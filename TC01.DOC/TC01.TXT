     Т  У  Р  Б  О    С  И
     Р У К О В О Д С Т В О   П О Л Ь З О В А Т Е Л Я.............19
     --------------------------------------------------------------
     В В Е Д Е Н И Е.............................................20
     Пакет поставки Турбо Си.....................................21
     Что нового в Турбо Си 2.0 ?.................................23
     Технические требования......................................25
     Реализация Турбо Си.........................................26
     Том I: Руководство пользователя.............................26
     Том 2: Справочное руководство...............................29
     Рекомендуемая литература....................................32
     И с п о л ь з у е м ы е   ш р и ф т ы.......................33
     Авторские права фирмы Borland...............................34
     Как заключить контракт с фирмой Borland.....................36
     Г Л А В А  1................................................38
     ПЕРЕД ТЕМ КАК НАЧАТЬ........................................38
     В этой главе ...............................................40
     README файл.................................................41
     Установка Турбо Си на вашей системе.........................42
     Если вы устанавливаете Турбо Си на систему с гибкими
      дисками....................................................42
     Запуск программы INSTALL....................................43

     Переброска Турбо Си на портативную систему..................44
     MicroCalc...................................................45
     Что дальше?.................................................45
     Программистам, изучающим Си.................................47
     Программистам, имеющим опыт работы с Си.....................47
     Программистам, работающим с Турбо Паскалем..................48
     Программистам, работающим с Турбо Прологом..................49
     Г Л А В А  2................................................50
     НАЧАЛО РАБОТЫ...............................................50
     В этой главе ...............................................51
     HELLO.C: Компиляция и запуск на выполнение простой
      пpогpаммы..................................................51
     Шаг 1 : загрузка ТС.........................................52
     Шаг 2 : выбор рабочего каталога.............................53
     Шаг 3 : установка паpаметpов pабочего окpужения.............54
     Шаг 4: Загpузка исходного файла в pедактоp..................56
     Шаг 5: Создание выполняемого файла..........................59
     Шаг 6: Запуск пpогpаммы на выполнение.......................60
     Что вы совеpшили?...........................................62
     Pедактиpование вашей пpогpаммы..............................64
     Если вы допустили ошибку....................................67
     Вывод на пpинтеp............................................67

                         - 3,4 -

     Написание вашей втоpой Си-пpогpаммы.........................69
     Запись на диск..............................................71
     Запуск SUM.C на исполнение..................................71
     Г Л А В А   3
     КОМПИЛЯЦИЯ И ЗАПУСК ВАШИХ ПРОГРАММ..........................73
     В этой главе................................................75
     Создание файлов в ТС........................................77
     Отладка вашей программы.....................................78
     Обнаружение синтаксических ошибок...........................78
     Окно сообщений..............................................80
     Исправление синтаксических ошибок...........................82
     Обнаружение ошибок времени выполнения
     интегрированным отладчиком..................................85
     Использование нескольких исходных файлов....................86
     Создание программы из нескольких исходных файлов............90
     Еще раз об отслеживании ошибок..............................91
     Остановка Make..............................................93
     Синтаксические ошибки в нескольких исходных файлах..........95
     Сохранение и очистка сообщений..............................98
     Более мощные средства построения проекта....................100
     Явные зависимости...........................................102
     Автоматическая проверка зависимости.........................104

     Какие у Make дополнительные возможности?....................105
     Внешние объектные и библиотечные файлы......................105
     Компиляция и компоновка из командной строки.................109
     Командная строка ТСС........................................110
     Опции компилятора и компоновщика в командной строке.........110
     Имена файлов в командной строке.............................111
     Выполняемый файл............................................112
     Некоторые примеры командных строк...........................112
     Файл TURBOC.CFG.............................................115
     TCCONFIG -  утилита  для  пpеобpазования  файлов
     конфигуpации................................................119
     Утилита МАКЕ................................................121
     BUILTINS.MAK................................................123
     Запуск программ Турбо Си из командной строки DOS............123
     Теперь все вместе: вперед с Турбо Си........................124
     ГЛАВА 4
     ОТЛАДКА ПРОГРАММ............................................125
     В этой главе ...............................................126
     Как работает интегрированный отладчик.......................127
     Установка и использование точки останова....................140
     Использование Ctrl-Break....................................143
     Пошаговое выполнение "через функции"........................145

                         - 5,6 -

     Вычисление выражений........................................147
     Функции nextword и wordlen..................................150
     Остановимся и подумаем......................................152
     Что же делать?..............................................154
     Содержимое окна вычислений, установленное по умолчанию......156
     Изменение значения оцениваемого выражения...................158
     Спецификация имен переменных................................161
     Спецификаторы формата.......................................163
     Упражнение 2: поиск ошибки в wordlen........................175
     Устранение ошибки...........................................179
     Что вы достигли.............................................179
     Немного о контрольных точках................................181
     Упражнение 3: возвращение к программе.......................185
     Редактирование и уничтожение выражений......................188
     Расширение и переключение окон..............................190
     Прокрутка выражений в окне Watch............................192
     Упражнение 4: отладка цикла печати..........................192
     Упражнение 5: работа с большими программами.................196
     Поиск определенной функции..................................196
     Стек вызова.................................................197
     Возврат в позицию выполнения................................198
     О многофайловых исходных текстах............................200

     Обзор команд отладчика и зарезервированных клавиш...........201
     Советы для эффективного тестирования программ...............208
     Развитие стандартного подхода...............................208
     Тщательно проверяйте изменения..............................212
     Как избежать некоторых трудностей...........................213
     Отладка снизу вверх.........................................215
     Исправление подобных ошибок.................................216
     Отладка встроенного кода ассемблера.........................217
     ГЛАВА  5
     ИНТЕГРИРОВАННАЯ СРЕДА ТУРБО СИ..............................219
     В этой главе................................................219
     Что Вы должны прочитать.....................................222
     Как получить помощь.........................................223
     ЧАСТЬ 1: ИСПОЛЬЗОВАНИЕ ТУРБО СИ.............................225
     Переключатели в командной строке Турбо Си...................227
     Ваше пребывание в Турбо Си..................................231
     Клавиши быстрого вмешательства ("горячие" клавиши)..........234
     Структура меню..............................................241
     О наименованиях меню........................................243
     Основное меню...............................................244
     Строка быстрой подсказки....................................248
     Окно редактирования.........................................249

                         - 7,8 -

     Быстрое руководство по командам редактирования..............254
     Как работать с исходными файлами в окне редактора...........256
     Создание нового исходного файла.............................258
     Загрузка исходного файла....................................259
     Запись исходного файла......................................261
     Запись порождаемых файлов...................................261
     Окно сообщений..............................................263
     Окно наблюдений.............................................265
     Интегрированный отладчик....................................269
     Управление отладчиком.......................................270
     Дисплейный экран отладчика..................................272
     Меню команд отладки и "горячие" клавиши.....................273
     ЧАСТЬ 2. КОМАНДЫ МЕНЮ.......................................280
     File (меню работы с файлами)................................281
     Load (загрузка).............................................281
     Pick (выбор)................................................282
     New (новый).................................................283
     Save (сохранение)...........................................283
     Write to (запись в).........................................284
     Directory (каталог).........................................284
     Change Dir (сменить каталог)................................284
     OS Shell (доступ к DOS).....................................285

     Quit (выход)................................................285
     Edit (редактор).............................................286
     Run (меню выполнения).......................................286
     Run (выполнить).............................................287
     Program Reset (сброс программы).............................289
     Go to Cursor (выполнять до курсора).........................289
     Trace Into (трассировать внутрь)............................291
     Step Over (пошаговое выполнение)............................292
     Compile (меню компиляции)...................................295
     Compile to OBJ (компилировать в объектный файл).............295
     Make EXE File (создать выполняемый файл)....................296
     Link EXE (компоновать в .EXE-файл)..........................297
     Build All (перестроить).....................................298
     Primary C File (первичный .C-файл)..........................298
     Get Info (получить информацию)..............................299
     Project (меню проекта)......................................301
     Project Name (имя проекта)..................................301
     Break Make On (прервать создание)...........................301
     Auto Dependencies (автозависимости).........................302
     Clear Project (очистить проект).............................303
     Remove Messages (удалить сообщения).........................303
     Options (меню опций)........................................304

                         - 9,10 -

     Compiler (меню компилятора).................................305
     Model (меню модели памяти)..................................305
     Defines (макроопределения)..................................306
     Code Generation (меню генерации кода).......................307
     Calling Convention (соглашения по вызову)...................307
     Instuction Set (установка набора команд)....................308
     Floating Point (плавающая точка)............................308
     Default Char Type (тип символа, используемый по умолчанию)..309
     Alignment (выравнивание)....................................310
     Generated Underbars (генерация символа подчеркивания).......310
     Merge Dublicate String (слияние одинаковых строк)...........311
     Standart Stack Frame (стандартная запись активации).........311
     Test Stack Overflow (проверка переполнения стека)...........312
     Line Numbers (нумерация строк)..............................313
     OBJ Debug Information (тип отладочной информации)...........314
     Optimization (меню оптимизации).............................314
     Optimize For (оптимизировать по...).........................314
     User Register Variables (использование регистровых
      переменных)................................................315
     Register Optimization (регистровая оптимизация).............316
     Jump Optimization (оптимизация по переходам)................316
     Source (меню работы с исходным текстом).....................318

     Identifier Length (длина идентификатора)....................318
     Nested Comments (вложенные комментарии).....................318
     ANSI Keywords Only (ключевые слова только согласно ANSI)....319
     Errors (меню ошибок)........................................320
     Errors: Stop After (ошибки: остановиться после ...).........320
     Warnings: Stop After (предупреждения: остановиться
      после...)..................................................320
     Display Warnings (вывод предупреждений на экран)............321
     Names (имена)...............................................322
     Linker (меню компоновщика)..................................323
     Map File (файл карты).......................................323
     Initialize Segments (инициализация сегментов)...............323
     Default Libraries (библиотеки по умолчанию).................324
     Graphics Libraries (графические библиотеки).................325
     Warn Dublicate Symbols (предупреждение о дублирующихся
     идентификаторах)............................................325
     Stack Warning (стековое предупреждение).....................326
     Case-sensitive Link (компоновка с учетом регистра)..........326
     Environment (среда).........................................327
     Message Tracking (отслеживать сообщения)....................327
     Keep messages (сохранить сообщения).........................328
     Config Auto Save (автоматическое сохранение конфигурации)...328

                         - 11,12 -

     Edit Auto Save (автоматическая запись редактируемого
      файла).....................................................329
     Backup Files (резервирование файлов)........................329
     Tab Size (размер табуляции).................................330
     Zoomed windows (увеличенные окна)...........................331
     Screen Size (размер экрана).................................331
     Directories (каталоги)......................................332
     Include Directories (каталоги включаемых файлов)............332
     Library Directories (каталоги библиотечных файлов)..........333
     Output Directory (выходной каталог).........................334
     Turbo С Directory (каталог Турбо Си)........................334
     Pick File Name (имя файла выбора)...........................335
     Current Pick File (текущий файл выбора).....................336
     Arguments (аргументы).......................................337
     Save Options (сохранить опции)..............................337
     Retrieve Options (восстановить опции).......................337
     Debug (меню отладчика)......................................338
     Evaluate (Оценка)...........................................340
     Поиск функции (Find Function)...............................348
     Стек вызова (Call stack)....................................348
     Отладка исходных текстов (Source Debugging).................350
     Свопинг экрана (Display Swapping)...........................351

     Регенерация дисплея (Refresh Display).......................353
     Меню прерываний/слежения (Break/Watch Menu).................353
       ) в левой колонке.........................................355
     Команда "Add Watch".........................................357
     Стирание контрольных выражений (Delete Watch)...............357
       ) с левой стороны.........................................358
     Редактирование контрольных выражений (Edit Watch)...........358
     Стирание всех контрольных выражений (Remove all Watches)....359
     Флаг точки прерывания (Toggle Breakpoint)...................359
     Убирание всех точек прерывания (Clear All Breakpoint).......362
     Смотри следующую точку прерывания (View next Breakpoint)....362
     Часть III. Дополнительные сведения о конфигурационных
     файлах и Pick файлах (выборки)..............................363
     Что представляет собой конфигурационный файл?...............363
     Конфигурационные файлы Турбо Си.............................364
     TCCONFIG.TC.................................................365
     Другие конфигурационные файлы ТС............................365
     Что хранится в конфигурационных файлах ТС...................366
     Создание конфигурационного файла ТС.........................367
     Изменение конфигурационных файлов во время работы...........368
     Где TC.EXE ищет TCCONFIG.TC.................................369
     TCINST в сравнении с конфигурационным файлом:

                         - 13,14 -

     кто управляет?..............................................370
     Что делает команда Options/Environment/Config Auto Save?....371
     Что представляют собой списки и файлы Pick (выборки)........373
     Список Pick (выборки).......................................373
     Файл Pick...................................................375
     Когда и каким образом вы получаете файл Pick?...............376
     Где Турбо Си сохраняет файлы Pick?..........................378
     Часть IV. Дополнительные возможности и команды
     Дополнительные сведения о табуляции.........................379
     Автоматическое смещение, смещение влево.....................381
     и оптимальное заполнение....................................381
     Определение парности (Match Pair)...........................384
     Некоторая информация об определении парности................386
     Дирекционное и недирекционное сравнение.....................387
     Вложенные разграничители....................................390
     Это может быть проиллюстрировано на некоторых примерах......391
     Ведение поиска разграничителей комментариев.................392
     Назначение редактирующих ключей.............................396
     ГЛАВА 6
     ПРОГРАММИРОВАНИЕ НА ТУРБО СИ................................400
     В этой главе................................................400
     Семь основных элементов программирования....................402

     Вывод.......................................................405
     Функция printf..............................................405
     Строка формата..............................................405
     Другие функции вывода: puts и putchar.......................408
     Типы данных.................................................411
     Числа с плавающей точкой....................................411
     Три типа целых..............................................414
     Беззнаковые.................................................414
     Определение строки..........................................415
     Использование символьного массива...........................415
     Использование указателя на символ...........................417
     Идентификаторы..............................................419
     Операции....................................................422
     Операция присваивания.......................................422
     Одноместные и двуместные операции...........................423
     Операции приращения (++) и уменьшения (--)..................423
     Побитовые операции..........................................425
     Комбинированные операции....................................427
     Адресные операции...........................................429
     Ввод........................................................431
     Функция scanf...............................................431
     Белое поле..................................................432

                         - 15,16 -

     Передача адреса функции scanf...............................433
     Использование gets и getch для ввода........................434
     Условные операторы..........................................437
     Операции сравнения..........................................437
     Логические операции.........................................440
     Дополнительные сведения о выражениях........................441
     Операторы присваивания......................................442
     Оператор запятая............................................443
     Оператор if.................................................444
     Циклические конструкции в программах........................448
     Цикл while..................................................448
     Цикл for....................................................452
     Цикл do...while.............................................457
     Функции.....................................................460
     Анализ программы............................................463
     Функция get_parms...........................................465
     Функция get_ratio...........................................466
     Функция put_ratio...........................................467
     Глобальные описания.........................................468
     Описание функций............................................468
     Определение функций.........................................471
     Комментарии.................................................474

     Резюме......................................................475
     Г Л А В А  7
     О НЕКОТОРЫХ ОСОБЕННОСТЯХ ПРОГРАММИРОВАНИЯ НА СИ.............476
     В этой главе................................................476
     Обзор структур данных.......................................478
     Указатели...................................................478
     Динамическое распределение..................................485
     Указатели и функции.........................................489
     Адресная арифметика.........................................492
     Массивы.....................................................496
     Массивы и указатели.........................................498
     Массивы и строки............................................500
     Многомерные массивы.........................................500
     Массивы и функции...........................................503
     Структуры...................................................508
     Структуры и указатели.......................................511
     Оператор switch (переключатель).............................513
     Команды передачи управления.................................520
     Оператор return.............................................521
     Оператор break..............................................524
     Оператор continue...........................................526
     Оператор goto...............................................528

                         - 17,18 -

     Условный оператор (?:)......................................528
     Потоки и поток ввода - вывода...............................531
     Что такое потоки?...........................................531
     Текстовые и двоичные потоки.................................532
     Буферизация потоков.........................................534
     Предопределенные потоки.....................................536
     Программирование на Си: классический и современный стили....538
     Использование прототипов функций
     и полных определений функций................................539
     Использование ключевого слова enum..........................541
     Использование директивы typedef.............................542
     Описание функции void.......................................544
     Используемые расширения.....................................545
     Строковые литералы..........................................546
     Шестнадцатиричная символьная константа......................547
     Типы со знаком..............................................548
     Ловушки в программировании на Си............................549
     Маршрут MS DOS в строке Си..................................549
     Неправильное употребление указателей........................550
     Использование неинициализированных указателей...............551
     Строки......................................................553
     Разница между присваиванием (=) и равенством (==)...........558


     Пропуск break в операторе switch............................560
     Индексы массивов............................................561
     Ошибки при передаче по адресу...............................563
     В добрый путь...............................................567


















                         - 19,20 -








                            Т  У  Р  Б  О    С  И


               Р У К О В О Д С Т В О   П О Л Ь З О В А Т Е Л Я

                                 Версия 2.0




                               Москва, 1989 г.



     -----------------------------------------------------------------

     В В Е Д Е Н И Е
     -----------------------------------------------------------------

          Турбо Си предназначен:  для Си программистов, желающих рабо-
     тать с быстрым и  эффективным  компилятором;  для  Турбо  Паскаль
     программистов, желающих  изучить  Си со всеми возможностями "Тур-
     бо"; а также для любого,  начинающего изучать Си и желающего  на-
     чать программирование   вместе с быстрым и легким в использовании
     инструментом.

          Язык Си - это структурированный,  модульный,  компилируемый,
     универсальный язык, традиционно используемый для системного прог-
     раммирования. Это переносимый язык,  т.е.  прикладные  программы,
     написанные на нем, могут быть легко перенесены с одной системы на
     другую. Вам можно использовать Си практически  для  любых  задач.
     Однако, если  обычные компиляторы Си "плетутся" через компиляцию,
     то Турбо Си "пролетает" ее,  оставляя больше времени для тестиро-
     вания и совершенствования ваших программ.





                         - 21,22 -

               Пакет поставки Турбо Си
     -----------------------------------------------------------------

          В пакет  поставки  Турбо  Си включены дистрибутивные диски и
     два тома документации:  "Турбо Си. Руководство пользователя" (эта
     книга) и "Турбо Си. Справочное руководство". Дистрибутивные диски
     содержат все программы,  файлы и библиотеки, необходимые для соз-
     дания, компиляции,  компоновки и запуска программ Турбо Си; кроме
     того, на них находятся примеры  программ,   несколько  автономных
     утилит, контекстно-зависимый файл подсказок, встроенный отладчик,
     а также дополнительная документация по вопросам,  не освещенным в
     данных руководствах.

          Руководство пользователя  выполнено в виде справочника-путе-
     водителя для начинающего,  но может быть полезно и  профессионалу
     для освежения знаний. Справочное руководство - это, прежде всего,
     подробное описание с обьяснением обширной библиотеки функций Тур-
     бо Си.  Кроме того, в нем содержится информация о редакторе Турбо
     Си, сообщениях  об ошибках,  сервисных  программах  (СРР,   МАКЕ,
     TLINK, TLIB,  GREP, BGIOBJ и OBJXREF), параметрах командной стро-
     ки, синтаксисе  Турбо Си и указаниях по установке. Если вы не яв-
     ляетесь профессиональным   программистом,  то вам,  скорее всего,


     лучше начать с Руководства пользователя,  а не Справочного  руко-
     водства.




















                         - 23,24 -

               Что нового в Турбо Си 2.0 ?
     -----------------------------------------------------------------

          Турбо Си 2.0 включает множество новых хороших  возможностей:

          # Интегрированный отладчик:  с пошаговым и трассируемым про-
     ходом инструкций,  заданием точек останова, просмотром и вычисле-
     нием выражений.

          # Ускоренный компилятор (на 20-30%) и компоновщик.

          # Поддержка расширенной памяти  EMS  для  буфера  редактора:
     позволяющая использовать 64 К и более памяти для компиляции и за-
     пуска.

          # Ускоренное распределение памяти и работа строчных функций.

          # Ускоренная эмуляция операций с плавающей точкой.

          # Новые функции signal и raise.

          # _emit_,  разрешающая вставлять машинные коды в вашу  прог-

     рамму во время компиляции.

          # Расширенная графическая библиотека BGI,  вместе с множест-
     вом новых функций, включая инсталируемые драйверы и шрифты.

          # Поддержка в командной строке символов-шаблонов (* и ?).

          # Для  крохотной  модели  памяти компоновщик может создавать
     .COM файлы.

          # Поддержка нового автономного отладчика фирмы Borland.

          # Автонастраиваемое управление для утилиты MAKE.

          # Поддержка констант и переменных типа long double  (двойной
     длины).

          # Новые возможности редактора,  включая блочный отступ и оп-
     тимальное заполнение.




                         - 25,26 -

               Технические требования
     -----------------------------------------------------------------

          Турбо Си  работает  на  всех  компьютерах  семейства IBM PC,
     включая ХТ,  АТ и PS/2, а также на всех действительно совместимых
     с IBM PC.  Он требует операционную систему DOS версии 2.0 и выше,
     а также не  менее  448К  оперативной  памяти  (RAM);  запускается
     только на мониторах,  строка которых содержит 80 символов.  Мини-
     мально необходимым является один дисковод для гибких дисков, хотя
     мы рекомендуем  использовать два таких дисковода или же один вин-
     честер с одним дисководом для гибких дисков.

          В поставку включены процедуры работы с плавающей точкой, ко-
     торые позволяют  использовать  математический  сопроцессор 80x87.
     Имеется возможность эмуляции 80x87 при его отсутствии.  Сопроцес-
     сор 80x87 позволит вам значительно увеличить быстродействие прог-
     рамм, но его наличие не является обязательным.






               Реализация Турбо Си
     -----------------------------------------------------------------

          Турбо Си поддерживает проект стандарта языка Си,  предложен-
     ный Американским   национальным  институтом стандартов (ANSI),  а
     также полностью определения Кернигана и Ритчи.  Кроме этого Турбо
     Си имеет  некоторые необязательные расширения для смешивания язы-
     ков, смешенно-модульного программирования, разрешающие полнее ис-
     пользовать возможности IBM PC.




               Том I: Руководство пользователя
     -----------------------------------------------------------------

          В Руководстве пользователя (этот том) дается введение в Тур-
     бо Си,  демонстрируется как создавать и запускать  программы,   а
     также дается  основная и вспомогательная информация о компиляции,
     компоновке, отладке и создании проектов.  Ниже приведено  краткое
     содержание глав Руководства пользователя:


                         - 27,28 -

          Глава 1:  Перед началом. Сообщает как установить Турбо Си на
     вашей системе. Кроме того, дает советы по использованию оставшей-
     ся части Руководства.

          Глава 2:  Начало работы.  Обучает  вас основам использования
     интегрированной среды Турбо Си (TC): загрузке, компиляции, запус-
     ку, редактированию и записи простых программ Турбо Си.

          Глава 3:  Компиляция, отладка и запуск программ. Показывает,
     как использовать команду Run и как  "выстраивать" (перестраивать)
     файлы, из которых состоит программа.

          Глава 4:  Отладка ваших программ. Знакомит с интегрированным
     отладчиком Турбо Си и демонстрирует,   "путешествуя"  по  простой
     программе со встроенными "жучками",  различные возможности отлад-
     чика.

          Глава 5:  Интегрированное окружение Турбо Си для  разработки
     программ. В этой главе объясняется работа с текстовым редактором,
     интегрированным отладчиком и системным меню Турбо Си, а также об-
     суждаются pick файлы и файлы конфигурации.


          Глава 6:  Программирование в Турбо Си. Знакомит с некоторыми
     основными шагами создания и запуска программ Турбо Си на  примере
     последовательности коротких программ возрастающей сложности.

          Глава 7:  О некоторых особенностях программирования  на  Си.
     Обзор дополнительных элементов языка Си,  включая массивы, указа-
     тели, структуры и операторы.

          Глава 8:   Видеофункции Турбо Си.  Вводное сжатое обсуждение
     видеорежимов и видеоокон,  с последующим описанием программирова-
     ния в текстовом и графическом режимах.

          Глава 9:  Замечания для программистов,  работающих на  Турбо
     Паскале. На  примерах конкретных программ сравниваются Турбо Си и
     Турбо Паскаль. Описаны наиболее значительные различия двух языков
     и приведены советы по избежанию распространенных ошибок.

          Глава 10: Интерфейс между Турбо Си и Турбо Прологом. Показа-
     но, как  связывать между собой модули,  написанные на Турбо Си, с
     программами, написанными на Турбо Прологе.   Приведено  несколько
     примеров, поясняющих этот процесс.


                         - 29,30 -

          Глава 11: Руководство по языку Турбо Си. Перечислены все ас-
     пекты и возможности данной реализации языка Си,  отличающиеся  от
     определения, данного Керниганом и Ритчи, а также подробно описаны
     расширения языка, не вошедшие в проект стандарта ANSI.

          Глава 12: Тонкости программирования на Турбо Си. Дается под-
     робная информация о программе начальной загрузки, организации па-
     мяти в различных моделях памяти,  арифметике указателей,  взаимо-
     действии с  ассемблером и использовании чисел с плавающей точкой.




               Том 2: Справочное руководство
     -----------------------------------------------------------------

          Справочное руководство предназначено для опытных программис-
     тов; в нем описаны сведения,  касающиеся  конкретного  исполнения
     языка и рабочего окружения. Также, в алфавитном порядке, приведе-
     но описание всех функций Турбо Си.  Ниже дается краткое  описание
     содержания глав и приложений Справочного руководства:


          Глава 1: Использование библиотечных функций Турбо Си. Приво-
     дится список #include файлов (*.H) Турбо Си и каждой из их библи-
     отечных программ по категориям. Обсуждается функция main и ее ар-
     гументы. Заканчивается глава описанием всех глобальных переменных
     Турбо Си.

          Глава 2: Библиотека Турбо Си. Описание всех библиотечных фу-
     нкций Турбо Си в алфавитном порядке.  Для каждой функции  указана
     следующая информация:  синтаксис, включаемые файлы, относящиеся к
     ней функции,  краткое описание действия,  возвращаемые значения и
     мобильность данной  функции.   Кроме этого даются ссылки на соот-
     ветствующие функции и примеры использования функций.

          Приложение A:   Интерактивный  редактор Турбо Си.  Приведено
     подробное описание команд редактора,  для тех, кому нехватило ин-
     формации в Главе 5 Руководства пользователя.

          Приложение  B:  Сообщения  об  ошибках транслятора. Приведен
     список сообщений с объяснением возможных причин появления каждого
     сообщения.

          Приложение C:  Опции командной строки. Приведен список опций

                         - 31,32 -

     компилятора, используемых с транслятором ТСС.

          Приложение D:  Служебные программы Турбо  Си.   Описаны  три
     программы, включенные    в пакет поставки Турбо Си:  препроцессор
     СРР; МАКЕ  -  построитель  программ;  компоновщик  Турбо - TLINK;
     TLIB - библиотекарь Турбо; GREP - утилита поиска в файлах; BGIOBJ
     - утилита для подготовки графических драйверов и шрифтов, а также
     объектный модуль перекрестных ссылок OBJXREF.

          Приложение E:  Сводка синтаксиса языка. Использует модифици-
     рованную форму Бэкуса-Наура для определения синтаксиса всех конс-
     трукций Турбо Си.

          Приложение F:  Настройка Турбо Си.  Описание программы уста-
     новки TCINST, позволяющей настроить клавиатуру, изменить значения
     по умолчанию, изменить цвет экрана и т.д.

          Приложение G:  MicroCalc объясняет как откомпилировать,  за-
     пустить и  использовать  MicroCalc  (простой табличный процессор,
     поставляемый на дистрибутивных дискетах Турбо Си).



               Рекомендуемая литература
     -----------------------------------------------------------------

          Указанные  ниже  книги  будут  полезным  дополнением к вашим
     руководствам по Турбо Си:

          - The  C Programming Lanquage by Brian W.Kernigan and Dennis
     M.Ritchie (New Jersey: Prentice-Hall. 1978) Переведена на русский
     язык -  Б.Керниган,  Д.Ритчи,  А.Фьюэр "Язык программирования Си.
     Задачи по языку Си". М.: Финансы и статистика, 1985 г. - 279 с.

          - Подкомитет  X3J11 по стандартизации языка Си Американского
     национального института по стандартизации (ANSI) в настоящее вре-
     мя готовит официальный стандарт языка,  и Турбо Си полностью под-
     держивает этот стандарт ANSI на язык Си.

          Если вы только начинаете изучать Си,  то мы рекомендуем  вам
     проработать на  нем упражнения,  приведенные в Кернигане и Ритчи.
     Если же у вас есть опыт работы с Си,  то  изучение  Турбо  Си  не
     представит каких-либо трудностей.



                         - 33,34 -

               И с п о л ь з у е м ы е   ш р и ф т ы
     -----------------------------------------------------------------

          Все используемые  в данном руководстве шрифты получены с по-
     мощью продукта Sprint - профессионального  текстового  процессора
     фирмы Борланд  и лазерного принтера PostScript.  Различные шрифты
     используются следующим образом:

          (Примечание. Шрифты в переводе не воссоздаются.)

        - Этим шрифтом печатается текст в том виде,  как он появляется
          на экране или в программе,  а также тот текст, который печа-
          таете вы /например, опции командной строки/.

        - В квадратные скобки в тексте или в команде  DOS  заключаются
          необязательные входные данные или данные, зависящие от вашей
          системы.

        - В острые скобки в тексте или в команде DOS заключаются  нео-
          бязательные входные   данные или данные,  зависящие от вашей
          системы.


          При описании функций в острые скобки заключаются имена вклю-
          чаемых файлов.

        - Этим жирным шрифтом печатаются имена функций Турбо Си и име-
          на структур в тексте (но не в программных  примерах).   Этот
          шрифт также используется в тексте,  но не в программных при-
          мерах, для ключевых слов Турбо Си,  таких как char,  switch,
          near и cdecl.

        - Курсивом  Italic в тексте выделяются имена переменных (иден-
          тификаторов), а  также слова,  на которые  следует  обратить
          внимание, особенно новые термины.

        - Этот специальный вид шрифта используется для указания клави-
          ши на клавиатуре дисплея. Он часто используется для указания
          клавиши, на  которую необходимо нажать,  например,  "Нажмите
          Esc для отмены меню".




               Авторские права фирмы Borland.

                         - 35,36 -

     -----------------------------------------------------------------

          Этот пакет программного обеспечения защищен Законом на права
     копирования США и Международным договором о правах на программное
     обеспечение. Поэтому вы должны использовать это пакет как книгу с
     с одним лишь исключением:  компания Borland разрешает вам сделать
     архивную копию пакета Турбо Си с той целью, чтобы вы смогли восс-
     тановить утерянное или испорченное программное обеспечение и сох-
     ранить ваши денежные вложения.

          Вы спросите,  а как это "как книгу"? Borland позволяет, нап-
     ример, использовать это программное обеспечение каким угодно чис-
     лом людей,  и оно может быть свободно перенесено с одного  компь-
     ютера на   другой.   Но  вместе  с  тем,  как одна книга не может
     читаться двумя различными людьми в двух различных местах в одно и
     то же  время,  программное обеспечение не может быть использовано
     двумя различными людьми в двух различных местах одновременно (ес-
     ли, конечно, не нарушаются права фирмы Borland незаконным копиро-
     ванием).




               Как заключить контракт с фирмой Borland.
     -----------------------------------------------------------------

          Лучшим путем установления контактов с фирмой Borland являет-
     ся подключение   к  Borland`s Forum с помощью системы CompuServe.
     Для этого достаточно указать  режим  "GO  BOR"  в  головном  меню
     CompuServe, а затем выбрать пункт "Borland  Programming  Forum  B
     (Turbo Prolog  & Turbo C)" из главного меню Borland.  После этого
     вы можете задать вопрос или послать сообщение,  поддерживая штат-
     ный процесс.

          Кроме  того,  при  желании  вы  можете  написать  письмо   и
     направить его по адресу:

                      Technical Support Department
                         Borland International
                         1800 Green Hills Road
                            P.O.Box 660001
                           Scotts Valley, CA
                           95066-0001, USA

          Вы также можете позвонить нам в отдел технического сопровож-

                         - 37,38 -


     дения 408-438-5300. Если это не вызовет у вас каких-либо труднос-
     тей, то, пожалуйста, подготовьте перед этим следующую информацию:

          - название программного продукта и номер его версии;
          - тип и модель компьютера;
          - тип операционной системы и номер ее версии.
















                           Г Л А В А  1
                           ------------


                       ПЕРЕД ТЕМ КАК НАЧАТЬ
     ----------------------------------------------------------------

          Ваш пакет  поставки  Турбо  Си включает две различные версии
     компилятора языка Си: интегрированной среды и отдельного автоном-
     ного компилятора,  использующего командную строку.  При установке
     Турбо Си вам необходимо скопировать файлы с дистрибутивных дисков
     на рабочие гибкие дискеты или на жесткий диск.  Никакой защиты от
     копирования не  предусмотрено,   а имеющаяся программа инсталяции
     обеспечивает простую настройку Турбо Си.  Дистрибутивные  дискеты
     отформатированы для двусторонних дисководов с двойной плотностью,
     они могут быть прочитаны на любом компьютере IBM PC или  на  сов-
     местимых с   ним.   Для справок мы включили список дистрибутивных
     файлов в файл README, находящийся на инсталяционном диске.

          Мы предполагаем,  что вам знакомы команды DOS. Например, вам
     понадобится команда  DISKCOPY  для создания копии ваших дистрибу-
     тивных дисков.  Если вы еще не знаете как пользоваться  командами

                         - 39,40 -


     DOS, то обратитесь к справочному руководству DOS перед установкой
     Турбо Си на своей системе.

          После получения пакета, вам необходимо полностью скопировать
     дистрибутивные диски и положить их на хранение.  Не вздумайте за-
     пускать Турбо Си с дистрибутивных дисков,  т.к.  это единственная
     эталонная копия, имеющаяся в вашем распоряжении, она поможет вам,
     если что-либо случится с рабочими файлами.

          Если вы  не  знакомы  с  лицензионными  ограничениями  фирмы
     Borland, то  вернитесь к Введению (есть также на передней обложке
     этой книги) и вашей регистрационной карте на продукт.











               В этой главе ...
     -----------------------------------------------------------------

          Эта глава начинается с инструкций необходимых для знакомства
     с содержимым файла README и инсталяции Турбо Си на вашей системе.
     В конце главы приводятся рекомендации, которые помогут ориентиро-
     ваться в дальнейших главах руководства,  основываясь на имеющемся
     опыте программирования.














                         - 41,42 -


               README файл
     -----------------------------------------------------------------

          Весьма важно,  чтобы  вы нашли время для знакомства с файлом
     README на инсталяционном диске,  прежде чем вы что-либо выполните
     с Турбо Си.  Этот файл включает последнюю информацию, возможно не
     попавшую в Руководства. В нем также содержится перечень всех фай-
     лов дистрибутивных дискет с коротким описанием их предназначения.

          Для доступа  к файлу README,  вставьте инсталяционный диск в
     устройство A,  перейдите на это устройство,  набрав A:  и Ввод, а
     затем наберите  README и снова Ввод.  Для просмотра файла исполь-
     зуйте клавиши со стрелками Вверх и Вниз (Up и Down).  Для  выхода
     используйте Esc.








               Установка Турбо Си на вашей системе
     -----------------------------------------------------------------

          В пакет  поставки  Турбо  Си включены все файлы и программы,
     необходимые для запуска как интегрированной среды,  так и  версии
     командной строки,  а также модули загрузчиков  и  библиотеки  для
     шести моделей памяти и эмуляции сопроцессора 8087. Устанавливаете
     ли вы Турбо Си в первый раз или уже имели опыт установки предыду-
     щей версии (1.5),  все равно программа INSTALL сделает это легко.




         Если вы устанавливаете Турбо Си на систему с гибкими дисками
     -----------------------------------------------------------------

          Если у вашей системы один или два гибких дисковода без жест-
     кого диска, то вы должны приготовить три чистых отформатированных
     диска перед запуском INSTALL.

          Каждый раз, при запуске INSTALL, вы устанавливаете для Турбо
     Си одну модель памяти.  Если вы хотите установить более одной мо-

                         - 43,44 -

     дели, то вы должны иметь дополнительные дискеты, для каждой моде-
     ли памяти, что вы пожелали установить.



               Запуск программы INSTALL
     -----------------------------------------------------------------

          Программа INSTALL,   предназначенная для установки Турбо Си,
     выполняет процесс установки путем совместной "прогулки".  Все что
     вы должны делать - это выполнять экранные инструкции, появляющие-
     ся на каждом шаге. Пожалуйста читайте их полностью.

          Для запуска программы INSTALL:

          1. Вставьте дистрибутивный диск с меткой Installation Disk в
     дисковод A.

          2. Наберите A: и нажмите Ввод.

          3. Наберите INSTALL и нажмите Ввод.


          С этой  точки  следуйте  появляющимся  на экране инструкциям
     программы INSTALL.

          Как только INSTALL закончит работу,  вы можете начать  рабо-
     тать с Турбо Си.

          Запомните: Если  вам понадобится изменить опции в интегриро-
     ванной версии компилятора Турбо Си,  то  вы  можете  это  сделать
     просто, вызвав  TCINST.  За пояснениями обратитесь к Приложению F
     Справочного руководства Турбо Си.



               Переброска Турбо Си на портативную систему
     -----------------------------------------------------------------

          Если у вас есть портативный компьютер (с жидкокристалическим
     или плазменным дисплеем)  в дополнении к процессу,  изложенному в
     предыдущем разделе,  перед использованием Турбо Си вам необходимо
     установить параметры для экрана.  Для  работы  с  интегрированной
     версией, лучше установить режим MODE BW80 с командной строки, пе-
     ред запуском Турбо Си.

                         - 45,46 -


          Вы можете также установить TC для работы с черно-белым экра-
     ном с помощью программы TCINST. Смотрите Приложение F Справочного
     руководства Турбо Си.  В этой программы вы должны  сделать  выбор
     "Black and White"  в меню Screen Modes (режимы экрана).



               MicroCalc
     -----------------------------------------------------------------

          Мы включили файл с исходным текстом программы обработки таб-
     лиц, называемый MicroCalc. Прежде чем приступить к его компиляции
     ознакомьтесь с Приложением G в Справочном руководстве Турбо Си.



               Что дальше?
     -----------------------------------------------------------------

          Теперь, после установки Турбо Си, вы готовы приступить к уг-
     лубленному изучению данного  руководства  и  собственно Турбо Си.


     Но, так как данное руководство написано для четырех различных ка-
     тегорий пользователей,  определенные его главы учитывают конкрет-
     ные нужды каждой категории.  Перед тем,  как включиться в работу,
     настоятельно рекомендуем прочесть следующий материал.


















                         - 47,48 -

               Программистам, изучающим Си
     -----------------------------------------------------------------

          Если вы только приступили к изучению Си, то вам следует про-
     честь 2 и 3 главы, которые знакомят с интегрированной средой Тур-
     бо Си,  демонстрируют загрузку,  компиляцию,  компоновку и запуск
     простой программы,  написанной на Турбо Си, в аналогии с редакти-
     рованием и записью ваших собственных разработок. Глава 4 познако-
     мит вас с интегрированным отладчиком Турбо Си.  Далее читайте 6 и
     7 главу. Обе написаны в стиле учебного пособия с подробным описа-
     нием процесса создания и компиляции программ Си. Если вы не очень
     хорошо представляете, как использовать интегрированную версию, то
     прочтите главу 5.  Глава 8 познакомит вас с графическими  возмож-
     ностями Турбо Си.




               Программистам, имеющим опыт работы с Си.
     -----------------------------------------------------------------

          Если у  вас  уже  есть опыт работы с Си,  то вам не составит

     труда перенести ваши программы в данное  окружение.  Вам  следует
     прочесть главу 11 "Руководство по языку Турбо Си", для обзора как
     Турбо Си совпадает с определениями Кернигана и Ритчи,  а также  с
     проектом стандарта  ANSI.  Когда вы будете готовы переносить свои
     Си программы на Турбо Си вам понадобится глава 3 "Компиляция, от-
     ладка и  запуск программ," глава 4 - о том как использовать интег-
     рированный отладчик,  а также глава 12 "Тонкости программирования
     на Турбо Си". Если вас заинтересуют возможности графики Турбо Си,
     то читайте главу 8.



               Программистам, работающим с Турбо Паскалем
     -----------------------------------------------------------------

          Глава 9,  "Замечания для программистов,  работающих на Турбо
     Паскале" написана специально для вас,  в ней  приведены  примеры,
     сравнивающие программы на Турбо Паскале с эквивалентными програм-
     мами,  написанными на Турбо Си.  Также в ней обсуждаются наиболее
     важные различия между двумя языками.

          Если вы  писали на Турбо Паскале,  то хорошо знакомы с семью

                         - 49,50 -


     основными элементами программирования. Для быстрого освоения Тур-
     бо Си вам нужно прочитать главы 5, 6 и 7. (Если же вы использова-
     ли другие управляющие меню продуктов  фирмы  Borland,  таких  как
     SideKick или Турбо Бейсик,  то вам необходима только глава 5.) Вы
     также можете просмотреть главу 3 о  компиляции  и  запуске  ваших
     программ Турбо  Си  и  главу 4 об интегрированном отладчике Турбо
     Си.




               Программистам, работающим с Турбо Прологом
     -----------------------------------------------------------------

          Если вы работали с Турбо Прологом и хотели бы связать модули
     с Турбо Си, то необходимо прочесть главу 10.






                          Г Л А В А  2
                          ------------

                          НАЧАЛО РАБОТЫ
     -----------------------------------------------------------------

          Вы уже имеете установленный в вашей системе Турбо Си и гото-
     вы к программированию. Но сначала вам необходимо узнать несколько
     основ, таких  как:  запуск Турбо Си, использование текстового ре-
     дактора для создания и модификации ваших программ,  компиляции  и
     запуска их на выполнение.

          Для создания ваших программ  вы  можете  использовать  любой
     текстовый редактор ASCII.  Затем используйте компилятор командной
     строки (ТСС версии Турбо Си) для компиляции и последующего запус-
     ка на выполнение программ из командной строки DOS.  Все же, такой
     путь может показаться вам неудобным, и вы можете использовать ин-
     тегрированную среду Турбо Си (TC версии Турбо Си),  предоставляю-
     щую вам редактор,  системное меню команд,  интегрированный отлад-
     чик,  средства для построения проектов, позволяющих компилировать
     и запускать программы непосредственно из среды Турбо Си.


                         - 51,52 -

               В этой главе ...
     -----------------------------------------------------------------

          Мы вас обучим нескольким основам, которые необходимы для ис-
     пользования  Турбо  Си, - загрузке интегрированной среды Турбо Си
     (TC),  загрузке программ Турбо Си,  а также компиляции и  запуску
     программ на исполнение.

          Далее мы покажем каким образом модифицировать программы, ис-
     пользуя редактор Турбо Си.

          В заключении мы покажем вам как создавать  совершенно  новые
     программы и сохранять их в файле перед компиляцией и запуском.



         HELLO.C: Компиляция и запуск на выполнение простой пpогpаммы
     -----------------------------------------------------------------

          Перед тем,  как  приступить  к  написанию  ваших собственных
     программ на Турбо Си, предлагаем вам использовать интегрированную
     среду Турбо Си с программой, которая уже существует.


          В каталоге,  в  котором  вы записали примеры программ,  есть
     файл с именем HELLO.C,  содержащий  исходный  код  очень  простой
     программы.  При работе с ней будет продемонстрировано шесть шагов
     по созданию и запуску простой Турбо Си программы.


          Шаг 1 : загрузка ТС
          -------------------

          Если для  инсталляции  Турбо  Си  вы пользовались программой
     INSTALL, тогда ТС уже должна находиться в основном каталоге Турбо
     Си.  Перейдите в этот каталог,  загрузите ТС,  набрав в командной
     строке операционной системы TC, и нажмите клавишу Ввод.

          Примечание. Если  вы  хотите создавать программы в каталоге,
     отличном от того, где содержится Турбо Си, вы должны сообщить DOS
     где находятся ТС программы :

          - определить каталог с Турбо Си, используя команду DOS PATH;

          - в  версиях  DOS  3.X вы можете ввести маршрут для каталога

                         - 53,54 -

     Турбо Си в командной строке. Например :\TURBOC\TC.


          Шаг 2 : выбор рабочего каталога
          -------------------------------

          Если ваш текущий каталог содержит HELLO.C, вы можете пропус-
     тить этот  шаг.  Выберите устройство и каталог,  которые содержат
     HELLO.C. Для этого выберите опцию FILE меню (нажмите F10, затем F
     или сразу Alt-F).  Выберите Change Dir (используйте клавиши пози-
     ционирования светового курсора,  а затем нажмите Ввод,  или сразу
     С).  Когда появится рамка нового каталога,  введите имя каталога,
     который содержит HELLO.C, а затем нажмите Ввод. Этот каталог ста-
     новится текущим.

          Примечание. При  появлении  рамки-каталога  показывается имя
     текущего каталога.  Это средство может быть использовано вами для
     определения каталога,  являющегося текущим в данный момент. Таким
     образом,  если вы хотите вернуться обратно без изменения текущего
     каталога, нажмите клавишу Esc.



          Шаг 3 : установка паpаметpов pабочего окpужения
          -----------------------------------------------

          Если вы  использовали пpогpамму INSTALL для установки пакета
     Туpбо Си в вашей системе,  то pабочее окpужение уже  должно  быть
     установлено. Во всяком случае,  вы можете обpатиться к этому pаз-
     делу для пpовеpки, пpавильно ли установлены паpаметpы сpеды.

          Для установки и записи  вашего  pабочего  окpужения  нажмите
     клавишу F10, а затем клавишу O (или нажмите Alt-O), после чего вы
     попадете из основного меню в меню  Options.   Для  входа  в  меню
     Directories выбеpите соответствующую ему опцию. Вам будут необхо-
     димы два пункта из этого меню:   Include  Directories  и  Library
     Directories.

          Выбеpите Include Directories, затем введите имена устpойства
     и каталогов,  котоpые содеpжат файлы Туpбо Си с  pасшиpением  .h,
     pазделяя имена каталогов точкой с запятой. Этими каталогами обыч-
     но являются:  C:\TURBOC\INCLUDE и C:\TURBOC\INCLUDE\SYS;  в  этом
     случае необходимо ввести:

          C:\TURBOC\INCLUDE;C:\TURBOC\INCLUDE\SYS

                         - 55,56 -


     а затем нажать клавишу Ввод.

          После этого   выбеpите   Library  Directories,  введите  имя
     устpойства и каталога,  котоpый содеpжит библиотечные файлы (этим
     каталогом может быть C:\TURBOC\LIB). Возможен перечень имен ката-
     логов, котоpые должны быть pазделены точкой с запятой.

          Пpимечание: В    этом    же    месте,     выбрав     команду
     Options/Directories/Output Directory, вы можете установить выход-
     ной  каталог,  в  который  будут  записываться  откомпилиpованные
     пpогpаммы. Если  вы опpеделите выходной каталог,  то все выходные
     файлы после компиляции и компоновки будут сохpанены в этом  ката-
     логе, а не в текущем, как ранее. В нашем пpимеpе установка выход-
     ного каталога не является необходимой.

          В наиболее пpостых случаях  этих  установок  достаточно  для
     создания пpогpамм, написанных на Си.

          Выбpанные паpаметpы конфигуpации вы можете сохpанить в файле
     конфигуpации, котоpый автоматически загpужается пpи  запуске  ТС.
     Для возвpата в меню Options нажмите клавишу Esc. Затем, для запи-

     си текущих паpаметpов в файл конфигуpации,  выбеpите  пункт  Save
     Options. Данный  файл (TCCONFIG.TC) будет записан в текущий ката-
     лог.

          Пpимечание: Пpи запуске, TC ищет файл TCCONFIG.TC и загpужа-
     ет его,  если он существует. Пpи желании вы можете указать дpугое
     имя файла конфигуpации,  набрав его и нажав клавишу  Ввод.  Таким
     обpазом,  pаботая с конкpетной пpогpаммой, полезно иметь по умол-
     чанию файл конфигуpации в том же  каталоге,  где  находится  сама
     пpогpамма, и запускать Туpбо Си из этого же каталога. Однако, ес-
     ли файл конфигуpации не найден в текущем каталоге, Туpбо Си пpос-
     матpивает  также  каталоге  TURBO.  Это позволяет иметь один файл
     конфигуpации общего назначения в каталоге TURBO, а остальные фай-
     лы конфигуpации с установками целевого назначения - в каталогах с
     исходными файлами.


          Шаг 4: Загpузка исходного файла в pедактоp
          ------------------------------------------

          Загpузите HELLO.C.   Для этого выбеpите команду Load из меню
     File или нажмите клавишу F3 (клавиша  быстpого  pеагиpования  для

                         - 57,58 -

     загpузки файла). Появится рамка, содеpжащая шаблон

          *.C.

          Введите Hello (pасшиpение .C указывать необязательно) и наж-
     мите Ввод.

          Пpимечание: Если вы не увеpены в названии файла, котоpый хо-
     тите загpузить, или хотите посмотpеть список всех исходных файлов
     в текущем каталоге, то просто нажмите клавишу Ввод, не вводя име-
     ни файла.  ТС покажет вам пеpечень всех исходных файлов в  данном
     каталоге.  Для  выбоpа  файлов  используйте  клавиши  пеpемещения
     куpсоpа, пеpедвигая рамку-куpсоp на имя необходимого файла. Затем
     нажмите Ввод.

          Файл HELLO.C отобpазится в окне pедактоpа.  Он выглядит сле-
     дующим обpазом :

          /* HELLO.C -- HELLO, world*/
          # include <stdio.h>
          main( )


          {
              printf ("Hello,world\n");
          }

          Пpимечание: существует  возможность  загpузки ТС,  исходного
     файла и файла конфигуpации из командной стpоки, что делает ненуж-
     ным выполнение  шагов 2,  3 и 4.  Интегpиpованная сpеда допускает
     два аpгумента в командной стpоке, котоpые означают следующее: имя
     исходного файла,  котоpый должен быть загpужен в pедактоp и опция
     /C  с непосpедственно следующим за ней именем файла конфигуpации,
     котоpый вы хотите загpузить вместе с исходным файлом.  Эти  аpгу-
     менты могут следовать в любой последовательности.  Таким обpазом,

          tc hello /cmyconfig

     поместит HELLO.C  в  pедактоp  и  загpузит  в  файл  конфигуpации
     MYCONFIG.TC  (заметьте,  что не должно быть пpобелов между опцией
     /C и именем файла, а также, что по умолчанию для исходного файла,
     котоpый будет загpужен в pедактоp,  пpинимается pасшиpение .C,  а
     для файла конфигуpации - .TC).



                         - 59,60 -

          Шаг 5: Создание выполняемого файла
          ----------------------------------

          Пpи создании пpогpаммы вы сначала компилиpуете исходный файл
     в объектный файл (файл в машинных кодах с pасшиpением .OBJ).  За-
     тем вы посылаете объектный файл  на  компоновку,   чтобы  он  был
     пpеобpазован в  выполняемый файл с pасшиpением .EXE.  Компоновщик
     копиpует в ваш объектный файл необходимые подпpогpаммы  из  стан-
     даpтных библиотечных файлов (вы должны сообщить Туpбо Си  где ис-
     кать эти библиотечные файлы).

          В этом пpостом случае - с единственной пpогpаммой, вы можете
     создавать  и запускать пpогpамму на выполнение без создания файла
     пpоекта (более подpобно о файлах-пpоектах смотpите в главе 3).

          Однако есть и дpугие пути.  Самый легкий путь  для  создания
     пpогpамм - это нажать клавишу F10,  затем "C", чтобы войти в меню
     Compile (или нажать Alt-C).  Затем выбpать пункт  Make  EXE  File
     (или нажать F9 - "горячая" клавиша для создания .EXE файла).  За-
     метьте,  что меню Compile сообщает вам имя объектного (.OBJ) фай-
     ла, котоpый будет откомпилиpован в файл .EXE.


          На экpане появится окно компиляции.  Если все пpойдет успеш-
     но, в окне компиляции появится мигающий тpанспаpант Press any key
     (нажмите любую клавишу).

          Пpимечание: В случае ошибки в вашей пpогpамме вы увидите со-
     общения об ошибках или пpедупpеждения в окне сообщений  в  нижней
     части экpана.  Если это случится,  убедитесь,  что ваша пpогpамма
     выглядит именно так,  как было описано выше, затем откомпилиpуйте
     ее снова.


          Шаг 6: Запуск пpогpаммы на выполнение
          -------------------------------------

          В данной точке вы уже должны иметь выполняемую пpогpамму.

          Для запуска пpогpаммы выбеpите пункт Run  из  меню  Run  или
     нажмите клавиши Ctrl-F9, котоpые являются клавишами быстpого вме-
     шательства для запуска пpогpаммы.

          Что случилось? Вы видели как мигнул экpан, и затем вы веpну-
     лись в  экpан  основного меню.  Для пpосмотpа на экpане сообщений

                         - 61,62 -


     пpогpаммы, выбеpите Run\User Screen или нажмите Alt-F5. Это вызо-
     вет появление экpана пользователя, на котоpый вы выводили сообще-
     ния.

          Пользовательский экpан должен содеpжать сообщения.

          Неllo, world

          После того,  как  вы пpовеpите сообщения пpогpаммы,  нажмите
     любую клавишу для возвpата в экpан ТС.












               Что вы совеpшили?
     -----------------------------------------------------------------

          Выйдите из  Туpбо  Си,  выбpав команду Quit из меню File или
     нажмите Alt-X.

          Посмотpите что вы  создали.  Находясь  в  DOS,  введите  dir
     hello.*  и нажмите клавишу Ввод.  Вы получите список файлов,  ко-
     тоpый выглядит подобно пpиведенному ниже:

          HELLO      C     104    5-11-88     2:57p
          HELLO    OBJ     459    5-11-88     3:01p
          HELLO    EXE    8884    5-11-88     3:01p

          Пеpвый файл  (HELLO.C)   является  исходным  текстом   вашей
     пpогpаммы. Вы можете вызвать его на экpан,  находясь в DOS, введя
     команду type hello.c.  Как вы можете заметить,  HELLO.C не  очень
     большой -  всего 104 байта.

          Втоpой файл  (HELLO.OBJ)  является объектным файлом.  Он со-
     деpжит двоичные машинные инстpукции (объектные коды),  полученные
     с помощью  компилятоpа Туpбо Си.  Если вы,  используя команду DOS

                         - 63,64 -


     TYPE, выведите данный файл на экpан,  то получите нечто  несуpаз-
     ное.

          Последний файл  (HELLO.EXE)   является  загpузочным модулем,
     сделанным компоновщиком Туpбо Си. Он содеpжит не только код файла
     HELLO.OBJ, но  и все необходимые подпpогpаммы (такие как printf),
     котоpые компоновщик поместил в него из библиотечного файла.   Для
     запуска любого  выполняемого  файла  из DOS вам необходимо ввести
     его имя без pасшиpения .EXE.

          Для запуска HELLO.EXE из DOS введите hello и нажмите клавишу
     Ввод.  На  экpане  появится  сообщение  Hello world и затем снова
     пpиглашение в DOS.









               Pедактиpование вашей пpогpаммы
     -----------------------------------------------------------------

          Тpадиционно, что  пеpвая  ваша пpогpамма,  написанная на Си,
     выводит сообщение Hello world  и  находится  в  книге  Kernighan,
     Ritchie  "The  C  Programming  Language"  ("Язык пpогpаммиpования
     Си").  Эту  маленькую  пpогpамму  HELLO.C  вы  сделаете  довольно
     быстpо.

          Тепеpь, когда  вы немного освоились с интегpиpованной сpедой
     Туpбо Си, попpобуйте пpогpаммиpовать сами. Вы можете начать с мо-
     дификации пpогpаммы HELLO.C. Чтобы сделать это, вы должны изучить
     использование pедактоpа ТС. Если вы еще не веpнулись в Туpбо Си и
     находитесь в DOS,  введите команду tc hello. Вы снова окажетесь в
     ТС, а ваша пpогpамма уже будет загpужена.

          Модифициpуйте вашу  пpогpамму,   что  позволит  вам  немного
     поpаботать с ней.

          Заметьте, что мигающий куpсоp находится в веpхнем левом углу
     экpана. Вы можете пеpемещать его по окну pедактиpования с помощью
     клавиш упpавления куpсоpом. Для ввода текста пеpедвиньте куpсоp в

                         - 65,66 -

     необходимое место и набеpите текст.   Вы  можете  удалить  стpоку
     текста, нажав Ctrl-Y, а также вставить стpоку, нажав Ctrl-N. Убе-
     дитесь, что вы pаботаете в pежиме Insert (слово Insert должно на-
     ходится в  стpоке  установок ввеpху окна pедактиpования; если оно
     отсутствует, нажмите клавишу Ins для его появления). (Для получе-
     ния полной инфоpмации об использовании pедактоpа ТС смотpите гла-
     ву 5.  данного pуководства,  а также  пpиложение  А  в  "Turbo  C
     Reference Guide".)

          Следуйте далее  и  отpедактиpуйте  вашу  пpогpамму следующим
     обpазом:

          #include <stdio.h>

          main( )
          {
           char name [150];

           printf ("what's your name?\n");
           scanf ("%S",name);
           printf ("Hello,%S\n",name);
          }


          Вы добавили  тpи стpоки в HELLO.C.  Пеpвая стpока (char name
     [150];) объявляет пеpеменную с именем name,  котоpая может состо-
     ять из 150 символов (букв, цифp, знаков пунктуации и т.д. Позиция
     150 показывает количество заpезеpвиpованных символов). Втоpая до-
     бавленная вами  стpока вызывает функцию printf для вывода сообще-
     ния "what's your name?".  Тpетья новая  стpока  вызывает  функцию
     scanf для чтения имени в пеpеменную name.

          Далее для запуска вашей пpогpаммы нажмите Ctrl-F9. Заметьте,
     что Туpбо Си узнал,  что вы  модифициpовали  исходный  текст,   и
     пеpекомпилиpовал пpогpамму пеpед ее выполнением.

          В то вpемя, как ваша пpогpамма будет выполняться, пpоизойдут
     две вещи:  появится пользовательский экpан с  сообщением  "what's
     your name?"  и куpсоp будет ожидать на следующей стpоке.  Введите
     ваше имя и нажмите клавишу Ввод. Нажмите Alt-F5. На пользователь-
     ском экpане будет выведено Hello,<ваше имя>. Заметьте, что счита-
     но только пеpвое слово вашего имени,  котоpое вы вводили; об этом
     вы  узнаете  в  главе  6.  А тепеpь нажмите любую клавишу,  чтобы
     веpнуться в экpан ТС.


                         - 67,68 -

               Если вы допустили ошибку
     -----------------------------------------------------------------

          Во вpемя  написания  пpогpамм вы можете допускать ошибки или
     получать пpедупреждения.  Error является ошибкой в вашей пpогpам-
     ме, котоpую пpедотвpащает компилятоp Туpбо Си от попадания в объ-
     ектный код. Warning - это сообщение, котоpое указывает на возмож-
     ность возникновения пpоблем. Ошибки и пpедупреждения появляются в
     окне сообщений ввеpху экpана ТС. Имеется много pазличных ошибок и
     пpедупреждений. Подpобно они pаскpыты в пpиложении B "Справочного
     руководства по Турбо Си".



               Вывод на пpинтеp
     -----------------------------------------------------------------

          Вы в недоумении,  каким обpазом  сообщения  вашей  пpогpаммы
     HELLO.EXE послать на пpинтеp взамен экpана.  Мы покажем вам,  как
     это сделать,  хотя вы  можете захотеть  вникнуть в детали,  каким
     обpазом это делается; сейчас вам этого для изучения вполне доста-
     точно.


          Загpузите HELLO.C в pедактоp и модифициpуйте,  как  показано
     ниже:

          #include <stdio.h>

          main( )
          {
           fprintf(stdprn,"Hello, world\n");
          }

          Убедитесь в том,  что ваш пpинтеp находится в состоянии  го-
     товности, затем откомпилиpуйте свою пpогpамму тем же обpазом, что
     и pаньше - нажатием Ctrl-F9.  На вашем пpинтеpе должно  появиться
     сообщение "Hello, world".

          Заметьте, что  в  этот  pаз  использовалась  функция fprintf
     вместо printf.  Пpи дальнейших экспеpиментах с Туpбо Си и обpаще-
     нии к "Справочному руководству по Турбо Си" вы узнаете  больше  о
     данной возможности.



                         - 69,70 -

               Написание вашей втоpой Си-пpогpаммы
     ----------------------------------------------------------------

          Тепеpь давайте несколько модифициpуем  пpогpамму  HELLO.C  и
     сохpаним ее в новом файле.  Вы должны находиться в pедактоpе,  но
     если вы не находитесь в нем, для быстpого входа нажмите Alt-E или
     F10 для пеpехода в главное меню, а затем - "E" или выбеpите пункт
     Edit. Тепеpь измените вашу пpогpамму следующим обpазом:

          #include <stdio.h>

          main( )
          {
           int a,b,sum;

           printf("Enter two numbers: ");
           scanf("%d %d, &a, &b);
           sum = a + b;
           printf("The sum is %d\n",sum);
          }

          Вы выполнили пять изменений в пpогpамме.


          А именно:

          - заменили стpоку,  опpеделяющую name на стpоку  опpеделения
            дpугих пеpеменных (a, b, sum - все целочисленные);

          - изменили сообщение в паpаметpе printf;

          - изменили  фоpмат  стpоки  и  список пеpеменных в паpаметpе
            scanf;

          - добавили выpажение sum=a+b;

          - изменили фоpмат стpоки и  список  аpгументов  в  последнем
            printf.

          Не опускайте знаки %, &, и \ ; их назначение будет объяснено
     в главе 6.





                         - 71,72 -

               Запись на диск
     -----------------------------------------------------------------

          Тепеpь не нажимайте на клавишу F2. Если вы это сделаете, эта
     пpогpамма будет записана в файл HELLO.C (вы собиpаетесь сохpанить
     ее под дpугим именем).

          Взамен нажмите Alt-F для входа в меню File.  Нажмите  W  для
     выбоpа команды Write To.  Туpбо Си пpедложит вам ввести новое имя
     для данной пpогpаммы;  введите sum.c и нажмите Ввод.  Ваша втоpая
     пpогpамма в данный момент запишется на диске в файл SUM.C.



               Запуск SUM.C на исполнение
     -----------------------------------------------------------------

          Нажмите Ctrl-F9. Туpбо Си откомпилиpует вашу пpогpамму. Если
     возникнут какие-либо ошибки, то веpнитесь в pедактоp и убедитесь,
     что то,  что вы напечатали,  соответствует тексту, пpиведенному в
     пpимеpе.


          В случае отсутствия ошибок,  Туpбо Си скомпонует и  направит
     на  выполнение вашу пpогpамму.  Появится пользовательский экpан с
     сообщением:

          Enter two numbers:

          Пpогpамма будет ждать,  пока вы не введете два числа, pазде-
     ленных  либо  пpобелом,  либо нажатием Ввод.  После ввода втоpого
     числа нажмите клавишу Ввод. Пpогpамма выведет на пользовательский
     экpан сумму,  введенных чисел; выбеpите Run/User screen (или наж-
     мите Alt-F5) для того,  чтобы посмотpеть pезультат. Нажмите любую
     клавишу для возвpата в Туpбо Си.

          Поздpавляем! Вы написали две совеpшенно pазные Си-пpогpаммы,
     используя несколько основных элементов пpогpаммиpования. Вы удив-
     лены, что это за элементы? Вы можете узнать о них, пpочитав главу
     6, а затем пеpейти к главе 7.






                         - 73,74 -

                            Г Л А В А   3
                            -------------


                  КОМПИЛЯЦИЯ И ЗАПУСК ВАШИХ ПРОГРАММ
     -----------------------------------------------------------------

          Тепеpь, когда вы уже  имеете  некотоpый  опыт  использования
     Туpбо Си,  давайте  пеpейдем  к  более  сложным пpоблемам - более
     подpобным особенностям интегpиpованной сpеды и  командной  стpоке
     Туpбо Си.

          Туpбо Си  пpедоставляет гибкую сpеду для написания пpогpамм;
     пpи запуске пpоизводится установка опpеделенных паpаметpов,   ко-
     тоpые, пpи необходимости, вы можете легко изменить. Туpбо Си так-
     же обеспечивает поддеpжку pазличных возможностей  для  выполнения
     однотипных pабот, связанных с созданием пpогpамм, таких как тpас-
     сиpовка ошибок и система манипуляций с файлами.

          Если вы не очень увеpены с  легко  используемой  боpландской
     интегpиpованной сpедой (TC), вы должны хоpошо поpаботать над гла-
     вой 5 пеpед компилиpованием и запуском пpогpамм из основного меню


     ТС. Это легко для изучения и не займет много вpемени до того, как
     вы будете увеpенно себя чувствовать в сpеде ТС.




















                         - 75,76 -

               В этой главе
     -----------------------------------------------------------------

          Так как вы можете компилиpовать и  запускать  на  выполнение
     ваши пpогpаммы непосpедственно из интегpиpованной сpеды,  а также
     использую стандаpтную командную стpоку DOS,  то мы в  этой  главе
     обсудим эти оба случая. Однако, так как интегpиpованная сpеда яв-
     ляется компактной,  мощной и пpостой в эксплуатации,  мы  думаем,
     что вы пожелаете узнать о ней в пеpвую очеpедь.

          Мы начнем эту главу с кpаткого обзоpа как выполняются компи-
     ляция и компоновка исходного текста в загpужаемый код  с  помощью
     интегpиpованной сpеды. И пpодолжим ее кpатким обсуждением пpоцес-
     са отладки.

          Далее мы покажем вам каким обpазом запускать ваши  пpогpаммы
     на выполнение из интегpиpованной сpеды; также мы познакомим вас с
     созданием пpоектов и пpодемонстpиpуем как их использовать.

          После демонстpации  запуска  пpогpамм   из   интегpиpованной
     сpеды, мы объясним как использовать командную стpоку для компиля-
     ции, компоновки,  создания и запуска ваших пpогpамм.   Кpоме  ин-


     тегpиpованной сpеды  ваш  пакет  включает  в себя также отдельный
     компилятоp (TCC),  компоновщик и MAKE утилиту. Описание отдельных
     пpогpамм пpиведено в пpиложениях C и D в  Справочном  руководстве
     по Турбо Си.


















                         - 77,78 -


               Создание файлов в ТС
     ----------------------------------------------------------------

          Создание новой  пpогpаммы  в  интегpиpованной сpеде Туpбо Си
     обычно связывается с пpохождением чеpез следующие шаги:

          1. Установка  опций  каталогов для того,  чтобы компилятоp и
     компоновщик знали, где искать и сохpанять файлы.

          2. Загpузка  пpогpаммы  в  pедактоp  ТС.  (Пpимечание:  если
     пpогpамма состоит более чем из одного модуля, вам необходимо соз-
     дать файл пpоекта, в котоpом пеpечислить имена этих модулей).

          3. Создание выполняемого файла пpогpаммы.

          Точность соблюдения этих основных  шагов  зависит  от  того,
     pаботаете ли вы с одним файлом, или с несколькими.





               Отладка вашей программы.
     -----------------------------------------------------------------

          Выявление и  исправление ошибок в программах является всегда
     одним из наиболее неприятных аспектов программирования.  Интегри-
     рованная среда облегчает вашу работу за счет возможностей имеюще-
     гося отладчика,  который помогает вам в обнаружении ошибок как на
     этапах компиляции, так и выполнения.



               Обнаружение синтаксических ошибок.
     ------------------------------------------------------------------

          Однако, одной из наиболее весомых причин удобства  работы  с
     интегрированной версией Турбо Си является,  конечно, фиксирование
     синтаксических ошибок и возможность  оценки  всех  предупреждений
     выдаваемых вам компилятором.  Турбо Си сначала записывает все со-
     общения компилятора и компоновщика в буфер,  а затем  выводит  их
     сразу в окно сообщений.  Это позволяет ознакомиться с ними, в ус-
     ловиях, когда  сохраняется возможность непосредственно редактиро-
     вать тексты исходных файлов.

                         - 79,80 -


          Для проверки этой возможности добавьте  несколько  синтакси-
     ческих ошибок   в  пример программы.  Уберите знак # из оператора
     включения в первой строке.  Затем уберите последние кавычки в пя-
     той строке программы - printf. Получившийся файл с ошибками будет
     выглядеть следующим образом:

     include <stdio.h>

     main()
     {
          printf("Hello world\n);


          Теперь откомпилируйте  файл  снова,  нажав Alt-F9 (Compile).
     Окно компиляции подскажет вам  сколько  получилось  в  результате
     ошибок и предупреждений (должно получиться два сообщения об ошиб-
     ках и ни одного предупреждения).





               Окно сообщений.
     -----------------------------------------------------------------

          Когда вы увидите в окне компиляции сообщение Press  any  key
     (нажмите любую клавишу),  нажмите пробел. На экране появится окно
     сообщений, и  светлая полоса (маркер-строка) расположится на пер-
     вой ошибке или предупреждении.  Поскольку первая ошибка относится
     к файлу,  находящемуся в данный момент в окне редактора,   то  вы
     также увидите  подсвеченную строку,  отмечающую место в вашей ис-
     ходной программе, где компилятор сгенерировал сообщение об ошибке
     или предупреждение.

          Если вы желаете просмотреть другие сообщения, то воспользуй-
     тесь клавишами управления курсором для перемещения  маркер-строки
     окна сообщений  вверх и вниз.  Обратите внимание,  что эта строка
     перемещается как в окне редактора,  так и в окне сообщений по об-
     наруженным компилятором  ошибкам в вашей исходной программе.  При
     желании посмотреть строку на которой вы находились перед  выходом
     из редактора, поместите маркер-строку на сообщение о компиляции.

          Если текст в окне сообщений имеет слишком большую длину так,
     что не умещается в окне,  то вы можете использовать для обозрения

                         - 81,82 -


     клавиши со стрелками влево и вправо для горизонтального продвиже-
     ния сообщения.  Для обзора большего числа сообщений одновременно,
     вы можете увеличить окно сообщений до размеров всего экрана,  на-
     жав F5 (Zoom). Если окно сообщений увеличено, то оно заслоняет от
     вас окно редактора и слежение не выполняется.  Поэтому снова вер-
     ните окна в режим наложения.
















               Исправление синтаксических ошибок.
     -----------------------------------------------------------------

          Для исправления ошибки, поместите маркер-строку окна сообще-
     ний на первом сообщении об ошибке и нажмите Ввод.  Ваш маркер пе-
     рекинется в окно редактора и расположится на месте,  которое выз-
     вало сообщение   об  ошибке.   Заметьте,   что  строка  состояния
     редактора показывает сообщение,  которое вы выбрали (это  полезно
     когда вы  работаете с распахнутым окном).  Теперь можно исправить
     ошибку, которая  породила сообщение. (Для этого поставьте знак #,
     который вы ранее убрали в первой строке программы.)

          Поскольку  данное  сообщение  не  единственное,  то есть два
     метода для продолжения корректировок.

          Первый метод  заключается  в  возвращении  к окну сообщений,
     через нажатие F6  (Message),  и выборе  очередного сообщения, как
     это было сделано ранее.

          Однако, вам не обязательно возвращаться  в  окно  сообщений,
     чтобы перейти к следующей ошибке.  Вы просто можете нажать ALT-F8
     (Next error   -  следующая ошибка)  и редактор поместит курсор на

                         - 83,84 -

     место, соответствующее очередной ошибке окна сообщений. Заметьте,
     что сообщение,    показанное  в  строке состояния и в высвеченной
     строке окна сообщений,  меняется по мере того,  как вы продвигае-
     тесь от   одной ошибки к другой.  По аналогии можно двигаться и в
     обратном направлении,  нажав Alt-F7 (Previos error  -  предыдущая
     ошибка).

          Имеются определенные преимущества у обоих этих  методов,   и
     обычно обстоятельства диктуют какой метод предпочтительней. Иног-
     да одна глупая ошибка в исходной программе может "смутить" компи-
     лятор, вызвав множество сообщений. Исправление такой ошибки дела-
     ет все остальные сообщения бессмысленными и тогда наиболее удобно
     использовать первый метод - вернуться к окну сообщений после исп-
     равления первой ошибки, переместиться вниз к следующему значащему
     сообщению и  выбрать его.  В других случаях имеет смысл проверить
     все сообщения  последовательно; нажатие Alt-F8 (следующая ошибка)
     в этом случае более эффективно.

          Запомните, что Alt-F7 и Alt-F8 (предыдущая и следующая ошиб-
     ка) являются клавишами оперативного доступа, т.е. работают из лю-
     бого места в среде программирования Турбо Си.  Так, если вы нахо-
     дитесь в  окне сообщений и нажмете Alt-F8 (следующая ошибка),  то


     не получите сообщения,  которое высвечивается текущим, а получите
     следующее за ним сообщение. (Если вы хотите выбрать текущее сооб-
     щение, то нажмите Ввод.) Если больше у компилятора нет сообщений,
     то Alt-F8 не даст никакого результата.

          Примечание: сообщения  компоновщика  не могут быть выбраны и
     не отслеживаются в вашем исходном файле.

          В ходе  исправления  ошибок  обычно  добавляется и удаляется
     текст. Редактор  отслеживает эти действия:  когда вы переходите к
     следующей ошибке,    он правильно устанавливает курсор на ошибке.
     Поэтому вам нет необходимости запоминать номера строк или считать
     добавленные или удаленные строки текста.









                         - 85,86 -


               Обнаружение ошибок времени выполнения
               интегрированным отладчиком
     ----------------------------------------------------------------

          Если вы обнаружили уже все ошибки, то ваша  программа  будет
     откомпилированна без проблем.  Однако при этом может остаться не-
     выполнимой, т. к. может содержать логические (времени выполнения)
     ошибки. Средства  обнаружения  синтаксических ошибок не помогут в
     этом случае.

          Для обнаружения ошибок времени выполнения ТС включает в себя
     интегрированный отладчик.  Вы  можете запустить свою программу на
     выполнение из отладчика,  остановить ее в любой точке,  проверить
     значения переменных и даже изменить их значения для проверки  ка-
     ким образом ваша программа будет на это реагировать. Для обучения
     работе с интегрированным отладчиком ТС читайте  главу  4  данного
     руководства.
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Использование нескольких исходных файлов                         
     ----------------------------------------------------------------           
                                                                                
          Одним из  преимуществ Турбо Си является возможность раздель-          
     ной компиляции нескольких исходных  файлов.   К  тому  же  сервис          
     Project-Make по   управлению разработкой на Турбо Си,  делает эту          
     возможность еще более привлекательной.                                     
                                                                                
          В предыдущем  примере  в главе 2 имелся только один исходный          
     файл, поэтому  можно было использовать Compile/Make для  создания          
     выполняемой программы  без определения файла проекта.  Однако при          
     построении программы из нескольких исходных файлов Си  необходимо          
     точно сообщить Турбо Си,  какие файлы используются,  т.е. создать          
     файл проекта.                                                              
                                                                                
          Создание файла проекта также просто,  как перечисление  имен          
     ваших исходных файлов на Си.  В дальнейшем вы увидете, что можете          
     вложить большую мощь в создание проекта, а сейчас, давайте начнем          
     с простого - с двухфайловой программы.                                     
                                                                                
          В обычном случае лучше иметь файл  с  главной  программой  и          
     вспомогательный файл с определениями функций и данных, вызываемых          

                         - 87,88 -
                                                                                
     из главной программы.  Например, главный файл MYMAIN.C может выг-          
     лядеть таким образом:                                                      
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main(int argc, char *argv[])                                          
          {                                                                     
            char *s                                                             
                                                                                
            if (argc > 1)                                                       
              s = argv[1];                                                      
            else                                                                
              s = "the universe";                                               
                                                                                
            printf("%s %s.\n",GetString(),s);                                   
                                                                                
          }                                                                     
                                                                                
          Вспомогательный  файл  MYFUNCS.C  может  выглядеть следующим          
     образом:                                                                   
                                                                                
          char ss [] = "the restaurant at the end of";                          
                                                                                
                                                                                
          char *GetString(void)                                                 
          {                                                                     
            return ss;                                                          
          }                                                                     
                                                                                
          Создайте файлы MYMAIN.C и MYFUNCS.C.                                  
                                                                                
          Эти два файла требуют некоторой  работы  по  созданию  файла          
     проекта. Как вы, вероятно, догадываетесь, файл проекта просто со-          
     держит две строки с названиями файлов, которые нужно откомпилиро-          
     вать и скомпоновать. Назовем файл проекта MYPROC.PRJ. Он выглядит          
     так:                                                                       
                                                                                
          mymain                                                                
          myfuncs                                                               
                                                                                
          Вот и все.  Турбо Си считает,  что любой файл без расширения          
     является .С файлом (хотя вы можете явно задать - .С). Кроме того,          
     порядок указания файлов не имеет значения,  он влияет лишь на по-          
     рядок компиляции.  Следующий файл проекта приведет к тому же  ко-          
     нечному результату:                                                        

                         - 89,90 -
                                                                                
                                                                                
          myfuncs                                                               
          mymain                                                                
                                                                                
          Теперь сохраните  ваш файл как MYPROG.PRJ (выберите Write из          
     меню File).                                                                
                                                                                
          Заметим, что имя файла проекта (MYPROG.PRJ)   отличается  от          
     имени главного файла (MYMAIN.C). Два имени (но не расширения) мо-          
     гут быть одинаковыми, однако это не обязательно. Важно запомнить,          
     что имя  вашего выполняемого файла (а также имя любого MAP файла,          
     создаваемого компоновщиком)  будет определяться именем файла про-          
     екта. В   нашем случае выполняемым файлом будет MYPROG.EXE (а MAP          
     файлом, если таковой имеется - MYPROG.MAP).                                
                                                                                
          Заметим также, что вы можете указывать маршрут к любому фай-          
     лу, перечисленному в файле проекте. Таким образом, вы можете соз-          
     давать программу не только из файлов, расположенных в одном и том          
     же каталоге.                                                               
                                                                                
                                                                                
                                                                                
                                                                                
               Создание программы из нескольких исходных файлов                 
     ----------------------------------------------------------------           
                                                                                
          Теперь, когда у вас есть файл проекта,  все, что вам необхо-          
     димо сделать   -  это  сообщить Турбо Си,  какой проект вы хотите          
     построить. Для  этого введите имя файла проекта в меню  работы  с          
     проектом. Нажмите ALT-P для входа в меню Project и выберите пункт          
     Project name (имя проекта). Вы можете явно ввести имя вашего фай-          
     ла или можете воспользоваться символами маскирования (?  и *) для          
     нахождения его в каталоге.  (Но помните,  если  вы  не  сохранили          
     файл, то  его нет на диске.) Когда имя проекта введено, вы можете          
     просто нажать F9 (Make)  для создания выполняемого файла. Для за-          
     пуска необходимо нажать Ctrl-F9 (Run/Run).                                 
                                                                                
          Заметим, что  запуск программы включает в себя и ее создание          
     "make". Это  значит,  что, если файлы в проекте должны быть пере-          
     компилированы, то нажатие Ctrl-F9 может начать процесс компиляции          
     и компоновки.  Таким образом, вы можете опустить явный вызов make          
     (F9). Выберите Run/User screen ( или нажмите Alt-F5) для просмот-          
     ра выходных данных. Нажмите любую клавишу для возврата в ТС.               
                                                                                
                                                                                

                         - 91,92 -
                                                                                
               Еще раз об отслеживании ошибок                                   
     ----------------------------------------------------------------           
                                                                                
          В примере с единственным исходным файлом вы видели, что син-          
     таксические ошибки,  о которых компилятор выдает предупреждения и          
     сообщения,  могут быть просмотрены и выбраны  из  окна сообщений.          
     Аналогично,  окно  сообщений  позволяет  обрабатывать  ошибки при          
     многофайловой компиляции (или makes).                                      
                                                                                
          Для того,  чтобы это увидеть, введите некоторые синтаксичес-          
     кие ошибки в два файла:  MYMAIN.C и MYFUNCS.C. Из MYMAIN.C в пер-          
     вой строке удалите первую острую скобку,  а в пятой - удалите с в          
     char.  Эти изменения должны генерировать три ошибки и  три преду-          
     преждения в MYMAIN.                                                        
                                                                                
          Теперь загрузите MYFUNCS.C и удалите первое r из  "return" в          
     пятой строке. Это изменение вызовет две ошибки и два предупрежде-          
     ния.                                                                       
                                                                                
          Редактирование этих файлов сделает их не соответствующими по          
     времени создания своим объектными файлами, поэтому при выполнении          
     make они  перекомпилируются.  Так как вам нужно посмотреть эффект          
                                                                                
                                                                                
     обработки ошибок в нескольких файлах, то необходимо изменить кри-          
     терий для   определения останова в Project-Make.  Это достигается          
     включением переключателя on в меню Project.                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 93,94 -
                                                                                
               Остановка Make                                                   
     -----------------------------------------------------------------          
                                                                                
          Имеется несколько причин прерывания процесса  make  в  Турбо          
     Си. Очевидно,  Project-Make останавливается после создания выпол-          
     няемого файла.  Однако,  Project-Make будет также останавливаться          
     для вывода сообщений об ошибках некоторого типа.                           
                                                                                
          Например, Project-Make всегда будет останавливаться, если он          
     не сможет найти один из исходных файлов (или  один  из  зависимых          
     файлов - что будет обсуждаться позже), перечисленных в файле про-          
     екте. Кроме  того,  вы сами в состоянии остановить  Project-Make,          
     нажав Ctrl-Break.                                                          
                                                                                
          Make может  также остановиться,  когда компилятор генерирует          
     сообщения. Вы можете выбрать тип сообщений, по которым надо оста-          
     навливаться, установкой в меню Project режима переключателя Break          
     make on.  Этот переключатель имеет значение  по  умолчанию  Break          
     make on...Errors - которое обычно устраивает вас.  Однако, вы мо-          
     жете захотеть прервать make после компиляции файла,  при  наличии          
     предупреждений, ошибок, фатальных ошибок или перед началом компо-          
     новки.                                                                     
                                                                                
                                                                                
                                                                                
          Полезность каждой из этих возможностей фактически  определя-          
     ется способом,  которым вы предпочитаете исправлять ошибки и пре-          
     дупреждения. Если вы предпочитаете исправлять их сразу по обнару-          
     жению, то вам необходимо установить переключатель Break make on в          
     режим Warnings (предупреждения)  или Errors  (ошибки).   Если  вы          
     предпочитаете работать   с полным списком ошибок во всех исходных          
     файлах до их исправления,  то необходимо установить переключатель          
     в режим Fatal errors (фатальные ошибки) или Link (компоновка).             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 95,96 -
                                                                                
               Синтаксические ошибки в нескольких исходных файлах.              
     -----------------------------------------------------------------          
                                                                                
          Для демонстрации ошибок в нескольких файлах установите пере-          
     ключатель Break make on в состояние Fatal errors (фатальные ошиб-          
     ки).  Для этого нажатием Alt-P войдите в меню  Project и выберите          
     Break make on.  Из подменю выберите пункт Fatal errors (фатальные          
     ошибки).                                                                   
                                                                                
          К данному  моменту  вы должны были уже внести синтаксические          
     ошибки в MYMAIN.C и MYFUNCS.C. Нажмите F9 (MAKE) "создание проек-          
     та". Окно    компиляции  покажет компилируемые файлы и количество          
     ошибок и предупреждений в каждом файле и общее для  сеанса  Make.          
     Когда появится   сообщение Press any key (нажмите любую клавишу),          
     нажмите пробел.                                                            
                                                                                
          Ваш курсор должен располагаться на первой ошибке или предуп-          
     реждении в окне сообщений.  И если файл, к которому относится это          
     сообщение, находится в редакторе, яркая подсветка в окне редакто-          
     ра покажет вам место возникновения проблемы у компилятора.  Далее          
     вы можете перемещаться вверх и вниз в окне сообщений для просмот-          
     ра различных сообщений.  Заметим, что для каждого исходного файла          
                                                                                
     имеется сообщение "Compiling" (компиляция),  которое не  является          
     ни ошибкой,  ни предупреждением, а просто разделяет различные со-          
     общения, генерируемые для каждого файла.                                   
                                                                                
          Когда вы подойдете вниз к границе файла,  окно редактора мо-          
     жет перейти   или  не  перейти на следующий файл в зависимости от          
     состояния Messages Track в меню Debug (отладка). По умолчанию от-          
     слеживание сообщений производится только в текущем файле.                  
                                                                                
          Итак, перемещаясь  к  сообщению,  которое относится к файлу,          
     которого нет в окне редактора, подсветка выключается. Если вы вы-          
     бирете одно из этих сообщений (т.е. нажмете Ввод, находясь на со-          
     общении),  то соответствующий файл будет загружен в  редактор,  и          
     вам будет указано курсором место ошибки.  Если вы затем вернетесь          
     в окно сообщений нажатием F6 (Message),  то слежение в этом файле          
     возобновится.                                                              
                                                                                
          Однако,  установив переключатели  Messages Track в режим All          
     files (все файлы), вы можете обрабатывать сообщения через границы          
     файлов. Это означает, что, когда вы перемещаетесь по окну сообще-          
     ний,  Турбо Си автоматически будет загружать соответствующий файл          
     в  редактор  и,  следовательно,  позволит  вам  увидеть,  к  чему          

                         - 97,98 -
                                                                                
                                                                                
     относится каждое сообщение. Попробуйте сделать это сами.                   
                                                                                
          Вы можете также полностью  отключить обработку ошибок, уста-          
     новив переключатель Messages Track в режим off.  В этом случае вы          
     просто выбираете сообщение, с которым хотите работать и нажимаете          
     ввод.  Соответствующий файл загружается в редактор, а курсор ука-          
     зывает на место ошибки.                                                    
                                                                                
          Заметим, что на Alt-F7 и Alt-F8 (предыдущая ошибка и следую-          
     щая ошибка)    не действует изменение режимов переключателя Track          
     messages. Эти  полезные клавиши всегда будут  находить  следующую          
     или предыдущую ошибку и загружать соответствующий файл,  если это          
     необходимо.                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Сохранение и очистка сообщений                                   
     -----------------------------------------------------------------          
                                                                                
          Обычно, перед  созданием  проекта,  окно сообщений очищается          
     для новых сообщений.  Иногда, однако, требуется сохранять сообще-          
     ния между созданием проектов.                                              
                                                                                
          Рассмотрим следующий пример:  у вас может быть проект, имею-          
     щий множество исходных файлов,  и переключатель Break make on ус-          
     тановлен на остановку по ошибкам (Errors). В этом случае вы може-          
     те получить  несколько  предупреждающих  сообщений  в  нескольких          
     файлах, но как только в одном из файлов обнаружится ошибка, пост-          
     роение останавливается.  Вы обнаруживаете эту ошибку и хотите оп-          
     ределить, исправит ли ее компилятор. Однако, если вы снова выпол-          
     няете make или компиляцию,  предыдушие предупреждающие  сообщения          
     пропадают. Как  этого избежать?  Все, что вам нужно сделать - это          
     включить переключатель Keep messages в меню Options/Environment.           
                                                                                
          Когда переключатель Keep massages включен, сообщения не очи-          
     щаются при начале построения. Удаляются только сообщения из пере-          
     компилируемых файлов.  Следовательно старые сообщения для данного          
     файла заменяются новыми сообщениями, генерируемые компилятором.            

                         - 99,100 -
                                                                                
                                                                                
                                                                                
          Если  в некотором месте вы  работаете  с  сообщениями, то вы          
     можете очистить  их  по  выбору  Clear messages  on  в меню Debug          
     (отладка).  При  этом  очищаются все текущие  сообщения. Выключая          
     установку Keep messages и запуская снова make, мы получим очистку          
     предыдущих сообщений.                                                      
                                                                                
          Очистка предыдущих сообщений при изменении проекта - это чу-          
     десная идея. Очистка выполняется легко - заданием в проектном ме-          
     ню соответствующей функции.  После выбора Сlear project вы можете          
     опредилить новый проект,  компилировать и выполнять  однофайловые          
     программы посредством   загрузки их в редактор или по определению          
     имени первичного Си файла.                                                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Более мощные средства построения проекта                         
     -----------------------------------------------------------------          
                                                                                
          В последнем описании построения проекта вы столкнулись с на-          
     иболее типичной ситуацией - использованием простого списка исход-          
     ных файлов Си.  Project-Make предусматривает гораздо больше,  чем          
     показано  в  этом пpостом примере.  Для того,  чтобы увидеть это,          
     нужно понять как работает make.                                            
                                                                                
          Make работает с помощью сравнения  даты  создания  исходного          
     файла с датой создания объектного файла, генерируемого компилято-          
     ром. Это  сравнение дат создания определяет некоторые неявные за-          
     висимости в  простом списке файлов.                                        
                                                                                
          В ранее данном примере с использованием  MYPROG.PRJ  имеются          
     следующие зависимости:                                                     
                                                                                
          MYMAIN.OBJ зависит от MYMAIN.C                                        
          MYFUNCS.OBJ зависит от MYFUNCS.C                                      
          MYPROG.EXE зависит от MYMAIN.OBJ, MYFUNCS.OBJ и MYPROG.PRJ            
                                                                                
          Это означает, что объектный файл MYMAIN.OBJ не соответствует          

                         - 101,102 -
                                                                                
                                                                                
     по дате,    если MYMAIN.C моложе,  чем MYMAIN.OBJ; следовательно,          
     MYMAIN.C будет перекомпилирован.  Заметим,  что выполняемый  файл          
     всегда зависит  от всех объектных файлов проекта и от самого про-          
     ектного файла.  Этот последний факт означает,  что если любой  из          
     объектных файлов   или  сам проектный файл MYPROG.PRJ имеет более          
     позднюю дату,  чем MYPROG.EXE, то функция Make перекомпонует файл          
     MYPROG.EXE. Эти  неявные зависимости возникают из простого списка          
     имен файлов вашего проекта.                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Явные зависимости                                                
     ----------------------------------------------------------------           
                                                                                
          Однако, более сложные проекты требуют более совершенных воз-          
     можностей построения, которые позволяют задавать явные зависимос-          
     ти. Это  полезно,  когда конкретный исходный файл Си  зависит  от          
     других файлов.    Для  исходных  файлов Си обычным делом является          
     включение нескольких файлов заголовка (.Н файлов),  которые опре-          
     деляют интерфейс  с внешними программами.  Если интерфейс с этими          
     программами изменяется,  то вам нужно перекомпилировать файл, ко-          
     торый использует эти программы.  Это делается с помощью явных за-          
     висимостей.                                                                
                                                                                
          Например, у вас есть главная  программа  MYMAIN.C,   которая          
     включает файл заголовка MYFUNCS.H.  Make перекомпилирует MYMAIN.C          
     и MYFUNCS.C,  если MYFUNCS.H изменяется, при условии, что в вашем          
     проектном файле заданы следующие зависимости:                              
                                                                                
                  MYMAIN.C (MYFUNCS.H)                                          
                  MYFUNCS  (MYFUNCS.H)                                          
                                                                                
          Заметим, что этот файл проекта делает файл MYFUNCS.C зависи-          

                         - 103,104 -
                                                                                
                                                                                
     мым от файла MYFUNCS.H.  Это хорошая проверка на логичность ваших          
     файлов. Итак, теперь вы имеете те же самые косвенные зависимости,          
     а также некоторые явные, а именно:                                         
                                                                                
             MUMAIN.OBJ  зависит от MYMAIN.C и MYFUNCS.H                        
             MYFUNCS.OBJ зависит от MYFUNCS.C и MFUNCS.H                        
             MYPROG.EXE зависит от MYMAIN.OBJ, MYFUNC.OBJ и MYPROG.PRI          
                                                                                
          Любой Си  файл,  перечисленный в файле проекта,  может иметь          
     столько явных зависимостей,  сколько необходимо. Просто поместите          
     файлы, от  которых должен зависеть ваш файл с исходным текстом, в          
     скобки и разделите их пробелами,  запятыми или точками с запятой.          
                                                                                
          Например, если нужно,  чтобы MYMAIN.C зависел  от  MYFYNCS.H          
     YOURS и OTHER.H, введите                                                   
                                                                                
             MYMAIN.C (MYFUNCS.H, YORS.H, OTHER.H)                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Автоматическая проверка зависимости.                             
     ------------------------------------------------------------------         
                                                                                
          Средство создания проектов имеет способность  автоматической          
     проверки зависимости  между исходными файлами в проекте и объект-          
     ными файлами на которые они ссылаются. Средство создания открыва-          
     ет файл .OBJ  и ищет в нем информацию о файлах,  включенных в ис-          
     ходный текст. Эта информация всегда помещается как ТС,  так и ТСС          
     в файл .OBJ при компиляции  исходного модуля.  Затем время и дата          
     каждого файла,  который использовался при  создании  файла  .OBJ,          
     проверяется с  информацией  о  времени и дате находящейся в файле          
     .OBJ. Если даты различны,  то .C исходный файл будет перекомпили-          
     рован.                                                                     
                                                                                
          Примечание. Чтобы данная возможность была включена, вы долж-          
     ны в    интегрированной    среде    переключатель    Project/Auto          
     Dependencies установить в положение On.                                    
                                                                                
          Это все о зависимостях. Этот метод дает вам мощный прием для          
     создания программ без использования полного синтаксиса make.               
                                                                                
                                                                                

                         - 105,106 -
                                                                                
               Какие у Make дополнительные возможности?                         
     -----------------------------------------------------------------          
                                                                                
          Имеются две дополнительные возможности,  усиливающие функции          
     Make. Первая  позволяет вам задавать внешние объектные и  библио-          
     течные файлы  для компоновки вашего проекта,  а вторая - изменять          
     стандартные загрузочные модули и библиотеки.                               
                                                                                
                                                                                
                                                                                
              Внешние объектные и библиотечные файлы.                           
     -----------------------------------------------------------------          
                                                                                
          Время от времени вам может потребоваться  использовать неко-          
     торые  программы,  написанные на других  языках, например, ассем-          
     блере или же другом компиляторе Си.  Или, быть может, вам понадо-          
     бятся дополнительные библиотечные файлы,  выполняющие специальные          
     функции, не  предусмотренные в стандартных библиотеках.   В  этих          
     случаях вы  можете включить имена объектных или библиотечных фай-          
     лов в ваш проект с явным расширением. Например, так (заметим, что          
     порядок перечисления файлов не важен):                                     
                                                                                
                                                                                
          MYMAIN       (MYFUNCS.H)                                              
          MYFUNCS      (MYFUNCS.H)                                              
          SPECIAL.OBJ                                                           
          OTHER.LIB                                                             
                                                                                
          Когда Projekt-Make  увидит файл с явным расширением .OBJ, то          
     он просто включает его в список файлов, компонуемых вместе. Попы-          
     ток  откомпилировать его или отыскать его исходный файл не проис-          
     ходит. Точно так же, имя в вашем файле проекте с расширением .LIB          
     добавляется в список библиотек, которые компоновщик просматривает          
     при попытке разрешить внешние ссылки.  Опять же,  он не  пытается          
     компилировать или перестраивать библиотеку.                                
                                                                                
          Заметим, что эти типы файлов не могут иметь списки явных за-          
     висимостей (если их сделать,  они будут проигнорированы). Однако,          
     можно свободно  включить  эти имена в  списки  зависимостей ваших          
     исходных Си файлов,  как любые другие файлы, от которых вы хотите          
     установить зависимости.                                                    
                                                                                
          Например:                                                             
                                                                                
          MYMAIN (MYFUNCS.H, SPECIAL.OBJ)                                       

                         - 107,108 -
                                                                                
          MYFUNCS (MYFUNCS.H, OTHER.LIB)                                        
          SPECIAL.OBJ                                                           
          OTHER.LIB                                                             
                                                                                
          Это означает, что при изменении файлов .OBJ или .LIB, исход-          
     ные файлы Си перекомпилируются.                                            
                                                                                
                                                                                
                                                                                
               Изменение стандартных файлов.                                    
     -----------------------------------------------------------------          
                                                                                
          В некоторых случаях необходимо изменить  стандартные  загру-          
     зочные файлы  и библиотеки.  Эта возможность обычно резервируется          
     для заядлых программистов (хакеров),  а не для практики  начинаю-          
     щих. Но,   если вы почувствуете в этом необходимость, то сделайте          
     нижеследующее.                                                             
                                                                                
          Для отмены стандартного загрузочного файла поместите файл  с          
     именем C0*.OBJ первым в вашем файле проекте - где знак * заменяет          
     любое имя,  соответствующее DOS (например, C0MINE.OBJ). Критичес-          
     кими моментами здесь является то, что имя должно начинаться с С0,          
                                                                                
                                                                                
     стоять  на  первом месте в вашем проекте и иметь явное расширение          
     .OBJ.                                                                      
                                                                                
          Для изменения стандартной библиотеки все, что вам нужно сде-          
     лать, это  поместить имя специальной  библиотеки  в  любом  месте          
     списка имен вашего проекта. Имя библиотеки должно начинаться с С,          
     следующая  буква  указывает  на  модель (так S для малой модели),          
     следующие шесть знаков могут быть любыми.  Вы должны явно указать          
     расширение .LIB (например, CSMYFILE.LIB или CSNEW.LIB).                    
                                                                                
          При исключении стандартной библиотеки,  МАКЕ не будет выпол-          
     нять компоновку с математической библиотекой,  в  соответствии  с          
     установкой Floating   point  (плавающей  точки)   в меню O/C/Code          
     Generation. Если  вы хотите использовать и эти библиотеки при от-          
     мене стандартной библиотеки,  то вы должны явно включить их в ваш          
     файл проекта.                                                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 109,110 -
                                                                                
               Компиляция и компоновка из командной строки.                     
     -----------------------------------------------------------------          
                                                                                
          В дополнение к использованию интегрированной среды вы можете          
     запускать ваши  программы Турбо Си при помощи обычного интерфейса          
     типа командной строки.  Несмотря на то, что режим интегрированной          
     среды является лучшим для разработки и выполнения ваших программ,          
     вы можете иногда предпочесть использование  командной  строки;  в          
     некоторых сложных программах интерфейс программной строки являет-          
     ся единственным путем сделать что-то углубленное.  Например, если          
     ваши программы  Турбо Си включают встроенный ассемблеровский код,          
     то вам нужно использовать версию Турбо Си (ТСС), работающую с ко-          
     мандной строкой, а не интегрированную версию TC.                           
                                                                                
          ТСС компилирует  исходные  файлы  Си и связывает их вместе в          
     выполняемый файл.  TCC работает  аналогично  команде  СС  системы          
     UNIX. ТСС  также будет вызывать ТASM для ассемблирования исходных          
     .ASM-файлов.  Заметим,  что для выполнения  только компиляции вам          
     нужно использовать в командной строке опцию -с.                            
                                                                                
                                                                                
                                                                                
                                                                                
               Командная строка ТСС.                                            
     -----------------------------------------------------------------          
                                                                                
          Для вызова Турбо Си из командной строки в ответ на приглаше-          
     ние DOS введите tcc с сопровождением набора аргументов  командной          
     строки. Аргументы   командной строки включают опции компилятора и          
     компоновщика, а  также имена файлов.  Основной  формат  командной          
     строки следующий:                                                          
                                                                                
          tcc [режим режим режим ... ] имяфайла имяфайла ...                    
                                                                                
                                                                                
                                                                                
               Опции компилятора и компоновщика в командной строке.             
     -----------------------------------------------------------------          
                                                                                
          Каждой опции  командной строки предшествует тире (-).  Опции          
     отделяются от команды tcc и последующих имен  файлов  по  крайней          
     мере одним пробелом. Опцию можно явно выключить в командной стро-          
     ке, если  указать после нее тире (например,  -K-  отменяет  опцию          
     unsigned chars). Опции командной строки Турбо Си описаны в прило-          
     жении С Reference Guide.                                                   

                         - 111,112 -
                                                                                
               Имена файлов в командной строке.                                 
     ----------------------------------------------------------------           
                                                                                
          После  списка  опций  компилятора  и  компоновщика введите в          
     командной строке имена файлов.                                             
                                                                                
          Компилятор  компилирует  файлы  в  соответствии со следующим          
     набором правил:                                                            
                                                                                
          имяфайла          компилируется имяфайла.с                            
          имяфайла.с        компилируется имяфайла.с                            
          имяфайла.xyz      компилируется имяфайла.xyz                          
          имяфайла.obj      включается в качестве объектного файла              
                            при компоновке                                      
          имяфайла.lib      включается в качестве библиотеки при                
                            компоновке                                          
          имяфайла.asm      вызывает TASM для ассемблирования в .OBJ.           
                                                                                
          Затем компилятор  вызовет  компоновщик и снабдит его именами          
     соответствующего стартового файла Си и стандартных библиотек  Си.          
                                                                                
                                                                                
                                                                                
               Выполняемый файл.                                                
     -----------------------------------------------------------------          
                                                                                
          Обычно компилятор создает имя выполняемого  файла  по  имени          
     первого исходного   или  объектного файла,  заданного в командной          
     строке. Выполняемой  программе присваивается это первое имя файла          
     с расширением .EXE.                                                        
                                                                                
          Если вы хотите задать отличное имя файла, то используйте оп-          
     цию -e. После команды tcc, перед любыми именами файлов, введите -          
     e, непосредственно  сопровождая именем, которое вы хотите присво-          
     ить выполняемому файлу (ни одного пробела не должно быть между -e          
     и именем файла).                                                           
                                                                                
                                                                                
                                                                                
               Некоторые примеры командных строк.                               
     ----------------------------------------------------------------           
                                                                                
          Следующий пример  иллюстрирует соответствующий синтаксис для          
     вызова Турбо Си из командной строки DOS:                                   
                                                                                

                         - 113,114 -
                                                                                
          tcc -IB:\include -LB:\lib -etest start.c body.obj end                 
                                                                                
          По этой команде tcc вызывает Турбо Си на запрос  DOS.  Турбо          
     Си  затем  интерпретирует режимы командной строки следующим обра-          
     зом:                                                                       
                                                                                
          - включаемый каталог - это B:\INCLUDE (-IB:\include).                 
          - библиотеки - это B:\LIB каталог (-LB:\lib ).                        
          - выполняемый  результат  будет  помещен  в  файл  с  именем          
            TEST.EXE (-etest).                                                  
                                                                                
          Турбо Си  интерпретирует перечисленные имена файлов, считая,          
     что программа состоит из:                                                  
                                                                                
          - исходного файла START.C, подлежащего компиляции                     
          - объектного файла BODY.OBJ, включаемого при компоновке               
          - еще одного исходного файла END.C, подлежащего компиляции.           
                                                                                
          Рассмотрим другой пример командной строки Турбо Си для                
     времени компиляции:                                                        
                                                                                
     tcc -IB:\include -LB:\lib2 -mm -C -K s1 s2.c z.asm mylib.lib               
                                                                                
                                                                                
          Эта командная строка времени компиляции указывает Турбо Си:           
                                                                                
          - искать включаемые файлы в каталоге B:\INCLUDE                       
            (-IB:\include)                                                      
          - искать библиотеки в каталоге B:\LIB2 (-LB:\lib2)                    
          - использовать среднюю модель памяти (-mm)                            
          - разрешить вложенные комментарии (-C)                                
          - сделать chars беззнаковыми (-К)                                     
                                                                                
          Турбо Си интерпретирует перечисленные имена файлов следующим          
     образом:                                                                   
                                                                                
          - исходные файлы S1.C и S2.C должны компилироваться;                  
                                                                                
          - файл Z.ASM должен ассемблироваться (используя TASM);                
                                                                                
          - выполняемый файл будет назван S1.EXE;                               
                                                                                
          - библиотечный файл MYLIB.LIB будет подключен при компоновке          
                                                                                
                                                                                

                         - 115,116 -
                                                                                
               Файл TURBOC.CFG                                                  
     -----------------------------------------------------------------          
                                                                                
          В дополнение к опциям, заданным в командной строке, вы може-          
     те установить   список  опций в файле конфигурации TURBOC.CFG.  В          
     этом файле опции указываются в виде,  соответствующем вводу с ко-          
     мандной строки.                                                            
                                                                                
          Если вы  не хотите пpи использовании ТСС вводить в командной          
     стpоке паpаметpы,  то можете воспользоваться установками в  файле          
     TURBOC.CFG, в  пpотивном  случае вы можете указать их в командном          
     файле и не использовать файл TURBOC.CFG.                                   
                                                                                
          Вы можете создавать файл TURBOC.CFG любым стандартным редак-          
     тором ASCII или текстовым процессором (таким,  как редактор Турбо          
     в интегрированной  версии).  Опции (разделенные пробелами)  можно          
     указывать в одной строке  или  записывать  списком  в  нескольких          
     строках. Позже,   при  компиляции  программы  с помощью командной          
     строки, Турбо Си использует опции TURBOC.CFG, в дополнение к име-          
     ющимся в командной строке.                                                 
                                                                                
          При загрузке ТСС он ищет файл TURBOC.CFG в текущем каталоге.          
                                                                                
     Если его там нет,  и если  вы работаете  в DOS 3.0  и выше, тогда          
     просматривается еще  и стартовый каталог (где  находится TCC.EXE)          
     Заметим,  что  этот файл конфигурации  отличается от TCCONFIG.TC,          
     который является файлом конфигурации по  умолчанию для интегриро-          
     ванной версии.                                                             
                                                                                
          Опции, заданные в командной строке, отменяют одноименные оп-          
     ции, заданные  в TURBOC.CFG, что является немаловажным свойством.          
     Если, например,   ваш файл конфигурации содержит некоторые опции,          
     среди которых  находится -a (которую вы хотите отменить),  доста-          
     точно указать в командной строке опцию -a-  и  использовать  файл          
     конфигурации без изменения.                                                
                                                                                
          Поясним комбинирование  и  отмену  опций  командной строки и          
     TURBOC.CFG. Концептуально  список опций файла TURBOC.CFG разбива-          
     ется на две части:                                                         
                                                                                
          - паpаметpы -I и -L                                                   
                                                                                
          - все дpугие паpаметpы в файле.                                       
                                                                                
          В некотоpых  случаях паpаметpы командной стpоки пpосматpива-          

                         - 117,118 -
                                                                                
     ются слева напpаво, действует следующее пpавило:                           
                                                                                
          - для  некотоpых  паpаметpов, котоpыми не являются паpаметpы          
     -I и  -L,  дублиpование  спpава  аннулиpует те же паpаметpы слева          
     (таким обpазом пеpеключатель Off спpава  аннулиpует пеpеключатель          
     On слева).                                                                 
                                                                                
          - паpаметpы -I и -L слева,  однако, бывают случаи, когда они          
     пеpеносятся впpаво.                                                        
                                                                                
          Когда паpаметpы  из  файла  конфигуpации   комбиниpуются   с          
     паpаметpами командной стpоки,  паpаметpы -I и -L из TURBO.CFG по-          
     мещаются в пpавой части командной стpоки, а остальные паpаметpы -          
     в левой части командной стpоки сpазу же после команды tcc.                 
                                                                                
          Таким обpазом,  так как командная стpока и TURBOC.CFG комби-          
     ниpуются, паpаметpы -I и -L TURBOC.CFG находятся в кpайней пpавой          
     части, то включающие и библиотечные каталоги, указанные в команд-          
     ной стpоке,  являются каталогами,  котоpые Туpбо Си  будет  пpос-          
     матpивать в пеpвую очеpедь.  Это дает пpиоpитет -I и -L каталогам          
     в командной стpоке  над  указанными  в  файле  конфигуpации.  Все          
     дpугие паpаметpы из файла TURBOC.CFG включаются в левую часть ко-          
                                                                                
                                                                                
     мандной стpоки,  котоpые также имеют пpиоpитет над  указанными  в          
     TURBOC.CFG.                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 119,120 -
                                                                                
               TCCONFIG -  утилита  для  пpеобpазования  файлов                 
                           конфигуpации                                         
     -----------------------------------------------------------------          
                                                                                
                                                                                
          Интегpиpованная сpеда и  стpоковый  компилятоp  имеют  общие          
     паpаметpы, котоpые  пеpечислены  в  таблице  C.1  пpиложения  C в          
     "Справочном руководстве по Турбо Си",  "TCC  паpаметpы  командных          
     стpок". TCCONFIG.EXE беpет файл конфигуpации, созданный для одно-          
     го окpужения и пpеобpазует его для использования с дpугим.                 
                                                                                
          Команда пpеобpазования:                                               
                                                                                
          TCCONFIG исходный файл [файл назначения]                              
                                                                                
          TCCONFIG автоматически  опpеделяет  напpавление пpеобpазова-          
     ния:  пpовеpяет исходный файл, является ли он файлом конфигуpации          
     сpеды (TC) или файлом конфигуpации стpокового компилятоpа (TCC).           
                                                                                
          Опpеделение имени файла является  необязательным.   Если  не          
     указывать имени  файла,   то TCCONFIG использует имя по умолчанию          
     TCCONFIG.TC или TURBOC.CFG в зависимости от напpавления  пpеобpа-          
                                                                                
                                                                                
     зования. Вы  можете задать любое имя файла; однако стpоковый ком-          
     пилятоp пpи его запуске ждет файл только TURBOC.CFG. С любым дpу-          
     гим именем он pаботать не будет.                                           
                                                                                
          Когда TCCONFIG  создает файл TCCONFIG.TC,  он использует за-          
     данные по умолчанию значения для некотоpых паpаметpов, не опpеде-          
     ленные файлом конфигуpации (TURBOC.CFG) стpокового компилятоpа.            
                                                                                
          TCCONFIG после  того,   как  пpеобpазование будет выполнено,          
     возвpатит вас в DOS.                                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 121,122 -
                                                                                
               Утилита МАКЕ.                                                    
     -----------------------------------------------------------------          
                                                                                
          Самостоятельная утилита Турбо Си МАКЕ, является более мощной          
     версией Projekt-Make.  Она позволяет описывать зависимости исход-          
     ных и объектных файлов аналогично утилите МАКЕ системы UNIX. Ути-          
     лита  МАКЕ  оценивает указанные зависимости и  проверяет правиль-          
     ность компиляции и компоновки файлов.                                      
                                                                                
          В чем преимущество использования утилиты МАКЕ? Так же, как и          
     при создании проектов, вам нет необходимости следить за изменени-          
     ем компонентов программы.  Самостоятельная утилита МАКЕ,  однако,          
     обладает большими возможностями,  чем процедура создания проектов          
     Projekt-Make, поскольку она является конструктором программ обще-          
     го назначения.  Перед компоновкой объектных файлов вашей  сложной          
     программы она перекомпилирует все файлы,  требующие обновления, а          
     затем просто объединяет вновь компилированные файлы с теми, кото-          
     рые не   нуждаются в перекомпиляции,  и создает новый выполняемый          
     программный файл.                                                          
                                                                                
          Для получения полной информации о МАКЕ вам необходимо прочи-          
     тать Приложение D в "Справочном руководстве".  Это приложение со-          
                                                                                
                                                                                
     держит детальное разъяснение самостоятельной утилиты МАКЕ.                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 123,124 -
                                                                                
               BUILTINS.MAK                                                     
     ----------------------------------------------------------------           
                                                                                
          BUILTINS.MAK является необязательным файлом,  в  котоpом  вы          
     можете сохpанить MAKE- макpосы и пpавила,  котоpые вы используете          
     каждый pаз,  таким обpазом у вас нет необходимости хpанить  их  в          
     ваших make-файлах. Для получения инфоpмации о написании make-фай-          
     лов и установки файла BUILTINS.MAK смотpите пpиложение D в "Turbo          
     C Reference Guide".                                                        
                                                                                
                                                                                
                                                                                
               Запуск программ Турбо Си из командной строки DOS.                
     -----------------------------------------------------------------          
                                                                                
          Для запуска  выполняемой  программы  Турбо  Си  из командной          
     строки DOS введите просто ее имя в ответ на приглашение DOS. Рас-          
     ширение .EXE можно не указывать.  Например,  для выполнения прог-          
     раммы TEST.EXE необходимо ввести только test и нажать Ввод. После          
     этого программа TEST начнет выполняться.                                   
                                                                                
                                                                                
                                                                                
               Теперь все вместе: вперед с Турбо Си.                            
     ----------------------------------------------------------------           
                                                                                
          Теперь,  после знакомства  с процессами компиляции, компоно-          
     вки,  запуска и создания программ Турбо Си  как в интегрированной          
     среде,  так и при помощи стандартной командной  строки, вы можете          
     считать себя подготовленными к работе с Турбо Си.  По мере расши-          
     рения ваших знаний о языке и конкретно Турбо Си,  вы захотите пе-          
     рейти ко второму тому этой книги - "Справочному руководству",   в          
     котором описывается среда выполнения, библиотечные файлы, передо-          
     вая технология программирования и реализация  Си  системой  Турбо          
     Си.                                                                        
                                                                                
          Если  вы  знакомы с Турбо Паскалем  или  Турбо Прологом,  то          
     вас могут заинтересовать также главы  9 и  10,  соответственно, в          
     которых рассказано о том,  как использовать эти языки совместно с          
     быстрым и мощным пакетом программирования Турбо Си.                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 125,126 -
                                                                                
                                 ГЛАВА 4                                        
                                 -------                                        
                                                                                
                            ОТЛАДКА ПРОГРАММ                                    
     -----------------------------------------------------------------          
                                                                                
          Когда, после исправления всех ошибок компиляции и  компонов-          
     ки, вы впервые запустите свою программу - вероятность ее правиль-          
     ной работы будет очень мала.  Новая программа почти всегда содер-          
     жит многочисленные ошибки - логические и концептуальные - которые          
     вы должны найти и исправить.  Процесс поиска и исправления ошибок          
     называется отладкой.                                                       
                                                                                
          Очень сложно найти ошибки, наблюдая за "поведением" програм-          
     мы,  поэтому для их обнаружения в  своих  программах  большинство          
     программистов  используют  отладчик.  Отладчик  - это программное          
     средство,  позволяющее управлять программой во время ее  выполне-          
     ния. С помощью отладчика вы можете остановить выполнение програм-          
     мы в любой точке, выполнить отдельный оператор и просмотреть зна-          
     чения данных, на которые этот оператор воздействовал.                      
                                                                                
                                                                                
                                                                                
               В этой главе ...                                                 
     -----------------------------------------------------------------          
                                                                                
          Интегрированная среда Турбо Си  включает  отладчик,  который          
     называется интегрированным отладчиком.  В этой главе мы объясним,          
     как пользоваться отладчиком Турбо Си.                                      
                                                                                
          Глава начинается с серии примеров,  демонстрирующих примене-          
     ние  отладчика.  В первом примере показаны простейшие возможности          
     распознавания "легких" ошибок.  И следующие примеры  иллюстрируют          
     более сложные возможности отладчика.                                       
                                                                                
          Затем будет рассмотрено меню команд отладчика с соответству-          
     ющими "горячими" клавишами или комбинациями "горячих"  клавиш,  а          
     также будет дано описание каждой команды.                                  
                                                                                
          И, наконец, мы дадим несколько советов, облегчающих отладку.          
     Многие из этих советов касаются не только самого процесса  отлад-          
     ки,  но и того,  как вообще лучше писать программы, поэтому боль-          
     шинство из этих идей вы можете применять не только в Турбо Си, но          
     и в любых других языках программирования.                                  
                                                                                

                         - 127,128 -
                                                                                
               Как работает интегрированный отладчик                            
     -----------------------------------------------------------------          
                                                                                
          Интегрированный отладчик Турбо Си - это символьный отладчик,          
     работающий в терминах языка программирования.  Это значит, что вы          
     можете "общаться" с отладчиком с помощью того же языка,  на кото-          
     ром написана ваша программа.  Например, вы можете просмотреть ве-          
     личину элемента массива, указав его отладчику с помощью следующе-          
     го выражения:                                                              
                                                                                
          rptr->image[nptr+0x80]                                                
                                                                                
          Отлаживать свою программу вы сможете просто  запустив  ее  с          
     помощью  элемента меню Run/Run ("горячая" клавиша Ctrl-F9).  При-          
     чем,  для подключения отладчика к вашей программе,  необходимо ее          
     откомпилировать  с  "установленным"  (On)  вариантом  меню Source          
     Debugging.   (Установить   этот   вариант   меню   можно   выбрав          
     Debug/SOURCE Debugging).                                                   
                                                                                
          Перед выполнением программы вы можете установить в ней точки          
     останова,  указав их в одной  или  нескольких  строках  исходного          
     текста  вашей  программы.  Когда  отлаживаемая программа встретит          
                                                                                
     точку останова, она остановится перед первым оператором строки, в          
     которой эта точка задана,  и возвратит вам управление отладчиком.          
                                                                                
          В момент  остановки программы вы можете выполнять самые раз-          
     личные действия. Например, вы можете:                                      
                                                                                
          # вывести значение переменной или выражения;                          
                                                                                
          # задать в специальном окне список выражений и наблюдать за           
     изменениями их значений;                                                   
                                                                                
          # изменить значение переменной;                                       
                                                                                
          # удалить  существующую  точку останова или  задать новую;            
                                                                                
          # выполнить одну строку программы;                                    
                                                                                
          # исправить файл,  перекомпилировать и перекомпоновать прог-          
     рамму или использовать любые другие возможности меню системы Тур-          
     бо Си;                                                                     
                                                                                
          # продолжить выполнение программы до тех пор, пока не встре-          

                         - 129,130 -
                                                                                
     тится другая точка останова.                                               
                                                                                
          Рисунок 4.1 иллюстрирует типичный алгоритм  сеанса  отладки.          
     (Заметьте, что на нем не показаны возможности отладчика на каждом          
     отдельном шаге.)                                                           
                                                                                
                             ┌─────────────────────┐                            
                             │Написание или модифи-│                            
                             │  кация программы    │                            
                             └──────────┬──────────┘                            
          ┌─────────────────────────────┤                                       
          │                 ┌───────────┴─────────────────┐                     
          │                 │Создание (компиляция и компо-│                     
          │                 │      новка) программы       │                     
          │                 └───────────┬─────────────────┘                     
          │                             │                                       
          │                                                                     
          │                                                                     
       ┌──┴────────┐   Да             Ошибки                                    
       │Исправление├───────      компиляции и/или                               
       │  ошибок   │              редактирования ?                              
       └──┬────────┘                                                            
                                                                                
          │                             │                                       
          │                             │Нет                                    
          │                             │                                       
          │                  ┌──────────┴─────────────┐                         
          │                  │Задание или изменение   │                         
          │                  │   точек останова       │                         
          │                  └──────────┬─────────────┘                         
          │                  ┌──────────┴────────┐                              
          │                  │  Запуск программы │                              
          │                  └──────────┬────────┘                              
          │                             │                                       
          │                             │                                       
     ┌────┴──────┐                                                              
     │Исправление│                    Ошибки         Нет  ┌─────────┐           
     │  ошибок   │                  выполнения ?──────────┤ Останов │           
     └────┬──────┘                                        │         │           
          │                             │                 └─────────┘           
          │                             │ Да                                    
          │                             │                                       
          │                  ┌──────────┴────────┐                              
          └──────────────────┤Отладка  программы │                              
                             └───────────────────┘                              

                         - 131,132 -
                                                                                
                                                                                
                                                                                
              Рисунок 4.1: Типичный алгоритм процесса отладки                   
                                                                                
                                                                                
          Пример 1: Отладка простой программы.                                  
                                                                                
          Для получения  первого опыта отладки с помощью Турбо Си,  вы          
     можете воспользоваться программой, приведенной ниже. Мы ее назва-          
     ли WORDCNT. Она выводит содержимое текстового файла и подсчитыва-          
     ет длины его слов,  то есть сообщает о том,  сколько в этом файле          
     есть слов,  состоящих из одной,  двух и т.д.  букв.  К несчастью,          
     WORDCNT содержит несколько ошибок,  и вы должны их найти, исполь-          
     зуя для этой цели отладчик.                                                
                                                                                
          Программа WORDCNT  находится  в  файле WORDCNT.C на одном из          
     дистрибутивных дисков. Для того, чтобы сохранить ее "нетронутой",          
     скопируйте ее в ваш каталог Турбо Си.                                      
                                                                                
          Если вы  работаете  в каталоге,  не содержащем Турбо Си,  то          
     сделайте  в  нем  рабочие  копии  файлов  проекта   WORDCNT.C   и          
     WORDCNT.PRJ. Все три файла должны быть на дистрибутивных дисках и          
                                                                                
     в вашем каталоге Турбо Си.                                                 
                                                                                
     /*****                                                                     
     *  Read a text file; count the numberof words of length 1, 2, 3,           
     *  etc. (Прим. Диалог с пользователем здесь адаптирован, на                
     *              дистрибутивных дисках - нет )                               
     * Note: This programm is for use with the debugging tutorial               
     *       in the debbuging chapter of the User's Guide. It                   
     *       intetionally contains bugs.                                        
     *****/                                                                     
                                                                                
     #include <stdio.h>                                                         
     #include <ctype.h>                                                         
                                                                                
     #define MAXWORDLEN  16                                                     
     #define NULL        ((char)0)                                              
     #define SPACE       ((char)0x20)                                           
                                                                                
     /*****                                                                     
     * Find the next word in the line buffer.                                   
     * IN:      wordptr points to the first character of a word or a            
     *          preceding space.                                                

                         - 133,134 -
                                                                                
     * RETURN:  A pointer to the first character of the word. If there          
     *          are no more words, a pointer to the terminating NUL.            
     *****/                                                                     
                                                                                
     char *nextword(char *wordptr)                                              
     {                                                                          
     /* Advance to the first non-space. */                                      
          while ( *wordptr==SPACE )                                             
               wordptr++;                                                       
          return (wordptr);                                                     
     }                                                                          
     /*****                                                                     
     * Find the length of a word. A word is defined as sequence of              
     * characters terminated by a space or a NUL.                               
     * IN: wordptr points to a word.                                            
     * RETURN: The length of the word.                                          
     *****/                                                                     
                                                                                
     int wordlen(char *wordptr)                                                 
     {                                                                          
          char *wordlimit;                                                      
                                                                                
                                                                                
          wordlimit = wordptr;                                                  
          while ( *wordlimit & *wordlimit!=SPACE )                              
               *wordlimit++;                                                    
          return(wordlimit-wordptr);                                            
     }                                                                          
                                                                                
     /*****                                                                     
     * The main function.                                                       
     *****/                                                                     
                                                                                
     void main(void)                                                            
     {                                                                          
          FILE        *infile;         /* Input file. */                        
          char        linebfr[1024],   /* Input line buffer, very               
                                          long for safety */                    
                      *wordptr;        /* Pointer to next word in               
                                          linebfr */                            
          int            i;            /* Scratch variable. */                  
          static int  wordlencnt[MAXWORDLEN],                                   
                                                                                
                           /* Word lengths are counted in elements 1            
                              to MAXWORDLEN. Element 0 isn't used.              

                         - 135,136 -
                                                                                
                              The array is static so that the elements          
                              need not be set to zero at run time. */           
                                                                                
                      overlencnt; /* Overlength words are counted               
                                     here. */                                   
                                                                                
     printf("Эта программа предлагается в качестве примера для\n");             
     printf("проведения практического занятия по отладке\n");                   
     printf("Если вы не хотите ее выполнить под управлением\n");                
     printf("интегрированной среды, нажмите Ctrl-Break.\n");                    
     printf("Смотрите главу Отладка программ Руководства");                     
     printf("пользователя для уточнения деталей.\n\n");                         
                                                                                
          printf("Введите имя файла: ");                                        
          gets(linebfr);                                                        
          if ( !strlen(linebfr) ) {                                             
               printf("Вы должны указать имя файла !\n");                       
               exit();                                                          
          }                                                                     
                                                                                
          infile = fopen( linebfr,"r" );                                        
          if ( !infile ) {                                                      
                                                                                
               printf("Файл нельзя открыть !\n");                               
               exit();                                                          
          }                                                                     
                                                                                
          /* Each loop processes one line. NOTE: If a line is longer            
          than the  input  buffer,  the  program  may  produce invalid          
          results. The very large buffer makes this unlikely. */                
                                                                                
          while (  fgets( linebfr, sizeof(linebfr), infile ) ) {                
               printf("%s\n",linebfr);                                          
          /* Check for buffer overflow & remove the  trailing newline.          
          */                                                                    
               i=strlen(linebfr);                                               
               if ( linebfr[i-1] != '\n' ) {                                    
                printf("Длина строки превышает максимальную");                  
                printf("\n\t%70s\n",linebfr); }                                 
               else                                                             
                linebfr[i-1] = NULL;                                            
                                                                                
           /* lineptr points to the 1st word in linebfr (past leading           
              spaces). */                                                       
                wordptr = nextword(linebfr);                                    

                         - 137,138 -
                                                                                
                                                                                
           /* Each loop processes one word. The loop ends when                  
              [nextword] returns NULL, indicating there are more                
              words. */                                                         
               while (*wordptr) {                                               
               /* Find the length of this word, increment the proper            
                  element of the length count array, and point to the           
                  space following the word .*/                                  
                    i=wordlen(wordptr);                                         
                    if ( i > MAXWORDLEN )                                       
                         overlencnt++;                                          
                    else                                                        
                         ;                                                      
                         wordlencnt[i]++;                                       
                    wordptr += i;                                               
                /* Find the next word (if any). */                              
                    wordptr = nextword(wordptr);                                
               }                                                                
          }                                                                     
                                                                                
          /* Print the word length counts. Each loop prints one. */             
          printf("Длина  Количество\n");                                        
                                                                                
          for ( i=1, i=MAXWORDLEN, i++)                                         
               printf(" %5d %5d\n", i, wordlencnt[i] );                         
          printf("Остальные %5d\n", overlencnt );                               
                                                                                
          /* Close the file and quit. */                                        
          fclose(infile);                                                       
     }                                                                          
                                                                                
          Убедитесь в  том,  что  опции   Debug/Source   Debugging   и          
     O/C/C/OBJ Debug Information были включены (On).  В ответ на приг-          
     лашение DOS запустите Турбо Си с помощью следующей команды                 
                                                                                
          TC WORDCNT                                                            
                                                                                
     в ответ  на   приглашение   DOS.   Создайте   программу   (выбрав          
     Compiler/Build  All).  Турбо  Си выполнит компиляцию и компоновку          
     программы WORDCNT,  тем самым подготовив ее для выполнения, а за-          
     тем остановится. Теперь выберите элемент меню Run/Trace Into (или          
     нажмите F7).                                                               
                                                                                
          В этот момент отладчик разместит в окне  редактирования вашу          
     программу так,  чтобы было видно начало функции main. Строка, со-          

                         - 139,140 -
                                                                                
                                                                                
     держащая объявление функции main (void main(void)), будет выделе-          
     на  (цветом),  свидетельствуя о том,  что при запуске WORDCNT она          
     будет выполнена первой.  Эта выделенная строка называется "марке-          
     ром выполнения",  фиксирующим текущую позицию программы:  строку,          
     содержащую оператор, который будет выполнен следующим.                     
                                                                                
          Для того, чтобы выполнить WORDCNT, выберите Run/Run. WORDCNT          
     предложит  вам ввести имя входного файла.  Наберите WORDCNT.DAT и          
     нажмите Ввод.  WORDCNT считает и выведет первую строку файла дан-          
     ных,  а  затем  ваш компьютер "зависнет",  т.к.  в программе есть          
     ошибки.  Нажав Ctrl-Break и затем Esc, вы разблокируете компьютер          
     и сможете продолжить работу.  Для завершения сеанса отладки необ-          
     ходимо выбрать Run/Program Reset (или  нажать  "горячую"  клавишу          
     Ctrl-F2),  а  для возобновления отладки - Run/Trace Into (или на-          
     жать F7).                                                                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Установка и использование точки останова                         
     -----------------------------------------------------------------          
                                                                                
          Первая часть функции main,  согласно комментариям в исходном          
     тексте программы,  выдает приглашение для  ввода  имени  входного          
     файла  и открывает этот файл.  Тот факт,  что WORDCNT считывает и          
     выводит первую строку входного файла свидетельствует о правильной          
     работе этой части программы,  по крайней мере, она не причастна к          
     наблюдаемой ошибке. Поэтому вы можете выполнить первую часть main          
     и  остановиться,  когда достигнете подозрительных,  с вашей точки          
     зрения,  строк программы.  Для этого,  вы должны установить точку          
     останова в той строке, где хотите остановиться.                            
                                                                                
          Используя клавиши PgDn и "стрелка вниз",  переместите курсор          
     в строку, начинающуюся с                                                   
                                                                                
          while(fgets(...                                                       
                                                                                
     (эта строка находится сразу же за комментарием,  начинающимся  со          
     слов "Each loop proceess...")                                              
                                                                                
          Обратите внимание,  что  маркер выполнения не движется.  Это          

                         - 141,142 -
                                                                                
     происходит из-за того,  что никакие операторы программы не выпол-          
     няются; вы лишь перемещаете курсор редактора.                              
                                                                                
          Для того, чтобы установить точку останова, необходимо помес-          
     тить   курсор   в   нужную   строку   и   выбрать    Break/Watch/          
     TOGLE/Breakpoint   (или   нажать   комбинацию   "горячих"  клавиш          
     Ctrl-F8).  Отладчик выделит указанную строку (цветом),  что будет          
     свидетельствовать об установке в этой строке точки останова.  За-          
     метьте, что строка,  в которой находится точка останова и  маркер          
     выполнения, выделяются по-разному (разными цветами).                       
                                                                                
          Выберите Run/Run  (или  нажмите Ctrl-F9) и WORDCNT продолжит          
     свою работу (в данном случае - с самого начала). После выдачи со-          
     общения о необходимости ввода имени входного файла, WORDCNT оста-          
     новится и будет ожидать ввода с клавиатуры.  Отладчик выводит со-          
     общение  WORDCNT  на  экран  выполнения  (Execution),  на который          
     сообщения WORDCNT выдаются так,  как если бы ее работа  протекала          
     без отладчика.  Наберите WORDCNT.DAT и нажмите Ввод. WORDCNT про-          
     должит выполнение до тех пор,  пока не встретится точка останова;          
     затем  она остановится и на экране вновь появится окно редактиро-          
     вания (Edit).  Курсор и маркер выполнения будут указывать на опе-          
     ратор while.                                                               
                                                                                
                                                                                
                                                                                
          Заметим, что установленная вами на операторе while точка ос-          
     танова не исчезла, вы просто не видите ее, потому что ее заслонил          
     маркер выполнения,  но она вновь появится после того,  как маркер          
     выполнения переместится дальше. Каждый раз, "доходя" до этой точ-          
     ки останова,  WORDCNT будет останавливаться.  И это будет продол-          
     жаться до тех пор, пока вы ее не "выключите".                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 143,144 -
                                                                                
               Использование Ctrl-Break                                         
     -----------------------------------------------------------------          
                                                                                
          Помимо всех  заданных вами точек останова вы можете восполь-          
     зоваться во время выполнения программы "моментальной" точкой  ос-          
     танова, нажав Ctrl-Break. Используя это средство, вы можете оста-          
     навливать программу в любой момент времени.  Когда  вы  нажимаете          
     Ctrl-Break,  вы  выходите из программы и возвращаетесь в редактор          
     Турбо Си,  причем маркер выполнения находится на строке,  которая          
     должна  быть  выполнена в следующий раз,  а сама программа готова          
     продолжить свою работу.                                                    
                                                                                
          Объясним, как в действительности происходит останов програм-          
     мы при нажатии Ctrl-Break.                                                 
                                                                                
          В процессе своей работы отладчик взаимодействует с DOS, BIOS          
     и другими частями операционной системы; поэтому ему известно, что          
     работает в данный момент времени (подпрограмма DOS,  функция BIOS          
     или же именно фрагмент вашей программы).  После того, как вы наж-          
     мете Ctrl-Break,  отладчик дождется,  чтобы заработала непосредс-          
     твенно ваша программа. Затем, на уровне инструкций микропроцессо-          
     ра,   он   сделает   несколько   шагов,   чтобы  дойти  до  кода,          
                                                                                
                                                                                
     соответствующему началу исходной строки на  Си.  И  только  после          
     всего  этого он остановится и переведет маркер выполнения на дан-          
     ную строку.                                                                
                                                                                
          Если же вы повторно нажмете Ctrl-Break прежде,  чем отладчик          
     найдет и укажет строку программы, то он немедленно прервет работу          
     программы и не будет пытаться найти строку  исходного  текста.  В          
     этом случае,  программа останавливается без завершения своего вы-          
     вода и вызова какой-либо функции выхода. (Что аналогично заверше-          
     нию работы программы, выполняемому с помощью функции _exit). Поэ-          
     тому,  дважды нажимать Ctrl-Break вам следует лишь  тогда,  когда          
     программа "зациклилась" и одно нажатие ее не останавливает.                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 145,146 -
                                                                                
               Пошаговое выполнение "через функции"                             
     -----------------------------------------------------------------          
                                                                                
          Теперь, когда вы достигли той части WORDCNT, в которой могут          
     быть ошибки,  необходимо быть очень внимательным. Данный фрагмент          
     main будет обрабатывать по одной строке, сравнивая получаемые ре-          
     зультаты с желаемым эффектом.                                              
                                                                                
          Для того, чтобы выполнить одну строку main выберите Run/Step          
     Over.  Отладчик отработал оператор while и считает первую  строку          
     входного файла.  Затем он переместит маркер выполнения на следую-          
     щую строку, содержащую исполняемые операторы. Повторно воспользо-          
     вавшись   Run/Step   Over   можно  выполнить  следующий  оператор          
     (printf).                                                                  
                                                                                
          Привело ли к желаемому эффекту выполнение  оператора  while?          
     Для того,  чтобы определить это,  выберите вариант User Screen из          
     меню Run, или нажмите Alt-F5. В результате этой команды вы увиде-          
     те экран выполнения.  Т.к.  на этом экране видна первая считанная          
     из файла строка,  вы можете сделать вывод,  что и while и  printf          
     работают  правильно.  Для  возврата в окно редактирования нажмите          
     любую клавишу.                                                             
                                                                                
                                                                                
                                                                                
          "Горячей" клавишей для команды Run/Step  Over  является  F8.          
     Поэтому, для выполнения очередного оператора нажмите F8, что при-          
     ведет к вычислению длины введенной строки, значение которой прис-          
     воится переменной i.                                                       
                                                                                
          Внимание! "трассирование  в"  или  "шаг  через" библиотечную          
     функцию longjmp не приведет к остановке на следующей строке прог-          
     раммы (т.к. эта функция никогда не возвращается). По этой причине          
     ваша программа (в этом случае)  будет  выполняться  до  следующей          
     точки останова или до самого конца.                                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 147,148 -
                                                                                
               Вычисление выражений                                             
     -----------------------------------------------------------------          
                                                                                
          Приводит ли выполнение оператора  присваивания  к  желаемому          
     результату?  Узнать это можно оценив значение переменной i. Выбе-          
     рите Debug/Evaluate.  Отладчик откроет окно содержащее три  поля.          
     Мы будем называть эти поля в соответствии с присвоенными им функ-          
     циями:                                                                     
                                                                                
          1. Поле Evaluate (вычислений): сюда вы вводите те выражения,          
     которые вы хотите вычислить и,  возможно,  изменить.  (Замечание:          
     Если длина вашего выражения превышает размер поля  вычислений, то          
     для  его просмотра вы можете воспользоваться клавишами управления          
     курсором).                                                                 
                                                                                
          2. Поле RESULT (результата):  в это  поле  отладчик  выводит          
     вычисленное значение.                                                      
                                                                                
          3. Поле  NEW VALUE (нового значения):  в этом поле вы можете          
     присвоить своему выражению новое значение (при необходимости).             
                                                                                
          Отметим, что в поле вычислений инидицируется слово. Это сло-          
                                                                                
     во, перенесенное  в данное поле из текущей позиции курсора в окне          
     редактирования, является значением поля вычислений,  принятым  по          
     умолчанию. Мы  сразу же можем воспользоваться им.  Однако в нашем          
     случае, введите выражение i и нажмите Ввод. В поле результата от-          
     ладчик поместит значение переменной i. Оно равно 43, что является          
     правильным. Для выхода из системы меню нажмите F10.                        
                                                                                
          Следующая группа операторов программы проверяет,  заканчива-          
     ется ли  символом новой строки строка,  считанная функцией fgets.          
     Если нет,  то можно сделать вывод,  что считанная строка является          
     слишком длинной для имеющегося буфера,  и, поэтому, программа вы-          
     ведет соответствующее предупреждение. В противном же случае - все          
     в порядке. Программа удалит из строки найденный символ окончания,          
     для того, чтобы он не был включен в размер последнего слова.               
                                                                                
          Перед выполнением оператора if было бы очень полезно  взгля-          
     нуть на введенную строку,  для того чтобы узнать, что нужно ждать          
     от выполнения этого оператора.  Установите курсор в окне редакти-          
     рования   над  словом  linebfr  и  снова  выберите  элемент  меню          
     Debug/Evaluate (или же "горячую" клавишу Ctrl-F4). Отладчик выве-          
     дет в появившееся окно (в поле вычислений) слово "linebfr".  Наж-          
     мите Ввод.                                                                 

                         - 149,150 -
                                                                                
                                                                                
                                                                                
          Отладчик выведет:                                                     
                                                                                
          To be or not to be: that is the question.\n                           
                                                                                
          Точно также,  как и в исходных текстах Си-программы, обозна-          
     чение "\n" соответствует символу конца строки.                             
                                                                                
          Теперь, нажав F8,  обработайте оператор if.  В случае,  если          
     этот оператор сработает правильно,  маркер выполнения должен  пе-          
     редвинуться на предложение "else".  Выполните оператор присваива-          
     ния (под else),  а затем вновь просмотрите linebfr. (Для этого вы          
     можете использовать  Ctrl-F4  или  элемент  меню Debug/Evaluate).          
     Символ новой строки (\n) должен быть удален.  Ну  и  слава  богу,          
     пойдем дальше.                                                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Функции nextword и wordlen                                       
     -----------------------------------------------------------------          
                                                                                
          Следующий оператор вызывает функцию  nextword.  Эта  функция          
     определяет положение очередного (в данном случае - первого) слова          
     в строке.  Обработайте этот оператор,  используя F8, а затем пос-          
     мотрите wordptr  для того,  чтобы узнать что же вернула nextword.          
     Вы можете убедиться, что wordptr указывает на T в строке To be or          
     not to be:  that is the question. Если это так, то nextword рабо-          
     тает правильно, по крайней мере в этом простом случае.                     
                                                                                
          Следующим фрагментом программы является цикл  while.  Каждая          
     итерация  этого  цикла должна обрабатывать одно слово из linebfr,          
     знаращивая при этом wordptr так,  чтобы он указывал на новое сло-          
     во. После  того,  как таким образом в этом цикле будет обработано          
     последнее слово, wordptr должен указывать на ограничивающий стро-          
     ку null символ, а сам цикл должен завершиться.                             
                                                                                
          Выполните  оператор while. Маркер выполнения переместится на          
     первый оператор в теле цикла,  который вызывает функцию  wordlen.          
     Эта функция определяет длину слова, на которое указывает wordptr.          
     Выполните оператор и оцените значение переменной  i.  Значение  i          

                         - 151,152 -
                                                                                
                                                                                
     равно 0, что является неправильным; длина первого слова обрабаты-          
     ваемой строки должна быть равна 2. Мы нашли ошибку!                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Остановимся и подумаем                                           
     -----------------------------------------------------------------          
                                                                                
          Прежде чем вы исправите найденную ошибку, давайте обсудим ее          
     влияние на отлаживаемую программу.  Некорректная длина слова  (0)          
     "имеет" два значение. Во-первых, из-за нее неправильно увеличится          
     значение нулевого элемента массива wordlencnt. А во-вторых, нуле-          
     вая длина приведет к тому,  что после обработки оператора wordptr          
     += i,  значение указателя wordptr не изменится. Из-за этого, вто-          
     рая итерация  цикла  loop  начнется  с  тем  же  самым  значением          
     wordptr, что и в первой.  Поэтому,  точно также как и при  первом          
     обращении к  wordlen (когда она вернула 0),  повторный вызов этой          
     функции также возвратит все тот  же  0.  Следовательно,  значение          
     wordptr останется неизменным и в третьей итерации цикла loop, и в          
     четвертой, и в последующих. Таким образом, найденная ошибка явля-          
     ется причиной "зависания" вашего компьютера.                               
                                                                                
          Какой вывод  можно сделать из проведенного исследования?  Вы          
     можете подумать, что найденная ошибка объясняет только часть неп-          
     равильной работы WORDCNT или же, что неправильная работа програм-          
     мы объясняется не только найденной ошибкой.  Для того, чтобы уви-          
     деть, что  же  происходит  дальше,  в  обоих  случаях  вы  можете          

                         - 153,154 -
                                                                                
                                                                                
     захотеть вновь запустить программу.  Сделав это, вы захотите сос-          
     редоточиться на обнаружении новых ошибок, причем, понятно, вы за-          
     хотите, чтобы уже просмотренный фрагмент программы  работал  пра-          
     вильно.                                                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Что же делать?                                                   
     -----------------------------------------------------------------          
                                                                                
          Вы выяснили,  что неправильная  работа  WORDCNT  объясняется          
     ошибкой в функции wordlen.  Кроме того вы точно определили, в чем          
     выражается неправильная работа этой функции.  Чуть позже мы  вер-          
     немся к этим рассуждениям, а сейчас давайте познакомимся с коман-          
     дами отладчика. В процессе вашей первой попытки отладки программы          
     WORDCNT вы делали следующее:                                               
                                                                                
          # убеждались в том, что опции Debug/Source Debugging и O/C/C          
            /OBJ Debug включены (On).                                           
                                                                                
          # для подготовки WORDCNT к  отладке  выбирали Compiler/Build          
            All.                                                                
                                                                                
          # пользуясь командами редактора, перемещали курсор на нужные          
            фрагменты WORDCNT;  выбирали Break/Watch/Toggle Breakpoint          
            для установки точек останова в позиции курсора; для запус-          
            ка WORDCNT до заданной точки останова пользовались Run/Run          
            (или же "горячей" клавишей Ctrl-F9).                                
                                                                                

                         - 155,156 -
                                                                                
                                                                                
          # пользовались  Run/USER SCREEN или Alt-F5 для просмотра вы-          
            ходных данных вашей программы на  пользовательском экране.          
                                                                                
          # для обработки операторов функции  main  (по  одной  строке          
            программы  за шаг) выбирали Run/Step Over (или же нажимали          
            "горячую" клавишу F8).                                              
                                                                                
          # выбрав Debug/Evaluate (или нажав  Ctrl-F4),  просматривали          
            значения нескольких переменных.                                     
                                                                                
          # проанализировав найденную ошибку,  сделали вывод,  что она          
            объясняет некорректную работу WORDCNT и,  поэтому, требует          
            немедленного исправления.                                           
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Содержимое окна вычислений, установленное по умолчанию           
     -----------------------------------------------------------------          
                                                                                
          Напомним, что выбор Debug/Evaluate переносит в поле вычисле-          
     ний  слово,  на  которое  указывает курсор в окне редактирования.          
     Благодаря этому,  вы можете облегчить себе работу, если перед об-          
     ращением к Debug/Evaluate установите курсор над переменной , зна-          
     чение которой вы хотите оценить. Даже если все выражение, которое          
     вы хотите вычислить, является весьма сложным, то вы можете значи-          
     тельно ускорить его ввод,  если будете редактировать принятое  по          
     умолчанию  в окно вычислений выражение,  а не вводя его на пустом          
     месте.  Более того,  нажимая клавишу со стрелкой вправо вы можете          
     "перенести" из окна редактирования в окно вычислений еще несколь-          
     ко требуемых вам символов.  Каждый раз,  когда вы будете нажимать          
     эту клавишу, будет выполняться перенос одного символа.                     
                                                                                
          Например, пусть   вы  хотите  вычислить  значение  выражения          
     linebfr[i-1], которое находится в следующей строке исходного фай-          
     ла:                                                                        
                                                                                
          if (linebfr[i-1] != '\n' )                                            
                                                                                

                         - 157,158 -
                                                                                
                                                                                
          Для этого   переместите   курсор   к   linebfr   и  выберите          
     Debug/Evaluate.  В поле вычислений (Evaluate)  будет  скопировано          
     слово linebfr. Нажав пять раз клавишу со стрелкой вправо, добавь-          
     те к этому слову [i-1], затем нажмите Ввод.                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                Изменение значения оцениваемого выражения                       
     -----------------------------------------------------------------          
                                                                                
          Элемент меню Debug/Evaluate способен изменять значения неко-          
     торых типов выражений, а именно, тех выражений, которые соответс-          
     твуют конкретному элементу данных,  например:  i,  linebfr[i] или          
     *(linebfr+i).                                                              
                                                                                
          Попробуем вычислить значение переменной i,  а затем изменить          
     его. После того,  как для получения значения переменной i вы наж-          
     мете Ввод,  отладчик выведет это значение в поле результата.  Пе-          
     рейдите (с помощью клавиши со стрелкой вниз) в поле нового значе-          
     ния и введите в него то значение,  которое вы хотите присвоить i.          
     Например, вы можете ввести i+1 (с целью увеличения i на страницу)          
     или же просто 17.  После того,  как вы нажмете Ввод, отладчик вы-          
     числит введенное вами выражение,  изменит значение i, а затем вы-          
     ведет в поле результата новую  величину.  (Замечание:  Запомните!          
     После того,  как  в поле новой величины в нажмете Ввод,  значение          
     переменной будет измененно в соответствии с  введенным выражением          
     и нажатие  после этого клавиши Esc не приведет к отмене сдаланных          
     изменений.) Для того, чтобы выйти из Debug/Evaluate, нажмите Esc,          
     затем снова  выберите  Debug/Evaluate и посмотрите значение пере-          

                         - 159,160 -
                                                                                
     менной i с тем,  чтобы убедиться в том, что оно изменилось. После          
     этого восстановите   старое   значение   i  и  опять  выйдите  из          
     Debug/Evaluate.                                                            
                                                                                
          Изменив значение какого-либо выражения,  вы можете  избежать          
     проявления программной  ошибки,  что  позволит вам запустить свою          
     программу дальше, в результате чего могут быть найдеты какие-либо          
     дополнительные ошибки.  Кроме  этого изменение значений выражений          
     позволяет исследовать поведение отдельных частей программы. В ка-          
     честве примера предположим, что вы хотите проверить поведение от-          
     дельных частей программы.  Например,  предположим,  что вы хотите          
     проверить поведение  какой-либо  функции,  при передаче ей некор-          
     ректных параметров.  Вполне возможно, что сделать так, чтобы ваша          
     программа передала  в  функцию требуемое для этого значение,  вам          
     сложно, однако вы можете получить нужный результат,  изменив зна-          
     чение какой-либо переменной непосредственно перед тем,  как прог-          
     рамма обратится к проверяемой функции.                                     
                                                                                
          Если для выхода из поля нового  значения  вы  воспользуетесь          
     клавишей Esc  (а  не Ввод),  то отладчик не будет менять значение          
     выражения. Мы советуем вам пользоваться этой клавишей  в  случае,          
     если вы по какой-либо причине изменили свои намерения и решили не          
                                                                                
                                                                                
     вводить нового значения.                                                   
                                                                                
          Вы  можете  вычислить  значение  любого  допустимого   в  Си          
     выражения, при условии, что оно не содержит:                               
                                                                                
          # вызовы функции;                                                     
                                                                                
          # описанные  символы  (с помощью define) или типы (с помощью          
     typedef). Например: *wordptr == 0x20 верно, тогда как *wordptr ==          
     SPACE - не допускается, так как SPACE является описанием);                 
                                                                                
          #  локальные  или  статические  переменные,  находящиеся вне          
     области действия выполняемой функции (за исключением случая, ког-          
     да они полностью специфицированы).                                         
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 161,162 -
                                                                                
               Спецификация имен переменных                                     
     -----------------------------------------------------------------          
                                                                                
          Существует две типичные ситуации,  в которых возникает необ-          
     ходимость подробной спецификации имен переменных, использзуемых в          
     выражении:                                                                 
                                                                                
          # когда вы хотите проконтролировать значения переменных типа          
            static, находящихся в различных модулях;                            
                                                                                
          # или, когда вы хотите просмотреть переменные типа auto (ло-          
            кальные) или типа static, находящиеся в другой функции.             
                                                                                
          Для  полного   описания   имени   переменной  воспользуйтесь          
     следующим синтаксисом:                                                     
                                                                                
          .<имя модуля>.<имя функции>.<имя переменной>                          
                                                                                
          Отметим, что как имя модуля,  так имя функции в определенных          
     случаях могут пропускаться.  Например,  если вы трассируете  свою          
     функцию  main  и  хотите узнать значение статической переменной с          
     именем myvar, находящуюся в другом модуле с именем mysubs, то вам          
                                                                                
                                                                                
     нужно ввести .mysubs.myvar.  Если же переменная myvar находится в          
     функции myfunc модуля mysubs,  то для определения ее значения  вы          
     должны ввести .mysubs.myfunc.myvar.  С другой стороны, если пере-          
     менная myfunc, расположенная в том же самом моделе, что и функция          
     main, то для определения ее значения вам достаточно ввести только          
     .myfunc.myvar.                                                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 163,164 -
                                                                                
               Спецификаторы формата                                            
     -----------------------------------------------------------------          
                                                                                
          Для управления информацией, выводимой в окно Debug/Evaluate,          
     Турбо Си предоставляет вам спецификаторы формата выражений в поле          
     вычислений (которые подходят и для окна просмотра (Watch)).  Спе-          
     цификаторы формата следуют за выражением,  разделяются запятой  и          
     могут быть набраны на верхнем или нижнем регистрах.                        
                                                                                
          Спецификатор формата  состоит из необязательного повторителя          
     (целого), следующего за ним символа формата;  причем между повто-          
     рителем и символом формата не должно быть пробелов. В таблице 4.1          
     приводится список имеющихся символов формата и их описание.                
                                                                                
          Повторитель используется для вывода следующих  подряд  пере-          
     менных, типичным примером которых может служить массив. Например,          
     если list массив из 10 чисел,  то выражение list  будет  выведено          
     следующим образом:                                                         
                                                                                
          list: ( 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 )                     
                                                                                
          Если вы хотите посмотреть  часть массива,  вы можете указать          
                                                                                
                                                                                
     индекс первого элемента и повторитель:                                     
                                                                                
          list[5],3: 60, 70, 80                                                 
                                                                                
          Эта техника в частности полезна при  выводе массивов большой          
     размерности, которые не помещаются в одной строке.                         
                                                                                
          Применение  повторителей  не  ограничивается  массивами;  за          
     любой   переменной   может   следовать   повторитель.   Выражение          
     синтаксиса var,<n>  просто  выводит последовательность из n пере-          
     менных такого же типа что и var,  начиная с адреса var. Заметьте,          
     однако, что повторитель игнорируется если ваше выражение не соот-          
     ветствует переменной.  В данной конструкции может  использоваться          
     переменная  если она находится в левой части оператора присваива-          
     ния или, если она используется в качестве аргумента функции.               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 165,166 -
                                                                                
                Таблица 4.1 ОТЛАДОЧНЫЕ СПЕЦИФИКАЦИИ ФОРМАТА                     
     -----------------------------------------------------------------          
     Символ          Функция                                                    
     -----------------------------------------------------------------          
                                                                                
       С            Символ.  Служит для  замены  управляющих  символов          
                    (ASCII от 0 до 31) на специальные символы.  Напри-          
                    мер ^С будет выведен как "Счастливое  лицо" (Happy          
                    face). Применяется для символов и строк.                    
                                                                                
       S            Строка. Выводит управляющие символы (ASCII от 0 до          
                    31) как величины ASCII, в соответствии с принятыми          
                    в  Си  управляющими последовательностями.  Так как          
                    функция выводит символ и строку по  умолчанию,  то          
                    спецификатор S полезен только со спецификатором M.          
                                                                                
       D            Десятичный.   Все   целые   величины  выводятся  в          
                    десятичном виде.  Применяется для простых числовых          
                    выражений,   таких   как   массивы   и   структуры          
                    содержащие числа.                                           
                                                                                
       H или X      Шестнадцатиричный.  Все целые величины выводятся в          
                                                                                
                    шестнадцатеричном виде с префиксом 0x. Применяется          
                    для простых числовых выражений,  таких как массивы          
                    и структуры, содержащие целые числа.                        
                                                                                
       F<n>         С  плавающей  точкой.  n  -  целое  от  2  до  18,          
                    обозначает     количество      значащих      цифр,          
                    предназначенных для вывода. Применяется только для          
                    величин с плавающей точкой.                                 
                                                                                
       M            Дамп  памяти.  Выводит  дамп  памяти,  начиная   с          
                    адреса, указанного  в  выражении.  Выражение может          
                    быть конструкцией, допустимой в левой части опера-          
                    тора присваивания, т.е. конструкцией, обозначающей          
                    адрес памяти;  в остальных случаях спецификатор  M          
                    игнорируется. По умолчанию, каждый байт переменной          
                    представляется двумя  шестнадцатиричными  цифрами.          
                    Если  спецификатор M дополнен спецификатором D, то          
                    байт представляется в виде десятичных  цифр,  если          
                    же X или H,  то в виде шестнадцатиричных. В случае          
                    спецификаторов C или S  переменные  выводятся  как          
                    строки ( с или без специальных символов). По умол-          
                    чанию, количество байт соответствует размеру пере-          

                         - 167,168 -
                                                                                
                                                                                
                    менной,  но может быть использован повторитель для          
                    точного указания количества байт.                           
                                                                                
       P            Указатель.  Выводит указатели  в  виде  seg:ofs  с          
                    дополнительной    информацией   об   адресе,   это          
                    предпочтительнее чем принятый по умолчанию машинно          
                    -зависимый seg:ofs формат.  Формат seg:ofs говорит          
                    вам об области памяти,  в которой размещен сегмент          
                    и   имени  переменной  по  адресной  ссылке.  Ниже          
                    приведены области памяти:                                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                    --------------------------------------------------          
                    Область памяти           Пояснение                          
                    --------------------------------------------------          
                                                                                
                    0000:0000-0000:03FF Таблица вектора прерывания              
                                                                                
                    0000:0400-0000:04FF Область данных BIOS                     
                                                                                
                    0000:0500-Турбо Си  MSDOS/TSR's                             
                                                                                
                    Турбо Си - Програм- Турбо Си                                
                    мы пользователя PSP                                         
                                                                                
                    PSP процесса поль-  PSP процесса пользователя               
                        зователя                                                
                                                                                
                    Процесс пользовате- Имя  статической переменной             
                    ля - начало RAM     пользователя, если ее адрес             
                                        лежит вне  памяти  размещенных          
                                        переменных; в противном случае          
                                        ничего.                                 

                         - 169,170 -
                                                                                
                                                                                
                    A000:0000-AFFF:FFFF Видео-память EGA                        
                                                                                
                    B000:0000-B7FF:FFFF Память монохромного дисплея             
                                                                                
                    B800:0000-BFFF:FFFF Память цветного дисплея                 
                                                                                
                    C000:0000-EFFF:FFFF EMS страница/Адаптер BIOS               
                                        ROM's                                   
                                                                                
                    F000:0000-FFFF:FFFF BIOS ROM's                              
                    --------------------------------------------------          
                                                                                
        R           Структуры/объединения. Отображает имена полей, так          
                    и их значения, например {X:1, Y:10, Z:5}. Применя-          
                    ется только для структур и объединений.                     
     -----------------------------------------------------------------          
                                                                                
          Ниже  приведены   некоторые   основные   правила  применения          
     спецификаторов формата:                                                    
                                                                                
          1. Спецификаторы формата эффективны  только  в  том  случае,          
                                                                                
                                                                                
     если  они  применяются  для  переменной соответствующего типа.  В          
     противном случае они игнорируются.                                         
                                                                                
          Обратите внимание, что если вам необходимо вычислить выраже-          
     ние состоящее  из  множества объектов (например,  структура),  то          
     нужно указать несколько спецификаторов формата для каждого объек-          
     та.  Например,  если вы ввели struct,F5H для вывода структуры со-          
     держажей целые и действительные числа,  то целые будут выведены в          
     шестнадцатеричном (Н) виде,  а действительные в виде чисел с пла-          
     вающей точкой с пятью значащими цифрами (F5).                              
                                                                                
          2. Если  вы  ввели  более  обного спецификатора формата,  то          
     выбран будет один с наивысшим приоритетом.  Это,  конечно,  имеет          
     значение  только  для  структур  и  объединений,  а  для  простых          
     переменных  и  массивов  простых  переменных  вы  будете   обычно          
     использовать только один спецификатор формата.                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 171,172 -
                                                                                
            Таблица 4.2 Приоритет и правила умолчания в                         
                         классификации спецификаторов формата                   
                                                                                
     ----------------------------------------------------------------           
      Тип               Спецификаторы в порядке          По умолчанию           
                        возрастания приоритета                                  
     ----------------------------------------------------------------           
                                                                                
     char               C S H D                           S                     
     unsigned char      C S H D                           S                     
     int                H D C* S*                         D                     
     unsigned int       H D C* S*                         D                     
     long               H D C* S*                         D                     
     unsigned long      H D C* S*                         D                     
     char ptr           C S P H                           S                     
     other ptr          P H                               P                     
     enum               H D C* S*                         D(следует             
                                                          за именем)            
     float              Fn                                F7                    
     double             Fn                                F15                   
     long double        Fn                                F18                   
     array of char      C S H D                           S                     
                                                                                
     другие массивы     элементы заключаются в квадратные скобки ([])           
                        и разделяются запятыми                                  
                                                                                
     structure          R                                                       
                                                                                
     * символ типа спецификаторов формата допустим только для величины          
     в интервале (-128 до 127 для типа со знаком (signed),  и 0 до 255          
     для типа без знака (unsigned)).                                            
     -----------------------------------------------------------------          
                                                                                
          Замечание: Спецификатор  формата Н,  используемый для вывода          
                     переменной типа указатель, выводится как шестнад-          
                     цатиричное целое число.                                    
                                                                                
          Продемонстрируем использование спецификаторов формата, пола-          
     гая, что следующие структуры и переменные были объявлены:                  
                                                                                
          struct {                                                              
              int account;                                                      
              char name[10];                                                    
          } client = { 5000, "ДЖОН" }                                           
                                                                                

                         - 173,174 -
                                                                                
                                                                                
          int  list[5] = {0,10,20,30,40};                                       
          char *ptr = list;                                                     
                                                                                
          void main()                                                           
          {                                                                     
          }                                                                     
                                                                                
          После ввода   следующих   выражений   в   поле    вычислений          
     (Evaluate),  будет производиться пересылка вычисленных значений в          
     поле результатов (Result).                                                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
          -----------------------------------------------------------           
               Evaluate               Result                                    
          -----------------------------------------------------------           
                                                                                
            list             { 0, 10, 20, 30, 40 }                              
            list[2],3        20, 30, 40                                         
            list[2],3x       0x14, 0x1E, 0x28                                   
            list,m           00 00 0A 00  00 14 00 1E 00 28 00                  
            ptr              DS:0198                                            
            ptr,p            DS:0198 [_list]                                    
            *ptr,3           0, 10, 20                                          
            client           { 5000, "ДЖОН\0\0\0\0\0" }                         
            client,r         { account:5000, name: "ДЖОН\0\0\0\0\0"}            
          -----------------------------------------------------------           
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 175,176 -
                                                                                
               Упражнение 2: поиск ошибки в wordlen                             
     -----------------------------------------------------------------          
                                                                                
          Сейчас давайте вырнемся к  WORDCNT  и  попробуем  определить          
     причину неправильной работы функции wordlen.                               
                                                                                
          Если вы все еще продолжаете сеанс отладки,  начатый в первом          
     уроке,   произведите   отмену,   набрав  Run/Program  Reset  (или          
     Ctrl-F2).  По этой команде Турбо Си освободит  память, занимаемую          
     WORDCNT, закроет открытый файл и завершит выполнение WORDCNT.              
                                                                                
          С другой стороны, если вы вышли из интегрированной среды или          
     использовали ее для выполнения других программ, подобно тому, как          
     мы это делали  в первом  уроке,  то начните  снова, выберите файл          
     WORDCNT.PRJ.   Затем  установите  контрольную   точку   в  строке          
     содержащей оператор while (fgets(...                                       
                                                                                
          Теперь  выберите   Run/Run  и  начните   отладку.  Турбо  Си          
     подготовит WORDCNT к выполнению и начнет ее выполнять  до тех пор          
     пока не встретит контрольную точку.                                        
                                                                                
          На запрос имени файла, введите WORDCNT.DAT и нажмите Ввод.            
                                                                                
                                                                                
          Выберите  Run/Step  Over,  выполните  WORDCNT  до  оператора          
     вызова wordlen.  Затем выберите  Run/Trace Into  (или  F7), чтобы          
     войти в функцию wordlen раньше чем выполнится оператор ее вызова.          
     Run/Trace  Into  пошагово  выполнит  программу,  подобно Run/Step          
     Over,  но вместо вызова функций осуществляет вход в  них. В нашем          
     случае, шкала выполнения переместится в wordlen.                           
                                                                                
          Сейчас важно понять логику работы wordlen. Функции передает-          
     ся один параметр (указатель), который указывает на слово в буфере          
     строки  и называется wordptr.  Значение wordptr присваивается ло-          
     кальной переменной wordlimit.  Затем начинается цикл while до тех          
     пор, пока не встретится пробел (конец слова) или null-символ (ко-          
     нец строки). И наконец происходит возврат разницы между wordlimit          
     и wordptr, как длины слова.                                                
                                                                                
          Выполните две строки wordlen, описанные через оператор прис-          
     воения. Для этого вы можете воспользоваться  Run/Trace  Into  или          
     Run/Step Over.  Поскольку wordlen не вызывает никаких функций, то          
     эти две команды будут работать одинаково.                                  
                                                                                
          Оцените строку,  содержащую wordlimit и присваивающую указа-          

                         - 177,178 -
                                                                                
     тель. Выполните оператор while. Маркер выполнения должен перемес-          
     титься на  следующую  строку,  в  которой  происходит  увеличение          
     wordlimit. Вместо этого он перемещается на строку дальше, на опе-          
     ратор return. Это может быть ошибка, которую мы ищем.                      
                                                                                
          Замечание: вы вероятно захотите дважды нажать Esc, для того,          
     чтобы  вернуться  в  редактор  Турбо   Си.   Вместо  этого  можно          
     воспользоваться F10.                                                       
                                                                                
          Обсудим, что происходит дальше.  Поскольку wordlimit не уве-          
     личивается,  то  разница  между  wordptr  и wordlimit равна 0,  и          
     wordlen тоже возвратит 0.  Это именно та ошибка, которую мы иска-          
     ли.  Мы  сузили  область ошибки с "ошибка в wordlen" до "ошибка в          
     операторе while функции wordlen".  Раз так,  то нужно внимательно          
     посмотреть на текст программы и сделать вывод, что же неверно.             
                                                                                
          Мы можем  вычислить выражение,  стоящее в операторе while по          
     частям и посмотреть, как они работают вместе. Величина *wordlimit          
     равна  Т  кода ASCII.  Мы не можем вычислить *wordlimit != SPACE,          
     так как SPACE символ определенный с помощью #define;  но мы можем          
     вычмслить *wordlimit != ' ' (SPACE это ' '), и его величина равна          
     1 (истина).  Значением выражения в целом должна быть  истина,  но          
                                                                                
                                                                                
     оно ложно. Значит все дело в операторе &.                                  
                                                                                
          В  данном  случае  оператор  &  применен  неверно.  В  Си он          
     определен  как  оператор  поразрядного  И,  то  есть  операция  И          
     применяется к каждому биту одного операнда с  соответствующим ему          
     битом другого операнда.  Так как *wordlimit != SPACE всегда равен          
     0  или 1 , *wordlimit & *wordlimit != SPACE равно 0 всякий раз. И          
     здесь  необходимо  применить  оператор  &&,  результатом которого          
     является 1,  если  оба операнда  ненулевые. (Попробуйте вычислить          
     все  выражение  сначала  с  одним  &  и  затем  с  &&  и сравните          
     результат).                                                                
                                                                                
          Путаница,  возникающая &  с &&  и !  с !!, является одной из          
     самых общих ошибок,  которые допускают новички программирующие на          
     Си.  После  того,  как  вы  нашли ошибку  в вашей программе,  и в          
     дальнейшем подобные ошибки вы легко узнаете.                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 179,180 -
                                                                                
               Устранение ошибки                                                
     -----------------------------------------------------------------          
                                                                                
          Для  того,  чтобы  исправить ошибку,  вам  нужно  всего лишь          
     изменить & на &&.  Сохраните исправленную программу в файле (наж-          
     мите F2),  для защиты выполненных изменений,  в случае случайного          
     разрушения программы  во время последующего сеанса отладки. Затем          
     выполните Run /Run снова.  Так,  как вы  модифицировали  исходный          
     текст, вам будет сделан запрос на пересоздание программы. Нажмите          
     Y и программа будет перекомпилирована и  перекомпонована.  Теперь          
     возможна дальнейшая отладка откорректированной программы.                  
                                                                                
          Прежде чем  приступить к дальшему поиску ошибок дадим корот-          
     кое резюме нашим действиям, закрывая взгляд на встретившиеся воз-          
     можности отладчика.                                                        
                                                                                
                                                                                
               Что вы достигли                                                  
     -----------------------------------------------------------------          
                                                                                
          Вы  завершили первый  сеанс  отладки  с  помощью Run/Program          
     Reset (или Ctrl-F2). Затем вы выполнили WORDCNT до вызова функции          
                                                                                
                                                                                
     wordlen с помощью установленной контрольной точки.                         
                                                                                
          Потом вы провели трассировку wordlen,  войдя в нее с помощью          
     Run/Trace  INFO (или F7),  начали ее пошаговое выполнение и нашли          
     ошибку. Вы исправили ошибку, сохранили исходный текст, и подгото-          
     вили программу к дальнейшей отладке.                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 181,182 -
                                                                                
               Немного о контрольных точках                                     
     -----------------------------------------------------------------          
                                                                                
          Если вы  не  выходили  из  Турбо Си после первого урока,  то          
     контрольная точка,  установленная вами в строке содержащей опера-          
     тор while( fgets(...  ,  остается,  когда мы стартуем и во второй          
     раз.  Вот почему WORDCNT выполнится до котрольной точки,  а не до          
     конца  программы.  Как вы видите контрольные точки сохраняются от          
     одного сеанса к другому. Даже если между ними вы проводили редак-          
     тирование или преобразование программы.  Турбо Си перемещает каж-          
     дую контрольную точку выше или ниже, держа ее справа оператора.            
                                                                                
          Контрольные точки  сохраняются если вы установили их в прог-          
     раммном файле и сохранили его.  Контрольные точки будут  потеряны          
     только в том случае, когда вы:                                             
                                                                                
          # вышли из интегрированной среды;                                     
                                                                                
          # уничтожили строку исходного файла, в которой была установ-          
            лена контрольная точка;                                             
                                                                                
          # убрали все контрольные точки с  помощью  Break/Watch/Clear          
                                                                                
            All Breakpoints.                                                    
                                                                                
          Однако  Турбо Си  может потерять  контрольные  точки  в двух          
     случаях:                                                                   
                                                                                
          # если вы редактируете файл, содержащий контрольные точки, а          
            затем потеряли  (не  сохранили)  отредактированную  версию          
            файла. Турбо  Си  не  помнит положение контрольных точек в          
            оригинальной версии файла и может поместить их  в неверные          
            строки.                                                             
                                                                                
            Если вы потеряли отредактированную версию исходного файла,          
            то   вам   необходимо   убрать   все   контрольные   точки          
            (выберите Break/Watch/Clear All Breakpoints), а затем соз-          
            дать их  вновь.  Заметьте,  что  Break  /Watch/Clear   All          
            Breakpoints  уничтожает  все контрольные точки вашей прог-          
            раммы, а не только те, которые вы редактировали в исходном          
            файле.                                                              
                                                                                
          # если вы редактируете файл и продолжаете сеанс, не выполнив          
            перередактирование и компиляцию.  Контрольные точки  стоят          
            на своих местах, но так как исходный файл не соответствует          

                         - 183,184 -
                                                                                
            выполняемой программе,  то  индикаторы  контрольных  точек          
            указывают не на те строки.  (Маркер выполнения также нахо-          
            дится на неверной строке).                                          
                                                                                
            Вы не можете попасть в такую ситуацию случайно потому, что          
            Турбо Си выдает запрос "Source modified, rebuild (Исходный          
            текст модифицирован,  перестроить)?",  когда вы  пытаетесь          
            продолжить или начать сеанс вновь.                                  
                                                                                
          Перед компиляцией вы  можете установить контрольные  точки в          
     строках, содержащих невыполняемые операторы,  таких как коммента-          
     рии  или пустые строки.  В этом случае Турбо Си сообщит вам,  что          
     контрольные точки установлены в строках, содержащих невыполняемый          
     код.  После компиляции файла Турбо Си становятся известны строки,          
     содержащие выполняемые операторы и вы будете об этом предупрежде-          
     ны, если попытаетесь установить контрольную точку в этих строках.          
                                                                                
          Переместить курсор к следующей контрольной точке можно с по-          
     мощью выбора Break/View Next Breakpoints.  Заметьте,  что по этой          
     команде курсор перемещается к следующей контрольной точке в текс-          
     те программы,  а не к той,  которая бы выполнилась, если бы прог-          
     рамма  работала.  Для просмотра контрольных точек программы можно          
                                                                                
                                                                                
     испоьзовать Break/Watch/Next Breakpoints,  это полезно,  когда вы          
     хотите уничтожить только часть контрольных точек.                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 185,186 -
                                                                                
               Упражнение 3: возвращение к программе                            
     -----------------------------------------------------------------          
                                                                                
          Давайте проверим, исправили ли вы ошибку.                             
                                                                                
          Если  вы  вышли из  интегрированой  среды или  решали другие          
     программы после упражнения 2,  запустите ее снова и создайте файл          
     WORDCNT.PRJ с текущим проектом.  Выберите Run/Run и начните новый          
     сеанс отладки. Выполните WORDCNT сначала до вызова wordlen, трас-          
     сируя ее шаг за шагом.  На этот раз она работает корректно и зна-          
     чение, возвращаемое функцией wordlen, равно 2. Это успех!                  
                                                                                
          Однако ваша работа не завершена. Большая часть программы еще          
     не проверена и может иметь другие ошибки.  На следующем этапе  вы          
     должны провести тестирование внутреннего цикла while в main.  Бо-          
     лее полный подход к тестированию включает в себя пошаговое выпол-          
     нение main до тех пор,  пока не будет отработана первая введенная          
     строка, и проверку на выход из цикла. Проверьте, чтобы каждый шаг          
     правильно  выполнялся и выход из цикла выполнялся в нужной точке.          
                                                                                
          Но контроль всех выражений - большая работа.  Окно Watch от-          
     ладчика позволяет это сделать довольно легко.  В окне Watch выво-          
                                                                                
     дится  одно  или более выражений и их текущие значения.  Во время          
     каждого останова отладчик производит пересчет каждого выражения в          
     окне Watch.  Таким образом вы можете наблюдать изменение значений          
     выражений во время решения вашей программы.                                
                                                                                
          Создайте выражения для всех  элементов  данных,  входящих  в          
     внутренний  цикл  while (переменная  i,  строка,  начинающаяся с           
     wordptr и несколько первых элементов wordlencnt).                          
                                                                                
          Окно Watch обычно размещается в нижней части экрана, там же,          
     где  находится окно Message во время компиляции и редактирования.          
     Оно инициализирует одну яркую пустую строку.  Если окно Watch не-          
     видимо,  то  это  потому,  что окно Edit расширено на весь экран;          
     нажмите F5 и отладчик вернется в полиэкранный режим и  окно Watch          
     восстановится.                                                             
                                                                                
          Выберите Break/Watch/Add Watch (или комбинацию Ctrl-F7). От-          
     ладчик откроет окно и выдаст запрос на  ввод  выражения.  Подобно          
     Debug/Evaluate, Break/Watch/Add Watch использует по умолчанию вы-          
     ражение,  у которого стоит курсор в окне Edit.  Если выражение  в          
     окне  не i,  введите i и нажмите Ввод.  Отладчик вычислит текущее          
     значение i и выведет его в окне Watch.                                     

                         - 187,188 -
                                                                                
                                                                                
                                                                                
          Повторите эту  процедуру  для  пяти  выражений:  wordptr   и          
     wordlencnt[1]...wordlencnt[4]. После ввода каждого выражения окно          
     Watch будет вырастать и приспосабливаться к нему. Теперь пошагово          
     выполните цикл while WORDCNT до тех пор, пока не будет обработана          
     первая введенная строка. Как только начнете, вы сможете наблюдать          
     продвижение вперед wordptr и увеличение соответствующего элемента          
     wordlencnt.  Остановитесь, когда wordptr достигнет конца строки и          
     маркер выполнения выйдет из внутреннего цикла while. Цикл работа-          
     ет правильно.                                                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
              Редактирование и уничтожение выражений                            
              --------------------------------------                            
                                                                                
          Вы можете редактировать и уничтожать выражения в окне Watch,          
     также как и добавлять их.                                                  
                                                                                
          Для того,  чтобы отредактировать или уничтожить выражения  -          
     активизируйте окно Watch.  Если вы находитесь в меню системы,  то          
     нажмите F10 и выйдите из него.  Нажмите F6, чтобы переключиться с          
     окна Edit на окно Watch.  Редактор высветит выражение, которое вы          
     можете изменить или уничтожить;  перемещение поля  выполняется  с          
     помощью клавиш управления курсором.                                        
                                                                                
          Попробуйте изменить выражение. Для этого переместите поле на          
     wordlencnt[4] и выберите Break/Watch/Edit Watch (или  Ввод).  От-          
     ладчик откроет окно,  содержащее выражение и запрос на его редак-          
     тирование.                                                                 
                                                                                
          Измените индекс  массива с 4  на 6  и нажмите Ввод. Отладчик          
     изменит выражение в окне WINDOW и выведет его новое значение.              
                                                                                
          Переместите поле на выражение wordlencnt[3] и выберите Break          

                         - 189,190 -
                                                                                
                                                                                
     /WATCN/Delete Watch (или Del, или Ctrl-Y). Отладчик уничтожит вы-          
     ражение.                                                                   
                                                                                
          Нажмите F6  для активизации окна Edit.  Заметьте,  что когда          
     окно Watch разактивизируется,  перед выражением, помеченным повы-          
     шенной  яркостью,  появляется  символ "бриллиант формы" (код F0).          
     Для того, чтобы активизировать окно Watch, нажмите F6.                     
                                                                                
          Вы   можете    уничтожить    все    выражения    с   помощью          
     Break/Watch/Remove All Watches. (Для этого окно Watch должно быть          
     активно). Сейчас уничтожьте все  видимые  выражения.  Окно  Watch          
     возвратится в свое исходное состояние.  Для активизации окна Edit          
     нажмите F6. С помощью этой команды вы можете переключаться с окна          
     Edit на окно Watch, или наоборот.                                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Расширение и переключение окон                                   
               ------------------------------                                   
                                                                                
          Правила расширения и переключения окон в отладчике расширены          
     по  сравнению с правилами,  которые вы  уже изучили при  работе с          
     редактором, компилятором и компановщиком.                                  
                                                                                
          Работа с окнами Watch и Edit выполняется в полиэкранном  ре-          
     жиме,  подобно тому,  как это делается при работе с окнами Edit и          
     Message при компиляции и редактировании.                                   
                                                                                
          Для того, чтобы произвести переключение между двумя окнами -          
     Edit и Message или Edit и Watch, - нажмите F6.                             
                                                                                
          Чтобы расширить окно  до  полного экрана  -  нажмите F8. Для          
     возврата в полиэкранный режим нажмите F5.  Попробуйте это сделать          
     с окнами Edit и Watch.                                                     
                                                                                
          Для вывода  экрана  выполнения  выберите Run/User Screen или          
     Alt-F5. Попробуйте это.                                                    
                                                                                
          Используйте Alt-F6 для изменения содержимого окна:                    

                         - 191,192 -
                                                                                
                                                                                
                                                                                
          # когда активно окно Edit, загруженный файл перезагружается           
                                                                                
          # если активно окно Watch или Message, то нажатие Alt-F6 яв-          
            ляется переключателем  между  окном  Watch и окном Message          
            tracking.                                                           
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Прокрутка выражений в окне Watch                                 
               ---------------------------------                                
                                                                                
          При добавлении выражений в окно Watch может возникнуть ситу-          
     ация,  когда окно займет около половины экрана.  И при добавлении          
     выражений в этом случае возникает прокрутка содержимого окна. Уп-          
     равление содержимым окна выполняется с помощью клавиш PgUp, PgDn,          
     стрелка вверх  и стрелка вниз.  Если выражение очень длинное и не          
     помещается в окно,  то вы можете  воспользоваться  горизонтальной          
     прокруткой с  помощью ключей Home,  End,  стрелка влево и стрелка          
     вправо (этим средством можно пользоваться и при просмотре длинных          
     значений выражения).                                                       
                                                                                
                                                                                
                                                                                
               Упражнение 4: отладка цикла печати                               
     -----------------------------------------------------------------          
                                                                                
          Вы отладили цикл while,  который  считывает  и  обрабатывает          
     входной  файл.  В  этом цикле есть несколько мест,  где вас могут          
     ожидать ошибки,  и для того,  чтобы их найти вам нужно  чтобы  на          
     входе WORDCNT чувствовал специфичные типы,  например,  такие, как          

                         - 193,194 -
                                                                                
     пустые строки.  Однако, мы отложим поиск таких ошибок и приступим          
     к проверке цикла for, который выводит результаты.                          
                                                                                
          Вам необходимо выполнить WORDCNT до строки,  содержащей цикл          
     for  (приблизительно  117   строка).   Как  вам  известно,  можно          
     переместить курсор в эту строку,  установить контрольную  точку и          
     выбрать  опцию Run/Run.  Но  сейчас  мы  будем использовать более          
     удобную технику,  если вы предполагаете  останавливаться только в          
     определенных точках.                                                       
                                                                                
          Переместите курсор к строке,  в которой начинается цикл for,          
     и выберите Run/Go to Cursor (или F4). Отладчик выполнит WORDCNT и          
     остановится в той строке,  где находится курсор.  (Останов  может          
     произойти  раньше в контрольной точке,  но в этой части программы          
     они не устанавливались).                                                   
                                                                                
          Выполните один  оператор,  шкала  выполнения переместится на          
     оператор printf цикла for. Заметим, что в цикле for нет контроль-          
     ной точки.  Run/Go to Cursor является одноразовой операцией;  она          
     не устанавливает контрольную точку.                                        
                                                                                
          Начните пошаговое выполнение  цикла for с  помощью Run/Trace          
                                                                                
     Into.  Обратите внимание,  что Run/Trace Into трассировку функции          
     printf не выполняет. Это происходит потому, что функция printf не          
     определена в исходном файле.  Отладчик может только выполнять та-          
     кие функции, но не может их трассировать. (В этом случае нет дру-          
     гого выхода, трассировка этой функции невозможна: исходного текс-          
     та функции printf в вашем файле нет).                                      
                                                                                
          Каждый раз,  когда  вы  выполняете строку,  содержащую вызов          
     printf, отладчик открывает экран выполнения (Execution).  На него          
     будет выводиться текст, выводимый printf. Отладчик сохранит экран          
     выполнения до тех пор,  пока будет выполняться оператор, содержа-          
     щий функцию printf.                                                        
                                                                                
          Вы вероятно не сможете прочитать вывод программы в столь ко-          
     роткий промежуток времени,  пока экран выполнения виден, но с по-          
     мощью  Run/User  Screen (или Alt-F5) можно перейти в режим экрана          
     пользователя и наблюдать работу WORDCNT.                                   
                                                                                
          Замечание: С другой стороны,  если заметить, что вывод прог-          
     раммы переписывается в ваш исходный текст в окно Edit,  то вы мо-          
     жете избавиться от этого,  выбрав Debug/Refresh Display для реге-          
     нерации экрана. Затем проконтролируйте, чтобы опция Debug/Display          

                         - 195,196 -
                                                                                
                                                                                
     Swapping  была  установлена в состояние Smart или Always.                  
                                                                                
          (Более полная информация об  этой  опции  рассматривается  в          
     Главе 5).                                                                  
                                                                                
          На этом четвертое упражнение заканчивается. Мы покидаем вас,          
     а вы можете поискать ошибки в цикле for, и если их обнаружите, то          
     исправьте.                                                                 
                                                                                
          Замечание: Мы обещали,  что WORDCNT содержит несколько  оши-          
     бок. Вы нашли их?  Каждая из них упоминается в разделе  "Алгоритм          
     для  эффективного тестирования программного обеспечения",  приве-          
     денного в конце этой главы.                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Упражнение 5: работа с большими программами                      
     -----------------------------------------------------------------          
                                                                                
          Отладчик имеет несколько дополнительных возможностей,  помо-          
     гающих вам при работе с большими исходными текстами и многофайло-          
     выми программами. В следующем разделе мы продемонстрируем их. Для          
     того, чтобы использовать одну из них, вы должны компилировать ва-          
     шу программу с включенной опцией Options/Compiler/Code Generation          
     /Standard Stack Frame.  Проверьте эту опцию.  Если она выключена,          
     то включите ее, затем убедитесь, что WORDCNT загружен в окно Edit          
     и перекомпилируйте, нажав Alt-F9. Начните сеанс отладки с помощью          
     Run/Step Over или, нажав F8.                                               
                                                                                
                                                                                
                                                                                
               Поиск определенной функции                                       
              ---------------------------                                       
                                                                                
          Debug/Find Function  выполняет  прокрутку описаний функций в          
     окне Edit. Она поможет найти некоторую функцию в программе, кото-          
     рую можно откомпилировать с флагом Debug/Source Debugging и O/O/C          
     /OBJ Debugging Information в состояние On.                                 

                         - 197,198 -
                                                                                
                                                                                
          Debug/Find Function полезна в том случае, если введенная ва-          
     ми  ошибка в одной части программы,  должна быть исправлена с по-          
     мощью изменений в других частях.                                           
                                                                                
          Для   проверки   этой   команды,    переместите   курсор   в          
     небезизвестную  вам строку,  содержащую  вызов  wordlen. Выберите          
     Run/Go to Cursor.  Затем переместите курсор на wordlen и выберите          
     Debug/Find Function.  Отладчик откроет окно  и выдаст приглашение          
     для ввода имени функции;  так как wordlen это функция, которую мы          
     хотели найти, то вводите ее имя, и нажмите Ввод. Отладчик выведет          
     описание функции в окне Edit.                                              
                                                                                
                                                                                
               Стек вызова                                                      
               -----------                                                      
                                                                                
          Когда вы отлаживаете программу,  содержащую  вызовы  функций          
     различных уровней,  вам иногда будет нужно просмотреть стек вызо-          
     ва,  который содержит имена вызывавшихся функций в порядке их вы-          
     полнения. Для этой возможности необходимо включить опцию Options/          
     Compiler/Code Generation/Standard Stack Frame.                             
                                                                                
                                                                                
          Войдите в wordlen, затем выберите Debug/Call Stack (или Ctrl          
     -F3).  Отладчик выведет стек вызова во всплывающем окне. Функция,          
     выполняемая в данный момент,  будет находиться в вершине стека, а          
     на дне стека будет main. Заметьте, что в стек выводятся не только          
     имена функций, но и значения их параметров.                                
                                                                                
          Для того,  чтобы посмотреть,  какая строка выполняется,  вам          
     необходимо  переместить светящееся поле в окне стека на имя функ-          
     ции и нажать Ввод. Например, для того, чтобы узнать, какая строка          
     main  выполняется в данный момент,  переместите поле в окне стека          
     на main и нажмите Ввод.  Отладчик прокрутит часть main и  выведет          
     строку, содержащую вызов wordlen в окне Edit. Если имеются допол-          
     нительные точки входа стека вызова, то вы можете вывести выполня-          
     ющуюся строку любой другой функции, выбрав Debug/Call Stack снова          
     и другую точку входа стека.                                                
                                                                                
                                                                                
                                                                                
               Возврат в позицию выполнения                                     
               ----------------------------                                     
                                                                                

                         - 199,200 -
                                                                                
                                                                                
          Вы можете  также  использовать  опцию  Debug/Call  Stack для          
     возврата к маркеру выполнения после просмотра других частей прог-          
     раммы.  Для  этого необходимо выбрать самую верхнюю функцию стека          
     вызова. Попробуйте.                                                        
                                                                                
          На этом упражнения с отладчиком заканчиваются.                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               О многофайловых исходных текстах                                 
     -----------------------------------------------------------------          
                                                                                
          Все команды отладчика работают с программами,  состоящими из          
     нескольких файлов.  Например, если вы выбрали Debug/Find Function          
     для  того,  чтобы найти функцию,  которая описана в другом файле,          
     отладчик загрузит трубуемый файл в окно Edit.  Если захотите сде-          
     лать изменения текущего файла, отладчик спросит хотите ли вы сох-          
     ранить файл, который был загружен предыдущим.                              
                                                                                
          Подобно этому,  когда вы выбираете функцию из  стека  вызова          
     (используя  Debug/Call Stack),  отладчик перезагружает окно Edit.          
     Точно так же отладчик дает запрос на сохранение.  Если  программа          
     состоит из большого количества файлов, то одновременно отлаживать          
     лучше только несколько.                                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 201,202 -
                                                                                
                                                                                
             Обзор команд отладчика и зарезервированных клавиш                  
     -----------------------------------------------------------------          
                                                                                
          Это введение  представляет  вам  наиболее часто используемые          
     команды интегрированного отладчика.  Когда вы приобретете некото-          
     рое  мастерство при работе с отладчиком,  большинство этих команд          
     вы запомните.  Наиболее часто используемые  команды  приведены  в          
     таблицах 4.3 и 4.4.                                                        
                                                                                
          Многие команды отладчика и команды меню могут быть выполнены          
     с помощью  зарезервированных клавиш или их комбинаций.  Для того,          
     чтобы избежать беспорядка,  мы укажем только самые важные из них.          
     В таблице  4.3 приведены все зарезервированные клавиши команд от-          
     ладчика, которые вы изучили.                                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
         Табл. 4.3: Команды отладки и клавиши быстрого вмешательства.           
     -----------------------------------------------------------------          
      Клавиша   Команда меню           Описание                                 
     -----------------------------------------------------------------          
                                                                                
       F4       Run/Go to Cursor       Выполнение  программы продолжа-          
                                       ется до строки с курсором.  Бу-          
                                       дет инициирован сеанс отладки.           
                                                                                
       Ctrl-F2  Run/Program Reset      Прекращает текущий сеанс отлад-          
                                       ки, освобождает  распределенную          
                                       память и закрывает файл.  Имеет          
                                       действие только в сеансе отлад-          
                                       ки.                                      
                                                                                
       F7       Run/Trace Into         Выполняет  следующий   оператор          
                                       текущей функции. Будучи вызван-          
                                       ной и,  если  самый нижний уро-          
                                       вень функции был откомпилирован          
                                       с   опциями   O/C/C/OBJ   Debug          
                                       Information   и    Debug/Sourse          
                                       Debudding в состоянии On,  осу-          

                         - 203,204 -
                                                                                
                                       ществляет  трассировку   внутри          
                                       функции.  Будет инициирован се-          
                                       анс отладки.                             
                                                                                
       F8       Run/Step  Over         Выполняет   следующий  оператор          
                                       текущей функции. Не выполняется          
                                       трассирование внутри вызываемой          
                                       функции. Будет  инициирован се-          
                                       анс отладки.                             
                                                                                
                O/C/C/Standard         Опция     Options/Compiler/Code          
                Stack Frame            Generation/Standard Stack Frame          
                                       Если присутствует    Debug/Call          
                                       Stack, то для правильной работы          
                                       программы при    компилировании          
                                       эта опция должна быть  установ-          
                                       лена в состояние On.                     
                                                                                
                O/C/C/OBJ Debug        Опция  O/C/C/Debug Information.          
                Information            Только файлы  откомпилированные          
                                       и скомпанованные  с этой опцией          
                                       в состоянии On,  могут быть от-          
                                                                                
                                       лажены.                                  
                                                                                
       Ctrl-F4  Debug/Evaluate         Вычисляет выражение;  позволяет          
                                       вам изменить значение  перемен-          
                                       ной.                                     
                                                                                
                Debug/Find Function    Наxодит  определение  функции и          
                                       отображает его  в окне редакти-          
                                       рования. Имеет  действие только          
                                       в сеансе отладки.                        
                                                                                
       Ctrl-F3  Debug/Call Stack       Отображает вызов стека.  Вы мо-          
                                       жете вывести на дисплей текущую          
                                       выполняемую строку     функции,          
                                       указав имя   функции  из вызова          
                                       стека. Имеет  действие только в          
                                       сеансе отладки.                          
                                                                                
                Debug/Source Debugging Проверяет разрешена ли отладка.          
                                       При установленном значении On -          
                                       процесс отладки разрешен. Когда          
                                       установлено значение None,  ин-          

                         - 205,206 -
                                                                                
                                                                                
                                       формация отладчика в файле .EXE          
                                       будет отсутствовать,  и, поэто-          
                                       му, программа  не  сможет  быть          
                                       отлажена другим отладчиком.              
                                                                                
       Ctrl-F7  Break/Watch/Add Watch  Добавляет  наблюдаемое  выраже-          
                                       ние.                                     
                Break/Watch/Delete     Удаляет наблюдаемое выражение.           
                Watch                                                           
                                                                                
                Break/Watch/Edit Watch Позволяет   вам   редактировать          
                                       наблюдаемое выражение.                   
                Break/Watch/Remove     Удаляет все наблюдаемые выраже-          
                All Watches            ния.                                     
                                                                                
       Ctrl-F8  Break/Watch/Toggle     Устанавливает или удаляет точку          
                Breakpoint             останова  в  строке,  в которой          
                                       расположен курсор.                       
                                                                                
                Break/Watch/Clear      Удаляет  в  программе все точки          
                Breakpoints            останова.                                
                                                                                
                                                                                
                Break/Watch/View       Выводит  на  дисплей  следующую          
                Next Breakpoint        точку останова.                          
                                                                                
     -----------------------------------------------------------------          
                                                                                
          В таблице 4.4 приведены другие команды меню, часто использу-          
     емые в интегрированном отладчике.  (Для изучения остальных  заре-          
     зервированных клавиш и команд меню смотрите Главу 5).                      
                                                                                
          Табл. 4.4: Команды меню и "горячие" клавиши отладчика.                
     -----------------------------------------------------------------          
       Клавиша   Команда меню             Описание                              
     -----------------------------------------------------------------          
                                                                                
        F5                           Увеличивает до полного  экрана  и          
                                     уменьшает активное окно.                   
                                                                                
        Alt-F5                       Переключает  дисплей в  пользова-          
                                     тельский экран.    Нажатие  любой          
                                     клавиши приведет к возврату в ин-          
                                     тегрированную среду.                       

                         - 207,208 -
                                                                                
        F6                           Переключает активное  окно  между          
                                     окном редактирования и окном наб-          
                                     людения или сообщений.                     
        Alt-F6                       Если окно редактора активно - пе-          
                                     реключает в  файл,   который  был          
                                     загружен последним.  Если активно          
                                     нижнее окно -  переключает  между          
                                     окном наблюдения и сообщений.              
                                                                                
        Ctrl-F9  Run/Run             Запускает программу на выполнение          
                                     с или без отладчика.  Компилирует          
                                     исxодный файл (файлы) и компонует          
                                     программу, если  это  необxодимо.          
                                     Запускает программу на выполнение          
                                     до точки останова или  до  конца,          
                                     если компиляция     и  компоновка          
                                     программы были выполнены с Debug/          
                                     Source    Debugging  и  O/C/C/OBJ          
                                     Debug Informatoin в положении On.          
                                                                                
                 Project/Remove      Удаляет содержимое  окна  сообще-          
                 Messages            ний.                                       
                                                                                
               Советы для эффективного тестирования программ.                   
     -----------------------------------------------------------------          
                                                                                
          Методов   отладки   больше,   чем  знаний  как  использовать          
     отладчик.  Объяснение  поведения  программы  -  одна  из наиболее          
     ответственных фаз в программировании.                                      
                                                                                
          Остаток этой главы посвящен технике программирования,  кото-          
     рая облегчит отладку.                                                      
                                                                                
                                                                                
                                                                                
               Развитие стандартного подхода                                    
     -----------------------------------------------------------------          
                                                                                
          Развитый  стандартный  подход  к  тестированию  программного          
     обеспечения  заключается  в  серии  шагов,  которые  в результате          
     эксперимента позволят вам судить о надежности программы.                   
                                                                                
          Для тестирования не  выбирайте только  один правильный путь;          
     список шагов будет  зависеть от типа  написанной программы, вашей          
     квалификации  как программиста  и  вашего  индивидуального стиля.          

                         - 209,210 -
                                                                                
     Список  шагов,  приведенных ниже,  может  вам служить  в качестве          
     отправной точки.                                                           
                                                                                
          # Делайте вход программы простым, но не тривиальным. Трасси-          
            ровку проводите используя Debug/Evaluate и почаще  контро-          
            лируйте значение элементов данных. Одновременно находите и          
            исправляйте несколько ошибок.                                       
                                                                                
          # Подавайте на вход различные наборы данных, чтобы проверить          
            те части программы,  которые вы не смогли оттестировать на          
            предыдущем шаге.                                                    
                                                                                
          # Проверьте каждый оператор программы. Вы можете найти ошиб-          
            ки там,  где меньше всего ожидаете.  В WORDCNT,  например,          
            проверяя каждый оператор,  обнаружили случайную  ошибку  с          
            запятой после else,  которая создает нежелательный эффект,          
            когда  программа  встречает  слово   длиной   больше   чем          
            MAXWORDLEN.  (Точка  с  запятой обычно находится за правым          
            краем окна Edit и маловероятно,  что вы ее заметите в дру-          
            гих случаях).                                                       
                                                                                
          # Будьте осторожны с операторами или выражениями, которые не          
                                                                                
            могут быть проверены за один раз, подобных этому:                   
                                                                                
              if (strcmp( a, b ) )...                                           
                                                                                
            strcmp может вернуть три значения - 0 (a равно b),  -1  (a          
            иеньше b) или 1 (a больше b). Это предположение делает не-          
            обходимым проверить оператор с тремя наборами входных  ве-          
            личин  и в каждом случае оператор должен работать правиль-          
            но.                                                                 
                                                                                
              x = (x>0) ? fun(x) : 0;                                           
                                                                                
            Этот оператор содержит условное выражение,  которое  может          
            порождать два результата.                                           
                                                                                
          # Обратите особое внимание на граничные условия: условия при          
            которых программа выходит из  цикла,  заполняет  массив  и          
            т.д.  Ошибки,  в  особенности подобные failures to handle,          
            часто вызваны нарушением граничных условий.                         
                                                                                
            WORDCNT содержит два примера ошибок, связанных с граничны-          
            ми  условиями.  Во-первых,  цикл  for  не  выведет элемент          

                         - 211,212 -
                                                                                
            wordlencnt,  который   соответствует   словам   длиной   в          
            MAXWORDLEN символов. Во-вторых, wordlencnt размещенный для          
            одного элемента будет слишком мал, и элемент будет не дос-          
            тупен.                                                              
                                                                                
          # Полностью проверьте программу без отладчика. Если програм-          
            му будут использовать другие люди, они будут предполагать,          
            что  она работает правильно,  поэтому проверьте ее реакцию          
            на каждый тип ошибки,  возможных при обработке. О програм-          
            ме,  обрабатывающей большинство типов оишбок,  говорят как          
            об ошибкоустойчивой.                                                
                                                                                
          # Если вашей программой будут пользоваться другие  люди,  то          
            они должны иметь по крайней мере один индивидуальный тест.          
            Выберите кого-нибудь, кто является типичным представителем          
            пользователей вашей программы, который с упорством и энту-          
            зиазмом будет искать ошибки и сможет правильно  сообщить о          
            них. Не выбирайте программиста, если только ваша программа          
            не предназначена для программистов.                                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                Тщательно проверяйте изменения                                  
     -----------------------------------------------------------------          
                                                                                
          Когда вы изменили программу, тщательно оттестируйте все зат-          
     ронутые  части  программы.  Необходимо также проверить работу тех          
     частей программы,  которые не изменились, но связаны с этим изме-          
     нением. Если программа сложная, то сохраните запись тестов. Когда          
     вы будете модифицировать программу,  эта запись поможет повторить          
     вам все тесты связанные с изменением.  Если тест включает входные          
     файлы - сохраните эти файлы.                                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 213,214 -
                                                                                
             Как избежать некоторых трудностей                                  
     -----------------------------------------------------------------          
                                                                                
          Пишите ясные программы с последовательным  отступом  вправо,          
     отражающим  вложенность операторов,  с подробными комментариями и          
     описаниями имен переменных.                                                
                                                                                
          Сохраните текст вашей программы простым. Старайтесь выражать          
     запутанные операции с помощью нескольких простых операторов, а не          
     сбивать их в одну кучу. Турбо Си прооптимизирует код с максималь-          
     ной эффективностью,  в свою очередь,  исходный текст должен легко          
     отлаживаться,  читаться и модифицироваться.                                
                                                                                
          Старайтесь строить программу из функций с простыми  и хорошо          
     определенными целями.  Это  облегчит  создание тестов и анализ их          
     результатов. Это также сделает программу легко читаемой и модифи-          
     цируемой.                                                                  
                                                                                
          Пытайтесь минимизировать число  элементов данных требующихся          
     каждой функции и число элементов, которые она изменяет. Это то же          
     облегчит  создание  тестов и анализ их результатов.  Такой подход          
     ограничивает количество функций с ошибками и  позволяет проверить          
                                                                                
                                                                                
     функцию несколько раз за один сеанс отладки.  Программа, разрабо-          
     танная таким образом, является практически независимой.                    
                                                                                
          При написании  программы,  не  экономьте биты.  Обычно такая          
     экономия приводит к усложнению программы, в ней тяжело разобрать-          
     ся и сложно отлаживать. Если ваша программа медленно выполняется,          
     то найдите какая часть программы нуждается в улучшении  и  решите          
     как это лучше сделать.                                                     
                                                                                
          Будьте осторожны при написании функций, которые используются          
     в программе в нескольких местах или могут  использоваться другими          
     программами.  Написание и отладка одной обобщенной функции прохо-          
     дит обычно легче чем нескольких специализированных.                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 215,216 -
                                                                                
                                                                                
               Отладка снизу вверх                                              
     -----------------------------------------------------------------          
                                                                                
          На сколько  возможно  сосредоточьтесь  на  отладке   функций          
     нижнего уровня (это функции, которые не вызывают другие функции).          
     Затем принимайтесь за отладку функций  более  верхнего  уровня  и          
     т.д.  по  направлению  к  main.  В  этом случае,  вы будете иметь          
     фундамент из нужных функций, и эти функции вы можете выполнить за          
     один шаг, когда они вызываются в других частях программы.                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Исправление подобных ошибок                                      
     -----------------------------------------------------------------          
                                                                                
          Когда вы нашли  ошибку,  проконтролируйте  наличие  подобной          
     ошибки в остальных частях программы. Например, если вы нашли, что          
     вызов функции выглядит следующим образом:                                  
                                                                                
                fp = fopen("rb",filename);                                      
                                                                                
     который должен выглядеть                                                   
                                                                                
                fp = fopen(filename,"rb");                                      
                                                                                
     то исправьте ошибку  и проверьте вызовы  fopen  и  других простых          
     функций с целью обнаружения подобных ошибок.                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 217,218 -
                                                                                
               Отладка встроенного кода ассемблера                              
     -----------------------------------------------------------------          
                                                                                
          Если вы используете ассемблер ТАСМ фирмы  Borland, совместно          
     с интегрированным  окружением,  то  можете шаг за шагом проверить          
     код на уровне ассемблера,  без использования внешнего  отладчика.          
     (Для полной поддержки отладки на уровне ассемблера вы можете, ко-          
     нечно, использовать и автономный отладчик фирмы Borland.)                  
                                                                                
          Когда модуль,  написанный на ассемблере,  проассемблирован с          
     опцией TASM  -zi,  Турбо  Си может распознавать исходные строки и          
     идентификаторы ассемблера.  Если же вы вышли на  уровень  функций          
     ассемблера, то  Турбо  Си будет показывать вам на экране исходный          
     текст ассемблера для этой функции. Для вашего исходного текста на          
     языке ассемблера вы можете использовать обычные команды отладчика          
     TC,  такие как Debug/Go to cursor (F4),  Debug/Trace Into (F7)  и          
     Debug/Step Over (F8).                                                      
                                                                                
          Большинство идентификаторов,  определенных  в вашем исходном          
     тексте на ассемблере,  будет доступно для использовании в  оценке          
     значений выражений и их отображения. Кроме того, вы имеете доступ          
     к псевдорегистрам (_AX,  _BX,  и т.д.) и  специальной  переменной          
                                                                                
                                                                                
     _FLAGS, отражающей состояние регистра флагов центрального процес-          
     сора.  Конечно,  с TC и средой разработки Си,  вы не  распознаете          
     каждую конструкцию или выражение ассемблера.                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 219,220 -
                                                                                
                                ГЛАВА  5                                        
                                --------                                        
                                                                                
                     ИНТЕГРИРОВАННАЯ СРЕДА ТУРБО СИ                             
     -----------------------------------------------------------------          
                                                                                
          Турбо Си,  интегрированная  среда Турбо Си,  - это более чем          
     просто быстрый Си компилятор, это быстрый и эффективный Си компи-          
     лятор  со  встроенными  редактором текстов,  отладчиком и другими          
     утилитами,  которые просты в изучении и использовании.  Работая с          
     Турбо Си вы не нуждаетесь в отдельныx редакторе текста,  отладчи-          
     ке, компиляторе, компоновщике и утилите Make для того, чтобы соз-          
     давать и запускать на выполнение ваши Си программы.  Все эти воз-          
     можности заложены в самом Турбо Си и все они  легко  достопны  из          
     основного экрана Турбо Си.                                                 
                                                                                
                                                                                
               В этой главе...                                                  
     -----------------------------------------------------------------          
                                                                                
          Эта глава разделена на четыре части: Часть I " Использование          
     Турбо Си ",  Часть II " Меню команд ",  Часть III "  Подробнее  о          
                                                                                
     файлаx конфигурации  и Pick " и Часть IV " Дополнительные особен-          
     ности и команды редактирования ".                                          
                                                                                
         В Части I " Использование Турбо Си " мы:                               
                                                                                
          - знакомим с переключателями в командной строке Турбо  Си  и          
            клавиши быстрого вмешательства;                                     
                                                                                
          - описываем компоненты основного экрана Турбо Си;                     
                                                                                
          - объясняем как использовать опции основного меню;                    
                                                                                
          - показываем как войти в окно  текстового  редактора  и  как          
            пользоваться Турбо Си редактором;                                   
            (команды редактирования описаны в Приложении А руководства          
            по Турбо Си: "Турбо Си интерактивный редактор").                    
                                                                                
          - знакомим вас с Турбо Си интегрированным отладчиком;                 
            (для получения  детальной  информации об использовании от-          
            ладчика смотрите главу 4 : "Отладка вашиx программ").               
                                                                                
         В Части II "Команды меню" мы:                                          

                         - 221,222 -
                                                                                
                                                                                
          - исследуем и объясняем каждый пункт функций меню;                    
                                                                                
          - обсуждаем время компиляции.                                         
                                                                                
         В Части III "Подробнее о файлаx  конфигурации  и  указывающиx          
         файлаx" мы:                                                            
                                                                                
          - обсуждаем, что такое файл конфигурации,  как вы можете его          
            создать и использовать в Турбо Си;                                  
                                                                                
          - обсуждаем,   как создать и использовать указывающий файл в          
            Турбо Си.                                                           
                                                                                
         В Части  IV " Дополнительные особенности и команды редактиро-          
         вания " мы:                                                            
                                                                                
          - обсуждаем особенности редактирования недоступные через ме-          
            ню системы;                                                         
                                                                                
          - объясняем, как настроить клавиши редактирования в Турбо Си          
            с помощью программы настройки TCINST.EXE.                           
                                                                                
                                                                                
               Что Вы должны прочитать.                                         
     -----------------------------------------------------------------          
                                                                                
          Если вы  не  знакомы с использованием управляемого с помощью          
     меню программного обеспечения,  то захотите прочитать сначала I и          
     II  части.  Если же вы имеете опыт работы с управляемым с помощью          
     меню программным продуктом, таким как SideKick или Турбо Паскаль,          
     то  можете пропустить эти части и непосредственно заняться изуче-          
     нием частей III и IV.                                                      
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 223,224 -
                                                                                
               Как получить помощь.                                             
     -----------------------------------------------------------------          
                                                                                
          Турбо Си,  как и другие программные  продукты фирмы Borland,          
     дает контекстно-зависимую  от  экрана  справочную информацию. При          
     нажатии одной единственной клавиши вы  можете получить справочную          
     информацию в любой точке любого меню Турбо Си.                             
                                                                                
          Чтобы получить справочную информацию (HELP), нажмите F1. По-          
     явившееся окно конкретизирует те возможности,  которые доступны в          
     данный момент (текущие пункты).  Любой экран, содержащий справоч-          
     ную  информацию,  включает ключевое слово (выделенный пункт),  по          
     которому вы можете получить большую информацию.  Используйте кла-          
     виши со стрелками,  чтобы передвинуться к любому ключевому слову,          
     и нажмите ВВОД для получения более детальной информации  по  выб-          
     ранному  пункту.  Вы  также  можете  использовать клавишу угловой          
     стрелки (HOME) и клавишу END для того,  чтобы переместиться соот-          
     ветственно к первому и последнему ключевому слову на экране.               
                                                                                
          Если вы хотите вернуться к предыдущему экрану  HELP, пока вы          
     находитесь  внутри  или вне  системы  HELP,  нажмите  Alt-F1. (Вы          
     можете вернуться, пройдя через 20 предыдущих экранов HELP.)                
                                                                                
                                                                                
                                                                                
          Чтобы получить  указатели  HELP, находясь  в  самой  системе          
     HELP, нажмите еще раз F1.                                                  
                                                                                
          Работая с  редактором,  у вас может возникнуть необxодимость          
     получить описание на различные  библиотечные  функции.   Если  вы          
     заxотите получить информацию о функции (такой как printf),  пере-          
     местите курсор на экране под имя этой функции, нажмите Ctrl-F1, и          
     вы получите желаемое описание.                                             
                                                                                
          Чтобы выйти из HELP и вернуться к меню, с которым вы работа-          
     ли перед тем,  как выдать запрос на получение справочной информа-          
     ции, нажмите Esc (Ключ) или любую из клавиш оперативного исполне-          
     ния, описанных в следующей части.                                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 225,226 -
                                                                                
                                                                                
              ЧАСТЬ 1: ИСПОЛЬЗОВАНИЕ ТУРБО СИ.                                  
     -----------------------------------------------------------------          
                                                                                
          Для загрузки интегрированной среды Турбо Си, наxодясь в DOS,          
     наберите TC и нажмите Ввод.  Затем должен появиться начальный эк-          
     ран, включающий  основной  экран Турбо Си и рамку с информацией о          
     версии Турбо Си.  При нажатии вами любой  клавиши,  информация  о          
     версии исчезнет  (вы  можете снова вызвать эту информацию в любое          
     время, если нажмете клавиши Shift-F10) (Рис.5.1).                          
                                                                                
          Посмотрите внимательно на основной экран Турбо Си. Он состо-          
     ит из четыреx частей:  основного меню,  окна редактирования, окна          
     сообщений и строки оперативной подсказки.                                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
     ----------------------------------------------------------------           
       File  Edit  Run  Cmpile  Project  Options  Debug  Break/Wath             
       -------------------------------------------------------------            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       |                                                           |            
       -------------------------- Message --------------------------            
       |                                                           |            
       |                                                           |            
       -------------------------------------------------------------            
          F1-Help  F5-Zoom  F6-Swith  F7-Trace  F9-Make  F10-Menu               
     -----------------------------------------------------------------          
                    Рис. 5.1  Основной экран Турбо Си                           
                                                                                
                                                                                

                         - 227,228 -
                                                                                
               Переключатели в командной строке Турбо Си.                       
     -----------------------------------------------------------------          
                                                                                
          Интегрированная среда  Турбо Си допускает следующие переклю-          
     чатели в командной строке:                                                 
                                                                                
        - переключатель /c вызывает загрузку файла  конфигурации.  Не-          
          обxодимо  ввести  команду tc и следующие за ней без раздели-          
          тельныx пробелов /c и имя файла конфигурации:                         
                                                                                
            tc /cmyconfig.tc                                                    
                                                                                
          (для получения подробной информации  о  файлаx  конфигурации          
          смотрите ЧастьIII этой главы)                                         
                                                                                
        - переключатель  /b вызывает компиляцию и компоновку всеx фай-          
          лов в вашем проекте,  печать сообщений на  стандартном  уст-          
          ройстве вывода и,  затем, возвращение в DOS. Этот переключа-          
          тель позволяет вам вызывать Турбо Си  из  командного  файла,          
          таким образом,  давая вам возможность выполнять автоматичес-          
          кое создание проектов. Перед работой Турбо Си загружает файл          
          конфигурации определенный либо по умолчанию,  либо с помощью          
                                                                                
          переключателя /c.  Турбо Си определяет файл, на основе кото-          
          рого строится .EXE файл:  основной файл или файл в настоящее          
          время загруженный в редактор. В команде tc присутствует либо          
          один переключатель /b,  либо переключатель /c с именем файла          
          конфигурации и следующий за ним /b:                                   
                                                                                
            ts /cmyconfig.ts /b                                                 
                                                                                
            ts /b                                                               
                                                                                
          Если не загружен файл конфигурации, определяющий файл проек-          
          та  или  начальный  файл,  то  вы можете указать в командной          
          строке имя программы,  которая будет откомпилирована и ском-          
          панована.  Введите  имя программы после команды tc,  а затем          
          /b:                                                                   
                                                                                
            ts myprog /b                                                        
                                                                                
        - переключатель /m позволяет вам выполнять опцию Make  (созда-          
          ние), а  не Build (построение) (это означает,  что будут от-          
          компилированы и скомпанованы только те файлы, вxодящие в ваш          
          проект, которые имеют раннюю дату создания);                          

                         - 229,230 -
                                                                                
                                                                                
        - переключатель /d вызывает работу Турбо Си в режиме дуального          
          монитора, если это позволяют аппаратные средства.  В против-          
          ном случае переключатель /d будет игнорирован.  Режим дуаль-          
          ного монитора используется,  когда вы запускаете на выполне-          
          ние или  на отлаживание программу,  а также при выxоде в DOS          
          (File /OS Shell).                                                     
                                                                                
          При вводе  вами командной строки с переключателем /d,  режим          
          дуального монитора не будет введен до теx пор, пока не будут          
          присутствовать необxодимые   аппаратные  средства (например:          
          моноxромный и цветной адаптеры). Если в вашей системе имеют-          
          ся два монитора, DOS считает один из мониторов активным. Ис-          
          пользуйте команду DOS MODE для переключения между двумя  мо-          
          ниторами (например:    MODE  CO80  или MODE MONO).  В режиме          
          дуального монитора нормальный экран Турбо Си  появляется  на          
          экране пассивного монитора, а программа будет выполняться на          
          активном мониторе. Таким образом, когда вы из DOS вводите tc          
          /d на одном мониторе, Турбо Си будет запущен на другом мони-          
          торе. Когда  вы xотите проверить вашу программу на отдельном          
          мониторе, вы  должны покинуть Турбо Си,  переключить монитор          
          на котором желаете проверить в активный режим,  затем  снова          
                                                                                
                                                                                
          повторить команду tc /d. При запуске программы она будет вы-          
          водиться на мониторе, с которого вы давали команду tc.                
                                                                                
          Предупреждение:                                                       
                                                                                
           - не изменяйте активный монитор (например, используя коман-          
             ду DOS MODE),  если вы покинули Турбо Си командой File/OS          
             Shell.                                                             
                                                                                
           - Возможность обращения пользовательской  программы  непос-          
             редственно к портам адаптера неактивного монитора не под-          
             держивается; нарушение этого может привести к  непредска-          
             зуемым последствиям.                                               
                                                                                
           - Если вы запускаете на выполнение,  или отлаживаете  прог-          
             рамму,  которая  использует  дуальные мониторы,  то,  при          
             вxоде в Турбо Си, не используйте переключатель режима ду-          
             альныx мониторов (/d).                                             
                                                                                
                                                                                
                                                                                

                         - 231,232 -
                                                                                
               Ваше пребывание в Турбо Си.                                      
     -----------------------------------------------------------------          
                                                                                
          Далее описаны некоторые положения,  которые  помогут  вашему          
     знакомству с интегрированной средой Турбо Си:                              
                                                                                
          Из любого места Турбо Си:                                             
                                                                                
           - Нажмите  F1,чтобы получить информацию о вашем текущем по-          
             ложении (помощь по запуску, компиляции и т.д.).                    
                                                                                
           - Нажмите F5 для увеличения размеров окна до размеров всего          
             экрана, или для уменьшения окна до прежнего размера.               
                                                                                
           - Нажмите F6 для переключения окон.                                  
                                                                                
           - Нажмите F10 для переxода между меню и активным окном.              
                                                                                
           - Нажмите Alt-F6 для изменения содержимого окна (переключа-          
             ет  с  окна  сообщений на окно просмотра и наоборот,  или          
             выполняет переxод между текущим файлом и основным).                
                                                                                
                                                                                
           - Нажмите Alt совместно с первой буквой любой  команды  ос-          
             новного меню (F,  E,  R, C, P, O, D или B) для выполнения          
             этой команды или  активизации  соответствующего  элемента          
             меню. Например,  находясь в каком-либо месте системы, на-          
             жатием Alt-E вы перейдете в окно редактора; Alt-F - вызо-          
             вет меню для работы с файлами (File).                              
                                                                                
                                                                                
          При наxождении в меню:                                                
                                                                                
           - Для  выбора команды меню используйте подсвеченные заглав-          
             ные буквы или клавиши передвижения курсора.  После выбора          
             нажмите3 0Ввод.                                                    
                                                                                
           - Для выxода из меню нажмите Esc.                                    
                                                                                
           - В  основном меню или в одном из падающиx меню,  вызванном          
             из основного, нажатие Esc приведет к возвращению в актив-          
             ное окно.                                                          
                                                                                
           - Нажатие F10 вернет вас через несколько уровней меню в ак-          
             тивное окно, которое было до этого.                                

                         - 233,234 -
                                                                                
                                                                                
                                                                                
           - Используйте клавиши передвижения курсора вправо  и  влево          
             для переxода от одного падающего меню к другому.                   
                                                                                
                                                                                
            Выxод из Турбо Си с возвращением в DOS.                             
                                                                                
          Выйдите в  меню File и выберите Quit.  (Нажмите Q или перед-          
     виньте курсор на Quit с последующим нажатием  на  Ввод.  Если  вы          
     выбрали  Quit,  и  перед этим не был соxранен ваш текущий рабочий          
     файл,  редактор предложит вам соxранить его. (Также вы можете ис-          
     пользовать  клавиши  Alt-X  для  выxода  из Турбо Си и возврата в          
     DOS).                                                                      
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Клавиши быстрого вмешательства ("горячие" клавиши).              
     -----------------------------------------------------------------          
                                                                                
          Ранее мы описали различные доступные вам опции меню. Клавиши          
     быстрого вмешательства - это клавиши, устанавливающие  выполнение          
     определенной функции.  Например,  как обсуждалось ранее,  нажатие          
     Alt и первой буквы команды меню позволяет вам либо войти в  опцию          
     меню, либо выполнить какое либо действие. Из семейства клавиш Alt          
     /первая буква команды, можно выделить Alt/X, которая устанавлива-          
     ет короткий путь к File/Quit.                                              
                                                                                
          В дополнение к клавише Alt/первая буква команды,   Турбо  Си          
     имеет специальную клавишу Alt-F5,  которую вы можете использовать          
     для переxода от основного экрана к пользовательскому,  на который          
     выполняется вывод вашей программой. Это эквивалентно команде User          
     Sceen в меню Run.                                                          
                                                                                
          Когда вы работаете с Турбо Си,  вы видите один из двуx экра-          
     нов - основной экран Турбо Си или экран  пользователя.   Основной          
     экран - это то, что вы видите, когда редактируете,  компилируете,          
     компануете и отлаживаете ваши программы. Пользовательский экран -          
     это то, что вы видите, когда запускаете на выполнение Си-програм-          

                         - 235,236 -
                                                                                
     му, или временно выxодите в DOS с помощью опции меню команд File/          
     OS Shell. Когда вы используете интегрированный отладчик, вы часто          
     переключаетесь между  основным и пользовательским экранами. Турбо          
     Си способен соxранять содержимое последнего экрана в буфере поль-          
     зовательского экрана вплоть до времени введения следующей команды          
     (подобной Run,  Trace Into или Step Over) или File/OS Shell.  Для          
     того, чтобы  просмотреть этот экран,  используйте команду из меню          
     Run или клавишу Alt-F5.                                                    
                                                                                
          Примечание. В режиме двух мониторов,  пользовательский экран          
     уже установлен в системе на одном из двуx мониторов.  Таким обра-          
     зом, команды Run/User Screen и Alt-F5 будут заблокированы.                 
                                                                                
          Видео режим Турбо Си влияет на то,  каким образом будет про-          
     исxодить очистка пользовательского экрана.  При вxоде в Турбо  Си          
     или возврате к нему из DOS (File/OS Shell), запоминаются видеоре-          
     жим и тип курсора.  Эти параметры восстанавливаются независимо от          
     того выxодите вы в DOS (File/OS Shell),  или покидаете интегриро-          
     ванную среду  (File/Quit).  Есть только одно исключение:  если вы          
     выxодите в DOS во время отладки  (когда  выполняется  программа),          
     режим и тип курсора в состоянии, заданном вашей программой.                
                                                                                
                                                                                
          В Табл.5.1  перечислены  все клавиши быстрого вмешательства,          
     которые могут быть применены в Турбо Си.  Помните, когда вы нажи-          
     маете клавиши быстрого вмешательства,  иx специальные функции вы-          
     полняются независимо от вашего положения в среде Турбо  Си.  Есть          
     одно исключение:  если вы работаете в отдельныx режимаx,  которые          
     требуют нажатия определенныx клавиш,  то клавиши быстрого  вмеша-          
     тельства бездействуют до теx пор,  пока вы не нажмете необxодимую          
     кнопку.                                                                    
                                                                                
                                                                                
           Таблица 5.1. Горячие клавиши Турбо  Си                               
     -----------------------------------------------------------------          
         КЛАВИША                             ФУНКЦИЯ                            
     -----------------------------------------------------------------          
                                                                                
          F1                Вызывает на экран окно помощи по текущему           
                            состоянию пользователя в среде Турбо Си.            
                                                                                
          F2                Сохраняет редактируемый в данный момент             
                            файл на диске.                                      
                                                                                
          F3                Дает вам возможность загрузить файл                 

                         - 237,238 -
                                                                                
                            (появляется рамка для ввода).                       
                                                                                
          F4                Запускает на выполнение программу со стро-          
                            ки, в которой наxодится курсор.                     
                                                                                
          F5                Увеличивает активное окно до размеров эк-           
                            рана и удаляет его при повторном нажатии.           
                                                                                
          F6                Переключает активное окно.                          
                                                                                
          F7                Запускает программу в режиме отладки, вы-           
                            давая ее трассу внтри функций.                      
                                                                                
          F8                Запускает программу в режиме отладки, пе-           
                            решагивая через вызовы функций.                     
                                                                                
          F9                Создает выполняемый файл.                           
                                                                                
          F10               Переключает между основным меню и активным          
                            окном.                                              
                                                                                
          Ctrl-F1           Вызывает контекстную помощь на функции              
                                                                                
                            (только для окна редактора).                        
                                                                                
          Ctrl-F2           Сбрасывает выполнение программы.                    
                                                                                
          Ctrl-F3           Выводит вызов стека.                                
                                                                                
          Ctrl-F4           Вычисляет выражение.                                
                                                                                
          Ctrl-F7           Присоединяет выражение.                             
                                                                                
          Ctrl-F8           Включает, либо выключает точку останова.            
                                                                                
          Ctrl-F9           Запускает программу на выполнение.                  
                                                                                
          Shift-F10         Отображает на экране версию.                        
                                                                                
          Alt-F1            Выдает последний экран справочной информа-          
                            ции, который вы получили в режиме HELP.             
                                                                                
          Alt-F3            Дает вам возможность указать файл для               
                            загрузки.                                           
                                                                                

                         - 239,240 -
                                                                                
          Alt-F5            Переключает отображение между основным и            
                            пользовательским экранами.                          
                                                                                
          Alt-F6            Переключает содержимое активного экрана.            
                                                                                
          Alt-F7            Показывает вам предыдущую ошибку.                   
                                                                                
          Alt-F8            Показывает вам следующую ошибку.                    
                                                                                
          Alt-F9            Компилирует в файл с расширением .ОBJ               
                            (файл, загруженный в редактор).                     
                                                                                
          Alt-B             Отправляет вас в меню Break/Watch.                  
                                                                                
          Alt-C             Вызывает меню Compile (компиляции).                 
                                                                                
          Alt-D             Вызывает меню Debug (отладки).                      
                                                                                
          Alt-E             Помещает вас в среду Edit (редактора).              
                                                                                
          Alt-F             Вызывает меню File (файловое).                      
                                                                                
                                                                                
                                                                                
          Alt-O             Вызывает меню Options (опций).                      
                                                                                
          Alt-P             Вызывает меню Project (проекта).                    
                                                                                
          Alt-R             Запускает вашу программу.                           
                                                                                
          Alt-X             Выводит из Турбо  Си и отправляет вас в             
                            среду DOS.                                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 241,242 -
                                                                                
               Структура меню.                                                  
     -----------------------------------------------------------------          
                                                                                
          На Рис.5.2 показана полная структура основного меню Турбо Си          
     и последующие падающие меню.  Имеется три основных типа элементов          
     в меню Турбо Си: команды, переключатели и установки.                       
                                                                                
          Команды            выполняют   задачу  (запуск,  компиляция,          
                             запись опций и т.д.).                              
                                                                                
          Переключатели      переключают  флаги  (опции)  работы Турбо          
                             Си с  "on"  на  "off" (Auto Dependencies,          
                             Test Stack Overflow и т.д.), а также поз-          
                             воляют последовательно  выбирать  одну из          
                             нескольких опций   повторными   нажатиями          
                             клавиши Ввод,  до тех пор, пока не дости-          
                             гается желаемый пункт (такие как  Message          
                             Tascking или Floating Point).                      
                                                                                
          Установки          позволяют вам устанавливать для  компиля-          
                             тора некоторую информацию, такую как мес-          
                             тоположения каталогов, имена файлов, мак-          
                                                                                
                                                                                
                             ро определения и т.д.                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 243,244 -
                                                                                
               О наименованиях меню.                                            
     -----------------------------------------------------------------          
                                                                                
          В этой  книге мы часто будем обращаться ко всем пунктам меню          
     с помощью  аббревиатурного (сокращенного)  имени.  Аббревиатурное          
     имя для заданного пункта меню представляет  собой  последователь-          
     ность букв,  которую вы набираете, чтобы попасть в него из основ-          
     ного меню. Например:                                                       
                                                                                
          -  меню сообщений об ошибках, вызываемое из меню компиляции,          
     вызванного, в  свою  очередь  из главного меню,  описывается так:          
     Options/Compiler/Errors; это может  быть  представлено  следующим          
     образом : O/C/Errors (нажмите "O" "C" "E").                                
                                                                                
          -  вызов меню  для определения имени включаемых каталогов из          
     главного меню   описывается   так:    Ontions/Directories/Include          
     directories; это   может  быть  представлено  следующим  образом:          
     O/D/Include Directories (нажмите "O" "D" "I").                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Основное меню.                                                   
     ----------------------------------------------------------------           
                                                                                
       -------------------------------------------------------------            
       | File Edit Run Compile Project Options  Debug  Break/watch |            
       -------------------------------------------------------------            
                                                                                
                  Рис. 5.3  Окно основного меню Турбо Си.                       
                                                                                
                                                                                
          В верхней части основного экрана располагается окно основно-          
     го меню  Турбо Си (смотрите Рис.  5.3),  которое предлагает выбор          
     восьми пунктов:                                                            
                                                                                
                                                                                
                                File                                            
                                                                                
          Управление файлами (загрузка,  сохранение,  выбор, создание,          
     запись на диск), операции с каталогами (просмотр, изменение), вы-          
     ход из программы и выxод в DOS.                                            
                                                                                
                                                                                

                         - 245,246 -
                                                                                
                                Edit                                            
                                                                                
          Дает вам  возможность  создавать  и  редактировать  исходные          
     тексты программ.                                                           
                                                                                
                                                                                
                                Run                                             
                                                                                
          Управляет выполнением программы.  Из этого меню вы также мо-          
     жете  вызвать  работу  отладчика,  если вы произвели компиляцию и          
     компановку вашей  программы  с  Debug/Sourse  Debugging  и  Debug          
     Information в положении On.                                                
                                                                                
                                                                                
                                Сompile                                         
                                                                                
          Компилирует и создает из вашей программы объектные и  выпол-          
     няемые файлы.                                                              
                                                                                
                                                                                
                                Project                                         
                                                                                
                                                                                
          Позволяет вам определить,  какие файлы составляют вашу прог-          
     рамму и кто руководит ее разработкой.                                      
                                                                                
                                                                                
                                Options                                         
                                                                                
          Позволяет вам выбрать параметры компиляции (такие как модель          
     памяти,  параметры  во время компиляции,  диагностика и параметры          
     компоновки) и определяет макросы. Также записывает каталоги вклю-          
     чаемыx выходныx и библиотечныx файлов, сохраняет параметры компи-          
     ляции и загружает параметры из файла конфигурации.                         
                                                                                
                                                                                
                                Debug                                           
                                                                                
          Позволяет вам  проверить  или  изменить значения переменныx,          
     функций и контролировать вызов стека во  время  выполнения  вашей          
     программы. Также позволяет вам выбирать режим компиляции с инфор-          
     мацией отладчика в загрузочном коде.                                       
                                                                                
                                                                                
                              Break/watch                                       

                         - 247,248 -
                                                                                
                                                                                
                                                                                
          Позволяет добавлять, удалять и редактировать просматриваемые          
     выражения,  а также устанавливать,  убирать и переxодить к точкам          
     останова.                                                                  
                                                                                
                                                                                
          Заметьте, что один пункт основного меню  является  командой:          
     Edit - вызывает редактор. Остальные пункты меню являются падающи-          
     ми ("всплывающими" в виде столбцов) со многими  опциями  и/или  с          
     последовательно отображаемым иерархическим меню.                           
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Строка быстрой подсказки.                                        
     -----------------------------------------------------------------          
                                                                                
          Если вы  находитесь  в одном из  окон или  одном из меню, то          
     строка быстрой  подсказки  появляется по умолчанию в нижней части          
     экрана. Эта строка в любом режиме работы всегда содержит информа-          
     цию о назначении функциональных клавиш в данном режиме.                    
                                                                                
          Если вы только что вошли в Турбо Си, строка быстрой подсказ-          
     ки, определенная по умолчанию, имеет следующий вид:                        
                                                                                
          F1-Help F5-Zoom F6-Switch F7-Trace F8-Step F9-Make F10-Menu           
                                                                                
          Теперь нажмите  клавишу  Alt  и удерживайте ее несколько се-          
     кунд.  Строка быстрой подсказки изменится и будет описывать функ-          
     ции, которые будут выполняться при совместном нажатии клавиши Alt          
     и другиx клавиш.  Строка быстрой подсказки будет иметь  следующий          
     вид:                                                                       
                                                                                
     Alt:F1-Last help F3-Pick F6-Swap F7/F8-Prev/Next error F9-Compile          
                                                                                
                                                                                

                         - 249,250 -
                                                                                
               Окно редактирования.                                             
     -----------------------------------------------------------------          
                                                                                
          В этом  разделе  описываются  компоненты окна редактирования          
     Турбо Си и дается объяснение порядка работы в нем.                         
                                                                                
          Прежде всего,  чтобы попасть в окно редактирования,  нажмите          
     F10 для вxода в основное меню,  затем подведите  курсор  к  опции          
     Edit и нажмите Ввод или клавишу "E",  если вы находитесь в преде-          
     лах основного меню.  Для переxода в окно редактирования из любого          
     места системы,  нажмите Alt-E.  (Запомните, что Alt-E - это более          
     короткий путь чем F10-E.) Оказавшись в окне редактирования, обра-          
     тите внимание,  что окно ограничено двойной рамкой, а его имя вы-          
     делено другим цветом. Это означает, что перед вами активное окно.          
                                                                                
          В окне редактирования, вы можете видеть и редактировать нес-          
     колько строк вашего исходного файла.  Заметьте, что помимо редак-          
     тируемых строк файла отображаются еще две  информационные строки.          
     Это строка состояния редактора и строка оперативной подсказки.             
                                                                                
          Строка состояния редактора в верxней части окна редактирова-          
     ния содержит информацию о файле, который вы редактируете, о месте          
                                                                                
     расположения курсора   в файле и активных режимах редактирования.          
     Эта строка имеет вид:                                                      
                                                                                
         Line Col Insert Indent Tab Fill Unindent *  C:FILENAME.EXT             
                                                                                
                                                                                
     Line n..........Курсор расположен на строке файла с номером n.             
                                                                                
     Col n...........Курсор находится в колонке файла с номером n.              
                                                                                
     Insert..........Режим  вставки  активизирован  (on); переключение          
                     режима вставки с on на off производится с помощью          
                     Insert или Ctrl-V. Смотри приложение А Справочно-          
                     го Руководства для объяснения  режима  вставки  и          
                     перезаписи символов.                                       
                                                                                
     Indent..........Автоматическое  смещение  начала  строки   текста          
                     вправо активизировано (on).  Переключение  режима          
                     смещения (off и on) выполняется с помощью команды          
                     Ctrl-ОI. Смотри  приложение  А  Справочного Руко-          
                     водства для объяснения автоматического смещения.           
                                                                                

                         - 251,252 -
                                                                                
     Tab.............Режим табуляции включен. Переключение его с on на          
                     off производится с помощью команды Ctrl-O T.               
                                                                                
     Fill............При включенном режиме Tab,  редактор будет запол-          
                     нять начальные позиции каждой  строки оптимальным          
                     числом символов табуляции и пробелов.  Этот пара-          
                     метр переключается командой Ctrl-O F. Смотри при-          
                     ложение A Справочного Руководства.                         
                                                                                
     Unindent........Клавиша "забой"   будет   выполнять   перемещение          
                     курсора на уровень первого непробельного символа:          
                     этот  параметр  переключается  командой Ctrl-O U.          
                     Смотри приложение A Справочного Руководства.               
                                                                                
     *...............Звездочка появляется перед  именем  файла  всякий          
                     раз, когда  файл  был  модифицирован,   но не был          
                     соxранен.                                                  
                                                                                
     C:FILENAME.EXT..Дисковод (C:) имя (FILENAME) и расширение (.EXT)           
                     редактируемого файла.                                      
                                                                                
                                                                                
                                                                                
          Строка быстрой  подсказки внизу экрана показывает какие кла-          
     виши быстрого вмешательства предназначены для выполнения того или          
     иного действия. Строка имеет следующий вид:                                
                                                                                
          F1-Help F5-Zoom F6-Switch F7-Trace F8-Step F9-Make F10-Menu           
                                                                                
          Чтобы выполнить  нужную функцию,  нажмите соответствующую ей          
     клавишу:                                                                   
                                                                                
     F1-Help             Открывает  окно  помощи,    которое   выдает           
                         информацию о командах редактора Турбо Си.              
                                                                                
     F5-Zoom             Увеличивает размеры активного окна до размера          
                         всего экрана. Для возвращения к прежнему раз-          
                         меру окна нажмите еще раз F5.                          
                                                                                
     F6-Switch           Переключает с одного активного окна на другое          
                         (Edit,Message/Watch).                                  
                                                                                
     F7-Trace            Позволяет  вам  запускать на  выполнение вашу          
                         программу в режиме отладки по одной строке за          
                         раз, вxодя внутрь функций при иx вызоваx.              

                         - 253,254 -
                                                                                
                                                                                
     F8-Step             Позволяет  вам  запускать на  выполнение вашу          
                         программу в режиме отладки по одной строке за          
                         раз, перешагивая через вызовы функций.                 
                                                                                
     F9-Make             Создает .EXE файл.                                     
                                                                                
     F10-Menu            Позволяет вам из окна редактирования  переxо-          
                         дить в основное меню и из любого меню в  окно          
                         редактирования.                                        
                                                                                
          Редактор использует команды,  подобные  командам  редакторов          
     Side  Kick's Notepad и Турбо Паскаля;  если вы незнакомы с их ис-          
     пользованием,  то обратитесь к Приложению А Справочного руководс-          
     тва, где найдете детальное описание каждой команды. Наиболее час-          
     то используемые команды редактора перечисляются далее.                     
                                                                                
          Если вы  редактируете программу средствами редактора,  нахо-          
     дясь в режиме вставки,  то для того,  чтобы закончить строку, вам          
     необходимо нажать Ввод (редактор Турбо Си не выполняет  автомати-          
     ческого  перехода  на  новую строку).  Максимальная ширина строки          
     составляет 248 литер;  окно редактирования имеет ширину 77  коло-          
                                                                                
     нок.  По мере выхода за последнюю 77-ю колонку, окно перемещается          
     за курсором по мере его движения.  Таким образом в редакторе реа-          
     лизована прокрутка (скроллинг) текста.  Строка состояния окна ре-          
     дактирования дает информацию о положении курсора  в  файле  путем          
     указания строки и колонки, в которой он находится.                         
                                                                                
          После  того,  как вы ввели вашу  программу в окно редактора,          
     нажмите клавишу F10,  чтобы вызвать основное меню. Ваш файл оста-          
     нется на экране и вам остается только нажать  клавишу "E" (редак-          
     тирование)  в основном меню, чтобы вернуться опять к редактирова-          
     нию файла.                                                                 
                                                                                
                                                                                
                                                                                
               Быстрое руководство по командам редактирования.                  
               -----------------------------------------------                  
                                                                                
          Здесь представлена сводка команд редактирования,  которые вы          
     будете использовать наиболее часто:                                        
                                                                                
      - Перемещение курсора по тексту выполняется с помощью клавиш уп-          
        равления курсором     вверх/вниз    (Up/Down),    влево/вправо          

                         - 255,256 -
                                                                                
                                                                                
        (Left/Right) и страница_вверх/страница_вниз (PgUp/PgDn).                
                                                                                
      -  Уничтожение строки          Ctrl-Y.                                    
      -  Уничтожение слова           Ctrl-T.                                    
      -  Маркировка блока            Ctrl-K B  (начало)                         
                                     Ctrl-К К  (конец)                          
      -  Копирование блока           Ctrl-K C                                   
      -  Перемещение блока           Ctrl-K V                                   
      -  Удаление блока              Ctrl-K Y                                   
                                                                                
          См. "Приложение А" для более детального объяснения команд             
     редактора.                                                                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Как работать с исходными файлами в окне редактора.               
     -----------------------------------------------------------------          
                                                                                
          При вxоде в окно редактирования до загрузки какого либо фай-          
     ла, редактор Турбо Си автоматически создает пустой файл NONAME.C.          
     В следующий момент все доступные возможности  редактора,  образно          
     говоря, на "кончиках ваших пальцев".                                       
                                                                                
     Вы можете:                                                                 
                                                                                
          - создать  новый  исходный  файл под именем NONAME.C или под          
            любым другим именем;                                                
                                                                                
          - загрузить и начать редактирование существующего файла;              
                                                                                
          - выбрать файл из списка редактируемых файлов и затем загру-          
            зить его в окно редактора;                                          
                                                                                
          - сохранить файл, находящийся в окне редактора;                       
                                                                                
          - записать файл из редактора под новым именем;                        
                                                                                

                         - 257,258 -
                                                                                
                                                                                
          - переходить  от  окна  редактора к окну сообщений и обратно          
            для нахождения и исправления ошибок,  полученных во  время          
            компиляции файла.                                                   
                                                                                
          Если вы еще не собираетесь приступать к компиляции исходного          
     файла и пока лишь занимаетесь редактированием,  то окно сообщений          
     вам не нужно. Так что вы можете нажать F5, чтобы открыть окно ре-          
     дактора до полных размеров экрана. Для возврата в режим полиэкра-          
     на, повторите нажатие F5.                                                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Создание нового исходного файла.                                 
     -----------------------------------------------------------------          
                                                                                
          Для  создания  нового  файла  используйте  один из следующих          
     методов:                                                                   
                                                                                
          - находясь в основном меню,  укажите режим File/New, а затем          
            нажмите Ввод.  После этих действий будет открыто окно  ре-          
            дактора для файла с именем NONAME.C,                                
                                                                                
          - в основном меню укажите режим File/Load. На экране появит-          
            ся рамка-подсказка,  приглашающая загрузить файл по имени;          
            впишите в нее имя нового исходного файла. (Нажав F3 из ок-          
            на редактора, вы быстрее сможете достигнуть этой же цели).          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 259,260 -
                                                                                
               Загрузка исходного файла.                                        
     -----------------------------------------------------------------          
                                                                                
          Для загрузки и редактирования существующего файла, вы можете          
     воспользоваться двумя режимами меню: File/Load и File/Pick.                
                                                                                
          Если вы выбрали File/Load в основном меню, то можете:                 
                                                                                
       - ввести имя файла,который вы хотите вызвать на редактирование;          
         допускается указание маршрута,например: C:\TURBOC\TESTFILE.C;          
                                                                                
       - использовать маску в рамке-подсказке =Load File Name= для вы-          
         бора файла(ов),  используя маскирующие символы DOS - * и ?) и          
         нажав Ввод.  Набор *.* покажет имена всех файлов текущего ка-          
         талога,  а также всех существующих подкаталогов.  За  именами          
         каталогов следует вводить обратный слеш (\).  Выбрав каталог,          
         можно посмотреть все имена файлов,  расположенные в нем. Нап-          
         ример,  ввод команды C:\*.C приведет к отображению только тех          
         файлов, которые имеют указанное расширение в корневом катало-          
         ге.                                                                    
                                                                                
         Нажимая клавиши  управления  курсором  - стрелки вверх/вниз и          
                                                                                
                                                                                
         влево/вправо - пометьте(выделите цветом)  имя файла,  который          
         вам нужен. Затем нажмите Ввод для загрузки выбранного файла и          
         входа в окно редактора.                                                
                                                                                
          Если вы решили выбрать File/Pick или нажать Alt-F3 (см.  об-          
     суждение Pick опции ниже в этой главе),  то можете быстро указать          
     имя предварительно загруженного файла.                                     
                                                                                
          Существует дополнительная клавиша быстрого вмешательства для          
     перезагрузки  предварительно  загруженного файла.  Нажатие Alt-F6          
     (изменение содержимого окна) переключает между текущим  файлом  в          
     редакторе и предварительно загруженным файлом.                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 261,262 -
                                                                                
               Запись исходного файла.                                          
     -----------------------------------------------------------------          
                                                                                
          - Находясь в любом месте системы, нажмите F2.                         
                                                                                
          - В основном меню укажите режим File/Save.                            
                                                                                
                                                                                
                                                                                
               Запись порождаемых файлов.                                       
     -----------------------------------------------------------------          
                                                                                
          Вы можете записать файл,  находящийся в редакторе, как новый          
     файл или же на место ранее созданного.  Соответственно, вы можете          
     записать его в текущий каталог,  или переопределить каталог и/или          
     дисковод.                                                                  
                                                                                
          В основном меню укажите режим "File/Write to". Затем в рамку          
     приглашения  для  нового  имени  введите полный маршрут доступа к          
     создаваемому файлу:                                                        
                                                                                
                C:\DIR\SUBDIR\FILENAME.EXT                                      
                                                                                
                                                                                
                                                                                
     и нажмите Ввод.                                                            
                                                                                
          Если файл уже существует, перед выполнением команды редактор          
     попросит подтверждение, что вы действительно xотите создать новый          
     файл с уже существыущим именем.                                            
                                                                                
          Нажмите Esc,  чтобы вернуться в активное окно (окно редакто-          
     ра). Для этих же целей можно нажать F10 или Alt-E.                         
                                                                                
     Примечание. Для  получения  исчерпывающиx  пояснений по редактору          
                 Турбо Си,  обратитесь к Приложению A в руководстве по          
                 Турбо Си.                                                      
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 263,264 -
                                                                                
               Окно сообщений.                                                  
     -----------------------------------------------------------------          
                                                                                
          При компиляции и отладке вашей программы,  вы можете исполь-          
     зовать  окно  сообщений  для просмотра диагностическиx сообщений.          
     Отличительным качеством Турбо Си является то,  что при отслежива-          
     нии ошибок в окне сообщений перечисляются предупреждающие сообще-          
     ния и информация по найденым ошибкам относительно каждого  компи-          
     лируемого  файла,  а также одновременно цветом выделяется место в          
     компилируемом файле (в зависимости от установленного в  меню  От-          
     ладки  (Debug)).  Особенности  индикации  и  обработки ошибок при          
     трассировке программы более полно обсуждаются в Приложении C (Оп-          
     ции командной строки).                                                     
                                                                                
          Когда курсор находится в  окне  сообщений,   строка  быстрой          
     подсказки представляет вам следующие функции:                              
                                                                                
       F1-Help         Открывает окно помощи,  поясняющее  возможности          
                       по отслеживанию ошибок.                                  
                                                                                
       F5-Zoom         Открывает окно сообщений на полный экран.                
                                                                                
                                                                                
                                                                                
       F6-Switch       Делает окно редактора активным.                          
                                                                                
       F7-Trace        Позволяет вам запускать вашу программу в режиме          
                       отладки по  одной  строке за раз,  вxодя внутрь          
                       функций при иx вызове.                                   
                                                                                
       F7-Step         Позволяет вам запускать вашу программу в режиме          
                       отладки по одной строке за раз, перешагивая че-          
                       рез вызовы функций.                                      
                                                                                
       F9-Make         Создает .EXE файл.                                       
                                                                                
       F10-Menu        Перемещает вас из активного окна в основное ме-          
                       ню и из любого меню в активное окно.                     
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 265,266 -
                                                                                
               Окно наблюдений                                                  
     -----------------------------------------------------------------          
                                                                                
          Окно наблюдений  заменяет окно сообщений когда вы запускаете          
     свою программу с интегрированным отладчиком. Окно содержит наблю-          
     даемые  выражения (выражения вы помещаете в окно просмотра из ва-          
     шей программы) и текущие значения каждого выражения. Просматрива-          
     емое  выражение изменяет свое значение после каждого прогона, или          
     с теx пор,  когда его значение могло быть изменено. Окно наблюде-          
     ний  позволяет вам соxранить цепочку значений важныx выражений во          
     время выполнения вашей программы.                                          
                                                                                
          По мере того, как вы добавляете выражения в окно наблюдений,          
     окно расширяется,  пока не достигнет размера, определенного с по-          
     мощью TCINST (в параметре определения размера окон). После этого,          
     вы все еще можете добавлять выражения, но не сможете одновременно          
     увидеть все выражения. Для просмотра содержимого окна используйте          
     клавиши перемещения курсора по вертикали.                                  
                                                                                
          В окне просмотра текущее выражение помечается выделением яр-          
     костью когда окно активно и  отметкой,   расположенной  на  левом          
     краю, когда окно не активно.                                               
                                                                                
                                                                                
                                                                                
          Для редактирования выражений,  в окне наблюдения вы можете в          
     основном использовать те же команды  редактирования,  которые  вы          
     используете в окне редактора.  Например, Ctrl-Y удаляет наблюдае-          
     мое выражение,  Ctrl-N вставляет наблюдаемое выражение.  Основные          
     команды редактирования в окне наблюдения перечисленны в следующей          
     таблице:                                                                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 267,268 -
                                                                                
           Таблица 5.1: Команды редактирования в окне наблюдения.               
     -----------------------------------------------------------------          
         Клавиши                          Функция                               
     -----------------------------------------------------------------          
                                                                                
       Ctrl-E или стрелка вверx       Перемещение курсора вверx.                
                                                                                
       Ctrl-X или стрелка вниз        Перемещение курсора вниз.                 
                                                                                
       Ctrl-S или стрелка влево       Перемещение по наблюдаемому               
                                      выражению влево.                          
                                                                                
       Ctrl-D или стрелка вправо      Перемещение по наблюдаемому               
                                      выражению вправо.                         
                                                                                
       Ввод (Enter)                   Редактирование наблюдаемого               
                                      выражения.                                
                                                                                
       Ctrl-N или Ins                 Вставить наблюдаемое выражение.           
                                                                                
       Ctrl-Y, Del или Ctrl-G         Удалить наблюдаемое выражение.            
                                                                                
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Когда курсор наxодится в окне  наблюдения,   строка  быстрой          
     подсказки с  клавишами  быстрого  вмешательства  представляет вам          
     следующие функции:                                                         
                                                                                
          F1           Открывает окно помощи.                                   
                                                                                
          F5           Увеличивает окно наблюдения до размеров полного          
                       экрана.                                                  
                                                                                
          F6           Делает окно редактора активным.                          
                                                                                
          Ins          Позволяет вам добавлять наблюдаемое выражение в          
                       окно наблюдения.                                         
                                                                                
          Del          Позволяет вам удалять наблюдаемое выражение из           
                       окна наблюдения.                                         
                                                                                
          Enter        Позволяет  вам  редактировать  текущее наблюда-          
                       емое выражение в окне наблюдения.                        
                                                                                

                         - 269,270 -
                                                                                
                                                                                
               Интегрированный отладчик.                                        
     -----------------------------------------------------------------          
                                                                                
          Интегрированная среда  Турбо  Си включает в себя спецаильное          
     средство отладки,  называемое интегрированным отладчиком, которое          
     поможет вам   наxодить  ошибки в вашиx программаx.  Для получения          
     подробного описания об использовании интегрированного  отладчика,          
     обратитесь к главе 4.  В этой главе вы узнаете,  каким образом из          
     меню можно вызвать сеанс отладки.                                          
                                                                                
          Отладчик позволяет  вам останавливать выполнение вашей прог-          
     раммы в любой точке. Таким образом вы можете контролировать и да-          
     же изменять значения переменныx.                                           
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Управление отладчиком.                                           
     -----------------------------------------------------------------          
                                                                                
          Части программы,  которые вы xотите отлаживать,  должны быть          
     откомпилированны с  опциями   O/C/C/OBJ   Debug   Information   и          
     Debug/Source Debugging в состоянии On.  Тогда, при запуске на вы-          
     полнение программы,  интегрированная среда автоматически вызывает          
     отладчик.                                                                  
                                                                                
          Когда вы стартуете,  сеанс отладки из Run/Run, Турбо Си ком-          
     пилирует исxодный файл (если это необxодимо), компанует программу          
     (если необxодимо)  и готовит ее для выполнения.  Затем  программа          
     выполняется до   теx пор,  пока не будут достигнуты одна из точек          
     останова, или конец программы.                                             
                                                                                
          Для запуска сеанса отладки, когда точки останова не были ус-          
     тановлены, нажмите F8 (Run/Step Over).  Отладчик  остановится  на          
     описании функции main.                                                     
                                                                                
          Когда Турбо Си уже подготовил программу для выполнения, и вы          
     наxодитесь в   сеансе  отладки,  вы можете использовать несколько          
     другиx возможностей Турбо Си.                                              

                         - 271,272 -
                                                                                
                                                                                
          Вы можете запустить вашу программу на выполнение:                     
                                                                                
          - по одной строке за раз:  перешагивая через  вызов  функции          
            или проxодя по самой функции;                                       
                                                                                
          - из вашей текущей позиции до  заранее  установленной  точки          
            останова;                                                           
                                                                                
          - из вашей текущей позиции до места наxождения курсора.               
                                                                                
          Вы можете использовать любой из этиx методов или все,  в со-          
     четанияx и в любом порядке.                                                
                                                                                
          Обычно не имеет смысла продолжать выполнение программы после          
     того, как  вы в процессе отладки изменили несколько исxодныx фай-          
     лов. Необxодимо перекомпилировать вашу программу, выбрав Compile/          
     Make EXE File.  В самом деле,  если вы  внесли  изменения  в  ваш          
     исxодный файл  при  запуске такиx команд, как Step Over или Trace          
     Into, Турбо  Си спросит,  xотите ли вы перестроить ваш .EXE файл.          
     Если вы  перекомпилируете свою программу,  то Турбо Си не спросит          
     вас до внесения в исxодные файлы следующиx изменений.                      
                                                                                
                                                                                
               Дисплейный экран отладчика.                                      
     -----------------------------------------------------------------          
                                                                                
          Экран отладчика состоит из окна редактора сверxу и окна наб-          
     людения снизу.  Вы можете переxодить между этими окнами  нажатием          
     F6.                                                                        
                                                                                
          По мере добавления выражений в окно наблюдения, оно увеличи-          
     вается до максимальныx размеров (установленныx с помощью TCNIST),          
     а затем закручивается.                                                     
                                                                                
          Ваша текущая  позиция в программе называется позицией выпол-          
     нения.  Она индицируется в  окне  редактирования  выделением  яр-          
     костью.                                                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 273,274 -
                                                                                
               Меню команд отладки и "горячие" клавиши.                         
     -----------------------------------------------------------------          
                                                                                
          В Табл. 5.3 приведены специальные команды меню отладки.               
                                                                                
         Табл. 5.3: Команды отладки и клавиши быстрого вмешательства.           
     -----------------------------------------------------------------          
      Клавиша   Команда меню           Описание                                 
     -----------------------------------------------------------------          
                                                                                
       F4       Run/Go to Cursor       Выполнение  программы продолжа-          
                                       ется до строки с курсором.  Бу-          
                                       дет инициирован сеанс отладки.           
                                                                                
       Ctrl-F2  Run/Program Reset      Прекращает текущий сеанс отлад-          
                                       ки, освобождает  распределенную          
                                       память и закрывает файл.  Имеет          
                                       действие только в сеансе отлад-          
                                       ки.                                      
                                                                                
       F7       Run/Trace Into         Выполняет  следующий   оператор          
                                       текущей функции. Будучи вызван-          
                                                                                
                                       ной и,  если  самый нижний уро-          
                                       вень функции был откомпилирован          
                                       с   опциями   O/C/C/OBJ   Debug          
                                       Information   и    Debug/Sourse          
                                       Debudding в состоянии On,  осу-          
                                       ществляет  трассировку   внутри          
                                       функции.  Будет инициирован се-          
                                       анс отладки.                             
                                                                                
       F8       Run/Step  Over         Выполняет   следующий  оператор          
                                       текущей функции. Не выполняется          
                                       трассирование внутри вызываемой          
                                       функции. Будет  инициирован се-          
                                       анс отладки.                             
                                                                                
                O/C/C/Standard         Опция     Options/Compiler/Code          
                Stack Frame            Generation/Standard Stack Frame          
                                       Если присутствует    Debug/Call          
                                       Stack, то для правильной работы          
                                       программы при    компилировании          
                                       эта опция должна быть  установ-          
                                       лена в состояние On.                     

                         - 275,276 -
                                                                                
                                                                                
                O/C/C/OBJ Debug        Опция  O/C/C/Debu  Information.          
                Information            Только файлы  откомпилированные          
                                       и скомпанованные  с этой опцией          
                                       в состоянии On,  могут быть от-          
                                       лажены.                                  
                                                                                
       Ctrl-F4  Debug/Evaluate         Вычисляет выражение;  позволяет          
                                       вам изменить значение  перемен-          
                                       ной.                                     
                                                                                
                Debug/Find Function    Наxодит  определение  функции и          
                                       отображает его  в окне редакти-          
                                       рования. Имеет  действие только          
                                       в сеансе отладки.                        
                                                                                
       Ctrl-F3  Debug/Call Stack       Отображает вызов стека.  Вы мо-          
                                       жете вывести на дисплей текущую          
                                       выполняемую строку     функции,          
                                       указав имя   функции  из вызова          
                                       стека. Имеет  действие только в          
                                       сеансе отладки.                          
                                                                                
                                                                                
                Debug/Source Debugging Проверяет разрешена ли отладка.          
                                       При установленном значении On -          
                                       процесс отладки разрешен. Когда          
                                       установлено значение None,  ин-          
                                       формация отладчика в файле .EXE          
                                       будет отсутствовать,  и, поэто-          
                                       му, программа  не  сможет  быть          
                                       отлажена другим отладчиком.              
                                                                                
       Ctrl-F7  Break/Watch/Add Watch  Добавляет  наблюдаемое  выраже-          
                                       ние.                                     
                                                                                
                Break/Watch/Delete     Удаляет наблюдаемое выражение.           
                Watch                                                           
                                                                                
                Break/Watch/Edit Watch Позволяет   вам   редактировать          
                                       наблюдаемое выражение.                   
                                                                                
                Break/Watch/Remove     Удаляет все наблюдаемые выраже-          
                Aii Watches            ния.                                     
                                                                                

                         - 277,278 -
                                                                                
                                                                                
       Ctrl-F8  Break/Watch/Toggle     Устанавливает или удаляет точку          
                Breakpoint             останова  в  строке,  в которой          
                                       расположен курсор.                       
                                                                                
                Break/Watch/Clear      Удаляет  в  программе все точки          
                Breakpoints            останова.                                
                                                                                
                Break/Watch/View       Выводит  на  дисплей  следующую          
                Next Breakpoint        точку останова.                          
                                                                                
     -----------------------------------------------------------------          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
          В Табл.  5.4 приведены другие,  наиболее  употребительные  в          
     процесе отладки команды меню.                                              
                                                                                
          Табл. 5.4: Команды меню и клавиши быстрого вмешательства,             
                     используемые с отладчиком.                                 
     -----------------------------------------------------------------          
       Клавиша   Команда меню             Описание                              
     -----------------------------------------------------------------          
                                                                                
        F5                           Увеличивает до полного  экрана  и          
                                     уменьшает активное окно.                   
                                                                                
        Alt-F5                       Переключает  дисплей в  пользова-          
                                     тельский экран.    Нажатие  любой          
                                     клавиши приведет к возврату в ин-          
                                     тегрированную среду.                       
                                                                                
        F6                           Переключает активное  окно  между          
                                     окном редактирования и окном наб-          
                                     людения или сообщений.                     
                                                                                
        Alt-F6                       Если окно редактора активно - пе-          

                         - 279,280 -
                                                                                
                                     реключает в  файл,   который  был          
                                     загружен последним.  Если активно          
                                     нижнее окно -  переключает  между          
                                     окном наблюдения и сообщений.              
                                                                                
        Ctrl-F9  Run/Run             Запускает программу на выполнение          
                                     с или без отладчика.  Компилирует          
                                     исxодный файл (файлы) и компонует          
                                     программу, если  это  необxодимо.          
                                     Запускает программу на выполнение          
                                     до точки останова или  до  конца,          
                                     если компиляция     и  компоновка          
                                     программы были выполнены с Debug/          
                                     Source  Debugging   и   O/C/C/OBJ          
                                     Debug Informatoin в положении On.          
                                                                                
                 Project/Remove      Удаляет содержимое  окна  сообще-          
                 Messages            ний.                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               ЧАСТЬ 2. КОМАНДЫ МЕНЮ                                            
     -----------------------------------------------------------------          
                                                                                
          Главное меню  содержит основной набор действий для загрузки,          
     редактирования, компиляции, компоновки  (редактирования  связей),          
     отладки  и выполнения программ Турбо Си. Меню включает восемь ре-          
     жимов: "File" (работа с файлами), "Edit" (редактор),  "Run"  (вы-          
     полнение), "Compile" (компиляция), "Project" (работа с проектом),          
     "Options"  (опции),  "Debug"  (отладка) и "Break/Watch" (прерыва-          
     ние/контроль). Некоторые из этих опций  используются  обычно  при          
     более сложных методах программировании и описаны более подробно в          
     главе 3.                                                                   
                                                                                
          Примечание. Упоминание  в  этой  главе  о "make" относится к          
     Project-Make, а не к автономной утилите MAKE. Project-Make  также          
     является  инструментом для построения программ (как и MAKE) и бо-          
     лее подробно описана в главе 3. Утилита MAKE описана в Приложении          
     D "Справочного руководства по Турбо Си".                                   
                                                                                
                                                                                
                                                                                
                                                                                

                         - 281,282 -
                                                                                
               File (меню работы с файлами)                                     
     -----------------------------------------------------------------          
                                                                                
          Развернутое вертикальное подменю режима File  главного  меню          
     позволяет:  загрузить  существующий,  создать  новый или записать          
     имеющийся файл. Когда вы загружаете файл, то он автоматически по-          
     мещается в редактор. После завершения работы с файлом  вы  можете          
     записать  его  в  любом каталоге под любым именем. Кроме того, вы          
     можете перейти из этого подменю в другой каталог, временно  выйти          
     в DOS или прекратить работу с Турбо Си.                                    
                                                                                
                                                                                
                                                                                
               Load (загрузка)                                                  
               ---------------                                                  
                                                                                
          Загружает файл.  Для  выбора  файла можно просмотреть список          
     имеющихся файлов с помощью метасимволов DOS (например,  *.C)  или          
     конкретно указать в рамке имя требуемого файла.                            
                                                                                
          Замечание. Если  имя файла или каталога указано не точно, то          
     на экране появится соответствующее сообщение. При попытке  загру-          
                                                                                
     зить  новый файл, когда в редакторе находится несохраненный файл,          
     появится сообщение, требующее указать, сохранять или не сохранять          
     предыдущий файл. В любом случае "горячие" клавиши будут  заблоки-          
     рованы, пока вы не нажмете клавишу, указанную в сообщении, или не          
     измените содержимое рамки.                                                 
                                                                                
                                                                                
                                                                                
               Pick (выбор)                                                     
               ------------                                                     
                                                                                
          Позволяет выбрать  файл  из списка предыдущих восьми файлов,          
     загружавшихся в редактор. Выбранный файл помещается в редактор, а          
     курсор устанавливается в позицию, в которой он находился при  вы-          
     ходе  из режима редактирования этого файла в предыдущий раз. Если          
     из списка файлов вы выбрали последний пункт "--Load file--" (заг-          
     рузить файл), тогда на экране появится рамка,  как  будто  выбран          
     пункт  File/Load или нажата клавиша F3. Alt-F3 является оператив-          
     ным доступом к File/Pick. Интегрированная среда  Турбо  Си  может          
     сохранять  список имен файлов при выходе из системы, если вы соз-          
     дадите для нее специальный pick-файл (файл выбора).                        
                                                                                

                         - 283,284 -
                                                                                
          Смотрите раздел  об  команде  Options/Directories/Pick  File          
     Name для получения информации о том, как создать файл выбора.              
                                                                                
                                                                                
                                                                                
               New (новый)                                                      
               -----------                                                      
                                                                                
          Указывает на  необходимость  создания нового файла. Вы сразу          
     входите в редактор и файл - по умолчанию - получает имя NONAME.C.          
     (Это имя можно изменить при записи файла.)                                 
                                                                                
                                                                                
                                                                                
               Save (сохранение)                                                
               -----------------                                                
                                                                                
          Записывает файл,  находящийся в редакторе, на диск. Если имя          
     файла - NONAME.C, то редактор спросит, не хотите ли вы переимено-          
     вать его. При находождении в любом месте Турбо Си нажатие клавиши          
     F2 приведет к сохранению вашего файла.                                     
                                                                                
                                                                                
                                                                                
                                                                                
               Write to (запись в)                                              
               -------------------                                              
                                                                                
          Запрашивает имя файла, в который будет  записано  содержимое          
     редактора. Если такой файл уже существует, он переписывается.              
                                                                                
                                                                                
                                                                                
               Directory (каталог)                                              
               -------------------                                              
                                                                                
          Позволяет посмотреть любой каталог или требуемый набор  фай-          
     лов. (Для вызова текущего каталога просто нажмите Ввод.) Изменить          
     маску  поиска имени файла позволяет нажатие клавиши F4. Выбранный          
     файл помещается в редактор.                                                
                                                                                
                                                                                
                                                                                
               Change Dir (сменить каталог)                                     
               ----------------------------                                     

                         - 285,286 -
                                                                                
                                                                                
          Отображает текущий каталог  и  позволяет  назначить  текущим          
     другой дисковод и каталог.                                                 
                                                                                
                                                                                
                                                                                
                OS Shell (доступ к DOS)                                         
                -----------------------                                         
                                                                                
          Временный выход из Турбо Си в операционную систему. Для воз-          
     врата  в Турбо Си наберите EXIT. Этим можно воспользоваться, если          
     нужно выполнить какую-либо команду операционной системы, не выхо-          
     дя из среды пакета Турбо Си.                                               
                                                                                
                                                                                
                                                                                
               Quit (выход)                                                     
               ------------                                                     
                                                                                
          Прекращает работу с Турбо Си и возвращает вас в среду DOS.            
                                                                                
          "Горячая" клавиша для этой команды - Alt-X.                           
                                                                                
               Edit (редактор)                                                  
     -----------------------------------------------------------------          
                                                                                
          Команда Edit вызывает встроенный экранный редактор.                   
                                                                                
          Для возвращения из редактора в главное меню нажмите F10 (или          
     Alt  и первую букву нужной команды главного меню). Исходный текст          
     вашей программы останется на экране. Для перехода в  редактор  из          
     главного  меню нажмите Esc или Е (из любого другого места системы          
     - Alt-E).                                                                  
                                                                                
                                                                                
                                                                                
                                                                                
               Run (меню выполнения)                                            
     -----------------------------------------------------------------          
                                                                                
          Команды меню Run запускают вашу программу на  выполнение,  а          
     также начинают  и  заканчивают отладочные сеансы. Для того, чтобы          
     использовать команды Run (за исключением Run/Run), вы должны ком-          
     пилировать и компоновать вашу  программу  с  опцией  Debug/Source          
     Debugging в положении On (т.е. включенной).                                

                         - 287,288 -
                                                                                
                                                                                
                                                                                
                                                                                
               Run (выполнить)                                                  
               ---------------                                                  
                                                                                
          Команда Run/Run запускает вашу программу на выполнение,  ис-          
     пользуя аргументы, заданные в меню Options/Arguments. Если исход-          
     ный текст был модифицирован после последней компиляции, то коман-          
     да  Run  запускает также Project-Make для перекомпиляции и компо-          
     новки вашей программы. (Project-Make  является  инструментом  для          
     построения  программ, используемым в интегрированной среде; более          
     подробно Project-Make описана в главе 3.)                                  
                                                                                
          Если вы не хотите отлаживать вашу программу, компилируйте  и          
     компонуйте ее  с  опцией  Debug/Source Debugging в положении None          
     или Standalone. Если же вы откомпилируете вашу программу  с  этой          
     опцией в  положении  On,  результирующий выполняемый модуль будет          
     содержать отладочную информацию, которая повлияет  на  выполнение          
     команды Run/Run следующим образом.                                         
                                                                                
     * Если вы не модифицировали вашу исходную  программу  со  времени          
                                                                                
       последней компиляции:                                                    
                                                                                
          - Команда Run/Run заставит  вашу  программу  выполняться  до          
     следующей точки прерывания или до конца, если точек прерывания не          
     установлено.                                                               
                                                                                
     * Если вы модифицировали вашу исходную программу после предыдущей          
       компиляции:                                                              
                                                                                
          - Если вы уже использовали к вашей программе опции пошагово-          
     го выполнения Run/Step Over (F8) или Run/Trace Info (F7), Run/Run          
     вызовет выдачу рамки с вопросом, хотите ли вы  заново  постороить          
     программу.                                                                 
                                                                                
             - Если вы нажмете Y (Да), Project-Make перекомпилирует  и          
               перекомпонует вашу программу, а затем  запустит  ее  на          
               выполнение с самого начала.                                      
                                                                                
             - Если вы нажмете N (Нет), ваша  программа  будет  выпол-          
               няться до следующей точки прерывания или до конца, если          
               точек прерывания не установлено.                                 
                                                                                

                         - 289,290 -
                                                                                
          - Если  вы  еще не использовали опции пошагового выполнения,          
     Project-Make перекомпилирует вашу прогрмму и запустит ее  на  вы-          
     полнение с самого начала.                                                  
                                                                                
          "Горячая" клавиша для команды Run/Run - Ctrl-F9.                      
                                                                                
                                                                                
                                                                                
               Program Reset (сброс программы)                                  
               -------------------------------                                  
                                                                                
          Команда Run/Program  Reset  прерывает текущий сеанс отладки.          
     Она освобождает память, размещенную вашей программой, и закрывает          
     все открытые файлы. "Горячая" клавиша  для  Run/Program  Reset  -          
     Ctrl-F2.                                                                   
                                                                                
                                                                                
                                                                                
               Go to Cursor (выполнять до курсора)                              
               -----------------------------------                              
                                                                                
          Команда Run/Go  to  Cursor запускает программу с позиции, на          
                                                                                
     которой ее выполнение было приостановлено (выполняемой  позиции),          
     и  выполняет ее до строки, на которой в редакторе расположен кур-          
     сор. Если курсор находится на строке, не  содержащей  выполняемый          
     оператор, команда выдает рамку, содержащую предупреждение и пред-          
     ложение  нажать  клавишу Esc. Run/Go to Cursor может также начать          
     сеанс отладки.                                                             
                                                                                
          Команда Run/Go to Cursor не устанавливает  постоянную  точку          
     прерывания,  но  позволяет программе останавливаться в постоянной          
     точке прерывания, если она расположена до строки, содержащей кур-          
     сор. Если это происходит, вы должны повторно запустить команду Go          
     to Cursor.                                                                 
                                                                                
          Используйте эту команду, если вы хотите отладить часть прог-          
     раммы. Если же вы хотите, чтобы ваша программа останавливалась на          
     определенном операторе каждый раз, установите точку прерывания  в          
     этой строке.                                                               
                                                                                
          "Горячая" клавиша для команды Run/Go to Cursor - F4.                  
                                                                                
                                                                                
                                                                                

                         - 291,292 -
                                                                                
               Trace Into (трассировать внутрь)                                 
               --------------------------------                                 
                                                                                
          Команда Run/Trace Into запускает следующий оператор в  теку-          
     щей  функции. Если оператор не содержит вызова функции, доступной          
     отладчику, Trace Into переходит на следующий  выполняемый  опера-          
     тор.                                                                       
                                                                                
          Если оператор содержит вызов функции,  доступной  отладчику,          
     Trace Into останавливается в начале определения функции. Последу-          
     ющее задание команды Trace Into или Step Over запустит выполнение          
     операторов  в  описании  функции. Когда отладчик покинет функцию,          
     возобновится выполнение оператора, который содержит вызов.                 
                                                                                
          Функция доступна отладчику, если она описана в исходном фай-          
     ле, который  был  откомпилирован  с  включенными   (On)   опциями          
     O/C/C/OBJ Debug  Information и Debug/Source Debugging, и отладчик          
     может найти исходный файл на диске.                                        
                                                                                
          Используйте Trace  Into для перемещения отслеживаемой выпол-          
     няемой позиции внутрь функции, вызываемой из отлаживаемой в теку-          
     щий момент функции.                                                        
                                                                                
                                                                                
          "Горячая" клавиша для команды Run/Trace Into - F7.                    
                                                                                
                                                                                
                                                                                
               Step Over (пошаговое выполнение)                                 
               --------------------------------                                 
                                                                                
          Run/Step Over выполняет следующий оператор в  текущей  функ-          
     ции. Она  не  перемещает выполняемую позицию в вызываемые функции          
     нижнего уровня, даже если они доступны отладчику.                          
                                                                                
          Используйте Step Over для пошагового (один оператор за  раз)          
     выполнения отлаживаемой функции.                                           
                                                                                
          Ниже приведен    пример,   демонстрирующий   разницу   между          
     Run/Trace Into и Run/Step Over.  Представлены  первые  двенадцать          
     строк программы, загруженной в редактор.                                   
                                                                                
        int findit(void)                                /* Строка 1 */          
        {                                                                       
          return(2);                                                            

                         - 293,294 -
                                                                                
        }                                                                       
                                                                                
        void main(void)                                 /* Строка 6 */          
        {                                                                       
          int i,j;                                                              
                                                                                
          i = findit();                                /* Строка 10 */          
          printf("%d\n",i);                            /* Строка 11 */          
          j = 0; ...                                   /* Строка 12 */          
        }                                                                       
                                                                                
          findit является функцией, определенной пользователем в моду-          
     ле, который  был откомпилирован с отладочной информацией. Предпо-          
     ложим, что в текущий момент выполняемой позицией является  строка          
     10 вашей программы.                                                        
                                                                                
          - Если вы выберете Run/Trace Into, выполняемая позиция пере-          
     местится в  первую строку функции findit (строка 1 вашей програм-          
     мы), позволяя вам проверить и ее.                                          
                                                                                
          - Если вы выберете Run/Step Over, функция findit  будет  вы-          
     полнена,  и i будет присвоено значение 2. Выполняемая позиция пе-          
                                                                                
                                                                                
     реместится на строку 11.                                                   
                                                                                
          Если бы, однако, выполняемая позиция размещалась  на  строке          
     11 вашей программы, то разницы между выбором той или иной из этих          
     двух функций  не было - обе они выполнили бы функцию printf и пе-          
     реместили позицию выполнения на строку 12. Это  обусловлено  тем,          
     что функция printf не содержит отладочной информации.                      
                                                                                
          "Горячая" клавиша для команды Run/Step Over - F8.                     
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 295,296 -
                                                                                
               Compile (меню компиляции)                                        
     -----------------------------------------------------------------          
                                                                                
          Режимы, перечисленные в этом меню,  позволяют  компилировать          
     программу  в  объектный (.OBJ) файл, создавать выполняемый (.EXE)          
     файл, производить компоновку, перестраивать все файлы, входящие в          
     проект, указывать первичный Си-файл, а также получать  информацию          
     о последней компиляции или выполнении.                                     
                                                                                
                                                                                
                                                                                
               Compile to OBJ (компилировать в объектный файл)                  
               -----------------------------------------------                  
                                                                                
          Эта команда  компилирует .C-файл в .OBJ-файл. Имя файла, ко-          
     торый  будет   получен   в   результате   компиляции   (например,          
     С:EXAMPLE.OBJ),  постоянно  отображается в ходе процесса компиля-          
     ции. Это имя образуется на основе одного из двух имен по  следую-          
     щему простому алгоритму:                                                   
                                                                                
          - в качестве имени файла принимается имя первичного исходно-          
            го файла; если оно не указано, то:                                  
                                                                                
          - принимается  имя  последнего  файла,  загруженного в  окно          
            редактора.                                                          
                                                                                
          Во время  процесса компиляции на экране отображается окно, в          
     котором представляются результаты компиляции. По  окончании  про-          
     цесса компиляции  нажмите  любую клавишу для удаления этого окна.          
     Если были обнаружены ошибки, то вы окажетесь в окне сообщений  на          
     первой ошибке  (она  отображается с повышенной яркостью). Эта ко-          
     манда и ее опции более подробно рассматриваются в главе 3.                 
                                                                                
          "Горячая" клавиша для команды Compile to OBJ - Alt-F9.                
                                                                                
                                                                                
                                                                                
               Make EXE File (создать выполняемый файл)                         
               ----------------------------------------                         
                                                                                
          Эта команда вызывает Project-Make для создания .EXE-файла. В          
     ходе процесса создания выполняемого файла постоянно  отображается          
     имя  файла,  который  получится  в результате выполнения команды,          
     например, C:EXAMPLE.EXE. Имя .EXE-файла выбирается в соответствии          
     со следующим простым алгоритмом:                                           

                         - 297,298 -
                                                                                
                                                                                
          -  имя файла-проекта (с расширением .PRJ), указанное в  меню          
             Project/Project Name,  или,  если это имя  не указано, то          
             принимается:                                                       
          -  имя первичного Си-файла или, если оно не указано, то при-          
             нимается:                                                          
          -  имя последнего файла, загруженного в окно редактора.               
                                                                                
          "Горячая" клавиша для этой команды - F9.                              
                                                                                
                                                                                
                                                                                
               Link EXE (компоновать в .EXE-файл)                               
               ----------------------------------                               
                                                                                
          Компонует текущие .OBJ и  .LIB-файлы  (как  используемые  по          
     умолчанию, так и заданные в текущем project-файле) без выполнения          
     make. В результате получается новый выполняемый файл с расширени-          
     ем .EXE.                                                                   
                                                                                
                                                                                
                                                                                
                                                                                
               Build All (перестроить)                                          
               -----------------------                                          
                                                                                
          Перестраивает все  файлы  вашего проекта, независимо от даты          
     создания. Эта команда похожа на команду Compile/Мake ЕХЕ File, за          
     исключением того, что в данном случае перекомпиляция делается для          
     всех файлов, независимо от их актуальности, тогда  как  Мake  EXE          
     File перекомпилирует только те файлы, которые являются неактуаль-          
     ными. Build All сначала устанавливает даты создания всех файлов в          
     нуль,  а  затем  выполняет make. (Таким образом, если вы прервете          
     выполнение команды Build All с помощью Ctrl-Break, то для  возоб-          
     новления тех же действий вы можете задать уже и Make EXE File.)            
                                                                                
                                                                                
                                                                                
               Primary C File (первичный .C-файл)                               
               ----------------------------------                               
                                                                                
          Эта команда полезна (но не обязательна), когда вы компилиру-          
     ете  единичный  .C-файл,  включающий  несколько файлов-заголовков          
     (.H-файлов). Если при компиляции обнаружена ошибка, то файл,  со-          
     держащий  ошибку (а это может быть файл как с расширением .С, так          

                         - 299,300 -
                                                                                
     и с расширением .Н), автоматически загружается в редактор,  чтобы          
     вы  могли  исправить ошибку. (Следует отметить, что .Н-файл будет          
     автоматически загружен в редактор только в том случае,  если  для          
     опции  /Options/Environment/Message  Tracking  вместо значения по          
     умолчанию поставлено значение "All Files" (все файлы). В  против-          
     ном случае файл с расширением .Н в редактор автоматически не заг-          
     ружается.) После исправления ошибки первичный исходный файл пере-          
     компилируется  после  нажатия комбинации клавиш Alt-F9, даже если          
     он не загружен в редактор.                                                 
                                                                                
                                                                                
                                                                                
               Get Info (получить информацию)                                   
               ------------------------------                                   
                                                                                
          Команда Compile/Get Info обеспечивает выдачу на экран инфор-          
     мацию, содержащую:                                                         
                                                                                
          - первичный файл;                                                     
          - имя объектного файла, соответствующего текущему файлу;              
          - имя текущего исходного файла;                                       
          - размер текущего исходного файла (в байтах);                         
                                                                                
                                                                                
          - код завершения программы;                                           
          - доступную память.                                                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 301,302 -
                                                                                
               Project (меню проекта)                                           
     -----------------------------------------------------------------          
                                                                                
          Это меню предназначено для связи в единый проект  нескольких          
     исходных  и  объектных  файлов с целью создания законченных прог-          
     рамм.                                                                      
                                                                                
          Более подробная информация о проектах содержится в главе 3.           
                                                                                
                                                                                
                                                                                
               Project Name (имя проекта)                                       
               --------------------------                                       
                                                                                
          Выбирает файл проекта, содержащий имена файлов, которые дол-          
     жны компилироваться и/или компоноваться. Имя проекта присваивает-          
     ся файлам .ЕХЕ и .МАР при их создании. Файл  проекта  имеет,  как          
     правило, расширение .PRJ.                                                  
                                                                                
                                                                                
                                                                                
               Break Make On (прервать создание)                                
                                                                                
               ---------------------------------                                
                                                                                
          Данный пункт  позволяет  указать условие, при котором должно          
     прерваться создание (make): если  файл  содержит  предупреждения,          
     ошибки, фатальные ошибки, или же перед компоновкой файла.                  
                                                                                
                                                                                
                                                                                
               Auto Dependencies (автозависимости)                              
               -----------------------------------                              
                                                                                
          Эта опция является переключателем. Если она установлена в On          
     (включена),   Project-Make   будет   автоматически   для  каждого          
     .OBJ-файла в списке проекта проверять исходные .C-файлы.                   
                                                                                
          Project-Make открывает .OBJ-файл и просматривает  информацию          
     об исходных файлах, составляющих его. Эта информация всегда поме-          
     щается в .OBJ-файл как TC, так и TCC при компиляции. Затем дата и          
     время  каждого  исходного файла сопоставляются с датой и временем          
     создания .OBJ-файла. Если даты различаются, то производится пере-          
     компиляция.                                                                
                                                                                

                         - 303,304 -
                                                                                
          Это называется проверкой автозависимостей.                            
                                                                                
          Если же опция Auto Dependencies выключена  (Off),  то  такая          
     проверка не производится.                                                  
                                                                                
                                                                                
                                                                                
               Clear Project (очистить проект)                                  
               -------------------------------                                  
                                                                                
          Команда очищает  имя проекта и удаляет сообщения из окна со-          
     общений.                                                                   
                                                                                
                                                                                
                                                                                
               Remove Messages (удалить сообщения)                              
               -----------------------------------                              
                                                                                
          Команда удаляет сообщения из окна сообщений.                          
                                                                                
                                                                                
                                                                                
                                                                                
               Options (меню опций)                                             
     -----------------------------------------------------------------          
                                                                                
          Меню Options  содержит  установки, которые определяют, каким          
     образом работает интегрированная среда. Эти  установки  позволяют          
     управлять  работой  компилятора,  компоновщика, изменять каталоги          
     включаемых и библиотечных файлов, устанавливать аргументы,  пере-          
     даваемые программе во время ее выполнения, и т.д. Некоторые пунк-          
     ты  этого  меню  содержат подменю, один является установкой и два          
     решают управленческие задачи.                                              
                                                                                
          - Compiler (содержит подменю)                                         
          - Linker (содержит подменю)                                           
          - Environment (содержит подменю)                                      
          - Directories (содержит подменю)                                      
          - Arguments (установка)                                               
          - Save Options (управление)                                           
          - Retrieve Options (управление)                                       
                                                                                
                                                                                
                                                                                
                                                                                

                         - 305,306 -
                                                                                
               Compiler (меню компилятора)                                      
     -----------------------------------------------------------------          
                                                                                
          Опции этого  меню позволяют определить конкретную конфигура-          
     цию вашего компьютера, модель памяти, способ отладки, вид оптими-          
     зации получаемой программы, управление диагностическими сообщени-          
     ями и макроопределения. Элементы этого меню рассматриваются ниже,          
     ими являются:                                                              
                                                                                
          - Model (модель памяти)                                               
          - Defines (макроопределения)                                          
          - Code Generation (генерация кода)                                    
          - Optimization (оптимизация)                                          
          - Source (работа с исходным текстом)                                  
          - Errors (ошибки)                                                     
          - Names (имена)                                                       
                                                                                
                                                                                
               Model (меню модели памяти)                                       
               --------------------------                                       
                                                                                
          В этом пункте можно выбрать одну из существующих в Турбо  Си          
                                                                                
     моделей памяти. Модель памяти определяет принимаемый по умолчанию          
     способ  адресации  памяти.  Опциями данного пункта являются: Tiny          
     (крохотная), Small (малая), Compact (компактная),  Medium  (сред-          
     няя), Large (большая) и Huge (максимальная). По умолчанию выбира-          
     ется  малая  модель памяти, на что указывает слово Small, стоящее          
     справа от наименования пункта Model. Более подробно модели памяти          
     описаны в главе 12.                                                        
                                                                                
                                                                                
               Defines (макроопределения)                                       
               --------------------------                                       
          Выбрав этот пункт, вы можете вписать в появившуюся на экране          
     рамку  макроопределения,  передаваемые  препроцессору.  Несколько          
     макроопределений  могут быть разделены точкой с запятой (;). Зна-          
     чение (при необходимости) присваивается знаком равенства (=).              
                                                                                
          Пробелы в начале и конце строки удаляются; пробелы,  находя-          
     щиеся в середине макроопределения, оставляются. Если в макроопре-          
     деление  необходимо  вставить  точку с запятой, перед ней следует          
     поставить слеш (\).                                                        
                                                                                
          Приведенный ниже пример означает следующее: определяется имя          

                         - 307,308 -
                                                                                
     BETA_TEST, переменной ONE присваивается  значение  1;  переменной          
     COMPILER присваивается значение TURBOC.                                    
                                                                                
               BETA_TEST; ONE = 1; COMPILER = TURBOC                            
                                                                                
                                                                                
               Code Generation (меню генерации кода)                            
               -------------------------------------                            
          Параметры этого режима определяют различные варианты генера-          
     ции объектного кода.                                                       
                                                                                
                                                                                
               Calling Convention (соглашения по вызову)                        
               -----------------------------------------                        
                                                                                
          Указывает компилятору генерировать последовательность вызова          
     функции,  соответствующую  либо  Си,  либо Паскалю (более быструю          
     последовательность). Разница между ними заключается в способе ра-          
     боты со стеком, числе и порядке передаваемых параметров, а  также          
     в  обработке  внешних  идентификаторов (по-разному обрабатываются          
     различные регистры и символы нижнего подчеркивания внешних  иден-          
     тификаторов).                                                              
                                                                                
                                                                                
          Если вы не являетесь специалистом и не читали главу 12, пос-          
     вященную более сложным вопросам программирования, то не изменяйте          
     значение данного пункта, установленное по умолчанию.                       
                                                                                
                                                                                
               Instuction Set (установка набора команд)                         
               ----------------------------------------                         
                                                                                
          Установка набора команд позволяет  настроить  компилятор  на          
     команды  соответствующего процессора; переключает с набора команд          
     процессора типа 8088/8086 на набор команд процессоров  80x86.  По          
     умолчанию  генерируется объектный код для процессоров типа 80x86.          
     Турбо Си может генерировать расширенный набор  команд  процессора          
     80x86. Вы можете использовать также эту опцию при генерации прог-          
     рамм для процессора 80x86, выполняемых в реальном масштабе време-          
     ни,  таком,  например,  как реализованный на компьютере IBM PC AT          
     под управлением MS-DOS версии 3.x.                                         
                                                                                
                                                                                
               Floating Point (плавающая точка)                                 
               --------------------------------                                 

                         - 309,310 -
                                                                                
                                                                                
          Этот переключатель допускает три опции.                               
                                                                                
          - 8087/80287,  которая  непосредственно  генерирует машинные          
     команды сопроцессора (обработки операций с плавающей точкой).              
                                                                                
          - Emulation (эмуляция), которая определяет, имеете ли  вы  в          
     своей  конфигурации  компьютера  сопроцессор обработки операций с          
     плавающей точкой типа 8087/80287, и использует его, если он есть;          
     в противном случае  этот  процессор  эмулируется,  но  полученная          
     программа будет выполняться более медленно.                                
                                                                                
          - None,  которая предполагает, что вы не используете в прог-          
     рамме операции с плавающей точкой. (Если выбрана опция None, а вы          
     используете вычисления с плавающей точкой в вашей  программе,  то          
     вы получите ошибки при компоновке).                                        
                                                                                
                                                                                
         Default Char Type (тип символа, используемый по умолчанию)             
         ----------------------------------------------------------             
                                                                                
          Переключает между Signed (со знаком) и Unsigned (без  знака)          
                                                                                
     тип символа, используемый по умолчанию. Если вы выбираете Signed,          
     то  компилятор  будет обрабатывать все определения типа char, как          
     если бы они  были  типа  signed  char;  и  наоборот,  при  выборе          
     Unsigned,  компилятор обрабатывает все определения типа char так,          
     как если бы они имели тип unsigned char. Значением  по  умолчанию          
     является Signed.                                                           
                                                                                
                                                                                
               Alignment (выравнивание)                                         
               ------------------------                                         
                                                                                
          Позволяет вам переключаться с выравнивания объектного фай-            
     ла  на  границу слова на выравнивание на границу байта. При вы-            
     равнивании на границу слова несимвольные  данные  выравниваются            
     по четным адресам. При выравнивании на границу байта данные мо-            
     гут  выравниваться  как по нечетным, так и по четным адресам, в            
     зависимости от следующего доступного  адреса.  Выравнивание  на            
     границу  слова  увеличивает  скорость выборки и записи в память            
     данных процессорами типа 8086 и 80286.                                     
                                                                                
                                                                                
               Generated Underbars (генерация символа подчеркивания)            

                         - 311,312 -
                                                                                
               -----------------------------------------------------            
                                                                                
          По умолчанию эта опция всегда включена (установлена в On).            
                                                                                
          Если вы не являетесь специалистом и не читали главу 12, пос-          
     вященную более сложным вопросам программирования, то не изменяйте          
     значение этой опции.                                                       
                                                                                
                                                                                
               Merge Dublicate String (слияние одинаковых строк)                
               -------------------------------------------------                
                                                                                
          Слияние одинаковых строк оптимизирует объектный  файл  путем          
     объединения строк, в случае когда одна строка совпадает с другой.          
     Это  приводит к более компактным программам. По умолчанию эта оп-          
     ция выключена (Off).                                                       
                                                                                
                                                                                
               Standart Stack Frame (стандартная запись активации)              
               ---------------------------------------------------              
                                                                                
          Генерирует стандартные записи  активации  (стандартные  коды          
                                                                                
     вызова  и  выхода из функции). Целесообразно использовать при от-          
     ладке с помощью символного отладчика для упрощения процесса прос-          
     мотра хранящихся в  стеке  вызванных  подпрограмм.  По  умолчанию          
     включена (On).                                                             
                                                                                
          Если исходный файл компилируется при выключенной (Off) опции          
     Standart  Stack Frame, все функции, не использующие локальные пе-          
     ременные и не имеющие параметры, компилируются с сокращенным вхо-          
     дом и кодом возврата. Это делает код программы короче и  быстрее,          
     однако делает функции недоступными для Debug/Call Stack. Поэтому,          
     если  вы  хотите использовать отладчик, компилируйте ваш исходный          
     файл при включенной опции Standart Stack Frame.                            
                                                                                
                                                                                
               Test Stack Overflow (проверка переполнения стека)                
               -------------------------------------------------                
                                                                                
          Генерирует код для проверки переполнения стека во время  вы-          
     полнения  программы. Хотя это отражается на занимаемой программой          
     памяти и времени ее выполнения, но на практике пренебрегать  воз-          
     можностью компилятора генерировать такие средства не стоит: пере-          
     полнение  стека  очень сложная для выявления ошибка. По умолчанию          

                         - 313,314 -
                                                                                
     эта опция выключена (Off).                                                 
                                                                                
                                                                                
               Line Numbers (нумерация строк)                                   
               ------------------------------                                   
                                                                                
          Включает режим нумерации строк объектного файла  (для  даль-          
     нейшего  использования  символьным  отладчиком).  Это увеличивает          
     размеры обьектного файла и файла карты, но не  влияет  на  размер          
     или  скорость выполнения программы. (Размер выполняемой программы          
     увеличится, если переключатель Debug/Source Debugging  установлен          
     в On, и вы компонуете объектные файлы, созданные с включенной оп-          
     цией  O/C/C/Line Numbers. Размер файла увеличивается из-за добав-          
     ления отладочной информации.) По умолчанию выключена (Off).                
                                                                                
          Так как компилятор может группировать общий код из различных          
     участков исходного текста во время оптимизации переходов или  пе-          
     реупорядочивать  строки  (что  затрудняет  прослеживание  номеров          
     строк),  мы  рекомендуем  отключить  установку  Options/Compiler/          
     Optimization/Jump Optimization при использовании режима нумерации          
     строк объектного файла.                                                    
                                                                                
                                                                                
                                                                                
               OBJ Debug Information (тип отладочной информации)                
               -------------------------------------------------                
                                                                                
          Управляет типом  отладочной информации, включаемой в объект-          
     ные файлы. По умолчанию установлена в On (включена), что позволя-          
     ет применять для отладки как встроенный  интегрированный,  так  и          
     автономный отладчик Турбо.                                                 
                                                                                
                                                                                
               Optimization (меню оптимизации)                                  
               -------------------------------                                  
                                                                                
          Опции данного  меню  позволяют  вам оптимизировать код вашей          
     программы тем или иным образом.                                            
                                                                                
                                                                                
               Optimize For (оптимизировать по...)                              
               ------------------------------------                             
                                                                                
          Изменяет стратегию генерации обьектного кода Турбо Си. Обыч-          
     но компилятор работает в режиме "Optimize for...Size"  (оптимиза-          

                         - 315,316 -
                                                                                
     ция  по  размеру), создавая возможно меньшую по объему последова-          
     тельность  кодов.  При  переключении  этого  режима   работы   на          
     "Optimize  for...Speed" (оптимизация по скорости выполнения прог-          
     раммы), компилятор генерирует  наиболее  быструю  (из  возможных)          
     последовательность кодов объектного файла для данной задачи.               
                                                                                
                                                                                
        User Register Variables (использование регистровых переменных)          
        --------------------------------------------------------------          
                                                                                
          Запрещает или разрешает использовать регистровые  переменные          
     в программе на Турбо Си. При включении этой опции (On), регистро-          
     вые  переменные  используются  автоматически. При выключении этой          
     опции (Off), регистровые переменные не используются компилятором,          
     даже если вы указали ключевое слово register при их описании (см.          
     Приложение C "Справочного руководства" для выяснения деталей).             
                                                                                
          Вообще лучше сохранять эту опцию в положении On, если вы  не          
     создаете интерфейс с уже существующими программами на ассемблере,          
     которые не поддерживают работу с регистровыми переменными.                 
                                                                                
                                                                                
                                                                                
               Register Optimization (регистровая оптимизация)                  
               -----------------------------------------------                  
                                                                                
          Регистровая оптимизация   запрещает  избыточные  загрузочные          
     операции, запоминая содержимое регистров и вторично используя его          
     так часто, как это возможно.                                               
                                                                                
          Замечание. Вы должны соблюдать осторожность при  использова-          
     нии этой опции, потому что компилятор не может определить, был ли          
     регистр модифицирован косвенно, посредством указателя. Обратитесь          
     к Приложению A "Справочного руководства" для более подробного ра-          
     зъяснения этого ограничения.                                               
                                                                                
                                                                                
               Jump Optimization (оптимизация по переходам)                     
               --------------------------------------------                     
                                                                                
          Оптимизация по  переходам уменьшает размер программы за счет          
     удаления лишних передач управления, реорганизации циклов и опера-          
     торов switch. Реорганизации циклов могут ускорить действие сжатых          
     внутренних циклов.                                                         
                                                                                

                         - 317,318 -
                                                                                
                                                                                
          Замечание. Когда  этот  переключатель установлен в On (вклю-          
     чен), пошаговая отладка и трассирование могут быть запутаны, т.к.          
     несколько строк исходного текста могут соответствовать одной пос-          
     ледовательности кода. Поэтому  при  отладке  лучше  устанавливать          
     этот переключатель в Off (выключен).                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Source (меню работы с исходным текстом)                          
     -----------------------------------------------------------------          
                                                                                
          Пункты этого меню определяют действия компилятора с исходным          
     текстом программы на начальных стадиях компиляции.                         
                                                                                
                                                                                
               Identifier Length (длина идентификатора)                         
               ----------------------------------------                         
                                                                                
          Устанавливает число  значащих символов в идентификаторе. Все          
     идентификаторы трактуются как различные только в том случае, если          
     их первые N литер различны. Это распространяется  на  переменные,          
     макроимена препроцессора и имена элементов структуры. Длина иден-          
     тификатора может быть указана любой величины от 1 до 32 символов;          
     по умолчанию длина идентификатора составляет 32 значащих символа.          
                                                                                
                                                                                
               Nested Comments (вложенные комментарии)                          
               ---------------------------------------                          
          Позволяет использовать вложенные комментарии в исходных фай-          
     лах  Турбо Си. Вложенные комментарии обычно не допускаются в дру-          

                         - 319,320 -
                                                                                
                                                                                
     гих трансляторах Си, и поэтому программы, использующие их, не пе-          
     реносимы.                                                                  
                                                                                
                                                                                
          ANSI Keywords Only (ключевые слова только согласно ANSI)              
          --------------------------------------------------------              
                                                                                
          Переключите на On (включена), если хотите, чтобы  компилятор          
     распознавал  только  ключевые  слова,  предусмотренные стандартом          
     ANSI, а к дополнительным ключевым словам Турбо Си относился как к          
     обычным идентификаторам.  Игнорируются  (при  включенном  режиме)          
     следующие  ключевые  слова Турбо Си: near, far, huge, asm, cdecl,          
     pascal, interrupt, _es, _ds, _cs, _ss, а также регистровые  псев-          
     допеременные  (_AX, _BX, ...). Эта опция определяет также иденти-          
     фикатор _STDC_ в ходе компиляции.                                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Errors (меню ошибок)                                             
     -----------------------------------------------------------------          
                                                                                
          С помощью этого меню вы можете указать  реакцию  компилятора          
     Турбо Си на различные диагностические сообщения.                           
                                                                                
                                                                                
               Errors: Stop After (ошибки: остановиться после ...)              
               --------------------------------------------------               
                                                                                
          Вызывает прекращение компиляции  после  того,  как  выявлено          
     указанное  число  ошибок.  По умолчанию установлено 25, однако вы          
     можете ввести любое число от 0 до 255. (Ввод 0 вызывает  компиля-          
     цию без ограничений этой опции.)                                           
                                                                                
                                                                                
          Warnings: Stop After (предупреждения: остановиться после...)          
          ------------------------------------------------------------          
                                                                                
          Выбор этой опции вызывает прекращение компиляции  после  100          
     предупреждений. Однако, 100 - это только число по умолчанию; раз-          
     решенные значения находится в диапазоне от 0 до 255, где введение          

                         - 321,322 -
                                                                                
     0 вызывает компиляцию, продолжающуюся без ограничений или пока не          
     будет исчерпан лимит ошибок.                                               
                                                                                
                                                                                
                                                                                
               Display Warnings (вывод предупреждений на экран)                 
               ------------------------------------------------                 
                                                                                
          По умолчанию эта опция включена (On), что означает, что  вы-          
     водятся  любые из следующих типов предупреждений, если они выбра-          
     ны:                                                                        
                                                                                
        - Portability Warnings (предупреждения о переносимости)                 
        - ANSI Violations (нарушения стандарта ANSI)                            
        - Common Errors (общие ошибки)                                          
        - Less Common Errors (менее общие ошибки)                               
                                                                                
          Когда этот пункт принимает значение Off, ни одно из  предуп-          
     реждений не будет отображаться на экране. Более подробно все пре-          
     дупреждения обсуждаются в Приложениях B и C "Справочного руковод-          
     ства".                                                                     
                                                                                
                                                                                
                                                                                
               Names (имена)                                                    
     -----------------------------------------------------------------          
                                                                                
          С помощью  этого пункта вы можете изменять заданные по умол-          
     чанию имена сегментов, групп и классов для Code, Data и BSS  сек-          
     ций.                                                                       
                                                                                
          Когда вы выбираете один из этих  пунктов,  звездочка  (*)  в          
     следующем  появляющемся  меню  указывает компилятору использовать          
     имена по умолчанию.                                                        
                                                                                
          Не изменяйте эту опцию, если вы не являетесь специалистом  и          
     не  читали главу 12, посвященную более сложным приемам программи-          
     рования.                                                                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 323,324 -
                                                                                
               Linker (меню компоновщика)                                       
     -----------------------------------------------------------------          
                                                                                
          Пункты в  этом меню связаны с установкой опций для компонов-          
     щика. Обратитесь к Приложению D "Справочного руководства" для по-          
     лучения большей информации об установках компоновщика.                     
                                                                                
                                                                                
               Map File (файл карты)                                            
     -----------------------------------------------------------------          
                                                                                
          Выбирает тип генерируемого файла карты. Если установка режи-          
     ма Map File отлична от Off (выключен), то файл карты помещается в          
     выходной   каталог,   определенный  в  Options/Directiries/Output          
     Directiry. По умолчанию файл карты не создается,  так  как  режим          
     выключен  (Off).  Кроме этого, вы можете задать тип генерируемого          
     компоновщиком файла карты, указав в этом  меню:  "Segments"  (для          
     сегментов  памяти),  "Publics"  (для  глобальных  переменных) или          
     "Detailed" (подробный).                                                    
                                                                                
                                                                                
               Initialize Segments (инициализация сегментов)                    
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Предписывает компоновщику  инициализировать  неинициализиро-          
     ванные сегменты памяти. (Обычно в этом нет нужды, кроме того, это          
     увеличивает без необходимости размер .EXE-файла).                          
                                                                                
                                                                                
                                                                                
               Default Libraries (библиотеки по умолчанию)                      
     -----------------------------------------------------------------          
                                                                                
          Когда вы  производите  компоновку  с  модулями, которые были          
     созданы компилятором, отличным от Турбо Си, знайте: этот компиля-          
     тор мог разместить в объектном файле список  своих  библиотек,  к          
     которым он обращался при компиляции.                                       
                                                                                
          Если эта опция  включена  (On),  то  компоновщик  попытается          
     отыскать любую не определенную функцию в этих библиотеках, наряду          
     с  поиском  в  библиотеках, используемых по умолчанию в Турбо Си.          
     Если эта опция выключена (Off), то поиск будет проводиться только          
     в библиотеках, используемых по умолчанию в Турбо Си.                       
                                                                                

                         - 325,326 -
                                                                                
                                                                                
               Graphics Libraries (графические библиотеки)                      
     -----------------------------------------------------------------          
                                                                                
          Включает (On) и выключает (Off) автоматический поиск  графи-          
     ческой  библиотеки BGI. Когда этот переключатель включен (On), вы          
     можете построить и запустить графическую программу, состоящую  из          
     единичного  файла,  без  использования  файла-проекта. Выключение          
     (Off) повышает скорость компоновки, поскольку компоновщику в этом          
     случае не нужно компоновать файл графической библиотеки  BGI.  По          
     умолчанию включен (On).                                                    
                                                                                
          Замечание. Вы  можете выключить автоматический поиск, но ис-          
     пользовать графическую библиотеку путем включения ее в  файл-про-          
     ект.                                                                       
                                                                                
                                                                                
               Warn Dublicate Symbols (предупреждение о дублирующихся           
               идентификаторах)                                                 
     -----------------------------------------------------------------          
                                                                                
          Включает (On)  и выключает (Off) предупреждения компоновщика          
                                                                                
     о совпадении имен идентификаторов в обьектных и библиотечных фай-          
     лах. По умолчанию опция выключена (Off).                                   
                                                                                
                                                                                
               Stack Warning (стековое предупреждение)                          
     -----------------------------------------------------------------          
                                                                                
          Блокирует генерацию компоновщиком сообщения "No stack"  (нет          
     стека). (Обычно это сообщение генерируется для программ крохотной          
     (tiny) модели памяти.)                                                     
                                                                                
                                                                                
               Case-sensitive Link (компоновка с учетом регистра)               
     -----------------------------------------------------------------          
                                                                                
          В зависимости от установки в состояние On (включена) или Off          
     (выключена), символы нижнего и верхнего регистра во время  компо-          
     новки  различаются или не различаются. Обычно эта опция включена,          
     т.к. Си - сам по себе язык, учитывающий различие регистров.                
                                                                                
                                                                                
                                                                                

                         - 327,328 -
                                                                                
               Environment (среда)                                              
     -----------------------------------------------------------------          
                                                                                
          Элементы этого меню позволяют  вам  сохранять  ваш  исходный          
     файл, находящийся в редакторе, и приспособить условия работы Тур-          
     бо Си к нуждам вашего программирования.                                    
                                                                                
                                                                                
               Message Tracking (отслеживать сообщения)                         
     -----------------------------------------------------------------          
                                                                                
          Турбо Си отслеживает синтаксические ошибки в редакторе в со-          
     ответствии с тем, как вы их выбираете в  окне  сообщений.  Данный          
     трехпозиционный  переключатель указывает Турбо Си, в каких файлах          
     необходимо отслеживать сообещения.                                         
                                                                                
          По умолчанию  принимается  значение  "Track...Current  file"          
     (отслеживать  в текущем файле). При этом в редакторе будет отсле-          
     живаться  только  текущий  (находившийся  в  нем)   файл.   Режим          
     "Track...All  files" обеспечивает загрузку и отслеживание сообще-          
     ний во всех файлах. Режим отслеживания может быть выключен  зада-          
     нием значения Off.                                                         
                                                                                
                                                                                
                                                                                
                                                                                
               Keep messages (сохранить сообщения)                              
     -----------------------------------------------------------------          
                                                                                
          Когда эта  опция  включена  (On), Турбо Си сохраняет текущую          
     информацию об ошибках в окне сообщений, добавляя любые  сообщения          
     в это окно в ходе последующих компиляций. Когда же файл скомпили-          
     рован,  любые  сообщения,  касающиеся этого файла, перемещаются в          
     окне сообщений и новые сообщения добавляются к старым.  Когда  же          
     опция  выключена (Off), сообщения автоматически удаляются из окна          
     (т.е. окно полностью очищается) перед компиляцией  другого  файла          
     или выполнением Make.                                                      
                                                                                
                                                                                
          Config Auto Save (автоматическое сохранение конфигурации)             
     -----------------------------------------------------------------          
                                                                                
          Обычно Турбо  Си  сохраняет текущую конфигурацию (записывает          
     на диск) только когда вы задаете  команду  Options/Save  Options.          
     Если  же  вы включите (On) данную опцию, Турбо Си будет автомати-          

                         - 329,330 -
                                                                                
     чески сохранять конфигурацию каждый раз, когда вы задаете команды          
     Run/Run или File/OS Shell или выходите из интегрированной  среды,          
     если текущая конфигурация отличается от сохраненной перед этим.            
                                                                                
          При автоматической  записи файла конфигурации Турбо Си выби-          
     рает его имя. Это либо имя файла, в который записывалась конфигу-          
     рация в предыдущий раз, либо файл TCCONFIG.TC (в текущем  катало-          
     ге),  если вы еще не загружали, не восстанавливали и не сохраняли          
     файл конфигурации.                                                         
                                                                                
                                                                                
          Edit Auto Save (автоматическая запись редактируемого файла)           
     -----------------------------------------------------------------          
                                                                                
          Когда эта опция включена (On), Турбо Си осуществляет автома-          
     тическую  запись  редактируемого  файла  при использовании команд          
     Run/Run или File/OS Shell, если файл был модифицирован со времени          
     последнего сохранения.                                                     
                                                                                
                                                                                
               Backup Files (резервирование файлов)                             
     -----------------------------------------------------------------          
                                                                                
                                                                                
          По умолчанию Турбо Си автоматически создает  архивную  копию          
     вашего  исходного  файла, когда вы используете команду File/Save.          
     Резервная копия имеет расширение .BAK. Вы  можете  включать  (On)          
     или выключать (Off) данную опцию.                                          
                                                                                
                                                                                
               Tab Size (размер табуляции)                                      
     -----------------------------------------------------------------          
                                                                                
          Когда в редакторе включен (On) режим табуляции, и вы нажима-          
     ете клавишу Tab, редактор вставляет в файл символ табуляции и пе-          
     ремещает курсор в соответствии с размером табуляции. Размер табу-          
     ляции  задается  именно этим пунктом меню, и может иметь значение          
     от 2 до 16. По умолчанию принято 8.                                        
                                                                                
          Для изменения размера всех табуляций в текущем файле  просто          
     измените Tab Size на значение, которое вам необходимо, и редактор          
     сразу изменит размер всех табуляций в файле на выбранный вами. Вы          
     можете сохранить выбранный вами размер табуляций в файле конфигу-          
     рации (заданием команды Save Options в меню опций).                        
                                                                                

                         - 331,332 -
                                                                                
                                                                                
               Zoomed windows (увеличенные окна)                                
     -----------------------------------------------------------------          
                                                                                
          Если в интегрированной среде Турбо Си экран установлен таким          
     образом,  что одновременно отображаются окно редактора и окно со-          
     общений, то при включении данной опции (On)  они  будут  занимать          
     весь экран каждое, при этом отображаться будет активное.                   
                                                                                
          Для перехода из одного окна в другое используйте клавишу F6.          
                                                                                
          Для возврата в прежний режим одновременного отображения обо-          
     их окон установите данную опцию в положение Off (выключена).               
                                                                                
                                                                                
               Screen Size (размер экрана)                                      
     -----------------------------------------------------------------          
                                                                                
          При выборе  данного пункта появляется еще одно меню, которое          
     позволяет вам указывать режим отображения текста в  интегрирован-          
     ной среде:  25  строк  или 43/50 строк. Выбор одного из этих двух          
     режимов зависит от используемого видео адаптера.                           
                                                                                
                                                                                
          - 25 строк. Это стантартный дисплей персонального  компьюте-          
     ра: 25  строк  и 80 столбцов. Этот режим всегда доступен. Для мо-          
     нохромного (MDA) и цветного графического (CGA) адаптеров этот ре-          
     жим является единственно возможным.                                        
                                                                                
          - 43/50 строк. Этот  режим  доступен,  если  вы  используете          
     адаптеры EGA или VGA. При этом первый из них использует 43 строки          
     и 80 колонок, а второй - 50 строк и 80 колонок.                            
                                                                                
                                                                                
                                                                                
               Directories (каталоги)                                           
     -----------------------------------------------------------------          
                                                                                
          Пункты этого меню позволяют указать Турбо Си, где ему следу-          
     ет искать файлы для компиляции, компоновки, где размещать  выход-          
     ные файлы и где искать файлы конфигурации, выбора (pick) и помощи          
     (help).                                                                    
                                                                                
                                                                                
               Include Directories (каталоги включаемых файлов)                 

                         - 333,334 -
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Описывает каталоги, которые содержат ваши стандартные  вклю-          
     чаемые файлы. Стандартные включаемые файлы - это файлы, которые в          
     операторе  #include заключаются в угловые скобки (<>). (Например:          
     #include <myfile.h>.) Если указывается список каталогов,  то  они          
     разделяется  точкой  с запятой (;). Для получения более подробной          
     информации об этой опции смотри главу 3.                                   
                                                                                
                                                                                
               Library Directories (каталоги библиотечных файлов)               
     -----------------------------------------------------------------          
                                                                                
          Описывает каталог, который содержит инициализирующие обьект-          
     ные  файлы  (CO?.OBJ)  и  файлы  библиотеки  времени   выполнения          
     (.LIB-файлы). Можно  указывать  список файлов длиной не более 127          
     символов (включая пробелы).                                                
                                                                                
          Руководствуйтесь следующими правилами:                                
                                                                                
          - при задании нескольких каталогов разделяйте  их  точкой  с          
            запятой (;);                                                        
                                                                                
          - пробелы до и после точки с запятой допустимы, но не обяза-          
            тельны;                                                             
          - допустимы  как  относительные,  так и абсолютные составные          
            имена, включая имена каталогов на носителях, не являющихся          
            текущими.                                                           
                                                                                
          Например:                                                             
     C:\TURBOC\LIB; C:\TURBOC\MYLIB; A:NEWTURBO\MATHLIBS; A:..\VIDLIBS          
                                                                                
                                                                                
               Output Directory (выходной каталог)                              
     -----------------------------------------------------------------          
                                                                                
          Ваши .OBJ,  .EXE  и  .MAP  файлы  сохраняются в определяемом          
     здесь каталоге; Турбо Си просматривает этот каталог при  выполне-          
     нии команд Run и Make. При его отсутствии файлы сохраняются в те-          
     кущем каталоге.                                                            
                                                                                
                                                                                
               Turbo С Directory (каталог Турбо Си)                             
     -----------------------------------------------------------------          
                                                                                

                         - 335,336 -
                                                                                
          Этот каталог  используется  системой Турбо Си для нахождения          
     файла  конфигурации   (.ТС)   и   файла   справочной   информации          
     (TCHELP.TCH).  Для того, чтобы Турбо Си нашел ваш файл конфигура-          
     ции, используемый по умолчанию, - TCCONFIG.TC, при первой загруз-          
     ке, если он не находится в текущем каталоге, вы должны установить          
     к нему маршрут доступа с помощью TCINST - внешней программы наст-          
     ройки системы.                                                             
                                                                                
                                                                                
               Pick File Name (имя файла выбора)                                
     -----------------------------------------------------------------          
                                                                                
          Этот пункт  позволяет  определить  имя  pick-файла.  Задание          
     здесь имени позволяет Турбо Си загружать этот файл (если  он  су-          
     ществует)  и  указывает Турбо Си, куда записывать соответствующую          
     информацию. Если вы изменяете имя pick-файла, то Турбо Си сначала          
     сохраняет текущий pick-файл, а затем загружает новый.                      
                                                                                
          Если здесь имя не задано, то Турбо Си  записывает  pick-файл          
     только если  установка  Options/Directories/Current Pick File со-          
     держит имя файла.                                                          
                                                                                
                                                                                
          Для создания pick-файла вы должны определить  его  имя.  Для          
     этого вы  должны ввести имя в рамку, которая появляется после вы-          
     бора пункта Options/Directories/Current Pick  File.  После  того,          
     как вы  определите pick-файл, Турбо Си будет сохранять его каждый          
     раз при выходе из системы. Это имя pick-файла будет  сохранено  в          
     вашем файле  конфигурации  при  выполнении  команды  Options/Save          
     Options.                                                                   
                                                                                
                                                                                
               Current Pick File (текущий файл выбора)                          
     -----------------------------------------------------------------          
                                                                                
          Этот пункт  меню  показывает  имя и расположение pick-файла,          
     если он существует. Информацию этого пункта нельзя изменять.  Те-          
     кущий  pick-файл  показывает  имя  файла выбора, используемого по          
     умолчанию или задаваемого вами с помощью команды Pick File  Name.          
     Если  вы изменяете имя pick-файла или выходите из интегрированной          
     среды, Турбо Си сохраняет текущую информацию  в  указанном  здесь          
     файле выбора.                                                              
                                                                                
                                                                                
                                                                                

                         - 337,338 -
                                                                                
               Arguments (аргументы)                                            
     -----------------------------------------------------------------          
                                                                                
          Позволяет вам задавать аргументы командной строки для выпол-          
     няемой программы, как если бы они были набраны в командной строке          
     DOS (переназначение не поддерживается). Здесь необходимо задавать          
     только одни аргументы, без имени программы.                                
                                                                                
                                                                                
                                                                                
               Save Options (сохранить опции)                                   
     -----------------------------------------------------------------          
                                                                                
          Сохраняет все  выбранные вами опции компилятора, компоновщи-          
     ка, среды, отладчика и проектировщика в  файле  конфигурации  (по          
     умолчанию  им  является  файл TCCONFIG.TC). При загрузке Турбо Си          
     ищет в текущем каталоге TCCONFIG.TC; при его отсутствии там, Тур-          
     бо Си просматривает каталог Турбо Си.                                      
                                                                                
                                                                                
                                                                                
               Retrieve Options (восстановить опции)                            
                                                                                
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Загружает файл  конфигурации,  ранее  сохраненный   командой          
     Options/Save Options.                                                      
                                                                                
                                                                                
                                                                                
                                                                                
               Debug (меню отладчика)                                           
     -----------------------------------------------------------------          
                                                                                
          Команды этого  меню  управляют  установками интегрированного          
     отладчика, за исключением точек останова и контрольных  выражений          
     (они указаны в меню Break/Watch).                                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 339,340 -
                                                                                
     ╔───────────────────────────────────────────────────────────────╗          
     ║   Files Edit  Run  Compile Project Options ║Debug║ Break/watch║          
     ║─────────────────────────  Edit  ──────────────────────────────║          
                                 └─────┘            ║                           
     ║  Line 1  Col 1  Insert Indent Tab    ║Evaluate   Ctrl-F4     ║║          
     ║                                      ║───────────────────────║║          
     ║                                      ║Call stack Ctrl-F3     ║║          
     ║                                      ║Find function          ║║          
     ║                                      ║Refresh display        ║║          
     ║                                      ║Display swapping  Smart║║          
     ║                                      ║Source debugging  On   ║║          
     ║                                      └───────────────────────┘║          
     ║                                                               ║          
     ║                                                               ║          
     ═══════════════════════════ Watch ══════════════════════════════           
     ║                                                               ║          
     ║  F1-Help F5-Zoom F6-Switch F7-Trace F8-Step F9-Make F10-Menu  ║          
     └───────────────────────────────────────────────────────────────┘          
                                                                                
               Рис 5.22. Меню отладчика (Debug)                                 
                                                                                
                                                                                
                                                                                
     Evaluate (Оценка)                                                          
     -----------------------------------------------------------------          
                                                                                
          "Оценка" позволяет оценивать переменные или выражения, отоб-          
     ражать их значения и, при необходимости, модифицировать их значе-          
     ния.                                                                       
                                                                                
          Команда открывает расположенное вверху окно,  содержащее три          
     поля: поле оценки (Evaluate), результирующее (Result) поле и поле          
     нового значения (New Value).  При этом в поле оценки  переносится          
     текущее выражение,  представляющее собой слово, на котором разме-          
     щается в данное время курсор в  окне  редактирования.  Вы  можете          
     оценить текущее  выражение,  нажав Ввод,  отредактировать его или          
     оставить прежним. Вы можете также расширить текущее выражение пу-          
     тем  копирования дополнительных символов из окна редактирования с          
     помощью ключа "Right arrow" (стрелка вправо).                              
                                                                                
          Вы можете оценить любое допустимое выражение Си, если оно не          
     содержит:                                                                  
                                                                                
          - функциональных обращений;                                           
                                                                                

                         - 341,342 -
                                                                                
          - обозначений  или макросов,  определяемых с помощью #define          
     или typedef;                                                               
                                                                                
          - локальных либо статических переменных,  не  находящихся  в          
     области действия используемой функции до тех пор, пока они не бу-          
     дут полностью квалифицированы.                                             
                                                                                
          Если отладчик может оценить выражение,  то он отображает его          
     значение в результирующем поле.                                            
                                                                                
          Если выражение относится к переменной, либо простому элемен-          
     ту данных,  то вы можете переместить курсор вниз  в  поле  нового          
     значения и ввести выражение как новое значение.                            
                                                                                
          Если вам необходимо модифицировать значение выражения, но вы          
     не хотите делать этого,  нажмите клавишу Esc для того, чтобы зак-          
     рыть окно.  Если вы изменили содержание поля нового значения,  но          
     не нажали клавиши Ввод, отладчик проигнорирует сделанные вами из-          
     менения при выходе из окна.                                                
                                                                                
          Debug/Evaluate отобразит каждый тип значения в соответствую-          
     щем формате. Например, он отобразит int как целое по основанию 10          
                                                                                
                                                                                
     и массив как указатель по основанию 16.  Для того, чтобы получить          
     различные форматы отображения, дополните выражение командой, сле-          
     дующей за одним из форматных спецификаторов, приведенных в Табли-          
     це 5.5.                                                                    
                                                                                
          Используйте повторное  выражение  для  отображения  значений          
     последовательных элементов данных.  Например:  для массива целых,          
     поименованного xarray,                                                     
                                                                                
          xarray[0],5    отображается 5 последовательных целых чисел            
                         в десятичной системе счисления                         
                                                                                
          xarray[0],5x   отображается 5 последовательных целых чисел            
                         в шестнадцатиричной форме.                             
                                                                                
          Выражение, использованное в повторном счете,  должно  предс-          
     тавлять собой один элемент данных. Отладчик рассматривает элемент          
     данных как первый элемент массива,  если он не является  указате-          
     лем, либо как указатель массива, если он является таковым.                 
                                                                                
                                                                                

                         - 343,344 -
                                                                                
               Таблица 5.5. Спецификаторы формата, распознаваемые               
                            в выражениях отладчика.                             
     -----------------------------------------------------------------          
     Символ                        Функция                                      
     -----------------------------------------------------------------          
                                                                                
       C      Character (символ).  Показывает специальные символы ото-          
              бражения для управляющих символов (ASCII от 0 до 31); по          
              умолчанию подобные символы показываются с использованием          
              соответствующих управляющих последовательностей  Си (\n,          
              \t, и т.д.). Действует на символы и строки.                       
                                                                                
                                                                                
       S      String  (строка).  Показывает управляющие символы (ASCII          
              от 0  до 31) в виде значение ASCII,  используя соответс-          
              твующие управляющие последовательности  Си.  В  связи  с          
              тем, что это формат отображения текущего символа и стро-          
              ки, то спецификатор S может быть использован  только  со          
              спецификатором M.                                                 
                                                                                
                                                                                
       D      Decimal (десятичный). Все целочисленные значения отобра-          
                                                                                
              жаются в десятичной системе счисления.  Действует как на          
              выражения с простыми целыми числами,  так и на массивы и          
              структуры, содержащие целые числа.                                
                                                                                
                                                                                
      H или X Hexadecimal (шестнадцатиричный).  Все целочисленные зна-          
              чения  отображаются в виде шестнадцатиричных с прибавле-          
              нием впереди 0x. Действует на выражения с простыми целы-          
              ми числами,  а также на массивы и структуры,  содержащие          
              целые числа.                                                      
                                                                                
      F<n>    Floating point (плавающая точка).   n представляет собой          
              целое число  от  2  до 18,  определяющее номера значащих          
              цифр для отображения.  Текущее число равно 7.  Действует          
              только на значения с плавающей точкой.                            
                                                                                
       M      Memory dump (дамп памяти). Отображает  дамп памяти,начи-          
              нающийся с адреса отмеченного выражения. Выражение долж-          
              но представлять собой конструкцию,  которая с левой сто-          
              роны должна быть приемлема для  оператора  присваивания.          
              Другими словами,  конструкция указывает на адрес памяти.          
              В противном случае спецификатор M игнорируется. По умол-          

                         - 345,346 -
                                                                                
                                                                                
              чанию,  каждый  байт переменной показывается в виде двух          
              шестнадцатиричных цифр.  В случае использования вместе с          
              M спецификатора D, байты будут отображаться в виде деся-          
              тичных цифр.  При использовании вместе с M спецификатора          
              H или X, байты будут отображаться в виде шестнадцатирич-          
              ных цифр.  Использование спецификаторов C и S приведет к          
              тому, что переменная будет отображаться в виде строки (с          
              или без специальных символов).  Текущее число байт соот-          
              ветствует  размеру  переменной,  однако  для определения          
              точного числа  байт  может  быть  использован  повторный          
              счет.                                                             
                                                                                
       P      Pointer (указатель). Отображает указатели в формате seg:          
              ofs с дополнительной информацией  об  указанных  адресах          
              скорее,  чем текущий формат seg:ofs,  ориентированный на          
              аппаратные средства.  Точнее, он сообщает вам об области          
              памяти, в которой находится сегмент, и имя переменной по          
              смещенному адресу,  если он присвоен. Области памяти мо-          
              гут быть следующими:                                              
                                                                                
                                                                                
                                                                                
                                                                                
              --------------------------------------------------------          
                 Область памяти         Оценочное сообщение                     
              --------------------------------------------------------          
                                                                                
              0000:0000-0000:03FF    Таблица вектора прерывания                 
                                                                                
              0000:0400-0000:04FF    Область данных BIOS                        
                                                                                
              0000:0500 - Турбо Си   MSDOS/TSR                                  
                                                                                
              Турбо Си - Пользовате- Турбо Си                                   
              льская программа PSP                                              
                                                                                
              Пользовательская       Пользовательский процесс PSP               
              программа PSP                                                     
                                                                                
              Пользовательская про-  Имя статической переменной  поль-          
              грамма PSP - верх ОЗУ  зователя, если ее адрес  попадает          
                                     в память, где находятся  перемен-          
                                     ные, в противном случае, ничего            
                                                                                

                         - 347,348 -
                                                                                
              A000:0000-AFFF:FFFF    EGA (усовершенствованный графиче-          
                                     ский адаптер) Video RAM (видеопа-          
                                     мять)                                      
                                                                                
              B000:0000-B7FF:FFFF    Монохромный дисплей ОЗУ (RAM)              
                                                                                
              B800:0000-BFFF:FFFF    Цветный дисплей ОЗУ (RAM)                  
                                                                                
              C000:0000-EFFF:FFFF    Страницы EMS/Адаптер BIOS ПЗУ              
                                     (ROM)                                      
                                                                                
              F000:0000-EFFF:FFFF    BIOS ROM (базовая система ввода-           
                                     вывода ПЗУ)                                
              --------------------------------------------------------          
                                                                                
       R      Structure/Union (структура/объединение). Отображает име-          
              на полей,  а также значений типа {x:1, y:10, z:5}. Дейс-          
              твует только на структуры и объединения                           
     -----------------------------------------------------------------          
                                                                                
          "Горячим ключом" для Debug/Evaluate является Ctrl-F4.                 
                                                                                
                                                                                
     Поиск функции (Find Function)                                              
     -----------------------------------------------------------------          
                                                                                
          Поиск функции отображает определенные функции в окне  редак-          
     тирования.  Команда  может найти любую функцию в вашей программе,          
     которая компилировалась с помощью Debug/Source Debugging и O/C/C/          
     OBJ Debug Information в случае, если их опции включены (в положе-          
     нии "ON"),  и чьи исходные файлы доступны.  Если  функции  нет  в          
     отображаемом в настоящее время файле,  команда автоматически заг-          
     ружает надлежащий файл.                                                    
                                                                                
          Для поиска функции вы должны находится в сеансе отладки.              
                                                                                
                                                                                
                                                                                
               Стек вызова (Call stack)                                         
     -----------------------------------------------------------------          
                                                                                
          Команда стек вызова отображает в верхней части  экрана окно,          
     содержащее стек вызова. Стек вызова показывает последовательность          
     функций, вызываемых вашей программой с тем, чтобы достичь работа-          
     ющей  в настоящее время функции.  Функция main находится в нижней          

                         - 349,350 -
                                                                                
     части стека;  работающая в настоящее время  функция  находится  в          
     верхней части стека.                                                       
                                                                                
          Каждое обращение  к  стеку  вызова отображает имя вызываемой          
     функции и значения параметров, передаваемых ему.                           
                                                                                
          Выход в верхнюю часть стека выделяется подсветкой. Для отоб-          
     ражения  текущей строки любой другой функции вызова стека необхо-          
     димо переместить подсветку на имя этой функции и  нажать  клавишу          
     Ввод.  Курсор  будет перемещен на строку,  содержащую обращение к          
     функции, следующей выше в стеке. Например, если стек вызова будет          
     выглядеть следующим образом:                                               
                                                                                
          func 2 ()                                                             
          func 1 ()                                                             
          main ()                                                               
                                                                                
     (таким образом main вызывает func 1, а func 1 вызывает func 2), а          
     вам хотелось бы увидеть исполняемую в настоящее время строку func          
     1, вы должны переместить подсветку на func 1 в стеке вызова и на-          
     жать клавишу Ввод.  Код для func 1 должен появиться в окне редак-          
     тирования, а курсор переместиться на обращение к func 2.                   
                                                                                
                                                                                
          Для возврата  текущей  строки  работающей  в настоящее время          
     функции (т.е.  находящейся в положении исполнения) подсветите са-          
     мую верхнюю функцию в стеке вызова и нажмите клавишу Ввод.                 
                                                                                
          Некоторые функции могут не запускаться из стека вызова, если          
     ваша   программа    компилировалась    при    включенной    опции          
     O/C/C/Standart Stack Frame. Для получения дополнительной информа-          
     ции смотрите описание O/C/C/Standart Stack Frame.                          
                                                                                
          "Горячим ключом" для  O/C/C/Standart  Stack  Frame  является          
     Ctrl-F3.                                                                   
                                                                                
                                                                                
                                                                                
               Отладка исходных текстов (Source Debugging)                      
     -----------------------------------------------------------------          
                                                                                
          Опция Debug/Source Debugging имеет три режима установки фла-          
     га: Включено, Автономно и Выключено.                                       
                                                                                
          Программы, компонуемые при положении флага "Включено", могут          

                         - 351,352 -
                                                                                
     отлаживаться как во встроенном в ТС отладчике,  так и в стандарт-          
     ном отладчике Turbo.                                                       
                                                                                
          Если флаг находится в позиции Автономно,  то программы могут          
     быть отлажены только с помощью отладчика Turbo, хотя могут запус-          
     каться в ТС.  При положении флага "Выключено" программы не  могут          
     быть отлажены по той причине,  что в .EXE файле нет информации по          
     отладке.                                                                   
                                                                                
                                                                                
                                                                                
               Свопинг экрана (Display Swapping)                                
     -----------------------------------------------------------------          
                                                                                
          Debug/Display Swapping ("подкачка" экрана при работе в сеан-          
     се отладки) имеет трехпозиционный флаг, который устанавливается в          
     следующих положениях:  Smart (установлена по  умолчанию);  Always          
     (всегда); None (выключено).                                                
                                                                                
          При запуске своей программы в режиме отладки с установленным          
     по умолчанию флагом в положении Smart, отладчик просматривает ис-          
     полняемый код с тем, чтобы определить, будет код генерировать вы-          
                                                                                
     вод  данных на экран или нет.  Если код выполняет вывод данных на          
     экран (или если он вызывает функцию), то экран заменяется с экра-          
     на редактирования на пользовательский экран на время, достаточное          
     для вывода данных,  затем возвращается  экран  редактирования.  В          
     других случаях свопинга экрана не происходит.                              
                                                                                
          Примечание: Smart,  что дословно означает "сообразительный",          
     не во всех случаях отвечает своему названию:                               
                                                                                
          - этот режим производит замену экрана при вызове любой функ-          
     ции даже в том случае, когда вызываемая функция не выводит данные          
     на экран;                                                                  
                                                                                
          - в некоторых случаях экран редактора может быть модифициро-          
     ван  без  замены.  Например,  когда происходят выдачи на экран во          
     время прерывания работы сервисной программы по таймеру.                    
                                                                                
          При положении флага Always экран будет заменяться, когда бу-          
     дет выполняться оператор.  Вы можете использовать этот режим каж-          
     дый раз,  когда желаете переписать экран редактора вашей работаю-          
     щей программой.                                                            
                                                                                

                         - 353,354 -
                                                                                
          При положении  флага  None отладчик не заменяет экран.  Этот          
     режим мог бы использоваться для отладки сегментов  кода, который,          
     по вашему мнению, не должен выводиться на экран.                           
                                                                                
     Примечание: Если  вы  производите отладку в двухмониторном режиме          
                 (т.е. использовали командную строку ТС /d  ключ),  то          
                 можете  увидеть вывод данных своей программы на одном          
                 мониторе, а экран ТС на другом. Следовательно, ТС ни-          
                 когда  не  заменяет  экранов,  а  потому Debug/Screen          
                 Swapping в этом случае неэффективен.                           
                                                                                
                                                                                
                                                                                
               Регенерация дисплея (Refresh Display)                            
     -----------------------------------------------------------------          
                                                                                
          Если экран редактора ошибочно переписан, вы можете использо-          
     вать эту опцию для восстановления предудыщего содержания.                  
                                                                                
                                                                                
                                                                                
               Меню прерываний/слежения (Break/Watch Menu)                      
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Меню включает в себя команды, управляющие точками прерывания          
     и контрольными (следящими) выражениями.                                    
                                                                                
          Точка прерывания представляет собой то  место  в  программе,          
     где  происходит ее останов с тем,  чтобы дать вам время проверить          
     значение критических переменных и выражений.  Это нужно для того,          
     чтобы вы могли убедиться, что ваша программа работает так как на-          
     до.                                                                        
                                                                                
          Контрольная точка обозначается подсветкой контрольной точки.          
     Когда программа останавливается на точке прерывания,  то ее подс-          
     ветка становится незаметной из-за полосы выполнения, но снова по-          
     является, когда полоса выполнения начинает двигаться.                      
                                                                                
          Контрольное выражение представляет собой выражение, чье зна-          
     чение отображается в окне Watch. При останове программы контроль-          
     ное значение перевычисляется. Правила ввода правильного контроль-          
     ного     выражения     аналогичны     правилам     Debug/Evaluate          
     (отладки/оценки)  за исключением того,  что контрольное выражение          
     может не содержать побочных эффектов типа i++. Символы конверсно-          

                         - 355,356 -
                                                                                
                                                                                
     го  типа,  а также повторный счет могут быть использованы в конт-          
     рольных выражениях также, как и в Debug/Evaluate. Например:                
                                                                                
              i,x                                                               
                                                                                
     отображает содержание целого числа i в шестнадцатиричном формате.          
                                                                                
          Если вы  желаете  ввести  дополнительные  выражения  в  окно          
     Watch,  то можете увеличить его до максимальных  размеров  (около          
     половины  экрана) с помощью опции изменения размеров окон сервис-          
     ной программы TCINST.  Если вы вводите большее количество выраже-          
     ний, чем может поместиться в окне, то некоторые выражения исчеза-          
     ют из окна.  Для их просмотра в окне Watch  используются  клавиши          
     "Страница  вверх",  "Страница  вниз",  "Стрелка вверх",  "Стрелка          
     вниз".                                                                     
                                                                                
          Текущее контрольное выражение в окне Watch выделяется в слу-          
     чае, если окно Watch активно - полосой подсветки, если окно Watch          
     не активно - знаком "пуля" () в левой колонке.                             
                                                                                
                                                                                
                                                                                
     ╔───────────────────────────────────────────────────────────────╗          
     ║  Files Edit  Run  Compile Project Options Debug ║ Break/watch ║          
     ║─────────────────────────  Edit  ──────────────────────────────║          
                                 └─────┘            ║                           
     ║ Line 1 Col 1 Insert Indent Tab Fill  ║Add watch         CtrlF7║          
     ║                                      ║────────────────────────║          
     ║                                      ║Delete watch            ║          
     ║                                      ║Edit watch              ║          
     ║                                      ║Remove all watches      ║          
     ║                                      ║                        ║          
     ║                                      ║Toogle breakpoint CtrlF8║          
     ║                                      ║Clear all breakpoints   ║          
     ║                                      ║View next breakpoints   ║          
     ║                                      └────────────────────────║          
     ║                                                               ║          
     ═══════════════════════════ Watch ══════════════════════════════           
     ║                                                               ║          
     ║Alt: F1-Last help F3-Pick F6-Swap F7/F8-Prv/Next err F9-Compile║          
     └───────────────────────────────────────────────────────────────┘          
                                                                                
                    Рисунок 5.23. Меню Break/Watch.                             
                                                                                

                         - 357,358 -
                                                                                
                                                                                
                                                                                
               Команда "Add Watch"                                              
     -----------------------------------------------------------------          
                                                                                
          Эта команда  позволяет  вывести контрольное выражение в окно          
     Watch.  При выборе вами этой команды отладчик  открывает  окно  в          
     верхней  части  экрана и запрашивает ввод контрольного выражения.          
     Текущим выражением является слово,  на котором стоит курсор в эк-          
     ране редактирования. После того, как вы наберете правильное выра-          
     жение,  нажмите Ввод.  Отладчик добавит выражение и  его  текущее          
     значение в окно Watch.                                                     
                                                                                
          "Горячим ключом"  для  этой команды является Ctrl-F7.  Кроме          
     того,  если окно Watch активно,  то вы можете ввести новое  конт-          
     рольное выражение, нажав на Ins (Вст), либо Ctrl-N.                        
                                                                                
                                                                                
                                                                                
               Стирание контрольных выражений (Delete Watch)                    
     -----------------------------------------------------------------          
                                                                                
                                                                                
          Эта команда стирает контрольные выражения из окна Watch. Для          
     того,  чтобы вы могли использовать эту команду,  вы должны видеть          
     окно Watch,  т.е. в этом случае окно редактирования не может быть          
     раскрыто на весь экран дисплея.  Если вы находитесь в окне Watch,          
     то текущее контрольное выражение обозначается  полосой подсветки,          
     если вы находитесь в экране Edit, то оно обозначается знаком "пу-          
     ли" () с левой стороны.                                                    
                                                                                
          Для стирания контрольного выражения, отмеченного знаком "пу-          
     ли", выберите Break/Watch/Delete Watch, если вы находитесь в окне          
     Edit.  Для стирания контрольного выражения,  не являющегося теку-          
     щим,  вы должны выйти в окно Watch,  переместить полосу подсветки          
     на необходимое выражение и нажать либо Del, либо Ctrl-Y.                   
                                                                                
                                                                                
                                                                                
               Редактирование контрольных выражений (Edit Watch)                
     -----------------------------------------------------------------          
                                                                                
          Эта команда  позволяет вам редактировать текущее контрольное          
     выражение в окне Watch.                                                    
                                                                                

                         - 359,360 -
                                                                                
          Когда вы выбираете Break/Watch (Edit Watch), отладчик откры-          
     вает всплывающее окно, содержащее копию текущего контрольного вы-          
     ражения.  Отредактировав его,  нажмите Ввод;  Отладчик произведет          
     замену прежнего варианта контрольного выражения на новый отредак-          
     тированный вариант. Вы можете также редактировать контрольное вы-          
     ражение из окна Watch путем перемещения полосы подсветки на необ-          
     ходимое выражение и нажатия клавиши Ввод.                                  
                                                                                
                                                                                
                                                                                
          Стирание всех контрольных выражений (Remove all Watches)              
     -----------------------------------------------------------------          
                                                                                
          Эта команда  позволяет  стереть все контрольные выражения из          
     окна Watch.                                                                
                                                                                
                                                                                
                                                                                
               Флаг точки прерывания (Toggle Breakpoint)                        
     -----------------------------------------------------------------          
                                                                                
          Эта команда позволяет устанавливать или убирать точку преры-          
                                                                                
     вания в строке в месте расположения курсора.  При установке точки          
     прерывания она выделяется подсветкой.                                      
                                                                                
          Для запуска команды нажмите клавиши Ctrl-F8.                          
                                                                                
          Каждый раз,  когда ваша программа будет  доходить  до  точки          
     прерывания,  ее выполнение будет прекращаться. Во время остановки          
     программы полоса подсветки находится на строке с точкой  прерыва-          
     ния. Подсветка точки прерывания становится незаметной из-за подс-          
     веченной полосы выполнения. Как только полоса выполнения начинает          
     перемещаться, появляется выделение точки прерывания.                       
                                                                                
          При редактировании  исходного  файла каждая точка прерывания          
     "втыкается" в строку,  где была установлена. Она может потеряться          
     только когда вы покидаете интегрированную среду,  стираете исход-          
     ную строку,  где находится точка прерывания,  либо убираете ее  с          
     помощью      команд     Break/Watch/Toggle     Breakpoint     или          
     Break/Watch/Clear All Breakpoint.                                          
                                                                                
          Турбо Си "теряет дорогу" по своим точкам прерывания  в  двух          
     случаях:                                                                   
                                                                                

                         - 361,362 -
                                                                                
          - если вы редактируете файл,  содержащий точки прерывания, а          
            затем отказываетесь  от  отредактированной  версии  файла.          
            (Турбо  Си не может запомнить места установки точек преры-          
            вания, прежде чем файл будет отредактирован, поэтому пока-          
            зывает их в неправильных строках);                                  
                                                                                
          - если вы редактируете файл,  содержащий точки прерывания, а          
            затем продолжаете сеанс отладки без отметки  в  программе.          
            (Турбо   Си   отобразит   предупреждающий  запрос:  Source          
            modified, rebuild?  (Исходный текст модифицирован, перест-          
            роен)                                                               
                                                                                
          Прежде, чем вы будете компилировать исходный файл, вы можете          
     установить точку прерывания в любой строке,  даже в чистой, или в          
     комментарии.  Когда вы откомпилируете и запустите файл,  Турбо Си          
     проверит расположение точек прерывания и даст вам возможность пе-          
     реместить,  игнорировать или изменить неправильные точки прерыва-          
     ния.  При отладке файла Турбо Си,  зная расположение  выполняемых          
     операторов,  выдаст  предупреждение  об  ошибке в установке точки          
     прерывания.                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Убирание всех точек прерывания (Clear All Breakpoint)            
     -----------------------------------------------------------------          
                                                                                
          Эта команда убирает все точки прерывания из вашей программы.          
                                                                                
                                                                                
          Смотри следующую точку прерывания (View next Breakpoint)              
     -----------------------------------------------------------------          
                                                                                
          Эта команда перемещает курсор на следующую  точку прерывания          
     в вашей программе.  Обратите внимание на то,  что курсор перемес-          
     тится на следующую точку прерывания,  исходя из порядка их  уста-          
     новки, а не порядка их расположения в вашей программе. Эта коман-          
     да не запускает вашу программу;  она  только  размещает  активные          
     точки прерывания в окне редактирования.                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 363,364 -
                                                                                
               Часть III. Дополнительные сведения о конфигурационных            
               ---------- файлах и Pick файлах (выборки)                        
     -----------------------------------------------------------------          
                                                                                
                                                                                
               Что представляет собой конфигурационный файл?                    
     -----------------------------------------------------------------          
                                                                                
          Обычно, конфигурационный  файл представляет собой файл,  со-          
     держащий информацию, необходимую Турбо Си. В нем вы храните такую          
     информацию,  как выбранные опции компилятора, опции своего компо-          
     новщика и различные каталоги,  в которых нуждается Турбо  Си  при          
     компиляции и компоновке ваших программ.                                    
                                                                                
          Есть два типа конфигурационных файлов Турбо Си:  один вы ис-          
     пользуете с TCC.EXE (Турбо Си с командной строкой),  другой  -  с          
     TC.EXE (интегрированной средой Турбо Си).  Существует только один          
     конфигурационный файл с командной строкой.  Он должен  называться          
     TURBOC.CFG.  Файл  интегрированной  среды  может иметь любое имя.          
     Файл TCCONFIG.TC является текущим (подразумеваемым)  конфигураци-          
     онным файлом интегрированной среды разработки.                             
                                                                                
                                                                                
          В этой  части  мы детально рассмотрим конфигурационные файлы          
     интегрированной среды.  Если вы хотите больше узнать о  том,  как          
     использовать TURBOC.CFG, смотрите в главе 3 "TURBOC.CFG файл".             
                                                                                
                                                                                
                                                                                
               Конфигурационные файлы Турбо Си                                  
     -----------------------------------------------------------------          
                                                                                
          При первоначальном запуске интегрированной  среды  Турбо  Си          
     конфигурационного файла не существует. TC.EXE запускается со все-          
     ми флагами и отметками,  установленными  по  умолчанию  (Options/          
     Compiler/Model  будет  установлен  в  положение  Small;  Options/          
     Compiler/Calling Convention в положение  C;  Options/Environment/          
     Keep Messages в положение No и т.д.).  В случае использования ин-          
     тегрированной среды вам,  по-видимому, захочется изменить некото-          
     рые положения флагов и отметок.                                            
                                                                                
          Если вы  выходите из Турбо Си без сохранения новых положений          
     флагов и отметок в конфигурационном файле,  то  в  следующий  раз          
     должны  будете  устанавливать их заново,  т.к.  при запуске будут          
     выставлены предыдущие положения флагов и отметок.  Если вы сохра-          

                         - 365,366 -
                                                                                
     ните  новые  положения флагов и отметок в конфигурационном файле,          
     то при новом запуске меню будет с  теми  значениями,  которые  вы          
     выбрали. Вам не надо будет устанавливать их заново.                        
                                                                                
                                                                                
                                                                                
               TCCONFIG.TC                                                      
     -----------------------------------------------------------------          
                                                                                
          Когда вы стартуете TC.EXE,  она ищет конфигурационный  файл,          
     имеющий имя TCCONFIG.TC.  Она ищет его в определенных местах (да-          
     лее мы подробно объясним, где она его ищет). Если TC.EXE не может          
     найти  файл  TCCONFIG.TC,  то интегрированная среда запускается с          
     использованием положений, заданных по умолчанию в TC.EXE.                  
                                                                                
                                                                                
                                                                                
               Другие конфигурационные файлы ТС                                 
     -----------------------------------------------------------------          
                                                                                
          Вы можете  запустить TC.EXE в операционной системе, запросив          
     специальный конфигурационный файл. Для этого необходимо использо-          
                                                                                
     вать  ключ /c (для дополнительной информации смотри раздел "Ключи          
     командной строки ТС" (TC Command-Line Switches) стр.82 оригиналь-          
     ного руководства).                                                         
                                                                                
          Например, если вы наберете                                            
                                                                                
          tc/cmyconfig                                                          
                                                                                
     в ответ  на  приглашение операционной системы,  то Турбо Си будет          
     искать в текущем  каталоге  конфигурационный  файл,  имеющий  имя          
     MYCONFIG.TC (если вы не даете расширения,  то Турбо Си подразуме-          
     вает расширение .ТС).                                                      
                                                                                
          Если Турбо Си не может найти конфигурационного файла по име-          
     ни которое вы назвали, то он выдаст предупреждающее сообщение. Он          
     не будет искать другие конфигурационные файлы,  а  стартует,  ис-          
     пользуя встроенные,  заданные по умолчанию положения флагов и от-          
     меток.                                                                     
                                                                                
                                                                                
                                                                                
               Что хранится в конфигурационных файлах ТС                        

                         - 367,368 -
                                                                                
     -----------------------------------------------------------------          
                                                                                
          Информацию, хранящуюся  в конфигурационных файлах ТС,  можно          
     подразделить на две категории:  опции компилятора-компоновщика  и          
     особые значения TC.EXE.                                                    
                                                                                
          Опции компилятора-компоновщика  управляют компилятором.  Все          
     они имеют соответствующие опции в версии  Турбо  Си  с  командной          
     строкой.  Особые  значения TC.EXE связаны с собственно интегриро-          
     ванной средой.  Некоторыми примерами этих значений особых для ин-          
     тегрированной  среды  являются  меню  опций Project/Project Name,          
     Options/Directories/Pick File Name и Options/Environment.                  
                                                                                
                                                                                
                                                                                
               Создание конфигурационного файла ТС                              
     -----------------------------------------------------------------          
                                                                                
          Как можно  создать  конфигурационный  файл ТС?  В отличие от          
     конфигурационного файа (TURBOC.CFG) с командной строкой, конфигу-          
     рационный файл интегрированной среды не может быть создан или мо-          
     дифицирован с помощью редактора.  Вместо этого вы должны  выбрать          
                                                                                
     команду Options/Save Options из меню опций и интегрированная сре-          
     да создаст для вас конфигурационный файл.                                  
                                                                                
          Если вы установите Options/Environment/Config  Auto  Save  в          
     положение  ON  (Включено),  ваши  текущие положения отметок будут          
     сохранены в конфигурационном файле ТС (TCCONFIG.TC) при выходе из          
     интегрированной среды.                                                     
                                                                                
                                                                                
                                                                                
               Изменение конфигурационных файлов во время работы                
     -----------------------------------------------------------------          
                                                                                
          Внести изменения в конфигурационный файл .ТС, находясь внут-          
     ри интегрированной среды несложно. Для этого надо:                         
                                                                                
          - выбрать опцию Options/Retrieve Options из меню опций. Поя-          
     вится всплывающий прямоугольник, отображающий имя последнего кон-          
     фигурационного файла,  введенного вами (в первый раз по умолчанию          
     *.ТС).                                                                     
                                                                                
          - вы можете набрать маску (типа *.tc,  либо ??config.*). За-          

                         - 369,370 -
                                                                                
     тем нажмите Ввод с тем,  чтобы получить каталог файлов .ТС. После          
     того,  как вы выбрали файл из каталога, вы можете набрать его имя          
     и нажать Ввод для его загрузки.                                            
                                                                                
                                                                                
                                                                                
               Где TC.EXE ищет TCCONFIG.TC                                      
     -----------------------------------------------------------------          
                                                                                
          Имеется два места,  где TC.EXE  ищет  конфигурационный  файл          
     TCCONFIG.TC по умолчанию.  Первое - текущий каталог.  Если TC.EXE          
     не находит файла TCCONFIG.TC здесь,  то ищет в каталоге Турбо Си,          
     Если  вы  предварительно  включили  каталог  Турбо  Си  с помощью          
     TCINST.                                                                    
                                                                                
          Если вы хотите получить дополнительную информацию по катало-          
     гу Турбо Си и TCINST, читайте приложение F "Настройка Турбо Си" в          
     Справочном руководстве по Турбо Си.                                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               TCINST в сравнении с конфигурационным файлом:                    
               кто управляет?                                                   
     -----------------------------------------------------------------          
                                                                                
          Вы можете использовать TCINST для установки  любых элементов          
     данных,  находящихся в меню Турбо Си, затем сохранить эти отметки          
     непосредственно в TC.EXE.  Если конфигурационный файл ТС не  най-          
     ден, то  запускается ваш настроенный TC.EXE с установками,  дейс-          
     твующими по умолчанию.                                                     
                                                                                
          Однако, если TC.EXE запускается и находит TCCONFIG.TC файл в          
     текущем каталоге (либо в каталоге Турбо Си),  то установки, запи-          
     санные в этом файле, будут иметь преимущество перед теми установ-          
     ками, которые вы установили с помощью TCINST.                              
                                                                                
          Следовательно, если вы вызываете TC.EXE,  используя ключ /c,          
     и Турбо Си находит определенный вами  конфигурационный  файл,  то          
     положения отметок,  записанные в файле,  будут иметь преимущество          
     перед положениями отметок, установленными с помощью TCINST.                
                                                                                
                                                                                
                                                                                

                         - 371,372 -
                                                                                
          Что делает команда Options/Environment/Config Auto Save?              
     -----------------------------------------------------------------          
                                                                                
          Турбо Си сохранит текущий конфигурационный файл (запишет его          
     на магнитный диск) только тогда, когда вы воспользуетесь командой          
     Options/Environment/Config  Auto Save.  Однако,  при определенных          
     условиях вы можете сделать так,  чтобы Турбо Си сохранял конфигу-          
     рационный файл автоматически.                                              
                                                                                
          Установите флаг Options/Environment/Config Auto Save в поло-          
     жение ON (Включено). При этом положении флага Турбо Си будет сох-          
     ранять файл всякий раз, когда вы используете команды Run/Run, ли-          
     бо File/OS Shell,  либо когда используете команду  File/Quit  для          
     выхода из интегрированной среды.  Сохранение файла будет происхо-          
     дить, если он до этого не был сохранен или он был модифицирован с          
     момента последнего сохранения.  Если конфигурационный файл прежде          
     не был сохранен,  Турбо Си произведет выбор имени файла  для  его          
     сохранения в автоматическом режиме из двух возможных вариантов:            
                                                                                
          - по  имени  последнего конфигурационного файла,  которое вы          
     хранили или выбирали;                                                      
                                                                                
                                                                                
                                                                                
          - TCCONFIG.TC (в текущем каталоге),  если вы еще не загружа-          
     ли, не хранили, либо не выбирали конфигурационный файл.                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 373,374 -
                                                                                
               Что представляют собой списки и файлы Pick (выборки)             
     -----------------------------------------------------------------          
                                                                                
          Список и файл Pick являются двумя нужными возможностями  ин-          
     тегрированной среды Турбо Си.  Они действуют совместно. Их основ-          
     ной задачей является сохранение состояния сеансов редактирования.          
     Список Pick  запоминает  какие  файлы вы редактируете в то время,          
     когда находитесь в интегрированной среде.  Файл  Pick  запоминает          
     какие файлы вы редактировали после того,  как покинули интегриро-          
     ванную среду,  либо после изменения контекстов внутри  интегриро-          
     ванной среды. (Изменение контекстов означает загрузку нового кон-          
     фигурационного  файла,  либо  определение  нового   имени   файла          
     Pick)                                                                      
                                                                                
                                                                                
                                                                                
               Список Pick (выборки)                                            
     -----------------------------------------------------------------          
                                                                                
          Вы можете выбрать список Pick по команде File/Pick, либо на-          
     жав  Alt-F3.  Команда File/Pick обеспечивает выдачу списка восьми          
     файлов, загруженных в последнее время в редактор.  Если в  списке          
                                                                                
     более  одного  имени  файла,  то  имя  второго  файла  выделяется          
     подсветкой. Этот файл был загружен в редактор раньше.                      
                                                                                
          Для загрузки файла из списка Pick в  редактор, необходимо  с          
     помощью клавиш со стрелками переместить полосу подсветки на соот-          
     ветствующее имя файла и нажать клавишу Ввод.  Когда вы это проде-          
     лаете,  Турбо Си загрузит выбранный файл в редактор. Редактор по-          
     местит курсор в этом вновь загруженном файле в том  месте, откуда          
     вы  вышли последний раз.  Кроме того,  любой маркированный блок и          
     маркеры в файле будут в точности соответствовать  тем положениям,          
     при которых вы выходили из файла.                                          
                                                                                
          Список Pick  является  удобным  инструментом для перемещения          
     назад и вперед  ваших  файлов  при  разработке  программы.  Нажав          
     Alt-F3 и Ввод,  вы можете чередовать файлы (соответствует нажатию          
     Alt-F6 в редакторе).                                                       
                                                                                
          Если файл,  который вы ищете,  отсутствует в списке Pick, то          
     можете выбрать --load file-- (последний ввод в меню списка Pick).          
     По этой команде выдается рамка Load  File  Name  (загрузка  имени          
     файла),  где  вы  можете набрать имя нужного вам файла (используя          
     символы множественного выбора ДОС). Вы можете также нажать F3 для          

                         - 375,376 -
                                                                                
     автоматического выбора File/Load.                                          
                                                                                
                                                                                
                                                                                
               Файл Pick                                                        
     -----------------------------------------------------------------          
                                                                                
          Файл Pick хранит информацию,  связанную с  файлами,  включая          
     содержание списка Pick.  Для каждого файла в списке Pick Турбо Си          
     сохраняет имя  файла,  поожение  курсора,  маркированный  блок  и          
     маркеры.                                                                   
                                                                                
          В дополнение  к информации о каждом файле файл Pick содержит          
     данные о состоянии редактора,  когда вы последний раз выходили из          
     него.  Он содержит также самые последние строки поиска и замены и          
     опции поиска.                                                              
                                                                                
          Для создания файла Pick вы должны  определить  его  имя.  Вы          
     можете  сделать это с помощью Options/Directories/Pick File Name,          
     затем ввести имя файла.  Как только вы определите имя файла Pick,          
     Турбо Си будет сбрасывать его на диск всякий раз, когда вы будете          
     выходить из интегрированной среды.                                         
                                                                                
                                                                                
                                                                                
                                                                                
               Когда и каким образом вы получаете файл Pick?                    
     -----------------------------------------------------------------          
                                                                                
          Есть два  меню,  которые вы можете просмотреть для получения          
     информации о файле Pick:  Options/Directories/Pick  File  Name  и          
     Options/Directories/Current Pick File.                                     
                                                                                
     Q:   Каким образом можно узнать, имеете ли вы файл Pick?                   
                                                                                
     A:   Вы имеете файл Pick, если поле меню Options/Directories/              
          Current Pick File содержит имя файла.                                 
                                                                                
     Q:   Каким образом это имя файла появляется в Options/Directories          
          /Current Pick File?                                                   
                                                                                
     A:   Имя файла либо вносится в список с помощью Options/                   
          Directories/Pick File Name, либо (если поле меню Options/             
          Directories/Pick File Name не содержит в себе имя файла)              
          загрузкой текущего файла Pick.                                        

                         - 377,378 -
                                                                                
                                                                                
     Q:   Предположим, что Options/Directories/Pick File Name содержит          
          имя файла. Каким образом оно там появляется?                          
                                                                                
     A:   Вы помещаете имя файла в Pick File Name следующим образом:            
                                                                                
          - вводя его собственноручно во время текущего сеанса;                 
                                                                                
          - введя  его в предыдущем сеансе,  сохраняя конфигурационный          
            файл,  а затем используя в конфигурационный файл в текущем          
            сеансе;                                                             
                                                                                
          - выполняя его инсталяцию с помощью TCINST.                           
                                                                                
     Q:   Предположим, поле Options/Directories/Pick File Name пустое,          
          а поле Options/Directories/Current Pick  File  содержит  имя          
          файла Pick. Каким образом оно туда загружается?                       
                                                                                
     A:   В текущем каталоге, либо (если не в нем) в каталоге Турбо Си          
          имеется текущий файл Pick, имеющий имя TCPICK.TCP. Этот файл          
          при запуске автоматически загружается Турбо Си.                       
                                                                                
                                                                                
          Как только  файл Pick будет загружен,  интегрированная среда          
     заполняет его полное составное имя. Эта информация отображается в          
     поле Options/Directories/Current Pick File.                                
                                                                                
                                                                                
                                                                                
               Где Турбо Си сохраняет файлы Pick?                               
     -----------------------------------------------------------------          
                                                                                
          Турбо Си   сохраняет   файл,   поименованный   в    Options/          
     Directories/Current Pick  File  всякий раз,  когда вы выходите из          
     интегрированной среды. Кроме того, в каждом случае, когда меняет-          
     ся  имя файла Pick (непосредственно,  путем ввода нового имени из          
     меню, либо косвенно, при загрузке конфигурационного файла, содер-          
     жащего другое имя файла Pick), Турбо Си в первую очередь сохраня-          
     ет имя текущего файла.                                                     
                                                                                
          Турбо Си не будет сохранять файл Pick путем  его  сброса  на          
     магнитный  диск  при выходе из ТС,  если поле Options/Directories          
     /Current Pick File пустое.                                                 
                                                                                
                                                                                

                         - 379,380 -
                                                                                
               Часть IV. Дополнительные возможности и команды                   
               --------- редактирования.                                        
     -----------------------------------------------------------------          
                                                                                
          К некоторым полезным возможностям редактирования  Турбо  Си,          
     которые можно использовать в интегрированной среде,  нельзя полу-          
     чить доступ из системы меню. В этой части содержится информация о          
     том,  каким образом использовать эти возможности при редактирова-          
     нии исходного текста.                                                      
                                                                                
                                                                                
                                                                                
               Дополнительные сведения о табуляции                              
     -----------------------------------------------------------------          
                                                                                
          1. В случае, когда режим табуляции редактора выключен, нажав          
     клавишу Тab можно вставить достаточное количество пробелов с тем,          
     чтобы  переместить курсор на следующий символ табуляции.  Позиции          
     табуляции выравниваются по первой букве каждого  слова  в  строке          
     текста над текущей строкой.  (При включенном режиме табуляции на-          
     жатие клавиши Tab позволяет вставить достаточное пространство для          
     перемещения курсора на следующую позицию табуляции. Как определе-          
                                                                                
                                                                                
     но Options/Environment/Tab Size по умолчанию 8 пробелов.)                  
                                                                                
          2. Если вы пересылаете выделенный блок текста из редактора в          
     файл (или в PRN) с помощью команды Ctrl-K W,  редактор обращается          
     со всеми символами табуляции как с клавишами табуяции и описывает          
     (или погашает) их в виде последних.  Это в целом приводит к уста-          
     новке позиций табуляции в каждом восьмом столбце. Однако, при пе-          
     ресылке текста из редактора на принтер с помощью команды Ctrl-K P          
     редактор обращается со знаками табуляции как с символами  табуля-          
     ции  и  печатает  их  в виде соответствующего количества пробелов          
     (равному размеру табуляции,  выбор которой выполняется с  помощью          
     Options/Environment/Tab Size).                                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 381,382 -
                                                                                
               Автоматическое смещение, смещение влево                          
                     и оптимальное заполнение                                   
     -----------------------------------------------------------------          
                                                                                
          Автоматическое смещение является характерной чертой редакти-          
     рования и,  следуя жесткому возврату,  устанавливает  курсор  под          
     первым значащим символом в предыдущей заполненной строке.                  
                                                                                
          При первоначальном запуске TCINST (программа настройки Турбо          
     Си) режим автоматического смещения вправо включается автоматичес-          
     ки  по умолчанию,  потому что TCINST Options/Environment /Options          
     определяет положение флага Editor/Autoindent в позиции ON  (Вклю-          
     чено).                                                                     
                                                                                
          В последующем,  в окне редактирования вы можете включить или          
     выключить этот режим,  нажав Ctrl-O I либо Ctrl-Q I (сначала наж-          
     мите Ctrl и,  удерживая ее в этом положении,  нажмите O либо Q, а          
     затем I).                                                                  
                                                                                
          Смещение влево также является особенностью  редактирования и          
     позволяет  смещать  курсор на один и более пробелов влево на одну          
     линию с прежнем уровнем смещения.                                          
                                                                                
                                                                                
          a = 3;                                                                
          i - 1;                                                                
          while (i <= 25)                                                       
              {                                                                 
             product = a * i;                                                   
             printf("%d. %d", i product);                                       
             ++i;                                                               
             }                                                                  
                                                                                
             <--- Автоматическое  смещение возвращает вас в этот стол-          
                  бец.                                                          
          <------ Нажав  клавишу забоя (Backspace),  вы возвратитесь в          
                  этот столбец.                                                 
                                                                                
                    Рисунок 5.24. Работа режима смещения влево.                 
                                                                                
          Для использования режима смещения влево установите курсор на          
     первый значащий символ строки либо на пустую строку. Нажмите кла-          
     вишу Backspace (возврата). Курсор переместится на прежний уровень          
     смещения.  В этом случае кавиша Backspace может перемещать курсор          
     более, чем на один пробел.                                                 

                         - 383,384 -
                                                                                
                                                                                
          Режим оптимального заполнения не действует до тех  пор, пока          
     не будет включен режим табуляции. С помощью этих двух режимов на-          
     чало каждой строки со смещением вправо либо влево оптимально  за-          
     полняется  символами табуляции и пробелами.  Это позволяет писать          
     строки с минимальным количеством символов. Включение и выключение          
     режима оптимального заполнения выполняется с помощью Ctrl-O F.             
                                                                                
          Примеры:                                                              
                                                                                
          1. Options/Environment/Tab Size установлен на 8 (позиции та-          
     буляции в стобцах 1, 9, 17, 25...); режимы смещения вправо, табу-          
     ляции и вставки включены;  курсор находится в конце строки, начи-          
     нающейся в столбце 27.                                                     
                                                                                
        а) Нажмите ввод для вставки новой строки,  редактор устанавли-          
           вает курсор в столбце 27 на новой строке.                            
                                                                                
        б) Не перемещая курсор, наберите символ на новой строке.                
                                                                                
        в) Редактор заполнит начало новой строки тремя символами табу-          
           ляции (до символа 25) и двумя пробелами  (до  столбца  27).          
                                                                                
           Таким образом, общее количество вставленных символов запол-          
           нения составило 5.                                                   
                                                                                
          2. Если при тех же условиях Options/Environment/Tab Size ус-          
     тановлен на 5 (позиции табуляции в столбцах 1,  6,  11,  16,  21,          
     26...),  то редактор добавит 5 символов табуляции (до столбца 26)          
     и один пробел.                                                             
                                                                                
          3. Или,  если Tab Size установлен на 6 (позиции табуляции на          
     1, 7, 13, 19, 25...) и вы перемещаете курсор в столбец 18 прежде,          
     чем набрать первый символ,  редактор дополнит два символа табуля-          
     ции (до 13-го столбца) и пять пробелов (до столбца 18).                    
                                                                                
                                                                                
                                                                                
               Определение парности (Match Pair)                                
     -----------------------------------------------------------------          
                                                                                
          Эта операция выполняется во время отладки исходного файла, в          
     котором множество функций,  выражений,  комментариев и ряд других          
     конструкций,  для которых используются парные разделители.  Дейс-          
     твительно, в вашем файле встречаются:                                      

                         - 385,386 -
                                                                                
                                                                                
          - фигурные скобки {};                                                 
          - угловые скобки <>;                                                  
          - круглые скобки ();                                                  
          - квадратные скобки [];                                               
          - маркеры комментариев /**/;                                          
          - двойные кавычки "";                                                 
          - одинарные кавычки ''.                                               
                                                                                
          Поиск сравнения отдельных парных конструкций выполняется до-          
     вольно хитроумно.  Предположим, что вы имеете сложное выражение с          
     вложенными подвыражениями. Вы хотите узнать, имеет ли это выраже-          
     ние несбалансированные скобки. Или, скажем, вы находитесь в нача-          
     ле функции,  которая проходит через несколько экранов, а вам пот-          
     ребовалось перейти сразу в конец этой функции. Решение этих задач          
     с помощью команд сравнения парности Турбо Си в  ваших  руках.  Вы          
     должны выполнить следующие операции:                                       
                                                                                
          1. Поместите курсор на разделитель, которым вы интересуетесь          
     (например, открытая скобка какой-то функции, которая проходит че-          
     рез ряд экранов).                                                          
                                                                                
                                                                                
          2. Для  поиска  парного  разделителя к выбранному достаточно          
     нажать Ctrl-Q Ctrl-[. (В данном примере закрывающая скобка должна          
     быть в конце функции).                                                     
                                                                                
          3. Редактор немедленно переместит курсор на разделитель, ко-          
     торый соответствует выбранному вами.  Если курсор переместится на          
     разграничитель,  который вы имели ввиду,  значит этот кусок вашей          
     программы не содержит непарных разделителей этого типа. Если кур-          
     сор переместится  на  неправильный разделитель,  то у вас ошибка.          
     Теперь все, что от вас требуется, это найти ее.                            
                                                                                
                                                                                
                                                                                
               Некоторая информация об определении парности                     
     -----------------------------------------------------------------          
                                                                                
          Мы уже  рассказали  вам основы команд "Match Pair" Турбо Си.          
     Теперь хотим дать информацию,  что вы сможете и не сможете делать          
     с  помощью этих команд.  Мы хотим также обратить ваше внимание на          
     некоторые тонкости. Это касается следующих вопросов:                       
                                                                                
          1. Есть две редактирующие команды Match Pair:  одна для  вы-          

                         - 387,388 -
                                                                                
             полнения сравнения парности вперед (Ctrl-Q Ctrl-[),  дру-          
             гая для сравнения парности назад (Ctrl-Q Ctrl-]).                  
                                                                                
          2. Способ,  с помощью которого редактор ищет  разграничители          
             комментария (/**/), мало чем отличается от способа поиска          
             других типов разделителей.                                         
                                                                                
          3. Если парный разделитель к тому,  который вы  выбрали,  не          
             найден, редактор не переместит курсор.                             
                                                                                
                                                                                
               Дирекционное и недирекционное сравнение                          
     -----------------------------------------------------------------          
                                                                                
          Необходимо использовать  две  команды  Match  Pair в связи с          
     тем,  что некоторые разграничители дирекционные (указывающие нап-          
     равление поиска), другие - нет.                                            
                                                                                
          Например, предположим,  вы задаете редактору поиск, указывая          
     на открывающуюся фигурную ({) или квадратную ([) скобку. Редактор          
     знает, что закрывающаяся скобка может быть только впереди,  и вы-          
     бирает поиск в этом направлении.  Открывающиеся фигурные и  квад-          
                                                                                
     ратные  скобки  являются дирекционными.  Редактор знает,  в каком          
     направлении вести поиск, поэтому нет различия в том, какую коман-          
     ду  задавать.  Вы можете задать любую команду,  при этом редактор          
     будет вести поиск в правильном направлении.                                
                                                                                
          Аналогично, если вы зададите закрывающуюся фигурную  (}) или          
     квадратную (]) скобку,  то редактор, зная в каком направлении на-          
     ходится открывающая скобка,  ведет поиск назад.  В  этом  случае,          
     также нет различия, какую задавать команду. Редактор всегда будет          
     вести поиск в правильном направлении.                                      
                                                                                
          Однако, если вы зададите редактору  поиск  двойных  (")  или          
     одинарных (') кавычек,  то он не будет знать, в каком направлении          
     искать пару.  Вы должны задать направление  поиска  путем  подачи          
     правильной команды Match Pair. Если вы задаете команду CtrlQ Ctrl          
     -[, то редактор будет вести поиск вперед по программе, а если ко-          
     манду Ctrl-Q Ctrl-], то назад.                                             
                                                                                
          В следующей таблице приведены парные разграничители. Опреде-          
     лены разграничители, являющиеся дирекционными и вложенными (опре-          
     деление  вложенных  разграничителей будет дано сразу после табли-          
     цы).                                                                       

                         - 389,390 -
                                                                                
                                                                                
     -----------------------------------------------------------------          
     Парные разграничители     Определяют направ-      Являются                 
                               ление поиска            вложенными               
     -----------------------------------------------------------------          
                                                                                
              { }                   Да                    Да                    
                                                                                
              ( )                   Да                    Да                    
                                                                                
              [ ]                   Да                    Да                    
                                                                                
              < >                   Да                    Да                    
                                                                                
             /* */                  Да                  Да и нет                
                                                                                
              " "                   Нет                   Нет                   
                                                                                
              ' '                   Нет                   Нет                   
     -----------------------------------------------------------------          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Вложенные разграничители                                         
     -----------------------------------------------------------------          
                                                                                
          Что означает  термин "вложенные"?  Проще говоря,  при поиске          
     дирекционного разделителя редактор постоянно  ведет  счет,  через          
     сколько открывающихся и закрывающихся парных разделителей он про-          
     шел во время поиска.                                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 391,392 -
                                                                                
                                                                                
          Это может быть проиллюстрировано на некоторых примерах.               
                                                                                
        сравненная пара          сравненная пара   сравненная пара              
                   |                       |          |                         
                  ---                   -------    -------                      
                  | |                   |     |    |     |                      
         arrl[arr2[x]]                ( (x > 0) && (y < 0) )                    
             |       |                |                    |                    
             ---------                ----------------------                    
                 |                               |                              
           сравненная пара                 сравненная пара                      
                                                                                
                    Рисунок 5.25. Поиск и сравнение квадратных                  
                                  и круглых скобок.                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Ведение поиска разграничителей комментариев                      
     -----------------------------------------------------------------          
                                                                                
          В связи с тем,  что разграничитель комментариев  состоит  из          
     двух знаков / (слэша, наклонной черты вправо) и * (звездочки), вы          
     должны быть внимательны при задавании этого сложного разделителя.          
     Еси  вы не выделите подсветкой оба знака,  то редактор распознает          
     только первый знак (слэш (/) в случае,  если вы задаете /*,  либо          
     звездочку (*),  если вы задаете */).  Если вы поместите курсор на          
     втором знаке в этих разделителях, то редактор не будет знать нап-          
     равление поиска, а значит и поиска не будет.                               
                                                                                
          Кроме того,  как видно из вышеприведенной таблицы, в некото-          
     рых случаях разделители комментариев бывают вложенными, а в неко-          
     торых  случаях  нет.  Это не является капризом или невозможностью          
     решения. Это используется для проверки в различных случаях. Прог-          
     раммы Си,  совместимые с ANSI,  не могут содержать вложенные ком-          
     ментарии,  а Турбо Си с помощью O/C/S/Nested Comments может.  Эта          
     особенность  влияет  на возможность определения наличия вложенных          
     разделителей комментариев при их поиске и определении парности.            
                                                                                
          1. Если Options/Compiler/Source/Nested Comments  в положении          

                         - 393,394 -
                                                                                
                                                                                
             ON (Включено),  то  редактор  обращается  с разделителями          
             комментариев как с вложенными и выполняет учет количества          
             открывающихся и закрывающихся парных разделителей.                 
                                                                                
          2. Если  Options/Compiler/Source/Nested Comments в положении          
             OFF (Выключено), то редактор не обращается с разделителя-          
             ми комментариев как с вложенными. Когда задается раздели-          
             тель /*,  то редактор ищет и выдает первый же разделитель          
             */ (или наоборот).                                                 
                                                                                
          Примечание: Если  несравниваемые  разделители  того же типа,          
     что заданы,  встречаются в комментариях,  кавычках, сегментах ус-          
     ловной компиляции  между  сравниваемыми парами,  то это влмяет на          
     поиск.                                                                     
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
          Некоторые различия при поиске вложенных разделителей коммен-          
     тариев приведены ниже.                                                     
                                                                                
                                                                                
     /* /* /* /* Вложенные комментарии */ */ */ */                              
     |                                           |                              
     ---Заданный уровень         Найденный уровень                              
        сравнения                сравнения                                      
                                                                                
              Рисунок 5.26. Режим O/C/S/Nested Comments включен.                
                            Поиск вперед с помощью ^Q^[                         
                                                                                
                                                                                
          Примечание: Обратный  поиск  при  включенном  режиме  O/C/S/          
     Nested Comments от найденного разделителя */ приведет к заданному          
     разделителю /*.                                                            
                                                                                
                                                                                
                                                                                
                                                                                

                         - 395,396 -
                                                                                
                                                                                
                                                                                
     /* /* /* /* Вложенные комментарии */ */ */ */                              
     |                                           |                              
     ---Заданный уровень         Найденный уровень                              
        сравнения                сравнения                                      
                                                                                
              Рисунок 5.27. Режим O/C/S/Nested Comments выключен.               
                            Поиск вперед с помощью ^Q^[                         
                                                                                
                                                                                
     /* /* /* /* Вложенные комментарии */ */ */ */                              
     |                                           |                              
     ---Заданный уровень         Найденный уровень                              
        сравнения                сравнения                                      
                                                                                
              Рисунок 5.28. Режим O/C/S/Nested Comments выключен.               
                            Поиск назад с помощью ^Q^]                          
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Назначение редактирующих ключей                                  
     -----------------------------------------------------------------          
                                                                                
          Интерактивный редактор Турбо Си обеспечивает множество функ-          
     ций  редактирования,  которые  определены конкретными клавишами и          
     сочетаниями клавиш.  Подробно это описано в Приложении A Справоч-          
     ного руководства по Турбо Си.                                              
                                                                                
          TCINST является  необязательной  пользовательской программой          
     Турбо Си.  Одно из ее меню позволяет вам определить  клавиши  для          
     функций редактирования Турбо Си.  Это известно как переназначение          
     клавиш.                                                                    
                                                                                
          Примечание: Указанная операция подробно описана в Приложении          
     F Справочного руководства по Турбо Си,  поэтому здесь дано только          
     общее описание.                                                            
                                                                                
          Для изменения  команд редактирования Турбо Си необходимо вы-          
     полнить следующие основные процедуры:                                      
                                                                                
          1. Загрузить TCINST.EXE (на приглашение ДОС  наберите tcinst          
     и нажмите Ввод). Из основного меню пользователя выберите меню ко-          

                         - 397,398 -
                                                                                
     манд редактора (Editor commands). Перед вами появится экран наст-          
     ройки редактора с тремя колонками текста.                                  
                                                                                
     - В первой (левой)  колонке описываются все доступные функции ин-          
       терактивного редактора TC .                                              
                                                                                
     - Во второй колонке описываются первичные управляющие клавиши: то          
       есть клавиши и их комбинации,  которые вы должны нажать для вы-          
       полнения определенных функций редактора.                                 
                                                                                
     - В  третьей  колонке описаны вторичные управляющие клавиши:  это          
       альтернативные, т.е. необязательные нажатия клавиш, нажав кото-          
       рые, вы вызываете определенные функции редактора.                        
                                                                                
          2. Нижняя  строка  текста на экране Install Еditor описывает          
     клавиши,  которыми вы можете изменять содержимое из первой или из          
     второй колонки. При нажатии Ввод, вы входите в режим модификации,          
     затем, используя  клавиши со стелками влево и вправо,  можете пе-          
     редвинуть яркую полосу к первичной или вторичной колонке.                  
                                                                                
          3. Используя клавиши со стрелками вверх  и  вниз,  высветите          
     команду редактирования, "горячую" клавишу которой вы хотите пере-          
                                                                                
     назначить.                                                                 
                                                                                
          4. Для  выбора  высвеченной  команды  редактирования нажмите          
     Ввод; заданная для данной команды последовательность нажатия кла-          
     виш высветится в всплывающем окне.                                         
                                                                                
          5. Для стирания отдельных нажатий клавиш справа налево отно-          
     сительно всплывшего окна используйте клавишу Забой, а для очистки          
     всей последовательности нажатий - F3.                                      
                                                                                
          6. Комбинации  нажатий  клавиш предоставляются в трех видах:          
     WordStar-like (в стиле WordStar),  Ignore case (с  игнорированием          
     регистра) и Verbatim (в буквальном).  Нажатие F4 циклически пока-          
     жет их все до тех пор,  пока требуемая комбинация не станет выде-          
     лена в нижней строке экрана.  Для получения большей информации об          
     этих трех  режимах  смотрите Приложение F Справочного руководства          
     Турбо Си".                                                                 
                                                                                
          7. Введите  новое  описание  последовательности  нажатий для          
     данной функции редактирования (максимально до 6 нажатий). При не-          
     обходимости стереть последний введенный символ используйте Забой.          
     Если же вы захотите отказаться от назначения  новой  клавиши  для          

                         - 399,400 -
                                                                                
                                                                                
     данной функции, то для восстановления первоначального назначения,          
     нажмите F2 или Esc - для восстановления и выхода из режима редак-          
     тирования последовательности нажатия клавиш.                               
                                                                                
          8. Как  только вы будете удовлетворены новым (или восстанов-          
     ленным) назначением клавиш, нажмите Ввод для его запоминания.              
                                                                                
          9. Когда вы закончите назначение клавиш, для выхода из экра-          
     на настройки редактора нажмите Esc, и вы вернетесь в главное меню          
     TCINST.                                                                    
                                                                                
          Замечание: если вы переопределите стандартные "горячие" клю-          
     чи Турбо Си, то при нахождении в редакторе вы не сможете ими вос-          
     пользоваться.                                                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                   ГЛАВА 6                                      
                                   -------                                      
                                                                                
                        ПРОГРАММИРОВАНИЕ НА ТУРБО СИ.                           
     -----------------------------------------------------------------          
                                                                                
          Программировали ли вы на Си раньше? Вы могли слышать различ-          
     ные истории о том,  как трудно изучать язык Си.  Ерунда. Действи-          
     тельно, некоторые программисты ухитряются писать ужасные програм-          
     мы,  которые  трудно  читать  и  отлаживать,   но   нет   никакой          
     необходимости следовать их примеру. Основные элементы языка прог-          
     раммирования Си легки в понимании и использовании.                         
                                                                                
                                                                                
                                                                                
               В этой главе...                                                  
     -----------------------------------------------------------------          
                                                                                
          В этой главе мы обучим вас основным элементам языка Си и по-          
     кажем, как использовать их в ваших программах. В следующей главе,          
     "О некоторых особенностях программирования на Си",  дается больше          
     информации о Си,  в то время как в  главе  12  "Углубленный  курс          

                         - 401,402 -
                                                                                
     программирования  на Турбо Си" рассказывается все о моделях памя-          
     ти,  прерываниях, программировании на ассемблере и других трудно-          
     доступных вершинах.                                                        
                                                                                
          Конечно, мы  не  сможем научить вас всему в программировании          
     на Си в одной или двух главах;  написаны  целые  книги  об  этом.          
     (смотри библиографию в конце данного руководства).                         
                                                                                
          Перед тем  как будете читать эту главу,  вам нужно прочитать          
     главу 5 "Интегрированное окружение Турбо Си для разработки  прог-          
     рамм",  и  научиться использовать меню и текстовой редактор Турбо          
     Си.  Необходимо также установить Турбо Си (сделать рабочие  копии          
     ваших дисков Турбо Си или скопировать файлы на ваш жесткий диск),          
     как это описано в главе 1.                                                 
                                                                                
          Когда вы сделаете это,  сядьте, включите вашу ПЭВМ (если она          
     еще не включена) и приговьтесь к изучению программирования в Тур-          
     бо Си.                                                                     
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Семь основных элементов программирования.                        
     -----------------------------------------------------------------          
                                                                                
          Целью большинства программ является решение задач. Программа          
     решает задачи, манипулируя информацией или данными. Вы должны на-          
     учиться:                                                                   
                                                                                
          * вводить данные в программу                                          
                                                                                
          * выделять место для хранения данных                                  
                                                                                
          * задавать команды по обработке информации                            
                                                                                
          * выводить  информацию  обратно  из  программы  пользователю          
            (обычно, вам)                                                       
                                                                                
          Вы можете организовать ваши команды так, что:                         
                                                                                
          * некоторые из них будут  выполняться  только  тогда,  когда          
     специальное условие (или набор условий) истинно                            
                                                                                
          * другие будут повторяться несколько раз                              

                         - 403,404 -
                                                                                
                                                                                
          * третьи разбиты на группы, которые могут выполняться в раз-          
            личных местах вашей программы.                                      
                                                                                
          Вот мы и описали семь основных  элементов  программирования:          
     ввод,  тип данных,  операции, вывод, условное выполнение, циклы и          
     подпрограммы. Этот список не полон, но он все же описывает те об-          
     щие элементы, которые обычно включают программы.                           
                                                                                
          Большинство языков программирования содержат все эти элемен-          
     ты;  многие из них, включая Си, имеют также и дополнительные воз-          
     можности. Однако, если вы хотите изучить новый язык быстро, то вы          
     можете определить как этот язык реализует эти семь  элементов,  а          
     затем  двигаться дальше.  Приведем обзорное описание каждого эле-          
     мента:                                                                     
                                                                                
         - вывод означает запись информации на экран,  на диск  или  в          
           порт ввода-вывода;                                                   
                                                                                
         - типы данных - это константы,  переменные и структуры, кото-          
           рые содержат числа (целые и вещественные), текст (символы и          
           строки) или адреса (переменных и структур);                          
                                                                                
                                                                                
         - операции  присваивают  одно  значение другому,  комбинируют          
           значения (складывают,  делят и т.д.), и сравнивают значения          
           (равно, не равно и т.д.);                                            
                                                                                
          - ввод  означает чтение данных с клавиатуры,  с диска или из          
            порта ввода-вывода;                                                 
                                                                                
          - условное выполнение относится к выполнению  набора команд,          
            если  заданное  условие  истинно (и пропуску их,  если оно          
            ложно);                                                             
                                                                                
          - циклы выполняют набор команд некоторое фиксированное коли-          
            чество раз или пока истинно некоторое условие;                      
                                                                                
          - подпрограммы являются отдельно поименованными наборами ко-          
            манд, которые могут быть выполнены в любом месте программы          
            с помощью ссылки по имени;                                          
                                                                                
          Теперь мы рассмотрим,  как использовать эти элементы в Турбо          
     Си.                                                                        
                                                                                

                         - 405,406 -
                                                                                
               Вывод                                                            
     -----------------------------------------------------------------          
                                                                                
          Может показаться странным, что мы начинаем разговор именно с          
     вывода, однако программ которые ничего не выводят, почти нет. Под          
     выводом  обычно понимают форму информации,  записываемой на экран          
     (слова и картинки),  на запоминающее устройство (гибкий или жест-          
     кий  диск)  или в порт ввода-вывода (последовательный порт,  порт          
     принтера).                                                                 
                                                                                
                                                                                
          Функция printf                                                        
          --------------                                                        
                                                                                
          Мы уже  использовали наиболее употребительную функцию вывода          
     в Си - подпрограмму printf.  Ее целью является запись  информации          
     на экран. Ее формат как прост, так и гибок:                                
                                                                                
          printf(<строка формата>, <объект>, <объект>, ...);                    
                                                                                
                                                                                
          Строка формата                                                        
                                                                                
          --------------                                                        
                                                                                
          Строка формата - это строка, которая начинается и заканчива-          
     ется двойными кавычками ("как эта");  цель  printf - запись  этой          
     строки на экран.  Перед выводом printf заменяет все дополнительно          
     перечисленные объекты в строке в соответствии  со  спецификациями          
     формата,  указанными в самой строке.  Например, в последней прог-          
     рамме был следующий оператор printf:                                       
                                                                                
          printf("Сумма = %d \n",sum);                                          
                                                                                
          %d в строке формата - это спецификация формата. Все специфи-          
     кации формата начинаются с символа процента (%) и (обычно) сопро-          
     вождаются одной буквой,  обозначающей тип данных и способ их пре-          
     образования.                                                               
                                                                                
          Вы должны иметь для каждого объекта только одну соответству-          
     ющую ему спецификацию формата.  Если объект имеет тип данных,  не          
     соответствующий спецификации формата,  то Турбо Си попытается вы-          
     полнить нужное преобразование.                                             
                                                                                
          Сами объекты могут быть переменными, константами, выражения-          

                         - 407,408 -
                                                                                
     ми,  вызовами функций.  Короче говоря, они могут быть чем угодно,          
     что дает соответствующее значение спецификации формата.                    
                                                                                
          %d, используемое в спецификации, говорит о том, что ожидает-          
     ся  некоторое целое число.  Вот несколько других общеиспользуемых          
     спецификаций формата:                                                      
                                                                                
          - %u  целое число без знака                                           
          - %ld длинное целое число                                             
          - %p  значение указателя                                              
          - %f  число с плавающей точкой                                        
          - %e  число с плавающей точкой в экспоненциальной форме               
          - %c  cимвол                                                          
          - %s  строка                                                          
          - %x  или %X целое в шестнадцатиричном формате.                       
                                                                                
          Вы можете задать ширину поля,  помещая ее между %  и буквой,          
     например,  десятичное поле шириной 4 задается,  как %4d. Значение          
     будет напечатано сдвинутым вправо (впереди пробелы),  так что об-          
     щая ширина поля равна 4.                                                   
                                                                                
          Если нужно напечатать знак %, то вставьте %%. \n в строке не          
                                                                                
     является спецификацией формата,  а употребляется (по историческим          
     мотивам) как управляющая (escape) последовательность, и представ-          
     ляет специальный символ,  вставляемый в строку.  В этом случае \n          
     вставляет символ в начале  новой  строки,  поэтому  после  вывода          
     строки курсор передвинется к началу новой строки.                          
                                                                                
          Полный список  всех  управляющих  последовательностей  можно          
     найти в главе 11, из них наиболее часто используются:                      
                                                                                
          - \f  (перевод формата или очистка экрана)                            
          - \t  (табуляция)                                                     
          - \b  (забой <-)                                                      
          - \xhhh (вставка символа c кодом  ASCII hhh, где hhh                  
            содержит от 1 до 3 16-ричных цифр)                                  
                                                                                
          Если вам нужно напечатать обратную косую черту,  то вставьте          
     \\.  При желании получить больше деталей о работе printf, обрати-          
     тесь к описанию printf в справочном руководстве Турбо Си.                  
                                                                                
                                                                                
          Другие функции вывода: puts и putchar                                 
          -------------------------------------                                 

                         - 409,410 -
                                                                                
                                                                                
          Имеются две другие функции вывода, которые могут вас заинте-          
     ресовать:  puts и putchar. Функция puts выводит строку на экран и          
     завершает вывод символом новой строки.                                     
                                                                                
          Например, можно переписать HELLO.C следующим образом:                 
                                                                                
          #include <stdio.h>                                                    
          main ()                                                               
          {                                                                     
            puts("Hello, world");                                               
          }                                                                     
                                                                                
          Заметим, что в конце строки опущен \n; это не нужно, так как          
     puts сама добавляет этот символ.                                           
                                                                                
          Наоборот, функция putchar записывает единственный символ  на          
     экран и не добавляет \n. Оператор putchar(ch) эквивалентен printf          
     ("%c",ch).                                                                 
                                                                                
          Зачем же  нужно  использовать  puts  и/или  putchar   вместо          
     printf? Одним из доводов является тот, что программа, реализующая          
                                                                                
                                                                                
     printf, гораздо больше; если вы не нуждаетесь в ней (для числово-          
     го вывода или специального форматирования),  то, используя puts и          
     putchar, можно сделать свою программу меньше и быстрее. Например,          
     файл .EXE,  создаваемый компиляцией версии HELLO.C,  использующий          
     puts,  значительно меньше, чем файл .EXE для версии, использующей          
     printf.                                                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 411,412 -
                                                                                
               Типы данных.                                                     
     -----------------------------------------------------------------          
                                                                                
          При написании программы,  вы работаете с некоторым видом ин-          
     формации, большинство которой попадает в один из 4-х основных ти-          
     пов: целые числа, числа с плавающей точкой, текст и указатели.             
                                                                                
          Целые - это числа, которые используются для счета ( 1, 2, 5,          
     -21 и 752, например).                                                      
                                                                                
          Числа с  плавающей  точкой могут содержать дробные разряды и          
     экспоненту (5.4567*10^65).  Иногда  их  называют  действительными          
     (вещественными) числами (real).                                            
                                                                                
          Текст состоит из символов (а,  Z, !, 3) и строк ("Это просто          
     проверка").                                                                
                                                                                
          Указатели не хранят информацию;  вместо этого каждый из  них          
     содержит адрес памяти ЭВМ, в которой хранится информация.                  
                                                                                
                                                                                
          Числа с плавающей точкой.                                             
                                                                                
          ------------------------                                              
                                                                                
          Си поддерживает  4  основных типа данных в различных формах.          
     Вы уже использовали 2 из них:  целые (int) и символы (char). Сей-          
     час  будем  модифицировать  последнюю программу для использования          
     3-го типа:  чисел с плавающей точкой (float).  Войдите в редактор          
     Турбо Си и преобразуйте программу к следующему виду:                       
                                                                                
          #include <stdio.h>                                                    
          main()                                                                
          {                                                                     
      int a,b;                                                                  
      float ratio;                                                              
                                                                                
      printf("Введите два числа:  ");                                           
      scanf("%d %d,&a,&b);                                                      
      ratio = a / b;                                                            
      printf("Отношение = %f \n", ratio);                                       
          }                                                                     
                                                                                
          Сохраните ее под именем RATIO.C, выйдя в главное меню и выб-          
     рав команду File/Write. Затем нажмите R для компиляции и выполне-          

                         - 413,414 -
                                                                                
     ния программы. Введя два значения (такие, как 10 и 3), вы получи-          
     те результат (3.000000).                                                   
                                                                                
          Вероятно, вы ожидали ответа 3.333333;  почему же ответ  ока-          
     зался только 3? Потому, что a и b имеют тип int, отсюда и резуль-          
     тат тоже типа int.  Он был преобразован к типу float при присваи-          
     вании  его  ratio,  но преобразование имело место после,  а не до          
     деления.                                                                   
                                                                                
          Вернитесь в редактор и измените тип a и b на float; измените          
     также строку формата "%d %d" в scanf на "%f %f".  Сохраните прог-          
     рамму (нажмите F2),  затем компилируйте и  выполняйте.  Результат          
     теперь 3.333333, как и ожидалось.                                          
                                                                                
          Имеется также две версии типа float,  известная как double и          
     long double.  Как вы могли догадаться,  переменные типа double  в          
     два  раза  больше  переменных типа float,  а переменные типа long          
     double еще больше.  Это означает, что они могут иметь больше зна-          
     чащих  цифр  и больший диапазон значений экспоненты.  Стандартные          
     размеры и диапазоны значений для этих типов в Турбо Си  описаны в          
     Главе 11.                                                                  
                                                                                
                                                                                
                                                                                
          Три типа целых                                                        
          --------------                                                        
                                                                                
          В дополнение к типу int,  Си поддерживает версии short int и          
     long int, обычно сокращаемые до short и long. Фактические размеры          
     short,  int и long зависят от реализации; все, что гарантирует Си          
     - это то,  что переменная типа short не будет больше (то есть  не          
     займет больше байтов),  чем переменная типа long.  В Турбо Си эти          
     типы занимают 16 битов (short),  16 битов (int) и 32 бита (long).          
                                                                                
                                                                                
          Беззнаковые                                                           
          -----------                                                           
                                                                                
          Си позволяет вам объявлять некоторые типы (сhar, short, int,          
     long) беззнаковыми (unsigned).  Это означает,  что вместо отрица-          
     тельных значений эти типы имеют  только  неотрицательные  (больше          
     или  равные  нулю).  Переменные такого типа могут поэтому хранить          
     большие значения,  чем знаковые типы.  Например, в Турбо Си пере-          
     менная типа int может содержать значения от -32768 до 32767;  пе-          
     ременная же типа insigned int может содержать значения  от  0  до          

                         - 415,416 -
                                                                                
     65535. Обе занимают одно и тоже место в памяти (16 битов в данном          
     случае);  но используют ее по-разному. Опять же, см. главу 11 для          
     выяснения деталей.                                                         
                                                                                
                                                                                
          Определение строки                                                    
          ------------------                                                    
                                                                                
          Си не поддерживает отдельный строковый тип данных, но он все          
     же предусматривает два слегка отличающихся подхода  к определению          
     строк.  Один состоит в использовании символьного массива,  другой          
     заключается в использовании указателя на символ.                           
                                                                                
                                                                                
          Использование символьного массива                                     
          - - - - - - - - - - - - - - - - -                                     
                                                                                
          Выбирете команду Load из меню файла  и  загрузите  программу          
     HELLO.C снова в редактор.  Теперь приведите ее к следующему виду:          
                                                                                
          #include <stdio.h>                                                    
          #include <string.h>                                                   
                                                                                
          main ()                                                               
          {                                                                     
        char msg[30];                                                           
                                                                                
        strcpy(msg, "Hello, world");                                            
        puts(msg);                                                              
          }                                                                     
                                                                                
          [30], после  msg,  предписывает  компилятору выделить память          
     для 29 символов,  то есть для массива из 29 переменных типа  char          
     (30-е  знакоместо  будет  заполнено нулевым символом - \0 - часто          
     называемым нулевым завершителем или ограничителем  ).  Переменная          
     msg не содержит символьное значение; она хранит адрес (некоторого          
     места в памяти) первого из этих 29 переменных типа char.                   
                                                                                
          Когда компилятор обнаруживает оператор  strcpy(msg,  "Hello,          
     world"), он делает две вещи:                                               
                                                                                
          - Создает строку "Hello,  world", ограниченную (\0) символом          
            (с кодом ASCII 0),в некотором месте файла объектного кода.          
                                                                                
          - Вызывает подпрограмму strcpy,  которая копирует символы из          

                         - 417,418 -
                                                                                
            этой строки по одному в участок памяти,  указываемый пере-          
            менной msg.  Он делает это до тех пор пока не будет скопи-          
            рован нулевой символ в конце строки "Hello, world".                 
                                                                                
          Когда вы вызываете функцию puts(msg),  то ей передается зна-          
     чение msg - адрес первой буквы,  на которую он  указывает.  Затем          
     puts  проверяет,  не  является ли символ по этому адресу нулевым.          
     Если да,  то puts заканчивает работу;  иначе puts  печатает  этот          
     символ, добавляет единицу (1) к адресу и делает проверку на нуле-          
     вой символ снова.                                                          
                                                                                
          Из-за этой зависимости от  нулевого  символа  известно,  что          
     строки в Си называются "завершающиеся нулем",  т.е. они представ-          
     ляют из себя последовательности символов, заканчивающиеся нулевым          
     символом.  Этот подход позволяет снять ограничения с длины строк;          
     строка может быть такой длины, какой позволяет память для ее хра-          
     нения.                                                                     
                                                                                
                                                                                
          Использование указателя на символ                                     
          ---------------------------------                                     
                                                                                
                                                                                
          Второй метод,  который  можно  использовать  для определения          
     строк,  - это указатель на символы. Отредактируйте вашу программу          
     к следующему виду:                                                         
                                                                                
                                                                                
          #include <stdio.h>                                                    
          #include <string.h>                                                   
                                                                                
          main()                                                                
          {                                                                     
       char *msg;                                                               
       msg = "Hello, world";                                                    
       puts(msg);                                                               
          }                                                                     
                                                                                
          Звездочка (*) впереди msg указывает компилятору, что msg яв-          
     ляется указателем на символ;  другими словами,  msg может хранить          
     адрес некоторого символа. Однако, при этом компилятор не выделяет          
     никакого пространства для размещения символов и не инициализирует          
     msg каким-либо конкретным значением.                                       
                                                                                
          Когда компилятор находит оператор msg = "Hello,world  ",  он          

                         - 419,420 -
                                                                                
     делает две вещи:                                                           
                                                                                
          - Как и раньше,  он создает строку "Hello, world\n", ограни-          
            ченную нулевым символом,  где-то внутри  файла  объектного          
            кода.                                                               
                                                                                
          - Присваивает начальный адрес этой строки - адрес символа H           
            переменной msg.                                                     
                                                                                
          Команда puts(msg) работает так же,  как  и  раньше,  печатая          
     символы до тех пор, пока она не встретит нулевой символ.                   
                                                                                
          Имеется тесная зависимость между методами массива и указате-          
     ля при определении строк, которые мы обсудим в следующей главе.            
                                                                                
                                                                                
          Идентификаторы                                                        
          --------------                                                        
                                                                                
          До сих пор мы давали имена переменным,  не заботясь  о  том,          
     какие  на  них накладываются ограничения.  Давайте теперь обсудим          
     эти ограничения.                                                           
                                                                                
                                                                                
          Имена, которые вы даете константам, типам данных, переменным          
     и функциям называются идентификаторами.  Некоторые из идентифика-          
     торов, мы использовали ранее - это:                                        
                                                                                
          char, int, float       предопределенные типы данных                   
          main                   главная функция программы                      
          name,a,b,sum,msg,ratio переменные,  определенные пользовате-          
                                 лем                                            
          scanf, printf, puts    стандартные библиотечные функции               
                                                                                
          В Турбо Си имеется несколько правил об  идентификаторах; вот          
     краткая их сводка:                                                         
                                                                                
          - Все  идентификаторы  должны  начинаться с  буквы  (a...z,           
            A...Z) или с подчеркивания (_).                                     
                                                                                
          - Остальная  часть  идентификатора может  состоять из  букв,          
            подчеркиваний и/или цифр (0...9). Никакие другие  символы           
            не разрешены.                                                       
                                                                                
          - Идентификаторы являются чувствительными от типа букв. Это           

                         - 421,422 -
                                                                                
                                                                                
            означает, что строчные буквы (a...z) - это не тоже самое,           
            что  прописные буквы  (A...Z).  Например,  идентификаторы           
            indx, Indx, INDX различны и отличаются друг от друга.               
                                                                                
          - Значимыми являются первые 32 символа идентификатора.                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Операции                                                         
     -----------------------------------------------------------------          
                                                                                
          Итак, вы научились получать данные в программу (и в ваши пе-          
     ременные);  что же вы собираетесь делать с ними? Вероятно, как-то          
     с ними манипулировать, используя допустимые операции. Язык Си об-          
     ладает большим количеством таких операций.                                 
                                                                                
                                                                                
          Операция присваивания                                                 
          ---------------------                                                 
                                                                                
          Самой общей операцией является присваивание, например, ratio          
     = a/b или ch = getch(). В Си присваивание обозначается одним зна-          
     ком  равенства  (=);  при этом значение справа от знака равенства          
     присваивается переменной слева.                                            
                                                                                
          Можно применять также последовательные присваивания,  напри-          
     мер: sum = a = b. В таких случаях присваивание производится спра-          
     ва налево,  то есть b будет присвоено a,  которая в свою  очередь          
     будет присвоена sum, так что все три переменных получат одно и то          
     же значение (а именно, начальное значение b).                              

                         - 423,424 -
                                                                                
                                                                                
                                                                                
          Одноместные и двуместные операции                                     
          ---------------------------------                                     
                                                                                
          Си поддерживает обычный набор арифметических операций:                
                                                                                
          - умножение (*)                                                       
          - деление (/)                                                         
          - целочисленное деление (%)                                           
          - сложение (+)                                                        
          - вычитание (-)                                                       
                                                                                
          Турбо Си поддерживает одноместный минус (a +  (-b)), который          
     выполняет двоичное дополнение как в расширении ANSI. Кроме этого,          
     Турбо Си поддерживает одноместный плюс (a + (+b)).                         
                                                                                
                                                                                
                                                                                
          Операции приращения (++) и уменьшения (--)                            
          ------------------------------------------                            
                                                                                
                                                                                
          В Си  имеются некоторые специальные одноместные и двуместные          
     операции.  Наиболее известными являются одноместные операции при-          
     ращения  (++)  и уменьшения (--).  Они позволяют вам использовать          
     единственную операцию,  которая добавляет 1 или вычитает 1 из лю-          
     бого значения;  сложение и вычитание может быть выполнено в сере-          
     дине выражения,  причем вы можете даже решить, сделать это до или          
     после вычисления выражения.  Рассмотрим следующие строки програм-          
     мы:                                                                        
                                                                                
          sum = a + b++;                                                        
          sum = a + ++b;                                                        
                                                                                
          Первая означает:  "сложить a и b,  присвоить результат sum и          
     увеличить b на единицу".                                                   
                                                                                
          Вторая означает:  "увеличить b на единицу,  сложить a и b, и          
     присвоить результат sum".                                                  
                                                                                
          Это очень  мощные  операции,  расширяющие возможности языка,          
     однако перед их использованием нужно убедиться, что вы хорошо по-          
     нимаете их действие.  Измените SUM.C, как показано ниже, а затем,          
     перед ее запуском, попытайтесь определить, что она выведет:                

                         - 425,426 -
                                                                                
                                                                                
          #include <stdio.h>                                                    
          main()                                                                
          {                                                                     
       int a, b, sum;                                                           
       char *format;                                                            
                                                                                
       format = "a = %d    b = %d   sum = %d \n";                               
       a = b = 5;                                                               
       sum = a   + b; printf(format,a,b,sum);                                   
       sum = a++ + b; printf(format,a,b,sum);                                   
       sum = ++a + b; printf(format,a,b,sum);                                   
       sum = --a + b; printf(format,a,b,sum);                                   
       sum = a-- + b; printf(format,a,b,sum);                                   
       sum = a   + b; printf(format,a,b,sum);                                   
          }                                                                     
                                                                                
                                                                                
          Побитовые операции                                                    
          ------------------                                                    
                                                                                
          Для обработки на уровне битов Си имеет следующие операции:            
                                                                                
                                                                                
          - сдвиг влево (<<)                                                    
          - сдвиг вправо (>>)                                                   
          - И (&)                                                               
          - ИЛИ (|)                                                             
          - исключающее ИЛИ (^)                                                 
          - НЕ (~)                                                              
                                                                                
          Они позволяют вам производить операции очень низкого уровня.          
     Для того,  чтобы понять эффект этих операций, введите и выполните          
     следующую программу:                                                       
                                                                                
          #include <stdio.h>                                                    
          main()                                                                
          {                                                                     
       int a, b, c;                                                             
       char *format1, *format2;                                                 
                                                                                
       format1 = " %04X %s %04X = %04X\n";                                      
       format2 = " %c%04X = %04X\n";                                            
       a = 0x0FF0; b = 0xFF00;                                                  
       c = a<<4;   printf(format1, a, "<<", 4, c);                              

                         - 427,428 -
                                                                                
       c = a>>4;   printf(format1, a, ">>", 4, c);                              
       c = a & b;  printf(format1, a, "& ", b, c);                              
       c = a | b;  printf(format1, a, "| ", b, c);                              
       c = a ^ b;  printf(format1, a, "^ ", b, c);                              
       c = ~a;     printf(format2, `~`, a,  c);                                 
       c = -a;     printf(format2, `-`, a, c);                                  
          }                                                                     
                                                                                
          Опять же,  попробуйте предугадать то, что будет выводить эта          
     программа, не запуская ее. Заметим, что спецификаторы ширины поля          
     выравнивают  выводимые  значения;  спецификатор %04X указывает на          
     использование нулей в начале числа,  на ширину поля вывода четыре          
     цифры и на шестнадцатиричное представление (основание 16).                 
                                                                                
                                                                                
          Комбинированные операции                                              
          ------------------------                                              
                                                                                
          Си позволяет использовать некоторые сокращения при написании          
     выражений,  содержащих многочисленные  операции,  описанные  выше          
     (одноместные,  двуместные,  приращение,  уменьшение и побитовые).          
     Так, любое выражение вида                                                  
                                                                                
                                                                                
          <переменная> = <переменная> <операция> <выражение>;                   
                                                                                
     может быть заменено на                                                     
                                                                                
          <переменная> <операция> = <выражение>;                                
                                                                                
          Ниже приводятся некоторые примеры таких  выражений и способы          
     их сокращения:                                                             
                                                                                
          a = a + b;  сокращается до  a += b;                                   
          a = a - b;  сокращается до  a -= b;                                   
          a = a * b;  сокращается до  a *= b;                                   
          a = a / b;  сокращается до  a /= b;                                   
          a = a % b;  сокращается до  a %= b;                                   
          a = a << b; сокращается до  a <<= b;                                  
          a = a >> b; сокращается до  a >>= b;                                  
          a = a & b;  сокращается до  a &= b;                                   
          a = a | b;  сокращается до  a |= b;                                   
          a = a ^ b;  сокращается до  a ^= b;                                   
                                                                                
                                                                                

                         - 429,430 -
                                                                                
          Адресные операции                                                     
          -----------------                                                     
                                                                                
          Си поддерживает две специальные  адресные операции: операцию          
     определения адреса (&) и операцию  обращения по адресу(*).                 
                                                                                
          Операция & возвращает адрес данной переменной;  если sum яв-          
     ляется переменной типа int,  то &sum является адресом (расположе-          
     ния в памяти) этой переменной. С другой стороны, если msg являет-          
     ся указателем на тип char,  то *msg является символом, на который          
     указывает msg.  Введите следующую программу и посмотрите, что по-          
     лучится.                                                                   
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main()                                                                
          {                                                                     
      int sum;                                                                  
      char *msg;                                                                
                                                                                
      sum = 5 + 3;                                                              
      msg = "Hello, thore\n";                                                   
                                                                                
                                                                                
      printf(" sum = %d &sum = %p \n", sum, &sum);                              
      printf("*msg = %c  msg = %p \n", *msg, msg);                              
          }                                                                     
                                                                                
          В первой строке печатается два значения:  значение sum (8) и          
     адрес sum (назначаемый компилятором).  Во второй строке также пе-          
     чатается два значения:  символ,  на который указывает msg (H),  и          
     значение msg,  которое является адресом этого символа (также наз-          
     начен компилятором).                                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 431,432 -
                                                                                
               Ввод                                                             
     -----------------------------------------------------------------          
                                                                                
          В Си имеется несколько функций ввода;  одни производят  ввод          
     из файла или из входного потока, другие - с клавиатуры. Если тре-          
     буется детальная информация о функциях ввода Турбо Си, то читайте          
     о функциях ...scanf, read, а также Главу 8.                                
                                                                                
                                                                                
          Функция scanf                                                         
          -------------                                                         
                                                                                
          Для интерактивного режима ввода,  вероятно,  можно использо-          
     вать в большинстве случаев функцию scanf.  scanf это функция вво-          
     да, по смыслу эквивалентная printf; ее формат выглядит так:                
                                                                                
          scanf(<строка формата>,<адрес>,<адрес>,...)                           
                                                                                
          В scanf используются многие из тех же спецификаторов формата          
     %<буква>,  что и у функции printf: %d - для целых, %f - для чисел          
     с плавающей точкой, %s - для строк и т.д.                                  
                                                                                
                                                                                
          Однако scanf имеет одно очень важное отличие:  объекты, сле-          
     дующие за строкой формата, должны быть адресами, а не значениями.          
     В программе SUM.C содержится следующий вызов:                              
                                                                                
          scanf("%d %d", &a, &b);                                               
                                                                                
          Этот вызов сообщает программе, что она должна ожидать от вас          
     ввода двух десятичных (целых) чисел, разделенных пробелом; первое          
     будет присвоено а,  а второе b.  Заметим,  что здесь используется          
     операция адреса (&) для передачи адресов а и b функции scanf.              
                                                                                
                                                                                
          Белое поле                                                            
          ----------                                                            
                                                                                
          Промежуток между двумя командами формата %d фактически озна-          
     чает больше,  чем просто промежуток.  Он означает,  что вы можете          
     иметь любое количество "белых полей" между значениями.                     
                                                                                
          Что такое белое поле? Это любая комбинация пробелов, табуля-          
     ций и символов новой строки. В большинстве ситуаций компиляторы и          
     программы Си обычно игнорируют белое поле.                                 

                         - 433,434 -
                                                                                
                                                                                
          Но что же надо делать,  если вы хотите разделить числа запя-          
     той вместо пробела? Необходимо лишь изменить строку ввода:                 
                                                                                
          scanf ("%d, %d", &a, &b);                                             
                                                                                
          Это позволяет вам ввести значения, разделенные запятой.               
                                                                                
                                                                                
          Передача адреса функции scanf                                         
          -----------------------------                                         
                                                                                
          Что  если вы  хотите  ввести  строку?  Наберите и выполните           
     следующую программу:                                                       
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main ()                                                               
          {                                                                     
            char name[30];                                                      
                                                                                
            printf("Как Вас зовут: ");                                          
                                                                                
            scanf("%s", name);                                                  
            printf ("Привет, %s\n", name);                                      
          }                                                                     
                                                                                
          Поскольку name  является массивом символов,  значение name -          
     это адрес самого массива. По этой же причине перед именем name не          
     используется  адресный  оператор &,  вы просто пишете scanf("%s",          
     name);                                                                     
                                                                                
          Обратите внимание, что мы использовали массив символов (char          
     name  [30];),  вместо указателя на символ (char *name;).  Почему?          
     Причиной этого служит тот факт,  что объявление массива на  самом          
     деле резервирует память для хранения его элементов,  а при объяв-          
     лении ссылки этого не происходит.  Если бы мы использовали объяв-          
     ление char *name,  тогда нам бы пришлось явным образом резервиро-          
     вать память для хранения переменной *name.                                 
                                                                                
                                                                                
          Использование gets и getch для ввода                                  
          ------------------------------------                                  
                                                                                
          Использование scanf, однако, порождает другую проблему. Сно-          

                         - 435,436 -
                                                                                
     ва выполните программу, но теперь введите ваше имя и фамилию. За-          
     метьте, что программа использует в своем ответе только имя. Поче-          
     му?  Потому,  что введенный вами после имени пробел сигнализирует          
     scanf о конце вводимой строки.                                             
                                                                                
          Возможны два способа решения  этой  проблемы.  Вот первый из          
     них:                                                                       
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main ()                                                               
          {                                                                     
            char first[20],middle[20],last[20];                                 
                                                                                
            printf("Как Вас зовут:");                                           
            scanf("%s %s %s",first,middle,last);                                
            printf("Дорогой %s, или вам приятней %s?\n",  last,                 
             first);                                                            
           }                                                                    
                                                                                
          Это означает,  что  имеется три компоненты имени;  в примере          
     функция scanf не пойдет дальше,  пока вы действительно не введете          
                                                                                
     три строки. Но что, если необходимо прочитать полное имя, как од-          
     ну строку, включая пробелы? Вот второй способ решения:                     
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main ()                                                               
          {                                                                     
            char name [60];                                                     
                                                                                
            printf("Как вас зовут: ");                                          
            gets (name);                                                        
            printf ("Привет, %s\n", name);                                      
          }                                                                     
                                                                                
          Функция gets читает все,  что вы набираете до тех пор,  пока          
     не нажмете Ввод.  Она не помещает Ввод в строку;  однако в  конец          
     строки добавляет нулевой символ (\0).                                      
                                                                                
          Наконец, есть  еще  функция  getch.  Она читает единственный          
     символ с клавиатуры,  не выдавая его на экран (в отличии от scanf          
     и  gets).  Заметим,  что  у нее нет параметра ch;  getch является          
     функцией типа char,  ее значение может быть непосредственно прис-          

                         - 437,438 -
                                                                                
     воено ch.                                                                  
                                                                                
                                                                                
                                                                                
          Условные операторы                                                    
     -----------------------------------------------------------------          
                                                                                
          Имеется несколько операторов,  о которых мы еще не говорили:          
     условные  и  логические  операторы.  При этом возникают некоторые          
     непростые моменты в выражениях,  которые мы приберегли для обсуж-          
     дения условных (true или false - истина или ложь) операторов.              
                                                                                
                                                                                
                                                                                
          Операции сравнения                                                    
          ------------------                                                    
                                                                                
          Операции сравнения позволяют сравнивать два значения,  полу-          
     чая результат в зависимости от того, дает ли сравнение истину или          
     ложь.  Если сравнение дает ложь, то результирующее значение равно          
     нулю,  если значение истинно, то результат равен 1. Ниже приведен          
     список операций сравнения:                                                 
                                                                                
                                                                                
          > больше                                                              
          >= больше или равно                                                   
          < меньше                                                              
          <= меньше или равно                                                   
          == равно                                                              
          != не равно                                                           
                                                                                
          Почему нас  должно  заботить,  является ли нечто истиной или          
     ложью?  Загрузите и выполните программу RATIO.C и посмотрите, что          
     произойдет,  когда  вы введете 0 для второго значения.  Программа          
     напечатает сообщение об ошибке (Divide by zero - Деление на ноль)          
     и остановится.  Теперь сделайте следующие изменения в программе и          
     запустите ее снова.                                                        
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main ()                                                               
          {                                                                     
            float a,b,ratio;                                                    
                                                                                
            printf("Введите два числа: ");                                      

                         - 439,440 -
                                                                                
            scanf("%f %f",&a,&b);                                               
            if (b == 0.0)                                                       
        printf("Отношение не определено\n");                                    
            else {                                                              
        ratio= a / b;                                                           
        printf("Отношение = %f \n",ratio);                                      
            }                                                                   
          }                                                                     
                                                                                
          Оператор, находящийся в двух следующих за  оператором  scanf          
     строках,  известен  как условный оператор if.  Вы можете понимать          
     его так:"Если значение выражения (b == 0.0) истинно,  сразу  выз-          
     вать printf.  Если значение выражения ложно,  присвоить a/b пере-          
     менной ratio, затем вызвать printf."                                       
                                                                                
          Теперь, если вы введете 0 в качестве  второго  значения,  то          
     ваша программа напечатает сообщение                                        
                                                                                
          Отношение не определено                                               
                                                                                
     и будет ожидать от вас нажатия любой клавиши для возврата в Турбо          
     Си. Если второе значение - ненулевое,  то программа  вычисляет  и          
                                                                                
     печатает ratio,  а затем ожидает нажатия клавиши - и все это бла-          
     годаря магии оператора if.                                                 
                                                                                
                                                                                
                                                                                
          Логические операции                                                   
     -----------------------------------------------------------------          
                                                                                
          Имеется также три логические операции: И (&&), ИЛИ (||) и НЕ          
     (!).  Их не следует путать с описанными выше битовыми  операциями          
     (&,|,~).  Логические  операции  работают с логическими значениями          
     (истина или ложь) и позволяют составлять логические выражения.             
                                                                                
          Как же их отличать от соответствующих битовых операций?               
                                                                                
         - Эти логические операторы всегда дают в  результате значение          
     либо 0 (ложь), либо 1 (истина), в то время как поразрядные опера-          
     торы выполняются путем последовательной обработки  цепочки  битов          
     до тех пор, пока не станет ясен результат.                                 
                                                                                
         - Логические  операторы  && и !!  известны как операторы типа          
     "short circuit".  Выполнение операторов такого типа  прекращается          

                         - 441,442 -
                                                                                
     как только становится ясно, будет ли результат иметь значение ис-          
     тина или ложь. Предположим, что вы имеете выражение вида:                  
                                                                                
               exp1 && exp2                                                     
                                                                                
          Если exp1 - ложь,  значит и все выражение ложь.  Таким обра-          
     зом, exp2 никогда не будет вычисляться. Аналогично, если мы имеем          
     выражение вида                                                             
                                                                                
               exp1 !! exp2                                                     
                                                                                
     то exp2 никогда не будет вычисляться, если exp1 верно.                     
                                                                                
                                                                                
                                                                                
          Дополнительные сведения о выражениях.                                 
     -----------------------------------------------------------------          
                                                                                
          Прежде чем  перейти к обсуждению операторов цикла,  мы дадим          
     некоторые комментарии к использованию выражений. Такие выражения,          
     как (b == 0.0) и (a <= q*r) довольно привлекательны по своей кра-          
     соте.  Однако Си допускает написание более сложных  и  запутанных          
                                                                                
     конструкций, чем эти.                                                      
                                                                                
                                                                                
                                                                                
          Операторы присваивания.                                               
     -----------------------------------------------------------------          
                                                                                
          Любой оператор присваивания,  заключенный в круглые  скобки,          
     является выражением с определенным значением,  которое получается          
     в реэультате этого присваивания.                                           
                                                                                
          Например, выражение (sum = 5+3) имеет  значение  8,  поэтому          
     выражение  ((sum = 5+3) <= 10) будет всегда иметь значение "исти-          
     на" (т.к. 8 <= 10). Более экзотичен следующий пример:                      
                                                                                
       if ((ch=getch()) == 'q')                                                 
           puts("До свидания! Программа завершена.\n");                         
       else                                                                     
           puts("Продолжаем работу!\n");                                        
                                                                                
          Как работает эта конструкция?  Если в программе используется          
     выражение ((ch=getch()) == 'q'),  то она, дойдя до него, останав-          

                         - 443,444 -
                                                                                
     ливается и переходит в состояние ожидания ввода символа с клавиа-          
     туры.  После того, как вы введете символ, осуществляется присваи-          
     вание  введенного  символа  переменной ch и выполняется сравнение          
     введенного символа с символом 'q'.  Если введенный  символ  равен          
     'q', то на экран будет выведено сообщение "До свидания! Программа          
     завершена.", в противном случае будет выведено сообщение "Продол-          
     жаем работу!".                                                             
                                                                                
                                                                                
                                                                                
          Оператор запятая.                                                     
     -----------------------------------------------------------------          
                                                                                
          Вы можете использовать оператор запятая (,)  для организации          
     множественных выражений, расположенных внутри круглых скобок. Вы-          
     ражение внутри скобок вычисляется слева направо и  все  выражение          
     принимает значение,  которое было вычислено последним.  Например,          
     если oldch и ch имеют тип char, то выражение                               
                                                                                
            (oldch = ch, ch = getch())                                          
                                                                                
     присваивает переменной oldch значение ch, затем считывает символ,          
                                                                                
     вводимый с клавиатуры,  и запоминает его в ch.  Результатом всего          
     выражения, в итоге, будет значение введенного с клавиатуры симво-          
     ла. Приведем еще один пример:                                              
                                                                                
            ch='a';                                                             
            if((oldch = ch, ch = 'b') == 'a')                                   
       puts("Это символ 'a'\n");                                                
            else                                                                
       puts("Это символ 'b'\n");                                                
                                                                                
     Как вы  считаете,  какое сообщение будет выведено на экран вашего          
     дисплея в результате выполнения приведенной выше программы?                
                                                                                
                                                                                
                                                                                
          Оператор if.                                                          
     -----------------------------------------------------------------          
                                                                                
          Обратимся теперь  опять к оператору if,  который фигурировал          
     при рассмотрении первых примеров. Оператор if имеет следующий ос-          
     новной формат:                                                             
                                                                                

                         - 445,446 -
                                                                                
           if (значение)                                                        
       оператор1;                                                               
           else                                                                 
       оператор2;                                                               
                                                                                
     где "значение" является любым выражением,  которое приводится или          
     может  быть приведено к целочисленному значению.  Если "значение"          
     отлично от нуля ("истина"), то выполняется "оператор1", в против-          
     ном случае выполняется "оператор2".                                        
                                                                                
          Дадим пояснение относительно двух важных моментов по исполь-          
     зованию оператора if-else.                                                 
                                                                                
          Во-первых, часть "else  оператор2"  является  необязательной          
     частью  оператора  if;  другими словами,  правомерно употребление          
     следующей формы оператора if:                                              
                                                                                
            if (значение)                                                       
          оператор1;                                                            
                                                                                
          В этой  конструкции  "оператор1"  выполняется тогда и только          
     тогда,  когда "значение" отлично от нуля.  Если "значение"  равно          
                                                                                
     нулю, "оператор1" пропускается и программа продолжает выполняться          
     дальше.                                                                    
                                                                                
          Во-вторых, что делать если вы хотите выполнить  более одного          
     оператора в зависимости от того ложно или истинно выражение, ука-          
     занное в операторе if?  Ответ:  используйте  составной  оператор.          
     Составной оператор состоит из:                                             
                                                                                
         - левой или открывающей фигурной скобки ({)                            
                                                                                
         - последовательности операторов, разделенных между собой точ-          
           кой с запятой (;)                                                    
                                                                                
         - правой или закрывающей фигурной скобки (})                           
                                                                                
          В приведенном ниже примере  в  предложении  if  используется          
     один оператор                                                              
                                                                                
        if (b == 0.0)                                                           
           printf("Отношение не определено\n");                                 
                                                                                
     а в предложении else - составной оператор                                  

                         - 447,448 -
                                                                                
                                                                                
                                                                                
        else {                                                                  
           ratio = a/b;                                                         
           printf( "Значение отношения равно %f\n", ratio);                     
                                                                                
        }                                                                       
                                                                                
          Вы можете так же заметить, что тело вашей программы (функции          
     main) является подобием составного оператора.                              
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Циклические конструкции в программах.                            
     -----------------------------------------------------------------          
                                                                                
          Наряду с операторами (или группами операторов),  которые мо-          
     гут  выполняться в зависимости от каких-либо условий,  существуют          
     еще и операторы,  которые могут выполняться несколько раз в одной          
     и  той  же последовательности.  Такой вид конструкции в программе          
     известен как цикл. Есть три основных типа циклов (хотя два из них          
     можно  рассматривать  как  разновидность одного).  Это цикл while          
     ("пока"), цикл for ("для") и цикл do...while ("делать ... пока").          
     Рассмотрим их по порядку.                                                  
                                                                                
                                                                                
                                                                                
          Цикл while.                                                           
     -----------------------------------------------------------------          
                                                                                
          Цикл while является наиболее общим  и  может  использоваться          
     вместо двух других типов циклических конструкций. В принципе мож-          
     но сказать,  что  по-настоящему  для  программирования  необходим          
     только  цикл while,  а другие типы циклических конструкций служат          
     лишь для удобства написания программ.                                      

                         - 449,450 -
                                                                                
                                                                                
          Загрузите с диска файл HELLO.C и измените его следующим  об-          
     разом:                                                                     
                                                                                
         #inсlude <stdio.h>                                                     
          main()                                                                
          {                                                                     
      int len;                                                                  
                                                                                
      len=0;                                                                    
      puts("Наберите предложение, затем нажмите <Ввод>");                       
        while ( getchar() != '\n')                                              
        {                                                                       
           len++;                                                               
        }                                                                       
           printf("\nВаше предложение имеет длину %d символов\n",len);          
          }                                                                     
                                                                                
          Эта программа  позволяет  ввести  предложение с клавиатуры и          
     подсчитать при этом,  сколько раз вы нажали на клавиши клавиатуры          
     до тех пор,  пока не нажали на клавишу <Ввод> (соответствует спе-          
     циальному символу конца строки - '\n').  Затем программа  сообщит          
                                                                                
     вам сколько символов (символ '\n' не подсчитывается) вы ввели.             
                                                                                
          Оператор while имеет следующий формат:                                
                                                                                
          while (выражение)                                                     
            оператор                                                            
                                                                                
     где "выражение" принимает нулевое или отличное от  нуля значение,          
     а  "оператор"  может представлять собой как один оператор,  так и          
     составной оператор.                                                        
                                                                                
          В процессе выполнения цикла while вычисляется значение  "вы-          
     ражения".  Если оно истинно, то "оператор", следующий за ключевым          
     словом while,  выполняется и "выражение" вычисляется снова.  Если          
     "выражение" ложно,  то цикл while завершается и программа продол-          
     жает выполняться дальше.                                                   
                                                                                
          Обратите внимание на другой пример цикла while, который               
     также находится в файле HELLO.C:                                           
                                                                                
          #include <stdio.h>                                                    
                                                                                

                         - 451,452 -
                                                                                
         main()                                                                 
         {                                                                      
            char *msg;                                                          
            int indx;                                                           
                                                                                
            msg = "Здравствуй, мир";                                            
            indx = 1 ;                                                          
            while (indx <= 10 ) {                                               
               printf("Время # %2d: %s\n", indx,msg);                           
               indx++;                                                          
               }                                                                
         }                                                                      
                                                                                
                                                                                
          После компиляции и выполнения этой программы на экране будут          
     отображены строки со следующей информацией:                                
                                                                                
        Время # 1 : Здравствуй, мир                                             
        Время # 2 : Здравствуй, мир                                             
        Время # 3 : Здравствуй, мир                                             
          ........................                                              
        Время # 9 : Здравствуй, мир                                             
                                                                                
        Время # 10 : Здравствуй, мир                                            
                                                                                
          Очевидно, что оператор printf был выполнен ровно десять раз.          
     При этом значение параметра цикла indx изменилось от 1 до 10.              
                                                                                
          Немного подумав, вы сможете переписать этот  цикл несколько           
     компактнее:                                                                
                                                                                
           indx = 0 ;                                                           
           while (indx++ < 10 )                                                 
       printf("Время #%2d: %s\n",indx,msg);                                     
                                                                                
                                                                                
          Изучайте этот второй пример цикла while до тех пор, пока вам          
     не станет ясно,  почему он работает точно так же,  как и в первом          
     случае. Затем переходите к изучению цикла типа for.                        
                                                                                
                                                                                
                                                                                
          Цикл for.                                                             
     -----------------------------------------------------------------          
                                                                                

                         - 453,454 -
                                                                                
          Цикл for  является  одним из основных видов циклов,  которые          
     имеются во всех универсальных  языках  программирования,  включая          
     Си.  Однако, версия цикла for, используемая в Си, как вы увидите,          
     обладает большей мощностью и гибкостью.                                    
                                                                                
          Основная идея, заложенная в его функционирование, заключает-          
     ся в том,  что операторы,  находящиеся внутри цикла,  выполняются          
     фиксированное число раз, в то время как переменная цикла (извест-          
     ная еще как индексная переменная) пробегает определенный ряд зна-          
     чений. Например, модифицируем программу, о которой говорилось вы-          
     ше, в следующую:                                                           
                                                                                
          #include <stdio.h>                                                    
                                                                                
          main()                                                                
          {                                                                     
      char  *msg;                                                               
      int indx;                                                                 
                                                                                
      msg = "Здравствуй, мир";                                                  
      for (indx = 1; indx <= 10; indx++ )                                       
         printf("Время #%2d: %s\n",indx,msg);                                   
                                                                                
          }                                                                     
                                                                                
          Выполните эту программу и вы убедитесь, что она делает те же          
     действия, что и программа с циклом while, которую мы уже разобра-          
     ли, и является точным эквивалентом первого ее варианта.                    
                                                                                
          Теперь приведем основной формат цикла for:                            
                                                                                
       for (выр1; выр2; выр3)                                                   
           оператор                                                             
                                                                                
          Так же,  как и в цикле while,  "оператор" в теле  цикла  for          
     обычно является одним из операторов программы, но может использо-          
     ваться  и  составной  оператор,  заключенный  в  фигурные  скобки          
     ({...}).                                                                   
                                                                                
          Заметим, что  параметры  цикла  for,  заключенные  в скобки,          
     должны разделяться точкой с запятой (позиционный параметр), кото-          
     рая делит в свою очередь пространство внутри скобок на три секто-          
     ра.  Каждый параметр,  занимающий определенную позицию,  означает          
     следующее:                                                                 
                                                                                

                         - 455,456 -
                                                                                
          - выр1 - обычно   задает начальное   значение индексной               
            переменной;                                                         
                                                                                
          - выр2 - условие продолжения цикла;                                   
                                                                                
          - выр3 - обычно задает  некоторую  модификацию  (приращение)          
            индексной переменной за каждое выполнение цикла.                    
                                                                                
          Основной вариант  цикла for эквивалентен следующей конструк-          
     ции, выраженной с помощью цикла while:                                     
                                                                                
            выр1;                                                               
       while (выр2) {                                                           
          оператор;                                                             
       выр3;                                                                    
       }                                                                        
                                                                                
          Вы можете опускать одно,  несколько или даже все выражения в          
     операторе for,  однако о необходимости наличия точек с запятой вы          
     должны помнить всегда. Если вы опустите "выр2", то это будет рав-          
     носильно  тому,  что значение выражения "выр2" всегда будет иметь          
     значение 1 (истина) и цикл никогда не завершится (такие циклы из-          
                                                                                
     вестны еще как бесконечные).                                               
                                                                                
          Во многих  случаях вам поможет использование оператора запя-          
     тая (,), который позволяет вводить составные выражения в оператор          
     цикла for.  Вот,  например, еще одна правильная модификация файла          
     HELLO.C с использованием составного выражения в операторе for:             
                                                                                
         #include <stdio.h>                                                     
                                                                                
         main()                                                                 
         {                                                                      
            char *msg;                                                          
            int up,down;                                                        
                                                                                
            msg = "Здравствуй, мир";                                            
            for (up = 1, down = 9; up <= 10; up++, down--)                      
      printf("%s: %2d растет, %2d уменьшается \n",msg,up,down);                 
         }                                                                      
                                                                                
          Заметьте, что и первое и последнее выражение  в  этом  цикле          
     for состоит из двух выражений,  инициализирующих и модифицирующих          
     переменные up и down. Вы можете сделать эти выражения сколь угод-          

                         - 457,458 -
                                                                                
     но сложными.  (Возможно  вы  слышали  о  легендарных  хаккерах Си          
     (hacker - программист,  способный писать программы без  предвари-          
     тельной  разработки спецификаций и оперативно вносить исправления          
     в работающие программы, не имеющие документации), которые запихи-          
     вают  большинство  своих  программ в три выражения оператора for,          
     оставляя в теле цикла лишь несколько операторов).                          
                                                                                
                                                                                
                                                                                
          Цикл do...while.                                                      
     -----------------------------------------------------------------          
                                                                                
          Последним видом цикла является цикл do...while. Модифицируй-          
     те RATIO.C следующим образом:                                              
                                                                                
          #include <stdio.h>                                                    
          #include <conio.h>                                                    
                                                                                
          main()                                                                
          {                                                                     
      float a,b,ratio;                                                          
                                                                                
                                                                                
      do {                                                                      
        printf("\nВведите два числа: ");                                        
        scanf("%f %f", &a, &b);                                                 
        if (b == 0.0)                                                           
           printf("\n Деление на ноль!");                                       
        else {                                                                  
           ratio = a/b;                                                         
           printf("\nРезультат деления двух чисел: %f",ratio);                  
        }                                                                       
        printf("\nНажми 'q' для выхода или любую клавишу для"                   
        " продолжения")                                                         
      } while ( getch() != 'q');                                                
          }                                                                     
                                                                                
          Эта программа  вычисляет  результат  деления одного числа на          
     другое.Затем порсит вас нажать любую  клавишу.  Если  вы  нажмете          
     клавишу  'q',  то выражение в операторе цикла while в конце прог-          
     раммы примет значение "ложь" и цикл (а значит и программа) завер-          
     шится. Если вы введете какой-либо другой символ, отличный от 'q',          
     то выражение будет иметь значение "истина" и цикл повторится.              
                                                                                
          Формат цикла do...while можно представить в виде:                     

                         - 459,460 -
                                                                                
                                                                                
                                                                                
           do оператор while (выр);                                             
                                                                                
          Основным отличием между циклом while и циклом  do...while  в          
     том,  что  операторы внутри do...while всегда выполняются хотя бы          
     один раз (т.к.  проверка условия выполнения цикла  осуществляется          
     после выполнения последовательности операторов, составляющих тело          
     цикла).  Это похоже на цикл repeat...until в Паскале с одним, од-          
     нако, различием: цикл repeat выполняется дотехпор, пока его усло-          
     вие не станет истинным;  а цикл do...while выполняется пока исти-          
     на.                                                                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Функции.                                                         
     -----------------------------------------------------------------          
                                                                                
          Вы изучили, как выполняются программы, содержащие условные и          
     итеративные операторы.  Сейчас настало время задать нам вопрос: а          
     что же делать,  если я вдруг захочу  выполнить  различные  группы          
     операторов,  использующие различные наборы данных или находящиеся          
     в различных частях программы? Ответ прост: объединяйте эти группы          
     операторов в подпрограммы,  к которым вы будете обращаться по не-          
     обходимости.                                                               
                                                                                
          В Си все подпрограммы рассматриваются как функции.  Теорети-          
     чески,  каждая функция возвращает некоторое значение. Практически          
     же,  значения,  возвращаемые большинством функций игнорируются  и          
     целое  семейство новых определений языка Си (включая проект стан-          
     дарта Си,  предложенный ANSI,  и Турбо Си) позволяют описывать  и          
     использовать в языке функции типа void,  которые никогда не возв-          
     ращают значений. Никогда.                                                  
                                                                                
          В Си вы можете и описывать и определять  функцию.  Когда  вы          
     описываете  функцию,  то даете всем остальным программам (включая          
     главный модудь main) информацию о том,  каким образом должно осу-          

                         - 461,462 -
                                                                                
     ществляться обращение к этой функции.  Когда вы определяете функ-          
     цию,  вы присваиваете ей имя,  по которому к ней  будет  осущест-          
     вляться  обращение,  и  указываете,  какие конкретно действия она          
     будет выполнять.  Внимательно изучите этот модифицированный вари-          
     ант RATIO.C:                                                               
                                                                                
          #include <stdio.h>                                                    
          #include <conio.h>                                                    
                                                                                
          /* Описание функций */                                                
                                                                                
          void  get_parms(float *p1, float *p2);                                
          float get_ratio(float divident, float divisor);                       
          void  put_ratio (float quotient);                                     
                                                                                
          const float INFINITY = 3.4E+38;                                       
                                                                                
          /* Главная (main) функция: стартовая точка программы */               
                                                                                
          main()                                                                
          {                                                                     
           float a,b,ratio;                                                     
                                                                                
                                                                                
            do {                                                                
      get_parms(&a,&b);        /* ввод параметров */                            
      ratio = get_ratio(a,b);  /* вычисление частного */                        
      put_ratio(ratio);        /* печать выходного результата */                
      printf("Нажми 'q' для выхода или любую клавишу для"                       
             " продолжения\n");                                                 
         } while ( getch() != 'q');                                             
          }                                                                     
          /* конец main */                                                      
                                                                                
          /* Определение функций */                                             
                                                                                
          void get_parms(float *p1, float *p2)                                  
          {                                                                     
      printf("Введите два числа: ");                                            
      scanf("%f %f", p1, p2);                                                   
          }                                                                     
                                                                                
          float get_ratio(float divident, float divisor)                        
          {                                                                     
      if (divisor == 0.0)                                                       

                         - 463,464 -
                                                                                
          return (INFINITY);                                                    
      else                                                                      
          return(divident / divisor);                                           
          }                                                                     
                                                                                
          void put_ratio(float ratio)                                           
          {                                                                     
      if (ratio == INFINITY)                                                    
         printf("Внимание! Деление на ноль!\n");                                
      else                                                                      
         printf("Результат деления двух чисел: %f\n",ratio);                    
          }                                                                     
                                                                                
                                                                                
                                                                                
               Анализ программы.                                                
     -----------------------------------------------------------------          
                                                                                
          Первые три строки программы - описание функций; они вводятся          
     для того, чтобы описать как тип функций, так и порядок следования          
     их параметров с целью контроля ошибок.                                     
                                                                                
                                                                                
          Следующая строка описывает константу с плавающей точкой, ко-          
     торой присваивается имя INFINITY (в соответствии с принятым  в Си          
     соглашением имена констант состоят из заглавных букв).  Эта конс-          
     танта имеет очень большое положительное значение - близкое к наи-          
     большему  из  допустимых для типа float,  и используется как флаг          
     возникновения ситуации деления на ноль (divide-by-zero).                   
                                                                                
          Заметьте, что несмотря на то,  что константа описана  здесь,          
     она доступна внутри всех функций (включая главную функцию).                
                                                                                
          Далее следует функция main (главная функция),  которая явля-          
     ется основным телом вашей программы.  Каждая программа на Си обя-          
     зательно содержит функцию с именем main. Когда ваша программа на-          
     чинает  выполняться,  вызывается  функция   main   и   дальнейшее          
     выполнение  программы продолжается под ее управлением.  Когда вы-          
     полнение функции с именем main заканчивается,  то  завершается  и          
     вся  программа,  после чего управление передается интегрированной          
     среде Турбо Си или, если вы выполняли программу непосредственно в          
     DOS, то монитору DOS.                                                      
                                                                                
          Функция main может быть расположена в любом месте программы,          
     наиболее часто - это первая функция  программы.  Это  обусловлено          

                         - 465,466 -
                                                                                
     тем,  что  расположение функции main в начале программы облегчает          
     ее чтение, описание прототипов функций и различных глобальных пе-          
     ременных.  Это, в свою очередь, позволяет облегчить поиск и доку-          
     ментирование функций во всей программе.                                    
                                                                                
          После main следует  фактическое  определение  трех  функций,          
     прототипы  которых  были  описаны  выше:  get_parms,  get_ratio и          
     put_ratio. Рассмотрим отдельно каждое из определений.                      
                                                                                
                                                                                
                                                                                
          Функция get_parms.                                                    
          -----------------                                                     
                                                                                
          Функция get_parms  не возвращает никакого значения,  так как          
     ее тип мы определили как void.  Это было сделано в связи  с  тем,          
     что  функция служит лишь для чтения двух значений и сохранения их          
     в некотором месте.  В каком?  Сейчас дадим  некоторые  пояснения.          
     Итак,  мы передаем в get_parms два параметра.  Эти параметры суть          
     адреса,  по которым должны быть размещены считанные функцией зна-          
     чения.  Обратите внимание! Оба параметра не являются данными типа          
     float,  но являются указателями на переменные типа float. Другими          
                                                                                
     словами, мы работаем непосредственно с адресами памяти по которым          
     размещены переменные типа float.                                           
                                                                                
          В соответствии с этим и организовано обращение к  функции из          
     main:  когда  мы вызываем get_parms из main,  параметрами функции          
     являются &a и &b (адреса),  а не текущие значения a и b. Заметьте          
     также,  что вся информация,  используемая при обращении к функции          
     scanf, находится непосредственно внутри функции get_parms и перед          
     параметрами  p1  и p2 не стоят знаки операций адресации.  Почему?          
     Потому, что p1 и p2 уже сами по себе адреса; они являются адреса-          
     ми переменных a и b.                                                       
                                                                                
                                                                                
                                                                                
          Функция get_ratio.                                                    
          -----------------                                                     
                                                                                
          Функция get_ratio возвращает результат (типа float) обработ-          
     ки   двух  значений  типа  float,  передаваемых  ей  (divident  и          
     divisor).  Возвращенный функцией результат зависит от того, равно          
     значение  переменной divisor нулю или нет.  Если значение divisor          
     равно нулю,  get_ratio возвращает константу INFINITY.  Если нет -          

                         - 467,468 -
                                                                                
                                                                                
     действительное значение частного двух чисел. Обратите внимание на          
     вид оператора return.                                                      
                                                                                
                                                                                
                                                                                
          Функция put_ratio.                                                    
          -----------------                                                     
                                                                                
          Функция put_ratio не возвращает значение, т.к. ее тип объяв-          
     лен как void.  Она имеет ровно один параметр - ratio, который ис-          
     пользуется  для  того,  чтобы определить,  какое именно сообщение          
     следует выводить на экран дисплея.  Если  ratio  равно  INFINITY,          
     значит  значение частного двух чисел считается неопределенным,  в          
     противном случае значение ratio выводится на  экран  дисплея  как          
     результат работы программы.                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Глобальные описания.                                             
     -----------------------------------------------------------------          
                                                                                
          Константы, типы данных и переменные,  описанные вне  функций          
     (включая main),  считаются  глобальными ниже точки описания.  Это          
     позволяет использовать их внутри функций в пределах всей програм-          
     мы вследствие того,  что они уже описаны и известны во всех функ-          
     циях ниже точки описания. Если вы переместите описание INFINITY в          
     конец программы, то компилятор выдаст сообщение о том, что им об-          
     наружены  две  ошибки:  одна  из  них - в get_ratio, a другая - в          
     put_ratio. Причина  ошибок - использование неописанного идентифи-          
     катора.                                                                    
                                                                                
                                                                                
                                                                                
               Описание функций                                                 
     -----------------------------------------------------------------          
                                                                                
          Вы можете  использовать два различных стиля описания функций          
     как классический стиль,  так и современный.  Классический  стиль,          
     который  нашел  широкое  применение в большинстве программ на Си,          
     имеет следующий формат:                                                    

                         - 469,470 -
                                                                                
                                                                                
          тип имя_функции() ;                                                   
                                                                                
          Эта спецификация описывает имя функции ("имя_функции") и тип          
     возвращаемых ею значений ("тип").  Это описание не содержит ника-          
     кой информации о параметрах функции,  однако это не вызовет обна-          
     ружения  ошибки компилятором или преобразования типов к типу, уже          
     принятому контекстно,  в соответствии с принятыми соглашениями  о          
     преобразовании  типов.  Если  вы  перепишите  описания  функций в          
     RATIO.C,  используя этот стиль, то вновь полученные описания при-          
     обретут вид:                                                               
                                                                                
           void   get_parms();                                                  
           float  get_ratio();                                                  
           void   put_ratio();                                                  
                                                                                
          Современный стиль  используется  в  конструкциях расширенной          
     версии Си,  предложенной ANSI. При описании функций в этой версии          
     Си используются специальные средства языка,  известные под назва-          
     нием "прототип функции".  Описание функции  с  использованием  ее          
     прототипа содержит дополнительно информацию о ее параметрах:               
                                                                                
                                                                                
           тип имя_функции(пар_инф1,пар_инф2,...)                               
                                                                                
     где параметр пар_инф1 имеет один из следующих форматов:                    
                                                                                
           тип                                                                  
           тип имя_пар                                                          
           ...                                                                  
                                                                                
          Другими словами,  для использования прототипа функции должен          
     быть описан тип каждого формального параметра,  либо указано  его          
     имя.  Если  функция  использует переменный список параметров,  то          
     после указания последнего параметра функции в описании необходимо          
     использовать эллипсис (...).                                               
                                                                                
          Подход к  описанию  функций  с помощью описания ее прототипа          
     дает возможность компилятору производить проверку на соответствие          
     количества  и типа параметров при каждом обращении к функции. Это          
     также позволяет компилятору выполнять по  возможности необходимые          
     преобразования. Обратите внимание, что описание функций в началь-          
     ной версии RATIO.C осуществлено с помощью прототипов функций. Бо-          
     лее  полную информацию о прототипах функций можно получить в гла-          
     вах 11 и 12.                                                               

                         - 471,472 -
                                                                                
               Определение функций                                              
     -----------------------------------------------------------------          
                                                                                
          Так же,  как  и в описании функций,  при определении функций          
     прослеживается два стиля - классический и современный.                     
                                                                                
          Классический формат определения функций имеет примерно  сле-          
     дующий вид:                                                                
                                                                                
          тип имя_функции(имена_параметров)                                     
          описание параметров;                                                  
          {                                                                     
             локальные описания;                                                
             операторы;                                                         
          }                                                                     
                                                                                
          Формат описания в современном стиле предусматривает  опреде-          
     ление параметров функции в скобках, следующих за "имя_функции":            
                                                                                
          тип имя_функции(пар_инф, пар_инф, ...)                                
                                                                                
          Однако, в  этом  примере определение параметра "пар_инф" со-          
                                                                                
     держит всю информацию о передаваемом параметре: тип и идентифика-          
     тор.  Это позволяет рассматривать первую строку определения функ-          
     ции как часть соответствующего прототипа функции за  одним важным          
     исключением:  эта  строка определения функции не содержит точку с          
     запятой (;) в определении,  тогда как прототип функции всегда за-          
     канчивается  точкой  с  запятой.  Например,  определение  функции          
     get_parms в классическом стиле выглядит следующим образом:                 
                                                                                
          void get_parms(p1, p2)                                                
          float *p1; float *p2;                                                 
          { ... }                                                               
                                                                                
          Но приверженец  современного  стиля  программирования  на Си          
     опишет эту же функцию иначе, с использованием прототипа:                   
                                                                                
          void get_parms(float *p1, float *p2)                                  
          { ... }                                                               
                                                                                
          Заметьте, что ряд описаний (константы, типы данных, перемен-          
     ные),  содержащихся внутри функции (исключение составляет главная          
     функция main),  "видимы" или определены только внутри этой  функ-          
     ции.  Поэтому Си не поддерживает вложенность функций;  т.е. вы не          

                         - 473,474 -
                                                                                
                                                                                
     можете объявить одну функцию внутри другой.                                
                                                                                
          Функции могут быть размещены в программе в различном порядке          
     и  считаются  глобальными для всей программы,  включая встроенные          
     функции,  описанные до их использования. Старайтесь корректно ис-          
     пользовать функции,  которые еще вами не определены и не описаны;          
     когда компилятор обнаружит функцию,  которую прежде он не  встре-          
     чал,  он  определит тип значений,  возвращаемый функцией как int.          
     Если вы ранее определили тип возвращаемых ею значений как, напри-          
     мер, char*, то компилятор выдаст ошибку несоответствия типов дан-          
     ных.                                                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Комментарии                                                      
     -----------------------------------------------------------------          
                                                                                
          Итак, вы хотите внести в программу некоторые пояснения,  ко-          
     торые напомнили бы вам (или информировали  кого-нибудь  другого),          
     что означает та или иная переменная, что дает та или иная функция          
     или оператор и т.д.  Эти пояснения носят  название  "комментарий"          
     (comments). Си так же, как и большинство других языков программи-          
     рования, позволяет вносить комментарии в программы.                        
                                                                                
          Начало комментария обозначается комбинацией  знаков  слеш  и          
     звездочка (/*). После того, как компилятор обнаружит эту комбина-          
     цию знаков,  он игнорирует участок программы вплоть до последова-          
     тельности знаков */.                                                       
                                                                                
          Комментарий может занимать несколько строк программы:                 
                                                                                
          /* Это очень длинный комментарий,                                     
           занимающий более одной строки программы */                           
                                                                                
          Проанализируйте еще раз расширенную версию RATIO.C и добавь-          
     те в нее комментарии.                                                      

                         - 475,476 -
                                                                                
                                                                                
     Резюме                                                                     
     -----------------------------------------------------------------          
                                                                                
          Мы изучили семь основных конструкций  языка программирования          
     и  показали,  как можно использовать каждую из них в рамках Турбо          
     Си.                                                                        
                                                                                
          На этом изучение основных конструкций Си  не  заканчивается,          
     мы вернемся к ним в главе 7, где рассмотрим их более подробно.             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                              Г Л А В А  7                                      
                                                                                
                                                                                
              О НЕКОТОРЫХ ОСОБЕННОСТЯХ ПРОГРАММИРОВАНИЯ НА СИ                   
     -----------------------------------------------------------------          
                                                                                
          Приятно знать,  что вы добрались и до этой главы.  В прошлой          
     главе мы дали вам представление о программировании на  Турбо  Си,          
     вполне достаточное для пробуждения вашей любознательности. Теперь          
     вы готовы углубиться в некоторые тонкости и тайны  программирова-          
     ния на Си, в чем мы и постараемся вам помочь.                              
                                                                                
                                                                                
                                                                                
          В этой главе...                                                       
     -----------------------------------------------------------------          
                                                                                
          В этой главе мы предлагаем вам изучить следующее:                     
                                                                                
        - структуры данных, включающие указатели, массивы и структуры;          
        - оператор switch;                                                      
        - команды   передачи  управления,  включающие  return,  break,          

                         - 477,478 -
                                                                                
                                                                                
          continue, goto и условный оператор (?:);                              
        - потоки  и поток ввода-вывода:  как считывать из и записывать          
          на дисковый файл или встроенное оборудование;                         
        - стиль программирования на Си и обзор новых расширений Си;             
        - некоторые общие "ловушки" для программистов на Си.                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Обзор структур данных                                            
     -----------------------------------------------------------------          
                                                                                
          Основные типы данных мы рассмотрели в прошлой главе.  К  ним          
     относятся числа - целые и с плавающей точкой, символы и их разно-          
     видности. Теперь мы поговорим о том, как использовать эти элемен-          
     ты для  построения СТРУКТУР данных.  Но сначала мы исследуем одно          
     из важнейших понятий Си - указатели.                                       
                                                                                
                                                                                
                                                                                
          Указатели                                                             
     -----------------------------------------------------------------          
                                                                                
          Большинство переменных,  рассмотренных вами,  в основном со-          
     держали данные, т.е. текущую информацию для работы вашей програм-          
     мы. Но  иногда важнее знать место расположения данных,  чем собс-          
     твенно их значение. Именно для этого и используются указатели.             
                                                                                
          Если вы  имеете  слабое  представление  о понятиях "адрес" и          
     "память", то вам просто необходимо ознакомиться с их кратким опи-          
     санием, которое мы приводим ниже.                                          

                         - 479,480 -
                                                                                
                                                                                
          Итак, ваш  компьютер содержит в своей памяти (часто называе-          
     мой RAM - Random Access Memory -  память  произвольного  доступа)          
     вашу программу и совокупность данных.  На самом нижнем уровне па-          
     мять вашего компьютера состоит из  бит,   мельчайших  электронных          
     схем которые  могут "запомнить" (пока компьютер включен)  одно из          
     двух значений, обычно интерпретируемое как "0" и "1".                      
                                                                                
          Восемь битов группируются в один БАЙТ. Большим группам битов          
     как правило,  присваивается имя: обычно два байта составляют СЛО-          
     ВО, четыре  байта составляют ДЛИННОЕ СЛОВО; и для IBM PC шестнад-          
     цать байт составляют ПАРАГРАФ.                                             
                                                                                
          Каждый байт  в  памяти  вашего  компьютера имеет собственный          
     уникальный адрес, так же, как каждый дом на любой улице. Но в от-          
     личие от большинства домов, последовательные байты имеют последо-          
     вательные адреса:  если данный байт имеет адрес N,  то предыдущий          
     байт имеет адрес N-1, а следующий - N+1.                                   
                                                                                
          УКАЗАТЕЛЬ -  это переменная, содержащая адрес некоторых дан-          
     ных, а не их значение. Зачем это нужно?                                    
                                                                                
                                                                                
          Во-первых, мы можем использовать указатель места  расположе-          
     ния различных данных и различных структур данных.  Изменением ад-          
     реса, содержащегося в указателе, вы можете манипулировать (созда-          
     вать, считывать,   изменять)  информацию в различных ячейках. Это          
     позволит вам, например, связать несколько зависимых структур дан-          
     ных с помощью одного указателя.                                            
                                                                                
          Во-вторых, использование  указателей  позволит вам создавать          
     новые переменные в процессе выполнения программы.   Си  позволяет          
     вашей программе   запрашивать некоторое количество памяти (в бай-          
     тах), возвращая адреса, которые можно запомнить в указателе. Этот          
     прием известен как ДИНАМИЧЕСКОЕ РАСПРЕДЕЛЕНИЕ; используя его, ва-          
     ша программа может приспосабливаться к любому объему  памяти,   в          
     зависимости от  того как много (или мало)  памяти доступно вашему          
     компьютеру.                                                                
                                                                                
          В-третьих, вы можете использовать указатели  для  доступа  к          
     различным элементам  структур данных,  таким как массивы,  строки          
     или структуры.  Указатель,  в сущности,  указывает место в памяти          
     вашего компьютера   (а используя смещение относительно начального          
     адреса можно указать целый сегмент памяти),  в котором  размещены          
     те или иные данные.  Индексируя указатель,  вы получаете доступ к          

                         - 481,482 -
                                                                                
     некоторой последовательноси байтов,  которая может  представлять,          
     например, массив или структуру.                                            
                                                                                
          Теперь вы,  несомнено, убеждены в удобстве указателей. А как          
     же их использовать в Си? Для начала вы должны их объявить.                 
                                                                                
          Рассмотрим следующую программу:                                       
                                                                                
                  main()                                                        
                  {                                                             
                    int ivar,*iptr;                                             
                                                                                
                    iptr = &ivar;                                               
                    ivar = 421;                                                 
                    printf("Размещение ivar: %p\n",&ivar);                      
                    printf("Содержимое ivar: %d\n", ivar);                      
                    printf("Содержимое iptr: %p\n", iptr);                      
                    printf("Адресуемое значение: %d\n",*iptr);                  
                  }                                                             
                                                                                
          В ней объявлены две переменные:  ivar и iptr. Первая, ivar -          
     это целая переменная,  т.е. содержащая значение типа int. Вторая,          
                                                                                
     iptr - это указатель на целую переменную,  следовательно она  со-          
     держит АДРЕС значения типа int. Можно также сказать, что перемен-          
     ная iptr - это указатель,  так как перед ее описанием стоит звез-          
     дочка (*).    В  языке  Си  эта  звездочка  называется  косвенным          
     оператором.                                                                
                                                                                
          В основном, данная программа делает следующее:                        
                                                                                
             - адрес переменной ivar присваисвается iptr                        
                                                                                
             - целое значение 421 присваивается ivar                            
                                                                                
          Адресный оператор  (&),  как это было  показано в предыдущей          
     главе,  позволяет получить адрес,  по которому размещено значение          
     переменной ivar.                                                           
                                                                                
          Введя  эту программу  в  свой  компьютер  и  выполнив ее, вы          
     получите следующий результат:                                              
                                                                                
             Размещение ivar: 166E                                              
             Содержимое ivar: 421                                               
             Содержимое iptr: 166E                                              

                         - 483,484 -
                                                                                
             Адресуемое значение: 421                                           
                                                                                
          Первые две строки указывают адрес и содержимое ivar.  Третья          
     представляет адрес,  содержащийся в iptr.  Как видите,  это адрес          
     переменной ivar,  т.е.  место в памяти, где ваша программа решила          
     создать переменную с идентификатором ivar. В последней строке пе-          
     чатается то,  что хранится по этому адресу - те же самые  данные,          
     которые уже присвоены переменной ivar.                                     
                                                                                
          Заметим, что в третьем обращении к функции printf используе-          
     тся выражение iptr,  содержимое которого есть адрес ivar.  В пос-          
     леднем обращении  к printf используется выражение *iptr,  которое          
     позволяет получить данные, хранящиеся по этому адресу.                     
                                                                                
          Рассмотрим теперь небольшую вариацию предыдущей программы:            
                                                                                
                  main()                                                        
                  {                                                             
                      int ivar,*iptr;                                           
                                                                                
                      iptr  = &ivar;                                            
                      *iptr = 421;                                              
                                                                                
                                                                                
                    printf("Размещение ivar: %p\n",&ivar);                      
                    printf("Содержимое ivar: %d\n", ivar);                      
                    printf("Содержимое iptr: %p\n", iptr);                      
                    printf("Адресуемое значение: %d\n",*iptr);                  
                  }                                                             
                                                                                
                                                                                
           В этой  программе также адрес переменной ivar присваивается          
     iptr, но  вместо присваивания числа 421 переменной ivar, это зна-          
     чение присваивается по указателю *iptr.  Каков результат ?  Точно          
     такой же, как и в предыдущей программе. Почему ? Потому что выра-          
     жения *iptr   и  ivar суть одна и та же ячейка памяти - поэтому в          
     этом случае оба оператора заносят значение 421 в  одну  и  ту  же          
     ячейку памяти.                                                             
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 485,486 -
                                                                                
                Динамическое распределение                                      
     -----------------------------------------------------------------          
                                                                                
          Изменим еще раз нашу программу:                                       
                                                                                
                  #include <alloc.h>                                            
                  main()                                                        
                  {                                                             
                     int *iptr;                                                 
                                                                                
                     iptr = (int *) malloc(sizeof(int));                        
                     *iptr = 421;                                               
                     printf("Содержимое iptr: %p\n", iptr);                     
                     printf("Адресуемое значение: %d\n",*iptr);                 
                  }                                                             
                                                                                
          Эта версия позволяет вполне обойтись без описания переменной          
     ivar, которое    непременно  фигурировало  в предыдущих примерах.          
     Вместо адреса этой переменной iptr присваивается  значение  (тоже          
     адрес некоторой ячейки памяти),  возвращаемое некоторой функцией,          
     которая называется malloc, и описана в библиотеке alloc.h (отсюда          
     появление директивы #include в начале программы).  Затем по этому          
                                                                                
     адресу присваивается значение 421 и переменная *iptr вновь, как и          
     в предыдущем примере, принимает значение 421.                              
                                                                                
          Обратите внимание,   что если вы теперь выполните программу,          
     то получите иное значение iptr, чем раньше, но значение *iptr ос-          
     танется равным 421.                                                        
                                                                                
          Разберем теперь, что же делает оператор                               
                                                                                
                    iptr = (int *) malloc(sizeof(int));                         
                                                                                
          Разобьем его на части:                                                
                                                                                
             - выражение  sizeof(int)   возвращает  количество байтов,          
               требуемое для хранения переменной типа int; для  компи-          
               лятора Турбо Си,  работающего на IBM PC, это возвращае-          
               мое значение равно 2.                                            
                                                                                
             - функция malloc(num)  резервирует  num  последовательных          
               байтов доступной (свободной) памяти в компьютере, а за-          
               тем возвращает начальный адрес размещения в памяти этой          
               последовательности байтов.                                       

                         - 487,488 -
                                                                                
                                                                                
             - выражение (int *)  указывает,  что этот начальный адрес          
               суть указатель на данные типа int. Выражение такого ви-          
               да известно     как  выражение  приведения  типа  (type          
               casting). В  данном случае Турбо Си не  требует  обяза-          
               тельного его применения. Но в связи с тем, что для дру-          
               гих компиляторов Си это выражение  является  обязатель-          
               ным, при    его  отсутствии  вы  получите  сообщение об          
               ошибке:                                                          
                                                                                
                        " Non-portable pointer assignment."                     
               (Непереносимое в другие системы присваивание указателя)          
                                                                                
               Из соображений  переносимости программного обеспечения,          
               лучше всегда предусматривайте явное приведение типов  в          
               своих программах.                                                
                                                                                
             - наконец,   адрес,  полученный с помощью функции malloc,          
               запоминается в iptr. Таким образом, вами получена дина-          
               мически созданная  целая переменная к которой вы можете          
               обращаться при помощи идентификатора *iptr.                      
                                                                                
                                                                                
                                                                                
          Весь этот блок можно описать следующим образом:  "выделить в          
     памяти компьютера некоторый участок для переменной типa int,  за-          
     тем присвоить начальный адрес этого участка переменной iptr,  яв-          
     ляющейся указателем на переменную типа int".                               
                                                                                
          Необходимо ли все это?  Да.  Почему?  Потому что без этого у          
     вас нет гарантии, что iptr указывает на свободный участок памяти.          
     iptr будет   содержать некоторое значение,  которое вы будете ис-          
     пользовать в качестве адреса,  но вам не будет известно,  не  ис-          
     пользуется ли   уже этот раздел памяти для других целей.  Правило          
     использования указателей простое:  указатель всегда должен  иметь          
     адрес до своего использования в программе.                                 
                                                                                
          Иными  словами,  не  присваивайте  целое  значение *iptr без          
     предварительного присвоения адреса в iptr.                                 
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 489,490 -
                                                                                
               Указатели и функции                                              
     -----------------------------------------------------------------          
                                                                                
          В прошлой главе мы объяснили,  как объявлять параметры функ-          
     ций. Возможно теперь вам более понятна причина использования ука-          
     зателей в качестве формальных параметров функции,  значения кото-          
     рых вы можете изменять.                                                    
                                                                                
          Рассмотрим, например, следующую функцию:                              
                                                                                
                  void swap(int *a, int *b)                                     
                  {                                                             
                      int temp;                                                 
                      temp = *a; *a = *b; *b =temp;                             
                  }                                                             
                                                                                
          Эта функция swap (обмен)  объявляет два формальных параметра          
     a и b,  как указатели на некие данные типа int. Это означает, что          
     функция swap работает с адресами целых переменных (а не с их зна-          
     чениями). Поэтому будут обработаны данные, адреса которых переда-          
     ны функции во время обращения к ней.                                       
                                                                                
                                                                                
          Далее представлена программа, вызывающая swap:                        
                                                                                
                  main()                                                        
                  {                                                             
                      int i,j;                                                  
                                                                                
                      i = 421;                                                  
                      j = 53;                                                   
                     printf("До обращения: i=%4d, j=%4d\n",i,j);                
                      swap(&i,&j);                                              
                     printf("После обращения: i =%4d, j=%4d\n",i,j);            
                  }                                                             
                                                                                
                                                                                
          Вы видите, что эта программа действительно заменяет значение          
     i на значение j (переставляет их местами).  Заменим эту программу          
     на аналогичную ей, раскрыв процедуру swap в теле программы:                
                                                                                
                                                                                
                  main()                                                        
                  {                                                             
                      int i,j;                                                  

                         - 491,492 -
                                                                                
                                                                                
                      int *a,*b,temp;                                           
                                                                                
                      i = 421;                                                  
                      j = 53;                                                   
                     printf("До обработки: i = %4d j = %4d\n",i,j);             
                      a = &i;                                                   
                      b = &j;                                                   
                      temp = *a; *a = *b; *b =temp;                             
                     printf("После обработки: i = %4d j = %4d\n",i,j);          
                  }                                                             
                                                                                
                                                                                
          Эта программа, конечно, приводит к тому же результату, что и          
     предыдущая, поскольку  не отличается от нее.  При вызове функции,          
     swap(&i,&j) значения двух фактических параметров (&i,&j) присваи-          
     ваются двум формальным параметрам (a и b),  обрабатываемым непос-          
     редственно операторами функции swap.                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Адресная арифметика                                              
     -----------------------------------------------------------------          
                                                                                
          Каким образом  вам необходимо поступить,  если вы хотите так          
     модифицировать программу,  чтобы iptr указывала на три переменных          
     типа int вместо одной? Далее представлено одно из возможных реше-          
     ний:                                                                       
                                                                                
                     #include <alloc.h>                                         
                     main()                                                     
                     {                                                          
                        #define NUMINTS 3                                       
                        int *list,i;                                            
                                                                                
                        list = (int *) calloc(NUMINTS,sizeof(int));             
                        *list = 421;                                            
                        *(list+1) = 53;                                         
                        *(list+2) = 1806;                                       
                        printf("Список адресов :");                             
                        for (i=0; i<NUMINTS; i++)                               
                              printf("%4p ",(list+i));                          
                        printf("\nСписок значений :");                          

                         - 493,494 -
                                                                                
                        for (i=0; i<NUMINTS; i++)                               
                              printf("%4p ",*(list+i));                         
                        printf("\n");                                           
                     }                                                          
                                                                                
                                                                                
          Вместо функции  malloc  эта  программа  использует   функцию          
     calloc c двумя параметрами:  первый показывает, для скольких эле-          
     ментов будет происходить резервирование памяти, второй - величину          
     каждого элемента в байтах. После обращения к функции calloc, list          
     указывает на участок памяти размером 6 (3*2)  байта,  достаточный          
     для хранения трех переменных типа int.                                     
                                                                                
          Более подробно  рассмотрим  следующие три оператора.  Первый          
     оператор вам знаком - *list = 421.  Он означает: "запомнить 421 в          
     переменной типа int,  расположенной по адресу , хранящемуся в пе-          
     ременной list".                                                            
                                                                                
          Следующий: *(list+1) = 53 - особенно важен для понимания. На          
     первый взгляд,   его можно интерпретировать так:  "запомнить 53 в          
     переменной типа int, расположенной байтом дальше адреса, храняще-          
     гося в list". Если это так, то вы окажетесь в середине предыдущей          
                                                                                
     int-переменной (которая имеет длину 2 байта).  Это,  естественно,          
     испортит ее значение.                                                      
                                                                                
          Однако, ваш компилятор с Си не сделает такой ошибки. Он "по-          
     нимает", что list - это указатель на тип int, и поэтому выражение          
     list+1 представляет  собой адрес байта,  определенного выражением          
     list+(1*sizeof(int)), и,  поэтому, значение 53 не испортит значе-          
     ния 421 (т.е. для этого значения будет выделена другая ячейка па-          
     мяти).                                                                     
                                                                                
          Аналогично,     (list+2)=1806    представляет    адрес байта          
     list+(2*sizeof(int))  и 1806 запоминается, не затрагивая два пре-          
     дыдущих значения.                                                          
                                                                                
          В  общем,   ptr+i  представляет  адрес  памяти, определяемый          
     выражением ptr+(i*sizeof(int)).                                            
                                                                                
          Введите и  выполните  вышеописанную  программу; на выходе вы          
     получите следующее:                                                        
                                                                                
                  Список адресов : 066A 06AC 06AE                               
                  Список значений:  421   53 1806                               

                         - 495,496 -
                                                                                
                                                                                
                                                                                
          Заметьте, что адреса различаются не в один байт,  а в два, и          
     все три значения хранятся отдельно.                                        
                                                                                
          Подведем итог:  Если вы  используете  ptr,  указатель на тип          
     type,    то   выражение   (ptr+1)   представляет   адрес   памяти          
     (ptr+(1*sizeof(type)),  где  sizeof(type)  возвращает  количество          
     байт, занимаемых переменной типа type.                                     
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Массивы                                                          
     -----------------------------------------------------------------          
                                                                                
          Большинство языков  высокого уровня - включая Си - позволяют          
     определять МАССИВЫ,  т.е. индексированный набор данных определен-          
     ного типа.    Используя  массив,  вы можете переписать предыдущую          
     программу следующим образом:                                               
                                                                                
                  main()                                                        
                  {                                                             
                        #define NUMINTS 3                                       
                        int list[NUMINTS],i;                                    
                                                                                
                        list[0] = 421;                                          
                        list[1] = 53;                                           
                        list[2] = 1806;                                         
                        printf("Список адресов:");                              
                        for(i=0; i<NUMINTS; i++)                                
                              printf("%p ",&list[i]);                           
                        printf("\nСписок значений:");                           
                        for (i=0; i<NUMINTS; i++)                               
                              printf("%4p ",list[i]);                           

                         - 497,498 -
                                                                                
                        printf("\n");                                           
                   }                                                            
                                                                                
          Выражение int  list[NUMINTS] объявляет list как массив пере-          
     менных типа int,  c объемом памяти, выделяемым для трех целых пе-          
     ременых.                                                                   
                                                                                
          К первой переменной массива можно обращаться  как к list[0],          
     второй - как к list[1] и третьей - как к list[2].                          
                                                                                
          В общем случае описание любого массива имеет следующий вид:           
                                                                                
                          type name[size]                                       
                        (тип  имя [размер])                                     
                                                                                
     где  type - тип данных элементов массива (любой из допустимых в            
                 языке),                                                        
          name - имя массива.                                                   
                                                                                
          Первый элемент массива - это name[0], последний элемент -             
     name[size-1]; общий объем памяти в байтах оперделяется выражением          
     size*(sizeof(type)).                                                       
                                                                                
               Массивы и указатели                                              
     -----------------------------------------------------------------          
                                                                                
          Вы, наверное, уже поняли , что существует определенная связь          
     между массивами и указателями.  Поэтому, если вы выполните только          
     что рассмотренную  программу,  полученный результат будет вам уже          
     знаком:                                                                    
                                                                                
                        список адресов : 163A 163C 163E                         
                        список значений:  421   53 1806                         
                                                                                
          Начальный адрес другой,  но это единственное различие. В са-          
     мом деле, имя массива можно использовать как указатель; более то-          
     го, вы можете определить указатель как массив. Рассмотрим следую-          
     щие важные тождества:                                                      
                                                                                
                        (list + i) == &(list[i])                                
                        *(list + i) == list[i]                                  
                                                                                
          В обоих случаях выражение слева эквивалентно выражению спра-          
     ва; и вы можете использовать одно вместо другого,  не принимая во          
     внимание, описан ли list как указатель, или как массив.                    

                         - 499,500 -
                                                                                
                                                                                
                                                                                
          Единственное различие между описанием list,как указателя или          
     как массива состоит в размещении самого массива.  Если вы описали          
     list как   массив,  то программа автоматически выделяет требуемый          
     объем памяти.  Если же вы описали переменную list как  указатель,          
     то вы сами обязательно должны выделить память под массив, исполь-          
     зуя для этого функцию calloc или сходную с ней функцию,   или  же          
     присвоить этой переменной адрес некоторого сегмента памяти, кото-          
     рый уже был определен ранее.                                               
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Массивы и строки                                                 
     -----------------------------------------------------------------          
                                                                                
          Мы говорили о строках в предыдущей главе  и  обращались  при          
     описании строк   к двум немного различным способам:  мы описывали          
     строку как указатель на символы и как массив символов.  Теперь вы          
     можете лучше понять это различие.                                          
                                                                                
          Если вы  описываете  строку как массив типа char,  то память          
     для этой строки резервируется автоматически. Если же вы описывае-          
     те строку как указатель на тип данных char, то память не резерви-          
     руется: вы должны либо сами выделить ее (используя функцию malloc          
     или ей подобную),  или же присвоить ей адрес существующей строки.          
     Пример этой ситуации дается далее в разделе "Ловушки программиро-          
     вания на Си" этой главы.                                                   
                                                                                
                                                                                
                                                                                
          Многомерные массивы                                                   
     -----------------------------------------------------------------          
                                                                                
          Да, вы  действительно можете использовать многомерные масси-          

                         - 501,502 -
                                                                                
     вы, и они описываются именно так, как вы себе и представляли:              
                                                                                
                   type name[size1][size2]...[sizeN]                            
                (тип имя [размер1][размер2]...[размерN])                        
                                                                                
          Рассморим следующую программу,  которая определяет два  дву-          
     мерных массива, а затем выполняет их матричное умножение:                  
                                                                                
                  main()                                                        
                  {                                                             
                     int a[3][4] = {{ 5,  3, -21, 42},                          
                                    {44, 15,   0,  6},                          
                                    {97 , 6,  81,  2}};                         
                     int b[4][2] = {{22,   7},                                  
                                    {97, -53},                                  
                                    {45,   0},                                  
                                    {72,   1} };                                
                     int c[3][2],i,j,k;                                         
                                                                                
                     for (i=0; i<3; i++) {                                      
                         for (j=0; j<2; j++) {                                  
                             c[i][j] = 0;                                       
                                                                                
                             for (k=0; k<4; k++)                                
                                 c[i][j] += a[i][k] * b[k][j];                  
                         }                                                      
                     }                                                          
                     for (i=0; i<3; i++) {                                      
                         for (j=0; j<2; j++)                                    
                             printf("c[%d][%d] = %d ",i,j,c[i][j]);             
                         printf("\n");                                          
                     }                                                          
                  }                                                             
                                                                                
          Отметим два момента в этой программе.  Синтаксис определения          
     двумерного массива состоит из набора {...} списков,   разделенных          
     запятой. Квадратные  скобки ([ ]) используются для записи каждого          
     индекса.                                                                   
                                                                                
          Некоторые языки для определения массивов используют  синтак-          
     сис [i,j]. Так можно написать и на Си, но это все равно, что ска-          
     зать просто [j],  т.к. запятая интерпретируется как оператор, оз-          
     начающий ("   определить i,  затем определить j,  затем присвоить          
     всему выражению значение j").                                              
                                                                                

                         - 503,504 -
                                                                                
          Для  полной  уверенности  ставьте  квадратные  скобки вокруг          
     каждого индекса.                                                           
                                                                                
          Многомерные массивы  хранятся в памяти слева направо по пра-          
     вилу "строки - столбцы". Это означает, что последний индекс изме-          
     няется быстрее. Другими словами, в массиве arr[3][2] элементы arr          
     хранятся в памяти в следующем порядке:                                     
                                                                                
                  arr[0][0]                                                     
                  arr[0][1]                                                     
                  arr[1][0]                                                     
                  arr[1][1]                                                     
                  arr[2][0]                                                     
                  arr[2][1]                                                     
                                                                                
          Тот  же  принцип  сохраняется  для  массивов  двух-, трех- и          
     большей размерности.                                                       
                                                                                
                                                                                
                                                                                
          Массивы и функции                                                     
     -----------------------------------------------------------------          
                                                                                
                                                                                
          Что произойдет,  если вы захотите передать массив в функцию?          
     Рассмотрим следующую   функцию,  возвращающую индекс минимального          
     числа массива int:                                                         
                                                                                
                  int imin(int list[], int size)                                
                  {                                                             
                     int i, minindx, min;                                       
                                                                                
                     minindx = 0;                                               
                     min = list[minindx];                                       
                     for (i = 1; i < size; i++)                                 
                         if (list[i] < min) {                                   
                             min = list[i];                                     
                             minindx = i;                                       
                         }                                                      
                     return(minindx);                                           
                  }                                                             
                                                                                
          Здесь вы видите одну из важных особенностей Си: вам необяза-          
     тельно знать при трансляции величину list[].  Почему?  Потому что          
     компилятор считает list[] начальным адресом массива,  и не  забо-          

                         - 505,506 -
                                                                                
     тится о том, где его конец.                                                
                                                                                
          Программа, обращающаяся к функции imin, может выглядеть так:          
                                                                                
             main()                                                             
             {                                                                  
                #define VSIZE 22                                                
                int i,vector[VSIZE];                                            
                                                                                
                for (i = 0; i < VSIZE; i++) {                                   
                    vector[i] = rand();                                         
                    printf("vector[%2d] = %6d\n",i,vector[i]);                  
                }                                                               
                i = imin(vector,VSIZE);                                         
                printf("minimum: vector[%2d] = %6d\n",i,vector[i]);             
             }                                                                  
                                                                                
          Может возникнуть вопрос:  что именно передается в  imin?   В          
     функцию imin передается начальный адрес массива vector. Это озна-          
     чает, что если вы производите какие-либо изменения массива list в          
     imin то,    те же изменения будут произведены и в массиве vector.          
     Например, вы можете написать следующую функцию :                           
                                                                                
                                                                                
             void setrand(int list[],int size);                                 
             {                                                                  
                int i;                                                          
                for (i = 0; i < size; i++) list[i] = rand();                    
             }                                                                  
                                                                                
          Теперь для инициализации массива vector вы можете написать в          
     main setrand(vector,VSIZE).  Следует заметить, что массиву vector          
     будут присвыоены некие случайные числа,   являющиеся  результатом          
     работы датчика   случайных чисел,  эмулируемого функцией Турбо Си          
     rand().                                                                    
                                                                                
          А как передавать многомерный массив?  Имеется ли такая  воз-          
     можность? Предположим, вы хотите модифицировать setrand для рабо-          
     ты с двумерным массивом. Вы должны написать приблизительно следу-          
     ющее:                                                                      
                                                                                
             void setrand(int matrix[][CSIZE],int rsize)                        
             {                                                                  
                int i,j;                                                        
                for (i = 0; i < rsize; i++) {                                   

                         - 507,508 -
                                                                                
                    for (j = 0; j < CSIZE; i++)                                 
                        matrix[i][j] = rand();                                  
                }                                                               
             }                                                                  
                                                                                
          Где CSIZE - это глобальная константа,   определяющая  второе          
     измерение массива.  Другими словами,  любой массив,  передаваемый          
     setrand получит второе измерение массива, равный CSIZE.                    
                                                                                
          Однако, есть еще одно решение.  Предположим, у вас есть мас-          
     сив matrix[15,7],  который вы хотите передать в setrand.  Если вы          
     используете следующее описание:                                            
                                                                                
                        setrand(int list[],int size)                            
                                                                                
     обращение к функции будет иметь вид:                                       
                                                                                
                           setrand(matrix,15*7);                                
                                                                                
          Массив matrix будет рассматриваться функцией setrand как од-          
     номерный массив,    содержащий 105 элементов (15 строк * 7 столб-          
     цов), с которым будут произведены необходимые вам действия.                
                                                                                
     Структуры                                                                  
     -----------------------------------------------------------------          
                                                                                
          Массивы и указатели позволяют вам создавать список элементов          
     одного типа. А что, если вы хотите создать нечто, содержащее эле-          
     менты различного типа? Для этого используются СТРУКТУРЫ.                   
                                                                                
          Структура - это конгломерат элементов различного типа.   До-          
     пустим, вы хотите сохранить информацию о звезде:  ее имя,  спект-          
     ральный класс, координаты и прочее. Вы можете описать это следую-          
     щим образом:                                                               
                                                                                
                  typedef struct {                                              
                     char   name[25];                                           
                     char   class;                                              
                     short  subclass;                                           
                     float  decl,RA,dist;                                       
                  } star ;                                                      
                                                                                
          Здесь определена структура (struct)  типа star. Сделав такое          
     описание в  начале своей програмы,  вы можете дальше использовать          
     этот определенный вами тип данных:                                         

                         - 509,510 -
                                                                                
                                                                                
                                                                                
                  main()                                                        
                  {                                                             
                     star mystar;                                               
                                                                                
                     strcpy(mystar.name,"Эпсилон Лебедя");                      
                     mystar.class    = 'N';                                     
                     mystar.subclass =  2;                                      
                     mystar.decl     =  3.5167;                                 
                     mystar.RA       = -9.633;                                  
                     mystar.dist     =  0.303;                                  
                                                                                
                     /* конец функции main() */                                 
                  }                                                             
                                                                                
          Вы обращаетесь  к каждому элементу структуры,  используя его          
     составное имя,  состоящее из имени структуры (на первом месте) и,          
     в порядке иерархической подчиненности, имен ее образующих элемен-          
     тов, разделенных  точками (.).  Конструкция вида: varname.memname          
     (имя переменной.имя элемента) считается эквивалентной имени пере-          
     менной того же типа,  что и memname,  и вы можете выполнять с ней          
                                                                                
                                                                                
     те же операции.                                                            
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 511,512 -
                                                                                
               Структуры и указатели                                            
     -----------------------------------------------------------------          
                                                                                
          Вы можете описывать указатели на структуры точно так же, как          
     и  указатели на другие типы  данных.  Это необходимо для создания          
     связных списков и других динамических структур  данных элементами          
     которых, в свою очередь, являются структуры данных.                        
                                                                                
          Фактически указатели на структуры так часто  используются  в          
     Си, что    существует  специальный  символ  для ссылки на элемент          
     структуры, аресованной  указателем.  Рассмотрим следующий вариант          
     предыдущей программы:                                                      
                                                                                
                  #include <alloc.h>                                            
                  main()                                                        
                  {                                                             
                     star *mystar;                                              
                                                                                
                     mystar = (star *) malloc(sizeof(star));                    
                     strcpy(mystar -> name,"Эпсилон Лебедя");                   
                     mystar -> class    = 'N';                                  
                     mystar -> subclass =  2;                                   
                                                                                
                                                                                
                     mystar -> decl     =  3.5167;                              
                     mystar -> RA       = -9.633;                               
                     mystar -> dist     =  0.303;                               
                                                                                
                     /* Конец функции main() */                                 
                  }                                                             
                                                                                
                                                                                
          В этом варианте mystar объявляется как указатель типа  star,          
     а не   как переменная типа star.  Память для mystar резервируется          
     путем обращения к функции malloc.  ТЕПЕРЬ, КОГДА ВЫ ССЫЛАЕТЕСЬ НА          
     ЭЛЕМЕНТЫ mystar,  ИСПОЛЬЗУЙТЕ ptrname -> memnane. Символ -> озна-          
     чает, что  "элемент структуры направлен в ...";  это  сокращенный          
     вариант от обозначения (*ptrname).memnane принятый в Си.                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 513,514 -
                                                                                
               Оператор switch (переключатель)                                  
     -----------------------------------------------------------------          
                                                                                
          Часто бывает необходимо построить длинные конструкции типа            
     if..else if..else и т.д. Рассмотрим следующую функцию:                     
                                                                                
                  #include <ctype.h>                                            
                                                                                
                  do_main_menu(short *done)                                     
                  {                                                             
                                                                                
                      char cmd;                                                 
                                                                                
                      *done = 0;                                                
                      do {                                                      
                          cmd = toupper(getch());                               
                          if (cmd == 'F') do_file_menu(done);                   
                          else if (cmd == 'R') run_program();                   
                          else if (cmd == 'C') do_compile();                    
                          else if (cmd == 'M') do_make();                       
                          else if (cmd == '?') do_project_menu();               
                          else if (cmd == 'O') do_option_menu();                
                                                                                
                          else if (cmd == 'E') do_error_menu();                 
                          else handle_others(cmd,done);                         
                      } while (!*done);                                         
                  }                                                             
                                                                                
          Подобная ситуация встречается настолько часто, что в Си была          
     была введена специальная управляющая структура которая носит наз-          
     вание оператор switch. Вот та же функция, но записанная с исполь-          
     зованием оператора switch :                                                
                                                                                
                  #include <ctype.h>                                            
                                                                                
                  do_main_menu(short *done)                                     
                  {                                                             
                                                                                
                      char cmd;                                                 
                                                                                
                      *done = 0;                                                
                      do {                                                      
                          cmd = toupper(getch());                               
                          switch(cmd) {                                         
                              case 'F' : do_file_menu(done); break;             

                         - 515,516 -
                                                                                
                              case 'R' : run_program(); break;                  
                              case 'C' : do_compile(); break;                   
                              case 'M' : do_make(); break;                      
                              case '?' : do_project_menu(); break;              
                              case 'O' : do_option_menu(); break;               
                              case 'E' : do_error_menu(); break;                
                              default  : handle_others(cmd,done);               
                      } while (!*done);                                         
                  }                                                             
                                                                                
          Эта функция организует  цикл,  в котором символ считывается,          
     преобразуется к значению на верхнем регистре, а затем запоминает-          
     ся  в  переменной  cmd.  Потом   введенный  символ обрабатывается          
     оператором switch на основе значения cmd.                                  
                                                                                
          Цикл повторяется до тех пор,  пока переменная done не станет          
     равной нулю   (предположительно  в   функции   do_file_menu   или          
     handle_others).                                                            
                                                                                
          Оператор switch  получает  значение  cmd  и сравнивает его с          
     каждым значением метки case.  Если они совпадают,  начинается вы-          
     полнение операторов   данной метки,  которое продолжается либо до          
                                                                                
     ближайшего оператора break,  либо до конца оператора switch. Если          
     ни одна из меток не совпадает, и вы включили метку default в опе-          
     ратор switch,  то будут выполняться операторы  этой  метки;  если          
     метки default нет, оператор switch целиком игнорируется.                   
                                                                                
          Значение value,   используемое  в switch(value)  должно быть          
     приведено к целому значению. Другими словами, это значение должно          
     легко преобразовываться  в целое для таких типов данных как char,          
     разновидности enum и,  конечно,  int, а также всех его вариантов.          
     Нельзя использовать   в операторе switch вещественные типы данных          
     (такие как float и double),  указатели, строки и другие структуры          
     данных, но разрешается использовать элементы структур данных сов-          
     местимых с целыми значениями.                                              
                                                                                
          Хотя (value)  может быть выражением (константа,  переменная,          
     вызов функции,  и другие комбинации их), метки case должны содер-          
     жать константы.  Кроме того,  в качестве ключевого значения  case          
     может быть только одно значение.  Если бы do_main_menu не исполь-          
     зовало фукцию toupper для преобразования cmd, оператор switch мог          
     бы выглядеть следующим образом:                                            
                                                                                
                  switch (cmd) {                                                

                         - 517,518 -
                                                                                
                      case 'f' :                                                
                      case 'F' : do_file_menu(done);                            
                           break;                                               
                      case 'r' :                                                
                      case 'R' : run_program();                                 
                           break;                                               
                      ...                                                       
                                                                                
          Этот оператор выполняет функцию do_file_menu  независимо  от          
     того, в  каком регистре поступает значение cmd, аналогично выпол-          
     няются действия для других альтернатив значения cmd.                       
                                                                                
          Запомните, что для завершения данного case вы должны исполь-          
     зовать оператор break . В противном случае будут выполняться пос-          
     ледовательно все операторы,  относящиеся к другим меткам (до  тех          
     пор пока не встретится оператор break).                                    
                                                                                
          Если вы уберете оператор break после вызова do_file_menu, то          
     при вводе символа F будет вызываться do_file_menu,  а затем будет          
     вызвана функция run_program.                                               
                                                                                
          Однако  иногда  вам  нужно  сделать  именно  так. Рассмотрим          
                                                                                
     следующий пример:                                                          
                                                                                
          typedef enum( sun, mon, tues, wed, thur, fri, sat, ) days;            
                                                                                
          main()                                                                
          {                                                                     
              days today;                                                       
                                                                                
              ...                                                               
              swith (today) {                                                   
                                                                                
                  case mon  :                                                   
                  case tues :                                                   
                  case wed  :                                                   
                  case thur :                                                   
                  case fri  : puts("Иди работать!");break;                      
                  case sat  : printf("Убери во дворе и ");                      
                  case sun  : puts("Расслабься!");                              
          }                                                                     
                                                                                
          В этом операторе switch для значений от mon до fri  выполня-          
     ется одна и та же функции put,  после которой оператор break ука-          

                         - 519,520 -
                                                                                
                                                                                
     зывает на выход из switch. Однако, если today равно sat, выполня-          
     ется соответствующая   функция  printf,  а затем выполняется puts          
     ("Расслабься!"); если же today равно sun, выполняется только пос-          
     ледняя функция puts.                                                       
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Команды передачи управления                                      
     ----------------------------------------------------------------           
                                                                                
          Это дополнительные  команды, предназначенные для использова-          
     ния в управляющих операторах или для моделирования других  управ-          
     ляющих структур.  Оператор return позволяет вам досрочно выйти из          
     функции. Операторы break и continue предназначены для использова-          
     ния в цикле и позволяют пропустить последующие операторы програм-          
     мы. Условный  оператор (?:) позволят сжать определенные выражения          
     типа if..else в одну строку.                                               
                                                                                
          Один совет: подумайте дважды перед использованием каждой ко-          
     манды передачи управления (за исключением,  конечно, return). Ис-          
     пользуйте их в тех случаях,  когда они представляют наилучшее ре-          
     шение, но  помните,  что чаще всего вы  можете  решить  возникшую          
     перед вами   проблему проблему без их помощи.  Особенно избегайте          
     оператора goto:  операторы return,  break или continue  наверняка          
     заменят его вам.                                                           
                                                                                
                                                                                
                                                                                
                                                                                

                         - 521,522 -
                                                                                
               Оператор return                                                  
     -----------------------------------------------------------------          
                                                                                
          Существует  два  основных   способа  использования оператора          
     return.                                                                    
                                                                                
          Во-первыx, в том случае,  когда функция возвращает значение,          
     и вам   необходимо использовать его в зависимости от того,  какое          
     значение возвращается в вызыващую программу, например:                     
                                                                                
                   int  imax(int a, int b);                                     
                   {                                                            
                     if (a > b) return(a);                                      
                     else       return(b);                                      
                   }                                                            
                                                                                
          Здесь функция использует  оператор  return  для  возвращения          
     максимального из двуx переданныx ей значений.                              
                                                                                
          Второй способ использования оператора return  состоит в воз-          
     можности выxода  из функции  в некоторой точке до  ее завершения.          
     Например,  функция может определить условие, по которому произво-          
                                                                                
     дится прерывание. Вместо того, чтобы помещать все основные опера-          
     торы функции внутрь оператора if,  для  выхода можно использовать          
     оператор return.  Если функция имеет тип VOID (т.е. не возвращаю-          
     щает никакого значения),  можно написать return без возвращаемого          
     значения.                                                                  
                                                                                
          Рассмотрим модификацию программы imin, предложенную ранее:            
                                                                                
                   int imin(int list[], int size))                              
                   {                                                            
                     int i, minindx, min;                                       
                                                                                
                     if (size <= 0) return(-1);                                 
                     ...                                                        
                   }                                                            
                                                                                
           В этом примере,  если параметр size меньше либо равен нулю,          
     то массив list пуст, в связи с чем оператор return вызывает выход          
     из функции.                                                                
                                                                                
           Заметим, что в случае ошибки возвращается значение -1. Т.к.          
     -1  никогда не может быть индексом  массива, вызывающая программа          

                         - 523,524 -
                                                                                
                                                                                
     регистрирует факт возникновения ошибки.                                    
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Оператор break                                                   
     -----------------------------------------------------------------          
                                                                                
          Иногда бывает  необходимо выйти из цикла  до его завершения.          
     Рассмотрим следующую программу:                                            
                                                                                
                                                                                
              #define LIMIT 100                                                 
              #define MAX  10                                                   
              main()                                                            
              {                                                                 
                int i,j,k,score;                                                
                int scores[LIMIT][MAX];                                         
                                                                                
                for (i = 0; i < LIMIT; i++) {                                   
                        j = 0;                                                  
                        while (j < MAX-1) {                                     
                         printf("Введите следующее значение #%d: ",j);          
                                scanf("%d", score);                             
                                if (score < 0)                                  
                                       break;                                   
                                scores[i][++j] = score;                         

                         - 525,526 -
                                                                                
                        }                                                       
                        scores[i][0] = j;                                       
                }                                                               
              }                                                                 
                                                                                
          Рассмотрим оператор if (score < 0) break;. Он указывает, что          
     если пользователь введет отрицательное значение score, цикл while          
     прерывается. Переменная  j  используется  и  в  качестве  индекса          
     scores и в качестве счетчика общего количества элементов в каждой          
     строке; это значение записывается в первом элементе строки.                
                                                                                
          Вспомните, пожалуйста,  использование оператора break в опе-          
     раторе switch, представленное ранее. Там break указывает програм-          
     ме выйти из оператора switch; здесь он указывает программе  выйти          
     из цикла   и  продолжить работу.  Кроме оператора switch оператор          
     break может быть использован во всех трех циклах (for, while и do          
     ... while),   однако его нельзя использовать в конструкции if ...          
     else или в теле главной процедуры main для выхода из нее.                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Оператор continue                                                
     ----------------------------------------------------------------           
                                                                                
          Иногда нужно не выходить из цикла, а пропустить ряд операто-          
     ров в теле цикла и начать его заново.  В этом случае можно приме-          
     нить оператор continue, предназначенный специально для этого. Об-          
     ратите внимание на следующую программу:                                    
                                                                                
                   #define LIMIT 100                                            
                   #define MAX  10                                              
                   main()                                                       
                   {                                                            
                     int i,j,k,score;                                           
                     int scores[LIMIT][MAX];                                    
                                                                                
                     for (i = 0; i < LIMIT; i++) (                              
                             j = 0;                                             
                             while (j < MAX-1) (                                
                         printf("Введите следующее значение #%d: ",j);          
                                scanf("%d", score);                             
                                if (score < 0)                                  
                                        continue;                               

                         - 527,528 -
                                                                                
                                                                                
                                scores[i][++j] = score;                         
                             )                                                  
                             scores[i][0] = j;                                  
                     )                                                          
                   }                                                            
                                                                                
          Когда выполняется  оператор  continue,  программа пропускает          
     остаток цикла и начинает цикл сначала. В результате эта программа          
     работает иначе,  чем предыдущая. При вводе пользователем числа -1          
     считатся что была сделана ошибка,  и вместо выхода из внутреннего          
     цикла цикл while начинается сначала. Поскольку значение j не было          
     увеличено, программа снова просит ввести то же значение.                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Оператор goto                                                    
     -----------------------------------------------------------------          
                                                                                
          Да, в Си действительно есть оператор goto.  Формат  простой:          
     goto метка,  где "метка" - любой идентификатор, связанный с опре-          
     деленным выражением.  Однако наиболее разумное решение при  прог-          
     раммировании на   Си - обойтись без использования оператора goto.          
     Для этого предусмотрено три оператора цикла. Подумайте вниматель-          
     но, прежде   чем использовать оператор goto,  действительно ли он          
     вам нужен в создавшейся ситуации и может быть его можно  заменить          
     на оператор цикла?.                                                        
                                                                                
                                                                                
                                                                                
          Условный оператор (?:)                                                
     -----------------------------------------------------------------          
                                                                                
          В некоторых  случаях необходимо произвести выбор между двумя          
     альтернативами (и результирующими значениями),  основанный на не-          
     котором условии.  Обычно это реализуется оператором if ...  else,          
     например, так:                                                             
                                                                                

                         - 529,530 -
                                                                                
                   int imin(int a, int b)                                       
                   (                                                            
                     if (a < b) return(a);                                      
                     else       return(b);                                      
                   )                                                            
                                                                                
          Но, как оказывается,  для реализации такого типа выбора дос-          
     таточно одной специальной конструкции. Ее формат следующий:                
                                                                                
                выражение 1 ? выражение 2 : выражение 3.                        
                                                                                
          А смысл таков: "если выражение 1 верно, то вычисляется выра-          
     жение 2 и все выражение получает его значение; иначе  вычисляется          
     выражение 3  и передается его значение".  Используя эту конструк-          
     цию, imin можно представить следующим образом:                             
                                                                                
                   int imin(int a, int b)                                       
                   (                                                            
                     return((a < b) ? a : b );                                  
                   )                                                            
                                                                                
          более того,можно даже записать imin как строку макроса:               
                                                                                
                                                                                
                                                                                
                   #define imin(a,b) ((a < b) ? a : b)                          
                                                                                
          Теперь, где   бы   ваша  программа  ни  встретила  выражение          
     imin(e1,e2), она замещает его на ((e1<e2) ? e1 : e2) и продолжает          
     вычисления. Это   в действительности наиболее общее решение,  так          
     как a и b больше не ограничены типом int; они могут  быть  любого          
     типа, с которым можно выполнить операцию сравнения.                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 531,532 -
                                                                                
               Потоки и поток ввода - вывода                                    
     -----------------------------------------------------------------          
                                                                                
          Что такое потоки?                                                     
     -----------------------------------------------------------------          
                                                                                
          Потоки - это наиболее переносимые средства  для  чтения  или          
     записи  данных  в Турбо Си.  Они позволяют разрабатывать гибкий и          
     эффективный ввод-вывод, который не зависит от используемых файлов          
     или встроенного оборудования.                                              
                                                                                
          Поток является  файлом или физическим устройством (принтером          
     или монитором,  например), которым вы управляете с помощью указа-          
     телей на объект FILE (определенный в stdio.h). Объект FILE содер-          
     жит различную информацию о потоке,  включая текущую позицию пото-          
     ка,  указателм  на соответствующие буферы и индикаторы ошибки или          
     конца файла.                                                               
                                                                                
          Ваша программа никогда не может саздавать и  копировать  не-          
     посредственно объекты FILE; однако, она может использовать указа-          
     тели, возвращенные из функций типа fopen. Убедитесь, что нет про-          
     тиворечия между  указателями FILE и файловым управлением DOS (при          
                                                                                
     использовании DOS низкого уровня или UNIX совместимого  ввода-вы-          
     вода).                                                                     
                                                                                
          Вы должны открыть поток перед тем, как вы будете производить          
     ввод-вывод в него.  Открытый поток связывается с названным в  DOS          
     файлом или устройством.  Программы, которые открывают потоки, это          
     fopen,  fdopen и freopen. Когда вы открываете поток, вы указывае-          
     те, хотите ли вы читать или записывать в поток, или делать и то и          
     другое. Вы должны также указать, будете ли вы обращатся с данными          
     из потока как с текстом или как с двоичными данными.  Это послед-          
     нее указание важно для уменьшения несовместимости  между потоками          
     ввода-вывода Си и текстовым файлом DOS.                                    
                                                                                
                                                                                
                                                                                
          Текстовые и двоичные потоки                                           
     -----------------------------------------------------------------          
                                                                                
          Текстовые потоки  используются  для обычных текстовых файлов          
     DOS,  таких как файл,  созданный редактором Турбо Си.  Поток вво-          
     да-вывода Си предполагает, что текстовый файл разделен на строки,          
     отделенные с помощью одного символа новой строки (которым являет-          

                         - 533,534 -
                                                                                
     ся ASCII символ перевода строки). Текстовый файл DOS, однако, за-          
     писывается на диск с двумя символами между каждой строкой - ASCII          
     символами  возврат  каретки и перевод строки.  В текстовом режиме          
     Турбо Си преобразует пару возврат каретки/перевод  строки (CR/LF)          
     в один символ перевод строки при вводе; перевод строки преобразу-          
     ется в пару CR/LF при выводе.                                              
                                                                                
          Двоичный поток значительно  проще,  чем  текстовый.  Никаких          
     преобразований не производится.  Любые символы читаются и записы-          
     ваются без изменений.                                                      
                                                                                
          Файл может быть объявлен и в текстовом и в  двоичном  режиме          
     без всяких проблем,  если вы осведомлены и понимаете преобразова-          
     ния, имеющие место в текстовом потоке.  Турбо Си не "запоминает",          
     как файл был создан или модифицирован.                                     
                                                                                
          Если режим преобразования не указывается, когда поток откры-          
     вается, то он открывается по умолчанию,  определяемому в глобаль-          
     ной переменной _fmode. По умолчанию _fmode настроена на текстовый          
     режим.                                                                     
                                                                                
                                                                                
                                                                                
                                                                                
          Буферизация потоков                                                   
     -----------------------------------------------------------------          
                                                                                
          Потоки, связанные с файлами, обычно буферизируются. Это поз-          
     воляет  очень  быстро вводить или выводить одиночные символы так,          
     как это делают getc и putc. Вы можете создать ваш собственный бу-          
     фер, изменить размер используемого буфера, или заставить поток не          
     использовать буфер с помощью вызова setvbuf или setbuf.                    
                                                                                
          Буфер автоматически очищается при его заполнении, при созда-          
     нии потока  и при нормальном завершении программы.  Вы можете ис-          
     пользовать fflush и flushall для очистки буфера.                           
                                                                                
          Обычно, вы используете потоки для  чтения  и  записи  данных          
     последовательно.  Ввод-вывод располагается в текущей позиции фай-          
     ла. Когда вы записываете или считываете данные, программа переме-          
     щает  файловую  позицию непосредственно за обработанными данными.          
     Поток, который связан с дисковым файлом, может быть также потоком          
     произвольного доступа.  Вы можете использовать fseek для позицио-          
     нирования файла, а затем результатом выполнения операторов чтения          
     или записи будет доступ к данным после этой точки.                         

                         - 535,536 -
                                                                                
                                                                                
                                                                                
          Если вы  одновременно записываете и считываете данные из по-          
     тока, то вы не можете свободно смешивать операторы чтения и запи-          
     си.  Вы должны очистить буфер потока между записью и чтением. Вы-          
     зов fflush, flushall или fseek очищает буфер и позволяет вам сме-          
     нить  операции.  Для максимальной переносимости вы должны очищать          
     буфер, даже если он не используется, так как другие системы могут          
     иметь дополнительные ограничения на смешивание операций ввода-вы-          
     вода даже без буфера.                                                      
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Предопределенные потоки                                          
     -----------------------------------------------------------------          
                                                                                
          В дополнение к потокам, создоваемым вызовом fopen, пять пре-          
     допределенных потоков доступны всякий раз,  когда ваша  программа          
     начинает исполнятся.                                                       
                                                                                
          -------------------------------------------------------               
            Имя     ввод-вывод       Режим         Поток                        
          -------------------------------------------------------               
          stdin      ввод          Текстовый   Стандартный ввод                 
          stdout     вывод         Текстовый   Стандартный вывод                
          stderr     вывод         Текстовый   Стандартная ошибка               
          stdaux     ввод-вывод    Двоичный    Вспом. ввод-вывод                
          stdprn     вывод         Двоичный    Принтерный вывод                 
          -------------------------------------------------------               
                                                                                
          Потоки stdaux и stdprn специфичны для DOS и не переносимы на          
     другие системы.                                                            
                                                                                
          Потоки stdin и stdout могут быть перенаправлены  DOS,  в  то          
     время как другие связаны с особыми устройствами:  stderr - с кон-          

                         - 537,538 -
                                                                                
                                                                                
     солью (CON:),  stdprn - с принтером (PRN:), а stdaux - со вспомо-          
     гательным портом.                                                          
                                                                                
          Вспомогательный порт  зависит  от конфигурации вашей машины;          
     обычно это COM1:.  Посмотрите в документации вашей DOS о перенап-          
     равлении ввода и вывода в командной строке DOS. Без перенаправле-          
     ния потоки stdin и stdout связаны с консолью (CON:).  Кроме того,          
     если нет перенаправления,  stdin имеет строку буфера, а stdout не          
     буферизируется. Другие предопределенные потоки тоже не  буферизи-          
     руются.                                                                    
                                                                                
          Для установки  предопределенного  потока в режим отличный от          
     режима по умолчанию (например,  для установки stdprn в  текстовый          
     режим) используйте setmode. Имя предопределенного потока является          
     константой и вы не можете присваивать ему значения. Если вы хоти-          
     те связать один из этих потоков с файлом или устройством,  то ис-          
     пользуйте freopen.                                                         
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
          Программирование на Си: классический и современный стили              
     ----------------------------------------------------------------           
                                                                                
          В программировании  на Си существует несколько общераспрост-          
     раненных тенденций,  объединяющих известные  технические  приемы,          
     облегчающие использование Си. Многие из этих тенденций противоре-          
     чат классическим традициям  и  методам  программирования  на  Си.          
     Большинство из них стали возможны благодаря расширению языка ANSI          
     C Standart Committee.  Этот раздел ознакомит вас с приемами,  ис-          
     пользуемыми ранее и новыми стандартами, которые помогут вам в на-          
     писании более удобных программ на Си.                                      
                                                                                
          Турбо Си  позволяет следовать наравне классическому и совре-          
     менному стилям.                                                            
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 539,540 -
                                                                                
          Использование прототипов функций                                      
          и полных определений функций                                          
     -----------------------------------------------------------------          
                                                                                
          В классическом стиле программирования на Си  вы  определяете          
     функцию, специфицируя имя и тип возвращаемого результата.                  
                                                                                
          Например, вы определяете функцию swap следующим образом:              
                                                                                
                  int swap();                                                   
                                                                                
          Никакой информации  о  параметрах не передается:  ни о коли-          
     честве их,  ни о типе.  Классическое определение функции выглядит          
     так:                                                                       
                                                                                
                  int swap(a,b)                                                 
                  int *a, *b;                                                   
                  {                                                             
                /* Тело функции */                                              
                  }                                                             
                                                                                
          Результат такого определения - отсутствие контроля над ошиб-          
                                                                                
     ками при использовании параметров,  что приводит к появлению хит-          
     рых и труднообнаружимых ошибок.                                            
                                                                                
          Избегайте такого стиля.                                               
                                                                                
          Современный стиль  включает использование прототипов функций          
     (для описания функций) и списка параметров (для определения функ-          
     ций). Давайте переопределим swap, используя прототипы:                     
                                                                                
                  int swap(int *a, int *b);                                     
                                                                                
          Теперь при  выполнении ваша программа получает всю необходи-          
     мую информацию,  требуемую для выполнения контроля  над  ошибками          
     при любом обращении к swap. Теперь вы можете использовать простой          
     формат и при определении функции:                                          
                                                                                
                  int swap(int *a, int *b)                                      
                  {                                                             
                     /* тело функции */                                         
                  }                                                             
                                                                                
          Современный стиль  программирования повышает вероятность об-          

                         - 541,542 -
                                                                                
     наружения ошибки, даже если вы не используете прототипов функций;          
     если же вы используете прототипы, то компилятор автоматически от-          
     слеживает и обеспечивает соответствие описаний и определений.              
                                                                                
                                                                                
                                                                                
          Использование ключевого слова enum                                    
     -----------------------------------------------------------------          
                                                                                
          В классическом   языке  Си  списки  определяются  директивой          
     #define следующим образом:                                                 
                                                                                
                                                                                
                  #define sun  0                                                
                  #define mon  1                                                
                  #define tues 2                                                
                  #define wed  3                                                
                  #define thur 4                                                
                  #define fri  5                                                
                  #define sat  6                                                
                                                                                
           Однако в нашей версии Си введен так называемый перечислимый          
                                                                                
     тип данных, который вы можете объявить с помощьдю ключевого слова          
     enum, как это показано далее:                                              
                                                                                
             typedef enum(sun,mon,tues,wed,thur,fri,sat) days;                  
                                                                                
          Результат здесь тот же, что и в классическом методе: присво-          
     ение осуществляется   в  порядке возрастания значений от sun=0 до          
     sat = 6. Однако современный метод позволяет представлять информа-          
     цию более абстрактно и содержательно, чем длинный список директив          
     #define. Кроме  того, вы можете описать переменные принадлежащими          
     к абстрактному типу данных days.                                           
                                                                                
                                                                                
                                                                                
          Использование директивы typedef                                       
     -----------------------------------------------------------------          
                                                                                
          В классическом  Си  определенные  пользователем  типы данных          
     именуются редко,  за исключением структур и объединений  -  перед          
     любым объявлением   которых  вы ставите ключевые слова struct или          
     union.                                                                     
                                                                                

                         - 543,544 -
                                                                                
          В современом Си обеспечивается другой уровень информационной          
     содержательности путем использования директивы typedef.  Она поз-          
     воляет связать нужный тип данных (включая struct и enum)  с неко-          
     торым именем, а затем объявить переменые этого типа. Далее предс-          
     тавлен пример определения типа  и  определение  переменных  этого          
     нового, введенного пользователем, типа данных:                             
                                                                                
                  typedef int *intptr;                                          
                  typedef char namestr[30];                                     
                  typedef enum ( male, female, unknown) sex;                    
                  typedef struct (                                              
                      namestr  last, first;                                     
                      char     ssn[9];                                          
                      sex      gender;                                          
                      short    age;                                             
                      float    gpa;                                             
                  ) student;                                                    
                  typedef student class[100];                                   
                                                                                
                  class   hist104,ps102;                                        
                  student valedictorian;                                        
                  intptr  iptr;                                                 
                                                                                
                                                                                
          Использование typedef делает программу более читабельной,  а          
     также позволяет вам не ограничиваться  одним  участком  программы          
     для определения типов данных,  а распространить их определение на          
     всю программу по мере их появления и использования в ней.                  
                                                                                
                                                                                
                                                                                
          Описание функции void                                                 
     ----------------------------------------------------------------           
                                                                                
          В начальной версии языка Си каждая функция возвращала значе-          
     ние некоторого типа;  если же тип не был описан,  то по умолчанию          
     функции присваивался тип int. Подобно этому функция, возвращающая          
     "сгенерированные"  (нетипичные) указатели, обычно описывалась как          
     возвращающая указатель   типа char, только потому, что она должна          
     была хоть что-то возвращать.                                               
                                                                                
          В нашей же версии Си существует стандартный тип void,  кото-          
     рый представляется как разновидность "нулевого" типа. Любая функ-          
     ция, не  возвращающая явно какое-либо значение, может быть объяв-          
     лена как функция типа void.  Заметим,  что большинство  программ,          

                         - 545,546 -
                                                                                
     использующих динамическое распределение памяти (например malloc),          
     описываются как имеющие тип void. Это означает, что они возвраща-          
     ют нетипизированный указатель, значение которого вы затем (в Тур-          
     бо Си)  можете присвоить указателю любого типа данных без предва-          
     рительного преобразования  типов (хотя преобразования типов лучше          
     использовать повсеместно, для сохранения совместимости).                   
                                                                                
                                                                                
                                                                                
          Используемые расширения                                               
     ----------------------------------------------------------------           
                                                                                
          Существует несколько дополнительных расширений языка Си, ко-          
     торые делают   программу более читаемой.  Эти расширения заменяют          
     некоторые анахронизмы ранних версий Си и позволяют вам писать бо-          
     лее эффективные, красивые и мобильные программы, а также повысить          
     производительность вашего труда.                                           
                                                                                
          Здесь мы представляем их краткий список.                              
                                                                                
                                                                                
                                                                                
                                                                                
          Строковые литералы                                                    
     -----------------------------------------------------------------          
                                                                                
          В классическом Си для получения длинной строковой переменной          
     в программе вы используете символы продолжения или некоторые раз-          
     новидности конкатенации.  В современном Си вы можете просто  раз-          
     бить большую  строковую переменную на несколько строк таким обра-          
     зом:                                                                       
                                                                                
                main()                                                          
                {                                                               
                  char *msg;                                                    
                                                                                
                 msg="Не так давно те, кто стал уже Си-хаккерами,"              
                     "были вынуждены пускаться на различные ухищрения"          
                     "для того, чтобы записать длинную стоку в"                 
                     "одну переменную. Но вам даже не нужно шевелить"           
                     "мозгами, чтобы засунуть в переменную целое"               
                     "стихотворение."                                           
                                                                                
                  printf("%s",msg);                                             
                }                                                               

                         - 547,548 -
                                                                                
               Шестнадцатиричная символьная константа                           
     -----------------------------------------------------------------          
                                                                                
          В классическом Си ключевые последовательности,  определяющие          
     конкретные символы в коде ASCII, представлены в восьмиричной сис-          
     теме счисления.  Это обусловлено тем, что в начале развития машин          
     двоичные числа обычно представлялись в восьмиричной форме.                 
                                                                                
          В настоящее  время  большинство компьютеров используют шест-          
     надцатиричную форму для представления  двоичных  чисел.   Поэтому          
     современный Си   позволяет объявлять символьные константы в шест-          
     надцатиричной системе счисления. Основная форма шестнадцатиричной          
     константы имеет вид:                                                       
                                                                                
                                '\xDD'                                          
                                                                                
     где  DD  представляет  одну  или две шестнадцатиричные  цифры (из          
     набора 0..9,A..F).                                                         
                                                                                
          Эта ключевая последовательность может быть  прямо  присвоена          
     переменной типа char или может быть вложена в строку:                      
                                                                                
                                                                                
                             ch = '\x20'.                                       
                                                                                
                                                                                
                                                                                
          Типы со знаком.                                                       
     -----------------------------------------------------------------          
                                                                                
          Классический Си подразумевает, что все int-типы являются ти-          
     пами со знаком, и потому включает модификатор типа unsigned чтобы          
     специфицировать обратное.  По умолчанию переменные типа char счи-          
     таются signed (со знаком),  что подразумевает изменение их значе-          
     ний от -128 до 127.                                                        
                                                                                
          Однако, в настоящее время большинство компиляторов Си,  реа-          
     лизованных для современных моделей компьютеров,  воспринимают тип          
     данных char как unsigned.  В связи с этим,  для повышения мобиль-          
     ности программ на Турбо Си,  в компилятор пакета включена  опция,          
     позволяющая компилировать тип данных char как unsigned по умолча-          
     нию. В  противном случае вы можете объявить  символьную  знаковую          
     переменную как signed char.                                                
                                                                                
                                                                                

                         - 549,550 -
                                                                                
               Ловушки в программировании на Си                                 
     -----------------------------------------------------------------          
                                                                                
          Существует несколько  общих ошибок,  допускаемых начинающими          
     программистами при программировании на  Си.   Далее  предлагаются          
     несколько из них вместе с предложениями, как их избежать.                  
                                                                                
                                                                                
                                                                                
          Маршрут MS DOS в строке Си                                            
     -----------------------------------------------------------------          
                                                                                
          Все знают, что обратный слеш (\) в MS DOS означает, что сле-          
     дующая далее строка есть имя каталога (справочника),  однако в Си          
     слеш является ключевым символом в строке.  Это противоречие явля-          
     ется одной из проблем,  в тех случаях,  когда вам необходимо ука-          
     зать маршрут доступа к файлу в строке Си. Например, вы набираете:          
                                                                                
                          "c:\new\tools.c"                                      
                                                                                
          При этом  вы ожидаете,  что задается файл tools.c в каталоге          
     new на драйвере с.  Это, однако, не совсем так. Вместо желаемого,          
                                                                                
     комбинация \n, являющаяся подстрокой строки Си, указывающей марш-          
     рут доступа к файлу,  представляет собой ключевую  последователь-          
     ность для перехода на новую строку (LF или символ перехода на но-          
     вую строку),  а \t есть  ни  что  иное  как  изображение  символа          
     табуляции в Си-программе.  Таким образом возникла ситуация, когда          
     в имя файла были встроены символы новой строки и табуляции. В ре-          
     зультате, DOS    воспримет эту строку как неправильное имя файла,          
     так как имя файла не должно включать символов табуляции или новой          
     строки. Если  же необходимость использования в имени файла комби-          
     наций символов, воспринимаемых как управляющие, велика, применяй-          
     те их  экранирование путем удвоения обратного слеша для каждой из          
     встречающихся комбинаций управляющих символов.                             
                                                                                
          Правильная   строка   (с   учетом  экранирования управляющих          
     последовательностей) будет иметь вид:                                      
                                                                                
                             "c:\\new\\tools.c"                                 
                                                                                
                                                                                
                                                                                
          Неправильное употребление указателей                                  
     ----------------------------------------------------------------           

                         - 551,552 -
                                                                                
                                                                                
          Использование указателей  может быть наиболее трудно для по-          
     нимания начинающему программисту на Си.  Когда надо  использовать          
     указатели, а    когда нет?  Когда использовать косвенный оператор          
     (*)? Когда  использовать адресный оператор (&)?  И  как  избежать          
     ошибок операционной системы во время выполнения программы?                 
                                                                                
          На все  эти и многие  другие вопросы ответ  будет дан в этом          
     разделе.                                                                   
                                                                                
                                                                                
                                                                                
          Использование неинициализированных указателей                         
     -----------------------------------------------------------------          
                                                                                
          Одна серьезная опасность таится в присвоении значения по ад-          
     ресу, содержащемуся  в указателе,  без первоначального присвоения          
     адреса этому указателю.                                                    
                                                                                
          Например:                                                             
                                                                                
                   main()                                                       
                                                                                
                   {                                                            
                       int *iptr;                                               
                                                                                
                       *iptr = 421;                                             
                       printf("*iptr = %d\n",*iptr);                            
                   }                                                            
                                                                                
          Эта ловушка опасна тем,  что программа, содержащая ее, может          
     быть "верна"   и  компилятор может не выдать никаких сообщений во          
     время компиляции такой программы. В примере, указанном выше, ука-          
     затель iptr имеет некоторый произвольный адрес, по которому запо-          
     минается значение 421. Эта программа настолько мала, что шанс что          
     -нибудь  затереть  в  памяти с ее помощью ничтожно мал,  однако в          
     больших  программах  возрастает  вероятность  разрушения   других          
     данных,  поскольку  вполне  возможно,  что  по  адресу  iptr  уже          
     хранится другая информация.  Если  вы  используете  модель  самой          
     маленькой  памяти  (tiny),  в которой сегменты программы и данных          
     занимают одну и ту же область  памяти,  то  вы  подвергаете  себя          
     риску испортить свой же загрузочный модуль. Поэтому старайтесь не          
     рубить сук на котором вы сами  же  сидите  и  внимательно  пишите          
     программы, использующие указатели.                                         
                                                                                

                         - 553,554 -
                                                                                
     Строки                                                                     
     -----------------------------------------------------------------          
                                                                                
          Как мы уже говорили,  строки можно объявить как указатели на          
     тип данных char или как массивы данных типа char. Речь шла о том,          
     что между ними существует лишь одно важное различие:  если вы ис-          
     пользуете указатель на данные типа char, память для строки не ре-          
     зервируется; если вы используете массив данных,  то память резер-          
     вируется автоматически и переменная  -  имя  массива  -  содержит          
     адрес начала зарезервированной области памяти.                             
                                                                                
          Недостаточное понимание  этой  разницы может привести к двум          
     типам ошибок. Рассмотрим следующую программу:                              
                                                                                
                   main()                                                       
                   {                                                            
                       char *name;                                              
                       char msg[10];                                            
                                                                                
                       printf("Назовите свое имя.");                            
                       scanf("%s",name);                                        
                       msg = "Здраствуйте, ";                                   
                                                                                
                       printf("%s %s:",msg,name);                               
                   }                                                            
                                                                                
          На первый  взгляд все законно,  немного неуклюже,  но вполне          
     допустимо. Однако здесь допущены две ошибки.                               
                                                                                
          Первая ошибка содержится в выражении:                                 
                                                                                
                   scanf("%s",name).                                            
                                                                                
          Выражение само по себе законно и корректно.  Поскольку  name          
     является указателем  на char,  вам не нужно ставить перед ним ад-          
     ресный оператор (&).  Однако память для name не  зарезервирована;          
     строка, которую вы введете, будет записана по какому-то случайно-          
     му адресу,  который окажется в name. Компилятор обнаружит это, но          
     поскольку эта   ситуация  не приведет к сбою выполнения программы          
     (т.к. строка все же будет сохранена),  то компилятор выдаст  лишь          
     предупреждающее сообщение, но не ошибку.                                   
                                                                                
                 "Possible use of 'name' before definition"                     
           ("Возможно использование 'name' до ее определения")                  
                                                                                

                         - 555,556 -
                                                                                
          Вторая ошибка содержится в операторе msg =  "Здравствуйте,".          
     Компилятор считает, что вы пытаетесь заменить значение msg на ад-          
     рес строковой константы "Здравствуйте,".  Это сделать невозможно,          
     поскольку имена   массивов являются константами,  и не могут быть          
     модифицированы (как, например, 7 является константой и нельзя за-          
     писать "7 = i"). Компилятор выдаст вам сообщение об ошибке:                
                                                                                
                          "Lvalue required."                                    
                   ("Использование константы недопустимо")                      
                                                                                
          Каково решение этой проблемы?  Простейший выход  -  изменить          
     способ описания переменных name и msg:                                     
                                                                                
                   main()                                                       
                   {                                                            
                        char name[10];                                          
                        char *msg;                                              
                                                                                
                        printf("Назовите свое имя");                            
                        scanf("%s",name);                                       
                        msg = "Здравствуйте,";                                  
                        printf("%s%s",msg,name);                                
                                                                                
                   }                                                            
                                                                                
          Эта программа безупречна.  Переменной name выделяется память          
     независимо от памяти,  выделяемой для строки, которую вы вводите,          
     тогда как в msg присваивается адрес строковой константы  "Здравс-          
     твуйте,". Если, тем не менее, вы оставите старое описание, то вам          
     нужно изменить программу следующим образом:                                
                                                                                
                   #include <alloc.h>                                           
                   main()                                                       
                   {                                                            
                        char *name;                                             
                        char msg[10];                                           
                                                                                
                        name = (char *) malloc (10);                            
                        printf("Назовите свое имя");                            
                        scanf("%s",name);                                       
                        strcpy(msg,"Здраствуйте,");                             
                        printf("%s%s",msg,name);                                
                   }                                                            
                                                                                
          Вызов функции  malloc  выделяет  отдельно 10 байтов памяти и          

                         - 557,558 -
                                                                                
                                                                                
     присваивает адрес этого участка памяти name,  решив  нашу  первую          
     проблему. Функция   strcpy производит посимвольное копирование из          
     строковой константы string "Здравствуйте," в массив msg.                   
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
               Разница между присваиванием (=) и равенством (==)                
     ----------------------------------------------------------------           
                                                                                
          В языках Паскаль и Бейсик проверка на равенство производится          
     выражением                                                                 
                                                                                
                               if (a = b).                                      
                                                                                
          Для Си  эта  конструкция допустима,  но имеет несколько иное          
     значение. Посмотрите на этот фрагмент программы:                           
                                                                                
                          if (a = b) puts("Равно");                             
                          else       puts("Не равно");                          
                                                                                
          Если это  программа  на  Паскале  или Бейсике,  то вы можете          
     предполагать, что будет напечатано "Равно", если a и b имеют оди-          
     наковое значение и "Не равно" в противном случае.                          
                                                                                
          Иначе происходит с программой на Си, где выражение a = b оз-          
     начает "Присвоить значение b переменной a",  и все выражение при-          
     нимает значение b.  Поэтому во фрагменте, приведенном выше, прис-          
     воится значение b переменной a,  а  затем  напечатается  "Равно",          

                         - 559,560 -
                                                                                
                                                                                
     если b имеет нулевое значение, в противном случае - "Не равно".            
                                                                                
          Правильное решение следующее:                                         
                                                                                
                          if (a == b) puts("Равно");                            
                          else        puts("Не равно");                         
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
     Пропуск break в операторе switch                                           
     ----------------------------------------------------------------           
                                                                                
                                                                                
          Как вы  помните,   оператор  break  используется в операторе          
     switch в конце каждой помеченной альтернативы выбора. Пожалуйста,          
     не забывайте это. Если вы забудете поставить break в данную поме-          
     ченную альтернативу выбора,  то операторы  следующих  альтернатив          
     выбора, помеченных за ней, будут также выполняться.                        
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 561,562 -
                                                                                
               Индексы массивов                                                 
     -----------------------------------------------------------------          
                                                                                
          Не забудьте, что индекс массива начинается с элемента [0], а          
     не с элемента [1].  Наиболее распространенная ошибка  может  быть          
     проиллюстрирована на примере следующей программы:                          
                                                                                
               main()                                                           
               {                                                                
                   int list[100],i;                                             
                                                                                
                   for (i = 1; i <= 100; i++);                                  
                    list[i] = i + 1;                                            
               }                                                                
                                                                                
          Данная  программа   оставляет  первый элемент list - list[0]          
     - неинициализированным,  и записывает значение  в  несуществующий          
     элемент list - list[100] - возможно испортив при этом другие дан-          
     ные.                                                                       
                                                                                
          Правильная программа будет иметь следующий вид:                       
                                                                                
                                                                                
                                                                                
               main()                                                           
               {                                                                
                   int list[100],i;                                             
                                                                                
                   for (i = 0; i < 100; i++)                                    
                    list[i] = i+1;                                              
               }                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 563,564 -
                                                                                
               Ошибки при передаче по адресу                                    
     -----------------------------------------------------------------          
                                                                                
          Посмотрите на следующую программу и найдите,  что здесь неп-          
     равильно :                                                                 
                                                                                
               main()                                                           
               {                                                                
                   int a,b,sum;                                                 
                                                                                
                   printf("Введите два значения:");                             
                   scanf("%d %d",a,b);                                          
                   sum = a + b;                                                 
                   printf("Сумма значений равна: %d\n",sum0;                    
               }                                                                
                                                                                
          Нашли? Ошибка в операторе                                             
                                                                                
                         scanf("%d %d",a,b);                                    
                                                                                
          Вспомните, что  scanf требует от вас передачи адресов,  а не          
     значений!                                                                  
                                                                                
                                                                                
          То же самое относится к любым функциям, содержащим в качест-          
     ве формальных параметров указатели.  Программа,  написанная выше,          
     оттранслируется и выполнится,  но при этом scanf возьмет какие-то          
     случайные значения  (мусор),  находящиеся в a и b и использует их          
     как адреса, по которым будут записаны введенные вами значения.             
                                                                                
          Правильно этот оператор необходимо записать так:                      
                                                                                
                        scanf("%d %d", &a, &b);                                 
                                                                                
          Здесь функции scanf передаются адреса a и  b,   и  введенные          
     значения правильно  запоминаются в этих переменных по их адресам.          
                                                                                
          Та же  неприятность  может случиться с вашей собственноручно          
     написанной функцией.  Помните функцию swap, которую мы определили          
     в параграфе об указателях?                                                 
                                                                                
          Что произойдет, если вы вызовете ее следующим образом:                
                                                                                
               main()                                                           
               {                                                                

                         - 565,566 -
                                                                                
                   int i,j;                                                     
                                                                                
                   i = 421;                                                     
                   j = 53;                                                      
                   printf("До обработки: i = %fd j = %fd\n",i,j);               
                   swap(i,j);                                                   
                   printf("После обработки: i = %fd j = %fd\n",i,j);            
               }                                                                
                                                                                
          Переменные i и j будут иметь одни и те же значения  как  до,          
     так и   после их обработки путем обращения к функции swap; однако          
     значения адресов чисел 421 и 53 будут переставлены,  что  породит          
     некоторые хитрые и труднообнаружимые ошибки.  Как избежать этого?          
                                                                                
          Пользуйтесь  прототипами  функций   и  полными определениями          
     функций.                                                                   
                                                                                
          И действительно,  вы получили бы ошибку при выполнении main,          
     если бы swap была описана так, как в этой главе. Если же вы опре-          
     делите ее таким образом,  как представлено  далее,  то  программа          
     выполнится без ошибок:                                                     
                                                                                
                                                                                
                                                                                
               void swap(a,b)                                                   
               int *a,*b;                                                       
               {                                                                
                  ...                                                           
               }                                                                
                                                                                
          Вынесение описания  переменных  a  и  b  из скобок отключает          
     контроль над ошибками, проводимый в противном случае; это являет-          
     ся лучшим доводом в пользу того, чтобы не использовать классичес-          
     кий стиль при определении функции.                                         
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                

                         - 567,568 -
                                                                                
                                                                                
               В добрый путь                                                    
     ----------------------------------------------------------------           
                                                                                
          Как и говорилось в начале предыдудущей главы,  мы  не  можем          
     дать вам   полное представление о Си только в двух главах.  Но мы          
     предложили вам оптимальный вариант знакомства с этим языком прог-          
     раммирования. Что   вам теперь делать дальше - ответ в предостав-          
     ленных вам примерах программ: компилируйте их, выполняйте, и (что          
     более важно)    модифицируйте  их  для того,  чтобы понять что же          
     все-таки произойдет, если вы что-нибудь измените в программе.              
                                                                                
               Удачи вам, счастливого пути в познании тайн                      
                       программирования на Си!                                  
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
                                                                                
