                                                                              
                                  Глава 1 Турне по С++
           
                                       Единственный способ  изучать новый язык
                                  программирования - писать на нем программы.
                                                            - Брайэн Керниган
           
             Эта глава  представляет  собой  краткий обзор основных черт языка
           программирования С++.  Сначала приводится программа на  С++,  затем
           показано, как ее откомпилировать и запустить, и как такая программа
           может выводить выходные данные и считывать входные.  В первой трети
           этой  главы  после  введения  описаны  наиболее  обычные черты С++:
           основные типы,  описания, выражения, операторы, функции и структура
           программы. Оставшаяся часть главы посвящена возможностям С++ по оп-
           ределению новых типов,  сокрытию  данных,  операциям,  определяемым
           пользователем, и иерархии определяемых пользователем типов.
                1.1 Введение
           
             Это турне проведет вас через ряд программ и  частей  программ  на
           С++. К концу у вас должно сложиться общее представление об основных
           особенностях С++,  и  будет  достаточно  информации,  чтобы  писать
           простые программы. Для точного и полного объяснения понятий, затро-
           нутых даже в самом маленьком законченном примере,  потребовалось бы
           несколько  страниц  определений.  Чтобы  не  превращать эту главу в
           описание или в обсуждение общих понятий,  примеры  снабжены  только
           самыми   короткими  определениями  используемых  терминов.  Термины
           рассматриваются позже,  когда будет больше примеров, способствующих
           обсуждению.
           
                1.1.1 Вывод
           
                 Прежде всего, давайте напишем программу, выводящую строку вы-
           дачи:
           
             #include <stream.h>
           
             main() {
                 cout << "Hello, world\n";
             }
           
             Строка #include <stream.h> сообщает компилятору, чтобы он включил
           стандартные возможности потока ввода и вывода,  находящиеся в файле
           stream.h.  Без этих описаний выражение cout << "Hello,  world\n" не
           имело бы смысла. Операция << ("поместить в"*) пишет свой первый ар-
           гумент во второй (в данном случае,  строку "Hello, world\n" в стан-
           дартный поток вывода cout).  Строка - это последовательность симво-
           лов,  заключенная в двойные кавычки. В строке символ обратной косой
           \,  за  которым следует другой символ,  обозначает один специальный
           символ,  в данном случае,  \n является символом новой строки. Таким
           образом выводимые символы состоят из Hello,  world и перевода стро-
           ки.
           
           ────────────────────
           * Программирующим на C << известно как операция сдвига влево для
           целых. Такое использование << не утеряно,  просто в  дальнейшем  <<
           было определено для случая,  когда его левый операнд является пото-
           ком вывода. Как это делается, описано в #1.8. (прим. автора)
             Остальная часть программы
           
             main() { ... }
           
           определяет функцию,  названную main. Каждая программа должна содер-
           жать функцию с именем main,  и работа программы начинается с выпол-
           нения этой функции.
           
                1.1.2 Компиляция
           
             Откуда появились выходной поток cout и код,  реализующий операцию
           вывода <<?  Для получения выполняемого кода написанная на С++ прог-
           рамма должна быть скомпилирована.  По своей сути процесс компиляции
           такой же,  как и для С,  и в нем участвует большая часть входящих в
           последний программ.  Производится чтение и анализ текста программы,
           и если не обнаружены ошибки,  то генерируется код.  Затем программа
           проверяется на наличие имен и операций,  которые использовались, но
           не были определены (в нашем случае это cout и <<). Если это возмож-
           но, то программа делается полной посредством дополнения недостающих
           определений из библиотеки (есть стандартные библиотеки, и пользова-
           тели  могут  создавать свои собственные).  В нашем случае cout и <<
           были описаны в stream.h,  то есть, были указаны их типы, но не было
           дано никаких подробностей относительно их реализации. В стандартной
           библиотеке содержится спецификация пространства и  инициализирующий
           код  для cout и <<.  На самом деле,  в этой библиотеке содержится и
           много других вещей,  часть из которых описана в stream.h,  однако к
           скомпилированной версии добавляется только подмножество библиотеки,
           необходимое для того, чтобы сделать нашу программу полной.
           
             Команда компиляции в С++ обычно называется CC.  Она  используется
           так  же,  как  команда cc для программ на C,  подробности вы можете
           найти в вашем руководстве.  Предположим,  что программа  с  "Hello,
           world" хранится в файле с именем hello.c,  тогда вы можете ее ском-
           пилировать и запустить примерно так ($ - системное приглашение):
           
             $ CC hello.c
             $ a.out
             Hello,world
             $
           
             a.out -  это принимаемое по умолчанию имя исполняемого результата
           компиляции.  Если вы хотите назвать свою программу,  вы можете сде-
           лать это с помощью опции -o:
           
             $ CC hello.c -o hello
             $ hello
             Hello,world
             $
                1.1.3 Ввод
           
             Следующая (довольно многословная) программа предлагает вам ввести
           число дюймов. После того, как вы это сделаете, она напечатает соот-
           ветствующее число сантиметров.
           
             #include <stream.h>
           
             main() {
                 int inch = 0;  // inch - дюйм cout << "inches";  cin >> inch;
                 cout << inch;  cout << " in = "; cout << inch*2.54; cout << "
                 cm\n";
             }
           
             Первая строка функции main() описывает целую переменную inch.  Ее
           значение считывается с помощью операции >> ("взять из")  над  стан-
           дартным потоком ввода cin. Описания cin и >>, конечно же, находятся
           в <stream.h>. После ее запуска ваш терминал может выглядеть пример-
           но так:
           
             $ a.out
             inches=12
             12 in = 30.48 cm
             $
           
             В этом примере на каждую команду вывода приходится один оператор.
           Это  слишком  длинно.  Операцию  вывода  <<  можно  применять  к ее
           собственному результату,  так что последние четыре  команды  вывода
           можно было записать одним оператором:
           
             cout << inch << " in = " << inch*2.54 << " cm\n";
           
             В последующих  разделах  ввод и вывод будут описаны гораздо более
           подробно.  Вся эта глава фактически может рассматриваться как  объ-
           яснение того, как можно написать предыдущие программы на языке, ко-
           торый не обеспечивает операции ввода-вывода.  На самом деле, приве-
           денные  выше  программы  написаны на С++,  "расширенном" операциями
           ввода-вывода посредством использования библиотек и включения файлов
           с помощью #include. Другими словами, язык С++ в том виде, в котором
           он описан в справочном руководстве, не определяет средств ввода-вы-
           вода. Вместо этого исключительно с помощью средств, доступных любо-
           му программисту, определены операции << и >>.
                     1.2 Комментарии
           
             Часто бывает  полезно вставлять в программу текст,  который пред-
           назначается в качестве комментария только для  читающего  программу
           человека  и игнорируется компилятором в программе.  В С++ это можно
           сделать одним из двух способов.
           
             Символы /* начинают комментарий,  заканчивающийся  символами  */.
           Вся  эта  последовательность символов эквивалентна символу пропуска
           (например, символу пробела). Это наиболее полезно для многострочных
           комментариев и изъятия частей программы при редактировании,  однако
           следует помнить, что комментарии /* */ не могут быть вложенными.
           
             Символы // начинают комментарий,  который заканчивается  в  конце
           строки,  на  которой они появились.  Опять,  вся последовательность
           символов эквивалентна пропуску.  Этот способ наиболее  полезен  для
           коротких комментариев. Символы // можно использовать для того, что-
           бы закомментировать символы /* или */,  а символами /* можно заком-
           ментировать //.
                1.3 Типы и Описания
           
             Каждое имя и каждое выражение имеет тип,  определяющий  операции,
           которые могут над ними производиться. Например, описание
           
             int inch;
           
           определяет, что  inch имеет тип int,  то есть,  inch является целой
           переменной.
           
             Описание - это оператор, который вводит имя в программе. Описание
           задает  тип  этого  имени.  Тип определяет правильное использование
           имени или выражения. Для целых определены такие операции, как +, -,
           * и /. После того, как включен файл stream.h, объект типа int может
           также быть вторым операндом <<, когда первый операнд ostream.
           
             Тип объекта определяет не только то,  какие операции могут к нему
           применяться, но и смысл этих операций. Например, оператор
           
             cout << inch << " in = " << inch*2.54 << " cm\n";
           
           правильно обрабатывает  четыре  входных значения различным образом.
           Строки печатаются буквально, тогда как целое inch и значение с пла-
           вающей точкой inch*2.54 преобразуются из их внутреннего представле-
           ния в подходящее для человеческого глаза символьное представление.
           
             В С++ есть несколько основных типов и несколько  способов  созда-
           вать новые.  Простейшие виды типов С++ описываются в следующих раз-
           делах, а более интересные оставлены на потом.
           
                1.3.1 Основные Типы
           
             Основные типы,  наиболее непосредственно отвечающие средствам ап-
           паратного обеспечения, такие:
           
             char short int long float double
           
             Первые четыре типа используются для представления целых,  послед-
           ние два - для представления чисел с  плавающей  точкой.  Переменная
           типа char имеет размер, естественный для хранения символа на данной
           машине (обычно,  байт),  а переменная типа int имеет размер,  соот-
           ветствующий целой арифметике на данной машине (обычно, слово). Диа-
           пазон целых чисел,  которые могут быть представлены типом,  зависит
           от его размера (sizeof). В С++ размеры измеряются в единицах разме-
           ра данных типа char,  поэтому char по определению имеет размер еди-
           ница. Соотношение между основными типами можно записать так:
           
             1 =  sizeof(char) <= sizeof(short) <= sizeof(int) <= sizeof(long)
             sizeof(float) <= sizeof(double)
           
             В целом,  предполагать что-либо еще относительно  основных  типов
           неразумно.  В частности, то, что целое достаточно для хранения ука-
           зателя, верно не для всех машин.
             К основному  типу можно применять прилагательное const.  Это дает
           тип, имеющий те же свойства, что и исходный тип, за исключением то-
           го,  что  значение  переменных типа const не может изменяться после
           инициализации.
           
             const float pi = 3.14; const char plus = '+';
           
             Символ, заключенный  в  одинарные  кавычки,  является  символьной
           константой. Заметьте, что часто константа, определенная таким обра-
           зом, не занимает память. Просто там, где требуется, ее значение мо-
           жет использоваться непосредственно.  Константа должна инициализиро-
           ваться при описании. Для переменных инициализация необязательна, но
           настоятельно рекомендуется.  Оснований для введения локальной пере-
           менной без ее инициализации очень немного.
           
             К любой комбинации этих типов  могут  применяться  арифметические
           операции:
           
             + (плюс, унарный и бинарный)
             - (минус, унарный и бинарный)
             * (умножение)
             / (деление)
           
             А также операции сравнения:
           
             == (равно)
             != (не равно)
             < (меньше)
             > (больше)
             <= (меньше или равно)
             >= (больше или равно)
           
             Заметьте, что целое деление дает целый результат: 7/2 есть 3. Над
           целыми может выполняться операция % получения остатка: 7%2 равно 1.
           
              При присваивании и арифметических операциях  С++  выполняет  все
           осмысленные  преобразования между основными типами,  чтобы их можно
           было сочетать без ограничений:
           
             double d = 1; int i = 1; d = d + i; i = d + i;
           
                1.3.2 Производные Типы
           
             Вот операции, создающие из основных типов новые типы:
           
             * указатель на
             *const константный указатель на
             & ссылка на
             [] вектор* () функция, возвращающая
           
           ────────────────────
           * одномерный массив. Это принятый термин (например, вектора
           прерываний), и  мы сочли,  что стандартный перевод его как "массив"
           затуманит изложение. (прим. перев.)
             Например:
           
             char* p  // указатель на символ char *const q // константный ука-
             затель на символ char v[10] // вектор из 10 символов
           
             Все вектора в качестве нижней границы индекса имеют ноль, поэтому
           в v десять элементов: v[0]..v[9]. Функции объясняются в #1.5, ссыл-
           ки в #1.9. Переменная указатель может содержать адрес объекта соот-
           ветствующего типа:
           
             char c;
             // ...
             p = &c; // p указывает на c
           
             Унарное & является операцией взятия адреса.
           
                1.4 Выражения и Операторы
           
             В С++ имеется богатый набор операций, с помощью которых в выраже-
           ниях образуются новые значения и  изменяются  значения  переменных.
           Поток  управления  в  программе  задается  с помощью операторов,  а
           описания используются для введения  в  программе  имен  переменных,
           констант и т.д. Заметьте, что описания являются операторами, поэто-
           му они свободно могут сочетаться с другими операторами.
                1.4.1 Выражения
           
             В С++  имеется  большое  число операций,  и они будут объясняться
           там, где (и если) это потребуется. Следует учесть, что операции
           
             ~ (дополнение)
             & (И)
             ^ (исключающее ИЛИ)
             | (включающее ИЛИ)
             << (логический сдвиг влево)
             >> (логический сдвиг вправо)
           
           применяются к  целым,  и  что  нет отдельного типа данных для логи-
           ческих действий.
           
             Смысл операции зависит от числа  операндов.  Унарное  &  является
           операцией взятия адреса, а бинарное & - это операция логического И.
           Смысл операции зависит также от типа ее операндов:  +  в  выражении
           a+b  означает сложение с плавающей точкой,  если операнды имеют тип
           float,  но целое сложение,  если они типа int.  В #1.8 объясняется,
           как  можно определить операцию для типа,  определяемого пользовате-
           лем,  без потери ее значения, предопределенного для основных и про-
           изводных типов.
           
             В С++  есть операция присваивания =,  а не оператор присваивания,
           как в некоторых языках.  Таким образом,  присваивание может  встре-
           чаться в неожиданном контексте, например, x=sqrt(a=3*x). Это бывает
           полезно.  a=b=c означает присвоение c объекту b, а затем объекту a.
           Другим  свойством операции присваивания является то,  что она может
           совмещаться с большинством бинарных операций.  Например,  x[i+3]*=4
           означает x[i+3]=x[i+3]*4,  за исключением того факта, что выражение
           x[i+3] вычисляется только один раз.  Это дает привлекательную  сте-
           пень  эффективности  без  необходимости  обращения к оптимизирующим
           компиляторам. К тому же это более кратко.
           
             В большинстве программ на С++ широко применяются указатели. Унар-
           ная операция * разыменовывает* указатель,  т.е.  *p есть объект, на
           который указывает p.  Эта операция также называется  косвенной  ад-
           ресацией. Например, если имеется char* p, то *p есть символ, на ко-
           торый указывает p.  Часто при работе с указателями  бывают  полезны
           операция  увеличения  ++ и операция уменьшения --.  Предположим,  p
           указывает на элемент вектора v,  тогда p++ делает p указывающим  на
           следующий элемент.
           
           ────────────────────
           * англ. dereference - получить значение объекта, на который
           указывает данный указатель. (прим. перев.)
                1.4.2 Операторы Выражения
           
             Самый обычный вид оператора - выражение;.  Он состоит из  выраже-
           ния, за которым следует точка с запятой. Например:
           
             a = b*3+c; cout << "go go go"; lseek(fd,0,2);
           
                1.4.3 Пустой оператор
           
             Простейшей формой оператора является оператор:
           
             ;
           
             Он не делает ничего.  Однако он может быть полезен в тех случаях,
           когда синтаксис требует наличие оператора, а вам оператор не нужен.
           
                1.4.4 Блоки
           
             Блок - это возможно пустой список операторов,  заключенный в  фи-
           гурные скобки:
           
             { a=b+2; b++; }
           
           Блок позволяет рассматривать несколько операторов как один. Область
           видимости имени,  описанного в блоке,  простирается до конца блока.
           Имя  можно  сделать невидимым с помощью описаний такого же имени во
           внутренних блоках.
           
                1.4.5 Оператор if
           
             Программа в следующем примере осуществляет преобразование  дюймов
           в сантиметры и сантиметров в дюймы.  Предполагается, что вы укажете
           единицы измерения вводимых данных,  добавляя i для дюймов и  c  для
           сантиметров:
           
             #include <stream.h>
           
             main() {
                 const float fac = 2.54; float x, in, cm; char ch = 0;
           
                 cout << "введите длину: "; cin >> x >> ch;
           
                 if (ch == 'i') { // inch - дюймы in = x; cm = x*fac;
                 }
                 else if (ch == 'c') // cm - сантиметры in = x/fac; cm = x;
                 }
                 else in = cm = 0;
           
                 cout << in << " in = " << cm << " cm\n";
             }
           
             Заметьте, что  условие  в  операторе  if  должно быть заключено в
           круглые скобки.
                1.4.6 Операторы switch
           
             Оператор switch  производит  сопоставление  значения с множеством
           констант. Проверки в предыдущем примере можно записать так:
           
             switch (ch) { case 'i':
                 in = x; cm = x*fac; break;
             case 'c':
                 in = x/fac; cm = x; break;
             default:
                 in = cm = 0; break;
             }
           
             Операторы break  применяются  для  выхода  из  оператора  switch.
           Константы в вариантах case должны быть различными, и если проверяе-
           мое значение не совпадает ни с одной из констант,  выбирается вари-
           ант default. Программисту не обязательно предусматривать default.
           
                1.4.7 Оператор while
           
             Рассмотрим копирование  строки,  когда  заданы  указатель p на ее
           первый символ и указатель q на целевую строку. По соглашению строка
           оканчивается символом с целым значением 0.
           
             while (p != 0) {
                 *q = *p; // скопировать символ
                 q = q+1; p = p+1;
             }
             *q = 0;      // завершающий символ 0 скопирован не был
           
             Следующее после  while  условие  должно  быть заключено в круглые
           скобки.  Условие вычисляется, и если его значение не ноль, выполня-
           ется непосредственно следующий за ним оператор.  Это повторяется до
           тех пор, пока вычисление условия не даст ноль.
           
             Этот пример слишком пространен.  Можно использовать  операцию  ++
           для непосредственного указания увеличения, и проверка упростится:
           
             while (*p) *q++ = *p++;
             *q = 0;
           
           где конструкция *p++ означает:  "взять символ, на который указывает
           p, затем увеличить p."
           
             Пример можно еще упростить,  так как указатель p разыменовывается
           дважды за каждый цикл.  Копирование символа можно делать тогда  же,
           когда производится проверка условия:
           
             while (*q++ = *p++) ;
           
             Здесь берется  символ,  на который указывает p,  p увеличивается,
           этот символ копируется туда,  куда указывает q,  и q увеличивается.
           Если символ ненулевой,  цикл повторяется.  Поскольку вся работа вы-
           полняется в условии,  не требуется ни одного оператора.  Чтобы ука-
           зать на это,  используется пустой оператор.  С++ (как и C) одновре-
           менно любят и ненавидят за возможность такого чрезвычайно  краткого
           ориентированного на выразительность программирования*.
           
           ────────────────────
           * в оригинале expression-oriented (expression - выразительность и
           выражение). (прим. перев.)
                1.4.8 Оператор for
           
             Рассмотрим копирование десяти элементов одного вектора в другой:
           
             for (int i=0; i<10; i++) q[i]=p[i];
           
             Это эквивалентно
           
             int i = 0; while (i<10) {
                 q[i] = p[i]; i++;
             }
           
           но более удобочитаемо,  поскольку вся информация,  управляющая цик-
           лом,  локализована. При применении операции ++ к целой переменной к
           ней просто добавляется единица.  Первая часть оператора for не обя-
           зательно  должна  быть описанием,  она может быть любым оператором.
           Например:
           
             for (i=0; i<10; i++) q[i]=p[i];
           
           тоже эквивалентно предыдущей записи при условии, что i соответству-
           ющим образом описано раньше.
           
                1.4.9 Описания
           
             Описание - это оператор, вводящий имя в программе. Оно может так-
           же инициализировать объект с этим именем. Выполнение описания озна-
           чает,  что когда поток управления доходит до описания,  вычисляется
           инициализирующее выражение (инициализатор) и производится инициали-
           зация. Например:
           
             for (int i = 1; i<MAX; i++) { int t = v[i-1]; v[i-1] = v[i]; v[i]
                 = t;
             }
           
             При каждом  выполнении  оператора  for i будет инициализироваться
           один раз, а t MAX-1 раз.
           
                1.5 Функции
           
             Функция - это именованная часть программы,  к которой можно обра-
           щаться из других частей программы столько раз, сколько потребуется.
           Рассмотрим программу, печатающую степени числа 2:
           
             extern float pow(float, int); //pow() определена в другом месте
           
             main() {
                 for (int i=0; i<10; i++) cout << pow(2,i) << "\n";
             }
           
             Первая строка функции - ее описание, указывающее, что pow - функ-
           ция,  получающая  параметры  типа float и int и возвращающая float.
           Описание функции используется для того, чтобы сделать определенными
           обращения к функции в других местах.
             При вызове функции тип каждого параметра сопоставляется с ожидае-
           мым  типом точно так же,  как если бы инициализировалась переменная
           описанного типа. Это гарантирует надлежащую проверку и преобразова-
           ние типов. Например, обращение pow(12.3,"abcd") вызовет недовольст-
           во компилятора,  поскольку "abcd" является строкой,  а не int.  При
           вызове  pow(2,i)  компилятор  преобразует 2 к типу float,  как того
           требует функция. Функция pow может быть определена например так:
           
             float pow(float x, int n) {
                 if (n < 0) error("sorry, negative exponent to pow()");
                              // извините, отрицательный показатель для pow()
                 switch (n) { case 0:  return 1;  case 1:  return x;  default:
                 return x*pow(x,n-1); }
             }
           
             Первая часть определения функции задает имя функции,  тип возвра-
           щаемого ею значения (если таковое имеется) и типы и имена ее  пара-
           метров (если они есть).  Значение возвращается из функции с помощью
           оператора return.
           
             Разные функции, обычно имеют разные имена, но функциям, выполняю-
           щим  сходные  действия над объектами различных типов,  иногда лучше
           дать возможность иметь одинаковые имена.  Если типы  их  параметров
           различны, то компилятор всегда может различить их и выбрать для вы-
           зова нужную функцию. Может, например, иметься одна функция возведе-
           ния в степень для целых переменных и другая для переменных с плава-
           ющей точкой:
           
             overload pow;  int pow(int,  int);  double  pow(double,  double);
             //... x=pow(2,10); y=pow(2.0,10.0);
           
             Описание
           
             overload pow;
           
           сообщает компилятору, что использование имени pow более чем для од-
           ной функции является умышленным.
           
             Если функция не возвращает значения,  то ее следует  описать  как
           void:
           
             void swap(int* p, int* q) // поменять местами {
                 int t = *p;
                 *p = *q;
                 *q = t;
             }
                1.6 Структура программы
           
             Программа на С++ обычно состоит из большого числа  исходных  фай-
           лов, каждый из которых содержит описания типов, функций, переменных
           и констант.  Чтобы имя можно было использовать  в  разных  исходных
           файлах для ссылки на один и тот же объект,  оно должно быть описано
           как внешнее. Например:
           
             extern double sqrt(double); extern instream cin;
           
             Самый обычный способ обеспечить согласованность исходных файлов
           - это поместить такие описания в отдельные файлы,  называемые заго-
           ловочными (или хэдер) файлами,  а затем включить,  то есть скопиро-
           вать,  эти заголовочные файлы во все файлы, где нужны эти описания.
           Например,  если описание sqrt хранится  в  заголовочном  файле  для
           стандартных  математических  функций  math.h,  и  вы хотите извлечь
           квадратный корень из 4, можно написать:
           
             #include <math.h>
             //...
             x = sqrt(4);
           
             Поскольку обычные заголовочные файлы включаются во многие  исход-
           ные файлы, они не содержат описаний, которые не должны повторяться.
           Например, тела функций даются только для inline-подставляемых функ-
           ций  (#1.12)  и инициализаторы даются только для констант (#1.3.1).
           За исключением этих случаев,  заголовочный файл является хранилищем
           информации о типах. Он обеспечивает интерфейс между отдельно компи-
           лируемыми частями программы.
           
             В команде включения include  имя  файла,  заключенное  в  угловые
           скобки,  например <math.h>, относится к файлу с этим именем в стан-
           дартном каталоге (часто это /usr/include/CC), на файлы, находящиеся
           в каких-либо других местах ссылаются с помощью имен,  заключенных в
           двойные кавычки. Например:
           
             #include "math1.h"
             #include "/usr/bs/math2.h"
           
           включит math1.h  из текущего пользовательского каталога,  а math2.h
           из каталога /usr/bs.
           
             Здесь приводится очень маленький законченный пример программы,  в
           котором строка определяется в одном файле, а ее печать производится
           в другом. Файл header.h определяет необходимые типы:
           
             // header.h
           
             extern char* prog_name; extern void f(); В файле main.c находится
             главная программа:
           
             // main.c
           
             #include "header.h"
             char* prog_name = "дурацкий, но полный"; main() {
                 f();
             }
           
           а файл f.c печатает строку:
           
             // f.c
           
             #include <stream.h>
             #include "header.h"
             void f() {
                 cout << prog_name << "\n";
             }
           
             Скомпилировать и запустить программу вы можете например так:
           
             $ CC main.c f.c -o silly
             $ silly
             дурацкий, но полный
             $
           
                1.7 Классы
           
             Давайте посмотрим,  как  мы могли бы определить тип потока вывода
           ostream.  Чтобы упростить задачу,  предположим, что для буферизации
           определен  тип  streambuf.  Тип streambuf на самом деле определен в
           <stream.h>, где также находится и настоящее определение ostream.
           
             Пожалуйста, не испытывайте примеры, определяющие ostream в этом и
           последующих разделах. Пока вы не сможете полностью избежать исполь-
           зования <stream.h>, компилятор будет возражать против переопределе-
           ний.
           
             Определение типа,  определяемого пользователем (который в С++ на-
           зывается class,  т.е. класс), специфицирует данные, необходимые для
           представления объекта этого типа, и множество операций для работы с
           этими объектами.  Определение имеет две части:  закрытую  (private)
           часть, содержащую информацию, которой может пользоваться только его
           разработчик,  и открытую (public) часть,  представляющую  интерфейс
           типа с пользователем:
           
             class ostream { streambuf* buf; int state;
             public:
                 void put(char*); void put(long); void put(double);
             }
             Описания после метки public: задают интерфейс: пользователь может
           обращаться только к трем  функциям  put().  Описания  перед  меткой
           public  задают  представление  объекта класса ostream.  Имена buf и
           state могут использоваться только функциями put(), описанными в от-
           крытой части.
           
             class определяет тип, а не объект данных, поэтому чтобы использо-
           вать ostream,  мы должны один такой объект описать (так же,  как мы
           описываем переменные типа int):
           
             ostream my_out;
           
             Считая, что my_out был соответствующим образом проинициализирован
           (как, объясняется в #1.10), его можно использовать например так:
           
             my_out.put("Hello, world\n");
           
             С помощью операции точка выбирается член класса для данного  объ-
           екта этого класса. Здесь для объекта my_out вызывается член функция
           put().
           
             Функция может определяться так:
           
             void ostream::put(char* p) {
                 while (*p) buf.sputc(*p++);
             }
           
           где sputc() - функция, которая помещает символ в streambuf. Префикс
           ostream необходим, чтобы отличить put() ostream'а от других функций
           с именем put().
           
             Для обращения к функции члену должен быть указан объект класса. В
           функции члене можно ссылаться на этот объект неявно,  как это дела-
           лось выше в ostream::put():  в каждом вызове buf относится к  члену
           buf объекта, для которого функция вызвана.
           
             Можно также ссылаться на этот объект явно посредством указателя с
           именем this.  В функции члене класса X this неявно  описан  как  X*
           (указатель  на  X) и инициализирован указателем на тот объект,  для
           которого эта функция вызвана. Определение ostream::put() можно так-
           же записать в виде:
           
             void ostream::put(char* p) {
                 while (*p) this->buf.sputc(*p++);
             }
           
             Операция -> применяется для выбора члена объекта,  заданного ука-
           зателем.
                1.8 Перегрузка операций
           
             Настоящий класс  ostream  определяет  операцию <<,  чтобы сделать
           удобным вывод нескольких объектов одним оператором. Давайте посмот-
           рим, как это сделано.
           
             Чтобы определить  @,  где  @ - некоторая операция языка С++,  для
           каждого определяемого пользователем типа вы определяете  функцию  с
           именем operator@, которая получает параметры соответствующего типа.
           Например:
           
             class ostream {
                 //...
                 ostream operator<<(char*);
             };
           
             ostream ostream::operator<<(char* p) {
                 while (*p) buf.sputc(*p++); return *this;
             }
           
           определяет операцию  <<  как член класса ostream,  поэтому s<<p ин-
           терпретируется как s.operator<<(p),  когда s является ostream и p -
           указатель    на    символ.   Операция   <<   бинарна,   а   функция
           operator<<(char*) на первый взгляд имеет только один параметр.  Од-
           нако, помимо этого она имеет свой стандартный параметр this.
           
             То, что  в  качестве возвращаемого значения возвращается ostream,
           позволяет применять <<  к  результату  операции  вывода.  Например,
           s<<p<<q  интерпретируется как (s.operator<<(p)).operator<<(q).  Так
           задаются операции вывода для встроенных типов.
           
             С помощью множества операций,  заданных как открытые члены класса
           ostream,  вы  можете  теперь определить << для такого определяемого
           типа, как complex, не изменяя описание класса ostream:
           
             ostream operator<<(ostream s, complex z)
             // у complex две части: действительная real и мнимая imag
             // печатает complex как (real,imag)
             { return s << "(" << z.real << "," << z.imag << ")';
             }
           
             Поскольку operator<<(ostream,complex) не является  функцией  чле-
           ном,  для бинарности необходимо два явных параметра. Вывод значений
           будет производиться в правильном порядке,  потому  что  <<,  как  и
           большинство операций С++, группирует слева направо, то есть f<<b<<c
           означает (a<<b)<<c. При интерпретации операций компилятору известна
           разница  между функциями членами и функциями не членами.  Например,
           если z - комплексная переменная,  то s<<z будет расширяться  с  по-
           мощью вызова стандартной функции (не члена) operator<<(s,z).
                1.9 Ссылки
           
             К сожалению, последняя версия ostream содержит серьезную ошибку и
           к тому же очень неэффективна.  Сложность состоит в том, что ostream
           копируется дважды при каждом использовании <<:  один раз как  пара-
           метр и один раз как возвращаемое значение.  Это оставляет state не-
           измененным после каждого вызова.  Необходима  возможность  передачи
           указателя на ostream вместо передачи самого ostream.
           
             Это можно сделать с помощью ссылок.  Ссылка действует как имя для
           объекта.  T& означает ссылку на T. Ссылка должна быть инициализиро-
           вана, и она становится другим именем того объекта, которым она ини-
           циализирована. Например:
           
             ostream& s1 = my_out; ostream& s2 = cout;
           
             Теперь можно использовать ссылку s1 и my_out одинаково, и они бу-
           дут иметь одинаковые значения. Например, присваивание
           
             s1 = s2;
           
           копирует объект, на который ссылается s2 (то есть, cout), в объект,
           на который ссылается s1 (то есть,  my_out). Члены берутся с помощью
           операции точка
           
             s1.put("не надо использовать ->");
           
           а если применить операцию взятия адреса,  то вы получите адрес объ-
           екта, на который ссылается ссылка:
           
             &s1 == &my_out
           
             Первая очевидная польза от ссылок состоит в том, чтобы обеспечить
           передачу адреса объекта,  а не самого объекта,  в функцию вывода (в
           некоторых языках это называется вызов по ссылке):
           
             ostream& operator<<(ostream& s,  complex z) { return s << "("  <<
                 z.real << "," << z.imag << ")";
             }
           
             Достаточно интересно, что тело функции осталось без изменений, но
           если  вы будете осуществлять присваивание s,  то будете воздейство-
           вать на сам объект,  а не на его копию.  В данном  случае  то,  что
           возвращается ссылка,  также повышает эффективность,  поскольку оче-
           видный способ реализации ссылки - это указатель,  а передача указа-
           теля гораздо дешевле, чем передача большой структуры данных.
           
             Ссылки также существенны для определения потока ввода,  поскольку
           операция ввода получает в качестве операнда переменную для считыва-
           ния.  Если бы ссылки не использовались,  то пользователь должен был
           бы явно передавать указатели в функции ввода.
           
             class istream {
                 //...
                 int state; public:
                 istream& operator>>(char&);    istream&    operator>>(char*);
                 istream& operator>>(int&); istream& operator>>(long&); //...
             };
             Заметьте, что для чтения long и int используются разные  функции,
           тогда как для их печати требовалась только одна. Это вполне обычно,
           и причина в том,  что int может быть преобразовано в long по  стан-
           дартным  правилам неявного преобразования (#с.6.6),  избавляя таким
           образом программиста от  беспокойства  по  поводу  написания  обеих
           функций ввода.
           
                1.10 Конструкторы
           
             Определение ostream  как  класса  сделало члены данные закрытыми.
           Только функция член имеет доступ к закрытым  членам,  поэтому  надо
           предусмотреть  функцию для инициализации.  Такая функция называется
           конструктором и отличается тем,  что имеет то  же  имя,  что  и  ее
           класс:
           
             class ostream {
                 //...
                 ostream(streambuf*); ostream(int size, char* s);
             };
           
             Здесь задано  два  конструктора.  Один  получает   вышеупомянутый
           streambuf для реального вывода,  другой получает размер и указатель
           на символ для форматирования строки.  В  описании  необходимый  для
           конструктора  список  параметров присоединяется к имени.  Теперь вы
           можете, например, описать такие потоки:
           
             ostream my_out(&some_stream_buffer);   char   xx[256];    ostream
             xx_stream(256,xx);
           
             Описание my_out  не  только  задает  соответствующий объем памяти
           где-то   в   другом   месте,   оно   также   вызывает   конструктор
           ostream::ostream(streambuf*), чтобы инициализировать его параметром
           &some_stream_buffer, предположительно указателем на подходящий объ-
           ект  класса streambuf.  Описание конструкторов для класса не только
           дает способ инициализации объектов,  но также обеспечивает то,  что
           все объекты этого класса будут проинициализированы. Если для класса
           были описаны конструкторы,  то невозможно описать переменную  этого
           класса  так,  чтобы  конструктор  не  был вызван.  Если класс имеет
           конструктор,  не получающий параметров,  то этот конструктор  будет
           вызываться в том случае, если в описании нет ни одного параметра.
                1.11 Вектора
           
             Встроенное в С++ понятие  вектора  было  разработано  так,  чтобы
           обеспечить  максимальную  эффективность  выполнения при минимальном
           расходе памяти.  Оно также (особенно когда используется совместно с
           указателями) является весьма универсальным инструментом для постро-
           ения средств более высокого уровня.  Вы могли бы,  конечно,  возра-
           зить,  что размер вектора должен задаваться как константа,  что нет
           проверки выхода за границы вектора и т.д.  Ответ на подобные возра-
           жения  таков:  "Вы  можете  запрограммировать  это  сами."  Давайте
           посмотрим,  действительно ли оправдан такой ответ. Другими словами,
           проверим средства абстракции языка С++, попытавшись реализовать эти
           возможности для  векторных  типов,  которые  мы  создадим  сами,  и
           посмотрим,  какие с этим связаны трудности,  каких это требует зат-
           рат, и насколько получившиеся векторные типы удобны в обращении.
           
             class vector { int* v; int sz;
             public:
                     vector(int); // конструктор
                     ~vector(); // деструктор
                 int size()  {  return  sz;   }   void   set_size(int);   int&
                 operator[](int); int& elem(int i) { return v[i]; }
             };
           
             Функция size возвращает число элементов  вектора,  таким  образом
           индексы должны лежать в диапазоне 0 ...  size()-1. Функция set_size
           сделана для изменения этого размера,  elem  обеспечивает  доступ  к
           элементам без проверки индекса,  а operator[] дает доступ с провер-
           кой границ.
           
             Идея состоит в том, чтобы класс сам был структурой фиксированного
           размера, управляющей доступом к фактической памяти вектора, которая
           выделяется конструктором вектора с помощью распределителя свободной
           памяти new:
           
             vector::vector(int s) {
                 if (s<=0) error("bad vector size");
                               // плохой размер вектора
                 sz = s; v = new int[s];
             }
           
             Теперь вы  можете  описывать  вектора  типа vector почти столь же
           элегантно, как и вектора, встроенные в сам язык:
           
             vector v1(100); vector v2(nelem*2-4);
           
             Операцию доступа можно определить как
           
             int& vector::operator[](int i) {
                 if(i<0 || sz<=i) error("vector index out of range");
                                      // индекс выходит за границы вектора
                 return v[i];
             }
             Операция ||  (ИЛИИЛИ)  -  это логическая операция ИЛИ.  Ее правый
           операнд вычисляется только тогда,  когда это  необходимо,  то  есть
           если  вычисление  левого  операнда  дало  ноль.  Возвращение ссылки
           обеспечивает то, что запись [] может использоваться с любой стороны
           операции присваивания:
           
             v1[x] = v2[y];
           
             Функция со  странным  именем  ~vector  - это деструктор,  то есть
           функция,  описанная для того,  чтобы она неявно  вызывалась,  когда
           объект  класса  выходит  из области видимости.  Деструктор класса C
           имеет имя ~C. Если его определить как
           
             vector::~vector() {
                 delete v;
             }
           
           то он будет,  с помощью операции delete,  освобождать пространство,
           выделенное  конструктором,  поэтому когда vector выходит из области
           видимости,  все его пространство возвращается обратно в память  для
           дальнейшего использования.
           
                1.12 Inline-подстановка
           
             Если часто повторяется обращение к очень маленькой функции, то вы
           можете начать беспокоиться о стоимости вызова функции.  Обращение к
           функции  члену  не  дороже  обращения  к  функции не члену с тем же
           числом параметров (надо помнить, что функция член всегда имеет хотя
           бы  один параметр),  и вызовы в функций в С++ примерно столь же эф-
           фективны, сколь и в любом языке. Однако для слишком маленьких функ-
           ций  может встать вопрос о накладных расходах на обращение.  В этом
           случае  можно  рассмотреть  возможность  спецификации  функции  как
           inline-подставляемой.  Если вы поступите таким образом, то компиля-
           тор сгенерирует для функции соответствующий код в месте ее  вызова.
           Семантика  вызова  не  изменяется.  Если,  например,  size  и  elem
           inline-подставляемые, то
           
             vector s(100);
             //...
             i = s.size(); x = elem(i-1);
           
           порождает код, эквивалентный
           
             //...
             i = 100; x = s.v[i-1];
           
             С++ компилятор  обычно  достаточно  разумен,  чтобы  генерировать
           настолько хороший код,  насколько вы можете получить  в  результате
           прямого  макрорасширения.  Разумеется,  компилятор  иногда вынужден
           использовать временные переменные и другие уловки,  чтобы сохранить
           семантику.
             Вы можете  указать,   что   вы   хотите,   чтобы   функция   была
           inline-подставляемой,  поставив  ключевое  слово inline,  или,  для
           функции  члена,  просто  включив  определение  функции  в  описание
           класса, как это сделано в предыдущем примере для size() и elem().
           
             При хорошем  использовании inline-функции резко повышают скорость
           выполнения и уменьшают  размер  объектного  кода.  Однако,  inline-
           функции запутывают описания и могут замедлить компиляцию,  поэтому,
           если они не необходимы,  то их желательно избегать.  Чтобы  inline-
           функция  давала существенный выигрыш по сравнению с обычной функци-
           ей, она должна быть очень маленькой.
           
                1.13 Производные классы
           
             Теперь давайте определим вектор,  для которого пользователь может
           задавать границы изменения индекса.
           
             class vec: public vector { int low, high;
             public:
                 vec(int,int); int& elem(int); int& operator[](int);
             };
           
           Определение vec как
           
             :public vector
           
           означает, в первую очередь,  что vec - это vector. То есть, тип vec
           имеет (наследует) все свойства типа vector дополнительно к тем, что
           описаны специально для него.  Говорят,  что vector является базовым
           классом  для  vec,  а о vec говорится,  что он производный класс от
           vector.
           
             Класс vec модифицирует класс vector тем,  что в нем задается дру-
           гой конструктор, который требует от пользователя указывать две гра-
           ницы изменения индекса,  а не длину,  и  имеются  свои  собственные
           функции доступа elem(int) и operator[](int).  Функция elem() класса
           vec легко выражается через elem() класса vector:
           
             int& vec::elem(int i) {
                 return vector::elem(i-low);
             }
           
             Операция разрешения области видимости ::  используется для  того,
           чтобы  не  было бесконечной рекурсии обращения к vec::elem() из нее
           самой. с помощью унарной операции :: можно ссылаться на нелокальные
           имена.  Было бы разумно описать vec::elem() как inline,  поскольку,
           скорее всего, эффективность существенна, но необязательно, неразум-
           но и невозможно написать ее так,  чтобы она непосредственно исполь-
           зовала закрытый член v класса vector.  Функции производного  класса
           не  имеют  специального  доступа  к  закрытым  членам  его базового
           класса.
             Конструктор можно написать так:
           
             vec::vec(int lb, int hb) : (hb-lb+1) {
                 if (hb-lb<0) hb = lb; low = lb; high = hb;
             }
           
             Запись: (hb-lb+1)  используется для определения списка параметров
           конструктора базового класса vector::vector(). Этот конструктор вы-
           зывается перед телом vec::vec(). Вот небольшой пример, который мож-
           но запустить, если скомпилировать его вместе с остальными описания-
           ми vector:
           
             #include <streams.h>
           
             void error(char* p) {
                 cerr << p << "\n";
                     // cerr - выходной поток сообщений об ошибках
                 exit(1);
             }
           
             void vector::set_size(int) { /* пустышка */ }
           
             int& vec::operator[](int i) {
                 if (i<low || high<i) error("vec index out of range");
                                          // индекс vec за границами
                 return elem(i);
             }
           
             main() {
                 vector a(10); for (int i=0; i<a.size(); i++) {
                     a[i] = i; cout << a[i] << " ";
                 }
                 cout <<  "\n";  vec  b(10,19);  for  (i=0;  i<b.size();  i++)
                 b[i+10] = a[i]; for (i=0; i<b.size(); i++) cout << b[i+10] <<
                 " "; cout << "\n";
             }
           
             Он выдает
           
             0 1 2 3 4 5 6 7 8 9
             0 1 2 3 4 5 6 7 8 9
           
             Это направление  развития  векторного  типа  можно  разрабатывать
           дальше. Довольно просто сделать многомерные массивы, массивы, в ко-
           торых число размерностей задается как параметр конструктора, масси-
           вы в стиле Фортрана,  к которым можно одновременно обращаться и как
           к имеющим две размерности, и как к имеющим три, и т.д.
             Так класс управляет доступом к некоторым данным.  Поскольку  весь
           доступ осуществляется через интерфейс, обеспеченный открытой частью
           класса, то можно использовать представление данных в соответствие с
           нуждами разработчика.  Например,  тривиально можно было бы поменять
           представление вектора на связанный  список.  Другая  сторона  этого
           состоит  в том,  что при заданной реализации можно обеспечить любой
           удобный интерфейс.
           
                1.14 Еще об операциях
           
             Другое направление развития - снабдить вектора операциями:
           
             class Vec : public vector { public:
                 Vec(int s)    :    (s)   {}   Vec(Vec&);   ~Vec()   {}   void
                 operator=(Vec&); void operator*=(Vec&); void operator*=(int);
                 //...
             };
           
             Обратите внимание на способ определения конструктора производного
           класса,  Vec::Vec(),  когда  он передает свой параметр конструктору
           базового класса vector::vector() и больше не делает ничего. Это по-
           лезная парадигма. Операция присваивания перегружена, ее можно опре-
           делить так:
           
             void Vec::operator=(Vec& a) {
                 int s  = size();  if (s!=a.size()) error("bad vector size for
                 =");
                                      // плохой размер вектора для =
                 for (int i = 0; i<s; i++) elem(i) = a.elem(i);
             }
           
             Присваивание объектов  класса  Vec  теперь действительно копирует
           элементы,  в то время как присваивание объектов vector просто копи-
           рует структуру,  управляющую доступом к элементам. Последнее, одна-
           ко,  происходит и тогда, когда vector копируется без явного исполь-
           зования операции присваивания:  (1) когда vector передается как па-
           раметр и (3) когда vector  передается  как  значение,  возвращаемое
           функцией.  Чтобы обрабатывать эти случаи для векторов Vec, вы опре-
           деляете конструктор Vec(Vec&):
           
             Vec::Vec(Vec& a) : (a.size()) {
                 int sz  =  a.size();  for  (int i = 0;  i<sz;  i++) elem(i) =
                 a.elem(i);
             }
           
             Этот конструктор инициализирует Vec как копию другого Vec,  и бу-
           дет вызываться в отмеченных выше случаях.
             Выражение в  левой части таких операций,  как = и +=,  безусловно
           определено,  поэтому кажется вполне естественным реализовать их как
           операции над объектом, который обозначается (денотируется) этим вы-
           ражением.  В частности,  тогда они смогут изменять значение  своего
           первого операнда. Левый операнд таких операций, как + и - не требу-
           ет особого внимания. Вы могли бы, например, передавать оба аргумен-
           та по значению и все равно получить правильную реализацию векторно-
           го сложения. Однако вектора могут оказаться большими, поэтому чтобы
           избежать  ненужного  копирования  операнды  операции + передаются в
           operator+() по ссылке:
           
             Vec operator+(Vec& a,Vec &b) {
                 int s  = a.size();  if (s != b.size()) error("bad vector size
                 for +");
                                        // плохой размер вектора для +
                 Vec sum(s); for (int i=0; i<s; i++)
                     sum.elem(i) = a.elem(i) + b.elem(i); return sum;
             }
           
             Вот пример небольшой программы,  которую  можно  выполнить,  если
           скомпилировать ее вместе с ранее приведенными описаниями vector:
           
             #include <stream.h>
           
             void error(char* p) { cerr << p << "\n"; exit(1);
             }
           
             void vector::set_size(int) { /*...*/ }
           
             int& vec::operator[](int i) { /*...*/ }
           
             main() {
                 Vec a(10);  Vec b(10);  for (int i=0; i<a.size(); i++) a[i] =
                 i;  b = a;  Vec c = a+b;  for (i=0;  i<c.size(); i++) cout <<
                 c[i] << "\n";
             }
                1.15 Друзья (friend)
           
             Функция operator+()  не воздействует непосредственно на представ-
           ление вектора.  Действительно, она не может этого делать, поскольку
           не является членом.  Однако иногда желательно дать функциям не чле-
           нам возможность доступа к закрытой части класса.  Например, если бы
           не было функции "доступа без проверки" vector::elem(), вам пришлось
           бы проверять индекс i на соответствие границам три раза  за  каждый
           проход цикла. Здесь мы избежали этой сложности, но она довольно ти-
           пична,  поэтому у класса есть механизм предоставления права доступа
           к  своей закрытой части функциям не членам.  Просто в класс помеща-
           ется описание функции,  перед которым стоит ключевое слово  friend.
           Например, если имеется
           
             class Vec; // Vec - имя класса
           
             class vector { friend Vec operator+(Vec, Vec); //...
             };
           
           То вы можете написать
           
             Vec operator+(Vec a, Vec b) {
                 int s  = a.size();  if (s != b.size()) error("bad vector size
                 for +");
                                        // плохой размер вектора для +
                 Vec& sum = *new Vec(s);  int* sp = sum.v; int* ap = a.v; int*
                 bp = b.v; while (s--) *sp++ = *ap++ + *bp++; return sum;
             }
           
             Одним из особенно полезных аспектов механизма friend является то,
           что  функция может быть другом двух и более классов.  Чтобы увидеть
           это,  рассмотрим определение vector и matrix,  а затем  определение
           функции умножения (см. #с.8.8).
           
                1.16 Обобщенные Вектора
           
             "Пока все хорошо," - можете сказать вы,  - "но я хочу, чтобы один
           из этих векторов был типа matrix,  который я только что определил."
           К сожалению, в С++ не предусмотрены средства для определения класса
           векторов с типом элемента в качестве параметра.  Один из способов -
           продублировать описание и класса, и его функций членов. Это не иде-
           альный способ, но зачастую вполне приемлемый.
           
             Вы можете воспользоваться препроцессором (#4.7),  чтобы механизи-
           ровать работу.  Например, класс vector - упрощенный вариант класса,
           который можно найти в стандартном заголовочном файле.  Вы могли  бы
           написать:
           
             #include <vector.h>
           
             declare(vector,int);
           
             main() {
                 vector(int) vv(10);  vv[2] = 3;  vv[10] = 4; // ошибка: выход
                 за границы
             }
             Файл vector.h  таким  образом  определяет  макросы,  чтобы макрос
           declare(vector,int) после расширения превращался в описание  класса
           vector,  очень похожий на тот, который был определен выше, а макрос
           implement(vector,int)  расширялся  в  определение   функций   этого
           класса.  Поскольку макрос implement(vector,int) в результате расши-
           рения превращается в определение функций,  его можно использовать в
           программе только один раз, в то время как declare(vector,int) долж-
           но использоваться по одному разу в каждом файле,  работающем с этим
           типом целых векторов.
           
             declare(vector,char);
             //...
             implement(vector,char);
           
           даст вам  отдельный тип "вектор символов".  Пример реализации обоб-
           щенных классов с помощью макросов приведен в #7.3.5.
           
                1.17 Полиморфные Вектора
           
             У вас есть другая возможность - определить ваш векторный и другие
           вмещающие классы через указатели на объекты некоторого класса:
           
             class common {
                 //...
             };
             class vector { common** v; //...
             public:
                 cvector(int); common*& elem(int);  common*&  operator[](int);
                 //...
             };
           
             Заметьте, что поскольку в таких векторах хранятся указатели, а не
           сами  объекты,  объект может быть "в" нескольких таких векторах од-
           новременно. Это очень полезное свойство подобных вмещающих классов,
           таких,  как вектора, связанные списки, множества и т.д. Кроме того,
           можно присваивать указатель на производный класс указателю  на  его
           базовый класс,  поэтому можно использовать приведенный выше cvector
           для хранения указателей  на  объекты  всех  производных  от  common
           классов. Например:
           
             class apple  :  public  common { /*...*/ } class orange :  public
             common { /*...*/ } class apple_vector : public cvector { public:
           
             cvector fruitbowl(100);
             //...
             apple aa;  orange oo;  //...  fruitbowl[0] = &aa;  fruitbowl[1] =
             &oo;  } Однако,  точный тип объекта,  вошедшего в такой вмещающий
             класс,
           больше компилятору не известен.  Например,  в предыдущем примере вы
           знаете,  что элемент вектора является common,  но является он apple
           или  orange?  Обычно точный тип должен впоследствии быть восстанов-
           лен,  чтобы обеспечить правильное использование объекта.  Для этого
           нужно или в какой-то форме хранить информацию о типе в самом объек-
           те, или обеспечить, чтобы во вмещающий класс помещались только объ-
           екты данного типа.  Последнее легко достигается с помощью производ-
           ного класса.  Вы можете,  например,  создать вектор  указателей  на
           apple:
           
             class apple_vector : public cvector { public:
                 apple*& elem(int i) { return (apple*&) cvector::elem(i); }
                 //...
             };
           
           используя запись приведения к типу (тип)выражение, чтобы преобразо-
           вать  common*& (ссылку на указатель на common),  которую возвращает
           cvector::elem, в apple*&. Такое применение производных классов соз-
           дает  альтернативу  обобщенным классам.  Писать его немного труднее
           (если не использовать  макросы  таким  образом,  чтобы  производные
           классы фактически реализовывали обобщенные классы,  см. #7.3.5), но
           оно имеет то преимущество,  что все  производные  классы  совместно
           используют  единственную  копию  функции базового класса.  В случае
           обобщенных классов,  таких,  как vector(type),  для каждого  нового
           используемого типа должна создаваться (с помощью implement()) новая
           копия таких функций.  Другой способ,  хранение идентификации типа в
           каждом  объекте,  приводит  нас  к стилю программирования,  который
           часто называют объекто-основанным или объектно-ориентированным.
           
                1.18 Виртуальные Функции
           
             Предположим, что мы пишем программу для изображения фигур на  эк-
           ране. Общие атрибуты фигуры представлены классом shape, а специаль-
           ные атрибуты - специальными классами:
           
             class shape { point center; color col; //...
             public:
                 void move(point to) { center=to;  draw();  } point where()  {
                 return   center;   }   virtual   void  draw();  virtual  void
                 rotate(int); //...
             };
             Функции, которые можно определить не зная точно определенной  фи-
           гуры (например, move и where, то есть, "передвинуть" и "где"), мож-
           но описать как обычно.  Остальные функции описываются как  virtual,
           то  есть  такие,  которые должны определяться в производном классе.
           Например:
           
             class circle: public shape { int radius;
             public:
                 void draw(); void rotatte(int i) {} //...
             };
           
           Теперь, если shape_vec - вектор фигур, то можно написать:
           
             for (int i = 0; i<no_of_shapes; i++) shape_vec[i].rotate(45);
           
           чтобы повернуть все фигуры на 45 градусов (и заново нарисовать)
           
             Такой стиль  особенно  полезен в интерактивных программах,  когда
           объекты разных типов одинаково обрабатываются основным  программным
           обеспечением.  Ведь по сути дела,  типичное действие пользователя -
           это ткнуть в какой-нибудь объект и сказать Кто ты?  Что ты такое? и
           Делай,  что надо! не давая никакой информации о типе. Программа мо-
           жет и должна уяснить это для себя сама.
