                                          Глава 5 Классы
           
                                                    Эти типы не  "абстрактны",
                                       они столь же реальны, как int и float.
                                                               - Дуг Макилрой
           
             В этой главе описываются возможности определения  новых  типов  в
           С++,  для  которых  доступ  к  данным ограничен заданным множеством
           функций доступа.  Объясняются способы защиты структуры  данных,  ее
           инициализации,  доступа к ней и,  наконец,  ее уничтожения. Примеры
           содержат простые классы для работы  с  таблицей  имен,  манипуляции
           стеком,  работу  с  множеством  и  реализацию дискриминирующего (то
           есть, "надежного") объединения. Две следующие главы дополнят описа-
           ние возможностей определения новых типов в С++ и познакомят читате-
           ля еще с некоторыми интересными примерами.
                              5.1 Знакомство и Краткий Обзор
           
             Предназначение понятия  класса,  которому  посвящены  эта  и  две
           последующие главы,  состоит в том,  чтобы предоставить программисту
           инструмент  для создания новых типов,  столь же удобных в обращении
           сколь и встроенные типы.  В идеале тип определяемый  пользователем,
           способом использования должен отличаться от встроенных типов, толь-
           ко способом создания.
           
             Тип есть конкретное представление некоторой концепции  (понятия).
           Например, имеющийся в С++ тип float с его операциями +, -, * и т.д.
           обеспечивает ограниченную, но конкретную версию математического по-
           нятия  действительного числа.  Новый тип создается для того,  чтобы
           дать специальное и конкретное определение понятия,  которому  ничто
           прямо  и очевидно среди встроенных типов не отвечает.  Например,  в
           программе,  которая работает с телефоном, можно было бы создать тип
           trunk_module (элемент линии), а в программе обработки текстов - тип
           list_of_paragraphs (список параграфов).  Как правило,  программу, в
           которой создаются типы,  хорошо отвечающие понятиям приложения, по-
           нять легче,  чем программу,  в которой это не делается. Хорошо выб-
           ранные  типы,  определяемые  пользователем,  делают программу более
           четкой и короткой. Это также позволяет компилятору обнаруживать не-
           допустимые использования объектов, которые в противном случае оста-
           нутся необнаруженными до тестирования программы.
           
             В определении нового типа основная идея - отделить несущественные
           подробности реализации (например,  формат данных, которые использу-
           ются для хранения объекта типа) от тех качеств, которые существенны
           для его правильного использования (например, полный список функций,
           которые имеют доступ к данным). Такое разделение можно описать так,
           что  работа  со  структурой  данных и внутренними административными
           подпрограммами осуществляется через специальный интерфейс  (канали-
           зируется).
             Эта глава состоит из четырех практически отдельных частей:
           
             #5.2 Классы и Члены. Этот раздел знакомит с основным понятием
                типа, определяемого  пользователем,  который  называется класс
                (class). Доступ к объектам класса может ограничиваться набором
                функций, которые описаны как часть этого класса. Такие функции
                называются функциями членами.  Объекты класса создаются и ини-
                циализируются  функциями  членами,  специально  для  этой цели
                описанными.  Эти функции  называются  конструкторами.  Функция
                член может быть специальным образом описана для "очистки" каж-
                дого классового объекта при его уничтожении. Такая функция на-
                зывается деструктором.
           
             #5.3 Интерфейсы и Реализации. В этом разделе приводится два
                примера того, как класс проектируется, реализуется и использу-
                ется.
           
             #5.4 Друзья и Объединения. В этом разделе приводится много
                дополнительных подробностей, касающихся классов. В нем показа-
                но,  как  предоставить доступ к закрытой части класса функции,
                которая не является членом этого класса. Такая функция называ-
                ется друг (friend). В этом разделе показано также, как опреде-
                лить дискриминирующее объединение.
           
             #5.5 Конструкторы и Деструкторы. Объект может создаваться как
                автоматический, статический или как объект в свободной памяти.
                Объект может также быть членом  некоторой  совокупности  (типа
                вектора или класса),  которая в свою очередь может размещаться
                одним из этих трех  способов.  Довольно  подробно  объясняется
                использование конструкторов и деструкторов.
           
                5.2 Классы и Члены
           
             Класс - это определяемый пользователем тип.  Этот раздел знакомит
           с основными средствами определения класса, создания объекта класса,
           работы  с такими объектами и,  наконец,  уничтожения таких объектов
           после использования.
                5.2.1 Функции Члены
           
             Рассмотрим реализацию  понятия  даты  с использованием struct для
           того,  чтобы определить представление даты date и множества функций
           для работы с переменными этого типа:
           
             struct date { int month, day, year; };
                 // дата: месяц, день, год }
             date today;   void   set_date(date*,   int,   int,   int);   void
             next_date(date*); void print_date(date*); // ...
           
             Никакой явной связи между функциями и  типом  данных  нет.  Такую
           связь можно установить, описав функции как члены:
           
             struct date { int month, day, year;
           
             void set(int, int, int); void get(int*, int*, int*); void next();
             void print(); };
           
             Функции, описанные таким образом,  называются функциями членами и
           могут вызываться только для специальной переменной соответствующего
           типа с использованием стандартного синтаксиса для доступа к  членам
           структуры. Например:
           
             date today; // сегодня date my_burthday; // мой день рождения
           
             void f() {
                 my_burthday.set(30,12,1950); today.set(18,1,1985);
           
                 my_burthday.print(); today.next();
             }
           
             Поскольку разные структуры могут иметь функции члены с одинаковы-
           ми именами,  при определении функции члена необходимо указывать имя
           структуры:
           
             void date::next() {
                 if ( ++day > 28 ) {
                     // делает сложную часть работы
                 }
             }
           
             В функции члене имена членов могут использоваться без явной ссыл-
           ки на объект. В этом случае имя относится к члену того объекта, для
           которого функция была вызвана.
                5.2.2 Классы
           
             Описание date в предыдущем подразделе дает множество функций  для
           работы  с  date,  но  не  указывает,  что  эти  функции должны быть
           единственными для доступа к объектам  типа  date.  Это  ограничение
           можно наложить используя вместо struct class:
           
             class date { int month, day, year;
             public:
                 void set(int,  int,  int);  void get(int*,  int*, int*); void
                 next(); void print();
             };
           
             Метка public:  делит  тело  класса на две части.  Имена в первой,
           закрытой части, могут использоваться только функциями членами. Вто-
           рая,  открытая часть, составляет интерфейс к объекту класса. Struct
           - это просто class,  у которого все члены классы открытые,  поэтому
           функции члены определяются и используются точно так же,  как в пре-
           дыдущем случае. Например:
           
             void date::ptinr() // печатает в записи, принятой в США {
                 cout << month << "/" << day << "/" year;
             }
           
             Однако функции не члены отгорожены от использования закрытых чле-
           нов класса date. Например:
           
             void backdate() {
                 today.day--; // ошибка
             }
           
             В том,  что  доступ  к  структуре данных ограничен явно описанным
           списком функций,  есть несколько преимуществ. Любая ошибка, которая
           приводит  к тому,  что дата принимает недопустимое значение (напри-
           мер, Декабрь 36, 1985) должна быть вызвана кодом функции члена, по-
           этому первая стадия отладки,  локализация, выполняется еще до того,
           как программа будет запущена.  Это частный случай общего  утвержде-
           ния, что любое изменение в поведении типа date может и должно вызы-
           ваться изменениями в его членах.  Другое преимущество - это то, что
           потенциальному  пользователю  такого типа нужно будет только узнать
           определение функций членов, чтобы научиться им пользоваться.
           
             Защита закрытых данных связана с ограничением использования  имен
           членов класса.  Это можно обойти с помощью манипуляции адресами, но
           это уже, конечно, жульничество.
                5.2.3 Ссылки на Себя
           
             В функции члене на члены объекта,  для которого она была вызвана,
           можно ссылаться непосредственно. Например:
           
             class x { int m;
             public:
                 int readm() { return m; }
             };
           
             x aa; x bb;
           
             void f() {
                 int a = aa.readm(); int b = bb.readm(); // ...
             }
           
             В первом вызове члена member() m относится к aa.m,  а во втором -
           к bb.m.
           
             Указатель на объект,  для которого вызвана функция член, является
           скрытым  параметром  функции.  На  этот неявный параметр можно ссы-
           латься явно как на this.  В каждой функции класса x указатель  this
           неявно описан как
           
             x* this;
           
           и инициализирован так, что он указывает на объект, для которого бы-
           ла вызвана функция член.  this не может быть описан явно,  так  как
           это  ключевое  слово.  Класс  x можно эквивалентным образом описать
           так:
           
             class x { int m;
             public:
                 int readm() { return this->m; }
             };
             При ссылке на члены использование this излишне.  Главным  образом
           this используется при написании функций членов, которые манипулиру-
           ют непосредственно указателями.  Типичный пример этого  -  функция,
           вставляющая звено в дважды связанный список:
           
             class dlink { dlink* pre; // предшествующий dlink* suc; // следу-
                 ющий
             public:
                 void append(dlink*);
                 // ...
             };
           
             void dlink::append(dlink* p) {
                 p->suc = suc;  // то есть,  p->suc = this->suc p->pre = this;
                 // явное  использование  this  suc->pre  =  p;  //  то  есть,
                 this->suc->pre = p suc = p; // то есть, this->suc = p
             }
           
             dlink* list_head;
           
             void f(dlink*a, dlink *b) {
                 // ...
                 list_head->append(a); list_head->append(b);
             }
           
             Цепочки такой   общей  природы  являются  основой  для  списковых
           классов,  которые описываются в Главе 7. Чтобы присоединить звено к
           списку необходимо обновить объекты,  на которые указывают указатели
           this,  pre и suc (текущий,  предыдущий и последующий). Все они типа
           dlink,  поэтому  функция  член  dlink::append() имеет к ним доступ.
           Единицей защиты в С++ является class, а не отдельный объект класса.
                5.2.4 Инициализация
           
             Использование для  обеспечения инициализации объекта класса функ-
           ций вроде set_date() (установить дату) неэлегантно и чревато  ошиб-
           ками.  Поскольку нигде не утверждается, что объект должен быть ини-
           циализирован,  то программист может забыть это  сделать,  или  (что
           приводит, как правило, к столь же разрушительным последствиям) сде-
           лать это дважды.  Есть более хороший подход: дать возможность прог-
           раммисту  описать  функцию,  явно предназначенную для инициализации
           объектов. Поскольку такая функция конструирует значения данного ти-
           па, она называется конструктором. Конструктор распознается по тому,
           что имеет то же имя, что и сам класс. Например:
           
             class date {
                 // ...
                 date(int, int, int);
             };
           
             Когда класс  имеет  конструктор,  все  объекты этого класса будут
           инициализироваться.  Если для  конструктора  нужны  параметры,  они
           должны даваться:
           
             date today = date(23,6,1983);  date xmas(25,12,0); // сокращенная
             форма
                                     // (xmas - рождество)
             date my_burthday; // недопустимо, опущена инициализация
           
             Часто бывает хорошо обеспечить несколько  способов  инициализации
           объекта класса.  Это можно сделать,  задав несколько конструкторов.
           Например:
           
             class date { int month, day, year;
             public:
                 // ...
                 date(int, int, int); // день месяц год date(char*); // дата в
                 строковом представлении date(int);  // день,  месяц и год се-
                 годняшние date(); // дата по умолчанию: сегодня
             };
           
             Конструкторы подчиняются тем же правилам относительно типов пара-
           метров, что и перегруженные функции (#4.6.7). Если конструкторы су-
           щественно различаются по типам своих параметров,  то компилятор при
           каждом использовании может выбрать правильный:
           
             date today(4);  date  july4("Июль 4,  1983");  date guy("5 Ноя");
             date now; // инициализируется по умолчанию
           
             Заметьте, что функции члены могут  быть  перегружены  без  явного
           использования  ключевого  слова  overload.  Поскольку полный список
           функций членов находится в описании класса и как правило  короткий,
           то  нет  никакой  серьезной  причины  требовать использования слова
           overload для  предотвращения  случайного  повторного  использования
           имени.
             Размножение конструкторов в примере с date типично. При разработ-
           ке  класса всегда есть соблазн обеспечить "все",  поскольку кажется
           проще обеспечить какое-нибудь средство просто на  случай,  что  оно
           кому-то  понадобится или потому,  что оно изящно выглядит,  чем ре-
           шить, что же нужно на самом деле. Последнее требует больших размыш-
           лений, но обычно приводит к программам, которые меньше по размеру и
           более понятны. Один из способов сократить число родственных функций
           - использовать параметры со значением по умолчанию,  пример. В слу-
           чае date для каждого параметра можно задать значение по  умолчанию,
           интерпретируемое как "по умолчанию принимать: today" (сегодня).
           
             class date { int month, day, year;
             public:
                 // ...
                 date(int d =0,  int m =0,  int y =0);  date(char*); // дата в
                 строковом представлении
             };
           
             date::date(int d, int m, int y) {
                 day = d ?  d : today.day; month = m ? m : today.month; year =
                 y ? y : today.year; // проверка, что дата допустимая // ...
             }
           
             Когда используется  значение  параметра,  указывающее  "брать  по
           умолчанию",  выбранное значение должно лежать вне множества возмож-
           ных значений параметра.  Для дня day и месяца mounth ясно,  что это
           так,  но для года year выбор нуля неочевиден.  К счастью,  в  евро-
           пейском  календаре  нет  нулевого года .  Сразу после 1 г.  до н.э.
           (year==-1) идет 1 г.  н.э. (year==1), но для реальной программы это
           может оказаться слишком тонко.
           
             Объект класса  без  конструкторов  можно  инициализировать  путем
           присваивания ему другого объекта этого класса.  Это можно делать  и
           тогда, когда конструкторы описаны. Например:
           
             date d = today; // инициализация посредством присваивания
           
             По существу,  имеется конструктор по умолчанию,  определенный как
           побитовая копия объекта того же класса.  Если для  класса  X  такой
           конструктор  по  умолчанию  нежелателен,  его  можно переопределить
           конструктором с именем X(X&). Это будет обсуждаться в #6.6.
                5.2.5 Очистка
           
             Определяемый пользователем   тип   чаще   имеет,  чем  не  имеет,
           конструктор,  который обеспечивает  надлежащую  инициализацию.  Для
           многих типов также требуется обратное действие,  деструктор,  чтобы
           обеспечить соответствующую очистку объектов этого типа.  Имя  дест-
           руктора для класса X есть ~X() ("дополнение конструктора"). В част-
           ности,  многие типы используют некоторый объем памяти из  свободной
           памяти (см.  #3.2.6), который выделяется конструктором и освобожда-
           ется деструктором. Вот, например, традиционный стековый тип, из ко-
           торого для краткости полностью выброшена обработка ошибок:
           
             class char_stack { int size; char* top; char* s;
             public:
                 char_stack(int sz) { top=s=new char[size=sz]; }
                 ~char_stack() { delete s; } // деструктор
                 void push(char  c)  {  *top++  =  c;  }  char  pop() { return
                 *--top;}
             }
           
             Когда char_stack  выходит из области видимости,  вызывается дест-
           руктор:
           
             void f() {
                 char_stack s1(100);    char_stack    s2(200);   s1.push('a');
                 s2.push(s1.pop());  char ch = s2.pop();  cout <<  chr(ch)  <<
                 "\n";
             }
           
             Когда вызывается f(),  конструктор char_stack вызывается для  s1,
           чтобы  выделить  вектор из 100 символов,  и для s2,  чтобы выделить
           вектор из 200 символов.  При возврате из f() эти два вектора  будут
           освобождены.
                5.2.6 Inline
           
             При программировании с использованием классов очень часто исполь-
           зуется  много маленьких функций.  По сути,  везде,  где в программе
           традиционной  структуры  стояло  бы  просто  какое-нибудь   обычное
           использование структуры данных, дается функция. То, что было согла-
           шением,  стало стандартом, который распознает компилятор. Это может
           страшно понизить эффективность, потому что стоимость вызова функции
           (хотя и вовсе не высокая по сравнению с другими языками) все  равно
           намного выше, чем пара ссылок по памяти, необходимая для тела функ-
           ции.
           
             Чтобы справиться  с  этой  проблемой,  был   разработан   аппарат
           inline-функций.  Функция,  определенная  (а  не просто описанная) в
           описании класса,  считается inline.  Это значит,  например,  что  в
           функциях, которые используют приведенные выше char_stack, нет ника-
           ких вызовов функций кроме тех,  которые используются для реализации
           операций вывода! Другими словами, нет никаких затрат времени выпол-
           нения,  которые стоит принимать во внимание при разработке  класса.
           Любое,  даже самое маленькое действие, можно задать эффективно. Это
           утверждение снимает аргумент, который чаще всего приводят чаще все-
           го в пользу открытых членов данных.
           
             Функцию член  можно также описать как inline вне описания класса.
           Например:
           
             char char_stack { int size; char* top; char* s;
             public:
                 char pop();
                 // ...
             };
           
             inline char char_stack::pop() {
                 return *--top;
             }
                5.3 Интерфейсы и Реализации
           
             Что представляет собой хороший класс?  Нечто, имеющее небольшое и
           хорошо определенное множество действий. Нечто, что можно рассматри-
           вать  как  "черный  ящик",  которым манипулируют только посредством
           этого множества действий. Нечто, чье фактическое представление мож-
           но любым мыслимым способом изменить, не повлияв на способ использо-
           вания множества действий. Нечто, чего можно хотеть иметь больше од-
           ного.
           
             Для всех видов контейнеров существуют очевидные примеры:
           таблицы, множества,  списки,  вектора,  словари и т.д.  Такой класс
           имеет операцию "вставить",  обычно он также имеет операции для про-
           верки того,  был ли вставлен  данный  элемент.  В  нем  могут  быть
           действия  для  осуществления проверки всех элементов в определенном
           порядке,  и кроме всего прочего,  в нем может иметься операция  для
           удаления элемента.  Обычно контейнерные (то есть, вмещающие) классы
           имеют конструкторы и деструкторы.
           
             Сокрытие данных и продуманный интерфейс может дать концепция  мо-
           дуля (см. например #4.4: файлы как модули). Класс, однако, является
           типом.  Чтобы использовать его,  необходимо создать  объекты  этого
           класса,  и  таких объектов можно создавать столько,  сколько нужно.
           Модуль же сам является объектом.  Чтобы использовать его,  его надо
           только инициализировать, и таких объектов ровно один.
                5.3.1 Альтернативные Реализации
           
             Пока описание открытой части класса  и  описание  функций  членов
           остаются  неизменными,  реализацию  класса  можно модифицировать не
           влияя на ее пользователей.  Как  пример  этого  рассмотрим  таблицу
           имен,  которая  использовалась в настольном калькуляторе в Главе 3.
           Это таблица имен:
           
             struct name { char* string; char* next; double value;
             };
           
           Вот вариант класса table:
           
             // файл table.h
           
             class table { name* tbl;
             public:
                 table() { tbl = 0; }
           
             name* look(char*,  int  =  0);  name*  insert(char*  s)  { return
             look(s,1); } };
           
             Эта таблица отличается от той,  которая определена в Главе 3 тем,
           что  это настоящий тип.  Можно описать более чем одну table,  можно
           иметь указатель на table и т.д. Например:
           
             #include "table.h"
           
             table globals; table keywords; table* locals;
           
             main() { locals = new table; // ...
             }
           
             Вот реализация table::look(), которая использует линейный поиск в
           связанном списке имен name в таблице:
           
             #include <string.h>
           
             name* table::look(char* p, int ins) {
                 for (name* n = tbl;  n; n=n->next) if (strcmp(p,n->string) ==
                     0) return n;
           
                 if (ins == 0) error("имя не найдено");
           
                 name* nn = new  name;  nn->string  =  new  char[strlen(p)+1];
                 strcpy(nn->string,p);  nn->value = 1;  nn->next = tbl;  tbl =
                 nn; return nn;
             }
             Теперь рассмотрим класс table, усовершенствованный таким образом,
           чтобы использовать хэшированный просмотр, как это делалось в приме-
           ре с настольным калькулятором. Сделать это труднее из-за того огра-
           ничения,  что  уже  написанные программы,  в которых использовалась
           только что определенная версия класса table, должны оставаться вер-
           ными без изменений:
           
             class table { name** tbl; int size;
             public:
                 table(int sz = 15);
                 ~table();
           
             name* look(char*,  int =  0);  name*  insert(char*  s)  {  return
             look(s,1); } };
           
             В структуру  данных  и конструктор внесены изменения,  отражающие
           необходимость того, что при использовании хэширования таблица долж-
           на иметь определенный размер.  Задание конструктора с параметром по
           умолчанию обеспечивает,  что старая программа,  в которой не указы-
           вался размер таблицы,  останется правильной. Параметры по умолчанию
           очень полезны в ситуации,  когда нужно изменить класс не повлияв на
           старые программы. Теперь конструктор и деструктор создают и уничто-
           жают хэш-таблицы:
           
             table::table(int sz) {
                 if (sz < 0) error("отрицательный размер таблицы");  tbl = new
                 name*[size=sz]; for (int i = 0; i<sz; i++) tbl[i] = 0;
             }
           
             table::~table() {
                 for (int i = 0;  i<size;  i++) for  (name*  n  =  tbl[i];  n;
                     n=n->next) {
                         delete n->string; delete n;
                     }
                     delete tbl;
             }
             Описав деструктор для класса name можно получить более простой  и
           ясный вариант table::~table().  Функция просмотра практически иден-
           тична той, которая использовалась в примере настольного калькулято-
           ра (#3.1.3):
           
             #include <string.h>
           
             name* table::look(char* p, int ins) {
                 int ii = 0;  char* pp = p; while (*pp) ii = ii<<1 ^ *pp++; if
                 (ii < 0) ii = -ii; ii %= size;
           
                 for (name* n=tbl[ii];  n;  n=n->next) if (strcmp(p,n->string)
                     == 0) return n;
           
                 if (ins == 0) error("имя не найдено");
           
                 name* nn = new  name;  nn->string  =  new  char[strlen(p)+1];
                 strcpy(nn->string,p);  nn->value  =  1;  nn->next  = tbl[ii];
                 tbl[ii] = nn; return nn;
           
             }
           
             Очевидно, что функции члены класса должны заново  компилироваться
           всегда,  когда  вносится какое-либо изменение в описание класса.  В
           идеале такое изменение никак не должно отражаться на  пользователях
           класса.  К сожалению, это не так. Для размещения переменной классо-
           вого типа компилятор должен знать размер объекта класса.  Если раз-
           мер этих объектов меняется, то файлы, в которых класс используется,
           нужно компилировать заново.  Можно написать такую программу (и  она
           уже  написана),  которая определяет множество (минимальное) файлов,
           которое необходимо компилировать заново  после  изменения  описания
           класса, но пока что широкого распространения она не получила.
             Почему, можете вы спросить, С++ разработан так, что после измене-
           ния   закрытой  части  необходима  новая  компиляция  пользователей
           класса?  И действительно,  почему вообще закрытая часть должна быть
           представлена в описании класса?  Другими словами, раз пользователям
           класса не разрешается  обращаться  к  закрытым  членам,  почему  их
           описания  должны  приводиться в заголовочных файлах,  которые,  как
           предполагается, пользователь читает? Ответ - эффективность. Во мно-
           гих  системах и процесс компиляции,  и последовательность операций,
           реализующих вызов функции,  проще, когда размер автоматических объ-
           ектов (объектов в стеке) известен во время компиляции.
           
             Этой сложности  можно  избежать,  представив каждый объект класса
           как указатель на "настоящий" объект.  Так как все эти указатели бу-
           дут иметь одинаковый размер, а размещение "настоящих" объектов мож-
           но определить в файле,  где доступна закрытая часть,  то это  может
           решить проблему. Однако решение подразумевает дополнительные ссылки
           по памяти при обращении к членам класса,  а также,  что  еще  хуже,
           каждый  вызов  функции с автоматическим объектом класса включает по
           меньшей мере один вызов программ выделения и освобождения свободной
           памяти.  Это сделало бы также невозможным реализацию inline-функций
           членов, которые обращаются к данным закрытой части. Более того, та-
           кое  изменение  сделает  невозможным  совместную компоновку C и С++
           программ (поскольку C компилятор обрабатывает struct  не  так,  как
           это будет делать С++ компилятор). Для С++ это было сочтено неприем-
           лемым.
           
                5.3.2 Законченный Класс
           
             Программирование без сокрытия  данных  (с  применением  структур)
           требует  меньшей  продуманности,  чем программирование со сокрытием
           данных (с использованием классов).  Структуру можно  определить  не
           слишком  задумываясь о том,  как ее предполагается использовать.  А
           когда определяется класс, все внимание сосредотачивается на обеспе-
           чении  нового типа полным множеством операций;  это важное смещение
           акцента.  Время, потраченное на разработку нового типа, обычно мно-
           гократно окупается при разработке и тестировании программы.
           
             Вот пример  законченного  типа intset,  который реализует понятие
           "множество целых":
           
             class intset { int cursize, maxsize; int *x;
             public:
                 intset(int m, int n); // самое большее, m int'ов в 1..n
                 ~intset();
           
                 int member(int   t);   //   является  ли  t  элементом?  void
                 insert(int t); // добавить "t" в множество
           
                 void iterate(int& i) { i = 0;  }  int  ok(int&  i)  {  return
                 i<cursize; } int next(int& i) { return x[i++]; }
             };
             Чтобы протестировать этот класс, можно создать и распечатать мно-
           жество случайных целых чисел. Такое множество могло бы быть резуль-
           татом розыгрыша лотереи.  Это простое множество можно также исполь-
           зовать для проверки последовательности целых  на  повторы.  Но  для
           большинства приложений тип множество должен быть немного более про-
           работанным. Как всегда, возможны ошибки:
           
             #include <stream.h>
           
             void error(char* s) {
                 cerr << "set: " << s << "\n"; exit(1);
             }
           
             Класс intset используется в main(),  которая предполагает два це-
           лых параметра.  Первый параметр задает число случайных чисел, кото-
           рые нужно сгенерировать.  Второй параметр указывает диапазон, в ко-
           тором должны лежать случайные целые:
           
             main(int argc, char* argv[]) {
                 if (argc != 3) error("ожидается два параметра");  int count =
                 0;  int m = atoi(argv[1]); // число элементов множества int n
                 = atoi(argv[2]); // в диапазоне 1..n intset s(m,n);
           
                 while (count<m) { int t = randint(n); if (s.member(t)==0) {
                         s.insert(t); count++;
                     }
                 }
           
                 print_in_order(&s);
             }
           
             В программе,  для которой требуется два параметра,  счетчик числа
           параметров,  argc,  должен равняться трем, потому что имя программы
           всегда передается как argv[0]. Функция
           
             extern int atoi(char*);
           
           функция atoi() это стандартная библиотечная функция для  преобразо-
           вания  представления  целого в виде строки в его внутреннюю (двоич-
           ную) форму.  Случайные числа  генерируются  с  помощью  стандартной
           функции rand():
           
             extern int rand(); // Не очень случайные, будьте осторожны
           
             int randint(int u) // в диапазоне 1..u {
                 int r = rand(); if (r < 0) r = -r; return 1 + r%u ;
             }
             Подробности реализации класса должны представлять для пользовате-
           ля  весьма  незначительный  интерес,  но здесь в любом случае будут
           функции члены.  Конструктор выделяет целый вектор заданного  макси-
           мального размера множества, а деструктор освобождает его:
           
             intset::intset(int m, int n) // самое большее, m int'ов в 1..n {
                 if (m<1 || n<m) error("недопустимый размер intset");  cursize
                 = 0; maxsize = m; x = new int[maxsize];
             }
           
             intset::~intset() {
                 delete x;
             }
           
             Целые числа вставляются,  поэтому они хранятся в возрастающем по-
           рядке:
           
             void intset::insert(int t) {
                 if (++cursize > maxsize)  error("слишком  много  элементов");
                 int i = cursize-1; x[i] = t;
           
                 while (i>0  &&  x[i-1]>x[i])  { int t = x[i];  // переставить
                     x[i] и [i-1] x[i] = x[i-1]; x[i-1] = t; i--;
                 }
             }
           
           Для нахождения членов используется просто двоичный поиск:
           
             int intset::member(int t) // двоичный поиск {
                 int l = 0; int u = cursize-1;
           
                 while (l <= u) { int m = (l+u)/2; if (t < x[m])
                         u = m-1; else if (t > x[m])
                         l = m+1; else
                         return 1; // найдено
                 }
                 return 0; // не найдено
             }
             И, наконец,  нам нужно обеспечить множество операций, чтобы поль-
           зователь  мог  осуществлять  цикл по множеству в некотором порядке,
           поскольку представление intset от  пользователя  скрыто.  Множество
           внутренней  упорядоченности  не  имеет,  поэтому мы не можем просто
           дать возможность обращаться к вектору (завтра я, наверное, реализую
           intset по-другому, в виде связанного списка).
           
             Дается три  функции:  iterate() для инициализации итерации,  ok()
           для проверки,  есть ли следующий элемент,  и next() для того, чтобы
           взять следующий элемент:
           
             class intset {
                 // ...
                 void iterate(int&  i)  {  i  =  0;  } int ok(int& i) { return
                 i<cursize; } int next(int& i) { return x[i++]; }
             };
           
             Чтобы дать  возможность  этим трем операциям работать совместно и
           чтобы запомнить,  куда дошел цикл,  пользователь должен дать  целый
           параметр.  Поскольку элементы хранятся в отсортированном списке, их
           реализация тривиальна.  Теперь можно определить функцию  печати  по
           порядку print_in_order:
           
             void print_in_order(intset* set) {
                 int var;  set->iterate(var);  while  (set->ok(var))  cout  <<
                 set->next(var) << "\n";
             }
           
           Другой способ задать итератор приводится в #6.8.
                5.4 Друзья и Объединения
           
             В это  разделе описываются еще некоторые особенности,  касающиеся
           классов.  Показано, как предоставить функции не члену доступ к зак-
           рытым членам. Описывается, как разрешать конфликты имен членов, как
           можно делать вложенные описания классов, и как избежать нежелатель-
           ной вложенности.  Обсуждается также,  как объекты класса могут сов-
           местно использовать члены данные,  и как использовать указатели  на
           члены.  Наконец,  приводится  пример,  показывающий,  как построить
           дискриминирующее (экономное) объединение.
           
                5.4.1 Друзья
           
             Предположим, вы определили два класса,  vector и matrix (вектор и
           матрица). Каждый скрывает свое представление и предоставляет полный
           набор действий для манипуляции объектами его типа. Теперь определим
           функцию, умножающую матрицу на вектор. Для простоты допустим, что в
           векторе четыре элемента, которые индексируются 0...3, и что матрица
           состоит из четырех векторов, индексированных 0...3. Допустим также,
           что доступ к элементам вектора осуществляется через функцию elem(),
           которая осуществляет проверку индекса,  и что в matrix имеется ана-
           логичная функция.  Один подход  состоит  в  определении  глобальной
           функции multiply() (перемножить) примерно следующим образом:
           
             vector multiply(matrix& m, vector& v); {
                 vector r; for (int i = 0; i<3; i++) { // r[i] = m[i] * v;
                     r.elem(i) = 0; for (int j = 0; j<3; j++)
                         r.elem(i) += m.elem(i,j) * v.elem(j);
                 }
                 return r;
             }
           
             Это своего рода "естественный" способ,  но он очень неэффективен.
           При каждом обращении к multiply() elem() будет вызываться 4*(1+4*3)
           раза.
             Теперь, если мы сделаем multiply() членом класса vector,  мы смо-
           жем  обойтись без проверки индексов при обращении к элементу векто-
           ра, а если мы сделаем multiply() членом класса matrix, то мы сможем
           обойтись  без  проверки  индексов при обращении к элементу матрицы.
           Однако членом  двух  классов  функция  быть  не  может.  Нам  нужно
           средство  языка,  предоставляющее  функции право доступа к закрытой
           части класса.  Функция не член, получившая право доступа к закрытой
           части класса, называется другом класса (friend). Функция становится
           другом класса после описания как friend. Например:
           
             class matrix;
           
             class vector { float v[4]; // ... friend vector multiply(matrix&,
                 vector&);
             };
           
             class matrix   {   vector   v[4];   //    ...    friend    vector
                 multiply(matrix&, vector&);
             };
           
             Функция друг не имеет никаких особенностей,  помимо права доступа
           к закрытой части класса.  В частности, friend функция не имеет ука-
           зателя this (если только она не является полноправным членом  функ-
           цией). Описание friend - настоящее описание. Оно вводит имя функции
           в самой внешней области видимости программы и сопоставляется с дру-
           гими описаниями этого имени. Описание друга может располагаться или
           в закрытой,  или в открытой части описания класса. Где именно, зна-
           чения не имеет.
           
             Теперь можно написать функцию умножения,  которая использует эле-
           менты векторов и матрицы непосредственно:
           
             vector multiply(matrix& m, vector& v); {
                 vector r; for (int i = 0; i<3; i++) { // r[i] = m[i] * v;
                     r.v[i] = 0; for (int j = 0; j<3; j++)
                         r.v[i] += m.v[i][j] * v.v[j];
                 }
                 return r;
             }
             Есть способы  преодолеть эту конкретную проблему эффективности не
           используя аппарат friend (можно было бы определить операцию вектор-
           ного  умножения  и определить multiply() с ее помощью).  Однако су-
           ществует много задач,  которые проще всего решаются, если есть воз-
           можность предоставить доступ к закрытой части класса функции, кото-
           рая не является членом этого класса.  В Главе 6 есть много примеров
           применения friend. Достоинства функций друзей и членов будут обсуж-
           даться позже.
           
             Функция член одного класса может быть другом другого. Например:
           
             class x {
                 // ...
                 void f();
             };
           
             class y {
                 // ...
                 friend void x::f();
             };
           
             Нет ничего необычного в том,  что все функции члены одного класса
           являются  друзьями  другого.  Для этого есть даже более краткая за-
           пись:
           
             class x { friend class y; // ...
             };
           
             Такое описание  friend делает все функции члены класса y друзьями
           x.
                5.4.2 Уточнение* Имени Члена
           
             Иногда полезно  делать явное различие между именами членов класса
           и прочими именами.  Для этого используется операция ::, "разрешения
           области видимости":
           
             class x { int m;
             public:
                 int readm() { return x::m; } void setm(int m) { x::m = m; }
             };
           
             В x::setm() имя параметра m прячет член m,  поэтому  единственный
           способ  сослаться  на  член  -  это использовать его уточненное имя
           x::m. Операнд в левой части :: должен быть именем класса.
           
             Имя с префиксом ::  (просто) должно быть глобальным  именем.  Это
           особенно  полезно  для  того,  чтобы  можно было использовать часто
           употребимые имена вроде read,  put и open как имена функций членов,
           не теряя при этом возможности обращаться к той версии функции,  ко-
           торая не является членом. Например:
           
             class my_file {
                 // ...
             public:
                 int open(char*, char*);
             };
           
             int my_file::open(char* name, char* spec) {
                 // ...
                 if (::open(name,flag)) { // использовать open() из UNIX(2)
                     // ...
                 }
                 // ...
             }
           
           ────────────────────
           * Иногда называется также квалификацией. (прим. перев.)
                5.4.3 Вложенные Классы
           
             Описание класса может быть вложенным. Например:
           
             class set { struct setmem {
                     int mem;  setmem* next; setmem(int m, setmem* n) { mem=m;
                     next=n; }
                 };
                 setmem* first; public:
                 set() {   first=0;   }   insert(int   m)   {   first   =  new
                 setmem(m,first);} // ...
             };
           
             Если только  вложенный  класс не является очень простым,  в таком
           описании трудно разобраться.  Кроме того, вложение классов - это не
           более  чем соглашение о записи,  поскольку вложенный класс не явля-
           ется скрытым в области видимости лексически охватывающего класса:
           
             class set { struct setmem {
                     int mem; setmem* next; setmem(int m, setmem* n)
                 };
                 // ...
             };
           
                 setmem::setmem(int m,  setmem* n)  {  mem=m,  next=n}  setmem
                 m1(1,0);
           
             Такая запись, как set::setmem::setmem(), не является ни необходи-
           мой,  ни допустимой.  Единственный способ скрыть имя класса  -  это
           сделать это с помощью метода файлы-как-модули (#4.4). Большую часть
           нетривиальных классов лучше описывать раздельно:
           
             class setmem { friend class set;  // доступ только с помощью чле-
             нов set
                 int mem;  setmem* next;  setmem(int m,  setmem* n)  {  mem=m;
                 next=n; } };
           
             class set { setmem* first;
             public:
                 set() {   first=0;   }   insert(int   m)   {   first   =  new
                 setmem(m,first);} // ...
             };
                5.4.4 Статические Члены
           
             Класс - это тип,  а не объект данных,  и в каждом объекте  класса
           имеется своя собственная копия данных,  членов этого класса. Однако
           некоторые типы наиболее элегантно  реализуются,  если  все  объекты
           этого  типа могут совместно использовать (разделять) некоторые дан-
           ные.  Предпочтительно,  чтобы такие разделяемые данные были описаны
           как часть класса.  Например, для управления задачами в операционной
           системе или в ее модели часто бывает полезен список всех задач:
           
             class task {
                 // ...
                 task* next;  static task* task_chain; void shedule(int); void
                 wait(event); // ...
             };
           
             Описание члена task_chain (цепочка задач) как static  обеспечива-
           ет,  что  он  будет всего лишь один,  а не по одной копии на каждый
           объект task. Он все равно остается в области видимости класса task,
           и  "извне" доступ к нему можно получить,  только если он был описан
           как public.  В этом случае его имя  должно  уточняться  именем  его
           класса:
           
             task::task_chain
           
           В функции члене на него можно ссылаться просто task_chain.  Исполь-
           зование статических членов класса может заметно снизить потребность
           в глобальных переменных.
           
                5.4.5 Указатели на Члены
           
             Можно брать  адрес  члена класса.  Получение адреса функции члена
           часто бывает полезно, поскольку те цели и причины, которые приводи-
           лись в #4.6.9 относительно указателей на функции,  в равной степени
           применимы и к функциям членам.  Однако,  на настоящее время в языке
           имеется дефект:  невозможно описать выражением тип указателя, кото-
           рый получается в результате этой операции. Поэтому в текущей реали-
           зации приходится жульничать, используя трюки. Что касается примера,
           который приводится ниже,  то не гарантируется,  что он будет  рабо-
           тать.  Используемый  трюк надо локализовать,  чтобы программу можно
           было  преобразовать  с  использованием   соответствующей   языковой
           конструкции, когда появится такая возможность. Этот трюк использует
           тот факт,  что в текущей реализации  this  реализуется  как  первый
           (скрытый) параметр функции члена*:
           
           ────────────────────
           * Более поздние версии С++ поддерживают понятие указатель на член:
           cl::* означает "указатель на член класса cl". Например:
             typedef void (cl::*PROC)(int); PROC pf1 = &cl::print; // приведе-
             ние к типу ненужно PROC pf2 = &cl::print;
           
             Для вызовов через указатель на функцию член используются операции
           . и ->. Например:
           
             (z1.*pf1)(2); ((&z2)->*pf2)(4);
           
           (прим. автора)
           
             #include <stream.h>
           
             struct cl {
                 char* val;  void print(int x) { cout << val << x << "\n";  };
                 cl(char* v) { val = v; }
             };
           
             // ``фальшивый'' тип для функций членов:
             typedef void (*PROC)(void*, int);
           
             main() {
                 cl z1("z1 ");  cl z2("z2 "); PROC pf1 = PROC(&z1.print); PROC
                 pf2   =    PROC(&z2.print);    z1.print(1);    (*pf1)(&z1,2);
                 z2.print(3); (*pf2)(&z2,4);
             }
           
             Во многих случаях можно  воспользоваться  виртуальными  функциями
           (см.  Главу 7) там, где иначе пришлось бы использовать указатели на
           функции.
           
                5.4.6 Структуры и Объединения
           
             По определению struct - это просто класс, все члены которого отк-
           рытые, то есть
           
             struct s { ...
           
           есть просто сокращенная запись
           
             class s { public: ...
           
             Структуры используются в тех случаях,  когда сокрытие данных неу-
           местно.
             Именованное объединение  определяется  как struct,  в которой все
           члены имеют один и тот же адрес (см. #с.8.5.13). Если известно, что
           в каждый момент времени нужно только одно значение из структуры, то
           объединение может сэкономить пространство.  Например, можно опреде-
           лить объединение для хранения лексических символов C компилятора:
           
             union tok_val  { char* p;  // строка char v[8];  // идентификатор
                 (максимум 8 char) long i; // целые значения double d; // зна-
                 чения с плавающей точкой
             };
           
             Сложность состоит в том, что компилятор, вообще говоря, не знает,
           какой член используется в каждый данный момент,  поэтому надлежащая
           проверка типа невозможна. Например:
           
             void strange(int i) {
                 tok_val x; if (i)
                     x.p = "2"; else
                     x.d = 2; sqrt(x.d); // ошибка если i != 0
             }
           
           Кроме того,  объединение, определенное так, как это, нельзя инициа-
           лизировать. Например:
           
             tok_val curr_val = 12; // ошибка: int присваивается tok_val'у
           
           является недопустимым.   Для  того,  чтобы  это  преодолеть,  можно
           воспользоваться конструкторами:
           
             union tok_val { char* p;  // строка char v[8];  //  идентификатор
                 (максимум 8 char) long i; // целые значения double d; // зна-
                 чения с плавающей точкой
           
                 tok_val(char*); // должна выбрать между p и v tok_val(int ii)
                 { i = ii; } tok_val() { d = dd; }
             };
           
             Это позволяет справляться с теми ситуациями,  когда  типы  членов
           могут  быть разрешены по правилам для перегрузки имени функции (см.
           #4.6.7 и #6.3.3). Например:
           
             void f() {
                 tok_val a = 10; // a.i = 10 tok_val b = 10.0; // b.d = 10.0
             }
             Когда это невозможно (для таких типов, как char* и char[8], int и
           char,  и т.п.),  нужный член может быть найден  только  посредством
           анализа  инициализатора в ходе выполнения или с помощью задания до-
           полнительного параметра. Например:
           
             tok_val::tok_val(char* pp) {
                 if (strlen(pp) <= 8) strncpy(v,pp,8); // короткая строка
                 else p = pp; // длинная строка
             }
           
           Таких ситуаций вообще-то лучше избегать.
           
             Использование конструкторов  не предохраняет от такого случайного
           неправильного употребления  tok_val,  когда  сначала  присваивается
           значение одного типа,  а потом рассматривается как другой тип.  Эта
           проблема решается встраиванием объединения в класс,  который отсле-
           живает, какого типа значение помещается:
           
             class tok_val { char tag;
             union { char* p;  char v[8];  long i; double d; }; int check(char
                 t, char* s)
                     { if (tag!=t) { error(s); return 0; } return 1; } public:
                 tok_val(char* pp);   tok_val(long  ii)  {  i=ii;  tag='I';  }
                 tok_val(double dd) { d=dd; tag='D'; }
           
                 long& ival() { check('I',"ival");  return i; } double& fval()
                 {   check('D',"fval");   return   d;   }   char*&   sval()  {
                 check('S',"sval");  return p; } char* id() { check('N',"id");
                 return v; }
             };
             Конструктор, получающий строковый параметр,  использует для копи-
           рования коротких строк strncpy().  strncpy() похожа на strcpy(), но
           получает третий параметр, который указывает, сколько символов долж-
           но копироваться:
           
             tok_val::tok_val(char* pp) {
                 if (strlen(pp)   <=  8)  {  //  короткая  строка  tag  =  'N'
                     strncpy(v,pp,8); // скопировать 8 символов
                 }
                 else { // длинная строка tag = 'S';  p = pp; // просто сохра-
                     нить указатель
                 }
             }
           
             Тип tok_val можно использовать так:
           
             void f() {
                 tok_val t1("short");  //  короткая,   присвоить   v   tok_val
                 t2("long string");  // длинная строка, присвоить p char s[8];
                 strncpy(s,t1.id(),8); // ok strncpy(s,t2.id(),8); // проверка
                 check() не пройдет
             }
                5.5 Конструкторы и Деструкторы
           
             Если у  класса есть конструктор,  то он вызывается всегда,  когда
           создается объект класса. Если у класса есть деструктор, то он вызы-
           вается всегда, когда объект класса уничтожается. Объекты могут соз-
           даваться как:
           
             [1] Автоматический объект: создается каждый раз, когда его описа-
                ние встречается при выполнении программы,  и уничтожается каж-
                дый раз при выходе из блока, в котором оно появилось;
           
             [2] Статический объект:  создается один раз, при запуске програм-
                мы, и уничтожается один раз, при ее завершении;
           
             [3] Объект в свободной памяти: создается с помощью операции new и
                уничтожается с помощью операции delete;
           
             [4] Объект член: как объект другого класса или как элемент векто-
                ра.
           
             Объект также  может  быть  построен  с  помощью явного применения
           конструктора в выражении (см.  #6.4), в этом случае он является ав-
           томатическим объектом.  В следующих подразделах предполагается, что
           объекты принадлежат классу, имеющему конструктор и деструктор. При-
           мером может служить класс table из #5.3.
                5.5.1 Предостережение
           
             Если x и y - объекты класса cl, то x=y в стандартном случае озна-
           чает побитовое копирование y в x (см.  #2.3.8). Такая интерпретация
           присваивания может привести к изумляющему (и обычно нежелательному)
           результату,  если  оно применяется к объектам класса,  для которого
           определены конструктор и деструктор. Например:
           
             class char_stack { int size; char* top; char* s;
             public:
                 char_stack(int sz) { top=s=new char[size=sz]; }
                 ~char_stack() { delete s; } // деструктор
                 void push(char c) { *top++ = c; } char pop() { return *--top;
                 }
             };
           
             void h() {
                 char_stack s1(100);  char_stack  s2  =  s1;  //  неприятность
                 char_stack s3(99); s3 = s2; // неприятность
             }
           
             Здесь char_stack::char_stack()  вызывается  дважды:  для s1 и для
           s3. Для s2 он не вызывается, поскольку эта переменная инициализиру-
           ется присваиванием. Однако деструктор char_stack::~char_stack() вы-
           зывается трижды: для s1, s2 и s3! Кроме того, по умолчанию действу-
           ет интерпретация присваивания как побитовое копирование,  поэтому в
           конце h() каждый из s1, s2 и s3 будет содержать указатель на вектор
           символов,  размещенный в свободной памяти при создании s1. Не оста-
           нется никакого указателя на вектор символов,  выделенный при созда-
           нии s3. Таких отклонений можно избежать: см. Главу 6.
                5.5.2 Статическая Память
           
             Рассмотрим следующее:
           
             table tbl1(100);
           
             void f() { static table tbl2(200);
             }
           
             main() {
                 f();
             }
           
             Здесь конструктор  table::table(),  определенный в #5.3.1,  будет
           вызываться дважды:  один раз для tbl1 и один раз для tbl2. Деструк-
           тор table::~table() также будет вызван дважды: для уничтожения tbl1
           и tbl2 после выхода из main().  Конструкторы для глобальных  стати-
           ческих объектов в файле выполняются в том порядке, в котором встре-
           чаются описания; деструкторы вызываются в обратном порядке. Неопре-
           делено,  вызывается ли конструктор для локального статического объ-
           екта,  если функция,  в которой этот объект описан,  не вызывается.
           Если конструктор для локального статического объекта вызывается, то
           он вызывается после того,  как вызваны конструкторы для  лексически
           предшествующих ему глобальных статических объектов.
           
             Параметры конструкторов  для  статических  объектов  должны  быть
           константными выражениями:
           
             void g(int a) {
                 static table t(a); // ошибка
             }
           
             Традиционно выполнением программы  считалось  выполнение  main().
           Так  никогда  не было,  даже в C,  но только размещение статических
           объектов класса с конструктором и/или  деструктором  дают  програм-
           мисту  простой  и  очевидный способ задания того,  что будет выпол-
           няться до и/или после вызова main().
           
             Вызов конструкторов и деструкторов для статических объектов игра-
           ет в С++ чрезвычайно важную роль.  Это способ обеспечить надлежащую
           инициализацию и очистку структур данных в  библиотеках.  Рассмотрим
           <stream.h>.  Откуда берутся cin, cout и cerr? Где они получают ини-
           циализацию?  И,  что самое главное,  поскольку потоки вывода  имеют
           внутренние буферы символов,  как же эти буферы заполняются? Простой
           и очевидный ответ таков, что эта работа осуществляется соответству-
           ющими  конструкторами и деструкторами до и после выполнения main().
           Для инициализации и очистки библиотечных средств есть  возможности,
           альтернативные использованию конструкторов и деструкторов.  Все они
           или очень специальные, или очень уродливые.
             Если программа завершается с помощью функции exit(),  то деструк-
           торы для статических объектов будут вызваны, а если она завершается
           с помощью abort(),  то не будут.  Заметьте,  что это подразумевает,
           что exit() не завершает программу мгновенно.  Вызов exit() в  дест-
           рукторе может привести к бесконечной рекурсии.
           
             Иногда, когда вы разрабатываете библиотеку, необходимо или просто
           удобно создать тип с конструктором и деструктором, предназначенными
           только  для одного:  инициализировать и очистить.  Такой тип обычно
           используется только с одной целью, для размещения статического объ-
           екта так, чтобы вызывались конструктор и деструктор.
           
                5.5.3 Свободная Память
           
             Рассмотрим:
           
             main() {  table*  p = new table(100);  table* q = new table(200);
                 delete p; delete p; // возможно, ошибка
             }
           
             Конструктор table::table() будет вызван дважды,  как и деструктор
           table::~table(). То, что С++ не дает никаких гарантий, что для объ-
           екта, созданного с помощью new, когда-либо будет вызван деструктор,
           ничего не значит.  В предыдущей программе q не  уничтожается,  а  p
           уничтожается дважды!  Программист может счесть это ошибкой, а может
           и не счесть,  в зависимости от типа p и q. Обычно то, что объект не
           уничтожается,  является не ошибкой,  а просто лишней тратой памяти.
           Уничтожение p дважды будет,  как правило, серьезной ошибкой. Обычно
           результатом  применения delete дважды к одному указателю приводит к
           бесконечному циклу в подпрограмме управления свободной памятью,  но
           определение языка не задает поведение в таком случае, и оно зависит
           от реализации.
           
             Пользователь может определить новую  реализацию  операций  new  и
           delete (см.  #3.2.6).  Можно также определить способ взаимодействия
           конструктора или деструктора с операциями new и delete (см. #5.5.6)
           
                5.5.4 Объекты Класса как Члены
           
             Рассмотрим
           
             class classdef  {  table  members;  int  no_of_members;  //   ...
                 classdef(int size); ~classdef();
             };
             Очевидное намерение состоит в том,  что classdef должен содержать
           таблицу длиной size из членов members,  а сложность -  в  том,  как
           сделать так,  чтобы конструктор table::table() вызывался с парамет-
           ром size. Это делается так:
           
             classdef::classdef(int size)
             : members(size)
             { no_of_members = size; // ...
             }
           
             Параметры для конструктора члена (здесь это table::table()) поме-
           щаются в определение (не в описание) конструктора класса, вмещающе-
           го  его  (здесь это classdef::classdef()).  После этого конструктор
           члена вызывается перед телом конструктора, задающего его список па-
           раметров.
           
             Если есть   еще   члены,  которым  нужны  списки  параметров  для
           конструкторов, их можно задать аналогично. Например:
           
             class classdef { table members; table friends; int no_of_members;
                 // ... classdef(int size); ~classdef();
             };
           
             Список параметров для членов разделяется запятыми (а не двоеточи-
           ями),  и  список  инициализаторов для членов может представляться в
           произвольном порядке:
           
             classdef::classdef(int size)
             : friends(size), members(size)
             { no_of_members = size; // ...
             }
           
             Порядок, в котором вызываются конструкторы,  неопределен, поэтому
           не рекомендуется делать списки параметров с побочными эффектами:
           
             classdef::classdef(int size)
             : friends(size=size/2), members(size); // дурной стиль
             { no_of_members = size; // ...
             }
             Если конструктору для члена не нужно ни одного параметра,  то ни-
           какого  списка  параметров  задавать не надо.  Например,  поскольку
           table::table был определен с параметром по умолчанию 15,  следующая
           запись является правильной:
           
             classdef::classdef(int size)
             : members(size)
             { no_of_members = size; // ...
             }
           
           и размер size таблицы friends будет равен 15.
           
             Когда объект  класса,  содержащий   объект   класса,   (например,
           classdef) уничтожается,  первым выполняется тело собственного дест-
           руктора объекта, а затем выполняются деструкторы членов.
           
             Рассмотрим традиционную альтернативу тому,  чтобы  иметь  объекты
           класса  как члены,  - иметь члены указатели и инициализировать их в
           конструкторе:
           
             class classdef   {   table*   members;   table*   friends;    int
                 no_of_members; // ... classdef(int size); ~classdef();
             };
           
             classdef::classdef(int size) {
                 members =  new  table(size);  friends = new table;  // размер
                 таблицы по умолчанию no_of_members = size; // ...
             }
           
             Так как  таблицы  создавались  с помощью new,  они должны уничто-
           жаться с помощью delete:
           
             classdef::~classdef() {
                 // ...
                 delete members; delete friends;
             }
           
            Раздельно создаваемые  объекты вроде этих могут оказаться полезны-
           ми,  но учтите, что members и friends указывают на отдельные объек-
           ты,  что  требует для каждого из них действие по выделению памяти и
           ее освобождению.  Кроме того, указатель плюс объект в свободной па-
           мяти занимают больше места, чем объект член.
                5.5.5 Вектора Объектов Класса
           
             Чтобы описать вектор объектов класса,  имеющего конструктор, этот
           класс должен иметь конструктор, который может вызываться без списка
           параметров. Нельзя использовать даже параметры по умолчанию. Напри-
           мер:
           
             table tblvec[10];
           
           будет ошибкой, так как для table::table() требуется целый параметр.
           Нет способа задать параметры конструктора в описании вектора. Чтобы
           можно  было  описывать  вектор  таблиц table,  можно модифицировать
           описание table (#5.3.1), например, так:
           
             class table {
                 // ...
                 void init(int sz); // как старый конструктор public:
                 table(int sz) // как раньше,  но без по умолчанию { init(sz);
                     }
                 table() // по умолчанию { init(15); }
             }
           
             Когда вектор уничтожается,  деструктор должен вызываться для каж-
           дого элемента этого вектора. Для векторов, которые не были размеще-
           ны с помощью new,  это делается неявно.  Однако для векторов в сво-
           бодной памяти это не может быть сделано неявно,  поскольку компиля-
           тор не может отличить указатель на один объект от указателя на пер-
           вый элемент вектора объектов. Например:
           
             void f() {
                 table* t1 = new table;  table* t2 = new table[10]; delete t1;
                 // одна таблица delete t2; // неприятность: 10 таблиц
             }
           
           В этом случае длину вектора должен задавать программист:
           
             void g(int sz) {
                 table* t1 = new table;  table* t2 = new table[sz]; delete t1;
                 delete[] t2;
             }
           
             Но почему же компилятор не может найти число элементов вектора из
           объема выделенной памяти?  Потому, что распределитель свободной па-
           мяти не является частью языка и может быть задан программистом.
                5.5.6 Небольшие Объекты
           
             Когда вы используете много небольших объектов, размещаемых в сво-
           бодной памяти,  то вы можете обнаружить,  что ваша программа тратит
           много времени выделяя и освобождая память под эти  объекты.  Первое
           решение - это обеспечить более хороший распределитель памяти общего
           назначения,  второе для разработчика классов состоит в  том,  чтобы
           взять  под контроль управление свободной памятью для объектов неко-
           торого класса с помощью подходящих конструкторов и деструкторов.
           
             Рассмотрим класс name,  который использовался в  примерах  table.
           Его можно было бы определить так:
           
             struct name { char* string; name* next; double value;
           
                 name(char*, double, name*);
                 ~name();
             };
           
             Программист может воспользоваться тем,  что размещение и освобож-
           дение объектов заранее известного размера можно обрабатывать гораз-
           до эффективнее (и по памяти, и по времени), чем с помощью общей ре-
           ализации new и delete.  Общая идея состоит в том,  чтобы  предвари-
           тельно  разместить  "куски" из объектов name,  а затем сцеплять их,
           чтобы свести выделение и освобождение к простым операциям над  свя-
           занным списком. Переменная nfree является вершиной списка неисполь-
           зованных name:
           
             const NALL = 128; name* nfree;
           
             Распределитель, используемый операцией new, хранит размер объекта
           вместе  с  объектом,  чтобы  обеспечить  правильную работу операции
           delete.  С помощью распределителя,  специализированного  для  типа,
           можно  избежать этих накладных расходов.  Например,  на моей машине
           следующий распределитель использует для хранения name 16 байт, тог-
           да  как  для  стандартного распределителя свободной памяти нужно 20
           байт. Вот как это можно сделать:
           
             name::name(char* s, double v, name* n) {
                 register name* p = nfree; // сначала выделить
           
                 if (p) nfree = p->next;
                 else { // выделить и  сцепить  name*  q  =  (name*)new  char[
                     NALL*sizeof(name) ];  for (p=nfree=&q[NALL-1];  q<p; p--)
                     p->next = p-1; (p+1)->next = 0;
                 }
           
                 this =  p;  // затем инициализировать string = s;  value = v;
                 next = n;
             }
             Присвоение указателю this информирует компилятор о том, что прог-
           раммист взял себе управление,  и что не надо использовать стандарт-
           ный механизм распределения памяти. Конструктор name::name() обраба-
           тывает  только тот случай,  когда name размещается посредством new,
           но для большей части типов это всегда так.  В  #5.5.8  объясняется,
           как  написать  конструктор для обработки как размещения в свободной
           памяти, так и других видов размещения.
           
             Заметьте, что просто как
           
             name* q = new name[NALL];
           
           память выделять нельзя,  поскольку это приведет к  бесконечной  ре-
           курсии, когда new вызовет name::name().
           
             Освобождение памяти обычно тривиально:
           
             name::~name() {
                 next = nfree; nfree = this; this = 0;
             }
           
             Присваивание указателю  this  0  в деструкторе обеспечивает,  что
           стандартный распределитель памяти не используется.
           
                5.5.7 Предостережение
           
             Когда в конструкторе производится указателю this,  значение  this
           до этого присваивания неопределено.  Таким образом,  ссылка на член
           до этого присваивания неопределена и скорее всего  приведет  к  ка-
           тастрофе.  Имеющийся  компилятор  не пытается убедиться в том,  что
           присваивание указателю this происходит на всех траекториях выполне-
           ния:
           
             mytype::mytype(int i) {
                 if (i) this = mytype_alloc();
                 // присваивание членам
             };
           
           откомпилируется, и при  i==0  никакой  объект  размещен  не  будет.
             Конструктор может определить, был ли он вызван операцией new,
           или нет. Если он вызван new, то указатель this на входе имеет нуле-
           вое  значение,  в  противном случае this указывает на пространство,
           уже выделенное для  объекта  (например,  на  стек).  Поэтому  можно
           просто написать конструктор, который выделяет память, если (и толь-
           ко если) он был вызван через new. Например:
           
             mytype::mytype(int i) {
                 if (this == 0) this = mytype_alloc();
                 // присваивание членам
             };
           
             Эквивалентного средства,  которое  позволяет  деструктору  решить
           вопрос, был ли его объект создан с помощью new, не имеется, как нет
           и средства,  позволяющего ему узнать, вызвала ли его delete, или он
           вызван объектом, выходящим из области видимости. Если для пользова-
           теля это существенно,  то он может сохранить где-то соответствующую
           информацию для деструктора.  Другой  способ  -  когда  пользователь
           обеспечивает,  что  объекты  этого  класса размещаются только соот-
           ветствующим образом. Если удается справиться с первой проблемой, то
           второй способ интереса не представляет.
           
             Если тот,  кто  реализует  класс,  является  одновременно  и  его
           единственным пользователем,  то имеет смысл упростить класс, исходя
           из  предположений о его использовании.  Когда класс разрабатывается
           для более широкого использования,  таких  допущений,  как  правило,
           лучше избегать.
                5.5.8 Объекты Переменного Размера
           
             Когда пользователь берет управление распределением и освобождени-
           ем памяти, он может конструировать объекты размеры, которых во вре-
           мя компиляции недетерминирован.  В  предыдущих  примерах  вмещающие
           (или  контейнерные - перев.) классы vector,  stack,  intset и table
           реализовывались как структуры доступа фиксированного  размера,  со-
           держащие указатели на реальную память.  Это подразумевает,  что для
           создания таких объектов в свободной памяти необходимо две  операции
           по  выделению  памяти,  и что любое обращение к хранимой информации
           будет содержать дополнительную косвенную адресацию. Например:
           
             class char_stack { int size; char* top; char* s;
             public:
                 char_stack(int sz) { top=s=new char[size=sz]; }
                 ~char_stack() { delete s; } // деструктор
                 void push(char c) { *top++ = c; } char pop() { return *--top;
                 }
             };
           
             Если каждый объект класса размещается в свободной памяти, это де-
           лать не нужно. Вот другой вариант:
           
             class char_stack { int size; char* top; char s[1];
             public:
                 char_stack(int sz);  void  push(char c) { *top++ = c;  } char
                 pop() { return *--top; }
             };
           
             char_stack::char_stack(int sz) {
                 if (this) error("стек не в свободной памяти");  if (sz  <  1)
                 error("размер   стека   <   1");  this  =  (char_stack*)  new
                 char[sizeof(char_stack)+sz-1]; size = sz; top = s;
             }
           
             Заметьте, что деструктор больше не нужен, поскольку память, кото-
           рую использует char_stack,  может освободить delete без всякого со-
           действия со стороны программиста.
                5.6 Упражнения
           
             1. (*1) Модифицируйте настольный калькулятор из  Главы  3,  чтобы
                использовать класс table.
           
             2. (*1)  Разработайте  tnode (#с.8.5) как класс с конструкторами,
                деструкторами и т.п. Определите дерево из tnode'ов как класс с
                конструкторами, деструкторами и т.п.
           
             3. (*1) Преобразуйте класс intset (#5.3.2) в множество строк.
           
             4. (*1)  Преобразуйте  класс  intset в множество узлов node,  где
                node - определяемая вами структура.
           
             5. (*3) Определите класс для анализа,  хранения, вычисления и пе-
                чати  простых  арифметических  выражений,  состоящих  из целых
                констант и операций +,  -,  * и /.  Открытый интерфейс  должен
                выглядеть примерно так:
           
                  class expr {
                      // ...
                  public:
                      expr(char*); int eval(); void print();
                  }
           
                Параметр строка конструктора expr::expr() является выражением.
                Функция  expr::eval()   возвращает   значение   выражения,   а
                expr::print()  печатает представление выражения в cout.  Прог-
                рамма может выглядеть, например, так:
           
                  expr x("123/4+123*4-3"); cout << "x = " << x.eval() << "\n";
                  x.print();
           
                Определите класс expr два раза:  один раз используя в качестве
                представления связанный список узлов,  а другой раз - символь-
                ную строку. Поэкспериментируйте с разными способами печати вы-
                ражения:  с полностью расставленными скобками,  в  постфиксной
                записи, в ассемблерном коде и т.д.
           
             6. (*1)  Определите  класс  char_queue (символьная очередь) таким
                образом, чтобы открытый интерфейс не зависел от представления.
                Реализуйте  char_queue как (1) связанный список и как (2) век-
                тор. О согласованности не заботьтесь.
           
             7. (*2) Определите класс histogram (гистограмма),  в котором  ве-
                дется  подсчет чисел в определенных интервалах,  которые зада-
                ются как параметры конструктора histogram.  Обеспечьте функцию
                вывода гистограммы на печать. Сделайте обработку значений, вы-
                ходящих за границы. Подсказка: <task.h>.
             8. (*2)  Определите несколько классов,  предоставляющих случайные
                числа с  определенными  распределениями.  Каждый  класс  имеет
                конструктор, задающий параметры распределения, и функцию draw,
                которая возвращает "следующее" значение.  Подсказка: <task.h>.
                Посмотрите также класс intset.
           
             9. (*2)   Перепишите  пример  date  (#5.8.2),  пример  char_stack
                (#5.2.5) и пример intset (#5.3.2) не используя функций  членов
                (даже конструкторов и деструкторов).  Используйте только class
                и friend.  Сравните с версиями, в которых использовались функ-
                ции члены.
           
             10. (*3) Для какого-нибудь языка спроектируйте класс таблица имен
                и класс вхождение в таблицу имен. Чтобы посмотреть, как на са-
                мом деле выглядит таблица имен, посмотрите на компилятор этого
                языка.
           
             11. (*2) Модифицируйте класс выражение из Упражнения 5 так, чтобы
                обрабатывать переменные и операцию присваивания =. Используйте
                класс таблица имен из Упражнения 10.
           
             12. (*1) Дана программа:
           
                  #include <stream.h>
           
                  main() {
                      cout << "Hello, world\n";
                  }
           
                модифицируйте ее, чтобы получить выдачу
           
                  Initialize Hello, world Clean up
           
                Не делайте никаких изменений в main().
