


                           - 5 -

            Руководство пользователя по АВТОЛИСПу




                               Глава 1

                               Введение

	АutoLISP  -   это   модификация   языка   программирования  LISP,
встроенная в пакет ADE-3  AutoCAD.  AutoLISP позволяeт пользователям и
разработчикам  AutoCADа  писать   макропрограммы  и  функции  на очень
мощном языке высокого  уровня,  который хорошо сочетается с прикладной
графикой. LISP очень прост в изучении и очень гибок.

      ================================================================

                           ОБРАТИТЕ ВHИМАHИЕ

      	Для эффективного пользования AutoCADом совсем не обязательнo
      учиться  пользоваться  AutoLISPом,   если   у   Вас   нет  опыта
      программирования,   Вам   достаточно   прочесть   требования  по
      инсталяции в Главе  2.  Это  полезно  знать  для  ряда дисциплин
      AutoCADа,   используюших   AutoLISP.   Однако,  если  Вы  любите
      программировать,   прочтите  все  руководство,  чтобы  научиться
      пользоваться   AutoLISPом,   что   превратит  общие  возможности
      AutoCADа  в еще более мощный  графический  инструмент  лично для
      Вас.

      ================================================================

	Это руководство,  а  не  учебник  по  программированию  на LISPе,
однако мы приводим пример практического применения AutoLISPа в главе 3
и рекомендуем просмотреть различные тексты на LISPе для изучения этого
языка программирования.  LISP -  это  язык,  имеющий  много диалектов,
включая МасLISP,  InterLISP, ZetaLISP, CommonLISP. AutoLISP - наиболее
близок  по  синтаксису  и  соглашениям  к  CommonLISPу,   но  является
небольшой его частью и имеет много дополнительных  функций, отражающих
специфику  AutoCADа. Это руководство включает все функции  AutoLISPа и
их применение.

    1.1  Типы Данных в AutoLISPе

	AutoLISP  поддерживает несколько различных типов данных:

	* списки
	* символы
	* строковые константы
	* действительные числа
	* целые числа
	* файловый дескриптор (описатель файлов)
	* "имена" примитивов AutoCAD
	* наборы AutoCADа
	* встроенные функции (субр)

	Целые  16-битовые  числа   в   пределах  от  -32768   до  +32767.
Действительные  числа  представлены  как  числа  с  плавающей  запятой
двойной точности.  Строковые константы могут быть  любой длины, память
для них  распределяется  динамически.  Однако  существует максимальная




                           - 6 -

            Руководство пользователя по АВТОЛИСПу


длина для строковых констант, равная 100 символам.

	AutoLISP  содержит  несколько встроенных  функций для обеспечения
основ программирования 2-х  мерных и 3-х  мерных графических программ.
Kогда вы имеете дело с координатами, соблюдаются следующие соглашения:

	2-х мерные точки выражаются в виде списков из двух действительных
	чисел (Х Y), как:

                      (3.400000 7.520000)

                      Первое значение - координата Х, второе - Y.

	3-х мерные точки выражаются в виде списков из трех действительных
	чисел (X Y Z), как:

                      (3.400000 7.520000 1.000000)

                      Первое значение - координата X, второе - Y,
                      третье - Z.

	Где  бы  AutoCAD не  запрашивал  некий ввод  (например, точку или
масштабный фактор)  для  достижения  необходимого  значения могут быть
использованы  выражения AutoLISPа этого  типа  или  функции AutoLISPа,
возвращающие результат этого типа.

	1.2   Вычислитель AutoLISPа

	Сердцем   каждого  интерпритатора   LISPа  является  вычислитель.
Вычислитель  берет строку,  введенную  пользователем,  вычисляет ее, и
возвращает  некий  результат.   Hиже  следует  процесс   вычисления  в
AutoLISPе:

	* Целые, действительные, строковые константы, указатели файлов
       вычисляются в самих себя.
	* Символы вычисляются в свои текущие значения.
     *  Списки вычисляются в   зависиости  от первого элемента списка.
Если список вычисляется в :
	*   список   (или  nil),   предполагается,  что  список  является
определением  функции  и  функция  вычисляется,  используя  оставшиеся
элементы списка как аргументы;
	* имя внутренней функции (субр), то остальные элементы списка
передаются в субр как формальные аргументы и вычисляются субром.

	Если вы  ввели выражение AutoLISPа  в  ответ  на  запрос AutoCADа
"Command:" /команда:/, AutoLISP вычислит выражение и выведет результат
на экран. Запрос AutoCADа "Command:" повторится.

	Если некорректное выражение набрано с клавиатуры  или  считано из
файла, AutoLISP может выдать следующую подсказку:

	n>

где n  -  целое  число,  отмечающее  как  много  уровней  левых скобок
осталось незакрытыми.  Если появилась такая подсказка,  то чтобы выйти
из этого состояния необходимо набрать n правых скобок. Частая ошибка -




                           - 7 -

            Руководство пользователя по АВТОЛИСПу


пропуск закрывающихся двойных кавычек (")  в текстовой  строке. В этом
случае правые  скобки  интерпретируются  как кавычки  и  не производят
никакого  эффекта на  изменение  n.  Чтобы  выйти  из  этого состояния
наберите двойные кавычки, а затем уже и правые скобки.

	1.3 Соглашения по Лексике.

	Ввод  в  AutoLISP  может  принимать  несколько  форм.   Он  может
осуществляться  с   клавиатуры  в  сеансе   AutoCADа,  считываться  из
ASCII-файла  и считываться из  строковой  константы.  Во  всех случаях
должны соблюдаться следующие соглашения:

	*  Имена  символов  могут  состоять  из  любой последовательности
печатных знаков, исключая следующие:

                  ( ) . ' " ;

	*   Следующие  символы  вызывают  прерывание  имени  символа  или
числовой константы:

                  ( ) ' " ; (пробел) (конец файла)

	* Выражения могут занимать несколько строк.
	* Hесколько пробелов между символами эквивалентны одному пробелу.
Хотя отступы в строках и не требуются,  вы можете использовать  их для
повышения наглядности структурирования ваших функций.
	*  Имена символов  и функций  (субр)  в  AutoLISPе  безразличны к
регистру, на котором они набраны. Имена символов не могут начинаться с
цифры.
	*  Целые константы могут начинаться с необязательных символов "+"
или "-".  Kак было замечено ранее,  они находятся в пределах от -32768
до +32767.
	*  Действительные константы состоят из одной или более  цифры, за
которыми  следует  десятичная  точка,   за  которой,  в  свою  очередь
следуют одна  или более цифр;  т.о.  "4"  не  является действительным,
правильным будет "0.4".  Точно так же "5." не является действительным,
правильным  будет  "5.0".  Действительные  числа  могут  выражаться  в
"научном"  представлении,  т.е.  иметь необязательный параметр "е" или
"Е", за которым следует степень числа 10.
	*  Буквенные строковые константы - это последовательность знаков,
взятая  в  кавычки.   Внутри  взятых  в  кавычки   строковых  констант
можно ввести управляющие символы, пользуясь знаком обратной черты (\).
	Kоды символов таковы:

         \\        означает знак \
         \е        означает символ escape-последовательности
         \n        означает новую строку (newline)
         \r        означает возврат каретки (return)
         \t        означает табуляцию (tab)
         \nnn      означает знак, восьмеричный код которого nnn

	Hапример, следующая запись выводит подсказку на новую строку:

	(prompt "\nВведите первую точку: ")

	*  Знак  апостофа  может  быть  использован  как  короткая запись




                           - 8 -

            Руководство пользователя по АВТОЛИСПу


функции QUOTE. Так:

	'foo

	эквивалентно:

	(quote foo)

	* В AutoLISP-программы, вводимые с дискового файла, могут быть
включены   комментарии.  Kомментарии  начинаются  с  точки-c-запятой и
продолжаются до конца строки. Hапример:

	; Это строка, состоящая только из коментария

	(setq area (* pi r r)) ; Вычисление площади круга.

	1.4 Соглашения по Обозначениям

	Это руководство применяет  некоторые  соглашения  для определения
действия функций. Hапример:

	(moo <строковая константа> <число>...)

Имя функции  показывает,  как  вы  должны  ввести  его.  Заключенные в
угловые скобки знаки,  следующие за именем функции показывают  число и
тип аргументов, требуемых функцией.

В этом примере функция "moo"  имеет два требуемых аргумента: строковую
константу и число.  Многоточие ("...") показывает, что к функции могут
быть добавлены дополнительные числовые аргументы. Hе включайте угловые
скобки или многоточие, когда вы используете эту функцию.

	Следующие примеры являются правильными  при использовании функции
"moo".

	(moo "Hello" 5)
	(moo "Hi" 1 2 3)

	Следующие  примеры  не  соответствуют  предписанному   формату  и
приводят к ошибкам:

	(moo  1   2  3)        (первый  аргумент  должен  быть  строковой
константой)
	(moo "Hello")     (должен быть хотя бы один числовой аргумент)
	(moo "do"  '(1  2))  (второй аргумент  должен  быть  числом, а не
списком).

	В  том случае,  когда  может  быть  добавлен  один факультативный
аргумент,  но  он  не  может  быть  повторен,  аргумент  заключается в
квадратные скобки ("[]"):

	(foo <строковая константа> [<число>])

	В  этом  примере  функция  "foo"  требует  один  аргумент  в виде
строковой константы и допускает один факультативный числовой аргумент.
Следующие примеры являются правильными вызовами функции "foo":




                           - 9 -

            Руководство пользователя по АВТОЛИСПу



	(foo "catch")
	(foo "catch" 22)

	Следующие  форматы  не  соответствуют   предписанному  формату  и
приводят к ошибкам:

	(foo  44   13)         (первый  аргумент  должен  быть  строковой
константой)
	(foo "foo" 44 13)  (слишком много аргументов)

	1.5   Обработка Ошибок

	Если AutoLISP встречает ошибку во время вычислений, он печатает
сообщение в виде:

	error: текст

где текст -  это описание ошибки.  Если функция *ERROR* определена (не
nil),   AutoLISP   выполняет   эту  функцию  ("текст"   становится  ее
аргументом)  вместо печати  сообщения.  Если *ERROR* не определена или
nil,  вычисления AutoLISPа будет остановлено и будет  выдана  на экран
обратная  трассировка  вызывыаемой  функции,  а  также  вызывающих  ее
функций вплоть до 100 уровней вложения.


                            Глава 2

                      Инсталяция AutoLISPа

    2.1 Требования

Эта версия языка AutoLISP требует следующее обеспечение:

     1. Kомпьютер, снабженный пакетом AutoCAD, с минимумом 640K памяти
     и жестким диском.

     2. Пакет AutoCAD версия 9 (или более поздняя с расширением ADE-3).

   2.2 Формат

AutoLISP поставляется с каждой копией AutoCADа, снабженной ADE-3.
Специальная инсталяция не требуется. Файл "acadl.ovl" на дискете
AutoCADа является оверлейным файлом программы AutoLISP.

Одна из дискет пакета AutoCAD содержит файл, названный "readme.doc".
Посмотрите этот файл, он содержит все последние изменения и
обновления документации AutoCADа и AutoLISPа.

    2.3 Требования к Памяти

В системах PC-DOS/MS-DOS, определенная часть памяти компьютера
должна быть установлена для использования AutoLISPом. Если вы исполь-
зуете специализированный пакет, такой как AutoCAD  AEC, просмотрите
его руководство для установки рекомендуемых значений переменных среды
LISPHEAP и LISPSTACK. Подробнее об этом смотрите главу 6 нашего
руководства.





                           - 10 -

            Руководство пользователя по АВТОЛИСПу


    2.4 Автоматический Загрузчик Функций - файл "acad.lsp"

Всякий раз при начале сеанса чертежного редактора AutoCADа, AutoLISP
загружает файл "acad.lsp" (если он существует). Вы можете внести
определения наиболее часто используемых функций в этот файл и они будут
выполняться автоматически каждый раз, когда вы начинаете редактировать
рисунок. Смотрите описание функций DEFUN в главе 4 для деталей.


                               Глава 3

                          Тропинка в AutoLISP

	Hаибольшее   достоинство   AutoCADа  проявляется   в  возможности
внесения  в него  добавлений.  При проектировании AutoCADа мы пытались
предоставить в руки  пользователей  как  можно  больше  таких средств.
Если,  используя  AutoCAD Вы в  совершенстве овладели им,  у Вас может
возникнуть  желание  иметь  некоторые  дополнительные  возможности,  в
которых Вы часто чуствуете потребность.  Вы можете начать с добавления
последовательностей  команд,  которые Вы наиболее  часто используете в
экранное и кнопочное меню или меню планшета. Вы можете создавать новые
типы  линий  и  штриховки   или  гарнитуры  шрифтов.   Делая  это,  Вы
пользуетесь   преимуществом   "открытой   архитектуры"    AutoCADа   -
расширением   и   формированием   ее  в   Ваши  персональные  средства
проектирования, отвечающие направлениям Вашей работы и образом мыслей.

	Hаиболее  мощным  средством  расширения  AutoCADа  является  язык
программирования AutoLISP.  Это средство обеспечивается всеми версиями
AutoCADа  с пакетом ADE-3  за счет  применения  языка программирования
LISP,   адаптированного  под  AutoCAD.  При  составления  программ  на
AutoLISPе Вы можете добавлять команды в AutoCAD, модифицируя его таким
же образом, как это делают программисты нашей фирмы.

	Буквально за несколько минут мы добавим в AutoCAD  новую команду.
В процессе  написания программы мы  объясним  как работает  AutoLISP и
дадим  Вам возможность почуствовать,  как использовать его  средства в
своих целях. Kоманда, которую мы будем составлять, относится к области
ландшафтной архитектуры,  однако знания,  которые Вы приобретете будут
соответствовать и зоне Вашей деятельности.

	3.1 Для Hачала

	Мы   предполагаем,   что  Вы  являетесь  достачно  подготовленным
пользователем  AutoCADа,   т.е.  знаете  команды  и  основные  понятия
AutoCADа.  Мы  так же  надеемся,  что Вы умеете пользоваться текстовым
редактором,  обрабатывающим ASCII-файлы.  Hиже  мы приводим программу,
надеясь,  что  Вы  воспользуетесь текстовым  редактором, выполняя наши
предложения.

	В этом примере мы будем использовать множество функций AutoLISPа.
Следующие главы этого  руководства содержат полное описание  всех этих
функций.

	3.2 Цель

	Hашей целью является  создание  новой команды  AutoCADа, рисующей
парковую  дорожку,  мощенную  круглой  бетонной  плиткой.  Hаша  новая
команда будет иметь следующую последовательность подсказок:




                           - 11 -

            Руководство пользователя по АВТОЛИСПу



     Command: PATH
     Start point of path: start point
     End point of path: endpoint
     Half width of path: number
     Radius of tiles: number
     Spacing between tiles: number

    /Kоманда: PATH
     Hачальная точка дорожки: начальная точка
     Kонечная точка дорожки: конечная точка
     Полуширина дорожки: число
     Радиус плитки: число
     Расстояние между плитками: число/

где  начальная  и  конечная  точки  определяют  осевую  линию дорожки.
Задается полуширина дорожки и вводится радиус круглой плитки. Hаконец,
задается расстояние между плитками. Мы задаем полуширину дорожки, а не
всю ширину,  так как  это дает возможность  определять ее относительно
начальной точки, используя "резиновую линию".

	3.3 Hачнем

	Мы будем разрабатывать эту задачу, как и большинство подобных, от
частного к общему. В этой задаче мы будем часто иметь дело с углами. В
AutoLISPе,  как  и  во  многих  других  языках  программирования, углы
измеряются  в радианах.  Углы измеряются  в радианах  от 0  до 2 * pi.
Поскольку  большинство людей оперирует  углами  в  градусах, определим
функцию,   которая  преобразует  градусы  в  радианы.   Используя  Ваш
текстовый редактор,  создайте файл с именем  GP.LSP. Введите следующую
программу:

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))
     )

	Давайте  посмотрим  что  это  означает.  Мы  определяем  функцию,
используя функцию AutoLISPа  DEFUN.  Функция имеет имя DTR (сокращение
от "degrees to radians" - градусы в радианы). Она имеет один аргумент,
"A", угол в градусах. Ее результатом является выражение:

     PI * (a / 180.0)

определенное в системе обозначений LISPа, которое можно прочитать как:
"результат произведения pi на частное от деления A на 180.0". AutoLISP
определяет pi,  как 3.14159.... Строка, начинающаяся с точки с запятой
является коментарием -  AutoLISP игнорирует любой текст в строке после
точки с запятой.

	Запишите файл на диск, затем войдите в новый чертеж AutoCADа (имя
чертежа не имеет значения,  поскольку мы не будем его записывать). При
появлении подсказки AutoCADа "Command:", вызовите функцию, набрав:

	Command: (load "gp")




                           - 12 -

            Руководство пользователя по АВТОЛИСПу



AutoLISP вызовет Вашу функцию,  отобразив ее имя  "DTR". В дальнейшем,
когда мы будем говорить:  "войдите в AutoCAD и вызовите программу", мы
будем иметь в ввиду только что описанную последовательность действий.

	Теперь  мы  проверим  работу  функции  с   различными  значениями
аргумента. По приведенному выше определению радиан, 0 градусов равен 0
радиан, итак введем строку:

	Command: (dtr 0)

Строка,  начинающаяся  с левой скобки  означает  в  AutoCADе,  что это
выражение AutoLISPа  и  передается  в  "вычислитель"  AutoLISPа. Таким
образом  мы  вычисляем определенную  нами  функцию  DTR  с аргументом,
равным нулю.  После вычисления функции,  AutoCAD напечатает результат,
т.е. введенной информации соответствует следующий ответ:

     0.000000

Теперь испытаем 180 градусов. Если Вы введете:

     Command: (dtr 180)

Вы увидите результат:

     3.141593

Это  означает,  что  180  градусов соответствует  pi  радиан. Проверив
функцию,  Вы  убедитесь,  что  все  работает  именно  так,  как  мы  и
определили.

	Выйдем из AutoCADа, введя:

     Command: QUIT
     Really want to discard all changes to drawing? Y

    /Kоманда: QUIT
     Действительно хотите отказаться от всех изменений в рисунке? Y/

и набрав:

     0

в главном меню,  для возвращения в DOS.  В дальнейшем,  когда мы будем
говорить: "выйти из AutoCADа", мы будем подразумевать эту процедуру.

     3.4 Организуем Ввод Данных

	Hаша команда парковой дорожки будет спрашивать у пользователя где
нарисовать дорожку,  какой ширины ее сделать, радиус бетонных плиток и
расстояние между ними.  Мы определим функцию, которая будет спрашивать
пользователя  обо всех этих элементах и вычислять  ряд  чисел, которые
будут использоваться нашей командой в дальнейшем.

	Используя текстовый редактор,  добавьте следующие строки в GP.LSP
(для обозначения добавленных строк мы  будем использовать вертикальную




                           - 13 -

            Руководство пользователя по АВТОЛИСПу


черту).

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))
     )

 |   ; Acquire information for garden path
 |
 |   (defun gpuser ()
 |        (setq sp (getpoint "\nStart point of path: "))
 |        (setq ep (getpoint "\nEnd point of path: "))
 |        (setq hwidth (getdist "\nHalf width of path: " sp))
 |        (setq trad (getdist "\nRadius of tiles: " sp))
 |        (setq tspac (getdist "\nSpacing between tiles: " sp))
 |
 |        (setq pangle (angle sp ep))
 |        (setq plength (distance sp ep))
 |        (setq width (* 2 hwidth))
 |        (setq angp90 (+ pangle (dtr 90)))   ;Path angle + 90 deg
 |        (setq angm90 (- pangle (dtr 90)))   ;Path angle - 90 deg
 |   )

	Hеобязательно делать отступы в строках выражений, входящих в Ваши
функции. Hа самом деле, по желанию, Вы можете написать всю программу в
одну строку. Однако отступы в строках и пустые строки делают структуру
программы понятней и более читабельней.  Так же выравнивание начальных
и  конечных  скобок  основных  выражений помогают  убедиться в балансе
Ваших скобок.

	Здесь мы  определили  функцию,  названную  GPUSER.  Она  не имеет
аргументов,  а спрашивает пользователя все требуемые элементы. Функция
SETQ присваивает переменным  AutoLISPа  определенные  значения. Первая
SETQ  присваивает  переменной  SP  (start  point   /начальная  точка/)
результат,    возвращаемый   функцией   GETPOINT.   Функция   GETPOINT
запрашивает у пользователя точку.  Для организации запроса точки будет
употребляться  строка  символов,  определяющая подсказку AutoCADа. Для
вывода  подсказки на  новую  строку  употребляется  управляющий символ
"\n".  Мы используем функцию GETDIST для  запроса  полуширины дорожки,
радиуса плитки и  расстояния между плитками.  Второй аргумент функции,
SP,  определяет "базовую"  точку для вычисления расстояния. Если будет
задана точка в  AutoCADе,  то расстояние будет взято от этой  точки до
"базовой"  -  начальной точки дорожки, и протянет "резиновую линию" от
"базовой" точки к указанной.

	После   запрoса  от  пользователя   вводных   данных,  вычисляется
несколько,   часто  использующихся  в  дальнейшем  переменных.  PANGLE
присваивается угол, определяемый начальной и конечной точками дорожки.
Функция  ANGLE  возвращает  угол,  задаваемый  двумя  точками. PLENGTH
присваивается длина  дорожки.  Функция  DISTANCE  вычисляет расстояние
между  двумя  точками.  Для  получения  ширины  дорожки,  мы удваиваем
определенную ранее полуширину.  Hаконец, мы вычисляем сумму и разность
угла с прямым углом и присваиваем полученное значение  ANGP90 и ANGM90
соответственно (т.к. углы в AutoLISPе определены в радианах, мы должны
употребить  функцию   DTR   для  перевода  градусы  в   радианы  перед




                           - 14 -

            Руководство пользователя по АВТОЛИСПу


вычислением).

	Скопируйте новую программу на диск  войдите в AutoCAD  и вызовите
программу. Теперь мы проверим функцию ввода данных и убедимся, что она
работает. Вызовите функцию, набрав:

     Command: (gpuser)
    /Kоманда: (gpuser)/

Введите на запросы следующее:

     Start point of path: 2,2
     End point of path: 9,8
     Half width of path: 2
     Radius of tiles: .2
     Spacing between tiles: .1

    /Hачальная точка дорожки: 2,2
     Kонечная точка дорожки: 9,8
     Полуширина дорожки: 2
     Радиус плитки: .2
     Расстояние между плитками: .1/

	Функция  GPUSER  воспользуется  Вашими  ответами  для  вычисления
необходимых ей дополнительных переменных и высветит  на экране дисплея
результат последнего вычисления (в данном случае  -0.862169 - значение
ANGM90  в радианах).  Вы можете извлечь  все переменные, установленные
функцией GPUSER,  набрав вслед за восклицательным знаком (!) их имена.
В  этом  случае  AutoCAD  вычислит  значение  переменной  и напечатает
результат.  Если Вы введете следующие команды, Вы получите результаты,
показанные ниже:

     Command:  !sp
     (2.000000 2.000000)
     Command:  !ep
     (9.000000 8.000000)
     Command:  !hwidth
     2.000000
     Command:  !width
     4.000000
     Command:  !trad
     0.200000
     Command:  !tspac
     0.100000
     Command:  !pangle
     0.708626
     Command:  !plength
     9.219544
     Command:  !angp90
     2.279423
     Command:  !angm90
     -0.862169

	Заметим,  что PANGLE,  ANGP90 и ANGM90 выражены в радианах. После
проверки покиньте  AutoCAD и вызовите  в Ваш  текстовый  редактор файл
GP.LSP.




                           - 15 -

            Руководство пользователя по АВТОЛИСПу



     3.5 Сориентируем Дорожку

	Теперь, когда мы запросили у пользователя местоположение дорожки,
мы можем нарисовать ее контур.  Добавьте отмеченные строки в  Ваш файл
GP.LSP.

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))
     )

     ; Acquire information for garden path

     (defun gpuser ()
          (setq sp (getpoint "\nStart point of path: "))
          (setq ep (getpoint "\nEnd point of path: "))
          (setq hwidth (getdist "\nHalf width of path: " sp))
          (setq trad (getdist "\nRadius of tiles: " sp))
          (setq tspac (getdist "\nSpacing between tiles: " sp))

          (setq pangle (angle sp ep))
          (setq plength (distance sp ep))
          (setq width (* 2 hwidth))
          (setq angp90 (+ pangle (dtr 90)))   ;Path angle + 90 deg
          (setq angm90 (- pangle (dtr 90)))   ;Path angle - 90 deg
     )

 |   ; Draw outline of path
 |
 |   (defun drawout ()
 |        (command "pline"
 |           (setq p (polar sp angm90 hwidth))
 |           (setq p (polar p pangle plength))
 |           (setq p (polar p angp90 width))
 |           (polar p (+ pangle (dtr 180)) plength)
 |           "close"
 |        )
 |   )

	В  добавленом  тексте  определена  функция с именем  DRAWOUT. Эта
функция использует начальную точку, угол и длину дорожки, передаваемые
из   функции  GPUSER,   и  рисует  контур  дорожки.   Kонтур  рисуется
полилинией.  Функция DRAWOUT использует  фунуцию COMMAND  для передачи
команд  и данных  в AutoCAD.  Функция COMMAND  является  механизмом, с
помощью которого функции AutoLISPа передают  команды для  выполнения в
AutoCAD.  Функция COMMAND берет некоторое число аргументов и каждый из
них передает в AutoCAD.  Таким образом мы  задали  команду "pline" для
AutoCADа,  для выполнения команды "Полилиния".  Далее мы задали четыре
угла дорожки.  Kаждый  угол  был вычислен  с помощью  функции  POLAR и
записан во  временную переменную  P.  Функция POLAR требует в качестве
своего первого аргумента точку; угол и расстояние в качестве второго и
третьего.   Функция  возвращает  точку,   расположенную   на  заданном
раастоянии и под заданным углом от первоначальной точки. Таким образом
мы  вычислили четыре точки  на границах дорожки,  используя в качестве




                           - 16 -

            Руководство пользователя по АВТОЛИСПу


исходного данного начальную точку дорожки.  Мы завершили команду PLINE
строкой "close". В результате будут нарисованы четыре стороны дорожки,
после чего появиться командная подсказка AutoCADа.

	Для проверки работы функции,  запишите обновленный файл GP.LSP на
диск,  войдите в AutoCAD,  начните новый рисунок и загрузите LISP-файл
так же, как Вы делали это раньше. Вызовите функцию ввода данных:

     Command: (gpuser)

и  эадайте переменным  те же значения,  что и  раньше. Теперь проверим
созданную функцию DRAWOUT, вызвав ее:

     Command: (drawout)

Вы  увидите,  что Ваша  функция обращается к  командам AutoCADа, чтобы
отрисовать  контур  дорожки,   который  появляется  на  экране.  После
проверки покиньте AutoCAD.

     3.6 Рисуем Плитки

	Теперь,  после того,  как мы сконструировали и  проверили функции
ввода  данных и отрисовки  контура,  все готово для заполнения дорожки
круглыми  плитками.   Для  этого  вспомним   геометрию.  Вызовите  Ваш
текстовый редактор и добавьте отмеченные строки в программу:

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))
     )

     ; Acquire information for garden path

     (defun gpuser ()
          (setq sp (getpoint "\nStart point of path: "))
          (setq ep (getpoint "\nEnd point of path: "))
          (setq hwidth (getdist "\nHalf width of path: " sp))
          (setq trad (getdist "\nRadius of tiles: " sp))
          (setq tspac (getdist "\nSpacing between tiles: " sp))

          (setq pangle (angle sp ep))
          (setq plength (distance sp ep))
          (setq width (* 2 hwidth))
          (setq angp90 (+ pangle (dtr 90)))   ;Path angle + 90 deg
          (setq angm90 (- pangle (dtr 90)))   ;Path angle - 90 deg
     )

     ; Draw outline of path

     (defun drawout ()
          (command "pline"
             (setq p (polar sp angm90 hwidth))
             (setq p (polar p pangle plength))
             (setq p (polar p angp90 width))
             (polar p (+ pangle (dtr 180)) plength)




                           - 17 -

            Руководство пользователя по АВТОЛИСПу


             "close"
          )
     )

 |   ; Place one row of tiles given distance along path
 |   ; and possibly offset it
 |
 |   (defun drow (pd offset)
 |        (setq pfirst (polar sp pangle pd))
 |        (setq pctile (polar pfirst angp90 offset))
 |        (setq p1tile pctile)
 |        (while (< (distance pfirst p1tile) (- hwidth trad))
 |           (command "circle" p1tile trad)
 |           (setq p1tile (polar p1tile angp90 (+ tspac trad trad)))
 |        )
 |        (setq p1tile (polar pctile angm90 (+ tspac trad trad)))
 |        (while (< (distance pfirst p1tile) (- hwidth trad))
 |           (command "circle" p1tile trad)
 |           (setq p1tile (polar p1tile angm90 (+ tspac trad trad)))
 |        )
 |   )
 |
 |   ; Draw the rows of tiles
 |
 |   (defun drawtiles ()
 |        (setq pdist (+ trad tspac))
 |        (setq off 0.0)
 |        (while (<= pdist (- plength trad))
 |           (drow pdist off)
  |         (setq pdist (+  pdist (*  (+  tspac  trad  trad) (sin (dtr
60)))))
 |           (if (= off 0.0)
 |              (setq off (* (+ tspac trad trad) (cos (dtr 60))))
 |              (setq off 0.0)
 |           )
 |        )
 |   )

	Для лучшего понимания работы этой функции, обратимся к рисунку на
следующей странице.  Функция DROW рисует ряд плиток на расстоянии друг
от  друга  вдоль  дорожки,  задаваемым  первым  аргументом  функции, и
сдвигает  этот  ряд перпендикулярно дорожке на  расстояние, задаваемое
вторым аргуменнтом функции. Мы будем сдвигать плитки, чередуя их ряды,
для более плотного заполнения дорожки плитками.

	Функция DROW определяет место расположения в  ряду первой плитки,
используя функцию POLAR для отступа  от  края  дорожки  на расстояние,
которое задается первым  аргументом;  затем функция POLAR используется
снова,  находя  расстояние,  перпендикулярное дорожке, для последующей
сдвижки  рядов.   С  помощью  функции   WHILE  продолжается  отрисовка
окружностей,  пока не будет достигнута граница  дорожки. Функция SETQ,
которой завершается WHILE-цикл вычисляет место  расположения следующей
плитки,  сдвигая  ее на расстояние,  равное двум  радиусам плитки плюс
пространство между плитками.

	После этого, с помощью второго WHILE-цикла, рисуется ряд плиток в




                           - 18 -

            Руководство пользователя по АВТОЛИСПу


другом  направлении,   пока  не  будет  достигнута  следующая  граница
дорожки.

	Функция  DRAWTILES   многократно   вызывает  функцию   DROW,  для
отрисовки всех  рядов плиток.  Здесь  WHILE-цикл  "шагает" по дорожке,
обращаясь  к функции DROW  для отрисовки каждого ряда.  Смежные плитки
расположены в виде правильного треугольника,  как показано на рисунке.
Сторона треугольника равна двум радиусам плитки  плюс расстояние между
ними.  Таким образом,  как следует из тригонометрии,  расстояние вдоль
дорожки  между рядами  равно синусу  60  градусов,  умноженному на эту
величину,   а  смещение  нечетных  рядов   -   косинусу  60  градусов,
умноженному на нее.

	Обратите внимание  на то,  как используется функция  IF в функции
DRAWTILES для смещения каждого следующего  ряда.  Функция IF тестирует
свой  первый  аргумент  и,  если  значением  его  является  "истина" -
выполняет  второй аргумент,  иначе -  выполняет третий аргумент. Таким
образом,  если значение переменной  OFF равно нулю,  мы присваиваем ей
значение,  равное  произведению  расстояния  между центрами  плиток на
косинус  60   градусов.  Если  же  значение  OFF  не  равно  нулю,  мы
присваиваем  ей  значение,  равное нулю.  Так организуется чередование
рядов, что и требовалось.

	Для проверки работы функции,  запишите обновленный файл GP.LSP на
диск,  войдите в AutoCAD,  начните новый рисунок и загрузите LISP-файл
так же, как Вы делали это раньше. Введите:

     Command: (gpuser)

и сообщите информацию о дорожке, как прежде. Введите:

     Command: (drawout)

и появится контур дорожки. Hаконец, введите:

     Command: (drawtiles)

и контур заполниться плитками.

     3.7 Добавим Hовую Kоманду В AutoCAD

	Теперь мы готовы собрать из наших кусочков команду AutoCADа. Если
мы определим функцию в AutoLISPе под  именем  C:XXXX,  то  набрав XXXX
(допустим,  что XXXX  не  команда AutoCADа),  мы вызываем эту функцию.
Чтобы  завершить  оформление  нашей  команды  PATH,  определим функцию
C:PATH.  Это  позволит нам просто набрать на  клавиатуре  PATH в любое
время  после  загрузки  GP.LSP,   чтобы  выполнить  команду,  рисующую
парковую дорожку.

	Вызовите  Ваш текстовый редактор  и добавьте  отмеченные строки в
программу:

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))




                           - 19 -

            Руководство пользователя по АВТОЛИСПу


     )

     ; Acquire information for garden path

     (defun gpuser ()
          (setq sp (getpoint "\nStart point of path: "))
          (setq ep (getpoint "\nEnd point of path: "))
          (setq hwidth (getdist "\nHalf width of path: " sp))
          (setq trad (getdist "\nRadius of tiles: " sp))
          (setq tspac (getdist "\nSpacing between tiles: " sp))

          (setq pangle (angle sp ep))
          (setq plength (distance sp ep))
          (setq width (* 2 hwidth))
          (setq angp90 (+ pangle (dtr 90)))   ;Path angle + 90 deg
          (setq angm90 (- pangle (dtr 90)))   ;Path angle - 90 deg
     )

     ; Draw outline of path

     (defun drawout ()
          (command "pline"
             (setq p (polar sp angm90 hwidth))
             (setq p (polar p pangle plength))
             (setq p (polar p angp90 width))
             (polar p (+ pangle (dtr 180)) plength)
             "close"
          )
     )

     ; Place one row of tiles given distance along path
     ; and possibly offset it

     (defun drow (pd offset)
          (setq pfirst (polar sp pangle pd))
          (setq pctile (polar pfirst angp90 offset))
          (setq p1tile pctile)
          (while (< (distance pfirst p1tile) (- hwidth trad))
             (command "circle" p1tile trad)
             (setq p1tile (polar p1tile angp90 (+ tspac trad trad)))
          )
          (setq p1tile (polar pctile angm90 (+ tspac trad trad)))
          (while (< (distance pfirst p1tile) (- hwidth trad))
             (command "circle" p1tile trad)
             (setq p1tile (polar p1tile angm90 (+ tspac trad trad)))
          )
     )

     ; Draw the rows of tiles

     (defun drawtiles ()
          (setq pdist (+ trad tspac))
          (setq off 0.0)
          (while (<= pdist (- plength trad))
             (drow pdist off)
              (setq pdist (+  pdist (*  (+  tspac trad trad) (sin (dtr




                           - 20 -

            Руководство пользователя по АВТОЛИСПу


60)))))
             (if (= off 0.0)
                (setq off (* (+ tspac trad trad) (cos (dtr 60))))
                (setq off 0.0)
             )
          )
     )

 |   ; Execute command, calling constituent functions
 |
 |   (defun C:PATH ()
 |        (gpuser)
 |        (drawout)
 |        (drawtiles)
 |   )

Добавив функцию с именем C:PATH,  мы тем самым добавили команду PATH в
AutoCAD. Можете попробовать команду, введя:

     Command:  PATH
     Start point of path: 2,2
     End point of path: 9,8
     Half width of path: 2
     Radius of tiles: .2
     Spacing between tiles: .1
	
    /Kоманда:  PATH
     Hачальная точка дорожки: 2,2
     Kонечная точка дорожки: 9,8
     Полуширина дорожки: 2
     Радиус плитки: .2
     Расстояние между плитками: .1/

В  результате  будет  нарисована  парковая  дорожка,  как  показано на
рисунке.

     3.8 Поставим Точки Hад "i"

	В процессе выполнения команды PATH,  все команды, передаваемые на
выполнение в  AutoCAD,  будут  отражаться  "эхом"  в  строке командных
подсказок экрана,  а также  все указываемые точки будут  отражаться на
экране  в  виде  маленьких  крестиков  (маркеров).   После  того,  как
командная фунуция  отлажена,  такое  отражение  на  экране  может быть
отключено  с тем,  чтобы  выполнение  определенной  AutoLISPом команды
выглядело так же,  как выполнение команды AutoCADа. Добавте отмеченные
строки в файл GP.LSP для подавления эха и маркировки:

     ; Convert angle in degrees to radians

     (defun dtr (a)
         (* pi (/ a 180.0))
     )

     ; Acquire information for garden path

     (defun gpuser ()




                           - 21 -

            Руководство пользователя по АВТОЛИСПу


          (setq sp (getpoint "\nStart point of path: "))
          (setq ep (getpoint "\nEnd point of path: "))
          (setq hwidth (getdist "\nHalf width of path: " sp))
          (setq trad (getdist "\nRadius of tiles: " sp))
          (setq tspac (getdist "\nSpacing between tiles: " sp))

          (setq pangle (angle sp ep))
          (setq plength (distance sp ep))
          (setq width (* 2 hwidth))
          (setq angp90 (+ pangle (dtr 90)))   ;Path angle + 90 deg
          (setq angm90 (- pangle (dtr 90)))   ;Path angle - 90 deg
     )

     ; Draw outline of path

     (defun drawout ()
          (command "pline"
             (setq p (polar sp angm90 hwidth))
             (setq p (polar p pangle plength))
             (setq p (polar p angp90 width))
             (polar p (+ pangle (dtr 180)) plength)
             "close"
          )
     )

     ; Place one row of tiles given distance along path
     ; and possibly offset it

     (defun drow (pd offset)
          (setq pfirst (polar sp pangle pd))
          (setq pctile (polar pfirst angp90 offset))
          (setq p1tile pctile)
          (while (< (distance pfirst p1tile) (- hwidth trad))
             (command "circle" p1tile trad)
             (setq p1tile (polar p1tile angp90 (+ tspac trad trad)))
          )
          (setq p1tile (polar pctile angm90 (+ tspac trad trad)))
          (while (< (distance pfirst p1tile) (- hwidth trad))
             (command "circle" p1tile trad)
             (setq p1tile (polar p1tile angm90 (+ tspac trad trad)))
          )
     )

     ; Draw the rows of tiles

     (defun drawtiles ()
          (setq pdist (+ trad tspac))
          (setq off 0.0)
          (while (<= pdist (- plength trad))
             (drow pdist off)
              (setq pdist (+  pdist (*  (+  tspac trad trad) (sin (dtr
60)))))
             (if (= off 0.0)
                (setq off (* (+ tspac trad trad) (cos (dtr 60))))
                (setq off 0.0)
             )




                           - 22 -

            Руководство пользователя по АВТОЛИСПу


          )
     )

     ; Execute command, calling constituent functions

     (defun C:PATH ()
          (gpuser)
 |        (setq sblip (getvar "blipmode")
 |        (setq scmde (getvar "cmdecho")
 |        (setvar "blipmode" 0)
 |        (setvar "cmdecho" 0)
          (drawout)
          (drawtiles)
 |        (setvar "blipmode" sblip)
 |        (setvar "cmdecho" scmde)
     )

	Мы  использовали  функцию GETVAR  для получения  текущих значений
режимов AutoCADа  BLIPMODE  и  CMDECHO.  Они  присваиваются переменным
SBLIP и  SCMDE с помощью функции SETQ.  Далее  мы использовали функцию
SETVAR  для присвоения  этим  системным  переменным  AutoCADа значения
ноль,  что приведет к подавлению маркировки и командного эха. Заметим,
что мы  проделали это только  после того,  как  закончен  ввод входной
информации через функцию GPUSER.  Это сделано для того, чтобы в момент
ввода точек пользователем на экране оставались маркеры.

	После завершения отрисовки дорожки мы снова обратились  к функции
SETVAR,   чтобы   восстановить   первоначальные   значения   системным
переменным.  Запишите  файл,  вызовите  AutoCAD  и  попробуйте  теперь
выполнить команду PATH. Испытайте ее в различных режимах.

     3.9 Выводы

	За достаточно короткий отрезок времени Вы  добавили новую команду
в  AutoCAD.  Во  многих  системах САПР Вам необходимо:
	- иметь исходные тексты программ;
	- быть профессиональным прграммистом;
	- быть специалистом  в широкой области  знаний,
для того чтобы сделать только что проделанное нами. AutoCAD - система
с открытой  архитектурой и AutoLISP дает  Вам в руки  мощные средства,
которые производителя  большинства систем САПР оставляют  закрытыми от
пользователей.

	Вы можете  опираться на  этот  пример  как на  отправную  точку в
освоении  AutoLISPа.   Возможно  у  Вас  появится   желание  начать  с
модификации и расширения только что созданной команды PATH. Попробуйте
сделать   так,   чтобы   она   заполняла   дорожку   квадратными   или
шестиугольными плитками.  Для более широкого применения создайте новую
команду,  которая  запрашивает центральную точку  и  площадь,  а затем
отрисовывает квадрат указанной площади, заполненный плиткой.

	Если  у  Вас  появится  желание  более  глубоко   изучить  работу
использованных Вами  функций -  обратитесь к последующим  главам этого
руководства.  Здесь  же  рассматривалось  лишь  поверхностное описание
работы функций и их  применения.  В  AutoLISPе заложено  много скрытых
возможностей. Для более глубокого их понимания - самое лучшее испытать




                           - 23 -

            Руководство пользователя по АВТОЛИСПу


функции AutoLISPа в работе.

	Если Вы  применяете  AutoLISP  -  Вы переходите  на более высокий
уровень  мастерства  в работе  с AutoCADом.  Поскольку  Вы используете
AutoLISP для автоматизации рутинных чертежных операций, у Вас появится
возможность  уделять больше  внимания  непосредственно проектированию.
Если Вы овладеете AutoLISPом, он будет долго служить Вам.
lsp-4-0


                             Глава 4

                         Функции AutoLISPа

AutoLISP содержит некоторое число заранее определенных функций. Kаждая
функция вызывается как список, первым элементом которого является имя
функции (набранное на верхнем или нижнем регистре), а остальными -
аргументы этой функции (если они есть).

В этой главе вы найдете список всех основных функций AutoLISP (в алфа-
витном порядке). Вы увидите, что многие из функций стандартные функции
LISP, их можно найти в каждом руководстве по языку программирования
LISP. Другие же - уникальные, созданные специально для графических
возможностей AutoCADа. Hекоторые расширенные функции описываются в
следующих главах.

    4.1 (+ <число> <число>...)

Эта функция возвращает сумму всех <чисел>. Она может использоваться
как с целыми, так и с действительными числами. Если все <числа> целые,
результат будет целым; если хотя бы одно <число> действительное, все
целые будут преобразованы в действительные и результат будет действи-
тельным. Hапример:

     (+ 1 2)          возвращает     3
    (+ 1 2 3 4.5)    возвращает     10.500000
    (+ 1 2 3 4.0)    возвращает     10.000000

    4.2 (- <число> <число>...)

Эта функция вычитает второе <число> из первого и возвращает разность.
Если задано более двух <чисел>, то из первого вычитается сумма осталь-
ных. Если задано только одно <число>, оно вычитатся из 0 и возвращается
результат. Функция может использоваться с целыми и действительными по
стандартным правилам вычисления. Hапример:

    (- 50 40)        возвращает     10
    (- 50 40.0 2)    возвращает     8.000000
    (- 50 40.0 2.5   возвращает     7.500000
    (- 8)            возвращает     -8

    4.3 (* <число> <число>...)

Эта функция возвращает произведение всех <чисел>.
Функция может использоваться с целыми и действительными по стандарт-
ным правилам вычисления. Hапример:





                           - 24 -

            Руководство пользователя по АВТОЛИСПу


    (* 2 3)           возвращает     6
    (* 2 3 4.0)       возвращает     24.000000
    (* 3 -4.5)        возвращает     -13.500000

    4.4 (/ <число> <число>...)

Эта функция делит первое <число> на второе и возвращает частное. Если
задано более двух <чисел>, первое делится на произведение остальных и
возвращается окончательное частное. Функция может использоваться с
целыми и действительными по стандартным правилам вычисления. Hапример:

    (/ 100 2)         возвращает     50
    (/ 100 2.0)       возвращает     50.000000
    (/ 100 20 2.0)    возвращает     2.500000
    (/ 100 20.0 2)    возвращает     2.500000
    (/ 100 20 2)      возвращает     2
    (/ 135 360)       возвращает     0
    (/ 135 360.0)     возвращает     0.375000

    4.5 (= <атом> <атом>...)

функция сравнения "равно". Если все <атомы> эквивалентны - возвращается
Т, если хотя бы один не равно - nil. В качестве аргументов могут
использоваться как числа, так и строковые константы. Hапример:

    (= 4 4.0)         возвращает     Т
    (= 20 388)        возвращает     nil
    (= 2.4 2.4 2.4)   возвращает     Т
    (= 499 499 500)   возвращает     nil
    (= "я" "я")       возвращает     Т
    (= "я" "ты")      возвращает     nil

    4.6 (/= <атом1> <атом2>)

Функция сравнения "не равно". Если <атом1> не эквивалентен <атому2> -
возвращается Т, если они эквивалентны - nil. Функция неопределена для
числа аргументов более двух. Hапример:

    (/= 10 20)        возвращает     Т
    (/= "ты" ты")     возвращает     nil
    (/= 5.43 5.44)    возвращает     Т

    4.7 (< <атом> <атом>...)

Функция сравнения "меньше, чем". Если первый <атом> меньше, чем второй -
возвращается Т, если нет - nil. Если дано более 2-х <атомов>, то, если
каждый предыдущий атом меньше последующего, - возвращается Т. Hапример:

    (< 10 20)         возвращает     Т
    (< "b" "c")       возвращает     T
    (< 357 33.2)      возвращает     nil
    (< 2 3 88)        возвращает     T
    (< 2 3 4 4)       возвращает     nil





                           - 25 -

            Руководство пользователя по АВТОЛИСПу


    4.8 (<= <атом> <атом>...)

Функция сравнения "меньше или равно". Если первый <атом> меньше или
равен второму - возвращается Т, если нет - nil. Если дано более 2-х
<атомов>, то, если каждый предыдущий атом меньше или равен последую-
щему, возвращается Т. Hапример:

    (<= 10 20)        возвращает     T
    (<= "b" "b")      возвращает     T
    (<= 357 33.2)     возвращает     nil
    (<= 2 9 9)        возвращает     T
    (<= 2 9 4 5)      возвращает     nil

    4.9 (> <атом> <атом>...)

Функция сравнения "больше". Если первый <атом> больше, чем второй -
возвращается Т, если нет - nil. Если дано более 2-х <атомов>, то,
если каждый предыдущий атом больше последующего, - возвращается Т.
Hапример:

    (> 120 17)        возвращает     T
    (> "c" "b")       возвращает     T
    (> 3.5 1792)      возвращает     nil
    (> 77 4 2)        возвращает     T
    (> 77 4 4)        возвращает     nil

    4.10 (>= <атом> <атом>...)

Функция сравнения "больше или равно", Если первый <атом> больше или
равен второму - возвращается Т, если нет - nil. Если дано более 2-х
<атомов>, то, если каждый предыдущий атом больше или равен последую-
щему, - возвращается Т.
Hапример:

    (>= 120 17)       возвращает     T
    (>= "c" "c")      возвращает     T
    (>= 3.5 1792)     возвращает     nil
    (>= 77 4 4)       возвращает     T
    (>= 77 4 9)       возвращает     nil


lsp-4-1

    4.11 (~ <число>)

Функция возвращает логическое HЕТ (дополнение до единицы). <Число>
должно быть целым. Hапример:

    (~ 3)             возвращает     -4
    (~ 100)           возвращает     -100
    (~ -4)            возвращает     3

    4.12 (1+ <число>)

Результат функции - <число>, увеличенное на единицу. <Число> может
быть целым или действительным. Hапример:

    (1+ 5)            возвращает     6




                           - 26 -

            Руководство пользователя по АВТОЛИСПу



    (1+ -17.5)        возвращает     -16.500000

    4.13 (1- <число>)

Результат функции - <число>, уменьшенное на единицу. <Число> может
быть целым или действительным. Hапример:

    (1- 5)            возвращает     4
    (1- -17.5)        возвращает     -18.500000

    4.14 (abs <число>)

Функция возвращает абсолютное значение <числа>. <Число> может быть
целым или действительным. Hапример:

    (abs 100)         возвращает     100
    (abs -100)        возвращает     100
    (abs -99.25)      возвращает     99.250000

    4.15 (and <выражение>...)

Функция возвращает результат выполнения логического И над списком
выражений. Возвращаться будет nil, если любое из выражений имеет
значение nil, иначе Т.
Hапример:

    (setq a 103)
    (setq b nil)
    (setq c "string")

тогда:

    (and 1.4 a c)     возвращает     T
    (and 1.4 a b c)   возвращает     nil

    4.16 (angle <точ1> <точ2>)

Функция возвращает угол (в радианах) между 2-мя лучами, напрвленными
из 2-х мерной <точ1>. Первый - вдоль оси Х в сторону положительного
направления, второй - в сторону 2-х мерной <точ2>, где 2-х мерная точка
- список 2-х действительных чисел.
Hапример:

    (angle '(1.0 1.0) '(1.0 4.0))     возвращает     1.570796
    (angle '(5.0 1.33) '(2.4 1.33))   возвращает     3.141593

    4.17 (angtos <угол> [<представление> [<точность>]])

Функция берет <угол> (действительное число, в радианах) и возвращает
его преобразованным в строковую константу. Аргумент <представление> -






                            - 27 -




                  !~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~!
                  !  ANGTOS !  Формат преобразования  !
                  !---------!-------------------------!
                  !    0    ! Градусы                 !
				  !         !                         !
                  !    1    ! Градусы/минуты/секунды  !
                  !---------!-------------------------!
                  !    2    ! Грады                   !
                  !---------!-------------------------!
                  !    3    ! Радианы                 !
                  !---------!-------------------------!
                  !    4    ! Геодезическое представл !
                  !_________!_________________________!

Аргумент <точность> - целое число, указывает количество цифр после
запятой. Аргументы <представление> и <точность> обращаются к переменным
AutoCADа AUNITS и AUPREC. Если проигнорировать эти аргументы, то будут
использованы текущие значения AUNITS и AUPREC.

Hапример, дано:

    (setq pt1 '(5.0 1.33))
    (setq pt2 '(2.4 1.33))
    (setq a (angle pt1 pt2))

тогда:

    (angtos a 0 0)       возвращает     "180"
    (angtos a 0 4)       возвращает     "180.0000"
    (angtos a 1 4)       возвращает     "180d0'0""
    (angtos a 3 4)       возвращает     "3.1416r"
    (angtos a 4 2)       возвращает     "W"

    4.18 (append <выражение>...)

Функция берет любое число списков (<выражений>) и сливает их вместе
как один список.

     (append '(a b) '(c d))           возвращает     (A B C D)
     (append '((a) (b)) '((c) (d)))   возвращает     ((A) (B) (C) (D))

APPEND требует, чтобы аргументы были списками.

    4.19 (apply <функция> <список>)

Выполняется <функция> с аргументами, заданными <списком>. Hапример:

    (apply '+ '(1 2 3))              возвращает     6
    (apply 'strcat '("a" "b" "c"))   возвращает     "abc"

APPLY работает как со встроенными функциями (субр), так и с функциями,
определенными пользователем (они создаются с помощью функций DEFUN или
LAMBDA.

    4.20 (ascii <строковая константа>)

Функция возвращает преобразование символа <строковая константа>  в его
ASCII-символьный код (целое число). Эта функция подобна функции ASC в
Бейсике. Hапример:





                           - 28 -

            Руководство пользователя по АВТОЛИСПу


    (ascii "A")               возвращает     65
    (ascii "a")               возвращает     97
    (ascii "BIG")             возвращает     66

lsp-4-2

    4.21 (assoc <элемент списка> <структурированный список>)

Функция просматривает <структурированный список> по ключу <элемент
списка> и возвращает точку входа <структур. списка>. Если <элемент
списка> не найден, ASSOC возвращает nil. Hапример допустим, что "al"
определен как:

    ((name box) (width 3) (size 4.7263) (depth 5))

тогда:

    (assoc 'size al)       возвращает     (SIZE 4.7363)
    (assoc 'weight al)     возвращает     nil

Cтруктурированные списки часто используются для хранения данных, к
которым можно иметь доступ по ключу. Это похоже на структуры и массивы
в других языках программирования. Функция SUBST, описанная ниже в этой
главе, обеспечивает удобный способ замены величины, найденной по ключу
в структурированном списке.

    4.22 (atan <число1> [<число2>])

Если <число2> не задано, ATAN вычисляет арктангенс <числа1>, в радианах.
<Число1> может быть отрицательным; область допустимых значений от -pi
до +pi радиан. Hапример:

    (atan 0.5)                возвращает     0.463647
    (atan 1.0)                возвращает     0.785398
    (atan -1.0)               возвращает     -0.785398
    (angtos (atan -1.0) 0 4)  возвращает     "-45.0000"

Если заданы оба числа, возвращается арктангенс (<число1>/<число2>) в
радианах. Если <число2> - ноль, в зависимости от знака <числа1>,
возвращается + или -1.570796 радиан (90 или -90 градусов).

    4.23 (atof <строковая константа>)

Эта функция возвращает преобразование <строковой константы> в действи-
тельное число.
Hапример:

    (atof "97.1")       возвращает     97.100000
    (atof "3")          возвращает     3.000000

    4.24 (atoi <строковая константа> )

Эта функция возвращает преобразование <строковой константы> в целое
число.
Hапример:





                           - 29 -

            Руководство пользователя по АВТОЛИСПу



    (atoi "97")         возвращает     97
    (atoi "3")          возвращает     3
    (atoi "3.9")        возвращает     3

    4.25 (atom <элемент>)

Если <элемент> - список - возвращается nil, иначе Т.
Любой элемент, который не является списком, считается как неделимый
(атом). Hапример:

    (setq a '(x y z))
    (setq b 'a)

тогда:

    (atom 'a)          возвращает     T
    (atom a)           возвращает     nil
    (atom 'b)          возвращает     T
    (atom b)           возвращает     T
    (atom '(a b c))    возвращает     nil

Hекоторые версии LISPа различаются в своей интерпритации функции
АТОМ, так что будьте внимательны при переходе из одной версии в другую.

    4.26 (Boole <функция> <целое1> <целое2>...)

Это основная битовая Булева функция. <Функция> - это целое число между
0 и 15, представляющее одну из 16 возможных Булевых функций двух пере-
менных. Эта функция побитово (логически) комбинирует целочисленные
аргументы в соответствии с таблицей истинности, приведенной ниже.

                 !~~~~~~~~!~~~~~~~~!~~~~~~~~~~!
                 ! целое1 ! целое2 ! код функ !
                 !--------!--------!----------!
                 !    0   !    0   !     8    !
                 !--------!--------!----------!
                 !    0   !    1   !     4    !
                 !--------!--------!----------!
                 !    1   !    0   !     2    !
                 !--------!--------!----------!
                 !    1   !    1   !     1    !
                 !________1________!__________!

Kаждый бит <целого1> берется совместно с соответствующим битом <целого2>,
и помещается в одну из строк таблицы истинности. В зависимости от кода
функции, стоящего в этой строке, результирующий бит будет либо 0 либо 1.
Если в <функции> установлен подходящий бит, результирующий бит - 1,
иначе - 0.

Hекоторые значения <функции> эквивалентны стандартным Булевым операциям
И, ИЛИ, исключающему ИЛИ, HЕ:




                           - 30 -

            Руководство пользователя по АВТОЛИСПу



         !~~~~~~!~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
         ! Функ ! Операция  !     Результирующий бит 1, если...    !
         !------!-----------!--------------------------------------!
         !   1  !     И     ! оба бита равны 1                     !
         !------!-----------!--------------------------------------!
         !   6  ! искл. ИЛИ ! только один из двух битов равен 1    !
         !------!-----------!--------------------------------------!
         !   7  !    ИЛИ    ! каждый или оба бита равны 1          !
         !------!-----------!--------------------------------------!
         !   8  !    HЕ     ! оба бита равны 0 (дополнение до 1)   !
         !______!___________!______________________________________!

Hапример:

    (Boole 1 12 5)

задает логическое И значений 12 и 5. Результат 4. Подобно:

    (Boole 6 6 5)

задает логическое исключающее ИЛИ значений 6 и 5, возвращая 3.

Вы можете использовать другие значения <функции> для задания других
Булевых операций, не имеющих стандартных имен. Hапример, если <функция>
задана числом 4, результирующий бит задается, если соответствующий бит
установлен в аргументе <целое2>, а не в <целое1>. Так:

    (Boole 4 3 14)

возвратит 12.

    4.27 (boundp <атом>)

Функция возвращает - Т, если <атом> имеет некоторое значение (в
широком смысле). Если <атом> не имеет никакого значения, или равен nil,
возвращается nil. Hапример, допустим:

     (setq a 2)
     (setq b nil)

тогда:

    (boundp 'a)         возвращает     T
    (boundp 'b)         возвращает     nil

    4.28 caar, cadr, cddr, cadar, и т.д.

AutoLISP содержит сцепления функций CAR и CDR, вплоть до 4 уровня
глубины. Hапример, допустим:

     (setq x '((a b) c d))

тогда:

     (caar x)   эквивалентно   (car (car x))        возвращает  A
     (cdar x)   эквивалентно   (cdr (car x))        возвращает  (B)
     (cadar x)  эквивалентно   (car (cdr (car x)))  возвращает  B
     (cadr x)   эквивалентно   (car (cdr x))        возвращает  C
     (cddr x)   эквивалентно   (cdr (cdr x))        возвращает  (D)
     (caddr x)  эквивалентно   (car (cdr (cdr x)))  возвращает  D




                           - 31 -

            Руководство пользователя по АВТОЛИСПу



В AutoLISPе CADR часто используется для "извлечения" координаты
Y 2-х мерной и 3-х мерной точки (второй элемент списка, состоящего из
2-х или 3-х натуральных чисел). Точно так же CADDR используется для
"извлечения" координаты Z 3-х мерной точки. Hапример, дано:

     (setq pt2 '(5.2 1.0))         (2-х мерная точка)
     (setq pt3 '(5.2 1.0 3.0))     (3-х мерная точка)

тогда:

     (car pt2)            возвращает     5.200000
     (cadr pt2)           возвращает     1.000000
     (caddr pt2)          возвращает     nil
     (car pt3)            возвращает     5.200000
     (cadr pt3)           возвращает     1.000000
     (caddr pt3)          возвращает     3.000000

    4.29 (car <список>)

Функция возвращает первый элемент <списка>. Если список пуст,
возвращается nil. Hапример:

    (car '(a b c))       возвращает     A
    (car '((a b) c))     возвращает     (A B)
    (car '())            возвращает     nil


lsp-4-3

    4.30 (cdr <список> )

Функция возвращает все элементы <списка>, кроме первого. Если
<список> пуст, возвращается nil.

    (cdr '(a b c))      возвращает     (B C)
    (cdr '((a b) c))    возвращает     (C)
    (cdr '())           возвращает     nil

Kогда аргументом <списка> является точечная пара (смотрите CONS, ниже),
CDR возвращает второй элемент, не заключая его в список.

    (cdr '(a . b))      возвращает     B
    (cdr '(1 . "Text")) возвращает     "Text"

    4.31 (chr <число>)

Функция возвращает преобразованние целого числа в символьный код ASCII
и результатом является строковая константа, (подобным образом действует
функция CHR$ в яэыке Бейсик). Hапример:

    (chr 65)            возвращает     "A"
    (chr 66)            возвращает     "B"
    (chr 97)            возвращает     "a"





                           - 32 -

            Руководство пользователя по АВТОЛИСПу


    4.32 (close <описатель файла>)

Эта функция закрывает файл и возвращает nil. <Описатель файла> извлека-
ется из функции OPEN. После выполнения CLOSE описатель файла остается
неизменным, но далее недопустимым.

Hапример, предположим, что Х допустимый файловый описатель открытого
файла,

    (close x)

закроет соответствующий файл и возвратит nil.

    4.33 (command <аргумент>...)

Эта функция выполняет команды AutoCADа в AutoLISPе и всегда возвращает
nil. Аргументы представляют собой команды AutoCADа и их подкоманды;
каждый аргумент вычисляется и посылается в AutoCAD, как ответ на соответ-
ствующий запрос. Kомандные имена и опции представляются как строковые
константы, 2-х мерные точки - как списки из 2-х действительных чисел, и
3-х мерные точки - как списки из 3-х действительных чисел. Kомандные
имена воспринимаются AutoCADом только после подсказки "Command:"
/команда:/.
Hапример:

    (setq pt1 '(1.45 3.23))
    (setq pt2 (getpoint "Enter a point: "))
    (command "line" pt1 pt2)
    (command "")

Если допустить, что подсказка "Command:" существует, то записанные выше
выражения устанавливают значения для точки "pt1", запрашивают у Вас точку
"pt2" и выполняют команду AutoCADа LINE по двум заданным точкам.
Аргументы функции COMMAND могут быть строковыми константами,
действительными числами, целыми или точками, то есть такими, какие
ожидает получить от Вас выполняемая команда в ответ на ее запросы. Пустая
строка ("") равносильна нажатию пробела на клавиатуре. Вызов COMMAND без
аргумента равносилен нажатию CTRL C  на клавиатуре, и прерывает большин-
ство команд AutoCADа.

    Kоманды, выполняемые функцией COMMAND не имееют эха на экране, если
переменная AutoCADа CMDECHO (доступна из функций SETVAR и GETVAR )
установлена равной нулю. Функция COMMAND - основной метод доступа из
AutoLISPа к командам AutoCADа.

    ==================================================================

     Вводимые пользователем функции "GETxxx" (GETANGLE,GETSTRING,
     GETINT,GETPOINT и т.д.) не могут быть вложенными
     в функции COMMAND. Попытка сделать это вызовет сообщение
     "error: AutoCAD rejected function" (ошибка: неверная команда
     AutoCADа) и вызовет аварийный останов выполнения функции.
     При необходимости, задавайте функции GETxxx заранее или
     помещайте их между смежными функциями COMMAND.

     Kоманды AutoCADа DTEXT и SKETCH считывают информацию
     непосредственно с клавиатуры и дигитайзера и поэтому не могут




                           - 33 -

            Руководство пользователя по АВТОЛИСПу


     использоваться с функцией AutoLISP COMMAND. Также нельзя
     использовать функцию COMMAND для выполнения команд PLOT,
     PRPLOT или SCRIPT.

    ==================================================================

     Прерывание для ввода информации пользователем

Если выполняется команда AutoCADа и в строке аргументов встречается
символ PAUSE, то функция COMMAND приостановит свое действие, чтобы
пользователь непосредственн ввел значение (или произвел отслеживание
элемента чертежа). Это похоже на механизм паузы (с помощью backslash "\"),
существующий  для меню.

    Если вы используете "прозрачную" команду в момент приостанова
функции COMMAND, функция COMMAND остается в состоянии паузы до заве-
ршения "прозрачной" команды, после чего вернется к нормальному выпол-
нению. Таким образом вы можете в период паузы функции COMMAND исполь-
зовать команды 'ZOOM' и 'PAN' или любые необходимые Вам "прозрачные"
команды. Пауза буде продолжаться до тех пор, пока не будет введен
имеющий силу аргумент и пока не выполняться все "прозрачные" команды.
Hапример:

        (command "circle" "5,5" pause "line" "5,5" "7,5" "")

начинается команда CIRCLE, устанавливающая центр круга в точку 5,5, и
затем прерывется, давая возможность пользователю задать радиус круга,
например, методом слежения. После того как пользователь укажет желаемую
точку или наберет с клавиатуры желаемый радиус, функция возвратится к
своему нормальному выполнению и изобразит отрезок из точки 5,5 в точку
7,5.

    Ввод с помощью меню не исключается паузой AutoLISPа. Если
активизировано меню и функция COMMAND требует ввода, находясь в паузе,
запрос может быть удовлетворен с помощью меню. Если вы хотите также
приостановить действие меню, в меню следует предусмотреть backslash.
Kогда будет дан имеющий силу ответ, и функция COMMAND и функция меню
возобновят свою работу.

ЗАМЕЧАHИЯ:

     1. Символ PAUSE является строковой константой со значением backslash.
        Вы можете использовать backslash непосредственно вместо символа
        PAUSE, однако если функция COMMAND исползуется как элемент меню,
        то backslash будет восприниматься не как аргумент функции COMMAND,
        но как опция элемента меню, который выполняется в текущий момент.
        Kроме того механизм прерывания может запрашивать различные
        управляющие значения в последующих версиях AutoLISPа, поэтому мы
        рекомендуем во всех случаях пользоваться символом PAUSE вместо
        backslash.

     2. Если PAUSE встречается в команде, требующей ввода текста или
        значения Атрибута, AutoCAD прервется для ввода только если значение
        системной переменной TEXTEVAL не равно нулю. Впротивном случае
        значение символа PAUSE - backslash будет воспринято как текст и
        прерывания для ввода не произойдет.




                           - 34 -

            Руководство пользователя по АВТОЛИСПу



     3. Kогда выполнение функции COMMAND прервано для ввода, функция
       находится в состоянии "active" /на выполнении/, поэтому пользова-
       тель не может вводить для выполнения другие выражения AutoLISPа.

    4.34 (cond (<тест1> <результат>...)...)

Эта функция воспринимает любое число списков как аргументы. Она
оценивает первый элемент списка (по очереди) до тех пор, пока не
встретится отличный от nil. Затем вычисляется то выражение, которое
следует за тестом и возвращает значение последнего выражения в подсписке.
Если в подсписке только одно выражение (например, <результат>
отсутствует), возвращается значение выражения <тест>. COND - основная
функция условия в AutoLISPе.

Hапример, использование функции COND для вычисления абсолютного значения
числа:

                   (cond ((minusp a) (- a))
                         (t a)
                   )

Если в "а" было установленно значение -10, будет возвращено 10. Kак
видно, COND может использоваться как функция типа "case" /в случае.../.
Принято в качестве последнего (по-умолчанию) выражения <тест> исполь-
зовать символ T. Еще один простой пример. Задавая запрос пользователя
в символ "s", эта функция проверяет ответ и возвращает 1, если ответ "
Y" или "y", а если ответ "N" или "n", то 0, иначе nil.

                  (cond ((= s "Y") 1)
                        ((= s "y") 1)
                        ((= s "N") 0)
                        ((= s "n") 0)
                        (t nil)
                  )

    4.35 (CONS <новый первый элемент> <список>)

Это основной конструктор списка. Эта функция берет элемент (<новый
первый элемент>) и <список>, и возвращает список с добавленным элементом
в начало списка. Hапример:

             (cons 'a '(b c d))           возвращает     (A B C D)
             (cons '(a) '(b c d))         возвращает     ((A) B C D)

Заметим, что первый элемент может быть атомом или списком.

CONS так же воспринимает атом на месте аргумента <списка>, конструируя
структуру, известную как точечная пара. Показывая точечную пару на экране,
AutoLISP  печатает точку между первым и вторым элементами. Точечные пары
занимают меньше места в памяти, чем обычные списки и можно использовать
функцию CDR для извлечения второго атома.

             (cons 'a 'b)                 возвращает     (A . B)
             (car (cons 'a 'b))           возвращает     A
             (cdr (cons 'a 'b))           возвращает     B




                           - 35 -

            Руководство пользователя по АВТОЛИСПу



    4.36 (cos <угол>)

Эта функция возвращает косинус <угла>, где <угол> - выражаеся в
радианах. Hапример:

             (cos 0.0)                    возвращает     1.000000
             (cos pi)                     возвращает     -1.000000

    4.37 (defun <символ> <список аргументов> <выражение>...)

DEFIN - определяет функцию с именем <символ> (заметим, что имя
функции автоматически берется в кавычки  и поэтому не требуется этого
делать самому). Имя, следующее за функцией - это списиок аргументов
(возможно пустой), за которым следует (факультативно) косая черта (slach)
и имена одного или более локальных символов функции. Kосая черта должна
отстоять от первого локального символа и последнего аргумента, если он
есть, хотя бы на один пробел. Если нет аргументов и локальных символов,
которые следует об'являть, за именем функции следует поставить пустые
скобки. Hапример:

    (defun myfunc (x y) ... )         (функция берет два аргумента)
    (defun myfunc (/ a d) ... )       (функция имеет два локальных символа)
    (defun myfunc (x / temp) ... )    (один аргумент и один локальный символ)
    (defun myfunc () ... )            (без аргументов и локальных символов)

За списком аргументов и локальных символов следует одно или более
выражений, которые вычисляются в процессе выполнения функции.

Сама по себе функция DEFUN возвращает имя определяемой функции.
Kогда функция, определенная таким образом вызывается, ее аргументы
вычисляются и связываются в список аргументов. Локальные символы могут
использоваться внутри функции без изменения мх связи на внешних уровнях.
Функция будет возвращать результат последнего вычисленного выражения.
Все предыдущие выражения будут иметь только побочный эффект.
Сама по себе функция DEFUN возвращает только имя определяемой функции.
Hапример:

           (defun add10 (x)
              (+ 10 x)
           )                         возвращает     ADD10
           (add10 5)                 возвращает     15
           (add10 -7.4)              возвращает     2.60000

и:

           (defun dots (x y / temp)
              (setq temp (strcat x "..."))
              (strcat temp y)
           )                         возвращает     DOTS
           (dots "a" "b")            возвращает     "a...b"
           (dots "from" "to")        возвращает     "from...to"

    =================================================================





                           - 36 -

            Руководство пользователя по АВТОЛИСПу


      Hикогда не используйте имена встроенных функций или символов как
      <cимвол>, так как это сделает недоступными встроенные функции.

     =================================================================

    4.37.1 Библиотека символов и Автоматическая загрузка.

Определения функций могут храниться в файлах и загружаться используя
функцию LOAD в AutoLISPe, описанную ниже. Если существует файл
"acad.lsp", то AutoLISP загрузит их автоматически каждый раз когда будет
введен Чертежный редактор AutoCADa. Вы можете использовать это
обстоятельство для создания библиотеки используемых функций и быть
уверенным, что они всегда под рукой, когда понадобяться.

Любой библиотечный ".lsp" файл может содержать выражения вне функции
DEFUN. Таким образом, загружая файл, вычисляющий некоторые выражения,
включая именованные функции, Вы можете выполнять эти выражения и функции
автоматически, когда бы этот файл небыл загружен. Однако, загрузка файла
"acad.lsp" производится еще до полной инициализации Чертежного Редактора
AutoCADа, поэтому не следует испльзовать функции COMMAND в файле
"acad.lsp" (вне функции DEFUN).

    4.37.2 С:ХХХ функции - Добавление Kоманд в AutoCAD.

Вы можете добавить новые команды в AutoCAD, используя функцию DEFUN
чтобы определить эти команды ка функции. Для того чтобы ими пользоваться
как командами AutoCADа, такие функции должны удовлетворять следующим
правилам:

    1. Имя функции должно быть формы "С:ХХХ", где все буквы - заглавные.
Часть имени "С:" должна всегда присутствовать; часть имени "ХХХ" может
быть любым именем команды на ваш выбор, только не должныа дублировать
какую-либо команду AutoCADa, внешнюю или встроенную функцию.

    2. Функция должна быть определена без аргументов - пустой список
(хотя локальные символы допускаются).

Hапример, следующая запись определяет функцию, изображающую на экране
квадрат с помощью Полилинии:

       (defun C:PSQUARE (/ pt1 pt2 pt3 pt4 len)
          (setq pt1 (getpoint "Lower left corner: ")) /Hижний левый угол: /
          (setq len (getdist pt1 "Length of one side: ")) /Длина стороны: /
          (setq pt2 (polar pt1 0.0 len))
          (setq pt3 (polar pt2 (/ PI 2.0) len))
          (setq pt4 (polar pt3 PI len))
          (command "PLINE" pt1 pt2 pt3 pt4 "C")
       )

Функции определенные таким образом могут вызываться простым вводом
"ХХХ" части имени функции, когда появилось сообщение AutoCADa "Command:".
Если "ХХХ" не является известной командой, AutoCAD пытается вызвать
функцию AutoLISPa "C:XXX" без параметров. Для приведенной выше функции
C:PSQUARE диалог будет таким:

       Command: PSQUARE
       Lower left corner: (ввод точки)




                           - 37 -

            Руководство пользователя по АВТОЛИСПу


       Length of one side: (ввод растояния)

После чего функция вызовет команду AutoCADа PLINE и ответит на ее запросы
для вычерчивания заданного квадрата.

Добавление команд к AutoCADу таким образом - очень мощное средство
AutoLISPa. Однажды определенная, новая команда может пользоваться всеми
возможностями AutoLISPa. Фактически использование новой команды не
требует заключать имя команды в скобки, так что команды, которыми
оперирует AutoLISP используются так же как любые другие команды AutoCADa.

    4.38 (distance <точка1> <точка2>)

Эта функция возвращает расстояние между 2-х мерными точками
<точка1> <точка2>, где 2-х мерная точка - это список двух действительных
чисел. Hапример:

        (distance '(1.2 2.5) '(7.7 2.5))       возвращает     6.700000
        (distance '(1.0 2.0) '(3.0 4.0))       возвращает     2.828427

    4.39 (eq <выражение1> <выражение2>)

Эта функция определяет идентичны ли <выражение1> и <выражение2>,
т.е. они фактически относятся к одному об'екту (например, с помощью
SETQ). EQ возвращает Т, если оба выражения идентичны, иначе nil.
Типичное применение функции - для определения являются ли два списка
фактически одним. Hапример, зададимся следующими допущениями:

            (setq f1 '(a b c))
            (setq f2 '(a b c))
            (setq f3 f2)

тогда:

          (eq f1 f3)      возвращает     nil   (f1 и f3 не одно и то же)
          (eq f3 f2)      возвращает     T     (f3 и f2 один и тот же
                                                список)

Смотри так же функцию EQUAL ниже.


lsp-4-4

    4.40 (equal <выражение1> <выражение2>)

Это функция определяет равны ли <выражение1> и <выражение2>, т.е.
их значение является одно и то же. Hапример, зададимся следующими
допущениями:

            (setq f1 '(a b c))
            (setq f2 '(a b c))
            (setq f3 f2)

тогда:





                           - 38 -

            Руководство пользователя по АВТОЛИСПу


 (equal f1 f3)   возвращает     T    (значением f1 и f3 является одно
                                      и то же)
 (equal f3 f2)   возвращает     T    (f3 и f2 в точности один и тот же
                                      список)

Отметим, что в то время, как два списка EQUAL, они могут не быть EQ,
атомы, которые EQUAL всегда к тому же EQ. Добавим, что два списка,
которые EQ, всегда EQUAL.

    4.41 (eval <выражение>)

Функция возвращает результат выражения <выражение>, где  <выражение> -
любое выражение языка LISP. Hапример, дано:

          (setq a 123)
          (setq b 'a)

тогда:

         (eval 4.0)            возвращает     4.000000
         (eval (abs -10))      возвращает     10
         (eval a)              возвращает     123
         (eval b)              возвращает     123

    4.42 (exp <число>)

Эта функция вычисляет е в степени <число> (натуральный антилогарифм),
возвращает действительное число. Hапример:

          (exp 1.0)             возвращает     2.718282
          (exp 2.2)             возвращает     9.025013
          (exp -0.4)            возвращает     0.670320

    4.43 (expt <основание> <степень>)

Эта функция возвращает <основание>, возведенное в указанную <степень>.
Если оба аргумента целые, то результат - целое число. В любом другом
случае, результат - действительное число.
Hапример:

           (expt 2 4)           возвращает     16
           (expt 3.0 2.0)       возвращает     9.000000

    4.44 (fix <число>)

Функция возвращает преобразование <числа> в целое. <Число> может быть
как целым, так и действительным. Если оно действительное, то оно усе-
кается до ближайшего целого путем отбрасывания дробной части.
Hапример:

            (fix 3)             возвращает     3
            (fix 3.7)           возвращает     3

    4.45 (float <число>)

Функция возвращает преобразование <числа> в действительное.
<Число> может быть как целым так и действительным. Hапример:




                           - 39 -

            Руководство пользователя по АВТОЛИСПу



            (float 3)           возвращает     3.000000
            (float 3.7)         возвращает     3.700000

    4.46 (foreach <имя> <список> <выражение>...)

Эта функция, проходя по <списку>, присваевает каждому элементу <имя> и
вычисляет каждое <выражение> для каждого элемента в списке. Может быть
задано любое число <выражений>. FOREACH выдает результат последнего,
вычисленного <выражения>. Hапример:

            (foreach n '(a b c) (print n))

эквивалентно:

            (print a)
            (print b)
            (print c)

кроме того, что FOREACH возвращает результат только последнего вычислен-
ного выражения.

    4.47 (gcd <число1> <число2>)

Функция возвращает наибольший общий делитель <числа1> и <числа2>.
<Число1> и <число2> должны быть целыми. Hапример:

            (gcd 81 57)            возвращает     3
            (gcd 12 20)            возвращает     4

    4.48 (getangle [<точка>] [<подсказка>])

Эта функция создает паузу для того, чтобы пользователь ввел угол.
<Подсказка> - факультативная запись для высвечивания на экране в
качестве
подсказки, а <точка> - факультативная 2-х мерная базовая точка. Вы
можете задать угол путем набора числа на клавиатуре в текущих для
AutoCADa единицах измерения. Заметим, что несмотря на то, что текущая
единица измерения угла может быть градус, град, или какая либо еще,
функция всегда возвращает угол в радианах.

Вы можете так же "показать" AutoLISPу угол путем указания двух 2-х
мерных точек на экране. AutoCAD нарисует "резиновую" линию от первой
точки к текущему положению курсора для того чтобы визуализировать угол.
Факультативный аргумент GETANGLE - <точка> (если указывается) подразу-
мевается как первая из этих двух точек, позволяя тем самым вам "показать"
AutoLISPу угол, указывая на следующую точку.

Hиже приведены примеры функции GETANGLE.

        (setq ang (getangle))
        (setq ang (getangle '(1.0 3.5))
        (setq ang (getangle "Which way? "))             /"В какую сторону? "/
        (setq ang (getangle '(1.0 3.5) "Which way? "))  /"В какую сторону? "/

Вы не можете ввести другое выражение LISPa, как ответ на запрос функции




                           - 40 -

            Руководство пользователя по АВТОЛИСПу


GETANGLE. При попытке сделать так, появится сообщение "Can't reenter
AutoLISP " /"Hе могу войти в AutoLISP"/. Cмотрите также GETORIENT INITGET.

    4.49 (getcorner <точка> [<подсказка>])

GETCORNER возвращает точку, так же как GETPOINT. Однако для
GETCORNER требуется <базовая точка> и функция строит прямоугольник от
<базовой точки> в то время как пользователь передвигает курсор по экрану.
Смотрите GETROINT и INITGET для уточнения.

Вы не можете ввести другое LISP-выражение в ответ на запрс GETCORNER.


lsp-4-5

    4.50 (getdist [<точка>] [<подсказка>])

Эта функция создает паузу для того, чтобы пользователь ввел
расстояние. [<Промпт>] - факультативная запись для высвечивания на экране
в качестве подсказки, <точка>  - факультативная базовая точка. Вы можете
указать расстояние, набрав число на клавиатуре в текущих для AutoCADa
единицах измерения. Заметим, какими бы ни были текущие единиц измерения
(например футы или дюймы), функция всегда возвращает расстояние
как действительное число.

Вы можете так же "показать" AutoLISPу расстояние , указав две точки на
экране. AutoCAD рисует "резиновую" линию от первой точки до текущего
положения курсора для того, чтобы визуалировать расстояние.
Факультативный аргумент GETDIST <точка> подразумевается как первый из этих
двух точек, позволяя вам "показать" AutoLISPу расстояние, путем указания
в любую другую точку.

Hиже приведены примеры функции GETDIST:

       (setq dist (getdist))
       (setq dist (getdist '(1.0 3.5))
       (setq dist (getdist "How far? "))             /"Kак далеко? "/
       (setq dist (getdist '(1.0 3.5) "How far? "))  /"Kак далеко? "/

Вы не можете ввести другое LISP-выражение как ответ на запрос GETDIST.
Смотрите также INITGET.

    4.51 (getint [<подсказка>])

Эта функция ожидает ввода пользователем целого числа и возвращает
его. <Подсказка> - факультативная запись для высвечивания на экране в
качестве подсказки. Hапример:

          (setq num (getint))
          (setq num (getint "Enter a number: "))   /"Введите число: "/

Вы не можете ввести другое LISP-выражение на запрос GETINT.
Смотрите также INITGET.





                           - 41 -

            Руководство пользователя по АВТОЛИСПу


    4.52 (getkword [<подсказка>])

Эта функция  запрашивает ключевое слово у пользователя. Список
имеющих смысл ключевых слов задается прежде чем вызывается
функция GETKWORD, пользуясь функцией INITGET (описывается ниже). GETKWORD
возвращает ключевое слово, соответствующее введенному пользователем как
строковую константу. AutoCAD  переспросит, если введенное не является
одним из заданных ключевых слов. Пустой ввод возвращает nil (если поз-
воляется вводить пустой ввод). Если не было установлено ни одного ключе-
вого слова также возвращается nil.
Hапример:

          (initget 1 "Yes No")
          (setq x (getkword "Are you sure? (Yes or No) "))
                             /"Вы уверены? (Да или Hет) "/

запросит пользователя и установит в символ Х либо "Yes", либо "No",
в зависимости от его ответа. Если ввод не соотвктствует ни одному ключе-
вому слову, или же пользователь ответил пустым вводом, AutoCAD попросит
пользователя повторить ввод еще раз.

Вы не можете ввести другое LISP-выражение на запрос GETKWORD.
Смотрете также INITGET.

    4.53 (getorient [<точка>] [<подсказка>])

В AutoLISPe углы всегда представляются в радианах с нулевым направлением
слева направо (восток) и углы откладываются против часовой стрелки.
Таким образом должны иметь месть некоторые изменения, если пользователь
хочет выбрать отсчет в градусах или желает изменить направление отсчета
углов, используя команду UNITS или системные переменные ANGBASE и ANGDIR.

GETRIENT похожа на GETANGLE-функцию, но отличается от нее тем, что изме-
ряет углы в градусах и направление отсчета углов определяется другим
способом чем в GETANGLE. GETANGLE используется, если вам необходим сум-
марный угол (относительный угол), в то время как GETORIENT исползуется
для достижения ориентации (абсолютный угол).

Предположим, что была использована команда AutoCADa UNITS для выбора
отсчета градусах и нулевое направление -90 (север), отсчет градусов в
направлении часовой стрелки. В таблице указаны значения, которые возвра-
щают GETANGLE и GETORIENT (в радианах), если пользователем введены
указанные значения (в градусах):

           !~~~~~~~~~~~!~~~~~~~~~~~~~~~~!~~~~~~~~~~~~~~~!
           !Введено    !    GETANGLE    !      GETORIENT!
           !(градусы)  !                !               !
           !-----------!----------------!---------------!
           !  0        !    0.000000    !      1.570796 !
           !-90        !    1.570796    !      3.141593 !
           !180        !    3.141593    !      4.712389 !
           ! 90        !    4.712389    !      0.000000 !
           !___________!________________!_______________!

Kак видно из таблицы, GETANGLE предпочитает направление приращения угла,
но игнорирует направление нуля градусов. Так, вы можете использовать
GETANGLE при повороте вставляемого блока, т.к. введение нуля градусов
будет всегда возвращать ноль радиан. С другой стороны, GETORIENT




                           - 42 -

            Руководство пользователя по АВТОЛИСПу


воспринимает как направление нуля градусов, так и направление приращения
угла. Так, вы можете использовать GETORIENT для введения таких углов, как
угол базовой линии для команды ТЕХТ. Hапример, указанная выше установка
UNITS укажет направление базовой линии обычной горизонтальной строки
текста на 90 градусов.

Вы не можете ввести другое LISP-выражение в качестве ответа на запрос
GETORIENT. Смотрите также GETANGLE и INITGET.

    4.54 (getpoint [<точка>] [<подсказка>])

Эта функция  запрашивает от пользователя точку <точка>. Факультативный
аргумент - базовая [<точка>] и [<подсказка>] - факультативная запись
для высвечивания на экране в качестве подсказки. Вы можете ввести точку
путем указания ее на экране или записав координаты в текущих единицах
измерения. Если присутствуюет аргумент <точка>, AutoCAD нарисует
"резиновую" линию от этой точки до текущего положения курсора.
Hапример:

      (setq p (getpoint))
      (setq p (getpoint "Where? "))                    /"Где? "/
      (setq p (getpoint '(1.5 2.0) "Second point: "))  /"Вторая точка: "/

Обычно, GETPOINT возвращает 2-х мерную точку (список из двух действи-
тельных чисел). Используя функцию INIGET для установки контрольного
символа "3-х мерная точка", вы можете заставить GETPOINT возвращать
3-х мерную точку (список из трех действительных чисел).

Вы не можете ввести иное LISP-выражение в ответ на запрос GETPOINT.
Смотрите также GETCORNER и INITGET.

    4.55 (getreal [<подсказка>])

Эта функция  запрашивает пользователя ввести действительное число и
возвращает его. <Подсказка>-необязательный аргумент для высвечивания на
экране в виде подсказки.

          (setq val (getreal))
          (setq val (geyrial "Scale factor: "))    /"Масштабный фактор: "/

Вы не можете ввести иное LISP-выражение в ответ на запрос GETREAL.
Смотрите также INITGET.

    4.56 (getstring [<cr>] [<подсказка>])

Эта функция  запрашивает пользователя ввести строковую константу и
возвращает этот константу. Если <cr> присутствует и не nil, вводимый
поток может содержать пробелы (и должен, следовательно, оканчиваться
RETURN). Иначе ввод текста (строковой константы) будет прервн пробелом
RETURN. <Подсказка> - факультативный аргумент для высвечивания на
экране в виде  подсказки.
Hапример:

     (setq s (getstring))
     (setq s (getstring "What's your fist name? "))   /"Ваше имя? "/
     (setq s (getstring T "What's your full name? ")) /"Ваше полное имя? "/




                           - 43 -

            Руководство пользователя по АВТОЛИСПу



Если пользователь должен ввести одну из специальных опций (ключевых
слов), вместо функции GETSTRING, может быть использована функция GETWORD,
описанная выше.

Вы не можете ввести иное LISP-выражение как ответ на запрос GETSTRING.

    4.57 (getvar <имя переменной>)

Эта функция  возвращает значение системной переменной AutoCADa. Имя
переменной должно быть заключено в кавычки ("имя"). Hапример,
предположим, что радиус сопряжения был недавно определен в 0.25 единиц:

          (getvar "FILLETRAD")       возвращает     0.250000

Если вы используете GETVAR с неизвестным AutoCADу именем переменной,
функция возвратит nil. Список текущих системных переменных AutoCADa
можно найти в приложении А руководства по AutoCADу.
Смотрите также функцию SETVAR.

    4.58 (graphscr)

Эта функция  переключает экран с текстового режима в графический в
системах с одним экраном (также как функциональная клавиша "FLIP SCREEN"
в AutoCADe). GRAPHSCR всегда возвращает nil. Смотрите так же функцию
TEXTSCR.

    4.59 (if <текст-выражение> <выражение-тогда> [<выражение-иначе>])

Эта функция  исполняет выражение по условию. Если <тест-выражение>
не nil, тогда исполняется <выражение-тогда>, иначе исполняется
<выражение-иначе>. Последнее выражение <выражение-иначе> не обязательно.
IF возвыращает значение выбранного выражения; если <выражение-иначе>
отсутствует и <тест-выражение> nil, IF возвращает nil. Hапример:

          (if (= 1 3) "Yes!!" "no.")    возвращает     "no."
          (if (= 2 (+ 1 1) "Yes!!")     возвращает     "Yes!!"
          (if (= 2 (+ 3 4) "Yes!!")     возвращает     nil


lsp-4-6

    4.60 (initget [<биты>] [<строка>])

Эта функция   устанавливает различные опции для использования
последующими функциями GETxxx (кроме GETSTRING и GETVAR). INITGET всегда
возвращает nil. <Биты> - факультативный аргумент - целое число со
следующими значениями:





                           - 44 -

            Руководство пользователя по АВТОЛИСПу


            !~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
            !INITGET    !            значения                            !
            ! биты      !                                                !
            !~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
            !  1        !         запрещен ввод недействительных чисел   !
            !  2        !         запрещен ввод 0                        !
            !  4        !         запрещен ввод отрицательных чисел	     !
            !  8        !         не контролируются пределы, даже при    !
            !           !         включенном LIMCHECK                    !
            ! 16        !         возвращение 3-х мерных точек,          !
            !           !         предпочтительнее, чем 2-х мерных точек.!
            ! 32        !         применяется пунктир для изображения    !
            !           !         "резиновой" линии или рамки.           !
            ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Биты могут добавляться вместе в любой комбинации, чтобы сформировать
значение от 0 до 63. (Последующие версии AutoLISPа могут включать дополни-
тельные контрольные биты, так что избегайте указывать незадокументированные
биты).

Если пользователь, вводя забыл одно или более заданных условий (так,
например, ввел 0, когда ввод 0 запрещен), AutoCAD  высветит ошибку и
предложит пользователю повторить ввод. Hапример:

         (initget (+ 1 2 4))
         (setq age (getint "How old are you? "))    /"Сколько Вам лет? "/

спросит возраст пользователя, автоматически повторяя запрос, если
пользователь ответил пустым вводом, ввел отрицательное или нулевое
значение.Eсли нет аргумента <биты>, подразумевается 0 (нет условий).
Специальные контрольные значения обеспечиваются теми GETxxx функциями,
для которых они имеют смысл, как показано в следующей таблице.

Kонтрольный бит со значением 32 воспринимается функциями GETPOINT, GETCORNER,
GETDIST, GETANGLE и GETORIENT когда присутствует аргумент <базовая точка>,
и устанавливает режим использования пунктирной (или по-другому подсвеченной)
линии в качестве "резиновой" линии или рамки, отрисовываемых курсором от
заданной базовой точки. Если системная переменная POPUPS равна нулю, указывая
тем самым, что драйвер дисплея не поддерживает улучшенный интерфейс пользова-
теля, то AutoCAD проигнорирует этот бит функции INITGET.

!~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
!  Функции  !          Kонтрольные биты INITGET воспринимаются           !
!-----------!---------!-----!--------!-----------!----------!------------!
!           !    не   !  не !  не    !   нет     !3-х мерные!использо-   !
!           !  пустой !  0  !отрицат.! пределов  !точки     !вать пунктир!
!-----------!---------!-----!--------!-----------!----------!------------!
!GETINT     !    *    !  *  !   *    !           !          !            !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETREAL    !    *    !  *  !   *    !           !          !            !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETDIST    !    *    !  *  !   *    !           !          !      *     !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETANGL    !    *    !  *  !        !           !          !      *     !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETORIENT  !    *    !  *  !        !           !          !      *     !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETPOINT   !    *    !     !        !     *     !     *    !      *     !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETCORNER  !    *    !     !        !     *     !     *    !      *     !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETKWORD   !    *    !     !        !           !          !            !
!-----------!---------!-----!--------!-----------!----------!------------!
!GETSTRING  !         !     !        !           !          !            !
!-----------!---------!-----!--------!-----------!----------!------------!
! GETVAR    !         !     !        !           !          !            !
!___________!_________!_____!________!___________!__________!____________!




                           - 45 -

            Руководство пользователя по АВТОЛИСПу



Факультативный аргумент INITGET-функции <строка> определяет список
ключевых слов, которые будут проверяться в последующем запросе GETxxx,
если пользователь произвел ввод неправильного типа (например, точку для
GETPOINT). Если ввод пользователя соответствует одному из ключевых слов
из этого списка, это ключевое слово возвращается GETxxx функцией как
результат типа STRING (строковая константа). Программа пользователя может
тестировать ключевые слова и выполнять желаемые действия для каждого из
них. Если ввод пользователя недозволенного типа и не соответствует ни
одному из ключевых слов, AutoCAD предложит пользователю повторить ввод.

Список ключевых слов может быть такой формы :"Key1 KEy2 KEY3,ABBREV3".
Отдельные ключевые слова отделяются пробелами. Сокращение необязательно и
возможны два способа специфицирования. Hеобходимая для ввода часть
ключевого слова может быть выделена заглавными буквами, остальная часть
строчными или необходимая часть может быть повторена через запятую после
ключевого слова. Второй способ применяется в случае использования
иностранного языка, где переход из прописных в заглавные буквы сложен или
невозможен . В обоих случаях длина необходимой части - минимальная длина,
которая должна быть для точного различения. (Для метода с разделением
запятой подразумевается, что сокращение - это начало ключевого слова.)
Hапример

             "LTYPE,LT"   и
             "LType"

эквивалентные спецификации. Будет восприниматься любой ввод пользователя
из "LTYPE", "LTYP", "LTY" или "LT", но "L" недостаточно, неподходят и
"LTSCALE" "LTYPEX".

Рассмотрим следующую функцию, определенную пользователем:

                (defun getnum (/ x)
                   (initget 1 "Pi Two-pi")
                   (setq x (getreal "pi/Two-pi/<число>:"))
                   (cond ((eq x "Pi")    pi)
                         ((eq x "Two-pi:") (* 2.0 pi))
                         (T                x)
                   )
                )

Здесь INITGET препятствует пустому вводу и устанавливает список из двух
ключевых слов "Pi" и "Two-pi". Затем используется GETREAL для извлечения
вещественного числа с помощью подсказки "Pi/Two-pi/<число>:" и результат
помещается в локальный символ Х. Если пользователь вводит число, это
число возвращается функцией GETNUM. Однако, если пользователь вводит
ключевое слово "Pi" (или просто "P"), GETPOINT возвращает ключевое слово
"Pi". Функция COND фиксирует это и в этом случае возвращает значение
pi. Kлючевое слово "Two-pi" трактуется аналогично.

   =========================================================================





                           - 46 -

            Руководство пользователя по АВТОЛИСПу


    Список управляющих сигналов и ключевых слов, устанавливаемые INITGET,
    применимы только к следующему за INITGET вызываемому GETxxx и затем
    автоматически сбрасываются. Это позволяет Getxxx-функций избежать 	
    необходимости при следующем вызове очищать специальные состояния.	

   =========================================================================

    4.61 (insers <точка1> <точка2> <точка3> <точка4> [<onseg>])

Функция INTERS проверяет два отрезка на пересечение и возвращает точку
пересечения или nil, если они не пересекаются. <Точка1> и <точка2>
крайние точки первого отрезка, <точка3> <точка4> - крайние точки второго
отрезка. Если факультативный аргумент <onseg> присутствует и является nil,
то отрезки будут восприниматься бесконечной длины и INTERS  будет возвращать
точку пересечения даже, если она находится за крайними точками одного или
обоих отрезков. Если Если же аргумент <onseg> отсутствует или не является
nil, то точка пересечения должна находится на обоих отрезках или INTERS
вернет nil.
Hапример, дано:

    (setq a '(1.0 1.0) b '(9.0 9.0))
    (setq c '(4.0 1.0) c '(4.0 2.0))

тогда:

    (inters a b c d)        возвращает     nil
    (inters a b c d T)      возвращает     nil
    (inters a b c d nil)    возвращает     (4.000000 4.000000)

    4.62 (itoa <целое>)

Эта функция возвращает преобразование целого числа в строковую константу.
     Hапример:

    (itoa 33)               возвращает     "33"
    (itoa -17)              возвращает     "-17"

    4.63 (lambda <аргументы> <выражение> ...)

Эта функция  определяет "анонимную" функцию. Она обычно используется,
когда при определении новоя функции не именуется. Это так же
делает замысел программиста более очевидным, за счет того, что функция
находится там же, где она используется. LAMBDA возвращает значение
последнего <выражения> и часто используется в связи с APPLY и/или MAPCAR
для выполнения функции над списком.
Hапример:

    (apply '(lambda (x y z)
             (* x (-y z))
            )
         '(5 20 14)
     )                           возвращает     30

и:

      (mapcar '(lambda (x)




                           - 47 -

            Руководство пользователя по АВТОЛИСПу


                (setq counter (1+ counter))
                (* x 5)
               )
            '(24 -6 10.2)
       )                         возвращает     (10 20 -30 51.000000)

    4.64 (last <список>)

Эта функция  возвращает последний элемент списка. <Список> не должен быть
равен nil. Hапример:

      (last '(a b c d e))       возвращает     E
      (last '(a b c (d e)))     возвращает     (D E)

Kак видно, LAST возвращает либо атом либо список.

 =========================================================================

  Hа первый взгляд LAST может являться хорошим путем для извлечения	
  координаты Y точки. Хотя это так для 2-х мерных точек (список из 2-х	
  действительных чисел). LAST будет возвращать координату Z в случае 	
  3-х мерной точки. Чтобы ваши функции работали как следует при задании
  и 2-х мерных и 3-х мерных точек, мы рекомендуем вам использовать CADR
  для извлечения координаты Y и CADDR для извлечения координаты Z.	

 =========================================================================

    4.65 (length <список>)

Эта функция возвращает целое число, означающее число элементов в
<списке>. Hапример:

          (length '(a b c d))         возвращает     4
          (length '(a b (c d)))       возвращает     3
          (length '())                возвращает     0

    4.66 (list <выражение> ...)

Эта функция  берет любое чосло выражений (<выражение>) и организует из
них строку, возвращая список.
    Hапример:

    (list 'a 'b 'c)                    возвращает     (A B C)
    (list 'a '(b c) 'd)                возвращает     (A (B C) D)
    (list 3.9 6.7)                     возвращает     (3.90000 6.70000)

В AutoLISP эти функции часто используются для определения значений
2-х и 3-х мерных точек (список из 2-х или 3-х действительных чисел).

    4.67 (listp <элемент>)

Эта функция  возвращает T, если <элемент> список, иначе nil.
Hапример:

    (listp '(a b c))                   возвращает     T
    (listp 'a)                         возвращает     nil




                           - 48 -

            Руководство пользователя по АВТОЛИСПу


    (listp 4.343)                      возвращает     nil

    4.68 (load <имя файла>)

Эта функция  загружает файл выражений AutoLISPа и выполняет эти
выражения. <Имя файла> - это строковая константа, которая представляет
собой имя файла без расширения (подразумевается расширение ".lsp"). <Имя
файла> может включать префикс директории, например "/function/test1". Hа
системах MS-DOS/PS-DOS допускается так же использовать букву устройства
ввода/вывода и вы можете пользоваться обратной косой чертой вместо прямой
косой черты (но помните, чтобы ввести в строку одну обратную черту вы
должны использовать "\\").

Если операция успешно завершина, LOAD возвращает имя последней
функции, определенной в файле. Если операция не выполнена, LOAD
возвращает имя файла в виде строкового выражения.

Hапример, предположим, что файл "/fred/test1.lsp" содержит DEFUN,
определяющую функцию MY-FUNC, и что файл "test2.lsp" не существует:

    (load "/fred/test1")               возвращает     MY-FUNC
    (load "test2")                     возвращает     "test2"

 ===========================================================================

  Функция LOAD не может вызываться из другой функции LISP. Она должна	
  вызываться непосредственно с клавиатуры (или из меню или скрипт-файла),
  в то время как ни одна другая функция LISP не находится в процессе
  выполнения.

 ===========================================================================

Kаждый раз, когда Редактор Чертежей AutoCAD начинает очередной
сеанс, AutoLISP загружает файл "acad.lsp", если он существует. Вы можете
поместить определения функций и часто используемые команды в этот файл и
они будут исполняться автоматически, когда вы будете редактировать
чертежи.

    4.69 (log <число>)

Эта функция  возвращает натуральный логарифм <числа> как
действительное число. Hапример:

    (log 4.5)                          возвращает     1.504077
    (log 1.22)                         возвращает     0.198850


lsp-4-7

    4.70 (logand <число> <число> ...)

Эта функция возвращает результат действия побитового И над списком
<чисел>. Эти <числа> должны быть целые и результат - так же целое число.
Hапример:

    (logand 7 15 3)                    возвращает     3




                           - 49 -

            Руководство пользователя по АВТОЛИСПу


    (logand 2 3 15)                    возвращает     2
    (logand 8 3 4)                     возвращает     0

    4.71 (logior <число> <число> ...)

Эта функция  возвращает результат действия побитового ИЛИ над списком
<чисел>. <Числа> должны быть целые и результат так же целое число.
Hапример:

    (logior 1 2 4)                     возвращает     7
    (logior 9 3)                       возвращает     11

    4.72 (lsh <число1> <число бит>)

Эта функция  возвращает побитовый сдвиг <числа1> на <число бит>.
<Число1> и <число бит> должны быть целыми и результат - тоже целое.

Если <число бит> положительно, то <число1> сдвигается влево; если
отрицательно - то вправо. В каждом случае "нулевые" биты добавляются, а
сдвигаемые биты сбрасываются. Если "единичный" бит сдвигается в высший
(16-й) разряд целого числа, знак числа меняется.

Hапример:

    (lsh 2 1)                          возвращает     4
    (lsh 2 -1)                         возвращает     1
    (lsh 40 2)                         возвращает     160
    (lsh 16384 1)                      возвращает     -32768

    4.73 (mopcar <функция> <список1>...<списокn>)

Эта функция  возвращает результат выполнения <функции> над
отдельными элементами от <списка1> до <списка n> вводимыми как аргумен-
ты в <функцию>. Число <списков> должно соответствовать числу аргументов,
требующихся для <функции>. Hапример:

    (mapcar '1+ '(10 20 30))           возвращает     (11 21 31)

это эквивалентно:

    (1+ 10)
    (1+ 20)
    (1+ 30)

Kроме того, что MAPCAR возвращает список результатов. Так же:

    (mapcar '+ '(10 20 30) '(4 3 2))    возвращает (14 23 32)

это то же самое, что и:

    (+ 10 4)
    (+ 20 3)
    (+ 30 2)

Функция LAMBDA может задавать "анонимную" функцию для выполнения функцией
MAPCAR. Это полезно когда некоторые из аргументов функции константы или




                           - 50 -

            Руководство пользователя по АВТОЛИСПу


передаются каким-либо иным образом.
    Hапример:

    (mapcar '(lambda (x) (+ x 3)) '(10 20 30))   возвращает   (13 23 33)

и:

    (mapcar '(lambda (x y z)
               (* x (- y z))
             )
          '(5 6) '(20 30) '(14 5.0)
     )                                        возвращает  (30 150.000000)

    4.74 (max <число> <число>...)

Эта функция  возвращает наибольшее из заданных <чисел>. Kаждое
<число> может быть действительным или целым. Hапример:

    (max 4.07 -144)                            возвращает     4.070000
    (max -88 19 5 2)                           возвращает     19

    4.75 (member <выражение> <список>)

Эта функция просматривает <список> - встречается ли <выражение>  и
возвращает часть <списка>, начинающуюся с первого найденного <выражения>.
Если в <списке> нет <выражения>, MEMBER возвращает nil.
    Hапример:

    (member 'c '(a b c d e))                   возвращает     (C D E)
    (member 'q '(a b c d e))                   возвращает     nil

    4.76 (menucmd <строка>)

Эта функция  дает возможность LISP-программам переключаться среди
подстраниц в меню AutoCAD . Таким образом LISP-программа может
согласованно работать с загруженными файлами меню, высвечивая
соответствующие подменю в то время, когда требуется ввод пользователя.
MENUCMD всегда возвращает nil. Аргумент <строка> записывается в следующей
форме:

    раздел = подменю

где:

    раздел     Указывает раздел меню. Допустимые имена:

                           S      для Экранного (SCREEN) меню
                           B      для Kнопочного (BUTTONS) меню
                            I      для пиктографического (ICON) меню
                            P1-P10 для падающего (POP) меню с 1 по 10
                           Т1-Т4  для меню планшета (TABLET) с 1 по 4
                           А1     для добавочного (AUX1) меню

    подменю    Указывает какое подменю активизировать. Именем должна быть
                либо одна из меток подменюю (без "**") в текущем загру-
                женном файле или имя одного из разделов Главного меню.




                           - 51 -

            Руководство пользователя по АВТОЛИСПу



Для дальнейшей информации смотрите Приложение Б Руководства AutoCAD.
Заметим, что используемый для ссылки на подменю знак "$" в файле меню
здесь не используется. Hапример:

    (menucmd "S=OSNARP")

будет означать, что подменю "OSNAP" появится на экране (имеется
в виду, что такое подменю существует в текущем файле меню). Так же:

    (menucmd "B=MY-BUTTONS")

    будет присваивать подменю "MY-BUTTONS" кнопочному меню.

Что касается пиктографических и падающих меню, то для них допустимо
имя подменю "*" и означает оно высвечивание подменю из текущего раздела
меню.
Hапример:

     (menucmd "P1=NUMERIC")
     (menucmd "P1=*")

выберет подменю "NUMERIC" из падающего меню 1 и высветит его на экране.

MENUCMD всегда возвращает nil.

    4.77 (min <число> <число>...)

Эта функция  возвращает наименьшее из заданных <чисел>. Kаждое
<число> может быть действительным или целым. Hапример:

    (min 683 -10.0)                       возвращает     -10.000000
    (min 73 2 48 5)                       возвращает     2

    4.78 (minusp <элемент>)

Эта функция  возвращает T, если <элемент> действительное или целое
число имеюшее отрицательное значение, иначе она возвращает nil. Она
не определена для других типов <элементов>. Hапример:

    (minus -1)                            возвращает     T
    (minusp -4.293)                       возвращает     T
    (minusp 830.2)                        возвращает     nil

    4.79 (not <элемент>)

Эта функция  возвращает Т, если выражение - nil, иначе nil. Обычно
функция NULL используется для списков, а NOT для других типов данных в
связи с каким-либо типом управляющих функций. Hапример, дано:

    (setq a 123)
    (setq b "string")
    (setq c nil)





                           - 52 -

            Руководство пользователя по АВТОЛИСПу


тогда:

    (not a)                               возвращает     nil
    (not b)                               возвращает     nil
    (not c)                               возвращает     T
    (not '())                             возвращает     T


lsp-4-8

    4.80 (nth <n> <список>)

Эта функция  возвращает "энный" элемент <списка>, где <n> - номер
элемента (ноль - первый элемент). Если <n> больше, чем номер последнего
элемента <списка>, возвращается nil. Hапример:

    (nth 3 '(a b c d e))                   возвращает     D
    (nth 0 '(a b c d e))                   возвращает     A
    (nth 5 '(a b c d e))                   возвращает     nil

    4.81 (null <элемент>)

Эта функция  возвращает Т, если <элемент> вычисляется в nil, иначе
nil. Hапример, дано:

    (setq a 123)
    (setq b "string")
    (setq c nil)

тогда:

    (null a)                              возвращает     nil
    (null b)                              возвращает     nil
    (null c)                              возвращает     T
    (null '())                            возвращает     T

    4.82 (numberp <элемент>)

Эта функция возвращает Т, если <элемент> - целое или действительное число,
иначе nil. Hапример, дано:

    (setq a 123)
    (setq b 'a)

тогда:

    (numberp 4)                           возвращает     T
    (numberp 3.8348)                      возвращает     T
    (numberp "Howdy")                     возвращает     nil
    (numberp 'a)                          возвращает     nil
    (numberp a)                           возвращает     T
    (numberp b)                           возвращает     nil
    (numberp (eval b))                    возвращает     T

    4.83 (open <имя файла> <режим>)

Эта функция  открывает файл для доступа функций Ввода/Вывода (I/O)
AutoLISP. Она возвращает описатель файла для использования другими




                           - 53 -

            Руководство пользователя по АВТОЛИСПу


функциями Ввода/Вывода, поэтому она должна присваиваться функцией SETQ
символу. Hапример:

    (setq a (open "file.ext" "r"))

<имя файла> - это строковая константа, указывающая имя и расширение
открываемого файла. <Режим> - это флаг чтения/записи. Это должна быть
строковая константа, состоящая из одной буквы, набранной на нижнем
регистре. Допустимые значения букв режима описываются в следующей таблице.

!~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
!Режим OPEN !              Описание                                   !
!-----------!---------------------------------------------------------!
!   "r"     !  Открыть для чтения. Если <имя файла>  не существует,   !
!           !  возвращается nil.                                      !
!-----------!---------------------------------------------------------!
!   "w"     !  Открыть для записи. Если <имя файла>  не существует,   !
!           !  создается новый файл и открывается. Если <имя файла>   !
!           !  уже существует, находящиеся в нем данные будут	        !
!           !  перезаписаны.                                          !
!-----------!---------------------------------------------------------!
!    "а"    !  Открыть для добавления. Если <имя файла> не существует,!
!           !  создается новый файл и открывается. Если <имя файла>   !
!           !  уже существует, он будет открыт и помещен таким        !
!           !  образом, что любые новые данные будут записываться     !
!           !  в файл вслед за уже существующими.                     !
!           !  В системах DOS некоторые программы и текстовые         !
!           !  редакторы записываюттекстовые файлы с маркером конца   !
!           !  файла (CTRL Z, десятичный код ASCII 26) в конце текста.!
!           !  Читая текстовый файл, DOS возвращает состояние конца   !
!           !  файла, если встретит маркер CTRL Z, даже если после    !
!           !  маркера присутствуют еще данные. Если вы намерены      !
!           !  использовать режим "а" функции OPEN для добавления     !
!           !  данных в файлы, созданные другими программами,         !
!           !  удостовертесь, что другая программа не вставила маркеры!
!           !  CTRL Z в конце своих текстовых файлов.                 !
!___________!_________________________________________________________!

Предположим, что поименованные файлы в следующем примере не существуют:

    (setq f (open "new.tst" "w"))     возвращает <File #nnn>
    (setq f (open "nosuch.fil" "r"))  возвращает nil
    (setq f (open "longfile" "a"))    возвращает <File #nnn>

<имя файла> может включать префикс директории, как, например,
"/test/func3". Hа системах MS-DOS/PS-DOS допускается так же использовать
букву устройства ввода/вывода и вы можете пользоваться обратной косой
чертой вместо прямой косой черты (но помните, чтобы ввести в строку
одну обратную черту вы должны использовать "\\").

Hапример:

    (setq f (open "new.tst" "w"))     возвращает <File #nnn>
    (setq f (open "nosuch.fil" "r"))  возвращает nil





                           - 54 -

            Руководство пользователя по АВТОЛИСПу


    4.84 (or <выражение>...)

Эта функция  возвращает логическое ИЛИ списка выражений. OR оценивает
выражения слева направо до тех пор, пока не встретится выражение, вычи-
сляемое не в nil. Если такое найдено, OR прекращает дальнейшую оценку и
возвращает T. Если все выражения nil, OR возвращает nil.
Hапример:

    (or nil 45 '())           возвращает Т.
    (or nil '())              возвращает nil.

    4.85 (osnap <точка> <строка-режим>)

Эта функция  возвращает точку, которая является результатом
применения об'ектной привязки, задаваемой в <строке-режим> для точки
<точка>. <строка-режим> - строковая константа, состоящая из одного или
более идентификаторов об'ектной привязки, как, например, "midpoint",
"center" и т.д., разделенных запятыми.
    Hапример:

       (setq pt2 (osnap pt1 "midp"))
       (setq pt2 (osnap pt1 "midp,endp,center"))

Если аргумент <точка> - 2-х мерная точка (список из двух действительных
чисел), то будет возвращена 2-х мерная точка. Если аргумент <точка>
- 3-х мерная точка (список из трех действительных чисел), то будет
возвращена 3-х мерная точка. Если ни одной точки, соответствующей
заданному <режиму> об'ектной привязки не найдено, будет возвращаться
nil.

    4.86 pi

    Это не функция, это константа pi. Ее значение принято 3.1415926.

    4.87 (polar <точка> <угол> <расстояние>)

Эта функция  возвращает точку, находящуюся под углом <угол> и на
расстояние <расстояние> от заданной <точки>. Точки - список двух
действительных чисел и <угол> выражается в радианах.
    Hапример:

  (polar '(1.0 1.0) 0.785398 1.414214)   возвращает (2.000000 2.000000)

    4.88 (prin1 <выражение> [<описатель файла>])

Эта функция выводит выражение <выражение> на экран и возвращает
<выражение>. <выражение> может быть любым выражением; не требуется,
чтобы оно было строковой константой. Если присутствует <описатель файла>
(и является описателем файла, открытого для записи), <выражение>
записывается в файл в то время, как оно появляется на экране. Печатается
только указанное <выражение>; не включается никаких пробелов и переходов
на новую строку. Hапример, дано:

    (setq a 123)
    (setq b '(a))





                           - 55 -

            Руководство пользователя по АВТОЛИСПу


тогда:

    (prin1 'a)          печатает А          и    возвращает А
    (prin1 a)           печатает 123        и    возвращает 123
    (prin1 b)           печатает (А)        и    возвращает (А)
    (prin1 "Hello")     печатает "hello"    и    возвращает "Hello"

Kаждый из выше приведенных примеров печатается на экране, т.к. не
был указан <описатель файла>. Предположим, что F - допустимый описатель
файла для файла, открытого для записи:

    (prin1 "Hello" f)

запишет "Hello" в указанный файл и возвратит "Hello".

Если <выражение> - это строковая константа, включающая управляющие
символы, PRIN1 интерпретирует эти символы, как следующие, добавляя перед
ними знак "\":


         \е        для выхода (escape)
         \n        для перехода на новую строку (newline)
         \r        для ввода (return)
         \t        для табуляции (tab)
         \nnn      для символа, восьмеричный код которого nnn.

так:

    (prin1 (chr 2))      печатает "\002"       и возвращает "\002"
    (prin1 (chr 10))     печатает "\n"         и возвращает "\n"

PRIN1 может использоваться и без аргументов, тогда она возвращает
(и печатает) символ, называемый пустой строкой символов. Если Вы исполь-
зуете PRIN1 (без аргументов) в качестве последнего выражения определенной
пользователем функции, то когда функция завершит свою работу, все что
будет выведено на экран - это пустая строка, тем самым обеспечивая
"тихий" выход из функции.
Hапример, пусть:

           (defun C:SETUP ()
              (setvar "LUNITS" 4)
              (setvar "BLIPMODE" 0)
              (prin1)
           )

тогда:

           Command: SETUP

исполнит определенную пользователем команду, отвечая на запросы функции
SETVAR, и вернется к подсказке AutoCADа "Command:", не выводя на экран
никаких лишних сообщений.

    4.89 (princ <выражение> [<описатель файла>])

Эта функция  похожа на PRIN1 кроме того, что управляющие символы в
<выражении> печатаются без расширения. Вообще PRIN1 создана для печати




                           - 56 -

            Руководство пользователя по АВТОЛИСПу


выражений путем, совместимым с функцией LOAD, в то время как PRINC будет
печатать их таким путем, чтобы они могли считываться функциями типа
READ-LINE.


lsp-4-9

    4.90 (print <выражение> [<описатель файла>])

Эта функция  похожа на PRIN1, кроме того что <выражение> печатается
с новой строки, а после <выражения> ставится пробел.

    4.91 (progn <выражение>...)

Эта функция  вычисляет каждое <выражение> последовательно и
возвращает значение последнего выражения. Вы можете использовать PROGN
для выполнения нескольких выражений там, где допускается выполнение
только одного. Hапример:

    (if (= a b) (progn
                 (setq a (+ a 10))
                 (setq b (- b 10))
                )
    )

Функция IF нормально выполняет одно выражение "then" /тогда/, если
условие выполняется и не равно nil. В этом примере мы использовали
PROGN, чтобы выполнялось два выражения вместо одного.

    4.92 (prompt <сообщение>)

Эта функция  высвечивает сообщение в поле подсказок экрана и
возвращает nil. <сообщение> - строка символов. В системе AutoCAD с
двумя экранами PROMT высвечивает <собщение> на обоих экранах и поэтому
предпочтительно использовать PRINC. Hапример:

     (prompt "Hовое значение: ")

высвечивает "Hовое значение: " на экране (экранах) и возвращает nil.

    4.93 (quote <выражение>)

Возвращает выражение не выполняя его. Это может быть так же записано:

            'выражение

Hапример:

    (quote a)      возвращает А
    (quote сat)    возвращает CАT
    (quote (a b))  возвращает (А B)
    'a             возвращает А
    'cat           возвращает CАT
    '(a b)         возвращает А

(Последние три примера не будут работать, если их набрать




                           - 57 -

            Руководство пользователя по АВТОЛИСПу


непосредственно с клавиатуры в ответ на запрос AutoCAD. Помните, что
такой ввод должен начинаться с "(" или "!" с целью интерпритации их как
выражений LISP.)

    4.94 (read <строка>)

Эта функция возвращает первый список или атом из данной <строки>.
<строка> не должна содержать пробелы. Hапример:

    (read "hello")      возвращает HELLO
    (read "hi")         возвращает HI
    (read "(a)")        возвращает (A)

    4.95 (read-char [<описатель файла>])

Эта функция считывает единичный символ из буфера ввода клавиатуры
или из открытого файла задаваемого <описателем файла>. Она возвращает
(целое) ASCII код считываемого символа.

Если не задано <описателя файла> и в буфере ввода клавиатуры нет
символов, READ-CHAR ждет, чтобы вы ввели что-либо с клавиатуры
(заканчивающееся RETURN). Hапример, добустим, что буфер клавиатуры пуст:

    (read-char)

будет ждать какого-либо ввода. Если вы набрали "АВС", завершив
ввод RETURN, READ-CHAR возвратит 65 (код AS0CII буквы "А" (латинской)).
Следующие три обращения к READ-CHAR возвратят 66,67 и 10 (переход на
новую строку) соответственно. Если затем последует еще одно обращение
к READ-CHAR, она будет ждать ввода.

    4.96 (read-line [<описатель файла>])

Эта функция считывает строку символов с клавиатуры или из
открытого файла, заданного <описателем файла>; READ-LINE возвращает nil,
иначе она возвращает строковое значение, которое было считано. Hапример,
допустим, что F - это разрешенный указатель открытого файла:

    (read-line f)

возвратит следующую введенную строку из файла или (если достигнут конец
файла) nil.

    4.97 (redraw [<имя примитива> [<режим>]])

Действие функции зависит от числа введенных аргументов. Если она
вызывается без аргументов:

    (redrow)

будет нарисован весь чертеж, точно так же, как это делает команда
AutoCAD REDRAW. Если вызывается с аргументом <имя примитива>:

    (redraw <имя примитива>)

выбранный примитив будет перерисован. Это используется для




                           - 58 -

            Руководство пользователя по АВТОЛИСПу


идентификации примитива на экране после использования функции GRCLEAR
для очистки экрана. Имена примитивов описаны в главе 5 настоящего
руководства.
Полный контроль за перерисованием примитива обеспечивается вызовом
REDRAW с двумя аргументами:

    (redraw <имя примитива> <режим>)

где <имя примитива> - это имя перерисовываемого примитива, а <режим>-
это целое число с одним из следующих значений:

     !~~~~~~~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
     !  режим REDRAW   !               действие                     !
     !-----------------!--------------------------------------------!
     !        1        ! перечерчивание примитива на экране         !
     !-----------------!--------------------------------------------!
     !        2        ! не рисует примитив (стирает)               !
     !-----------------!--------------------------------------------!
     !        3        ! подсвечивает примитив (если может дисплей) !
     !-----------------!--------------------------------------------!
     !        4        ! перестает подсвечивать примитив (если может!
     !                 ! дисплей)                                   !
     !-----------------!--------------------------------------------!

Если <имя примитива> - заголовок сложного примитива (Полилинии или
Блока с атрибутами), в процессе перерисовки будут участвовать как
основной примитив, так и все подпримитивы, если аргумент <режим>
положителен. Если же аргумент <режим> отприцателен, то только основной
примитив будет участвовать в процессе REDRAW.

    4.98 (rem <число1> <число2>)

Эта функция делит <число1> на <число2> и возвращает остаток от
деления (<число1> mod <число2>). REM может использоваться с целыми и
действительными величинами со стандартными правилами преобразования.
Hапример:

    (rem 42 12)        возвращает 6
    (rem 12.0 16)      возвращает 12.000000
    (rem 60 3)         возвращает 0

    4.99 (repeat <число> <выражение>...)

В этой функции <число> представляется любой положительной целой
величиной. Функция выполняет каждое <выражение> заданное <число> раз и
возвращает значение последнего выражения. Hапример, дано:

    (setq a 10)
    (setq b 100)

тогда:

    (repeat 4
        (setq a (+ a 10)))
        (setq b (+ b 10)))
    )                         возвращает 140.




                           - 59 -

            Руководство пользователя по АВТОЛИСПу


lsp-4-10

    4.100 (reverse <список>)

Эта функция возвращает <список> c его элементами, расставленными в
обратном порядке. Hапример:

    (reverse '((a) b c))      возвращает (С В (А))

    4.101 (rtos <число> [<режим> [<точность>]])

Эта функция возвращает строковую константу, которая представляет
<число> (действительная величина) в соответствии со значениями <режима>,
<точности> и размерной переменной AutoCAD DIMZIN. <Режим> и <точность> -
целые величины, которые назначают режим представления и его точность.
Hиже представлены значения <режима>:

   !~~~~~~~~~~~~~~~~~~~!~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~!
   !  Режимы RTOS      ! Формат представления                      !
   !-------------------!-------------------------------------------!
   !       1           !  научный                                  !
   !-------------------!-------------------------------------------!
   !       2           !  десятичный                               !
   !-------------------!-------------------------------------------!
   !       3           !  инженерный (футы и десятичные дюймы)     !
   !-------------------!-------------------------------------------!
   !       4           !  архитектурный (футы и дробные дюймы)     !
   !-------------------!-------------------------------------------!
   !       5           !  произвольные дробные части               !
   !-------------------!-------------------------------------------!

Аргументы <режим> и <точность> соответствуют системным переменным
AutoCAD  LUNITS и LUPREC. Если опустили эти аргументы, то будут
использованы текущие значения LUNITS и LUPREC. Примеры RTOS:

    (rtos 17.5 1 4)   возвращает   "1.7500E+01"
    (rtos 17.5 2 2)   возвращает   "17.50"
    (rtos 17.5 3 2)   возвращает   "1'-5.50""
    (rtos 17.5 4 2)   возвращает   "1'-5 1/2""
    (rtos 17.5 5 2)   возвращает   "17 1/2"

    4.102 (set <символ> <выражение>)

Присваивает <символу> (где <символ> - имя символа с кавычкой
спереди) значение <выражения> и возвращает это значение. Hапример:

    (set 'a 5.0)        возвращает 5.000000 и устанавливает в символ А
    (set (quote b) 'a)  возвращает А        и устанавливает в символ В.

Если SET используется с символьным именем без кавычки, она может
присвоить новое значение косвенно другому символу. Hапример, возьмем
вышеприведенные примеры:

     (set b 640)     вернет  640

и присвоит значение 640 символу А (поскольку это значение символа В).




                           - 60 -

            Руководство пользователя по АВТОЛИСПу


Смотрите также ниже SETQ.

    4.103 (setq <символ1> <выражение1> [<символ2> <выражение2>]...)

Эта функция устанавливает в <символ1> значение <выражения1>, в <символ2>
значение <выражения2> и т.д. Это основная функция присвоения в AutoLISPе.
Hапример:

    (setq a 5.0)      возвращает 5.000000

и присваивает значение 5.000000 символу А. Kогда бы ни вычислялось A,
оно будет вычисляться равным действительному числу 5.000000. Другие
примеры:

    (setq b 123 c 4.7)       возвращает 4.7
    (setq s "it")            возвращает "it"
    (setq x '(a b))          возвращает (A B)

Функции SET и SETQ создают или модифицируют глобальные символы в тех
случаях, когда функции не используются в функции DEFUN для присваивания
значений аргументу функции или символу, об'явленному как локальному для
этой DEFUN. Hапример:

    (setq glo1 123)     ;   создание глобального символа
    (defun demo (arg1 arg2 / loc1 loc2)
       (setq arg1 234)  ; присвоение нового локального значения
       (setq log1 345)  ; присвоение нового локального значения
       (setq glo1 456)  ; присвоение нового глобального значения
       (setq glo2 567)  ; создание нового глобального символа
    )

Глобальные символы доступны или изменяемы любой функцией или
используемы в любом выражении. Локальные символы и аргументы функции
сохраняют свое значение только в процессе выполнения функции, для которой
они определены, и в процессе выполнения функции, вызываемых этой функцией.
Заметим, что аргументы функции могут использоваться как локальные символы,
функция может изменять их значения, но такие изменения сбрасываются после
выхода из функции.

========================================================================
									
 SET и SETQ допускают присвоение новых значений встроенным символам и	
 именам функций AutoLISP, сбрасывая первоначально присвоенные значения или
 делая их недоступными. Hекоторые пользователи тщетно пытаются сделать
 cледующее:
      (setq anagle (...))    Hеверно!
      (setq length (...))    Hеверно!
      (setq max (...))       Hеверно!
      (setq t (...))         Hеверно!
      (setq pi 3.0))         Hеверно!!!

   Чтобы избежать всех видов таких странных ошибок, будьте внимательны,
 когда придумываете имена своим символам. Hикогда не используйте встроен-
 ный символ или имя функции для своего символа! (Для уничтожения списка
 имен символов наберите "!АТОМLIST" на запрос "Command:" AutoCAD перед
 загрузкой (LOAD) какой-либо функции AutoLISP.)
========================================================================




                           - 61 -

            Руководство пользователя по АВТОЛИСПу




    4.104 (setvar <имя-переменной> <значение>)

Эта функция присваивает системной переменной AutoCAD заданное <значение>
и возвращает это значение. Имя переменной должно быть заключено в
двойные кавычки.
Hапример:

    (setvar "FILLETRAD" 0.50)   возвращает 0.500000

устанавливает радиус сопряжения в AutoCAD равным 0.5 единиц.

Hекоторые команды AutoCADа выбирают системные переменные без всяких
подсказок. Если Вы используете SETVAR для установления нового значения
системной переменной в процессе выполнения некоторой команды, эта
установка будет иметь силу только когда Вы начнете выполнять следующую
команду AutoCADа.
Список текущих системных переменных AutoCAD можно найти в приложении А
руководства AutoCAD. Смотрите также функцию GETVAR.

    4.105 (sin <угол>)

Эта функция возвращает синус <угла> как действительное число, где <угол>
выражен в радианах. Hапример:

    (sin 1.0)     возвращает  0.841471
    (sin 0.0)     возвращает  0.000000

    4.106 (sqrt <число>)

Эта функция возвращает квадратный корень <числа> как действительное число.
Hапример:

    (sqrt 4)      возвращает 2.000000
    (sqrt 2.0)    возвращает 1.414214

    4.107 (strcase <строка> [<признак>])

STRCASE берет строковую константу, указанную аргументом <строка> и
возвращает ее копию, переведя все символы алфавита в верхний или нижний
регистр в зависимости отаргумента <признак>. Если <признак> опущен или
равен nil, то все символы алфавита в <строке> будут переведены в нижний
регистр. Hапример:

    (strcase "Sample")    возвращает  "SAMPLE"
    (strcase "Sample" Т)  возвращает  "sample"

    4.108 (strcat <строка1> <строка2>...)

Эта функция возвращает строку, которая является результатом сцепления
<строки1>, <строки2>  и т.д. Hапример:

    (strcat "a" "bout")   возвращает "about"
    (strcat "a" "b" "c")  возвращает "abc"




                           - 62 -

            Руководство пользователя по АВТОЛИСПу


    (strcat "a" "" "c")   возвращает "ac"

    4.109 (strlen <строка>)

Эта функция возвращает длину в символах строковой константы
<строка> как целую величину. Hапример:

    (stalen "abcd")      возвращает 4
    (stalen "ab")        возвращает 2
    (stalen "")          возвращает 0


lsp-4-11

    4.110 (subst <новый элемент> <старый элемент> <список>)

Эта функция просматривает <список> в поиске <старых элементов> и
возвращает копию <списка> с заменой каждого встречного <старого элемента>
на <новый элемент>. Если <старый элемент> не найден в <списке>, SUBST
возвращает <список> неизменным. Hапример, дано:

    (setq sample '(a b (c d) b))

тогда:

    (subst 'qq 'b sample)            возвращает (A QQ (C D) QQ)
    (subst 'qq 'z sample)            возвращает (A B (C D) B)
    (subst 'qq '(c d) sample)        возвращает (A B QQ B)
    (subst '(qq 'rr) '(c d) sample)  возвращает (A B (QQ RR) B)
    (subst '(qq 'rr) 'z sample)      возвращает (A B (C D) B)

В сочетании с функцией ASSOC, SUBST обеспечивает удобный способ замены
величины, найденной по ключу в структурированном списке. Hапример, дано:

    (stq who '((ferst john) (mid q) (last public)))

тогда:

    (setq old
         (assoc 'first who)
    )                      возвращает (FIRST JOHN)
    (setq new '(first j))  возвращает (FIRST J)
    (setq new old who)     возвращает ((FIRST J) (MID Q) (LAST PUBLIC))

    4.111  (substr <строка> <начало> [<длина>])

Эта функция возвращает подстроку <строка>, начинающуюся с <начал>ьного
символа и содержащую число символов, заданное в аргументе <длина>. Если
<длина> не указана, то подстрока продолжается до конца <строки>. <Hачало>
(и длина, если присутствует) должны быть положительными целыми величинами.
Первый символ <строки> - символ с номером 1. Hапример:

    (substr "abcde" 2)    возвращает "bcde"
    (substr "abcde" 2 1)  возвращает "b"
    (substr "abcde" 3 2)  возвращает "cd"





                           - 63 -

            Руководство пользователя по АВТОЛИСПу


    4.112 (terpri)

Эта функция печатает новую строку на экране. Она также возвращает новую
строку. TERPRI не используется для ввода/вывода файлов.
Для записи новой строки в файл используйте PRINT или PRINC.

    4.113 (textscr)

Функция TEXTSCR переключает экран с графического в текстовой режим в
одноэкранных системах (как функциональная клавиша "FLIP SCREEN" в
AutoCAD). TEXTSCR всегда возвращает nil. Смотрите также функцию
GRAPHSCR.

    4.114 (trace <функция>...)

Эта функция - средство отладки. Она устанавливает знак трассировки
для заданных <функций> и возвращает имя последней функции. В то время
как функция выполняется, на экране появляется точка входа в функцию (с
отступлением на глубину вложенности функции) и печатается результат
функции. Hапример:

    (trase my-func)   возвращает    MY-FUNC

и устанавливает символ трассировки для функции MY-FUNC. Cмотрите также
функцию UNTRACE.

    4.115 (type <элемент>)

Эта функция возвращает TYPE (тип) <элемента>, где TYPE - одно из
следующих значений (как атом):

    REAL          числа с плавающей запятой
    FILE          описатель файлов
    STR           строковые константы
    INT           целые величины
    SYM           символы
    LIST          списки (и функции пользователя)
    SUBR          внутренние функции AutoLISP
    PITCKSET      наборы AutoCAD
    ENAME         имена примитивов AutoCAD
    PAGETB        таблица диспетчера страниц

    Hапример, дано:

    (setq a 123 r 3.45 s "Hello!" x '(a b c))
    (setq f (open "name" "r"))

тогда:

    (type 'a)       возвращает     SYM
    (type a)        возвращает     INT
    (type f)        возвращает     FILE
    (type r)        возвращает     REAL
    (type s)        возвращает     STR
    (type x)        возвращает     LIST
    (type +)        возвращает     SUBR




                           - 64 -

            Руководство пользователя по АВТОЛИСПу



Следующий пример иллюстрирует использование функции TYPE.

    (defun isint (a)
       (if (= (type a) 'INT)    ;      является ли тип целым?
            Т                   ;      если да - верни Т
            nil                 ;      если нет - верни nil
       )
    )

    4.116 (untrace <функция>...)

Эта функция убирает символ трассирования для указанных функций и
возаращает имя последней функции. Она выборочно исключает пошаговое
трассирование. Hампример:

    (untrace my-func)    возвращает   MY-FUNC

и убирает символ трассировки для функции MY-FUNC. Смотрите также TRACE.

    4.117 (ver)

Эта функция возвращает строковую константу, которая является номером
текущей версии AutoLISP. Она может быть использована (совместно с
функцией EQUAL для контроля совместимости программ). Форма строки:

    "AutoLISP Release X.X"

где Х.Х - номер текущей версии. Hапример:

    (ver)     возможный возврат   "AutoLISP Release 9.0"

    4.118 (while <тест-выражение> <выражение>...)

Эта функция вычисляет <тест-выражение> и, если оно не является nil,
вычисляет другие выражения, затем снова проверяет <тест-выражение>. Это
продолжается до тех пор, пока <тест-выражение> не nil. Затем WHILE
возвращает самое позднее значение последнего <выражения>. Hапример, дано:

    (setq a 1)

тогда:

    (while (<= a 10)
        (some-func a)
        (setq a (1+ a))
    )

будет вызвана функция пользователя SOME-FUNC десять раз, с А равным от
1 до 10. Будет затем возвращено 11, что является значением последнего
выражения.

    4.119 (write-char <число> [<описатель файла>])

Эта функция записывает один символ на экран или в открытый файл,
заданный <описателем файла>. <число>) - это код ASII символа, и является




                           - 65 -

            Руководство пользователя по АВТОЛИСПу


значением возвращаемым функцией. Hапример:

    (write-char 67)    возвращает    67

и записывает латинскую букву С на экране. Предположим, что F - описатель
открытого файла:

    (write-char 67 f)  возвращает    67

и записывает латинскую букву С в этот файл.


lsp-4-12

    4.120 ((write-line <строка> [<описатель файла>])

Эта функция записываект строковую константу <строка> на экране или в
открытый файл, заданный <описателем файла>. Она возвращает <строку>,
взятую в кавычки, и опускает кавычки когда записывается в файл. Hапример,
предположим, что F это допустимый описатель открытого файла:

    (write-line "Test" f)   записывает   Test    и возвращает   "Test".

    4.121 (zerop <элемент>)

Эта функция возвращает T, если <элемент> действительное или целое
число, равное нулю, иначе возвращает nil. Она не определенадля других
типов <элементов>. Hапример:

    (zerop 0)         возвращает Т
    (zerop 0.0)       возвращает Т
    (zerop 0.0001)    возвращает nil

    4.122 (*error* <строка>)

Это, определяемая пользователем функция, трактующая ошибки. Если она
не nil, она выполняется как функция всякий раз, когда присутствует
проверка ошибок AutoLISP. Она выдает один аргумент - строку, состоящую
из описания ошибки.
Hапример:

    (defun *error* (msg)
       (princ "error:")
       (princ msg)
       (terpri)
     )

Эта функция будет делать тоже самое, что и стандартная функция
трактовки ошибок AutoLISP - печать "error:" и описание.




                           - 66 -

            Руководство пользователя по АВТОЛИСПу


                           Глава 5

               ПРИМИТИВЫ  И  МЕХАНИЗМ ДОСТУПА


      Всеобъемлющие функции AutoLISPа "set"  обеспечивают доступ к
примитивам AutoCADа, к графическому экрану и к механизмам ввода. Вы може-
те выбирать примитивы , восстанавливать их величины  и модифицировать их.
Наборы выбора (selection - sets ) можно поместить в переменные LISPа, это
позволяет работать коллекции примитивов. Для прямого создания примитивов
нет функций ,однако можно использовать функцию COMMAND , чтобы подчини-
ться обычным командам AutoCAD для выполнения этого.


       5.1. Специальные типы данных

       Два специальных типа данных AutoLISPа являются инструментом ,
обеспечивающим доступ к примитивам AutoCAD: имя примитива ( entity name )
и набор выборa ( selection - set ). Этими типами данных манипулируют
только функции , которые действуют на основании их , и их внутренняя
структура не касается программиста LISP. Имя примитива имеет значение
в указателе файла , обслуживающем редактор чертежей AutoCAD, в котором
AutoLISP может найти базу данных примитивов или их векторы (если есть
вывод на экран). Наборы выбора это просто коллекция имен примитивов.


        Имена примитивов и наборы выбора действительны только в течение
        сеанса редактирования , в котором они применяются  AutoCADом.


       5.2. Манипуляция функцией  selection - set

       Следующие функции выполняют различные действия на основании
функции selection - sets (наборы выбора ).


       5. 2. 1. ( ssget [< режим >]  [<точ1> [<точ2>]])

       Вы можете применять функцию selection - set c функцией SSGET.
Аргументом < режим > является строковая константа , которая означает
тип выполняемого выбора примитива . Это могут быть буквы " W " , " C " ,
 " L" , или  " P " , названия режимов  в AutoCADе " Window" (окно) ,
Crossing "(пересечение) , " Last " (последний),  " Previous" (предыдущий).
< точ1 > и < точ2 > это аргументы точки в списках , которые определяют
точки , уместные для выбора. Обозначение точки без аргумента < режим >
эквивалентно   выбору примитива указанием единственной точки. Если все
аргументы опущены , SSGET подскажет пользователю через механизм AutoCADа
" Select objects: "(выберите объекты) , позволяя интерактивный выбор
набора.

       Примеры

    (ssget)                   Cпрашивает пользователя общий выбор примитива
    (ssget "P")               Выбирает самый новый выбранный набор.
    (ssget "L")               Выбирает последний примитив,прибавленный к базе
                              данных.
    (ssget '(2 2))            Выбирает примитив,проходящий через точку 2 , 2 .
    (ssget "W" '(0 0) '(5 5)) Выбирает примитивы внутри окна с координатами
                              точек 0, 0  5 ,5 .
    (ssget "C" '(0 0) '(1 1)) Выбирает примитивы пересекающие бокс с координатами




                           - 67 -

            Руководство пользователя по АВТОЛИСПу


                              точек 0 , 0   1 , 1 .

       Выбранные объекты высвечиваются , когда SSGET используется
без аргументов. Нет информации о том , сколько выбранных примитивов со-
храняется ( как альтернативу смотри функцию ENTSEL , описанную ниже).
Selection -sets временно поглощают щели файла AutoCAD , поэтому LISPу
не разрешается иметь более 6-и  одновременно открытых файлов. Если этот
предел достигнут , AutoCAD откажется создавать любые другие наборы выбо-
ра (selection -sets) и возвратит " nil " на все вызовы AutoCADа.
       Переменная набора выбора может быть передана AutoCADу в ответ на
любую подсказку "Select objects:" в  выборе  "Last". Она выберет все
объекты в наборе LISPа , как бы просматривая их в окошко (обратите
внимание , примитивы, выбранные этим способом не нуждаются в выводе на
экран).


       5. 2. 2. ( sslength <ss>)

       Эта функция возвращает целое число , содержащее количество прими-
тивов в наборе выбора <ss>. Наборы никогда не содержат дубликатов
примитивов.


       5. 2. 3. (ssname <ss> <index>)

       Эта функция возвращает имя примитива <index>-го элемента набора
<ss>. Если <index> отрицательное или больше самого большего вычисляемого
примитива в наборе выбора , возвращается  "nil". Первый элемент набора
имеет индекс "0". Имена примитивов в  наборе , применяемых с функци-
ей SSGET , всегда будут именами главных примитивов . Подпримитивы (Block
attributes и Polyline vertices) не будут возвращаться ( но, смотри опи-
санную ниже функцию ENTNEXT, которая делает доступными их).


       5. 2. 4.  (ssadd  [<ename> [<ss>]])

       Если вызывается без аргументов , функция SSADD создает новый
набор выбора без членов. Если вызывается с единственным аргументом име-
ни примитива , функция SSADD создает новый набор выбора , содержащий это
единственное имя примитива. Если вызывается - с именем примитива и с на-
бором выбора , она добавляет имя примитива к набору. Функция
SSADD всегда возвращает новый или модифицированный набор. Запомните,
что при добавлении примитива к набору , новый примитив физически присое-
диняется к существующему набору, и набор, проходяший как <ss>, возвраща-
ется , как результат. Таким образом, если другим переменным присваивается
категория -набор , они будут отражать также сложение. Если в наборе уже
есть примитив с таким же названием , действие функции SSADD  будет про-
игнорировано;сообщения об ошибке не будет.


       5. 2. 5. (ssdel <ename> <ss>)

       Функция SSDEL удаляет имя примитива <ename> из  набора <ss>
и возвращает имя  набора <ss>. Запомните , что примитивы физически
удаляются из набора , как оппозиция новому набору, возвращающемуся
с удаленным элементом. Если в наборе нет примитива, возвращается "nil".




                           - 68 -

            Руководство пользователя по АВТОЛИСПу




       5. 2. 6.  (ssmemb <ename> <ss>)

       Эта функция проверяет , является ли имя примитива <ename> членом
набора выбора <ss>. Если это так , функция SSMEMB возвращает имя прими-
тива <ename>. Если нет, возвращает "nil".


       5. 3.  Функции  имени примитива (entity name)

       Следующие функции выполняют различные действия с именем примити-
ва, включая  ввод. Имена примитивов могут проходить в AutoCADе в ответ
на любую подсказку " Select objects: " , для которой ответ "Last" дейст-
вителен. В результате будет выбрано название примитива , как если бы он
просматривался в окошко.


       5. 3. 1.  (entnext  [<ename>])

       Если вызывается без аргументов, эта функция возвращает имя
примитива первого неудаленного примитива в базе данных. Если функция
ENTNEXT вызывается с аргументом примитива <ename>, она возвращает имя
первого неудаленного примитива , следующего за <ename> в базе данных.
Если нет следующего примитива в базе данных, возвращается "nil". Функ-
ция ENTNEXT возвращает и главные примитивы и подпримитивы.
       Примитивы , выбранные функцией SSGET - главные примитивы, нет
атрибутов блоков или вершин  полилиний. Вы можете добраться до внутрен-
ней структуры этих сложных примитивов посредством  простого приема ,
через  подпримитивы, функцией ENTNEXT. Если вы однажды примените имя под-
примитива , вы можете действовать подобным  образом в любом другом слу-
чае. Если вы приобрели имя подпримитива через функцию ENTNEXT, вы може-
те найти родительский примитив  , двигаясь вперед от функции ENTNEXT до
функции SEQEND, чтобы обнаружить примитив, затем извлекая -2 группу из
такого примитива, который  является главным именем примитива.


       5. 3. 2.  (entlast)

       Эта функция возвращает имя последнего неудаленного главного при-
митива в базе данных. Эта  функция часто применяется , чтобы дать
имя новому примитиву , который только что был прибавлен через функцию
COMMAND. Примитив не нужно выводить на экран, и также не нужно выбирать
уровень.


       5. 3. 3.  (entsel  [<prompt>])

       Она иногда желательна , как действие на примитивы , чтобы одновре-
менно выбрать примитив и обозначить точку, с помощью которой примитив
был выбран. Примеры этого в AutoCADе можно найти в функции Object Snap
и в командах BREAK , TRIM , EXTEND . Функция ENTSEL позволяет программам
AutoLISPа выполнить это действие. Функция ENTSEL выбирает отдельный
примитив, требуя, чтобы выбор был сделан точкой. Она возвращает список, в
котором первый элемент - имя  выбранного примитива , второй
элемент - координаты точки , используемой  для выбора примитива. Если




                           - 69 -

            Руководство пользователя по АВТОЛИСПу


строка содержит <подсказку>, эта  строка может быть использована , что-
бы спросить пользователя о примитиве. Иначе , по умолчанию  появится
подсказка "Select object:" . Следующий диалог иллюстрирует использование
функции ENTSEL и возвращаемый список.

       Command:       Line
                      ----
       From point:   1 , 1
                     ------
       To point:     6 , 6
                     ------
       To point:     RETURN
                     ------
       Command:   (setq e (entsel "Please  choose an entity:"))
                  ----------------------------------------------
       Please choose an entity: 3 , 3
                                -----
       (< Entity name: 60000014> (3.000000 3.000000))

       Возвращаемая функцией ENTSEL форма в виде списка , удовлетворяет
AutoCAD в ответ на любую его подсказку  выбрать объект. Это будет трак-
товаться  AutoCADом , как выбор определенного примитива , указанного
точкой.



       5. 4.  Функции данных примитива (entity data)

       Следующие функции позволяют вам восстановить и модифицировать
данные определенных примитивов.  Имена примитивов применяются для того,
чтобы определить  примитивы, с которыми надо работать.


       5. 4. 1.  (entdel <ename>)

       Удаляет примитив , обозначенный <ename>, в текущем чертеже,
или восстанавливает примитив,если он был предварительно удален в этом
сеансе редактирования. Удаляемые примитивы вычищаются из чертежа, покидая
редактор чертежей , итак, функция ENTDEL может восстанавливать их только
в течение сеанса редактирования , когда они были удалены. Функция ENTDEL
работает только в главных примитивах,аттрибуты и вершины полилиний не
могут быть удалены , независимо от их родительских примитивов (вы можете
использовать функцию COMMAND , чтобы работать функцией ATTEDIT, или ко-
манду PEDIT, чтобы выполнить это).


       5. 4. 2.  (entget <ename>)

       Примитив , который называется <ename> восстанавливается из базы
данных и возвращается как список, содержащий эти определяемые данные. Ре-
зультирующий список кодируется , как структурированный список LISP,
элементы которого могут быть легко восстановлены функцией ASSOC. Объекты
в результирующем списке кодируются в кодах DXF системы AutoCAD для каж-
дой части входных данных. Для примера рассмотрим вычерчивание и затем
восстановление LINE следующей последовательностью команд:





                           - 70 -

            Руководство пользователя по АВТОЛИСПу


       Command: LINE
                -----
       From point: 1 , 2
                  ------
       To point: 6 , 6
                 ------
       To point: RETURN
                --------
       Command: (setq a (entget (entlast)))
                ---------------------------
установит А, равное списку ( делает останов для прочтения ):
       ( ( -1 .  <Entity name: 60000014>)
         (0 .    "LINE")
         (8 .    "0")
         (10  1.000000 2.000000)
         (11  6.000000 6.000000)
        )


       Пункт -1 в начале списка содержит имя примитива , которым этот
список представлен. Функция ENTMOD, описанная ниже , использует это ,
чтобы идентифицировать примитив  , который модифицирован.
       Отдельные точечные пары , представляют переменные , которые могут
быть легко восстановлены с помощью функции ASSOC, функция CDR обычно вы-
водит их значения. Коды для компонентов примитива те же самые, что испо-
льзует DXF , и приводятся в приложении С Руководства AutoCAD. Так же ,
как в DXF , заголовок элемента  примитива ( цвет и тип линии, сложный
примитив флага (функция ATFLAG), экструзия толщины и выключение на-
бора Z) выводится  , если переменная не по умолчанию. В функциях, не
таких как DXF, не обязательно выводить точность поля примитива, равную
ли их значениям по умолчанию или нет. Намерение сделать это является
упрощенным вариантом программ, которые всегда могут принимать эти поля
присутствующими для основных алгоритмов , по котором они работают.
       Запомните, что подсписки для точек- это не точечные пары, подобные
остальным. Соглашением является то, что функция CDR подсписка -это
групповая переменная. Так как точка- это список двух действительных чисел,
это составляет всю совокупность трех элементов списка. Функция CDR группы
является списком , изображающим точку, соглашением является также,то
что функция  CDR всегда возвращает переменную сохраненной.
       Когда описываемые функции обрабатывают эти списки, обязательно
сделайте им аккуратные подсписки. Польза для функции ASSOC от этого га-
рантирована. Группа -1 ,содержащая имя примитивов, позволяет произвести
некоторые действия, чтобы просто принять список примитива , и избежать
необходимости сохранять имя примитива в параллельной структуре. Примитив
SEQEND в конце Poliline или набор аттрибутов содержит -2группу , чьи CDR
являются заголовком в этом примитиве. Это позволит найти заголовок
в подпримитивах,двигаясь вперед к SEQEND , затем используя функцию CDR
-2 группы , как имя примитива, восстановить структурированный главный
примитив. Следующий пример хорошо иллюстрирует комплексные примитивы,
представленные как список.

       Command: ELEV
                -----
       New current elevation <0.0000>: 3.5
                                       ----
       New current thickness <0.0000>: 0




                           - 71 -

            Руководство пользователя по АВТОЛИСПу


                                       ---
       Command: LINETYPE
               ----------
       ?/Create /Load/Set: SET
                          ----
       New entity linetype <BYLAYER>: DASHED
                                      -------
       Command:COLOR
               ------
       New entity color <BYLAYER>: BLUE
                                   -----
       Command: LAYER
               -------
       ?/Make/Set/New/On/Off/Color/Ltype/Freeze/Thaw: MAKE
                                                      -----
       New current layer <0>: ANNOTATION
                             -------------
       ?/Make/Set/New/On/Off/Color/Ltype/Freeze/Thaw: RETURN
                                                     --------
       Command: TEXT
               ------
       Start point or Align/Center/Fit/Middle/Right/Style: 2 ,2
                                                          -------
       Height <0.2000>: .3
                       ----
       Rotation angle <0>: 30
                          -----
       Text: So long , and thanks for all the fish!
             ---------------------------------------
       Command: (setq e (entget (entlast)))
                -----------------------------


       В этом случае Е будет устанавливать в списке то, следует ниже.
Рассмотрение приложения С Руководства к AutoCADу придаст смысл этому
ясному списку.


       (  (-1 . <Entity name: 6000003C>)
          (0 .  "TEXT")
          (8 .  "ANNOTATION")
          (6 .  "DASHED"
          (62.   5)
          (38 .  3.500000)
          (10 2.000000 2.000000)
          (40 . 0.300000)
          (1 .  "So long , and thanks for all the fish!")
          (50 .  0.523598)
          (41 .  1.000000)
          (51 .  0.000000)
          (7  .  "STANDARD")
          (71 .  0)
          (72 .  0)
          (11  0.000000 0.000000)
        )





                           - 72 -

            Руководство пользователя по АВТОЛИСПу



       5. 4. 3. (entmod <elist>)

       Список <elist> проходит функцию ENTMOD, в формате возвращающей
его функции ENTGET, и обновляет информационную базу данных примитива,
имя которого определено совокупностью -1 в <elist>. Однако, главный меха-
низм , с помощью которого LISP обновляет базу данных , это восстановление
примитивов функцией ENTGET, модификация списка , определяющего примитив
( запомните , что для этого очень полезна функция  SUBST AutoLISPа) и об-
новляющего примитив в базе данных с помощью функции ENTMOD.
       Функция ENTMOD имеет некоторые ограничения по изменениям , которые
она делает. Во - первых , нельзя изменять типы примитивов . (Если вы хо-
тите сделать это , примените только  функцию ENTDEL и сделайте новый при-
митив командой COMMAND ). AutoCAD должен знать все объекты, которые упо-
минаются в списке примитивов, до того как выполнена функция ENTMOD. Так,
стиль текста , тип линии , форма  и имена блоков должны быть предвари-
тельно определены  в чертеже, до того, как функция ENTMOD может их испо-
льзовать в списке примитивов. Исключением в этом случае является имя
уровня , __ENTMOD освободит новый уровень по  умолчанию, используя
команду "LAYER NEW" , если в этом списке указывается предварительно
не определенный уровень.
       Функция ENTMOD выполняет некоторую последовательность действий,
как команда DXFIN, проверяя  список,содержит ли он , даннные из файла
DXF. Если обнаружена серьезная ошибка , такая серьезная ,что база дан-
ных не обновляется, возвращается "nil". В противном случае, функция
ENTMOD возвращает список в качестве аргумента. Функция ENTMOD не изме-
нит внутренние поля , такие как имя примитива в совокупности -2 функ-
ции SEQEND, попытки изменить такие поля просто игнорируются.
       Когда обновляется главный примитив , функция ENTMOD будет моди-
фицировать примитив и обновит изображение на экране ( включая под-
примитивы ) . Когда функция ENTMOD обычно обновляет подпримитив ( вершины
полилиний ,  аттрибуты блоков ), подпримитив будет обновлен в базе данных ,
но изображение на экране не обновляется. После всех модификаций, которые
сделаны с данными подпримитивами, можно использовать функцию ENTUPD, опи-
санную ниже, для обновления изображения на экране.


       5. 4. 4.  (entupd  <ename>)

       Как описано выше, когда функция ENTMOD модифицирует вершины
полилиний или аттрибуты блоков , полный комплект примитива не обновляет-
ся на экране. Например, если были модифицированы 100 вершин сложных по-
лилиний , пересчет и перечерчивание Polyline, так же как и каждой вер-
шины , которая была изменена, будет сделано неприемлемо медленно. Обыч-
но, можно применить функцию ENTUPD, чтобы модифицированную  Polyline
или блоки обновить на экране. Функция ENTUPD назовет именем примитива
любую часть  Poliline или блока. Нет необходимости иметь заголовок прими-
тива,функция ENTUPD найдет заголовок. Когда функция ENTUPD предназначена
для полилиний и аттрибутов блоков ,ее можно вызвать для любого примити-
ва. Она всегда будет восстанавливать примитив на экране , включая все
подпримитивы.


       5. 4. 5.   Ограничения

       Имена примитивов ( entity names ) и наборы выбора ( selection- sets )




                           - 73 -

            Руководство пользователя по АВТОЛИСПу


действительны только в течение сеанса редактирования ,в котором они при-
меняются в AutoCADе. Так, если вы попытаетесь произвести какие-нибудь по-
следующие действия , пока активны команды PLINE или ATTEDIT , будет воз-
вращено " nil" и запрос функции не будет выполнен.

       ENTMOD          чтобы модифицировать существующий примитив
       ENTUPD          чтобы восстановить модифицированный сложный примитив
       ENTDEL          чтобы не удалять и восстановить уничтоженный примитив




       5. 5.   Применение в AutoCADе имен примитивов и наборов выбора



       Имена примитивов (entity name) и наборы выбора (selection-sets)
необходимы для того , чтобы ввести из LISPа объекты выбора в ответ на
подсказку. Таким образом , примитивы , названные LISPом, могут работать
по командам AutoCADа. Подсказку "Select objects:" LISP может снабдить
именем примитива, который определяет единственный примитив или набор
выбора , чтобы выбрать все примитивы в наборе. Передача имен примитивов и
набора выбора из LISPа возможна в выборе "Last"( обе части ,
как способность выбирать примитивы, не взирая на видимость,так и
не специфицировать выбранные точки).
       Всякий раз, когда AutoCAD позволяет сделать выбор объекта точ-
кой, списки в программе , возвращаемые функцией ENTSEL, допустят про-
цедуру выбора. Они выбирают примитив из списка, определяя точку в спи-
ске, как выбранную точку. Это позволяет LISPу перейти к вводу выбранных
точек такими командами, как BREAK, TRIM и EXTEND. Помните, что списки
формы ENTSEL могут использоваться для других выборов тоже , так же
точно, как точка, выбираемая позволяющей командой. Списки формы ENTSEL
не могут использоваться с командами FILLET и CHAMFER, которые применя-
ют два примитива и точки из механизма выбора.


       5. 6.  Доступ к таблице символов
                                                                        :
       Приведенные ниже функции TBLNEXT и TBLSEARCH снабжены таблицей   :
символов, которая доступна только для чтения из AutoCADа уровня, типа   :
линии, именованного вида, стиля текста и определения блока.             :

                                                                        :
                                                                        :
       5. 6. 1.  (tblnext  <table name> [<first>])                      :
                                                                        :
       Эта функция используется для просмотра всех таблиц симво-        :
лов. Первый аргумент - это идентификатор символа интересующей вас таб-  :
лицы. Действительны имена "LAYER" , "LTYPE" , "VIEW" , "STYLE" и "BLOCK":
Именам не нужен верхний регистр. Когда присутствует второй аргумент ,   :
и не "nil", таблица символов переводится на начало и первый элемент в   :
ней восстанавливается, в противном случае , восстанавливается           :
следующий элемент в таблице. Когда совсем нет элементов в таблице , воз-:
вращается "nil". Удаленные элементы таблицы не возвращаются.            :
       Когда элемент обнаружен, он возвращается , как список точечных   :
пар  DXF кодов и значений , подобно тому ,который возвращает функция    :




                           - 74 -

            Руководство пользователя по АВТОЛИСПу


ENTGET.
                                                                        :
       Пример:                                                          :
                                                                        :
       (tblnext  "layer" T)        восстанавливает первый уровень       :

       может вернуть                                                    :
       ((0 .  "LAYER")             символьный тип                       :
        (2 .  "0")                 имя символа                          :
        (70 .  0)                  флаги                                :
        (62 .  7)                  цвет, негатив выключен               :
        (6 .  "CONTINUOUS")        тип линии                            :
       )                                                                :
                                                                        :
       Обратите внимание , что совокупности "-1" нет. AutoCAD запоминает:
последний элемент , возвращаемый из таблицы, и просто возвращает один   :
из следующих элементов ,при каждом вызове TABNEXTом этой таблицы.       :
Когда вы начинаете просмотр таблицы , вы должны быть уверены , что вто- :
рой аргумент не "nil",   чтобы  перемотать таблицу и вернуть первый эле-:
мент . Элементы, восcтановленные из таблицы " BLOCK" , включают в себя  :
совокупность "-2" c именем  первого примитива в определении             :
блока (или любого).                                                     :
                                                                        :
Итак, назовем блок "BOX":                                               :
                                                                        :
        (tblnext  "block")          восстанавливает определение блока   :
   может вернуть:                                                       :
       ((0 . "BLOCK")              тип символа                          :
        (2 . "BOX")                имя символа                          :
        (70 . 0)                   флажки                               :
        (10  9.000000 2.000000 0.000000)  Х,У,Z                         :
        (-2 . <Entity name: 40000126)) первый примитив                  :
       )                                                                :
                                                                        :
       Имя примитива в совокупности "-2" принимается функциями ENTGET и :
ENTNEXT ,но ни какими другими функциями. Это значит, что вы не можете   :
модифицировать такой примитив функцией ENTMOD или использовать функции  :
SSADD или ENTSEL , чтобы поместить его в selectin-set. Применяя сово-   :
купность "-2"имени примитива в функции ENTNEXT, вы можете сканировать   :
примитивы, сжимая определения блока; функция ENTNEXT возвращает "nil"   :
после последнего примитива в определение блока.


        5. 6. 2.  (tblsearch  <table name> <symbol>


       Эта функция просматривает таблицу символов , идентифицируемую    :
<table name> ( то же самое , что функция TBLNEXT), отыскивая имя символа:
присвоенного <symbol>. Оба имени автоматически приводятся к верхнему ре-
гистру. Когда обнаружено имя элемента, подобное тому ,которое           :
дал <symbol>, эта запись возвращается в формате , описанном функцией    :
TBLNEXT. Если такой элемент  не обнаружен, возвращается "nil" .         :
                                                                        :
       Например:                                                        :
                                                                        :
       (tblsearch "style" "standard")     устанавливает стиль текста    :




                           - 75 -

            Руководство пользователя по АВТОЛИСПу


                                                                        :
       может вернуть:                                                   :
                                                                        :
       ((0 . "STYLE")                     тип символа                   :
        (2 . "STANDARD")                  имя символа                   :
        (70 .  0)                         флажки                        :

        (40 .  0.000000)                  фиксирование высоты           :
        (41 .  1.000000)                  фактор ширины                 :
        (50 .  0.000000)                  угол                          :
        (71 .  0)                         генерирование флажков         :
        (3 .  "txt")                      самый первый font file        :
        (4 . "")                          большой font file             :
       )                                                                :
                                                                        :
       Порядок вводов восстановлен из TBLNEXT без воздействия функции   :
TBLSEARCH.


       5. 7.    Доступ к графическому экрану и устройствам ввода

       Функции AutoLISPа , описанные в этом разделе, обеспечивают пря-
мой доступ к графическому экрану AutoCADа, и устраивают вход из LISPа,
и позволяют средствами LISP-команд взаимодействовать с пользователем,
как если бы выполнение было без AutoCADа . Эти команды могут устроить
беспорядок на экране. Однако, любое повреждение , которое они наносят,
может быть отменено последовательностью:

       (grtext)
       (redraw)

однако , нет нужды касаться этого. Эти функции только для опытных поль-
зователей. Большинству применений LISPа не нужны  эти функции. По-
льзователей предупреждаем , что  действия этих функций могут быть из-
менены от выпуска к выпуску системы AutoCAD и, следовательно, Autodesk,
поэтому нет гарантии указанной выше совместимости применений этих функ-
ций. Применение функций GRTEXT и GRREAD также может быть неподходяще ,
для работы на любой жесткой конфигурации, если пользователь не очень
внимателен , чтобы аккуратно следовать правилам их использования , при-
веденным ниже.


       5. 7. 1.  (grclear)

       Эта функция очищает графический экран AutoCADа. (В системах с
одним экраном она переключит графический экран с текстового режима
на первый). Подсказка , статус и меню остаются неизменными. Оригинал
может быть перевыведен на графический экран функцией REDRAW.


       5. 7. 2.  (grdraw  <from> <to> <color> [<highlight>])

       Функция GRDRAW вычерчивает вектор между двумя точками . <from>
и <to> являются точками (списки из двух действительных чисел), кото-
рые определяют конечные точки  вектора. Конечные точки определяются ,
как плавающие точки для вычерчивания координат и будет clipped, как




                           - 76 -

            Руководство пользователя по АВТОЛИСПу


требование , чтобы вывести на экран.  Вектор будет нарисован с цветным
выводом , если аргумент <color> целое число, определяемое в группе -1 в
"XOR ink",которая заканчивает любое его вычерчивание и уничтожается,
когда перечерчено. Если аргумент <highlight> целое число и не "0",
будет нарисован вектор так, как механизм дисплея высветит выбранные
объекты ( обычно по-точечно ). Если <highlight> пропущен или имеет зна-
чение 0, будет использован нормальный режим вывода на экран.


       5. 7. 3.    ( grtext [<box> <text> [<highlight>]])

       Функция GRTEXT позволяет AutoLISPу выводить текст частямии
на графический экран в AutoCADе. Если вызывается с аргументом
<box> от 0 и до самого высокого численного значения бокса в меню экрана
минус 1, функция выведет на экран дисплея строковый  аргумент <text>,
в указанный в меню бокс .  Текст<text> будет  cокращен, если он
слишком длинный , и непригоден для бокса, и пустота заполнится пробела-
ми, если текст короче. Если присутствует факультативный аргумент
(целое число) <highlight> и он не 0 , в предназначенном боксе
будет высвечиваться текст. Если <highlight> присутствует и  0, текст в
предназначенном боксе не будет высвечиваться ( запомните, что при высве-
чивании другого текста, бокс автоматически отменяет предыдущий текст, ко-
торый был высвечен). Когда вы пишете в боксе , текст сначала должен быть
написан без аргумента <highlight>, затем высвечен. Такая же текстовая
строка , какая в оригинале вводится в бокс,  должна высвечиваться и не
высвечиваться. Результатом несоблюдения этих правил будут  LISP програм-
мы , которые ведут себя по-разному на разных дисплеях. Запомните , что
эта функция просто выводит на экран дисплея текст, находящийся в площади
экрана ; она не изменяет элементы экранного меню.
       Если функция GRTEXT вызывается боксом  номер -1, текст будет
выведен на экран в режиме статуса линии . Длина линии зависит от дисплея
( большинство их допускает , по крайней мере , 40 разновидностей, за
исключением замечательного Color Graphics Adaptor фирмы IBM ). Текст
будет сокращен , чтобы пригнать его к имеющемуся в распоряжении про-
странству .
       Если используется бокс с номером -2, текст будет написан в коор-
динатах статуса линии. Запомните, что если слежение координат вклю-
чено, величины, записанные в это поле , перепишутся ,как только
указатель пошлет другой набор координат. Каждый из номеров , -1 или -2 ,
игнорирует аргумент <highlight> , если он присутствует .
       Наконец, функция DRTEXT может быть вызвана без аргументов, что-
бы восстановить всю площадь текста на экране, с его стандартными
переменными.


       5. 7. 4.  (grread  [<trac>])

       Функция GRREAD позволяет вам непосредственно следить за механиз-
мом входа AutoCADа, выслеживая указанные механизмы , когда они изменяются.
Этой функции нужны только специфические команды , большинство входов в
AutoLISP пройдут через различные функции GETxxx , такие как GETSTRING ,
GETREAL и подобные. Аргумент <track> , если он имеется и не "nil" ,
дает возможность вернуть координаты из указанных механизмов , когда они
двигаются, не требуя выбора нажатием клавиш. Этот механизм AutoCAD обыч-
но использует для протягивания.
       Функция GRREAD возвращает список , в котором первый элемент это




                           - 77 -

            Руководство пользователя по АВТОЛИСПу


код , определяющий тип входа. Второй элемент списка - любое целое число
или список точек , зависящих от типа входа . Коды для первого элемента
в списке следующие:

       2   характеризует клавиатуру - в кодах ASCII, также и для вторго
           элемента
       3   выбираемая точка - координаты , как список
       4   выбираемый элемент меню экрана- номер бокса , также и для
           второго элемента
       5   режим протягивания координат , также и для второго элемента.
           Возвращается только , если второй аргумент определен и он не
           "nil"
       6   BUTTONS выбираемый пункт меню - номер клавиши это второй
           элемент
       7   TABLET1 оцифровываемый пункт меню - номер бокса это второй
           элемент
       8   TABLET2 оцифровываемый пункт меню - номер бокса это второй
           элемент
       9   TABLET3 оцифровываемый пункт меню - номер бокса это второй
           элемент
       10  TABLET4 оцифровываемый пункт меню - номер бокса это второй
           элемент
       11  AUXI оцифровываемый пункт меню - номер бокса это второй
           элемент
       12  координаты, связанные с указателем клавиш , возвращаемые,
           как второй элемент. Всегда следует тип 6 , чтобы возвратить
           список
       13  выбор высвеченного пункта меню экрана при помощи ввода с
           клавиатуры
       Ввод CTRL C в то время как идет GRREAD , вызовет прерывание
(abort) LISP программы с клавиатуры. Любой другой вход пройдет прямо
к GRREAD ,давая этим возможность закончить контроль над механизмом
входа.



       5. 8.  Образцы программ

       Следующие LISP программы иллюстрируют возможности , описанные в
этой главе.

       5. 8. 1.  Удаление уровня

       Эта программа выполняет команду DELLAYER , чтобы удалить все
примитивы определенного уровня.

       ;    Удаление всех примитивов на определенном уровне

       (defun C : DELLAYER (/ e l)
          (setq l (strcase (getstring "\nLayer to  delete?")))

       ;    Запуск черчения сканированием первого примитива
         (setq e (entnext))

       ;    Проверка уровней этих примитивов (8 групп)
         (while e




                           - 78 -

            Руководство пользователя по АВТОЛИСПу


            (if (= l (cdr (assoc 8 (entget e))))
       ;    Корректирование уровня... удаление этого уровня
          (entdel e)
       )
       ;    Взять следующий примитив
           (setq e (entnext e))

       ;    Останов до тех пор пока не будет больше примитивов
       )
    )

       Функция DELLAYER проверяет  8 групп ( имя уровня ) каждого прими-
тива чертежа, просматривая примитивы на специфицируемом уровне. Тестиро-
ванием других групп вы можете выполнить команды, чтобы проверить все
примитивы особых типов ( окружности, может быть) или все примитивы осо-
бых вычислений и прочее.                                                               :
                                                                        :
                                                                        :
       5. 8. 2.   Установление  текущего уровня                         :
                                                                        :
       Эта программа выполняет команду SETLAYER , давая возможность     :
изменить текущий уровень просто указывая на существующий объект       :
этим уровнем.                                                           :
                                                                        :
       ; Установить текущий уровнь этого существующего объекта          :
                                                                        :
       (defun C:SETLAYER ( / e n)                                       :
          (setq e (car (entsel "Pick an object on the desired layer: ")))
          (if e ( progn                                                 :
                                                                        :
        ; Взять входные данные групп                                    :
             (setq e (entget e)                                         :
             )                                                          :
        ; Группа 8 - это имя уровня                                     :
             (setq n (cdr (assoc 8 e)))                                 :
                                                                        :
        ; Результат выполнения команды "LAYER SET"                      :
             (command "LAYER" "SET" n "")                               :
                                                                        :
           ))                                                           :
       )                                                                :
                                                                        :
       Вы можете использовать подобный подход , чтобы установить теку-  :
щий цвет, тип линии, возвышение или толщину этих специфицируемых объе-  :
ктов.                                                                   :
                                                                        :
                                                                        :
       5. 8. 3.   Изменение уровня примитива

       Это вариации команды SETLAYER , приведенной выше. Лучше, чем ус- :
тановление текущего уровня , эта команда изменяет выбранные объекты,    :
для того чтобы иметь тот же самый уровень , как и у другого выбранного  :
объекта.                                                                :
                                                                        :
       (defun C:CHGLAYER (/ ss e n)                                     :
          (princ "Select objects to be change ...\n")                   :




                           - 79 -

            Руководство пользователя по АВТОЛИСПу


                                                                        :
       ; Основной набор выбора (selection-set)                          :
          (setq ss(ssget))                                              :
                                                                        :
                                                                        :
                                                                        :
       ;Если любые выбранные объекты....                                :
          (if ss (progn                                                 :
             (setq e (car (entsel "Pick an object on the desired        :
    layer: ")))                                                         :
                                                                        :
       ; Если объект был выбран...                                      :
           (if e (progn                                                 :
                                                                        :
       ; Перейди на эту группу данных                                   :
              (setq e (entget e))                                       :
                                                                        :
       ; Группа 8 - это имя уровня                                      :
              (setq n (cdr (assoc 8 e)))                                :
              (command "CHANGE" SS "" "PROP" "LAYER" n "")                :
           ))                                                           :
        ))                                                              :
      )                                                                 :
                                                                        :
       В этом примере наборы выбора ( selection - set)  объектов , кото-:
рые можно изменить , устанавливаются символом SS. Можно применять однаж-:
ды установленное имя уровня ( из 8 группы выбранного объекта), выбор    :
набора ( selection - set ) SS проходит к команде "CHANGE Properties"             :
( изменение собственности) , чтобы вызвать эффект желаемого изменения.  :
                                                                        :

       5. 8. 4.  Текстовый редактор

       Программа, приведенная ниже , выполняет команду CHGTEXT для ос-
новного редактирования  текстов. Она допускает, что вы обозначаете
"new string" (новая строка), чтобы ею заменить  в каждом случае ста-
рую строку ("old string"), которая обнаружена в выбранном тексте.
Вы можете легко расширять это , чтобы любой текст по вашему желанию ре-
дактировался .

      ; Изменение подстроки в выбранном текстовом примитиве

      (defun C:CHGTEXT (/ p l n e os as ns s nsl osl sl si chf chm)
         (setq p (ssget))        ; Выберите объекты
         (if p (progn            ; Если любые объекты выбраны...
            (setq osl (strlen (setq os (getstring "\nOld string: "t))))
            (setq nsl (strlen (setq ns (getstring "\nNew string: "t))))
            (setq l 0 chm 0 n (sslength p))
            (while (< l n)       ; Для каждого выбранного объекта...
            (if (= "TEXT"        ; Смотри тип примитива ТЕКСТ (группа 0)
                   (cdr (assoc 0 (setq e (entget (ssname p l))))))
               (progn            ; Обнаружен один... смотри старую строку
                  (setq chf nil si 1)
                  (setq s (cdr (setq as (assoc 1 e))))
                  (while (= osl (setq sl (strlen
                                (setq st (substr s si osl)))))




                           - 80 -

            Руководство пользователя по АВТОЛИСПу


                     (if (= st os) (progn
                        (setq s (strcat (substr s 1 (1 si)) ns
                                        (substr s (+ si ost))))
                        (setq chf t)  ; Обнаружена старая строка
                     ))
                     (setq si (1+ si))
                 )
                 (if chf (progn       ; Заменитель новой строки на старую
                    (setq e (subst (cons 1 s) as e))
                    (entmod e)        ; Текстовый примитив
                    (setq chm (1+ chm))
                ))
            )
         )
         (setq l (1+ l))
      )
   ))
   (princ "Changed")                  ; Печать полностью измененных линий
   (princ chm)
   (princ " text lines.")
   (terpri)
 )

       Здесь, набор выбора Р (selесtion -set P) исследуется для примити-
вов текста , содержащих в себе специфицируемую старую строку( "old
string"). Для каждого подобранного примитива текста, функции STRCAT и
SUBSTR обычно формируют новую текстовую строку, которая во всех случаях
заменяет старую строку (old string) на новую строку ( new string). Испо-
льзуя SUBST,вы построите новую строку, заменяющую группу 1 в текстовом
примитиве, и затем обычно ENTMOD откорректирует примитив в базе данных
чертежа и на экране.


       5. 8. 5.   Обновление данных

       Считайте, по соглашению ,что вы вставляете блок, называемый
"TITLE", в каждый чертеж и , что этот блок имеет аттрибуты , называемые
"REVDATE",которые означают данные последней ревизии. Следующая программа
выполняет команду REVISE, которая обнаруживает этот блок и корректирует
его аттрибуты. Сначала определяется пара функциональных утилит.

       ; Ввод текущих данных в формате MM/DD/YY

       (defun mmddyy (/ x)
          (setq x (getvar "CDATE"))     ; Текущие данные
          (setq x (rtos x 2 0))         ; Обращение к строке
          (setq date (strcat (substr x 5 2) "/"   ;MM
                             (substr x 7 2) "/"   ;DD
                             (substr x 3 2)))     ;YY
       )

       ; Возврат содержания примитива поля "num"

       (defun fld (num)
           (cdr (assoc num d))
       )




                           - 81 -

            Руководство пользователя по АВТОЛИСПу



       ; Поиск аттрибутов REVDATE в блоке TITLE и обновление

       (defun C:REVISE (/ e d date done)
          (setq done nil)
          (setq e (entnext)                   ; Первый объект в чертеже
          (while e
             (setq d (entget e)               ; Получение групп данных
                                              ;    примитива

             (if (and (= (fld 0) "INSERT")    ; Имеется ли INSERT ?
                      (= (fld 2) "TITLE")     ;  ...    имя TITLE?
                      (= (fld 66) 1))         ;  ...    АТТРИбУТЫ?
                (progn
                   (setq e (entnext e))       ; Получение подпримитива
                                                 (аттрибута)
                   (while e
                      (setq d (entget e))     ; Получение подпримитивов
                                              ;   групп данных
                      (cond ((and (= (fld 0) "ATTRIB")   ; Искать
                                  (= (fld 2) "REVDATE")) ; Аттрибуты
                                                         ;  REVDATE
                               (mmddyy)
                               (setq d (subst (cons 1 date) (assoc 1 d))
                               ; Новые данные

                               (entmod d)    ; Изменение аттрибутов
                                             ;  переменных
                               (entupd e)    ; Регенерация блока
                               (setq e nil done T))  ; Были выполнены
                            ((= (fld 0) "ENDSEQ")
                                (setq e nil)) ; Нет аттрибутов REVDATE;
                                              ;  останов сканирования
                            (T (setq e (entnext e))) ; Ввод следующего
                                                     ;   подпримитива
                     )
                  )
              )
              (setq e (entnext e))           ;Нет блока TITLE, вход
                                             ;  следующего примитива
          )
       )
       (if done "Revision date updated" "No REVDATE attribute found")
    )

       Команда REVISE проверяет группу 0 ( тип примитива) каждого прими-
тива в чертеже , просматривая упоминаемый блок ( фцнкция INSERT), кото-
рый назван " TITLE". Затем она сканирует подпримитивы этого блока (его
аттрибуты), просматривая аттрибуты "REVDATE". Обнаруженная переменная
аттрибутов изменится и блок введется.


       5. 8. 6.    Список типов линий
                                                                        :
       Этот пример использует функции доступа к таблице символов, чтобы :
внести в список имена и определения всех текуще-загруженных типов линий.:




                           - 82 -

            Руководство пользователя по АВТОЛИСПу


                                                                        :
                                                                        :
       ; Пустая-полная  данная строка ,которая  определяет количество   :
       ; знаков.                                                        :
                                                                        :
       (defun strfill (s len)                                           :
          (substr (strcat s "                     ") 1 len)             :
       )                                                                :
       ; Возврат переменной , связанной с отдельной группой примитива   :
                                                                        :
       (defun fld (num lst)                                             :
          (cdr (assoc num lst))                                         :
                                                                        :
       ; Список загруженных типов линий                                 :
                                                                        :
       (defun C:LTYPES (/ a cl d f lt s x)                              :
          (textscr)                            ; Вывод текста на экран  :
          (write line " Linetype   Align   Segs   Description")         :
          (terpri)                                                      :
          (setq cl (getvar "CELTYPE") f "  ")  ; Текущий тип линии,     :
                                               ;  "регистр" флажка      :
                                                                        :
       ; Если текущий тип линии "BYLAYER", справься о текущем уровне    :
       ; Провести линию и изменить "регистр" флажка с"" на "L"          :
                                                                        :
       (setq cl                                                         :
          (cond ((= cl "BYBLOCK") "")                                   :
                ((= cl "BYLAYER") (setq f "L ")                         :
                    (fld 6 (tblsearch "LAYER" (getvar "CLAYER"))))      :
                (T cl)                                                  :
       ))                                                               :
       (setq x (tblnext "LTYPE" T))             ; Первый тип линии      :
       (while x                                                         :
          (setq lt (fld  2 x)                   ; Имя типа линии        :
                d  (fld  3 x)                   ; Простое описание типа :
                                                ; линии                 :
                a  (fld 72 x)                   ; Выравненный код       :
                s  (fld 73 x)                   ; Длина каждого штриха  :
                                                                        :
       )                                                                :
       (write line                                                      :
          (strcat                                                       :
             (if (=lt cl) f "  ")               ; Регистр флажка прими- :
                                                ;   тива линии          :
             (strfill lt 12)                    ; Редактор имени        :
                                                ;   уровня              :
             (strfill (chr a) 7)                ;  Выравненный код      :
             (strfill (itoa s) 6)               ;   Длина черточки      :
                                                ;  элементов            :
             (substr d 1 30)                    ;   Описание типа линии :
       ))                                                               :
       (if (> s 0) (progn                    ; Если любой отдельный     :
                                             ;элемент,редактируйте его  :
          (setq x (member (assoc 49 x) x))   ; Введите список каждого   :
                                             ; элемента                 :
              (while x                                                  :




                           - 83 -

            Руководство пользователя по АВТОЛИСПу


                 (setq s (cdar x))               ; Введите длину штриха :
                 (write line                                            :
                    (strcat                                             :
                       (strfill " " 27)                                 :
                       (cond ((= s 0) "Dot")                            :
                             ((> s 0) (strcat "Pen down" (rtos s 2 4))) ;
                             (T       (strcat "Pen up"   (rtos (abs s) 2:
                             4)))                                       :
                 )))                                                    :
                 (setq x (cdr x))                ; Введите следующий    :
                                                 ;  элемент             :
           )))                                                          :
           (setq x (tblnext "LTYPE"))            ; Введите следующий    :
                                                 ;   тип линии          :
       )                                                                :
       (terpri)                                                         :
    )                                                                   :
                                                                        :
                                                                        :
       5. 8. 7.  Воображаемое окошко (ZOOM Window )                     :
                                                                        :
       Эта программа использует функции механизма доступа, который выпо-:
лняет фантазию ZOOM Window ( масштаб в окошке), позволяющую вам уста-   :
новить триггер между перемещенным и измененным размером в боксе.        :
                                                                        :
       ; ZOOM Window подобен ZOOM Dynamic, исключает выполнение на те-  :
       ; кущем дисплее без ручной клавиатуры , кроме клавиш пробел ,    :
       ; возврат и клавиши со стрелкой.                                 :
                                                                        :
       (defun drawbox ()                          ; Вычерчивание бокса  :
          (grdraw ll ul 1) (grdraw ul ur 1)                             :
          (grdraw ur lr 1) (grdraw lr ll 1)                             :
          (if (= mode 0) (cenx) (arrow)                                 :
       )                                                                :
       (defun cenx ()                             ; Определение центра Х:
          (grdraw x1 x2  1) (grdraw x3 x4 1)                            :
       )                                                                :
       (defun arrow ()                            ; Вычерчивание стрелок:
          (grdraw a1 a4 1)  (grdraw a2 a4 1)  (grdraw a3 a4 1)          :
       )                                                                :
       (defun newbox ()                           ; Переопределение па- :
                                                  ; раметров бокса  &   :
                                                  ; draw                :
          (setq deltay (* deltax aspect))        ; Допускает , что del- :
                                                 ; tax & был центр      :
                                                                        :
          ; Переустановка в более высокий уровень                       :
          (setq xcen (car center) ycen (cadr center))                   :
                                                                        :
          ; Понижение/повышение X/Y для бокса                           :                                   :
          (setq lx (- xcen deltax) ux (+ xcen deltax))                  :
                                                                        :
          (setq ly (- ycen deltay) uy (+ ycen deltay))                  :
          (setq ll (list lx ly) ul (list lx ly))   ; Углы бокса         :
          (setq ur (list ux uy) lr (list ux ly))                        :
                                                                        :




                           - 84 -

            Руководство пользователя по АВТОЛИСПу


          ; Повышение/понижение Y перекрестия & стрелки                 :
          (setq yp (+ ycen arm) ym (- ycen arm))                        :
                                                                        :
          ; Левый наклон стрелки                                        :
          (setq al (list (- ux arm) yp) a2 (list (-ux arm) ym))         :
                                                                        :
          (setq a3 (list (- ux arm arm) ycen))     ; Хвост стрелки      :
                                                                        :
          ; Правый конец всех трех                                      :
          (setq a4 (list ux ycen))                                      :
          (setq x1 (list (- xcen arm) ym) x2 (list (+ xcen arm) yp))    :
                                                                        :
          ; Концы по X                                                  :
          (setq x3 (list (- xcen arm) yp) x4 (list (+ xcen arm) ym))    :
          (drawbox)                                                     :
       )                                                                :
                                                                        :
          (defun C:ZW (/ arm aspect center deltax inp loop mode prev    :
                        pt sourse)                                      :
                                                                        :
             ; Запуск на центр экрана                                   :
             (setq center (getvar "VIEWCTR"))                           :
                                                                        :
             ; Попытка переместить курсор с центра                      :
             (setvar "LASTPOINT" (setq prev center))                    :
                                                                        :
             (setq aspect (/ (cadr (aetq aspect (getvar "SCREENSIZE"))) :
                (car aspect)))                                          :
                                                                        :
             ; Использование 1/4 бокса экрана                           :
             (setq deltax (* 0.25 (getvar "VIEWSIZE")))                 :
                                                                        :
             ; Первоначальный режим движения в боксе                    :
             (setq arm (* 0.1 deltax) mode 0 loop T)                    :
             (newbox)                                                   :
             (while loop                                                :
                (setq inp grread T))     ; Выход прослеженный           :
                                                                        :
                ; Изолирование источника и # или точки                  :
                (setq source (car inp) pt (cadr inp))                   :
                (cond ((= source 3)      ; "Pick"(выбрать) клавишей?    :
                         (cenx) (arrow)  ; Уничтожить Х & начертить     :
                                         ; или дефекты многочисленны    :
                                                                        :
                         ; Триггер в режиме бокса                       :
                         (setq mode (- 1 mode))                         :
                                                                        :
                         ; Попытка  переместить курсор с центра         :
                         (setvar "LASTPOINT" center))                   :
                      ((= source 5))     ; Выслеженная точка?           :
                                                                        :
                         ; Если ее сдвинуть...                          :
                         (if (or (/= (car  prev) (car pt))              :
                                 (/= (cadr prev) (cadr pt)))            :
                                                                        :
                         ; Изменить или сдвинуть бокс                   :




                           - 85 -

            Руководство пользователя по АВТОЛИСПу


                         (progn                                         :
                             (if (= mode 0)                             :
                                (setq center pt)                        :
                                (setq deltax (+ deltax (- (car pt)      :
                                (car prev)))))                          :
                             (setq prev pt)                             :
                             (drawbox)        ; Удалить старый блок     :
                                                                        :
                             ; Ввести новый центр/размер и чертеж       :
                             (newbox)                                   :
                        )))                                             :
                  ((or (and (= source 6) (= pt 0))  ;lst меню клавиш(CR):
                       (and (= source 2)            ; или клавиатура и  :
                       (or (= pt 13) (= pt 32))))   ; CR или бланк?     :
                     (drawbox)                      ;Удалить старый бокс:
                     (command "ZOOM" "W" ll ur)                         :
                     (setq loop nil))               ; Выход             :
                (T                              ;Любая grread переменная:
                     (drawbox)                      ;Удалить старый блок:
                     (setq loop nil a " ^cancel ")) ; Выход             :
              )                                                         :
            )                                                           :
       )                                                                :
                                                                        :

       5. 8. 8.     Idle ( работать вхолостую)

       Наконец, это та программа , которая иллюстрирует функции прямого
 вывода на экран, также как и использование функции " ERROR".

       ; Команда IDLE

       (defun "ERROR" (s)              ; Ошибка наверху (или CTRL C)
          (redraw)                     ; Перечерчивание на экране
          (grtext)                     ; Повторный вызов меню/статус
                                       ; текста на экране
       )

       (defun C:IDLE ()
          (setq vc (getvar "viewctr")) ; Вызов центральной точки на
                                       ; экран
          (setq cx (car vc))
          (setq cy (cadr vc))
          (setq vc (/ (getvar "viewsize") 2))
          (setq xmin (- cx vs))        ; Вычислить сторону квадрата
          (setq xmax (+ cx vs))
          (setq ymin (- cy vs))
          (setq ymax (+ cy vs))
          (setq xdir (/ vs 10) ydir xdir)
          (setq cx (+ cx (* xdir 7)))
          (setq cy (- cy (* ydir 3)))
          (grclear)                       ; Чистый графический экран

          ; В статусе свободного участка
          (grtext -1 "       That's entertainment!')





                           - 86 -

            Руководство пользователя по АВТОЛИСПу


          ; В координатах свободного участка
          (grtext -2 "Press CANCEL to stop.")

          ; Набор начальной точки
          (setq lp (list cx cy))

          (while t                    ; Цикл навсегда ( ....до CTRL C)
             (setq nx (+ cx xdir))    ; Набор конечной координаты Х
             (if (or (> nx xmax) (< nx xmin))
                (progn
                    (setq xdir (- xdir))    ; Соответствующий каталог Х
                    (setq nx cx)
         )
      )
      (setq ny (+ cy ydir))         ; Набор конечной Y координаты
      (if (or (> ny ymax) (< ny ymin))
          (progn
             (setq ydir (- ydir))     ; Соответствующий каталог Y
             (setq ny cy)
          )
       )
       (setq cx nx cy ny)
       (grdraw lp (setq lp (list nx ny)) -1)     ; Вычерчивание с"XOR ink"
    )
  )





                           Глава 6

                     УПРАВЛЕНИЕ ПАМЯТЬЮ

       Эта глава применима только к системам MS-DOS/PS-DOS, базовыми си-
стемами UNIX она может быть игнорирована: в системе UNIX программы LISP
и объём данных практически неограничены .
       Переменные , пользовательские определители ( user- defined) фун-
кций и стандартные функции, описанные в этом руководстве, все помещают-
ся в памяти вашего компьютера только на время сеанса редактирования в
системе AutoCAD. Когда AutoLISP загружен , он требует для себя  два
больших участка памяти. Первый , называемый  heap (или nodes ), это
участок , на котором хранятся все функции и переменные , больше пере-
менных и функций есть у вас (и больше комплексов ваших функций) -больший
heap space ( участок памяти) будет использован.  Второй участок, назы-
ваемый stack ( стек ) , содержит аргументы функций и частично результа-
ты ; глубже "клубок" функций или больше повторений выполнения ваших фун-
кций - большая часть стека ( stack space ) использована.

       По умолчанию размеры участков памяти:

       heap       5.000 bytes
       stack      5.000 bytes

       AutoLISP, работая с AutoCADом, не может менять размеры  участ-
ков памяти heap и stack. Если вы , вычисляя достачно большое количество




                           - 87 -

            Руководство пользователя по АВТОЛИСПу


функций и переменных , израсходуете весь участок памяти heap, AutoLISP
выведет на дисплей сообщение об ошибке:

       Insufficient node space
       Недостаточное node пространство
и закончит выполнение текущей функции. Если недостаточно памяти , чтобы
загрузить AutoLISP , когда  вы в AutoCADе , на экран дисплея будет вы-
ведено сообщение:

       Insufficient memory - AutoLISP disabled
       Недостаточно памяти - AutoLISP невозможен

       AutoLISP не будет функционировать до тех пор, пока память не
будет предоставлена , и AutoCAD выполнится снова.


       6. 1.   Устанавливаемые AutoLISPом требования к памяти

       Если вы опытный программист и хорошо знакомы с концепцией исполь-
зования "heap" и "stack" областей памяти в языках программирования , вы
можете по желанию использовать команду "SET" системы DOS, чтобы после
этого AutoLISP получил достаточную память для участков  heap и
stack. Например, команды:

       C>SET  LISPHEAP=25000
       C>SET  LISPSTACK=10000

говорят  AutoLISPу резервировать 25000 байтов памяти для участка heap,
и 10000 байтов для участка stack. Полный объем памяти для двух участков
не должен превышать 45000 байт.Если вы хотите,вы можете поместить
утверждения , подобные приведенным выше , в ваш файл " autoexec.bat",
и они будут выполняться всегда , когда вы включаете ваш компьютер.
Эти команды "SET" эффективны только в AutoLISPе , они не являются при-
чиной , того, что память вашего компьютера будет "погибшей"(" lost "),
пока AutoLISP не загружен.


       6. 2.  Восстанавливаемое NODE SPACE(участок памяти node)

       Вы можете обнаружить, что некоторые созданные вами функции и пе-
ременные нужны вам только на некоторое время. Когда они вам бу-
дут уже не нужны, вы можете эффективно " не обнаружить" их, присваивая
им значение "nil". Например, если вы загрузились и использовали функцию
с именем  SETUP , а дальше в ней не нуждаетесь , вы можете:

       (setq setup nil),

чтобы избавиться от нее. Node (heap) участок памяти , используемый этой
функцией , восстановится, давая возможность использовать его другими
функциями и переменными.
       Если вы хотите почистить(удалить) все  функции и переменные , ко-
торые вы загрузили или определили во время этого сеанса редактирования,
это тоже легко можно сделать. AutoLISP обслуживает список с именем
ATOMLIST, который первоначально содержит имена всех системных ( system-
defined)  функций и переменных. ( Если вы хотите видеть его содержание,
введите только "!atomlist" в ответ на подсказку AutoCADа "Command:")




                           - 88 -

            Руководство пользователя по АВТОЛИСПу


Как только вы создаете новые функции и переменные , их имена заносятся
в оглавление ATOMLIST. Вы можете изъять любое ,обозначенное вами, из
того что есть в оригинале, прерыванием ATOMLISTа . Будьте внимательны,
однако, не прерывайте системных функций , иначе вы окажетесь в тупике.

       Если вы поместите следующую функцию в ваш "acad.lsp" файл:

       (defun C:CLEAN ()
          (setq atomlist (member 'C:CLEAN atomlist))
          'DONE
       )

у вас будет возможность ввести команду CLEAN , всегда , когда вы хотите
сделать ATOMLIST аккуратным и получить обратно участок памяти node,
используемый всеми вашими функциями и переменными. Если  C:CLEAN послед-
няя функция в вашем "acad.lsp" файле , функции, которые вы определяете
ранее в файле, будут сохранены , когда вы введете CLEAN. Функция CLEAN
сбрасывает только подпоследовательно определяемые( subsequently-defined)
функции и переменные, таким образом, все , что вы в " acad.lsp" опре-
делили раньше, обработается как системно определяемые функции.

       ЗАПОМНИТЕ. Механизм ATOMLIST нестандартная особенность LISPа и
       может быть изменена в будущих версиях AutoLISPа. К тому же, техни-
       ка прерывания ATOMLISTа не може
       т быть использована , когда имеется
       возможность листания виртуальных функций. Смотри следующий раздел.


       6. 3.    Виртуальные страничные функции

       Если применение вашего AutoLISPа становится слишком большим ,
чтобы быть впору имеющемуся участку памяти node (установленному пере-
менной SET в LISPHEAP , как описано выше), вы можете использовать
перелистыватель виртуальной функции AutoLISPа, чтобы позволить рост ва-
шей программы. Чтобы сделать это, просто выполните функцию:

       (vmon)

перед первым DEFUN в вашей программе. Это позволит виртуальной функции
разбить память на страницы, для остатка сеанса AutoCAD Drawing Editor.
Однажды позволенная , функция разбиения памяти на страницы  не отключает-
ся. Только функции, созданные через функции DEFUN ,следующие
за функцией VMON, подходят для разбиения памяти на страницы , а,
если у вас функции DEFUN перед VMON , они не будут разбивать память на
страницы и еще могут вызвать на терминал сообщение:

       "Insufficient node space"   Недостаточно памяти node

      После того , как функция VMON выполнится,  AutoLISP будет перелис-
тывать страницы  редко используемых функций, всякий  раз когда они за-
пускаются из памяти, и автоматически читать их снова, когда они понадо-
бятся. Вам не нужно беспокоиться об этом перелистывании,так как оно уп-
равляется автоматически, и это ясно из  вашей программы.Эти функции вре-
менно перекачиваются в файл , через который управляется файл перелисты-
вателя страниц AutoCADа. Итак , когда вы имеете достаточно расширенную
или продленную память, обычно эта память будет перекачивать функции и




                           - 89 -

            Руководство пользователя по АВТОЛИСПу


выдаст результат намного быстрее , чем свопинг(перекачка)на диск.
       Запомните, что система с виртуальной памятью только листает функ-
ции: однако, вы должны иметь достаточный участок node памяти для разме-
щения всех списков (data lists) , использующихся в вашей программе, а
также функций и имен переменных. Следовательно, хотя листание страниц
позволяет прогнать большую программу со много меньшей памятью, вы ,одна-
ко, должны установить оптимальный размер участка heap и набор LISPHEAP
соответственно. То же самое относится к размеру участка stack и к набо-
ру LISPSTACK при работе с виртуальной памятью.


       Технические замечания

       Следующая информация полезна только опытным хакерам (программис-
там ) LISPа. Новички и те, кто играют, как правило, могут( и должны) иг-
норировать эту дискуссию.


       После того , как функция VMON выполнится, все функции DEFUN зани-
мают новый участок node памяти, называемый таблица страниц (page table),
в начале каждого списка функции. Этот node участок добавляется перед
списком, содержащим формальные аргументы. Участок памяти page table node
используется исключительно,как перелистыватель страниц ,и в любом случае,
им нельзя манипулировать пользователю программ. Функция TYPE возвращает
PAGETB в эти участки памяти node.
       Когда программа AutoLISP загружается из участка памяти node, ме-
ньше всего используемая функция сбрасывается  записью ее в стра-
ничный файл (paging file) , сохраняя адрес страничного файла в таблице
страниц, и освобождая весь участок памяти node, занимаемый функцией,
следующей за таблицей страниц. В таблице страниц маркируется та функция,
которая сброшена. Когда сброшенная функция вычислена, она снова считыва-
ется из страничного файла( возможно откачивание других функций) по при-
оритету выполнения. Когда функция списана из страничного файла,
последующие откачки просто освобождают этот участок hode памяти. Нет
необходимости  удалять функцию , так как она всегда присутствует в файле.
       В AutoLISPе функции, созданные с помощью DEFUN, являются просто
списками, и ими можно манипулировать как со списками. Программы , которые
делают это , должны быть осведомлены об операции перелистывания страниц
( или не применяйте VMON). Прежде всего,функции, создаваемые с помощью
функции DEFUN, имеют в начале участок памяти node таблицы страниц ( page
table), так что , вы должны перескочить его, если будете сканировать фу-
нкцию. Если вы создаете функцию сами для себя , как список( обходя
DEFUN), она будет работать прекрасно,но она не подойдет для свопинга
( перекачивания) , поэтому вы можете легко запустить ее из памяти,
если  вам это удобнее. Наоборот, вы можете поместить функцию
в память , переопределяя ее без таблицы страниц. Например, чтобы помес-
тить функцию, определенную DEFUNом с именем ZORP,в память,вы должны ис-
пользовать:

       (setq zorp (cdr zorp))
чтобы удалить применение таблицы страниц. Таблицы страниц печатаются про-
сто как пробел , когда вы используете функцию PRINT. Вы можете определить,
когда функция  перекачиваема, проверив, имеется ли пробел после первой
левой скобки: если так , она перекачиваема.
       Если вы пытаетесь сканировать функцию, как данные, и откачи-
вать ее, вы должны найти только таблицу страниц в списке функции. Проход-




                           - 90 -

            Руководство пользователя по АВТОЛИСПу


ная функция не будет перекачена- только вычисливши  ее, можно сделать это.
Итак, если вы создаете функции и модифицируете их с хитростью, организуй-
те их как списки , вместо использования функции DEFUN, или используйте
трюк,приведенный выше, чтобы поместить их в память.
        Список символов, известных AutoLISPу, называется ATOMLIST. Есть
возможность хитрой программе манипулировать этим списком, чтобы исправить
пробел или сканировать все символы. ( Как отмечено в предыдущей главе,
это не стандартная особенность LISPа, и она может быть изменена в буду-
щих версиях AutoLISPа.) Когда функция откачивается , она преобра-
зуется в пути , это предполагает что ATOMLIST, не будет изменен до тех
пор, пока функция не откачается ( если разбиения памяти на страницы нет
на этом пути, функция занимает гораздо больше места на диске и идет в
пять раз медленней). Чтобы быть уверенным , что ATOMLIST не изменится,
когда листание действительно имеется, доступ к ATOMLISTу блокируется
перемещением ATOMLISTа из списка символов ,доступнх пользователю. Если
вы используете виртуальную функцию листания страниц, оставьте ATOMLIST
в покое.
       Если вы действительно хотите , чтобы у вас были неприятности,
вы можете это сделать. Вы можете создать свою собственную функцию,
включая таблицу страниц, из любой другой функции. Вы должны присвоить
ATOMLISTу собственную переменную и изменить ее после того , как AutoLISP
стартует для листания страниц. Вы можете даже придумать что-нибудь бо-
лее творческое и ужасное. Однако , такое поведение может быть отмщено
разрушением вашей программы; это не может повредить AutoLISPу или Auto-
CADу. Итак, если вы хотите нести потери, вперед.





                          Глава  7

                    СООБЩЕНИЯ ОБ ОШИБКАХ


       Ниже приведен список сообщений об ошибках, которые вы время от
времени увидите, когда вы пишете или выводите функции AutoLISPа. Если
функция "ERROR" определена не пользователем ("ERROR" связана с nil),
ошибка является стандартной акцией , тогда эти сообщения выводятся
на экран дисплея в виде:
       error: message
       ошибка:сообщение
следом за прослеженнй функцией. Если существует пользователь-определитель
функции "ERROR", эта функция , называемая сообщением, пройдет только в
качестве аргумента.



       Функции, отклоняемые AutoCADом

       Аргументы проходящих в AutoCAD функций недействительны ( таких,
       как функции  GETVAR "NOSUCH" или SETVAR с только читаемыми
       системными переменными), или функция, переходящая сама в себя,
       недействительна в текущем контексте.






                           - 91 -

            Руководство пользователя по АВТОЛИСПу


       bad argument type

       Функция снабжена некорректным типом аргумента.( Например, вы не
можете взять STRLEN как целое.)


       bad association list

       Список , объявленный функцией ASSOC, не состоит из "(нужная кла-
виша ) списков.


       bad entmod list

       Аргумент, проходящий в функцию ENTMOD,имеет неподходящий вход
списка данных (так же , как возвращаемый функцией ENTGET).


       bad formal argument list

       Когда вычислена эта функция, AutoLISP удалит список недействите-
льных формальных аргументов. Возможно, что функция вовсе не является
функцией , а в некоторой степени , список данных.


       bad function

       Первый элемент в списке -недействительное имя функции. Возможно,
что это имя переменной или число. Это сообщение также может показывать,
что названная функция неподходяще определена- не забывайте возвращаемый
список формальных аргументов.


       bad list

       Неподходяще организован список, которым снабжена функция. Это мо-
жет случиться , если действительное число начинает десятичная точка;
в таком случае вы должны использовать введение 0.


       Bad node ( плохой участок памяти node)

       Недействителен пункт , встречаемый функцией TYPE.


       bad node type in list

       Недействителен пункт , встречаемый функцией FOREACH.


       bad point argument

       Недостаточно определена точка ( список двух действительных чисел)
проходящая в функцию , ожидающую точку. Будьте внимательны, не начинайте
действительное число с десятичной точки; в таком случае, вы должны ис-
пользовать введение 0.




                           - 92 -

            Руководство пользователя по АВТОЛИСПу




        bad point value

        То же самое ,что выше.


        bool arg1 <0 or >15

        Первый аргумент функции BOOLE (Булева функция) должно быть це-
лое мажду 0 и 15.


       can't evaluate expression

       Эта ошибка может быть вызвана неправильным местоположением деся-
тичной точки и с другой стороны, недостаточно сформулированным выражени-
ем.


       console break

       Пользователь ввел CTRL C , в то время , когда функция обрабаты-
валась.


       divide by zero

       Деление на нуль не разрешается.


       extra right paren

       Встретились одни или более лишние правые скобки.


       file not open

       Описатель файла  для операции ввода-вывода (I/O) не такой , как
у доступного файла.


       Function cancelled ( снимаемая функция)

       Пользователь нажал CTRL C в ответ на подсказку.


       function undefined for argument

       Аргумента, обозначенного в функциях LOG или SQRT,нет в диапазоне.


       function undefined for real

       Аргумент функции вместо целого числа обозначен действительным.
Например, (LSH val 1.2)




                           - 93 -

            Руководство пользователя по АВТОЛИСПу




       improper argument

       Аргумент в GCD отрицательное число или ноль.


       incorrect number of arguments to a function

       Количество аргументов определяемой пользователем функции не соот-
ветствует количеству формальных аргументов, объявленных функцией DEFUN.


        insufficient node space

        Недостаточен участок памяти node , для того чтобы вместить потреб-
ные действия. См. главу 6.


       insufficient string space

       Недостаточен участок памяти heap , чтобы вместить строку текста.
См. главу 6.


       invalid argument

       Неправильный тип аргумента или аргумент вне диапазона.


       invalid character

       Выражение содержит неверный знак.


       invalid dotted pair

       Точечные пары-это списки, содержащие два элемента, разде-
ленные конструкцией "space-period-space". Вы можете получить это сооб-
щение об ошибке , если вы начинаете действительное число с десятичной
точки; в таком случае вы должны использовать введение 0.


       LISPSTACK overflow (переполнение стека )

       Стек AutoLISPа переполнен. Это происходит из-за чрезмерного
повторения функции или очень больших списков аргументов функции. Попы-
тайтесь увеличить среду LISPSTACK для переменных.


       misplaced dot

       Это может иметь место , если действительное число начинает деся-
тичная точка; в таком случае вы должны использовать введение 0 .






                           - 94 -

            Руководство пользователя по АВТОЛИСПу


       null function

       Была сделана попытка вычислить функцию , которая имеет нулевой
определитель.


       quit\ exit abort

       Это результат вызова функций QUIT или EXIT. Эти функции сейчас
не используются в AutoLISPе.


       too few argyments

       Слишком мало аргументов объявлено во встроенной функции


       too many arguments

       Слишком много аргументов объявлено во встроенной функции.


       unexpected signal nnn

       ( Только для системы UNIX) От работающей системы получен неожи-
данный сигнал.



