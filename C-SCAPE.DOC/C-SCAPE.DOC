                       Аннотация .


     Настоящий  документ  представляет  собой  методику  для
изучения и работы с высокоуровневым программным интерфейсом
C - scape . Интерфейс , благодаря разработанному в нем набору
специальных функций , создавать экран как объект и производить
с него ввод данных ; а также преобразовывать графическую ин-
формацию ( экранную ) в тексты С - программ.

     C - scape ориентирован на работу на ПЭВМ .

     Документ разработан при проведении НИР " Комплекс  " .
В документе приведено описание интерфейса  C - scape , его сис-
тем  Look & Feel  и Help , приведены тексты  " учебных " прог-
рамм и анализ этих программ .
В документе приведен текст и краткое описание программы прос-
мотра архива предприятия для ПЭВМ .

     1. Haзначение .

     C-scape мощный , гибкий и легкий в изучении инструмент для
управления пользовательским интерфейсом из  C - программ.
     C-scape предлагает вам несколько важных средств для проек-
тирования  и развития прикладных программ , требующих наличия вы-
сокоуровневого пользовательского  интерфейса в алфавитно-цифровом
режиме работы дисплея.
Основанный на функции С  printf, C-scape создает экран как объект,
в который осуществляется ввод. Язык описания меню позволяет:
     - адресовать экран ;
     - описывать поля ;
     - использовать функции проверки.
Специальные управляющие символы - аналоги   " % "  в языке  C
позволяют Вам определить позицию курсора и маски поля .
     C-scape включает в себя две составные части  -  библиотеки
функций  для транслятора MICROSOFT C 5.0 и QUICK C 2.0.



     2. Условия применения .

     C-scape объектно-ориентирован и согласован в применениях.
Все части  C - scape  разработаны для совместной работы . Это
помогает сделать его легким в обучении , изменении и поддержке.
Изменяя указатели  функций , используемых  полями , границами и
драйверами устройств , можно изменять выполняемые операции в
большинстве частей  C - scape .
     Программные единицы , входящие в состав C - scape , написа-
ны на инструментальном языке высокого уровня  Си .
     В состав математического обеспечения должны входить :
- Си - транслятор ;
- объем потребной оперативной памяти достаточная для работы транслятора;
- программы работают в операционной среде  MS DOS версии 3.0

     Программные единицы , входящие в состав высокоуровневого
пользовательского интерфейса  C - scape , ориентированы на их
использование при работе на  ПЭВМ типа  IBM PC/AT и могут быть
использованы при обработке информации на совместимых ПЭВМ без
доработок и изменений .

                             - 2 -

     3. Описание работы C - scape .

     Описание работы  C - scape дано в форме разбора и анализа
нескольких программ . Для овладения техникой работы с С -scape
достаточно их изучить .

     Главная сила  C - scape  в использовании его функций полей.
Функции полей - это функции , связанные с отдельными полями ;


-------------   они назначаются каждому полю.
Функции полей определяют :
     - тип данных , которые отображают поля ;
     - как данные вводятся/редактируются ;
     - как данные проверяются .
С тех пор как функции полей  начали определять  операции ввода ,
границы типов полей в C-scape стали неограниченны .
Обеспечены  все функции , необходимые для построения  функций
полей . C-scape содержит много различных функций полей . Вы мо-
жете использовать их или изменять применительно к вашему вкусу
и потребностям .

     C - scape  хорошо подходит для многих различных приложений .
Он использовался в широко  распространенных базах  данных , про-
граммах связи , справочных экранах , электронных таблицах , про-
граммах форматировния выходных документов .

     C - scape  обеспечивает ассортимент разнообразных видов ра-
мок для экрана от простого ограничителя до поименованных рамок с
выделением  выбора  и предупреждающими сообщениями .
     Пользователь может самостоятельно , пользуясь инструментари-
ем  C - scape , создать тип рамки .

     Функции  C - scape , зависящие от оборудования , содержатся
в структуре драйвера.
     Для использования  C - scape  на новой ПЭВМ или с новой опе-
рационной системой , все , что Вам необходимо изменить , находит-
ся в  этой структуре . Это помогает обеспечивать переносимость
программ , использующих  C - scape .

     Огромную помощь в разработке программ для  C-scape  может
принести использование   Разработчика Экранов  Look & Feel .
Экраны и интерактивные меню , генерируемые  Look & Feel ,  могут
быть прямо преобразованы в  C- код.  Это исключает необходимость
вводить коды для содержимого экрана и координаты для объектов в
окне .

     В процессе адаптации  интерфейса С - scape  ocуществлен пере-
вод системы help для  интерфейса  C - scape .
Использование  Look & Feel  в несколько раз ускоряет  разработку
объектов , высвечиваемых на экранах .






                             - 3 -

     3.1. Программа ввода с экрана простейших данных .

     Рассмотрим типичное применение  C - scape : ввод простейших
данных с экрана.  В эту программу включены функции программного
интерфейса C - scape ( Пример 1 ) . Дан подробный анализ исполь-
зуемых объектов , команд , функций C - scape .

           Рассмотрим исходные коды, необходимые для создания
           программы .

main()
{
    menu_type menu;
    sed_type  sed;
    char *name = "            ";

    menu = menu_Open();
    menu_Printf(menu, "Name: @@f[############]", name,
                &string_funcs);
    menu_Flush(menu);

    sed = sed_Open(menu);
    sed_Repaint(sed);
    sed_Go(sed);
    menu_Close(menu);
    sed_Close(sed);
}

     Объект menu
     -----------
     Объект  menu содержит структуру и формат экрана.
Размещение в menu определяется функцией   menu_Printf . После
определения menu  может быть создан  объект sed .

      Объект sed
      ----------
     Объект sed используется для отображения и активации дисплея.
Объект  sed ( Screen EDitor ) управляет активной информацией на
дисплее . Sed создается из Объекта menu . Объект menu может рас-
сматриваться как  " template "  для экрана и содержит всю стати-
ческую , предопределенную информацию для экрана .
     Может быть любое количество seds на дисплее.  Размер , цвет
и местоположение каждого sed могут изменяться .  Если размер sed
меньше чем  menu , из которого он создается , возможна автомати-
ческая прокрутка.
Sed создается по командe sed_Open .

     string_funcs
     ------------
      Каждое поле ограничивается своей функцией поля. Функция поля
вызывается , когда поле активируется.  Функция поля управляет опе-
рациями ввода включающими ввод , редактирование, проверку правиль-
сти и запись в поле данных.




                             - 4 -

     Библиотека  C - scape  поставляется  с  семейством  функций ,
поддерживающим много стандартных типов полей . Можно изменить эти
типы функций для создания новых типов полей , уникальных для Ваших
прикладных программ.
В этом случае работает функция поля   string_funcs .  string_funcs
позволяет пользователю вводить и редактировать строки и возвращает
результат в переменную поля.

     menu_Open
     ---------
     Команда  menu_Open  создает новый объект menu. После создания
объекта menu можно задавать расположение вашего экрана,  используя
функцию  menu_Printf.

     menu_Printf
     -----------
     Команда  menu_Printf  является сердцем C-scape. Она использу-
ется для определения расположения экрана . Оно запоминается в
объекте menu .
     Команда  menu_Printf  включает операции , подобные  операциям
команды  printf  и поддерживает все ее составляющие  %% .  Это по-
лезно при создании экранов из данных , запоминаемых в файле.
     В дополнение к обычным командам  %%  ,  menu_Printf поддержи-
вает дополнительный набор команд , использующих символ  @@ .
Эти команды включают :
     - выбор цвета;
     - расположения;
     - повтор строк;
     - определения поля.

В исходном тексте команда :

     menu_Printf(menu, "Name: @@f[############]", name,
                 &string_funcs);

определяет поле из 12 позиций с переменной  " name "  и соответ-
ствующей ей функцией поля  string_funcs .

     menu_Flush
     ----------
     Мenu_Flush  заканчивает определение объекта  menu .
menu_Flush сообщает C-scape о том , что Вы закончили выдачу зада-
ния на структуру и формат Вашего экрана.

     sed_Open
     --------
     Команда  sed_Open  создает объект  sed  из определенного
объекта  menu . Эта команда сообщает  C - scape о том , что вы
готовы создать версию вашего экрана , который можно будет ото-
бразить на экране дисплея.

     После открытия  sed  вы можете изменять его , используя
разные команды . Цвет , рвсположение , высота , ширина и тип
окантовки вашего экрана может быть изменен .



                             - 5 -

     sed_Repaint
     -----------
     Команда  sed_Repaint  рисует объект  sed  на экране.
     Используйте эту функцию  при необходимости отобразить ваш
экран.

     sed_Go
     ------
     Команда  sed_Go  активирует обЪект  sed .  При вызове этой
функции программы управления подключают функции полей , связанные
с экраном . Пользователь может теперь вводить и редактировать .
Функция  sed_Go  возвращает значения при окончании ввода данных .

     menu_Close
     ----------
     Команда  menu_Close  уничтожают объект  menu  и освобождает
всю память , используемую им.

     sed_Close
     ---------
     Команда  sed_Close  уничтожают объект  sed  и освобождает
всю память , испольуемую им.














     4. Look & Feel Редактор экранов  высокоуровневого
          интерфейса  C - scape .

--------------------------------------------------------------

     Если Вы используете  Look & Feel  с адаптером CGA и моно-
хромным  монитором при вызове  LNF  задавайтe параметр  - m .

Например :

     lnf -m sample

---------------------------------------------------------------








                             - 6 -


     4.1. Начальные сведения .

     4.1.1.  Введение .

     Look & Feel  ( tm )  Р е д а к т о р  Э к р а н о в , помо-
гающий программистам создавать экраны  для своих программ очень
эффективно с последующим получением текстов на языке  С , с ис-
пользованием  C - scape .  Look & Feel может использоваться для
создания :
 - экранов  ввода ;
 - экранов меню ;
 - отображаемых экранов .
Каждый из них может быть больще , чем экран дисплея  80 х 25 ,
так как  Look & Feel  и  C - scape  поддерживают вертикальную
и горизонтальную прогрутку .

     Look & Feel -  визуально ориентированный редактор экранов.
Экраны могут рисоваться в свободной манере и отображаются таким
способом ,что в результате может быть получена программа .

     В редакторе доступны все обычные функции  для  редактора ,
такие как :
 - cut  - удаление блока текста ;
 - pastе - вставка блока текста ;
 - move  - перемещение блока текста .

     Дополнительно для разработки экранов добавлены такие сред-
ства , как :
 - определение полей ;
 - редактирование полей ;
 - рисование линий .

     Окончательный экран может быть сохранен на диске для после-
дующего использования  в формате  LNF  или преобразован  в текст
на языке C .


     4.1.2.  Установка  Look & Feel .

     Установка  Look & Feel  заключается  в копировании файлов
LNF.EXE, LNF.CFG и LNF.HLP на Ваш рабочий диск .

Файл  LNF.CFG  содержит информацию о конфигурации для программы
Look & Feel .
Файл  LNF.HLP  содержит  help , используемый редактором экранов
и переведенный на русский язык .










                             - 7 -

     4.1.3. Пример работы  Look & Feel .

Look & Feel  позволяет создавать  экраны быстро и легко .

     Старт программы  - набор  LNF  из  DOS .

Высветится  экран заставки . Нажмите любую клавишу для начала
редактирования .  Расположение курсора управляется клавишами
управления курсором.

     Наберите обычное поле , например :

     Name:  ##########

где символы # определяют область ввода данных .

     Установите курсор на начало или конец поля ( символ 'N'
или последний символ '#' ) .

Нажмите < F10 > для выбора меню MAIN .
Выберете FIELD из меню MAIN .
Выберите MARK из меню FIELD .
Вокруг курсора появится рамка.  Перемещайте рамку до тех пор ,
пока она полностью не окружит поле .
Нажмите < ENTER > .
Вам высветится  экран задания данных  FIELD DATA .
Нажмите клавишу < Серый + > для вызова появляющегося  списка
типов функций , выберете необходимый тип функции , подведете к
нему курсор , и , выбрав  "string_funcs" , нажмите < ENTER > .
Перейдите к "variable"  экрана FIELD DATA , наберите имя пере-
менной  " name "  и нажмите  < ENTER > .
Нажмите  < ENTER > еще раз для сохранения информации  и  экран
FIELD DATA исчезнет .

Нажмите < F10 > снова и выберите  DISK  из меню MAIN .  Сохра-
ните экран выбором        из меню DISK .

Выберите CONVERT из меню DISK  и Вы получите меню  CONVERT .
Ответьте "YES"  для  " Generate test code " .
Нажмите < ENTER > (вы не обязаны изменять  любую другую инфор-
мацию ) .
Нажмите < ENTER > снова и  Look & Feel  создаст текст прог-
раммы на  C - code и возвратится в режим рисования.

Покиньте LNF , нажав < ESC > .  Откомпилируйте и соберите текст
"SAMPLE.C".
Вы получите выполняемую программу.










                             - 8 -


     4.1.4  Текст программы .

/*   SAMPLE.C  generated by Look & Feel version 1.02   */

#include <stdio.h>
#include <cscape.h>

int sample(name)
     char *name;
{
     menu_type menu;
     sed_type  sed;
     int       ret;

     menu = menu_Open();

     menu_Printf(menu, "@p[0,0]@c[\x07]╔@[53,═]╗");
     menu_Printf(menu, "@p[1,0]║");
     menu_Printf(menu, "@p[1,54]║");
     menu_Printf(menu, "@p[2,0]║");
     menu_Printf(menu, "@p[2,13]┌@[26,─]┐");
     menu_Printf(menu, "@p[2,54]║");
     menu_Printf(menu, "@p[3,0]║");
     menu_Printf(menu, "@p[3,13]│ This is a sample screen  │");
     menu_Printf(menu, "@p[3,54]║");
     menu_Printf(menu, "@p[4,0]║");
     menu_Printf(menu, "@p[4,13]│");
     menu_Printf(menu, "@p[4,40]│");
     menu_Printf(menu, "@p[4,54]║");
     menu_Printf(menu, "@p[5,0]║");
     menu_Printf(menu, "@p[5,13]│");
     menu_Printf(menu, "@p[5,40]│");
     menu_Printf(menu, "@p[5,54]║");
     menu_Printf(menu, "@p[6,0]║");
     menu_Printf(menu, "@p[6,13]│");
     menu_Printf(menu, "@p[6,40]│");
     menu_Printf(menu, "@p[6,54]║");
     menu_Printf(menu, "@p[7,0]║");
     menu_Printf(menu, "@p[7,13]│");
     menu_Printf(menu, "@p[7,40]│");
     menu_Printf(menu, "@p[7,54]║");
     menu_Printf(menu, "@p[8,0]║");
     menu_Printf(menu, "@p[8,13]│");
     menu_Printf(menu, "@p[8,40]│");
     menu_Printf(menu, "@p[8,54]║");
     menu_Printf(menu, "@p[9,0]║");
     menu_Printf(menu, "@p[9,13]│");
     menu_Printf(menu, "@p[9,40]│");
     menu_Printf(menu, "@p[9,54]║");
     menu_Printf(menu, "@p[10,0]║");
     menu_Printf(menu, "@p[10,13]└@[26,─]┘");
     menu_Printf(menu, "@p[10,54]║");
     menu_Printf(menu, "@p[11,0]║");
     menu_Printf(menu, "@p[11,54]║");
     menu_Printf(menu, "@p[12,0]║");

                             - 9 -
     menu_Printf(menu, "@p[12,54]║");
     menu_Printf(menu, "@p[13,0]║");
     menu_Printf(menu, "@p[13,54]║");
     menu_Printf(menu, "@p[14,0]║");
     menu_Printf(menu, "@p[14,54]║");
     menu_Printf(menu, "@p[15,0]║");
     menu_Printf(menu, "@p[15,54]║");
     menu_Printf(menu, "@p[16,0]║");
     menu_Printf(menu, "@p[16,54]║");
     menu_Printf(menu, "@p[17,0]║");
     menu_Printf(menu, "@p[17,54]║");
     menu_Printf(menu, "@p[18,0]╚@[53,═]╝");
     menu_Printf(menu, "@p[6,15]@f[Name :  @[12,#]]",
       name, &string_funcs);
     menu_Flush(menu);
     sed = sed_Open(menu);
     sed_SetColors(sed, '\x07', '\x07', '\x70');
     sed_SetPosition(sed, 4, 8);
     sed_Push(sed);
     sed_Repaint(sed);
     ret = sed_Go(sed);
     sed_Pop(sed);
     menu_Close(menu);
     sed_Close(sed);
     return(ret);
}

     4.2.  Базовые операции .

     4.2.1. Функциональные клавиши .

  F1  Help.
  F9  Текущее состояние.
  F10 Главное меню.

     4.2.2. Режим Рисования.

    В этом режиме возможно вводить символы.
Клавиши перемещения курсора  :

Down Arrow:    Перемещение курсора на одну строку вниз.
Ctrl End:      Перемещение экрана в правый дальний конец.
Ctrl Home:     Перемещение экрана в левый дальний конец.
Ctrl PgDn:     Перемещение экрана в конец.
Ctrl PgUp:     Перемещение экрана в начало.
Enter:         Перемещение курсора в крайнюю левую позицию сле-
               дующей линии .
End:           Перемещение курсора в наибольшую правую колонку
               дисплея.
Tab:           Перемещение курсора вперед на следующую табуляцию.
Home:          Перемещение курсора в наибольшую левуюю колонку
               дисплея.
PgDn:          Перемещение экрана ниже на одну страницу.
PgUp:          Перемещение экрана назад на одну страницу.
Shift Tab:     Перемещение курсора назад на предыдущую табуляцию.
Up arrow:      Перемещение курсора на одну строку вверх.
BackSpace:     Воссстановление предыдущего экрана.

                             - 10 -


    Размер экрана : 100 столбцов и 100 строк. Нажатие < F9 > в
любой момент времени  покажет положение курсора в абсолютных
координатах.

     4.2.3. Cтруктура команд .

     Различные команды   Look & Feel  вызываются из системы меню.
Меню MAIN вызывается нажатием клавиши < F10 > .  Текущий выбор
отображается высвечиванием строки .  Для выбора нажмите клавишу
< ENTER > . Для выхода в предыдущее меню нажмите < ESC > .

Клавиши Меню :

Down Arrow:    Высветить предыдущий выбор в меню.
Enter:         Выбрать высвеченный выбор.
End:           Высветить последний выбор в меню.
Escape:        Выход в меню.  Возврат в предыдущее меню.
Home:          Высветить первый выбор в меню.
Up arrow:      Высветить следующий выбор в меню.


     Некоторые выборы вызыват дополнительные меню .  Эти меню
работают так же . Некоторые часто используемые команды могут
быть вызваны использованием быстрой последовательности клавиш ,
которая включает в себя одновременное нажатие клавиши
< Control >  и буквы .

Быстрые клавиши :

Ctrl A:  Изменение  attribute текущего отмеченного блока.
Ctrl C:  Выбор специального cимвола из списка.
Ctrl E:  Выбрать и  редактировать поле.
Ctrl F:  Отметить и определить поле.
Ctrl L:  Вход в режим рисования линий .
Ctrl M:  Отметить блок.
Ctrl P:  Вставить предыдущий отмеченный блок.
Ctrl S:  Сохранить экран в файле.

     4.2.4.  Ввод данных .

     Многие меню выдают экраны ввода данных . Работа со всеми
такими экранами организована единообразно. Обычно экран в режиме
выбора . В этом режиме перемещение между полями осуществляется
клавишами управления курсором .

Нажимая любую из клавиш алфавита  или клавишу  < пробел >  ,
переходим в режим редактирования . В этом режиме вокруг поля по-
является рамка, а в самом поле производятся изменения . При на-
жатии < ESC > поле востанавливается в предыдущее состояние . При
нажатии клавиш < ENTER > , < UP ARROW > или < DOWN ARROW > осу-
ществляется выход из режима редактирования .
При нажатии < ESC > в режиме выбора экран возвращается в предыду-
щее состояние.
При нажатии < ENTER > в режиме выбора данные запоминаются .


                             - 11 -
В некоторых полях клавиша  < Серый + >  ( часть цифровой клавиа-
туры ) может использоваться для выдачи появляющегося списка воз-
можных выборов . Выбор в нем осуществляется так же , как и в меню.



     4.2.5. Режим  Help .

     В любой момент можно отобразить  help  нажатием функциональ-
ной клавиши < F1 > .
Для возврата клавиша < ESC > .
Между разными экранами возможны переходы .
При нажатии  < BACKSPACE >  цепь выбором проходится в обратном
порядке.

     4.2.6. Состояние

     Нажимая  < F9 > мы отображаем :
 - местоположение текущегo экрана ;
 - текущее имя файла ;
 - расположение курсора ;
 - текущий режим .
Для возврата в нормальный  режим нажмите оодну из клавиш
< ESC > , < ENTER > или < F9 > .


     4.2.7. Режим Set Up .

     Выбрать режим Set Up  из Главного Меню .

Меню Set Up содержит общую информацию поведения:

Normal              Атрибут , назначаемый всем символам.
Regular Fields      Атрибут , назначаемый всем полям.
Selected Fields     Атрибут , назначаемый всем выделенным полям
                    когда поле выбрано для редактирования

Tab size            Tабуляции осуществляются умножением на это
                    значение , начиная с крайнего левого положения
                    на экране.

Margin              Левая граница - колонка , в которую помещается
                    курсор после нажатия  < Enter > в режиме рисо-
                    вания.

Cursor Direction    Нажатие может осуществляться в любом направле-
                    нии . Клавиша < Gray + > отображает список воз-
                    можных выборов.










                             - 12 -

    4.3. Команда Disk .

     Команда  Disk  используется для :
 - сохранения экранов ;
 - загрузки старых экранов ;
 - преобразования экранов в программы на C .

     4.3.1.  Coхранение файла .



Выбрать Disk из       Главного Меню
Выбрать Save из       Меню Disk
Или Набрать  < Control > < S > .

     В меню  Save  Вы можете :
     Редактировать текущее оглавление . Клавиша < пробел > -
для редактирования, любая другая  клавиша - для перезаписи .
     Редактировать текущее имя файла . Используйте  клавишу
< Серый + > для появляющегося списка с текущим оглавлением
файлов   .LNF .

     4.3.2.  Загрузка файла .

Выбрать Disk из       Главного Меню
Выбрать Load из       Меню Disk

     При выборе меню  Загрузка файла  можно :
     Редактировать текущее оглавление . Клавиша < пробел > -
для редактирования , любая другая клавиша - для перезаписи.
     Редактировать текущее имя файла.Используйте клавишу
< Серый + > для появляющегося списка с текущим оглавлением
файлов  .LNF .
     Редактировать текущий тип файла . Клавиша < Серый + > вы-
дает в список выборов .



     4.3.3.  Конвертирование файла .

Выбрать Disk из       Главного Меню
Выбрать Convert из    Меню Disk

     Convert получает  C - коды , отображающие экран и управля-
ющие вводом .

Меню преобразования данных содержит:

Directory      Оглавление , в которое записывается  C - код.
File Name      Имя файла , в который записывается  С - код.
                                                    < Серый + >
Function Name  Имя генерируемой функции  C .
Border Func    Функция бордюра  С - scape  , подключаемого
               к экрану .                            < Optional>
BGround Color  Основной цвет вашего экрана .         < Gray + >
Label          Значение метки , используемой системой  help

                             - 13 -
               C - scape .                           < Optional>
Height         Bысота экрана.                        < Optional>
Width          Ширина экрана.                        < Optional>
Relative Pos   " NO " -  для aбсолютных координат, " YES  "
               для координат , относительных для левого наиболь-
               шего символа экрана.
Quote n-Print  " Yes " размещает ' x\NN ' вместо специальных
               графических символов в генерируемом  С - коде.
Gen Test Code  " YES " генерирует  MAIN  , вызывающую экранную
               функцию.

     4.4.  Рисование линий .

Выбрать Line из      Главного Меню
Или используйте < Control > < L >

Нажмите < 0 > - для перемещения курсора без рисования .
Нажмите < 1 > -  для рисования одиночной линией.
Нажмите < Press > < 2 > - для рисования двойной линией.
Нажмите < Press > < 3 > - для рисования cимволом ,отме-
ченным курсором.

Нажмите < Backspace > - для восстановления.

Нажмите < ESC > или < Enter > - для окончания режима линии.


     5. Методика разработки программ

   Наиболее быстрая отдача при использовании  C - scape при активном
использовании Look & Feel для разработки экранов .

     5.1  Описания некоторых объектов C - scape.

    При  создании  программ  с  использованием  библиотеки  C-scape
используются некоторые объекты описанные в разных включаемых файлах.

    В     menudecl.h  описан  объект типа menu_type.

typedef struct menu_struct {

     /* immutable данные меню */
int  fieldcount;         /* количество полей */
int  rowcount;           /* количество строк      */
int  colcount;      /* количество колонок    */
xarray    fa;            /* xarray полей          */
xarray    fgrid;              /* массив строк полей    */
tb_type textbuf;         /* буфер текста          */
unsigned  flushed:1;     /* flushed флаг          */
char      *data;              /* указатель на создаваемые данные */
     /* информация для создания меню функцией menu_Printf */
int  mp_count;      /* число обращений к menu_Printf
                       (для сообщений об ошибке) */
int  row, col;      /* текущее местоположение     */
char color;              /* текущий цвет     */
char      old_color;          /* предыдущий используемый цвет    */
     } *menu_type;

                             - 14 -

     seddecl.h


/** the border type **/
typedef struct bord_struct {
int  (*bd_func)();  /* функция border  */
int  xmin, ymin, xmax, ymax;       /* углы границ */
                         /* относительно sed */
char color;         /* цвет границ */
char *data;         /* hold any border data here */
} *bord_type;

/* The screen editor type. */
typedef struct sed_struct {
     /** state information **/
int             fieldno, fieldpos;
int       row, col;
int       yoffset;
int       xoffset;
unsigned  exit_toggle:1;
unsigned       active:1;

     /** cursor control information **/
int       cur_row, cur_col, cur_type;



     /** permanent information **/
menu_type       menu;
int            fieldcount;

     /** display information: nВe mdisplay **/
int       xmin, ymin, xmax, ymax;  /* Window coordinates */
char           back, fore, high;        /* Colors   */
bord_type border;             /* border data */

     /** misc. information **/
int       baton;              /* the baton */
int       label;              /* numeric label (for help) */
char      *data;              /* generic data pointer */
} *sed_type;


/* Rep Invariants:
     field number and field position should always be in range (according to
     menu).
     field number should always be less than or equal to maxfieldno.
*/









                             - 15 -

   В helpdecl.h описаны следующие объекты

/** структура help  **/

typedef struct help_struct {

int  msg;     /* текущее сообщение   */
int  chap;         /* текущий раздел      */
int  par;     /* текущий параграф    */
int  high_msg;   /* highest accessed message */
FILE *fp;     /* help файл       */
larray    offset;       /* larray ссылок в файле help  */
unsigned int size;  /* размер текста       */
char *text;        /* буфер текста сообщения */
char title[HELPLINE+3];  /* наименование сообщения */
int  **index;    /* индекс сообщения    */
int  chap_count; /* количество разделов */
int  par_count;  /* количество параграфов*/
int  (*disp)();  /* функция отображения  */
char    *data ;     /* указатель на данные help */

} *help_type;

/* Дополнительные структуры данных */

struct hv_struct {  /* используется help_View */
int  row; /* строка места  help окна */
int  col; /* столбец места help окна */
int  height;   /* высота  help окна       */
int  width;    /* ширина   help окна      */
char      color;    /* цвет     help окна      */
int  (*border)();   /* функция границы help окна */
};

struct hx_struct {  /* используется  help_Xref */
char bk_clr;   /* цвет фона help оккна  */
char      reg_clr;/* цвет выборов     */
char sel_clr;/* цвет выброанного выбора */
char bd_clr;   /* цвет границы help окна  */
int  (*border)();   /* функция границы help окна */
};

     В    framer.h  описаны объекты создаваемые для высокоуровневого
фрейм ориентированного меню.

struct frame_def {
char *choice;
int  (*frame_func)();    /*  frame функция */
int  value;
};
typedef struct frame_struct {
sed_type  top_sed;
sed_type  *pop_sed;
int       pop_count;     /* tколичество   pop_seds */
char           *data;         /* данные пердаваемые функции */
} *frame_type;

                             - 16 -


   В  slug.h
*/
/* the slug type */
struct slug_list {
char      *choice;
char      *message;
struct    slug_list *child;
int       (*slug_func)();               /* the slug function */
int       value;
};

typedef struct slug_struct {
sed_type       top_sed;
struct slug_struct  **child;
sed_type       *message;      /* the messages */
int            child_count;        /* the number of children */
int            row, col;      /* the position */
int            dir;           /* the direction */
char           *data;              /* data for user functions */
char           bk_clr;
char           sel_clr;
} *slug_type;


     6. HELP - система высокоуровневого интерфейса C - scape .
     C - scape  имеет мощную , контекстно зависимую  help - сис-
тему .  Help - система  позволяет отображать сообщения при необ-
ходимости . Вы  можете вызывать  различные help - сообщения для
каждого зкрана или даже для каждого поля или их комбинации.
Вы можете легко приспособить функции , используемые для отобра-
жения help - сообщений для просмотра в любых программах.
    С help системой используются две функции help_Xref и help_View.
Используя help_Xref легко написать систему использующую help при
обращении по F1. А с помощью help_View организовать просмотр набора
данных.

     6.1. Программа просмотра на экране архива предприятия .


     В рамках освоения  S - scape  c использованием  help-cис-
темы была разработана пнрограмма просмотра содержания  архива
предприятия.Для разработки экрана использовался  Look & Feel .


     6.1.1 Текст программы .

     Программа просмотра содержания архива  предприятия .


#include <stdio.h>


#include <csc.h>
#include <helpdecl.h>


                             - 17 -
struct hx_struct hxd = { '\x07', '\x0f', '\x70', '\x07',bd_xref};
void main()
{
     FILE *fp;
     char      string[25];
     string[0] = '\0';
     fp = fopen("apx.hlp", "rb");
     if (fp == NULL) {
        Pop_Prompt("Unable to open help file.\n", -1, -1, -1, 26,
                  (char) '\x70', bd_2);
          return;
     }
     help_Init(fp, help_Xref, 6000, (char *) &hxd);
     apx();
     fclose(fp);
}
int apx()
{
     menu_type       menu;
     sed_type        sed;
     int             ret;

     menu = menu_Open();
     menu_Printf(menu, "@p[0,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[1,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[2,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[3,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[3,15]@c[\x02]@[39, ]");
     menu_Printf(menu, "@p[3,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[4,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[4,15]@c[\x02]╔@[37,═]╗");
     menu_Printf(menu, "@p[4,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[5,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[5,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[5,17]@c[\x05]@[35, ]");
     menu_Printf(menu, "@p[5,52]@c[\x02] ║");
     menu_Printf(menu, "@p[5,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[6,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[6,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[6,17]@c[\x05]@[35, ]");
     menu_Printf(menu, "@p[6,52]@c[\x02] ║");
     menu_Printf(menu, "@p[6,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[7,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[7,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[7,17]@c[\x05]    Просмотр файла с
                    информацией   ");
     menu_Printf(menu, "@p[7,52]@c[\x02] ║");
     menu_Printf(menu, "@p[7,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[8,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[8,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[8,17]@c[\x05]@[16, ]по@[17, ]");
     menu_Printf(menu, "@p[8,52]@c[\x02] ║");
     menu_Printf(menu, "@p[8,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[9,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[9,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[9,17]@c[\x05]@[35, ]");
     menu_Printf(menu, "@p[9,52]@c[\x02] ║");

                             - 18 -
     menu_Printf(menu, "@p[9,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[10,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[10,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[10,17]@c[\x05]@[9, ]К А Т А Л О
                    Г У@[11, ]");
     menu_Printf(menu, "@p[10,52]@c[\x02] ║");


     menu_Printf(menu, "@p[10,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[11,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[11,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[11,17]@c[\x05]@[35, ]");
     menu_Printf(menu, "@p[11,52]@c[\x02] ║");
     menu_Printf(menu, "@p[11,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[12,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[12,15]@c[\x02]║ ");
     menu_Printf(menu, "@p[12,17]@c[\x05]    архива      ");
     menu_Printf(menu, "@p[12,33]@c[\x07]@[16, ]");
     menu_Printf(menu, "@p[12,49]@c[\x05]   ");
     menu_Printf(menu, "@p[12,52]@c[\x02] ║");
     menu_Printf(menu, "@p[12,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[13,0]@c[\x07]@[15, ]");
     menu_Printf(menu, "@p[13,15]@c[\x02]╚@[37,═]╝");
     menu_Printf(menu, "@p[13,54]@c[\x07]@[46, ]");
     menu_Printf(menu, "@p[14,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[15,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[16,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[17,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[18,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[19,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[20,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[21,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[22,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[23,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[24,0]@c[\x07]@[100, ]");
     menu_Printf(menu, "@p[22,4]F1 - Просмотр , ESC - Выход");
     menu_Printf(menu, "@p[12,33]@f[  Н И И Х С М   ]",
       NULL, &int_funcs);

     menu_Flush(menu);
     sed = sed_Open(menu);
     sed_SetColors(sed, '\x04', '\x04', '\x70');
     sed_SetBorder(sed, bd_plain);
     sed_SetPosition(sed, 0, 0);
     sed_SetHeight(sed, 23);
     sed_SetWidth(sed, 70);
     sed_SetLabel(sed, 1); /* вызов страницы help
                                 с номером 1 */
     sed_Push(sed);
     sed_Repaint(sed);
     ret = sed_Go(sed);
     sed_Pop(sed);
     menu_Close(menu);
     sed_Close(sed);
     return(ret);
}


                             - 19 -

     6.1.2 Входные и выходные данные .


     Для этой программы при помощи любого из обычных  редакторов
текстов подготавливается   набор данных apx.hlp .

    Обращение к  help - системе  осуществляется нажатием кла-
виши  < F1 > . В наборе  help - cистемы  имеются номера страниц
(например .1) , а также описываются перекрестные ссылки , позво-
ляющие , не выходя из  help - системы , переходить к другой вы-
свечиваемой странице . Такие ссылки выделяются в выдаваемом эк-
ране , переход между различными выборами осуществляется при по-
мощи клавиш  управления курсором .
В набираемом тексте такие выб оры подготавливаются в виде :

     @2[ Обозначения дискет]

     6.1.3. Пример двух страниц для  help - cистемы .

Архив программных средств для ПЭВМ   НИИХСМ

Для @2[ Обозначения дискет] придумана специальная классификация

Для @3[ Хранения дискет ] используются упаковочные коробки

    @20[Описание программных продуктов]

Обозначение дискет :

В наименование дискеты включены три составляющие :
 "тип разметки"  " тип информации"  и " номер дискеты"

  тип разметки      01   -   720 кБ
                    02   -   2 х 360 кБ

  тип информации    P    Программные продукты не в фирменной
                         поставке
                    I    Фирменная поставка хранение инсталяций
                    D    Документация

  номер дискеты    Последовательные номера дискет


@1[Возврат в описание архива].

     6.2  Пример  использования функций help_View.

#include <stdio.h>
#include <stdlib.h>
#include <cscape.h>
#include <popdecl.h>
#include <helpdecl.h>
#include <csdemo.h>
#define  FILESIZE   9000 /* maximum file size */
#define  TAB        4    /* size of expanded tabs */


                             - 20 -
static char *source_list[] = {     "csborder.c",  "csdata.c",
     "csdemo.c","csmenu.c","cssource.c",NULL};

int source(sdata, idata)
     char *sdata;
     int idata;
/*  Выдача списка исходных файлов , и их отображение .*/
{
     FILE *fp;
     int x;
     if ((x = pop_Menu(SOURCELIST_MSG, source_list, -1, -1, -1,
                    30, '\x31', 7, bd_title)) == 0) {
          return(0);
     }
     x--;
     /* open source file */
     if ((fp = fopen(source_list[x], "r")) == NULL) {
          pop_Prompt(NOSOURCE_MSG, -1, -1, -1, -1, '\x31', bd_2);
          return(0);
     }
     view_file(source_list[x], fp);
     fclose(fp);
     return(0);
}

boolean view_file(fname, fp)


     char *fname;
     FILE *fp;
/* Отображение файла в рамках просмотра. Символы табуляции учитываются
     returns TRUE if successful, FALSE otherwise.*/
{
     char *text, *q;
     int spaces, col, c;
     if ((text = (char *) malloc(FILESIZE + 50)) == NULL) {
          pop_Prompt(NOMEM_MSG, -1, -1, -1, -1, '\x31', bd_2);
          return(FALSE);
     }
     pop_Message(WAIT_MSG, -1, -1, -1, -1, '\x31', bd_2);
     /* read the file, expanding the tabs */
     for(q = text, col = 0;(c = getc(fp)) != EOF && (q - text) < FILESIZE;) {
     f (c == '\t') {
          for (spaces = (TAB - (col % TAB)); spaces > 0; spaces--) {
               *q++ = ' ';
               col++;
          }
     }
          else if (c == '\n') {
               *q++ = (char) c;
               col = 0;
          }
          else {
               *q++ = (char) c;
               col++;
          }
     }

                             - 21 -
     *q = '\0';
     pop_Message(NULL, -1, -1, -1, -1, '\x31', bd_2);
     pop_View(fname, text, -1, -1, vid_GetHeight() - 5, vid_GetWidth() - 10, '\x13', 6, bd_title);
     free(text);
     return(TRUE);
}/*******/

int cs_info(sdata, idata)
     char *sdata;
     int idata;
/* Получение информации о C-scape  */
{
     FILE *fp;
     /* open function list file */
     if ((fp = fopen("csfuncs.txt", "r")) == NULL) {
          pop_Prompt(NOFUNCS_MSG, -1, -1, -1, -1, '\x31', bd_2);
          return(0);
     }
     view_file(FUNCLIST_MSG, fp);
     fclose(fp);
     return(0);
}/*******/

int cs_order(sdata, idata)
     char *sdata;
     int idata;
/*   Gives ordering information about C-scape*/
{
     pop_Prompt(ORDER_MSG, -1, -1, 12, 78, '\x31', bd_2);
     return(0);
}/*******/

int cs_intro(sdata, idata)
     char *sdata;
     int idata;
/*   Gives an introduction to C-scape using the help system */
{


     help_Show(9, 0);
     return(0);
}/*******/

int cs_sample(sdata, idata)
     char *sdata;
     int idata;
/*   Demonstrates a sample C-scape use using the help system */
{
     help_Show(10, 0);
     return(0);
}







                             - 22 -

     7. Примеры встроенных функций  C - scape .

      В составе С-scape множество функций . В первоисточнике
документация на них составляет 500 страниц . Далее приведен
список этих функций.
     Необходимо отметить , что для использования  C - scape
достаточно приведенных примеров .

     C - scape также содержит несколько высокоуровневых функций,
встроенных в ядро  C - scape .
     Эти подпрограммы содержат различные системы меню :
 - pulldown - меню ;
 - popup - меню ;
 - вложенное меню ;
 - предупреждения и сообшения.


     ПРИМЕРЫ :  меню C - scape .

Popup      Перемещаемый в  появляющемся окне набор выборов.

Pulldown   Серия меню , опускающихся от верхнего края дисплея
           при выборе определенного имени

123        Меню , подобное используемому в Lotus-123

Slug       Меню , используемое разработчиком экранов Look & Feel.



     7.1. Пример использования slug - системы .

     Рассмотрим пример использования  slug - системы . В примере у
пользователя запрашивается заказываемый тип меню :
 - вертикальный (как в  Look & Feel ) ;
 - горизонтальный .
Все выборы в меню вызывают функцию empty.

#include <stdio.h>
#include <cscape.h>
#include <popdecl.h>
#include <slug.h>
int empty(char *, int);
struct slug_list dbv_menu[] = {    /* note: values must be positive */
{" Insert ", "Insert a record",    NULL, empty, 20 },
{" Delete ", "Delete a record",    NULL, empty, 23 },
{" Next ",     "Display next record",   NULL, empty, 24 },
{" Previous ", "Display previous record",NULL, empty, 25 },
{" Locate ", "Locate record",      NULL, empty, 26 },
{" Sort ",     "Sort records",     NULL, empty, 27 },
{" Output ", "List data records", NULL, empty, 28 },
{" Quit ", "Exit to DOS",NULL, empty, 29 },
{  NULL, "Block Menu", NULL, NULL,   0 }


};

                             - 23 -

struct slug_list block_menu[] = {
{" Copy ",   "Copy block to buffer",NULL, empty, 22 },
{" Delete , "Delete block", NULL, empty, 23 },
{" Move ",   "Move block", NULL, empty, 25 },
{" Paste ",  "Paste buffer",NULL, empty, 26 },
{" Fill ",   "Fill block",NULL, empty, 27 },
{" Attribute ", "Colour block",    NULL, empty, 28 },
{" DataBase? ", "Access data base",dbv_menu, empty, 20 },
{ NULL, "Block Menu",    NULL, NULL,     0 }
};
#define   QUIT      6
struct slug_list main_menu[] = {
{" Block ","Block functions", block_menu,NULL,1},
{" Characters ","Character set", NULL,  empty,    2},
{" Disk ","Disk functions",   NULL,     empty,    4},
{" Erase ","Clear entire screen",NULL,  empty,    8},
{" Field ","Field functions", NULL,     empty,    3},
{" Lines ","Line drawing  (^L)", NULL,  empty,    7},
{" Set up ", "Set global data", NULL,   empty,    5},
{" Quit ","Leave the program",     NULL,     NULL,     0},
{   NULL, "Main Menu",  NULL,      NULL,          0}
};
/* list for pop_Menu */
static char *dir[] = {"Horizontal","Vertical",NULL};
void main()
{
     slug_type slug;
     int row, col;
     cls();
     switch (pop_Menu("Select menu direction", dir,
                   -1, -1, -1, -1, '\x70', 0, bd_title)) {
case 1:
     slug = slug_Open(main_menu,SLUG_HORIZONTAL, bd_123,
                    '\x07', '\x70', '\x07');
     row = 0;
     col = 0;  /* Paint the menu bar first */
     slug_Repaint(slug, row, col);
     break;
case 2:
     slug = slug_Open(main_menu, SLUG_VERTICAL, bd_std,
                          '\x70', '\x07', '\x70');
     row = 5;
     col = 20;
     break;
     default:
     return;
}
     slug_Go(slug, 0, row, col, NULL);
     slug_Close(slug);
}
int empty(sdata, idata)
     char *sdata;
     int idata;/*   A user supplied function...*/
{
     char msg[80];
     sprintf(msg, "This is message number %d\n", idata);

                             - 24 -
     pop_Prompt(msg, -1, -1, -1, -1, '\x70', bd_2);
     /* return 0 to return to menuing system */
     /* return positive value to exit menuing system */
     return(0);
}


     7.2. Пример использования  фрейм - системы .



     Другим примером является использование  фрейм - системы .

#include <stdio.h>
#include <cscape.h>
#include <popdecl.h>
#include <framer.h>

int empty(char *, int);
struct frame_def test_frame[] = {   /* note: values must be positive */
{ "Help!",     empty,  0},
{ "Help!",     empty,  1},
{ "The night before",    empty,  2},
{ "You've got to hide your love away",  empty,  3},
{ "I need you", empty,  4     },
{ "Another girl", empty,  5   },
{ "You're going to lose that girl",empty,  6 },
{ "Ticket to ride",      empty,  7 },
{ "Act naturally",  empty,  8 },
{ "It's only love",      empty,  9 },
{ "You like me too much", empty, 10 },
{ "Tell me what you see", empty, 11 },
{ "I've just seen a face", empty, 12 },
{ "Yesterday",      empty, 13 },
{ "Dizzy miss lizzie",   empty, 14 },
{ FRAME_END },
{ "Rubber Soul",empty, 20 },
{ "Drive my car",  empty, 21 },
{ "Norwegian wood",  empty, 22     },
{ "You won't see me", empty, 23 },
{ "Nowhere man",  empty, 24 },
{ "Think for yourself", empty, 25 },

{ "The word", empty, 26 },
{ "Michelle",  empty, 27 },
{ "What goes on", empty, 28   },
{ "Girl",  empty, 29     },
{ "I'm looking through you",       empty, 30 },
{ "In my life",  empty, 31    },
{ "Wait",  empty, 32     },
{ "If I needed someone", empty, 33      },
{ "Run for your life",  empty, 34  },
{ FRAME_END    },
{ "Revolver",  empty, 40 },
{ "Taxman",  empty, 41   },
{ "Eleanor rigby",  empty, 42 },
{ "I'm only sleeping",   empty, 43 },

                             - 25 -
{ "Love you to",  empty, 44   },
{ "Here, there and everywhere", empty, 45    },
{ "Yellow submarine",    empty, 46 },
{ "She said she said",  empty, 47  },
{ "Good day sunshine",  empty, 48  },
{ "And your bird can sing", empty, 49   },
{ "For no one",  empty, 50    },
{ "Doctor robert",  empty, 51 },
{ "I want to tell you",  empty, 52 },
{ "Got to get you into my life", empty, 53   },
{ "Tomorrow never knows",  empty, 54    },
{ FRAME_END },
{ "Sgt. Pepper's Lonely Hearts Club Band", empty, 60},
{ "Sgt. pepper's lonely hearts club band", empty, 61},
{ "With a little help from my friends",  empty, 62},
{ "Lucy in the sky with diamonds", empty, 63},
{ "Getting better",  empty, 64},
{ "Fixing a hole",  empty, 65},
{ "She's leaving home",  empty, 66},


{ "Being for the benefit of mr. kite",  empty, 67},
{ "Within you without you",  empty, 68  },
{ "When I'm sixty-four",  empty, 69},
{ "Lovely rita",  empty, 70},
{ "Good morning good morning",     empty, 71},
{ "Sgt. pepper's lonely hearts club band (reprise)",  empty,  72 },
{ "A day in the life", empty, 73 },
{ FRAME_END },
{ FRAME_END }
};

void main()
{
     frame_type     frame;
     int       ret;
     char           *a;
     cls();
     frame = frame_Open(test_frame, bd_1, '\x70', '\x07', '\x70');
     frame_Repaint(frame);
     /* get a keystroke */
     kb_Read();
     frame_Go(frame, (char) ' ', NULL);
     frame_Close(frame);
}
int empty(sdata, idata)
     char *sdata;
     int idata;/*   A user supplied function...*/
{
     char msg[80];
     sprintf(msg, "This is message number %d\n", idata);
     pop_Prompt(msg, -1, -1, -1, -1, '\x70', bd_2);
     /* return 0 to return to menuing system */
     /* return positive value to exit menuing system */
     return(0);
}


                             - 26 -

   Приложение 1 .

1.    Функция help_Xref .

      Для ясности работы с  help - cистемой  ниже представлена
функция  help_Xref :

#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <cscape.h>
#include <scancode.h>
#include <helpdecl.h>
#define RING_LEN    22    /* must be greater than 1 */
static int ringbuf[RING_LEN]; /* used to remember previous
                                               help screens */
static int top, bot;

void help_fkey(sed_type);
static struct field_funcs help_funcs = {
NULL_FPTR,
NULL_FPTR,
help_fkey,
NULL_FPTR,
NULL_FPTR
};

int help_Xref(h)
     help_type h;


/* Подпрограмма отображения перекрестных ссылок . Ищет специальные
ссылочные символы в тексте help . Синтаксис ссылки "@3[word]".
В этом случае высвечивается word и может быть осуществлен переход
к сообщению номер 3.  В тексте может быть сделано любое количество
ссылок . В тексте могут также встречаться регулярные команды
C-scape ( @[] @p[] @c) . Клавиша backspace используется для возврата
к предыдущему экрану. Для запоминания предыдущих буферов используется
кольцевой буфер.*/
{
     menu_type menu;
     static sed_type sed = NULL;
     int key;
     char *p, *q, hold;
     int mode, xref;
     int msg = -1;
     char bk_clr, reg_clr, sel_clr, bd_clr;
     int  (*border)();
     struct hx_struct *hx;
     hx = (struct hx_struct *) help_GetData(h);
     if (hx == NULL) {
          bk_clr =   NORMAL;
          reg_clr =  BOLD;
          sel_clr =  REVERSE;
          bd_clr =   NORMAL;
          border = bd_xref;

                             - 27 -
     }
     else {
          bk_clr =  hx->bk_clr;
          reg_clr = hx->reg_clr;
          sel_clr = hx->sel_clr;
          bd_clr =  hx->bd_clr;
          border =  hx->border;
     }
     vid_Push();
     vid_SetCursorType(CURSOR_NONE);
     /* initialize ring buffer */
     top = bot = 0;
while (msg != 0) {
     if ((menu = menu_Open()) == NULL) {
          break;
     }
     menu_Printf(menu, "@c[%c] @p[0]", bk_clr);
     /* search for cross-references */
     for (mode = 0,q=p=help_GetText(h); *p!= \0'; p++) {
     switch (mode) {
     case 0:
          if (*p == '@') {
               mode = 1;
          }
          break;
     case 1:
          if (*p=='@'||*p=='['||*p=='c'||*p== 'p') {
               mode = 0;
          }
          else {
               hold = *(p-1);
               *(p-1) = '\0';
               menu_Printf(menu, q);
               *(p-1) = hold;
               mode = 2;
               q = p;
          }
          break;
     case 2:
          if (*p == '[') {
               xref = atoi(q);


               q = p + 1;
               mode = 3;
          }
          break;
     case 3:
          if (*p == ']') {
               hold = *p;
               *p = '\0';
               menu_Printf(menu, "@f[%s]", (char *) xref,
                                    &help_funcs, q);
               *p = hold;
               q = p+1;
               mode = 0;
          }

                             - 28 -
          break;
     default:
          break;
               }
          }
          menu_Printf(menu, q);
          menu_Flush(menu);
          if ((sed = sed_Open(menu)) == NULL) {
               menu_Close(menu);
               break;
          }
          sed_SetColors(sed, reg_clr, bk_clr, sel_clr);
          sed_SetHeight(sed, vid_GetHeight() - 4);
          sed_SetWidth(sed, vid_GetWidth());
     if (border != NULL) {
          sed_SetBorder(sed, border);
          sed_SetBorderColor(sed, bd_clr);
          sed_SetBorderTitle(sed, help_GetTitle(h));
     }
     sed_SetPosition(sed, 0, 0);
     sed_Repaint(sed);
     sed_BorderPrompt(sed, "Press Esc to leave help,
                         Backspace for previous help screen.");
     if (sed_GetFieldCount(sed) > 0) {
          msg = sed_Go(sed);
     }
     else {
          while(TRUE){
               key = kb_Read();
               if (key == ESC) {
                    msg = 0;
                    break;
               }
               if (key == BACKSPACE) {
                    msg = -1;
                    break;
               }
          }
     }
     menu_Close(menu);
     sed_Close(sed);
     if (msg == -1) {/* look up previous screen */
          if (top != bot) {
               top=(top ==0) ? RING_LEN - 1:top-1;
               if (!help_LookUp(ringbuf[top])) {
                    break;
               }
          }
     }
     else if (msg > 0) { /* adjust ring buffer */
          ringbuf[top++] = help_GetMessage(h);
          top %= RING_LEN;


          if (top == bot) {
               bot++;
               bot %= RING_LEN;

                             - 29 -
          }
          if (!help_LookUp(msg)) {
               break;
          }
     }
     }
     vid_Pop();
     return(0);
}

static void help_fkey(sed)
     sed_type sed;
/*   fkey function for x-referenced help screen.
     toggle through choices, return xref.          */
{
     int scancode, letter, choice;

     switch(scancode = kb_Read()) {
     case ESC:
          sed_SetBaton(sed, 0);
          sed_ToggleExit(sed);
          break;
     case BACKSPACE:
          /* look up the previous message,if there is one */
          if (top != bot) {
               sed_SetBaton(sed, -1);
               sed_ToggleExit(sed);
          }
          break;
     case ENTER:
          /* get the xref value */
          sed_SetBaton(sed, (int) sed_GetCurrVar(sed));
          sed_ToggleExit(sed);
          break;
     case HOME:
          sed_GotoFirstField(sed);
          break;
     case END:
          sed_GotoLastField(sed);
          break;
     case UP:
          if (sed_UpField(sed) == SED_STUCK) {
               sed_GotoLastField(sed);
          }
          break;
     case DOWN:
          if (sed_DownField(sed) == SED_STUCK) {
               sed_GotoFirstField(sed);
          }
          break;
     case LEFT:
          if (sed_DecField(sed) == SED_STUCK) {
               sed_GotoLastField(sed);
          }
          break;
     case RIGHT:
          if (sed_IncField(sed) == SED_STUCK) {

                             - 30 -
               sed_GotoFirstField(sed);
          }
          break;
     default:
          /* do first letter search */
          letter = ascii(scancode);


          if (isprint(letter) &&
                   (choice=sed_SearchMerge(sed,(char)letter))!=-1){
               sed_GotoField(sed, choice);
          }
          break;
     }
}

2.    Функция help_View .

      Для ясности работы с  help - cистемой  ниже представлена
функция  help_View :

#include <stdio.h>
#include <cscape.h>
#include <popdecl.h>
#include <helpdecl.h>

int help_View(h)
     help_type h;
/*   Display help using the pop_View function.
If there is data associated with help use it, else use defaults.*/
{
     struct hv_struct *hv;
     hv = (struct hv_struct *) help_GetData(h);
     if (hv == NULL) {
          pop_View(help_GetTitle(h), help_GetText(h),
               -1, -1,   -1, -1, NORMAL, 0, bd_std);
     }
     else {
          pop_View(help_GetTitle(h), help_GetText(h), hv->row, hv->col,
                    hv->height, hv->width, hv->color, 0, hv->border);
     }
     return(0);
}
