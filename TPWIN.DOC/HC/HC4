                           ГЛАВА 4

                   ПОСТРОЕНИЕ  HELP  ФАЙЛА

     После того,  как разработаны тематические файлы для Вашей
Help системы, вы готовы к созданию Help файла проекта и прого-
ну построения для проверки Help файла.  Help файл проекта  со-
держит всю информацию, которая требуется компилятору для  при-
ращения тематических  файлов  помощи  в  бинарный  Help   файл
ресурсов.
     Вы используете  Help  файл  проекта  для  подсказки  Help
Compiler о  том,  какие  тематические файлы включать в процесс
построения. Информация в Help файле проекта также дает возмож-
ность компилятору  отображать особые темы в номерах контекстов
(для контекстно-чувствительной части Help).
     После того,  как Вы откомпилировали Ваш Help файл, разра-
ботчики создают программу таким  образом,  чтобы  пользователь
мог иметь к ней доступ.
     В данной главе описывается следующее:
     - Создание Help файла проекта
     - Компилирование Help файла
     - Создание программы для доступа к Help
     Хотя большинство примеров в этой книге написаны на С,  Вы
также можете делать те же самые задачи в Turbo Pascal, кодовые
примеры для обоих языков включены в Ваши диски  Borland  прог-
раммного продукта.

                 Создание Help файла проекта

     Вы используете  Help файл проекта для контроля,  как Help
Compiler создает Ваши тематические файлы.Help файл проекта мо-
жет содержать  вплоть  до  шести сегментов,  которые выполняют
следующие функции:
  Сегмент        Функция
 ───────────────────────────────────────────────────────────
  [Files]     Определяет тематические файлы,  которые  должны
              включаться в построение.
              Этот сегмент является обязательным.
  [Options]   Определяет уровень сообщаемой ошибки,  темы, ко-
              торые должны быть включены в построение,справоч-
              ник, в котором находятся имена файлов и располо-
              жение Вашего Help индекса.
              Этот сегмент может быть необязательным.
  [BuildTags] Определяет действительные теги построения. Этот
              сегмент является необязательным.
  [Alias]     Присваивает одну или  более  контекстных  строк
              одной и той же теме.  Этот  сегмент является не-
              обязательным.
  [Map]       Связывает  контекстные   строки  с  контекстными
              номерами. Этот сегмент является необязательным.
  [Bitmaps]   Определяет растровые файлы, которые должны вклю-
              чаться  в  построение. Этот сегмент является не-
              обязательным.
 ───────────────────────────────────────────────────────────
     Вы можете использовать любой ASCII текстовый редактор для
создания Вашего  Help  файла  проекта.  Расширением Help файла
проекта является.HPJ.  Если Вы не используете расширение  .HPJ
на командной строке HC, то компилятор разыскивает файл проекта
с этим расширением перед тем,  как загрузить файл. .HPJ выход-
ной файл будет иметь то же самое имя, что и .HPJ файл.
     Порядок различных сегментов в пределах Help файла проекта
является произвольным,  с одним исключением:  при всех обстоя-
тельствах [Alias] сегмент должен предшествовать [Map] сегменту
(если используется [Alias] сегмент).
     Имена сегментов помещаются в квадратных скобках с исполь-
зованием следующей синтаксической структуры:
          [ сегмент - имя]
     Вы можете  использовать точку с запятой для указания ком-
ментария в файле проекта.  Компилятор игнорирует весь текст от
точки с запятой до конца строки, где они находятся.

        Определение тематических файлов: Сегмент Files

     Используйте сегмент  [Files] Help файла проекта для пере-
числения всех тематических файлов,  которые Help Compiler дол-
жен обрабатывать  для создания Help файла ресурсов.  Help файл
проекта должен иметь сегмент [Files].
     Следующий пример показывает формат [Files] сегмента:
     [Files]
     HELPEX.RTF ;Основные темы для Helpex программы
     TERMS.RTF  ;Термины поиска для Helpex программы
     Используя путь  доступа,  определенный ROOT опцией,  Help
Compiler находит и обрабатывает все файлы  ,  перечисленные  в
этом разделе файла проекта.  Если файл не находится на опреде-
ленном пути доступа и не может быть найден,  то компилятор ге-
нерирует ошибку. Более подробная информация о ROOT опции можно
найти в разделе "Определение корневого каталога:  корневая оп-
ция".
     Вы можете включить файлы в процесс построения,  используя
управляющую команду    #include    .    Управляющая    команда
#include использует следующий синтаксис:
     #include <filename>
     Вы должны включить угловые  скобки  вокруг  имени  файла.
Знак фунта (#) должен быть первым символом в строке. Имя файла
должно определять полный путь доступа либо путь доступа, опре-
деленный ROOT  опцией или абсолютным каталоговым путем доступа
к файлу.
     Вы можете обнаружить ,  что легче создать текстовый файл,
чем перечислить все файлы в Help проекте и включить такой файл
в построение, как например в этом примере:
     [Files]
     #include <hlpfiles.inc>

       Определение тегов построения: Сегмент BuildTags

     Если Вы  кодируете  теги  построения в Ваших тематических
файлах, используйте [BuildTags] сегмент Help файла проекта для
определения всех  действительных тегов построения особого Help
проекта. Сегмент [BuildTags] является необязательным.
     Следующий пример  показывает  формат [BuildTags] сегмента
в примере Help файла проекта:
     [BuildTags]
     WINENV     ;темы для включения в Windows построение
     DEBUGBUILD ;темы для включения в построение отладки
     TESTBUILD  ;темы для включения в минипостроение для тести-
                 рования
     Сегмент [BuildTags] может включать до 30  тегов  построе-
ния. Теги построения  не чувствительны к регистрам и не должны
содержать пробелы. В этом сегменте на строку допускается толь-
ко один тег построения.  Компилятор будет генерировать сообще-
ние об ошибке,  если что-нибудь иное,  чем  комментарий  пере-
числяется после тега построения в сегменте [BuildTags].
     Более подробную информацию о тегах построения  в  темати-
ческих файлах  можно найти в разделе главы 3 "Присвоение тегов
построения".

              Определение опций: Сегмент Options

     Используйте [Options] сегмент Help файла проекта для  оп-
ределения следующих опций:
  Опция         Значение
 ───────────────────────────────────────────────────────────
  BUILD      Определяет какие файлы компилятор включает в по-
             строение.
  COMPRESS   Задает уплотнение Help файла ресурсов.
  FORCEFONT  Определяет создание Help файла ресурсов, исполь-
             зуя только один шрифт.
  INDEX      Определяет контекстную строку Help индекса.
  MAPFONT-   Определяет  отображение  определенных  размеров
  SIZE       шрифта в различные размеры.
  MULTIKEY   Определяет альтернативное соответствие  ключево-
             го слова для тем.
  ROOT       Разрабатывает  каталог, который должен использо-
             ваться для Help построения.
  TITLE      Определяет заголовок,показанный для Help системы.
  WARNING    Указывает вид сообщения об ошибке, которое сооб-
             щает компилятор.
 ───────────────────────────────────────────────────────────
     Эти опции могут появляться в любом  порядке  в  [Options]
сегменте. Сегмент [Options] не является обязательным.
     Подробные объяснения имеющихся опций следуют далее.

        Определение сообщения об ошибке: Опция Warning

     Используйте опцию WARNING для определения количества  от-
ладочной информации,  о  которой сообщает компилятор.  WARNING
опция имеет следующий синтаксис:
     WARNING = level (уровень)
     Вы можете установить WARNING опцию на любом из  следующих
уровней:
  Уровень       Сообщаемая информация
 ───────────────────────────────────────────────────────────
   1      Только очень строгие предупреждения.
   2      Промежуточный уровень предупреждений.
   3      Все предупреждения. Это уровень, определенный по
          умолчанию, если не определяется опция WARNING.
 ───────────────────────────────────────────────────────────
     Следующий пример определяет промежуточный уровень сообща-
емой ошибки:
        [OPTIONS]
        WARNING=2
     Компилятор сообщает  об  ошибках  в  стандартный выходной
файл, обычно экран.  Вы можете перенаправить ошибки в дисковый
файл так, чтобы Вы могли просмотреть его, когда Вы отлаживаете
Help систему.  Следующий пример показывает перенаправление вы-
вода экрана компилятора в файл:
        HC HELPEX > errors.out
     Намек: Используйте клавишу акселератора DOS CONTROL+PRINT
SCREEN перед тем,  как начнете Вашу компиляцию для  эхоошибок,
которые появляются  на  экране  для Вашего принтера.  Наберите
снова CONTROL+PRINT SCREEN для остановки посылки информации на
принтер.

           Определение тем построения: Опция Build

     Если Вы включили теги построения в Ваши тематические фай-
лы, используйте BUILD опцию для определения, какие темы услов-
но включаются  в  построение.  Если Ваши тематические файлы не
имеют тегов построения,  то опустите опцию BUILD из  [Options]
сегмента.
     Примечание. Все теги построения  должны  перечисляться  в
[BuildTags] сегменте файла проекта, независимо от того, объяв-
ляет или нет данная условная компиляция теги.
     Более подробную  информацию о присвоении тегов построения
темам в Help тематических файлах смотрите в главе 3  "Создание
Help тематических фалов".
     Строка опции BUILD использует следующий синтаксис:
        BUILD = expression (выражение)
     Выражения BUILD не могут превышать в длину 255 символов и
должны вводиться только в одну строку. BUILD выражения исполь-
зуют булеву логику для определения какие темы в пределах опре-
деленных Help тематических файлов компилятора будут включаться
в построение.  Компилятор оценивает все  выражения  построения
слева направо.  Обозначениями  языка  (перечисленные в порядке
старшинства от наивысших к самым низшим) являются:
     Обозначение         Описание
 ───────────────────────────────────────────────────────────
     <tag>           Тег построения
     ()              Круглые скобки
     ~               Оператор отрицания
     &               Оператор И
     │               Оператор ИЛИ
 ───────────────────────────────────────────────────────────
     Например, если Вы закодировали теги построения, названные
WINENV,APP1 и TEST_BUILD в Ваших тематических  файлах,  то  Вы
могли бы  включить  одно  из  следующих выражений построения в
сегмент [Options]:
  Выражение построения    Построенные темы
 ───────────────────────────────────────────────────────────
  BUILD = WINENV     Только темы, которые имеют тег WINENV
  BUILD = WINENV     Темы, которые  имеют  как WINENV,  так и
  &APP1              APP1 теги
  BUILD = WINENV │   Темы, которые  имеют  либо  WINENV  тег,
  APP1               либо APP1 тег
  BUILD = (WINENV │  Темы, которые  имеют  либо  WINENV, либо
  APP1) & TESTBUILD  APP1    теги  и   которые  также   имеют
                     TESTBUILD тег
  BUILD =~APP1       Темы, которые не имеют APP1 тег
 ───────────────────────────────────────────────────────────

        Определение корневого справочника: Опция ROOT

     Используйте ROOT опцию для обозначения корневого справоч-
ника Help проекта. Компилятор ищет файлы в определенном корне-
вом справочнике.
     ROOT опция использует следующий синтаксис:
        ROOT = partname (имя пути)
     Например, следующая корневая опция определяет, что корне-
вым справочником является \BUILD\TEST на D дисководе:
        [OPTIONS]
        ROOT=D:\BUILD\TEST
     ROOT опция позволяет Вам ссылаться на соответствующие пу-
ти доступа из корневого справочника  Help  проекта.  Например,
следующая запись  в сегменте [Files] относится к соответствую-
щему пути из корневого справочника:
        TOPIC\FILE.RTF
     Для ссылки на файл в фиксированной позиции, независимо от
корневого проекта Вы должны задавать полностью квалифицирован-
ный или "абсолютный" путь,  включая букву драйвера, если необ-
ходимо, как в следующей строке:
        D:\HELPTEST\TESTFILE.RTF
     Если Вы  не включаете ROOT опцию в Ваш Help файл проекта,
то все пути являются соответствующими для текущего  DOS  спра-
вочника.

              Спецификация индекса: Index опция

     Используйте INDEX  опцию  для  идентификации  контекстной
строки Help индекса.  Так как INDEX кнопка  дает  пользователю
доступ к индексу из любого места в Help системе,  то Вы, веро-
ятно, не захотите,  чтобы автор переходил к индексу. Пользова-
тели имеют  доступ  этому  основному  индексу или из Help меню
программы, или посредством выбора INDEX кнопки из Help окна.
     Присваивание контекстной строки в индексной теме сегмента
[Options] позволяет компилятору узнать размещение главного ин-
декса Help тем для приложений Help файла. Если Вы не включаете
Index опцию в сегменте [Options],  то компилятор предполагает,
что первая тема, которая встречается - это индекс.
     Опция Index использует следующий синтаксис:
        INDEX = context-string (контекстная строка)
     Заданная контекстная строка должна  соответствовать  кон-
текстной строке,  которую Вы присвоили Help индексной теме.  В
следующем примере разработчик Help  информирует  компилятор  о
том, что контекстная строка Help индекса является "главным ин-
дексом":
        [OPTIONS]
        INDEX=main_index
     Более подробная  информация  о  присваивании  контекстных
строк приведена в разделе главы  3  "Присваивание  контекстных
строк".

      Присваивание заглавия в Help системе: Опция Title

     Можно присвоить заглавие Вашей Help системе с помощью оп-
ции TITLE.  Заглавие появляется в прямоугольнике заглавия Help
окна со словом "Help",  добавляемом автоматически,  за которым
следует DOS имя Help ресурсного файла.
     Опция TITLE  использует следующий синтаксис:
     TITLE=Help-system-title-name (имя-заглавие-система-Help)
     Заглавия ограничены 32 символами в длину.  Если Вы не за-
даете заглавие,  используя опцию TITLE,  то только слово Help,
за которым следует имя файла системы Help, будет выводиться на
дисплей в прямоугольнике заглавия.  Так как компилятор  всегда
вставляет слово Help,  то нужно это помнить, чтобы не дублиро-
вать это слово в заглавии.

           Преобразование шрифтов: Опция Forcefont

     Можно использовать опцию FORCEFONT для создания Help фай-
ла ресурсов,  который состоит только из одного шрифта. Это по-
лезно, если Вы должны компилировать  Help  систему,  используя
тематические файлы, которые включают шрифты, не поддерживаемы-
ми Вашими пользовательскими системами.
     Опция FORCEFONT использует следующий синтаксис:
        FORCEFONT = fontname (имя шрифта)
     Параметр fontname  -  это  любой  шрифт  системы Windows.
Windows поставляется со следующими шрифтами и размерами:
     - Courier 10,12,15
     - Гельветика 8,10,12,14,18,24
     - Современный
     - Прямой светлый шрифт
     - Script
     - Символьный 8,10,12,14,18,24
     - Tms Rmn 8,10,12,14,18,24
     Имена файлов должны записываться также,  как они записаны
в Font  диалоговом  окне управляющей панели.  Имена шрифтов не
превышают 20 символов в длину.  Если Вы задаете шрифт, который
не распознается  компилятором,  то  он генерирует сообщение об
ошибке и компиляция продолжается с использованием определенно-
го по умолчанию шрифта "Гельветика".
     Примечание. Имя шрифта,  используемое в опции  FORCEFONT,
не может  содержать пробелы.  Следовательно,  шрифт Tms Rmn не
может использоваться с помощью FORCEFONT.

         Изменение размеров шрифта: Опция Mapfontsize

     Размер шрифтов,заданный в тематических файлах,может отоб-
ражаться с  различными размерами с помощью опции MAPFONTSIZE.В
этом случае Вы можете создать и отредактировать текст в разме-
ре,выбранном для  более  раннего просмотра в тематических фай-
лах,а затем компилятор будет определять их размер для действи-
тельного изображения  в Help.Это может быть полезным,если есть
большая разница в размерах между Вашим создаваемым монитором и
предназначенным дисплейным монитором.
     Опция MAPFONTSIZE использует следующий синтаксис:
        MAPFONTSIZE = m[-n]:p
     Параметр m - это размер исходного шрифта,  а параметр p -
это размер  желаемого  шрифта для Help файла ресурсов.  Размер
всех шрифтов в тематических файлах,  которые имеют  размер  m,
изменяются на  p.  Необязательный параметр m позволяет Вам за-
дать диапазон, в котором может отображаться шрифт. Размер всех
шрифтов тематических  файлов,  попадающий  между m и p включи-
тельно, меняется на размер p.  Следующие примеры  иллюстрируют
использование опции MAPFONTSIZE:
     MAPFONTSIZE=12-24:16 ;делает размер шрифтов, имеющих раз-
                           мер от 12 до 24, равным 16.
     MAPFONTSIZE=8:12 ;делает  размер  всех  шрифтов,  имеющих
                       размер 8, равным 12.
     Заметим, что Вы  можете  отобразить  только  один  размер
шрифта или диапазон с каждым MAPFONTSIZE предложением, исполь-
зуемом в сегменте Options.  Если Вы используете  более  одного
MAPFONTSIZE в  предложении,  то  исходный  размер или диапазон
шрифта, заданные в последовательных предложениях, не могут пе-
рекрывать предыдущее отображение.  Например, следующее отобра-
жение будут генерировать ошибку,  когда  компилятор  встречает
второе предложение:
     MAPFONTSIZE=12-24:16 MAPFONTSIZE=14:20
     Так как второе отображение,  показанное в первом примере,
содержит размер,  уже отображенный в  предыдущем  предложении,
компилятор будет игнорировать эту строку. В файле проекта мож-
но задать максимум 5 диапазонов шрифтов.

            Таблица ключевых слов: Опция Multikey

     Опция MULTIKEY задает  символ,  который  будет  использо-
ваться для таблицы дополнительных ключевых слов.
     Опция MULTIKEY будет использовать следующий синтаксис:
        MULTIKEY = footnote-character (сноска-символ)
     Параметр footnote-character является чувствительной к ре-
гистру буквой, которая должна использовать для сноски ключево-
го слова.  Следующий пример иллюстрирует определение  буквы  L
для сноски в таблице ключевых слов:
        MULTIKEY=L
     Примечание. Вы  должны  быть  уверенными в том,  что Ваши
сноски в таблице ключевых  слов  ограничены  одним  регистром,
обычно используются  строчные буквы.  В предыдущем примере для
тем со сноской L ключевые слова будут введены в дополнительную
таблицу ключевых  слов,  а для тем,  которым назначено l,  это
происходить не будет.
     Вы можете  использовать  любой  алфавитно-цифровой символ
для любой таблицы ключевых слов, за исключением "К" и "к", ко-
торые резервируются  для  обычной  таблицы ключевых слов Help.
существует абсолютный предел из 5 таблиц ключевых слов,  вклю-
чая обычную таблицу.  Однако , в зависимости от конфигурации и
структуры Help системы  фактически  имеет  место  практический
предел только из 2 или 3 таблиц. Если компилятор не может соз-
дать дополнительную таблицу,  то при построении лишняя таблица
игнорируется.

                 Сжатие файла: Опция Compress

     Вы можете  использовать опцию COMPRESS ,  чтобы сократить
размер Help файла ресурсов, созданного компилятором.Объем сжа-
тия файла будет изменяться в зависимости от количества, разме-
ра и сложности тем, которые компилируются. В общем, чем больше
файлы Help, тем тем больше они могут быть сжаты.
     Опция COMPRESS имеет следующий синтаксис:
        COMPRESS = TRUE │ FALSE
     Так как Help программа может загружать быстро сжатые фай-
лы, то  очевидным  преимуществом  является создание и поставка
сжатых Help файлов с Вашей программой.  Однако, компилирование
с включенным  сжатием может увеличивать время компиляции из-за
дополнительного времени,  необходимого для  ассемблирования  и
сортировки таблицы ключевых фраз.  Таким образом,  возможно Вы
захотите компилировать без сжатия на ранних стадиях разработки
проекта.
     Опция COMPRESS  заставляет  компилятор  сжимать  систему,
посредством компилирования повторяющихся фраз, найденных внут-
ри исходного файла (файлов). Компилятор создает файл из табли-
цы фраз с расширением .PH,  если такой файл еще не существует.
Если компилятор находит файл с .PH, он будет использовать этот
файл для текущей компиляции. Это используется для того,  чтобы
ускорить сжатие,  когда со времени последней компиляции, изме-
нилось немного текста. Удаление файла ключевых фраз перед каж-
дой компиляцией будет предотвращать использование компилятором
предыдущего файла. Максимальное сжатие будет получаться только
тогда, когда компилятор будет создавать новую таблицу фраз.

      Определение новых контекстных строк: Сегмент Alias

     Используйте сегмент  [Alias]  для  присвоения  одной  или
нескольких контекстных  строк  одному  и тому же тематическому
псевдоимени. Так как контекстные строки должны быть уникальны-
ми для  для  каждой  темы  и не могут использоваться для любой
другой темы в Help проекте,  то сегмент  [Alias]  обеспечивает
способ удаления  или  комбинирования Help тем без записи Ваших
файлов,. Сегмент [Alias] является необязательным.
     Например, если Вы создали тему, которая заменяет информа-
цию в трех других темах и Вы удаляете эти  три  темы,  то  Вам
придется искать  в  файлах неправильную перекрестную ссылку на
удаленные темы.  Вы можете избежать этой проблемы  посредством
использования сегмента [Alias] для присвоения имени новой темы
удаленным темам.  Сегмент [Alias] может также  использоваться,
когда Ваша  прикладная  программа  имеет составные контекстные
идентификаторы, для которых Вы имеете только  одну  тему.  Это
может быть регистр с контекстно-чувствительной Help.
     Каждое выражение в сегменте [Alias] имеет следующий  фор-
мат:
        context_string=alias
     В выражении псевдоимени параметр alias является альтерна-
тивной строкой или псевдоименем, а context_string параметр яв-
ляется контекстной   строкой,  идентифицирующей  особую  тему.
Строка псевдоимени имеет тот же самый формат и следует тем  же
самым обычаям, что и тематическая контекстная строка. То есть,
она не чувствительна к регистру и может  содержать  алфавитные
символы A  - Z,  цифровые символы 0 - 9 и символы точки и под-
черкивания.
     Следующий пример иллюстрирует сегмент [Alias]:
     [Alias]
     sm_key= key_shrtcuts
     cc_key= key_shrtcuts
     st_key= key_shrtcuts;комбинирует в сокращения клавиатуры
     clskey=us_dlog_bxs
     maakey=us_dlog_bxs;реализуется в  использовании темы диа-
                        логового окна
     chk_key=dlogprts
     drp_key=dlogprts
     lst_key=dlogprts
     opt_key=dlogprts
     tbx_key=dlogprts;комбинируется в  части  темы диалогового
                      окна
     frmtxt=edittxt
     wrptxt=edittxt
     seltxt=edittxt;реализуется в редактировании темы текста
     Примечание. Вы можете использовать псевдоимена в сегменте
[Map] Help файла проекта.  Однако,  если Вы так поступите,  то
сегмент [Alias] должен предшествовать сегменту [Map].

    Отображение контекстно-чувствительных тем: Сегмент Map

     Если Ваша Help  система  обеспечивает контекстно-чувстви-
тельную Help, то используйте [Map] сегмент для ассоциации кон-
текстных строк или псевдоимен с  контекстными  номерами.  Кон-
текстный номер  соответствует  значению родительской программы
при передаче Help программе для того, чтобы вывести на дисплей
определенную тему. Этот сегмент является необязательным.
     При написании [Map] сегмента Вы можете сделать следующее:
     - Используйте  как  десятичные ,  так и шестнадцатиричные
номера, отформатированные в стандартной С системе  обозначений
для определения контекстных номеров.
     - Присвойте не более, чем один контекстный номер для кон-
текстной строки или псевдоимени.
     Присвоение одного и того же номера более,  чем одной кон-
текстной строке будет генерировать ошибку компилятора.
     - Разделите  контекстные  номера  и  контекстные   строки
посредством произвольного  количества пробелов,  используя как
символы пробелов, так и символы табуляции.
     Вы можете использовать  С#include директиву для включения
других файлов в отображение. В дополнение к этому, сегмент Map
обеспечивает расширенный  формат,  который  позволяет  Вам не-
посредственно включать С файлы  с  расширением  .H.  Элементы,
использующие этот   формат,   должны   начинаться   с  #define
и могут содержать комментарии в С формате,  как в данном  при-
мере:
     #define context_string context_number /* комментарий*/
     Следующий пример иллюстрирует несколько форматов, которые
Вы можете использовать в сегменте [Map]:
     [Map]
     1).
     Edit_Window       0x0001
     Control_Menu      0x0002
     Maximize_Icon     0x0003
     Minimize_Icon     0x0004
     Split_Bar         0x0005
     Scroll_Bar        0x0006
     Title_Bar         0x0007
     Window_Border     0x0008
     2).
     dcmb_scr       30;Document Control-menu Icon
     dmxi_scr       31;Document Maximize Icon
     dmni_scr       32;Document Minimize Icon
     dri_scr        33;Document Restore Icon
     dtb_scr        34;Document Title Bar
     3).
     #define vscroll 0x010A /* Линейка вертикальной прокрутки*/
     #define hscroll 0x010E /* Линейка горизонтальной прокрутки*/
     #define scrollthm  0x0111 /* Кнопка скролинга*/
     #define upscroll   0x0112 /* Прокрутка вверх*/
     #define dnscroll   0x0113 /* Прокрутка вниз*/
     4).
     #include <sample.h>

    В примере:
     1). Эти восемь записей  дают  шестнадцатиричные эквивален-
ты для номеров контекста.
     2). Эти  пять  записей  показывают десятичные контекстные
номера.
     3). Эти  пять записей показывают как Вы могли бы включить
темы, определенные в С include файл.
     4). Эта запись показывает С#include директиву для некото-
рых основных тем.
     Если контекстные  номера  используют  #define директиву и
файл, содержащий #define предложения,  включается  как  в  код
программу, так и в Help файл,  то тогда модификации, сделанные
в контекстных номерах разработчиками программы,  будут автома-
тически отражаться в следующем Help построении.
     Вы можете определить, перечисленные в [Map] сегменте, ли-
бо в Help теме,  или в [Alias] сегменте. Компилятор генерирует
предупреждение, если контекстная строка,  появляющаяся в [Map]
сегменте, не определяется в любом из тематических файлов или в
[Alias] сегменте.
     Примечание. Если   Вы   используете   псевдоимя,  сегмент
[Alias] должен предшествовать [Map] сегменту в Help файле про-
екта.
     Более подробную информацию о контекстно-чувствительной по-
мощи смотрите  в  разделе  главы  2 "Выведение на дисплей кон-
текстно-чувствительных Help тем".

         Включение растров по ссылке: Сегмент Bitmaps

     Если Ваша Help система использует растры  по  ссылке,  то
имена файлов   каждого   из  растров  должны  перечисляться  в
[Bitmaps] сегменте файла проекта. Следующий пример иллюстриру-
ет формат [Bitmaps] сегмента:
     [Bitmaps]
     DUMP01.BMP
     DUMP02.BMP
     DUMP03.BMP
     c:\PROJECT\HELP\BITMAPS\DUMP04.BMP
     Примечание. [Bitmaps] сегмент использует те же самые пра-
вила, как и [Files] сегмент для расположения растровых файлов.

                  Компилирование Help файлов

     После того,  как Вы создали Help файл проекта, Вы уже го-
товы создать  Help файл,  используя Help Compiler.  Компилятор
генерирует бинарный Help файл ресурсов из тематических файлов,
перечисленных в Help файле проекта.  Когда завершается процесс
построения, Ваша программа может иметь  доступ  к  полученному
Help файлу ресурсов.
     До инициирования операции построения  для  создания  Help
файла, рассмотрите расположение следующих файлов:
     - Help Compiler,  HC.EXE.  Компилятор должен быть в спра-
вочнике, из которого он может выполняться.Это может быть теку-
щий рабочий справочник на пути, установленном переменной среды
PATH или справочник,  определенный полным именем пути, как по-
казано ниже:
     С:\BIN\HC HELPEX.HPJ
     - Help файл проекта,  filename.HPJ.  Файл  проекта  может
располагаться или  в  текущем справочнике,  или определяться в
справочнике, определенном путем, как показано ниже:
     C:\BIN\HC D:\MYPROJ\HELPEX.HPJ
     - Тематические файлы,  названные в  Help  файле  проекта,
сохраняются как RTF.  Тематические файлы могут располагаться в
текущем рабочем справочнике,  подсправочнике текущего рабочего
справочника, определенного в [Files] сегменте,  или его распо-
ложение определяется в ROOT опции.
     - Файлы,  включенные  с помощью #include директивы в Help
файл проекта. Так как #include директива может принимать имена
пути, то  тогда  любое количество мест будет работать для этих
файлов.
     - Все растровые файлы, перечисленные по ссылке, в темати-
ческих файлах.
     Вы также   должны  поместить  любые  файлы,  названные  в
#include директиве,  на пути корневого справочника проекта или
определить их  путь,  используя  ROOT  опцию.  Компилятор ищет
только справочники,  определенные в Help файле проекта.  Более
подробную информацию о ROOT опции Вы можете получить в разделе
"Определение корневого справочника: Опция ROOT".
     Примечание. Если  Вы  используете  оперативную память для
рабочих файлов (установленную с помощью DOS  среды  переменной
TMP) ,  то  она  должна быть достаточно большой для сохранения
откомпилированного Help файла ресурсов.  Если  Ваш  Help  файл
больше, чем размер доступной оперативной памяти, то компилятор
будет генерировать сообщение  об  ошибке  и  компиляция  будет
прекращаться.

                Использование Help компилятора

     Для прогона Help Compiler используйте HC команду.  Для HC
не существует опций.  Все опции определяются в Help файле про-
екта.
     HC команда использует следующий синтаксис:
        HCfilename.HPJ
     Когда прогоняется программа компилятора,  то она  выводит
на дисплей  последовательные точки,  указывая на ее развитие в
процессе. Сообщение о  ошибках  выводится  на  дисплей,  когда
встречается условие каждой ошибки.  Когда Help Compiler закан-
чивает компилирование,  он пишет Help файл ресурсов с расшире-
нием .HLP  в  текущий  справочник  и возвращает DOS подсказку.
Help файл ресурсов,  получаемый из построения, имеет то же са-
мое имя , что и Help файл проекта.
     Ошибки компилятора и сообщения о статусе  могут  перенап-
равляться в файл,  используя стандартный DOS синтаксис переад-
ресовки. Это вполне пригодно для растянутого  построения,  где
Вы не в состоянии контролировать весь процесс.  Переадресован-
ный файл  сохраняется,  как  текстовый  файл6  который   можно
просматривать с помощью любого ASCII редактора.

           Разработка программы для доступа к Help

     Группа разработчиков программы должна разрабатывать прог-
рамму так,  чтобы пользователь мог иметь доступ к Windows Help
программе, так и к Вашему Help файлу. Help программа - это от-
дельная Windows программа и Ваша программа  может  запрашивать
Windows для прогона Help программы и определять тему,  которую
Help должна показывать пользователю. Для пользователя Help по-
является как  часть Вашей программы,  однако она действует по-
добно любой другой Windows программе.

                  Вызов WinHelp из программы

     Программа делает  Help  систему  доступной   пользователю
посредством вызова WinHelp функции.
     WinHelp функция имеет следующий синтаксис:
        BOOL WinHelp (hWnd,lpHelpFile,wCommand,dwData)
     Напоминаем: С и Pascal примеры находятся на диске.
     Параметр hWnd    идентифицирует    окно,    запрашивающее
Help. Windows Help программа  использует  этот  идентификатор,
чтобы следить за тем, какие программы запрашивают Help.
     Параметр lpHelpFile задает имя (с необязательным путем  к
справочнику) файла Help, содержащего требуемую тему.
     Параметр mCommand задает тип поиска, который Windows Help
программа использует  для определения положения заданной темы,
или задает,  что программе больше не нужна система Help. Этому
параметру можно присвоить одно из следующих значений:
  Значение            Что делает
 ───────────────────────────────────────────────────────────
  HELP_CONTEXT     Выводит на дисплей  Help для  определенной
                   темы, идентифицируемой номером контекста.
  HELP_HELPPONHELP Выводит на дисплей Using Help тему индекса
  HELP_INDEX       Выводит  на  дисплей главную Help тему ин-
                   декса.
  HELP_KEY         Выводит на дисплей Help для темы, заданной
                   ключевым словом.
  HELP_MULTIKEY    Выводит на дисплей Help для темы, заданной
                   ключевым словом  в  альтернативной  таблице
                   ключевых слов.
  HELP_QUIT        Информирует Help программу о том, что Help
                   больше не  нужна.  Если другие программы не
                   запрашивают Help, то Windows закрывает Help
                   программу.
  HELP_SETINDEX    Выводит  на  дисплей  назначенную Help тему
                   индекса.
 ───────────────────────────────────────────────────────────
     Параметр dwData задает тему, для которой программа запра-
шивает Help. Формат dwData зависит от значения mCommand, пере-
даваемого, когда  Ваша  программа вызывает WinHelp.  Следующий
список описывает формат wdData для каждого значения mCommand.
  Значение mCommand        dwData формат
 ───────────────────────────────────────────────────────────
  HELP_CONTEXT     Длинное целое  без знака,  содержащее номер
                   контекста  для темы.  Вместо  использования
                   HELP_INDEX, HELP_CONTEXT можно использовать
                   можно использовать значение -1.
  HELP_HELPPONHELP Игнорируется.
  HELP_INDEX       Игнорируется.
  HELP_KEY         Длинный указатель на  строку,  которая со-
                   держит ключевое слово для требуемой темы.
  HELP_MULTIKEY    Длинный  указатель  на MULTIKEYHELP струк-
                   туру, как  определено  в   WINDOWS.H.  Эта
                   структура определяет символ сноски таблицы
                   и ключевое слово.
  HELP_QUIT        Игнорируется.
  HELP_SETINDEX    Длинное целое без знака, содержащее  номер
                   контекста для темы.
 ───────────────────────────────────────────────────────────
     Так как можно задать как номер контекста,  так и ключевое
слово, то WinHelp поддерживает и  контекстно-чувствительный  и
тематический поиск Help файла.
     Примечание. Чтобы убедиться,  что правильный индекс оста-
ется установленным,   программа   должна   вызвать  WinHelp  с
mCommand ,  равным HELP_SETINDEX  (с  dwData,  задающим  соот-
ветствующий идентификатор контекста),  вслед за каждым вызовом
WinHelp с командой HELP_CONTEXT.  HELP_INDEX никогда не должен
использоваться  с HELP_SETINDEX.

          Получение контекстно-чувствительной помощи

     Контекстно-чувствительная Help   должна  быть  доступной,
когда пользователь желает узнать  о  назначении  определенного
окна или управления.  Например,  пользователь может вытолкнуть
File меню,  выбрать Open  команду  (посредством  использования
клавиши Direction),  а  затем нажать F1 для получения Help для
команды.
     Реализация определенных  типов  контекстно-чувствительной
помощи требует  более  совершенной  техники  программирования.
Helpex пример программы иллюстрирует использование двух техно-
логий. Эти технологии описываются в следующих разделах.

                      Shift+F1 поддержка

     Для реализации Shift+F1 режима, Helpex отвечает на клави-
шу акселератора  Shift+F1,  посредством  вызова Set-Cursor для
изменения формы курсора на стрелочный  указатель,  дополняемый
маркером вопроса.
    case WM_KEYDOWN:
      if WParam == VK_F1 {

        /*Если используется Shift-F1, то включается режим помо-
         щи и устанавливается курсор помощи*/

        if GetKeyState(VK_Shift)) {
          bHelp = True;
          SetCursor(hHelpCursor);
          return (DefWindowProc(hWnd, message, WParam, LParam));
        }

        /* Если используется F1 без клавиши  Shift,  то  тогда
         вызывается тема главного индекса помощи */
        else {
          WinHelp(hWnd, szHelpFileName, Help_Index, 0L);
        }
      }

      else if (wParam == vk_Escape && bHelp) {

        /* Клавиша Escape во время режима помощи: отключает
           режим помощи */
          bHelp = False;
          SetCursor(hCursor)GetClassWord(hWnd,GCW_HCursor));
      }

      break;

     Ниже показано как Вы должны это делать в Turbo Pascal:

    WM_KEYDOWN:
      if WParam = vk_F1 then
        { Если используется Shift-F1, то включается режим помо-
         щи и устанавливается курсор помощи }
        if GetKeyState(VK_Shift) < 0 then
        begin
          Help := True;
          SetCursor(HelpCursor);
          MainWndProc := DefWindowProc(Wnd, Message, WParam, LParam);
        end
         { Если используется F1 без клавиши  Shift,  то  тогда
         вызывается тема главного индекса помощи }
        else
          WinHelp(Wnd, HelpFileName, Help_Index, 0)
        { Клавиша Escape во время режима помощи: отключает
          режим помощи }
      else if (WParam = vk_Escape) and Help then
        begin
          Help := False;
          SetCursor(hCursor(GetClassWord(Wnd, GCW_HCursor)));
        end;

     Пока пользователь  находиться  в  режиме Help (то есть до
тех пор,  пока он нажимает клавишу на мышке или нажимает  кла-
вишу Escape),   Helpex   отвечает  на  WM_SETCURSOR  сообщения
посредством переопределения курсора на комбинацию стрелочки  и
маркера вопроса.
    case WM_SETCURSOR:
      /* В режиме помощи необходимо изменить курсор в ответ на
         каждое WM_SETCURSOR сообщение.  В противном случае,по
         умолчанию, Windows  будет  изменять  курсор на курсор
         класса окна. */

      if (bHelp) {
        SetCursor(hHelpCursor);
        break;
      }
      return (DefWindowProc(hWnd, message, wParam, lParam));
      break;

    case WM_INITMENU:
      if (bHelp) {
        SetCursor(hHelpCursor);
      }
      return(TRUE);

     Ниже представлено как это Вы должны делать в Turbo Pascal:

    WM_SETCURSOR:
      {  В режиме помощи необходимо изменить курсор в ответ на
         каждое WM_SETCURSOR сообщение.  В противном случае,по
         умолчанию, Windows  будет  изменять  курсор на курсор
         класса окна. }

      if Help then
        SetCursor(HelpCursor)
      else
        MainWndProc := DefWindowProc(Wnd, Message, WParam,
                       LParam);
        exit;
      end;

     Когда пользователь находится в Shift+F1 режиме Help и на-
жимает клавишу  мышки,  Helpex будет получать WM_NCLBUTTONDOWN
сообщение, если нажатие произошло не  в  области  пользователь
окна программы.  Благодаря  исследованию значения wParam этого
сообщения, программа может определить какой идентификатор кон-
текста послать в WinHelp.
    case WM_NCLBUTTONDOWN:
      /*Если мы находимся в режиме помощи (Shift+F1), то тогда
        выводится на  дисплей контекстно-чувствительная помощь
        для непользовательской среды. */

      if (bHelp) {
          dwHelpContextId =
               (wParam == HtCaption)?(DWORD)HelpId_Title_Bar:
               (wParam == HTSIZE)? (DWORD)HelpId_Size_Box:
               (wParam == HTREDUCE)?
    (DWORD)HELPID_MINIMIZE_ICON
               (wParam == HTZOOM)?(DWORD)HELPID_MAXIMIZE_ICON:
               (wParam == HTSYSMENU)?(DWORD)HELPID_SYSTEM_MENU:
               (wParam == HTBOTTOM)?
     (DWORD)HELPID_SIZING_BORDER:
               (wParam == HTBOTTOMLEFT)?
     (DWORD)HELPID_SIZING_BORDER:
               (wParam ==
     HTBOTTOMRIGHT)?HELPID_SIZING_BORDER:
               (mParam == HTTOP)?(DWORD)HELPID_SIZING_BORDER:
               (mParam == HTLEFT)?(DWORD)HELPID_SIZING_BORDER:
               (mParam == HTRIGHT)?(DWORD)HELPID_SIZING_BORDER:
               (mParam ==
     HTTOPLEFT)?(DWORD)HELPID_SIZING_BORDER:
               (mParam == HTTOPRIGHT)?
     (DWORD)HELPID_SIZING_BORDER:
               (DWORD)0L

          if (!((BOOL)dwHelpContextId))
             return (DefWindowProc(hWnd, message, wParam,
                     lParam));
          bHelp = False;
     WinHelp(hWnd, szHelpFileName, Help_Context,
             dwHelpContextId);
          break;
          }
          return (DefWindowProc(hWnd, message, wParam,
                  lParam));

    Ниже представлено как это Вы должны делать в Turbo Pascal:

    WM_NCLBUTTONDOWN:
      /*Если мы находимся в режиме помощи (Shift+F1), то тогда
        выводится на  дисплей контекстно-чувствительная помощь
        для непользовательской среды. */

      if Help then
      begin
        case WParam of
          HtCaption: HelpContextId := HelpIdTitleBar;
          HtReduce: HelpContextId := HelpIdMinimizeIcon;
          HtZoom: HelpContextId := HelpIdMaximizeIcon;
          HtSysMenu: HelpContextId := HelpIdSystemMenu;
          HtBottom: HelpContextId := HelpIdSizingBorder;
          HtBottomLeft: HelpContextId := HelpIdSizingBorder;
          HtBottomRight: HelpContextId := HelpIdSizingBorder;
          HtTop: HelpContextId := HelpIdSizingBorder;
          HtLeft: HelpContextId := HelpIdSizingBorder;
          HtRight: HelpContextId := HelpIdSizingBorder;
          HtTopLeft: HelpContextId := HelpIdSizingBorder;
          HtTopRight: HelpContextId := HelpIdSizingBorder;
        else
          HelpContextId := 0;
        end;
        if HelpContextId = 0 then
          MainWndProc := DefWindowProc(Wnd, Message, WParam,
                                       LParam)
        else
        begin
          Help := False;
          WinHelp(Wnd, HelpFileName, Help_Context,
                  HelpContextId);
        end
      end
      else
        MainWndProc := DefWindowProc(Wnd, Message, WParam,
                                     LParam);
        exit;
      end;

                         F1 поддержка

     Контекстно-чувствительная F1  поддержка  для меню относи-
тельно проста для реализации в Вашей программе. Если меню  от-
крыто и  пользователь  нажимает F1 в то время когда высвечива-
ется один из элементов  меню,  Windows  посылает  WM_ENTERIDLE
сообщение в  программу  для того,  чтобы указать 6 что система
возвращается обратно в состояние незанятости после определения
того, что  F1  не было  правильным нажатием клавиши для выбора
элемента меню. Вы можете получить преимущество от того состоя-
ния незанятости,  взглянув  на  состояние  клавиатуры во время
WM_ENTERIDLE сообщения.
     Ели нажата клавиша F1,  то тогда вы сможете смоделировать
нажатие пользователем клавиши ENTER ,  посредством регистрации
WM_KEYDOWN сообщения, используя VK_RETURN. Вы действительно не
желаете, чтобы Ваша программа выполняла команды меню.  То  что
Вы должны  сделать,  так это установить флаг (bHelp=TRUE) так,
чтобы когда вы получили WM_COMMAND сообщение для элемента  ме-
ню, Вы  не  выполняли команду.  Вместо этого тема для элемента
меню выводится на дисплей посредством Windows Help.
     Следующие кодовые  примеры  иллюстрируют  F1 чувствитель-
ность для элементов меню:
    case WM_ENTERIDLE:
      if ((WParam == msgf_Menu) && (GetKeyState(VK_F1) &
         0x8000)) {
        bHelp = True;
        PostMessage(hWnd, WM_KEYDOWN, VK_RETURN, 0L);
      }
      break;

    case WM_COMMAND:
      /* F1 только что нажата в меню или мы находимся в режиме
        помощи (Shift+F1)?  */

      if (bHelp) {
          dwHelpContextId =
            (wParam == Idm_New)?(DWORD)HelpId_File_New:
            (wParam == Idm_Open)?(DWORD)HelpId_File-Open:
            (wParam == Idm_Save)?(DWORD)HelpId_File_Save:
            (wParam == Idm_SaveAs)?
                       (DWORD)HelpId_File_Save_As:
            (wParam == Idm_Print)?(DWORD)HelpId_File_Print:
            (wParam == Idm_Exit)?(DWORD)HelpId_File_Exit:
            (wParam == Idm_Undo)?(DWORD)HelpId_Edit_Undo:
            (wParam == Idm_Cut)?(DWORD)HelpId_Edit_Cut:
            (wParam == Idm_Clear)?(DWORD)HelpId_Edit_Clear:
            (wParam == Idm_Copy)?(DWORD)HelpId_Edit_Copy:
            (wParam == Idm_Paste)?(DWORD)HelpId_Edit_Paste:
            (DWORD)0L;

          if (!dwHelpContextId)
          {MessageBox( hWnd, "Help not available for Help Menu
      Item",                 "Help Example", Mb_Ok
      return (DefWindowProc(hWnd, message, wParam, lParam));
                }

                bHelp = False;

          WinHelp(hWnd, szHelpFileName, Help_Context,
                  HelpContextId);
                   break;
                }

    Ниже представлено как это Вы должны делать в Turbo Pascal:

    WM_ENTERIDLE:
      if ((WParam = msgf_Menu) and ((GetKeyState(VK_F1) and
           $8000) <> 0)) then
      begin
        Help := True;
        PostMessage(Wnd, WM_KEYDOWN, VK_RETURN, 0);
      end;

    WM_COMMAND:

      { F1 только что нажата в меню или мы находимся в режиме
        помощи (Shift+F1)?  }

      if Help then
      begin
        case WParam of
          IdmNew: HelpContextId := HelpIdFileNew;
          IdmOpen: HelpContextId := HelpIdFileOpen;
          IdmSave: HelpContextId := HelpIdFileSave;
          IdmSaveAs: HelpContextId := HelpIdFileSaveAs;
          IdmPrint: HelpContextId := HelpIdFilePrint;
          IdmExit: HelpContextId := HelpIdFileExit;
          IdmUndo: HelpContextId := HelpIdEditUndo;
          IdmCut: HelpContextId := HelpIdEditCut;
          IdmClear: HelpContextId := HelpIdEditClear;
          IdmCopy: HelpContextId := HelpIdEditCopy;
          IdmPaste: HelpContextId := HelpIdEditPaste;
        else
          HelpContextId := 0;
        end;
        if HelpContextId = 0 then
        begin
          MessageBox(Wnd, 'Help not available for Help Menu
          Item',            'Help Example', Mb_Ok);
          MainWndProc := DefWindowProc(Wnd, Message, WParam,
                                       LParam);
          exit;
        end;
          Help := False;
          WinHelp(Wnd, HelpFileName, Help_Context,
                  HelpContextId);
        end
     Обнаружение F1 в диалоговых окнах несколько более затруд-
нено, чем  в  меню.  Вы  должны  установить  фильтр сообщения,
используя WH_MSGFILTER  опцию  функции  SetWindowsHook.   Ваша
функция фильтра  сообщения  реагирует на WH_KEYDOWN и WH_KEYUP
сообщения в VK_F1 ,  когда они посылаются в  диалоговое  окно,
как указывается MSGF_DIALOGBOX кодом. Посредством исследования
структуры сообщения, передаваемого в фильтр, Вы можете опреде-
лить контекст  F1 помощи - это находится в диалоговом окне,  и
определенную опцию или элемент.  Вы не должны вызывать WinHelp
при обработке фильтруемого сообщения,  а скорее регистрировать
сообщение, определенное программой, для Вашей программы, чтобы
вызвать WinHelp при первой доступной возможности.

          Получение Help по элементу, перечисленному
                         в меню Help

     Иногда пользователи могут пожелать получить информацию об
основной концепции в программе,  а не об определенном управле-
нии или окне.  В этих случаях программа должна обеспечить Help
определенной темой,  которая идентифицируется ключевым словом,
а не идентификатором контекста.
     Например, если  Help  файл для Вашей программы,  содержит
тему, описывающую как используется клавиатура,  Вы можете  по-
местить элемент  "Keyboard"  ("Клавиатура")  в Ваше меню Help.
Тогда, когда пользователь выбирает этот элемент, Ваша програм-
ма должна вызвать WinHelp и запросить эту тему:
     case IDM_HELP_KEY_BOARD:
        WinHelp (hWnd, lpHelpFile, HELP_KEY, (LPSTR)
     "Keyboard");
        break;

        Доступ к дополнительной таблице ключевых слов

     Ваша программа  может иметь команды или термины,  которые
соответствуют терминам в сходной,  но отличающейся  программе.
По данному  ключевому  слову программа может вызвать WinHelp и
найти темы,  определенные в  альтернативной  таблице  ключевых
слов. Эта Multikey функциональность доступна благодаря WinHelp
добавочному блоку  с  параметром  mCommand,  установленном  на
HELP_MULTIKEY.
     Вы определяете символ сноски для  альтернативной  таблицы
ключевых слов  и  ключевое  слово  или  фразу  через структуру
MULTIKEYHELP, которая передается в качестве  параметра  dwData
при вызове WinHelp. Эта структура определяется в WINDOW.H сле-
дующим образом:
     typedef struct tag MULTIKEYHELP {
         WORD mdSize;
         BYTE mkKeyList;
         BYTE szKeyPhrase[1];
     } MULTIKEYHELP;

     В следующей таблице перечисляются форматы полей структуры
MULTIKEYHELP:
  Параметр             Формат
 ───────────────────────────────────────────────────────────
  mkSize      Размер   структуры,  включающий  ключевое  слово
              (или фразу)  и  соответствующую  букву  ключевой
              таблицы.
  mkKeyList   Одиночный  символ,  которые  определяет   символ
              сноски для  разыскиваемой альтернативной таблицы
              ключевых слов.
  szKeyPhrase Ключевое  слово или фраза,  завершающаяся пустым
              указателем, которые должны разыскиваться  в аль-
              тернативной таблице ключевых слов.
 ───────────────────────────────────────────────────────────
     В следующем  примере иллюстрируется поиск ключевого слова
для слова "frame" ("рамка") в альтернативной таблице  ключевых
слов, обозначенном символом сноски "L":
     MULTIKEYHELP mk;
     char szKeyword[] = "frame";
     mk.mkSize=sizeof(MULTIKEYHELP)+(WORD)lstrlen(szKeyword);
     mk.mkKeylist="L";
     mk.szKeyphrase=szKeyword;
     WinHelp(hWnd,lpHelpfile,HELP_MULTIKEY,(LPSTR)&mk);

                         Отмена Help

     Windows Help  программа является общим ресурсом,  который
доступен для всех Windows программ.  В дополнение к этому, так
как это автономная программа,  пользователь может выполнять ее
подобно любой другой программе.  В результате этого Ваша прог-
рамма имеет  ограниченный  контроль над Help программой.  Хотя
Ваша программа не  может  непосредственно  закрыть  Help  окно
программы, Ваша  программа  может проинформировать  Help прог-
рамму о том,  что Help больше не требуется. До закрытия своего
главного окна  Ваша программа должна вызвать WinHelp с исполь-
зованием mCommand параметра для установки HELP_QUIT, как пока-
зано в следующем примере, чтобы проинформировать Help програм-
му о том, что Ваша программа не будет нуждаться в ней опять.
     case WM_DESTROY:
        WinHelp (hWnd, lpHelpFile, HELP_QUIT, NULL);
     Программа, которая вызывает WinHelp в некотором пункте во
время ее выполнения должна вызвать  WinHelp  c  использованием
mCommand параметра  для  установки  HELP_QUIT  перед тем,  как
программа выходит  из  WinMain  (типично  во  время  отработки
WM_DESTROY сообщения).
     Если программа открывает более чем  один  Help  файл,  то
тогда она  должна  вызвать  WinHelp для прекращения помощи для
каждого файла.
     Если программа или DLL открыли Help файл, однако более не
желают, чтобы связанный  пример  Help  средства  (WINHELP.EXE)
оставался активным,  то тогда программа или DLL должны вызвать
WinHelp с помощью mCommand параметра для установки  HELP_QUIT,
чтобы уничтожить пример Help средства.
     Ни при каких обстоятельствах программа или DLL не  должны
заканчиваться без  вызова  WinHelp для любого из открытых Help
файлов. Help файл открывается,  если любой другой WinHelp  вы-
зов, сделанный ранее с использованием Help имени файла.
     Windows Help программа не выходит до тех  пор,  пока  все
окна, которые  вызваны WinHelp не вызывают ее с использованием
mCommand для установки HELP_QUIT.  Если программа не в состоя-
нии делать так,  то тогда Help программа будет продолжать про-
гон после всех программ,  которые проводят запрос о завершении
Help.
                      Резюме

     В этой главе описывалось как создать Help  файл  проекта,
построить Help  файл ресурса и создать программу для доступа к
Help. Более подробную информацию смотрите ниже:
  Тема                Ссылка
 ───────────────────────────────────────────────────────────
  Планирование Help   Средства: Глава 2 " Планирование  Help
     системы          системы"
  Написание Help      Средства: Глава 3 "Создание Help тема-
     тем              тических файлов"
 ───────────────────────────────────────────────────────────












