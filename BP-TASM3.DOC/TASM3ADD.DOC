                    Дополнение для Borland C++ 3.1
    ══════════════════════════════════════════════════════════════════

                Новые средства Турбо ассемблера версии 3.1
     ─────────────────────────────────────────────────────────────────

          Турбо ассемблер версии 3.1 предусматривает  следующие  новые
     средства:

          1. Расширенные инструкции SETFIELD и GETFIELD.

             Когда исходное  значение  совпадает  с целевым регистром,
             инструкция SETFIELD больше не выполняет операцию  OR  над
             исходным значением. Вместо этого SETFIELD будет обеспечи-
             вать, что неустановленные поля целевого региста будут ну-
             левыми.

             Аналогично, если  вы используете при совпадении исходного
             и целевого регистра инструкцию  GETFIELD,  то  инструкция
             больше  не будет генерировать нефункциональную инструкцию
             "MOV приемник, источник".

          2. Дополнительные параметры командной строки.

             Турбо ассемблер 3.1 позволяет  теперь  задавать  дополни-
             тельные объектные форматы, используемые отдельными компо-
             новщиками. Это следущие параметры:

     ┌───────────────┬───────────────────────────────────────────────┐
     │    Параметр   │   Значение                                    │
     ├───────────────┼───────────────────────────────────────────────┤
     │   /o          │   Генерируются стандартные совместимые с TLINK│
     │               │   объектные файлы   с   разрешенной поддержкой│
     │               │   оверлеев.                                   │
     │               │                                               │
     │   /oi         │   Генерируются объектные файлы в формате, сов-│
     │               │   местимом с компоновщиком IBM.               │
     │               │                                               │
     │   /op         │   Генерируются объектные файлы в формате, сов-│
     │               │   местимом с компоновщиком Phar Lap.          │
     │               │                                               │
     │   /os         │   Генерируются стандартные совместимые с TLINK│
     │               │   объектные файлы   с   запрещенной поддержкой│
     │               │   оверлеев. Этот параметр задается по  умолча-│
     │               │   нию.                                        │
     └───────────────┴───────────────────────────────────────────────┘

          3. Новый атрибут сегмента и предупреждение о неинициализиро-
             ванном сегменте.

             Атрибут сегмента UNINIT позволяет вам выявлять  непредна-
             меренную запись инициализированных данных в неинициализи-
             рованные сегменты данных.  Использование данного атрибута
             в описании сегмента позволяет вам генерировать предупреж-
             дающее сообщение, уведомляющее об этой проблеме.

             Приведем пример сегментной директивы,  использующей новый
             атрибут:

                 BSS SEGMENT PUBLIC WORD UNINIT 'BSS'

             Данная директива  будет генерировать следующее предупреж-
             дающее сообщение:

                Warning: Data or code written to uninitialized segment
                (Предупреждение: Данные или код записываются в  неини-
                циализированный сегмент)

                Для запрещения данного сообщения используйте директиву
                NOWARN UNI.  Вновь разрешить это сообщение можно с по-
                мощью директивы WARN UNI.

          4. Директивы PUSHSTATE и POPSTATE.

             Директива PUSHSTATE сохраняет текущее оперативное состоя-
             ние внутреннего стека,  имеющего глубину 16 уровней.  Ди-
             ректива PUSHSTATE особенно полезна,  если у  вас  имеется
             код в макрокоманде,  функциирующий независимо от текущего
             оперативного состояния,  но не влияющий на текущий опера-
             тивный режим.

             Сохраняемая Турбо  ассемблером информация о состоянии со-
             держит:

             - текущую версию эмуляции (например, T310);
             - выбор режима (например, IDEAL, MASM, QUIRKS, MASM51);
             - переключатели EMUL и NOEMUL;
             - выбор текущего процессора и сопроцессора;
             - переключатели MULTERRS или NOMULTERRS;
             - переключатели SMART или NOSMART;
             - текущее основание системы счисления;
             - переключатели JUMPS или NOJUMPS;
             - переключатели LOCALS или NOLOCALS;
             - текущий префикс локального символа.

             Для возврате  последнего  сохраненного состояния из стека
             используйте директиву POPSTATE.

     ; примеры директив PUSHSTATE и POPSTATE

     ideal
     model small
     codeseg

     jumps
     locals  @@

             ; Показывает  изменение  состояние процессора,  основание
             ; чисел и режим JUMPS
             pushstate
             nojumps
             radix   2          ; Установить в двоичное основание
             p386
             jl      next1      ; После этого нет дополнительных NOPS
             mov     eax,100    ; Теперь 100 означает двоичное число
                                ; 100 или десятичное 4.
     next1:
             popstate           ; Восстановить JUMPS и режим не 386.

             ; Вернуться к директиве JUMPS, не 386 и десятичному осно-
             ; ванию

             jl      next2      ; Три дополнительных NOPS для
                                ; обработки JUMPS
             xor     eax,eax    ; Теперь не режим 386!

             mov     cx,100     ; Теперь 100 означает десятичное 100

             pushstate
             MULTERRS
             mov     ax,[bp+abc
             popstate

             mov     ax,[bp+abc


             ; Показазывает  запрещение  локальной  области   действия
             ; идентификаторов
             locals
     next2:
     @@a:    loop @@a
     next3:
     @@a:    loop @@a           ; Допутимо благодаря области действия
                                ; NEXT2: и NEXT3:

             pushstate
             nolocals
     next4:
     @@b:    loop @@b
     next5:
     @@b:    loop @@b           ; Это приведет к конфликту из-за
                                ; нелокальности
             popstate

             ; Показывает изменение префикса локального идентификатора
             ; и режим MASM/IDEAL
             pushstate
             masm
             locals @$

     testproc proc              ; Режим MASM для описания процедуры
              jmp    @$end

     @$end:   nop
     @@end:   ret
     testproc endp

     testproc2 proc
             jmp    @$end
     @$end:  nop                ; Это не приводит к конфликту с меткой
                                ; в TESTPROC
     @@end:  ret                ; Эта метка приведет к конфликту
     testproc2 endp
             popstate


             ; Теперь вернемся к @@ в качестве локального  префикса  и
             ; режиму IDEAL
     testproc2b proc            ; Это будет работать, так как мы снова
                                ; в режиме IDEAL
             ret
     testproc2b  endp           ; а это даст ошибку.

     proc    testproc3
             jmp    @$end2
     @$end2: nop
     @@end2: ret
     endp    testproc3

     proc    testproc4
             jmp    @$end2
     @$end2: nop                ; Эта метка не приведет к конфликту
     @@end2: ret                ; Эта метка не приведет к конфликту
                                ; с меткой в TESTPROC3
     endp    testproc4
     end


          5. Новые директивы процессора.

             Новые директивы  процессора добавлены для работы с платой
             486SX.

             .487 - разрешает ассемблирует инструкций  числового  про-
                    цессора 487.  Данная  инструкция работает только в
                    режиме MASM.

             P487 - разрешает ассемблирует инструкций  числового  про-
                    цессора 487.  Данная инструкция работает как в ре-
                    жиме MASM, так и в режиме Ideal.

          6. Подстановка текстовых присваиваний.

             Для улучшения совместимости с MASM в TASM 3.1 введены из-
             менения в характер постановки текстовых присваиваний. Это
             приводит к тому,  что старый код дает в TASM 3.1  ошибки,
             что можно устранить двумя способами:

             1) Используйте  директиву командной строки /UT300 для вы-
                бора обработки в стиле TASM 3.0.

             2) В начале строк,  которые вызывают ошибки в  TASM  3.1,
                но не в TASM 3.0,  явно используйте оператор текстовой
                макроподстановки %.

             Примером этого являются файлы WHEREIS.  Для WHEREIS, раз-
             мер  модели определятеся в командной строке следующим об-
             разом:

                TASM /dMDL=small iwhereis.asm

             Затем в IWHEREIS.ASM, код делает проверку, чтобы убедить-
             ся,  что определено MDL,  и, если это так, в TASM 3.0 ис-
             пользуется следующая строка кода:

                model MDL

             TASM 3.0 перед вычислением выражения автоматически  подс-
             тавляет значение MDL.  TASM 3.1 теперь требует от вас яв-
             ного указания оператора %:

                % model MDL


                         Исправления и добавления
             к "Руководству пользователя по Турбо ассемблеру"
     ─────────────────────────────────────────────────────────────────

                                Исправления

          На стp.  333 в Приложении D, "Утилиты," говорится, что спра-
     вочное  средство Турбо ассемблера называется TASMHELP.  Вы можете
     использовать TASMHELP как описывается в данном руководстве только
     если установите Турбо ассемблер в каталоге, отличном от Borland C
     ++.  В противном случае следует использовать утилиту THELP, кото-
     рая модифицирована таким образом, что может обращаться к множест-
     ву справочных файлов с помощью меню.

          Утилиту THELP можно использовать следующим образом:

          1) После установки Borland C++ и Турбо  ассемблера  вызовите
             THELP в ответ на подсказку DOS.

          2) Чтобы  вывести меню доступных справочных файлоа,  нажмите
             клавиши ALT-F.

          3) Для доступа к справочной информации по  Турбо  ассемблеру
             выберите файл TASM.TAH.

