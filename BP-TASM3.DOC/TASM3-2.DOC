     Турбо Ассемблер 3.0/tasm/#2-2                               = 1 =

   Глава 13. Расширенные инструкции..................................9
     Эффективная генерация кода: директивы SMART и NOSMART...........9
     Расширенные инструкции перехода................................10
     Дополнительные инструкции цикла процессора 80386...............11
     Дополнительные инструкции ENTER и LEAVE........................11
     Дополнительные инструкции возврата.............................11
     Расширенные инструкции PUSH и POP..............................12
     Инструкции PUSH и POP с несколькими операндами.................13
     Использование в инструкциях PUSH и POP указателей..............13
     Занесение в стек константа (процессор 8086)....................13
     Расширенные инструкции сдвига..................................15
     Принудительное переопределение сегментов: инструкции SEGxx.....15
     Дополнительные инструкции работы с флагами.....................16
     Дополнительные инструкции работы с битами полей................17
     Инструкция GETFIELD............................................19
     Дополнительная быстрая инструкции непосредственного
      умножения.....................................................19
     Расширение необходимых инструкций для процессора 80386.........20
     Вызов процедур с кадрами стека.................................22
     Вызываемые процедуры, содержащие RETURNS.......................23
     Вызов процедур методов для объектов: CALL...METHOD.............23
     Остаточная рекурсия для методов объектов: инструкция
      JMP...METHOD..................................................25
     Дополнительные инструкции для объектного программирования......25
   Глава 14. Использование макрокоманд..............................26
     Текстовые макрокоманды.........................................26
     Определение текстовых макрокоманд с помощью директивы EQU......26
     Директивы макрокоманд работы с текстовыми строками.............27
     Директива CATSTR...............................................28
     Директива SUBSTR...............................................28
     Директива INSTR................................................28
     Директива SIZESTR..............................................28
     Примеры макрокоманд работы с текстом...........................29
     Макрокоманды, состоящие из нескольких строк....................29
     Тело макрокоманды, состоящей из нескольких строк...............29
     Использование в макрокомандах символа &........................30
     Включение комментариев в тело макрокоманды.....................31
     Локальные формальные аргументы.................................31
     Директива EXITM................................................33
     Директива GOTO и макроидентификаторы перехода..................33
     Общие макрокоманды, состоящие из нескольких строк..............34
     Вызов общей макрокоманды, состоящей из нескольких строк........36
     Литеральные строки в угловых скобках...........................37
     Символ !.......................................................37
     Символ вычисления выражения %..................................38
     Переопределение общей макрокоманды, состоящей из нескольких
      строк.........................................................38
     Удаление общей макрокоманды: директива PURGE...................38
     Определение вложенных и рекурсивных макрокоманд................39
     Счетчик повторения макрокоманды................................40
     Директива WHILE................................................41
     Макрокоманды повторения строк..................................41
     Непосредственная макродиректива %..............................42

     Турбо Ассемблер 3.0/tasm/#2-2                               = 2 =

     Включение расширения макрокоманды в файл листинга..............43
   Глава 15. Использование условных директив........................44
     Синтаксис условных директив....................................44
     Директива условного ассемблирования IFxxx......................45
     Директивы условного ассемблирования ELSEIFxxx..................47
     Директивы генерации сообщений об ошибке ERRxx..................48
     Описания конкретных директив...................................49
     Безусловные директивы генерации сообщений об ошибке............49
     Условные директивы с выражениями...............................49
     Условные директивы с идентификатором...........................50
     Условные директивы с текстовыми строками.......................52
     Условия выполнения прохода Ассемблером.........................56
     Включение условных директив в файл листинга....................56
   Глава 16. Интерфейс с компоновщиком..............................58
     Описание внешних идентификаторов...............................58
     Соглашения для конкретного языка...............................58
     Описание общедоступных идентификаторов.........................58
     Описание идентификаторов библиотеки............................59
     Определение внешних идентификаторов............................60
     Описание глобальных идентификаторов............................60
     Определение общих переменных...................................60
     Включение библиотеки...........................................62
   Глава 17. Генерация листинга.....................................63
     Формат листинга................................................63
     Общие директивы управления листингом...........................64
     Директивы листинга включаемых файлов...........................65
     Директивы вывода блоков условного ассемблирования..............66
     Директивы вывода в файл листинга макрокоманд...................67
     Директивы вывода листинга перекрестных ссылок..................67
     Параметры изменения формата листинга...........................69
   Глава 18. Интерфейс Турбо Ассемблера и Borland C++...............73
     Вызов из Borland C++ функций Турбо Ассемблера..................74
     Основные моменты в интерфейсе Турбо Ассемблера и Borland
      C++...........................................................76
     Компоновка ассемблерных модулей с С++..........................77
     Использование Extern "C" для упрощения компоновки..............78
     Модели памяти и сегменты.......................................79
     Упрощенные директивы определения сегментов и Borland C++.......79
     Старые директивы определения сегментов и Borland C++...........80
     Значения по умолчанию: когда необходимо загружать сегменты?....83
     Общедоступные и внешние идентификаторы.........................86
     Подчеркивания и язык Си........................................86
     Различимость  строчных и прописные символов в
      идентификаторах...............................................88
     Типы меток.....................................................88
     Внешние дальние идентификаторы.................................90
     Командная строка компоновщика..................................91
     Взаимодействие между Турбо Ассемблером и Borland C++...........93
     Передача параметров............................................93
     Сохранение регистров..........................................101
     Возврат значений..............................................102
     Вызов функции Турбо Ассемблера из Borland C++.................104
     Написание на языке Ассемблера функций-элементов С++...........108

     Турбо Ассемблер 3.0/tasm/#2-2                               = 3 =

     Соглашения по вызовам, использующиеся в Паскале...............110
     Вызов Borland C++ из Турбо Ассемблера.........................111
     Компоновка с кодом инициализации С++..........................112
     Задание сегмента..............................................112
     Выполнение вызова.............................................112
     Вызов из Турбо Ассемблера функции Borland C++.................114
   Глава 19. Интерфейс Турбо Ассемблера с Турбо Паскалем...........117
     Совместное с Турбо Паскалем использование данных..............118
     Директива компилятора $L и внешние подпрограммы...............118
     Директива PUBLIC..............................................119
     Директива EXTRN...............................................119
     Ограничения при использовании объектов типа EXTRN.............122
     Использование корректировок сегментов.........................123
     Устранение неиспользуемого кода...............................125
     Соглашения Турбо Паскаля по передаче параметров...............125
     Параметры-значения............................................125
     Скалярные типы................................................125
     Вещественные значения.........................................126
     Типы Single, Double, Extended и Comp и типы сопроцессора
      8087.........................................................126
     Указатели.....................................................126
     Строки........................................................126
     Записи и массивы..............................................126
     Множества.....................................................127
     Параметры-переменные..........................................127
     Обеспечение стека.............................................127
     Доступ к параметрам...........................................128
     Использование для адресации к стеку регистра BP...............128
     Директива ARG.................................................129
     Турбо Паскаль и директива .MODEL..............................130
     Использование другого базового или индексного регистра........131
     Результаты функции в Турбо Паскале............................131
     Выделение пространства для локальных данных...................132
     Выделение статической памяти..................................132
     Выделение временной памяти....................................133
     Примеры подпрограмм на Ассемблере для Турбо Паскаля...........135
     Подпрограмма шестнадцатиричного преобразования общего
      назначения...................................................135
     Пример обмена содержимого двух переменных.....................138
     Пример анализа операционной среды DOS.........................141
 Часть 2. ПРИЛОЖЕНИЯ.............................................147
   Приложение A. Замечания по программированию.....................148
     Упрощенные директивы определения сегмента.....................148
     Программы DOS.................................................150
     Замечания по программам формата EXE...........................151
     Замечания по программам формата COM...........................152
     Программы Windows.............................................153
     Замечания по динамически компонуемым библиотекам Windows......153
     Замечания по прикладным программам Windows....................154
   Приложение B. Обзор синтаксических правил Турбо Ассемблера......156
     Лексическая грамматика........................................156
     Грамматика выражений в режиме MASM............................158
     Грамматика выражений в режиме Ideal...........................160

     Турбо Ассемблер 3.0/tasm/#2-2                               = 4 =

     Старшинство ключевых слов.....................................162
     Старшинство операций в режиме Ideal...........................162
     Старшинство операций в режиме MASM............................162
     Ключевые слова и предопределенные идентификаторы..............163
     Ключевые слова директив.......................................163
   Приложение C. Вопросы совместимости.............................168
     Одно- и двухпроходные режимы ассемблирования..................169
     Переменные операционной среды.................................170
     Формат фирмы Microsoft для двоичных чисел с плавающей
      точкой.......................................................170
   Приложение D. Утилиты Турбо Ассемблера..........................171
     Утилита-преобразователь H2ASH.................................171
   Приложение E. Сообщения об ошибках..............................174
     Информационные сообщения......................................174
     Предупреждающие сообщения и сообщения об ошибках..............176
     32-bit segment not allowed without .386.......................176
     Argument needs type override..................................176
     Argument to operation or instruction has illegal size.........177
     Arithmetic overflow...........................................177
     ASSUME must be segment register...............................177
     Bad keyword in SEGMENT statement..............................177
     Can't add relative quantities.................................177
     Can't address with currently ASSUMEd segment registers........178
     Can't convert to pointer......................................178
     Can't emulate 8087 instruction................................178
     Can't make variable public....................................179
     Can't override ES segment.....................................179
     Can't subtract dissimilar relative quantities.................179
     Can't use macro name in expression............................179
     Can't use this outside macro..................................179
     Code or data emission to undeclared segment...................180
     Constant assumed to mean Immediate const......................180
     Constant too large............................................180
     CS not correctly assumed......................................180
     CS override in protected mode.................................181
     CS unreachable from current segment...........................181
     Declaration needs name........................................181
     Directive ignored in Turbo Pascal model.......................181
     Directive not allowed inside structure definition.............182
     Duplicate dummy arguments:_...................................182
     ELSE or ENDIF without IF......................................182
     Expecting METHOD keyword......................................183
     Expecting offset quantity.....................................183
     Expecting offset or pointer quantity..........................183
     Expecting pointer type........................................183
     Expecting record field name...................................183
     Expecting register ID.........................................183
     Expecting scalar type.........................................183
     Expecting segment or group quantity...........................184
     Extra characters on line......................................184
     Forward reference needs override..............................184
     Global type doesn't match symbol type.........................184
     ID not member of structure....................................185

     Турбо Ассемблер 3.0/tasm/#2-2                               = 5 =

     Illegal forward reference.....................................185
     Illegal immediate.............................................185
     Illegal indexing mode.........................................186
     Illegal instruction...........................................186
     Illegal instruction for currently selected processor(s).......186
     Illegal local argument........................................186
     Illegal local symbol prefix...................................186
     Illegal mаcro argument........................................187
     Illegal memory reference......................................187
     Illegal number................................................187
     Illegal origin address........................................187
     Illegal override in structure.................................187
     Illegal override register.....................................188
     Illegal radix.................................................188
     Illegal register for instruction..............................188
     Illegal register multiplier...................................188
     Illegal segment address.......................................188
     Illegal use of constant.......................................189
     Illegal use of register.......................................189
     Illegal use of segment register...............................189
     Illegal USES register.........................................189
     Illegal version ID............................................189
     Illegal warning ID............................................189
     Instruction can be compacted with override....................190
     Invalid model type............................................190
     Invalid operand(s) to instruction.............................190
     Labels can't start with numeric characters....................190
     Line too long - truncated.....................................190
     Location counter overflow.....................................190
     Method call requires object name..............................191
     Missing argument list.........................................191
     Missing argument or <.........................................191
     Missing argument size variable................................191
     Missing COMM ID...............................................191
     Missing dummy argument........................................192
     Missing end quote.............................................192
     Missing macro ID..............................................192
     Missing module name...........................................192
     Missing or illegal language ID................................192
     Missing or illegal type specifier.............................193
     Missing table member ID.......................................193
     Missing term in list..........................................193
     Missing text macro............................................193
     Model must be specified first.................................193
     Module is pass-dependant - compatibility pass was done........193
     Name must come first..........................................194
     Near jump or call to different CS.............................194
     Need address or register......................................194
     Need angle brackets for structure fill........................194
     Need colon....................................................194
     Need expression...............................................195
     Need file name after INCLUDE..................................195
     Need left parenthesis.........................................195

     Турбо Ассемблер 3.0/tasm/#2-2                               = 6 =

     Need method name..............................................195
     Need pointer expression.......................................195
     Need quoted string............................................195
     Need register in expression...................................196
     Need right angle bracket......................................196
     Need right curly bracket......................................196
     Need right parenthesis........................................196
     Need right square bracket.....................................196
     Need stack argument...........................................197
     Need structure member name....................................197
     Not expecting group or segment quantity.......................197
     One non-null field allowed per union expansion................197
     Only one startup sequence allowed.............................198
     Open conditional..............................................198
     Open procedure................................................198
     Open segment..................................................198
     Open structure definition.....................................198
     Operand types do not match....................................199
     Operation illegal for static table member.....................199
     Pass-dependant construction encountered.......................199
     Pointer expression needs brackets.............................199
     Positive count expecting......................................200
     Record field too large........................................200
     Record member not found.......................................200
     Recursive definition not allowed for EQU......................200
     Register must be AL or AX.....................................200
     Register must be DX...........................................200
     Relative jump out of range by __ bytes........................201
     Relative quantity illegal.....................................201
     Reserved word used as symbol..................................201
     Rotate count must be constant or CL...........................201
     Rotate count out of range.....................................201
     Segment alignment not strict enough...........................202
     Segment attributes illegally redefined........................202
     Segment name is superfluous...................................202
     String too long...............................................202
     Symbol already defined:__.....................................203
     Symbol already different kind.................................203
     Symbol has no width or mask...................................203
     Symbol is not a segment or already part of a group............203
     Text macro expansion exceeds maximum line length..............203
     Too few operands to instruction...............................203
     Too many errors or warnings...................................204
     Too many initial values.......................................204
     Too many register multipliers in expression...................204
     Too many registers in expression..............................204
     Too many USES registers.......................................204
     Trailling null value assumed..................................205
     Undefined symbol..............................................205
     Unexpected end of file (no END directive).....................205
     Unknown character.............................................205
     Unmatched ENDP:_..............................................205
     Unmatched ENDS:_..............................................205

     Турбо Ассемблер 3.0/tasm/#2-2                               = 7 =

     User-generated error..........................................206
     Value out of range............................................206
     Сообщения о фатальных ошибках.................................207
     Bad switch....................................................207
     Can't find @file __...........................................207
     Сan't locate file __..........................................207
     Error writing to listing file.................................207
     Error writing to object file..................................207
     File not found................................................207
     File was changed or deleted while assembly in progress........208
     Insufficient memory to process command line...................208
     Internal error................................................208
     Invalid command line..........................................208
     Invalid number after _........................................208
     Out of hash space.............................................208
     Out of memory.................................................209
     Out of string space...........................................209
     Too many errors found.........................................209
     Unexpected end of file (no END directive).....................209

     Турбо Ассемблер 3.0/tasm/#2-2                               = 8 =


     Турбо Ассемблер 3.0/tasm/#2-2                               = 9 =

                     Глава 13. Расширенные инструкции
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер распознает все  стандартные  мнемоники  инс-
     трукций Intel,  применимые к текущему выбранному процессору. Дан-
     ная глава представляет собой  обзор  этих  инструкций.  Подробный
     перечень данных  инструкций  вы можете найти в кратком справочном
     руководстве.

           Эффективная генерация кода: директивы SMART и NOSMART
     ─────────────────────────────────────────────────────────────────

          Эффективная генерация кода означает, что Турбо Ассемблер мо-
     жет определить, что можно использовать различные инструкции более
     эффективно, чем  вы  это делаете.  Например,  в некоторых случаях
     можно заменить инструкцию LEA более короткой и быстрой инструкци-
     ей MOV:

          LEA AX,lval

     можно заменить на:

          MOV AX,OFFSET lval

          Турбо Ассемблер предусматривает директивы, которые позволяют
     вам использовать эффективную генерацию кода. Эти директивы описа-
     ны в следующей таблице:

                   Директивы эффективной генерации кода   Таблица 13.1
     ┌─────────────────┬──────────────────────────────────────────────┐
     │    Директива    │    Значение                                  │
     ├─────────────────┼──────────────────────────────────────────────┤
     │    SMART        │    Разрешает генерацию эффективного кода.    │
     │                 │                                              │
     │    NOSMART      │    Запрещает генерацию эффективного кода.    │
     └─────────────────┴──────────────────────────────────────────────┘

          По умолчанию  генерация эффективного кода разрешена.  Однако
     на генерацию эффективного кода влияют не только директивы SMART и
     NOSMART, но и директива VERSION.

                 Примечание: О директиве VERSION подробнее рассказыва-
            ется в Главе 3.

          Генерация эффективного кода влияет на следующие ситуации ге-
     нерации кода:

          - Замена инструкции LEA инструкцией MOV, если операндом инс-
            трукции LEA является простой адрес.

          - Где это возможно, выполняется генерация булевских инструк-
            ций со знаком,. Например, AND AX,+02 вместо AND AX,0002.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 10 =

          - Замена  инструкции  CALL  FAR  xxxx комбинацией инструкций
            PUSH CS, CALL NEAR xxxx, где целевой адрес xxxx использует
            тот же регистр CS.

          Использование эффективных инструкций облегчает написание эф-
     фективного кода.  Некоторые стандартные  инструкции  Intel  также
     расширены таким образом,  чтобы расширить их возможности и облег-
     чить использование. Они обсуждаются в следующих разделах.

                     Расширенные инструкции перехода
     ─────────────────────────────────────────────────────────────────

          Условные переходы,  такие  как JC или JE в процессорах 8086,
     80186 и 80286 могут быть только ближними (NAER),  то есть переход
     выполняется в  границах  сегмента  и на расстояние -128 байт +127
     байт относительно текущего адреса.  Это ограничение  действует  и
     для условных  инструкций цикла,  таких как JCXZ или LOOP (на всех
     процессорах фирмы Intel).

          Там, где это необходимо,  Турбо Ассемблер может генерировать
     дополнительные последовательности  переходов и обходить это огра-
     ничение. Например,  Турбо  Ассемблер может преобразовать инструк-
     цию:

          JC xxx

     в инструкции:

          JNC temptag
          JMP xxx

          Вы можете разрешить данную дополнительную последовательность
     переходов в  помощью  директивы JUMPS,  и запретить ее директивой
     NOJUMPS. По умолчанию Турбо Ассемблер не генерирует это средство.

          Когда вы указывает директиву JUMPS, Турбо Ассемблер резерви-
     рует достаточно  места для дополнительных последовательностей пе-
     рехода во всех условных переходах вперед. Когда определяется фак-
     тическое расстояние  перехода  вперед,  дополнительная последова-
     тельность может не понадобиться.  Когда это происходит, Турбо Ас-
     семблер для заполнения лишнего пространства генерирует инструкции
     NOP.

          Чтобы избежать дополнительных инструкций NOP, вы можете:

          - использовать переопределение условных  переходов, диапазон
            которых вам известен, например:

                    JC SHORT abc
                    ADD ax,ax
          abc:

          - задать параметр командной строки /m (подробнее о нем расс-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 11 =

            казывается в Главе 2).

             Дополнительные инструкции цикла процессора 80386
     ─────────────────────────────────────────────────────────────────

          В инструкциях  цикла  процессора  80386  в  качестве регист-
     ра-счетчика может использоваться регистр CX или  ECX. Стандартные
     мнемоники инструкций LOOP,  LOOPE,  LOOPZ,  LOOPNE и LOOPNZ фирмы
     Intel выбирают регистр-счетчик на основе того,  является ли теку-
     щий сегмент  кода  32-битовым  сегментом (тогда используется ECX)
     или 16-битовым (используется регистр CX).

          Турбо Ассемблер имеет специальные инструкции, которые увели-
     чивают гибкость средства LOOP.  Инструкции LOOP,  LOOPE,  LOOPWZ,
     LOOPWNE и LOOPWNZ используют в качестве счетчика регистр CX,  не-
     зависимо  от  текущего  сегмента.  Аналогично,  инструкции LOOPD,
     LOOPDE,  LOOPDZ, LOOPDNE и LOOPDNZ используют в качестве счетчика
     регистр ECX.

                  Дополнительные инструкции ENTER и LEAVE
     ─────────────────────────────────────────────────────────────────

          Инструкции ENTER и LEAVE используются для удаления  из стека
     кадра процедуры.  В зависимости от того, является текущий сегмент
     кода 16-битовым или 32-битовым,  стандартные инструкции  ENTER  и
     LEAVE будут модифицировать либо регистры BP и SP, либо EBP и ESP.
     Если сегмент кода - это 32-битовый сегмент, а сегмент стека - 16-
     битовый, то данные инструкции могут оказаться неподходящими.

          В Турбо  Ассемблере  предусмотрены 4 дополнительные инструк-
     ции, которые всегда выбирают конкретный размер  стека, независимо
     от размера сегмента кода. Инструкции ENTERW и LEAVEW всегда выби-
     рают в качестве регистров кадра стека BP и SP,  a ENTERD и LEAVED
     - регистры EBP и ESP.

                  Дополнительные инструкции возврата
     ─────────────────────────────────────────────────────────────────

          Стандартная инструкция RET генерирует код, который соответс-
     твующим образом завершает текущую процедуру.  Это включает в себя
     генерацию кода завершения процедуры,  которая  использует  интер-
     фейсные соглашения языка высокого уровня. Даже если для процедуры
     используются соглашения NOLANGUAGE,  инструкция RET в зависимости
     от описания  процедуры (описана она как NEAR или FAR) будет гене-
     рировать различный код.  Для процедуры NEAR Турбо Ассемблер гене-
     рирует дальнюю  инструкцию возврата.  Для процедуры FAR Турбо Ас-
     семблер генерирует ближнюю инструкцию  возврата.  (Вне  процедуры
     всегда генерируется ближний возврат.)

          Турбо Ассемблер  включает  в себя дополнительные инструкции,
     которые позволяют задавать генерацию  нужных инструкций  возврата
     (без кода завершения). Они перечислены в следующей таблице:


     Турбо Ассемблер 3.0/tasm/#2-2                              = 12 =

                            Инструкции возврата           Таблица 13.2
     ┌─────────────────┬─────────────────────────────────────────────┐
     │   Инструкция    │ Функция                                     │
     ├─────────────────┼─────────────────────────────────────────────┤
     │   RETN          │ Всегда генерирует ближний возврат.          │
     │                 │                                             │
     │   RETNF         │ Всегда генерирует дальний возврат.          │
     │                 │                                             │
     │   RETCODE       │ Генерирует возврат, тип  которого  соответ- │
     │                 │ ствует текущей выбранной модели. Для модели │
     │                 │ TINY, SMALL, COMPACT и TPASCAL генерируется │
     │                 │ ближний возврат. Для модели MEDIUM,  LARGE, │
     │                 │ HUGE и TCHUGE - дальний возврат.            │
     └─────────────────┴─────────────────────────────────────────────┘

                    Расширенные инструкции PUSH и POP
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер поддерживает несколько расширений инструкций
     PUSH и POP. Эти расширения существенно уменьшают объем ввода, не-
     обходимого для  задания расширенной последовательности инструкций
     PUSH  и POP.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 13 =

             Инструкции PUSH и POP с несколькими операндами
     ─────────────────────────────────────────────────────────────────

          На одной строке вы можете задать несколько инструкций PUSH и
     POP. Например:

          PUSH ax
          PUSH bx
          PUSH cx
          POP cx
          POP bx
          POP ax

     можно записать как:

          PUSH ax bx cx
          POP cx bx ax

          Чтобы Турбо Ассемблер распознавал наличие нескольких операн-
     дов в этих инструкциях, нужно чтобы любой операнд не мог рассмат-
     риваться как часть соседнего операнда, например инструкция:

          PUSH foo [bx]

     может привести к непредвиденному результату, поскольку foo,[bx] и
     foo[bx] являются  допустимыми  выражениями.  Чтобы эта инструкция
     стала определенней, можно  использовать  круглые  или  квадратные
     скобки, например:

          PUSH [foo] [bx]

            Использование в инструкциях PUSH и POP указателей
     ─────────────────────────────────────────────────────────────────

          Стандартные инструкции PUSH и POP не могут сохранять в стеке
     дальние указатели,  которые  требуют  4  байт в процессорах 8086,
     80186 и 80286 и 6 байт в процессоре 80386.

          Турбо Ассемблер допускает указание в инструкциях PUSH  и POP
     операнда-указателя  размером  DWORD для процессора 8086,  80186 и
     80286 и QWORD для процессора 80386.  Когда  обнаруживаются  такие
     инструкции, Турбо  Ассемблер генерирует инструкции PUSH и POP для
     двух частей операнда.

              Занесение в стек константа (процессор 8086)
     ─────────────────────────────────────────────────────────────────

          Хотя процессоры  80186б 80286 и 80386 среди основного набора
     инструкций  содержат инструкцию PUSH,  которая заносит в стек не-
     посредственное значение, в процессоре 8086 такой инструкции нет.

          Однако Турбо  Ассемблер  позволяет использовать в инструкции
     PUSH константы и в процессоре 8086.  При этом генерируется после-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 14 =

     довательность инструкций,  имеющая  тот же результат,  что и инс-
     трукция PUSH c операндом-константой для процессора 80186 и выше.

                 Примечание: Это средство вы можете использовать толь-
            ко при разрешении генерации эффективного кода.

          Последовательность инструкций,  которую  Турбо Ассемблер ис-
     пользуется для выполнения операции PUSH с константой, имеет длину
     около 10 байт.  Они короче и выполняются быстрее,  чем выполнение
     той же функции,  но их выполнение связано с  потерей  содержимого
     регистра, например:

          MOV ax, constant
          PUSH ax

          Данная последовательность имеет длину только 6  байт,  но  в
     процессе этого теряется содержимое регистра AX.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 15 =

                      Расширенные инструкции сдвига
     ─────────────────────────────────────────────────────────────────

          При использовании процессор 8086 инструкции сдвига RCL, RCR,
     ROL, ROR,  SHL,  SHR,  SAL и SAR не могут воспринимать  константу
     циклического  сдвига,  отличную  от 1.  При работе на процессорах
     80186,  80286 и 80386 можно использовать  константу  циклического
     сдвига со значением до 255.

          Когда Турбо Ассемблер обнаруживает инструкцию сдвига со зна-
     чением константы, большим 1 (при выборе процессора 8086),он гене-
     рирует соответствующее число инструкций сдвига со значением конс-
     танты циклического сдвига 1. Например, инструкции:

          .8086
          SHL ax,4

     генерируют последовательность:

          SHL   ax,1
          SHL   ax,1
          SHL   ax,1
          SHL   ax,1

       Принудительное переопределение сегментов: инструкции SEGxx
     ─────────────────────────────────────────────────────────────────

          В Турбо  Ассемблере  предусмотрены  6  инструкций,   которые
     приводят к генерации переопределений сегмента. Эти инструкции пе-
     речислены в следующей таблице:

                    Инструкции переопределения сегмента   Таблица 13.3
     ┌───────────────┬───────────────────────────────────────────────┐
     │    Инструкция │ Значение                                      │
     ├───────────────┼───────────────────────────────────────────────┤
     │    SEGCS      │ Генерирует префиксный байт переопределения CS.│
     │               │                                               │
     │    SEGSS      │ Генерирует префиксный байт переопределения SS.│
     │               │                                               │
     │    SEGDS      │ Генерирует префиксный байт переопределения DS.│
     │               │                                               │
     │    SEGES      │ Генерирует префиксный байт переопределения ES.│
     │               │                                               │
     │    SEGFS      │ Генерирует префиксный байт переопределения FS.│
     │               │                                               │
     │    SEGGS      │ Генерирует префиксный байт переопределения GS.│
     └───────────────┴───────────────────────────────────────────────┘

          Вы можете  использовать  эти инструкции в сочетании с такими
     инструкциями, как XLATB,  которые не требуют аргументов, но могут
     использовать переопределение сегментов, например:

          SEGCS XLATB

     Турбо Ассемблер 3.0/tasm/#2-2                              = 16 =


          Заметим, что в большинстве инструкций имеется альтернативная
     форма, при которой,  чтобы указать на необходимость переопределе-
     ния, вы можете задать пустой аргумент:

          XLAT BYTE cs:[bx]

          Приведенные два примера генерируют один и тот же код.

              Дополнительные инструкции работы с флагами
     ─────────────────────────────────────────────────────────────────

          Часто, чтобы улучшить эффективность и уменьшить размер кода,
     можно упростить  инструкции  работы  с  флагами.  Например,  если
     единственным желаемым результатом является  установка конкретного
     бита в AX,  а флаги процессора, на которые влияет данная инструк-
     ция, значение не имеют, инструкцию:

          OR ax,1000h

     можно упростить до инструкции:

          OR, ah,10h

          Турбо Ассемблер обеспечивает  4  дополнительных  инструкции,
     которые обеспечивают эти функциональные возможности. Они показаны
     в следующей таблице:

               Эффективные инструкции работы с флагами    Таблица 13.4
     ┌─────────────────┬────────────────┬─────────────────────────────┐
     │    Инструкция   │ Функция        │Соответствует инструкции     │
     ├─────────────────┼────────────────┼─────────────────────────────┤
     │    SETFLAG      │ Установка бит  │          OR                 │
     │                 │ (бита) флага.  │                             │
     │                 │                │                             │
     │    MASKFLAG     │ Размаскирование│          AND                │
     │                 │ бит (бита)     │                             │
     │                 │ флага.         │                             │
     │                 │                │                             │
     │    TESTFLAG     │ Проверка бит   │          TEST               │
     │                 │ (бита) флага.  │                             │
     │                 │                │                             │
     │    FLIPFLAG     │ Дополнение бит │          XOR                │
     │                 │ (бита) флага.  │                             │
     └─────────────────┴────────────────┴─────────────────────────────┘

          Эти инструкции можно использовать для  улучшения модульности
     записей, например:

          FOO        RECORD R0:1,R1:4,R2:3,R3:1
             .
             .
             .

     Турбо Ассемблер 3.0/tasm/#2-2                              = 17 =

             TESTFLAG AX,R0

          В данном примере TESTFLAG будет генерировать наиболее эффек-
     тивные инструкции, независимо от того, где в записи находится R0.

            Дополнительные инструкции работы с битами полей
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер  может  генерировать  специальные последова-
     тельности инструкций для задания значений и  извлечения  значений
     из битовых полей, заданных с помощью оператора RECORD. Это позво-
     ляет вам писать код, независимый от фактического расположения по-
     ля в записи.  При использовании их в сочетании с оператором ENUM,
     записи на языке ассемблера могут получить очень  высокий  уровень
     модульности. Список  данных инструкций приведен в следующей табли-
     це:

         Инструкции для установки и извлечения значения   Таблица 13.5
     ┌───────────────┬───────────────────────────────────────────────┐
     │   Инструкция  │  Функция                                      │
     ├───────────────┼───────────────────────────────────────────────┤
     │   SETFIELD    │  Устанавливает значение поля записи.          │
     │               │                                               │
     │   GETFIELD    │  Извлекает значение из поля записи.           │
     └───────────────┴───────────────────────────────────────────────┘

                            Инструкция SETFIELD
     ─────────────────────────────────────────────────────────────────

          Инструкция SETFIELD генерирует код, устанавливающий значение
     поля записи. Она имеет синтаксис:

          SETFIELD имя_поля регистр/память_приемник, регистр_источник

     где "имя_поля"  - имя поля записи,  "регистр/память_приемник" для
     SETFIELD представляет собой регистр или адрес в памяти  типа BYTE
     или WORD (DWORD для процессора 80386).  "Регистр_источник" должен
     быть регистром того же или меньшего размера.  Если источник мень-
     ше, чем приемник,  то регистр-источник должен быть младшей частью
     другого регистра,  имеющего тот же размер,  что и приемник.  Этот
     полный регистр  называется рабочим регистром.  Используйте данный
     регистр для сдвига значения в регистре-источнике,  благодаря чему
     оно выравнивается по приемнику. Например:

          FOO        RECORD R0:1,R1:4,R2:3,R3:1
             .
             .
             .
             SETFIELD  F1  AX,BL     ; рабочим регистром является BX
             SETFIELD  F1  AX,BH     ; недопустимо!

          SETFIELD сдвигает регистр-источник,  чтобы эффективно выров-
     нять его на поле приемника,  выполняет операцию OR и помещает ре-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 18 =

     зультат в регистр-приемник.

                Примечание: Операция SETFIELD уничтожает все  содержи-
           мое рабочего регистра.

          Чтобы выполнить свою функцию, инструкция SETFIELD генерирует
     эффективную и  расширенную  последовательность  инструкций   XOR,
     XCHG, ROL, ROR, OR и MOVZX.

          Операция SETFIELD  не  пытается  очистить целевое поле перед
     выполнением над его значением операции OR.  Если это  необходимо,
     вы можете   очистить  поле  явным  образом, используя  инструкцию
     MASKFLAG.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 19 =

                           Инструкция GETFIELD
     ─────────────────────────────────────────────────────────────────

          Инструкция GETFIELD извлекает данные из поля  записи. Логика
     ее работы противоположна инструкции SETFIELD. Она имеет следующий
     синтаксис:

          GETFIELD имя_поля регистр_приемник, регистр/память_источник

     где "имя_поля" и "регистр_приемник" работают так же, как в опера-
     ции SETFIELD. "Регистр/память_источник" можно использовать также,
     как "регистр_источник" в операции SETFIELD, например:

          FOO        RECORD R0:1,R1:4,R2:3,R3:1
             .
             .
             .
             GETFIELD  F1  AX,BL     ; рабочим регистром является BX
             GETFIELD  F1  AX,BH     ; недопустимо!

                Примечание: Операция GETFIELD уничтожает все  содержи-
           мое рабочего регистра.

          Операция GETFIELD извлекает значение  поля,  обнаруженное  в
     регистре-источнике или  по  адресу памяти,  и устанавливает в это
     значение соответствующую часть регистра-приемника.  На другие ре-
     гистры (кроме рабочего) и флаги процессора эта инструкция не вли-
     яет.

          Чтобы выполнить свою функцию, инструкция GETFIELD генерирует
     эффективную и  расширенную  последовательность  инструкций   MOV,
     XCHG, ROL и ROR.

      Дополнительная быстрая инструкции непосредственного умножения
     ─────────────────────────────────────────────────────────────────

          Для эффективной индексации массивов Турбо Ассемблер  обеспе-
     чивает специальную операцию непосредственного умножения. Инструк-
     ция FASTIMUL решает типичную проблему,  возникающую при  создании
     массива структур. Для процессора 8086 инструкция непосредственно-
     го умножения недоступна. Даже на более развитых процессорах умно-
     жение с использованием сдвигов и сложений выполняется в некоторых
     обстоятельствах существенно быстрее,  чем стандартная  непосредс-
     твенная инструкция IMUL. На основе текущего назначения процессора
     инструкция Турбо Ассемблера FASTIMUL выбирает между наиболее  эф-
     фективной доступной  последовательностью сдвигов и сложений и не-
     посредственной операцией IMUL текущего процессора (если она  име-
     ется). Инструкция FASTIMUL имеет следующий синтаксис::

          FASTIMUL регистр_приемник, регистр/память_источник, значение

          Данная инструкция  очень напоминает тернарную операцию IMUL,
     доступную на процессорах 80186, 80286 и 80386. Регистр-приемник -

     Турбо Ассемблер 3.0/tasm/#2-2                              = 20 =

     это  регистр  размером  в  слово (или двойное слово при работе на
     процессора 80386).  "Регистр/память_источник" - это  регистр  или
     адрес в памяти, который должен соответствовать размеру приемника.
     "Значение" - это фиксированная константа со знаком (множитель).

          Инструкция FASTIMUL использует для выполнения  своей функции
     комбинацию инструкций IMUL,  MOV,  NEG,  SHL, ADD и SUB. При этом
     содержимое регистра-источника (или адреса памяти) теряется. Флаги
     процессора не изменяются.

         Расширение необходимых инструкций для процессора 80386
     ─────────────────────────────────────────────────────────────────

          Процессор 80386 имеет возможность работы в 16-  или  32-раз-
     рядном режиме.  Многие стандартные инструкции в этих разных режи-
     мах имеют разный смысл.  В Турбо Ассемблере  размером  инструкции
     можно управлять с помощью используемых в выражениях переопределе-
     ний SMALL и LARGE.

          В общем случае,  если вы в  адресном  выражении  используете
     SMALL и LARGE,  операция управляет генерацией адресной части инс-
     трукции в зависимости от того, должна она быть 16- или 32-разряд-
     ной.

               Примечание: Более  подробно о переопределении размера с
          помощью операций SMALL и LARGE рассказывается в Главе 5.

          Когда SMALL или LARGE указывается вне адресной части выраже-
     ния, то  можно управлять тем,  какая инструкция выполняется - 16-
     или 32-битовая.  В тех случаях, когда размер инструкции определя-
     ется по  типу операнда,  Турбо Ассемблер сам выбирает размер инс-
     трукции. Действие SMALL и LARGE показано в следующей таблице.

                Примечание: Турбо Ассемблер выбирает  размер  инструк-
           ции,  используя SMALL и LARGE,  только когда нет другой ин-
           формации.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 21 =

                    Действие инструкций SMALL и LARGE     Таблица 13.6
     ┌─────────────────────────────┬─────────────────────────────────┐
     │ Инструкция                  │ Действие                        │
     ├─────────────────────────────┼─────────────────────────────────┤
     │ PUSH[SMALL/LARGE] сегм_рег  │ Выбирает, какая форма сегментно-│
     │                             │ го регистра  (16- или 32-разряд-│
     │                             │ ная) используется  в  инструкции│
     │                             │ PUSH.                           │
     │                             │                                 │
     │ POP[SMALL/LARGE] сегм_рег   │ Выбирает, какая форма сегментно-│
     │                             │ го регистра  (16- или 32-разряд-│
     │                             │ ная) используется  в  инструкции│
     │                             │ POP.                            │
     │                             │                                 │
     │ FSAVE[SMALL/LARGE] указ_пам │ Выбирает, какая форма  состояния│
     │                             │ с плавающей   точкой   (16-  или│
     │                             │ 32-разрядная) сохраняется.      │
     │                             │                                 │
     │ FRSTOR[SMALL/LARGE] указ_пам│ Выбирает, какая форма  состояния│
     │                             │ с плавающей   точкой   (16-  или│
     │                             │ 32-разрядная) восстанавливается.│
     │                             │                                 │
     │ FSTENV[SMALL/LARGE] указ_пам│ Выбирает, какая форма  состояния│
     │                             │ с плавающей   точкой   (16-  или│
     │                             │ 32-разрядная) записывается.     │
     │                             │                                 │
     │ FLDENV[SMALL/LARGE] указ_пам│ Выбирает, какая форма  состояния│
     │                             │ с плавающей   точкой   (16-  или│
     │                             │ 32-разрядная) загружается.      │
     │                             │                                 │
     │ LGDT[SMALL/LARGE] указ_пам  │ Выбирает, какая форма глобальной│
     │                             │ таблицы дескрипторов (16- или 32│
     │                             │ -разрядная) загружается.        │
     │                             │                                 │
     │ SGDT[SMALL/LARGE] указ_пам  │ Выбирает, какая форма глобальной│
     │                             │ таблицы дескрипторов (16- или 32│
     │                             │ -разрядная) сохраняется.        │
     │                             │                                 │
     │ LIDT[SMALL/LARGE] указ_пам  │ Выбирает,  какая  форма  таблицы│
     │                             │ дескрипторов прерываний (16- или│
     │                             │ 32-разрядная) загружается.      │
     │                             │                                 │
     │ SIDT[SMALL/LARGE] указ_пам  │ Выбирает,  какая  форма  таблицы│
     │                             │ дескрипторов прерываний (16- или│
     │                             │ 32-разрядная) сохраняется.      │
     │                             │                                 │
     │ JMP[SMALL/LARGE] указ_пам   │ Для адресов  памяти  размером  в│
     │                             │ двойное слово  (DWORD)  выбирает│
     │                             │ между 16-битовым  переходом  JMP│
     │                             │ типа  FAR и 32-битовым переходом│
     │                             │ JMP типа NEAR.                  │
     │                             │                                 │
     │  CALL[SMALL/LARGE] указ_пам │ Для адресов  памяти  размером  в│

     Турбо Ассемблер 3.0/tasm/#2-2                              = 22 =

     │                             │ двойное слово  (DWORD)  выбирает│
     │                             │ между 16-битовой     инструкцией│
     │                             │ CALL  типа FAR и 32-битовой инс-│
     │                             │ трукцией CALL типа NEAR.        │
     └─────────────────────────────┴─────────────────────────────────┘

                    Вызов процедур с кадрами стека
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер поддерживает  расширенную  форму  инструкции
     CALL, которая  позволяет  вам непосредственно вызывать процедуры,
     использующие интерфейсные соглашения языков высокого уровня.

          Аргументы процедурам,  использующим интерфейсные  соглашения
     языков высокого уровня,  передаются через стек в кадре стека. Пе-
     ред вызовом процедуры вызывающая программа должна занести эти ар-
     гументы в стек.

          Используемые процедурой  интерфейсные  соглашения определяют
     порядок, в котором аргументы должны заноситься в стек. Для проце-
     дур Бейсика,  Фортрана и Паскаля аргументы заносятся в стек в том
     порядке, в котором они указываются. Для языков Си и С++ аргументы
     заносятся в стек в обратном порядке.

          Используемые процедурой  интерфейсные  соглашения определяют
     также, должна удалять аргументы из стека после  вызова  процедуры
     сама процедура или вызывающая программа.  Языка Си и С++ требуют,
     чтобы стек очищала вызывающая программа.  Во всех  других  языках
     процедура должна  сама удалить аргументы из стека перед возвратом
     управления.

          Турбо Ассемблер с помощью расширенной  инструкции  CALL  сам
     выполняет за  вас функции по занесению аргументов в стек в нужном
     порядке и очисткой стека.  Вызов процедуры  с  параметрами  имеет
     следующий синтаксис:

          CALL выражение [язык] [,список_аргументов]

     где "выражение" является целью инструкции CALL, "язык" задает ис-
     пользуемые при вызове языковые соглашения.  Если  вы  не  задаете
     язык, Турбо  Ассемблер  использует по умолчанию язык,  заданный в
     директиве MODEL.

                Примечание: О директиве MODEL более подробнее  расска-
           зывается в Главе 7.

          Аргументы, если они имеются, указываются после идентификато-
     ра языка.  Синтаксис каждого аргумента в списке совпадает с  син-
     таксисом, который  используется  в расширенных инструкциях PUSH и
     POP. Вы можете разделить эти аргументы запятыми, например:

          CALL test PASCAL,ax,es OFFSET buffer,blen

     Турбо Ассемблер 3.0/tasm/#2-2                              = 23 =

          Поскольку в данном примере указан Паскаль,  Турбо  Ассемблер
     будет заносить аргументы в стек в том порядке, в котором они ука-
     заны.  Этот пример эквивалентен следующим инструкциям:

          PUSH ax
          PUSH es OFFSET buffer
          PUSH word PTR blen
          CALL test

          Вызов процедуры  Си  требует,  чтобы  аргументы заносились в
     стек в обратном порядке.  Турбо Ассемблер делает это автоматичес-
     ки, поэтому вызов вида:

          CALL test C,ax,es OFFSET buffer, word PTR blen

     даст в результате следующий код:

          PUSH word PTR blen
          PUSH es OFFSET buffer
          PUSH ax
          CALL test
          SUB sp,8

          При вызове процедуры с аргументами аргументы в списке следу-
     ет всегда указывать  в том порядке, в котором они следуют в заго-
     ловке процедуры.  При  необходимости  Турбо Ассемблер изменяет их
     порядок на обратный.

          Нужно не забывать разделять аргументы запятыми, а компоненты
     аргументов -  пробелами.  В  зависимости от соглашений указанного
     языка Турбо Ассемблер может заносить аргументы в стек  в обратном
     порядке, но порядок компонентов аргумента он не изменяет.

          Если при   вызове   используются   интерфейсные   соглашения
     NOLANGUAGE, Турбо Ассемблер при наличии любого аргумента сообщает
     об ошибке. Хотя аргументы для процедуры NOLANGUAGE можно задать с
     помощью директивы ARG, при вызове такой процедуры требуется явное
     занесение аргументов в стек.

                 Вызываемые процедуры, содержащие RETURNS
     ─────────────────────────────────────────────────────────────────

          Процедуры, определяющие  некоторые из своих аргументов с по-
     мощью ключевого слова RETURNS  требуют  отдельного  рассмотрения.
     Эти  аргументы  используются  для  возврата значений в вызывающую
     программу.  Таким образом,  вызывающая программа всегда извлекает
     их из стека.  Чтобы способствовать передаче этих аргументов, зад-
     анных  в описании процедуры после директивы RETURNS,  в Турбо Ас-
     семблере  нет специальных расширений инструкции CALL.  Перед инс-
     трукцией CALL вы должны явным образом занести  аргументы  в  стек
     (PUSH), а потом извлечь их их стека (POP).

     Турбо Ассемблер 3.0/tasm/#2-2                              = 24 =

           Вызов процедур методов для объектов: CALL...METHOD
     ─────────────────────────────────────────────────────────────────
          Инструкция CALL расширена таким образом,  чтобы поддерживать
     методы объектов. Вызов метода объекта может генерировать либо не-
     посредственный вызов  (для  статических методов),  либо косвенный
     вызов (для виртуальных методов).

          Поскольку вы можете использовать косвенный вызов,  выполняю-
     щие вызов инструкции  могут нарушить содержимое некоторых регист-
     ров. В этом случае,  если вы используете вызов виртуального мето-
     да, Турбо Ассемблер позволяет вам выбрать соответствующие регист-
     ры.
          Приведем синтаксис расширения CALL...METHOD:
          CALL указатель_экземпляра METHOD [имя_объекта:]имя_метода
             [USES [сегм_регистр:]регистр_смещения] [язык_и_аргументы]

     где "указатель_экземпляра"  должен описывать экземпляр объекта. В
     режиме MASM часто невозможно определить имя объекта, связанного с
     экземпляром. В этом случае Турбо Ассемблер позволяет использовать
     поле "имя_объекта", благодаря чему вы можете задать имя экземпля-
     ра объекта.

          Поле "имя_метода" содержит имя метода,  который должен вызы-
     ваться для конкретного экземпляра объекта.

                Примечание: О том, как задавать виртуальных или стати-
           ческий метод, подробнее рассказывается в Главе 8.

          Если метод является виртуальным,и требуется косвенный вызов,
     инструкция CALL...METHOD выполняет косвенный вызов через регистры
     ES:BX (ES:EBX для модели USE32 процессора 80386).  Если вы хотите
     использовать другие регистры,  можно переопределить их с  помощью
     оператора USES. Поле "сегм_регистр" это необязательный используе-
     мый сегментный регистр, а "регистр_смещения" - это регистр смеще-
     ния, используемый для вызова.

          Для объектов, описанных с помощью таблиц NEAR, CALL...METHOD
     загружает только регистр смещения.  Турбо Ассемблер предполагает,
     что сегментный регистр всегда установлен в корректное значение.

                 Примечание: Хорошей  практикой программирования явля-
            ется соответствующий  вызов  методов  с помощью косвенного
            вызова, даже когда вы знаете, что вызываемый метод являет-
            ся статическим.  При модификации объектов методы могут из-
            мениться со статических на виртуальные.

          Поле "язык_и_аргументы"  инструкции  CALL...METHOD  содержит
     необязательные спецификации языка и аргументов, которые идентичны
     по форме описанным в предыдущем разделе.

          Вызов процедур  методов  для  С++  и Паскаля требует обычно,

     Турбо Ассемблер 3.0/tasm/#2-2                              = 25 =

     чтобы экземпляр объекта передавался в качестве аргумента в стеке.
     Подробнее об этом рассказывается в Главе 18 и Главе 19.

    Остаточная рекурсия для методов объектов: инструкция JMP...METHOD
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер обеспечивает инструкцию JMP...METHOD,  соот-
     ветствующую инструкции  CALL...METHOD.  Она  имеет следующий син-
     таксис:

          JMP указатель_экземпляра METHOD [имя_объекта:]имя_метода
             [USES [сегм_регистр:]регистр_смещения]

          Инструкция JMP...METHOD   полностью   аналогична  инструкции
     CALL...METHOD, за исключением того, что она:

          - генерирует вместо инструкции CALL инструкцию JMP;

          - генерирует код завершения процедуры для очистки стека  пе-
            ред генерацией инструкции JMP.

          Инструкция JMP...METHOD  позволяет  писать  эффективный  код
     остаточной рекурсии (tail recursion). Она предназначена для заме-
     ны общей  ситуации,  когда инструкция  CALL...METHOD  дается  для
     конкретного метода с последующей инструкцией RET.

       Дополнительные инструкции для объектного программирования
     ─────────────────────────────────────────────────────────────────

          При создании  экземпляра  объекта требуется инициализировать
     указатель таблицы  виртуальных методом объекта (если он имеется),
     чтобы он указывал на корректную таблицу виртуальных методов.  Ин-
     струкция TBLINIT позволяет вам сделать это автоматически. Эта ин-
     струкция имеет следующий синтаксис:

          TBLINIT указатель_экземпляра_объекта

          Поле "указатель_экземпляра__объекта"  представляет собой ад-
     рес объекта, указатель таблицы виртуальных методов которого нужно
     инициализировать. Инструкция TBLINIT предполагает,  что экземпляр
     объекта должен иметь тип текущего объекта (другими  словами,  не-
     посредственно предшествующее  определение объекта определяет объ-
     ектный тип, который инициализирует TBLINIT). Например:

          TBLINIT DS:ST

      инициализирует указатель таблицы виртуальных методов объекта DS:
     SI (если она имеется).




     Турбо Ассемблер 3.0/tasm/#2-2                              = 26 =

                     Глава 14. Использование макрокоманд
     ─────────────────────────────────────────────────────────────────

          Макрокоманды позволяют вам задавать имя  идентификатора  для
     текстовой  строки  или блока кода,  которые будут часто использо-
     ваться в программе.  Однако макрокоманды выходят за рамки простой
     подстановки.  В Турбо Ассемблере имеются макрооперации, обеспечи-
     вающие большую гибкость в определении макрокоманд.  В сочетании с
     возможностью использования  макрокоманд из нескольких строк с ар-
     гументами это превращает макросредства Турбо Ассемблера  в  очень
     мощный инструмент.  В данной главе описывается, как можно исполь-
     зовать в программах текстовые макрокоманды и макрокоманды, состо-
     ящие из нескольких строк.

                       Текстовые макрокоманды
     ─────────────────────────────────────────────────────────────────

          Текстовая макрокоманда - это  идентификатор,  представляющий
     строку текстовых  символов.  Когда  Турбо  Ассемблер обнаруживает
     идентификатор в выражениях (и в других ситуациях), он подставляет
     вместо него текстовые символы. Например, если DoneMsg - это текс-
     товая макрокоманда,  имеющая значение "Returning to DOS", то сле-
     дующий оператор:

          GoodBy    DB DoneMsg

     дает в результате:

          GoodBy    DB 'Returning to DOS'

        Определение текстовых макрокоманд с помощью директивы EQU
     ─────────────────────────────────────────────────────────────────

          Для определения простых текстовых макрокоманд можно  исполь-
     зовать директиву EQU.Приведем синтаксис определения текстовой ма-
     крокоманды:

          имя   EQU  текстовая_строка

     где "текстовая_строка" связывается с  текстовой  макрокомандой  с
     именем "имя".  Для выделения текста вы можете заключить текстовую
     строку в угловые скобки (<>), например:

          DoneMsg    DB <'Returning to DOS'>

          Если в режиме MASM вы опустите скобки,  то  Турбо  Ассемблер
     будет определять,  можно  ли свести текстовую строку к выражению.
     Если ее вычислить нельзя,  Турбо Ассемблер будет интерпретировать
     текстовую  строку  как  текстовую  макрокоманду  (чтобы сохранить
     совместимость c MASM).  Чтобы обеспечить  правильное  определение
     текстовой строки,  нужно  всегда  заключать  ее в угловые скобки.
     Рассмотрим следующие ошибки,  которые могут  возникать,  если  вы
     этого не делаете:

     Турбо Ассемблер 3.0/tasm/#2-2                              = 27 =


          Earth   EQU dirt        ; Earth = "dirt"
          Planet  EQU Earth       ; Planet = "dirt" (неверно!)
          Planet  EQU <Earth>     ; Planet = "Earth" (верно!)

          В режиме Ideal оператор EQU всегда определяет текстовую мак-
     рокоманду.

          Текстовые макрокоманды  являются переопределяемыми. Вы може-
     те переопределить  текстовую  макрокоманду в том же модуле другой
     текстовой строкой.

           Директивы макрокоманд работы с текстовыми строками
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер обеспечивает директивы,  которые могут рабо-
     тать с текстовыми макрокоманд.  Эти директивы доступны  в  режиме
     Ideal и  для  версий  M510,  M520 и T300 (как задается директивой
     VERSION).

          Строковые аргументы для любой из этих  директив  могут  быть
     следующими:

          - текстовой строкой, заключенной в скобки, например, <abc>;

          - именем ранее определенной текстовой макрокоманды;

          - выражением с предшествующим символом %,  значение которого
            эквивалентно числовому представлению  строки  для текущего
            основания.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 28 =

                            Директива CATSTR
     ─────────────────────────────────────────────────────────────────

          Директива CATSTR определяет новую текстовую макрокоманду пу-
     тем конкатенации строк. Она имеет следующий синтаксис:

          имя CATSTR строка[,строка]...

          Директива CATSTR выполняет конкатенацию слева-направо. Турбо
     Ассемблер создает новую текстовую макрокоманду с именем "имя".

                            Директива SUBSTR
     ─────────────────────────────────────────────────────────────────

          Директива SUBSTR  определяет  новую  текстовую макрокоманду,
     которая является подстрокой строки.  Она имеет следующий  синтак-
     сис:

          имя SUBSTR строка,выражение_позиции[,выражение_размера]

          Новая текстовая макрокоманда с именем "имя" состоит из части
     строки ,  начинающейся с символа в позиции "выражение_позиции"  и
     длины "выражение_длины".  Если вы не указываете "выражение_разме-
     ра", новая текстовая макрокоманда содержит остаток строки,  начи-
     ная с символа в "выражении_позиции". Турбо Ассемблер рассматрива-
     ет первый символ строки как позицию 1.

                             Директива INSTR
     ─────────────────────────────────────────────────────────────────

          Директива INSTR  возвращает позицию одной строки внутри дру-
     гой. Она имеет следующий синтаксис:

          имя INSTR [выражение_начала,]строка_1,строка_2

          Турбо Ассемблер присваивает "имя" числовому значению,  кото-
     рое соответствует  первой  позиции первого вхождения "строки_2" в
     "строку_1". Первый символ "строки_1" имеет позицию 1. Если "стро-
     ка_2" в  "строке_1" не содержится,  то Турбо Ассемблер возвращает
     значение 0.  Если вы укажете "выражение_начала", то поиск начина-
     ется с символа, задаваемого этим выражением. Первый символ строки
     находится в позиции 1.

                            Директива SIZESTR
     ─────────────────────────────────────────────────────────────────

          Директива SIZESTR  возвращает  длину  текстовой макрокоманды
     (число символов в строке). Она имеет синтаксис:

          имя SIZESTR строка

     где "имя" устанавливается в числовое значение,  равное длине ука-
     занной строки. Нулевая строка <> имеет длину 0.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 29 =


                  Примеры макрокоманд работы с текстом
     ─────────────────────────────────────────────────────────────────

          Следующие примеры показывают, как работают эти операции:

          VERSION T300
          ABC     EQU       <abc>                 ; ABC = "abc"
          ABC2    EQU       ABC                   ; ABC2 = "ABC"
          ABC     EQU       <det>                 ; ABC = "det"
                                                  ; (переопределяется)
          ABC3    CATSTR    ABC2,<,>,ABC,<,>,ABC2 ;ABC3 = "ABC,DEF,
                                                  ; ABC"
          ABCLEN  SIZESTR   ABC                   ; ABCLEN = 3
          ABC3LEN SIZESTR   ABC3                  ; ABC3LEN = 11
          COMMA1  INSTR     ABC3,<,>              ; COMMA1 = 4
          COMMA2  INSTR     COMMA1+1,ABC3,<,>     ; COMMA2 = 8
          ABC4    SUBSTR    ABC3,5                ; ABC4 = "def,ABC"
          ABC5    SUBSTR    ABC3,5,3              ; ABC5 = "def"
          ABC6    EQU       3+2+1                 ; ABC6 = 6
                                                  ; (числовое
                                                  ; присваивание)
          ABC7    EQU       %3+2+1                ; ABC7 = "6"
                                                  ; (текстовая
                                                  ; макрокоманда)
          ABC8    EQU       %COMMA1               ; ABC8 = "4"

               Макрокоманды, состоящие из нескольких строк
     ─────────────────────────────────────────────────────────────────

          Макрокоманды, состояние из нескольких строк,  позволяют  вам
     определить в их теле инструкции, директивы или другие макрокоман-
     ды, которые будут включаться в исходный код при  вызове  макроко-
     манды. Вы  можете  указать аргументы макрокоманды,  которые Турбо
     Ассемблер будет подставлять в тело макрокоманды при  ее включении
     в модуле.

          Существует насколько  типов  макрокоманд,  состоящих из нес-
     кольких строк.  Одна версия  подставляет  каждый  элемент  строки
     (один за другим),  который является аргументом макрокоманды. Дру-
     гая версия повторяет определенное число  раз  тело  макрокоманды.
     Наконец, в одном месте вы можете определить еще одну версию,  ко-
     торая будет много раз вызываться.  Все эти версии имеют общее оп-
     ределение тела макрокоманды.

            Тело макрокоманды, состоящей из нескольких строк
     ─────────────────────────────────────────────────────────────────

          Независимо от содержимого тела макрокоманды,  средство обра-
     ботки макрокоманд  Турбо  Ассемблера интерпретирует макрокоманду,
     состоящую из нескольких строк, как просто несколько строк текста.
     Турбо Ассемблер позволяет вам заменить идентификаторы в теле мак-
     рокоманды текстом, заданным при вызове макрокоманды. Это средство

     Турбо Ассемблер 3.0/tasm/#2-2                              = 30 =

     называется подстановкой аргументов.  Идентификаторы в теле макро-
     команды, которые должны  быть  заменены,  называются  формальными
     (фиктивными) аргументами.  Предположим, например, что идентифика-
     тор foo - это формальный аргумент в следующем теле макрокоманды:

          PUSH foo
          MOV foo,1

          Если при  вызове  данной  макрокоманды  вы  присваиваете foo
     текстовую строку AX, то фактическим включаемым в модуль текст бу-
     дет:

          PUSH foo
          MOV AX,1

          Правила, которые Турбо Ассемблер использует для  распознава-
     ния формальных аргументов,  достаточно сложны. Рассмотрим, напри-
     мер, следующие строки тела макрокоманды,  где формальный аргумент
     foo не распознается:

          symfoo:
               DB 'It is foo time'

          В общем случае Турбо Ассемблер не  будет  распознавать  фор-
     мальный аргумент (без специального указания) в следующих ситуаци-
     ях:

          - когда он является частью другого идентификатора;

          - когда он находится внутри кавычек (' или ");

          - в  режиме  Ideal,  когда он указывается после двоеточия не
            внутри кавычек.

                 Использование в макрокомандах символа &
     ─────────────────────────────────────────────────────────────────

          Символ &  в теле макрокоманды имеет специальное значение.  В
     общем случае  & отделяет имя формального аргумента от окружающего
     текста, благодаря чему Турбо Ассемблер может распознавать его при
     подстановке. Если, например, имеется следующее тело макрокоманды:

          sym&foo:
               DB 'It is &foo time'

     и если  вы при вызове данной макрокоманды присвоите foo текстовую
     строку party, то фактическим включаемым в модуль текст будет сле-
     дующее:

          symparty:
               DB 'It is party time'

          В качестве другого примера можно привести следующий:

     Турбо Ассемблер 3.0/tasm/#2-2                              = 31 =


          foo&sym:
               DB 'We are in O&foo&o'

          Если вы при вызове данной макрокоманды присвоите foo тексто-
     вую строку  hi,  то  фактическим  включаемым в модуль текст будет
     следующее:

          hisym:
               DB 'We are in Ohio'

          Приведем правила для символа &:

          - вне заключенных в кавычки строк символ &  используется как
            разделитель;

          - внутри заключенной в кавычки строки и после двоеточия, ко-
            торое не находится в заключенной в кавычки строке в режиме
            Ideal, символ & должен предшествовать формальному аргумен-
            ту (чтобы этот аргумент мог распознаваться);

          - при расширении макрокоманды Турбо Ассемблер  удаляет  один
            символ & из группы таких символов.

          Последний пункт дает возможность помещать внутри макрокоманд
     макроопределения, требующие символа &. Турбо Ассемблер будет уда-
     лять только один символ & из группы.

               Включение комментариев в тело макрокоманды
     ─────────────────────────────────────────────────────────────────

          В особенно сложных макрокомандах иногда желательно поместить
     в теле макрокоманды комментарии, которые не должны включаться при
     ее расширении.  Это также уменьшает объем необходимой  Турбо  Ас-
     семблеру для обработки макрокоманд памяти.  Для этого используйте
     комментарий с предшествующей двойной  точкой  запятой  (в  начале
     строки). Например, следующее тело макрокоманды:

          ;; Это макрокоманда с комментарием
          DB 'макрокоманда с комментарием'

     приведет к включению при ее вызове только следующего текста:

          DB 'макрокоманда с комментарием'

                Примечание: Комментарии с одиночной точкой  с  запятой
           при вызове  макрокоманды  всегда включаются в макрорасшире-
           ние.

                     Локальные формальные аргументы
     ─────────────────────────────────────────────────────────────────

          В начале  тела  макрокоманды  вы всегда можете включить одну

     Турбо Ассемблер 3.0/tasm/#2-2                              = 32 =

     или более директив LOCAL.  Директива LOCAL описывает  специальные
     формальные аргументы,  которым при каждом расширении макрокоманды
     будет присваиваться уникальное символьное имя.

          Синтаксис директивы LOCAL в теле макрокоманды выглядит  сле-
     дующим образом:

          LOCAL формальный_аргумент_1 [,формальный_аргумент_2]...

          Если имя "формальный_аргумент", указанное в директиве LOCAL,
     не  содержит префикс локального идентификатора,  то присваиваемое
     ему уникальное имя идентификатора будет  иметь  вид  ??xxxx,  где
     xxxx  представляет  шестнадцатиричное  число.  В противном случае
     уникальное  символьное  имя  будет  иметь   вид   <локальный_пре-
     фикс>xxxx.

                Примечание: Подробности о разрешении локальных иденти-
           фикаторов и задании локального префикса можно узнать в Гла-
           ве 11.

          Вы можете  использовать формальные аргументы LOCAL для зада-
     ния в теле макрокоманды меток, например:

          LOCAL @agn, @zero
             XOR dx,dx
             MOV cx,exp
             MOV ax,1
             JCXZ @zero
             MOV bx,factor
          @agn: MUL bx
             LOOP @agn
          @zero:



     Турбо Ассемблер 3.0/tasm/#2-2                              = 33 =

                             Директива EXITM
     ─────────────────────────────────────────────────────────────────

          Директиву EXITM  можно  использовать в теле макрокоманды для
     принудительного завершения ассемблирования включаемого тела  мак-
     рокоманды. Она имеет следующий синтаксис:

          EXITM

          Когда Турбо  Ассемблер  обнаруживает  директиву EXITM в теле
     макрокоманды, которая включена в исходный код модуля, ассемблиро-
     вание расширенного  тела  макрокоманды  немедленно  прекращается.
     Вместо этого Турбо Ассемблер будет продолжать ассемблирование мо-
     дуля после конца макрокоманды.

          Для завершения макрокоманды при определенных условиях вы мо-
     жете использовать оператор EXITM с директивой условного ассембли-
     рования.

                Примечание: Директивы  условного  ассемблирования под-
           робнее рассматриваются в Главе 15.

              Директива GOTO и макроидентификаторы перехода
     ─────────────────────────────────────────────────────────────────

          Использование директивы GOTO и макроидентификаторов перехода
     позволяют вам управлять последовательностью расширения строк мак-
     рокоманды.  Вы можете поместить цель перехода в любом месте  тела
     макрокоманды. Она занимает всю строку макрокоманды и имеет следу-
     ющий синтаксис:

          :идентификатор_перехода

          При расширении макрокоманды все макроидентификаторы перехода
     отбрасываются.

          Директива GOTO сообщает Турбо Ассемблеру,  что нужно перейти
     на заданную  точку  исходного  кода,  а  именно - на "идентифика-
     тор_перехода". Это позволяет вам поместить GOTO в блоке условного
     ассемблирования. Например:

          IF foo
             GOTO tag1
          ENDIF
             DISPLAY "foo имеет значение false!"
          :tag
                   ; возобновление макрокоманды...
                   ; работает одинаково, независимо от того,
                   ; равно foo false или true

                Примечание: Будьте аккуратны и не создавайте  при  ис-
           пользовании  директивы GOTO бесконечных циклов. Бесконечные
           циклы могут привести к тому,  что Турбо Ассемблер исчерпает

     Турбо Ассемблер 3.0/tasm/#2-2                              = 34 =

           доступную память или даже прекратит работу.

          Подробнее о директивах условного ассемблирования рассказыва-
     ется в Главе 15.

            Общие макрокоманды, состоящие из нескольких строк
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер  связывает  тело макрокоманды,  состоящей из
     нескольких строк (включая директивы, инструкции и другие макроко-
     манды) с символьным именем макрокоманды.  При использовании имени
     макрокоманды в качестве  директивы  Турбо  Ассемблер  включает  в
     программу тело макрокоманды (операторы).  Таким образом вы можете
     использовать макрокоманду,  состоящую из нескольких  строк,  нес-
     колько раз.

          Приведем синтаксис  общей  макрокоманды  из нескольких строк
     режима Ideal:

          MACRO имя список_параметров
           тело_макрокоманды
          ENDM

          В режиме MASM общее определение макрокоманды  из  нескольких
     строк имеет следующий синтаксис:

          имя MACRO список_параметров
           тело_макрокоманды
          ENDM

     где "имя"  - это имя определяемой вами макрокоманды из нескольких
     строк. "Тело_макрокоманды" содержит операторы, которые составляет
     тело макрорасширения. В макрокоманду вы можете помещать любые до-
     пустимые операторы Турбо Ассемблера (и любое их число).  Макроко-
     манду завершает ключевое слово ENDM.

          В следующем   примере  определяется  макрокоманда  с  именем
     PUSHALL, которая при вызове включает в вашу программу тело макро-
     команды, состоящее из трех инструкций PUSH:

          PUSHALL MACRO
             PUSH AX BX CX DX
             PUSH DS SI
             PUSH ES DI
          ENDM

          "Список_параметров" -  это  список формальных аргументов (их
     идентификаторов) макрокоманды. Он имеет следующий синтаксис:

          [формальный_аргумент  [,формальный_аргумент]...]

          В макрокоманде вы можете использовать любое число формальных
     аргументов (если они не умещаются на одной строке,  для продолже-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 35 =

     ния на другой строке можно использовать символ /). Например:

          ADDUP MACRO dest,\       ; dest - это первый формальный
                                   ; аргумент, а s1,s2 -
                                   ; это второй и третий
                                   ; аргумент макрокоманды
             MOV dest,s1
             ADD dest,s2
          ENDM

          Каждый формальный аргумент имеет следующий синтаксис:

          имя_формального_аргумента[:тип_аргумента]

     где "имя_аргумента" - это символьное имя,  используемое для подс-
     тановки (вместо него) фактического параметра,  передаваемого мак-
     рокоманд при ее вызове. Необязательный "тип_аргумента" задает ка-
     кую-то информацию о виде фактического  параметра, воспринимаемого
     при вызове макрокоманды. Поддерживаются следующие типы:



     Турбо Ассемблер 3.0/tasm/#2-2                              = 36 =

                      Типы формальных аргументов          Таблица 14.1
     ┌──────────────────────┬────────────────────────────────────────┐
     │  Тип                 │ Значение                               │
     ├──────────────────────┼────────────────────────────────────────┤
     │  REQ                 │ Аргументы не  могут быть  нулевыми или │
     │                      │ состоять из пробелов.                  │
     │                      │                                        │
     │  =<текстовая_строка> │ Заключенная в кавычки текстовая строка │
     │                      │ задает используемое по умолчанию  зна- │
     │                      │ чение аргумента (когда фактический ар- │
     │                      │ гумент является нулевым или состоит из │
     │                      │ пробелов).                             │
     │                      │                                        │
     │  VARARG              │ Фактический аргумент  состоит  из  ос- │
     │                      │ тальной части макровызова, интерпрети- │
     │                      │ руемого  как  список  аргументов.  Для │
     │                      │ обеспечения этой интерпретации исполь- │
     │                      │ зуются угловые скобки, запятые.        │
     │                      │                                        │
     │  REST                │ Фактический аргумент  состоит  из  ос- │
     │                      │ тальной части макровызова, интерпрети- │
     │                      │ руемого  как непосредственный текст.   │
     └──────────────────────┴────────────────────────────────────────┘

         Вызов общей макрокоманды, состоящей из нескольких строк
     ─────────────────────────────────────────────────────────────────

          Чтобы вызвать общую макрокоманду,  используйте в вашей прог-
     раммы в  качестве  директивы  имя  макрокоманды.  Турбо Ассемблер
     вставляет в  этой  точке модуля (поле подстановок всех формальных
     аргументов) тело макрокоманды.  При  вызове  общей  макрокоманды,
     состоящей из нескольких строк, используется следующий синтаксис:

          имя_макрокоманды [аргумент [[,]аргументе]...]

     где "имя_макрокоманды" - это идентификатор макрокоманды.  Если вы
     вызываете макрокоманду с аргументами, то список аргументов указы-
     вается  после  имени  макрокоманды.  Вы можете задать любое число
     аргументов, но все они должны умещаться на одной строке. Аргумен-
     ты нужно отделять друг от друга запятыми или пробелами.  При рас-
     ширении макрокоманды Турбо Ассемблер заменяет  первый  формальный
     аргумент  макроопределения первым передаваемым аргументом, второй
     аргумент - вторым аргументом и т.д.

          Каждый "аргумент"  представляет текстовую строку.  Вы можете
     задать эту текстовую строку следующими способами:

          - как непрерывную группу символов,  не содержащую  пробелов,
            запятых или двоеточий;

          - как  группу  символов,  выделенную угловыми скобками (<>),
            которая может содержать пробелы, запятые и двоеточия;


     Турбо Ассемблер 3.0/tasm/#2-2                              = 37 =

          - как одиночный символ с предшествующим знаком !,  что экви-
            валентно заключению символа в угловые скобки;

          - как выражение с предшествующим символом %,  которое предс-
            тавляет текстовое значение выражения,  соответствующее те-
            кущему выбранному основанию.

                  Литеральные строки в угловых скобках
     ─────────────────────────────────────────────────────────────────

          Используйте угловые скобки для выделения литеральной строки,
     содержащей символы-разделители.  Следует  использовать  следующий
     синтаксис:

          <текст>

     где "текст"  интерпретируется  как  одиночный строковый параметр,
     даже если он содержит запятые, пробелы или символы табуляции, ко-
     торые обычно  разделяют  параметры.  Используйте данную операцию,
     когда вы хотите передать аргумент,  содержащий один из таких сим-
     волов.

          Вы можете также использовать эту операцию,  чтобы Турбо  Ас-
     семблер интерпретировал символ литерально, не придавая ему специ-
     альное значение. Например, если вы хотите передать в качестве па-
     раметра макровызова  точку с запятой (;),  то чтобы предотвратить
     ее интерпретацию как комментария,  вы можете заключить ее в угло-
     вые скобки (<;>).  При преобразовании заключенной в скобки строки
     в текстовый аргумент Турбо Ассемблер убирает только  один уровень
     угловых скобок.  Это  позволяет вызывать макрокоманду,  требующую
     наличия угловых скобок, из другой макрокоманды.

                                Символ !
     ─────────────────────────────────────────────────────────────────

          Символ !  позволяет вам вызывать макрокоманду с аргументами,
     которые содержат специальные символы.  Указание этого символа пе-
     ред другим символом эквивалентно заключению этого второго символа
     в угловые скобки.  Например, !; действует также, как <;>. Некото-
     рые общие случаи использования данного символа показаны в следую-
     щей таблице:

                   Использование специального символа !   Таблица 14.2
     ┌─────────────────┬─────────────────────────────────────────────┐
     │    Строка       │    Полученные в результате символ           │
     ├─────────────────┼─────────────────────────────────────────────┤
     │    !>           │            >                                │
     │                 │                                             │
     │    !<           │            <                                │
     │                 │                                             │
     │    !!           │            !                                │
     └─────────────────┴─────────────────────────────────────────────┘


     Турбо Ассемблер 3.0/tasm/#2-2                              = 38 =

                      Символ вычисления выражения %
     ─────────────────────────────────────────────────────────────────

          Символ % указывает Турбо Ассемблеру, что выражение нужно вы-
     числить. Ассемблер преобразует результат выражения к виду ASCII с
     текущим основанием.  Используйте данный символ,  когда в качестве
     макроаргумента вы хотите передать строку,представляющую вычислен-
     ный результат, а не само выражение. При этом используется следую-
     щий синтаксис:

          %выражение

     где "выражение"  может  быть  либо выражением (использующим любые
     допустимые операнды и операции), или именем текстовой макрокоман-
     ды. Если  это  выражение,  то создаваемым текстом будет результат
     выражения с текущим основанием.  Если "выражение" - это текстовая
     макрокоманда, то  создаваемым тестом будет текст,  который предс-
     тавляет  текстовая   макрокоманда.  Например,  следующий  фрагмент
     программы:

          DEFSYM               MACRO     NUM
          TMP_&NUM:
          ENDNUM

          TNAME            EQU       <JUNK> ; определение
                                            ; текстовой макрокоманды
          DEFSYM  %5+4
          DEFSYM  %TNAME

     приведет с следующему макрорасширению:

          TMP_9:
          TMP_JUNK:

    Переопределение общей макрокоманды, состоящей из нескольких строк
     ─────────────────────────────────────────────────────────────────

          Общие макрокоманды, состоящие из нескольких строк, вы можете
     переопределять. Новое  определение  автоматически заменяет старое
     определение. Все предшествующие места,  где макрокоманда уже была
     вызвана, не изменяются.  Во всех вызовах макрокоманды,  следующих
     за переопределением, используется новое определение.

              Удаление общей макрокоманды: директива PURGE
     ─────────────────────────────────────────────────────────────────

          Для удаления  макрокоманд  вы  можете использовать директиву
     PURGE. Директива PURGE имеет следующий синтаксис:

          PURGE имя_макрокоманды, [имя_макрокоманды]...

          Директива PURGE удаляет определение  макрокоманды, состоящей
     из нескольких строк,  с именем "имя_макрокоманды" После использо-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 39 =

     вания директивы PURGE Турбо Ассемблер  больше  не  интерпретирует
     идентификатор PURGE как макрокоманду, например:

          ADD MACRO a1,a2
             SUB a1,a2
          ENDM
             ADD ax,bx     ; этот вызов даст SUB ax,bx
          PURGE ADD
             ADD ax,bx     ; теперь это не макрокоманда, поэтому
                           ; вы получите ADD ax,bx

          Вы можете  сразу  удалить этой директивой несколько макроко-
     манд, разделив их имена запятыми. Отметим однако, что идентифика-
     тор  удаленной  макрокоманды  можно  переопределить только другой
     макрокомандой.

             Определение вложенных и рекурсивных макрокоманд
     ─────────────────────────────────────────────────────────────────

          Операторы в теле макрокоманды могут включать в себя операто-
     ры, вызывающие или определяющие другие макрокоманды. Возьмем сле-
     дующий пример:

          MCREATE         MACRO  opname, op1,op2,op3,op4,op5,op6,op7
             IFNB opname
                DO & opname MACRO op,count
                   IF count LE 4
                     REPT count
                       opname op,1
                     ENDM
                   ELSE
                     MOVE CL,count
                     opname op,CL
                  ENDIF
               EMDM                               ; конец DOopname
             MCREATE op1,op2,op3,op4,op5,op6,op7  ; рекурсия!
           ENDIF                      ; конец if
          ENDM                        ; конец макрокоманды MCREATE

          После вызова:

          MCREATE ror,rol,rcl,rcr,shl,sal,sar

     будут созданы  дополнительные  макрокоманды DOror,  DOrol и т.д.,
     которые можно использовать следующим образом:

          DOshr         ax,5
          DOrcr         bx,3

          Рекурсивные макрокоманды  можно вызывать со списком парамет-
     ров и задавать их таким образом,  что они будут работать с  пере-
     менным числом  параметров  (от  0 до максимального числа парамет-
     ров). Для этого макрокоманда должна использовать  первый параметр

     Турбо Ассемблер 3.0/tasm/#2-2                              = 40 =

     для выполнения  ее макрорасширения,  а затем вызывать сама себя с
     оставшимися параметрами.  При каждой рекурсии  остается  на  один
     параметр меньше. В конце концов, будет последняя рекурсия без па-
     раметров.

          Когда вы вызываете макрокоманду рекурсивно, всегда требуется
     как-то проверить конец рекурсии. Обычно при наличии передаваемого
     параметра это делается в теле макрокоманды  с  помощью  условного
     оператора IFNB. Приведем простой пример рекурсивной макрокоманды:

          PUSH MACRO r1,r2,r3,r4,r5,r6,r7,r8
          IFNB r1
              PUSH r1
              PUSH r2,r3,r4,r5,r6,r7,r8
          ENDIF
          ENDM

                     Счетчик повторения макрокоманды
     ─────────────────────────────────────────────────────────────────

         Для повторения тела макрокоманды  заданное число раз вы може-
     те использовать директиву повторения REPT. Для этого используется
     следующий синтаксис:

          REPT выражение
             тело_макрокоманды
          ENDM

     где "выражение"  указывает  Турбо  Ассемблеру,  сколько раз нужно
     повторить тело макрокоманды,  заданное между директивами  REPT  и
     ENDM. При вычислении "выражения" должна получаться константа. Оно
     не должно содержать имен идентификаторов с опережающими ссылками.
     Чтобы отметить  конец  блока  повторения,  используйте  директиву
     ENDM. Например, следующий код:

          REPT 4
              SHL ax,1
          ENDM

     даст в результате следующее:

          SHL  ax,1
          SHL  ax,1
          SHL  ax,1
          SHL  ax,1



     Турбо Ассемблер 3.0/tasm/#2-2                              = 41 =

                             Директива WHILE
     ─────────────────────────────────────────────────────────────────

          Для повторения тела макрокоманды до того момента, пока опре-
     деленное  выражение  не примет значения 0 (false),  вы можете ис-
     пользовать макродирективу WHILE. Она имеет следующий синтаксис:

          WHILE выражение
             тело_макрокоманды
          ENDM

          Перед каждой итерацией тела макрокоманды Турбо Ассемблер вы-
     числяет "выражение".  Будьте  аккуратны  и  избегайте бесконечных
     циклов, которые привести к тому,  что Турбо  Ассемблер  исчерпает
     доступную память или прекратит работу.  Приведем пример использо-
     вания директивы WHILE:

          WHILE  1
                         ;; ничего не делает
          ENDM

                      Макрокоманды повторения строк
     ─────────────────────────────────────────────────────────────────

          Для повторения  тела  макрокоманды  для  каждого  элемента в
     списке или каждого символа в строке вы можете использовать макро-
     директивы повторения IRP и IRPC.  Каждая из этих директив требует
     от вас  задания одного формального аргумента.  Приведем синтаксис
     директивы IRP:

          IRP формальный_аргумент, список_аргументов
             тело_макрокоманды
          ENDM

          Директива IRPC имеет следующий синтаксис:

          IRP формальный_аргумент, строка
             тело_макрокоманды
          ENDM

     в обоих случаях "формальный_аргумент" - это аргумент,  используе-
     мый в теле макрокоманды. Конец тела макрокоманды отмечает ENDM.

          В синтаксисе директивы IRP  "список_аргументов"  состоит  из
     спискам аргументов,  разделенных запятыми. Аргументами может быть
     любой текст (идентификаторы, строки, числа и т.д.). Форма каждого
     аргумента в списке аналогична той, которая описана выше для вызо-
     ва общей макрокоманды,  состоящей из нескольких строк. Список ар-
     гументов всегда нужно заключать в угловые скобки (<>).

          В синтаксисе  директива IRPC аргумент состоит из одной стро-
     ки. Строка может содержать столько символов, сколько вы хотите.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 42 =

          Для каждого аргумента или символа в строке  Турбо  Ассемблер
     будет включать в модуль тело макрокоманды, подставляя вместо фор-
     мального аргумента  аргумент  или  символ (когда он его находит).
     Например:

          IRP reg <ax,bx,cx,dx>
             PUSH reg
          ENDM

     дает следующее:

          PUSH  ax
          PUSH  bx
          PUSH  cx
          PUSH  dx

     а директива IRPC:

          IRPC LUCKY,1379
             DB LUCKY
          ENDM

     дает следующее:

          DB   1
          DB   2
          DB   3
          DB   4

          Используйте директива  IRPC  аккуратно,  поскольку Турбо Ас-
     семблер помещает каждый символ в строке  в  макрорасширение  "как
     есть", поэтому макрокоманда строкового повторения:

          IRPC CHAR,HELLO
               DB CHAR
          ENDM

     может дать не DB 'H','E'','L','L','O', а DB H,E,L,L,O (где каждая
     буква интерпретируется как имя идентификатора.

                    Непосредственная макродиректива %
     ─────────────────────────────────────────────────────────────────

          Непосредственная макродиректива  %   интерпретирует   строку
     текста так,  как если бы это было тело макрокоманды.  Приведем ее
     синтаксис:

          # строка_тела_макрокоманды

     где "строка_тела_макрокоманды"  представляет  тело  макрокоманды,
     используемое для непосредственного макрорасширения, например:

          SEGSIZE EQU <TINY>

     Турбо Ассемблер 3.0/tasm/#2-2                              = 43 =

          LANGUAGE EQU <WINDOWS PASCAL>

          % MODEL SEGSIZE,LANGUAGE   ; дает MODEL TINY,WINDOWS PASCAL

            Включение расширения макрокоманды в файл листинга
     ─────────────────────────────────────────────────────────────────

          Расширения макрокоманд, состоящих из нескольких строк, обыч-
     но включаются в файл листинга.  Однако в Турбо Ассемблере предус-
     мотрены следующей директивы:

          - .LALL

          - .SALL

          - .XALL

          - %MACS

          - %NOMACS

     которые позволяют управлять листингом макрорасширений.

                Примечание: Подробнее об этих директивах рассказывает-
           ся в Главе 17.




     Турбо Ассемблер 3.0/tasm/#2-2                              = 44 =

                Глава 15. Использование условных директив
     ─────────────────────────────────────────────────────────────────

          Существует два класса условных директив: директивы условного
     ассемблирования и условные директивы генерации сообщений об ошиб-
     ке. С помощью директив условного ассемблирования вы можете управ-
     лять тем,  какой код будет ассемблироваться в программе при опре-
     деленных условиях.

          Директивы условного ассемблирования позволяют вам  генериро-
     вать во  время ассемблирования сообщения об ошибках при наступле-
     нии определенных событий.  Турбо Ассемблер выводит  сообщение  об
     ошибке на экран и в файл листинга и предотвращает создание объек-
     тного файла.  В данной главе описывается,  как можно использовать
     имеющиеся условные директивы.

                    Синтаксис условных директив
     ─────────────────────────────────────────────────────────────────

          Тремя директивами условного ассемблирования являются  дирек-
     тивы IFxxx, ELSEIFxxx и ERRxxx. Эти директивы используются также,
     как операторы условия в языках высокого уровня.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 45 =

                Директива условного ассемблирования IFxxx
     ─────────────────────────────────────────────────────────────────

          Вы можете  использовать  директиву условного ассемблирования
     IFxxx для определения блока кода,  который включается в объектный
     файл при удовлетворении определенных условий (таких как определе-
     ние идентификатора или установка  какого-то  значения).  Приведем
     синтаксис оператора условного ассемблирования:

          IFxxx
            тело_условия_true
          EMDIF

     или
          IFxxx
            тело_условия_true
          ELSE
            тело_условия_false
          ENDIF

     где IFxxx представляет следующие директивы:

          IF
          IF1
          IF2
          IFDEF
          IFNDEF
          IFB
          IFNB
          IFIDN
          IFIDNI
          IFDIF
          IFDIFI

          Каждая директива  условного  ассемблирования  IFxxx   задает
     конкретное условие,  при  вычислении которого получается истинное
     (true) или ложное (false) значение.  Если условие имеет  значение
     true, то выполняется ассемблирование и помещение в объектный файл
     блока ассемблируемого кода "тело_условия_true". Если при вычисле-
     нии условия получается значение false, то Турбо Ассемблер пропус-
     кает "тело_условия_true" и не включает его в объектный  файл. При
     наличие директивы ELSE, если условие имеет значение false, то ас-
     семблируется и  выводится  в  объектный  файл  блок   "тело_усло-
     вия_false".  Если условие имеет значение true, то этот блок игно-
     рируется. Условный блок завершается директивой ENDIF.

          Кроме особых случаев директив IF1 и IF2 (которые  мы обсудим
     позднее) два  описанных блока кода являются  взаимноисключающими:
     в объектный файл включается либо "тело_условия_true", либо "тело_
     условия_false", но не оба блока одновременно. Кроме того, если вы
     используете форму IFxxx...ELSE...ENDIF, один из блоков будет обя-
     зательно включаться  в  объектный  файл.  Если используется форма
     IFxxx...ENDIF, то "тело_условия_true"  может  включаться  или  не

     Турбо Ассемблер 3.0/tasm/#2-2                              = 46 =

     включаться в объектный файл, в зависимости от условия.

          При использовании  вложенных  директив  IF  и ELSE директива
     ELSE всегда соответствует ближайшей директиве IF.

          В следующем примере test является  идентификатором,  который
     управляет включением  кода  (если идентификатор не определен,  то
     генерируется соответствующий блок кода) Идентификатор color уста-
     навливается в ненулевое значение,  если дисплей цветной,  и равен
     0, если дисплей монохромный.

          От этих значений зависит фактическая генерация кода:

          .
          .
          .
          IFDEF test                     ; true, если test определен
             ; первая часть блока кода   ; если test определен
          IF color                       ; true, если color <> 0
             ; блок кода color           ; если color <> 0
          ELSE                           ;
                                         ; код для монохромного
                                         ; дисплея если color = 0
          ENDIF                          ;
            ; вторая часть блока кода    ; если test определен
          ELSE                           ;
           ; другой код                  ; если test не определен
          ENDIF
          .
          .
          .

     ┌────────────┬──────────┬───────────┬──────────────┬────────────┐
     │   test     │определен │ определен │ не определен │не определен│
     │   color    │   0      │   не 0    │       0      │    не 0    │
     ├────────────┼──────────┼───────────┼──────────────┼────────────┤
     │    код     │ блок кода│ блок кода │  другой код  │другой код  │
     │            │    1     │    1      │              │            │
     │            │          │           │              │            │
     │цветной/моно│ блок кода│ блок кода │  блок кода   │            │
     │            │   color  │     2     │      2       │            │
     └────────────┴──────────┴───────────┴──────────────┴────────────┘

          Если идентификатор test не определен,то не ассемблируется ни
     код для цветного дисплея (color),  ни для монохромного, поскольку
     все это включено в блок условного  ассемблирования,  который  ас-
     семблируется только при определенном идентификаторе test.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 47 =

              Директивы условного ассемблирования ELSEIFxxx
     ─────────────────────────────────────────────────────────────────

          Вы можете использовать директивы  условного  ассемблирования
     ELSEIFxxx как  сокращенную  форму,  когда  требуется использовать
     несколько директив IF. Директива ELSEIFxxx представляет собой эк-
     вивалент директивы  ELSE,  за которой следует вложенная директива
     IFxxx, но дает более компактный код. Например:

          .
          .
          .
          IF mode EQ 0
             ; кода для mode = 0
          ELSEIF mode LT 5
             ; код для coe = 1..4
          ELSE
             ; код для mode = 5...
          ENDIF
          .
          .
          .

     сравните его со следующим:

          .
          .
          .
          IF mode EQ 0
             ; кода для mode = 0
          ELSE
           IF mode LT 5
             ; код для coe = 1..4
          ELSE
             ; код для mode = 5...
           ENDIF
          ENDIF
          .
          .
          .

          Вне оператора IFxxx директиву ELSEIFxxx использовать нельзя.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 48 =

              Директивы генерации сообщений об ошибке ERRxx
     ─────────────────────────────────────────────────────────────────

          Директива ERRxxx  генерирует при удовлетворении определенных
     условий сообщения пользователя об ошибке. Она имеет следующий об-
     щий синтаксис:

          ERRxxx [аргументы] [сообщение]

          В этом  случае  директива  ERRxxx представляет какую-либо из
     директив условной  генерации  сообщения  об  ошибке  (такие   как
     ERRIFB, .ERRB и т.д.).

          "Аргументы" представляют  аргументы,  которые могут потребо-
     ваться в директиве для вычисления  условия.  Некоторые  директивы
     требуют выражения,  другие требуют символьного выражения, а неко-
     торые - одно или два текстовых выражений.  Некоторые из  директив
     вовсе не требуют аргументов.

          Если указано "сообщение", то оно задает необязательное сооб-
     щение, которое выводится с ошибкой.  Сообщение должно быть заклю-
     чено в кавычки (' или ").

          Директивы генерации сообщений об ошибке генерируют пользова-
     тельское сообщение  об  ошибке,  которое  выводится  на  экран  и
     включается в файл листинга (если он имеется) в месте расположения
     директивы в исходном коде.  Если директива задает сообщение,  оно
     выводится на  той же строке непосредственно за ошибкой. Например,
     директива:

          ERRIFNDEF foo "foo не определено!"

     если идентификатор foo не определен при обнаружении ошибки,  при-
     ведет к генерации ошибки:

          User error: "foo не определено!"



     Турбо Ассемблер 3.0/tasm/#2-2                              = 49 =

                     Описания конкретных директив
     ─────────────────────────────────────────────────────────────────

            Далее следует описание директив.

           Безусловные директивы генерации сообщений об ошибке
     ─────────────────────────────────────────────────────────────────

          Безусловными директивами генерации сообщений об ошибке явля-
     ются директивы ERR и .ERR. Эти директивы всегда генерируют ошибку
     и не требуют аргументов,  хотя могут содержать необязательное со-
     общение. Директиву .ERR можно использовать только в режиме MASM.

                    Условные директивы с выражениями
     ─────────────────────────────────────────────────────────────────

          Эти директивы  обеспечивают условное ассемблирование или ге-
     нерацию сообщений об ошибке на основе  результатов  вычисления  в
     Турбо Ассемблере выражения.  Во всех этих директивах при вычисле-
     нии выражения должна получаться константа,  и оно не может содер-
     жать опережающих ссылок. Если при вычислении выражения получается
     0, Турбо Ассемблер рассматривает выражение, как ложное (false). в
     противном случае оно рассматривается как истинное (true).

          В следующей таблице показаны директивы условного ассемблиро-
     вания, использующие выражения.

        Директивы условного ассемблирования, использующие сообщения
                                                          Таблица 15.1
     ┌─────────────────────┬─────────────────────────────────────────┐
     │  Директива IFxxx    │ Ассемблирует "тело_условия_true" если:  │
     ├─────────────────────┼─────────────────────────────────────────┤
     │  IF выражение       │ при  вычислении   выражения  получается │
     │                     │ значение true.                          │
     │                     │                                         │
     │  IFE выражение      │ при  вычислении   выражения  получается │
     │                     │ значение false.                         │
     │                     │                                         │
     │  ELSEIF выражение   │ при  вычислении   выражения  получается │
     │                     │ значение true.                          │
     │                     │                                         │
     │  ELSEIFE выражение  │ при  вычислении   выражения  получается │
     │                     │ значение false.                         │
     └─────────────────────┴─────────────────────────────────────────┘

          В следующей таблице показаны  директивы  генерации сообщений
     об ошибке, в которых используются выражения:

      Директивы генерации сообщений об ошибке, использующие выражения


     Турбо Ассемблер 3.0/tasm/#2-2                              = 50 =

                                                         Таблица. 15.2
     ┌────────────────────┬──────────────────────────────────────────┐
     │  Директива ERRxxx  │ Генерируется сообщение user error, если: │
     ├────────────────────┼──────────────────────────────────────────┤
     │  ERRIF выражение   │ при вычислении выражения получается зна- │
     │                    │ чение true.                              │
     │                    │                                          │
     │  .ERRNZ выражение  │ при вычислении выражения получается зна- │
     │                    │ чение true (только в режиме MASM).       │
     │                    │                                          │
     │  ERRIFE выражение  │ при вычислении выражения получается зна- │
     │                    │ чение false.                             │
     │                    │                                          │
     │  .ERRE выражение   │ при вычислении выражения получается зна- │
     │                    │ чение false (только в режиме MASM).      │
     └────────────────────┴──────────────────────────────────────────┘

                  Условные директивы с идентификатором
     ─────────────────────────────────────────────────────────────────

          Эти директивы обеспечивают условное ассемблирование или  ге-
     нерацию сообщения  об ошибке на основе того,  является ли опреде-
     ленным один или более идентификаторов. Данные идентификаторы объ-
     единены в выражение с идентификаторами.

          Выражение с  идентификаторами - это выражение,  состоящее из
     имен идентификаторов,  булевских операций AND,  OR, NOT и круглых
     скобок. В  выражении с идентификаторами каждое имя идентификатора
     интерпретируется как булевское значение,  при вычислении которого
     получается значение true,  если идентификатор существует (опреде-
     лен), или false,  если идентификатор не существует (даже если  он
     определяется в  модуле позднее).  Турбо Ассемблер комбинирует эти
     значения, используя булевские операции,  для получения  конечного
     значения true  или  false.  В  своей простейшей форме выражение с
     идентификаторами содержит имя единственного идентификатора и дает
     при вычислении значение true,  если этот идентификатор определен.
     Синтаксические правила в выражении с  идентификаторами аналогичны
     тем, которые  используются в выражениях Турбо Ассемблера.  Напри-
     мер, если идентификатор foo определен, а идентификатор bar - нет,
     то при вычислении выражения с идентификаторами получаются следую-
     щие результаты:

         Вычисление определенных и неопределенных идентификаторов


     Турбо Ассемблер 3.0/tasm/#2-2                              = 51 =

                                                          Таблица 15.3
     ┌───────────────────────────────────┬───────────────────────────┐
     │    Выражение с идентификаторами   │         Результат         │
     ├───────────────────────────────────┼───────────────────────────┤
     │    foo                            │    True                   │
     │                                   │                           │
     │    bar                            │    False                  │
     │                                   │                           │
     │    not foo                        │    False                  │
     │                                   │                           │
     │    not bar                        │    True                   │
     │                                   │                           │
     │    foo OR bar                     │    True                   │
     │                                   │                           │
     │    foo AND bar                    │    False                  │
     │                                   │                           │
     │    NOT (foo AND bar)              │    True                   │
     │                                   │                           │
     │    NOT foo OR NOT bar             │    True (то же, что       │
     │                                   │  (NOT foo) OR (NOT bar)   │
     └───────────────────────────────────┴───────────────────────────┘

          В следующей  таблице  показаны директивы,  которые управляют
     ассемблированием и используют выражение с идентификаторами:

     Директивы, использующие выражение с идентификаторами Таблица 15.4
     ┌────────────────────────┬──────────────────────────────────────┐
     │Директива IFxxx         │ Ассемблирует "тело_условия_true" если│
     ├────────────────────────┼──────────────────────────────────────┤
     │IFDEF выражение_ид      │ при вычислении  выражения  получается│
     │                        │ значение true.                       │
     │                        │                                      │
     │IFNDEF выражение_ид     │ при вычислении  выражения  получается│
     │                        │ значение false.                      │
     │                        │                                      │
     │ELSEIFDEF выражение_ид  │ при вычислении  выражения  получается│
     │                        │ значение true.                       │
     │                        │                                      │
     │ELSEIFNDEF выражение_ид │ при вычислении  выражения  получается│
     │                        │ значение false.                      │
     └────────────────────────┴──────────────────────────────────────┘

          В следующей  таблице  показаны директивы выводы сообщения об
     ошибке, которые используют выражение с идентификаторами:



     Турбо Ассемблер 3.0/tasm/#2-2                              = 52 =

             Директивы генерации сообщения об ошибке      Таблица 15.5
     ┌────────────────────────┬──────────────────────────────────────┐
     │Директива IFxxx         │ Ассемблирует "тело_условия_true" если│
     ├────────────────────────┼──────────────────────────────────────┤
     │ERRIFDEF выражение_ид   │ при вычислении  выражения  получается│
     │                        │ значение true.                       │
     │                        │                                      │
     │.ERRDEF выражение_ид    │ при вычислении  выражения  получается│
     │                        │ значение  true  (только  для   режима│
     │                        │ MASM).                               │
     │                        │                                      │
     │ERRIFNDEF выражение_ид  │ при вычислении  выражения  получается│
     │                        │ значение false.                      │
     │                        │                                      │
     │.ERRNDEF выражение_ид   │ при вычислении  выражения  получается│
     │                        │ значение  false  (только   в   режиме│
     │                        │ MASM).                               │
     └────────────────────────┴──────────────────────────────────────┘

          Например, следующие  условия  генерации  сообщения об ошибке
     эквивалентны и приводят к генерации ошибки в  случае  определения
     foo и bar:

          ERRIFDEF foo AND bar
          ERRIFNDEF NOT ( foo AND bar )
          ERRIFBDEF NOT foo OR NOT bar

                Условные директивы с текстовыми строками
     ─────────────────────────────────────────────────────────────────

          Эти директивы условное ассемблирование или генерацию сообще-
     ний об  ошибке на основе содержимого текстовой строки.  Текстовой
     строкой может быть либо  строка,  заключенная  в  угловые  скобки
     (<>), либо  имя  текстовой макрокоманды с предшествующим символом
     %. Например:

          <ABC>                ; текстовая строка ABC
          %foo                 ; содержимое текстовой макрокоманды foo

                Примечание: Об определении текстовых макрокоманд и ра-
           боте с ними рассказывается в Главе 14.

          Директивы условного ассемблирования,  использующие текстовую
     строку, показаны в следующей таблице:

                            Директивы условного


     Турбо Ассемблер 3.0/tasm/#2-2                              = 53 =

          ассемблирования, использующие текстовую строку  Таблица 15.6
     ┌──────────────────────┬────────────────────────────────────────┐
     │ Директива IFxxx      │ ассемблирует "тело_условия_true", если:│
     ├──────────────────────┼────────────────────────────────────────┤
     │ IFNB текст_строка    │ "текст_строка" не состоит из одних про-│
     │                      │ белов.                                 │
     │                      │                                        │
     │ IFB текст_строка     │ "текст_строка" не пуста.               │
     │                      │                                        │
     │ IFIDN текст_строка_1,│ "текст_строка_1" и  "текст_строка_2"   │
     │     текст_строка_2   │ идентичны.                             │
     │                      │                                        │
     │ IFINDI текст_строка_1│ "текст_строка_1" и  "текст_строка_2"   │
     │     ,текст_строка_2  │ идентичны (регистр символов не учиты-  │
     │                      │ вается.                                │
     │                      │                                        │
     │ IFDIF текст_строка_1,│ "текст_строка_1" и  "текст_строка_2"   │
     │     текст_строка_2   │ различны.                              │
     │                      │                                        │
     │ IFDEFI текст_строка_1│ "текст_строка_1" и  "текст_строка_2"   │
     │     ,текст_строка_2  │ различны (регистр символов игнорирует- │
     │                      │ ся.                                    │
     │                      │                                        │
     │ ELSEIFNB текст_строка│ "текст_строка" не состоит из пробелов. │
     │                      │                                        │
     │ ELSEIFB текст_строка │ "текст_строка" не пуста.               │
     │                      │                                        │
     │ ELSEIFIDN текст_стро-│ "текст_строка_1" и  "текст_строка_2"   │
     │  ка_1, текст_строка_2│ идентичны.                             │
     │                      │                                        │
     │                      │                                        │
     │ ELSEIDNI текст_стро- │ "текст_строка_1" и  "текст_строка_2"   │
     │  ка_1,текст_строка_2 │ идентичны (регистр символов игнориру-  │
     │                      │ ется).                                 │
     │                      │                                        │
     │ ELSEIFDIF текст_стро-│ "текст_строка_1" и  "текст_строка_2"   │
     │  ка_1,текст_строка_2 │ различны.                              │
     │                      │                                        │
     │ ELSEIFDIFI текст_стро│ "текст_строка_1" и  "текст_строка_2"   │
     │  -ка_1,текст_строка_2│ различны (регистр символов игнориру-   │
     │                      │ ется).                                 │
     └──────────────────────┴────────────────────────────────────────┘

          Использующие текстовую  строку директивы генерации сообщения
     об ошибке показаны в следующей таблице:

                        Директивы вывода сообщений


     Турбо Ассемблер 3.0/tasm/#2-2                              = 54 =

           об ошибке использующие текстовую строку        Таблица 15.6
     ┌────────────────────────┬──────────────────────────────────────┐
     │Директива ERRxxx        │ Генерирует сообщение об ошибке, если:│
     ├────────────────────────┼──────────────────────────────────────┤
     │ERRIFNB текст_строка    │ "текст_строка"  не  состоит  из одних│
     │                        │ пробелов.                            │
     │                        │                                      │
     │.ERRIFNB текст_строка   │ "текст_строка"  не  состоит  из одних│
     │                        │ пробелов (только для режима MASM).   │
     │                        │                                      │
     │ERRIFB текст_строка     │ "текст_строка" состоит из пробелов.  │
     │                        │                                      │
     │.ERRB текст_строка      │ "текст_строка" состоит из одних  про-│
     │                        │ белов.                               │
     │                        │                                      │
     │ERRIFIDN текст_строка_1,│ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ идентичны.                           │
     │                        │                                      │
     │.ERRIDN текст_строка_1, │ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ идентичны (только для режима MASM).  │
     │                        │                                      │
     │ERRIFIDNI текст_строка_1│ "текст_строка_1" и  "текст_строка_2" │
     │ ,текст_строка_2        │ идентичны (регистр символов игнориру-│
     │                        │ ется).                               │
     │                        │                                      │
     │.ERRIDNI текст_строка_1,│ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ идентичны (регистр символов игнориру-│
     │                        │ ется) - только для режима MASM.      │
     │                        │                                      │
     │ERRIFDIF текст_строка_1,│ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ различны.                            │
     │                        │                                      │
     │.ERRDIF текст_строка_1, │ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ различны (только для режима MASM).   │
     │                        │                                      │
     │ERIFDIFI текст_строка_1,│ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ различны (регистр символов игнориру- │
     │                        │ ется).                               │
     │                        │                                      │
     │.ERRFIFI текст_строка_1,│ "текст_строка_1" и  "текст_строка_2" │
     │ текст_строка_2         │ различны (регистр символов игнориру- │
     │                        │ ется) - только для режима MASM.      │
     └────────────────────────┴──────────────────────────────────────┘

          Используйте эти директивы для проверки передаваемых макроко-
     мандам аргументов (однако их можно использовать не только в  мак-
     рокомандах).

          При использовании  их  в  макроопределениях  директивы IFB и
     IFNB позволяют определить,  передали ли вы в макрокоманду  нужное
     число аргументов.  Если при вызове макрокоманды вы передали слиш-
     ком мало аргументов,  Турбо Ассемблер не генерирует сообщение  об
     ошибке. Незаданные аргументы просто остаются пустыми. Таким обра-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 55 =

     зом, вы можете определить макрокоманду, воспринимающую переменное
     число аргументов. Например:

          .
          .
          .
          load MACRO addr, reg
             IFNB <reg>
                MOV reg,addr
             ELSE
                MOV ax,addr
             ENDIF
          ENDM
          .
          .
          .

          Вы можете  вызывать  макрокоманду данного примера,  как load
     test,cx, что даст генерацию инструкции mov cx,test,  или  вызвать
     ее как load test, то приведет к генерации инструкции mov ax,test,
     поскольку второй параметр пуст. Можно также использовать директи-
     ву ERRIFB для генерации сообщения об ошибке, если в вызове макро-
     команды пропущен аргумент:

          .
          .
          .
          load MACRO addr
             ERRIFNB <addr>
                MOV reg,addr
          ENDM
          .
          .
          .

          Если эту макрокоманду вызвать с помощью load, а не с помощью
     load test, то будет генерироваться ошибка.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 56 =

                 Условия выполнения прохода Ассемблером
     ─────────────────────────────────────────────────────────────────

          Следующие директивы  обеспечивают  выполнение  условного ас-
     семблирования или генерацию ошибки на основе текущего прохода Ас-
     семблера:

     ┌─────────────────────┬─────────────────────────────────────────┐
     │    Директива IFxxx  │  ассемблирует "тело_условия_true", если:│
     ├─────────────────────┼─────────────────────────────────────────┤
     │    IF1              │ Турбо Ассемблер выполняет первый проход.│
     │    IF2              │ Турбо Ассемблер выполняет второй проход.│
     └─────────────────────┴─────────────────────────────────────────┘

     ┌─────────────────────┬─────────────────────────────────────────┐
     │    Директива ERRxxx │ генерирует ошибку user error, если:     │
     ├─────────────────────┼─────────────────────────────────────────┤
     │    ERRIF1           │ Турбо Ассемблер выполняет первый проход.│
     │                     │                                         │
     │    .ERR1            │ Турбо  Ассемблер выполняет первый проход│
     │                     │ (только для режима MASM).               │
     │                     │                                         │
     │    ERRIF2           │ Турбо Ассемблер выполняет второй проход.│
     │                     │                                         │
     │    .ERR2            │ Турбо Ассемблер выполняет второй  проход│
     │                     │ (только для режима MASM).               │
     └─────────────────────┴─────────────────────────────────────────┘

          Обычно Турбо Ассемблер работает как однопроходный ассемблер.
     Если  вы используете средство многопроходной работы Турбо Ассемб-
     лера (вызывая его с параметром командной строки /m),  то  при не-
     обходимости используется несколько проходов.

          Поскольку Турбо  Ассемблер  всегда выполняет по крайней мере
     один проход, директива условного ассемблирования IF1 всегда будет
     ассемблировать код  своего  условного блока,  а директивы .ERR1 и
     ERRIF1 всегда будут генерировать сообщение об ошибке  (но  только
     на первом проходе).

          Если вы  используете  любую из этих директив и не разрешаете
     многопроходную работу, то Турбо Ассемблер будет генерировать  для
     всех  таких директив предупреждение "Pass dependent construction"
     ("Конструкция,  зависящая от прохода"),  чтобы предупредить вас о
     возможно опасном пропуске кода.  Если вы разрешите многопроходную
     работу, Турбо Ассемблер будет выполнять точно два прохода и гене-
     рировать  предупреждение Vaximum compatibility pass was done (Вы-
     полнен проход с целью обеспечения максимальной совместимости).

               Включение условных директив в файл листинга
     ─────────────────────────────────────────────────────────────────

          Обычно код  условного  ассемблирования  с  ложным   условием
     (false) в  листинг  не включается.  Используя директивы Турбо Ас-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 57 =

     семблера и параметры командной строки,  вы можете это переопреде-
     лить.

                Примечание: Более  подробная  информация  содержится в
           Главе 2 и Главе 17.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 58 =

                   Глава 16. Интерфейс с компоновщиком
     ─────────────────────────────────────────────────────────────────

          Модульные программы обычно состоят из нескольких независимых
     частей кода,  называемых модулями. Компилятор обрабатывает каждый
     из этих модулей независимо,  а компоновщик (TLINK) объединяет по-
     лученные части вместе для создания выполняемого файла. О том, как
     использовать TLINK, рассказывается в документации по компилятору,
     но важно также знать,  как определить и включить все файлы и биб-
     лиотеки, которые могут понадобиться при компоновке. В данной Гла-
     ве рассказывается о том, как это сделать.

                    Описание внешних идентификаторов
     ─────────────────────────────────────────────────────────────────

          Может оказаться так,  что вам потребуется использовать неко-
     торые переменные  или  процедуры во всех модулях вашей программы.
     Турбо Ассемблер обеспечивает несколько директив, которые позволя-
     ют вам  определить идентификаторы и библиотеки таким образом, что
     вы сможете использовать их глобально,  а также использовать общие
     переменные (для которых выделяет память компоновщик).  Вам потре-
     буется также соблюдать аккуратность при назначении имен идентифи-
     каторов, поскольку  различные языки имеют здесь конкретные требо-
     вания. В следующий нескольких разделах мы обсудим эти директивы и
     соглашения по наименованию.

                    Соглашения для конкретного языка
     ─────────────────────────────────────────────────────────────────

          Когда вы назначаете имена идентификаторам,  которые планиру-
     ется использовать глобально,  нужно помнить об использовании спе-
     цификатора языка.  К именам  переменных  предъявляются  следующие
     требования:

          - в Паскале имена указываются символами в верхнем регистре;

          - в  Си/С++  имен  должны начинаться с символа подчеркивания
            (_). Остальная часть имени записывается символами в нижнем
            регистре.

          Параметр /m (описанный в Главе 2) сообщает Турбо Ассемблеру,
     что во всех именах идентификаторов нужно различать регистр. Пара-
     метр /mx (также описанный в Главе 2) указывает, что различать ре-
     гистр символов нужно только во внешних и общедоступных  идентифи-
     каторах, и что все другие идентификаторы в исходном файле записа-
     ны в верхнем регистре.  Когда вы используете  эти  два  параметра
     вместе,  для идентификаторов, описанных в Паскале, они имеют спе-
     циальное значение: они приводят к тому, что рассматриваемые иден-
     тификаторы  будут  доступны  компоновщику,  как  идентификаторы в
     верхнем регистре.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 59 =

                 Описание общедоступных идентификаторов
     ─────────────────────────────────────────────────────────────────
          При описании общедоступного идентификатора вы предполагаете,
     что он должен быть доступен из других модулей. Общедоступными мо-
     гут быть следующие типы идентификаторов:

          - имена переменных;
          - метки программы;
          - числовые константы, определенные с помощь EQU.

          Для определения  общедоступных идентификаторов можно исполь-
     зовать директиву PUBLIC, которая имеет следующий синтаксис:

          PUBLIC [язык] идентификатор [,[язык] идентификатор] ...

     где "язык" представляет собой C,  CPP,  PASCAL,  BASIC,  FORTRAN,
     PROLOG или  NOLANGUAGE и определяет соглашения конкретного языка,
     применяемые к имени переменной. Использование спецификатора языка
     в директиве PUBLIC временно переопределяет временно переопределя-
     ет текущую установку языка (по умолчанию NOLANGUAGE,  если другой
     язык не задан в директиве .MODEL).

          Турбо Ассемблер  описывает  идентификатор в объектном модуле
     таким образом, что он будет доступен всем другим модулям. Если вы
     не сделаете идентификатор общедоступным,  то сможете обращаться к
     нему только из текущего модуля, например:

          PUBLIC XYPROC          ; процедура общедоступна
          XYPROC PROC NEAR

                   Описание идентификаторов библиотеки
     ─────────────────────────────────────────────────────────────────

          Вы можете использовать идентификаторы, как динамические точ-
     ки входа для динамически компонуемых библиотек (DLL).  Для описа-
     ния идентификаторов,  которые будут доступны таким  образом,  ис-
     пользуйте директиву PUBLICDDL. Она имеет следующий синтаксис:

          PUBLICDLL [язык] идентификатор [,[язык] идентификатор] ...

          Турбо Ассемблер  описывает  идентификатор в объектном файле,
     как динамически компонуемую точку входа, благодаря чему они могут
     быть доступны в других программах. Спецификатор "язык" приводит к
     применению специфических для языка соглашений к конкретному имени
     идентификатора. Допустимыми спецификаторами языка являются специ-
     фикаторы C, CPP, PASCAL, BASIC, FORTRAN, PROLOG и NOLANGUAGE.

     Приведем пример кода с использованием PUBLICDLL:

          PUBLICDLL XYPROC          ; процедура XYPROC доступна как
          XYPOROXC PROC NEAR        ; динамически компонуемая точка
                                    ; входа

     Турбо Ассемблер 3.0/tasm/#2-2                              = 60 =


                   Определение внешних идентификаторов
     ─────────────────────────────────────────────────────────────────

          Внешние идентификаторы - это идентификаторы, которые опреде-
     лены вне модуля и которые вы можете использовать  внутри  модуля.
     Эти идентификаторы   должны  быть  описаны  с  помощью  директивы
     PUBLIC. Директива EXTRN имеет следующий синтаксис:

          EXTRN определение [,определение] ...

     где "определение" описывает идентификатор и имеет следующий  фор-
     мат:

          [язык] имя [[счетчик_1]] :сложный_тип [:счетчик_2]

                   Описание глобальных идентификаторов
     ─────────────────────────────────────────────────────────────────

          Глобальные идентификаторы действуют также,  как  общедоступ-
     ные, при этом вам не нужно определять PUBLIC или EXTRN.  Если пе-
     ременная определена в модуле,  она действует  как  общедоступная.
     Если нет,  она действует как внешняя.  Для определения глобальных
     идентификаторов вы можете использовать директиву GLOBAL. Директи-
     ва GLOBAL  имеет  тот же синтаксис,  что директивы PUBLIC и EXTRN
     (их синтаксис описан в предыдущих разделах).

          Директива GLOBAL позволяет вам иметь включаемый файл,  кото-
     рый будет включаться во все исходные модули.  Включаемый файл со-
     держит все совместно используемые данные,  определенные как  гло-
     бальные идентификаторы.  Когда  вы  в каждом модуле ссылаетесь на
     эти элементы данных,  директива GLOBAL  действует  как  директива
     EXTRN, описывая для другого модуля, как определены данные.

          Перед тем, как использовать его где-либо в исходном коде, вы
     должны описать идентификатор как GLOBAL.  Кроме того заметим, что
     при задании  аргументов директивы GLOBAL используется тот же син-
     таксис, что и в директиве EXTRN.

          Приведем пример:

          GLOBAL X:WORD, Y:BYTE
          X  DW 0                 ; идентификатор стал доступен в
                                  ; других модулях
          mov  al, Y              ; описан как внешний

                      Определение общих переменных
     ─────────────────────────────────────────────────────────────────

          Общие переменные действуют как внешние переменные,  но здесь
     есть одно существенное различие:  общие переменные распределяются
     компоновщиком. Общие переменные переменные на самом деле аналоги-
     чны глобальным переменным, но вы не можете присвоить им начальные

     Турбо Ассемблер 3.0/tasm/#2-2                              = 61 =

     значения. На эти неинициализированные переменные  можно ссылаться
     из нескольких модулей.

          Для определения  общей переменной вы можете использовать ди-
     рективу COMM. Она имеет следующий синтаксис:

          COMM определение [,определение]...

          Каждое "определение" описывает идентификатор и имеет следую-
     щий формат:

          [расстояние] [язык] имя_идентификатора[[счетчик_1]]:
                                  сложный_тип [счетчик_2]

     где поле "расстояние" не является обязательным и может  быть  FAR
     или NEAR.  Если вы не зададите "расстояние", по умолчанию оно бу-
     дет соответствовать используемой модели памяти.  Если вы  не  ис-
     пользуете  упрощенные директивы сегментации,  то по умолчанию ис-
     пользуется  NEAR.  В  крошечной,  малой  и  средней  моделях   по
     умолчанию также используется NEAR, а во всех других - FAR.

          Поле "язык" задает язык:  C,  PASCAL, BASIC, FORTRAN, PROLOG
     или NOLANGUAGE. Использование в директиве COMM спецификатора язы-
     ка временно  переопределяет текущую установку языка (по умолчанию
     или заданную с помощью директивы .MODEL).  Заметим, что для того,
     чтобы действовало  данное средство,  вам не обязательно использо-
     вать директиву .MODEL.

          Поле "имя_идентификатора" задает имя идентификатора, который
     должен быть  общим,  и  память  для которого должна выделяться на
     этапе компоновки.  В этом поле можно также  задавать  коэффициент
     размера элемента массива "счетчик_1",  который должен учитываться
     в вычисляемом объеме общей памяти. Если в качестве расстояния за-
     дано FAR, то компоновщик, использует значение "счетчика_2", чтобы
     указать,  сколько имеется элементов с размером, равным произведе-
     нию  основного  размера элемента (который определяется его типом)
     на "счетчик_1". По умолчанию значение поля "счетчик_1" равно 1.

          "Сложный_тип" - это тип данных аргумента. Он может быть либо
     простым типом,  либо сложным выражением с указателем.  Более под-
     робно о синтаксисе сложного типа рассказывается в Главе 5.

          Необязательное значение "счетчик_2" определяет, сколько эле-
     ментов определяет  эта  общая переменная.  Если вы не задаете это
     поле, то подразумевается значение 1. Полный объем памяти, выделя-
     емой для  общей  переменной,  равен  произведению значения "счет-
     чик_2" на длину, заданную полем "тип", и на значение "счетчик_1".

          В режиме MASM,  предполагается,  что  общие  идентификаторы,
     описанные вне любого сегмента, должны быть доступны с помощью ре-
     гистра DS,  что не всегда может допустимым предположением. Убеди-
     тесь, что  вы  либо  поместили в DS корректное значение сегмента,
     либо при ссылке на  эти  переменные  используете  переопределение

     Турбо Ассемблер 3.0/tasm/#2-2                              = 62 =

     сегмента. В режиме Ideal Турбо Ассемблер корректно проверяет, яв-
     ляются ли общие переменные адресуемыми,  используя любой из теку-
     щих сегментных регистров, описанный в директиве ASSUME.

          Приведем пример использования директивы COMM:

          COMM buffer:BYTE:512        ; во время компоновки выделяет-
                                      ; ся 512 байт
          COMM abc[41]:WORD:10        ; на этапе компоновки выделяет-
                                      ; ся память  820  байт (10 эле-
                                      ; ментов из 41 слова каждый)

          COMM FAR abc[41]:WORD:10    ; на этапе компоновки выделяет-
                                      ; ся  10 элементов из  82  байт
                                      ; (2 байта * 41 элемент)

                          Включение библиотеки
     ─────────────────────────────────────────────────────────────────

          В том случае,  когда вы знаете,  что ваш исходный файл будет
     всегда использовать  подпрограммы заданной библиотеки,  можно ис-
     пользовать директиву INCLUDELIB.  Директива  INCLUDELIB  сообщает
     компоновщику, что  нужно включить указанную библиотеку.  В режиме
     Ideal эта директива имеет следующий синтаксис:

          INCLUDELIB "имя_файла"     ; обратите внимание на кавычки!

     а в режиме MASM:

          INCLUDELIB имя_файла

     где "имя_файла" - это имя библиотеки,  которую вы хотите включать
     с помощью компоновщика на этапе компоновки.  Если вы не укажете в
     заданном имени файла  расширение,  то  компоновщик  подразумевает
     расширение .LIB.

          Приведем пример:

          INCLUDELIB "diskio"      ; включает DISKIO.LIB




     Турбо Ассемблер 3.0/tasm/#2-2                              = 63 =

                     Глава 17. Генерация листинга
     ─────────────────────────────────────────────────────────────────

          Файл листинга полезно использовать,  когда вы  хотите  точно
     видеть, что генерирует Турбо Ассемблер при ассемблировании каждой
     инструкции или директивы. Основу этого файла составляет  исходный
     файл, в который включен большой объем сопровождающей информации о
     результатах ассемблирования.  Турбо Ассемблер выводит для  каждой
     инструкции полученный  машинный  код,  а также смещение в текущем
     сегменте (на каждой строке с машинным кодом).  Кроме того,  Турбо
     Ассемблер выводит в таблицах информацию о метках и сегментах, ис-
     пользуемых в программе, включая значение и тип каждой метки и ат-
     рибуты каждого сегмента.

                Примечание: См.  в Главе 2 описание параметров команд-
           ной строки /l и /la.

          Турбо Ассемблер  может также по запросу генерировать таблицу
     перекрестных ссылок для всех меток,  используемых в исходном фай-
     ле, в которой показано,  где определяется каждая метка,  и где на
     нее имеется ссылка.

                Примечание: См. в Главе 2 описание параметра командной
           строки /c.

                           Формат листинга
     ─────────────────────────────────────────────────────────────────

          В верхней  части  каждой страницы листинга выводится заголо-
     вок, содержащий версию Турбо Ассемблера, с помощью которой выпол-
     нено ассемблирование файла,  дату и время ассемблирования и номер
     страницы в листинге.

          Файл листинга содержит две части: аннотированный листинг ис-
     ходного кода и таблицу идентификаторов.  Сначала выводится исход-
     ный ассемблируемый код с заголовком,  содержащим имя файла, в ко-
     тором находится  исходный  код.  Вывод  исходного кода Ассемблера
     сопровождается информацией о машинном коде,  который ассемблирует
     Турбо Ассемблер.  Все  ошибки или предупреждения,  обнаруженные в
     процессе ассемблирования, включаются в листинг непосредственно за
     содержащей ошибку строкой.

          Строки кода в файле листинга имеет следующий формат:

     <глубина> <номер_строки> <смещение> <машинный_код> <исходный_код>

     где <глубина>  показывает  уровень  вложенности включаемых файлов
     или макрокоманд в файле листинга.

          Поле <номер_строки> содержит номер строки в  файле  листинга
     (не включая заголовки). Номера строк особенно полезны при исполь-
     зовании перекрестных ссылок Турбо Ассемблера,  в которых указыва-
     ются номер строк. Учтите, что поле <номер_строки> не соответству-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 64 =

     ет номерам  строк  исходного  модуля.  Например,  если   в   файл
     включается другой файл или выполняется макрорасширение, то значе-
     ние поля <номер_строки> продолжает  увеличиваться,  хотя  текущая
     строка в исходном файле остается той же.  Чтобы преобразовать но-
     мер строки обратно в строку исходного кода, вы должны найти стро-
     ку в файле листинга,  и найти такую же строку в исходном коде (по
     ее внешнему виду, а не по номеру).

          Поле <смещение> представляет смещение в текущем сегменте на-
     чала машинного кода, сгенерированного из соответствующей исходной
     строки Турбо Ассемблером.

          Поле <машинный_код>  показывает  фактическую  последователь-
     ность шестнадцатиричных значений размером в байт или слово, кото-
     рые  ассемблированы из соответствующей исходной строки на Ассемб-
     лере.

          Поле <исходный_код> - это просто исходная строка Ассемблера,
     с комментариями и всем,  что в ней содержится. Некоторые исходные
     строки (например те, которые содержат только комментарии) не  ге-
     нерируют никакого машинного кода.  Эти строки не  содержат  полей
     <смещение> и <машинный_код>, но имеют номер строки.

                  Общие директивы управления листингом
     ─────────────────────────────────────────────────────────────────

          Имеется ряд директив,  которые позволяют вам управлять видом
     файла листинга.  Общие  директивы управления листингом включают в
     себя следующие директивы:

          - .LIST             ; только режим MASM

          - .XLEST            ; только режим MASM

          - %LIST

          - %NOLIST

          - %CTLS

          - %NOCTLS

          - %SYMS

          - %NOSYMS

          Директива %LIST выводит в файл листинга все строки исходного
     кода. Эта  директива  назначается по умолчанию при создании файла
     листинга. Чтобы запретить вывод в листинг  всех  строк  исходного
     кода, используйте директиву %NOLIST. Приведем пример:

          %NOLIST            ; запретить листинг
          INCLUDE MORE .INC

     Турбо Ассемблер 3.0/tasm/#2-2                              = 65 =

          %LIST              ; разрешить листинг

          Директивы .LIST и .XLIST работают также, как директивы %LIST
     и %NOLIST. Приведем пример:

          .LIST
          jmp xyz           ; эта строка всегда выводится
          .XLIST
          add dx,ByteVar    ; не содержится в листинге

          Для управления включением в листинг директив управления лис-
     тингом вы можете использовать директивы %CTL и  %NOCTL. Директива
     %CTLS  приводит к включению в листинг директив управления листин-
     гом (таких как %LIST,  %INCL и т.д.). Обычно они в листинг не вы-
     водятся. Эта директива действует для всех последующих строк, поэ-
     тому сама директива  %CTLS  в  листинг  не  выводится.  Директива
     %NOCTLS изменяет действие директивы %CTLS на обратное.  После за-
     дания директивы %NOCTLS все последующие директивы управления лис-
     тингом  в  листинг  включаться  не будут (этот режим используется
     Турбо Ассемблером по умолчанию,  когда начинается ассемблирование
     исходного файла). Например:

          %CTLS
          %NOLIST           ; эта директива не будет включена в
                            ; исходный файл
          %NOCTLS
          %LIST             ; это не будет включаться в листинг

          Для задания  включения или не включения в файл листинга таб-
     лицы идентификаторов вы  можете  использовать  директивы  %SYMS и
     %NOSYMS (по умолчанию таблица идентификаторов выводится). Таблица
     будет выводиться в конце файла листинга.

          Приведем синтаксис директивы %SYMS:

          %SYMS

          Директива %NOSYMS имеет следующий синтаксис:

          %NOSYMS

                  Директивы листинга включаемых файлов
     ────────────────────────────────────────────────────────────────

          В том случае,  когда вы хотите вывести в файл листинга вклю-
     чаемые файлы, вы можете разрешить или запретить эту возможность с
     помощью директив  %INCL и %NOINCL.  По умолчанию включаемые файлы
     обычно включаются в файл листинга.  Директива %NOINCL приостанав-
     ливает вывод  в файл листинга всех последующих включаемых файлов,
     пока он снова не будет разрешен директивой %INCL. Это полезно ис-
     пользовать при наличии больших включаемых файлов,  которые содер-
     жат,  например, много определений EQU, которые никогда не изменя-
     ются.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 66 =


          Приведем пример:

          %INCL
          INCLUSE DEFS.INC        ; содержимое выводится в листинг
          %NOINCL
          INCLUSE DEF1.INC        ; содержимое не выводится в листинг

             Директивы вывода блоков условного ассемблирования
     ────────────────────────────────────────────────────────────────

          Когда в  исходном  коде  у  вас  содержатся  блоки условного
     ассемблирования, может оказаться желательным включение  в листинг
     всей информации. Вывод блоков условного ассемблирования может по-
     мочь в тех случаях, когда вы хотите точно видеть поведение исход-
     ного кода.  В  Турбо Ассемблере предусмотрены следующие директивы
     вывода блоков условного ассемблирования:

          - .LFCOND            ; только для режима MASM

          - .SFCOND            ; только для режима MASM

          - ,TFCOND            ; только для режима MASM

          - %CONDS

          - %NOCONDS

          Обычно Турбо Ассемблер не включает в листинг блоки условного
     ассемблирования.

          Директива %CONDS  выводит  в файл листинга все операторы ус-
     ловного блока. При этом в файл листинга выводятся также все блоки
     с условием false. Директива .LFCOND работает аналогично директиве
     .LFCOND. Директива %NOCONDS предотвращает вывода в  файл листинга
     блоков условного  ассемблирования  с  условием  false.  Директива
     .SFCONDS работает аналогично директиве %NOCOND.  Если  вы  хотите
     переключить режим  вывода  блоков условного ассемблирования,  ис-
     пользуйте директиву .TFCOND.

          Первая директива .TFCOND, которую обнаруживает Турбо Ассемб-
     лер, разрешает  вывод в листинг всех блоков условного ассемблиро-
     вания. Если вы используете параметр командной  строки  /X,  блоки
     условного ассемблирования  будут сначала выводиться в листинг,  а
     первая директива .TFCOND запретит их вывод.  При каждом обнаруже-
     нии в  исходном  файле  директивы .TFCOND состояние вывода блоков
     условного ассемблирования изменяется на обратное.

          Для указания любой из этих директив поместите  директиву  на
     отдельной строке  исходного кода.  Она будут влиять на непосредс-
     твенно следующие за данной директивой блоки условного ассемблиро-
     вания.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 67 =

             Директивы вывода в файл листинга макрокоманд
     ────────────────────────────────────────────────────────────────

          Обычно макрорасширения включаются в файлы  листинга. Наличие
     такой информации в файле листинга может оказаться очень полезной,
     когда вы хотите видеть, что делается в исходном коде. В Турбо Ас-
     семблере предусмотрено   несколько  директив,  которые  позволяют
     включать и выключать данное средство. Это следующие директивы:

          - .LALL              ; только для режима MASM
          - .SALL              ; только для режима MASM
          - .XALL              ; только для режима MASM
          - %MACS
          - %NOMACS

          Директива %MACS разрешает листинг всех макрорасширений. Тоже
     самое делает  директива  .LALL,  но  она работает только в режиме
     MASM. Вы можете использовать эти директивы для  включения  макро-
     расширений в файл листинга.

          Директива %MACS имеет следующий синтаксис:

          %MACS

          Директиву .LALL вы можете задать следующим образом:

          .LALL

          Если вы  хотите подавить вывод всех операторов макрорасшире-
     ния, используйте директивы %NOMACS или .SALL.  Заметим,  что  эти
     директивы можно  использовать для выключения вывода макрорасшире-
     ния в файл листинга.

          Директива %NOMACS имеет следующий синтаксис:

          %NOMACS

          Директива .SALL задается следующим образом:

          .SALL

          Доступная в режиме MASM директива .XALL позволяет вам  выво-
     дить в листинг только те макрорасширения,  которые генерируют код
     или данные. Она имеет следующий синтаксис:

          .XALL

     Турбо Ассемблер 3.0/tasm/#2-2                              = 68 =

             Директивы вывода листинга перекрестных ссылок
     ────────────────────────────────────────────────────────────────
          В таблице  идентификаторов  листинга ссылок обычно выводится
     большой объем информации о метках, группах и сегментах, но там не
     сообщается, где определены сегменты, группы и метки и где они ис-
     пользуются. Информация,  выводимая в таблице перекрестных ссылок,
     позволяет вам  легко находить метки и следить за ходом выполнения
     программы при ее отладке.

          Существует несколько способов разрешения включения  информа-
     ции о перекрестных ссылках в файл листинга.  Для получения инфор-
     мации о перекрестных ссылках для всего файла вы можете  использо-
     вать параметр  командной  строки  /c  (подробности  можно найти в
     Главе 2), либо включить в исходный код директивы, позволяющие вам
     разрешать и  запрещать  вывод  перекрестных  ссылок для отдельных
     частей исходного кода. Это следующие директивы:

          - .CREF                   ; только для режима MASM
          - .XCREF                  ; только для режима MASM
          - %CREF
          - %NOCREF
          - %CREFALL
          - %CREFREF
          - %CREFUREF

          Директивы %CREF и .CREF позволяют вам собрать  информацию  о
     перекрестных ссылках  для  всех идентификаторах в исходном файле,
     начиная с данной точки. Директивы %CREF и .CREF отменяют действие
     директив %NOCREF или .XCREF,  которые запрещают сбор информации о
     перекрестных ссылках.

          Директивы %CREF и .CREF имеют следующий синтаксис:

          %CREF
     или
          .CREF

          Директивы %NOCREF и .XCREF имеют синтаксис:

          %NOCREF [идентификатор, ...]
     или
          .XCREF [идентификатор, ...]

          Если вы  используете директивы %NOCREF и .XCREF без указания
     идентификатора, то вывод  перекрестных  ссылок  запрещается  пол-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 69 =

     ностью. Если  вы  указываете одно или более имен идентификаторов,
     то вывод перекрестных ссылок запрещается только для данных  иден-
     тификаторов.

          Директива %CREFALL выводит в листинг перекрестные ссылки для
     всех идентификаторов. Директива %CREFALL изменяет действие преды-
     дущей директивы  %CREFREF (запрещающей вывод в таблицу перекрест-
     ных ссылок тех идентификаторов, на которые ссылки отсутствуют) на
     обратное. После указания директивы %CREFALL все встречающиеся да-
     лее в исходном файле идентификаторы будут  включаться  в  листинг
     перекрестных ссылок.  Турбо  Ассемблер  использует  это  режим по
     умолчанию а начале ассемблирования исходного файла.

          Директивы %CREFALL,  %CREFREF и  %CREFUREF  имеют  следующий
     синтаксис:

          %CREFALL

          %CREFREF

          %CREFUREF

                  Параметры изменения формата листинга
     ────────────────────────────────────────────────────────────────

          Директивы управления форматом листинга изменяют формат файла
     листинга. Вы  можете использовать эти директивы,  чтобы приспосо-
     бить вид листинга под свой вкус и потребности.

          Директива PAGE задает высоту и ширину страницы файла листин-
     га и  начинает  новую страницу.  Директива PAGE работает только в
     режиме MASM. Она имеет следующий синтаксис:

          PAGE [число_строк] [,число_столбцов]
          PAGE +

     где "число_строк" задает число строк,  выводимых на странице лис-
     тинга. Поле "число_столбцов" может принимать значения  от  59  до
     255 и задает число столбцов на странице. Если вы опустите один из
     этих параметров,  то текущая установка данного параметра остается
     без изменений.  Чтобы изменить только число столбцов, укажите пе-
     ред этим параметром запятую, в противном случае вы измените число
     строк.

          Если вы  укажете  после директивы PAGE символ плюса (+),  то
     начинается новая страница,  номер раздела увеличивается,  а номер
     страницы снова начинается с 1. Если вы используете директиву PAGE
     без аргументов,  то листинг возобновляется с новой  страницы  без
     изменения номера раздела.

          Директива %PAGESIZE работает также,  как директива PAGE,  но
     она не начинает новую страницу и работает как в режиме Ideal, так
     и в режиме MASM. Директива %PAGESIZE имеет следующий синтаксис:

     Турбо Ассемблер 3.0/tasm/#2-2                              = 70 =


          %PAGESIZE [число_строк] [,число_столбцов]

          Директива %NEWPAGE  работает как директива PAGE без аргумен-
     тов. Строки исходного текста после директивы %NEWPAGE будут начи-
     наться в  файле  листинга  с новой страницы.  Директива %PAGESIZE
     имеет следующий синтаксис:

          %NEWPAGE

          Директива %BIN устанавливает длину поля  объектного  кода  в
     файле листинга. Директива %BIN имеет синтаксис:

          %BIN размер

     где "размер" является константой.  Если вы не используете эту ди-
     рективу, то поле кода операции занимает в файле  листинга  до  20
     позиций, например:

          %BIN 12        ; устанавливает 12 позиций в листинге

          Директива %DEPTH  устанавливает  размер поля глубины в файле
     листинга. Эта директива имеет следующий синтаксис:

          %DEPTH размер

     где "размер" задает, скольку столбцов нужно зарезервировать в по-
     ле глубины файла листинга. Это поле указывает уровень вложенности
     включаемых файлов (INCLUDE) и макрорасширений.  Если  в  качестве
     размера вы укажете 0,  то это поле в файле листинга не выводится.
     Обычно не требуется задавать "размер" > 2, поскольку при этом без
     усечения будет  выводиться  глубина до 99.  По умолчанию это поле
     имеет значение 1.

          Директива %LINENUM задает размер поля номеров строк  в файле
     листинга. Данная директива имеет следующий синтаксис:

          %LINENUM размер

          Директива %LINENUM  позволяет  вам  задать,  сколько позиций
     должны занимать номера строк в файле листинга.  В  поле  "размер"
     должна указываться константа. Если вы хотите минимизировать шири-
     ну листинга, то можете уменьшить размер поля номеров строк. Кроме
     того, если  ваш  файл содержит более 9999 строк,  то размер этого
     поля может потребоваться увеличить, чтобы номера не усекались. По
     умолчанию номер строки занимает 4 столбца.

          Директива %TRUNC  усекает слишком длинные поля листинга. Она
     имеет следующий синтаксис:

          %TRUNC

          Поле объектного кода в файле листинга имеет достаточно  мес-

     Турбо Ассемблер 3.0/tasm/#2-2                              = 71 =

     та для вывода кода, генерируемого большинством инструкций или ди-
     рективами выделения данных.  Размер этого поля можно настроить  с
     помощью директивы %BIN.  Если отдельная строка исходного кода ге-
     нерирует больше кода, чем можно вывести на одной строке, то оста-
     ток автоматически усекается и таким образом будет невидимым. Если
     вы хотите видеть весь генерируемый код,  то используйте директиву
     %NOTRUNC (слишком  длинная  строка при этом будет переноситься на
     следующую). В противном случае используйте директиву  %TRUNC.  Вы
     можете использовать эти инструкции для переключения режима усече-
     ния.

          Директива %NOTRUNC имеет следующий синтаксис:

          %NOTRUNC

          Директива %PCNT задает размер поля "сегмент:смещение" в фай-
     ле листинга. Она имеет следующий синтаксис:

          %PCNT размер

     где "размер" - это число столбцов, которые вы хотите зарезервиро-
     вать для смещения в текущем ассемблируемом  сегменте.  Турбо  Ас-
     семблер устанавливает  размер,  равный 4,  для обычных 16-битовых
     сегментов и 8 для 32-битовых сегментов процессора 80386. Директи-
     ва %PCNT  позволяет  переопределить эти используемые по умолчанию
     значения.

          Директива TITLE, которую вы можете использовать только в ре-
     жиме MASM,  задает заголовок файла листинга.  Эта директива имеет
     следующий синтаксис:

          TITLE текст

          Заголовок "текст" будет выводиться в  верхней  части  каждой
     страницы после имени исходного файла и перед заголовком, заданным
     по директиве SUBTTL.  Директиву TITLE можно использовать в  прог-
     рамме только один раз.

          Директива %TITLE работает также,  как директива TITLE, но вы
     можете использовать ее как в режиме MASM,  так и в режиме  Ideal.
     Эта директива имеет следующий синтаксис:

          %TITLE "текст"

          Директива SUBTTL работает только в режиме MASM и задает под-
     заголовок файла листинга. Она имеет следующий синтаксис:

          SUBTTL текст

          Подзаголовок выводится в верхней части каждой страницы после
     имени исходного  файла  и  после заголовка,  заданного директивой
     TITLE.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 72 =

          Директиву SUBTTL можно указывать в  программе  столько  раз,
     сколько требуется.  Каждая директива изменяет подзаголовок, кото-
     рый будет выводиться на следующей странице листинга.

          Директива %SUBTTL работает аналогично директиве  SUBTTL,  но
     ее можно указывать как в режиме Ideal,  так и в режиме MASM.  Эта
     директива имеет синтаксис:

          %SUBTTL "текст"

          Директива %TABSIZE задает позицию табуляции в файле  листин-
     га. Данная директива имеет следующий синтаксис:

          %TABSIZE размер

     где "размер" - это число столбцов между двумя позициями табуляции
     в файле листинга. По умолчанию это 8 столбцов.

          Для задания длины поля исходного  текста  в  файле  листинга
     можно использовать директиву %TEXT, которая имеет синтаксис:

          %TEXT размер

     где "размер" - это число столбцов, используемых для вывода в фай-
     ле листинга исходных строк. Если размер исходной строки превышает
     длину этого поля,  то оно будет либо усекаться, либо переноситься
     на следующую строку,  в зависимости  от  использования  директивы
     %TRUNC или %NOTRUNC.

          Чтобы сохранить   все   параметры   управления  листингом  в
     16-уровневом стеке,  можно использовать директиву  %PUSHCTL.  Она
     сохраняет только те параметры управления листингом, которые можно
     разрешить или запретить (%INCL,  %NOINCL и т.д.).  Размеры  полей
     листинга не сохраняются. Данная директива особенно полезна в мак-
     рокомандах, когда вы можете вызывать специальные режимы листинга,
     которые отменяются при завершении макрорасширения.

          Директива %PUSHCTL имеет синтаксис:

          %PUSHCTL

          Директива %POPCTL  восстанавливает из стека параметры управ-
     ления листингом и имеет следующий синтаксис:

          %POPCTL

          Эта директива восстанавливает параметры управления листингом
     в те  значения,  которые  они  имели  перед  последней директивой
     %PUSHCTL. Значения размеров полей листинга (%DEPTH, %PCNT и т.д.)
     не восстанавливаются.




     Турбо Ассемблер 3.0/tasm/#2-2                              = 73 =

            Глава 18. Интерфейс Турбо Ассемблера и Borland C++
     ─────────────────────────────────────────────────────────────────

          Хотя некоторые программисты  могут  разрабатывать  программы
     целиком  на языке Ассемблера (и делают это),  другие предпочитают
     писать основную часть программы на языке высокого уровня, обраща-
     ясь к языку Ассемблера только для осуществления управления нижне-
     го уровня,  или когда требуется высокая производительность. Неко-
     торые  предпочитают писать преимущественно на Ассемблере,  только
     иногда используя конструкции и библиотечные средства языков высо-
     кого уровня.

          Данная глава объясняет использование Турбо Ассемблера с ком-
     пиляторами С++. В этой главе они называются компиляторами семейс-
     тва Borland С++.  Однако Турбо Ассемблер можно использовать также
     с Турбо C++ и Турбо Си. Приводимая ниже таблица содержит перечень
     компиляторов этого семейства.

                      Компиляторы Borland С++ и Си        Таблица 18.1
     ┌────────────────────┬──────────────────────────────────────────┐
     │ Название продукта  │ Имя файла компилятора                    │
     ├────────────────────┼──────────────────────────────────────────┤
     │ Borland С++        │ bcc.exe, bccx.exe, bc.exe или bcx.exe    │
     │ Турбо C++          │ tcc.exe или tc.exe                       │
     │ Турбо Cи           │ tcc.exe                                  │
     └────────────────────┴──────────────────────────────────────────┘

          Например, если мы говорим,  чтобы  вы  выполнили  компиляцию
     строкой:

          bcc -S plusone.cpp

     а вы работаете с Турбо С++, то вместо нее вы можете ввести следу-
     ющую командную строку:

          tcc -S plusone.cpp

          Если при интерфейсе с Турбо Ассемблером вы используете Турбо
     Си,  то вы ограничены использованием только компилятора командной
     строки.  В случае же Borland С++ и Турбо С++ вы  можете  работать
     как с компиляторами командной строки, так и с компилятором интег-
     рированной среды.

          Borland C++ дает хорошие  возможности  поддержки  смешанного
     программирования на С++ и на языке Ассемблера на произвольной ос-
     нове и предоставляет не один,  а целых три механизма  объединения
     модулей на Ассемблере и на С++. Имеющееся в С++ средство встроен-
     ного ассемблирования позволяет быстро и просто вставить  текст на
     языке Ассемблера прямо в функцию С++. Вы можете выполнить ассемб-
     лирование встроенного кода при помощи Турбо Ассемблера или встро-
     енного Ассемблера Borland С++.  Те,  кто предпочитает держать ас-
     семблерные части программы в отдельных модулях,  написанных цели-
     ком на языке Ассемблера, может ассемблировать их при помощи Турбо

     Турбо Ассемблер 3.0/tasm/#2-2                              = 74 =

     Ассемблера и затем скомпоновать с модулями Borland С++.

          Сначала  мы  рассмотрим  использование встроенного в Borland
     C++ Ассемблера. Далее мы подробно обсудим компоновку отдельно ас-
     семблированных в Турбо Ассемблере модулей с Borland C++ и  иссле-
     дуем процесс вызова функций, написанных с помощью Турбо Ассембле-
     ра, из программы, созданной в Borland C++. И наконец, мы рассмот-
     рим вызов функций Borland C++ из программы на Турбо Ассемблере.

              Вызов из Borland C++ функций Турбо Ассемблера
     ─────────────────────────────────────────────────────────────────

          Обычно C++  и Ассемблер совместно используют путем написания
     отдельных модулей целиком на C++ или Ассемблере, компиляции моду-
     лей С++ и ассемблирования модулей Ассемблера с  последующей  сов-
     местно компоновкой  этих раздельно написанных модулей.  Это пока-
     зано на Рис. 1.18.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 75 =


     ┌──────────────────────────────┐ ┌──────────────────────────────┐
     │   Исходный файл на языке С++ │ │ Исходный файл на Ассемблере  │
     │          имя_файла.СPP       │ │        имя_файла.ASM         │
     └──────────────┬───────────────┘ └────────────┬─────────────────┘
                    │                              │
                      Компиляция                     Ассемблирование
             ╒═════════════╕              ╒══════════════════╕
             │ Borland C++ │              │  Турбо Ассемблер │
             ╘═════════════╛              ╘══════════════════╛
                    │                              │
                                                  
     ┌──────────────────────────────┐ ┌──────────────────────────────┐
     │     Объектный файл языка С++ │ │   Объектный файл языка С++   │
     │          имя_файла.OBJ       │ │        имя_файла.OBJ         │
     └──────────────┬───────────────┘ └─────────────┬────────────────┘
                    │                               │
                    │                               │
                    └─────────────┐   ┌─────────────┘
                                  │   │
                                     
                             ╒═════════════╕
                             │   TLINK     │ Компоновка
                             ╘═════════════╛
                                    │
                                    
                     ┌────────────────────────────────┐
                     │         Выполняемый файл       │
                     │          имя_файла.EXE         │
                     └────────────────────────────────┘

          Рис. 1.18  Цикл  компиляции,  ассемблирования  и  компоновки
     Borland C++, Турбо Ассемблера и компоновщика TLINK

          Выполняемый файл получается из "смеси" модулей С++ и Ассемб-
     лера. Этот цикл можно запустить командой:

             bcc имя_файла_1.cpp имя_файла_2.asm

     которая указывает Borland C++,  что нужно  сначала  компилировать
     файл имя_файла_1.СPP в файл имя_файла_1.OBJ, а затем вызвать Тур-
     бо Ассемблер для ассемблирования файла имя_файла_2.asm в имя_фай-
     ла_2.obj, и,  наконец,  вызвать  компоновщик TLINK для компоновки
     файла имя_файл_1.OBJ и имя_файл_2.OBJ в файл имя_файла.EXE.

          Раздельную компиляцию полезно использовать  для  программ  с
     большим объемом кода на Ассемблере, так как это позволяет исполь-
     зовать все возможности Турбо Ассемблера и программировать на язы-
     ке Ассемблера  в  чисто ассемблерном окружении  без ключевых слов
     asm, дополнительного времени на компиляцию  и  связанными  с  С++
     непроизводительными затратами  при работе со встроенным Ассембле-
     ром.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 76 =

          За раздельную компиляцию приходится платить  следующую цену:
     программист, работающий с Ассемблером,  должен вникать во все де-
     тали организации интерфейса между С++ и кодом  Ассемблера.  В  то
     время как  при  использовании  встроенного Ассемблера Borland C++
     сам выполняет спецификацию сегментов, передачу параметров, ссылку
     на переменные С++ и т.д.,  отдельно компилируемые функции Ассемб-
     лера должны все это (и даже более) делать самостоятельно.

          В интерфейсе Турбо Ассемблера и Borland C++ есть два  основ-
     ных  аспекта.  Во-первых,  различные  части кода С++ и Ассемблера
     должны правильно компоноваться,  а функции и переменные в  каждой
     части кода должны быть доступны (если это необходимо) в остальной
     части кода. Во-вторых, код Ассемблера должен правильно работать с
     вызовами  функций,  соответствующих  соглашениям  языка С++,  что
     включает в себя доступ к передаваемым параметрам,  возврат значе-
     ний  и соблюдение правил сохранения регистров,  которых требуется
     придерживаться в функциях С++.

          Давайте теперь приступим к изучению правил компоновки  прог-
     рамм Турбо Ассемблера и Borland C++.

       Основные моменты в интерфейсе Турбо Ассемблера и Borland C++
     ─────────────────────────────────────────────────────────────────

          Чтобы скомпоновать вместе модули Borland C++ и Турбо Ассемб-
     лера, должны быть соблюдены следующие три пункта:

          1. В модулях Турбо Ассемблера должны использоваться соглаше-
             ния об именах, принятые в Borland C++.

          2. Borland  C++ и Турбо Ассемблер должны совместно использо-
             вать соответствующие функции и имена переменных  в форме,
             приемлемой для Borland C++.

          3. Для  комбинирования модулей в выполняемую программу нужно
             использовать утилиту-компоновщик TLINK.

          Здесь ничего не говориться о том, что в действительности де-
     лают  модули  Турбо Ассемблера.  Пока мы коснемся только основных
     моментов,  обеспечивающих разработку  функций  Турбо  Ассемблера,
     совместимых с С++.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 77 =

                  Компоновка ассемблерных модулей с С++
     ─────────────────────────────────────────────────────────────────

          Важной концепцией С++ является  безопасная  с  точки  зрения
     стыковки типов компоновка.  Компилятор и компоновщик должны рабо-
     тать согласованно, чтобы гарантировать правильность типов переда-
     ваемых между функциями аргументов. Процесс, называемый "корректи-
     ровкой имен" (name-mangling), обеспечивает необходимую информацию
     о типах аргументов.  "Корректировка имени" модифицирует имя функ-
     ции таким образом, чтобы оно несло информацию о принимаемых функ-
     цией аргументах.

          Когда программа  пишется целиком на С++,  корректировка имен
     происходит автоматически и прозрачно для программы. Однако, когда
     вы пишете  ассемблерный  модуль  для последующей его компоновки с
     программой на С++,  вы сами обязаны обеспечить корректировку имен
     в модуле. Это легко сделать, написав пустую функцию на С+ и ском-
     пилировав  ее  с  ассемблерным  модулем.  Генерируемый  при  этом
     Borland С++  файл .ASM будет содержать исправленные имена.  Затем
     вы можете их использовать при написании  реального  ассемблерного
     модуля.

          Например, следующий  фрагмент кода определяет четыре различ-
     ные версии функции с именем test:

          void test()
          {
          }

          void test( int )
          {
          }

          void test( int, int )
          {
          }

          void test( float, double )
          {
          }

          Если этот код компилируется с параметром -S,  то  компилятор
     создает  на  выходе  файл на языке Ассемблера (.ASM).  Вот как он
     выглядит (несущественные детали убраны):

          ;       void test()
          @testSqv       proc    near
                 push    bp
                 mov     bp,sp
                 popo    bp
                 ret
          @testSqv       endp


     Турбо Ассемблер 3.0/tasm/#2-2                              = 78 =

          ;       void test( int )
          @testSqi       proc    near
                 push    bp
                 mov     bp,sp
                 popo    bp
                 ret
          @testSqi       endp

          ;       void test( int, int )
          @testSqii      proc    near
                 push    bp
                 mov     bp,sp
                 popo    bp
                 ret
          @testSqii      endp

          ;       void test( float, double )
          @testSqfd      proc    near
                 push    bp
                 mov     bp,sp
                 popo    bp
                 ret
          @testSqfd      endp

            Использование Extern "C" для упрощения компоновки
     ─────────────────────────────────────────────────────────────────

           При желании  вы можете использовать в ассемблерных функциях
     неисправленные имена,  не пытаясь выяснить,  как должны выглядеть
     правленные. Использование нескорректированных  имен  защитит ваши
     ассемблерные функции  от возможных изменений алгоритма в будущем.
     Borland С++ позволяет определять  в  программах  С++  стандартные
     имена функций С++, как в следующем примере:

          extern "C" {
               int add(int *a, int b);
          }

          Любые функции,  объявленные внутри фигурных скобок,  получат
     имена в стиле языка Си. Ниже показаны соответствующие определения
     в ассемблерном модуле:

                public _add
           _add proc

          Объявление ассемблерной функции в блоке extern "C"  позволит
     вам избежать  проблем  со "откорректированными именами". При этом
     улучшится и читаемость кода.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 79 =

                        Модели памяти и сегменты
     ─────────────────────────────────────────────────────────────────

          Чтобы  данная  функция  Ассемблера могла могла вызываться из
     С++, она должна использовать ту же модель памяти, что и программа
     на языке С++, а также совместимый с С++ сегмент кода. Аналогично,
     чтобы данные,  определенные в модуле Ассемблера,  были доступны в
     программе  на языке С++ (или данные С++ были доступны в программе
     Ассемблера),  в программе на Ассемблере должны соблюдаться согла-
     шения языка С++ по наименованию сегмента данных.

          Модели памяти и обработку сегментов на Ассемблере может ока-
     заться реализовать  довольно сложно.  К счастью,  Турбо Ассемблер
     сам выполняет почти всю работу по  реализации  моделей  памяти  и
     сегментов,  совместимых с Borland C++, при использовании упрощен-
     ных директив определения сегментов.

        Упрощенные директивы определения сегментов и Borland C++
     ─────────────────────────────────────────────────────────────────

          Директива .MODEL  указывает Турбо Ассемблеру,  что сегменты,
     создаваемые с помощью упрощенных директив  определения сегментов,
     должны быть совместимы с выбранной моделью памяти (TINY - крохот-
     ной,  SMALL - малой,  COMPACT -  компактной,  MEDIUM  -  средней,
     LARGEбольшой  или  HUGE  -  громадной) и управляет назначаемым по
     умолчанию типом (FAR или NEAR) процедур, создаваемых по директиве
     PROC.  Модели  памяти,  определенные  с помощью директивы .MODEL,
     совместимы с моделями Borland C++ с соответствующими именами.

          Наконец, упрощенные директивы определения  сегментов  .DATA,
     .CODE,  .DATA?, .FARDATA, .FARDATA? и .CONST генерируют сегменты,
     совместимые с Borland C++.

          Например, рассмотрим  следующий  модуль  Турбо  Ассемблера с
     именем DOTOTAL.ASM:

             .MODEL   SMALL       ; выбрать малую модель памяти
                                  ; (ближний код и данные)
             .DATA                ; инициализация сегмента данных,
                                  ; совместимого с Borland C++
             EXTRN   _Repetitions:WORD ; внешний идентификатор
             PUBLIC  _StartingValue ; доступен для других модулей
     _StartValue     DW   0
             .DATA?               ; инициализированный сегмент
                                  ; данных, совместимый с Borland C++
     RunningTotal    DW   ?
             .CODE                ; сегмент кода, совместимый с
                                  ; Borland C++
             PUBLIC  _DoTotal
     _DoTotal        PROC         ; функция (в малой модели памяти
                                  ; вызывается с помощью вызова
                                  ; ближнего типа)
             mov     cx,[_Repetitions] ; счетчик выполнения

     Турбо Ассемблер 3.0/tasm/#2-2                              = 80 =

             mov     ax,[_StartValue]
             mov     [RunningTotal],ax ; задать начальное
                                  ; значение
     TotalLoop:
             inc     [RunningTotal] ; RunningTotal++
             loop    TotalLoop
             mov     ax,[RunningTotal] ; возвратить конечное
                                  ; значение (результат)
             ret
     _DoTotal        ENDP
             END

          Написанная на  Ассемблере процедура _DoTotal при использова-
     нии малой модели памяти может вызываться из Borland C++ с помощью
     оператора:

             DoTotal();

          Заметим, что в процедуре DoTotal предполагается,  что где-то
     в  другой   части   программы   определена   внешняя   переменная
     Repetitions.  Аналогично, переменная StartingValue объявлена, как
     общедоступная,  поэтому она доступна в других  частях  программы.
     Следующий модуль Borland C++ (который называется SHOWTOT.CPP) об-
     ращается  к  данным  в  DOTOTAL.ASM  и  обеспечивает  для  модуля
     DOTOTAL.ASM внешние данные:

          extern  int StartingValue;
          extern  int DoTotal(word);
          int  Repetitions;
          main()
          {
             int i;
             Repetitions = 10;
             StartingValue = 2;
             print("%d\n", DoTotal());
          }

          Чтобы создать из модулей DOTOTAL.ASM и SHOWTOT.CPP выполняе-
     мую программу SHOWTOT.EXE, введите команду:

          bcc showtot.cpp dototal.asm

          Если бы вы захотели скомпоновать процедуру _DoTotal с  прог-
     раммой на языке C++,  использующей компактную модель  памяти,  то
     пришлось бы просто заменить директиву .MODEL на .MODEL COMPACT, а
     если бы вам  потребовалось  использовать  в  DOTATOL.ASM  сегмент
     дальнего типа,  то можно было бы использовать директиву .FARDATA.

          Короче говоря, при использовании упрощенных директив опреде-
     ления  сегментов генерация корректного  упорядочивания сегментов,
     моделей памяти и имен сегментов труда не составляет.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 81 =

          Старые директивы определения сегментов и Borland C++
     ─────────────────────────────────────────────────────────────────
          Коснемся теперь проблемы организации интерфейса Турбо Ассем-
     блера с  кодом языка С++,  где используются директивы определения
     сегментов старого типа (стандартные директивы определения сегмен-
     тов).  Например, если вы замените в модуле DOTOTAL.ASM упрощенные
     директивы определения сегментов директивами старого типа,  то по-
     лучите следующее:

         DGROUP  group    _DATA,_BSS
         _DATA   segment  word public 'DATA'
                 EXTRN   _Repetitions:WORD ; внешний идентификатор
                 PUBLIC  _StartingValue ; доступен для других модулей
         _StartValue     DW   0
         _DATA   ends
         _BSS    segment word public 'BSS'
         RunningTotal    DW   ?
         _BSS    ends
         _TEXT   segment byte public 'CODE'
                 assume  cs:_TEXT.ds:DGROUP,ss:DGROUP
                 PUBLIC  _DoTotal
         _DoTotal        PROC         ; функция (в малой модели памяти
                                      ; вызывается с помощью вызова
                                      ; ближнего типа)
                 mov     cx,[_Repetitions] ; счетчик выполнения
                 mov     ax,[_StartValue]
                 mov     [RunningTotal],ax ; задать начальное
                                      ; значение
         TotalLoop:
                 inc     [RunningTotal] ; RunningTotal++
                 loop    TotalLoop
                 mov     ax,[RunningTotal] ; возвратить конечное
                                      ; значение (результат)
                 ret
         _DoTotal        ENDP
         _TEXT   ENDS
                 END

          Данная версия директив определения сегментов не только длин-
     нее,  то также и хуже читается.  К тому же  при  использовании  в
     программе  на языке С++ различных моделей памяти ее труднее изме-
     нять.  При организации интерфейса с Borland C++ в общем случае  в
     использовании  старых  директив определения сегментов нет никаких
     преимуществ.  Если же вы тем не менее захотите  использовать  при
     организации интерфейса с Borland C++ старые директивы определения
     сегментов, вам придется идентифицировать корректные сегменты, со-
     ответствующие используемым в коде на языке С++ моделям памяти.

          Простейший способ  определения,  какие  сегментные директивы
     старых версий должны выбираться для компоновки  с  той  или  иной
     программой Borland С++,  заключается в компиляции главного модуля
     программы на Borland С++ для желаемой модели памяти  с параметром
     -S, что тем самым заставит Borland С++ сгенерировать ассемблерную

     Турбо Ассемблер 3.0/tasm/#2-2                              = 82 =

     версию соответствующей программы на Borland С++.  В  этой  версии
     кодов Си  вы  сможете найти все старые сегментные директивы,  ис-
     пользуемые Турбо Cи;  просто скопируйте их  в  вашу  ассемблерную
     часть программы.

          Вы также можете посмотреть, как будут выглядеть соответству-
     ющие старые директивы,  скомпилировав их обычным образом (без па-
     раметра -S) и использовав TDUMP - утилиту, поставляемую Турбо Ас-
     семблером,  чтобы получить все записи определения  сегмента.  Ис-
     пользуйте следующую командную строку:

         tdump -OI segdef module.obj



     Турбо Ассемблер 3.0/tasm/#2-2                              = 83 =

       Значения по умолчанию: когда необходимо загружать сегменты?
     ─────────────────────────────────────────────────────────────────

          В некоторых  случаях вызываемые из языка С++ функции Ассемб-
     лера могут использовать (загружать) для обращения  к  данным  ре-
     гистры  DS  и/или ES.  Полезно знать соотношение между значениями
     сегментных регистров при вызове из Borland C++,  так  как  иногда
     Ассемблер использует преимущества эквивалентности двух сегментных
     регистров. Давайте рассмотрим значения сегментных регистров в тот
     момент,  когда  функция  Ассемблера вызывается из Borland C++,  а
     также соотношения между сегментными регистрами, и случаи, когда в
     функции  Ассемблера требуется загружать один или более сегментных
     регистров.

          При входе  в функцию Ассемблера из Borland C++ регистры CS и
     DS имеют следующие значения,  которые зависят от используемой мо-
     дели памяти (регистр SS всегда используется для сегмента стека, а
     ES всегда используется, как начальный сегментный регистр):

           Значения регистров при входе в Ассемблер из Borland C++
                                                          Таблица 18.2
         ┌───────────────────────────────────────────────────────────┐
         │  Модель           CS                          DS          │
         ├───────────────────────────────────────────────────────────┤
         │ Крохотная         _TEXT                    DGROUP         │
         │ Малая             _TEXT                    DGROUP         │
         │ Компактная        _TEXT                    DGROUP         │
         │ Средняя        имя_файла_TEXT              DGROUP         │
         │ Большая        имя_файла_TEXT              DGROUP         │
         │ Громадная      имя_файла_TEXT   имя_вызывающего_файла_DATA│
         └───────────────────────────────────────────────────────────┘

          Здесь "имя_файла" - это имя модуля на Ассемблере, а "имя_вы-
     зывающего_файла" - это имя модуля Borland C++, вызывающего модуль
     на Ассемблере.

          В крохотной модели памяти _TEXT и DGROUP совпадают,  поэтому
     при входе в функцию содержимое регистра CS равно  содержимому DS.
     При  использовании  крохотной,  малой  и компактной модели памяти
     при входе в функцию содержимое SS равно содержимому  регистра DS.

          Когда же в функции на Ассемблере, вызываемой из программы на
     языке С++,  необходимо загружать сегментный регистр?  Отметим для
     начала, что вам никогда не придется (более того, этого не следует
     делать) загружать регистры SS или CS:  при дальних вызовах, пере-
     ходах или возвратах регистр CS  автоматически  устанавливается  в
     нужное значение, а регистр SS всегда указывает на сегмент стека и
     в ходе выполнения программы изменять его не следует  (если только
     вы не пишете программу,  которая "переключает" стеки. В этом слу-
     чае вам нужно четко понимать, что вы делаете).

          Регистр ES вы можете всегда использовать так, как это требу-
     ется.  Вы  можете установить его таким образом, чтобы он указывал

     Турбо Ассемблер 3.0/tasm/#2-2                              = 84 =

     на данные с дальним типом обращения,  или  загрузить  в  ES  сег-
     мент-приемник для строковой функции.

          С регистром  DS  дело обстоит иначе.  Во всех моделях памяти
     Borland C++,  кроме сверхбольшой,  регистр DS при входе в функцию
     указывает на статический сегмент данных (DGROUP),  и изменять его
     не следует. Для доступа к данным с дальним типом обращения всегда
     можно использовать регистр ES,  хотя вы можете посчитать, что для
     этого временно нужно использовать регистр DS (если вы собираетесь
     осуществлять интенсивный доступ к данным), что исключит необходи-
     мость использования в вашей программе множества инструкций с пре-
     фиксом переопределения сегмента. Например, вы можете обратиться к
     дальнему сегменту одним из следующих способов:

                       .
                       .
                       .
                       .FARDATA
     Counter           DW    0
                       .
                       .
                       .
                       .CODE
                       PUBLIC  _AsmFunction
     _AsmFunction      PROC
                       .
                       .
                       .
                       mov   ax,@FarData
                       mov   es,ax         ; ES указывает на
                                           ; сегмент данных с
                                           ; дальним типом
                                           ; обращения
                       inc   es:[Counter]  ; увеличить значение
                                           ; счетчика
                       .
                       .
                       .
     _AsmFunction      ENDP
                       .
                       .
                       .

     или иначе:

                       .
                       .
                       .
                       .FARDATA
     Counter           DW     0
                       .
                       .
                       .

     Турбо Ассемблер 3.0/tasm/#2-2                              = 85 =

                       .CODE
                       PUBLIC  _AsmFunction
     _AsmFunction      PROC
                       .
                       .
                       .
                       assume  ds:@FarData
                       mov   ax,@FarDAta
                       mov   ds,ax          ; DS указывает на
                                            ; сегмент данных с
                                            ; дальним типом
                                            ; обращения
                       inc   [Counter]      ; увеличить значение
                                            ; счетчика
                       assume ds:@Data
                       mov   ax,@Data
                       mov   dx,ax          ; DS снова указывает
                                            ; на DGROUP
                       .
                       .
                       .
     _AsmFunction      ENDP
                       .
                       .
                       .

          Второй вариант имеет то преимущество, что при каждом обраще-
     нии к дальнему сегменту данных в нем не требуется переопределение
     ES:. Если для обращения к дальнему сегменту вы загружаете регистр
     DS,  убедитесь в том,  что перед обращением к  другим  переменным
     DGROUP  вы  его  восстанавливаете (как это делается в приведенном
     примере). Даже если в данной функции на Ассемблере вы не обращае-
     тесь  к DGROUP,  перед выходом из нее все равно обязательно нужно
     восстановить содержимое DS,  так как в Borland C++ подразумевает-
     ся, что регистр DS не изменялся.

          При использовании в функциях,  вызываемых из С++, сверхболь-
     шой модели памяти работать с регистром DS нужно несколько по-дру-
     гому.  В сверхбольшой модели памяти Borland C++ совсем не исполь-
     зует DGROUP.  Вместо этого каждый модуль имеет  свой  собственный
     сегмент  данных,  который является дальним сегментом относительно
     всех других модулей  в  программе  (нет  совместно  используемого
     ближнего сегмента данных).  При использовании сверхбольшой модели
     памяти на входе в функцию регистр DS должен быть установлен таким
     образом,  чтобы он указывал на этот дальний сегмент данных модуля
     и не изменялся до конца функции, например:

                       .
                       .
                       .
                       .FARDATA
                       .
                       .

     Турбо Ассемблер 3.0/tasm/#2-2                              = 86 =

                       .
                       .CODE
                       PUBLIC  _AsmFunction
     _AsmFunction      PROC
                       push    ds
                       mov     ax,@FarData
                       mov     ds,ax
                       .
                       .
                       .
                       pop     ds
                       ret
     _AsmFunction      ENDP
                       .
                       .
                       .

          Заметим, что  исходное состояние регистра DS сохраняется при
     входе в функцию _AsmFunction с помощью инструкции  PUSH  и  перед
     выходом восстанавливается с помощью инструкции POP. Даже в сверх-
     большой модели памяти Borland C++ требует, чтобы все функции сох-
     раняли регистр DS.

                 Общедоступные и внешние идентификаторы
     ─────────────────────────────────────────────────────────────────

          Программы Турбо Ассемблера могут вызывать функции С++ и ссы-
     латься на внешние переменные Си.  Программы Borland C++ аналогич-
     ным образом могут вызывать общедоступные (PUBLIC)  функции  Турбо
     Ассемблера и обращаться к переменным Турбо Ассемблера.  После то-
     го,  как в Турбо Ассемблере устанавливаются совместимые с Borland
     C++ сегменты (как описано в предыдущих разделах), чтобы совместно
     использовать функции и переменные Borland C++ и Турбо Ассемблера,
     нужно соблюдать несколько простых правил.

                         Подчеркивания и язык Си
     ─────────────────────────────────────────────────────────────────

          Если вы пишете на языке Си или С++,  то  все  внешние  метки
     должны  начинаться  с символа  подчеркивания (_). Компилятор Си и
     С++ вставляет символы подчеркивания перед всеми  именами  внешних
     функций и  переменных  при их использовании в программе на Си/С++
     автоматически,  поэтому вам требуется вставить их самим только  в
     ассемблерных кодах. Вы должны убедиться, что все ассемблерные об-
     ращения к функциям и переменным Си начинаются с символа подчерки-
     вания,  и  кроме того,  вы должны вставить его перед именами всех
     ассемблерных функций и переменных,  которые делаются общими и вы-
     зываются из программы на языке Си/С++.

          Например, следующая программа на языке Си (link2asm.cpp):

           extrn int ToggleFlag();
           int Flag;

     Турбо Ассемблер 3.0/tasm/#2-2                              = 87 =

           main()
           {
               ToggleFlag();
           }

     правильно компонуется  со  следующей  программой  на   Ассемблере
     (CASMLINK.ASM):

                 .MODEL  SMALL
                 .DATA
                 EXTRN   _Flag:word
                 .CODE
                 PUBLIC  _ToggleFlag
     _ToggleFlag PROC
                 cmp     [_Flag],0      ; флаг сброшен?
                 jz      SetFlag        ; да, установить его
                 mov     [_Flag],0      ; нет, сбросить его
                 jmp     short EndToggleFlag ; выполнено
     SetFlag:
                 mov     [_Flag],1      ; установить флаг
     EndToggleFlag:
                 ret
     _ToggleFlag ENDP
                 END

          При использовании в директивах EXTERN и PUBLIC спецификатора
     языка Си правильно компонуется со следующей программой на Ассемб-
     лере (CSPEC.ASM):

                 .MODEL  SMALL
                 .DATA
                 EXTRN   C Flag:word
                 .CODE
                 PUBLIC  C ToggleFlag
     ToggleFlag  PROC
                 cmp     [Flag],0       ; флаг сброшен?
                 jz      SetFlag        ; да, установить его
                 mov     [Flag],0       ; нет, сбросить его
                 jmp     short EndToggleFlag ; выполнено
     SetFlag:
                 mov     [Flag],1       ; установить флаг
     EndToggleFlag:
                 ret
     ToggleFlag  ENDP
                 END

                Примечание: Метки,  на  которые  отсутствуют  ссылки в
           программе не Си (такие, как SetFlag) не требуют предшеству-
           ющих символов подчеркивания.

          Турбо Ассемблер  автоматически  при  записи  имен   Flag   и
     ToggleFlag  в объектный файл поместит перед ними символ подчерки-
     вания.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 88 =


      Различимость  строчных и прописные символов в идентификаторах
     ─────────────────────────────────────────────────────────────────

          В именах идентификаторов Турбо Ассемблер обычно не различает
     строчные и прописные буквы (верхний и нижний регистр).  Поскольку
     в С++ они различаются, желательно задать такое различие и в Турбо
     Ассемблере (по крайней мере для тех идентификаторов, которые сов-
     местно  используются Ассемблером и С++).  Это можно сделать с по-
     мощью параметров /ML и /MX.

          Переключатель (параметр) командной  строки  /ML  приводит  к
     тому,  что  в Турбо Ассемблере во всех идентификаторах строчные и
     прописные символы будут различаться (считаться различными). Пара-
     метр  командной строки /MX указывает Турбо Ассемблеру, что строч-
     ные и  прописные  символы  (символы  верхнего и нижнего регистра)
     нужно различать в общедоступных (PUBLIC) идентификаторах, внешних
     (EXTRN) идентификаторах глобальных (GLOBAL) идентификаторах и об-
     щих (COMM) идентификаторах.  В большинстве случаев следует  также
     использовать параметр /ML.

                               Типы меток
     ─────────────────────────────────────────────────────────────────

          Хотя в программах Турбо Ассемблера можно свободно обращаться
     к любой переменной или данным любого размера (8, 16, 32 бита и т.
     д.), в общем случае хорошо обращаться к переменным в соответствии
     с их размером. Например, если вы записываете слово в байтовую пе-
     ременную, то обычно это приводит к проблемам:

                 .
                 .
                 .
     SmallCount  DB   0
                 .
                 .
                 .
                 mov   WORD PTR [SmallCount],0ffffh
                 .
                 .
                 .

          Поэтому важно, чтобы в операторе Ассемблера EXTRN, в котором
     описываются переменные С++,  задавался правильный размер этих пе-
     ременных,  так как при генерации размера доступа к переменной С++
     Турбо Ассемблер основывается именно на этих описаниях.

          Если в программе на языке С++ содержится оператор:

             char c

     то код Ассемблера:


     Турбо Ассемблер 3.0/tasm/#2-2                              = 89 =

                      .
                      .
                      .
     EXTRN            c:WORD
                      .
                      .
                      .
                      inc  [c]
                      .
                      .
                      .

     может привести к весьма неприятным ошибкам, поскольку после того,
     как в  коде  на  языке  С++ переменная c увеличится очередные 256
     раз, ее значение будет сброшено, а так как она описана, как пере-
     менная  размером  в  слово,  то байт по адресу OFFSET c + 1 будет
     увеличиваться некорректно, что приведет к непредсказуемым резуль-
     татам.


     Турбо Ассемблер 3.0/tasm/#2-2                              = 90 =


          Между типами  данных  С++  а Ассемблера существует следующее
     соотношение:

     ┌───────────────────────────────┬───────────────────────────────┐
     │    Тип данных С++             │          Тип данных Ассемблера│
     ├───────────────────────────────┼───────────────────────────────┤
     │    unsigned char              │                     byte      │
     │    char                       │                     byte      │
     │    enum                       │                     word      │
     │    unsigned short             │                     word      │
     │    short                      │                     word      │
     │    unsigned int               │                     word      │
     │    int                        │                     word      │
     │    unsigned long              │                     dword     │
     │    long                       │                     dword     │
     │    float                      │                     dword     │
     │    double                     │                     qword     │
     │    long double                │                     tbyte     │
     │    near*                      │                     word      │
     │    far*                       │                     dword     │
     └───────────────────────────────┴───────────────────────────────┘

                     Внешние дальние идентификаторы
     ─────────────────────────────────────────────────────────────────

          Если вы используете упрощенные директивы определения сегмен-
     тов,  то описания идентификаторов EXTRN в сегментах дальнего типа
     не должны размещаться ни в каком сегменте, так как  Турбо  Ассем-
     блер  рассматривает  идентификаторы, описанные в данном сегменте,
     как связанные с данным сегментом. Это имеет свои недостатки: Тур-
     бо Ассемблер не может проверить возможность адресации к идентифи-
     катору, описанному, как внешний (EXTRN), вне  любого  сегмента  и
     поэтому  не может в случае необходимости  сгенерировать определе-
     ние сегмента или сообщить вам, что была попытка обратиться к дан-
     ной переменной, когда сегмент не был загружен корректным значени-
     ем. Тем  не  менее Турбо Ассемблер генерирует для ссылок на такие
     внешние идентификаторы правильный код,  но  не  может  обеспечить
     обычную степень проверки возможности адресации к сегменту.

          Если вы все-таки захотите, то можно использовать для  явного
     описания каждого внешнего идентификатора сегмента старые директи-
     вы определения сегментов, а затем поместить директиву  EXTRN  для
     этого  идентификатора внутрь описания сегмента. Это довольно уто-
     мительно, поэтому если вы не хотите обеспечивать загрузку коррек-
     тного  значения  сегмента  при обращении к данным, то проще всего
     просто разместить описания  EXTRN  для  идентификаторов  дальнего
     типа   вне   всех  сегментов.  Предположим,  например,  что  файл
     FILE1.ASM содержит следующее:

                          .
                          .
                          .

     Турбо Ассемблер 3.0/tasm/#2-2                              = 91 =

                          .FARDATA
     FileVariable         DB   0
                          .
                          .
                          .

     и он компонуется с файлом FILE2.ASM, который содержит:

                          .
                          .
                          .
                          .DATA
                          EXTRN  FileVariable:BYTE
                          .CODE
     Start                PROC
                          mov   ax,SEG FileVariable
                          mov   ds,ax
                          .
                          .
                          .

          SEG FileVariable  не  будет  возвращать корректного значения
     сегмента.  Директива EXTRN размещена в области действия директивы
     файла FILE2.ASM DATA,  поэтому Турбо Ассемблер считает, что пере-
     менная FileVariable должна находиться  в  ближнем  сегменте  DATA
     файла FILE2.ASM, а не в дальнем сегмента DATA.

          В следующем коде FILE2.ASM SEG FileVariable будет возвращать
     корректное значение сегмента:

                          .
                          .
                          .
                          .DATA
     @CurSeg              ENDS
                          EXTRN   FileVariable:BYTE
                          .CODE
     Start                PROC
                          mov   ax,SEG FileVariable
                          mov   ds,ax
                          .
                          .
                          .

          "Фокус" здесь состоит в том,  что директива @CurSeg ENDS за-
     вершает  сегмент  .DATA,  поэтому,  когда переменная FileVariable
     описывается,  как внешняя,  никакая сегментная директива не дейс-
     твует.

                     Командная строка компоновщика
     ─────────────────────────────────────────────────────────────────

          Простейший способ скомпоновать модули Borland C++ с модулями

     Турбо Ассемблер 3.0/tasm/#2-2                              = 92 =

     Турбо Ассемблера состоит в том, чтобы ввести одну командную стро-
     ку Borland C++,  после чего он выполнит всю остальную работу. При
     задании нужной командной строки Borland C++  выполнит  компиляцию
     исходного кода Си, вызовет Турбо Ассемблер для ассемблирования, а
     затем вызовет утилиту TLINK для компоновки объектных файлов в вы-
     полняемый файл.  Предположим, например, что у вас есть программа,
     состоящая из файлов на языке Си MAIN.CPP и STAT.CPP и файлов  Ас-
     семблера SUMM.ASM и DISPLAY.ASM. Командная строка:

             bcc main.cpp stat.cpp summ.asm display.asm

     выполняет компиляцию  файлов MAIN.CPP и STAT.CPP, ассемблирование
     файлов SUMM.ASM и DISPLAY.ASM и компоновку всех четырех объектных
     файлов, а также кода инициализации С++ и необходимых библиотечных
     функций в выполняемый файл MAIN.EXE.  При вводе имен  файлов  Ас-
     семблера нужно только помнить о расширениях .ASM.

          Если вы используете утилиту TLINK в  автономном  режиме,  то
     генерируемые Турбо Ассемблером объектные файлы представляют собой
     стандартные объектные модули и обрабатываются также,  как  объек-
     тные модули С++.  Описание TLINK в автономном режиме см. в Прило-
     жении С.



     Турбо Ассемблер 3.0/tasm/#2-2                              = 93 =

          Взаимодействие между Турбо Ассемблером и Borland C++
     ─────────────────────────────────────────────────────────────────

          Теперь, когда вы понимаете,  как нужно строить и компоновать
     совместимые с С++ модули Ассемблера, нужно знать, какой код можно
     помещать в функции Ассемблера,  вызываемые из  С++.  Здесь  нужно
     проанализировать три момента:  получение передаваемых параметров,
     использование регистров и возврат значений в вызывающую  програм-
     му.

                           Передача параметров
     ─────────────────────────────────────────────────────────────────

          Borland C++ передает функциям параметры  через  стек.  Перед
     вызовом функции С++ сначала заносит передаваемые этой функции па-
     раметры,  начиная с самого правого параметра и  кончая  левым,  в
     стек. В С++ вызов функции:

          .
          .
          .
          Test(i, j, 1);
          .
          .
          .

     компилируется в инструкции:

          mov   ax,1
          push  ax
          push  word ptr DGROUP:_j
          push  word ptr DGROUP:_i
          call  near ptr _Test
          add   sp,6

     где видно, что правый параметр (значение  1),  заносится  в  стек
     первым, затем туда заносится параметр j и, наконец, i.

          При возврате  из функции занесенные в стек параметры все еще
     находятся там,  но они больше не используются. Поэтому непосредс-
     твенно  после каждого вызова функции Borland C++ настраивает ука-
     затель стека обратно в соответствии со значением, которое он имел
     перед занесением в стек параметров (параметры, таким образом, от-
     брасываются).  В предыдущем примере три параметра (по  два  байта
     каждый)  занимают в стеке вместе 6 байт,  поэтому Borland C++ до-
     бавляет значение 6 к указателю стека,  чтобы отбросить  параметры
     после обращения к функции Test. Важный момент здесь заключается в
     том, что в соответствии с используемыми по умолчанию соглашениями
     Си/C++ за удаление параметров из стека отвечает вызывающая  прог-
     рамма.

          Функции Ассемблера могут обращаться к параметрам, передавае-
     мым в стеке, относительно регистра BP. Например, предположим, что

     Турбо Ассемблер 3.0/tasm/#2-2                              = 94 =

     функция Test в предыдущем примере  представляет  собой  следующую
     функцию на Ассемблере (PRMSTACK.ASM):

                  .MODEL   SMALL
                  .CODE
                  PUBLIC   _Test
     _Test        PROC
                  push   bp
                  mov    bp,sp
                  mov    ax,[bp+4]    ; получить параметр 1
                  add    ax,[bp+6]    ; прибавить параметр 2
                                      ; к параметру 1
                  sub    ax,[bp+8]    ; вычесть из суммы 3
                  pop    bp
                  ret
     _Test        ENDP

          Как можно видеть,  функция  Test  получает  передаваемые  из
     программы на языке Си параметры через стек, относительно регистра
     BP.  (Если вы помните, BP адресуется к сегменту стека.) Но откуда
     она знает, где найти параметры относительно BP?

          На Рис.  18.2 показано,  как выглядит стек перед выполнением
     первой инструкции в функции Test:

          i = 25;
          j = 4;
          Test(1, j, 1);

                              .                       .
                              .                       .
                              .                       .
                              │                       │
                              ├───────────────────────┤
                              │                       │
                              ├───────────────────────┤
                     SP ──   │    Адрес возврата     │
                              ├───────────────────────┤
                     SP + 2   │        25 (i)         │
                              ├───────────────────────┤
                     SP + 4   │        4 (j)          │
                              ├───────────────────────┤
                     SP + 6   │           1           │
                              ├───────────────────────┤
                              │                       │
                              ├───────────────────────┤
                              │                       │
                              .                       .
                              .                       .
                              .                       .

          Рис. 18.2 Состояние стека перед выполнением первой  инструк-
     ции функции Test

     Турбо Ассемблер 3.0/tasm/#2-2                              = 95 =


          Параметры функции Test представляют собой фиксированные  ад-
     реса относительно SP, начиная с ячейки, на два байта старше адре-
     са, по которому хранится адрес возврата, занесенный туда при  вы-
     зове. После загрузки регистра BP значением SP вы можете обращать-
     ся к параметрам относительно BP. Однако, вы должны сначала сохра-
     нить BP,  так как в вызывающей программе предполагается,  что при
     возврате  BP  изменен не будет.  Занесение в стек BP изменяет все
     смещения в стеке. На Рис. 18.3 показано состояние стека после вы-
     полнения следующих строк кода:

           .
           .
           .
           push  bp
           mov   bp,sp
           .
           .
           .

                           .                       .
                           .                       .
                           .                       .
                           │                       │
                           ├───────────────────────┤
                  SP ──   │ BP вызывающей прогр.  │  ── BP
                           ├───────────────────────┤
                  SP + 2   │    Адрес возврата     │  BP + 2
                           ├───────────────────────┤
                  SP + 4   │        25 (i)         │  BP + 4
                           ├───────────────────────┤
                  SP + 6   │        4 (j)          │  BP + 6
                           ├───────────────────────┤
                  SP + 8   │           1           │  BP + 8
                           ├───────────────────────┤
                           │                       │
                           ├───────────────────────┤
                           │                       │
                           .                       .
                           .                       .
                           .                       .

          Рис. 18.3 Состояние стека после инструкций PUSH и MOVE

          Организация передачи параметров функции через стек и исполь-
     зование его для динамических локальных переменных - это стандарт-
     ный прием в языке С++. Как можно заметить, неважно, сколько пара-
     метров имеет программа на языке С++:  самый левый параметр всегда
     хранится в стеке по адресу,  непосредственно следующим за  сохра-
     ненным в стеке адресом возврата,  следующий возвращаемый параметр
     хранится непосредственно после самого  левого  параметра  и  т.д.
     Поскольку  порядок  и  тип  передаваемых параметров известны,  их
     всегда можно найти в стеке.

     Турбо Ассемблер 3.0/tasm/#2-2                              = 96 =


          Пространство для динамических локальных переменных можно за-
     резервировать, вычитая  из  SP  требуемое  число байт.  Например,
     пространство для динамического локального массива размером  в 100
     байт можно  зарезервировать,  если начать функцию Test с инструк-
     ций:

          .
          .
          .
          push  bp
          mov   bp,sp
          sub   sp,100
          .
          .
          .

     как показано на Рис. 18.4


     Турбо Ассемблер 3.0/tasm/#2-2                              = 97 =


                               .                       .
                               .                       .
                               .                       .
                               │                       │
                               ├───────────────────────┤
                  SP ──       │                       │ ─ BP - 100
                               ├───────────────────────┤
                               │                       │
                               ├───────────────────────┤
                               .                       .
                               .                       .
                               .                       .
                               .                       .
                               │                       │
                               ├───────────────────────┤
                  SP + 100 ── │ BP вызывающей прогр.  │  ── BP
                               ├───────────────────────┤
                  SP + 102     │    Адрес возврата     │  BP + 2
                               ├───────────────────────┤
                  SP + 104     │        25 (i)         │  BP + 4
                               ├───────────────────────┤
                  SP + 106     │        4 (j)          │  BP + 6
                               ├───────────────────────┤
                  SP + 108     │           1           │  BP + 8
                               ├───────────────────────┤
                               │                       │
                               ├───────────────────────┤
                               │                       │
                               .                       .
                               .                       .
                               .                       .

          Рис. 18.4 Состояние стека после инструкций PUSH,  MOVE и SUB

          Поскольку та часть стека, где хранятся динамические  локаль-
     ные переменные, представляет собой более младшие  адреса, чем BP,
     для обращения к динамическим  локальным  переменным  используется
     отрицательное смещение. Например, инструкция:

           mov   byte ptr  [bp-100]

     даст значение первого байта ранее зарезервированного 100-байтово-
     го  массива.  При передаче параметров всегда используется положи-
     тельная адресация относительно регистра BP.

          Хотя можно выделять пространство для динамических  локальных
     переменных описанным выше способом, в Турбо Ассемблере предусмот-
     рена специальная версия директивы LOCAL, которая существенно  уп-
     рощает выделение  памяти и присваивание имен для динамических ло-
     кальных  переменных.  Когда  в  процедуре  встречается  директива
     LOCAL, то подразумевается, что она определяет для данной процеду-
     ры динамические локальные переменные. Например, директива:

     Турбо Ассемблер 3.0/tasm/#2-2                              = 98 =


          LOCAL  LocalArray:BYTE:100,LocalCount:WORD=AUTO_SIZE

     определяет  динамические  переменные   LocalArray  и  LocalCount.
     LocalArray на самом деле представляет собой метку, приравненную к
     [BP-100], а LocalCount - это метка, приравненная к [BP-102].  Од-
     нако  вы  можете  использовать их, как имена переменных. При этом
     вам даже не нужно будет знать их значения. AUTO_SIZE - это  общее
     число байт (объем памяти),  необходимых для хранения динамических
     локальных переменных.  Чтобы выделить пространство для динамичес-
     ких локальных переменных, это значение нужно вычесть из SP.

          Приведем  пример  того,  как  нужно  использовать  директиву
     LOCAL:

                     .
                     .
                     .
     _TestSub        PROC
                     LOCAL
     LocalArray:BYTE:100,LocalCount:WORD=AUTO_SIZE
                     push  bp          ; сохранить указатель стека
                                       ; вызывающей программы
                     mov   bp,sp       ; установить собственный
                                       ; указатель стека
                     sub   sp,AUTO_SIZE ; выделить пространство для
                                       ; динамических локальных
                                       ; переменных
                     mov   [LocalCount],10 ; установить переменную
                                       ; LocalCount в значение 10
                                       ; (LocalCount это  [BP-102])
                     .
                     .
                     .
                     mov   cx,[LocalCount] ; получить значение
                                        ; (счетчик) из локальной
                                        ; переменной
                     mov   al,'A'       ; заполним символом 'A'
                     lea   bx,[LocalArray] ; ссылка на локальный
                                        ; массив LocalArray
                                        ; (LocalArray это [BP-100])
     FillLoop:
                     mov   [bx],al      ; заполнить следующий байт
                     inc   bx           ; ссылка на следующий байт
                     loop  FillLoop     ; обработать следующий байт,
                                        ; если он имеется
                     mov   sp,bp        ; освободить память,
                                        ; выделенную для динамичес-
                                        ; ких локальных переменных
                                        ; (можно также использовать
                                        ; add sp,AUTO_SIZE)
                     pop   bp           ; восстановить указатель
                                        ; стека вызывающей программы

     Турбо Ассемблер 3.0/tasm/#2-2                              = 99 =

                     ret
     _TestSub        ENDP
                     .
                     .
                     .

          В данном примере следует обратить внимание не то, что первое
     поле  после  определения данной динамической локальной переменной
     представляет собой тип данных для этой  переменной:  BYTE,  WORD,
     DWORD,  NEAR и т.д.  Второе поле после определения данной динами-
     ческой локальной переменной - это число элементов указанного  ти-
     па, резервируемых для данной переменной. Это поле является необя-
     зательным и определяет используемый динамический локальный массив
     (если он используется). Если данное поле пропущено, то резервиру-
     ется один элемент указанного типа.  В итоге LocalArray состоит из
     100 элементов размером в 1 байт, а LocalCount - из одного элемен-
     та размером в слово (см. пример).

          Отметим также, что строка с директивой LOCAL в данном приме-
     ре  завершается полем =AUTO_SIZE. Это поле, начинающееся со знака
     равенства, необязательно. Если оно присутствует, то метка, следу-
     ющая за знаком равенства,  устанавливается в значение числа  байт
     требуемой динамической локальной памяти.  Вы должны затем исполь-
     зовать данную метку для выделения и освобождения памяти для дина-
     мических локальных переменных, так как директива LABEL только ге-
     нерирует метки и не  генерирует  никакого  кода  или  памяти  для
     данных.  Иначе говоря, директива LOCAL не выделяет память для ди-
     намических локальных переменных, а просто генерирует метки, кото-
     рые  вы  можете использовать как для выделения памяти,  так и для
     доступа к динамическим локальным переменным.

          Очень удобное свойство директивы LOCAL  заключается  в  том,
     что  область  действия  меток динамических локальных переменных и
     общего размера динамических локальных переменных  ограничена  той
     процедурой, в которой они используются, поэтому вы можете свобод-
     но использовать имя динамической локальной  переменной  в  другой
     процедуре.

          Как можно заметить, с помощью директивы LOCAL  определять  и
     использовать  автоматические  переменные  намного легче. Отметим,
     что при использовании в макрокомандах директива LOCAL  имеет  со-
     вершенно  другое  значение.

          Кстати, Borland  C++ работает с границами стека так же,  как
     мы здесь описали.  Вы  можете  скомпилировать  несколько  модулей
     Borland  C++  с параметром -S и посмотреть,  какой код Ассемблера
     генерирует Borland C++ и как там создаются и используются границы
     стека.

          Все  это  прекрасно,  но  здесь  есть  некоторые  трудности.
     Во-первых, такой способ доступа к параметрам, при котором исполь-
     зуется постоянное смещение относительно BP достаточно  неприятен:
     при  этом  не  только легко ошибиться, но если вы добавите другой

     Турбо Ассемблер 3.0/tasm/#2-2                             = 100 =

     параметр, все другие смещения указателя стека  в  функции  должны
     измениться.  Предположим, например, что функция Test воспринимает
     три параметра:

          Test(Flag, i, j, 1);

          Тогда i находится по смещению 6, а не по смещению 4, j -  по
     смещению 8, а не 6 и т.д. Для смещений параметров можно использо-
     вать директиву EQU:

                         .
                         .
                         .
           Flag          EQU  4
           AddParm1      EQU  6
           AddParm2      EQU  8
           SubParm1      EQU  10

                         mov   ax[bp+AddParm1]
                         add   ax,[bp+AddParm1]
                         sub   ax,[bp+SubParm1]
                         .
                         .
                         .

     но вычислять смещения и работать с ними довольно  сложно.  Однако
     здесь  могут возникнуть и более серьезные проблемы: в моделях па-
     мяти с дальним кодом размер занесенного в  стек  адреса  возврата
     увеличивается на два байта, как и размеры передаваемых указателей
     на код и данные в моделях памяти с дальним кодом и дальними  дан-
     ными,  соответственно. Разработка функции, которая с равным успе-
     хом будет ассемблироваться и правильно работать с указателем сте-
     ка при использовании любой модели памяти было бы весьма непростой
     задачей.

          Однако в Турбо Ассемблере предусмотрена директива ARG, с по-
     мощью которой можно легко выполнять передачу параметров  в  прог-
     раммах на Ассемблере.

          Директива ARG автоматически генерирует правильные смещения в
     стеке для заданных вами переменных. Например:

           ARG      FillArray:WORD, Count:WORD, FillValue:BYTE

          Здесь задается три параметра: FillArray, параметр размером в
     слово, Count, также параметр размером в слово и FillValue - пара-
     метр  размером  в  байт.  Директива  ARG    устанавливает   метку
     FillArray   в значение [BP+4] (подразумевается, что код находится
     в процедуре ближнего типа), метку Count - в  значение  [BP+6],  а
     метку FillValue - в значение [BP+8]. Однако особенно ценна дирек-
     тива ARG тем, что вы можете использовать определенные  с  ее  по-
     мощью метки не заботясь о тех значениях, в которые они установле-
     ны.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 101 =


          Например, предположим, что у вас есть функция FillSub  кото-
     рая вызывается из С++ следующим образом:

          extern "C" {
            void FillSub(
              char *FillArray,
              int Count,
              char FillValue);
          }

             main()
             {
             #define ARRAY_LENGTH 100
                char TestArray[ARRAY_LENGTH];
                FillSub(TestArray,ARRAY_LENGTH,'*');
          }

          В FillSub директиву ARG для работы с параметрами  можно  ис-
     пользовать следующим образом:

     _FillSub        PROC  NEAR
              ARG    FillArray:WORD, Count:WORD, FillValue:BYTE
              push   bp           ; сохранить указатель стека
                                  ; вызывающей программы
              mov    bp,sp        ; установить свой собственный
                                  ; указатель стека
              mov    bx,[FillArray] ; получить указатель на
                                  ; заполняемый массив
              mov    cx,[Count]   ; получить заполняемую длину
              mov    al,[FillValue] ; получить значение-заполнитель
     FillLoop:
              mov    [bx],al      ; заполнить символ
              inc    bx           ; ссылка на следующий символ
              loop   FillLoop     ; обработать следующий символ
              pop    bp           ; восстановить указатель стека
                                  ; вызывающей программы
              ret
     _FillSub        ENDP

          Не правда ли, удобно работать с параметрами с помощью дирек-
     тивы  ARG? Кроме того, директива ARG автоматически учитывает раз-
     личные размеры возвратов ближнего и дальнего типа.

                          Сохранение регистров
     ─────────────────────────────────────────────────────────────────

          При взаимодействии Турбо Ассемблера и Borland C++ вызываемые
     из программы на языке С++ функции Ассемблера могут делать все что
     угодно,  но при этом они должны сохранять регистры BP, SP, CS, DS
     и SS.  Хотя при выполнении функции Ассемблера эти регистры  можно
     изменять,  при  возврате  из  вызываемой  подпрограммы они должны
     иметь в точности такие значения,  какие они имели при ее  вызове.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 102 =

     Регистры AX, BX, CX, DX и ES, а также флаги могут произвольно из-
     меняться.

          Регистры DI и SI представляют собой особый случай, так как в
     Borland C++  они используются для регистровых переменных.  Если в
     модуле С++,  из которого вызывается ваша функция  на  Ассемблере,
     использование регистровых переменных разрешено, то вы должны сох-
     ранить регистры SI и DI,  если же нет,  то сохранять их не нужно.

          Однако неплохо всегда сохранять эти регистры,  независимо от
     того,  разрешено или запрещено использование регистровых перемен-
     ных.  Трудно заранее гарантировать,  что вам не придется компоно-
     вать данный модуль Ассемблера с другим модулем на языке  С++, или
     перекомпилировать  модуль С++ с разрешением использования регист-
     ровых переменных.  При этом вы можете забыть, что изменения нужно
     также внести и в код Ассемблера.

                            Возврат значений
     ─────────────────────────────────────────────────────────────────

          Вызываемые из программы на языке С++ функции  на Ассемблере,
     так  же  как и функции С++,  могут возвращать значения.  Значения
     функций возвращаются следующим образом:

     ┌──────────────────────────┬────────────────────────────────────┐
     │Тип возвращаемого значения│ Где находится возвращаемое значение│
     ├──────────────────────────┼────────────────────────────────────┤
     │ unsigned char            │                AX                  │
     │ char                     │                AX                  │
     │ enum                     │                AX                  │
     │ unsigned short           │                AX                  │
     │ short                    │                AX                  │
     │ unsigned int             │                AX                  │
     │ int                      │                AX                  │
     │ unsigned long            │                DX:AX               │
     │ long                     │                DX:AX               │
     │ float                    │  регистр вершины стека сопроцессора│
     │                          │  8087 (ST(0))                      │
     │ double                   │  регистр вершины стека сопроцессора│
     │                          │  8087 (ST(0))                      │
     │ long double              │  регистр вершины стека сопроцессора│
     │                          │  8087 (ST(0))                      │
     │ near*                    │                AX                  │
     │ far*                     │                DX:AX               │
     └──────────────────────────┴────────────────────────────────────┘

          В общем случае 8- и 16-битовые значения возвращаются  в  ре-
     гистре  AX,  а 32-битовые значения - в AX:DX (при этом старшие 16
     бит значения находятся в регистре DX).  Значения с плавающей точ-
     кой возвращаются в регистре ST(0), который представляет собой ре-
     гистр вершины стека сопроцессора 8087 или  эмулятора сопроцессора
     8087, если используется эмулятор операций с плавающей точкой.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 103 =

          Со структурами дело обстоит  несколько  сложнее.  Структуры,
     имеющие длину 1 или 2 байта, возвращаются в регистре AX, а струк-
     туры длиной 4 байта - в регистрах AX:DX. Трехбайтовые структуры и
     структуры,  превышающие 4 байта должны храниться в области стати-
     ческих данных, при этом должен возвращаться указатель на эти ста-
     тические данные. Как и все указатели, указатели на структуры, ко-
     торые  имеют  ближний тип (NEAR),  возвращаются в регистре AX,  а
     указатели дальнего типа - в паре регистров AX:DX.

          Давайте рассмотрим вызываемую  из  программы  на  языке  С++
     функцию на Ассемблере с малой моделью памяти FindLastChar,  кото-
     рая возвращает указатель на последний символ передаваемой строки.
     На языке С++ прототип этой функции выглядел бы следующим образом:

          extern char * FindLastChar(char * StringToScan);

     где StringToScan - это непустая строка, для которой должен  возв-
     ращаться указатель на последний символ.

          Функция FindLastChar имеет следующий вид:

                       .MODEL  SMALL
                       .CODE
                       PUBLIC _FindLastChar
     _FindLastChar            PROC
                       push  bp
                       mov   bp,sp
                       cld             ; в строковой инструкции нужно
                                       ; выполнять отсчет в прямом
                                       ; направлении
                       mov   ax,ds
                       mov   es,ax     ; теперь ES указывает на
                                       ; ближний сегмент данных
                       mov   di,       ; теперь ES:DI указывает на
                                       ; начало передаваемой строки
                       mov   al,0      ; найти нулевой символ,
                                       ; завершающий строку
                       mov   cx,0ffffh ; работать в пределах
                                       ; 64К-1 байт
                       repne scasb     ; найти нулевой символ
                       dec   di        ; установить указатель
                                       ; обратно на 0
                       dec   di        ; ссылка обратно на
                                       ; последний символ
                       mov   ax,dx     ; возвратить в AX указатель
                                       ; ближнего типа
                       pop   bp
                       ret
     _FindLastChar     ENDP
                       END

          Конечный результат, указатель на передаваемую строку,  возв-
     ращается в регистре AX.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 104 =


              Вызов функции Турбо Ассемблера из Borland C++
     ─────────────────────────────────────────────────────────────────

          Теперь мы рассмотрим пример программы на Borland C++,  вызы-
     вающей  функцию  Турбо  Ассемблера.   Модуль   Турбо   Ассемблера
     COUNT.ASM содержит функцию LineCount, которая возвращает значение
     счетчика числа строк и символов в передаваемой строке:

     ; Вызываемая из С++ функция на Ассемблере с малой моделью памяти
     ; для подсчета числа строк и символов в завершающейся нулем
     ; "строке".
     ;
     ; Прототип функции:
     ;      extern unsigned int LineCount(char * near StringToCount,
     ;             unsigned int near * CharacterCountPtr);
     ;
     ; Ввод:
     ;      char near * StringToCount: указатель на "строку", в
     ;      которой нужно выполнить подсчет строк.
     ;
     ;      unsigned int near * CharacterCountPtr: указатель на
     ;      целую переменную, в которую нужно записать значение
     ;      счетчика
     NEWLINE      EQU   0ah        ; символ перевода строки в Си
                  .MODEL  SMALL
                  .CODE
                  PUBLIC  _LineCount
     __LineCount   PROC
                  push  bp
                  mov   bp,sp
                  push  si         ; сохранить регистровую
                                   ; переменную вызывающей
                                   ; программы
                  mov   si,[bp+4]  ; SI указывает на строку
                  sub   cx,cx      ; установить значение
                                   ; счетчика символов в 0
                  mov   dx,cx      ; установить в 0 счетчик
                                   ; строк
     LineCountLoop:
                  lodsb            ; получить следующий символ
                  and   al,al      ; это 0? конец строки?
                  jz    EndLineCount ; да, выполнено
                  inc   cx         ; нет, подсчитать следующий
                                   ; символ
                  cmp   al,NEWLINE ; это новая строка?
                  jnz   LineCountLoop ; нет, проверить
                                   ; следующий символ
                  inc   dx         ; да, подсчитать еще одну
                                   ; строку
                  jmp   LineCountLoop
     EndLineCount:
                  inc   dx         ; подсчитать строку, которая

     Турбо Ассемблер 3.0/tasm/#2-2                             = 105 =

                                   ; завершается нулевым символом
                  mov   [bx],cx    ; задать значение переменной-
                                   ; счетчика
                  mov   ax,dx      ; возвратить счетчик строк в
                                   ; качестве значения счетчика
                  pop   si         ; восстановить регистровую
                                   ; переменную вызывающей
                                   ; программы
                  pop   bp
                  ret
     _LineCount         ENDP
                  END

          Следующий модуль на языке С++ с именем CALLCT.CPP  представ-
     ляет собой пример вызова функции LineCount:

          char * TestString="Line 1\nline 2\nline 3";
          extern "C" {
                 unsigned int LineCount(char * StringToCount,
                 unsigned int near * CharacterCountPtr); }
          main()
          {
             unsigned int LCount;
             unsigned int CCount;

             Lcount = LineCount(TestString, &CCount);
             printf("Lines: %d\nCharacters: %d\n", LCount, CCount);
          }

          Два модуля компилируются и компонуются вместе с помощью  ко-
     мандной строки:

             bcc -ms callct.cpp count.asm

          Как здесь показано, функция LineCount будет работать  только
     при компоновке с программами на языке С++, в которых используется
     малая модель памяти,  так как в других моделях размеры указателей
     и адресов в  стеке  изменятся.  Приведем  пример  версии  функции
     LineCount (COUNTLG.ASM),  которая будет работать с программами на
     С++, использующим большую модель памяти (но не малую модель: пос-
     кольку передаются дальние указатель, функция LineCount также опи-
     сана, как функция дальнего типа):

     ; Вызываемая из С++ функция на Ассемблере для подсчета числа
     ; строк и символов в завершающейся нулем "строке".
     ;
     ; Прототип функции:
     ;      extern unsigned int LineCount(char * far StringToCount,
     ;             unsigned int far * CharacterCountPtr);
     ;
     ; Ввод:
     ;      char far * StringToCount: указатель на "строку", в
     ;      которой нужно выполнить подсчет строк.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 106 =

     ;
     ;      unsigned int far * CharacterCountPtr: указатель на
     ;      целочисленную переменную, в которую нужно записать
     ;      значение счетчика
     NEWLINE      EQU   0ah        ; символ перевода строки в Си
                  .MODEL  LARGE
                  .CODE
                  PUBLIC  _LinaCount
     _LineCount   PROC
                  push  bp
                  mov   bp,sp
                  push  si         ; сохранить регистровую
                                   ; переменную вызывающей
                                   ; программы
                  push  ds         ; сохранить стандартный
                                   ; сегмент данных
                  lds   si,[bp+6]  ; DS:SI указывает на строку
                  sub   cx,cx      ; установить значение
                                   ; счетчика символов в 0
                  mov   dx,cx      ; установить в 0 счетчик
                                   ; строк
     LineCountLoop:
                  lodsb            ; получить следующий символ
                  and   al,al      ; это 0? конец строки?
                  jz    EndLineCount ; да, выполнено
                  inc   cx         ; нет, подсчитать следующий
                                   ; символ
                  cmp   al,NEWLINE ; это новая строка?
                  jnz   LineCountLoop ; нет, проверить
                                   ; следующий символ
                  inc   dx         ; да, подсчитать еще одну
                                   ; строку
                  jmp   LineCountLoop
     EndLineCount:
                  inc   dx         ; подсчитать строку, которая
                                   ; завершается нулевым символом
                  les   bx,[bp+10] ; ES:BX указывает на ячейку,
                                   ; в которой возвращается
                                   ; значение счетчика
                  mov   es:[bx],cx ; задать значение переменной-
                                   ; счетчика
                  mov   ax,dx      ; возвратить счетчик строк в
                                   ; качестве значения счетчика
                  pop   ds         ; восстановить стандартный
                                   ; сегмент данных Си
                  pop   si         ; восстановить регистровую
                                   ; переменную вызывающей
                                   ; программы
                  pop   bp
                  ret
     _LineCount         ENDP
                  END


     Турбо Ассемблер 3.0/tasm/#2-2                             = 107 =

          Программу COUNTLG.ASM можно скомпоновать с CALLCT.CPP с  по-
     мощью следующей командной строки:

          bcc -ml callct.cpp countlg.asm



     Турбо Ассемблер 3.0/tasm/#2-2                             = 108 =

           Написание на языке Ассемблера функций-элементов С++
     ─────────────────────────────────────────────────────────────────

          Хотя можно написать функцию-элемент класса  С++  целиком  на
     языке  Ассемблера,  это  далеко  не просто.  Например,  все функ-
     ции-элементы классов С++  имеют "откорректированные" имена,   что
     обеспечивает безопасную по согласованности типов компоновку функ-
     ций и делает возможным переопределение функций, а ваша ассемблер-
     ная  функция  должна знать в точности,  какое имя С++ ожидает для
     данной функции-элемента.  Для доступа к  переменным-элементам  вы
     должны подготовить в ассемблерном коде определение STRUC, опреде-
     ляющее все переменные-элементы с точно совпадающими  размерами  и
     расположением.  Если ваш класс является производным, то могут су-
     ществовать и другие переменные-элементы,  производные от базового
     класса. Даже если класс не является производным (порожденным), то
     расположение  переменных-элементов  в памяти изменяется в случае,
     если класс этот включает в себя какие-либо виртуальные функции.

          Если вы пишете функцию на встроенном Ассемблере, Borland С++
     может взять на себя эти вопросы. Однако если вы работаете на язы-
     ке  Ассемблера  отдельно  (например,  переделываете уже имеющийся
     код),  то существуют некоторые методы,  позволяющие упростить эту
     работу.

          Создайте определение  фиктивной функции С++ для ассемблерной
     функции.  Это определение удовлетворит компоновщик, так как будет
     содержать откорректированное имя функции-элемента.  Эта фиктивная
     функция будет вызывать ассемблерную функцию и передавать ей пере-
     менные-элементы и прочие параметры.  Так как ассемблерный код бу-
     дет иметь все нужные ему параметры посредством аргументов, вы мо-
     жете  не  заботиться  об  изменениях  в определении класса.  Ваша
     ассемблерная функция может быть описана в  коде  С++  как  extern
     "C", что показано в примерах. Например (countadd.cpp):

     class count_add {
          // Частные переменные-элементы (private)
          int access_count;   // число обращений
          int count;          // текущий счетчик
        public:
             count_add(void) { access_count=0;
                              count=0;
                           }
             int  get_count (void) {return Count;}

             // Две функции, которые будут фактически написаны на
             // Ассемблере:

             void increment(void);
             void add(int what_to_add=-1);
              // Отметим, что умолчание влияет только
              // на вызовы add; оно не влияет на код add
          }


     Турбо Ассемблер 3.0/tasm/#2-2                             = 109 =

          extern "C" {
            // Для создания уникальных и осмысленных имен
            // ассемблерных подпрограмм прибавим имя класса к
            // имени ассемблерной подпрограммы. В отличие от прочих
            // ассемблеров, Турбо Ассемблер не имеет проблем с
            // длиной имен.
            void count_add_increment(int *count); // Мы передадим
                                               // указатель на
                                               // переменную count.
                                               // Ассемблер выполнит
                                               // увеличение.
            void count_add_add(int *count,int what_to_add);
          }

          void count_add::increment(void)
          {
            count_add_increment(&count);
          }

          void count_add(int what_to_add)
          {
            count_add(&count, int what_to_add);
          }

          Ваш ассемблерный модуль, определяющий подпрограммы count_add
     _increment и count_add_add, должен иметь вид (COUNTADD.ASM):

          .MODEL small   ; выбор модели small (ближние код и данные)
          .CODE
          PUBLIC _count_add_increment
     _count_add_increment  PROC
          ARG count_offset:word   ; Адрес переменной-элемента
          push bp                 ; Сохранение записи активации
                                  ; вызывающей программы
          mov  bp,sp              ; Установка собственной записи
                                  ; активации
          mov  bx,[count_offset]  ; Загрузка указателя
          inc  word ptr [bx]      ; Увеличение переменной-элемента
          pop  bp                 ; Восстановление записи активации
                                  ; вызывающей программы
     _count_add_increment  ENDP

          PUBLIC _count_add_add
     _count_add_add  PROC
          ARG count_offset:word,what_to_add:word
          push bp
          mov  bp,sp
          mov  bx,[count_offset]   ; Загрузка указателя
          mov  ax,[what_to_add]
          add  [bx],ax
          pop  bp
          ret
     _count_add_add  ENDP

     Турбо Ассемблер 3.0/tasm/#2-2                             = 110 =


          end

          Используя данный метод, вы можете не беспокоиться об измене-
     ниях  в определении класса.  Даже если вы добавляете или удаляете
     переменные-элементы, делаете этот класс производным или добавляе-
     те  виртуальные  функции,  вам не требуется изменять ассемблерный
     модуль. Переассемблировать модуль нужно только в случае изменения
     структуры переменной-элемента count,  либо если вы ходите сделать
     версию данного класса для модели памяти large.  Переассемблирова-
     ние в этих случаях необходимо, поскольку при обращении к перемен-
     ной-элементу count вы имеете дело с сегментом и смещением.

             Соглашения по вызовам, использующиеся в Паскале
     ─────────────────────────────────────────────────────────────────

          Итак, теперь вы уже знаете,  как обычно в С++ передаются па-
     раметры функциям:  вызывающая программа заносит параметры (справа
     налево) в стек,  вызывает функцию, и извлекает параметры из стека
     (отбрасывает  их) после вызова.  Borland C++ может также работать
     по соглашениям, принятым в Паскале. Согласно этим соглашениям па-
     раметры  передаются  слева  направо,  а отбрасывает параметры (из
     стека) вызываемая программа.  Разрешить использование  соглашений
     Паскаля  в Borland C++ можно с помощью параметра командной строки
     -p или ключевого слова pascal.

                Примечание: Более подробно соглашения о связях Паскаля
           рассматриваются в Главе 19.

          Приведем пример функции на Ассемблере, в которой используют-
     ся соглашения Паскаля:

     ;
     ; Вызывается, как: TEST(i, j ,k)
     ;
     i       equ      8               ; левый параметр
     j       equ      6
     k       equ      4               ; правый параметр
     ;
                      .MODEL   SMALL
                      .CODE
                      PUBLIC   TEST
     TEST             PROC
                      push  bp
                      mov   bp,sp
                      mov   ax,[bp+i] ; получить i
                      add   ax,[bp+j] ; прибавить к i j
                      sub   ax,[bp+k] ; вычесть из суммы k
                      pop   bp
                      ret   6         ; возврат, отбросить
                                      ; 6 байт параметров
                                      ; (очистка стека)
     TEST             ENDP

     Турбо Ассемблер 3.0/tasm/#2-2                             = 111 =

                      END

          Заметим, что для очистки стека  от  передаваемых  параметров
     используется инструкция RET 6.

          На Рис.  18.5 показано состояние стека после выполнения инс-
     трукции MOV BP,SP:

                           .                       .
                           .                       .
                           .                       .
                           │                       │
                           ├───────────────────────┤
                  SP ──   │ BP вызывающей прогр.  │  ── BP
                           ├───────────────────────┤
                  SP + 2   │    Адрес возврата     │  BP + 2
                           ├───────────────────────┤
                  SP + 4   │          k            │  BP + 4
                           ├───────────────────────┤
                  SP + 6   │          j            │  BP + 6
                           ├───────────────────────┤
                  SP + 8   │          i            │  BP + 8
                           ├───────────────────────┤
                           │                       │
                           ├───────────────────────┤
                           │                       │
                           .                       .
                           .                       .
                           .                       .

          Рис. 18.5 Состояние стека после инструкции MOV BP,SP

          Соглашения по вызовам Паскаля требуют также, чтобы все внеш-
     ние и общедоступные идентификаторы указывались в верхнем регистре
     и без предшествующих подчеркиваний. Зачем может потребоваться ис-
     пользовать в программе на  С++  соглашения  по  вызовам  Паскаля?
     Программа,  использующая соглашения Паскаля, занимает обычно нес-
     колько меньше места в памяти  и  работает  быстрее,  чем  обычная
     программа  на языке С++,  так как для очистки стека от параметров
     не требуется выполнять n инструкций ADD SP.

                  Вызов Borland C++ из Турбо Ассемблера
     ─────────────────────────────────────────────────────────────────

          Хотя больше  принято  для выполнения специальных задач вызы-
     вать из С++ функции,  написанные на Ассемблере,  иногда вам может
     потребоваться вызывать из Ассемблера функции, написанные на языке
     С++. Оказывается, на самом деле легче вызвать функцию Borland C++
     из функции Турбо Ассемблера,  чем наоборот,  поскольку со стороны
     Ассемблера не требуется отслеживать границы стека.  Давайте расс-
     мотрим  кратко требования для вызова функций Borland C++ из Турбо
     Ассемблера.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 112 =

                   Компоновка с кодом инициализации С++
     ─────────────────────────────────────────────────────────────────

          Хорошим правилом является вызов библиотечных функций Borland
     C++ только из Ассемблера в программах,  которые компонуются с мо-
     дулем инициализации  С++ (используя его в качестве первого компо-
     нуемого модуля).  Этот "надежный" класс включает в себя все прог-
     раммы,  которые компонуются с помощью командной строки TC.EXE или
     TCC.EXE, и программы, в качестве первого компонуемого файла кото-
     рых используется файл C0T, C0S, C0C, C0M, C0L или C0H.

          В общем  случае вам не следует вызывать библиотечные функции
     Borland C++ из программ, которые не компонуются с модулем инициа-
     лизации  Borland  C++,  так  как  некоторые  библиотечные функции
     Borland C++ не будут правильно работать, если не выполнялась ком-
     поновка с кодом инициализации. Если вы действительно хотите вызы-
     вать библиотечные функции Borland C++ из таких программ, мы пред-
     лагаем вам взглянуть на код инициализации (файл C0.ASM на дистри-
     бутивных дисках Borland C++) и приобрести у фирмы Borland  исход-
     ный  код  библиотеки языка С++,  после чего вы сможете обеспечить
     правильную инициализацию для нужных библиотечных функций.

           Вызов определяемых  пользователем  функций  С++,  которые в
     свою очередь вызывают библиотечные функции языка С++,  попадают в
     ту же категорию,  что и непосредственный вызов библиотечных функ-
     ций С++.  Отсутствие кода инициализации С++ может вызывать ошибки
     в любой программе Ассемблера,  которая прямо или косвенно обраща-
     ется к библиотечным функциям С++.

                            Задание сегмента
     ─────────────────────────────────────────────────────────────────

          Как мы уже говорили ранее,  необходимо  обеспечивать,  чтобы
     Borland  C++  и  Турбо Ассемблер использовали одну и ту же модель
     памяти,  и чтобы сегменты, которые вы используете в Турбо Ассемб-
     лере,  совпадали  с  теми сегментами,  которые использует Borland
     C++. В Турбо Ассемблере имеется модель памяти tchuge,которая под-
     держивает модель huge Borland C++. Перечень моделей памяти и сег-
     ментов можно найти в предыдущем разделе.  Нужно не забывать также
     помещать  директиву  EXTRN  для  внешних идентификаторов вне всех
     сегментов или внутри правильного сегмента.

                            Выполнение вызова
     ─────────────────────────────────────────────────────────────────

          Все, что  требуется от вас для передачи параметров в функцию
     C++,  это занесение в стек самого правого параметра первым, затем
     следующего по порядку параметра и так далее, пока в стеке не ока-
     жется самый левый параметр.  После  этого  нужно  просто  вызвать
     функцию. Например, при программировании на Borland C++ для вызова
     библиотечной функции Borland C++ strcpy  для  копирования  строки
     SourceString в строку DestString можно ввести:


     Турбо Ассемблер 3.0/tasm/#2-2                             = 113 =

          strcpy(DestString, SourceString);

          Для выполнения того же вызова на Ассемблере нужно  использо-
     вать инструкции:

          lea   ax,SourceString            ; правый параметр
          push  ax
          lea   ax,DestString              ; левый параметр
          push  ax
          call  _strcpy                    ; скопировать строку
          add   sp,4                       ; отбросить параметры

          При настройке SP после вызова не забывайте очищать  стек  от
     параметров.

          Можно упростить ваш код и сделать его независимым  от языка,
     воспользовавшись расширением команды Турбо Ассемблера CALL:

          call назначение [язык [,аргумент_1] ...]

     где "язык"   -   это   C,  PASCAL,  BASIC,  FORTRAN,  PROLOG  или
     NOLANGUAGE, а "аргумент_n" это любой допустимый аргумент програм-
     мы, который может быть прямо помещен в стек процессора.

          Используя данное средство, можно записать:

          lea   ax,SourceString
          lea   bx,DestString
          call  strcpy c,bx,ax

          Турбо Ассемблер  автоматически вставит команды помещения ар-
     гументов в стек в последовательности, принятой в С++ (сначала AX,
     затем BX),  выполнит  вызов _strcopy (перед именами С++ Турбо Ас-
     семблер автоматически вставляет символ подчеркивания),  и очищает
     стек после вызова.

          Если вы вызываете функцию С++, которая использует соглашения
     Паскаля,  заносите в стек параметры слева направо.  После  вызова
     настраивать указатель стека SP не требуется.

          lea   ax,DestString              ; левый параметр
          push  ax
          lea   ax,SourceString            ; правый параметр
          push  ax
          call  CTRCPY                     ; скопировать строку

          Можно опять упростить ваш код,  воспользовавшись расширением
     команды Турбо Ассемблера CALL:

          lea   bx,DestString              ; самый левый параметр
          lea   ax,SourceString            ; самый правый параметр
          call  strcpy pascal,bx,ax


     Турбо Ассемблер 3.0/tasm/#2-2                             = 114 =

          Турбо Ассемблер автоматически вставит команды помещения  ар-
     гументов в стек в последовательности, принятой в Паскале (сначала
     BX, затем AX), и выполнит вызов STRCPY (преобразуя имя к верхнему
     регистру, как принято в соглашениях Паскаля).

          В последнем случае конечно подразумевается, что вы  переком-
     пилировали  функцию strcpy с параметром -p, так как в стандартной
     библиотечной версии данной функции используются соглашения по вы-
     зову, принятые в С++, а не в Паскале.

          Функции С++  сохраняют следующие регистры (и только их): SI,
     DI,  BP, DS, SS, SP и CS. Регистры AX, BX, CX, DX, ES и флаги мо-
     гут произвольно изменяться.

              Вызов из Турбо Ассемблера функции Borland C++
     ─────────────────────────────────────────────────────────────────

          Одним из случаев,  когда вам может потребоваться вызвать  из
     Турбо Ассемблера функцию Borland C++,  является необходимость вы-
     полнения сложных вычислений,  поскольку вычисления гораздо  проще
     выполнять  на  С++,  чем на Ассемблера.  Особенно это относится к
     случаю смешанных вычислений, где используются и значения с плава-
     ющей точкой и целые числа.  Лучше возложить функции по выполнению
     преобразования типов и реализации арифметики с  плавающей  точкой
     на С++.

          Давайте рассмотрим  пример программы на Ассемблере,  которая
     вызывает функцию Borland C++, чтобы выполнить вычисления с плава-
     ющей точкой.  Фактически в данном примере функция Borland C++ пе-
     редает последовательность целых чисел другой  функции  Турбо  Ас-
     семблера,  которая  суммирует  числа  и  в  свою очередь вызывает
     другую функцию Borland C++ для выполнения вычислений  с плавающей
     точкой (вычисление среднего значения).

          Часть программы   CALCAVG.CPP,    реализованная    на    С++
     (CALCAVG.CPP), выглядит следующим образом:

          #include <stdio.h>
          extern float Average(int far * ValuePtr, int
                                               NumberOfValues);
          #define NUMBER_OF_TEST_VALUES 10
          int TestValues(NUMBER_OF_TEST_VALUES) = {
              1, 2, 3, 4, 5, 6, 7, 8, 9, 10
          };

          main()
          {
                 printf("Среднее арифметическое равно: %f\n",
                        Average(TestValues, NUMBER_OF_TEST_VALUES));
          }
          float IntDivide(int Divedent, int Divisor)
          }
                return( (float) Divident / (float) Divisor );

     Турбо Ассемблер 3.0/tasm/#2-2                             = 115 =

          }

     а часть программы на Ассемблере (AVERAGE.ASM) имеет вид:

          ;
          ; Вызываемая из С++ функция с малой моделью памяти,
          ; которая возвращает среднее арифметическое последова-
          ; тельности целых чисел. Для выполнения завершающего
          ; деления вызывает функцию С++ IntDivide().
          ;
          ; Прототип функции:
          ;          extern float Average(int far * ValuePtr,
          ;                 int NumberOfValues);
          ;
          ; Ввод:
          ;          int far * ValuePtr:      ; массив значений для
          ;                                   ; вычисления среднего
          ;          int NumberOfValues:      ; число значений для
          ;                                   ; вычисления среднего
                         .MODEL   SMALL
                         EXTRN    _IntDivide:PROC
                         .CODE
                         PUBLIC   _Average
          _Average       PROC
                         push  bp
                         mov   bp,sp
                         les   bx,[bp+4]       ; ES:BX указывает на
                                               ; массив значений
                         mov   cx,[bp+8]       ; число значений, для
                                               ; которых нужно
                                               ; вычислить среднее
                         mov   ax,0
          AverageLoop:
                         add   ax,es:[bx]      ; прибавить текущее
                                               ; значение
                         add   ax,2            ; ссылка на следующее
                                               ; значение
                         loop  AverageLoop
                         push  WORD PTR [bp+8] ; получить снова число
                                               ; значений, переданных
                                               ; в функцию IntDivide
                                               ; в правом параметре
                         push  ax              ; передать сумму в
                                               ; левом параметре
                         call  _IntDivide      ; вычислить среднее
                                               ; значение с плавающей
                                               ; точкой
                         add   sp,4            ; отбросить параметры
                         pop   bp
                         ret                   ; среднее значение в
                                               ; регистре вершины
                                               ; стека сопроцессора
                                               ; 8087

     Турбо Ассемблер 3.0/tasm/#2-2                             = 116 =

          _Average       ENDP
                         END

          Основная функция (main) на языке С++ передает  указатель  на
     массив  целых  чисел  TestValues и длину массива в функцию на Ас-
     семблере Average.  Эта функция вычисляет сумму целых чисел, а за-
     тем  передает эту сумму и число значений в функцию С++ IntDivide.
     Функция IntDivide приводит сумму и число значений к типу с плава-
     ющей точкой и вычисляет среднее значение (делая это с помощью од-
     ной строки на С++,  в то время как на Ассемблере для этого потре-
     бовалось бы несколько строк).  Функция IntDivide возвращает сред-
     нее значение (Average) в регистре вершины стека сопроцессора 8087
     и передает управление обратно основной функции.

          Программы CALCAVG.CPP  и  AVERAGE.ASM можно скомпилировать и
     скомпоновать в выполняемую программу CALCAVG.EXE с помощью коман-
     ды:

          bcc calcavg.cpp average.asm

          Отметим, что функция Average будет работать как с малой, так
     и  с большой моделью данных без необходимости изменения ее исход-
     ного кода, так как во всех моделях передается указатель  дальнего
     типа. Для поддержки больших моделей кода (сверхбольшой, большой и
     средней) пришлось бы только  изменить  соответствующую  директиву
     .MODEL.

          Пользуясь преимуществами расширений,  обеспечивающих незави-
     симость Турбо Ассемблера от языка, ассемблерный код из предыдуще-
     го примера можно записать более сжато (CONSISE.ASM):

             .MODEL  small,C
             EXTRN   C IntDivide:PROC
             .CODE
             PUBLIC  C Average
     Average        PROC C ValuePtr:DWORD, NumberOfValues:WORD
             les     bx,ValuePtr
             mov     cx,NumberOfValues
             mov     ax,0
     AverageLoop:
             add     ax,es:[bx]
             add     bx,2        ;установить указатель
                                 ;на следующее значение
             loop    AverageLoop
             call    _IntDivide C,ax,NumberOfValues
             ret
     Average        ENDP
             END




     Турбо Ассемблер 3.0/tasm/#2-2                             = 117 =

         Глава 19. Интерфейс Турбо Ассемблера с Турбо Паскалем
     ─────────────────────────────────────────────────────────────────

          В  Турбо  Ассемблере  предусмотрены  расширенные  и   мощные
     средства,  позволяющие  вам добавлять код Ассемблера к программам
     Турбо Паскаля. В данной главе мы подробно расскажем  вам  о  том,
     что  нужно  знать,  чтобы полностью использовать данные средства,
     приведем множество примеров и дадим некоторую более глубокую  ин-
     формацию.

           Большинство программ,  которые вы захотите написать,  можно
     реализовать целиком на Турбо Паскале.  В отличие  от  большинства
     других  компиляторов  Паскаля,  Турбо Паскаль позволяет вам с по-
     мощью массивов Port[], Mem[], MemW[] и MemL[] непосредственно об-
     ращаться   ко  всем  ресурсам  компьютера,  а с помощью  процедур
     Intr() и MsDos() вы можете обращаться к базовой системе ввода-вы-
     вода (BIOS) и операционной системе.

          Для чего же тогда может потребоваться использовать совместно
     с  Турбо  Паскалем  Ассемблер? Для этого существуют две вероятные
     причины: выполнение некоторого небольшого числа операций, которые
     непосредственно в Турбо Паскале недоступны, и использование преи-
     муществ высокой скорости работы,  которые  дает  Ассемблер.  (Сам
     Турбо  Паскаль  работает достаточно быстро, потому что он написан
     на языке Ассемблера.) В данной главе мы покажем  вам,  как  можно
     использовать в Турбо Паскале преимущества Ассемблера.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 118 =

            Совместное с Турбо Паскалем использование данных
     ─────────────────────────────────────────────────────────────────

          Далее следует содержимое главы.

             Директива компилятора $L и внешние подпрограммы
     ─────────────────────────────────────────────────────────────────

          Два ключевых момента при использовании  Турбо  Ассемблера  с
     Турбо Паскалем - это директива компилятора (Турбо Паскаля) {$L} и
     описание   внешней   (external)   подпрограммы.   Директива   {$L
     MYFILE.OBJ}  приводит к тому, что Турбо Паскаль будет искать файл
     объектный MYFILE.OBJ (файл в стандартном пригодном для компоновки
     формате MS-DOS) и компоновать его с вашей программой Турбо Паска-
     ля.  Если у файла в директиве {$L} расширение не указывается,  то
     подразумевается расширение .OBJ.

          Каждая процедура или функция Турбо  Ассемблера,  которую  вы
     хотите сделать доступной в программе Турбо Паскаля, должна объяв-
     ляться, как идентификатор PUBLIC, и ей должно  соответствовать  в
     программе описание external (внешняя). Синтаксис описания внешней
     процедуры или функции в  Турбо  Паскале  аналогичен  опережающему
     (forward) описанию:

          procedure AsmProc(a : integer; b : real); external;

          function AsmFunc(c : word; d : byte); external;

          Эти описания должны соответствовать  следующим  описаниям  в
     программе Турбо Ассемблера:

          CODE        SEGMENT BYTE PUBLIC
          AsmProc     PROC NEAR
                      PUBLIC AsmProc
                      .
                      .
                      .
          AsmProc     ENDP
          AsmFunc     PROC FAR
                      PUBLIC Bar
                      .
                      .
                      .
          AsmFunc     ENDP
          CODE        ENDS

          Описание внешней (external) процедуры Турбо  Паскаля  должно
     находиться на самом внешнем уровне программы или модуля,  то есть
     оно не должно быть вложенным по отношению к другому описанию про-
     цедуры или функции.  Попытка описать процедуру или функцию на лю-
     бом другом уровне приведет к ошибке этапа компиляции.

          Турбо Паскаль не делает проверку, чтобы убедиться,  что  все

     Турбо Ассемблер 3.0/tasm/#2-2                             = 119 =

     процедуры,  описанные  с  атрибутами  NEAR или FAR, соответствуют
     ближним или дальним подпрограммам в программе Турбо Паскаля. Фак-
     тически,  он  даже  не  проверяет,  являются  ли  метки AsmProc и
     AsmFunc именами процедур. Поэтому  вы  должны  обеспечить,  чтобы
     описания в Ассемблере и Паскале были правильными.

                            Директива PUBLIC
     ─────────────────────────────────────────────────────────────────

          В Турбо Паскале доступны только те метки Ассемблера, которые
     объявлены   в  модуле  на  языке  Ассемблера,  как  общедоступные
     (PUBLIC). Метки представляют собой единственные объекты,  которые
     могут  передаваться  из  языка  Ассемблера в Турбо Паскаль. Более
     того, каждой общедоступной метке должно  соответствовать описание
     процедуры или функции в программе Турбо Паскаля, иначе компилятор
     выдаст сообщение об ошибке. Причем не требуется,  чтобы  общедос-
     тупная метка была частью описания PROC. Что касается Турбо Паска-
     ля, то для него описания:

          AsmLabel     PROC  FAR
                       PUBLIC Bar
     и

          AsmLabel:
                       PUBLIC Bar

     эквивалентны.

          Вы можете определять такие идентификаторы как  PUBLIC только
     в сегменте CODE. Турбо Паскаль не разрешает определения идентифи-
     каторов PUBLIC в сегменте данных,  поэтому создаваемые  вами  ас-
     семблерные  модули  для  компоновки с программой на Турбо Паскале
     также не должны иметь в сегменте данных.

                             Директива EXTRN
     ─────────────────────────────────────────────────────────────────

          Модуль Турбо Ассемблера может обращаться к любой  процедуре,
     функции, переменной или типизованной константе Турбо Паскаля, ко-
     торая описывается на самом внешнем уровне программы или модуля, с
     которым  она компонуется. (Заметим, что это включает в себя пере-
     менные, описанные после директивы компилятора {$L} и внешние опи-
     сания,  связанные  с  данным  модулем.) Метки и обычные константы
     Турбо Паскаля языку Ассемблера недоступны.

                Примечание: Эти включает в себя  переменные, указанные
           после  директивы компилятора $L и описаниях external,  свя-
           занных с данным модулем.

          Предположим, в вашем  программе  Турбо  Паскаля  описываются
     следующие глобальные переменные:

           var

     Турбо Ассемблер 3.0/tasm/#2-2                             = 120 =

               a : byte;
               b : word;
               c : shortint;
               d : integer;
               e : real;
               f : single;
               g : double;
               h : extended;
               i : comp;
               j : pointer;

          В программе на языке Ассемблера вы можете получить доступ ко
     всем этим переменным с помощью описаний EXTRN:

          EXTRN A : BYTE        ; 1 байт
          EXTRN B : WORD        ; 2 байта
          EXTRN C : BYTE        ; в Ассемблере значения со знаком и
                                ; без знака интерпретируются одинаково
          EXTRN D : WORD        ; то же самое
          EXTRN E : FWORD       ; 6-байтовое действительное значение
                                ; (обрабатывается программно)
          EXTRN F : DWORD       ; 4-байтовое значение с плавающей
                                ; точкой в формате IEEE
          EXTRN G : QWORD       ; 8-байтовое значение с плавающей
                                ; точкой (двойной точности) в
                                ; формате IEEE
          EXTRN H : TBYTE       ; 10-байтовое значение с плавающей
                                ; точкой во временном формате
          EXTRN I : QWORD       ; 8-байтовое целое со знаком в
                                ; формате IEEE (сопроцессор 8087)
          EXTRN J : DWORD       ; указатель Турбо Паскаля

          Аналогичным образом можно получить  доступ  к  процедурам  и
     функциям  Турбо Паскаля, включая библиотечные. Предположим, у вас
     имеется модуль Турбо Паскаля, который выглядит следующим образом:

          unit Sample;
          { Пример модуля, в котором определяется нескольку процедур
            Паскаля, вызываемых из процедуры на языке Ассемблера }

          interface

          procedure TestSample;

          procedure PublicProc;  { для обращения извне должна
                                   быть дальнего типа }
          inplementation

          var
            A : word;

          procedure AsmProc; external;
          {$L ASMPROC.OBJ}

     Турбо Ассемблер 3.0/tasm/#2-2                             = 121 =


          procedure PublicProc;
             begin { PublicProc }
               Writeln('В PublicProc');
             end   { PublicProc }

          procedure NearProc;   { должна быть ближнего типа }
             begin { NearProc }
               Writeln('B NearProc');
             end;  { NearProc }

          {$F+}
          procedure FarProc     { должна иметь дальний тип согласно
                                  директиве компилятора }
             begin { FarProc }
               Writeln('B FarProc');
             end   { FarProc }

          {$F-}

          procedure TestSample;
            begin { TestSample }
              Writeln('B TestSample');
              A := 10;
              Writeln('Значение A перед ASMPROC = ',A);
              AsmProc;
              Writeln('Значение A после ASMPROC = ',A);
            end   { TestSample };

          end.

          Процедура AsmProc вызывает  процедуры  PublicProc,  NearProc
     или FarProc, используя директиву EXTRN следующим образом:

       DATA   SEGMENT WORD PUBLIC
              ASSUME  DS:DATA
              EXTRN   A:WORD                ; переменная из модуля
       DATA   ENDS

       CODE   SEGMENT BYTE PUBLIC
              ASSUME  CS:CODE
              EXTRN   PublicProc : FAR      ; дальняя процедура
                                            ; (экспортируется модулем)
              EXTRN   NearProc   : NEAR     ; ближняя процедура
                                            ; (локальная для модуля)
              EXTRN   FarProc    : FAR      ; дальняя процедура
                                            ; (локальна, но задана,
                                            ; как дальняя)
       AsmProc        PROC NEAR
                      PUBLIC AsmProc
                      CALL   FAR PTR PublicProc
                      CALL   NearProc
                      CALL   FAR PTR FarProc

     Турбо Ассемблер 3.0/tasm/#2-2                             = 122 =

                      mov    cx,ds:A        ; взять переменную из
                                            ; модуля
                      sub    cx,2           ; изменить ее
                      mov    ds:A,cx        ; записать ее обратно
                      RET
       AsmProc        ENDP
       CODE           ENDS
                      END

          Основная программа, которая проверяет эту программу  на  Ас-
     семблере и модуль Паскаля, выглядит следующим образом:

           program TSample;
           uses Sample;
           begin
               TestSample;
           end.

          Чтобы сформировать пример программы с  помощью  компилятора,
     работающего  в режиме командной строки, и Ассемблера, используйте
     следующие команды (или командный файл):

          TASM ASMPROC
          TPC /B SAMPLE
          TSAMPLE

          Так как внешняя подпрограмма должна объявляться в  программе
     Турбо  Паскаля на самом внешнем уровне процедур, вы не можете для
     доступа к объектам, являющимся локальными по отношению к процеду-
     рам  или функциям использовать описания EXTRN. Однако, ваша прог-
     рамма на  Турбо  Ассемблере при вызове из программы Турбо Паскаля
     может получить эти объекты, как значения параметров-переменных.

            Ограничения при использовании объектов типа EXTRN
     ─────────────────────────────────────────────────────────────────

          Синтаксис уточненного идентификатора Турбо Паскаля,  при ко-
     тором  для  доступа  к объекту в заданном модуле используется имя
     модуля и точка, несовместим с синтаксическими правилами Турбо Ас-
     семблера и будет, таким образом, отвергнут. Описание:

             EXTRN SYSTEM.Assing : FAR

     приведет к тому, что Турбо Ассемблер выдаст сообщение об ошибке.

          Имеется также два других ограничения на использование в Тур-
     бо  Паскале  объектов  EXTRN.  Первое из них состоит в том, что в
     ссылках на процедуру или функцию не могут  выполняться  арифмети-
     ческие операции с адресами. Таким образом, если вы объявите:

             EXTRN PublicProc : FAR

     то не сможете записать оператор вида:

     Турбо Ассемблер 3.0/tasm/#2-2                             = 123 =


             call PublicProc + 42

          Второе ограничение относится к тому, что  компоновщик  Турбо
     Паскаля  не  будет распознавать операции, которые разделяют слова
     на байты, поэтому вы не можете применять такие операции к  объек-
     там EXTRN. Например, если вы объявите:

             EXTRN i : WORD

     то не сможете использовать в модуле  Турбо  Ассемблера  выражения
     LOW i или HIGH i.

                  Использование корректировок сегментов
     ─────────────────────────────────────────────────────────────────

          Турбо Паскаль генерирует файлы .EXE,  которые  могут  загру-
     жаться  в  память компьютера РС по любому доступному адресу. Пос-
     кольку в программе заранее неизвестно, куда будет загружен данный
     сегмент  программы, компоновщик указывает загрузчику DOS.EXE, что
     нужно при загрузке скорректировать в программе все ссылки на сег-
     менты. После выполнения этих корректировок все ссылки на сегменты
     (такие, как CODE или DATA) будут содержать корректные значения.

          Ваша программа на Турбо Ассемблере  может  использовать  это
     средство  для  получения  адресов  объектов  во время выполнения.
     Предположим, например, что в вашей программе  требуется  изменить
     значение  регистра DS, но вы не хотите сохранять в цикле исходное
     содержимое стека или перемещать эти  значения  во  временную  об-
     ласть.  Вместо этого вы можете использовать операцию Турбо Ассем-
     блера SEG:

          .
          .
          .
          mov   ax,SEG DATA          ; получить фактический
                                     ; адрес глобального значения
                                     ; DS Турбо Паскаля
          mov   ds,ax                ; поместить его в DS для
                                     ; использования Турбо
                                     ; Паскалем
          .
          .
          .

          Когда ваша программа будет загружаться, DOS поместит коррек-
     тное значение SEG DATA прямо в поле промежуточного операнда инст-
     рукции MOV. Это наиболее быстрый  путь  перезагрузки  сегментного
     регистра.

          Данный метод нужно также использовать, чтобы программы  обс-
     луживания  прерываний  сохраняли информацию в глобальном сегменте
     данных Турбо Паскаля. Регистр DS не обязательно во время прерыва-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 124 =

     ния содержит значение DS Турбо Паскаля,  но для получения доступа
     к переменным и типизованным константам Турбо  Паскаля  можно  ис-
     пользовать указанную выше последовательность.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 125 =

                     Устранение неиспользуемого кода
     ─────────────────────────────────────────────────────────────────

          В Турбо Паскале имеются средства, обеспечивающие  устранение
     неиспользуемого кода. Это означает, что в полученный в результате
     файл .EXE не будет включаться код процедур и функций, который ни-
     когда не выполняется. Но поскольку нет полной информации о содер-
     жимом модулей Турбо Ассемблера, Турбо Паскаль может выполнять для
     них только ограниченную оптимизацию.

          Турбо Паскаль будет устранять код модуля .OBJ в том и только
     в  том случае, если к любой доступной процедуре или функции этого
     модуля нет обращения. Если же на какую либо процедуру или функцию
     имеется ссылка, то весь этот модуль используется.

          Чтобы добиться большей эффективности использования  средства
     Турбо Паскаля по устранению неиспользуемого кода, неплохо было бы
     разбить программу на Ассемблере на небольшие модули, которые  со-
     держали  бы  только несколько процедур или функций. Это позволило
     бы Турбо Паскалю, если он может это сделать, уменьшить объем  ва-
     шей конечной программы.

             Соглашения Турбо Паскаля по передаче параметров
     ─────────────────────────────────────────────────────────────────

          Турбо Паскаль использует для передачи параметров  стек  цен-
     трального  процессора (или, в случае передачи значений параметров
     с одинарной, двойной, расширенной точностью  или  сложного  типа,
     стек  арифметического сопроцессора). Параметры всегда вычисляются
     и заносятся в стек в том порядке, в  котором  они  указываются  в
     описании  подпрограммы,  слева направо. В данном разделе мы пояс-
     ним, как эти параметры представляются.

                           Параметры-значения
     ─────────────────────────────────────────────────────────────────

          Параметр-значение - это параметр, значение которого не может
     изменяться  подпрограммой,  в которую он передается. В отличие от
     многих компиляторов, Турбо Паскаль не выполняет слепого копирова-
     ния  в стек каждого параметра-значения: как мы далее поясним, ис-
     пользуемый метод зависит от типа.

                             Скалярные типы
     ─────────────────────────────────────────────────────────────────

          Параметры-значения  всех  скалярных  типов  (boolean,  char,
     shortint,  byte, integer, word, longint, отрезки типов и перечис-
     лимые типы) передаются как значения через стек  процессора.  Если
     размер объекта составляет 1 байт, он заносится в стек, как полное
     16-битовое слово,  однако более значащий (старший) байт слова  не
     содержит полезной информации. Если размер объекта равен двум бай-
     там,  то он просто заносится в стек "как есть". Если объект имеет
     размер  4  байта  (длинное целое),  он заносится в стек,  как два

     Турбо Ассемблер 3.0/tasm/#2-2                             = 126 =

     16-битовых слова.  В соответствии со стандартом процессоров серии
     8088  наиболее значащее (старшее) слово заносится в стек первым и
     занимает в стеке старшие адреса.

                          Вещественные значения
     ─────────────────────────────────────────────────────────────────

          Параметры-значения вещественного типа (real) передаются, как
     6 байт в стеке (в Турбо Паскале это тип представляет собой 6-бай-
     товый программно-эмулируемый тип с плавающей точкой).  Это единс-
     твенный тип,  превышающий 4 байта, который может передаваться че-
     рез стек.

      Типы Single, Double, Extended и Comp и типы сопроцессора 8087
     ─────────────────────────────────────────────────────────────────

          Турбо Паскаль  использует  те же соглашения о передаче пера-
     метров для 8087,  что и семейство компиляторов Borland C++. Пара-
     метры  передаются  через  главный  стек  центрального процессора,
     вместе с остальными параметрами.

                                Указатели
     ─────────────────────────────────────────────────────────────────

          Значения параметров для всех типов указателей заносятся  не-
     посредственно в стек, как указатели дальнего типа: сначала слово,
     содержащее сегмент, затем другое слово, содержащее смещение. Сег-
     мент занимает старший адрес,  в соответствии с соглашениями фирмы
     Intel.  Для извлечения параметра-указателя в программе Турбо  Ас-
     семблера можно использовать инструкции LDS или LES.

                                 Строки
     ─────────────────────────────────────────────────────────────────

          Строковые параметры,  независимо от размера,  обычно никогда
     не  заносятся  в стек.  Вместо этого Турбо Паскаль заносит в стек
     указатель (дальнего типа) на строку.  Вызываемая подпрограмма  не
     должна изменять строку,  на которую ссылается указатель. Если это
     необходимо,  подпрограмма может создать и работать с копией стро-
     ки.

          Единственное исключение из этого правила - это случай, когда
     подпрограмма в перекрываемом (оверлейном) модуле A  передает  как
     параметр-значение  строковую константу подпрограмме в перекрывае-
     мом модуле B.  В этом контексте перекрываемый модуль означает лю-
     бой модуль,  скомпилированный  с  директивой  {$O+}  (допускаются
     оверлеи). В этом случае перед тем, как будет сделан вызов и адрес
     стека  будет передан программе в модуле B,  в стеке для строковой
     константы резервируется временная память.

                            Записи и массивы
     ─────────────────────────────────────────────────────────────────
          Записи и массивы,  занимающие ровно 1, 2 или 4 байта, дубли-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 127 =

     руются непосредственно в стек и передаются,  как параметры-значе-
     ния. Если массив или запись имеет какой-либо другой размер (вклю-
     чая 3 байта),  то в стек заносится указатель на этот  массив  или
     запись.  В  этом  случае,  если  подпрограмма  модифицирует такую
     структуру, то она должна создать ее локальную копию.

                                Множества
     ─────────────────────────────────────────────────────────────────

          Множества, как и строки,  обычно никогда не заносятся непос-
     редственно в стек.  Вместо этого в стек  заносится  указатель  на
     множество.  Первый  бит младшего байта множества всегда соответс-
     твует элементу базового типа (или порождающего типа) с порядковым
     значением 0.

          Единственное исключение из этого правила - это случай, когда
     подпрограмма в перекрываемом (оверлейном) модуле A  передает  как
     параметр-значение константу-множество подпрограмме  в  оверлейном
     модуле  B.  В  этом контексте перекрываемый модуль означает любой
     модуль, компилированный с директивой {$O+} (допускаются оверлеи).
     В этом случае перед тем, как будет сделан вызов и адрес стека бу-
     дет передан программе в модуле B, в стеке для множества-константы
     резервируется  временная память.

                          Параметры-переменные
     ─────────────────────────────────────────────────────────────────

          Все параметры-переменные  (var) передаются точно также:  как
     указатель дальнего типа на их действительные адреса в памяти.

                            Обеспечение стека
     ─────────────────────────────────────────────────────────────────

          Турбо Паскаль  ожидает,  что  перед  возвратом управления из
     подпрограммы все параметры в стеке центрального  процессора будут
     удалены.

          Есть два способа настройки стека. Вы можете использовать ин-
     струкцию RET N (где N - это число байт передаваемых,  то есть за-
     несенных в стек, параметров), либо сохранить адрес возврата в ре-
     гистрах  (или  в памяти) и извлечь параметры из стека поочередно.
     Такую технику извлечения полезно использовать для  оптимизации по
     скорости  при  работе с процессором 8086 или 8088 (самые "медлен-
     ные" процессоры серии), когда на адресацию типа "база плюс смеще-
     ние"  затрачивается минимум 8 циклов за обращение.  Это позволяет
     также сэкономить место,  так как инструкция POP  занимает  только
     один байт.

                Примечание: Если вы используете директивы .MODEL, PROC
           и ARG, то Ассемблер автоматически добавляет во все инструк-
           ции RET число байт извлекаемых параметров.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 128 =

                           Доступ к параметрам
     ─────────────────────────────────────────────────────────────────

          Когда получает управление ваша подпрограмма на Турбо Ассемб-
     лере, вершина стека будет содержать адрес возврата (два или четы-
     ре слова, в зависимости от того, является ли подпрограмма ближней
     или дальней), а далее будут находится передаваемые параметры.

                Примечание: При вычислении  адресов  параметров  нужно
           принимать  во внимание регистры,  такие как BP,  содержимое
           которых также может быть занесено в стек.)

          Существует три основных метода доступа к параметрам, переда-
     ваемых Турбо Паскалем вашей подпрограмме на Турбо  Ассемблере. Вы
     можете:

          - использовать для адресации к стеку регистр BP;

          - для получения параметров использовать другой  базовый  или
            индексный регистр;

          - извлечь из стека адрес возврата, а затем параметры.

          Первый и второй методы более сложны, и мы расскажем о них  в
     следующих  двух разделах. Третий метод предусматривает извлечение
     из стека и сохранение адреса возврата, а затем  извлечения  пара-
     метров  и  записи их в регистры. Лучше всего этот метод работает,
     когда ваша подпрограмма не требует пространства для локальных пе-
     ременных.

             Использование для адресации к стеку регистра BP
     ─────────────────────────────────────────────────────────────────

          Первый и наиболее часто используемый метод доступа  к  пара-
     метрам, передаваемым из Турбо Паскаля в Турбо Ассемблер, заключа-
     ется в том, чтобы использовать для адресации к стеку регистр  BP.
     Например:

     CODE       SEGMENT
                ASSUME  CS:CODE
     MyProc     PROC    FAR         ; procedure MyProc(i,j : integer);
                PUBLIC  MyProc
     j          EQU WORD PTR [bp+6] ; j находится над сохраненным BP
                                    ; и адресом возврата
     i          EQU WORD PTR [bp+8] ; i располагается над j
                push  bp            ; нужно сохранить BP вызывающей
                                    ; программы
                mov   bp,sp         ; BP теперь указывает на вершину
                                    ; стека
                mov   ax,i          ; адресуемся к i через BP
                .
                .
                .

     Турбо Ассемблер 3.0/tasm/#2-2                             = 129 =


          При вычислении смешений в стеке параметров, к которым мы об-
     ращаемся  таким  образом, нужно помнить, что 2 байта используются
     для сохраненного регистра BP.

          Обратите внимание на использование в данном примере присваи-
     ваний. Они позволяют сделать программу более понятной. У них есть
     только один недостаток: поскольку для выполнения такого рода при-
     сваиваний можно  использовать  только  директиву EQU (а не =),  в
     данной исходном файле Турбо Ассемблера вы не сможете  переопреде-
     лить идентификаторы i и j. Один из способов обойти это заключает-
     ся в том, чтобы использовать более описательные имена параметров,
     чтобы они не повторялись,  либо можно ассемблировать каждую подп-
     рограмму Ассемблера отдельно.

                              Директива ARG
     ─────────────────────────────────────────────────────────────────

          Хотя можно обращаться к параметрам через регистр  BP,  Турбо
     Ассемблер предусматривает альтернативу вычислению смещений в сте-
     ке и выполнению текстовых присваиваний. Это  директива  ARG.  При
     использовании  ее в процедуре директива ARG автоматически опреде-
     ляет смещения параметров относительно регистра BP.  Она вычисляет
     также размер блока параметров и использует его в  инструкции RET.
     Поскольку идентификаторы, создаваемые по директиве ARG, определе-
     ны только в соответствующей процедуре,  в  каждой  процедуре  или
     функции  вам  не требуется использовать уникальные имена парамет-
     ров.

          Покажем, как будет  выглядеть  пример  предыдущего  раздела,
     если переписать его, используя директиву ARG:

     CODE       SEGMENT
                ASSUME  CS:CODE
     MyProc     PROC    FAR         ; procedure MyProc(i,j : integer);
                                    ; external;
                PUBLIC  MyProc
                ARG j : WORD, i : WORD = RetBytes
                push  bp            ; нужно сохранить BP вызывающей
                                    ; программы
                mov   bp,sp         ; BP теперь указывает на вершину
                                    ; стека
                mov   ax,i          ; адресуемся к i через BP
                .
                .
                .

          Директива ARG Турбо Ассемблера создает локальные идентифика-
     торы для параметров i и j. На время выполнения процедуры строка:

             ARG j : WORD, i : WORD = RetBytes

     автоматически приравнивает идентификатор i  к  [WORD  PTR  BP+6],

     Турбо Ассемблер 3.0/tasm/#2-2                             = 130 =

     идентификатор  j  к [WORD PTR BP+8], а идентификатор RetBytes - к
     числу 4 (размеру в байтах блока параметров). В значениях учитыва-
     ется  и  занесенное в стек значение BP, и размер адреса возврата:
     если бы процедура MyProc имела ближний тип, то i было бы  прирав-
     нено  к  значению  [BP+4], j - к [BP+6], а RetBytes также было бы
     равно 4 (в любом случае процедура MyProc может завершить выполне-
     ние с помощью инструкции RET RetBytes).

          При использовании директивы ARG нужно помнить, что параметры
     должны  перечисляться в обратном порядке. Последний параметр про-
     цедуры или функции Турбо Паскаля нужно размещать в директиве  ARG
     первым и наоборот.

          Относительно использования директивы ARG  с  Турбо  Паскалем
     можно сделать еще одно замечание. В  отличие  от  других  языков,
     Турбо Паскаль всегда заносит в стек параметр-значение  размером в
     байт,  как 16-битовое слово. При этом сообщить Турбо Ассемблеру о
     дополнительном байте должны вы. Предположим, например, что вы на-
     писали функцию, описание которой в Паскале выглядит следующим об-
     разом:

          function MyProc(i, j : char) : string; external;

          Директива ARG для этой функции должна была бы выглядеть так:

          ARG j: BYTE: 2, i:BYTE: 2 = RetBytes  RETURN  result: DWORD

          Здесь 2 после каждого аргумента необходимо указывать для то-
     го, чтобы сообщить Ассемблеру, что каждый идентификатор заносится
     в стек,  как массив из 2 байт (где, в данном случае, младший байт
     каждой пары содержит полезную информацию).

          В функции, возвращающей строковое значение (как данная функ-
     ция),  параметр  RETURNS в директиве ARG позволяет вам определить
     переменную, приравненную к тому месту в стеке, которое  указывает
     на временный результат функции. Переменная в RETURNS на размер (в
     байтах) блока параметров.

                    Турбо Паскаль и директива .MODEL
     ─────────────────────────────────────────────────────────────────

          Директива .MODEL с параметром TPASCAL задает упрощенную сег-
     ментацию, модель памяти и языковую поддержку. Обычно используется
     большая модель памяти (large) Ранее мы уже видели, что нужно сде-
     лать в программах Ассемблера,  чтобы можно было использовать про-
     цедуры и функции Паскаля. Преобразуем пример, используя в нем ди-
     рективы .MODEL и PROC:

                    .MODEL   large, PASCAL
                    .CODE
     MyProc         PROC     FAR i:BYTE,j:BYTE result:DWORD
                    PUBLIC   MyProc
                    mov      ax,i

     Турбо Ассемблер 3.0/tasm/#2-2                             = 131 =

                    .
                    .
                    .
                    ret

          Заметим, что теперь не нужно задавать параметры  в  обратном
     порядке.  Не требуется также масса других операторов. Использова-
     ние в директиве .MODEL ключевого слова  PASCAL задает использова-
     ние  соглашений  Паскаля,  определяет  имена сегментов, выполняет
     инструкции PUSH BP и MOV BP,SP и задает также возврат  с  помощью
     инструкций POP BP и RETn (где n - число байт параметров).

         Использование другого базового или индексного регистра
     ─────────────────────────────────────────────────────────────────

          Второй способ доступа к параметрам состоит  в  использовании
     для получения этих параметров другого базового или индексного ре-
     гистра (BX, SI или DI). Нужно однако помнить,  что  по  умолчанию
     сегментным  регистром для них является  регистр DS, а не SS. Поэ-
     тому для их использования вам придется применять префикс  переоп-
     ределения сегмента.

          Приведем пример использования для получения  параметров  ре-
     гистра BX:

     CODE          SEGMENT
                   ASSUME  CS:CODE
     MyProc        PROC FAR         ; procedure MyProc(i,j : integer);
                   PUBLIC MyProc
     j          EQU WORD PTR SS:[BX+4] ; j находится над сохраненным
                                    ; BP и адресом возврата
     i          EQU WORD PTR SS:[bp+8] ; i располагается над j
                mov   bx,sp         ; BX теперь указывает на вершину
                                    ; стека
                mov   ax,i          ; адресуемся к i через BX
                .
                .
                .

          В тех программах, где нет большого числа ссылок на  парамет-
     ры, такой метод позволяет сэкономить время и место. Почему? Пото-
     му, что в отличие от BP,  регистр BX не требуется восстанавливать
     в конце программы.

                   Результаты функции в Турбо Паскале
     ─────────────────────────────────────────────────────────────────

          В зависимости от типа результата функции Турбо Паскаля возв-
     ращают свои результаты различными способами.

                    Результаты функции скалярного типа

          Результаты функции скалярных типов возвращаются в  регистрах

     Турбо Ассемблер 3.0/tasm/#2-2                             = 132 =

     центрального  процессора  (ЦП).  Байтовые значения возвращаются в
     регистре AL, значения  размером  в  2  байта  -  в  регистре  AX,
     4-байтовые значения - в паре регистров DX:AX (старшее слово нахо-
     дится в регистре DX).

                   Результаты функции вещественного типа

          Результаты используемого в Турбо Паскале  6-байтового  прог-
     раммно  эмулируемого  вещественного  типа возвращаются в трех ре-
     гистрах ЦП. Наиболее значащее (старшее) слово возвращается в  DX,
     среднее - в BX, а наименее значащее - в AX.

                 Результаты функции типов сопроцессора 8087

          Результаты типов, использующихся сопроцессором 8087, возвра-
     щаются в регистре вершины стека ST(0) (или просто ST).

                    Результаты функции строкового типа

          Результаты строкового типа возвращаются во временной рабочей
     области, выделяемой Турбо Паскалем перед вызовом. Указатель даль-
     него типа на эту область заносится в стек перед занесением перво-
     го  параметра.  Заметим,  что  этот  указатель не является частью
     списка параметров.

                Примечание: Не удаляйте из стека полученный в  резуль-
           тате  указатель,  так  как Турбо Паскаль ожидает, что после
           вызова он будет доступен.

                     Результаты функции типа указатель

          Результаты указатель возвращаются  в  паре  регистров  DX:AX
     (сегмент:смещение).

               Выделение пространства для локальных данных
     ─────────────────────────────────────────────────────────────────

          Ваши программы, написанные на Турбо Ассемблере, могут  выде-
     лять  пространство для своих собственных переменных, как постоян-
     ных (статических), то есть сохраняющихся в промежутке между вызо-
     вами,  так и для временных (которые после вызова будут потеряны).
     Оба этих случая обсуждаются в следующих разделах.

                      Выделение статической памяти
     ─────────────────────────────────────────────────────────────────

          Турбо Паскаль позволяет в программах Турбо Ассемблера резер-
     вировать пространство для статических переменных в сегментах гло-
     бальных данных (DATA или DSEG). Чтобы выделить это  пространство,
     можно просто использовать такие директивы, как DB, DW и т.д. Нап-
     ример:

          DATA        SEGMENT PUBLIC

     Турбо Ассемблер 3.0/tasm/#2-2                             = 133 =

          MyInt       DW      ?        ; зарезервировать слово
          MyByte      DB      ?        ; зарезервировать байт
            .
            .
            .
          DATA        ENDS

          Переменных, выделяемых Турбо Ассемблером в сегменте глобаль-
     ных данных, касаются два важных ограничения. Во-первых, эти пере-
     менными являются "частными", они недоступны программе Турбо  Пас-
     каля (хотя вы можете передавать указатели на них). Во-вторых, они
     не могут быть предварительно инициализированы,  как  типизованные
     константы. Оператор:

           MyInt       DW      42        ; это не инициализирует
                                         ; MyInt значением 42

     не вызовет ошибки при компоновке модуля с программой Турбо Паска-
     ля, однако MyInt при выполнении программы не будет иметь значение
     42.

          Эти ограничения можно обойти, описав переменные или  типизо-
     ванные  константы  Турбо  Паскаля  с помощью директивы EXTRN, что
     сделает их доступными Турбо Ассемблеру.

                       Выделение временной памяти
     ─────────────────────────────────────────────────────────────────

          В ваших программах на Турбо  Паскале  можно  выделять  также
     временную память (локальные переменные) в стеке на время выполне-
     ния каждого вызова. Перед возвратом управления эта память  должна
     быть освобождена, а значение регистра BP восстановлено. В следую-
     щем примере процедура MyProc резервирует  пространство  для  двух
     целых переменных a и b:

     CODE          SEGMENT
                   ASSUME  CS:CODE
     MyProc        PROC    FAR       ; procedure MyProc(i : integer);
                   PUBLIC  MyProc
                   LOCAL a : WORD, b : WORD = LocalSpace ; a в [bp-2]
                                     ; b - в [bp-4]
     i             equ   word ptr [bp+6] ; параметр i находится над
                                     ; сохраненным BP и адресом
                                     ; возврата
                   push  bp          ; нужно сохранить BP вызывающей
                                     ; программы
                   mov   bp,sp       ; теперь BP указывает на
                                     ; вершину стека
                   sub   sp,LocalSpace ; зарезервировать пространст-
                                     ; во для двух слов
                   mov   ax,42       ; загрузить в AX начальное
                                     ; значение A
                   mov   a,ax        ; и в A

     Турбо Ассемблер 3.0/tasm/#2-2                             = 134 =

                   xor   ax,ax       ; очистить регистр AX
                   mov   b,ax        ; инициализировать B нулем
                   mov   b,ax        ; выполнить нужные действия
                   .
                   .
                   .
                   mov   sp,bp       ; восстановить исходное
                                     ; значение SP
                   mov   bp          ; восстановить исходное
                                     ; значение регистра BP
                   ret   2
     MyProc        ENDP
     CODE          ENDS
                   END

                Примечание: Директива Турбо Ассемблера LOCAL использу-
           ется для создания идентификаторов и выделения  пространства
           для локальных переменных.

          Оператор:

             LOCAL a : WORD, b : WORD = LocalSpace

     на время выполнения процедуры присваивает идентификатору a значе-
     ние  [BP-2], идентификатору b - значение [BP-4], а идентификатору
     LocalSpace - число 4 (размер области локальных переменных).  Пос-
     кольку  нет соответствующего оператора для создания идентификато-
     ров, ссылающихся на параметры, вы должны использовать  присваива-
     ние i значения [BP+6].

          Более разумный  способ  инициализации  локальных  переменных
     заключается  в  том, чтобы вместо уменьшения SP занести в стек их
     значения. Таким образом, вы  должны  заменить  SUB  SP,LocalSpace
     инструкциями:

          mov   ax,42                ; получить начальное значение
                                     ; для a
          push  ax                   ; занести его в a
          xor   ax,ax                ; обнулить AX
          push  ax                   ; и занести 0 в b

          Если вы используете этот способ, нужно внимательно  отслежи-
     вать  стек!  Не  следует  ссылаться на идентификаторы a и b перед
     тем, как они занесены в стек.

          Другой вид оптимизации предусматривает  использование  инст-
     рукции PUSH CONST для инициализации локальных переменных (ее мож-
     но использовать при наличии процессором 80186,  80286  и  80386),
     или  сохранение  BP  в регистре вместо занесения его в стек (если
     есть неиспользованные регистры).



     Турбо Ассемблер 3.0/tasm/#2-2                             = 135 =

           Примеры подпрограмм на Ассемблере для Турбо Паскаля
     ─────────────────────────────────────────────────────────────────

          В данном разделе вы дадим некоторые примеры  подпрограмм  на
     языке  Ассемблера,  которые  вы можете вызывать из программ Турбо
     Паскаля.

     Подпрограмма шестнадцатиричного преобразования общего назначения
     ─────────────────────────────────────────────────────────────────

          Содержащиеся в параметре num байты  преобразуются  в  строку
     шестнадцатиричных  цифр  длины  (byteCount * 2). Поскольку каждый
     байт порождает два символа, максимальное значение byteCount равно
     127  (не проверяется). Для преобразования каждой группы (по 4 би-
     та) в шестнадцатиричную цифру мы для скорости используем последо-
     вательность add-daa-adc-daa.

          Процедура HexStr  (ее  можно найти в файле HEX.ASM) написана
     так,  что вызываться она должна с помощью вызова  дальнего  типа.
     Это означает, что ее следует описывать в интерфейсной части моду-
     ля Турбо Паскаля или с помощью директивы компилятора {$F+}.

     CODE           SEGMENT
                    ASSUME  cs:CODE,ds:NOTHING

     ; Параметры (+2 с учетом push bp)

     byteCount      equ byte ptr  ss:[bp+6]
     num            equ dword ptr ss:[bp+8]

     ; Адресация к результату функции (+2 с учетом push bp)

     resultPtr      equ dword ptr ss:[bp+12]

     HexStr         PROC FAR
                    PUBLIC HexStr

                    push  bp
                    mov   bp,sp            ; получить указатель
                                           ; стека
                    les   di,resultPtr     ; получить адрес
                                           ; результата функции
                    mov   dx,ds            ; сохранить DS Турбо
                                           ; Паскаля в DX
                    lds   si,sum           ; получить адрес числа
                    mov   al,byteCount     ; сколько байт?
                    xor   ah,ah            ; слово
                    mov   cx,ax            ; отслеживать число
                                           ; байт в CX
                    add   si,ax            ; начать со старшего
                                           ; байта числа
                    dec   si
                    shl   ax,1             ; сколько цифр?

     Турбо Ассемблер 3.0/tasm/#2-2                             = 136 =

                                           ; (2/байт)
                    cld                    ; сохранить число цифр
                                           ; (работать в прямом
                                           ; направлении)
                    stosb                  ; в приемнике - байт
                                           ; длины строки
     NextLoop:
                    std                    ; сканировать число от
                                           ; старшего байта к
                                           ; младшему
                    lodsb                  ; получить следующий
                                           ; байт
                    mov   ah,al            ; сохранить его
                    shr   al,1             ; выделить старшую
                                           ; группу бит
                    shr   al,1
                    shr   al,1
                    shr   al,1
                    add   al,90h           ; специальная после-
                                           ; довательность шестнад-
                                           ; тиричного преобразования
                    daa                    ; использование инструкций
                                           ; ADD и DAA
                    adc   al,40h
                    daa                    ; группа преобразована
                                           ; в код ASCII
                    cld                    ; сохраним ASCII и следуем
                                           ; далее
                    stosb
                    mov   al,ah            ; повторить преобразование
                                           ; для младшей группы
                    and   al,0Fh
                    add   al,90h
                    daa
                    adc   al,40h
                    daa
                    stosb
                    loop  HexLoop          ; продолжать, пока не
                                           ; будет выполнено
                    mov   ds,dx
                    pop   bp
                    ret   6                ; параметры занимают
                                           ; 6 байт
     HexStr         ENDP
     CODE           ENDS
                    END

          Пример  программы  на  Паскале,  где  используется   функция
     HexStr, имеет следующий вид:

          Program HexTest;
          var
            num : word;

     Турбо Ассемблер 3.0/tasm/#2-2                             = 137 =

          {$F+}

          function HexStr(var num; byteCount : byte) : string;
                                                        external;

          {$L HEXSTR.OBJ}

          {$F-}
          begin
            num := word;
            Writeln('Преобразованная строка имеет шестнадцатиричное
          представление: ', HexStr(num,Sizeof(num)),'*');
          end.

          Для построения и запуска  примеров  программы на  Паскале  и
     программы  Ассемблера  используйте  следующие  команды командного
     файла:

          TASM HEXSTR
          TPC HEXTEST
          HEXTEST

          Если вы используете директиву .MODEL,  то  программу  HexStr
     можно записать следующим образом (файл HEXMOD.ASM):

                    .MODEL   large, PASCAL
                    .CODE
     HexStr PROC FAR num:DWORD,byteCount:BYTE RETURNS resultPtr:DWORD
                    PUBLIC HexStr
                    les   di,resultPtr     ; получить адрес
                                           ; результата функции
                    mov   dx,ds            ; сохранить DS Турбо
                                           ; Паскаля в DX
                    lds   si,sum           ; получить адрес числа
                    mov   al,byteCount     ; сколько байт?
                    xor   ah,ah            ; слово
                    mov   cx,ax            ; отслеживать число
                                           ; байт в CX
                    add   si,ax            ; начать со старшего
                                           ; байта числа
                    dec   si
                    shl   ax,1             ; сколько цифр?
                                           ; (2/байт)
                    cld                    ; сохранить число цифр
                                           ; (работать в прямом
                                           ; направлении)
                    stosb                  ; в приемнике - байт
                                           ; длины строки
     NextLoop:
                    std                    ; сканировать число от
                                           ; старшего байта к
                                           ; младшему
                    lodsb                  ; получить следующий

     Турбо Ассемблер 3.0/tasm/#2-2                             = 138 =

                                           ; байт
                    mov   ah,al            ; сохранить его
                    shr   al,1             ; выделить старшую
                                           ; группу бит
                    shr   al,1
                    shr   al,1
                    shr   al,1
                    add   al,90h           ; специальная после-
                                           ; довательность шестнад-
                                           ; тиричного преобразования
                    daa                    ; использование инструкций
                                           ; ADD и DAA
                    adc   al,40h
                    daa                    ; группа преобразована
                                           ; в код ASCII
                    cld                    ; сохраним ASCII и следуем
                                           ; далее
                    stosb
                    mov   al,ah            ; повторить преобразование
                                           ; для младшей группы
                    and   al,0Fh
                    add   al,90h
                    daa
                    adc   al,40h
                    daa
                    stosb
                    loop  HexLoop          ; продолжать, пока не
                                           ; будет выполнено
                    mov   ds,dx            ; восстановить DS
                                           ; Турбо Паскаля
                    ret
     HexStr         ENDP
     CODE           ENDS
                    END

          При этом вы можете использовать ту же программу на Паскале и
     просто  ассемблировать альтернативный вариант HexStr и перекомпи-
     лировать программу с помощью того же командного файла.

                Пример обмена содержимого двух переменных
     ─────────────────────────────────────────────────────────────────

          С помощью данной процедуры (VAREXCH.ASM) вы можете выполнить
     обмен содержимого двух переменных размера count. Если count имеет
     значение 0, то то процессор попытается перекопировать 64К.

     CODE        SEGMENT
                 ASSUME cs:CODE,ds:NOTHING

     ; Параметры (заметим, что из-за push bp смещение
     ; увеличивается на 2)

     var1        equ    DWORD PTR ss:[bp+12]

     Турбо Ассемблер 3.0/tasm/#2-2                             = 139 =

     var2        equ    DWORD PTR ss:[bp+8]
     count       equ    WORD  PTR ss:[bp+6]

     Exchange    PROC FAR
                 PUBLIC Exchange
                 cld                   ; обмен в прямом направлении
                 mov    dx,ds          ; сохранить регистр DS
                 push   bp
                 mov    bp,sp          ; получить базу стека
                 lds    si,var1        ; получить первый адрес
                 les    di,var2        ; получить второй адрес
                 mov    cx,count       ; получить число перемещаемых
                                       ; байт
                 shr    cx,1           ; получить счетчик слов
                                       ; (младший бит -> перенос)
                 jnc    ExchangeWord   ; если не нечетный байт,
                                       ; войти в цикл
                 mov    al,es:[di]     ; считать нечетный байт
                                       ; из var2
                 movsb                 ; переместить байт из var1
                                       ; в var2
                 mov    [si-1],al      ; записать var2 в var1
                 jz     Finis          ; выполнено, если нужно
                                       ; выполнить обмен только
                                       ; одного байта
     ExchangeWords:
                 mov    bx,-2          ; BX - это удобное место
                                       ; для хранения -2
     ExchangeLoop:
                 mov    ax,es:[di]     ; считать слово из var2
                 movsw                 ; переместить из var1
                                       ; в var2
                 mov    [bx][si,ax     ; записать слово var2 в
                                       ; var1
                 loop   ExchangeLoop   ; повторить count/2 раз
     Finis:
                 mov    ds,dx          ; получить обратно DS
                                       ; Турбо Паскаля
                 pop    bp
                 ret    10
     Exchange    ENDP
     CODE        ENDS
                 END

          Программа Турбо Паскаля, которая использует функцию Exchange
     (файл varexch.pas), имеет вид:

          program TextExchange;

          type
            EmployeeRecord = record
                               Name     :    string[30];
                               Address  :    string[30];

     Турбо Ассемблер 3.0/tasm/#2-2                             = 140 =

                               City     :    string[15];
                               State    :    string[2];
                               Zip      :    string[10];
                              end;

          var
            OldEmployee, NewEmployee : EmployeeRecord;

          {$F+}

          procedure Exchange(var var1,var2; count : word); external;
          {$L XCHANGE.OBJ}
          {$F-}
          begin
            with OldEmployee do
            begin
              Name := 'John Smith';
              Address := ' 123 F Street';
              City := 'Scotts Valley';
              State := 'CA';
              Zip := ' 90000-0000';
            end;
            with NewEmployee do
            begin
              Name := 'Mary Jones';
              Address := ' 9471 41st Avenue';
              City := 'New York';
              State := 'NY';
              Zip := ' 10000-1111';
            end;
            Writeln('Before: ',OldEmployee.Name,' ',NewEmployee.Name);
            Exchange(OldEmployee,NewEmployee,sizeof(OldEmployee));
            Writeln('After: ',OldEmployeeName,' ',NewEmployee.Name);
            Exchange(OldEmployee,NewEmployee,sizeof(OldEmployee));
            Writeln('After: ',OldEmployeeName,' ',NewEmployee.Name);
          end.

          Чтобы сформировать и запустить данные программы на Паскале и
     Ассемблере, используйте следующие команды командного файла:

          TASM XCHANGE
          TPC  XCHANGE
          XCHANGE

          Если использовать директиву .MODEL, то программа Exchange на
     Ассемблере будет выглядеть следующим образом:

                 .MODEL  large, PASCAL
                 .CODE
     Exchange    PROC FAR var1:DWORD,var2:DWORD,count:WORD
                 PUBLIC Exchange
                 cld                  ; обмен в прямом направлении
                 mov    dx,ds         ; сохранить DS

     Турбо Ассемблер 3.0/tasm/#2-2                             = 141 =

                 push   bp
                 mov    bp,sp         ; получить базу стека
                 lds    si,var1       ; получить первый адрес
                 les    di,var2       ; получить второй адрес
                 mov    cx,count      ; получить число перемещаемых
                                      ; байт
                 shr    cx,1          ; получить счетчик слов
                                      ; (младший бит -> перенос)
                 jnc    ExchangeWord  ; если не нечетный байт,
                                      ; войти в цикл
                 mov    al,es:[di]    ; считать нечетный байт
                                      ; из var2
                 movsb                ; переместить байт из var1
                                      ; в var2
                 mov    [si-1],al     ; записать var2 в var1
                 jz     Finis         ; выполнено, если нужно
                                      ; выполнить обмен только
                                      ; одного байта
     ExchangeWords:
                 mov    bx,-2         ; BX - это удобное место
                                      ; для хранения -2
     ExchangeLoop:
                 mov    ax,es:[di]    ; считать слово из var2
                 movsw                ; переместить из var1
                                      ; в var2
                 mov    [bx][si,ax    ; записать слово var2 в
                                      ; var1
                 loop   ExchangeLoop  ; повторить count/2 раз
     Finis:
                 mov    ds,dx         ; получить обратно DS
                                      ; Турбо Паскаля
                 ret
     Exchage     ENDP
     CODE        ENDS
                 END

          Вы можете использовать ту же программу на Паскале  и  просто
     ассемблировать  альтернативный вариант процедуры Exchаnge и пере-
     компилировать программу с помощью того же командного файла.

                  Пример анализа операционной среды DOS
     ─────────────────────────────────────────────────────────────────

          С помощью функции EnvString вы сможете просмотреть  операци-
     онную среду DOS и найти строку вида "s=НЕЧТО" и возвратить НЕЧТО,
     если это найдено.

     DATA           SEGMENT PUBLIC
                    EXTRN prefixSeg : Word  ; дает адрес PSP
     DATA           ENDS
                    SEGMENT PUBLIC
                    ASSUME  cs:CODE,ds:DATA


     Турбо Ассемблер 3.0/tasm/#2-2                             = 142 =

     EnvString      PROC FAR
                    PUBLIC  EnvString
                    push    bp
                    cld                     ; работать в прямом
                                            ; направлении
                    mov     es,[prefixSeg]  ; посмотреть PSP
                    mov     es,es:[2Ch]     ; ES:DI указывают на
                                            ; операционную среду,
                    xor     di,di           ; которая выровнена на
                                            ; границу параграфа
                    mov     bp,sp           ; найти строку параметров,
                    lds     si,ss:[bp+6]    ; которая следует за
                                            ; адресом возврата
                    ASSUME  ds:NOTHING
                    lodsb                   ; посмотреть длину
                    or      al,al           ; она равна 0?
                    jz      RetNul          ; да, возврат
                    mov     ah,al           ; в противном случае
                                            ; сохранить ее в AH
                    mov     dx,si           ; DS:SI содержат указатель
                                            ; на первый параметр
                                            ; char
                    xor     al,al           ; сделать его равным 0
     Compare:
                    mov     ch,al           ; мы хотим, чтобы для
                                            ; следующего отсчета ch=0
                    mov     si,dx           ; возвратить указатель на
                                            ; просмотренную строку
                    mov     cl,ah           ; получить длину
                    mov     si,dx           ; возвратить указатель на
                                            ; строку
                    repe    cmpsb           ; сравнить байты
                    jne     Skip            ; если сравнение неудач-
                                            ; ное попробовать следу-
                                            ; ющую строку
                    cmp     byte ptr es:[di],'=' ; сравнение
                                            ; завершилось успешно
                                            ; следующий символ '='?
                    jne     NoEqual         ; если нет, все еще нет
                                            ; совпадения
     Found:
                    mov     ax,es           ; DI:SI будет указывать
                                            ; на найденную нами строку
                    mov     ds,ax
                    mov     si,di
                    inc     si              ; "пройти" символ '='
                    les     bx,ss:[bp+10]   ; получить адрес
                                            ; результата
                                            ; функции
                    mov     di,bx           ; занести его в ES:DI
                    inc     di              ; байт длины
                    mov     cl,255          ; задать максимальную
                                            ; длину

     Турбо Ассемблер 3.0/tasm/#2-2                             = 143 =

     CopyLoop:
                    lodsb                   ; получить байт
                    or      al,al           ; проверить на 0
                    jz      Done            ; если 0, выполнено
                    stosb                   ; занести его в результат
                    loop    CopyLoop        ; переместить до 255
                                            ; байт
     Done:          not     cl              ; при сохранении мы
                                            ; уменьшали от CL до 255
                    mov     es:[bx],cl      ; сохранить длину
                    mov     ax,SEG DATE
                    mov     ds,ax           ; восстановить DS
                    ASSUME  ds:DATA
                    pop     bp
                    ret     4
                    ASSUME  ds:NOTHING
     Skip:
                    dec     di              ; проверить на 0
     NoEqual:
                    mov     cx,7FFFh        ; длинный поиск, если
                                            ; нужно
                    sub     cx,di           ; операционная среда
                                            ; никогда не превышает
                                            ; 32К
                    jbe     RetNul          ; если конец, выйти
                    repne   scasb           ; посмотреть следующий
                                            ; 0
                    jcxz    RetNul          ; выйти, если не найден
                    cmp     byte ptr es:[di],al ; второй 0 в строке?
                    jne     Compare         ; если нет, попытаться
                                            ; снова
     RetNul:
                    les     di,ss:[bp+10]   ; получить адрес
                                            ; результата
                    stosb                   ; сохранить там 0
                    mov     ax,SEG DATA
                    mov     ds,ax           ; восстановить DS
                    ASSUME  ds:DATA
                    pop     bp
                    ret     4
     EnvString      ENDP
     CODE           ENDS
                    END

          Программа на Паскале, которая использует функцию  EnvString,
     выглядит следующим образом:

          program EnvTest;
          { программа ищет строки операционной среды }

          var
            EnvVariable : string;
            EnvValue    : string;

     Турбо Ассемблер 3.0/tasm/#2-2                             = 144 =


          {$F+}

          function EnvString(s:string) : string; external;
          {$L ENVSTRING.OBJ}
          {$F-}
          begin
            EnvVariable := 'PROMPT';
            EnvValue := EnvString(EnvVariable);
            if EnvValue = '' then EnvValue := '*** не найдена ***';
            Writeln('Переменная операционной среды: ',
                     EnvVariable,' Значение: ',EnvValue);
          end.

          Чтобы сформировать и запустить данные программы на Паскале и
     Ассемблере, используйте следующие команды командного файла:

          TASM ENVSTR
          TPC ENVTEST
          ENVTEST

          Если использовать директиву .MODEL,  то функция EnvString на
     Ассемблере будет выглядеть следующим образом (ENVMOD.ASM):

                    .MODEL   large, PASCAL
                    .DATA
                    EXTRN prefixSeg : Word  ; дает адрес PSP
                    .CODE
     EnvString      PROC FAR  EnvVar:DWORD  RETURNS EnvVal:DWORD
                    PUBLIC  EnvString
                    push    bp
                    cld                     ; работать в прямом
                                            ; направлении
                    mov     es,[prefixSeg]  ; посмотреть PSP
                    mov     es,es:[2Ch]     ; ES:DI указывают на
                                            ; операционную среду,
                    xor     di,di           ; которая выровнена на
                                            ; границу параграфа
                    mov     bp,sp           ; найти строку параметров,
                    lds     si,ss:[bp+6]    ; которая следует за
                                            ; адресом возврата
                    ASSUME  ds:NOTHING
                    lodsb                   ; посмотреть длину
                    or      al,al           ; она равна 0?
                    jz      RetNul          ; да, возврат
                    mov     ah,al           ; в противном случае
                                            ; сохранить ее в AH
                    mov     dx,si           ; DS:SI содержат указатель
                                            ; на первый параметр
                                            ; char
                    xor     al,al           ; сделать его равным 0
     Compare:
                    mov     ch,al           ; мы хотим, чтобы для

     Турбо Ассемблер 3.0/tasm/#2-2                             = 145 =

                                            ; следующего отсчета ch=0
                    mov     si,dx           ; возвратить указатель на
                                            ; просмотренную строку
                    mov     cl,ah           ; получить длину
                    mov     si,dx           ; возвратить указатель на
                                            ; строку
                    repe    cmpsb           ; сравнить байты
                    jne     Skip            ; если сравнение неудач-
                                            ; ное, попробовать следу-
                                            ; ющую строку
                    cmp     byte ptr es:[di],'=' ; сравнение
                                            ; завершилось успешно
                                            ; следующий символ '='?
                    jne     NoEqual         ; если нет, все еще нет
                                            ; совпадения
     Found:
                    mov     ax,es           ; DI:SI будет указывать
                                            ; на найденную нами строку
                    mov     ds,ax
                    mov     si,di
                    inc     si              ; "пройти" символ '='
                    les     bx,ss:[bp+10]   ; получить адрес
                                            ; результата функции
                    mov     di,bx           ; занести его в ES:DI
                    inc     di              ; байт длины
                    mov     cl,255          ; задать максимальную
                                            ; длину
     CopyLoop:
                    lodsb                   ; получить байт
                    or      al,al           ; проверить на 0
                    jz      Done            ; если 0, выполнено
                    stosb                   ; занести его в результат
                    loop    CopyLoop        ; переместить до 255
                                            ; байт
     Done:          not     cl              ; при сохранении мы
                                            ; уменьшали от CL до 255
                    mov     es:[bx],cl      ; сохранить длину
                    mov     ax,SEG DATE
                    mov     ds,ax           ; восстановить DS
                    ASSUME  ds:DATA
                    pop     bp
                    ret     4
                    ASSUME  ds:NOTHING
     Skip:
                    dec     di              ; проверять на 0
     NoEqual:
                    mov     cx,7FFFh        ; длинный поиск, если
                                            ; нужно
                    sub     cx,di           ; операционная среда
                                            ; никогда не превышает
                                            ; 32К
                    jbe     RetNul          ; если конец, выйти
                    repne   scasb           ; посмотреть следующий

     Турбо Ассемблер 3.0/tasm/#2-2                             = 146 =

                                            ; 0
                    jcxz    RetNul          ; выйти, если не найден
                    cmp     byte ptr es:[di],al ; второй 0 в строке?
                    jne     Compare         ; если нет, попытаться
                                            ; снова
     RetNul:
                    les     di,ss:[bp+10]   ; получить адрес
                                            ; результата
                    stosb                   ; сохранить там 0
                    mov     ax,SEG DATA
                    mov     ds,ax           ; восстановить DS
                    ASSUME  ds:DATA
                    ret     4
     EnvString      ENDP
     CODE           ENDS
                    END

          Вы можете использовать ту же программу на Паскале  и  просто
     ассемблировать  альтернативный  вариант функции EnvString и пере-
     компилировать программу с помощью того же командного файла.





     Турбо Ассемблер 3.0/tasm/#2-2                             = 147 =

                          Часть 2. ПРИЛОЖЕНИЯ
     ─────────────────────────────────────────────────────────────────

          Далее следует содержимое приложений.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 148 =

               Приложение A. Замечания по программированию
     ─────────────────────────────────────────────────────────────────

          В данном приложении приведена основная информация по постро-
     ению программ с конкретными моделями памяти и форматами выполняе-
     мого кода.

                Упрощенные директивы определения сегмента
     ─────────────────────────────────────────────────────────────────

          В следующей  таблице  показаны используемые по умолчанию для
     каждой модели памяти атрибуты сегмента.

      Используемые по умолчанию сегменты и типы для модели памяти TINY
                                                           Таблица A.1
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      _TEXT    WORD         PUBLIC      'CODE'     DGROUP │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      _DATA    WORD         PUBLIC      'DATA'     DGROUP │
     │.CONST     CONST    WORD         PUBLIC      'CONST;    DGROUP │
     │.DATA?     _BSS     WORD         PUBLIC      'BSS'      DGROUP │
     │STACK*     STACK    PARA         STACK       'STACK'    DGROUP │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP  или│
     │FARSTACK, заданным в директиве MODEL.                          │
     └───────────────────────────────────────────────────────────────┘

     Используемые по умолчанию сегменты и типы для модели памяти SMALL
                                                           Таблица A.2
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      _TEXT    WORD         PUBLIC      'CODE'            │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      _DATA    WORD         PUBLIC      'DATA'     DGROUP │
     │.CONST     CONST    WORD         PUBLIC      'CONST;    DGROUP │
     │.DATA?     _BSS     WORD         PUBLIC      'BSS'      DGROUP │
     │STACK*     STACK    PARA         STACK       'STACK'    DGROUP │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP  или│
     │ FARSTACK, заданным в директиве MODEL.                         │
     └───────────────────────────────────────────────────────────────┘

                         Используемые по умолчанию
                 сегменты и типы для модели памяти MEDIUM


     Турбо Ассемблер 3.0/tasm/#2-2                             = 149 =

                                                           Таблица A.3
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      имя_TEXT WORD         PUBLIC      'CODE'            │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      _DATA    WORD         PUBLIC      'DATA'     DGROUP │
     │.CONST     CONST    WORD         PUBLIC      'CONST;    DGROUP │
     │.DATA?     _BSS     WORD         PUBLIC      'BSS'      DGROUP │
     │STACK*     STACK    PARA         STACK       'STACK'    DGROUP │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP или │
     │ FARSTACK, заданным в директиве MODEL.                         │
     └───────────────────────────────────────────────────────────────┘

                         Используемые по умолчанию
                 сегменты и типы для модели памяти COMPACT
                                                           Таблица A.4
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      _TEXT    WORD         PUBLIC      'CODE'            │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      _DATA    WORD         PUBLIC      'DATA'     DGROUP │
     │.CONST     CONST    WORD         PUBLIC      'CONST;    DGROUP │
     │.DATA?     _BSS     WORD         PUBLIC      'BSS'      DGROUP │
     │STACK*     STACK    PARA         STACK       'STACK'    DGROUP │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP  или│
     │FARSTACK, заданным в директиве MODEL.                          │
     └───────────────────────────────────────────────────────────────┘

                         Используемые по умолчанию
             сегменты и типы для модели памяти LARGE или HUGE
                                                           Таблица A.5
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      имя_TEXT WORD         PUBLIC      'CODE'            │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      _DATA    WORD         PUBLIC      'DATA'     DGROUP │
     │.CONST     CONST    WORD         PUBLIC      'CONST;    DGROUP │
     │.DATA?     _BSS     WORD         PUBLIC      'BSS'      DGROUP │
     │STACK*     STACK    PARA         STACK       'STACK'    DGROUP │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP  или│
     │FARSTACK, заданным в директиве MODEL.                          │
     └───────────────────────────────────────────────────────────────┘

                         Используемые по умолчанию

     Турбо Ассемблер 3.0/tasm/#2-2                             = 150 =

        сегменты и типы для модели памяти HUGE (TCHUGE) Borland C++
                                                           Таблица A.6
     ┌───────────────────────────────────────────────────────────────┐
     │  Директива  Имя    Выравнивание Комбинирование  Класс   Группа│
     ├───────────────────────────────────────────────────────────────┤
     │.CODE      имя_TEXT WORD         PUBLIC      'CODE'            │
     │.FARDATA   FAR_DATA PARA         private     'FAR_DATA'        │
     │.FARDATA?  FAR_BSS  PARA         private     'FAR_BSS'         │
     │.DATA      имя_DATA PARA         private     'DATA'            │
     │STACK*     STACK    PARA         STACK       'STACK'           │
     │                                                               │
     │    * -  STACK  не  подразумевается  размещенным в  DGROUP  или│
     │FARSTACK, заданным в директиве MODEL.                          │
     └───────────────────────────────────────────────────────────────┘

                              Программы DOS
     ─────────────────────────────────────────────────────────────────

          Программы DOS  предназначены для работы под управлением опе-
     рационной системы DOS и записываются в двух форматах:

          - формат .EXE;

          - формат .COM.

          Формат EXE позволяет использовать наиболее общую в DOS  сег-
     ментацию программы.  Программы  могут иметь насколько сегментов и
     могут ссылаться на сегмент или группу сегментов по  имени.  Таким
     образом, программы .EXE могут превышать по размеру 64К.

          Формат COM представляет  собой  достаточно  простой  формат.
     Программы в таком формате не могут содержать символьных ссылок на
     имена групп и сегментов.  Таким образом, программы COM обычно пи-
     шутся с использованием модели TINY и ограничены по размеру данных
     или кода 64 килобайтами.

          Чтобы строить программы  DOS,  вам  потребуется  компоновщик
     (например, TLINK) и утилита построения программ (например, MAKE).
     Подробнее об утилитах рассказывается в Приложении D.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 151 =

                   Замечания по программам формата EXE
     ─────────────────────────────────────────────────────────────────

          При загрузке программы EXE операционная система устанавлива-
     ет регистры следующим образом:

     ┌─────────────────┬─────────────────────────────────────────────┐
     │    Регистр      │ Значение                                    │
     ├─────────────────┼─────────────────────────────────────────────┤
     │    DS, ES       │ Содержит адрес параграфа для префикса прог- │
     │                 │ рамного сегмента  программы (PSP).  PSP со- │
     │                 │ держит передаваемые  программе  в командной │
     │                 │ строке аргументы и указатель на строку опе- │
     │                 │ рационной среды для программы.              │
     │                 │                                             │
     │    CS:IP        │ Содержит начальный адрес, заданный в опера- │
     │                 │ торе END в  одном из модулей программы, или │
     │                 │ адрес директивы STARTUPCODE.                │
     │                 │                                             │
     │    SS:SP        │ Содержит адрес  последнего  слова,  которое │
     │                 │ задает в программе сегмент стека.           │
     └─────────────────┴─────────────────────────────────────────────┘

          В программах  EXE  вы  можете  задавать любую модель памяти.
     Следует использовать возможно более простую модель, поскольку это
     обеспечивает более  быстрое  выполнение и упрощает программирова-
     ние. Например,  если в вашей программе никогда не  предполагается
     использовать более  64К  данных и области стека,  то вполне можно
     использовать модель TINY.

          Директива STURTUPCODE в модуле генерирует инструкции,  кото-
     рые автоматически инициализируют все необходимые регистры,  соот-
     ветствующие выбранной модели.  Для использования в программе  она
     сохраняет адрес параграфа PSP в сегменте ES.

          Когда вы загружаете программу, операционная система выделяет
     программе до ее завершения всю оставшуюся память.  Для  программ,
     которые не  используют динамически распределяемую область памяти,
     или которые строят в памяти свою собственную динамически  распре-
     деляемую область,  такое поведение вполне подходит.  Другие прог-
     раммы могут выделять память через DOS. В этом случае через запро-
     сом на  память  из  DOS память должна быть освобождена и доступна
     операционной системе.

          Для выхода из  программы  используется  прерывание  INT  21,
     функция 4Ch.

          Эти вопросы иллюстрируются примером программы EXEPROG.ASM на
     дистрибутивном диске.  Чтобы сформировать программу EXE,  исполь-
     зуйте утилиту MAKE.  В формирующем файле MAKEFILE следует указать
     все модули, с которыми компонуется программа, например:

          EXECPROG.EXE:  EXECPROG.OBJ

     Турбо Ассемблер 3.0/tasm/#2-2                             = 152 =

             TLINK EXECPROG;
          EXECPROG.OBJ: EXECPROG.ASM
             TASM EXECPROG

                   Замечания по программам формата COM
     ─────────────────────────────────────────────────────────────────

          Программы COM представляют собой ограниченные  версии  прог-
     рамм EXE.  Каждую  программу  формата  COM  можно представить как
     программу EXE,  но не каждую программу EXE можно представить  как
     программу формата COM. Здесь действуют следующие ограничения:

          - Программы COM следует писать с использованием модели TINY.

          - В программах COM нельзя использовать предопределенный сег-
            мент стека.

          - Программа COM не может содержать прямых адресных ссылок на
            адрес сегмента или группы.  Это означает, что программа не
            может содержать непосредственных дальних вызовов или  ссы-
            латься на сегменты по имени. Все процедуры в программе COM
            должны описываться как BEAR.

          - Выполнение должно начинаться со смещения 100h  в  сегменте
            кода.  Чтобы это произошло, укажите в качестве первой инс-
            трукции сегмента кода директиву STURTUPCODE.

          Турбо Ассемблер загружает программы COM, начиная со смещения
     100h в префиксе программного сегмента программы (PSP).  Для этого
     директива STARTUPCODE  для  модели  TINY автоматически помещает в
     программу ORG 100h.

          При загрузке программы COM устанавливаются следующие регист-
     ры:

     ┌───────────────────┬───────────────────────────────────────────┐
     │   Регистр         │ Значение                                  │
     ├───────────────────┼───────────────────────────────────────────┤
     │   CS,DS,ES,SS     │ Содержит адрес параграфа в PSP программы. │
     │                   │                                           │
     │   IP              │ Устанавливается в значение 100h.          │
     │                   │                                           │
     │   SP              │ Устанавливается в 0FFFEh (последнее слово │
     │                   │ в сегменте программы.                     │
     └───────────────────┴───────────────────────────────────────────┘

          Если вы не хотите размещать стек в конце сегмента программы,
     то нужно установить новый стек. Для такого стека используйте неи-
     нициализированный сегмент данных (UDATASEG).

          Хотя программы  COM  должны  определяться  с  моделью памяти
     TINY, с помощью директив CODESEG, DATASEG и UDATASEG можно разде-
     лить код данные и неинициализированные данные.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 153 =


          Как и  в случае программ EXE,  когда вы загружаете программу
     COM, Турбо Ассемблер выделяет для ее  завершения  всю  оставшуюся
     память. При возврате памяти в DOS убедитесь,  что вы не освободи-
     ли непреднамеренно неинициализированные данные.

          Данные вопросы иллюстрируются  файлом-примером COMPROPG.ASM,
     который можно найти на дистрибутивных дисках Турбо Ассемблера.

           Чтобы сформировать программу COM, используйте утилиту MAKE.
     В формирующем файле MAEKFILE следует указать все модули,  с кото-
     рыми компонуется программа, например:

          COMPROG.COM:  COMPROG.OBJ
             TLINK COMPROG;
          COMPROG.OBJ: COMPROG.ASM
             TASM COMPROG

                           Программы Windows
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер  можно  использовать для создания прикладных
     программ Windows.  Windows может работать либо в реальном  режиме
     (на всех процессорах 8086) или в защищенном режиме (на процессоре
     80286 и старше). Таким образом программа, написанная для Windows,
     может работать  в защищенном режиме.  С помощью директив CODESEG,
     DATASEG и UDATASEG следует аккуратно разделить код и данные и ис-
     пользовать директиву  WARN  PRO,  чтобы отмечать любые проблемы с
     доступом, которые могут возникать во время ассемблирования. Нако-
     нец, в программах защищенного режима не следует пытаться устанав-
     ливать сегментные регистры в вычисленные значения параграфов сег-
     мента. Значениями  сегментов  в  защищенном  режиме  не  являются
     адреса параграфов. Вместо этого используются дескрипторы, которые
     не имеют смысла в прикладной программе.

          Кроме Турбо Ассемблера и Турбо отладчика для создания эффек-
     тивных прикладных программ Windows требуются другие  средства.  В
     частности, вы  должны  располагать компилятором Borland C++ (либо
     Microsoft C  2.6 и Windows Software Dewelopment Kit).  Прикладные
     программы Windows обычно требуют наличия утилиты-компилятора  ре-
     сурсов (RC) этих пакетов.  Должны быть также доступны стандартные
     библиотеки.  В Windows  также  необходим  компоновщик  (например,
     TLINK) и утилита построения программ (например, MAKE).

          Данное приложение содержит простейшие рекомендации по созда-
     нию прикладных программ Windows и динамически компонуемых библио-
     тек (DLL). Более полное описание прикладных программ Windows мож-
     но найти  в  "Руководстве  пользователя по С++" и соответствующей
     документации по Windows.

         Замечания по динамически компонуемым библиотекам Windows
     ─────────────────────────────────────────────────────────────────
          Динамически компонуемая  библиотека (DLL) представляет собой

     Турбо Ассемблер 3.0/tasm/#2-2                             = 154 =

     группу процедур,  которую вы можете вызывать из прикладных  прог-
     рамм Windows. Библиотеки DLL расширяют интерфейс прикладных прог-
     рамм Windows.

          Библиотеки DLL выполняют множество функций. Например, вы мо-
     жете в  DLL  неинтерактивные  программы DOS.  С помощью DLL можно
     добавить новые средства работы с экраном.

          На дистрибутивном диске Турбо Ассемблера можно  найти пример
     программы с именем DLLPROG.ASM, который иллюстрирует DLL.

          Для построения DLL можно использовать утилиту MAKE. Формиру-
     ющий файл должен включать в себя все модули, которые должны  ком-
     поноваться с DLL, например:

          dllprog.dll: dllprog.obj dllprog.def
             TLINK dllprog,,,,dllprog
             RC dllprog.dll

          dllprog.obj: dllprog.asm
             TASM dllprog

          Данный процесс построения требует наличия  следующего  файла
     определений компоновщика DLLPROG.DEF:

          LIBRARY DLLPROG
          EXETYPE WINDOWS
          CODE    PRELOAD MOVEABLE DISCARDABLE   ; CODE применяется к
                                                 ; сегментам _TEXT или
                                                 ; в классе CODE
          DATA    PRELOAD MOVEABLE SINGLE        ; DATE применяется ко
                                                 ; всем сегментам в
                                                 ; группе DGROUP и в
                                                 ; классе DATA
                                                 ; (должен быть
                                                 ; SINGLE для всех DLL
          HEAPSIZE 0

              Замечания по прикладным программам Windows
     ─────────────────────────────────────────────────────────────────

          Прикладная программа Windows  во  многом  аналогична  DLL  с
     единственной процедурой   с   именем  WinMain.  Windows  вызывает
     WinMain для запуска процедуры.  Прикладная программа имеет обычно
     стандартную структуру,  которая  позволяет ей взаимодействовать с
     графической операционной средой Windows.

          Пример прикладной программы  Windows  можно  найти  в  файле
     WINPROC.ASM на  дистрибутивных дисках Турбо Ассемблера.  В данном
     примере для вывода сообщения на экран используются функциональные
     возможности, обеспечиваемые предыдущим примером DLL.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 155 =

          Для построения прикладной программы Wiondows можно использо-
     вать утилиту MAKE.  При этом в формирующем файле следует  указать
     все модули, компонуемые с данной прикладной программой:

          winproc.exe: winprog.obj winprog.def winprogg.res
             TLINK winprog,,,,winprog
             RC winprog.res

          winproc.res:winproc.rc
             RC -r winproc.rc

          winproc.obj: winprog.asm winprog.inc
             TASM winprog

          Этот процесс  построения  требует  использования  следующего
     файла определений компоновщика WINPROG.DEF:

          NAME            WINPROG
          EXETYPE         WINDOWS
          CODE            MOVEABLE DISCARDABLE
          DATA            MOVEABLE MULTIPLE DISCARDABLE
          STACKSIZE 5120                  ; минимум для прикладных
                                          ; программ Windows

          ;-----------------------------------------------------------
          ; Определить импортируемые функции. (Это не обязательно, ес-
          ; ли вы  выполняете компоновку с  библиотекой  импорта  типа
          ; IMPORT.LIB или LIBW.LIB.)
          ;-----------------------------------------------------------
          IMPORTS  DLLPROG.SetHello




     Турбо Ассемблер 3.0/tasm/#2-2                             = 156 =

       Приложение B. Обзор синтаксических правил Турбо Ассемблера
     ─────────────────────────────────────────────────────────────────

          В этом приложении для описания  синтаксиса  выражений  Турбо
     Ассемблера, используется   модифицированная   форма  Бекуса-Наура
     (BNF). Символ ::= описывает синтаксический  результат.  Далее  во
     всех разделах многоточие (...) означает,  что предшествующий эле-
     мент может быть повторен любое число  раз.  В  данном  приложении
     описываются также ключевые слова и их старшинство.

                         Лексическая грамматика
     ─────────────────────────────────────────────────────────────────

     допустимая_строка ::=
           пропуск допустимая_строка
           знак_пунктуации допустимая_строка
           числовая_строка допустимая_строка
           идентификатор_строки допустимая_строка
           нуль

     пропуск ::=
           символ_пробела пропуск
           символ_пробела

     символ_пробела ::=
           все управляющие символы, символы > 128, ' '

     идентификатор_строки ::=
           идентификатор_символа идентификатор_строки_2

     идентификатор_строки_2 ::=
           идентификатор_символа_2 идентификатор_строки_2
           нуль

     идентификатор_символа ::=
           $,%,_,?,символы алфавита

     идентификатор_символа_2 ::=
           идентификатор_символов плюс цифры

     числовая_строка ::=
           числ_строка
           стр_строка

     числ_строка ::=
           цифры буквенно_цифровые_символы
           цифры'.'цифры показатель_степени
           цифры показатель_степени ; Только в режиме MASM в директи-
                                    ; вах DD, DQ и DT

     цифры ::=
          цифра цифры
          цифра

     Турбо Ассемблер 3.0/tasm/#2-2                             = 157 =


     цифра ::=
          от 0 до 9

     алфавитно-цифровые_символы ::=
          цифра буквенно_цифровые_символы
          буква буквенно_цифровые_символы
          нуль

     буква ::=
          буквы алфавита

     показатель_степени ::=
          Е+цифры
          Е-цифры
          Ецифры
          нуль

     стр_строка ::=
          строка в двойных кавычках; кавычка, вводимая двумя кавычками

     знак_пунктуации ::=
           любой символ, отличный  от следующих:
            символ_пробела,идентификатор_символ,'"',"'" или цифры

          Символ точки  (.) трактуется различным образом в режиме MASM
     и в режиме Ideal.  Этот символ не требуется указывать в числах  с
     плавающей запятой в режиме MASM.  Точка не может входить в состав
     символического имени в режиме Ideal. В режиме MASM с этого симво-
     ла иногда начинаются символические имена,  кроме того, знак пунк-
     туации используется иногда в качестве селектора поля структуры.

          Правила интерпретации точки (.):

          1. В режиме Ideal точка  всегда  интерпретируется  как  знак
              пунктуации.

          2. В  режиме MASM точка трактуется как первый символ иденти-
             фикатора в следующих случаях:

             а). Когда она является первым символом в строке и  в ряде
                 некоторых  других  специальных случаев,  например,  в
                 составе внешних (EXTRN) и общих (PUBLIC)  символичес-
                 ких имен, она присоединяется к следующему за ней сим-
                 волическому  имени,  если  следующий  за  ней  символ
                 представляет  собой  идентификатор_символа_2,  как он
                 определен выше.

             б). Если она не является первым символом  в  строке,  или
                 если результирующее  имя  идентификатора будет предс-
                 тавлять собой определенное имя  идентификатора, тогда
                 точка присоединяется к началу следующего за ней иден-
                 тификатора.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 158 =

                   Грамматика выражений в режиме MASM
     ─────────────────────────────────────────────────────────────────

          Синтаксис выражений начинается как MASM_выражение.

     MASM_выражение ::=
          выражение_1

     м_выражение_1 ::=
          SHORT м_выражение_1
          .TYPE м_выражение_1
          SMALL м_выражение_1 (преобразование в 16-битовое смещение
                           [только для процессора 386])
          LARGE м_выражение_1 (преобразование в 32-битовое смещение
                           [только для процессора 386])
          м_выражение_2

     м_выражение_2 ::=
          м_выражение_3 OR м_выражение_3...
          м_выражение_3 ХOR м_выражение_3...
          м_выражение_3

     м_выражение_3 ::=
          м_выражение_4 AND м_выражение_4...
          м_выражение_4

     м_выражение_4 ::=
          NOT м_выражение_4
          м_выражение_5

     м_выражение_5 ::=
          м_выражение_6 'EQ' м_выражение_6...
          м_выражение_6 'NE' м_выражение_6...
          м_выражение_6 'LT' м_выражение_6...
          м_выражение_6 'LE' м_выражение_6...
          м_выражение_6 'GT' м_выражение_6...
          м_выражение_6 'GE' м_выражение_6...
          м_выражение_6

     м_выражение_6 ::=
          м_выражение_7 '+' м_выражение_7...
          м_выражение_7 '-' м_выражение_7...
          м_выражение_7

     м_выражение_7 ::=
          м_выражение_8 '*' м_выражение_8...
          м_выражение_8 '/' м_выражение_8...
          м_выражение_8 'MOD' м_выражение_8...
          м_выражение_8 'SHR' м_выражение_8...
          м_выражение_8 'SHL' м_выражение_8...
          м_выражение_8

     м_выражение_8 ::=

     Турбо Ассемблер 3.0/tasm/#2-2                             = 159 =

          + выражение_8
          - выражение_8
          выражение_12

     м_выражение_10 ::=
          OFFSET указатель
          SEG указатель
          SIZE идентификатор
          LENGTH идентификатор
          WIDTH идентификатор
          MASK идентификатор
          THIS цел_тип
          идентификатор
          ( указатель )
          [ указатель ]

     м_выражение_10 ::=
          м_выражение_11 PTR м_выражение_10
          м_выражение_11
          OFFSET м_выражение_10
          SEG м_выражение_10
          LOW м_выражение_10
          HIGH м_выражение_10
          TYPE м_выражение_10
          THIS м_выражение_10

     м_выражение_11 ::=
          м_выражение_8 : м_выражение_8...

     м_выражение_12 ::=
          м_выражение_13  [м_выражение_13...(подразумеваемое сложение,
                                         только если есть '[' или '(')
          м_выражение_13  (м_выражение_13...(подразумеваемое сложение,
                                         только если есть '[' или '(')
          м_выражение_13'.'м_выражение_10

     м_выражение_13 ::=
          LENGTH идентификатор
          SIZE идентификатор
          WIDTH идентификатор
          MASK идентификатор
          ( м_выражение_1 )
          [ м_выражение_1 ]
          м_выражение_10



     Турбо Ассемблер 3.0/tasm/#2-2                             = 160 =

                   Грамматика выражений в режиме Ideal
     ─────────────────────────────────────────────────────────────────

          Синтаксис начинается, как id_выражение.

     id_выражение ::=

     указатель

     i_тип ::=
          UNKNOWN
          BYTE
          WORD
          DWORD
          FWORD
          QWORD
          PWORD
          TBYTE
          SHORT
          NEAR
          FAR
          PROC
          DATAPTR
          CODEPTR
          имя_структуры
          имя_таблицы
          имя_перечисления
          имя_записи
          TYPE указатель

     указатель ::=
          SMALL указатель               ; если 386
          LARGE указатель               ; если 386
          i_тип PTR указатель
          i_тип LOW указатель
          i_тип HIGH указатель
          i_тип указатель
          указатель_2

     указатель_2 ::=
          указатель_3.идентификатор (Операция выбора элемента
                                       структуры)
          указатель_3

     указатель_3 ::=
          выражение:указатель_3
          выражение

     выражение ::=
          SYMTYPE выражение (Операция определения типа символическо-
           го имени)
          выражение_2


     Турбо Ассемблер 3.0/tasm/#2-2                             = 161 =

     выражение_2 ::=
          выражение_3 OR выражение_3...
          выражение_3 ХOR выражение_3...
          выражение_3

     выражение_3 ::=
          выражение_4 AND выражение_4...
          выражение_4

     выражение_4 ::=
          NOT выражение_4
          выражение_5

     выражение_5 ::=
          выражение_6 ЕQ выражение_6...
          выражение_6 NE выражение_6...
          выражение_6 LT выражение_6...
          выражение_6 LE выражение_6...
          выражение_6 GT выражение_6...
          выражение_6 GE выражение_6...
          выражение_6

     выражение_6 ::=
          выражение_7 + выражение_7...
          выражение_7 - выражение_7...
          выражение_7

     выражение_7 ::=
          выражение_8 * выражение_8...
          выражение_8 / выражение_8...
          выражение_8 MOD выражение_8...
          выражение_8 SHR выражение_8...
          выражение_8 SHL выражение_8...
          выражение_8

     выражение_8
          +выражение_8
          -выражение_8
          выражение_9

     выражение_9
          HIGH выражение_9
          LOW выражение_9
          выражение_10

     выражение_10
          OFFSET указатель
          SEG указатель
          SIZE идентификатор
          LENGTH идентификатор
          WIDTH идентификатор
          MASK идентификатор
          THIS идентификатор

     Турбо Ассемблер 3.0/tasm/#2-2                             = 162 =

          идентификатор
          константа
          ( указатель )
          [ указатель ]  (Всегда означает "содержимое..")

                     Старшинство ключевых слов
     ─────────────────────────────────────────────────────────────────

          Важно понимать, как Турбо Ассемблер распознает строки исход-
     ного текста. Это позволит вам избежать записи кода, который может
     привести к  непредсказуемым  результатам.  Рассмотрим,  например,
     следующий фрагмент программы:

          NAME SEGMENT

          Если вы  записали эту строку,  рассчитывая открыть сегмент с
     именем NAME,  то будете разочарованы. Турбо Ассемблер  распознает
     ключевое слово NAME раньше,  чем SEGMENT,  называя ваш код именем
     SEGMENT.

          В общем случае определяет значение строки на  основе  первых
     двух символов строки. Самый левый символ находится в первой пози-
     ции, а символ справа от него находится во второй позиции.

                   Старшинство операций в режиме Ideal
     ─────────────────────────────────────────────────────────────────

          В режиме  Ideal  применяются  следующие  правила старшинства
     операций:

          1. Наивысший приоритет (приоритет 1) имеют все ключевые сло-
             ва в первой позиции строки. Они проверяются первыми.

          2. Ключевые слова на второй позиции строки имеют второй при-
             орите и рассматриваются во вторую очередь.

                   Старшинство операций в режиме MASM
     ─────────────────────────────────────────────────────────────────

          Правила синтаксического  анализа  строк в режиме MASM значи-
     тельно более сложны, чем в режиме Ideal. Вместо двух здесь имеет-
     ся три уровня приоритета:

          1. Наивысший приоритет (приоритет 1) присваивается отдельным
             ключевым словам в первой позиции (таким как NAME и %OUT).

          2. Следующий по старшинству приоритет  (приоритет  2)  имеют
             все идентификаторы, обнаруженные на второй позиции.

          3. Все другие ключевые слова в первой позиции имеют наимень-
             ший (третий) приоритет.

                Примечание: Внутри определений структур Турбо  Ассемб-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 163 =

           лер  интерпретирует ключевые слова приоритета 1 как приори-
           тет 3. В этом случае ключевые слова приоритета 2 имеют выс-
           ший приоритет.

          Например, в следующем фрагменте кода:

          NAME SEGMENT

     NAME -  это  ключевое  слово  первого  приоритета,  а  SEGMENT  -
     ключевое слово второго приоритета. Таким образом, Турбо Ассемблер
     будет интерпретировать эту строку,  как директиву NAME,  а не как
     директиву SEGMENT. В другом примере:

          MOV INSTR,1

     MOV - ключевое слово приоритета 3, а INSTR - ключевое слово прио-
     ритета 2. Таким образом, Турбо Ассемблер интерпретирует эту стро-
     ку как инструкцию INSTR,  а не как инструкцию MOV (как вы  можете
     предполагать).

            Ключевые слова и предопределенные идентификаторы
     ─────────────────────────────────────────────────────────────────

          В данном разделе приведен полный перечень всех ключевых слов
     Турбо Ассемблера. Значение в скобках после ключевых слов указыва-
     ют их приоритет (1 или 2) в режиме MASM.  Приоритет для  ключевых
     слов указан только, если он имеет значение 1 или 2. Для всех дру-
     гих ключевых слов подразумевается приоритет  3.  Турбо  Ассемблер
     распознает ключевые  слова  только в том случае,  если он находит
     их. В режиме MASM ключевые слова приоритета 1 или 3 всегда  нахо-
     дятся в первой позиции, а ключевые слова приоритета 2 - во второй
     позиции. Символ M после ключевого слово указывает, что оно допус-
     тимо только для режима MASM,  а I показывает ключевое слово, дос-
     тупное только в режиме Ideal.  Если буква не указана, то ключевые
     слова работают в обоих режимах. Номер после ключевого слова пока-
     зывает приоритет.

                     Ключевые слова директив
     ─────────────────────────────────────────────────────────────────

          В следующем  списке  содержатся  все ключевые слова директив
     Турбо Ассемблера.  Ключевые слова группируются по  версиям  Турбо
     Ассемблера, в которых они вводились.

          Следующие ключевые  слова  были  введены  в Турбо Ассемблере
     версии 1.0.

            Ключевые слова Турбо Ассемблера 1.0 (VERSION T100)
                                                           Таблица B.1
     ┌───────────────────────────────────────────────────────────────┐
     │    % (1)             %NOLIST           JZ             SETNLE  │
     │    .186 (M)          NOLOCALS          LAHF           SETNO   │
     │    .286 (M)          NOMASM51          LDS            SETNP   │

     Турбо Ассемблер 3.0/tasm/#2-2                             = 164 =

     │    .286C (M)         %NOMACS           LEA            SETNS   │
     │    .286P (M)         NOMULTERRS        LES            SETNZ   │
     │    .287 (M)          NOSMART           LOCK           SETO    │
     │    .386 (M)          %NOSYMS           LODS           SETP    │
     │    .386C (M)         %NOTRUNCS         LODSB          SETPE   │
     │    .386P (M)         NOWARN            LODSW          SETPO   │
     │    .387 (M)          ORG               LOOP           SETS    │
     │    .486 (M)          %OUT (1)          LOOPE          SETZ    │
     │    .486C (M)         P186              LOOPNE         SHLD    │
     │    .486P (M)         P286              LOOPNZ         SHRD    │
     │    .8086 (M)         P286N             LOOPZ          STOSD   │
     │    .8087 (M)         P286P             MOV            LOOPW   │
     │    : (2)             P287              MOVS           LOOPWE  │
     │    = (2)             P286              MOVSB          LOOPWNE │
     │    ALIGN             P386N             MOVSW          LOOPWNZ │
     │    .ALPHA            P386P             MUL            LOOPWZ  │
     │    ARG               P387              NEG            F2XM1   │
     │    ASSUME            P486              NOP            FABS    │
     │    %BI               P486N             NOT            FADD    │
     │    .CODE (M)         P8086             OR             FADDP   │
     │    .CODESEG          P8087             OUT            FBLD    │
     │    COMM (10)         PAGE              POP            FBSTP   │
     │    COMMENT (1)       %PAGESIZE         PUSH           FCHS    │
     │    %CONDS            %PCNT             PUSHF          FCLEX   │
     │    CONST             PNO87             RCL            FCOM    │
     │    .CONST (M)        %POPLCTL          RCR            FCOMP   │
     │    .CREF (M)         PROC (2)          REP            FCOMPP  │
     │    %CREF             %PUSHLCTL         REPE           FCOS    │
     │    %CREFALL          PUBLIC (1)        REPNE          FDECSTP │
     │    %CREFREF          PURGE             REPNZ          FDISI   │
     │    %CREFUREF         QUIRKS            REPZ           FDIV    │
     │    %CTLS             .RADIX (M)        RET            FDIVP   │
     │    .DATA (M)         RADIX             RETF           FDIVR   │
     │    .DATA? (M)        RECORD (2)        RETN           FDIVRP  │
     │    DATASEG           REPT (1)          ROL            FENI    │
     │    DB                .SALL (M)         ROL            FFREE   │
     │    DD                SEGMENT (2)       SAHF           FIADD   │
     │    %DEPTH            .SEQ (M)          SAL            FICOM   │
     │    DF (2)            .SFCOND (M)       SAR            FICOMP  │
     │    DISPLAY           SMART             SBB            FIDIV   │
     │    DOSSEG            .STACK (M)        SCAS           FIDIVR  │
     │    DP (2)            .STARTUP (M)      SCASB          FILD    │
     │    DQ (2)            STRUC (2)         SCASW          FIMUL   │
     │    DT (2)            SUBTTL (1)        SHL            FINCSTP │
     │    DW (2)            %SUBTTL [Р        SHR            FINIT   │
     │    ELSE (1)          %SYMS             STC            FIST    │
     │    ELSEIF (1)        %TABSIZE          STD            FISTP   │
     │    ELSEIF1 (1)       %TEXT             STI            FISUB   │
     │    ELSEIF2 (1)       .TFCOND (M)       STOS           FISUBR  │
     │    ELSEIFB (1)       TITLE (1)         STOSB          FLD     │
     │    ELSEIFDEF (1)     %TITLE            STOSW          FLDCTW  │
     │    ELSEIFDIF (1)     %TRUNC            SUB            FLDENV  │
     │    ELSEIFDIFI (1)    UDATASEG          TEST           FLDLG2  │

     Турбо Ассемблер 3.0/tasm/#2-2                             = 165 =

     │    ELSEIFE (1)       UFARDATA          WAIT           FLDLN2  │
     │    ELSEIFIDN (1)     UNION (2)         WBINV          FLDL2E  │
     │    ELSEIFIDNI (1)    USES              XCHG           FLDL2T  │
     │    ELSEIFNB (1)      WARN              XLAT           FLDPI   │
     │    ELSEIFNDEF (1)    .XALL (M)         XLATB          FLDZ    │
     │    EMUL              .XCREF (M)        SOR            FMUL    │
     │    END               .XLIST (M)        BOUND          FMULP   │
     │    ENDIF (1)         USECS             ENTER          FNCLEX  │
     │    ENDM              USEDS             INS            FNDSI   │
     │    ENDP (2)          USESS             INSB           FNENI   │
     │    ENDS (2)          USEES             INSW           FNINIT  │
     │    EQU (2)           USEFS             LEAVE          FNOP    │
     │    .ERR (1) (M)      USEFS             OUTS           FNSAVE  │
     │    ERR               CATSTR (2)        OUTSB          FNSTCW  │
     │    .ERR1 (1) (M)     INSTR (2)         OUTSW          FNSTENV │
     │    .ERR2 (1) (M)     SIZESTR (2)       POPA           FNSTSW  │
     │    .ERRB (1) (M)     SUBSTR (2)        PUSHA          FPATAN  │
     │    .ERRDEF (1) (M)   AAA               ARPL           FPREM   │
     │    .ERRDIF (1) (M)   AAD               CTLS           FPTAN   │
     │    .ERRDIFI (1) (M)  AAM               LAR            FRNDINT │
     │    .ERRE (1) (M)     AAS               LGDT           FRSTOR  │
     │    .ERRIDN (1) (M)   ADC               LIDT           FSAVE   │
     │    ERRIF             ADD               LLDT           FSCALE  │
     │    .ERRDIF (1) (M)   AND               LMSW           FSQRT   │
     │    .ERRDIFI (1) (M)  ARPL              LSL            FST     │
     │    .ERRE (1) (M)     BSF               LTR            FSTCW   │
     │    .ERRIDN (1) (M)   BSR               SGDT           FSTENV  │
     │    ERRIF             BSWAP             SIDT           FSTP    │
     │    ERRIF1            BT                SLDT           FSTSW   │
     │    ERRIF2            BTC               SMSW           FSTSW   │
     │    ERRIFB            BT                STR            FSUB    │
     │    ERRIFDEF          BTR               VERR           FSUBP   │
     │    ERRIFDIF          BTS               VERW           FSUBR   │
     │    ERRIFDIFI         CALL              BSF            FSUBRP  │
     │    ERRIFE            CBW               BSR            FTST    │
     │    ERRIFDIDN         CDQ               BT             FUCOM   │
     │    ERRIFDIDNI        CLC               BTC            FUCOMP  │
     │    ERRIFNB           CLD               BTR            FUCOMPP │
     │    ERRIFNDEF         CLI               BTS            FWAIT   │
     │    .ERRIFNB (1) (M)  CLTS              CDQ            FXAM    │
     │    .ERRIFDEF (1) (M) CMC               CMPSD          FXCH    │
     │    .ERRNZ (1) (M)    CMP               CWDE           FXTRACT │
     │    .EVEN             CMPS              INSD           FYL2X   │
     │    EVENDATA          CMPS              IRETD          FYL2XP1 │
     │    EXITM             CMPXCHG           IJECXZ         FSETPM  │
     │    EXTRN (1)         CWD               LPS            FPCOS   │
     │    .FARDATA          CWDE              LGS            FPREM1  │
     │    FARDATA           DAA               LODSD          FPSIN   │
     │    .FARDATA (M)      DAS               LOOPD          FPSINCOS│
     │    .FARDATA? (M)     DEC               LOOPDE         FUCOM   │
     │    GLOBAL (1)        DIV               LOOPDNE        FUCOMP  │
     │    GROUP (2)         ESC               LOOPDNZ        FUCOMPP │
     │    %INCL             HLT               LOOPDZ                 │

     Турбо Ассемблер 3.0/tasm/#2-2                             = 166 =

     │    IDEAL             IDIV              LSS                    │
     │    IF (1)            IMUL              MOVSD                  │
     │    IF1 (1)           IN                MOVSX                  │
     │    IF2 (1)           INC               MOVZX                  │
     │    IFb (1)           INS               OUTSD                  │
     │    IFDEF (1)         INT               POPAD                  │
     │    IFDIFI (1)        INVO              POPFD                  │
     │    IFE (1)           IRET              PUSHAD                 │
     │    IFIDN (1)         JA                PUSHFD                 │
     │    FIDNI (1)         JAE               SCASD                  │
     │    IFNB (1)          JB                SETA                   │
     │    IFNDEF (1)        JBT               SETAE                  │
     │    %INCTL (1)        JCXZ              SETB                   │
     │    INCLUD (1)        JE                SETBE                  │
     │    INCLUDELIB (1)    JG                SETC                   │
     │    IRP (1)           JGT               OUTSD                  │
     │    IRPC (1)          JL                POPAD                  │
     │    JUMPS             JLE               POPFD                  │
     │    LABEL (2)         JNA               PUSHAD                 │
     │    .LALL (M)         JNAE              PUSHFD                 │
     │    .LFCOND (M)       JNB               SCASD                  │
     │    %LINUM            JNBE              SETA                   │
     │    %LIST             JNC               SETAE                  │
     │    .LIST (M)         JNE               SETB                   │
     │    LOCAL             JNG               SETBE                  │
     │    LOCALS            JNGE              SETC                   │
     │    MASM              JNL               SETE                   │
     │    %MACS             JNLE              SETG                   │
     │    MACRO (2)         JNO               SETGE                  │
     │    MODEL             JNP               SETL                   │
     │    .MODEL (M)        JNC               SETLE                  │
     │    MULTERRS          JNP               SETNA                  │
     │    NAME (1)          JNS               SETNAE                 │
     │    %NEWPAGE          JNZ               SETNB                  │
     │    %NOCONDS          JO                SETNBE                 │
     │    %NNOCREF          JP                SETNC                  │
     │    %NOCTLS           JPE               SETNE                  │
     │    NOEMUL            JPO               SETNG                  │
     │    %NOINCL           JS                SETNGE                 │
     │    NOJUMPS           JUMP              SETNL                  │
     └───────────────────────────────────────────────────────────────┘

          В Турбо Ассемблере версии 2.0  поддерживаются  все  ключевые
     слова версии 1.0 со следующими дополнениями:

       Новые ключевые слова Турбо Ассемблера версии 2.0 (VERSION T200)
                                                           Таблица B.2
     ┌───────────────────────────────────────────────────────────────┐
     │   BSWAP              P486              STARTUPCODE            │
     │   CMPXCHG            P486N             WBINVD                 │
     │   INVD               PUBLICDLL(I)      XADD                   │
     │   INVLPG             RETCODE                                  │
     └───────────────────────────────────────────────────────────────┘

     Турбо Ассемблер 3.0/tasm/#2-2                             = 167 =


          В Турбо Ассемблере версии 2.5  поддерживаются  все  ключевые
     слова версии 2.0 со следующими дополнениями:

       Новые ключевые слова Турбо Ассемблера версии 2.5 (VERSION T250)
                                                           Таблица B.3
     ┌───────────────────────────────────────────────────────────────┐
     │  ENTERD              LEAVED                                   │
     │  ENTERW              LEAVEW                                   │
     └───────────────────────────────────────────────────────────────┘

          В Турбо Ассемблере версии 3.0  поддерживаются  все  ключевые
     слова версии 2.5 со следующими дополнениями:

       Новые ключевые слова Турбо Ассемблера версии 3.0 (VERSION T200)
                                                           Таблица B.4
     ┌───────────────────────────────────────────────────────────────┐
     │  CLRFLAG             LARGESTACK        TBLINIT                │
     │  ENUM(2)             SETFIELD          TBLINST                │
     │  FASTIMUL            SETFLAG           TBLPTR                 │
     │  FLIPFLAG            SMALLSTACK        TESTFLAG               │
     │  GETFIELD            TABLE(2)          VERSION                │
     │  GOTO(1)                               WHILE(1)               │
     └───────────────────────────────────────────────────────────────┘




     Турбо Ассемблер 3.0/tasm/#2-2                             = 168 =

                   Приложение C. Вопросы совместимости
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер в режиме MASM в высокой степени  совместим с
     ассемблером MASM версии 5.2. Однако стопроцентная совместимость -
     это идеал,  к которому можно только стремиться,  т.к.  формальная
     спецификация  языка отсутствует,  и даже различные версии MASM не
     полностью совместимы друг с другом.

          Для большинства программ замена MASM на Турбо  Ассемблер  не
     повлечет  за  собой каких-либо осложнений.  В некоторых случаях в
     Турбо Ассемблере появятся предупреждающие сообщения  и  сообщения
     об ошибках там,  где их в MASM не было,  что обычно означает, что
     ошибочный оператор не был выявлен макроассемблером  MASM.  Напри-
     мер, MASM не обнаруживает ошибок в следующих операторах:

               abc  EQU  [BP+2]
                    PUBLIC  abc

     и генерирует бессмысленный объектный код.  В Турбо Ассемблере по-
     добная конструкция, а также ряд других двусмысленных конструкций,
     будут идентифицированы как ошибочные.

          Если при ассемблировании программы  пользователя  с  помощью
     Турбо Ассемблера возникнут какие-либо затруднения, то можно попы-
     таться использовать директиву QUIRKS.  Например,  если с  помощью
     следующей командной строки:

               TASM /JQUIRKS  MYFILE

     программа будет  ассемблирована правильно,  то следует добавить в
     начало исходного файла директиву  QUIRKS.  Еще  лучше,  используя
     сведения из этого приложения,  определить операторы,  для которых
     требуется директива QUIRKS, и после этого переписать соответству-
     ющие  строки исходного файла так,  чтобы отпала необходимость ис-
     пользования директивы QUIRKS.

          Для максимальной совместимости с MASM  следует  использовать
     директиву NOSMART и режим QUIRKS.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 169 =

              Одно- и двухпроходные режимы ассемблирования
     ─────────────────────────────────────────────────────────────────

          В стандартном режиме Турбо Ассемблер выполняет ассемблирова-
     ние  за один проход,  а MASM - за два прохода.  Поэтому Турбо Ас-
     семблер - более быстрый ассемблер по сравнению с MASM. Однако од-
     нопроходность  Турбо  Ассемблера может  привести  к некоторой его
     несовместимости с MASM при разрешении ссылок вперед  и  обработке
     конструкций, зависящих  от  прохода.  В TASM имеется параметр ко-
     мандной строки (/m), с помощью которого можно задать число прохо-
     дов.  Если требуется обеспечить максимум совместимости с MASM, то
     нужно указать двухпроходный режим (/m2). (См. Главу 2, где данный
     параметр обсуждается более подробно.)

          Использование данного параметра командной строки будет гене-
     рировать режим,  совместимый с MASM (два прохода), когда присутс-
     твуют следующие конструкции:

          - директивы IF1 и IF2;

          - директивы ERR1 и ERR2;

          - ссылки вперед с IFDEF и IFNDEF;

          - опережающие ссылки с операцией .TYPE;

          - рекурсивно определенные числа, такие, как

                   NMBR=NMBR+1;

          - рекурсивно определенные текстовые макрокоманды или тексто-
            вые макрокоманды,  на которые имеются опережающие  ссылки,
            такие, как:

                  LNAME   CATSTR   LNAME,<1>

          - макрокоманды, на которые имеются опережающие ссылки.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 170 =

                     Переменные операционной среды
     ─────────────────────────────────────────────────────────────────

          В Турбо Ассемблере не используются переменные среды для  оп-
     ределения параметров, используемых по умолчанию, что отвечает об-
     щему подходу фирмы Borland,  используемому при создании программ-
     ных продуктов. Вместо этого параметры, используемые по умолчанию,
     следует помещать в файл конфигурации,  и для  различных  проектов
     создавать соответствующие им файлы конфигурации.

          Если при  использовании MASM для конфигурирования нужным об-
     разом системы  использовались   переменные   операционной   среды
     INCLUDE  или MASM,  то для использования той же программы с Турбо
     Ассемблером нужно создать файл конфигурации.  Все  те  параметры,
     которые  были  специфицированы,  используя переменную среды MASM,
     нужно поместить непосредственно в  файл  конфигурации.  Каталоги,
     указанные  переменной  INCLUDE,  помещаются в файл конфигурации с
     помощью параметра /I командной строки.

      Формат фирмы Microsoft для двоичных чисел с плавающей точкой
     ─────────────────────────────────────────────────────────────────

          В ранних  версиях макроассемблера MASM для чисел с плавающей
     точкой по умолчанию использовался формат,  несовместимый с форма-
     том  для  чисел с плавающей точкой стандарта IEEE.  В MASM версии
     5.1 числа с плавающей точкой генерируются в формате IEEE, но име-
     ется директива .MSFLOAT,  с помощью которой можно специфицировать
     использование ранее использовавшегося формата фирмы Microsoft.

          В Турбо Ассемблере не поддерживается старый формат  чисел  с
     плавающей точкой и, следовательно, .MSFLOAT является для него не-
     допустимой директивой.




     Турбо Ассемблер 3.0/tasm/#2-2                             = 171 =

                   Приложение D. Утилиты Турбо Ассемблера
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер TASM предоставляет вам семь мощных  автоном-
     ных  утилит.  Вы можете использовать их для файлов TASM,  а также
     для любых других файлов.

          Это такие утилиты, как:

          ■ MAKE (включая утилиту  TOUCH;  автономный  менеджер  прог-
            рамм);

          ■ TLINK (компоновщик);

          ■ TLIB (библиотекарь);

          ■ TASMHELP (оперативный справочник);

          ■ GREP (утилита поиска текста в файлах);

          ■ OBJXREF  (утилита  для  работы  с перекрестными ссылками в
            объектных модулях);

          ■ TCREF (утилита для работы с перекрестными ссылками);

          ■ H2ASH (утилита-преобразователь файлов .h в файл .ash).

          Подробности об  использовании  утилит  MAKE,  TOUCH,  TLINK,
     GREP, OBJXREF,  TASMHELP,  H2ASH  можно  узнать в документации по
     компилятору. TASMHELP работает аналогично утилите THELP, описание
     которой также  можно найти в документации по компилятору.  О том,
     как использовать утилиту TCREF в текстовых файлах,  можно  узнать
     файлах документации  на  дисках  Турбо Ассемблера.  Утилита H2ASH
     также описывается в файлах на дисках Турбо  Ассемблера,  но  пос-
     кольку это новая утилита,  мы подробнее коснемся ее в данном при-
     ложении.

                     Утилита-преобразователь H2ASH
     ─────────────────────────────────────────────────────────────────

          Модули Си  и С++ в программе обычно совместно используют оп-
     ределение типов  и  структур  данных.  Это  делается  с   помощью
     включения небольших файлов (файлов-заголовков),  которые содержат
     определения типов и структуры данных,  используемые в  нескольких
     модулях.  Файл  заголовка в Си/С++ имеет обычно имя с расширением
     .H. Ассемблируемые модули обычно имеют файлы заголовков с расшире-
     нием .ASH (или .INC).

          Программы, содержащие модули,  написанные на Си/С++ и модули
     Турбо Ассемблера,  должны иметь возможность совместного определе-
     ния типов и структур данных. Этому способствует утилита H2ASH.

          Утилита H2ASH  преобразует  файлы  заголовков Си/С++ в файлы

     Турбо Ассемблер 3.0/tasm/#2-2                             = 172 =

     заголовков  языка  Ассемблера. Как и исходные файлы с расширением
     .H полученные  в  результате файлы с расширением .ASH сами не со-
     держат программу.  Если для вызова H2ASH вы используете следующий
     синтаксис:

          H2ASH [[параметры] <имя_файла> [<имя_файла> ...]]

     где каждое  поле "имя_файла" задает имя конвертируемого файла за-
     головка. Утилита H2ASH предполагает, что преобразуемый файл имеет
     по умолчанию расширение .H. Для каждого обрабатываемого файла со-
     ответствующий выходной файл имеет расширение .ASH.

          "Параметры" соответствуют параметрам командной строки компи-
     лятора Borland  C++,  а  также  специфическим  параметрам утилиты
     H2ASH (которые соответствуют параметрам -q Турбо Ассемблера). См.
     "Руководство пользователя  Bоrland C++" и оперативный справочник,
     где можно найти описания данных параметров.

          Утилита H2ASH преобразует следующие конструкции:

          - все основные типы языка Си;

          - типы ENUM (в типы ENUM TASM);

          - #IFDEF (в эквивалентные IFDEF Ассемблера);

          - #DEFINE (в определения EQU);

          - структуры и объединения (в структуры и  объединения  Турбо
            Ассемблера);

          - структуры с битовыми полями (в записи Ассемблера RECORD);

          - определения TYPEDEF (в TYPEDEF Ассемблера);

          - классы  без  множественного наследования и без виртуальных
            базовых классов;

          - элементы классов;

          - переопределения операций.

          Утилита-преобразователь имеет следующие ограничения:

          - весь преобразуемый код игнорируется,  выполняемый  код  не
            генерируется;

          - директивы #INCLUDE в выходных файлах полностью расширяются;

          - в  выводе  Ассемблера может возникнуть конфликт имен,  так
            как правила области действия С++ существенно отличаются от
            правил Ассемблера (помочь здесь может использование режима
            Ideal);

     Турбо Ассемблер 3.0/tasm/#2-2                             = 173 =


          Преобразователь H2ASH не только облегчает организацию интер-
     фейса между  С/С++ и языком Ассемблера (с максимальной производи-
     тельностью). H2ASH  автоматически  преобразует  описания  базовых
     классов С++ в эквивалентные объектные описания Ассемблера и опре-
     деляет "нескорректированные" имена методов.  При записи  базового
     класса на языке Ассемблера мы рекомендуем вам использовать следу-
     ющую процедуру:

          1. Написать описание класса в файле заголовка языка Си.

          2. Включить описание файла заголовка Си во все классы-потом-
             ки и модули на языке Си,  которые используют этот базовый
             класс.

          3. Используйте преобразователь H2ASH для файла  заголовка  с
             целью получения  объектного  файла  заголовка  Ассемблера
             (этот процесс можно автоматизировать с помощью  формирую-
             щего файла).

          4. Включите  объектный  файл  заголовка Ассемблера в модуль,
             где записаны методы на языке Ассемблера.

          Более подробную информацию об утилите H2ASH  можно  найти  в
     текстовых файлах документации на дисках Турбо Ассемблера.




     Турбо Ассемблер 3.0/tasm/#2-2                             = 174 =

                   Приложение E. Сообщения об ошибках
     ─────────────────────────────────────────────────────────────────

          В данном приложении описаны все сообщения, генерируемые Тур-
     бо  Ассемблером.  Обычно  сообщения выдаются на экран,  однако их
     можно переадресовать в файл или на принтер с  помощью стандартных
     средств DOS переадресации потоков, т.е. надо указать имя устройс-
     тва или файла с предшествующим ему  символом  "больше  чем"  (>).
     Например:

                     TASM MYFILE > ERRORS

          В Турбо Ассемблере генерируются сообщения следующих типов:

          - информационные сообщения;
          - предупреждающие сообщения;
          - сообщения об ошибках;
          - сообщения о фатальных ошибках.

                        Информационные сообщения
     ─────────────────────────────────────────────────────────────────

          Турбо Ассемблер обычно выводит два информационных сообщения.
     Во-первых,  всегда выдается информационное  сообщение  непосредс-
     твенно  перед началом ассемблирования пользовательского исходного
     файла (или файлов). Кроме того, выдается информационное сообщение
     по окончании ассемблирования каждого файла. Пример информационно-
     го сообщения, выдаваемого при запуске Турбо Ассемблера:

     Turbo Assembler Version 3.0 Copyright(C) 1991 Borland
                              International Assembling file: TEST.ASM


     Турбо Ассемблер 3.0/tasm/#2-2                             = 175 =

     (Турбо Ассемблер, версия 3.0, продукт фирмы Borland, 1991г.)

          По окончании  ассемблирования исходного файла выдается сооб-
     щение с краткой характеристикой процесса ассемблирования. Это со-
     общение выглядит следующим образом:

             Error messages: None
             Warning messages: None
             Passes: 1
             Remaining memory: 279K

             (Сообщения об ошибках: Нет
             Проходов: 1
             Предупреждающие сообщения: Нет
             Осталось памяти: 279Кб)

          Подавить все  информационные сообщения можно с помощью пара-
     метра командной строки /T.  Информационные сообщения  подавляются
     только в случае отсутствия ошибок в процессе ассемблирования. При
     наличии ошибок параметр /T никакого влияния не имеет: стандартные
     информационные сообщения будут выданы в начале и в конце процесса
     ассемблирования.



     Турбо Ассемблер 3.0/tasm/#2-2                             = 176 =

            Предупреждающие сообщения и сообщения об ошибках
     ─────────────────────────────────────────────────────────────────

          Предупреждающие сообщения  выдаются для информирования поль-
     зователей о возможных нежелательных  последствиях ассемблирования
     оператора  исходного  файла.  Предупреждающее сообщение выдается,
     например,  в тех случаях, когда использование Turbo Assembler ка-
     кого-либо,  вообще говоря, допустимого умолчания может привести к
     некорректным результатам. Рекомендуется обязательно проанализиро-
     вать причины предупреждающих сообщений,  чтобы не допустить гене-
     рации неверного кода. Наличие этих сообщений не влияет на генера-
     цию  объектного  кода Turbo Assembler.  Предупреждающие сообщения
     имеют следующий формат:

                 **Warning** имя_файла(номер_строки) сообщение

          Если предупреждающее сообщение выдается во  время расширения
     макрокоманды или блока повторения,  то оно будет содержать допол-
     нительную информацию:  имя макрокоманды и номер строки,  при  ас-
     семблировании которой возникло это сообщение. Предупреждающее со-
     общение в этом случае имеет следующий формат:

           **Warning** имя_файла(номер_строки)
                имя_макрокоманды(номер_строки_в_макрокоманде)сообщение

          В отличие от предупреждающих сообщений,  появление сообщений
     об ошибках означает,  что объектный код Турбо Ассемблер генериро-
     вать не будет, хотя процесс ассемблирования будет доведен до кон-
     ца. Типичное сообщение об ошибке имеет следующий формат:

                 **Error** имя_файла(номер_строки) сообщение

          Если сообщение об ошибке выдается во время расширения макро-
     са  или блока повтора,  то оно будет содержать дополнительную ин-
     формацию: имя макрокоманды и номер  строки,  при  ассемблировании
     которой возникло это сообщение. Сообщение об ошибке в этом случае
     имеет следующий формат:

             **Error** имя_файла(номер_строки)
                имя_макрокоманды(номер_строки_в_макрокоманде)сообщение

          Далее в алфавитном порядке приводятся тексты предупредитель-
     ных сообщений и сообщений об ошибках:

         32-bit segment not allowed without .386
           (32-битовые флаги без директивы .386 не допускаются)

          Это средство расширено.  Теперь в операторе .MODEL можно за-
     давать USE32 и LARGESTACK.  Ранее это было сообщение  "USE32  not
     allowed without .386").

         Argument needs type override
          (Требуется явно указать тип операнда)

     Турбо Ассемблер 3.0/tasm/#2-2                             = 177 =


          Требуется явно указать размер,  или тип,  выражения, т.к. он
     не может быть определен из контекста. Например, ошибочной являет-
     ся следующая команда:

            mov [bx],1

          Ошибки такого  рода обычно корректируются с помощью операции
     PTR, позволяющей установить размер операнда:

           mov WORD PTR[bx],1

         Argument to operation or instruction has illegal size
          (Операнд операции или команды имеет недопустимый размер)

          В операции  указан  операнд,  имеющий тип,  недопустимый для
     данной операции. Например:

           Q LABEL QWORD
           QNOT = NOT Q ; операнд операции отрицания не может
                        ; иметь тип QWORD

         Arithmetic overflow
          (Арифметическое переполнение)

          Потеря значащих цифр при вычислении значения выражения. Нап-
     ример:

           X = 20000h * 20000h ; результат занимает более 32 бит

          Точность всех арифметических операций - 32 бита.

         ASSUME must be segment register
          (В директиве ASSUME должен быть указан сегментный регистр)

          В директиве ASSUME можно указывать только сегментные регист-
     ры, во всех остальных случаях выводится данное сообщение об ошиб-
     ке. Например, ошибочной является директива:

            ASSUME ax:CODE

         Bad keyword in SEGMENT statement
          (Неверное ключевое слово в операторе SEGMENT)

          Один из параметров директивы SEGMENT:  тип выравнивания, тип
     объединения или тип сегмента имеет недопустимое значение.  Напри-
     мер:

           DATA SEGMENT PAFA PUBLIC ; вместо PARA указано PAFA

         Can't add relative quantities
          (Нельзя складывать относительные адреса)


     Турбо Ассемблер 3.0/tasm/#2-2                             = 178 =

          Выражение содержит операцию сложения двух адресов, что явля-
     ется бессмысленной операцией. Например:

           ABC   DB  ?
           DEF   =  ABC  +  ABC  ; ошибка: нельзя складывать
                                 ; два относительные адреса

          Можно вычитать относительные адреса. Можно добавить констан-
     ту к относительному адресу, например:

           XYZ DB 5 DUP(0)
           XYZEND EQU $
           XYZLEN = SYZEND - XYZ    ; совершенно верно
           XYZ2 = XYZ + 2           ; тоже верно

         Can't address with currently ASSUMEd segment registers
          (Невозможна адресация  из текущих,  установленных директивой
          ASSUME, сегментных регистров)

          В выражении содержится ссылка на переменную,  для доступа  к
     которой не специфицирован сегментный регистр. Например:

          DSEG SEGMENT
          ASSUME ds:DSEG
          mov si,MPTR ; не определен сегментный регистр, который
                      ; обеспечил бы доступ к сегменту XSEG
          DSEG ENDS
          XSEG SEGMENT
          MPTR DW ?
          XSEG ENDS

         Can't convert to pointer
          (Невозможно преобразование в указатель)

          Часть выражения  не  может быть преобразована в указатель на
     память,  например, с помощью операции PTR:

               mov cl,[BYTE PTR al] ; AL нельзя преобразовать
                                    ; в указатель

         Can't emulate 8087 instruction
          (Невозможна эмуляция команд сопроцессора 8087)

          В Турбо Ассемблере параметром командной строки /E либо с по-
     мощью директивы EMUL установлен режим генерации эмулированных ко-
     манд арифметики с плавающей точкой, однако текущая команда не мо-
     жет быть эмулирована. Например:

           EMUL
           FNSAVE [WPTR]  ; эта команда не может быть эмулирована

          Некоторые команды не поддерживаются эмуляторами арифметики с
     плавающей точкой.  Это команды FNSAVE, FNSTCW, FNSTENV и FNSTSW.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 179 =


         Can't make variable public
          (Переменная не может быть объявлена как PUBLIC)

          Переменная была  уже ранее объявлена таким образом,  что уже
     не может быть определена как общая (PUBLIC). Например:

          EXTRN ABC:NEAR
          PUBLIC ABC    ; ошибка: ABC уже ранее объявлена
                        ; с атрибутом EXTRN

         Can't override ES segment
          (Нельзя переопределить сегмент ES)

          В текущем операторе указан регистр, использование которого в
     данной команде недопустимо. Например:

          STOS DS:BYTE PTR[di]

          В команде  STOS  для определения целевого адреса допускается
     использовать только регистр ES.

         Can't subtract dissimilar relative quantities
          (Недопустимое вычитание относительных адресов)

          Выражение содержит операцию вычитания двух  адресов, которая
     для данных адресов является недопустимой.  Данное сообщение выда-
     ется, например, в том случае, если адреса находятся в разных сег-
     ментах. Например:

          SEG1
          SEGMENT
       A: SEG1
          ENDS
          SEG2
          SEGMENT B:
          mov ax,B-A ; недопустимо, поскольку A и В находятся
                     ; в разных сегментах
          SEG2 ENDS

         Can't use macro name in expression
          (Недопустимо использование  имени  макрокоманды  в  качестве
          операнда выражения)

          Имя макрокоманды указано в качестве операнда выражения. Нап-
     ример:

          MyMac MACRO
            ENDM
            mov ax,MyMac   ; ошибка!

         Can't use this outside macro
          (Использование данного  оператора недопустимо вне макроопре-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 180 =

          деления)

          Вне макроопределения указана директива,  которую допускается
     использовать  только внутри макроопределений.  К таким директивам
     относятся, например, ENDM и EXITM. Например:

          DATA SEGMENT
            ENDM  ; ошибка: вне макроопределения недопустимо

         Code or data emission to undeclared segment
          (Не объявлен сегмент для кода или данных)

          Оператор, генерирующий код или данные, не принадлежит ни од-
     ному из сегментов, объявленных директивами SEGMENT. Например:

          ; Первая строка файла
            inc bx   ; ошибка: не определен сегмент
            END

          Генерировать данные  или код можно только внутри какого-либо
     сегмента.

         Constant assumed to mean Immediate const
          (Константа интерпретируется как непосредственная)

          Это предупреждающе  сообщение  выдается  для  выражений типа
     [0].  В режиме MASM это выражение интерпретируется как непосредс-
     твенная константа, равная 0. Например:

          mov ax,[0]; означает mov ax,0, а не mov ax,ds:[0]

         Constant too large
          (Слишком большая константа)

          Константа имеет, вообще говоря, правильный формат, однако ее
     значение превышает допустимую для данного режима величину. Напри-
     мер,  числа,  большие 0ffffh, можно использовать, если только ди-
     рективой  .386/.386P  или .486/.486Р разрешены команды процессора
     386 или i486.

         CS not correctly assumed
          (Некорректное значение в регистре CS)

          Адрес назначения в командах ближнего вызова и ближнего пере-
     хода не может находиться в другом сегменте. Например:

           SEG1 SEGMENT
           LAB1 LABEL NEAR
           SEG1 ENDS
           SEG2 SEGMENT
           JMP  LAB1   ; ошибка: неверный сегментный адрес
           SEG2 ENDS


     Турбо Ассемблер 3.0/tasm/#2-2                             = 181 =

          Такие ошибки возникают только в режиме MASM.  В режиме Ideal
     такие переходы и вызовы интерпретируются корректно.

         CS override in protected mode
          (Переопределение регистра CS в защищенном режиме)

          В защищенном  режиме  ассемблирования команд процессора 286,
     386 или i486,  установленном директивой Р286Р, P386P или Р486Р, в
     текущей  команде требуется переопределение регистра CS. Например:

          P286
          .CODE
     CVAL DW ?
          mov CVAL,1 ; генерирует переопределение регистра CS

          Это предупреждающее сообщение  выдается,  если  в  командной
     строке указан параметр /Р. В защищенном режиме команды, в которых
     переопределяется регистр CS, не будут выполняться без специальных
     подготовительных операций.

         CS unreachable from current segment
          (CS недостижим из текущего сегмента)

          При определении метки кода с помощью двоеточия (:) или с по-
     мощью  директив LABEL или PROC сегментный регистр не указывает на
     текущий кодовый сегмент или группу,  содержащую  текущий  кодовый
     сегмент. Например:

          PROG1  SEGMENT
              ASSUME CS:PROG2
          START:    ; ошибка: неверно установлен регистр CS

          Такие ошибки возникают только в режиме MASM.  В режиме Ideal
     такие переходы и вызовы обрабатываются корректно.

         Declaration needs name
          (В директиве объявления не указано имя)

          Не указано имя идентификатора в директиве,  для которой спе-
     цификация имени является обязательной. Например:

            PROC ; ошибка: в директиве PROC указание имени обязательно
                   ret
            ENDP

          В директивах объявления,  таких как SEGMENT, PROC или STRUC,
     обязательно должно быть указано имя идентификатора. В режиме MASM
     имя указывается перед именем директивы,  а в режиме Ideal - после
     имени директивы.

         Directive ignored in Turbo Pascal model
          (В режиме TPASCAL директива игнорируется)


     Турбо Ассемблер 3.0/tasm/#2-2                             = 182 =

         В модуле Ассемблера,  предназначенном для интерфейса с  Турбо
     Паскалем, используется недопустимая директива. Режим интерфейса с
     Турбо Паскалем специфицируется директивой .MODEL.  Более подробно
     интерфейс с Турбо Паскалем обсуждается в Главе 19.

         Directive not allowed inside structure definition
          (Недопустимая директива внутри определения структуры)

          Внутри блока определения структуры указана недопустимая  ди-
     ректива. Например:

            X STRUC
            MEM1 DB ?
               ORG $+4   ; ошибка: директиву ORG нельзя указывать
                         ; внутри структуры
            MEM2 DW ?
            ENDS

          При определении вложенных структур нельзя  определять  новые
     структуры на внутренних уровнях. Например:

           F00 STRUC
              F002 STRUC  ; ошибка: определена новая структура
              ENDS
           ENDS

          Для того  чтобы  использовать  одну  структуру внутри другой
     структуры,  нужно сначала определить первую  структуру,  а  после
     этого во второй структуре можно указывать имя первой.

         Duplicate dummy arguments:_
          (Недопустимо использование  одинаковых  имен  для формальных
          параметров)

          В директиве MACRO определено несколько формальных параметров
     с одинаковыми именами. Например:

           XYZ   MACRO  A,A   ; ошибка: дублируются  имена
                              ; формальных параметров
              DB A
              ENDM

          Все формальные параметры макроопределения должны иметь  раз-
     личные имена.

         ELSE or ENDIF without IF
          (ELSE или ENDIF без IF)

          Для директивы ELSE или ENDIF нет парной директивы IF,  обоз-
     начающей начало условно ассемблируемого блока. Например:

          BUF DB 10 DUP(?)
            ENDIF   ; ошибка: нет парной директивы IFxxx

     Турбо Ассемблер 3.0/tasm/#2-2                             = 183 =


         Expecting METHOD keyword
          (Требуется ключевое слово METHOD)

          В расширенном структурном операторе для определения объектов
     после порождающего объекта требуется ключевое слово METHOD.

         Expecting offset quantity
          (Требуется  указать величину смещения)

          В качестве  операнда  выражения  указано  неверное  значение
     вместо ожидаемого смещения внутри сегмента. Например:

          CODE SEGMENT
            mov ax,LOW CODE
          CODE ENDS

         Expecting offset or pointer quantity
          (Требуется  указать смещение или указатель)

          В качестве  операнда  выражения  указано  неверное  значение
     вместо  ожидаемого  смещения  внутри специфицированного сегмента.
     Например:

           CODE SEGMENT
              mov ax,SEG CODE  ; ошибка: СODE - это сегмент,
                               ; а не адрес внутри сегмента
           CODE ENDS

         Expecting pointer type
          (Операнд должен быть указателем)

          Операндом текущей  команды должен быть адрес памяти.  Напри-
     мер:

          LES di,4 ; неверно, т.к. 4 - константа

         Expecting record field name
          (Требуется имя поля записи)

          Вы использовали  инструкцию SETFIELD или GETFIELD без после-
     дующего имени поля.

         Expecting register ID
          (Требуется идентификатор регистра)

          В части USES оператору CALL...METHOD требуются имена регист-
     ров.

         Expecting scalar type
          (Операнд должен быть константой)

          Операндом текущей команды должна быть константа. Например:

     Турбо Ассемблер 3.0/tasm/#2-2                             = 184 =


          BB  DB  4
            rol ax,BB   ; ошибка: вторым операндом операции ROL
                        ; должна быть константа

         Expecting segment or group quantity
          (Должно быть указано имя сегмента или группы)

          В операторе вместо имени сегмента или  группы  указано  имя,
     которое таковым не является. Например:

              DATA SEGMENT
                 ASSUME ds:F00  ; ошибка: F00 не является именем
                                ; сегмента или группы
              F00 DW 0
              DATA ENDS

         Extra characters on line
          (Лишние символы в строке)

          Выражение имеет корректный синтаксис,  однако вслед за  ним,
     на той же строке имеются еще лишние символы. Например:

           ABC = 4 shl 3   3   ; нет знака операции
                               ; между двумя тройками

          Данная ошибка обычно является следствием  другой  ошибки,  в
     результате которой анализатор выражений преждевременно заканчива-
     ет обработку выражения.

         Forward reference needs override
          (Ошибка при использовании умолчания для ссылки вперед)

          В результате  использования умолчания для ссылки вперед было
     зарезервировано меньше памяти,  чем это оказалось необходимо. Эта
     ошибка возникает  тогда,  когда имя идентификатора,  по умолчанию
     означающее адрес ближнего перехода или вызова, переопределяется в
     программе  как  дальний  адрес.  Эта ошибка возникает также в тех
     случаях,  когда не указан сегмент (отличный от предполагаемого по
     умолчанию) для доступа к переменной. Например:

           ASSUME cs:DATA
           call A         ; по умолчанию - ближний вызов
        A PROC FAR        ; а здесь переопределяется как дальний
           mov ax,MEMVAR  ; не известно, что требуется другой сегмент
        DATA  SEGMENT
              MEMVAR DW ? ; здесь ошибка: требуется переопределение

          Эти ошибки исправляются путем явного указания  сегмента  или
     типа перехода FAR.

         Global type doesn't match symbol type
          (Тип, указанный в директиве GLOBAL не совпадает  с  действи-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 185 =

          тельным типом имени идентификатора)

          Это предупреждающее сообщение выдается, если объявление сим-
     волического имени директивой GLOBAL находится в том же самом сег-
     менте, где определяется это имя идентификатора,  однако тип, ука-
     занный в директиве GLOBAL,  не совпадает с  действительным  типом
     этого имени идентификатора.

         ID not member of structure
          (Идентификатор не является полем структуры)

          В режиме Ideal после точки (селектора поля структуры) указа-
     но имя идентификатора, которое не является именем поля структуры.
     Например:

             IDEAL
          STRUC DEMO
             DB ?
          ENDS
          COUNT DW 0
             mov  ax,[(DEMO  bx).COUNT]  ; COUNT  не  является
                                         ; полем структуры

          После точки может быть указано только имя поля той  структу-
     ры, имя которой указано перед точкой.

          Данная ошибка  обычно  является следствием другой ошибки,  в
     результате которой анализатор выражений преждевременно заканчива-
     ет обработку выражения.

         Illegal forward reference
          (Недопустимая ссылка вперед)

          Имя идентификатора, на которое происходит ссылка, еще не бы-
     ло  определено,  а в соответствующей директиве не допускается ис-
     пользовать ссылки вперед. Например:

          IF MYSYM   ; ошибка: MYSYM еще не определена
                     ;
          ENDIF
          MYSYM EQU 1

          Ссылки вперед нельзя использовать в директивах вида IFxxx, а
     также в качестве счетчика выражений в операции DUP.

         Illegal immediate
          (Недопустим непосредственный операнд)

          Команда содержит  непосредственный операнд (т.е.  константу)
     там, где он недопустим. Например:

           mov 4,al


     Турбо Ассемблер 3.0/tasm/#2-2                             = 186 =

         Illegal indexing mode
          (Недопустимый режим индексации)

          Команда содержит операнд, использующий недопустимую комбина-
     цию регистров. Например:

           mov al,[si+ax]

          Для всех процессоров, за исключением 80386, допустимыми ком-
     бинациями индексных регистров являются следующие: BX, BP, SI, DI,
     BX+SI, BX+DI, BP+SI, BP+DI.

         Illegal instruction
          (Недопустимая команда)

          Строка исходной программы начинается с имени идентификатора,
     которое не является ни именем директивы,  ни мнемоникой  команды.
     Например:

          move ax,4  ; должно быть "MOV"

         Illegal instruction for currently selected processor(s)
          (Недопустимая команда для выбранного в настоящий момент про-
          цессора (процессоров))

          Строка программы содержит команду, которая не может быть ас-
     семблирована текущим процессором. Например:

            .8086
          PUSH   1234h   ; занесение в  стек непосредственного
                         ; операнда для  процессора 8086 не
                         ; допускается

          При ассемблировании  исходного файла с помощью Турбо Ассемб-
     лера по умолчанию будут разрешены команды процессора  8086.  Если
     желательно использовать расширенные мнемоники команд,  определен-
     ные для процессоров 186/286/386,  то должна быть указана одна  из
     директив,  разрешающих  использование  этих  команд (Р186,  Р286,
     Р386).

         Illegal local argument
          (Недопустимый локальный параметр)

          В директиве  LOCAL  внутри макроопределения указан параметр,
     не являющийся допустимым именем идентификатора. Например:

          X  MACRO
             LOCAL 123  ; это не идентификатор
             ENDM

         Illegal local symbol prefix
          (Недопустимый префикс для локальных имен идентификаторов)


     Турбо Ассемблер 3.0/tasm/#2-2                             = 187 =

          В директиве  LOCALS специфицируется недопустимый префикс для
     локальных  имен идентификаторов. Например:

          LOCALS XYZ  ; ошибка: допускается только 2 символа

          Префикс локальных  идентификаторов  должен состоять ровно из
     двух символов и представлять собой допустимое имя идентификатора.
     Например,  допустимыми являются следующие комбинации:  __, @@ (по
     умолчанию для локальных имен идентификаторов используется префикс
     @ @).

         Illegal mаcro argument
          (Недопустимый параметр макрокоманды)

          В директиве  MACRO  для  формального  параметра макрокоманды
     указано недопустимое имя идентификатора. Например:

          X  MACRO 123 ; недопустимый формальный параметр
             ENDM

         Illegal memory reference
          (Недопустима ссылка на память)

          Операнд команды содержит ссылку на адрес памяти,  что  недо-
     пустимо для данного операнда. Например:

           mov [bx],BYTE PTR A   ; ошибка: недопустима пересылка
                                 ; из памяти в память

          В данной команде оба операнда представляют собой адреса  па-
     мяти, что недопустимо в команде mov. В командах семейства процес-
     соров 80х86 только один из операндов может ссылаться на адрес па-
     мяти.

         Illegal number
          (Недопустимое число)

          Число содержит один или более символов, недопустимых для чи-
     сел данного формата. Например:

          Z = 0ABCGH

          Здесь G - недопустимый символ для шестнадцатиричных чисел.

         Illegal origin address
          (Недопустимый начальный адрес)

          Указан адрес, недопустимый для установки текущего сегментно-
     го адреса ($).  Допускается указывать константу,  выражение,  ис-
     пользующее счетчика адреса ($), или имя идентификатора из текуще-
     го сегмента.

         Illegal override in structure

     Турбо Ассемблер 3.0/tasm/#2-2                             = 188 =

          (Недопустимое переопределение в структуре)

          Попытка инициализировать элемент структуры,  определенный  с
     помощью операции DUP. Инициализировать можно только те члены, ко-
     торые были объявлены без использования операции DUP.

         Illegal override register
          (Недопустимое переопределение регистра)

          В ссылке  на сегмент перед двоеточием был указан регистр, не
     являющийся сегментным регистром. К сегментным регистрам относятся
     следующие регистры: CS, DS, ES, SS, а также FS и GS для процессо-
     ра 80386. Например:

            mov dx:XYZ,1   ; DX не является сегментным регистром

         Illegal radix
          (Недопустимое основание системы счисления)

          В директиве  .RADIX  в  качестве основания системы счисления
     указано недопустимое число. Например:

          .RADIX 7 ; неверно

          Основанием системы счисления могут быть следующие  числа: 2,
     8, 10 и 16. Это число интерпретируется как десятичное, независимо
     от текущего умолчания для основания системы счисления.

         Illegal register for instruction
          (Недопустимый регистр в инструкции)

          В качестве  источника  в  инструкции SETFIELD и GETFIELD ис-
     пользован недопустимый регистр.

         Illegal register multiplier
          (Недопустимо указание множителя для регистра)

          Попытка умножить  регистр на какое-либо число,  что является
     недопустимой операцией. Например:

          mov ax * 3,1

          Единственный случай, когда допускается умножение регистра на
     константное выражение - это при определении масштабного индексно-
     го операнда для процессора 80386.

         Illegal segment address
          (Недопустимый сегментный адрес)

          Это сообщение об ошибке выдается,  если для позиционирования
     сегмента указывается значение адреса,  превышающее 65535.  Напри-
     мер:


     Турбо Ассемблер 3.0/tasm/#2-2                             = 189 =

          F00 SEGMENT AT 12345h

         Illegal use of constant
          (Недопустимо использование константы)

          В выражении  используется  константа там,  где использование
     константы недопустимо. Например:

            mov bx+4,5

         Illegal use of register
          (Недопустимо использование регистра)

          В выражении указывается имя регистра там,  где использование
     регистра недопустимо. Например:

            X = 4 shl ax ; в операции SHL нельзя указывать регистры

         Illegal use of segment register
          (Недопустимо использование сегментного регистра)

          В выражении или команде указывается имя сегментного регистра
     там,  где использование сегментного регистра недопустимо.  Напри-
     мер:

           ADD SS,4      ; в команде ADD нельзя указывать
                         ; сегментные регистры

         Illegal USES register
          (В директиве USES указан недопустимый регистр)

          Указан недопустимый  регистр в командах PUSH и POP при входе
     и выходе из процедуры. Допустимы следующие регистры:

           AX            CX               DS               ES
           BX            DI               DX               SI

          Если директивой  .386 или .386Р разрешены команды процессора
     80386,  то можно указывать 32-битовые  эквиваленты  перечисленных
     выше сегментов.

         Illegal version ID
          (Недопустимый идентификатор версии)

          Эта ошибка происходит,  когда в параметре /U или в операторе
     VERSION выбирается недопустимая версия.

         Illegal warning ID
          (Недопустимый идентификатор предупреждающего сообщения)

          Введен неверный трехсимвольный идентификатор предупреждающе-
     го сообщения. Список всех допустимых идентификаторов предупрежда-
     ющих сообщений приведен в Главе 2.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 190 =


         Instruction can be compacted with override
          (Возможно сокращение длины команды,  если явно  указать  тип
          имени)

          Из-за наличия ссылки вперед на имя идентификатора генерируе-
     мый код содержит дополнительные команды NOP.  Для того чтобы сок-
     ратить  код можно убрать ссылку вперед либо явно указать тип сим-
     волического имени. Например:

           jmp X ; для этой команды будет выдано предупреждающее
                 ; сообщение
           jmp SHORT X ; не будет выдано предупреждающего сообщения
       Х:

         Invalid model type
          (Недопустимая модель памяти)

          В директиве .MODEL для модели  памяти  указано  недопустимое
     ключевое слово. Например:

          .Model GIGANTIC

          Для обозначения  моделей памяти допустимы следующие ключевые
     слова: TINY, SMALL, COMPACT, MEDIUM, LARGE и HUGE.

         Invalid operand(s) to instruction
          (Недопустимый операнд(ы) для данной команды)

          В команде указана недопустимая комбинация операндов.  Напри-
     мер:

           FADD ST(2), ST(3)

          В команде FADD только на один стековый  регистр  можно  ссы-
     латься по имени, другой операнд должен быть вершиной стека.

         Labels can't start with numeric characters
          (Метки не могут начинаться с цифровых символов)

          Обнаружено имя, которое не является ни допустимым числом, ни
     допустимым именем идентификатора. Например: 123XYZ.

         Line too long - truncated
          (Строка слишком длинная - производится усечение)

          Текущая строка исходного файла содержит более  255 символов.
     Лишние символы игнорируются.

         Location counter overflow
          (Переполнение счетчика адреса)

          Текущий сегмент заполнен,  последующий код или данные затрут

     Турбо Ассемблер 3.0/tasm/#2-2                             = 191 =

     начало сегмента. Например:

          ORG 0FFF0h
          ARRAY DW 20 DUP (0)   ; переполнение

         Method call requires object name
          (В вызове метода необходимо имя объекта)

          Оператор CALL...METHOD не может получить тип объекта из  эк-
     земпляра указателя. Вы должны указать имя объекта.

         Missing argument list
          (Отсутствует список аргументов)

          В директиве IRP или IRPC,  определяющей блок повторения,  не
     указан список аргументов для формального параметра. Например:

              IRP X    ; нет списка аргументов
                 DB X
              ENDM

          В директивах IRP и IRPC обязательно должен быть указан  фор-
     мальный параметр и список аргументов.

         Missing argument or <
          (Отсутствует аргумент, либо не указана угловая скобка <)

          Не указаны угловые скобки, либо вообще отсутствует выражение
     в угловых скобках там, где оно необходимо. Например:

           if b  ; должно быть указано выражение в угловых
                 ; скобках

         Missing argument size variable
          (Отсутствует переменная для размера блока параметров)

          В директиве ARG или LOCAL не указано имя идентификатора пос-
     ле знака равенства в конце оператора. Например:

           ARG  A:WORD,B:DWORD=   ; ошибка, нет имени после знака=
           LOCAL X:TBYTE=         ; та же ошибка

          В директивах ARG и LOCAL после знака равенства, если он ука-
     зан,  обязательно должно быть указано имя переменной для  размера
     блока параметров.

         Missing COMM ID
          (Отсутствует идентификатор в директиве COMM)

          В директиве COMM не указано имя идентификатора перед  специ-
     фикатором типа. Например:

          COMM NEAR     ; ошибка: отсутствует

     Турбо Ассемблер 3.0/tasm/#2-2                             = 192 =

                        ; имя идентификатора перед "NEAR"

          В директиве СОММ обязательно должно быть указано имя иденти-
     фикатора. Имя идентификатора и спецификатор типа должны быть раз-
     делены двоеточием (:).

         Missing dummy argument
          (Отсутствует формальный параметр)

          В директиве IRP или IRPC, определяющей блок повтора, отсутс-
     твует формальный параметр. Например:

          IRP
             DB X   ; нет формального параметра
          ENDM

          В директивах IRP и IRPC обязательно должны быть указаны фор-
     мальный параметр и список аргументов.

         Missing end quote
          (Отсутствует закрывающая кавычка)

          В конце строковой константы нет закрывающей кавычки.  Напри-
     мер:

          DB  "abc        ; отсутствует кавычка в конце ABC
          mov al,'X       ; отсутствует кавычка после  Х

          Строковая константа должна оканчиваться той же кавычкой, ко-
     торой она начинается.

         Missing macro ID
          (Отсутствует идентификатор макрокоманды)

          В директиве MACRO,  определяющей  макрокоманду,  отсутствует
     имя. Например:

            MACRO   ; ошибка: не указано имя макрокоманды
             DB A
            ENDM

          Имя в определении макрокоманды указывать обязательно.

         Missing module name
          (Отсутствует имя модуля)

          В директиве NAME не указано имя модуля. Напомним, что дирек-
     тива NAME действует только в режиме Ideal.

         Missing or illegal language ID
          (Отсутствует или неверно указан идентификатор языка)

          В директиве .MODEL неверно указан идентификатор языка.  Под-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 193 =

     робное описание  директивы  MODEL см.  в Главе 7 настоящего руко-
     водства.

         Missing or illegal type specifier
          (Отсутствует или неверно указан спецификатор типа)

          В операторе  отсутствует или неверно указан обязательный па-
     раметр - идентификатор типа (BYTE, WORD и т.д.) Например:

           RED LABEL XXX         ; ошибка: "ХХХ" не является
                                 ; идентификатором типа

         Missing table member ID
          (Пропущен идентификатор элемента таблицы)

          В операторе   CALL...METHOD  после  ключевого  слова  METHOD
     пропущено имя объекта.

         Missing term in list
          (Отсутствует член в списке параметров)

          В режиме Ideal в директиве,  допускающей указание нескольких
     параметров (такой как EXTRN, PUBLIC и т.д.), отсутствует параметр
     после одной из запятых,  отделяющих параметры друг от друга. Нап-
     ример:

            EXTRN XXX:BYTE,,YYY:WORD

          В режиме  Ideal  параметры в любом списке всегда разделяются
     только одной запятой, в конце списка запятой быть не должно.

         Missing text macro
          (Отсутствует текстовая макрокоманда)

          В директиве не указан обязательный параметр - текстовая мак-
     рокоманда. Например:

          NEWSTR  SUBSTR          ; для SUBSTR должны быть
                                  ; указаны параметры

         Model must be specified first
          (Сначала должна быть указана модель памяти)

          Использована одна  из  упрощенных  сегментных  директив  без
     предварительной спецификации модели памяти. Например:

          .CODE     ; ошибка: сначала нужно указать директиву
                    ; .MODEL

          Перед использованием упрощенных сегментных  директив  должна
     быть указана с помощью директивы .MODEL модель памяти.

         Module is pass-dependant - compatibility pass was done

     Турбо Ассемблер 3.0/tasm/#2-2                             = 194 =

          (Модуль зависит от прохода.  Выполнен проход, обеспечивающий
          совместимость с MASM)

          Это предупреждающее   сообщение  выдается,  если  обнаружена
     конструкция, зависящая от прохода,  и в командной  строке  указан
     параметр  /m.  В  этом случае выполняется проход,  обеспечивающий
     совместимость с MASM.

         Name must come first
          (Имя должно быть указано первым)

          Имя идентификатора  указано после названия директивы,  тогда
     когда оно должно находиться перед названием  директивы. Например:

          STRUC ABC      ; ошибка: "ABC" должно стоять перед
                         ; ключевым словом STRUC

          В режиме Ideal имя идентификатора указывается после названия
     директивы,  поэтому эта ошибка часто возникает при  попытках  ас-
     семблирования в режиме MASM программ,  предназначенных для работы
     в режиме Ideal.

         Near jump or call to different CS
          (Адресат ближнего перехода или вызова находится в другом ко-
          довом сегменте)

          Это сообщение об ошибке  выдается  при  попытке  осуществить
     ближний вызов или переход по адресу, определенному в области, где
     регистр CS указывает на другой сегмент.

         Need address or register
          (Требуется указать адрес или регистр)

          Не указан второй операнд команды,  т.е.  операнд указываемый
     после запятой. Например:

           mov ax,   ; нет второго операнда

         Need angle brackets for structure fill
          (Значения для  структуры  должны указываться в угловых скоб-
          ках)

          В операторе выделения памяти под структуру не  указан список
     начальных значений. Например:

          STR1 STRUC
          M1 DW ?
          M2 DD ?
          ENDS
          STR1   ; нет списка начальных значений

         Need colon
          (Требуется двоеточие)

     Турбо Ассемблер 3.0/tasm/#2-2                             = 195 =


          В директиве EXTRN, GLOBAL, ARG и LOCAL отсутствует двоеточие
     перед спецификатором типа (BYTE, WORD и т.д.) Например:

           EXTRN X BYTE,Y:WORD ; после Х нет двоеточия

         Need expression
          (Требуется указать выражение)

          Выражение содержит операцию,  для которой не указан операнд.
     Например:

          Х = 4 + * 6

         Need file name after INCLUDE
          (В директиве INCLUDE должно быть указано имя файла)

          В директиве INCLUDE не указано имя файла. Например:

          INCLUDE   ; не указано, какой файл должен быть включен

          В режиме Ideal имя файла должно быть заключено в кавычки.

         Need left parenthesis
          (Отсутствует левая круглая скобка)

          Опущена левая  круглая  скобка  там,  где это не допускается
     синтаксисом выражения. Например:

          DB 4 DUP 7

          Выражение в операции DUP обязательно должно быть заключено в
     круглые скобки.

         Need method name
          (Требуется имя метода)

          Оператор CALL...METHOD  требует после ключевого слова METHOD
     имени метода.

         Need pointer expression
          (Требуется выражение-указатель)

          Эта ошибка возникает только в режиме Ideal и  указывает, что
     выражение в квадратных скобках ([]) не является указателем на па-
     мять. Например:

           mov ax,[word ptr]

          В режиме Ideal в квадратных  скобках  допускается  указывать
     только адресные выражения.

         Need quoted string

     Турбо Ассемблер 3.0/tasm/#2-2                             = 196 =

          (Требуется указать строку в кавычках)

          Ошибка при вводе параметра директивы,  который должен предс-
     тавлять собой строку,  заключенную в кавычки.  В режиме Ideal для
     ряда директив в качестве параметра указывается строка в кавычках.
     Например:

          Ideal
          DISPLAY  "Все сделано"

         Need register in expression
          (В выражении требуется указать имя регистра)

          В выражении  не  указано имя регистра там,  где это является
     обязательным.

         Need right angle bracket
          (Отсутствует правая угловая скобка)

          Выражение, используемое для инициализации структуры, объеди-
     нения или записи,  не оканчивается правой угловой скобкой  (>)  -
     парной  для  левой угловой скобки,  указывающей начало списка на-
     чальных значений. Например:

          MYSTRUC STRUCNAME <1,2,3

         Need right curly bracket
          (Требуется правая фигурная скобка)

          Эта ошибка возникает в структуре,  таблице или записи, когда
     ожидается }, но она не найдена.

         Need right parenthesis
          (Отсутствует правая круглая скобка)

          Выражение содержит левую круглую скобку без парной ей правой
     угловой скобки. Например:

            Х = 5 * (4 + 3

          В выражениях обязательно должно соблюдаться соответствие ле-
     вых и правых круглых скобок.

         Need right square bracket
          (Отсутствует правая квадратная скобка)

          Выражение, представляющее собой ссылку  на  память,  указано
     без правой квадратной скобки, которая должна соответствовать отк-
     рывающей левой квадратной скобке,  обозначающей начало выражения.
     Например:

            mov ax,[SI   ; ошибка: нет закрывающей
                         ; скобки (]) после SI

     Турбо Ассемблер 3.0/tasm/#2-2                             = 197 =


          В выражениях обязательно должно соблюдаться соответствие ле-
     вых и правых квадратных скобок.

         Need stack argument
          (Не указан стековый параметр)

          В команде арифметики с плавающей запятой  не  указан  второй
     операнд, т.е. операнд, указываемый после запятой. Например:

          FADD ST,

         Need structure member name
          (Не указано имя поля структуры)

          В режиме Ideal после селектора поля  структуры  (т.е.  после
     точки) не указано имя поля этой структуры. Например:

           Ideal
          STRUC DEMO
           DB ?
          ENDS
          COUNT  DW 0
            mov,[(DEMO bx).]

          При обращении к полю структуры справа от  точки  обязательно
     должно  быть указано поле той структуры,  имя которой стоит слева
     от точки.

         Not expecting group or segment quantity
          (Использование имени группы или сегмента недопустимо)

          Указано имя  группы  или сегмента там,  где это недопустимо.
     Например:

          CODE SEGMENT
             rol ax,CODE   ; ошибка: здесь нельзя указывать
                           ; имя сегмента

         One non-null field allowed per union expansion
          (При расширении объединения допускается указывать только од-
          но поле непустым)

          При инициализации  объединения,   определенного   директивой
     UNION, указано более одного значения. Например:

           U  UNION
              DW ?
              DD ?
           ENDS
           UINST U <1,2>  ;ошибка: можно указать <?,2> либо <1,?>

          В объединении можно инициализировать только одно поле.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 198 =


         Only one startup sequence allowed
          (Допускается только одна директива генерации кода  инициали-
          зации)

          Это сообщение  выдается,  если  в модуле указано более одной
     директивы .STARTUP или STARTUPCODE.

         Open conditional
          (Открытый условный блок)

          Обнаружена директива END,  означающая конец исходного файла.
     Однако условно ассемблируемый блок,  открытый одной  из  директив
     вида IFxxx, не был закрыт директивой ENDIF. Например:

          IF BIGBUF
          END        ; нет директивы ENDIF перед директивой END

          Эта ошибка обычно выдается,  если вместо директивы окончания
     условного блока ENDIF, ошибочно указана директива END.

         Open procedure
          (Открытая процедура)

          Обнаружена директива END,  означающая конец исходного файла.
     Однако блок описания процедуры,  открытый директивой PROC, не был
     закрыт директивой ENDР. Например:

            MYFUNC PROC
            END        ; нет директивы ENDР перед директивой END

          Эта ошибка обычно выдается, если вместо директивы конца бло-
     ка процедуры - ENDP ошибочно указана директива END.

         Open segment
          (Открытый сегмент)

          Обнаружена директива END,  означающая конец исходного файла.
     Однако сегмент, открытый директивой SEGMENT, не был закрыт дирек-
     тивой ENDS. Например:

            DATA SEGMENT
                 END      ; нет директивы ENDS перед директивой END

          Эта ошибка обычно выдается, если вместо директивы конца сег-
     мента - ENDS ошибочно указана директива END.

         Open structure definition
          (Не указан конец определения структуры)

          Обнаружена директива END,  означающая конец исходного файла.
     Однако  определение структуры,  начало которой указано директивой
     STRUCTURE, не было завершено директивой ENDS. Например:

     Турбо Ассемблер 3.0/tasm/#2-2                             = 199 =


          X  STRUC
          VAL1 DW ?
          END      ; нет директивы ENDS перед директивой END

          Эта ошибка обычно выводится,  если  вместо  директивы  конца
     структуры ENDS ошибочно указана директива END.

         Operand types do not match
          (Не совпадают типы операндов)

          Тип одного из операндов команды не совпадает с типом другого
     операнда  либо не является допустимым для данной команды.  Напри-
     мер:

          ABC DB 5
          ...
          mov ax,ABC

         Operation illegal for static table member
          (Для статического элемента таблицы операция не допускается)

          Для получения адреса статического элемента таблицы использо-
     вана операция точки. Это не допускается.

         Pass-dependant construction encountered
          (Обнаружена конструкция, зависящая от прохода)

          Действие оператора  возможно  не совпадает с ожидаемым из-за
     однопроходности Турбо Ассемблера. Например:

          IF1
                       ; на шаге ассемблирования
          ENDIF
          IF2
                       ; на шаге листинга
          ENDIF

          Большинство конструкций,  с  которыми связано это сообщение,
     может быть скорректировано  так,  чтобы  это  сообщение  исчезло.
     Обычно для этого достаточно убрать ссылки вперед.

         Pointer expression needs brackets
          (Адресное выражение должно быть заключено в квадратные скоб-
          ки)

          В режиме   Ideal  операнд,  содержащий  имя  идентификатора,
     представляющее собой ссылку на память,  не заключен в  квадратные
     скобки. В режиме Ideal квадратные скобки означают ссылку на адрес
     памяти. Например:

          B DB 0
            mov al,B  ; предупреждение: в режиме Ideal

     Турбо Ассемблер 3.0/tasm/#2-2                             = 200 =

                      ; должно быть указано [B]

          Т.к. в режиме MASM квадратные скобки не обязательны,  то это
     сообщение выдается как предупреждающее.

         Positive count expecting
          (Счетчик должен быть положительным)

          В  выражении для DUP в качестве счетчика повторений
     указано отрицательное число. Например:

            BUF  -1 DUP (?)   ; ошибка: отрицательный счетчик

          Счетчик в операции DUP должен быть равен или больше 1.

         Record field too large
          (Слишком длинное поле в записи)

          В определении записи сумма длин всех полей превышает 32  би-
     та. Например:

            AREC  RECORD RANGE:12,TOP:12,BOTTOM:12

         Record member not found
          (Не найден статический элемент записи)

          Элемент записи задан в заполнителе указанной записи, который
     не является частью заданной записи.

         Recursive definition not allowed for EQU
          (Рекурсивное определение не допустимо в директиве EQU)

          В выражении директивы EQU содержится то же самое имя,  кото-
     рое определяется этой директивой. Например:

             ABC EQU TWOTIMES ABC

         Register must be AL or AX
          (Допустимо указание только регистра AL или AX)

          Неверен операнд команды. Допускается использовать только ре-
     гистры AL и AX. Например:

           IN CL,dx   ; ошибка: в первом операнде команды IN
                      ; допускается указывать только регистры AL и AX

         Register must be DX
          (Допустимо указание только регистра DX)

          Неверен операнд команды. Допускается использовать только ре-
     гистр DX. Например:

           IN AL,cx  ; ошибка: вместо СХ должен быть указан регистр DX

     Турбо Ассемблер 3.0/tasm/#2-2                             = 201 =


         Relative jump out of range by __ bytes
          (Адрес назначения  условного  перехода  превышает допустимый
          предел на __ байт)

          Адрес назначения в команде условного перехода  находится вне
     допустимого диапазона, т.е. не принадлежит интервалу (-127, +128)
     от текущего адреса. В 32-битовом сегменте адрес назначения услов-
     ного  перехода  должен находиться в диапазоне от -32767 до +32768
     байт от текущего адреса.

         Relative quantity illegal
          (Недопустимый относительный адрес)

          Команда или директива содержит операнд, ссылающийся на адрес
     памяти таким способом,  что эта ссылка не может быть разрешена на
     этапе ассемблирования.  Такие  ссылки в Турбо Ассемблере являются
     недопустимыми. Например:

         DATA SEGMENT PUBLIC
         X  DB 0
         IF OFFSET X GT 127 ; на этапе ассемблирования
                            ; адрес не известен

         Reserved word used as symbol
          (Зарезервированное слово используется в качестве имени иден-
          тификатора)

          В программе  пользователя  определяется  имя идентификатора,
     совпадающее с одним из зарезервированных слов  Турбо  Ассемблера.
     Программа будет ассемблироваться правильно, однако переопределять
     зарезервированные в Турбо Ассемблере слова не рекомендуется.

         Rotate count must be constant or CL
          (Счетчик в  командах  сдвига  должен  быть  указан с помощью
          константы или регистра CL)

          В команде сдвига или циклического сдвига указан операнд, от-
     личный от константы и регистра CL. Например:

          ROL  ax,DL   ; ошибка: регистр DL нельзя указывать
                       ; в качестве счетчика

          В командах сдвига и циклического сдвига в  качестве  второго
     операнда можно указывать только константу или регистр CL.

         Rotate count out of range
          (Недопустимое значение для счетчика сдвига)

          В команде сдвига или циклического сдвига второй операнд пре-
     вышает допустимое значение. Например:

          .8086

     Турбо Ассемблер 3.0/tasm/#2-2                             = 202 =

          SHL  DL,3       ; ошибка: в командах процессора 8086
                          ; возможен сдвиг только на один разряд
          .286
          ROR  ax,40      ; ошибка:  максимальное допустимое
                          ; значение для счетчика сдвига равно 31

          Максимальное допустимое значение для счетчика сдвига  в  ко-
     мандах процессора 8086 равно 1, для других процессоров это значе-
     ние может быть равно 31.

         Segment alignment not strict enough
          (Выравнивание сегмента не достаточно точное)

          Указано недопустимое  значение для границы выравнивания сег-
     мента.  Либо оно не является степенью двойки,  либо специфицирует
     более  точное  выравнивание  чем то,  которое указано в директиве
     SEGMENT. Например:

          DATA SEGMENT PARA
             ALIGN 32   ; ошибка: PARA означает только 16
             ALIGN 3    ; ошибка: не является степенью двойки

         Segment attributes illegally redefined
          (Недопустимое переопределение атрибутов сегмента)

          Директивой SEGMENT повторно открывается уже определенный ра-
     нее сегмент,  при этом указываются новые значения  для  атрибутов
     этого сегмента. Например:

           DATA SEGMENT BYTE PUBLIC
           DATA ENDS
           DATA SEGMENT PARA         ; ошибка: ранее было указано
                                     ; выравнивание на байт
           DATA ENDS

          При повторном  открытии  сегмента атрибуты либо должны иметь
     те же самые значения,  либо вообще быть опущены. Если при повтор-
     ном открытии сегмента атрибуты не указаны,  то используются атри-
     буты из предыдущего определения.

         Segment name is superfluous
          (Имя сегмента игнорируется)

          Это предупреждающее  сообщение выдается в тех случаях, когда
     в директиве .CODE указано имя сегмента, а в текущей модели памяти
     не допускается использовать более одного сегмента.

         String too long
          (Слишком длинная строка)

          Указанная в кавычках строка имеет длину,  превышающую макси-
     мально допустимую - 255 символов.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 203 =

         Symbol already defined:__
          (Имя идентификатора уже определено)

          Указанное имя идентификатора уже было ранее объявлено  с тем
     же самым типом. Например:

          BB DB 1,2,3
          BB DB ?   ; ошибка: BB уже определено

         Symbol already different kind
          (Имя идентификатора уже объявлено с другим типом)

          Указанное идентификатора  имя  было ранее объявлено с другим
     типом, например:

          BB DB 1,2,3
          BB DW ?  ; ошибка: BB уже объявлено с типом BYTE

         Symbol has no width or mask
          (Имя идентификатора не может быть использовано  в  операциях
          WIDTH и MASK)

          Операнд операции  WIDTH  или  MASK не является именем записи
     или именем поля записи. Например:

          B DB 0
             mov ax,MASK B  ; В не является полем записи

         Symbol is not a segment or already part of a group
          (Имя идентификатора не является именем сегмента либо уже оп-
          ределено в группе)

          Либо имя идентификатора уже определено в группе, либо не яв-
     ляется именем сегмента. Например:

          DATA SEGMENT
          DATA ENDS
          DGROUP GROUP DATA
          DGROUP2 GROUP DATA    ; ошибка: DATA уже определено в DGROUP

         Text macro expansion exceeds maximum line length
          (Расширение текстовой макрокоманды превышает максимально до-
          пустимую длину)

          Это сообщение об ошибке выдается, когда расширение текстовой
     макрокоманды превышает максимально допустимую длину.

         Too few operands to instruction
          (В команде не хватает операндов)

          В команде должно быть указано большее число операндов.  Нап-
     ример:


     Турбо Ассемблер 3.0/tasm/#2-2                             = 204 =

          ADD  ax  ; отсутствует второй операнд

         Too many errors or warnings
          (Слишком много ошибок или предупреждений)

          Сообщения об ошибках больше выдаваться не будут.  Максималь-
     ное число сообщений об ошибках,  которое выдается Турбо Ассембле-
     ром,  равно 100. Это максимально допустимое число ошибок превыше-
     но.  Ассемблирование программы тем  не  менее  будет  продолжено,
     однако далее будут печататься только предупреждающие сообщения.

         Too many initial values
          (Слишком много начальных значений)

          При инициализации структуры или объединения  указано слишком
     много значений. Например:

          XYZ   STRUC
          A1  DB ?
          A2  DB ?
          XYZ   ENDS
          ANXYZ   XYZ <1,2,3>  ; ошибка: в XYZ определены
                               ; только два поля

          При инициализации полей структур и  объединений  допускается
     указывать меньше значений,  чем число полей,  но нельзя указывать
     больше значений.

         Too many register multipliers in expression
          (В выражении содержится слишком много множителей для регист-
          ров)

          Для процессора  80386 допускается коэффициент индексных опе-
     рандов. Однако коэффициент можно указывать не более, чем у одного
     регистра. Например:

            mov EAX,[2*EBX+4*EDX]       ; слишком много
                                        ; коэффициентов

         Too many registers in expression
          (В выражении указано слишком много регистров)

          В выражении указано более одного индексного и одного  базис-
     ного регистра. Например:

          mov ax,[BP+SI+DI]   ; нельзя одновременно указывать SI и DI

         Too many USES registers
          (Слишком много регистров в директиве USES)

          В директиве USES для текущей процедуры указано более  8  ре-
     гистров.


     Турбо Ассемблер 3.0/tasm/#2-2                             = 205 =

         Trailling null value assumed
          (Предполагается конечное пустое значение)

          Директива определения данных (DB,  DW и  т.д.)  оканчивается
     запятой. TASM интерпретирует ее как пустое значение. Например:

           db  'привет',13,10   ; то же, что и db'привет',13,10?

         Undefined symbol
          (Идентификатор не определен)

          Оператор содержит идентификатор,  который не был ранее опре-
     делен в исходном файле.

         Unexpected end of file (no END directive)
          (Неожиданный конец файла (нет директивы END))

          В исходном файле отсутствует директива  END.  Директива  END
     обязательно должна быть указана в конце исходного файла.

         Unknown character
          (Неизвестный символ)

          Текущая строка исходной программы содержит  символ,  который
     не принадлежит набору символов,  допустимых для построения симво-
     лических имен и выражений в Турбо Ассемблере. Например:

           add  ax,!1      ; ошибка:  восклицательный  знак -
                           ; недопустимый символ

         Unmatched ENDP:_
          (Непарная директива ENDP:_)

          В директиве ENDP указано имя, не совпадающее с именем проце-
     дуры, которую закрывает данная директива. Например:

           ABC  PROC
           XYZ  ENDP   ; ошибка: вместо XYZ должно быть указано ABC


         Unmatched ENDS:_
          (Непарная директива ENDS:_)

          В директиве  ENDS указано имя,  не совпадающее с именем сег-
     мента,  который закрывает данная директива, либо не совпадающее с
     именем  структуры или объединения,  оканчивающегося этой директи-
     вой. Например:

         ABC  STRUC
         XYZ  ENDP    ; ошибка: вместо XYZ должно быть указано ABC
         DATA  SEGMENT
         CODE  ENDS   ; ошибка: вместо CODE должно быть указано DATA


     Турбо Ассемблер 3.0/tasm/#2-2                             = 206 =

         User-generated error
          (Ошибка, сгенерированная пользователем)

          Ошибка выдана  в результате выполнения одной из директив ге-
     нерирования ошибки. Например:

          .ERR   ; попадание в это место является ошибкой

          USES has no effect without language
          (USES игнорируется без спецификации языка)

          Это предупреждающее  сообщение выдается,  если оператор USES
     используется без предварительной спецификации языка.


         Value out of range
          (Значение константы превышает допустимое значение)

          Константа представляет собой,  вообще говоря, число правиль-
     ного формата.  Однако ее значение превышает допустимую  в  данном
     конкретном случае величину. Например:

            DB  400



     Турбо Ассемблер 3.0/tasm/#2-2                             = 207 =

                      Сообщения о фатальных ошибках
     ─────────────────────────────────────────────────────────────────

          При возникновении фатальных ошибок  Турбо  Ассемблер  выдает
     соответствующее  сообщение  и  ассемблирование  пользовательского
     файла немедленно прекращается, независимо от того чем была вызва-
     на эта ошибка. В этом разделе приводится перечень возможных сооб-
     щений о фатальных ошибках.

         Bad switch
          (Неверный параметр-переключатель командной строки)

          В командной строке указан неверный параметр.  См.  Главу  2,
     где дается подробное описание параметров командной строки.

         Can't find @file __
          (Не найден файл подсказок __)

          В командной строке указано имя несуществующего файла подска-
     зок.  Следует проверить, указано ли полное имя файла. В Турбо Ас-
     семблере отсутствует умолчание для расширения имени файла подска-
     зок.  Вероятной  причиной данного сообщения может быть отсутствие
     места на диске при записи на этот диск файла,  содержащего перек-
     рестные ссылки.

         Сan't locate file __
          (Не обнаружен файл __)

          В директиве INCLUDE указано имя несуществующего файла. О ди-
     рективе INCLUDE см.  Главу 10 настоящего руководства,  где описан
     алгоритм поиска Турбо Ассемблером включаемых файлов.  Если выдано
     это сообщение,  проверьте, правильно ли указано в имени файла имя
     дисковода и маршрут доступа.

         Error writing to listing file
          (Ошибка при записи в файл листинга)

          Возможно при  записи  файла  листинга на диск было исчерпано
     место на этом диске.

         Error writing to object file
          (Ошибка при записи в объектный файл)

          Возможно при  записи объектного файла на диск было исчерпано
     место на этом диске.

         File not found
          (Не найден файл)

          В командной  строке  указано  имя  несуществующего исходного
     файла. Проверьте, правильно ли указано имя файла, включены ли имя
     диска и маршрут доступа, если файл находится в каталоге, отличном
     от текущего.

     Турбо Ассемблер 3.0/tasm/#2-2                             = 208 =


         File was changed or deleted while assembly in progress
          (Файл был  изменен или уничтожен в процессе ассемблирования)

          Какая-либо другая программа, например, резидентная активизи-
     руемая утилита,  уничтожила открытый Турбо  Ассемблером  файл.  В
     Турбо Ассемблере не допускается повторное открытие файла, который
     был ранее успешно открыт.

         Insufficient memory to process command line
          (Не хватает памяти для обработки командной строки)

          Командная строка  занимает более 64К,  либо для ее обработки
     не хватает имеющейся памяти.  Следует упростить командную  строку
     либо запустить  Турбо Ассемблер при наличии большего объема памя-
     ти.

         Internal error
          (Внутренняя ошибка)

          Это сообщение  не  должно  выдаваться  при нормальной работе
     Турбо Ассемблера. Сделайте копию файлов, вызвавших появление этой
     ошибки, и   сообщите  в  отдел  технического  обслуживания  фирмы
     Borland.

         Invalid command line
          (Недопустимая командная строка)

          Неверен формат командной строки,  с помощью которой запуска-
     ется Турбо Ассемблер. Например, в команде:

           NASM, MYFILE

     не указан исходный файл,  который  должен  ассемблироваться.  См.
     Главу 2, где дается подробное описание командной строки.

         Invalid number after _
          (Недопустимый номер после _)

          Верно указан идентификатор параметра,  однако неверно специ-
     фицирован числовой параметр после нее.  См.  Главу 2, где описаны
     параметры командной строки.

         Out of hash space
          (Не хватает памяти под хеш-таблицы)

          Каждому имени идентификатора,  определяемому в пользователь-
     ской программе,  соответствует один элемент хеш-таблицы. Эта таб-
     лица рассчитана  на 16384 определяемых пользователем имен иденти-
     фикаторов при условии запуска Турбо Ассемблера с достаточным объ-
     емом  свободной памяти.  Если в программе пользователя определено
     большее количество имен идентификаторов,  то нужно указать  пара-
     метр командной строки /КН, для того чтобы обеспечить в хеш-табли-

     Турбо Ассемблер 3.0/tasm/#2-2                             = 209 =

     це нужное число элементов для описания этого количества  символи-
     ческих имен.

         Out of memory
          (Не хватает памяти)

          Не хватает  свободной  памяти  для ассемблирования пользова-
     тельского файла. Попробуйте использовать TASMX.

          Если в оперативной памяти имеются какие-либо  резидентные  в
     памяти программы,  то следует убрать их и повторить ассемблирова-
     ние файла.  Возможно,  что потребуется перезагрузить систему, для
     того чтобы полностью освободить память.

          Другой путь  состоит  в том,  чтобы разбить исходный файл на
     два или более,  или переписать части исходного файла таким  обра-
     зом, чтобы его ассемблирование требовало меньше памяти. Для этого
     в программе  следует  укоротить имена идентификаторов,  уменьшить
     число комментариев в макрокомандах,  уменьшить число ссылок  впе-
     ред.

         Out of string space
          (Не хватает памяти под строки)

          Не хватает оперативной памяти для хранения строк: имен иден-
     тификаторов,  имен файлов,  информации для разрешения опережающих
     ссылок, текстов макрокоманд.  Допускается максимум 512К памяти, а
     ваш модуль превысил этот объем. Попробуйте использовать  TASMX.

         Too many errors found
          (Обнаружено слишком много ошибок)

          Ассемблирование пользовательского файла прекращено, посколь-
     ку в этом файле содержится слишком много ошибок. Возможно, что на
     самом деле ошибок не так уж и много, однако они таковы, что вызы-
     вают эффект "снежного кома". Примером такой ошибки может быть не-
     верное определение имени идентификатора,  которое используется во
     многих строках программы.  На самом деле сделана лишь одна ошибка
     (неверно определено  имя  идентификатора),  однако  сообщение  об
     ошибке будет выдано в каждой строке, где появляется это имя.

          Турбо Ассемблер прекращает ассемблирование файла,  когда об-
     щее число ошибок и предупреждающих сообщений достигает 100.

         Unexpected end of file (no END directive)
          (Неожиданный конец файла (отсутствует директива END))

          В конце  исходного  файла отсутствует директива END.  Каждый
     исходный файл обязательно должен заканчиваться директивой END.

