 
                        ПРИЛОЖЕНИЕ С
 
             Служебные программы Турбо-Паскаля
 
     Данное приложение подробно  описывает  пять  автономных 
обслуживающих  программ-утилит,  которые поставляются вместе 
с языком  Турбо-Паскаль:  TPUMOVER,  MAKE,  TOUCH,  BINOBJ и 
GREP.
 
                       Использование 
            программы пересылки модулей TPUMOVER
 
     Использование модулей предполагает простой доступ к ним
из любой программы. В Главе 4 дано разъяснение того, что та-
кое модуль и как создавать свои собственные модули. В насто-
ящей  главе  описывается  использование утилиты TPUMOVER для
удаления редко используемых модулей из  библиотечного  файла
модулей TURBO.TPL и для вставки часто используемых модулей в
файл TURBO.TPL
 
                    Обзор файлов модулей
 
     В Турбо-Паскале имеется два типа файлов модулей:  файлы
с  расширением .TPU и файлы с расширением .TPL. Оттранслиро-
вав модуль, Турбо-Паскаль помещает полученный объектный  код
в  файл  с расширением .TPU (Turbo Pascal Unit - модуль Тур-
бо-Паскаля), который может содержать только один модуль.
     С другой стороны, файл с расширением .TPL (Turbo Pascal
Library - библиотека Турбо-Паскаля) может содержать несколь-
ко модулей. Например, все модули, поставляемые на диске Тур-
бо-Паскаля,  находятся  в  файле TURBO.TPL. В текущий момент
файл TURBO.TPL является единственным библиотечным файлом, из
которого Турбо-Паскаль загружает модули.
     Различие в названии становится важным во время компиля-
ции.  Если  некоторый  модуль не найден в TURBO.TPL, то Тур-
бо-Паскаль осуществляет поиск файла, имя которого образовано
из  имени модуля и расширения .TPU. Если такой файл не обна-
ружен, то компиляция прекращается из-за ошибки. Если вы  ис-
пользуете  средство  Build  (построение  прораммы),  то Тур-
бо-Паскаль вначале ищет файл,  имя  которого  образовано  из
имени модуля и расширения .PAS, транслирует его и использует
полученный файл с  расширением  .TPU.  Если  вы  используете
средство  Make (создание программы), то Турбо-Паскаль осуще-
ствляет   поиск   обоих   файлов    -    имя_модуля.PAS    и
имя_модуля.TPU, сравнивает даты и время их последних модифи-
каций и заново транслирует файл с  расширением  .PAS  в  том
случае, если в него вносились изменения после создания файла
с расширением .TPU.
     Обычно при создании собственного модуля он  сохраняется
в  файле  с расширением .TPU. Для использования этого молуля
необходимо указать Турбо-Паскалю, где его найти. При  работе
в интегрированной интерактивной среде программирования необ-
ходимо задать опцию "Каталоги модулей"  (Unit  directories)в
меню  "Оиции/Каталоги" (Options/Directories) (файл TURBO.TPL
загружается из каталога TURBO в том же самом меню). При  ра-
боте с компилятором с командными строками необходимо исполь-
зовать параметр /U. (Используйте параметр  /L  для  загрузки
библиотеки  TURBO из любого другого подкаталога в среде ком-
пилятора ТРС, работающего в режиме командной строки).
     Возможно вы заметили, что стандартные модули Турбо-Пас-
каля  можно  использовать  без указания имени файла. Причина
этого состоит в том, что эти модули хранятся в  файле  стан-
дартных  модулей Турбо-Паскаля - TURBO.TPL на дистрибутивном
диске. Поскольку эти модули находятся в  этом  файле,  любая
программа  может  использовать их, "не зная" о их расположе-
нии.
     Допустим, имеется модуль с именем TOOLS.TPU  и  он  ис-
пользуется  во  многих  программах.  Хотя  добавление модуля
Tools в TURBO.TPL потребует затрат памяти (TURBO.TPL автома-
тически загружается в оперативную память при загрузке компи-
лятора), это добавление  в  резидентную  библиотеку  сделает
"использование"  Tools более быстрым, поскольку модуль будет
находиться в памяти, а не на диске.
     В TURBO.TPL находятся  уже  пято  стандартных  модулей:
System, Overlay, Printer, Crt и Dos.
 
               Использование утилиты TPUMOVER
 
     Утилита TPUMOVER представляет собой программу, ориенти-
рованную  на  работу  с экраном, аналогичную интегрированной
среде программирования. Она  позволяет  просмотреть  модули,
содержащиеся  в  двух  различных файлах, и скопировать их из
одного файла в другой или же удалить  модули  из  указанного
файла. Эта программа главным образом используется для внесе-
ния и удаления файлов из TURBO.TPL, но  также  она  имеет  и
другие полезные функции.
     Отметим, что экран утилиты  TPUMOVER  состоит  из  двух
расположенных рядом друг с другом окон. В верхней части окна
указывается имя файла, а за ним указывается список  модулей,
находящихся  в файле. Каждая строка в окне содержит информа-
цию об одном модуле, а именно: имя модуля, размер кода, раз-
мер  данных, размер таблицы символов и имена других модулей,
используемых данным модулем. Все размеры указаны в байтах, а
имена  модулей  обрезаны  до шести символов. Если список ис-
пользуемых модулей слишком велик и не помещается в окне,  то
внизу указываются три точки; нажмите клавишу F4, чтобы прог-
нать список и посмотреть имена других модулей, зависящих  от
указанного. Наконец, две строки в окне содержат информацию о
текущем размере (в байтах) указанного файла и  о  количестве
свободного пространства на диске, на котором расположен этот
файл.
     В любой момент только одно из окон находится в  "актив-
ном"  состоянии. Это активное состояние обозначается двойной
линией вокруг окна. Кроме того, только окно в активном  сос-
тоянии  содержит поле с подсветкой, перемещающееся по списку
модулей, находящихся в файле. Это поле  может  передвигаться
вверх  и вниз с помощью клавиш управления движением курсора.
Все команды имеют силу только для окна, находящегося  в  ак-
тивном состоянии. Переключение активного состояние между ок-
нами выполняется с помощью клавиши F6.
     Для использования TPUMOVER нужно ввести:
 
     TPUMOVER файл1 файл2
 
где "файл1" и "файл2" - это файлы  с  расширением  .TPL  или
.TPU.  Расширение  .TPU предполагается по умолчанию, поэтому
явным образом расширение указывается только для файлов TPL.
     TPUMOVER загружается и выводит на экран два окна: левое
окно  для  "файл1" и правое окно для "файл2". Отметим, что и
"файл1", и  "файл2"  являются  необязательными  параметрами.
Если указан только параметр "файл1", то правое окно имеет по
умолчанию имя NONAME.TPU. Если вы не укажите никакого файла,
то  TPUMOVER попытается загрузить TURBO.TPL (в левое окно, а
правое окно останется пустым). Если TPUMOVER не сможет найти
этот  файл,  то он распечатает на экране каталог всех файлов
текущего диска, имеющих расширение .TPL.
 
                Команды утилиты TPUMOVER
 
     Основные команды указываются  в  нижней  части  экрана.
Ниже приводится краткое описание каждой их этих команд:
 
     - F1 - выводит на экран диалоговую документацию.
     - F2 - записывает текущий файл (файл, связанный с окном
в активном состоянии) на диск.
     - F3 - позволяет выбрать новый файл для окна в активном
состоянии.
     - F4 - распечатывает не поместившиеся  в  окне  модули,
которые  зависят от рассматриваемого модуля. В основном окне
указывается только первая зависимость модуля. Если после нее
указаны три точки, то это означает, что остальные зависимос-
ти можно распечатать, нажав клавишу F4.
     - F6 позволяет  переключать  активное  состояние  между
двумя  окнами,  переводя окно из неактивного состояния в ак-
тивное (и наоборот).
     - + (знак плюс) помечает модуль  (для  копирования  или
удаления).  Одновременно  можно  пометить несколько модулей;
кроме того, вы можете отменить пометку модуля, нажав клавишу
+ повторно.
     - Ins копирует все помеченные модули из окна в активном
состоянии в окно, находящееся в неактивном состоянии.
     - Del удаляет все помеченные модули из окна в  активном
состоянии.
     - Esc позволяет выйти из программы  TPUMOVER.  Отметим,
что  при этом автоматически не сохраняются все произведенные
изменения. Вы должны явным образом с  помощью  F2  сохранить
все модификации прежде, чем выйти из утилиты TPUMOVER.
 
               Пересылка модулей в TURBO.TPL
 
     Допустим, вы создали модуль Tools, который после компи-
ляции  помещен  в  файл с именем TOOLS.TPU. Вам так нравится
этот модуль, что вы хотите поместить его в  файл  TURBO.TPL.
Как это сделать? Сначала введите команду:
 
     A>tpumover turbo tools
 
В  результате  на  экране  появится  окно  программы-утилиты
TPUMOVER с TURBO.TPL в левом (активном) окне и с TOOLS.TPU в
правом окне. Отметим, что в этом примере предполагается, что
TURBO.TPL и TOOLS.TPU оба находятся в текущем каталоге; если
это не так, то следует указать соответствующие  имена  путей
для каждого из них.
     Теперь выполните следующие шаги:
 
     1.  Нажмите  клавишу  F6  для  перевода  правого   окна
(TOOLS.TPU) в активное состояние.
     2. Нажмите клавишу + с тем, чтобы пометить IntLib  (это
единственный модуль в правом окне).
     3. Нажмите клавишу Ins с тем, чтобы скопировать  IntLib
в TURBO.TPL.
     4.  Нажмите  клавишу  F6  для  перевода   левого   окна
(TURBO.TPL) в активное состояние.
     5.  Нажмите  клавишу  F2  для  сохранения  изменений  в
TURBO.TPL на диске.
     6. Нажмите клавишу Esc для выхода из TPUMOVER.
 
     Модуль Tools теперь является частью TURBO.TPL  и  будет
автоматически загружаться в память при вызове Турбо-Паскаля.
     Если вам нужно добавить другие модули в  TURBO.TPL,  то
это можно сделать, не выходя из TPUMOVER. После нажатия кла-
виши F2 для сохранения TURBO.TPL на диске выполните  следую-
щие шаги:
 
     1. Нажмите клавишу F6 для перевода правого окна  в  ак-
тивное состояние.
     2. Нажмите клавишу F3 для выбора нового файла для  пра-
вого окна.
     3. Повторите предыдущие шаги с первого по пятый для по-
метки   соответствующего   модуля,  для  копирования  его  в
TURBO.TPL, для  перевода  левого окна в активное состояние и
записи TURBO.TPL на диск.
 
     Вы можете повторить эту процедуру  сколь  угодно  много
раз с тем, чтобы построить собственную библиотеку.
 
               Удаление модулей из TURBO.TPL
 
     Теперь давайте удалим неиспользуемые  модули  Turbo3  и
Graph3 из TURBO.TPL. Для этого вначале введем команду:
 
     tpumover turbo
 
     В  результате  появится  экран   утилиты   TPUMOVER   с
TURBO.TPL  в  левом окне и с NONAME.TPU (имя по умолчанию) в
правом. Левое окно находится в активном  состоянии,  поэтому
выполните следующие действия:
 
     - С помощью клавиши "стрелка вниз" переместите  поле  с
подсветкой на Turbo3.
     - Нажмите клавишу + для выбора Turbo3.
     - Нажмите клавишу Del для удаления Turbo3.
     -  Нажмите  клавишу  F2  для  сохранения  изменений   в
TURBO.TPL.
     - Нажмите клавишу Esc для выхода из TPUMOVER.
 
     Вы можете повторить эту процедуру для удаления Graph3.
 
                 Пересылка модулей между 
                файлами с расширением .TPL
 
     Допустим, ваш друг написал несколько модулей и  передал
вам  файл MYSTUFF.TPL, содержащий эти модули. Вы хотите ско-
пировать в TURBO.TPL только модули  GameStuff  и  RandStuff.
Как это сделать? Ваша командная строка должна выглядеть при-
мерно так:
 
     tpumover mystuff.tpl turbo.tpl
 
     В   результате   появится   изображение   TPUMOVER    с
MYSTUFF.TPL  в  левом (активном) окне и с TURBO.TPL в правом
окне. Теперь выполните следующие команды:
 
     - С помощью клавиш "стрелка вверх" и "стрелка вниз" пе-
реместите подсвеченное поле на GameStuff.
     - Нажмите клавишу + для выбора GameStuff.
     - С помощью клавиш "стрелка вверх" и "стрелка вниз" пе-
ремес- тите подствеченное поле на RandStuff.
     - Нажмите клавишу + для выбора RandStuff.
     -  Нажмите  клавишу  Ins  с  тем,   чтобы   скопировать
GameStuff и - RandStuff в TURBO.TPL.
     - Нажмите клавишу F6 для перевода окна  с  TURBO.TPL  в
активное состояние.
     - Нажмите клавишу F2 для сохранения изменений,  внесен-
ных а TURBO.TPL.
     - Нажмите клавишу Esc для выхода из TPUMOVER.
 
              Сокращения для командной строки
 
     Вы можете использовать несколько параметров в командной
строке для быстрой обработки модулей. Формат этих параметров
имеет следующий вид:
 
     TPUMOVER TURBO /параметр имя_модуля
 
где параметр есть +, - или *.
     Эти команды выполняют следующие действия, при  этом  на
экране  не  появляется  изображение двух рядом расположенных
окон программы TPUMOVER.
 
      /+ Добавляет модуль с указанным именем к TURBO.TPL. 
      /- Удаляет модуль с указанным именем из TURBO.TPL.
      /* Выделяет (копирует) модуль  с  указанным именем из
TURBO.TPL и записывает его файл с именем,  образованным  из 
имени модуля и расширения .ТРU. 
      /? Распечатывает небольшое окно с диалоговой докумен-
тацией.
 
          Автономная обслуживающая программа MAKE
 
     Данный раздел содержит полное описание создания  форми-
рующих файлов и использования обслуживающей программы MAKE.
 
                Создание формирующего файла
 
     Формирующий файл (makefile) содержит  определения,  ко-
манды и директивы, мспользуемые программой-утилитой Make для
обновления вашей программы. Можно создать столько  формирую-
щих  файлов, сколько потребуется, и назвать их произвольными
именами. Если при запуске утилиты Make (с необязательным па-
раметром  -f)  вы  не задаете имя формирующего файла, то она
будет  искать  файл  с  используемым  по  умолчанию   именем
MAKEFILE. 
     Формирующий файл можно создать с помощью текстового ре-
дактора,  работающего  в кодах ASCII (такого, как, например,
встроенный интерактивный редактор Турбо-Паскаля). Все прави-
ла,  определения и директивы заканчиваются символом возврата
каретки. Если строка является слишком длинной, то вы  можете
закончить  ее в следующей строке, помещая знак продолжения -
обратную косую черту (\) - в последней позиции  продолжаемой
строки.
     Пробелы и точки используются для отделения  расположен-
ных  рядом  идентификаторов  (таких как зависимости) и чтобы
выделять команды внутри правил. Приведем список конструкций,
допустимых в формирующем файле файле:
 
     - комментарии;
     - явные правила;
     - неявные правила;
     - макроопределения; 
     - директивы (включение файла, условное выполнение,  оп-
ределение ошибки, макроудаление).
 
     Давайте рассмотрим каждую из приведенных выше конструк-
ций более подробно.
 
                        Комментарии
 
     Комментарии начинаются знаком номера (#). Остаток стро-
ки,  следующий  за знаком # игнорируется обслуживающей прог-
раммой MAKE. Комментарии могут помещаться в любом  месте,  и
никогда  не должны начинаться в какой-то определенной колон-
ке. 
     Знак обратной косой черты (\) не продолжает комментарий
на  следующую  строку. Вместо него вы должны воспользоваться
на каждой строке знаком #. В действительности вы  не  можете
воспользоваться  в качестве знака продолжения обратной косой
чертой в строке, которая имеет комментарий.  Это  происходит
из-за того, что, если обратная косая черта предшествует зна-
ку #, то он более не  является  последним  знаком  в  данной
строке.  Если  же он следует за знаком #, то он сам является
частью комментария. Приведем некоторые примеры  комментариев 
в формирующем файле: 
 
     # makefile for GETSTARS.EXE
     # does complete project maintenance
     # implicit rule
     .asm.obj
       masm $* .asm,$*.obj;
     # unconditional rule
     getstars.exe;
       tpc getstars /m
     # dependencies
     slib2.obj: slib2.asm
     slib1.obj: slib1.asm
      masm slib1.asm,slib1.obj;
     # end of makefile

                       Явные правила
 
     Явные правила имеют вид 
 
     цел_файл [команда ...]:[исх_файл исх_файл...]
        [команда]
        [команда]
        ...
 
где "цел_файл" - это  файл,  подлежащий  изменению  (целевой
файл),   "исх_файл"   -   это   файл,  от  которого  зависит
"цел_файл", а  "команда" - это любая допустимая команда опе-
рационной системы ДОС (включая вызов файлов).
     Явные правила определяют одно или несколько имен  изме-
ненных файлов, ноль или несколько исходных файлов и необяза-
тельный список команд, которые должны выполняться. Имена це-
левого (измененного) и исходного файлов, приведенные в явных
правилах, могут содержать обычные спецификации  дисковода  и
каталоги,  но  не  могут содержать глобальных символов имени
файла (* или ?).
     Синтаксис здесь существенен. Имя "цел_файл" должно  на-
ходиться  в начале строки (в колонке 1), в то время как каж-
дая команда должна начинаться с  абзаца  (перед  ней  должен
стоять  по крайней мере один знак пробела). Как отмечено вы-
ше, обратная косая черта (\) может использоваться в качестве
знака продолжения, в случае, если список исходных файлов или
данная команда является слишком длинной и не  помещается  на
одной  строке. Кроме того, исходные файлы и команды являются
необязательными.  Разрешается  использовать  явное  правило,
состоящее только из "цел_файл[цел_файл...]", за которым сле-
дует двоеточие.
     Смысл, который несет с собой использование явного  пра-
вила, заключается в том, что заключительные команды создадут
или изменят файл "цел_файл", обычно используя  файлы  "исх_
файл". Когда обслуживающая программа MAKE обнаруживает явное 
правило, она сначала выясняет,  не  являются  ли  какие-либо 
файлы сами  файлами  "цел_файл"  где-нибудь в другом месте в 
формирующем файле.  Если да, то  такие  правила  вычисляются 
первыми.
     Когда все файлы "исх_файл" созданы или изменены в соот-
ветствии  с другими явными (иили неявными) правилами, обслу-
живающая  программа  MAKE  проверяет,  существует  ли   файл
"цел_файл".  Если нет, то каждая команда вызывается в задан-
ном порядке. Если "цел_файл" не существует, то время и  дата
его  последней  модификации  сравниваются с временем и датой
модификации каждого файла source. Если какой-либо из  файлов
"исх_файл" был изменен позднее, чем файл "цел_файл", то  вы-
полняется список команд. 
     Данное имя файла может появиться с левой стороны явного
правила один раз в данном выполнении обслуживающей программы
MAKE.
     Каждая командная строка в явном  правиле  начинается  с
пробела.  Обслуживающая  программа  МАКЕ  рассматривает  все
строки, следующие после явного правила и до следующей  стро-
ки,  начинающейся  в колонке 1 (без предшествующего пробела)
или до конца файла, в качестве  части  списка  команд  этого
правила. Строки пробелов игнорируются. Явное правило без ко-
мандных строк, следующих за ним,  рассматривается  несколько
иначе, чем явное правило с командными строками.
 
     - Если явное правило существует для  целевого  файла  с
командами, то единственными файлами, от которых зависит этот
целевой файл, являются файлы,  перечисленные  в  этом  явном
правиле.
     - Если явное правило не имеет команд, то целевые  файлы
зависят  от  файлов,  указанных в явном правиле, а также они
могут зависеть от любого  файла,  удовлетворяющего  неявному
правилу для целевых файлов.

     - Ниже показан образующий файл с примерами  явных  пра-
вил: 
 
     myutil.obj:myutil.asm
      masm myutil.asm.myutil.obj;
 
     myapp.exe:  myapp.pas myglobal.tpu myutils.tpu
      tpc myapp /Tc:\tp4\bin
 
     myglobal.tpu: myglobal.pas
      tpc myglobal /Tc:\tp4\bin
 
     myutils.tpu: myutlis.pas myglobal.tpu myutil.obj 
      tpc myutils /Tc:\tp4\bin

     - Первое явное правило указывает, что  файл  MYUTIL.OBJ
зависит  от  файла  MYUTIL.ASM, а файл MYUTIL.OBJ создан при
выполнению заданной команды MASM. (Параметр /Т и имя маршру-
та в этих примерах будут объяснены несколько позже).
     - Второе правило утверждает, что файл MYAPP.EXE зависит
от  MYAPP.PAS,  MYGLOBAL.TPU  и  MYUTILS.TPU и что он создан
данной командой TPC.
     -  Третье  правило  указывает,  что  файл  MYGLOBAL.TPU
зависит  от  файла  MYGLOBAL.PAS  и создан заданной командой
ТРС.
     - Последнее правило указывает, что файл MYUTIL.TPU  за-
висит от файлов MYUTILS.PAS, MYGLOBAL.TPU и MYUTIL.OBJ и что
он создан заданной командой ТРС. 
     - Если вы реорганизуете правило так,  что  правило  для
MYAPP.EXE  становится первым, а за ним следует остальные, то
обслуживающая программа МАКЕ перекомпилирует (или переассем-
блирует)  только те файлы, которые она должна перекомпилиро-
вать (или переассемблировать) для того, чтобы правильно осу-
ществлять коррекцию. Это происходит из-за того, что обслужи-
вающая программа МАКЕ без целевого файла в командной  строке
попытается  выполнить  сначала первое явное правило, которое
она найдет в формирующем файле. 
     - В действительности вы обычно должны опустить два пос-
ледних явных правила и просто добавить директиву /М к коман-
де под явным правилом для файла MYAPP.EXE. Вам однако  необ-
ходимо  будет добавить все зависимости файлов MYGLOBAL.TPU и
MYUTILS.TPU к исходному файлу для MYAPP.EXE.
 
                      Неявные правила
 
     Обслуживающая программа МАКЕ допускает также  определе-
ние неявных правил. Неявные правила являются обобщениями яв-
ных правил. Что это значит? Можно привести пример, иллюстри-
рующий  взаимосвязь  между  двумя  типами правил. Рассмотрим
приведенные ниже явные правила, взятые из предыдущего приме-
ра программы:
 
     myutil.obj: myutil.asm
     masm myutil.asm,myutil.obj;
 
     Это правило является общим правилом, так как оно следу-
ет общему принципу: файл .OBJ зависит от файла .ASM с тем же
файловым именем и создается с  помощью  выполнения  MASM.  В
действительности у вас может быть формирующий файл, где име-
ется несколько (или даже несколько десятков)  явных  правил,
имеющих этот самый же формат.
     Переопределяя явные правила в качестве неявных, вы  мо-
жете отменить все явные правила того же вида. В качестве не-
явного правила оно будет выглядеть следующим образом:
 
     .asm.obj:
       masm $ * .asm,$ *.obj;
 
     Это правило означает: "любой файл,  заканчивающийся  ся
на  .ASM,  а  файл .OBJ создается с помощью команды masm $*,
asm,$*.obj, где $* представляет имя файла  без  расширения".
(Символ $* является специальным макроопределением и описыва-
ется в следующем разделе).
     Синтаксис для неявного правила является следующим:
 
     .исх_файл_расшир.цел_файл_расшир:

       {команда}
       {команда}
       ...
 
где, как и выше, команды являются необязательными  и  должны
начинаться с абзаца. "Исх_файл_расшир" (то, что должно начи-
наться в колонке 1) является расширением исходного файла. То
есть оно применяется к любому файлу, имеющему формат 
 
     имя_файла.исх_файл_расшир
 
     Аналогично, "цел_файл_расшир" ссылается на файл:
 
     имя_файла.цел_файл.расшир
 
где "имя_файла" - это одно и то же для обоих файлов. Другими
словами  неявное правило замещает все явные правила, имеющие
формат:
 
     имя_файла.цел_файл_расшир:имя_файла.исх_файл_расшир:
       {команда}
       {команда}
       ...
 
для любого имени файла.
     Расширение имени файла при возникновении неясности  ис-
пользуется  для определения неявного правила, которое должно
быть применено. Неявное правило используется, если находится
файл  с  тем же именем, что и целевой файл, но с расширением
указанного исходного файла. Например, предположим, что у вас
имелся формирующий файл (с именем MAKEFILE), содержащий:
 
     .asm.obj:
       masm $*.asm,$*.obj;
 
     Если у вас имелась программа  на  языке  ассемблера,  с
именем  RATIO.ASM,  которую  вы хотели скомпилировать в файл
RATIO.OBJ, вы могли бы воспользоваться командой
 
     make ratio.obj
 
     Обслуживающая программа МАКЕ должна  будет  взять  файл
RATIO.OBJ  и  использовть его в качестве целевого. Поскольку
отсутствует явное правило для создания файла  RATIO.OBJ,  то  
обслуживающая  программа МАКЕ использует  неявное  правило и 
сгенерирует команду:
 
     tasm ratio.asm,ratio.obj;
 
которая, конечно, осуществит необходимые действия (использу-
ет Турбо-Ассемблер) для создания файла RATIO.OBJ.
     Неявные правила используются также, если явное  правило
дается  без  команд. Предположим, как отмечалось выше, у вас
имеется в начале формирующего файла следующее неявное прави-
ло:
 
    .pas.tpu:
      tpc $<
 
     Тогда можно переписать два  последних  неявных  правила
следующим образом:
 
     myglobal.tpu; myglobal.pas
     myutils.tpu: myutils.pas myglobal.tpu myutil.obj
 
     Поскольку я вас нет явной информации  по  поводу  того,
как  создать  файлы .TPU, обслуживающая программа использует
неявное правило, определенное ранее.
     Несколько неявных правил могут быть написаны с одинако-
вым расширением целевого файла ("цел_файл_расшир"), но толь-
ко одно такое правило может использоваться в данный  текущий
момент.  Если  для данного расширения целевого файла имеется
более одного неявного правила, то каждое правило проверяется
в  том порядке, в каком эти правила содержатся в формирующем
файле (до тех пор, пока все  применяемые  правила  не  будут
проверены).
     Обслуживающая программа МАКЕ использует первое  неявное
правило,  которое она обнаруживает для файла с исходным рас-
ширением. Даже, если команды этого  файла  ошибочны,  больше
неявные правила не проверяются.
     Все строки, следующие за  неявным  правилом  вплоть  до
следующей строки, которая начинается без пробела или до кон-
ца файла, рассматриваются как часть списка команд для данно-
го  правила.  Строки с пробелами игнорируются. Синтаксис для
командной строки приводится далее в данном разделе.
     В отличие от случая с явными  правилами,  обслуживающая
программа  МАКЕ при работе с неявным правилом не  знает пол-
ного имени файла. По этой  причине  обслуживающая  программа
МАКЕ поддерживает специальные макрокоманды, которые позволя-
ют включать имя данного файла, построенное в соответствии  с
эти  правилом. (Обсуждение, касающееся макроопределений, бо-
лее подробно приводится далее в этом приложении).
     Ниже приводятся некоторые примеры неявных правил:
 
     .pas.exe:
       tpc $<
 
     .pas.tpu:
       tpc $<
 
     .asm.obj:
       tasm $* /mx;
 
     В первом примере неявного правила целевыми файлами  яв-
ляются файлы .ЕХЕ, а их исходными файлами являются файлы ко-
манд (синтаксис командной  строки  приводится  ниже).  Кроме
того, второе неявное правило создает файлы .TPU из файлов
     Последний пример предписывает  обслуживающей  программе
МАКЕ  ассемблировать данный файл из его исходного файла .ASM
с помощью TASM с необязательным параметром /mx.
 
                       Списки команд
 
     Мы обсудили явные и неявные правила, и то, как они  ис-
пользуют  списки  команд.  Давайте  обсудим эти команды и их
возможности.
     Команды в командном списке должны начинаться с  абзаца,
то  есть  им должен предшествовать по крайней мере один знак
пробела, и они должны иметь следующий вид:
 
     [ префикс ... ] тело_команды
 
     Каждая командная строка  в  списке  команд  состоит  из
списка  (не обязательного) префиксов, за которым должно сле-
довать одно тело команды.
     Префиксы, которым позволено быть  в  команде,  изменяют
обработку обслуживающей программой МАКЕ этих команд. Префик-
сом является или знак @ или дефис  (-),  непосредственно  за
которым следует число. 
 
     "@" - Не позволяет обслуживающей программе  МАКЕ  выво-
дить  команду на экран перед ее выполнением. Вывод не осуще-
ствляется, даже если в командной строке утилиты МАКЕ не  был
задан  необязательный  параметр  -S.  Этот префикс относится
только к той команде, в которой он указывается.
 
     "- число" - Влияет на то, как  обслуживающая  программа
МАКЕ  обрабатывает  коды завершения. Если число указывается,
то обслуживающая программа МАКЕ прерывает  обработку  в  том
случае только, если код завершения превышает заданное число.
В приведенном  ниже  примере  обслуживающая  программа  МАКЕ
прервет  выполнение только в том случае, если код завершения
превысит по значению число 4:
 
     -4 myprog sample.x
 
Если "-число префикс" не задается, то обслуживающая програм-
ма  МАКЕ  проверяет  код завершения для данной команды. Если
этот код является ненулевым, то обслуживающая программа  ос-
тановится и удалит текущий целевой файл.
 
     "-" - При наличии дефиса без номера обслуживающая прог-
рамма  MAKE не будет проверять код завершения. Независимо от
кода завершения обслуживающая программа МАКЕ  будет  продол-
жать работу.
 
     Тело команды трактуется точно также, как  если  бы  она
указывалась в качестве строки в файле COMMAND.COM, за исклю-
чением того, что переадресация  ввода-вывода  и  программные
каналы  не используются. Обслуживающая программа МАКЕ выпол-
няет следующие встроенные команды, вызывая для их выполнения
копию COMMAND.COM:
 
      break      cd       chdir      cls      copy
      md         mkdir    path       prompt   ren
      rename     set      time       type     ver
      verify     vol
 
     Обслуживающая программа МАКЕ осуществляет  поиск  имени
какой-либо другой команды с помощью алгоритма поиска ДОС:
 
     - Сначала исследуется текущий каталог, за которым  сле-
дует каждый каталог указанного маршрута.
     - В каждом каталоге ищется сначала файл  с  расширением
.СОМ,  затем - файл с расширением .ВАТ, и, наконец, с расши-
рением .ЕХЕ.
     -  Если  найден  файл   .ВАТ,   то   вызывается   копия
COMMAND.COM для выполнения командного файла.
     Очевидно, что если расширение в командной строке указы-
вается,  то обслуживающая программа МАКЕ обсуществляет поиск
только для этого расширения. 
     Эта команда заставит COMMAND.COM выполнить команду  из-
менения каталога:
 
     cd c:\include
 
     Эта команда будет найдена для  использования  алгоритма
полного поиска:
 
     tpc myprog.pas /$B+,R+,I+
 
     Эта команда будет найдена для использования только рас-
ширения .СОМ:
 
     myprog.com geo.zyz
 
     Следующая команда будет выполнена с помощью  указанного
имени явного файла:
 
     c:\myprogs\fil.exe -r
 
                      Макроопределения
 
     Часто некоторые команды, имена файлов или  директивы  в
формирующем  файле  используются повторно. В примере, приве-
денном ранее в данном разделе все команды  ТРС  использовали
переключатель  /T  c:tp5\bin,  который обозначает, что файлы
TPC.CFG и TURBO.TPU находятся в подкаталоге C:TP5\BIN. Пред-
положим, что вы хотели переключиться для этих файлов на дру-
гой подкаталог. Что нужно для этого сделать? Вы могли бы по-
очередно изменить все опции /Т, вставляя соответствующее имя
маршрута, или могли бы задать макроопределения.
     Макроопределение - это  имя,  представляющее  некоторую
строку символов.  Макроопределение  представляет  имя макро-
определения и текст расширения. Поэтому, когда обслуживающая
программа  МАКЕ обнаруживает имя макроопределения, она заме-
щает это имя текстом расширения.
     Предположим, вы определили следующее макроопределение в
начале формирующего файла:
 
     TURBO=c:tp5\bin
 
     Вы определили макроопределение TURBO, которое  является
эквивалентным строке c:tp5\bin. Теперь формирующий файл мож-
но переписть следующим образом:
 
     TURBO=c:tp5\bin
     myapp.exe: myapp.pas myglobal.tpu myutils.tpu
     tpc myapp /T${TURBO}
     myutils.tpu: myutils.pas myglobal.tpu myutil.obj
     tpc myutils /T${TURBO}
     myglobal.tpu myglobal.pas
     tpc myglobal /T${TURBO}
     myutil.obj: myutil.asm
     masm myutil.asm,myutil.obj;

     Везде, где указывается каталог TURBO, используется мак-
ровызов  $(TURBO).  Когда  вы выполняете обслуживающую прог-
рамму МАКЕ,  $(TURBO)  замещается  текстом  его  расширения,
c:\TP5.BIN.  Результатом будет являться тот же набор команд,
то у вас был и ранее.
     Итак, что вы получили? Гибкость. Заменой первой  строки
на
     TURBO=c:\tp5\project
 
вы заменили все команды, чтобы воспользоваться файлами  кон-
фигурации  или библиотечными файлами в другом подкаталоге. В
действительности, если вы вышли из первой строки совсем,  то
вы  можете  указать  с  помощью нобязательного параметра -D,
какой подкаталого нужно использовать при выполнении осблужи-
вающей программы МАКЕ:
 
     make -DTURBO=c:tp5\project
 
     Указанное  выше  предписывает  обслуживающей  программе
МАКЕ  трактовать TURBO как макроопределение с текстом расши-
рения:
    
      c:tp4\project.

     Макроопределения имеют вид
 
     имя_макро=текст макрорасширения
 
где "имя_макро" - это имя  макроопределения:  последователь-
ность  букв  и  цифр без пробелов внутри нее, хотя вы можете
иметь пробел между "мя_макро" и знаком равенства (=).  Текст
макрорасширения - это произвольная строка, содержащая буквы,
цифры, пробелы и пунктуацию. Она заканчивается возвратом ка-
ретки.
     Если macroame было определено ранее или с помощью  мак-
роопределения  в формирующей файле, или с помощью опции -D в
командной строке МАКЕ, то новое определение заместит старое.
     Использование верхнего и нижнего регистров в макроопре-
делении  является существенным. То есть имена макроопределе-
ний turbo, Turbo и TURBO рассматриваются как  имена  различ-
ные.  Макроопределения  вызываются  в ваш формирующий файл с
помощью формата:
 
     $(имя_макро)
 
     Круглые скобки являются обязательными для всех вызовов,
если  макроимя  является однознаковым. Исключения составляют
три специальных предопределенных макрорасширения, о  которых
расскажем далее. Конструкция $(имя_макро) называется  макро-
вызовом.
     Когда обслуживающая программа МАКЕ обнаруживает  макро-
вызов, она замещает этот вызов текстом расширения этого мак-
роопределения. Если макроопределение не определено, то  обс-
луживающая программа МАКЕ замещает его нулевой строкой. 
     Допускается  использовать  вложенные  макроопределения.
Макроопределения  не  могут  быть  вызваны  с  левой стороны
(имя_макро) макроопределения.  Они  могут  использоваться  с
правой стороны (текст макрорасширения), но они не расширяют-
ся до тех пор, пока не вызовется определенное макроопределе-
ние.  Другими  словами,  когда макровызов расширяется, любые
макроопределения, вставленные в текст  его  расширения,  уже
должны быть расширены. Макроопределения можно использовать в
правилах. Макровызовы в  строках  правил  расширяются непос-
редственно.
     Макроопределения в директивах: макровызовы  расширяются
в директивах /if и /elif сразу же. Если вызванное макроопре-
деление в  директивах  /if  или  /elif в  данный  момент  не
определено, то оно расширяется в значение 0 (False).
     Макроопределения в  командах:  макровызовы  в  командах
расширяются при выполнении команд.
     Обслуживающая программа МАКЕ поставляется с несколькими
специальными предопределенными встроенными макроопределения-
ми: $d, $*, $<, $:, $., $E. Первое макроопределение является
определенным  макротекстом, используемым в условных директи-
вах /if и /elif. Остальные макроопределения являются  макро-
определениями  имен  файлов,  используемых в явных и неявных
правилах. Кроме того текущие строки среды SET  автоматически
загружаются в качестве макроопределений, Макроимя _MAKE_ оп-
ределено, как 1 (единица).
 
               Проверка макроопределения ($d)
 
     Mom`coi^ k^iommnocbcjclg~  $d расширяется в 1, если за-
данное имя макроопределения определено, или в 0, если оно не
определено. Содержимое текста макрорасширения не имеет  зна-
чения. Это специальное макрорасширение допускается использо-
вать только в директивах /if и /elif. Например, предположим,
что  вы  хотите изменить свой формирующий файл так, чтобы он
использовал конкретный каталог Турбо-Паскаля. Вы можете ука-
зать его в начале своего формирующего файла:
 
     ! if !$d(TURBO)        # Если TURBO не определяется,
     TURBO=c:\tp5\bin       # определите его как C:\TP5\BIN
     !endif
 
     Если вы вызвали обслуживающую программу МАКЕ  командной
строкой:
 
     make -DTURBO=c:\tp5\project
 
то TURBO определяется как c:\tp5\project.  Если  вы  вызвали
обслуживающую программу МАКЕ просто ее собственным именем:
 
     make
 
то TURBO определяется как c:\tp5\bin (подкаталог, рассматри-
ваемый по умолчнию).
 
         Макроопределения имени базового файла ($*)
 
     Макроопределения имени базового файла допускаются в ко-
мандах для явных и неявных правил. Это макроопределение ($*)
расширяет текст до имени построенного файла, исключая всякие
добавления, следующим образом:
 
     Имя файла A:PTESTFILE.PAS
     $* расширяет текст до A:PTESTFILE
 
     Например, вы могли бы изменить уже заданное явное  пра-
вило MYAPP.EXE на следующее
 
     myapp.exe: myapp.pas myglobal.tpu myutils.tpu
       tpc $* /T$(TURBO)
 
     Когда команда в этом правиле будет выполняться, то мак-
роопределение  $* будет заменено именем  целевого файла (без
расширения), myapp. Для неявных правил такое макрорасширение
бывает очень полезным.
     Например, неявное правило для ТРС могло выглядеть  сле-
дующим  образом (в предположении, что макроопределение TURBO
уже было или будет определено):
 
     .pas.exe:
       tpc $* /T$(TURBO)
 
         Макроопределения полного имени файла ($<)

     Макроопределения полного имени файла ($<) также исполь-
зуются в командах для явных или неявных правил. В явном пра-
виле $< расширяет текст  до  полного  имени  целевого  файла
(включая расширение) следующим образом:
 
     Имя файла - A:PTESTFILE.PAS
     $< расширяет до A:PTESTFILE.PAS
     Например, правило
 
     starlib.tpu: starlib.pas
       copy $< \oldtpus
       tpc $* /T$(TURBO)
 
скопирует   STARLIB.TPU   в   каталог   перед    компиляцией
STARLIB.PAS.
     В неявном правиле $< примет вид имени файла, плюс раши-
рение  имени  исходного  файла. Например, предыдущее неявное
правило:
 
     .asm.obj:
       tasm $*.asm,$*.obj;
 
может быть переписано следующим образом
 
     .asm.obj:
       masm $<,$*.obj;  
 
         Макроопределение имени маршрута файла ($:)
 
     Данное макроопределение расширяет текст до  имени  мар-
шрута (без имени файла) следующим образом:
 
     Имя файла - A:PTESTFILE.PAS
     $: расширяет тексты до A:P
 
       Макроопределение имени файла и расширения ($.)
 
     Это макроопределение расширяет текст до имени  файла  с
добавлением следующим образом:
 
     Имя файла - A:PTESTFILE.PAS
     $. расширяет текст до TESTFILE.PAS
 
             Макроопределение имени файла ($E)

     Это макроопределение расширяет текст до имени файла без
имени маршрута и расширения следующим образом:
 
     Имя файла - A:PTESTFILE.PAS
     $E расширяет текст до TESTFILE
 
                         Директивы
 
     Данная версия обслуживающей программы МАКЕ, связанная с
Турбо-Паскалем,  допускает некоторые возможности недоступные
другим версиям обслуживающей программы МАКЕ,  например,  ус-
ловные директивы, аналогичные условным директивам, допускае-
мым в Турбо-Паскале. Вы можете использовать  эти  директивы,
чтобы включать другие формирующие файлы, чтобы делать прави-
ла и команды условными, чтобы выводить на печатающие устрой-
ства сообщения об ошибках и чтобы отменять макроопределения.
     Директивы в формирующем файле  начинаются  с  восклица-
тельного  знака  (!)  в  качестве первого знака строки. Ниже
приводится полный список  директив  обслуживающей  программы
МАКЕ:
 
     !include
     !if
     !else
     !elif
     !endif
     !error
     !undef
 
     Директива включения  файла  (include)  вказывает  файл,
подлежащий  включению в формирующий файл для интерпретации в
качестве директивы. Данная директива имеет следующий вид:
 
     !include "имя_файла"
 
или
 
     !include <имя_файла>
 
     Эти директивы могут быть вложены одна в другую на любую
глубину. Если директива включения осуществляет попытку вклю-
чить файл, уже включенный на более высоком  уровне  вложения
(так  что должно начаться зацикливание), то более внутренняя
директива включения отвергается как ошибочная.
     Как пользоваться такой директивой? Предположим, вы соз-
дали файл PATH.MAC, содержащий следующее:
 
     !if !$d(TURBO)
     TURBO=c:\tp5\bin
     !endif

     Вы можете воспользоваться этим условным  макроопределе-
нием в любом формирующем файле, включая директиву
 
     !include "PACH.MAC"
 
     Когда обслуживающая программа МАКЕ обнаруживает  дирек-
тиву  include, она ищет файл и считывает его содержимое, как
если бы оно находилось в самом формирующем файле.
     Условные директивы (!if, !elif, !else и !endif) опреде-
ляют для программиста степень гибкости при создании формиру-
ющих файлов. Правила и макроопределения могут  быть  сделаны
условными,  так  что  макроопределения в командной строке (с
помощью директивы -D) могут приводить в действие  или  отме-
нять разделы формирующего файла. 
     Формат этих директив аналогичен формату (но более длин-
ный) использующихся в Турбо-Паскале условных директив:
 
     !if expression
       [ текст ]
     !endif
 
     !if expression
       [ текст ]
     !else
       [ текст ]
     !endif
 
     !if expression
       [ текст ]
     !elif expression
       [ тескт ]
     !endif
 
     Примечание [ текст ] может принимать следующие
     значения:
 
           (макроопределение)
           (явное правило)
           (неявное правило)
           (директива включения)
           (группа if)
           (директива error)
           (директива undef)
 
     Условные директивы образуют группу, состоящую по  край-
ней  мере  из  директивы !if, начинающей группу, и директивы
!endif.
     - В группе может появляться одна директива !else.
     - Директивы !elif могут  находиться  между  директивами
!if и любой директивой !else.
     - Правила, макроопределения и  другие  директивы  могут
находиться  между  различными  условными директивами в любом
количестве. Учтите, что полные правила с их командами не мо-
гут разбиваться условными директивами.
     - Группы условных директив могут  вкладываться  одна  в
другую на любую степень глубины.
     Любые правила, команды или директивы должны завершаться
внутри одного исходного файла.
     Любые директивы !if должны иметь соответствующие им ди-
рективы  !endif внутри одного и того же исходного файла. Та-
ким образом, следующий включаемый файл  является  неправиль-
ным,  независимо  от того, что содержится в любом из файлов,
который мог бы содержать его, так как этот  первый  файл  не
содержит соответствующей директивы !endif:
 
     !if $(FILEOUNT) > 5
     some rules ; правила
     !else
     other rules ; другие правила
     <end-of-file> ; конец файла
 
     Выражения, допускаемые в директивах !if или !elif,  ис-
пользуют синтаксис аналогичный синтаксису языка программиро-
вания С. Выражение вычисляется как простое 32-битовое  целое
выражение со знаком.
     Число могут вводиться как  десятичные,  восьмеричные  и
шестнадцатиричные константы. Например, приведенные ниже чис-
ла являются правильными константами выражения:
 
     4536                    десятичная константа
     0677                    восьмеричная константа
     0x23aF                  шестнадцатиричная константа
 
     В выражении могут использоваться следующие унарные опе-
рации:
 
    -   отрицание
    ~   битовое определение
    !   логическое не
 
     В выражении могут использоваться любые из следующих
бинарных операций:
 
    +   сложение
    -   вычитание
    *   умножение
    /   деление 
    %   остаток
    "   правый сдвиг
    "   левый сдвиг
    &   побитовое и
    |   побитовое или
    ^   побиовое исключительное или
    &&  логическое и
    ||  логическое или
    >   больше
    <   меньше
    >=  больше или равно
    <=  меньше или равно
    ==  равенство
    !=  неравенство
 
     Выражение может содержать следующий тернарный оператор:
 
    ?:  операнд  перед  знаком  вопроса  рассматривается как
        проверка. Если значение такого  операнда  ненулевое,
        то второй операнд (часть между знаком вопроса и дво-
        еточием) является результатом. Если значение первого
        операнда  равно  нулю,  то значение результата - это
        значение третьего операнда (часть после двоеточия).
 
     Для объединения операндов в выражении  в  группы  могут
использоваться  круглые  скобки.  В случае отсутствия скобок
бинарные операции группируются в  соответствии  с  правилами
последовательности  выполнения операторов, использующимися в
языке С.
     Как и в языке С, для операторов  одинакого  старшинства
группирования  происходят слева направо (за исключением тер-
нарного оператора (?:), для которого группирование  происхо-
дит справа налево).
     Внутри выражения могут быть  вызваны  макроопределения,
распознается  специальное  макроопределение $d(). После всех
расширенных макроопределений в выражении должен  соблюдаться
правильный  синтаксис.  Любые слова в расширенных выражениях
интерпретироваться, как ошибки.
     Директива  ошибки  (!error)  заставляет   обслуживающую
программу  МАКЕ  прекратить работу и распечатать диагностику
фатальной ошибки, содержащую указанный после  !error  текст.
Директива имеет формат:
 
     !error любой_текст
 
     Эта директива создана для того,  чтобы  ее  можно  было
включать  в условные директивы, позволяющие пользователю оп-
ределять условия прерывания. Например,  можно  перед  первым
явным правилом вставить следующий текст:
 
     !if !$d(TURBO)
      if TURBO is not defined
     !error TURBO not defined
     !endif
 
     Если вы дошли до этого места, а TURBO не определено, то
обслуживающая  программа МАКЕ остановится и выдаст сообщение
об ошибке:
 
     Fatal makefile 5: Error directive: TURBO not defined
     ( TURBO не определено)
 
     Директива разопределения (!undef) приводит к тому,  что
любое определение макрорасширения имени будет "забыто". Если
макроопределение в данный момент не оперделено, то  эта  ди-
ректива не будет действовать. Синтаксис следующий:
 
     !undef имя_макроопределения
 
         Использование обслуживающей программы МАКЕ
 
     Теперь вы знаете, как писать формирующие файлы.  Сейчас
настало  время изучить то, как использовать их с обслуживаю-
щей программой МАКЕ. Самый  простой  способ  воспользоваться
обслуживающей программой МАКЕ - это после подсказки ДОС наб-
рать команду:
 
     make
 
После этого обслуживающая программа МАКЕ будет  искать  файл
MAKEFILE.  Если она не сможет его найти, то она будет искать
файл MAKEFILE.MAK. Если она и его не  найдет,  то  прекратит
выполнение с выдачей сообщения об ошибке.
     А что, если вы захотите воспользоваться файлом с именем
отличным  от имен MAKEFILE или MAKEFILE.MAK? Вы укажете обс-
луживающей программе МАКЕ необязательный параметр (-f):
     make -fstars.mak
 
     Общий синтаксис для обслуживающей программы МАКЕ таков:
 
 make необяз_парам необяз_парам  ...  цел_файл  цел_файл ... 
 
где "необяз_парам" - параметр обслуживающей  программы  МАКЕ
(объясняется  далее), а "цел_файл" - это имя целевого файла,
подлежащего обработке с помощью явных правил.
     Ниже приводятся синтаксические правила:
     - Слово make стоит перед пробелом, а затем список пара-
метров make.
     - Каждый параметр make отделяется от соседних  парамет-
ров пробелом. Необязательные параметры могут  указываться  в 
любом порядке и любом количестве (столько, сколько позволяет  
место в командной строке).
     - После списка параметров make ставится пробел, а затем
необязательный список имен целевых файлов.
     - Каждое имя целевого файла также должно отделяться  от
соседних пробелом. Обслуживающая программа МАКЕ обрабатывает
целевые файлы в указанном вами  порядке,  перекомпилируя  их
в соответствии с необходимостью.
 
     Если командная строка не включает никаких имен  целевых
файлов,  то  обслуживающая  программа МАКЕ использует первый
упомянутый в явном правиле целевой файл. Если один или более
целевых  файлов упоминаются в командной строке, то они будут
построены в соответствии с необходимостью.
     Приведем несколько примеров командных строк  обслужива-
ющей программы МАКЕ:
 
     make -n -fstars.mak
     make -s
     make -Iinclude -DTURBO=c:\tp5\project
 
     Примечание: Обслуживающая программа МАКЕ прекратит свою  
     работу, если любая команда, которую она выполнила, пре-
     рываеется  из-за  предачи  управления.  Таким  образом, 
     нажатие клавиш Ctrl-C остановит  выполнение текущей ко-
     манды,  а также обслуживающей программы МАКЕ.
 
                     Файл BUILTINS.MAK
 
     При использовании обслуживающей программы МАКЕ вы часто
обнаруживаете, что имеются макроопределения и правила (обыч-
но неявные правила), которые используются  много  раз.  Есть
три  способа их обработки. Во-первыых, вы можете помещать их
в каждый формирующий файл, который создаете.  Во-вторых,  вы
можете  помещать их всех в один файл и пользоваться директи-
вой !include в каждом формирующем файле,  который  создаете.
В-третьих,  вы  можете  поместить  их  всех в файл, с именем
BUILTINS.MAK.
     При каждом выполнении обслуживающей программы МАКЕ, она
осуществляет поиск файла с именем BUILTINS.MAK. Если она на-
ходит этот файл, то считывает его перед обработкой  MAKEFILE
(или  любого  формирующего  файла, который вы хотите обрабо-
тать). 
     Файл  BUILTINS.MAK  предназначается  для  любых  правил
(обычно  неявных правил) или макроопределений, которые будут
служить для общего пользования в файлах в любом месте на ва-
шей вычислительной машине.
     Наличие файла BUILTINS.MAK  не  является  обязательным.
Если обслуживающая программа МАКЕ находит файл BUILTINS.MAK,
то она интерпретирует его первым. Если  обслуживающая  прог-
рамма МАКЕ не может найти файла BUILTINS.MAK, она приступает
к непосредственному интерпретированию  файла  MAKEFILE  (или
любого формирующего файла, который вы укажете).
 
               Как обслуживающая  программа  
             МАКЕ  осуществляет  поиск файлов

     Обслуживающая пр
error in text..................
торый вид синтаксических или семантических ошибок в исходном
формирующем файле. Обслуживающая программа МАКЕ в этом  слу-
чае завершит интерпретацию формирующего файла, а затем оста-
новится.
 
                      Фатальные ошибки
 
     Don't know how to make XXXXXXXX 
     (Неизвестно, как сформировать ХХХХХХХХ)
 
     Данное сообщение выдается, когда обслуживающая програм-
ма  МАКЕ  обнаруживает в  последовательности  построения имя
несуществующего файла, а правила, которые позволяли бы сфор-
мировать имя файла, отсутствуют.
 
     Error directive: XXXX (Неверная директива: ХХХХ)
 
     Это сообщение выдается, когда  обслуживающая  программа
МАКЕ  обрабатывает  директиву  в исходном файле error. Текст
директивы выводится на экран в сообщении.
 
     Incorrect command line argument: XXX (Неверный аргумент
в командной строке:ХХХ)
 
     Данная ошибка появляется, если обслуживающая  программа
МАКЕ выполняется с неверным аргументом в командной строке.
 
     Not enough memory (Недостаточно памяти)
 
     Данная ошибка появляется, если вся рабочая  память  ис-
черпана.  Вы должны попытаться осуществить то же на вычисли-
тельной машине с большой памятью. Если на вашей вычислитель-
ной машине имеется уже 640К, то упростите исходный файл.
 
     Unable to execute command  (Нет  возможности  выполнить
команду)
 
     Это сообщение выдается после того, как  команда  должна
была  выполнена.  Это могло произойти из-за того, что коман-
дный файл не был найден, или из-за того, что в нем были сде-
ланы  ошибки.  Наименее вероятно, что команда существует, но
каким-либо образом испорчена.
 
     Unable to open makefile (Нет возможности открыть форми-
рующий файл)
 
     Данное сообщение выдается, когда оглавление не содержит
файла по имени MAKEFILE.
 
                           Ошибки
 
     Bad file name format in include statement (В  операторе
включения задан неправильный формат имени файла)
 
     Имена включаемых файлов должны  заключаться  в  кавычки
или  угловые  скобки. Были пропущена открывающая кавычка или
угловая скобка.
 
     Bad undef statement syntax (Ошибка в систаксисе  опера-
тора "разопределения")
 
     Оператор !undef должен содержать один  идентификатор  и
ничего больше, как тело оператора.
 
     Character constant too long (Знаковая  константа  имеет
слишком большую длину)
 
     Знаковые константы могут иметь в длину только один  или
два знака.
 
     Command arguments too  long  (Аргументы  команды  имеют
слишком большую длину)
 
Аргументы команды, выполняемой обслуживающей программой  МА-
КЕ,  имеют  в длину более 127 знаков - ограничение, установ-
ленное системой ДОС.
 
     Command syntax error (Синтаксическая ошибка в команде)
 
     Это сообщение появляется, если:
     - Первая строка правила начинается с пробела.
     - Неявное правило не состоит из ".расшир.расшир:".
     - Явное правило не содержит имени перед ":" символа.
     - Макроопределение не содержит имени перед "=" символ.
 
     Division by zero (Деление на ноль)
 
     Деление или остаток в операторе !if имеет нулевой дели-
тель.
 
     Expression syntax error in !if statement  (Синтаксичес-
кая ошибка выражения в операторе !if)
 
     Выражение в операторе !if имеет неправильный  вид:  оно
содержит  неравное количество открывающих и закрывающих ско-
бок, лишний или пропущенный  оператор  или  пропущенную  или
лишнюю константу.
 
     File name too long (Имя  файла  имеет  слишком  большую
длину)
 
     Имя файла, заданное в директиве !include, имеет слишком
большую  длину для обработки ее обслуживающей программой МА-
КЕ. Имена маршрута файла в оерационной  системе  ДОС  должны
иметь в длину не более 78 знаков.
 
     Illegal character in constant  expression  X  (Неверный
знак в константном выражении Х)
 
     Обслуживающая программа МАКЕ обнаружила некоторый  сим-
вол, недопустимый для  выражения-константы. Если этим симво-
лом является буква, то это определяет  (вероятно)  идентифи-
катор, где имеется синтаксическая ошибка.
 
     Illegal octal digit (Неверная восьмеричная цифра)
 
     Обнаруженная восьмеричная константа  содержит  цифру  8
или 9.
 
     Macro expansion too long (Макрорасширение слишком вели-
ко)
 
     Макроопределение не может расширятться  более,  чем  на
4096 знаков. Такая ошибка часто появляется, если осуществля-
ется регулярное макрорасширение.  Макропределение  не  может
правильно расширять самое себя. 
 
     Misplaced elif statement (Оператор elif находится не на
месте)
 
     Директива !elif обнаружена без соответствующей  ей  ди-
рективы !if.
 
     Misplaced  else  statement  (Неверно  помещен  оператор
else)
 
     Обнаружена директива !else без соответствующей  ей  ди-
рективы !if.
 
     Misplaced endif  statement  (Неверно  помещен  оператор
endif)
 
     Была обнаружена директива !endif без соответствующей ей
директивы !if)
 
     No file name ending (Не закончено имя файла)
 
     Имя файла в операторе включения не содержит закрывающей
кавычки или угловой скибки.
 
     Redefinition of target XXXXXXXX (Повторное  определение
имени целевого файла ХХХХХХХХ)
 
     Названный файл обнаружен с левой стороны нескольких яв-
ных правил.
 
     Unable to open include file XXXXXXXXX.XXX  Нет  возмож-
ности открыть включаемый файл ХХХХХХХХХ.ХХХ)
 
     Названный файл не найден.  Это  могло  произойти  из-за
того,  что  включаемый файл включает самого себя. Проверьте,
сущестует ли найденный файл.
 
     Unexpected end of file in conditional started on line 
     (Неправильное окончание файла из  строки    в  условии,
начинающемся на строке #)
 
     Исходный файл закончился перед тем,  как  обслуживающая
программа  МАКЕ обнаружила !endif. Директива !endif была или
пропущена, или в ней имелась синтаксическая ошибка.
 
     Unknown preprocessor  statement  (Неизвестный  оператор
препроцессора)
 
     Был обнаружен знак "!" в начале строки, а имя  операто-
ра,  следующее  затем,  не  было одним из следующего: error,
undef, if, elif, include, else или endif.
 
               Обслсуживающая программа TOUCH
 
     Бывают случаи, когда нужно перекомпилировать конкретный
целевой  файл  или перестроить его, даже если не осуществля-
лись изменения в его  исходных  файлах.  Одним  из  средств,
плзвллыющих осуществить это является обслуживающая программа
TOUCH, включенная в Турбо-Паскаль.  Обслуживающая  программа
TOUCH  заменяет дату и время одного или нескольких файлов на
текущие дату и время, делая таким образом  этот  файл  более
новым, чем файлы от него зависящие.
     Чтобы перестроить целевой файл, примените эту программу
к  одному  из файлов, от которых зависит целевой файл. Чтобы
применить данную программу к файлу (или файлам), после подс-
казки ДОС введите
 
     touch имя_файла [ имя_файла... ]
 
Обслуживающая программа TOUCH после этого изменит даты  соз-
дания файлов.
     После этого можно вызвать обслуживающую программу МАКЕ,
чтобы перестроить обработанные таким образом файлы. (При ра-
боте с обслуживающей  программой  TOUCH  можно  пользоваться
глобальными символами имени файла ДОС * и ?.)
 
                Обслуживающая программа GREP
 
     Эта программа также имеется  на  дистрибутивных  дисках
Турбо-Паскаля  и  является автономной обслуживающей програм-
мой. Программа GREG является мощным средством,  осуществляю-
щим поиск текста одновременно в нескольких файлах. Например,
если вы забыли программу,  которой  определена  процедура  с
именем  SetUpMyModem, то можно воспользоваться обслуживающей
программой GREP, чтобы исследовать содержимое всех файлов на
наличие в них строки SetUpMyModem.
     Синтаксис командной строки для обслуживаующей программы
GREP является следующим: 
 
     GREP [опции] имена_файлов_поиска
 
         Переключатели обслуживающей программы GREP
 
     Необязательные  параметры   (переключатели)   командной
строки - это один или несколько знаков, перед которыми стоит
дефис (-). За каждым отдельным  знаком  переключателя  может
следовать символ "+", выполняющий функцию включения парамет-
ра или другой знак дефиса "-",  выполняющий  функцию  отмены
параметра.  По  умолчанию  предполагается  наличие знака "+"
(например, -r значит то  же  самое,  что  и  -r+).  Приведем
список необязательных параметров, используемых при работе  с
облуживющей программой GREP, и их значений:
 
     -С (только счетчик). Печатается только количество  сов-
падающих  строк, то есть имя файла и число совпадающих строк
для каждого файла, которое содержит  по  крайней  мере  одну
совпадающую строку. Сами совпадающие строки не печатаются.
 
     -D (каталоги). Для каждого набора файлов, указанного  в
командной  строке, все файлы, которые сравниваются по специ-
фикациям глобальных симолов имени файла, ищутся в  указанном
каталоге  и всем подкаталоги указанного каталога. Если набор
файлов указывается без пути доступа, то подразумевает  теку-
щий каталог.
 
     -I (игнорировать различие в строчных и прописных букв).
Утилита  GREP  будет игнорировать различие в строчных и про-
писных буквах, то есть символы a-z будут  интерпретироваться
так же, как символы A-Z.
 
     -L (вывод списка совпадающих имен  файлов).  Печатается
только имя каждого файла, содержащее цель поиска. После того
как цель поиска найдена, печатается имя файла, и тут же  на-
чинается обработка следующего файла.
 
     -N (номера). Перед каждой выводимой совпадающей строкой
печатается ее номер.
 
     -О (выходной формат операционной системы UNIX).  Выход-
ной  формат  совпадающих  строк  изменяется для более полной
поддержки конвейеризации команд по типу операционной системы
UNIX. Перед всеми строками вывода указывается имя файла, со-
держащего совпадающую строку.
 
     -R (поиск обычных выражений). Текст, заданный  парамет-
ром "имена_файлов_поиска", трактуется как обыкновенное выра-
жение, а не как строка.
 
     -U (обновить параметры). Утилита  GREP  будет  сочетать
параметры,  заданные  в командной строке, с параметрами, ис-
пользуемыми по умолчанию, и записывать эти параметры в  файл
GREP.COM,  как новые принятые по умолчанию значения (другими
словами, выполняется настройка конфигурации  утилиты  GREP).
Этот параметр позволит вам настроить значения, рассматирива-
емые утилитой GREP по умолчанию, по вашему усмотрению.
 
     -V (несовпадения). Выводятся только несовпадающие стро-
ки. Только строки, содержащие строку поиска, рассматриваются
как совпадающие строки.
 
     -W (поиск слова). Найденный с совпадающий с обычным вы-
ражением текст будет рассматриваться, как совпадающий, толь-
ко если  непосредственно  предшествующий  и  непосредственно
следующий символ не является частью слова. Принятый по умол-
чанию набор символов слов включает в себя символы A-Z, 9-0 д
символ  подчеркивания  (_). Альтернативная форма этого пара-
метра позволяет вам задавать набор разрешенных для слов сим-
волов.    Она    имеет   вид:   -W[множество_сиволов],   где
"множество_символов" представляет собой  обычной  допустимое
выражение, являющееся оперделением множества. Если для опре-
деления множества используются алфавитные символы,  то  мно-
жество автоматически будет определено так, что в него войдут
как строчные, так и прописные символы, независимо  от  того,
какие символы были использованы в определении (даже если при
поиске они различаются). Если параметр -W используется в со-
четании  с параметром -U, то набор допустимых символов будет
сохранен в качестве принятого по умолчанию.
 
     -Z (расширенный вывод). Выводится имя каждого  искомого
файла.  Перед  каждой совпадающей строкой ставится ее номер.
Задается количество сранимаемых строк в каждом  файле,  даже
если оно равно нулю.
 
     Некоторые из этих параметров находятся в прямом  проти-
воречии друг с другом. В таких случаях применяется следующий
порядок (первый параметр - это параметр, имеющая преимущест-
ва):
 
     -z -l -c -n 
 
     Каждое вхождение опции подавляет  предыдущее  определе-
ние. Может быть установлено значение по умолчанию для каждой
опции.
     С помощью параметр -U вы можете вы можете  для  каждого
параметра   установить   значение   по  умолчанию  из  файла
GPER.COM. Например, если вы хотите  использовать  включенное
значение  параметра -Z, то его можно задать следующей коман-
дой:
 
     GREP -U -Z
 
        Как осуществить поиск с помощью утилиты GREP
 
     Значение  "имена_файлов_поиска"  определяет  последова-
тельность  поиска.  Строка может быть заключена в кавычки (с
тем чтобы не ставить пробелы и не путать последние со знака-
ми-ограничителями).   При   использовании  переключателя  -r
строка поиска рассматривается как обыкновенное выражение  (в
в  противоположность  символьному   выражению),  а следующие
символы принимают специальные значения:
 
     ^ Каре в начале выражения отмечает начало строки. 
     $ Знак доллара в конце выражения отмечает конец строки.
     * Выражение, за которым следует глобальный знак *, сов-
падает  или  с  отсутствием  появления этого выражения или с
несколькими появлениями такого выражения: fo* совпадает с f,
fo, foo  и так далее.
     + Выражение, за которым следует знак +, совпадает или с
выражением таким же, появляющимся один раз или с выражениями
такими же, появляющимися  несколько  раз: fo+  совпадает  со 
строкой fo, foo и так далее, но не с f.
     [] Строка, заключенная в квадратные скобки, совпадает с
любым  знаком  в  этой строке, но не с другими знаками. Если
первый знак строки является символом каре (^), то  выражение
сравнивается  с  любым  знаком,  за  исключением знаков этой
строки. Например, [xyz^] совпадает  с  х,y,  и  z,  а  [xyz]
совпадает  с  а  и b, но не с х или y. Диапазон знаков можно
указывать с помощью двух знаков,  разделенных  дефисом  (-).
Эти свойства можно совместить, чтобы формировать выра- жения
типа [a-bd-z?], которые совпадают с любой буквой за исключе-
нием с и ?.
 
           Примечание: четыре знака ($, +, *, и .) не  имеют
      никакого  специального значения при использовании их в
      наборе. Знак ^  интерпретируется  специальным  образом
      только  в  том случае, если он следует непосредственно
      за началом набора (то есть сразу после знака [). 
 
     \ Знак обратной косой черты "знак перехода" предписыва-
ет GREP осуществлять поиск литерала, который следует за ним.
Например, \. сравнивается с точкой вместо какого-нибудь зна-
ка.
     Любой обычный символ, не упомянутый выше,  совпадает  с
этим символом. 
     Конкатенация обыкновенных выражений представляет  собой
обыкновенные выражения. 
 
            Примеры использование программы GREP
 
     Следующие примеры предполагают, что  все  параметры  по
умолчанию отключены:
 
     grep main( *.pas
 
     находит:
 
                main()
                mymain(
 
     не находит:
 
                mymainfunc()
                MAIN(i: integer);
 
     ищет: *.pas в текущем каталоге.
 
           Примечание: По умолчанию поиск зависит от принад-
      лежности  символа  к тому или иному регистру (является
      символ строчным или прописным).
 
     grep -r [a-z]main *( *.pas
 
     Находит: 
 
     main(i:integer)
     main(i,j:integer)
     if (main () ) halt;
 
     Не находит:
 
                mymain() 
                MAIN(i:integer);
 
     ищет: *.pas в текущем каталоге.
 
           Примечание: Поскольку пробелы обычно рассматрива-
      ются как ограничители командных строк, необходимо зак-
      лючить их в кавычки в случае, если вы хотите  включить
      их  в  обычное  выражение.  В этом случае пробел после
      main был выделен с помощью обратной косой  черты.  Это
      также могло быть выполнено с помощью помещения пробела
      или всего обыкновенного выражения  в  двойные  кавычки
      (").
 
     grep -ri [a-c]:data.fil *.pas *.inc
 
     находит: 
 
                a:\data.fil
                c:\data.fil
                b:\data.fil
 
     не находит: 
 
                d:\data.fil
                a:data.fil
                writeln("c:\\data.fil");
 
     Ищет *.pas и *.inc в текущем каталоге.
 
           Примечание: Из-за того, что знаки "\" и "." обыч-
      но имеют специальные значения в случае, если вы хотите
      осуществить их поиск, необходимо выделить их,  помещая
      знак обратной косой черты непосредственно перед ними.
 
     grep -ri [a-z]word[a-z] *.doc
 
     находит: 
 
           every new word must be on a new line.
           my word!
           word--smallest unit of speech.
           in the beginning there was thr word, and the word
 
     не находит:
 
                each file has at least 2000 words.
                he misspells toward as toword.
 
     ищет: *.doc в текущем каталоге.
 
           Примечание: Данный формат в  основном  определяет
      поиск строки "word".
 
grep "search stiring with spaces" *.doc *.asm a:workmyfile.*
 
     находит:
 
          this is a search string with spaces in it.
 
     не находит:
 
          this is a search string with spaces in it.
          this is a search string with many spaces in it.
 
     ищет: *.doc и *.asm в текущем каталоге и  каталоге  my-
file, а также в каталоге с именем work на дисководе а:.
 
           Примечание:  Приведем  пример  того,  как  ищется
      строка с включенными в нее пробелами:
 
     grep -rd "[ ,.:?'"]"$ *.doc
 
     находит: 
 
             he said hi to me
             where are you going?
             happening in anticipation of a unique situation,
             examples include the following:
             "many men smoke, but fu man chu."
 
     не находит: 
 
        he said "hi" to me
        where are you going? i'm headed to the beach this

     ищет: *.doc в корневом каталоге и всех его подкаталогах
на дисководе.
 
           Примечание: Утилита ищет "," (запятую), "." (точ-
      ку),  ":" (двоеточие) "?" (знак вопроса) и "'" (апост-
      роф) в конце строки.  Заметьте,  что  двойная  кавычка
      внутри диапазона имеет знак перехода перед ней, поэто-
      му рамматривается как обычный знак, а не как закрываю-
      щая кавычка для данной строки. отметьте также что знак
      $ появляется вне заключенной в кавычки строки. это де-
      монстрирует,  как  обычные выражения могут соединяться
      вместе для формирования более длинного выражения.
 
     grep -ild " the "\*.doc
     or grep -i -l -d " the "\*.doc
     or grep -il -d " the "\*.doc
 
     находит: 
 
                anyway, this is the time we have
                do you think? the main reason we are
 
     не находит: 
 
             he said "hi" to me just when i
             where are you going? i'll bet you're headed to
 
     ищет: *.doc в корневом каталоге и всех его подкаталогах
на текущем дисководе.
 
           Примечание: игнорирует регистр  набора  знаков  и
      печатает  имена всех файлов, которые содержат по край-
      ней мере одно совпадение. Примеры показывают различные
      способы задания нескольких переключателей.

                       Утилита BINOBJ
 
     Программа-утилита BINOBJ.EXE добавлена для того,  чтобы
можно  было преобразовывать любой файл в файл типа .OBJ, ко-
торый может компоноваться с любой программой  Турбо-Паскаля,
как  "процедура".  Это может оказаться полезным, когда у вас
есть двоичный файл данных, который должен находиться в  сег-
менте  кода, или он слишком велик, чтобы разместиться в мас-
сиве типизованных констант. Например, вы можете использовать
утилиту  BINOBJ  и  модуль Graph для компоновки графического
драйвера или файлов шрифтов непосредственно с  файлом  .ЕХЕ.
Тогда  для работы с вашей графической программой вам понадо-
бится только файл .ЕХЕ (см. пример программы  GRLINK.PAS  на
дистрибутивном диске 2).
     Утилита BINOBJ имеет три параметра:
 
BINONJ <исх_файл[.BIN]> <назначение[.OBJ]> <общедоступное имя>
 
где "исх_файл" - это преобразуемый двоичный файл,  "назначе-
ние"  -  имя  файла получаемого файла .OBJ, а "общедоступное
имя" - это имя процедуры (как оно должно объявляться в  Тур-
бо-Паскале).
     В следующем примере процедура ShowScreen  использует  в
качестве  параметра указатель и перемещает в экранную память
4000 байтов данных. Файл с именем  MENU.DTA  содержит  образ
экрана основного меню (80*25*2 = 4000 байтов). 
     Вот пример версии простой программы (в которой отсутст-
вуют проверки ошибок) MYPROC.PAS:
 
  program MyProg;
  procedure ShowScreen(var ScreenData : pointer);
  { Выводит экран данных, проверка на ошибки отсутствует }
  var
    ScreenSegment: word;
  begin 
    if (Lo(LastMode) = 7) then               { моно? }
       ScreenSegment := $B000
    else
       ScreenSegment := $B800;
    Move(ScreenData^,                    { от указателя ю
                 Тху(ХеужжпХжиожпх, 0)а, ь в видеопамять }
                 400);                   { 80*25*2 }
  end;
  var
    MenuP : pointer;
    MenuF : file;
  begin
    Assign(MenuF,'Menu.DTA'); { открыть файл экранных данных}
    Reset(menuF, 1);
    GetMem(MenuP, 4000);      { выделить буфер в динамически
                                распределяемой области }
    BlockRead(MenuF, MenuP^, 4000); { считать экран данных }
    Close(MenuF);
    ShowScreen(MenuP);        { вывести экран данных }
  end.
 
     Файл выводимых на экран данных (MENU.DTA) будет открыт,
а его содержимое считается в буфер в динамически распределя-
емой области. Чтобы эта программа работала, должны присетст-
вовать файлы MYPROG.EXE и MENU.DTA. Для преобразования файла
MENU.DTA в файл  .OBJ  (MENUDTA.OBJ)  можно  воспользоваться
утилитой  BINOBJ, указав ей, что нужно связять данные с про-
цедурой с именем MenuData. После этого  вы  можете  объявить
фиктивную внешнюю процедуру MenuData, которая в действитель-
ности будет собержать выводимые на экран  данные.  Когда  вы
компонуете  ее  в файл .OBJ, используя директиву компилятора
$L, процедура MenuData будет иметь в длину 4000 байтов и со-
держать  данные,  выводимые  на  экран. Однако сначала нужно
применить к файлу MENU.DTA утилиту BINOBJ:
 
     binobj MENU.DTA MENUDTA MenuData
 
     Первый параметр MENU.DTA задает  файл  данных,  которые
должны  выводиться  на  экран, второй, MENUDTA, представляет
собой имя создаваемого объектного файла .OBJ (поскольку рас-
ширение    не   указано,   будет   использовано   расширение
объявляемой в вашей программе. После того, как файл MENU.DTA
будет  преобразован  в  файл  .OBJ,  новый вариант программы
MYPROG.PAS будет выглядеть так:
 
  program MyProg;
  procedure ShowScreen(var ScreenData : pointer);
  { Выводит экран данных, проверка на ошибки отсутствует }
  var
    ScreenSegment: word;
  begin 
    if (Lo(LastMode) = 7) then               { моно? }
       ScreenSegment := $B000
    else
       ScreenSegment := $B800;
    Move(ScreenData^,                    { от указателя ю
                 Тху(ХеужжпХжиожпх, 0)а, ь в видеопамять }
                 400);                   { 80*25*2 }
  end;
  procedure MenuData; external;
  {$L MENUDTA.OBJ}
  ShowScreen(@MenuData);        { вывести экран данных }
  end.
 
     Заметим, что процедура ShowScreen совсем не изменилась,
а адрес процедуры передается с помощью оператора @. 
     Преимещество компоновки выводимых  на  экран  данных  в
файл  .ЕХЕ очевидна: ведь для работы программы вам не потре-
буется никаких вспомогательных файлов. К тому же вы  сможете
обращаться  к экрану данный по имени (MenuData). В числе не-
достатком можно указать следующие:
 
     - При каждом изменении выводимых на  экран  данных  вам
потребуется  преобразовывать их в файл .OBJ и перекомпилиро-
вать программу MYPROG.
     - Для каждого выводимого экрана данный вам  потребуется
иметь отдельный файл .OBJ (и внешнюю процедуру).
 
     Утилита BINOBJ особенно полезна в  тех  случаях,  когда
двоичный файл, котоый вы хотите скомпоновать, редко требует-
ся изменять. Одна из графических програм в примерах  исполь-
зует утилиту BINOBJ для построения двух модулей, которые со-
держат драйвер и файлы шрифтов  (см.  комментарии  в  начале
файла GRLING.PAS на дистрибутивном диске 2).



 
                        ПРИЛОЖЕНИЕ D
 
                  Настройка Турбо-Паскаля
 
     В данном приложении объясняется, как настроить операци-
онную   среду  Турбо-Паскаля  и  зафиксировать  ее  в  файле
TURBO.EXE.
                      Что такое TINST?
 
     TINST - это программа установки Турбо-Паскаля. Ее можно
использовать, чтобы создать нужный файл TURBO.EXE интегриро-
ванной усовершенствованной версии Турбо-Паскаля.  С  помощью
TINST  можно изменить различные установки по умолчанию в об-
рабатывающей среде языка Турбо-Паскаль, такие как, например,
размер  экрана, команды редактирования, цвета меню и катало-
ги, испоьзуемые по умолчанию.  Утилита  TINST  предоставляет
возможность  изменения  среды, в которой вы используете Тур-
бо-Паскаль. Он непосредственно изменяет  некоторые  значения
по умолчанию внутри вашей копии TURBO.EXE.
     С помощью TINST вы получите возможность осуществить лю-
бое из следующих действий:
 
     - установить маршруты доступа к каталогам, где находят-
ся  ваши  файлы  включения, файлы программных модулей, файлы
конфигурации, справочные файлы, файлы выборки и  выполняемые
файлы;
     - установить командные клавиши редактора;
     - установить значения по умолчанию редактора Турбо-Пас-
каля и экранного изображения;
     - установить режим по умолчанию видеодисплея;
     - менять цвета экрана;
     - изменять размеры окон редактора Турбо-Паскаля и  окна
вывода;
     - изменить значение по умолчанию некоторых  из  устано-
вок,  к  которым  осуществляется  доступ с помощью меню "Оп-
ции/Компилятор/Размеры   памяти"    (Options/Compiler/Memory
Sizes);
     - изменить значение по умолчанию некоторых  из  устано-
вок,  к  которым  осуществляется  доступ с помощью меню "Оп-
ции/Среда" (Options/Enviroment) или меню "Опции/Среда/Разме-
ры экрана" (Options/Enviroment/Screen Sizes);
     - изменить установку назначения -  адресата  информации
(эквивалент           меню:          "Компиляция/Назначение"
(Compile/Destination));
     - изменить принятые по умолчанию установки для интегри-
рованного отладчика.
 
     Турбо-Паскаль поставляется готовым для  выполнения.  Он
не поставляется отдельно, сам по себе. Вы можете скопировать
файлы с дистрибутивных дисков на свои рабочие  гибкие  диски
(или твердые диски), как это описано в Главе 1 "Начало рабо-
ты".
     Однако вам необходимо будет также  выполнить  программу
TINST,  если вы хотите осуществить что-нибудь из следующего:
 
     - автоматически загрузить файл конфигурации (TURBO.TP),
который не находится постоянно в текущем каталоге;
     -  заменить   значение   цветов   меню   по   умолчанию
Турбо-Паскаль (см. установка цветов меню");
     - задать дисплейный режим или проверку на вывод  инфор-
мации  во время обратного хода вертикальной развертки (чтобы
избежать помех на экране).
 
          Работа с обслуживающей программой TINST

     При запуске программа-утилита TINST сама распознает на-
личие  цветного адаптера и начинает работать в цветном режи-
ме. Вы можете отменить эту особенность  с  помощью  необяза-
тельного параметра /В (например, если если используется ком-
позиционный монитор с адаптером цветного типа).
     Обращение к утилите TINST имеет следующий синтаксис:
 
     TINST [необязараметр] [маршрут]
 
     Оба параметра ("необязараметр"  и  "маршрут")  являются
необязательными.  Если  вы  не  указываете маршрут, то TINST
ищет файл TURBO.EXE в текущем каталоге, в  противном  случае
она использует указанное имя маршрута.
     Заметим, что для настройки нескольких  различных  копий
Турбо-Паскаля  в  системе вы можете использовать одну версию
утилиты TINST. Эти различные  копии  TURBO.EXE  могут  иметь
разные  имена  файлов  выполняемых  программ. При этом можно
просто вызвать TINST, а для копирования настраиваемой версии
TURBO.EXE  указать  имя  маршрута доступа (относительное или
абсолютное) к нужному файлу TURBO.EXE. Например:
 
     TINST c:\TURBO00\tp00.exe
     TINST ..\..\BWTR.EXE
     TINST C:\BORLAND\COLORTP.EXE
 
     Таким образом, вы можете в своей системе настроить раз-
личные  копии Турбо-Паскаля и получить возможность использо-
вать различные клавиши команд редактора, цвета меню  и  т.д.
(если это вам необходимо).
     Первый экран утилиты TINST выглядит следующим образом:
 
    ------Installation Menu-----    - Меню настройки
    !                          !
    !#Сomplete#################!    - Завершение
    ! Options                  !    - Наобяз. параметры
    ! Debug                    !    - Отладка
    ! Editor commands          !    - Команды редактора
    ! Mode for display         !    - Режим дисплея
    ! Set colors               !    - Установка цветов
    ! Resize windows           !    - Изменение размеров
    ! Quit/save                !      окон
    ----------------------------   \_ Выход/сохранение
 
     Рис. D.1. Меню настройки утилиты TINST
 
     - Команда "Завершение" (Сomplete) позволяет вам  задать
назначаемое по умолчанию имя основного файла (Primary File),
который будет компилироваться, и назначение компиляции (Disk
- диск, или Memory - память).
     -   Команда   "Необязательные   параметры"    (Options)
позволяет получить доступ к принятым по умолчанию установкам
для большого числа различных  средств,  включая  компилятор,
компоновщик,  параметры  операционной среды, имена маршрутов
каталогов и другие параметры.
     - Команда "Отладка" (Debug) позволяет вам задать  пара-
метры  среды интерактивной отладки, автономной отладки и ус-
танавливаемые умолчанию режимы переключания экранов при  ра-
боте с автономным отладчиком.
     - Команды редактора (Editor commands)  можно  использо-
вать для переконфигурации (настройки) клавиш, использующихся
для управления интерактивным редактором.
     - С помощью команды "Режим экрана" (Моde  for  display)
вы  можете  задавать режим экрана, который будет действовать
при работе с Турбо-Паскалем, и указывать Турбо-Паскалю,  что
вы работаете с видеоадаптером, который может давать на экра-
не помехи в виде "снега".
     - С помощью меню "Установка цветов" (Set Colors)  можно
задавать  цвета,  использующиеся  почти  в  любой части Тур-
бо-Паскаля.
     - Команда "Изменение размеров  окон"  (Resize  wundows)
позволяет  вам изменять размеры окна редактирования (Edit) и
окон вывода и просмотра (Output/Watch).
     - Команда "Выход/Сохранение" (Quit/save) позволяет  вам
сохранить  сделанные  вами  в  интегрированной интерактивной
среде изменения и вернуться на уровень операционной системы.
 
     Для выбора команды меню нужно  просто  нажать  клавишу,
соответствующую  подсвеченной букве нужной вам команды. Нап-
ример, для выбора команды "Установка цветов" нажмите клавишу
S.  Можно  также для перемещения подсветки на нужную вам ко-
манду использовать клавиши Up и Down, а затем нажать клавишу
Enter.
     Нажатие клавиши Esc (если это  необходимо,  то  клавишу
Esc  нужно нажать несколько раз) вернет вас из подменю в ос-
новное меню настройки.
 
                Меню "Компиляция" (Compile)

     Это   меню   содержит   две    команды:    "Назначение"
(Destination)  и  "Основной файл" (Primary file). Назначение
компиляции  можно  установить  в  Disk  (диск)  или   Memory
(память). Если вы выбираете основной файл, то на экран выво-
дится рамка с подсказкой, где нужно ввести  используемое  по
умолчанию имя этого файла.
 
         Меню "Необязательные параметры" (Options)

     Это меню позволяет вам задать все необходимые параметры
(опции) для установок "Компилятор" (Compiler), "Компоновщик"
(Link),  "Операционная   среда"   (Enviroment),   "Каталоги"
(Directories) и "Параметры" (Parameters). Дадим краткое опи-
сание каждого из этих подменю.
 
                Меню "Компилятор" (Сompiler)

     Эта опция используется для  задания  различных  средств
компилятора.
 
     "Проверка диапазона" (Range-Checking)  -  по  умолчанию
Off (выключено)
 
     Эта опция позволяет включить или выключить проверку ди-
апазона.
 
     "Проверка стека" (Stack-Checking)  -  по  умолчанию  On
(включена)
 
     Эта опция служит переключателем для разрешения и запре-
щения проверки стека.
 
     "Проверка ввода-вывода" (I/O Checking) -  по  умолчанию
On (включена)
 
     Позволяет разрешить или запретить  выполнение  проверки
ввода-вывода.
 
     "Использование дальнего типа вызовов" (Force Far Calls)
- по умолчанию - Off (выключено)
 
     Этот переключатель  позволяет  задать  использование  в
процедурах  и функциях дальнего типа вызовов. При запрещении
этой возможности компилятор будет сам там, где это необходи-
мо,   использовать  вызовы  типов  NEAR  (ближние)  или  FAR
(дальние) автоматически.
 
     "Разрешение оверлеев" (Overlay Allowed) - по  умолчанию
Off (выключено)
 
     Этот переключатель позволяет установить, могут ли моду-
ли перекрываться.
 
     "Проверка строк-переменных" (Var-String Checking) -  по
умолчанию Strict (строгая)
 
     Позволяет  выбрать  строгую  или  ослабленную  проверку
строк.
 
     "Выравнивание данных" (Align Data) - по умолчанию  Word
(слово)
 
     Позволяет выбрать выравнивание типизованных констант  и
переменных на границу слова или байта.
 
     "Вычисление булевских выражений" (Boolean Evaluation) -
по умолчанию Short Circuit (по короткой схеме)
 
     Позволяет выбрать между вычислением булевских выражений
по короткой схеме и полным вычислением.
 
     "Числовая обработка" (Numeric Processing) - по  умолча-
нию Software (программная)
 
     Позволяет вам выбрать между использованием  сопроцессо-
ров 8087/80287 и соответствующего программного обеспечения.
 
     "Эмуляция" (Emulation) - по умолчанию On (включена)
 
     Позволяет использовать числа с плавающей запятой форма-
та  IEEE с помощью компоновки библиотеки, эмулирующей работу
сопроцессора 8087, или использовать сопроцессор 8087  непос-
редственно (если он имеется).
 
     "Информация для отладки" - по умолчанию On (включена)
 
     Разрешает или запрещает генерацию информации для отлад-
ки.  Эта  информация состоит из таблицы номеров строк каждой
процедуры, которая позволяет  отобразить  адреса  обьектного
кода в номера строк исходного текста для испоьзования из от-
ладчиком Турбо-Паскаля или Турбо-отладчиком.
 
     "Локальные символы" (Local Symbols) - по  умолчанию  On
(включено)
 
     Эта опция управляет  генерацией  отладочной  информации
для формальных параметров и локальных переменных.
 
     "Условные определения" (Сonditional Defines)
 
     Выводит рамку подсказки, в которой вы можете определить
символы.
 
     "Размеры памяти" (Memory Sizes) - по  умолчанию  16384,
0, 655360
 
     Позволяет вам задать размеры стека, а также  максималь-
ный  и минимальный размер динамически распределяемой области
памяти.
 
                Меню "Компоновщик" (Linker)

     Это меню позволяет задать принятые по  умолчанию  пара-
метры для компоновщика.
 
     "Файл MАР" (Map File) - по умолчанию Off (выключено)
 
     Эту команду вы можете использовать для задания  исполь-
зуемого  по  умолчанию типа файла МАР. Для него можно задать
значения  Off  (выключено),  Segments  (сегменты),   Publics
(общедоступные имена) или Detailed (подробная информация).
 
     "Буфер компоновки" (Link Buffer) - по умолчанию  Memory
(память)
 
     Эту команду можно использовать для задания  для  буфера
компоновки значений Memory (память) или Disk (диск).
 
           Меню "Операционная среда" (Enviroment)

     C помощью этого меню вы можете задать несколько исполь-
зуемых по умолчанию режимов работы редактора. Далее описыва-
ются основные команды этого меню.
     Сначала для определения того, как выбрать эти  команды,
обратимся  к  нижней  строке экрана. Можно либо использовать
клавиши для перемещения подсветки на соответствующую  коман-
ду, а затем нажать клавишу Enter, либо нажать клавишу, соот-
ветствующую подсвеченной букве команды. 
     Вы можете изменить используемые по умолчанию  параметры
операционной  системы (по вашему усмотрению), а затем сохра-
нить их, как часть Турбо-Паскаля. При этом, конечно, вы  мо-
жете изменить затем эти параметры из среды Турбо-Паскаля.
 
           Примечание: Любой параметр,  заданный  с  помощью
      программы  TINST,  и появляющийся в виде элемента меню
      интерактивной среды Турбо-Паскаля, будет  отменен  при
      загрузке файла конфигурации с другими значениями этого
      параметра.
 
     Автоматическое сохранение  файла  конфигурации  (Config
Auto Save) - по умолчанию Off (выключено)
 
     Когда эта опция установлена в значение  On  (квлючено),
Турбо-Паскаль   автоматически  сохраняет  файл  конфигурации
(если он был изменен со времени последнего  сохранения)  при
каждом  использовании  команды  "Выполнение"  (Run) (клавиши
Ctrl-F9, F7,  F4)  "Файл/Командый  процессор  ДОС"  (File/OS
Shell)  или  "Файл/Выход"  (File/Quit)  (Alt X). То, в каком
файле будет сохранена конфигурация, зависит от  трех  факто-
ров.
 
     Автоматическое сохранение в редакторе (Edit Auto  Save)
- по умолчанию Off (выключено)
 
     Когда эта опция установлена в значение  On  (включена),
то  Турбо-Паскаль  при  использовании команд "Файл/Командный
процессор ДОС" (File/OS Shell) или "Выполнение" (Run)  (Ctrl
F9  или  "Выполнение по шагам" - F8) автоматически сохраняет
загруженный в редактор файл (если он был изменен). Это  поз-
воляет избежать потери исходного файла в случае непредвиден-
ной ситуации. Если данная опция установлена в  значение  Off
(выключена),  такого  автоматического сохранения не происхо-
дит.
 
     Создание резервной копии файлов  (Backup  Files)  -  по
умолчанию On (включено)
 
     Если эта опция установлена в состояние  On  (включена),
Турбо-Паскаль автоматически выполняет создание резервных ко-
пий исходного файла при выполнении команды "Файл/Сохранение"
(File/Save). При этом для файла-Копии используется то же са-
мое имя файла и расширение .ВАК. Для  файлов  FILE,  FILE.C,
FILE.XYZ файл-копия получит имя FILE.BAK. Если эта опция ус-
тановлена в значение Off (выключена), то файл .ВАК не созда-
ется.
 
     Переключение окон (Zoom Windows)  -  по  умолчанию  Off
(выключено)
 
     Если эта опция установлена в значение On, то при запус-
ке Турбо-Паскаля окно редактора будет занимать весь экран, а
когда вы перейдете в окно вывода (Output), оно  также  будет
занимать  весь экран. Если данная опция установлена в значе-
ние Off (выключена), то окно редактора (Edit) будет занимать
честь  экрана  над окном просмотра (Watch) или вывода. Изме-
нить размеры окон можно с помощью команды "Изменение  разме-
ров окон" (Resize Windows) в основном меню настройки.
 
     Сохранение полного графического вывода  (Full  Graphics
Save) - по умолчанию On (включено)
 
     Для сохранения графических  экранов  Турбо-Паскаль  под
буферы палитр отводит память размером 8К. Если вы используе-
те только текстовые окна, то выключив эту  опцию  (установив
ее  в  значение Off) можно освободить дополнительную память.
Получить доступ к этой опции можно с помощью утилиты TINST.
 
     Размер экрана (Screen Size) - по умолчанию 25 строк
 
     При выборе этой опции выводится  меню.  Элементы  этого
меню позволяют вам использовть в интегрированной интерактив-
ной среде Турбо-Паскаля дисплей одного из  двух  размеров  -
25-строковый  или 43/50-строковый. Размер, который может ис-
пользоваться, зависит от наличия соответствующих  аппаратных
средств   (25   строк   можно   использовать  всегда,  43  и
50-строковый режимя доступны только при использовании  адап-
теров EGA или VGA).
 
     Параметры редактора 
 
     Эта команда позволяет вам задать принятые по  умолчанию
парамтеры для редактора.
 
     Режим вставки (Insert Mode) - по умолчанию On (включен)
 
     Если эта опция установлена в состояние  On  (включена),
то редактор при любом вводе с позиции курсора вставляет вво-
димую информацию, перемещая расположенный справа текст впра-
во  от  курсора.  Отмена этой опции позволяет перепечатывать
набираемую строку (изменяя старый текст).
 
     Режим автоматического отступа  (Autoident  Mode)  -  по
умолчанию On (включен)
 
     Если эта опция включена, то при нажатии  клавиши  Enter
курсор  будет  возвращаться  на начальную позицию предыдущей
строки. При выключении  этого  режима  (Off)  курсор  всегда
возвращается в позицию 1.
 
     Использование табуляции (Use Tabs) - по  умолчанию  Off
(выключено)
 
     Если эта опция имеет значение On (включена), и  вы  ис-
пользуете  клавишу  табуляции  (Tab), то редактор помещает в
текст символ табуляции (^I), используя при этом размер,  за-
данный  с  помощью опции "Размер табуляции" (Tab Size). Если
вы пользуетесь клавишей табуляции когда эта опция  находится
в состоянии Off (выключена), то редактор включает число про-
белов, необходимое для перемещения курсора  к  первой  букве
каждого слова предыдущей строки.
 
     Оптимальное заполнение (Optimal Fill) - по умолчанию On
(включено)
 
     Эта опция не дейтсвует, если опция "Использование табу-
ляции"  также не установлена в состояние On. Когда обе опции
установлены в состояние On, то строка с отступом или без за-
полняется пробелами оптимальным образом. Это позволяет полу-
чить строки с минимальным числом  символов.  Данной  команде
соответствуют оперативные клавиши Ctrl-O F.
 
     Обратное перемещение без выравнивание (Backspace  Unin-
dent) - по умолчанию On (включено)
 
     Если эта опция включена, то курсор  будет  позициониро-
ваться на первый непустой символ первой невыровненной распо-
ложенной выше строки или непосредственно  на  предшествующую
непустую  строку.  Данной  команде соответствуют оперативные
клавиши Ctrl-O U.
 
     Размер табуляции (Tab Size) - по умолчанию 8
 
     При выборе этой опции появляется рамка с подсказкой,  в
которой вы можете ввести число пробелов, соответсвующее сим-
волу табуляции.
 
     Размер буфера редактора (Editor Buffer Size) - по умол-
чанию 65534
 
     При разработке небольших модульных программ и маленьких
файлов,  используя небольшой размер буфера редактора, вы мо-
жете получить дополнительную память для отладки. Размер  бу-
фера  редактора  может иметь значения от 20000 до 65534 бай-
тов.
 
     Использование расширенной памяти (Make Use of EMS Memo-
ry) - по умолчанию On (включено)
 
     Обычно для тектового  буфера  редактор  использует  64К
расширенной  памяти (если она имеется). Если расширенная па-
мять (EMS) отсутствует, вы можете выключить эту опцию. 
     Турбо-Паскаль использует поддержку расширенной памяти с
помощью  драйверов ЕMS. Во время начала работы Турбо-Паскаль
автоматически распознает наличие расширенной памяти  в  этом
случае  размещает в ней буфер редактора. Это позволяет осво-
бодить около 64К оперативной памяти для компиляции и  выпол-
нения  программ.  Если вы не хотите, чтобы Турбо-Паскаль ис-
пользовал расширенную  память,  эту  опцию  нужно  выключить
(Off).
 
               Меню "Каталоги" (Directories)
 
     С помощью этого меню вы можете задать маршрут доступа к
любому  используемому  по  умолчанию каталогу Турбо-Паскаля.
Это те каталоги, которые Турбо-Паскаль просматривает при по-
иске  файла  конфигурации, справочного файла, а также объек-
тный файлов, включаемых файлов и файлов модулей, а также тот
каталог, куда будет помещаться выполняемый файл.
     При выборе этого меню Турбо-Паскаль выводит подменю  со
следующими элементами:
 
     - Каталог Турбо (Turbo Directory);
     - Каталог выполняемых файлов и файлов модулей  (.EXE  &
.TPU Directories);
     - Каталоги включаемых файлов (Include Directories);
     - Каталоги объектных файлов (Object Directories);
     - Имя файла выборки (Pick File Name).
 
     Каталог Турбо (Turbo Directory)
 
     Это тот каталог, в котором Турбо-Паскаль ищет  справоч-
ные  файлы,  используемый  по умолчанию файл выборки, и файл
TURBO.TP (используемый по умолчанию файл конфигурации), если
они отсутстуют в текущем каталоге.
     Например, в данном элементе меню вы можете задать  сле-
дующее имя маршрута каталога Турбо:
 
    C:\TURBO\CPGSNHLP
 
     Когда не может найти  файл  конфигурации  и  справочный
файл  в  текущем  каталоге, то он будет искать их в каталоге
TURBOCPGSNHLP.
 
     Каталог выполняемых файлов и  файлов  модулей  (.EXE  &
.TPU Directories)
 
     Это опция используется для определения  имени,  которое
по умолчанию будет использоваться хранения компилятором фай-
лов .EXE, .TPU, .MAP и .OVR. 
 
     Каталог файлов  модулей  (Unit  Directories),  каталоги
включаемых файлов (Include Directories) и каталоги объектных
файлов (Object Directories) 
 
     В этих элементах меню вы можете вводить несколько запи-
сей, разделяя их точкой с запятой. Для каждого имени маршру-
та можно использовать до 127 символов. При  этом  можно  ис-
пользовать абсолютные или относительные имена.
     Например, для каталога включаемых  файлов  в  выводимой
рамке-подсказке можно ввести следующее:
 
 C:\TURBO\INCLUDE\;C:MYINCLD;A:..\..\INCLUDE2
 
Кроме того, если вы хотите, чтобы Турбо-Паскаль искал  файлы
модулей  в четырех различных каталогах, в окне элемента меню
"Каталоги модулей" можно ввести следующее:
 
  
C:\TURBO\STARTUP;C:\TURBO\STDUNITS;C:..\MUUNITS2;A:NEWUNITS;
 
     Каталоги объектных файлов  Турбо-Паскаль  просматривает
также, как по директиве компитора $L.
 
             Имя файла выборки (Pick File Name)
 
     Если вы выберите этот элемент меню, то на  экране  поя-
вится окно ввода. В нем нужно набрать имя маршрута файла вы-
борки, который вы захотите загрузить или создать  с  помощью
Турбо-Паскаля.  Именем  по  умолчанию файла выборки является
TURBO.PCK.
     После набора имени пути (или имен) для любых  элементов
меню "Опции/Каталоги" (Options/Directories), нажмите клавишу
Enter, чтобы информация была  воспринята,  а  затем  нажмите
Esc,  чтобы  вернуться  в  основное меню установки программы
TINST. Когда вы выйдите из этой программы, она напомнит  вам
о том, что нужно ответить, хотите ли вы сохранить изменения.
Если вы сохраняете имена маршрутов Turbo, то адреса  записы-
ваются на диск и становятся частью принятых по умолчанию ус-
тановок TURBO.EXE.
 
                   Меню "Отладка" (Debug)

     Элементы этого меню позволяют вам  задать  определенные
принятые  по  умолчанию параметры интегрированного отладчика
Турбо-Паскаля.
 
     "Интегрированная отладка" (Integrated Debugging)  -  по
умолчанию On (включена)
 
     Эта команда управляет интегрированной отладкой в  инте-
рактивной  среде  программирования. Установка для этой опции
значения Off и компиляция на диск позволяет  увеличить  сво-
бодную память при работе программы (если ее не требуется от-
лаживать).
 
     "Автономная отладка" - по умолчанию Off (выключено)
 
     От этой опции зависит, будет ли при компиляции на  диск
в  выполняемый  файл .ЕХЕ помещаться информация для отладки.
Эта информация необходима для отдалки программы с  использо-
ванием Турбо-отладчика.
 
     "Переключение экрана" (Display Swapping) - по умолчанию
Smart (эффективное)
 
     Этот параметр позволяет вам задать желаемый уровень пе-
реключения  экрана  (Smart,  Always или Never - эффективный,
пошаговый или отсутствие переключения).
     При запуске программы в режиме  отладки  со  значением,
принятым  по умолчанию (Smart), отладчик будет просматривать
выполянемый код и анализировать, влияет ли это выполнение не
информацию  на  экране  (то есть, происходит ли вывод на эк-
ран). В случае вывода на экран (или  вызова  соответствующей
функции)  экран на то время, пока происходит вывод, переклю-
чается из режима редактирования (Editor) в режим  выполнения
(Execution).  После  завершения вывода экран переключается в
исходное состояние. В противном случае переключения  экранов
не  происходит.  Пошаговое  переключение (Always) приведет к
тому, что будет переключаться при каждом выполнении операто-
ра  вывода. При отсутствии переключения (Never) экран перек-
лючаться не будет.
 
         Меню "Команды редактора" (Editor Commands)

     Интерактивный редактор Турбо-Паскаль обеспечивает  мно-
жество функций редактирования, включающих команды для:
 
     - перемещения курсора
     - вставки и удаления текста
     - работы с блоками и файлами
     - просмотра строк (плюс просмотр и замена)
 
     Эти команды редактирования ставятся  в  соответствие  с
некоторыми  клавишами  (или группами клавиш). Более подробно
это объясняется в части 2.
     Когда вы выбираете команды редактора из основного  меню
и  установки программы TINST, на экране появляется изображе-
ние Установка редактора, на котором имеются три колонки тек-
ста. 
     - Первая колонка (слева) описывает все функции, доступ-
ные интерактивному редактору Турбо-Паскаля.
     - Вторая колонка приводит основные функциональные  кла-
виши  (какие  клавиши  или  специальные  сочетания клавиш вы
должны нажать, чтобы вызвать, конкретные команды редактора).
     - Третья колонка содержит второстепенные функциональные
клавиши.  Они являются необязательными альтернативными функ-
циональными клавишами, которые вы также можете  использовать
для вызова тех же команд редактора.
 
           Примечание: Вторичные функцинальные клавиши всег-
      да имеют преимущества перед первичными функциональными
      клавишами.
 
     Нижние строки текста в изображении установка  редактора
кратко описывают клавиши, которые можно использовать для вы-
бора элемента в основной и второстепенных колонках (см. Таб-
лицу D.1).
                                                   Таблица D.1
       Клавиши команд управления экраном редактора
--------------------------------------------------------------
 Клавиша          Пояснение               Что она делает
--------------------------------------------------------------
 Клавиши стрелок: Выбор          Выбирает команду редактора,
 налево, направо                 которую вы хотите повторно           
 вверх и вниз                    нажать
 
 Страница вверх   Страница       Прокручивает вверх или вниз
 и страница вниз                 одну полную страницу экрана
 (PgUp и PgDn)
 
 Ввод             Модификация    Вводит режим изменений 
                                 клавишных наборов
 
 R                Заново запо-   Снова устанавливает все коман-
                  минает за-     ды редактора в соответствии
                  водские значе- со значениями по умолчанию
                  ния по умол-   для наборов клавиш
                  чанию
 
 Esc              Выход          Выходит из изображения уста-
                                 новка редактора и возвращается 
                                 в основное меню установки 
                                 программы TINST
 
  F4              Клавишные      Осуществляет переключания
                  режимы         между тремя вариантами 
                                 сочетаний клавишных наборов
------------------------------------------------------------
 
     После нажатия клавиши Enter с целью ввести в режим  из-
менения  на экране появляется окно, в котором приводятся оп-
ределенные в данный момент клавишные  наборы  для  выбранных
команд,  а  нижние строки текста в изображении установка ре-
дактора кратко описывают клавиши, которые вы используете для
изменения таких клавишных наборов (см. Таблицу Ж.2). На ниж-
ней строке окна "Установки редактора" (Install Editor)  при-
водится  перечень тех клавиш, которые вы можете использовать
для изменения клавишных наборов.

                                                 Таблица D.2
     Клавишные наборы экрана редактора в режиме изменения
-------------------------------------------------------------
Клавиша             Пояснение                      Что делает
-------------------------------------------------------------
BackSpace    Обратный пробел   Отменяет клавишное нажатие с 
                               левой стороны от курсора
Enter           Восприятие     Воспринимает вновь определенные 
                               клавишные наборы для выбранной
                               команды редактора
Esc          Отказ от изме-    Отказывается от изменений в те-
                               нений кущем наборе, восстанавли-
                               вая исходные наборы клавиш данной
                               команды, и возвращается к изоб-
                               ражению "установка редактора"
                               (готова к выбору другой коман-
                               ды редактора)
F2            Восстановление   Отказывается от изменений
                               в текущем наборе, восстанавливая 
                               исходные наборы данной команды, 
                               но сохраняет текущую команду,
                               выбранную для повторного опре-
                               деления
F3            Очистка          Отменяет определение клавишного
                               набора для текущего выбора, но 
                               сохраняет текущую команду, выб-
                               ранную для повторного определе-
                               ния

F4           Клавишные         Переходит на три вида клавишных
                               режимы наборов: режим редактора 
                               WordStar, игнорирование регист-
                               ров и буквенный.
-------------------------------------------------------------

           Примечание: Чтобы ввести F2, F3, F4 или знак  ка-
      вычки в качестве части набора клавиш для данной коман-
      ды редактора, сначала нажмите клавишу кавычки  ('),  а
      затем нажмите соответствующую функциональную клавишу.
 
     Сочетания наборов клавиш имеют три режима: режим редак-
тора   WordStar,  Ignore  case  (игнорирование  регистра)  и
Verbatum (буквенный). Они приводятся на нижней строке  экра-
на. Выделенный режим 2 это тот режим, который вы выбрали. 
 
     Режим редактора WordStar
 
     В режиме редактора WordStar все  команды  должны  начи-
наться  со специальной клавиши или управляющей клавиши. Сле-
дующие знаки могут представлять собой любые клавиши. 
     Если вы выбираете букву (или  один  из  следующих  пяти
знаков:  [,],\,^,-) в таком режиме, то эта буква будет авто-
матически введена в качестве управляющего знака. Например:
 
     Набор а или Ctrl A приведет к вводу <Ctrl A> 
     Набор Y или Ctrl Y приведет к вводу <Ctrl Y>
     Набор [ приведет к вводу <Ctrl [>
 
     В редакторе Турбо-Паскаля вы должны затем нажать специ-
альную клавишу или клавишу Ctrl при вводе первого клавишного
набора из последовательности клавишных наборов  команды,  но
для следующих клавишных наборов данной команды вы можете ис-
пользовать клавиши нижнего регистра, верхнего  регистра  или
управляющую клавишу.
     Например, если вы задаете для команды редактора в режи-
ме  редактора  WordStar набор <Ctrl A> <Ctrl B> <Ctrl C>, то
вы можете для запуска этой  команды  набрать  для  редактора
Турбо-Паскаля один из следующих наборов:
 
     <Ctrl A> <Ctrl B> <Ctrl C> 
     <Ctrl A> <Ctrl B> <C>
     <CTRl A> <Ctrl B> <C>
     <Ctrl A> <B> <Ctrl C>
     <Ctrl A> <B> <C>
     <Ctrl A> <B> <c>
     <Ctrl A> <b> <Ctrl C>
     <Ctrl A> <b> <C>
     <Ctrl A> <b> <c>
 
     В режиме клавишных наборов редактора WordStar любая на-
жимаемая  вами клавиша преобразуется в сочетание управляющих
символов:
 
     - левая квадратная скобка ([);
     - обратная косая черта (\);
     - правая квадратная скобка (]);
     - знак каре (^ или Shift 6);
     - знак минус (-).
 
     Режим игнорирования регистра
 
     В режиме игнорирования регистра все команды должны  на-
чинаться  со  специальной  клавиши  или управляющей клавиши.
Следующие знаки могут быть любыми клавишами. В таком  режиме
все  буквенные  клавиши, которые вы вводите, преобразуются в
соответствующие им буквы верхнего регистра (прописные симво-
лы).  Когда  вы набираете в этом режиме букву, она автомати-
чески не вводится как  сочетание  управляющих  знаков.  Если
клавишный  набор должен быть сочетанием управляющих букв, то
Вы должны держать нажатой клавишу Ctrl, набирая данную  бук-
ву.
 
     - Набор а или А приведет к вводу А. (Если это  является
первым  клавишным набором, то вы получите сообщение об ошиб-
ке)
     - Набор Ctrl y или Ctrl Y приведет к вводу <Ctrl Y>
     - Набор Ctrl [ приведет к вводу <Ctrl [>
 
     Режим буквенного набора
 
     Буквенные клавишные наборы должны всегда явно начинать-
ся со знака, являющегося соответствующим специальной клавише
или управляющей клавише. Если вы набираете в  данном  режиме
букву, то она будет введена точно так, как вы ее набрали.
 
     - Набор а приведет к вводу а (если это является  первым
набором клавиши, то вы получите сообщение об ошибке)
     - Набор А приведет к вводу А (если это является  первым
клавишным набором, то вы получите сообщение об ошибке)
     - Набор Ctrl Y приведет к вводу <Ctrl Y>
     - Набор Ctrl y приведет к вводу <Ctrl y>
     - Набор Ctrl [ приведет к вводу <Ctrl [>
 
     В режиме буквенного набора то, что вы вводите в  экране
установки редактора (Install Editor) в точности соответству-
ет тому, что вы должны набрать в редакторе Турбо-Паскаля для
выполнения  данной команды. Например, если вы введи < Ctrl A
> и < Ctrl H > в качестве основной и вспомогательной клавиш-
ной  последовательности  для некоторой команды редактора, то
для вызова этой команды вы сможете использовать только нажа-
тие  в  точности этих символов. При использовании. например,
другого регистра (строчной буквы вместо прописной - < Ctrl h
>) команда не сработает.
 
                Допустимые клавишные наборы
 
     Хотя обслуживающая  программа  TINST  обеспечивает  вас
почти  неограниченной  гибкостью в приспосабливании команд в
редакторе Турбо-Паскаля к своим собственным вкусам,  имеется
несколько  правил,  ограничивающих свободу выбора последова-
тельностей определяемых вами клавишных наборов. Некоторые из
этих  правил применяются к любому определению клавишного на-
бора, в то время как другие правила  используются  только  в
некоторых режимах клавишных наборов.
 
     Общие правила.
     1.  Вы можете ввести максимум шесть  клавишных  наборов
         для любой заданной команды редактора. Некоторые со-
         четания клавишей эквиваленты двум  клавишным  набо-
         рам. Этими клавишными сочетаниями являются Alt (лю-
         бая клавиша), клавиши перемещения курсора (Up, Page
         Down, Del и так далее) и все функциональные клавиши
         или  сочетания  функциональных   клавишей   (   F4,
         snift-F7, Alt-F8 и так далее).
     2.  Первым клавишным набором должен быть знак, не явля-
         ющийся алфавитно-цифровым или пунтационным. Другими
         словами, он должен быть  управляющей  клавишей  или
         специальной клавишей.
     3.  Чтобы ввести знак клавиши Esc в качестве клавишного
         набора команды, наберите Ctrl [.
     4.  Чтобы ввести знак клавиши Backspace в качестве  ко-
         мандного клавишного набора, наберите Ctrl H.
     5.  Чтобы ввести знак клавиши Enter в  качестве  коман-
         дного клавишного набора, наберите Ctrl M.
     6.  Предопределенные Турбо-Паскалем функциональные кла-
         виши  помощи (F1 и Alt F2) не могут быть предназна-
         чены в качестве клавиш команд редактора  Турбо-Пас-
         каля.  Однако  любая  другая функциональная клавиша
         может предназначаться в таком качестве. Если  выво-
         дится в качестве части клавишной последовательности
         команды редактора клавиша питания, то обслуживающая
         программа TINST выдаст предупреждение, о том что вы
         подавляете в редакторе клавишу питания, и проверит,
         хотите ли вы подавить эту клавишу.
 
     Клавишные наборы редактора Турбо-Паскаля
 
    Имя команды           Основной             Вторичный  
  Новая строка           * <CtrlM>            *<CtrllM>
  Курсор налево          * <CtrlS>            * <Lft> 
  Курсор направо         * <CtrlD>            * <Rgt>
  Слово налево           * <CtrlA>            * <CtrlLft>
  Слово направо          * <CtrlF>            * <CtrlRgh>
  Курсор наверх          * <CtrlE>            * <Up>
  Курсор вниз            * <CtrlX>            * <Dn>
  Прокрутка вверх        * <CtrlW>            *
  Прокрутка вниз         * <CtrlZ>            *  
  Страница вверх         * <CtrlR>            * <PgUp>
  Страница вниз          * <CtrlC>            * <PgDn>
  Слева от строки        * <CtrlQ><CtrlS>     * <Home>
  Справа от строки       * <CtrlQ><CtrlD>     * <End>   
  Верх экрана            * <CtrlQ><CtrlE>     * <CtrlHome>
  Низ экрана             * <CtrlQ><CtrlX>     * <CtrlEnd>   
  Верх файла             * <CtrlQ><CtrlR>     * <CtrlPgUp>
  Низ файла              * <CtrlQ><CtrlC>     * <CtrlPgDn> 
  Переместить к ошибке   * <CtrlQ><CtrlW>     *
  Переместить к началу   * <CtrlQ><CtrlB>     *
  блока
  Переместить к началу
  блока                  * <CtrlQ><CtrlB>     *
  Переместить к концу  
  блока                  * <CtrlQ><CtrlK>     *
  Переместить к концу
  блока                  * <CtrlQ><CtrlK>     *             
  Переместить к преды-
  дущей позиции          * <CtrlQ><CtrlP>     *
  Переместить к маркеру  * <CtrlQ>0           *
  Переместить к маркеру1 * <CtrlQ>1           *
  Переместить к маркеру2 * <CtrlQ>2           * 
  Переместить к маркерr3 * <CtrlQ>3           *
  Переключить вставку    * <CtrlV>            * <Ins>
  Вставить строку        * <CtrlN             *
  Удалить строку         * <CtrlY>            *
  Удалить до конца 
  строки                 * <CtrlQ><CtrlY>     *
  Удалить слово          * <CtrlT>            *
  Удалить знак           * <CtrlG>            *
  Удалить знак слева     * <CtrlBkSp>         * <CtrlH>
  Установвить начало 
  блока                  * <CtrlK><CtrlB>     *
  Установить конец блока * <CtrlK><CtrlK>     *
  Пометить слово         * <CtrlK><CtrlT>     *
  Закрыть блок           * <CtrlK><CtrlH>     *
  Установить маркер 0    * <CtrlK>0           *
  Установить маркер 1    * <CtrlK>1           *
  Установить маркер 2    * <CtrlK>2           *
  Установить маркер 3    * <CtrlK>3           *
  Скопировать блок       * <CtrlK><CtrlC>     *
  Переместить блок       * <CtrlK><CtrlV>     *
  Удалить блок           * <CtrlK><CtrlY>     *
  Считать блок           * <CtrlK><CtrlR>     *
  Записать блок          * <CtrlK><CtrlW>     *
  Распечатать блок       * <CtrlK><CtrlP>     *
  Выйти из редактора     * <CtrlK><CtrlD>     * <CtrlK><CtrlQ>
  Пробел                 * <CtrlI>            *
  Переключить на авторе- * <CtrlO><CtrlI>     * <CtrlQ><CtrlI>
  дактирование текста
  Включить пробелы       * <CtrlO><CtrlT>     * <CtrlQ><CtrlT>
  Восстановить строку    * <CtrlQ><CtrlL>     *
  Найти строку           * <CtrlQ><CtrlF>     *
  Найти и заместить      * <CtrlQ><CtrlA>     *
  Повторное исследо-
  вание                  * <CtrlL>            *
  Вставить управляющий
  знак                   * <CtrlP>            *
  Сохранить файл         * <CtrlK><CtrlS>     *
  Сравнить пару          * <CtrlQ><Ctrl[>     *
  Сравнить пару в обрат-
  ном направлении        * <CtrlQ><Ctrl]>     *
 
 
                    Режим работы дисплея
 
     Обычно Турбо-Паскаль верно определяет видеорежим  вашей
системы.  вы  должны  изменять  опцию  "Видеорежим  системы"
(Display Mode) в случае если:
     - вы хотите выбрать режим, отличный от текущего  видео-
режима;
     - у вас есть цветной или графический  адаптер,  который
не вносит помех при выводе информации на экран;
     - вы считаете,  что  Турбо-Паскаль  неверно  определяет
ваше аппаратное оборудование;
     - у вас имеется система с адаптером CGA только с  одним
цветом  - для такой ситуации переключитесь в монохроматичес-
кий режим.
     Нажмите клавишу М, чтобы выбрать видеорежим дисплея  из
установочного  меню.  На экране появится меню. Из этого меню
вы можете выбрать экранный режим,  который  будет  использо-
ваться  Турбо-Паскалем во время работы. Ваши параметры вклю-
чают в себя следующие параметры: используемые по  умолчанию,
цветной,  черно-белый  жидкокристаллический или монохромати-
ческий. Они совершенно понятны.
     При выборе первых трех параметров  программа  выполняет
для  экрана видеотест. О том, что нужно при этом делать, со-
общается на нижней строке экрана. 
     Если вы нажмете любую клавишу, на экран выведется  окно
с вопросом:
 
     Was there Snow  on  the  screen?  (были  ли  на  экране
помехи?)
 
     Вы модете ответить:
     - Yes (Да), помехи были.
     - No (Нет). Проверка будет выключена.
     - Возможно. Аппаратные средства всегда будут проверять-
ся.
 
     Значения, используемые по умолчанию 
 
     По умолчанию Турбо-Паскаль всегда  работает  в  режиме,
который являлся действующим при его загрузке.
 
     Цветной
 
     Турбо-Паскаль использует  80-символьный  цветной  режим
вне  зависимости  от  того,  какой режим был действующим при
загрузке TURBO.EXE, и переключается обратно  в  режим,  дей-
ствовавший до этого, когда вы выходите из Турбо-Паскаля.
 
     Черно-белый
 
     Турбо-Паскаль использует знаки 80-символьного черно-бе-
лого  режима  вне  зависимости от того, какой режим был дей-
ствующим, и переключается обратно на действовавший до  этого
режим,  когда  вы выходите из Турбо-Паскаля. Является обяза-
тельным для мониторов составного изображения.
 
     Монохроматический
 
     Турбо-Паскаль использует монохроматический режим,  если
вы  сейчас находитесь в монохроматическом режиме, и переклю-
чается обратно на режим, действовавший ранее, когда вы выхо-
дите из Турбо-Паскаля.
 
     Режим экрана на жидких кристаллах
 
     Если обнаружен цветной адаптер,  то  Турбо-Паскаль  ис-
пользует  80-символьный черно-белый режим (независимо от то-
го, какой режим является активным). При выходе вы возвращае-
тесь в тот режим, который ранее был активным.
     Более подробные инструкции содержатся на нижней  строке
экрана. Для выхода в основное меню нажмите Esc.
 
           Меню меню "Выбор цветов" (Set Colors)
 
     Нажатие С из основного  меню  настройки  позволяет  вам
осуществить  изменения  по расширению цветового режима вашей
версии Турбо-Паскаля. После нажатия С  вы  увидите  меню  со
следующии опциями:
 
     - Выбор цветов
     - Набор цветов
     - Набор бирюзовых цветов
     - Набор красных цветов
 
     Так как имеются около 50 различных экранных  элементов,
которые  вы можете выбрать в отношении цветов, то, вероятно,
вам покажется проще выбрать заранее установленный набор цве-
тов,  соответствующий вашему вкусу. На диске имеются три за-
ранее установленных набора цветов.
     Нажмите клавиши D, T или М и просмотрите цвета-для  эк-
ранных  элементов  Турбо-Паскаля  с  помощью клавиш PgUP или
PgDn. Если ни один из предварительно  установленных  наборов
цветов не подходит вам, вы можете разработать свой собствен-
ный.
     Чтобы создать подходящие цвета, нажмите С, для  исполь-
зования  опции "Выбор цвета". При этом вы будете иметь выбор
из 12 типов элементов, для которых могут быть заданы цвета в
Турбо-Паскале.
     Некоторые из них являются элементами  текста,  являются
линиями  и прямоугольниками на экране. Выберите один из этих
элементов, нажимая буквы от А до L. 
     Если вы выбрали элемент экрана для подбора  ему  цвета,
то появится меню и видеопорт. Видеопорт - это пример элемен-
та экрана, который вы выбрали, в то время как  меню  выводит
компонент этого выьора. Видеопорт отражает также изменения в
цветах, когда вы просматриваете цветовую палитру.
     Например, если вы выбрали Н, чтобы  подобрать  цвета  к
прямоугольникам ошибок Турбо-Паскаля, то перед вами появится
меню с четырьмя различными  частями  прямоугольника  ошибок:
его заголовок, граница, обычный текст и выделенный текст.
     Теперь вы должны выбрать одну из компонент данного  ме-
ню.  Наберите соответствующую букву и вы будете приглашены к
цветовой палитре для элемента, который выбрали.  Воспользуй-
тесь клавишами стрелочек, выберите цвет, соответствующий ва-
шему вкусу из палитры. Взгляните на видеокод, чтобы  посмот-
реть,  как  выглядит этот элемент в выбранном цвете. Нажмите
клавишу Enter, чтобы записать свой выбор.
     Повторите эту процедуру для каждого экранного элемента,
для  которого вы хотите выбрать цвет. После того, как вы за-
кончите, нажимайте клавишу Esc до тех пор, пока не вернетесь
в основное установочное меню. 
 
           Примечание: Турбо-Паскаль обслуживает  три  внут-
      ренних цветовых таблицы: по таблице для каждой опции -
      цветной, черно-белой и монохроматической.  Обслуживаю-
      щая  программа TINST допускает изменять только один из
      этих трех наборов цветов за один раз,  основываясь  на
      вашем  текущем видеорежиме. Так, например, если вы хо-
      тели заменить набор на черно-белую  цветовую  таблицу,
      то  вы  должны установить свой видеорежим как BW80 при
      наличии напоминания DOS,а затем загрузить  обслуживаю-
      щую программу TINST.
 
       Меню "Изменение размера окон" (Resize Windows)
 
     Данная опция позволяет заменять  соответвующие  размеры
окон редактора Турбо-Паскаля (Edit) и окна просмотра (Watch)
и вывода (Output). Нажмите из основного  установочного  меню
R, чтобы выбрать опцию "Изменение размерой окон". 
     С  помощью  клавиш  стрелочек  UP  и  DOWN  `?z  kmecqc
ncockcpqgq{  jglg},  ofbcj~}xr}  milm  ocbiqgom`lg~  g  milm
`z`mb. Kg mblm gf miml lc kmecq q{ kcl{wc, vck  qog  pqomig.
Mmpjc qmam, ii `z gfkclgq{ ofkcoz miml nm pm1q`cllmkr `irpr,
lekgqc Enter. Вы можете отменить свой выбор  и  вернуться  в
установочное меню, нажимая Esc.
 
                    Выход из программы 
 
     Если вы закончили осуществление всех  желаемых  измене-
ний, выберите опцию выход/сохранение в основном установочном
меню. На экране появится сообщение
 
     Save changes to TURBO.EXE? (Y/N) (Сохранить изменения в
TURBO.EXE? (Да/Нет╝))
 
     - Если вы нажмете Y (да),  все  изменения,  которые  вы
осуществили,  будут  постоянно  установлены в Турбо-Паскале.
(Конечно, вы всегда можете выполнить еще  раз  обслуживающую
программу TINST в случае, если захотите изменить их).
     - Если вы нажмете N (для  Нет),  изменения  ваши  будут
проигнорированы,  и  вы вернетесь к напоминанию операционной
системы без измененных значений по  умолчанию  Турбо-Паскаля
или его запуска. Если вы нажмете Esc, то вернетесь к меню.
 
     Если вы решили, что хотите восстановить исходные значе-
ния, установленные в Турбо-Паскале по умолчанию, просто ско-
пируйте TURBO.EXE со своего основного диска на рабочий диск.
Вы  также можете восстановить команду редактора, выбирая оп-
цию Е в основном меню, а затем нажимая R (для восстановления
исходных значений по умолчанию) и Esc.


                        ПРИЛОЖЕНИЕ Е

                       Введение в ДОС

     Если вы являетесь новичком в вычислительной технике или
в  ДОС, то весьма возможно, что вы не поймете некоторых тер-
минов, используемых в данном руководстве. Данное  приложение
дает  краткий  обзор  следующих основных принципов и функций
операционной системы ДОС:

     - что такое ДОС и что она делает;
     - правильный способ загрузки программы;
     - каталоги, подкаталоги и команды маршрутов;
     - использование файлов AUTOEXEC.BAT.

     Приводимая информация не является методом полного объя-
нения  операционной  системы ДОС. Если вы нуждаетесь в более
подробной информации, смотрите "Руководство пользователя  по
ДОС", которо поставляется вместе с операционной системой ва-
шей ЭВМ.
     Турбо-Паскаль  работает  в  операционной  системе   ДОС
(MS-DOS или PC-DOS, версия 2.0 или более поздняя).

                       Что такое ДОС?

     ДОС - это сокращение для термина Дисковая  Операционная
Система.  MS-DOS  - это версия микропрограммного обеспечения
ДОС, в то время как PC-DOS - это вариант ДОС фирмы ИБМ (пос-
кольку  различие  этих систем невелико, в данном руководстве
использутся просто термин ДОС - прим. перев.). ДОС координи-
рует  работы и управляет взаимодействиями между частями сис-
темы вычислительной машины, операционной  системой  вычисли-
тельной машины и вами. ДОС работает в фоновом режиме, прини-
мая на себя заботу о возможных обслуживающих заданиях вычис-
лительной  машины,  думать о которых вы бы не хотели, напри-
мер, управление информационным потоком знаков между  клавиа-
турой и вычислительной машиной, между вычислительной машиной
и вашим печатающим устройством и между дисками и  внутренней
памятью (память прямого доступа).
     Остальные взаимодействия инициируются вводом  команд  в
командной строке ДОС. Другими словами - непосредственно пос-
ле подсказки ДОС. Вероятно ваше подсказка ДОС выглядит одним
из следующих образов:

     A>
     B>
     C>

     Заглавная буква представляет собой ссылку на  действую-
щий  дисковод  Например, если подсказка имеет вид A>, то это
значит, что вы работаете с файлами на дисководе А и что  ко-
манда,  которую вы выдаете ДОС, будет ссылаться на этот дис-
ковод. Если вы хотите переключиться на другой диск, то  все,
что  вы  должны  сделать, чтобы ваш диск был активным, - это
набрать букву диска с последующим двоеточием и нажть клавишу
Enter. Например, чтобы переключиться на дисковод В, наберите

     B: Enter

     Имеются несколько команд, которые вы будете  часто  ис-
пользовать с ДОС, или уже использовали:
 
    DEL или ERASE          Удалить файл
    DIR                    Просмотреть список файлов на
                           регистрируемом диске
    COPY                   Скопировать файлы с одного диска
                           на другой
    TURBO                  Загрузить Турбо-Паскаль
 
     ДОС не обращает внимания на то, набираете ли  вы  буквы
на  вкрхнем  регистре  или на нижнем или пользуетесь обоими,
поэтому вы можете вводить свои команды, как вам больше  нра-
вится.
     Мы предполагаем, что вы знаете как использовать  первые
три приведенные команды. Если нет, посмотрите справочное ру-
ководство по ДОС. Далее мы объясним правильный  способ  заг-
рузки  программ  Турбо-Паскаля, который вызывается последней
командой в приведенном выше списке - TURBO.

                  Как загрузить программу

     На вашем дистрибутивном диске вы найдете главную  прог-
рамму  Турбо-Паскаля  в файле по имени TURBO.EXE. Этот прог-
раммный файл является необходимым для всех функций,  поэтому
при  запуске программ он вам всегда потребуется. Имя файла с
расширением .СОМ или .ЕХЕ - это программный файл, который вы
можете  загружать  или выполнять (использовать, стартовать),
набирая его основное имя в ответ на подсказку ДОС. Чтобы за-
пустить  Турбо-Паскаль,  наберите  просто  TURBO  и  нажмите
Enter,  Турбо-Паскаль загрузится в память вашей вычислитель-
ной машины.
     Имеется одна вещь, которую  вам  необходимо  помнить  о
загрузке  Турбо-Паскаля и других аналогичных программ: чтобы
загрузить программу вы должны регистрироваться на диске и  в
каталоге,  куда программа загружается. Если вы не установите
маршрута ДОС (кратко описанного), то ДОС не будет знать, где
искать вашу программу.
     Например, если ваш  дистрибутивный  диск  с  программой
TURBO.EXE находится на дисководе А, а подсказкой, которую вы
видите на своем экране, является B>, то ДОС не будет  знать,
о  чем  вы  говорите,  если  наберете TURBO и нажмете Enter.
Вместо запуска Турбо-Паскаля ДОС выдаст  вам  сообщение  Bad
command or file name (Неверное имя или файл). 
     Это тоже самое, если бы вы спустали файл в своей карто-
теке, ищя в нем информацию о своих домашних финансах. Вы на-
ходитесь в неправильном месте. Поэтому, если с  вы  получили
это сообщение ДОС, просто переключитель на дисковод А, наби-
рая А:, а затем нажимая Enter. После этого наберите TURBO  и
нажмите Enter, чтобы загрузить Турбо-Паскаль.
     Вы можете установить "путь доступа" (маршрут) к  файлам
Турбо-Паскаля,  для того, чтобы ДОС смог затем их найти, ис-
пользуя команду ДОС path. Более подробную информацию смотри-
те в разделе, озаглавленном "Файл AUTOEXEC.BAT".

                          Каталоги

     Каталог - это удобный способ организации файлов на  ва-
шем гибком или твердом диске. Каталоги позволяют вам подраз-
делять диск на области, реализуя основной метод,  с  помощью
которого вы можете помещать группы картотек файлов в отдель-
ные файловые блоки. Например, вам может понадобиться  помес-
тить все свои картотеки файлов, имеющие отношение к финансам
- файл банковских бюллетеней, файл  подоходных  налогов  или
что-либо подобное - в блок, помеченный "Финансы".
     На своей ЭВМ было бы удобно создать оглавление,  храня-
щее  все  файлы  Турбо-Паскаля,  другое оглавление для ваших
файлов SideKick, третье для писем и так далее.  Таким  обра-
зом,  если вы набираете в командной строке ДОС DIR, то вы не
должны просматривать сотни имен файлов в поисках нужного. Вы
получите  список  файлов  только  того каталога, в которое в
данное время вошли.
     Затем вы можете создать каталоги и на гибком  диске,  и
на твердом диске. Наиболее часто они используются на твердом
диске. Так как твердые диски  могут  хранить  больший  объем
данных,  то  имеется и потребность в их организации и сорти-
ровке.
     Если вы находитесь на в среде ДОС, а не  в  среде  Тур-
бо-Паскаля или другой программы, то вы можете предписать ДОС
создать каталог, переместить файлы по каталогу и вывести  на
экран  информацию  о том, какие файлы находятся в конкретном
каталоге. 
     В примерых, которые следуют далее, мы предполагаем, что
вы используете систему с твердым (винчестерским) диском, пе-
реписывая на него информацию, и что подсказка, которое нахо-
дится  на  экране, - это C>. Если вы хотите создать каталоги
на гибких дисках, то подставьте в примере вместо С буквенные
метки А или В.
     Чтобы создать каталоги для файлов Турбо-Паскаля, выпол-
ните следующее:

     1. При подсказке C> наберите MKDIR Turbo и нажмите кла-
вишу  Enter.  Команда  MKDIR предпишет ДОС создать каталог с
именем TURBO.
     2. Наберите CHDIR TURBO и нажмите Enter. Команда  CHDIR
предпишет ДОС перейти в каталог TURBO.
     3. Теперь поместите диск Турбо-Паскаля, с  которого  вы
хотите  осуществить копирование, на один из ваших дисководов
для гибких дисков - скажем для данного примера А - и набери-
те COPY F: *.* Enter. (Звездочки являются глобальными симво-
лами, указываемыми для всех файлов). Команда COPY  предписы-
вает  ДОС  скопировать  все  файлы  на дисководе А в каталог
TURBO на дисководе С. При копировании каждого файла на диск,
его имя будет выводиться на экран. 
     Это все, что для этого нужно. В каталоге нужно работать
так же: чтобы загрузить Турбо-Паскаль, нужно перейти в ката-
лог TURBO (перед набором команды TURBO  и  нажатием  клавиши
Enter), иначе ДОС не сможет найти вашей программы.

                        Подкаталоги

     Если вы являетесь человеком, который действительно  лю-
бит порядок, вы можете подразделить каталоги на подкаталоги,
Допускается  создавать  столько  каталогов  и  подкаталогов,
сколько  вам понравится - только не забывайте, куда вы поме-
щаете свои файлы.
     Подкаталог создается таким же образом, как  и  каталог.
Чтобы  создать  подоглавление из оглавления TURBO (например,
для хранения ваших файлов  программных  модулей),  выполните
следующее:

     1. Убедитесь, что вы находитесь в оглавлении TURBO.
     2. Наберите команду MKDIR UNITS <Enter> .
     3. Наберите команду CHDIR UNITS. Теперь вы находитесь в
подкаталоге UNITS.
     4. Скопируйте свои файлы  программных  единиц  в  новый
подкаталог.

                      Подсказка $p $g

     Вы вероятно заметили при смене подкаталога, что на  эк-
ране  вы  видите подсказку C>. Указания того, что вы находи-
тесь в данный момент в данном каталоге или подкаталоге  нет.
И  это  легко может привести к путанице, особенно если вы на
некоторое время ушли с вычислительной машины. При этом очень
легко забыть, где вы находитесь. 
     ДОС предоставит вам легкий способ выйти из этого  поло-
жения. Наберите
 
 prompt=$p $g
 
и с этого момента (до тех пор, пока вы не выключите свою ЭВМ
или  не  перезагрузитесь) в подсказке будет указываться, где
вы находитесь в данное время. Попробуйте сделать  это.  Если
вы  еще  находитесь в плдкаталлге UNITS, nmbpifi mncougmllmh
pgpqckz ALO будет выглядеть следующим образом:
 
 C:\TURBO\UNITS >
 
                     Файл AUTOEXEC.BAT

     Чтобы избежать набора команды подсказки  (рассмотренной
в  предыдущем  разделе) с целью указания, где вы находитесь,
при каждом включении компьютера, вы можете сформировать файл
AUTOEXEC.BAT,  который будет выполнять эту функцию. Файл AU-
TOEXEC.BAT является  полезным  инструментом,  который  будет
заставлять  вашу  ЭВМ выполнять автоматически некоторые вещи
при ее запуске. На самом деле он  выполняет  гораздо  больше
функций, но вместе того, чтобы более подробно обсуждать это,
мы предлагаем вам обратиться к  справочному  руководству  по
ДОС.   Здесь  мы  продемонстрируем  вам,  как  создать  файл
AUTOEXEC.BAT, который автоматически будет изменять подсказку
так,  что вы будете знать, где вы находитесь в структуре ка-
талогов, будет устанавливать путь к каталогу TURBO  и  затем
загружать Турбо-Паскаль. 
     Команда ДОС path   сообщает  вычислительной  машине  то
место,  где  она должна искать команду, которую она не может
обнаружить. ДОС может распознать только программы, находящи-
еся  в  текущем  (в  котором вы находитесь сейчас) каталоге,
если не указан маршрут доступа к каталогу, содержащему  нуж-
ные программы или файлы.
     В следующем примере мы зададим маршрут каталога TURBO.
     Если у вас есть файл AUTOEXEC.BAT в корневом (основном)
оглавлении, ЭВМ выполнит все в этом файле, когда вы в первый
раз ее включите. (Корневой каталог находится там, где вы ви-
дите  подсказку  C>  или C: без имен каталогов, следующих за
ней).
     Ниже показано, как создать файл AUTOEXEC.BAT.

     1. Наберите команду CHDIR, чтобы убедиться, что вы  на-
ходитесь в корневом каталоге.
     2. Наберите команду COPY CON AUTOEXEC.BAT <Enter>.  Это
является  указанием  ДОС для копирования того, что вы будете
дальше вводить, в файл AUTOEXEC.BAT.
     3. Наберите:
 
    PROMPT=$P $G Enter
    PATH=C:\TURBO
    CHDIR TURBO
    Ctrl-Z <Enter>
 
     Последовательность Ctrl-Z сохранит ваши команды в файле
AUTOEXEC.BAT.
     Чтобы проверить свой новый файл AUTIEXEC.BAT,  перезаг-
рузите  ЭВМ,  держа нажатыми клавиши Ctrl и Alt, нажимая од-
новременно Del. Вы должны будете увидеть на экране C:TURBO>.

                      Смена каталогов

     Как получить из одного каталого доступ к  другому?  Это
зависит  от  того,  куда вы хотите перейти. Основная команда
ДОС для смены каталогов - CHDIR.  Используйте  ее  следующим
образом:
     - Чтобы перейти из одного каталога в другое,  например,
чтобы  перейти из каталога TURBO в каталог SPRINT, наберите,
находясь в каталоге TURBO,  следующее:
 
 C:\TURBO CHDIR \SPRINT Enter
 
     Обратите внимание на знак  обратной  косой  черты  (\),
стоящий  перед  именем каталога. Всегда, когда вы переходите
из одного каталога в другой, не зависимо от него,  набирайте
имя  этого  оглавления  со стоящим перед ним знаком обратной
косой черты.
     - Чтобы переместиться из  каталога  в  его  подкаталог,
например,  чтобы  перейти  из  оглавления TURBO в подкаталог
UNITS, наберите, находясь в оглавлении ТР, следующее:
 
 C:\TP> CHDIR UNITS <Enter>
 
     В таком случае вам не нужна обратная косая  черта,  так
как  каталог UNITS является прямым ответвлением каталога ТР.
В действительности операционная система не поняла бы, что бы
вы имели в виду, если бы вы использовали обратную косую чер-
ту. ДОС посчитала бы, что  UNITS  -  это  каталог  основного
(корневого) каталога. 
     - Чтобы переместиться из подкаталога в его основной ка-
талог,  например, чтобы переместиться из подкаталога UNITS в
каталоге ТР, находясь в каталоге UNITS, наберите следующее:
 
 C:\TP\UNITS> CHDIR .. <Enter>
 
     ДОС переместит вас обратно в каталог  ТР.  Каждый  раз,
когда вы захотите возвратиться из подкаталога в его каталог,
используйте пробел и две точки, которые должны следовать  за
командой CHDIR.
     - Чтобы перейти в корневой каталог, необходимо  следую-
щее.  Корневой каталог является исходным каталогом. Он явля-
ется для всех каталогов (и подкаталогов) порождающим.  Когда
вы  находитесь  в  корневом каталоге, то подсказка ДОС имеет
вид: 
 
     C:\>.
 
     Чтобы перейти в корневой каталог из любого другого  ка-
талога, наберите просто:
 
 CHDIR \ Enter
 
     Обратная косая черта без имени  каталога  говорит  ДОС,
что вы хотите вернуться в корневой каталог.
     Данное приложение дает только поверхностное представле-
ние  о  ДОС  и  ее функциях. Если вы хорошо знакомы с данной
здесь информацией, то у вас может появиться желание  изучить
руководство по ДОС и узнать обо всех остальных функциях, ко-
торые можно выполнить с помощью операционной  системы  вашей
вычислительной  машины.  Имеется  множество  функций ДОС, не
упомянутых здесь, которые могут упростить и повысить качест-
во использования вашей вычислительной машины.


                        ПРИЛОЖЕНИЕ F

                      Словарь терминов

     absolute variable (абсолютная переменная) - Переменная,
описанная, как существующая в фиксированном адресе памяти, а
не размещаемая в памяти компилятором.

     ANSI - Сокращение для American National  Standards  In-
stitute (Американский национальный институт стандартов), ор-
ганизации, которая, среди прочего,  описывает  элементы  так
называемого стандартного Паскаля.

     ASCII character set (набор знаков ASCII) - Американский
стандартный код для обмена информацией, который представляет
знаки и управляющие  символы,  используемые  вычислительными
машинами.

     actual parameter (фактический параметр)  -  Переменная,
выражение  или константа, которые представляются вместо фор-
мального параметра в обращениях к процедурам и функциям. 

     address (адрес) - Конкретное место в памяти.

     algorithm  (алгоритм) - Набор правил, определяющих  ре-
шение задачи.

     allocate  (распределение) - Служит  для  резервирования
области памяти для реализации определенной цели, обычно, вы-
деляется из динамической области.

     array  (массив) -  Последовательная  группа  однородных
элементов  данных,  которые упорядочиваются в одну структуру
данных и доступ к которым осуществляется с помощью индекса.

     argument  (аргумент) - Альтернативное название для  па-
раметра (смотрите фактический параметр).
     assignment operator (оператор  присваивания)  -  Символ
:=, который присваивает значение переменной или функции того
же типа.

     assignment statement  (оператор присваивания) -  Опера-
тор, который присваивает конкретное значение идентификатору.

     assembler (ассемблер) - Программа, которая  преобразует
программы на языке ассемблера в машинный язык.

     assembly language (язык ассемблера) -  Первый  языковый
уровень над машинным языком. Язык ассемблера является специ-
фическим  для  микропроцессора,  который  его  обрабатывает.
Главным  отличием  между языком ассемблера и машинным языком
является то, что язык ассемблера поддерживает  мнемонические
обозначения, облегчающие его чтение и запись.

     base type  (основной тип) - Базовый тип значения в мас-
сиве.

     binary  (двоичный) - Система счисления по основанию  2.
Метод представления чисел с помощью только двух цифр 0 и 1. 

     bit  (бит) - Двоичная цифора со значением 0 и  1.  Наи-
меньшая  единица представления данных в вычислительной маши-
не.

     block (блок) - Связанные части  описания  и  операторов
одной программой или подпрограммой.

     body  (тело) - Инструкции, принадлежащие программе  или
подпрограмме (процедуре или функции).

     boolean (булевский) - Тип данных, который  может  иметь
значение TRUE и FALSE.

     braces (фигурная скобки) - Знаки {  и  },  используемые
для  ограничения  комментариев,  иногда называемые фигурными
скобками.

     brackets (квадратные скобки) - Знаки [ и ],  называемые
квадратными скобками.

     buffer (буфер) - Область памяти, выделяемая в  качестве
временной памяти.

     bug  (ошибка)  -  Ошибка  в  программе.  Синтаксические
ошибки  ссылаются  на  неверное  использование  правил языка
программрования. Логические  ошибки  ссылаются  на  неверную
стратегию в программе, не обеспечивающую намеченного резуль-
тата.

     build (построение) - Процесс перекомпиляции всех  прог-
раммных модулей, используемых программой.

     byte (байт) - Последовательность из 8 бит.

     call (обращение) - Предписание  подпрогамме  (процедуре
или функции) выполняться при ссылке на ее имя.

     case label (метка оператора варианта) -  Константа  или
список констант, который помечает оператор-компоненту в опе-
раторе варианта.

     case selector (селектор варианта) - Выражение,  резуль-
тат  вычисления  которого  используется  для выбора операто-
ра-компонента из оператора варианта,  который  должен  будет
выполниться.

     central processing units (CPU) (центральное обрабатыва-
ющее устройство (CPU)) - Мозг системы вычислительной машины,
который интерпретирует и выполняет  инструкции  и  управляет
другими компонентами системы.

     chaining  (сцепление программы) -  Передача  управления
от одной программы к другой.
     char (pgk`m{lzh) -  Тип данных  алгоритмического  языка
Паскаль, который представляет одиночный символ.

     code  (код) - Предписание  для  вычислительной  машины.
Исходный код программы - это реализация алгоритмов.

     code segment (сегмент кода)  -  Часть  скомпилированной
программы, длиной до 32767 байт.

     comment (комментарий) - Пояснительное предложение в ис-
ходном коде, заключенное стмволами (* *) или { }.

     compiler (компилятор) -  Программа,  которая  переводит
программу,  написанную  на языке высокого уровня, в машинный
язык.

     compiler directive (директива компилятора)  -Инструкция
для компилятоа, которая вставляется внутрь программы. Напри-
мер, директива {$R+} приводит в действие проверку границ.

     compound statement (составной оператор) - Ряд  операто-
ров,  заключенных между парой зарезервированных слов begin и
end.

     concatenate  (соединение) - Объединение двух  или  нес-
кольких строк.

     constant (константа) - Фиксированное значение  в  прог-
рамме.

     control character (управляющий  символ)  -  Специальный
непечатаемый  символ  в наборе символов кода ASCII, разрабо-
танный для  управления  печатающим  устройством  или каналом 
связи.

     control structure (управляющая структура)  -  Оператор,
управляющий ходом выполнения программы. 

     crash (аварийный отказ) - Внезапный  отказ  в  вычисли-
тельной  машине, произошедшей из-за ошибки аппаратного обес-
печения или программы.

     data segment (сегмент данных)  -  Сегмент  памяти,  где
хранятся статические глобальные переменные.

     data structures (структуры данных) - Области взаимосвя-
занных элементов памяти, представленных в виде массивов, за-
писей или связанных списков.

     debugger  (отладчик) - Специальная  программа,  предос-
тавляющая  возможности  для запуска и остановки программы по
вашему желанию, а также для анализа значений, которыми  опе-
рирует  программа. Турбо-Паскаль снабжен встроенным отладчи-
ком, работающим в интегрированной среде. Предусмотрена также
поддержка автономного Турбо-отладчика.

     debugging  (отладка) - Процесс поиска и удаления ошибок
из программ.

     decimal (десятичный) - Метод представления чисел с  по-
мощью  записи в системе счисления по основанию 10, в которой
цифры находятся в диапазоне с 0 до 9.

     declare (описание) - Акт  явного  определения  имени  и
типа идентификатора в программе.

     dereferencing (разыменование) - Акт осуществления  дос-
тупа  к  значению, на которое указывает ссылочная переменная
(а не к самой ссылочной переменной).

     definition part (раздел определения) - Часть программы,
где определяются константы, метки и структурированные типы.

     delimiter  (разделитель) - Граничная метка, которой мо-
жет быть слово, знак или символ.

     directory (каталог) - Рабочая  область  на  диске,  или
список файлов (или оглавлений) на диске.

     documentation  (документация)  -  Записанное  пояснение
программы  вычислительной машины. Документацией может быть и
справочное руководство в сотни страниц, и комментарий,  сос-
тоящий из одной строки, вставленный в саму программу.

     dynamic (динамический) - Нечто, что изменяется во время
выполнения программы.

     dynamic allocation (динамическое распределение) - Расп-
ределение и освобождение памяти в динамической области расп-
ределения во время выполнения программы.

     dynamic variable (динамическая переменная) - Переменная
в динамически распределяемой области памяти.

     element (элемент) - Один из элементов в массиве.

     enumerated type (перечислимый тип) - Скалярный тип, оп-
ределяемый  пользователем,  который состоит из произвольного
списка идентификаторов.

     evaluate (вычислять) - Вычислить значение выражения.

     expression (выражение) - Часть оператора, которая может
представлять значение или может быть использована для вычис-
ления значения.

     extension (расширение) - Любое добавление к стандартно-
му  определению  языка.  Также это может быть необязательное
трехзнаковое окончание (следующее за точкой)  в  стандартном
имени файла ДОС.

     execute (выполнять) - Выполнять инструкции программы.

     external (внешний) - Файл одной или нескольких подпрог-
рамм,  которые были написаны на языке ассемблера и ассембли-
рованы в собственный выполняемый код.

     field list (список полей) - Имя поля и определение типа
записи.

     field width (размер поля) - Количество  имеющихся  эле-
ментов в выходном операторе.

     file (файл) - Совокупность  информации,  которая  может
быть запомнена и восстановлена с диска.

     file pointer (указатель файла) - Указатель, который за-
поминает, где будет восстановлен следующий объект из файла.

     file variable (файловая переменная) -  Идентификатор  в
программе, который представляет файл.

     fixed-point notation (запись с фикфированной запятой) -
Представление  действительных  чисел без использования деся-
тичной запятой.

     flag (флаг) - Переменная, обычно целого типа  (integer)
или  булевская,  которая  изменяет  значение для того, чтобы
указывать, на то, что произошло какое-нибудь событие.

     floating-point notation (запись с плавающей запятой)  -
Представление  действительных  числел с использованием деся-
тичных запятых.

     formal parameter (формальный параметр) - Идентификтор в
заголовке  описания процедуры или функции, который представ-
ляет аргументы, которые будут переданы в подпрограммы, когда
к ней произойдет обращение.

     forward declaration (опережающее описание)  -  Описание
процедуры  или  функции и их параметров перед действительным
определением такой подпрограммы.

     function (функция) - Подпрограммы, которая вычисляет  и
возвращает значения.

     global variable (глобальная переменная)  -  Переменная,
описанная  в основном блоке программы и к которой может быть
осуществлен доступ из любого места внутри программы.

     high-level language (язык высокого уровня) - Язык прог-
раммирования, который больше похож на человеческий язык, чем
машинный язык. Паскаль - это язык высокого уровня.

     heap (динамически распределяемая область памяти) -  Об-
ласть  памяти, зарезервированная для динамического распреде-
ления переменных.

     hexadecimal (шестнадцатиричный) -  Метод  представления
чисел  с помощью записи в системе счисления по основанию 16,
когда используются цифры в диапазоне от 0 до 9 и буквы от  A
до F.
     identifier (идентификатор) - Имя, определяемое  пользо-
вателем  для конкретного элемента (константы, типа, перемен-
ной, процедуры, функции, программного модуля  (unit),  прог-
раммы  и поля). Он должен начинаться с буквы и не должен со-
держать пробелов.

     implemantation (релизация) - Конкретное воплощение язы-
ка программирования. Турбо-Паскаль - это реализация стандар-
тного Паскаля для вычислительных машин, совместимых с компь-
ютером IBM РС.

      increment (приращение) - То, с помощью чего увеличива-
ют значение переменной.

     index (индекс) - Положение внутри списка элементов.

     index type (тип индекса) - Тип индексов в массиве.

     initialize (инициализация) - Процесс задания известного
начального значения переменной или структуре данных.

     input (ввод) - Информация, которую получает программа с
некоторого внешнего устройства такого, как, например, клави-
атура.

     integer (целое) - Числовая переменная, являющаяся целым
числом в диапазоне от -32768 до +32767.

     interactive (интерактивность) - Программа, которая осу-
ществляет  связь с пользователем через какое-либо устройство
ввода-вывода.

     interrupt (прерывание) - Временная остановка программы,
осуществляемая  с целью предоставления возможности обработки
события более высокого приоритета.

     interpreter (интерпретатор) - Программа, последователь-
но интерпретирующая каждый оператор программы в машинный код
и сразу же после этого его выполняющая.

     I/O (Input/Output) (ввод-вывод) - Процесс получения или
отправления информации.

     I/O error (ошибка ввода-вывода) - Ошибка,  появляющаяся
во время попытки ввести или вывести информацию.

     I/O redirection (перенаправление ввода-вывода)  -  Воз-
можность  направлять ввод-вывод на  устройство доступа,  от-
личное от устройства доступа, принятого по умолчанию.

     iteration (итерация) Процесс повторения или  зациклива-
ния.

     keyword (ключевое слово) -  Зарезервированное  слово  в
Паскале.  В  данном  руководстве ключевые слова изображаются
жирныи шрифтом (например, begin, end, nil).

     label (метка) - Идентификатор, который помечает место в
тексте  программы для оператора goto. Метки - это последова-
тельность цифр, чьи значения изменяются в диапазоне от 0  до
9999.

     level (уровень) - Глубина вложения процедур или  управ-
ляющих структур.

     linked list (связанный список) - Динамическая структура
данных,  получающаяся из элементов, каждый из которых указы-
вает на следующий элемент в этом списке с помощью  ссылочной
переменной.

     literal (литерал) - Разыменованная константа в програм-
ме.

     local identifier (локальный идентификатор) -  Идентифи-
катор, описанный внутри процедуры или функции.

     local variable  (локальная  переменная)  -  Переменная,
описанная внутри процедуры или функции.

     long word (двойное слово) - Адрес в памяти,  занимающий
4 соседних байта. Память, требующая для переменной типа lon-
gint.

     loop (цикл) -  Набор  операторов,  которые  выполняются
повторно.

     main procedure (основная процедура) - Часть  программы,
заключенная в самые внешние операторные скобки begin и end.
     mashine language  (машинный язык) - Язык, состоящий  из
строк  нолей  и  единиц, которые вычислительная машина инте-
рпретирует как инструкции. См. пункт данного  словаря  "язык
ассемблера".

     main program (основная программа) - Блок begin/end, за-
вершаемый точкой, стоящей в конце программы. Также называет-
ся разделом операторов.

     make (создание) -  Процесс  перекомпиляции  только  тех
программных  единиц,  исходные коды которых были изменены со
времени последней компиляции.  Программа,  управляющая  этим
процессом.

     memory (память) - Область в вычислительной  машине  для
хранения информации и выполняющихся программ.

     module (модуль)  -  Независимая  программа  или  группа
программ.

     nesting вложение) - Помещение одной программной единицы
внутрь другой. 

     nil pointer (указатель  типа  nil,  nrpqmh  rifqcj{)  -
Ссылка,  имеющая  специальное значение nil. Указатель nil ни
на что не указывает (пустой указатель).

     node (узел) - Отдельный элемент дерева или списка.

     object code (объектный код) - Выходная информация  ком-
пилятора.

     offset  (смещение) - Индекс внутри сегмента.

     operand (операнд) - Аргумент и один или несколько  опе-
рандов и операторов, сочетания которых образуют выражения.

     operating system (операционная  система)  -  Программа,
управляющая  всеми операциями и ресурсами вычислительной ма-
шины.

     operator (операцдя) - Символ такой, как,  например,  +,
использующийся для образования выражений.

     operator hierarchy (иерархия операций) - Правила, опре-
деляющие  порядок,  в котором выполняются операции в выраже-
нии. 

     ordinal type (порядковый тип) - Упорядоченный  диапазон
значений. То же самое, что и скалярный тип.

     output (вывод) - Результат работы программы. Вывод  мо-
жет  быть  послан на печатающее устройство, выведен на экран
или записан на диск. 

     overflow (переполнение) - Условие, которое  получается,
если операция получает значение, которое является больше са-
мого положительного или меньше самого отрицательного  значе-
ний,  которые может представить вычислительная машина в дан-
ные, выделенные для значения или выражения области.

     parameter (параметр) - Переменная или значение, которые
передаются процедуре или функции.

     parameter list (список параметров) - Список  параметров
значений и переменных, описываемый в заголовке описания про-
цедуры или функции.

     Pascal, Blaise (Паскаль, Блез) - Французский  математик
и философ (1623-66), создавший механическую суммириующую ма-
шину, которая считается древним предшественником калькулято-
ров и вычислительных машин.

     pass (передавать) - Использовать в качестве параметра.

     pointer (указатель, ссылка) -  Переменная,  указывающая
на конкретный адрес в памяти.

     pop (выталкивание) - Удаление самого верхнего  элемента
из стека.

     port (порт) - Устройство ввода-вывода, доступ к которо-
му осуществляется через шину процессора.

     precedence (порядок выполнения) -  Порядок,  в  котором
выполняются операции.

     predefiened identifier (предописанный идентификатор)  -
Константа,  тип,  файл,  логическое устройтво, процедура или
функция, доступная программисту без предварительного  описа-
ния или объявления.

     procedure (процедура) - Подпрограмма, которую можно вы-
зывать из различных мест большей программы.

     procedure call (вызов процедуры) - Вызов процедуры.

     program (программа)  -  Последовательность  инструкций,
которые должны быть обработаны компилятором.

     prompt (подсказка) - Строка, выводимая программой, что-
бы  указать пользователю, что нужно что-то ввести и (иногда)
тип ожидаемых данных.

     push (занести) - Добавление элемента в вершину стека.

     random access (прямой доступ) - Непосредственный доступ
к  элементу или структуре данных без последовательного прос-
мотра всей структуры.

     random-access memory (RAM) (память с произвольным обра-
щением)  Память, для которой можно выполнять операции чтения
и записи.

     range-checking (проверка границ) - Средство  Турбо-Пас-
каля, которое осуществляет проверку на принадлежность значе-
ния к допустимому диапазону.

     read-only memory (ROM)  (память,  доступная  только  по
чтению)  -  Память, в котторую нельзя производить запись, но
из которой можно считывать данные.

     real number (действительное число) -  Число,  представ-
ленное с использованием десятичной фиксированной или плаваю-
щей запятой.

     record (запись) - Структурный тип  данных,  допускающий
ссылку  на идентификатор, содержащий несколько различных по-
лей.

     recursion (рекурсия) - Метод программирования, при  ко-
тором допускается вызов программой самой себя.

     relational operator (оператор сравнения)  Операторы  =,
<>,  <, >, <=, >=, in, которые используются в выражениях бу-
левского типа.

     reserved word (зарезервированное слово) - Слово,  заре-
зервированное  компилятором.  Значение и использование этого
слова зарезервировано только для использования в  программе.
Изменение или переопределение такого слова не допускается.

     result (результат) - Значение, возвращаемое процедурой,
функцией или программой.

     runtime (время, этап выполнения) - Время, в течении ко-
торого выполняется программа.

     scalar type (скалярный тип) - Любой тип Паскаля, состо-
ящий из упорядоченных элементов.

     scientific notation (запись, используемая в научно-тех-
нических  расчетах) - Запись числа, при которой используется
число от 1 до 10 (мантисса), умноженное на степень числа  10
(экспоненту).

     scope (область действия) - Область действия идентифика-
тора в программе).

     segment (сегмент) - В машинах,  использующих  процессор
8088, память разделена на сегменты по 64К.

     separate compilation (раздельная компиляция) -  Возмож-
ность разбивать большую программу на несколько частей и ком-
пилировать каждый модуль отдельно, объединяя их затем в один
выполняемый файл (.ЕХЕ).

     separator (разделитель) - Пробел или комментарий.

     sequential access (последовательный доступ) -  Упорядо-
ченный доступ к каждому элементу или структуре данный, начи-
нающийся с первого элемента структуры.

     set (множество) - Неупорядоченная  группа  элементов  с
одинаковым скалярным типом.

     set operator (операция над множеством) - Символ  +,  -,
*, =, <, >, <=, >=, <>, in. При использовании операндов-мно-
жеств каждая операция  возвращает  результат  множественного
типа.

     simple type (простой тип) - Тип, содержащий одно значе-
ние.

     source code (исходный код) - Код,  подаваемый  на  вход
компилятора.

     stack (стек) Структура данных, в которой последний сох-
раняемый элемент извлекается первым.

     stack overflow (переволнение стека) - Ошибочное состоя-
ние.  Возникает, когда оказывается исчерпанным пространство,
выделенное для стека.

     stack segment (сегмент стека) - Сегмент  памяти,  выде-
ленный для программного стека.

     statement (оператор) -  Простейший  элемент  программы.
Операторы разделяются точкой с запятой.

     static variable (статическая переменная) -  Переменная,
существующая  только  во  время выполнения программы. Память
для статических переменных выделяется в  сегменте  (области)
данных.

     string (строка) - Последовательность символов,  рассма-
тириваемая, как одно целое.

     structured type (структурный тип) - Один из предопреде-
ленных типов (массив, запись, файл или строка), который сос-
тоит из структурных элементов данных.

     subprogram (подпрограмма) -  Процедура  или  функция  в
программе.

     subrange (поддиапазон)  -  Непрерывный  отрезок  любого
скалярного типа.

     subscript (индекс) -  Идентификатор,  используемый  для
осуществления доступа к конкретному элементу массива.

     syntax error (синтаксическая ошибка) -  Ошибка,  порож-
денная нарушением правил языка программирования.

     terminal (терминал) - Устройство ввода-вывода,  обеспе-
чивающее связь между человеком и вычислительной машиной.

     tracing (трассировка) - Ручное прохождение через каждый
оператор  программы с целью понять характер работы программы
- важный инструмент отладки.

     tansfer function (функция переноса) - Функция, преобра-
зующая значение одного типа в значение другого типа.

     tree (дерево) - Динамическая структура данных, в  кото-
рой узел (ветвь дерева) может указывать на один или несколь-
ко других узлов.

     type definition (определение типа) - Указание  не  пре-
допределенного  типа. Определяет набор значений, которые мо-
жет иметь переменная, и операции, которые могут  выполняться
с ней. 

     typed constant (типизированная константа) - Переменная,
значение  которой определяется во время компиляции, но может
изменяться во время выполнения. (Представляйте ее как  зара-
нее инициализированную переменную).

     type conversion (преобразование типа) -  Преобразование
значения в другой вид, например, преобразование целых значе-
ний в действительные.
     type coercion (смена типа) - Метод, известный также как
метод  приведения типа, при котором переменная должна считы-
ваться, как данные другого типа.

     underlying type (базовый тип) - Скалярный тип,  соотве-
тсвующий конкретному поддиапазону (отрезку типа). 

     unit  (программный модуль) - Программный модуль,  кото-
рый можно отдельно компилировать. Он может содержть код, ин-
формацию, описание типа и (или) констант. Программный модуль
использовать другие программные модули и разбиваться на раз-
делы интерфейса (открытые) и для использования (личные).

     untyped parameter (не типизированный параметр)  -  Фор-
мальный  параметр, позволяющий иметь действительный параметр
любого типа.

     value parameter  (значение параметра) - Параметр проце-
дуры или функции, передающийся значением, то есть передается
значение параметра, и оно не может быть изменено. 

     variable declaration (описание переменных) -  Описание,
состоящее из переменной и соответствующего ей типа.

     variable parameter  (параметр  переменной)  -  Параметр
процедуры или функции, передаваемый по ссылке. То есть адрес
параметра передается так, что может осуществляться доступ  к
значению этого параметра, а также оно может и изменяться.
     variant record (переменная запись) - Запись, в  которой
некоторые поля находятся в одной и той же области памяти.

     word (слово) - Место в памяти, занимающее два  соседних
байта.   Память,  необходимая  для  переменной  целого  типа
(integer).


