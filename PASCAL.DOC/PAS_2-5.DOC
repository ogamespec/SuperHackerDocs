 
                        ПРИЛОЖЕНИЕ А
 
                      Различия между 
           версиями Турбо-Паскаля 3.0, 4.0 и 5.0
 
     В данном приложении описываются различия между  версией
3.0, 4.0 и версией 5.0 алгоритмического языка Турбо-Паскаль.
Несмотря на множество различий в компиляторе и на реализацию
многих мощных средств, версия 5.0 является в высокой степени
совместимой с предыдущими версиями. Как вы увидите по  проч-
тении  этого раздела, большинство различий являются незначи-
тельными и представляют собой  результат  наличия  некоторых
новых свойств. 
     В соответствующих местах мы даем рекомендации по поводу
того, как осуществить необходимые преобразования. Для преоб-
разования программ предыдущей версии в более позднюю предус-
мотрены соответствующие утилиты.
 
                 Различие версий 4.0 и 5.0
 
     Имеется несколько различий между версиями  4.0  и  5.0,
влияющих  на обратную совместимость. Далее перечислены изме-
нения средств языка версии 4.0 и директив компилятора:
 
     1.  Изменены или добавлены многие процедру  и  функции.
         Подробно  они описаны в Главе 16 "Справочного руко-
         водства".
     2.  Файлы .TPU версии 4.0 несовместимы с  файлами  .TPU
         версии  5.0.  В  версии 5.0 нужно перекомсилировать
         весь  исходный  код  с  помощью  команды  "Компиля-
         ция/Построение" (Compile/Build).
              В версии 5.0 появились новые директивы  компи-
         лятора (они описываются в Приложении С "Справочного
         руководства"). Следующие директивы компилятора вер-
         сии 4.0 в версии 5.0 не поддерживаются:
          
         ---------------------------------------------------
         Директива версии 4.0              Описание
         ---------------------------------------------------
               $K                      Проверка стека.
               $U                  Маршрут доступа к модулю
                                       (исходный файл)
               $T                     Вывод файла .ТМР
         ---------------------------------------------------
          
              - Для управления проверкой  стека  используйте
         директиву  $S.  Для задания маршрута (пути) доступа
         ко всем используемым программой модулям используйте
         команду      "Опции/Каталоги/Каталоги      модулей"
         (Options/Directories/Unit  Directories).  Директива
         $T является устаревшей, поскольку теперь файлы .ТМР
         не генерируются. (При установке в команде  интерак-
         тивной     среды    "Отладка/Автономная    отладка"
         (Debug/Stand-Alone Debugging) значения On  информа-
         ция для отладки будет добавляться в конец выполняе-
         мого файла .ЕХЕ, после чего этот файл может исполь-
         зоваться Турбо-отладчиком. Файл .МАР можно сгенери-
         ровать, установив в интерактивной среде значение On
         для     команды     "Опции/Компоновщик/Файл    МАР"
         (Options/Linker/Map File)).
              - Директива компилятора $L, которая  управляла
         компоновкой  в  версии  4.0, в версии 5.0 управляет
         генерацией локальных символов:
          
         ---------------------------------------------------
         Директива в версии 4.0         Ее функция в версии
          5.0
         ---------------------------------------------------
         $L - Компоновка в памяти     Разрешение/запрещение
             или на диске             генерации информации о
                                      локальных символах
         ---------------------------------------------------
          
              - Для управления компоновкой  используйте  ко-
         манду      "Опции/Компоновщик/Буфер     компоновки"
         (Options/Linker/Link Buffer).
     3.  Параметры командной строки /R  и  /X,  используемые
         ранее в TPC.EXE, в версии 5.0 не поддреживаются.
     4.  В версии 5.0 введен параметр выравнивания на грани-
         цу  слова, позволяющий переключаться между выравни-
         ванием переменных и констант на границу  слова  или
         байта. В интегрированной интерактивной среде в меню
         "Опции/Компилятор" (Options/Compiler)  имеется  ко-
         манда  "Выравнивание на границу слова" (Tord Align)
         (по умолчанию выполняется выравнивание  на  границу
         слова).  Среди директив компилятора есть соответст-
         вующий эквивалент  -  директива  $A  )по  умолчанию
         {$A+}.
     5.  Описание функция в интерфейсной секции и секции ре-
         ализации  модуля  должно в точности совпадать (если
         только в  секции  реализации  не  описывается  один
         идентификатор без параметров или возвращаемого зна-
         чения). Если в интерфейсной секции  имеется  описа-
         ние:
          
           interface
               function MyFunc(X, Y : integer) : boolean;
         
         то в версии 4.0 допустима запись:
          
           implementation
                function MyFunc;
          
         Однако теперь это заменено на более  содержательный
         и  защищенный  от  ошибок вариант. В версии 5.0 обе
         следующих записи должны иметь следующий вид:
          
           implementation
                function MyFunc;
          
         или
          
           interface
               function MyFunc(X, Y : integer) : boolean;
         
     6.  В версии 4.0  при  установке  в  команде  "Компиля-
         ция/Назначение" (Compile/Destination) значения Disk
         и использовании команды "Опции/Каталоги/Каталог вы-
         полняемых  файлов"  (Options/Directories/Executable
         Directory) файл .ЕХЕ выводился в каталог  выполняе-
         мых файлов. В версии 5.0 каталог выполняемых файлов
         переименован в каталог файлов .ЕХЕ и .TPU и  позво-
         ляет управлять также выводом файлов .TPU, назависи-
         мо от того, установлено  ли  в  опции  "Назначение"
         (Destination)  значение Disk или Memory ("диск" или
         "память").
 
                  Отличие версий 3.0 и 5.0
 
     Этот раздел состоит из двух частей. В первой части  об-
суждаются  различия  и изменения в программировании в версии
3.0 и 5.0 и кратко описывается совместимость модулей (Turbo3)
и  (Graph3).  Отмечается также, где в версии 5.0 введены су-
щественные улучшения. Во второй части описывается  работа  с
программой  UPGRADE и как ее можно использовать для преобра-
зования программ версии 3.0 в программы версии 5.0.
     Многие из изменений являются  результатом  поддержки  в
версии  5.0  раздельной  компиляции с использованием модулей
(если вы не знаете, что такое модули (units), то  прочитайте
Главу 4 данного руководства). Любое настоящее преобразование
программ версии 3.0 в программы версии 4.0 должно включать в
себя  такую  реорганизацию  исходного кода версии 3.0, чтобы
можно было  воспользоваться  преимуществами  модулей  версии
5.0, которые позволяют:
 
     - создавать средства, которые могут  использоваться  во
множестве различных программ;
     - разбивать большую программу  на  управляемые  модули,
собрав вместе соответствующие описания, процедуры и функции.
Эти модули могут компилироваться отдельно,  а  затем  быстро
включаться  в  вашу  программу  с помощью встроенного в Тур-
бо-Паскаль компоновщика.
     - Использовать "скрытые"  описания  и  программы,  при-
сутствие которых нежелательно в остальной части программы.
     - Нарушать для кода ограничение в 64К, поскольку каждый
модуль модет содержать до 64К кода.
     - Строить очень большие программу, так как модули могут
перекрываться (см. Главу 13 "Справочного руководства", кото-
рая называется "Оверлеи").
 
     Даже при использовании прграммы UPGRADE, модулей Turbo3
и Graph3 (это обсуждается далее) может оказаться необходимым
внести изменения в исходный код программы версии 3.0. В сле-
дующем  разделе  рассказывается о том, какие это изменения и
как их можно выполнить.
 
                Изменения в программировании
 
                    Программные описания
 
     В версии 3.0 имя программы (идентификатор, указанный  в
операторе  программы)  могло  быть  таким же, как другой ка-
кой-нибудь идентификатор этой программы. В  версии  5.0  имя
программы  должно быть уникальным. Оно не может быть меткой,
константой, типом данных, переменной, процедурой или функци-
ей, то есть программным модулем с тем же именем.  Поэтому вы
можете теперь ссылаться на любой идентификатор, описанный  в
вашей  программе, следующим образом "имя программы.идентифи-
катор". Это дает вам возможность разрешить неоднозначности в
случае  использования программного модуля, которая описывает
некий объект, названный идентификатором.  В  такой  ситуации
можно ссылаться на элемент программного модуля следующим об-
разом: "имя программного модуля.идентификатор".
     В версии 3.0 все элементы Паскаля (константы, типы дан-
ных,  переменные, процедуры, функции) должны были компилиро-
ваться в одно и то же время и помещались или в ваш  исходный
файл,  или  во включаемый файл. В версии 5.0 вы можете соби-
рать группу констант, типов данных, переменных,  процедур  и
функций,  компилировать их по отдельности в какой-либо прог-
раммный модуль, а затем использовать в ряде программ. 
     В версии 3.0 вы могли  иметь  программу  по  объему  не
большую  64К,  и компилятор создавал файл .COM. В версии 5.0
размер кода ограничен только операционной системой (и  пара-
метрами  вашего компьютера), так как каждый модуль сам может
иметь размер до 64К, и компилятор генерирует файл .ЕХЕ.
     В версии 3.0 для того, чтобы обойти ограничения по  па-
мяти,  приходилось использовать связывание в цепочку и овер-
леи. В версии 5.0 оверлеи (основанные на модулях)  использу-
ются  для  лучшего управления памятью. Подсистема управления
оверлеями более совершенна и более  "прозразна".  Для  того,
чтобы  из  одних  программ запускать другие, вы можете также
использовать процедуру Exec (она содержится в модуле Dos).
 
                   Директивы компилятора
 
     В версии 3.0 вы могли вставлять набор директив компиля-
тора в свою программу, чтобы устанавливать (или удалять) не-
которые возможности. В версии 5.0 этот  набор  был  изменен.
Здесь,  конечно, хорошо просмотреть все директивы компилято-
ра, но особо нужно отметить директивы $B, $D и $F, поскольку
они  также используются, но тепрь имеют другой смысл. В При-
ложении С "Справочного руководства" все директивы описывают-
ся  подробно.  Здесь  же мы приведем перечень используемый в
настоящий момент (в версии 5.0) директив компилятора:
 
------------------------------------------------------------
  Директива          Описание                  Значение по
                                                 умолчанию
------------------------------------------------------------
 $A+/-       Выравнивание на границу слова         $A-
             (+=выравнивание на границу сло-
             ва, -=выравнивание на границу
             байта)
 $B+/-       Булевские вычисления (+=полные,       $B-
             -=короткие
 $D+/-       Информация по отладке (+=вклю-        $D+
             vclm, -=выключено)
 $F+/-       Дальние обращения (+=все              $F-
             b^j{lgc, -=по необходимости)
 $I+/-       Проверка ошибок ввода-вывода          $I+
             (+=включено, $=выключено  
 $I file     Включить файл
 $L+/-       Адрес буфера редактирования           $L+     
             (+=память, -=диск)
 $L файл     Компонуемый объектный файл
 $M s,l,h    Распределение памяти (стек,
             минимальный размер динамичес-
             ки распределяемой области, 
             максимальный размер динамичес-
             ки распределяемой области
             16К,0,655360       
 $N+/-       Числовой сопроцессор (+=8087,         $N-
             -=программное обеспечение)
 $O имя_мод. Разрешение использовать 
             оверлеи (+=разрешается,
             -=нет)
 $R+/-       Проверка границ (+=включена,          $R+
             -=выключена)
 $S+/-       Проверка переполнения стека           $S+
             (+=включена, -=выключена)
 $S+/-       Проверка на переполнение
             стека (+=разрешена, -=зап-
             рещена)
 $V+/-       Проверка строк-переменных             $V+
             (+=разрешена, -=запрещена)
------------------------------------------------------------
 
     Обратите внимание, что:
 
     1.  Проверка диапазона теперь по умолчанию имеет значе-
         ние Off (выключена). Если вы хотите ее включить, то
         поместите в начале вашей программы директиву компи-
         лятора {$R+}. В случае неопределенности уберите эту
         директиву. Если ваша  программа  останавливается  с
         ошибками нарушения границ (выход за допустимый диа-
         пазон), и вы не хотите с этим  разбираться,  то  не
         используйте данную директиву.
     2.  Если программа  работает  неправильно,  попытайтесь
         задать  полное вычисление булевских выражений с по-
         мощью директивы компилятора {$B+} (по умолчанию ис-
         пользуется  директива {$B-}). В интегрированной ин-
         терактивной среде имеется  соответствующий  эквива-
         лент  меню - можно установить опцию "Опции/Сомпиля-
         тор/Вычисление         булевских         выражений"
         (Option/Compiler/Boolean   Evaluation)  в  значение
         Complete (вычисление по полной схеме).
     3.  В  версии  3.0  директива  включения   файла   ([$I
         имя_файла])  может  помещаться  в  любом  месте или
         просто содержать выполняемые  операторы.  В  версии
         5.0  директива  включения  не  может  быть помещена
         внутри  операторных  скобок  begin  и   end.   Если
         "имя_файла"  содержит выполняемые операторы, то они
         должны находиться внутри завершенной процедуры  или
         функции,  или файл должен содержать целиком главное
         тело программы, включающее в себя операторные скоб-
         ки begin и end.
     4.  В  версии  3.0  директива  включения   файла   ([$I
         имя_файла])   не   требует   наличия   между  $I  и
         "имя_файла" пробела. В версии 5.0 вы обязаны поста-
         вить после $I пробел.
     5.  В версии 3.0 вы можете иметь вложенные файлы  вклю-
         чения. То есть, если ваша программа имеет директиву
         {$I mystuff.pas), то MYSTUFF.PAS не может содержать
         директив $I (включить файл). В версии 5.0 вы можете
         иметь вложенные файлы включения и программные моду-
         ли с глубиной до девяти уровней.
 
                        Ввод и вывод
 
     В работу ввода-вывода версии 5.0 внесены некоторые  су-
щественные  изменения. Эти изменения имеют целью обеспечениe
лучшей совместимости со стандартом ANSI. 

     Если вы выполняете запись и чтение вещественных  значе-
ний  из  файлов  данных,  то  нужно учитывать различия между
стандартным вещественным типом (6 байтов, совместим с верси-
ей  3.0) и типами с плавающей запятой  формата IEEE, поддер-
живаемыми по директивам {$N+} и {$E+}.
     Дальнейшее обсуждение касается различий между  реализа-
циями  стандартных  процедур  Read  и ReadLn в версиях 3.0 и
5.0. Заметим, что это относится только к работе данных  про-
цедур  со стандартным вводом (а не к чтению из файла на дис-
ке).
     В версии 3.0 процедуры Read и ReadLn обрабатывают  нес-
тандартный  ввод с консоли, в то время как в версии 5.0 кон-
соль интерпретируется так же, как  любое  другое  устройство
(например, так же, как файл на диске).
     В версии 3.0 процедуры Read  и  ReadLn  всегда  ожидают
ввода строки. Процедура ReadLn интерпретирует клавишу Enter,
как конец строки. Процедура Read - нет  (вместо  перемещения
на  новую  строку  курсор  остается в конце текущей строки).
Вводимая строка помещается в буфер ввода (без символов возв-
рата  каретки  и  перевода  строки,  то есть без метки конца
строки), а переменные ввода затем используют этот буфер, как
источник  входных данных. Если во вводимой строке вы задаете
число значений, превышающее число переменных в списке  пара-
метров процедур Read и ReadLn, то в версии 3.0 остаток стро-
ки игнорируется. Если во вводимой строке вы задаете  слишком
мало  символов,  то всем оставшимся переменным присваивается
значение Ctrl-Z, строковые значения будут пустыми, а  число-
вые  переменные  останутся неизмененными. Буфер ввода всегда
очищается до выполнения новых операций  Read  и  ReadLn,  то
есть символов от предыдущего запроса не остается.
     В версии 5.0 процедуры Read и ReadLn работают со  стан-
дартным  вводом  так  же,  как если бы данные считывались из
файла на диске. Каждая переменная текстового файла в  версии
5.0  имеет буфер ввода, который по умолчанию может содержать
до 128 символов. Каждый раз, когда процедурам Read и  ReadLn
нужно  выполнить  чтение  с диска, буфер ввода очищается, из
файла считывается новый блок до 128 символов, который сохра-
няется  в буфере. Затем символы по одному извлекаются из бу-
фера, пока он снова не окажется пустым. При стандартном вво-
де  версия  5.0  ведет  себя точно также, только каждый раз,
когда буфер становится пустым, новая  строка  считывается  с
консоли. При этом она сохраняется в буфере вместе с возврата
каретки и перевода строки (мерка конца строки).
     В качестве примера,  демонстрирующего  различия  версий
3.0 и 5.0 Турбо-Паскаля, приведем следующую программу:
 
  Program IntRead;
  var
    I, J: integer;
  begin
    ReadLn(I,J);
    Read(I); Read(J);
    Read(Input,I); Read(Input,J); ReadLn(Input);
  end.
 
     В версии 5.0 все три оператора чтения будут вести  себя
одинаково,  как и определено стандартом Паскаля. Первый опе-
ратор чтения является просто сокращенной формой  второго,  а
второй  -  сокращенной  формой  третьего.  В версии 3.0 Тур-
бо-Паскаля все они будут вести себя по разному.
     Когда в версии 5.0 выполняется первый оператор  ReadLn,
строка  вводится  с  консоли  и  сохраняется  в буфере ввода
(Input). Предположим теперь, что вводится следующая строка:
 
     10 20<Enter>
 
     Для считывания целого значения процедура Read пропуска-
ет  предшествующие пробелы, символы возврата каретки и пере-
вода строки и считывает символы до следующего пробела,  сим-
вола возврата каретки или перевода строки. Затем эти симполы
преобразуются в целое значение. В данном случае строка  '10'
преобразуется  в целое число, которое сохраняется в перемен-
ной I. Затем пропускается пробел, и строка '20' также преоб-
разуется  в целое и сохраняется в переменной J. Наконец, для
выполнения  процедуры  ReadLn  пропускается  остаток  строки
(пустой)  и последовательность символов возврата каретки/пе-
ревода строки. В точности тоже самое происходит при выполне-
нии чтения на следующих двух строках.
     В версии 3.0 при  каждом  обращении  (для  стандартного
ввода) к процедурам Read и ReadLn ожидается ввод строки, по-
этому на второй строке с оператором чтения между  значениями
требуется нажать калвишу Enter, а на третьей строке потребу-
ется дополнительное нажатие клавиши Enter после второго зна-
чения.
     Если вернуться к версии 5.0,  то  можно  заметить,  что
воспринималась бы также следующая последовательность ввода:
 
     10<Enter>
     20<Enter>
 
     Выполнение процедуры Read(I) приводит  к  вводу  первой
строки  и  обработки строкового значения '10'. Затем Read(I)
выполняет пропуск последовательности символов  возврата  ка-
ретки  и  перевода строки (Enter), которая осталась в буфере
ввода, вводит следующую строку, находит  строковое  значение
'20'  и преобразует его в целое значение. Наконец, процедура
ReadLn удаляет из буфера ввода  последовательность  символов
возврата  каретки  и  перевода строки и приводит к тому, что
следующая процедура Read или ReadLn  считает  новую  строку.
Как  можно заметить, процедура Read почти всегда оставляет в
буфере ввода оставшиеся символы. Это может привести к  тому,
что  следующая  процедура Read или ReadLn не считает строку.
Рассмотрим, в частности, следующий пример:
 
  program StrRead;
  var
    S1, S2: string[79];
  begin
    Read(S1);
    Read(S2);
  end.
 
     В версии 3.0 каждый оператор Read будет вводить  строку
без эхоотображения клавиши Enter. В версии 5.0 поведение бу-
дет совсем другим. Первая процедура Read  считает  строку  и
сохранит  ее  в буфере ввода вместе с символами возврата ка-
ретки и перевода строки (метка конца строки). Затем она счи-
тает все символы до метки конца строки в переменную S1. Вто-
рой оператор Read увидит оставшуюся метку конца строки и  не
сможет  выполнить дальнейшие действия. В результате перемен-
ной S1 будет присвоена вся строка ввода, S2  останется  пус-
той,  а в буфере будет содержаться последовательность симво-
лов возврата каретки и перевода строки  (которую  обработает
следующая процедура Read или ReadLn).
     Для того, чтобы в версии 5.0  в  буфере  не  оставалось
лишних  символов,  для  ввода  строковых и числовых значений
всегда используйте процедуру ReadLn. Например, данную  прог-
рамму StrRead следовало бы переписать следующим образом:
 
  program StrRead;
  var
    S1, S2: string[79];
  begin
    ReadLn(S1);
    ReadLn(S2);
  end.
 
                        Типы данных
 
     Там, где это можно сделать  и  удобно  использовать  на
практике,  перейдите  к  новым типа данных, использующимся в
версии  5.0.  Эти  типы  включают  в  себя  короткое   целое
(shortint),  длинное целое (longint) и слово (word), а также
указатель (как общий ссылочный тип -  pointer)  и  строковый
тип  -  string  (при  этом подразумевается, что максимальная
длина строки равна 255 символам).
     Поддерживаются также форматы с плавающей запятой  IEEE:
типы  с  одинарной, двойной и повышенной точностью и сложный
тип (comp). (См. описание директив компилятора  $N  и  $E  в
Главе  14 "Справочного руководства" и Приложение С "Справоч-
ного руководства"). Возможно вы  заходите  использовать  эти
типы  для  получения большей точности, чем предусматривается
встроенным вещественным типом. Если в вашей программе версии
3.0 используется тип данных версии 3.0 BCD или функция Form,
то возможно вы захотите использовать типы формата IEEE  (или
длинный  цедлый тип) для моделирования типов BCD (см. пример
программы BCD.PAS, содержащийся на дистрибутивном диске 2).
 
                Порядок вычисления выражений
 
     Даже если в команде меню  "Опции/Компилятор/Вычисление"
(Option/Compiler/Evaluation)  задано значение Complete (пол-
ное), порядок вычислений в версии 5.0 и 3.0 может  отличать-
ся:
 
  {$B+}
  function Func1 : boolean
  begin
    Writeln('Func1');
    Func1 := False
  end;
 
  function Func2 : boolean
  begin
    Writeln('Func2');
    Func2 := False
  end;
 
  begin 
    if Func1 and Func2 then;
  end.
 
     В версии 3.0 выведется следующая информация:
 
     Func1
     Func2
 
а в версии 5.0:
 
     Func2
     Func1
 
                Предописанные идентификаторы
 
     В версии 3.0 все предопределенные константы, типы  дан-
ных, переменные, процедуры и функции всегда были доступными.
В версии 5.0 многие из этих предопределенных объектов теперь
помещаются  в одном из стандартных программных модулей (Dos,
Crt, Printer, Graph, Turbo3, Graph3). Для  того,  чтобы  ис-
пользовать  эти элементы, ваша программа должна включать те-
перь оператор Uses, описывающий программные модули,  которые
должны быть использованы в программе. Например:
 
     uses Crt, Dos;
 
     Далее приводится список программных модулей версии  5.0
с элементами, которые были предописаны в версии 3.0:
 
------------------------------------------------------------
     5.0                                                 3.0
------------------------------------------------------------
 
     DOS                    MsDos,Intr,Exec (Execute вF 3.0)
     Crt           KeyPressed,TextMode,Window,GotoXY,WhereX,
             WhereY,ClrScr,CrlEol,Insline,Delline,TextColor,
              TextBackground,LowVideo,NormVideo,Delay,Sound,
               NoSound, и все константы текстовых режимов и 
               текстовые константы цветов
     Printer                                            Lst
     Turbo3                         Kbd,CBreak,LongFileSize,
                                       LongFilePos,LongSeek
     Graph3  Все основные, улучшенные, программы и программы 
                                                     графики
------------------------------------------------------------

           Примечание: Имеется два  дополнительных  стандар-
      тных  модуля (Overlay и Graph), которые содержат прог-
      раммы, не предусмотренные в версии 3.0.
 
     В версии 3.0 были доступными следующие  преодопределен-
ные   элементы:   CrtExit,  CrtInit,  Aux,  Con,  Trm,  Usr,
ConInPtr, ConOFutPtr,  ConStPtr,  LstOutPtr,  UsrInPtr,  Us-
rOutPtr,  ErrorPtr. В версии 5.0 вместо них вы можете теперь
написать мощные драйверы ввода-вывода.
     В версии 3.0 CBreak была не  описанной  в  документации
булевской  переменной,  позволявшей вам приводить в действие
или   отменять   проверку   программных   прерываний   через
Ctrl-Break.  В  версии  5.0 она документируется и называется
CheckBreak. Переменная CBreak  является  доступной  в  прог-
раммном модуле Turbo3.
     В версии 3.0 процедуре  Execute  передавалась  файловая
переменная.  В  версии  5.0 она называется Exec (находится в
модуле Dos), и вы передаете ей  имя  программы  и  командную
строку (параметры).
     В версии 3.0 предопределенные файловые переменные  Aux,
Con,  Kbd,  Lst, Trm и Usr являлись доступными. В версии 5.0
ни одна из не является предопределенной. Однако Lst является
доступной  благодаря  программому модулю Printer, а Kbd дос-
тупна в программном модуле Turbo3.  С  помощью  программного
модуля Dos вы можете написать свои собственные драйверы уст-
ройств. 
     В версии 3.0 функции MemAvial и  MaxAvial  имели  целый
тип и возвращали число свободных параграфов (16-байтовые об-
ласти). В версии 5.0 эти функции имеют тип longint (4 байта)
и  возвращают  число  свободных  байтов. Учтите, что прежние
версии имеются в программном модуле Turbo3.
     В версии 3.0 функции FileSize, FilePos и FileSeek возв-
ращают  значения  целого  типа.  В версии 5.0 они возвращают
значения длинного целого типа  longint  (4  байта)  и  могут
возвращать  значения  до  2147483647.  В  версии 5.0 функция
FileSize для нетипизованного файла будет игнорировать непол-
ный блок (если размер блока больше 1).
     В версии 3.0 функция MemW возвращала целое значение.  В
версии 5.0 она возвращает значение типа слова.
     В   версии   3.0   функции   LongFile    (LongFileSize,
LongFilePos,  LongSeek)  возвращают значения действительного
типа. В версии 5.0 эти функции являются доступными только  с
использованием  программной  единицы  Turbo3, они возвращают
значение действительного типа.
     В версии 3.0 процедуры MsDos и Intr имеют нетипизованый
параметр (действительный параметр может иметь значение любо-
го типа). Вы должны билы описывать соответствующую структуру
данных  регистрового типа и передавать туда параметр. В вер-
сии 4.0 MsDos и Intr требуют  параметра  регистрового  типа,
который также определяются в программном модуле Dos. 
     В версии 3.0 процедура Intr использует  константу  типа
целое  в качестве своего первого параметра. В версии 5.0 эта
процедура вопринимает любое выражение (константа, переменная
и так далее), но это значение должно иметь тип byte. 
     В версии 3.0 функция IOResult возвращает  коды  ошибок,
присущих  Турбо-Паскалю.  В  версии  5.0 IOResult возвращает
коды стандартных ошибок ДОС. (Модуль Turbo3 содержит функцию
IOResult,  которая преобразует коды ошибок 5.0, где это воз-
можно, в соответствующие значения для версии 3.0).
     В версии 3.0, в случае возникновения нескольких  после-
довательных ошибок ввода-вывода вызывалась функция IOResult.
При этом она должна была возвратить код ошибки, соответству-
ющий  первой  ошибке  ввода-вывода. В версии 5.0 эта функция
возвращает код, соответствующий последней ошибке ввода-выво-
да.
     В версии 3.0 процедура Seek использует параметр  целого
типа  для  номера  записи. В версии 5.0 этот параметр теперь
имеет тип longint (длинный целый тип).
     В версии 3.0 вы могли обращаться к  процедуре  TextMode
без параметров. Это должно было восстановить текстовый режим
таким же, каков был последний действующий режим перед графи-
ческим выводом. В версии 5.0 процедура TextMode должна всег-
да иметь параметр. Однако теперь существует предопределенная
константа текстового режима Last, которая устанавливает тек-
стовый режим таким, каков был  последний  действующий  режим
перед графическим выводом.
 
     TextMode(Last);
 
     Результаты такого обращения к процедуре TextMode в вер-
сии 5.0 будут такими же, как при обращении:
 
     TextMode
 
в версии 3.0.
 
               Другие улучшения и дополнения
 
     В версии 3.0 функция Addr возвращала адрес любой  пере-
менной.  Несмотря  на  то,  что  Addr  есть в версии 4.0, вы
должны и в ней использовать вместо этой функции оператор  @,
так что Ptr:=Addr(Item) приобретает вид: Ptr:=@Item.
     В версии 3.0 разрешалось использовать присваивание  пе-
ременных одинаковых типов, но определенных по отдельности:
 
     var
       A    : ^integer;
       B    : ^integer;
     begin 
       ...
       A := B;
       ...
 
     Версия 5.0 осуществляет проверку точности  соответствия
типов, и указанный выше текст программы приведет к ошибке на
этапе компиляции. С целью достижения совместимости  присваи-
ваемых  переменных необходимо эти переменные описывать вмес-
те, как показано ниже:
 
     var
       A,B  : ^integer;
 
или описывая их, нужно использовать один и тот же  тип  дан-
ных:
 
     type 
       IntPtr = ^integer;
     var
       A  : IntPtr;
       B  : IntPtr;
 
     В версии 3.0 можно было использовать строковую перемен-
ную  длиной 1, как селектор оператора варианта. В версии 5.0
это не допускается, хотя  можно  воспользоваться  отдельными
символами.
     В версии 3.0 знакомый тип был совместим со строкой дли-
ной 1:
 
     var
       Ch  : char;
       S   : string[10];
     begin
       S  := 'a';
       Ch := S;
       ... 
 
     Аналогичным  образом  можно  воспользоваться   функцией
Copy:
 
     S := 'abc';
     Ch := Copy(S,2,1);
 
     В версии 5.0 ни то , ни другое не  допускается.  Однако
можно  присвоить  переменной  Ch  значение S и всегда можете
присваивать S[I] значение CH.
     В версии 3.0 можно без всяких последствий вызвать  про-
цедуру Close для файла, который уже был закрыт. В версии 5.0
это приведет к ошибке ввода-вывода, которую можно обработать
отменяя  проверку ошибок ввода-вывода (с помощью опции {$I} 
и проверяя значение, возвращаемое функции IOResult. 
     В версии 3.0 можно было воспользоваться функцией CSeg и
DSeg  в абсолютных операторах:
 
     var
       Parameters  : string[127] absolute CSeg:$80;
 
     В версии54.0 в абсолютных операторах не допускаются  ни
функция Cseg, ни функция DSeg.
     В версии 3.0 нет ограничений на место описания управля-
ющей  переменной,  используемой  в  циклах с предусловием. В
версии 5.0 управляющая переменная должна быть или глобальной
переменной, или, если цикл с предусловием находится в проце-
дуре или функции, локальной по отношению  к  этой  процедуре
или  функции. Следующий текст программы приводит ошибки ком-
пилятора:
 
     procedure Outer;
     var
       I : integer;
 
       procedure Inner;
       begin
         for I := 1 to 10 do { 1 описывается в процедуре
                               Outer;}
           Writeln(I)
       end;  { of proc Inner  }  { оператор end процедуры
                                    Inner}
 
  begin { main body of Outer } { начало основного тела
                                  процедуры Outer }
 
       Inner
  end; { of proc Outer }        { конец процедуры Outer }
 
     В версии 3.0 нельзя было присвоить значение -32768  це-
лой  переменной.  Вместо  этого  нужно  было воспользоваться
шестнадцатиричной константой $8000. В версии 5.0 можно прис-
воить значение -32768 непосредственно. Шестнадцатиричная пе-
ременная $8000 (которая теперь равна +32768) имеет тип слова
и  не может присваиваться переменной целого типа. (Вы можете
также присваивать значение $FFFF8000 целой переменной).
     В версии 3.0 можно описывать метки в разделе меток,  не
используя  метки  в программе. В версии 5.0, если вы описали
метку, а затем ее не используете, то это приведет  к  ошибке
на этапе компиляции. В таком случае нужно или воспользовать-
ся меткой в тексте программы, или удалить ее из описания ме-
ток. 
     В версии 3.0 вы могли  (не  обязательно)  устанавливать
размеры буфера в текстовом файле при описании его:
 
     var
       F : text[4096]  { размер буфера 4096 байт }
 
     В версии 5.0 текстовый буфер  теперь  описывается,  как
структуру  данных и для него выделяется текстовый файл с по-
мощью процедуры SetTextBuf:
 
     var
       F  : text;
       Buf: array[0..4095] of char;
     begin
       Assign(F,'MyFile.TXT');
       SetTextBuf(F,Buf);
       Reset(F);
       ...
 
     В  версии  3.0  можно  было  воспользоваться   функцией
Read(Kbd,Ch), чтобы осуществить непосредственное с клавиату-
ры. В версии 5.0 функция ReadKey выполняет такое же действие
и позволяет легко распознавать специальные клавиши (функцио-
нальные клавиши, клавиши вспомогательной  клавиатуры  и  так
далее):
 
     Ch := ReadKey;
     if Ch = #0 than begin    { специальная клавиша }
       Ch := ReadKey;         { снова считывание }
       ...                    { обработка специальной
                                 клавиши }
     end
     else ...;                { обработать обычную клавишу }
 
     (Функция Kbd поддерживется в программном модуле Turbo3.
Однако мы настоятельно рекомендуем вам пользоваться функцией
ReadKey).
     В версии 3.0 некоторые варианты  компилятора  содержали
тип данных BCD (двоично-десятичный). В версии 4.0 нет такого
типа данных. Вместо этого предлагаем вам рассмотреть исполь-
зование  длинного  целого типа longint (4-х байтовое целое).
Если у вас есть математический сопроцессор 8087, то вы  име-
ете  возможность  задать  директиву компилятора {$N+} и вос-
пользоваться совместимым типом  данных  (восьмибайтовое  це-
лое).  Пример программы, содержащейся на дистрибутивных дис-
ках, демонстрирует, как можно преобразовать  данные  формата
BCD  (двоично-десятичные)  для использования с типами данных
версии 5.0 (смотрите на дистрибутивном  диске  Турбо-Паскаля
файл README). 
     В версии 3.0, если у вас был следующий вид программы:
 
     var
       I : Integer;
     begin
       I := 30;
       Write('Enter I: '); Readln(I);
       ...
 
и вы нажали Enter на вопрос в вводе I,  программа  продолжит
выполнение  со значением для I равным 30. В версии 5.0 прог-
рамма не будет продолжать работу до тех пор, пока вы не вве-
дете целое значение.
     Информация по изменению в обработке ввода-вывода в вер-
сии 5.0 содержится в разделе "Ввод и вывод" (см. далее).
     В версии 3.0 константы определенных типов располагаются
в  сегменте текста программы (CS). В версии 5.0 они распола-
гаются в сегменте данных.
     В вещественном типе данных теперь перед и  после  деся-
тичной точки требуется указывать цифру.
     В версии 3.0 для копирования данных из одной  структуры
данных  в другую (если они были нсовместимы по присваиванию)
нужно было использовать процедуру Move:
 
     type
       Buffer= array[0..5] of byte;
     var
       BufPtr: ^Buffer;
       X     : real;
     begin
       New(BufPtr);
       ...
       Move(BufPtr^,X,SizeOf(X));
 
     Исключения составляли ограниченные  типы  данных  (сим-
вольные, байтовые, целые, булевские и  перечислимые типы), в
случае чего вы могли воспользоваться  приведением  типа  (то
есть преобразованием типа переменной):
 
     IntVar := byte('a');
     MonthVar := Month(3);
 
     В версии 5.0 приведениее  типа  распространено  на  все
типы переменных с обязательным требованием, чтобы исходный и
получаемый типы имели один и тот же размер:
 
     type
       Buffer = array[0..5] of byte;
     var
       BufPtr : ^Buffer;
       X      : real;
     begin
       New(BufPtr);
       ...
       X := real(BufPtr^);
 
     В версии 3.0 можно было  использовать  только  байтовый
тип (0...255, 1 байт) и целый тип (-32768...32768, 2 байта).
В версии 4.0 введены  типы  данных  shortint  (-128..127,  1
байт), т.е. короткое целое, слово (0..65535, 2 байта) и lon-
gint (-2147483648..2147483647, 4 байта) - длинное целое.
     В версии 3.0 использовался только  один  действительный
тип  с плавающей запятой. В версии 5.0 в случае наличия соп-
роцессора можно задавать директиву {$N+} и использовать  три
дополнительных  типа данных с плавающей запятой: с одинарной
точностью (4 байта), с двойной точностью (8 байт) и повышен-
ной  точностью  (10  байт).  Можно  также использовать целые
8-байтовые. В случае отсутствия процессора 8087 те  же  типы
можно  использовать, задав с помощью директив {$N+,E+} прог-
раммную эмуляцию процессора 8087.
     В версии 3.0 нужно было указывать точную длину для  лю-
бой  описываемой строки-переменной. Вы должны были также оп-
ределить свой собственный тип, если хотели передать строки в
качестве параметров:
 
     type
       BigStr = string[255];
     var
       Name   : string[20];
       S      : BigStr;
     ...
     procedure Whatever(T : BigStr);
     ...
 
     В версии 5.0 можно описывать переменную как строку, ко-
торая  является  эквивалентной  строке с длиной 255 символов
(string[255]).  Можно  ткже  описывть   формльные   прметры,
которые имеют строковый тип:
 
     var
     S : string;
     procedure Whatever(T : string);
 
     В версии 3.0 все элементы в булевском выражении  вычис-
лялись  даже в том случае, если один элемент обращал все вы-
ражение в значение True или False. Из-за этого вы  не  могли
написать выражение 
 
     if (B = 0) of (A/B = X) than ...
 
поскольку второй член должен вычисляться, даже если B  =  0,
что  приведет к ошибке во время выполнения. В версии 5.0 та-
кие выражения могут вычисляться по короткой схеме. Если B  =
0,  то  все выражение будет иметь значение True, и выражение
(A/B = X) не будет вычисляться. При необходимости можно сде-
лать  так,  чтобы в версии 4.0 вычислялись все члены выраже-
ния. Для этого используется директива компилятора {$B+}. 
     В версии 3.0 вы пользовались функцией  ErrorPtr,  чтобы
установить  свой собственный обработчик ошибок. В версии 5.0
функции ErrorPtr не существует. Вместо нее  можно  обрабаты-
вать аварийные и нормальные завершения своей программы с по-
мощью функции ExitProc (см. более подробно в Главе 15 "Спра-
вочного руководства").
     В версии 3.0 вы должны были воспользоваться  программой
на  языке ассемблера, чтобы создать обработчик прерываний. В
версии 5.0 вы можете написать обработчики прерываний на Пас-
кале, описывая процедуры, которые должны иметь тип interrupt
(прерывание).
     В версии 3.0 для осуществления прямого доступа к памяти
вы  должны  были иметь предопределенные идентификаторы Mem и
MemW. В версии 5.0 также имеется идентификатор MemL, который
отображает массив типа longint (целый четырехбайтовый) в па-
мять.
     В версии 3.0 можно было включить машинный код в  проце-
дуры  и  функции (или в основное тело вашей программы) с по-
мощью оператора inline. В версии 5.0 также можно описать це-
ликом  короткие  процедуры  или функции, чтобы они имели тип
inline.  После  этого  машинный  код  непосредственно  будет
вставлен  (весьма похоже на макрорасширение) в процедуру или
функцию везде, где происходит обращение к этой процедуре или
функции.
     В версии 3.0  внешние  программы  на  языке  ассемблера
должны были иметь формат BIN (двоичный формат) и описывались
в программе как смещение по отношению к первой  программе  в
файле.  В версии 5.0 эти программы должны быть в формате OBJ
(аналогичном тому, который создавается Турбо-ассемблером)  и
описываются   просто   как   внешние  (external)  директивой
{$Lфайлы}, ` imqmomh ncocvgpj~}qp~ imknmlrckzc shjz OBJ.
     ? `copgg 3.0 `pc `zfm`z  nomucbro  g  srliugh  ~`j~jgp{
jgelgkg  `zfm`kg (qgn NEAR), при котором предполагается, что
все программы должны быть в одном и том же сегменте. В  вер-
сии 5.0 компилятор автоматически генерирует по необходимости
ближние или дальние вызовы, и у вас есть возможность сделать
все обращения дальними с помощью директивы {$F+}.
 
               Использование языка ассемблера
 
     В версии 5.0 сохранена поддержка встроенного языка  ас-
семблера.  Теперь  она включает в себя директивы типа inline
для определений процедур и функций, в которых вместо отдель-
ный  вызываемых программ содержатся макрокоманды типа inline
(машинный код). См. Главу 15 "Справочного руководства".
 
     1.  Для кототких кусков кода на ассемблере  рассмотрите
         возможность  использовзния  директивы  типа  inline
         (которая  отличается  от  оператора   inline).   Он
         позволяет  генерировть в  получаемом  в  результате 
         объектном коде макрокоманды inline. 
     2.  Там, где это можно сделать и удобно использовать на
         практике,  преобразуйте подпрограммы типа inline во
         внешние подпрограммы. Используйет подпрограммы типа
         inline  только там, где это действительно необходи-
         мо.
     3.  В операторе inline (в подпрограмме) ссылки на счет-
         чик инструкций (*) теперь не допускаются. Не допус-
         каются также ссылки на  идентификаторы  процедур  и
         функций.  Для  ссылки  на  идентификатор процедуры,
         например, нужно описать локальную переменную-указа-
         тель, присвоить ей адрес процедуры (имя процедуры),
         а затем сослаться на указатель в операторе inline.
     4.  Внешние подпрограммы нужно повторно  ассемблировать
         и объединить их в формате .OBJ.
     5.  Типизованные константы находятся теперь в  сегменте
         данных  (DS),  и доступ к ним их каких-либо внешних
         подпрограмм должен выполняться отдельно.
     6.  Внешние процедуры и функции и процедуры  и  функции
         типа inline, использующие параметры-значения байто-
         вого типа, в версии 3.0 часто использовали ту  осо-
         бенность,  что  при  занесении  с стек старший байт
         инициализировался занчением 0. В версии  5.0  такая
         инициализация  не  выполняетея,  поэтому нужно убе-
         диться в том, что указанные процедуры  или  функции
         не предполагают наличия в старшем байте значения 0.
 
     Имеется аткже много изменений, касающихся  преобразова-
ния при передаче прметров и результатов функций  через стек. 
Более подробно об этом можно узанть в Главе  15 "Справочного
руководства".
     Этот перечень не является исчерпывющим. Многие из прог-
рамм будут работать без изменений или с небольшими изменени-
ями. Другие программы будут хорошо работать после применения 
утилиты UPGRADE. Тем не менее  данный перечень не охватывает 
всех  вопросов совместимости, поскольку во многих программах  
версии 3.0 используются средства,  документация по которым в
версии 3.0 отсутствует или которые в этой версии не  поддер-
живаются.  Прочие  вопросы преобразования освещаются в файле
HEADME на дистрибутивном диске Турбо-Паскаля версии 5.0.
 
         Преобразование из версии 3.0 Турбо-Паскаля
 
     Турбо-Паскаль версии 5.0 содержит несколько  превосход-
ных  новых средств. В этой главе обсуждаются средства, кото-
рые помогут вам преобразовать программы версии 3.0  в  прог-
раммы  версии 5.0. Заметим, что в некоторых случаях в исход-
ный код возможно потребуется венсти изменения (см.  предыду-
щий раздел).
     В Турбо-Паскале предусмотрены два механизме перехода от
одной  версии  к  другой:  утилита UPGRADE.EXE и два модуля,
обеспечивающих совместимость - Turbo3 и Graph3. Заметим, что
утилита  UPGRADE  должна  использоваться только для программ
версии 3.0 (или более ранней). Различия в исходном коде вер-
сий 4.0 и 5.0 минимальны, их можно исправить в интерактивной
среде программирвания.
 
     1.  Утилита UPGRADE считывает  файл  с  исходным  кодом
         версии  3.0 и осуществляет ряд изменений для компи-
         ляции его в версии 5.0. Накоторые из этих изменений
         предусматривают комментирование устаревших размеров
         буферов, включение необходимых операторов  uses  и,
         возможно, разбиение больших файлов на несколько от-
         дельных модулей.
     2.  Модуль Turbo3  восстанавливает  некоторые  элементы
         ввода-вывода  и  системные элементы версии 3.0, от-
         сутствующие в версии 5.0.  (Глава  16  "Справочного
         руководства" содержит более подробную информацию).
     3.  Модуль Graph3 поддерживает полный набор графических
         вызовов  (основная,  расширенная графика и графика,
         использующая  относительные  команды)  версии  3.0.
         Если  вы  используете  Graph3,  по вы имеете полный
         доступ к константам, типам, переменные,  процедурам
         и  функциям, описанным в Главе 7 "Справочного руко-
         водства".
 
           Примечание: Заметим,  что  в  стандартном  модуле
      Graph  содержится  новая мощная библиотека независимых
      от устройств графических  программ.  Если  у  вас  нет
      программ,  активно  использующих  графические средства
      версии 3.0, то вам следует использовать модуль Graph.
 
     В данном разделе мы дадим перечень всех пунктов  преоб-
разования  программ, корорые (как может оказаться) нужно вы-
полнить дополнительно к  использованию  утилит.  Если  объем
кода  у  вас большой, не беспокойтесь. Преобразование обычно
выполняется очень быстро, особенно если учесть высокую  ско-
рость работы компилятора версии 5.0.
 
               Использование утилиты UPGRADE
 
     Эта утилита поможет преобразовать программы  Турбо-Пас-
каля,  написанные  для  более ранних версий компилятора. Она
просматривает исходный код и выполняет следующие действия:
 
     1.  В тех местах исходного кода, где синтаксис не  сов-
         падает  с  версией  5.0,  или программа будет вести
         себя иначе, чем в версии 3.0, ставятся комментарии.
     2.  Некоторые конструкции, к синтаксису которых  предъ-
         являются  новые  требования, исправляются автомати-
         чески.
     3.  Имеется возможность записи файла регистрации  (жур-
         нального  файла), в котором содержатся рекомендации
         по изменению программы для версии 5.0  и  подробные
         комментарии).
     4.  Для включения необходимых программ  из  стандартных
         модулей автоматически добавляется оператор uses.
     5.  Для реорганизации программы с использованием  овер-
         леев  и использования преимуществ раздельной компи-
         ляции, большие программы могут разбиваться на  нес-
         колько модулей 
 
     Чтобы использовать UPGRADE, вам потребуются два файла с
дистрибутивного диска Турбо-Паскаля. В рабочий каталог или в
каталог, указанный в команде  ДОС  PATH,  нужно  скопировать
файлы UPGRADE.EXE и UPGRADE.DTA.
     Утилитой UPGRADE можно управлять  с  помощью  командной
строки.  Формат  этой командной строки (в ответ на подсказку
ДОС) следующий:
 
     UPGRADE [параметры] имя_файла
 
     Здесь "имя_файла" задает имя существующего (в  заданном
по умолчанию каталоге на текущем диске) исходного файла вер-
сии 3.0 Турбо-Паскаля. Если расширение имени файла не  зада-
но, то подразумевается, что файл имеет расширение .PAS.
     Если утилита UPGRADE вызывается без параметров в коман-
дной  строке (то есть если параметры и имя файла не заданы),
то она выведет краткое поясняющее сообщение и закончит рабо-
ту.
     Заданный файл должен содержать полную программу  версии
3.0  Турбо-Паскаля,  а  не  просто ее фрагмент. Если в файле
имеются директивы включения файлов (include), то  в  текущем
каталоге   или  в  другом  каталоге,  заданном  в  директиве
include, должны также  присутствовать  указанные  включаемые
файлы.
     Задаваемый файл должнем представлять собой синтаксичес-
ки правильную программу, как это определяется Турбо-Паскалем
версий 2.0 и 3.0. Если вы не уверены в том, что в  программе
отсутствуют  синтаксические ошибки, скомпилируйте ее сначала
в версии 3.0 Турбо-Паскаля, а затем начинайте работу с  ути-
литой  UPGRADE, поскольку данная утилита не выполняет полную
синтаксическую проверку  исходного  кода,  и  синтаксические
ошибки во входном файле могут привести к непредсказуемым ре-
зультатам.
     По умолчанию утилита UPGRADE  будет  записывать  вместо
старой  новую  версию  исходного кода, сохраняя ее под новым
именем. При этом старая версия будет сохраняться в  файле  с
тем  же  именем  и расширением .3ТР. Если такой файл уже су-
ществует, то UPGRADE попытается создать файл  с  расширением
.4ТР, .5ТР и т.д. (пока не окажется, что такой файл отсутст-
вует).
     По умолчанию утилита UPGRADE  вносит  в  файл  исходной
программы комментарии. Это делается примерно так:
 
 TextMode;{! 20. ^ TextMode requires a parameter (Mode:word) 
in Turbo Pascal 5.0}
(в версии 5.0 Турбо-Паскаля для процедуры TextMode необходим 
параметр (Mode:word))
 
     В данном примере TextMode; - это оператор в  программе,
которую  обрабатывает утилита UPGRADE. Комментарии программы
UPGRADE всегда начиняются со знаков '{!', поэтому  их  очень
легко найти. Каждый такой комментарий нумеруется специальным
значением (в данном примере 20), которой соответствует номе-
ру  комментария, содержащегося в специальном файле регистра-
ции (см. далее). Далее  в  комментарии  содержится  коротное
предложение,  поясняющее данный вопрос. Для точного указания
того, что именно вызвало  появление  данного  комментария  в
указанной  строке исходного кода, утилита UPGRADE включает в
комментарий знак каре (^).
     В некоторых случаях утилита UPGRADE вносит  в  исходный
код активные изменения. Например:
 
  var
    f: text{[$1000]};
    {! 6. Use the new standard procedure SetTextBuf to set
 Text buffer size} 
 (для задания размера текстового буфера используйте новую 
стантдартную процедуру SetTextBuf)
 
     В этом комментарии отражается тот факт, что для задания
размеров буферов для текстовых файлов в Турбо-Паскале версии
5.0 используется другой  синтаксис.  Вместо  необязательного
заключенного  в  квадратные скобки размера буфера Турбо-Пас-
каль версии 5.0 предусматривает использвание новой  стандар-
тной  процедуры 
error in text.................... 
генерируемого утилитой UPGRADE предупреждающего сообщения, а
также рекомендации по изменению  вашей  программы.  Приведем
типичный пример части файла регистрации:
 
  4. MYPROG.PAS(6)
     s:byte absolute CSEG:$80
                     ^
 
           В абсолютных операторах теперь не могут использо-
      ваться CSEG и DSEG.
           Переменные в Турбо-Паскале 5.0 могут по отношению
      к другим переменным или типизованным константам прини-
      мать абсолютный вид (например, StrLen: byte  абсолютна
      относительно String1) или занимать фиксированную ячей-
      ку памяти (например, KeyBoardFlag: byte по абсолютному
      адресу $40:$17).
           Учитывая раздельную компиляцию и эффективную ком-
      поновку  версии 5.0, маловероятно, что переменные, аб-
      солютные относительно CSEG и DSEG, привели к желаемому
      эффекту.
 
     Каждый файл регистрации начинается с числового  иденти-
фикатора,  соответствующего  соответствующего  нумерованному
комментарию, включаемому утилитой UPGRADE в реальный  исход-
ный  код. За номером исходного файла следует имя файла с ис-
ходным кодом и номером строки (исходного файла), где  содер-
жится  оператор,  приведший  к появлению сообщения. Заметим,
что этот номер строки исходного файла  может  отличаться  от
номера  соответствующей строки инициализированного исходного
файла, в который включены комментарии. Для обеспечения  пол-
ной  идентификации утилита UPGRADE включает также в журналь-
ный файл строку реального кода и указатель, отмечающий  воз-
никшую проблему.
 
       Отсутствие комментариев в исходном файле - /N

     Этот необязательный параметр можно  использовать,  если
вы  не  хотите, чтобы в исходной файл утилита UPGRADE внесла
комментарии. При этом UPGRADE будет выполнять все  автомати-
ческие изменения: включать оператор uses, корректировать ис-
пользуемые по умолчанию директивы Турбо-Паскаля версии  3.0,
преобразуя директивы компилятора в стандарты версии 5.0 Тур-
бо-Паскаля,  и  деактивизировать   идентификаторы   Overlay,
OvrPath и размеры текстового буфера.
     Обычно необязательный параметр /N используется в  пара-
метрами /J (файл регистрации) и /U (разбиение на модули).
 
        Размещение выходных файлов - /O[d:][маршрут]

     Этот необязательный параметр можно использовать для пе-
ресылки  генерируемой  утилитой  UPGRADE информации в другой
каталог и на другой диск. При использовании данного парметра
утилита UPGRADE не будет изменять существующих исходных фай-
лов или переименовывать их после  завершения  процесса.  Все
генерируемые  выходные данные, включая активизированный файл
регистрации, будут помещаться в заданный каталог на  указан-
ном диске.
 
                  Разбиение на модули - /U

     Данный необязательный  параметр  инициализирует  вторую
основную функцию утилиты UPGRADE. В соответствии с размещен-
ными в исходном файле директивами UPGRADE будет автоматичес-
ки разбивать большие прикладные программы на отдельные моду-
ли.
     Необязательный параметр /U следует использовать  тогда,
когда ваша программа настолько велика, что в версии 3.0 тре-
буется использовать оверлеи, или время ее компиляции вас  не
удовлетворяет.
     Перед тем, как использовать параметр /U, в существующий
исходный код программы следует внести минимальные изменения.
Такие дополнения имеют вид специальных комментариев, которые
служат  для утилиты UPGRADE директивами. Каждая такая дирек-
тива должна иметь следующий вид:
 
     {.U имя_модуля}
 
где "имям_одуля" - это имя, отвечающее следующим  требовани-
ям:
     - оно является допустимым в Паскале идентификатором;
     - представляет собой допустимое в операционной  системе
ДОС имя файла;
     - не совпадает с именем любого присутствующего в  изме-
няемой программе идентификатора.
     Наконец, допустимые директивы имен модулей должны начи-
наться с алфавитного символа и не превышать восьми символов.
Приведем несколько примеров:
 
     {.U UNIT}
     {*.U ScrnUnit *}
     {.U heapstuf}
 
     Каждый раз, когда утилита UPGRADE обнаруживает в исход-
ном  коде  вашей программы директиву имени модуля (директиву
.U), она помещает следующий за  данной  директивой  исходный
код  в  указанный  модуль. UPGRADE выполняет все необходимые
для подготовки исходного кода модуля для компиляции шаги, то
есть:
     - включает в него операторы uses и unit;
     - организует интерфейс со всеми глобальными программами
и описаниями данных;
     - организует реализацию исходного кода (секция реализа-
ции);
     - генерирует пустой блок инициализации.
     Чтобы  разбитая  на  модули  программа  соответствовала
структуре модулей версии 5.0 Турбо-Паскаля, на использование
и размещение директив имени модуля (.U) накладываются  опре-
деленные ограничения:
 
     1.  Директивы имени модуля могут размещаться  только  в
         основном  файле программы и не могут указываться во
         включаемом файле. Это ограничение  позволяет  избе-
         жать  необходимости разбиения на части существующих
         включаемых файлов. В любом случае включаемые  файлы
         содержат  соответствующие программы, которые должны
         находится в том же модуле.
     2.  Каждое имя модуля может задаваться только один раз.
         Это ограничения позволяет избежать порождения взаи-
         мозависимости модулей, поскольку такую  особенность
         версии  5.0  Турбо-Паскаля утилита UPGRADE не может
         реализовать автоматически.
     3.  Директива имени модуля должна помещаться вне облас-
         ти действия процедур и функций, то есть, она должна
         размещаться на глобальном уровне программы. Это ог-
         раничения  приводит к тому, что определения модулей
         версии 5.0 Турбо-Паскаля будут  представлять  собой
         глобальные элементы.
     4.  Одно имя модуля -  Initial  -  является  в  утилите
         UPGRADE  предопределенным.  UPGRADE будет автомати-
         чески помещать  в  этот  модуль  описания,  которые
         предшествуют первой директиве имени модуля в исход-
         ном коде. Утилита UPGRADE определяет модуль Initial
         таким  образом, что впоследствии модули будут иметь
         доступ ко всем глобальным идентификаторам, заданным
         перед  первым именем модуля. Если вы указали дирек-
         тиву имени модуля перед всеми глобальными определе-
         ниями,  модуль  Initial  будет  пустым,  и  утилита
         UPGRADE автоматически его удалит.
     5.  Каждый модуль версии 5.0 Турбо-Паскаля имеет  огра-
         ничения  по размеру кода в 64К. Директивы имени мо-
         дуля (.U) нужно размещать таким образом, чтобы  это
         ограничение удовлетворялось.
     6.  Утилита UPGRADE не  можут  эффективно  обрабатывать
         опережающие  описания  (forward).  Вместо этого она
         при обнаружении такой директивы помещает в исходный
         код предупреждение. Вам нужно будет определить, что
         нужно сделать с опережающими директивами  (forward)
         и  модифицировать исходный код после того, как ути-
         лита UPGRADE закончит работу. Наилучшей  стратегией
         здесь  является минимальное использования опережаю-
         щих описаний в программе.
 
     Необязательный параметр /U автоматически удаляет ключе-
вые  слова overlay, которые модут встречаться в исходном ко-
де.
     После того, как утилита UPGRADE разобьет  программу  на
модули, основной модуль будет иметь простейший вид. Он будет
содержать оператор program и оператор uses, в котором  пере-
числяются необходимые системные модули а также модули, опре-
деляемые вами с помощью директив имени  модуля,  и  основной
блок исходного кода программы. Все другие процедуры, функции
и определения данных будут помещены в другие модули.
     Для  идентификаторов   пользователя   утилита   UPGRADE
организует  интерфейс максимально возможным образом. Это оз-
начает, что все глобальные идентификаторы  и  функции  будут
указываться  в  интерфейсной секции модуля, а все глобальные
типы, переменные, и константы - в операторе interface. После
того,  как  ваша  программа  будет преобразована к модульной
структуре версии 5.0 Турбо-Паскаля, вы,  возможно,  захотите
поместить  некоторые глобальные идентификаторы в секции реа-
лизации соответствущих модулей.
     Хотя необязательный параметр /U утилиты UPGRADE не поз-
воляет  справиться  с  наиболее  тонкими вопросами разбиения
программы на хорошо структурированные модули,  он  выполняет
автоматический, позволяющий сэкономить время процесс генера-
ции синтаксически правильных файлов модулей.
 
               Что распознает утилита UPGRADE

     Приведем полный перечень коротких предупреждений, гене-
рируемых утилитой UPGRADE:
     - Use the new standart procedure SetTextBuf to set text
buffer  size  (для задания размера текстового буфера исполь-
зуйте новую стандартную процедуру SetTestBuf).
     - New stack conventions require that  many  inlines  be
rewritten  (новые  соглашения по использованию стека требуют
исправления многих операторов типа inline).
     -  Assure  that  CSEG  refers   to   intended   segment
(проверьте, ссылается ли CSEG на нужный сегмент).
     - Restructure Chain and Execute programs to  use  units
or  Exec (измените структуру программ Chain и Execute, чтобы
можно было использовать модули или процедуру Exec).
     - Convert .BIN files to .OBJ files or convert  them  to
typed  constants  (also  see BINOBJ.EXE) (преобразуйте файлы
.BIN в файлы .OBJ или преобразуйте из в  типизованные  конс-
танты (см. также BINOBJ.EXE)).
     - Use the new ExitProc  facility  to  replace  ErrorPtr
references  (для замены ссылок на ErrorPtr используйте новое
средство ExitProc).
     - Use new text file device drivers to replace  I/O  Ptr
references  (для  замены сссылок на Ptr ввода-вывода исполь-
зуйте новые драйверы устройств для текстовых файлов).
     - The Turbo Pascal 5.0  overlay  system  does  not  use
Overlay  keyword (подсистема управления оверлеями Турбо-Пас-
каля не использует ключевого слова Overlay).
     - OvrPath, supported in 3.0,  is  replased  by  OvrInit
(поддерживаемая  в  версии 3.0 процедура OvrPath заменена на
OvrInitт - см. Главу 16 "Cправочного руководства").
     - The Form function (and BCD arithmetic)  is  not  sup-
ported in Turbo Pascal 5.0 (функция Form и арифметика в фор-
мате двоично-десятичных чисел в версии 5.0 не  поддерживает-
ся).
     - BufLen (for restricting ReadLn) is not  supported  in
Turbo Pascal 5.0 (Buflen не поддерживается в версии 5.0 Тур-
бо-Паскаля для ограничения процедуры RealLn).
     - interrupt, unit, interface, implementation, uses  are
not  reserved words (interrupt, unit, interface, implementa-
tion, uses не являются зарезервированными словами).
     - System, Dos, and Crt are standard unit names in Turbo
Pascal  5.0  (Sytem,  Dos  и  Crt являются в версии 5.0 Тур-
бо-Паскаля стандартными модулями).
     - Special file names INP:, OUT:, ERR: are not supported
in  Turbo  Pascal  5.0 (имена специальных файлов INP:, OUT:,
ERR: в Турбо-Паскале версии 5.0 не поддерживаются).
     - Assign unsigned values of $8000  or  larger  only  to
word or longint types (беззнаковые значения от $8000 и боль-
ше присваивайте только  переменным  типа  word  (слово)  или
longint (длинное целое)).
     - Use Turbo3 unit in order to MemAvail and MaxAvail  to
return  paragraphs  (для  того,  чтобы  функции  MemAvail  и
MaxAvail возвращали параграфы, используйте модуль Turbo3).
     - use Turbo3 unit to perform LongFile  operations  (для
выполнения операций LongFile используйте модуль Turbo3).
     - CBreak has been renamed to CheckBreak in Turbo Pascal
5.0   (в   Турбо-Паскале   версии   5.0   переменная  СBreak
переименована в CheckBreak).
     - IOResult now returns different  values  corresponding
to  DOS error codes (функция IOResult теперь возвращает дру-
гие значения, соотвертствующие кодам ошибок ДОС).
     - Use Tirbo3 unit for access to Kbd,  or,  better  yet,
use   Crt   and   ReadKey  (для  доступа  к  переменной  Kbd
используйте модуль Turbo3, или, лучше используйте модуль Crt
и функцию ReadKey).
     - The $I Include file directive must now be followed by
a  space (за директивой $I Include файл теперь должен следо-
вать пробел).
     - Directives A, B, C, D, F, G, P, U, W and X are  obso-
lete or changed in meaning (диретивы A, B, C, D, F, G, P, U,
W и Х устарели или имеют другое значение).
     - The stack-checking directive K has been chanded to  S
in Turbo Pascal 5.0 (директива проверки срека К в Турбо-Пас-
кале версии 5.0 изменена на S).
     - The effect of HighVideo, LowVideo, and NormVideo  are
different  in Turb Pascal 5.0 (процедуры HighVideo, LowVideo
и NormVideo в  Турбо-Паскале  версии  5.0  теперь  действуют
по-другому).
     - Special file name LST: is no  longer  supported;  use
Printer Lst file (имя специального файла LST: теперь не под-
держивается, используйте модуль Printer и имя Lst).
     - Special file name KBD: is no  supported;  use  Turbo3
Kbd file (имя специального файла KBD: не поддерживается, ис-
пользуйте модуль Turbo3 и Kbd).
     - Special file names CON:, TRM:,  AUX:,  USR:  are  not
supported  in  Turbo  Pascal  5.0  (имена специальных файлов
CON:, TRM:, AUX:, USR: в версии 5.0 не поддерживаются).
     - Special devices Con, Trm, Aux, and Usr are  not  sup-
ported in Turbo Pascal 5.0 (специальные устройство Con, Trm,
Aux и Usr в версии 5.0 не поддерживаются).
     - An identifier duplicating a program/unit name is  not
allowed  in  Turbo Pascal 5.0 (дублирование идентификатора -
имени программы или модуля в версии 5.0 Турбо-Паскаля не до-
пускается).
     - Intr and MsDos use Registers type from  Turbo  Pascal
5.0  Dos  unit (функции Intr и MsDos в версии 5.0 используют
регистровый тип из модуля Dos).
     - forwards will require manual modification after  ini-
tializing  (  диретивы forward потребуют после инициализации
исправления вручную).
     - Include directives cannot be located within  an  exe-
cutable  block (директивы Include не могут содержаться в вы-
полняемом блоке).
     - The CrtInit and CrtExit procedures are not  supported
in  Turbo  Pascal  5.0 (процедуры CrtInit и CrtExit в версии
5.0 Турбо-Паскаля не поддеживаются.
     - for loop counter variable must be local og global  in
Turbo  Pascal  5.0  (переменная-счетчик  оператора цикла for
должна быть в версии 5.0 локальной или глобальной).
     - All defined labels within the current routine must be
used  (все определенные в текущей программе метки должны ис-
пользоваться).
     - A parameter to Intr must be of the type Registers de-
fined  in  Dos  unit (параметр функции Intr должен иметь ре-
гистровый тип, определенный в модуле Dos).
     - The * operator is nоt supported by Turbo  Pascal  5.0
inline  statements (оператор * не поддерживается в операторе
inline версии 5.0 Турбо-Паскаля).
     - Procedure and function names cannot be used in  Turbo
Pascal  5.0  inline  statements  (имена процедур и функция в
операторах inline версии 5.0 не поддерживаются).
     - The state of directive I, R, K,  of  V  differs  from
that at entry to include (на входе во включаемый файл дирек-
тива I, R, K или V имеет другое значение).
     - The System unit now uses  this  name  as  a  standard
identifier  (в  модуле  System это имя теперь используется в
качестве стандартного идентификатора).
 
          Что не может обнаружить утилита UPGRADE

     Приведем описание различных моментов, с которыми утили-
та  при обнаружении их в исходном коде UPGRADE справиться не
может.
 
     1.  Смешивание строкового и символьного типа недопусти-
         мым в версии 5.0 Турбо-Паскаля. Например:
 
              Ch := Copy(S,1,1);
 
     2.  Несоответствие типов, обнаруживаемое более  строгой
         проверкой версии 5.0 Турбо-Паскаля. Например:
          
           var
             a : ^integer;
             b : ^integer;
           begin
             a := b;             {недопустимое присваивание}
           end.
          
     3.  Непредвиденное поведение во время выполнения  прог-
         раммы, вызванное побочными эффектами вичисления бу-
         левских выражений по короткой схеме, например:
          
           {$B-}
           if HandOnError and (IOResult <> 0) then
              Halt;
          
              Турбо-Паскаль версии 3.0  вызывает  встроенную
         функцию  IOResult, сбрасывая при вычислении булевс-
         кого выражения ее значение в 0. При  активизации  в
         версии  5.0  Турбо-Паскаля  вычисления  по короткой
         схеме функция IOResult не  будет  вызываться,  если
         HaltOnError  имеет значение False и, таким образом,
         эта функция может иметь значение кода ошибки преды-
         дущей  операции  ввода-вывода. Заметим, что утилита
         UPGRADE автоматически включает  в  текст  директивы
         компилятора,  деактивизирующие вычисление булевских
         выражений по короткой схеме, что позволяет избежать
         описанной  выше проблемы. Однако изменять директиву
         вычисления булевских выражений нужно осторожно.
 
             Перечень проверок утилиты UPGRADE

     Подведем итоги  основных  шагов  использования  утилиты
UPGRADE:
 
     1.  Скопировать с дистибутивного диска компилятора Тур-
         бо-Паскаля  в текущий каталог или в каталог, задан-
         ный в команде ДОС PATH, UPGRADE.EXE и UPGRADE.DTA.
     2.  Если это необходимо, перейти в каталог,  где  нахо-
         дятся  файлы  и программы версии 3.0 Турбо-Паскаля,
         которые вы ходите модифицировать для работы в  вер-
         сии 5.0.
     3.  Решите,  какие  необязательные  параметры   утилиты
         UPGRADE вы хотите использовать.
     4.  Если вы решили разбить программу на модули, то нуж-
         но сначала отредактировать основной исходный файл и
         включить в него директивы {.U имямодуля},  соблюдая
         указанные выше ограничения.
     5.  С помощью командной строки ДОС введите соответству-
         ющую  команду  UPGRADE, используя следующий синтак-
         сис:
 
              UPGRADE [параметры] имя_айла
 
              В качестве примеров  допустимых  команд  можно
         привести следующие:
 
              upgrade MYPROG.PAS /J /3
              UPGRADE bigprog /n /u /o c:\turbo5
 
     6.  Утилита UPGRADE выполняет при работе  два  прохода.
         На  первом  проходе распознаются области программы,
         которые могут потребовать модификации, а на  втором
         в  текст включаются соответствующие операторы uses,
         и, возможно, выполняется процесс разбиения на моду-
         ли. В конце второго прохода утилита UPGRADE сообщит
         о числе сгенерированных предупреждений.
     7.  Когда утилита UPGRADE закончит работу, перейдите  в
         каталог,  куда были направлены выходные файлы (если
         он отличается от текущего). Если вы задавали необя-
         зательный  парамтер  /J,  то возможно вам захочется
         просмотреть файл регистрации, чтобы сначала увидеть
         подробные   пояснения   к  предупреждениям  утилиты
         UPGRADE. После  этого,  используйте  для  просмотра
         каждого  созданного  файла  редактор  Турбо-Паскаля
         (или другой редактор).  Найдите  строки  "{!".  При
         каждом поиске вы увидите внесенное утилитой UPGRADE
         предупреждение. Во многих случаях при этом вы  смо-
         жете  сразу изменить исходный код. После этого ком-
         ментарии утилиты UPGRADE можно удалить.
     8.  После того, как вы просмотрели все внесенные утили-
         той  UPGRADE предупреждения и внесли в исходный код
         соответствующие изменения, можно выполнять компиля-
         цию программы в версии 5.0.


                        ПРИЛОЖЕНИЕ В
 
                  Использование редактора
 
     Встроенный редактор Турбо-Паскаля специально предназна-
чен для создания исходных текстов программ в интегрированной
среде программирования. Однако, если вы используете  вариант
компилятора,  работающего  в  режиме командной строки, то вы
будете работать с другим редактором и поэтому можете пропус-
тить эту главу. 
     Редактор Турбо-Паскаля позволяет вводить до 64К текста,
(при  этом размер строки равен 248 символам), при этом можно
использовать любые символы из набора  символов  кода  ASCII,
расширенного набора символов и набора управляющих символов.
     Если вы знакомы с системой редактирования WordStar, ре-
дактором  Турбо-Паскаля  версии 3.0 или редактором SideKick,
то вы уже знаете, как использовать редактор Турбо-Паскаля. В
конце  этой главы приводится краткое описание различий между
командами редактора Турбо-Паскаля и командами хорошо извест-
ного редактора WordStar.
 
      Быстрый вход в редактор и быстрый выход из него
 
     Для запуска редактора в интегрированной среде  програм-
мирования необходимо выбрать элемент "Редактирование" (Edit)
в основном меню Турбо-Паскаля. Для этого следует нажать кла-
вишу  Е  из любого места основного меню или с помощью клавиш
управления движением курсора перейти на команду Edit  и  на-
жать  Enter. Окно редактирования при этом переходит в актив-
ное состояние. Это означает, что заголовок окна редактирова-
ния (Edit) выделяется подсветкой, в верхней части появляется
двойная линия, а курсор помещается в верхний левый угол.
     Текст вводится таким образом, как если бы  вы  печатали
на  пишущей машинке. Для завершения строки необходимо нажать
клавишу Enter.
     Для вызова основного меню из редактора  необходимо  на-
жать  F10, Ctrl-K D или Ctrl-K O. При этом данные в окне ре-
дактирования останутся на экране, но активное состояние  бу-
дет  передано  рамке  меню. Для возвращения в редактор нужно
вновь нажать клавишу Е.
 
            Строка состояния окна редактирования
 
     Строка состоянияв верхней части окна редактирования со-
держит  информацию о том, какой файл редактируется, где рас-
положен курсор в файле и какие режимы редактирования активи-
зированы:
 
 Line n  Col n  Insert  Indent  Tab  C:FILENAME.EXT
 
Line (строка)     Курсор находится в строке файла с номером n
Ool (столбец)     Курсор находится в столбце файла с номером n
Insert (вставка)  Показывает, что редактор находится в режиме 
                  вставки; символы, вводимые с клавиатуры, 
                  вставляются в той позиции, где находится кур-
                  сор, и текст справа от курсора сдвигается 
                  дальше вправо.
                  Используйте клавишу Ins или Ctrl-V для пере-
                  ключения режимов вставки и замены.
                  В режиме замены текст, вводимый с клавиатуры,
                  затирает символы, на которых находится курсор,
                  а не вставляется перед имеющимся текстом.
Indent (отступ)   Указывает, что включен режим автоматического
                  отступа. Этот режим включается и выключается
                  с помощью команды Ctrl-O I.
Tab (табуляция)   Указывает, можно или нет вставлять символы та-
                  буляции; этот режим включается и выключается
                  с помощью команды Ctrl-O T.
C:FIILENAME.EXT   Указывает для редактируемого файла дисковод
                  (C:), имя (FILENAME) и расширение (.EXT). Ес-
                  ли именем файла и расширением является 
                  NONAME.PAS, то это означает, что вы еще не 
                  указали имени файла (NONAME.PAS является име-
                  нем файла, принятым в Турбо-Паскале по умол-
                  чанию).
 
                     Команды редактора
 
     В редакторе используется приблизительно 50  команд  для
перемещения курсора, просматривания текста по страницам, по-
иска и замены строк и так далее. Эти команды разбиты на  че-
тыре основныегруппы:
 
     - команды перемещения курсора (основные  и  расширенный
набор);
     - команды вставки и удаления;
     - команды работы с блоками;
     - остальные команды.
 
     В Таблице В.1 приведен список всех команд. Каждая стро-
ка  таблицы  состоит из определения команды и последователь-
ности нажатий клавиш для вызова этой команды. В  последующей
части главы дается подробное описание каждой команды.
 
                                           Таблица В.1
                Список команд редактора
---------------------------------------------------------------
Основные команды перемещения     
 
Влево на один символ              Ctrl-S или Стрелка влево
Вправо на один символ             Ctrl-D или Стрелка вправо
Влево на слово                    Ctrl-A или Ctrl-Стрелка влево
Вправо на слово                   Ctrl-F или Ctrl-Стрелка вправо
Вверх на одну строку              Ctrl-E или Стрелка вверх
Вниз на одну строку               Ctrl-X или Стрелка вниз
Экран на одну строку вверх        Ctrl-W
Экран на одну строку вниз         Ctrl-Z
Вверх на одну страницу            Ctrl-R или PgUp
Вниз на одну страницу             Ctrl-C или PgDn
 
---------------------------------------------------------------
Расширенный набор команд перемещения

Начало строки                     Ctrl-Q S или Home
Конец строки                      Ctrl-Q D или End
Верх окна                         Ctrl-Q E или Ctrl-Home
Низ окна                          Ctrl-Q X или Ctrl-End
Начало файла                      Ctrl-Q R или Ctrl-PgUp
Конец файла                       Ctrl-Q C или Ctrl-PgDn
Начало блока                      Ctrl-Q B
Конец блока                       Ctrl-Q K
Последняя позиция курсора         Ctrl-Q P
Позиция последней ошибки          Ctrl-Q W
 
Команды вставки и удаления
 
Вкл/выкл режим вставки            Ctrl-V или Ins
Вставить строку                   Ctrl-N
Удалить строку                    Ctrl-Y
Удалить до конца строки           Ctrl-Q Y
Удалить символ слева от курсора   Ctrl-H или Backspace
Удалить символ справа от курсора  Ctrl-G или Del
Удалить слово справа от курсора   Ctrl-T
 
Команды работы с блоками          
 
Пометить начало блока             Ctrl-K B или F7
Пометить конец блока              Ctrl-K K или F8
Пометить одиночное слово          Ctrl-K T 
Напечатать блок                   Ctrl-K P
Скопировать блок                  Ctrl-K C
Удалить блок                      Ctrl-K Y
Сделать невидимым/видимым блок    Ctrl-K H
Переместить блок                  Ctrl-K V
Считать блок с диска              Ctrl-K R
Записать блок на диск             Ctrl-K W
---------------------------------------------------------------

Остальные команды                 

Прервать выполнение команды       Ctrl-U
Вкл/выкл режим автоматического    
отступа                           Ctrl-O I или Ctrl-Q I
Префикс управляющего символа      Ctrl-P
Парные фигурные скобки вперед     Ctrl-Q //
Парные фигурные скобки назад      Ctrl-Q
Найти                             Ctrl-Q F
Найти и заменить                  Ctrl-Q A
Найти указатель места             Ctrl-Q n
Вызвать основное меню             F10
Загрузить файл                    F3
Выйти из редактора, не сохраняя   Ctrl-K D или Ctrl-K Q
Повторить последний поиск         Ctrl-L
Восстановить строку               Ctrl-Q L
Сохранить и отредактировать       Ctrl-K S или F2
Установить указатель места        Ctrl-K n
Табуляция                         Ctrl-I или Tab
Режим табуляции                   Ctrl-O T или Ctrl-Q T
---------------------------------------------------------------
 
                Основные команды перемещения
 
     Для перемещения курсора вверх, вниз, вправо и влево ре-
дактор использует управляющие символы (кроме того, вы можете
использовать клавиши со стрелками). Для перемещения  курсора
в той части файла, которая изображена на экране, используйте
последовательности нажатий клавиш, указанные в Таблице В.2.
 
                                                Таблица В.2
            Последовательности нажатий клавиш для 
                     управления курсором
--------------------------------------------------------------
При нажатии                    Курсор произведет действие:
Ctrl-A или Ctrl-Стрелка влево  Переместится на первую букву в
                               слове слева от курсора
Ctrl-S                         Переместится в первую позицию
                               слева от курсора
Ctrl-D                         Переместится в первую позицию
                               справа от курсора
Ctrl-F или Ctrl-Стрелка вправо Переместится на первую букву в
                               слове справа от курсора
Ctrl-E или Ctrl-Стрелка вверх  Переместится вверх на одну стро-
                               ку
Ctrl-R                         Переместится вверх на один пол-
                               ный экран
Ctrl-X или Ctrl-Стрелка вниз   Переместится вниз на одну строку
Ctrl-C                         Переместится вниз на один полный
                               экран
Ctrl-W                         Экран сдвинется вниз на одну
                               строку; курсор останется в преж-
                               ней строке
Ctrl-Z                         Экран сдвинется вверх на одну
                               строку; курсор останется в преж-
                               ней строке
---------------------------------------------------------------
 
            Расширенный набор команд перемещения
 
     Кроме того, редактор предлагает шесть команд для  быст-
рого перемещения курсора в начало и конец строки, в начало и
конец файла и в последнюю позицию курсора (см. Таблицу В.3).
    
                                                Таблица В.3
                 Команды быстрого перемещения
--------------------------------------------------------------
При нажатии              Курсор сделает следующее:
Ctrl-Q S или Home        Переместится в первый столбец текущей
                         строки
Ctrl-Q D или End         Переместится в конец текущей строки
Ctrl-Q E или Ctrl-Ноme   Переместится в верх экрана
Ctrl-Q X или Ctrl-End    Переместится в низ экрана
Ctrl-Q R                 Переместится на первый символ в файле
Ctrl-Q C                 Переместится на последний символ в 
                         файле
--------------------------------------------------------------
 
     Префикс Ctrl-Q, используемый вместе с  символами  В,  К
или  Р,  позволяет  быстро перемещаться в определенные точки
документа.
 
     Начало блока                           Ctrl-Q B
 
     Перемещает курсор на маркер начала блока, установленный
с  помощью Ctrl-Q B. Эта команда выполняется, даже если блок
не отображен на экране (см. "Сделать невидимым/видимым блок"
в  разделе "Команды работы с блоками") или если маркер конца
блока не установлен.
 
     Конец блока                            Ctrl-Q K
 
     Перемещает курсор на маркер конца блока,  установленный
с  помощью Ctrl-K K. Эта команда выполняется, даже если блок
не  отображен  на  экране  (см.  "Сделать  невидимым/видимым
блок") или если маркер начала блока не установлен.
 
     Последняя позиция курсора               Ctrl-Q P
 
     Перемещает курсор в последнюю позицию, которую он зани-
мал перед выполнением последней команды. Эту команду особен-
но полезно использовать после выполнения  поиска  или  поис-
ка/замены,  если  вам нужно возвратиться в последнюю позицию
курсора перед их выполнением.
 
     Позиция последней ошибки                Ctrl-Q W
 
     После того, как компилятор укажет в строке статуса  ре-
дактора обнаруженную ошибку, вы можете позднее возвратится в
эту позицию и вновь распечатать ошибку, нажав клавиши Ctrl-Q
W.
                  Команды вставки и удаления
 
     Для введения программы в редакторе нужно знать не толь-
ко,  как  перемещать  курсор.  Кроме  того,  вы должны уметь
вставлять  и  удалять  текст.  Следующие  команды  позволяют
вставлять и удалять символы, слова и строки.
 
     Вкл/Выкл режим вставки                  Ctrl-V или Ins
 
     При вводе текста вы можете выбрать один из двух  основ-
ных режимов ввода: режим вставки или режим замены. Вы можете
переключать  эти  режимы  с  помощью  переключателя  Insert,
Ctrl-V или Ins. Текущий режим указывается в строке статуса в
верхней части экрана.
     Режим вставки является режимом, принятым в Турбо-Паска-
ле  по умолчанию. Он позволяет вставлять новые символы в су-
ществующий текст. При этом текст справа от курсора сдвигает-
ся еще более вправо по мере введения нового текста.
     Режим замены используется для замены существующего тек-
ста  новым. Вводимые символы заменяют те, которые находились
под курсором.
 
     Удалить символ слева от курсора    Ctrl-H или Backspace
 
     Происходит перемещение на одну позицию влево и удаление
символа, расположенного в ней. Все символы справа от курсора
передвигаются на одну позицию влево. Эту команду  можно  ис-
пользовать для удаления разрывов строк.
 
     Удалить символ под курсором          Ctrl-G или Del
 
     Происходит удаление символа под курсором, и все символы
справа  от курсора сдвигаются на одну позицию влево. Эту ко-
манду можно использовать для удаления разрывов строк.
 
     Удалить слово справа от курсора            Ctrl-T
 
     Эта команда удаляет слово справа от курсора. Слово  оп-
ределяется  как  последовательность символов, ограниченная с
двух сторон одним из следющих символов:
 
     пробел <> , ; . () [] ^ ' * + - / $
 
     Эта команда выполняется через разрывы строк  и  поэтому
может использоваться для их удаления.
 
     Вставить строку                            Ctrl-N
 
     Эта команда разрывает строку в позиции курсора.
 
     Удалить строку                             Ctrl-Y
 
     Эта команда удаляет строку, содержащую курсор, и перед-
вигает  все  строки, расположенные ниже удаляемой строки, на
одну строку вверх. У вас нет возможности  восстановить  уда-
ленную строку, поэтому используйте эту команду осторожно.
 
     Удалить до конца строки                     Ctrl-Q Y
 
     Эта команда удаляет весь текст от позиции курсора и  до
конца строки.
 
                  Команды работы с блоками
 
     Команды работы с блоками также  требуют  последователь-
ности,  содержащей управляющий символ. Блок текста представ-
ляет собой любое количество текста, от одиночного символа до
нескольких сотен строк, с двух сторон ограниченное специаль-
ными символами маркеров блоков. В документе может быть толь-
ко один блок.
     Вы можете выделить нужную часть текста в качестве блока
с  помощью маркера начала блока, расположив его перед первым
символом, и с помощью маркера конца  блока,  расположив  его
после последнего символа. Пометив блок, вы можете копировать
его, перемещать, удалять или записывать в файл.
 
     Пометить начало блока                   Ctrl-K B или F7
 
     Эта команда помечает начало блока. Сам маркер  является
невидимым,  а блок становится видимым только после того, как
установлен маркер конца блока. Помеченный текст (блок)  рас-
печатывается на экране с другой интенсивностью цвета.
 
     Пометить конец блока                    Ctrl-K K или F8
 
     Эта команда помечает конец блока. Сам  маркер  является
невидимым,  а блок становится видимым только после того, как
установлен маркер начала блока.
 
     Пометить одиночное слово                 Ctrl-K T
 
     Эта команда помечает одиночное слово как блок  без  ис-
пользования  последовательности  начало  блока/конец  блока.
Если курсор расположен внутри слова, то будет  помечено  это
слово.  Если  курсор  находится вне слова, то будет помечено
слово слева от курсора.
 
     Напечатать блок                           Ctrl-K P
 
     Эта команда печатает выделенный блок.
 
     Скопировать блок                          Ctrl-K C
 
     Эта команда копирует ранее отмеченный  блок  в  текущую
позицию курсора. Первоначальный блок не изменяется, а марке-
ры теперь выделяют новую копию блока. Если  нет  помеченного
блока или если курсор находится внутри помеченного блока, то
ничего не происходит.
 
     Удалить блок                              Ctrl-K Y
 
     Эта команда удаляет ранее помеченный блок.  У  вас  нет
возможности восстановить удаленный блок, поэтому используйте
эту команду осторожно.
 
     Сделать невидимым/видимым блок             Ctrl-K H
 
     Эта команда включает и выключает режим визуального  вы-
деления  блока.  Команды манипуляции с блоками (копирование,
перемещение, удаление и запись в файл)  выполняются  только,
если блок является видимым. Перемещение курсора в блоке (пе-
реход на начало/конец блока) выполняются независимо от того,
является блок невидимым или видимым.
 
     Переместить блок                           Ctrl-K V
 
     Эта команда перемещает ранее  помеченный  блок  из  его
первоначального  положения в позицию курсора. В первоначаль-
ном положении блок исчезает, а маркеры помечают блок  в  его
новой позиции. Если нет помеченного блока, то ничего не про-
исходит.
 
     Считать блок с диска                       Ctrl-K R
 
     Эта команда считывает ранее помеченный файл на диске  в
текущий  текст  в позицию курсора, как если бы этот файл был
блоком. Считанный текст помечается как блок с помощью другой
интенсивности цвета.
     Когда вы даете эту команду, редактор Турбо-Паскаля зап-
рашивает  у вас имя файла, который нужно считать. Для указа-
ния файла можно использовать глобальные символы операционной
системы  ДОС (* и ?). Тогда в маленьком окне на экране появ-
ляется каталог. Для указания файла можно использовать  любое
допустимое  имя  файла.  Если вы не укажите тип файла (.PAS,
.TXT), то редактор присоединит к имени расширение  поставьте
точку.
 
     Записать блок на диск                       Ctrl-K W
 
     Эта команда записывает ранее помеченный блок в файл.  В
текущем  файле блок остается неизмененным, остаются на месте
и маркеры. Если блок не помечен, то ничего не происходит.
     Когда Вы даете эту команду, редактор Турбо-Паскаля зап-
рашивает  имя файла, в который нужно записать блок. Для ука-
зания файла для записи можно использовать глобальные символы
ДОС. При этом в маленьком окне на экране появляется каталог.
Если указанный файл уже существует, то редактор выдает  пре-
дупреждение  с  просьбой  проверить, следует ли затирать су-
ществующий файл. Вы можете указать любое допустимое имя фай-
ла (по умолчанию используется расширение .PAS). Для указания
файла без расширения, после имени файла поставьте точку.
 
              Остальные команды редактирования
 
     В этом разделе описываются команды, которые не попадают
ни в один из рассмотренных типов.
 
     Прервать выполнение команды                      Ctrl-U
 
     Эта команда позволяет прервать выполнение любой  коман-
ды,  когда  та делает паузу для ввода, как например, команда
поиска/замены,  запрашивающая   "Replace   Y/N╝"   (Заменить
Да/Нет╝"),  или  когда  вводится строка поиска или имя файла
(чтение и запись блока).
 
     Вкл/Выкл режим автоматического    Ctrl-O I или Ctrl-Q I
     отступа
 
     Эта команда обеспечивает автоматический отступ для пос-
ледующих строк. При режиме автоматического отступа курсор не
помещается в первый столбец при нажатии клавиши Enter. Вмес-
то  этого  он возвращается на столбец, с которого начиналась
только что введенная вами строка.
     Если вам нужно изменить отступ, то  для  выбора  нового
столбца  используйте клавишу пробела или клавишу со стрелкой
"Влево". В режиме автоматичнского отступа в  строке  статуса
появляется  сообщение  "Indent"  ("Отступ"),  при выключении
этого режима это сообщение исчезает. По умолчанию установлен
режим  автоматического  отступа. (В режиме табуляции для от-
ступа можно использовать табуляцию, однако при этом  исполь-
зуются клавиши табуляции).
 
     Префикс управляющего символа                 Ctrl-P
 
     Эта команда позволяет  вводить  управляющие  символы  в
файл,   предпосылая  нужному  управляющему  символу  префикс
Ctrl-P, после чего следует нажать клавишу нужного  управляю-
щего  символа.  На  экране  управляющие символы выглядят как
прописные буквы с меньшей интенсивностью цвета  (или  наобо-
рот, с большей - в зависимости от установки экрана).
 
     Перейти на позицию ошибки                     Ctrl-Q W
 
     Эта команда распечатывает в окне редактирования послед-
нюю  полученную ошибку и помещает курсор в редакторе в пози-
цию этой ошибки.
 
     Найти                                         Ctrl-Q F
 
     Эта команда осуществляет поиск строки длиной до 30 сим-
волов. При вводе этой команды редактор очищает строку стату-
са и в ней появляется подсказка для строки  поиска.  Введите
строку, которую вам нужно найти, и нажмите клавишу Enter.
     Строка поиска может содержать  любые  символы,  включая
управляющие.  Управляющие символы вводятся в строку поиска с
помощью префикса Ctrl-P. Например, для ввода Ctrl-T  утопите
клавишу  Ctrl и держите ее, пока не нажмете клавишу P, а за-
тем T. Вы можете вставлять а строку  поиска  разрыв  строки,
указав  Ctrl-M  J (возврат каретки/перевод строки). Отметим,
что Ctrl-A имеет специальное значение: он совпадает со всеми
символами и может использоваться в качестве глобального сим-
вола в строках поиска.
     Вы можете редактировать строки поиска с помощью  команд
"Символ  слева",  "Символ  справа",  "Слово  слева" и "Слово
справа". Команда Слово справа вызывает предыдущую строку по-
иска,  которую можно отредактировать. Для прерывания (завер-
шения) выполнения команды поиска используйте команду  преры-
вания (клавиши Ctrl-U).
     При указании строки поиска, редактор Турбо-Паскаля зап-
рашивает,  какое средство поиска следует использовать. В ва-
шем распоряжении находятся следующие средства:
 
  В   Осуществляет поиск в обратном направлении - от текущей
      позиции курсора до начала текста.
  G   Осуществляет глобальный поиск по всему тексту независимо 
      от текущей позиции курсора и прекращает поиск только на
      последнем вхождении строки.
  L   Осуществляет локальный поиск по выделенному блоку до 
      следующего вхождения строки.
  n   (где n есть число) Осуществляет поиск n-го вхождения
      строки поиска, считая от текущей позиции курсора.
  U   Игнорирует различия прописных и строчных букв.
  W   Осуществляет поиск только целых слов, опуская совпадения
      строки поиска с частями других слов.
  L   Осуществляет локальный поиск по выделенному блоку до 
      следующего вхождения строки.
 
Примеры:

  W   Осуществляет поиск только целых слов. В этом случае стро-
      ка поиска term совпадает, например, со словом term и не 
      совпадает со словом terminal.
  BU  Осуществляет поиск в обратном направлении и игнорирует
 
      различия между прописными и строчными буквами. Вlock 
      совпадает с blockhead и BLOCKADE и так далее.
  125 Осуществляет поиск 125-го вхождения строки поиска.
 
     Для завершения списка средств поиска (если они указыва-
ются) нужно нажать Enter; этим будет начат поиск. Если текст
содержит элемент, совпадающий со строкой поиска, то редактор
поместит курсор на этом элементе. Операцию поиска можно пов-
торить с помощью команды повторения последнего поиска  (кла-
виши Ctrl-L).
 
     Найти и заменить                            Ctrl-Q A
 
     Эта команды выполняется аналогично команде Найти за тем
исключением,  что  она позволяет заменить "найденную строку"
любой другой строкой, имеющей длину до 30 символов. Отметим,
что  Ctrl-A имеет специальное значение: он совпадает с любым
другим символом и поэтому может  использоваться  в  качестве
глобального символа в строках поиска.
     После того, как вы указали строку поиска, редактор зап-
росит  ввести  строку  замены. Введите не более 30 символов.
Ввод управляющих символов и  редактироание  выполняются  так
же,  как  в команде поиска. Если Вы просто нажмете Enter, то
редактор вместо найденного элемента  ничего  не  укажет,  то
есть тем самым удалит его. 
     Вы имеете в своем распоряжении такие же средства, как в
команде поиска, а также несколько дополнительных:
 
  N    Осуществляет замену, не запрашивая подтверждения совпа-
       дения для каждого вхождения строки поиска.
  n    Осуществляет замену n следующих вхождений строки поиска.
       Если при этом также используется средство G, то поиск
       начинается от начала файла и n игнорируется. В против-
       ном случае поиск начинается с текущей позиции курсора.
  L    Осуществляет локальную замену строк только внутри выде-
       ленного блока.
 
Примеры:
 
  N10  Находит десять последующих вхождений строки поиска и 
       заменяет их, не запрашивая подтверждения.
  GW   Осуществляет поиск и замену целых слов во всем тексте, 
       Игнорируя различия между прописными и строчными бук-
       вами. 
       Выдается подсказка для строки замены.
  GNU  Осуществляет поиск (по всему файлу) строк, содержащих
 
       прописные и строчные буквы, и заменяет их, не запра-
       шивая подтверждения.
 
     Список средств (если таковой имеется)  можно  закончить
нажатием клавиши Enter. При этом начнется выполнение команды
"Найти/заменить". При нахождении элемента (если  не  указана
опция  N)  редактор поместит курсор на конец элемента и даст
запрос "Replace  (Y/N)╝"  ("Заменить  (Да/Нет)?")  в  строке
подсказки  в  верхней части экрана. Вы можете здесь прервать
выполнение команды "Найти/заменить" с помощью команды преры-
вания  (Ctrl-U).  Можно  также  повторить выполнение команды
"Найти/заменить" с помощью команды повторения последнего по-
иска (клавиши Ctrl-L).
 
     Найти указатель места                          Ctrl-Q n
 
     Эта команда осуществляет поиск четырех (или менее) ука-
зателей места (0-3) в текста. Здесь n - определяемое пользо-
вателем целое число от 0 до 3. Курсор перемещается  в  ранее
установленный  указатель места нажатием клавиш Ctrl-Q и кла-
виши с номером указателя n.
 
     Парные фигурные скобки            Ctrl-Q [ или Ctrl-Q ]
 
     Эта команда перемещает курсор на соответствующий парный
символ {, [, (*, ", ', <, >, *), } или ]. Курсор должен быть
расположен на символе, для которого нужно найти соответству-
ющий парный символ. В случае поиска (* или *) он должен рас-
полагаться на ( или ).
     Эта команда учитывает вложенные фигурные  скобки.  Если
нельзя  найти соответствующую пару фигурной скобке, на кото-
рой находится курсор, то курсор не перемещается. Для (*  *),
{}, [] и <> обе команды Ctrl-Q [ и Ctrl-Q ] имеют одинаковый
эффект. Это имеет место, поскольку направление поиска  соот-
ветствующего  символа  может быть определено. В случае " и '
направление поиска определяется выбранной клавишей:  нажмите
Ctrl-Q [ для поиска пары для правой скобки; нажмите Ctrl-Q ]
- для поиска пары для левой скобки.
 
     Загрузить файл                                   F3
 
     Эта команда позволяет отредактировать существующий файл
или создать новый файл.
 
    Выйти из редактора, не сохраняя    Ctrl-K D или Ctrl-K Q
 
     Эта команда завершает работу редактора и возвращает вас
в  основное меню. Вы можете сохранить отредактированный файл
на диске с  помощью  опции  "Сохранение"  (Save)  в  команде
"Файл"  (File) основного меню или вручную, находясь в редак-
торе (с помощью клавиш Ctrl-K S или F2).
 
     Повторить последний поиск                        Ctrl-L
 
     Эта команда повторяет  последнюю  команду  "Найти"  или
"Найти/заменить",  как  если  бы вся информация была введена
заново.
 
     Восстановить строку                            Ctrl-Q L
 
     Эта команда позволяет отменить изменения,  внесенные  в
строку,  если курсор еще не перемещен из этой строки. Строка
восстанавливается в своем первоначальном состоянии,  незави-
симо от того, сколько изменений было внесено. 
 
     Сохранить файл                          Ctrl-K S или F2
 
     Эта команда сохраняет файл и оставляет вас в редакторе.
 
     Установить указатель места                     Ctrl-K n
 
     Вы можете пометить до четырех  мест  в  редакторе.  При
этом  n - это определяемое пользователем целое число от 0 до
3. Нажмите клавиши Ctrl-K, а после него клавишу с  цифрой  n
(0-3). Пометив позицию, вы можете потом перейти в любое мес-
то файла и легко возвратиться к помеченной позиции с помощью
команды Ctrl-Q n.
 
     Табуляция                                Ctrl-I или Tab
 
     Вне редактора Турбо-Паскаля табуляция по умолчанию рав-
на  восьми  столбцам.  Вы можете изменить размер табуляции в
меню "Опции/Среда программирования" (Options/Environment).
 
     Режим табуляции                   Ctrl-O T или Ctrl-Q T
 
     В режиме табуляции установленный шаг табуляции в тексте
равен  8.  При  выключенном режиме табуляции нажатие клавиши
Таb пере водит курсор на первую букву каждого слова в преды-
дущей строке.
 
        Отличие редактора Турбо-Паскаля от Word Star
 
     Несколько команд редактора Турбо-Паскаля слегка отлича-
ются от соответствующих команд редактора Word Star. Редактор
Турбо-Паскаля содержит только подмножество команд Word Star.
Некоторые средства, отсутствующие в редакторе Word Star, до-
бавлены в редакторе Турбо-Паскаля  с  тем,  чтобы  расширить
возможности  редактирования  исходных  текстов. Эти различия
перечислены ниже в алфавитном порядке.
 
     Автоматический отступ
 
     В редакторе Турбо-Паскаля команда Ctrl-O I  включает  и
выключает режим автоматического отступа. 
 
     Перемещение курсора
 
     Команды управления перемещением курсора в  Турбо-Паска-
ле: Ctrl-S, Ctrl-D, Ctrl-E и Ctrl-X - позволяют свободно пе-
ремещаться по экрану без перехода на первый столбец в пустых
строках. Это не означает, что весь экран заполнен пробелами.
Наоборот, все конечные пробелы автоматически удаляются. Этот
способ  перемещения  курсора  особенно удобен, например, при
редактировании программы, имеющей  операторы  с  одинаковыми
отступами.
 
     Удалить слева
 
     Последовательность Ctrl-Q Del, используемая в Word Star
(удалить  от позиции курсора до начала строки), не поддержи-
вается.

     Пометить слово, как блок
 
     Турбо-Паскаль позволяет пометить  одиночное  слово  как
блок с помощью клавиш Ctrl-K T. Это более удобно, чем двуша-
говая процедура Word Star, когда отдельно помечаются  начало
и конец слова.
 
     Перемещение через прерывания строк
 
     Клавиши Ctrl-S и Ctrl-D не выполняются через прерывания
строк.  Для  перемещения  от одной строки к другой нужно ис-
пользовать клавиши Ctrl-E, Ctrl-X, Ctrl-A или Ctrl-F.
 
     Завершение редактирования
 
     Команда Турбо-Паскаля Ctrl-K Q не совпадает с  командой
Word Star Ctrl-K Q (завершение редактирования). В Турбо-Пас-
кале измененный текст не отбрасывается, он остается в  памя-
ти,  готовый к тому, чтобы быть оттранслированным или сохра-
ненным.
 
     Отмена
 
     Команда Турбо-Паскаля Ctrl-Q L восстанавливает строку в
том  виде,  какой  она  имела до редактирования, до тех пор,
пока курсор не перемещен из этой строки.
 
     Обновление файла на диске
 
     Поскольку В Турбо-Паскале редактирование полностью осу-
ществляется  в памяти, команда Ctrl-K D не изменяет файла на
диске, как это имеет место в Word Star. Вы должны явным  об-
разом  обновить файл на диске с помощью средства Save в меню
File или с помощью Ctrl-K S или F2 внутри редактора.




