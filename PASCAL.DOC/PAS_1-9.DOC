
                        ПРИЛОЖЕНИЕ А

                Сравнение версии 5.0 языка
               Турбо-Паскаль с ANSI-Паскалем

     В данном приложении сравниваются алгоритмические  языки
Турбо-Паскаль  и  ANSI-Паскаль,  как он определен стандартом
ANSI/IEEE770X3.97-1983 в книге  American  National  Standart
Pascal  Computer Programming Language (Американский стандар-
тный   язык   программирования   на   ЭВМ   Паскаль)   (ISBN
0-471-88944-X,  опубликованной  The  Institute of Electrical
and Electronics Engineers in New  York  (Институтом  инжене-
ров-электриков и электроников в Нью-Йорке)).

           Исключения по отношению к требованиям
            алгоритмического языка ANSI-Паскаль

     Алгоритмический язык Турбо-Паскаль подчиняется требова-
ниям ANSI/IEEE770X3.97-1983 со следующими исключениями:

     - В ANSI-Паскале идентификатор может иметь любую  длину
и  все его знаки являются значащими. В Турбо-Паскале иденти-
фикатор может иметь любую длину, но  только  первые  63  его
знака являются значащими.

     - В ANSI-Паскале символ @ является  альтернативным  для
символа  ^.  В Турбо-Паскале  @ является оператором, который
никогда не трактуется идентично символу ^.

     - В ANSI-Паскале комментарий может начинаться [  и  за-
канчиваться  *)  или начинаться (* и заканчиваться ]. В Тур-
бо-Паскале комментарии должны начинаться и заканчиваться од-
ним и тем же набором символов (например { комментарий }).

     - В ANSI-Паскале каждое возможное  целевое  значение  в
операторе  варианта может появляться только один раз. В Тур-
бо-Паскале это требование не является обязательным.

     - В ANSI-Паскале тип компонента файлового типа не может
быть структурным типом, имеющим конпонент файлового же типа.
В Турбо-Паскале это требование не является обязательным.

     - В ANSI-Паскале файловые переменные имеют соответству-
ющую  буферную переменную, на которую можно сослаться, запи-
сывая символ после файловой переменной. В Турбо-Паскале фай-
ловая  переменная не имеет соответствующей буферной перемен-
ной и указание символа  после файловой  переменной  является
ошибкой.

     - В ANSI-Паскале раздел операторов функции  должен  со-
держать  по  крайней  мере  одно присваивание идентификатору
функции. В Турбо-Паскале это требование не  является  обяза-
тельным.

     - В ANSI-Паскале поле, которое является разделителем  в
операторе варианла, не может быть фактическим параметром-пе-
ременной. В Турбо-Паскале это требование не является  обяза-
тельным.

     - В ANSI-Паскале процедуры и функции могут иметь проце-
дурные и функциональные параметры. Такие параметры не допус-
каются в Турбо-Паскале.

     - В ANSI-Паскале стандартные процедуры Reset и  Rewrite
не  требуют  предварительной инициализации файловых перемен-
ных. В Турбо-Паскале файловым переменным должны быть присво-
ены  имена  внешнего  файла (для чего используется процедура
Assign ) перед тем, они передаются  в  процедуры  Reset  или
Rewrite.

     - ANSI-Паскале определены стандартные процедуры  Get  и
Put,  которые используются для считывания информации из фай-
лов и записи ее в них. Эти процедуры в Турбо-Паскале не  оп-
ределены.

     - В ANSI-Паскале синтаксис New (p,c1,...cn) создает ди-
намическую  переменную с конкретной действующей динамической
областью памяти. В Турбо-Паскале такой синтаксис не допуска-
ется.

     - В ANSI-Паскале синтаксис Dispose(q,k1,...km)  удаляет
динамическую  переменную с конкретной действующей динамичес-
кой областью памяти. В Турбо-Паскале такой синтаксис не  до-
пускается.

     - В ANSI-Паскале определены стандартные процедуры  Pack
и Unpack, которые используются для "упаковки" и "распаковки"
упакованных переменных. Эти процедуры в Турбо-Паскале не оп-
ределяются.

     - В ANSI-Паскале элемент i mod j всегда вычисляет поло-
жительное  значение, и если j является нолем или отрицатель-
ным числом, то влзникаеп ошибка. В Турбо-Паскале   i  mod  j
вычисляется  как  i-(i  div j)*j, и, если j является отрица-
тельным числом, то это не является ошибкой.

     - В ANSI-Паскале оператор goto внутри блока может  ссы-
латься на метку, находящуюся в блоке, его включающем. В Тур-
бо-Паскале такая ситуация вызывает ошибку.

     - В ANSI-Паскале является ошибкой, если значение управ-
ляющей  переменной  в операторе варианта не равно какой-либо
из констант варианта. В Турбо-Паскале такая ситуация не  яв-
ляется   ошибочной,  зато  игнорируется  оператор  вариантов
(case), если он не содержит предложения else.

     - В  ANSI-Паскале  модификация  управляющей  переменной
оператора  не допускается. В Турбо-Паскале такое ограничение
не является обязательным.

     - В ANSI-Паскале операция Read (считывание) из  тексто-
вого  файла с переменной типа char присваивает значение про-
бела этой переменной,если Eoln  имело  значение  True  перед
Read  (считывание). В Турбо-Паскале в данном случае этой пе-
ременной присваивается  значение  символа  возврата  каретки
(ANSII 13).

     - В ANSI-Паскале Read (считывание) из текстового  файла
с  переменной  типа integer или real прекращается сразу, как
появляется следующий знак в файле, не являющийся частью  це-
лого  числа  со  знаком  или  просто числа со знаком. В Тур-
бо-Паскале считывание прекращается, когда следующий  знак  в
файле является пробелом или управляющим знаком (включая мет-
ку конца строки).

     - В ANSI-Паскале операция Write  (запись)  в  текстовый
файл  со значением типа упакованная строка приводит к усече-
нию строки, если указанная ширина  поля  меньше,  чем  длина
строки.  В  Турбо-Паскале  строка всегда записывается полно-
стью, даже если она длиннее, чем указанная ширина поля.

           Примечание: В  Турбо-Паскале  нельзя  определить,
      нарушила ли программа какое-либо из ограничений, здесь
      указанных.

        Расширения по отношению к языку ANSI-Паскаль

     Следующие свойства языка Турбо-Паскаль представляют со-
бой  расширенные  возможности по отношению к Паскалю, как он
определен ANSI/IEEE770X3-1983.

     - В Turbo-Паскале имеются  следующие  зарезервированные
слова:

        absolute           interface            string
        external           interrupt            unit
        implementation     shl                  uses
        inline             shr                  xor

     - Идентификатор после первого символа  может  содержать
знаки подчеркивания (_).
     - Целые константы могут записываться в  шестнадцатирич-
ном виде. Перед такими константами ставится знак $.
     - Идентификаторы могут использоваться, как метки.
     - Строковые константы совместимы с  типом  string  Тур-
бо-Паскаля  и могут содержать управляющие знаки и другие не-
печатаемые символы.
     - Описания меток, констант, типов, переменных, процедур
и функций могут задаваться в блоке любое число раз и в любом
порядке.
     - Турбо-Паскаль реализует  дополнительные  типы  целых:
короткое  целое  (shortint), длинное целое (longint - 4 бай-
та), байт (byte) и слово (word), а также дополнительные типы
действительных  чисел: с одинарной точностью, с двойной точ-
ностью и с повышенной.
     - Турбо-Паскаль реализует типы строк, которые отличают-
ся  от  упакованных типов строк, определенных в ANSI-Паскале
тем, что такие строки исключают динамический признак  длины,
который может изменять длину во время выполнения программы.
     - Правила совместимости чисел расширены так, чтобы сде-
лать символьные типы (char) и типы упакованных строк совмес-
тимыми со строковыми типами (string).
     - Переменные могут описываться в абсолютных адресах па-
мяти с помощью соответствующего оператора.
     -  Переменная-указатель  может  содержать  обращение  к
функции ссылочного типа, результат которой затем разыменовы-
вается для обозначения динамической переменной.
     - Переменные строкового типа для осуществления  доступа
к  отдельным знакам в строке могут индексироваться, как мас-
сивы.
     - Тип переменной ссылочного типа (переменной-указателя)
может  быть  изменен на другой тип с помощью приведения типа
переменной.
     - Турбо-Паскаль использует константы с указанным  типом
данных,  которые  могут  описывать инициированные переменные
любых типов за исключением файлов.
     - Турбо-Паскаль использует три новых логических  опера-
тора: xor, shl и shr.
     - Операторы not, and, or и xor могут  использоваться  с
операндами  типа  целое для выполнения логических операций с
битами.
     - Оператор + может использоваться для соединения строк.
     - Операторы отношений могут использоваться для  сравне-
ния строк.
     - Турбо-Паскаль использует оператор @, применяемый  для
получения адреса переменной или процедуры, или функции.
     - Тип выражения может быть заменен на другой с  помощью
приведения типа значения.
     - Оператор case допускает наличие диапазонов значений в
списках  case  label и позволяет использовать необязательную
часть оператора - else.
     - Процедуры и функции могут описываться с  помощью  уп-
реждающих  директив, директив вставки и директив прерывания,
для того, чтобы обеспечивать возможность использования  под-
программ  на  языке ассемблера, внутреннего машинного кода и
процедур прерывания.
     - Переменный параметр может не иметь типа. В этом  слу-
чае  любой указатель-переменная может быть файтическим пара-
метром.
     - Турбо-Паскаль использует программные модули для обес-
печения возможности модульного программирования и раздельной
компиляции.
     - В Турбо-Паскале имеются следующие процедуры обработки
файлов и функций, отсутствующие в ANSI-Паскале:

     Append         Close         Flush            RmDir
     BlockRead      Erase         GetDir           Seek
     BlockWrite     FilePos       MkDir            SeekEof
     ChDir          FileSize      Rename           SeekEoln

     - Значения типа строка  могут  вводиться  и  выводиться
следующими  стандартными  процедурами:  Read, Readln, Write,
Writeln.
     - В  Турбо-Паскале  реализованы  следующие  стандартные
процедуры и функции, отсутствующие в ANSI-Паскале:

     Addr           GetMem        MemAvial         Release
     CSeg           Halt          Move             SPtr
     Concat         Hi            Ofs              SSeg
     Copy           Inc           ParamCount       Seg
     DSeg           Insert        ParamStr         SizeOf
     Dec            Int           Pi               Str
     Delete         Length        Pos              Swap
     Exit           Lo            Ptr              Upcase
     FillCharFrac   Mark          Random           Val
     FreeMem        MaxAvial      Randomize

     - Благодаря наличию стандартных программных  модулей  в
Турбо-Паскале  реализованы  дополнительные стандартные конс-
танты, типы, переменные, процедуры и функции.

           Примечание:  Турбо-Паскаль  не  может  обнаружить
      факт использования программой ни одного из  указанных
      здесь расширений.

         Особенности языка, зависящие от реализации

     Влияние использования особенности  реализации  Паскаля,
определенного  ANSI/IEEE770X3.97-1983, не указывается. Прог-
раммы не должны зависеть от конкретного пути реализации язы-
ка  в  случае,  когда используется особенность, зависящая от
такой реализации. Особенности, зависящие от конкретной  реа-
лизации, включают в себя:
     - порядок вычисления  индексных  выражений  в  указате-
ле-переменной;
     - порядок вычисления выражений в конструкторе набора;
     - порядок вычисления операндов в двоичном операторе;
     - порядок вычисления действительных параметров в вызове
функций;
     - порядок вычисления левой и правой частей в  операторе
присваивания;
     - порядок вычисления действительных параметров в опера-
торе процедуры;
     - влияние чтения текстового файла, с  которым  работала
процедура Page во время его создания;
     - привязка переменных, помеченных программными парамет-
рами, к объектам внешним по отношению к этой программе.

                      Обработка ошибок

     В данном разделе приводятся те ошибки из  Приложения  G
Стандарта  ANSI-Паскаля, которые не обнаруживаются автомати-
чески  Турбо-Паскалем.  Номера,  которыми  обозначены  здесь
ошибки,  являются  номерами,  используемыми в Стандарте ANSI
Pascal. Ошибки 6, 19-22, и  25-31  не  обнаруживаются  из-за
того, что не используются в Турбо-Паскале.

     1.  Если t является управляющей переменной в  операторе
         варианта, а f - это поле внутри активной ветви это-
         го оператора варианта изменение значения t во время
         существова-  ния  ссылки на f является ошибкой. Эта
         ошибка не обнаруживается. является ошибкой, если  p
         имеет значение nil. Эта ошибка не обнаруживается.
     2.  Если p является переменной-указателем, то ссылка p^
         является  ошибкой, если p не определено. Эта ошибка
         не обнаруживается.
     3.  Если p является указателем-переменной, то изменение
         значения  p  является  ошибкой до тех пор, пока су-
         ществует ссылка на p. Эта ошибка не обнаруживается.
     4.  Обращение к функции Eoln(f) является ошибкой,  если
         Eof(f)  имеет значение True. В Турбо-Паскале это не
         является ошибкой, и Eoln(f)  имеет  значение  True,
         если Eof(f) имеет значение True.
     5.  Ссылка на переменную в выражении является  ошибкой,
         если  значение  этой  переменной не определено. Эта
         ошибка не обнаруживается.
     6.  Выражение вида i mod j  является  ошибкой,  если  j
         равно нулю или имеет отрицательное значение. В Тур-
         бо-Паскале такое  выражение  не  является  ошибкой,
         если j имеет отрицательное значение.
     7.  Если функция  не  присваивает  значение  результата
         идентификатору  функции,  то  это является ошибкой.
         Эта ошибка не обнаруживается.
     8.  Является ошибкой, если значение  управляющей  пере-
         менной  в  операторе варианта не равно ни одному из
         значений констант в операторе  варианта  (case).  В
         Турбо-Паскале такая ситуация не является ошибочной.
         Однако оператор варианта игнорируется, если  он  не
         содержит предложения else.


                        ПРИЛОЖЕНИЕ В

                   Директивы компилятора

     Некоторые из возможностей компилятора Турбо-Паскаля ре-
ализуются с помощью директив компилятора. Директива компиля-
тора представляет собой комментарий со специальным синтакси-
сом.  Турбо-Паскаль  допускает  директивы компилятора везде,
где допускаются комментарии.
     Директива компилятора начинается со знака  $,  стоящего
первым  после открывающего граничного знака комментария. Не-
посредственно после знака $ следует имя (одна или  несколько
букв),  которое определяет конкретные директивы. Имеются три
типа директив:

     - Директивы переключения. Эти директивы включают  конк-
ретные  возможности  компилятора  или выключают их с помощью
указания знака плюса "+" или минуса "-"  сразу  после  имени
директивы.
     - Директивы с параметрами. Эти директивы  задают  пара-
метры, оказывающие влияние на компиляцию,  такие,  например,
как имена файлов и размеры памяти.
     - Условные директивы. Эти  директивы  используются  для
управления условной компиляцией частей исходного текста, ос-
нованной на определении пользователем условных символов.

     Все  директивы  за  исключением  директив  переключения
должны  по  иметь крайней мере  один пробел между именем ди-
рективы и параметром.
     Ниже приводятся некоторые примеры директив компилятора:

     {$B+}
     {$R- Turn off range-checking}
     {$I TYPES.INC}
     {$U C:\UNITS\MEM}
     {$M 65520,8192,655360}
     {$DEFINE Debug}
     {$IFDEF Debug}
     {$ENDIF}

     Директивы компилятора вы можете разместить  непосредст-
венно  в  исходном  коде программы. Можно также изменить ис-
пользуемые по умолчанию директивы с помощью компилятора, ис-
пользующего  командную строку (TPC.EXE) или с помощью компи-
лятора, работающего в диалоговой среде (TURBO.EXE). Все  ди-
рективы  компилятора  можно  задавать  с помощью меню выбора
возможностей  компилятора (Options/Compiler Menu). Все  вно-
симые вами в меню изменения будут иметь силу при последующих
компиляциях (более детальное описание дается в Приложении  А
"Руководства  пользователя").  При  использовании командного
компилятора директивы компилятора можно либо задавать в  ко-
мандной  строке  (например, TPC /$R+ MYPROG), либо поместить
их в файл конфигурации TPC.CFG (см. Приложение G "Руководст-
ва пользователя"). Директивы компилятора, которые содержатся
в исходном коде, всегда отменяют принятые по умолчанию  зна-
чения директив. Это справедливо как для компилятора, работа-
ющего в режиме командной строки, так  и  для  интерактивного
компилятора.

                   Директивы переключения

     Директивы переключения могут быть глобальными  или  ло-
кальными. Глобальные директивы оказывают влияние на всю ком-
пиляцию, тогда как  локальные  директивы  оказывают  влияние
только на ту часть компиляции, которая происходит, начиная с
появления данной директивы до следующего ее обнаружения.
     Глобальные директивы должны указываться перед  разделом
описания  данной  программы или данного программного модуля,
подлежащих компиляции, то есть перед  первым  использованием
ключевых  слов uses, label, const, type, procedure, function
или begin. Локальные директивы могут задаваться в любом мес-
те программы или программного модуля.
     Несколько директив переключения могут быть сгруппирова-
ны в одном комментарии директив компилятора с разделением их
запятыми, например:

     {$B+,R,S-}

     В этом случае пробелы между директивами могут не указы-
ваться.

                    Выравнивание данных

     Синтаксис: {$A+} или {$A-}
     По умолчанию: {$A+}
     Тип: Глобальный.
     Эквивалент меню: "Опции/Компилятор/Выравнивание данных"
(Option/Compiler/Align Data).

     Данная директива позволяет переключаться между выравни-
ванием переменных и типизованных констант на границу слова и
на границу байта. Для процессора 8088 выравнивание на грани-
цу слова игнорируется. Однако для всех процессоров 80х86 вы-
равнивание на границу слова означает более быстрое  выполне-
ние, поскольку адресация ко всем элементам, имеющим размер в
слово или четным адресам происходит за один цикл обращения к
памяти вместо двух.
     В состоянии {$A+} все переменные и  типизованные  конс-
танты,  превышающие  по  размеру один байт, выравниваются на
границу машинного слова (адреса  с  четными  значениями).  В
случае необходимости между переменными для достижения вырав-
нивания на границу слова включаются дополнительные неисполь-
зуемые  байты.  Директива  {$A+}  не влияет ни на переменные
размером в байт, ни на поля структур или элементы  массивoв.
Поле  записи  будет  выравниваться на границу слова только в
том случае, если общий размер всех следующих перед ним полей
будет иметь четное значение. Аналогично, для любого элемента
массива выравнивание на  границу  слова  будет  иметь  место
только когда размер элементов имеет четное значение.
     В состоянии {$A-} никаких действий по  выравниванию  не
предпринимается. Переменные и типизованные константы незави-
симо от их размера помещаются в этом случае просто по следу-
ющему доступному адресу.

           Примечание: Независимо от директивы $A+ в разделе
      описаний кождое описание var и const всегда начинается
      на границе слова.  Аналогично,  компилятор  компилятор
      всегда старается поддерживать указатель стека (SP) вы-
      ровненным на границу слова, для чего в случае  необхо-
      димости  для стека процедуры выделяется дополнительный
      неиспользуемый байт.

                    Булевские вычисления

     Синтаксис: {$B+} или {$B-}
     Значение по умолчанию: {$B+}
     Тип: Локальный.
     Эквивалент меню:  "Опции/Компилятор/Булевские  вычисле-
ния" (Options/Compiler/Boolean Evaluation).

     Эта директива осуществляет два различных вида генериро-
вания кода для булевских операторов and и or.
     В состоянии {$B+} компилятор генерирует код для полного
вычисления булевского выражения. Это значит, что каждый опе-
ранд булевского выражения, состоящий из операторов and и or,
будет  вычислен, даже если результат всего выражения заранее
известен.
     В состоянии {$B-} компилятор генерирует код для  вычис-
ления булевского выражения по короткой схеме, то есть вычис-
ление прекратится сразу, как станет очевидным результат  вы-
числения  всего этого выражения. Более подробно смотрите ин-
формацию в разделе "Булевские операции" .

                   Информация для отладки

     Синтаксис: {$D+} или {$D-}
     По умолчанию: {$D+}
     Тип: Глобальный.
     Эквивалент меню: "Опции/Компилятор/Информация  для  от-
ладки" (Options/Compiler/Debug Information).

     Данная директива задает или отменяет генерацию информа-
ции по отладке. Отладочная информация состоит из таблицы но-
меров строк для каждой процедуры, устанавливающей соответст-
вие  адресов объектных кодов с номерами строк исходного тек-
ста.
     Когда эта возможность задана для данной  программы  или
модуля,  встроенный  отладчик Турбо-Паскаля позволяет прохо-
дить этот модуль по шагам и  устанавливать  точки  останова.
Кроме  того,  при появлении ошибки во время выполнения прог-
раммы или программного модуля, который был  скомпилирован  с
включенной    опцией    информации   об   отладке   ({$D+}),
Турбо-Паскаль использует эту информацию для определения опе-
ратора в исходном тексте, приведшего к появлению ошибки.
     Переключатели       "Отладка/Автономная        отладка"
(Debug/Stand-Alone   Debugging)  и   "Опции/Компоновщик/Файл
МAР" позволяют включить  для данного только информацию о но-
мерах строк (еели этот  модуль  компилировался  в  состоянии
{$D+}).
     Для программных модулей отладочная информация записыва-
ется в файл .TPU вместе с объектным кодом. Отладочная инфор-
мация приводит к увеличению размера файлов  .TPU  и  требует
дополнительного  пространства  при  компиляции  использующей
данный модуль программы, но на размер и скорость работы  вы-
полняемой программы влияния не оказывает.
     Переключатель отладочной информации обычно используется
вместе с переключателем локальных символов, который позволя-
ет включить или выключить генерацию отладочной информации по
локальным символам.

           Примечание: Если вы хотите использовать  для  от-
      ладки  программ  Турбо-отладчик, то задайте компиляцию
      на диск (для чего  нужно  установить  опцию  "Компиля-
      ция/Назначение"   (Compiler/Destination)   в  значение
      Disk) и установить (в значение On) опцию  "Отладка/Ав-
      тономная отладка" (Debug/Stan-Alone Debugging).

                          Эмуляция

     Синтаксис: {$E+} или {$E-}
     По умолчанию: {$E-}
     Тип: Локальный.
     Эквивалент меню: "Опции/Компилятор/Эмуляция" (Options/
Compiler/Emulation).

     Эмуляция разрешает или запрещает компоновку с библиоте-
кой  исполняющей  системы,  которая будет эмулировать работу
сопроцессора 8087 в случае его отсутствия. Когда вы компили-
руете программу в состоянии {$N+,E+}, Турбо-Паскаль выполня-
ет компоновку с полным эмулятором 8087. Полученый в  резуль-
тате  выполняемый файл может использоваться на любом компью-
тере независимо от наличия сопроцессора 8087.  Если исполня-
ющая система находит такой сопроцессор, то она его использу-
ет. В противном случае он эмулируется с  помощью  библиотеки
исполняющей системы.
     В состоянии {$N+,E-} Турбо-Паскаль будет выполнять ком-
поновку  с существенно меньшей по размеру библиотекой работы
с плавающей запятой, которая может использоваться только при
наличии сопроцессора 8087.
     При использовании в  программном  модуле  переключатель
эмуляции сопроцессора 8087 никакого влияния не оказывает. Он
действует только при компиляции программы. Более того,  если
программа  была  скомпилирована в состоянии {$N+}, а все ис-
пользуемые этой программой модули - в  состоянии  {$N-},  то
необходимость  использования  библиотеки исполняющей системы
отпадает и переключатель эмуляции сопроцессора 8087  игнори-
руется.

                   Дальний тип обращений

     Синтаксис: {$F+} или {$F-}
     По умолчанию: {$F-}
     Тип: Локальный.
     Эквивалент меню:  "Опции/Компилятор/Дальние  обращения"
(Option/Compiler/Force Far Calls).

     Данная директива управляет выбором типа вызова последо-
вательно компилируемых процедур и функций. Процедуры и функ-
ции, скомпилированные в состоянии {$F+},  всегда  используют
дальний   тип   обращений.   При  указании  директивы  {$F-}
Турбо-Паскаль автоматически выбирает соответствующий тип об-
ращений:  дальний,  если процедура или функция описывается в
разделе интерфейс программной единицы, и ближний в противном
случае.
     Дальний и ближний тип вызова  описываются  полностью  в
Главе 15 "В среде Турбо-Паскаля".

           Примечание: Если программа использует оверлеи, то
      предполагается, что в начале этой программы и в начале
      каждого модуля помещена директива  {$F+},  позволяющая
      выполнить требования по дальнему типу обращения. Более
      подробно это обсуждается в  Главе  13  "Оверлеи".  Для
      программ, использующих процедурные переменные, все та-
      кие процедуры должны использовать вызовы типа FAR (см.
      раздел  "Переменные  процедур",  где  содержится более
      подробная информация).

                   Проверка ошибок ввода-вывода
                Проверка ошибок ввода-вывода

     Синтаксис: {$I+} или {$I-}
     По умолчанию: {$I+}
     Тип: Локальный.
     Эквивалент меню: "Опции/Компилятор/Проверка ошибок  вво-
да-вывода" (Option/Compiler/I/O-Checking).

     Данная директива задает или отменяет генерирование  ав-
томатического  кода, проверяющего результат обращения к про-
цедуре ввода-вывода. Процедуры  ввода-вывода  описываются  в
Главе 10 ("Ввод-вывод"). Если процедура ввода-вывода возвра-
щает ненулевой результат ввода-вывода при включенном  перек-
лючателе (+), то программа завершает работу, выводя на экран
сообщения об ошибке во время выполнения. Если  переключатель
выключен  (-), то результат операции ввода-вывода нужно про-
верять с помощью функции OIResult.

              Информация о локальных символах

     Синтаксис: {$L+} или {$L-}
     По умолчанию: {$L+}
     Тип: Глобальный.
     Эквивалент меню:  "Опции/Компилятор/Локальные  символы"
(Options/Compiler/Local Symbols).

     Данная директива приводит в действие или отменяет гене-
райию  информации о локальных символах. Информация о локаль-
ных символах состоит из имен и типов всех локальных перемен-
ных  и констант данного модуля, то есть из символов в секции
реализации модуля и символов, содержащихся  в  процедурах  и
функциях этого модуля.
     Когда для данного модуля задана генерация информации  о
локалных  символах, встроенный отладчик Турбо-Паскаля позво-
ляет вам проверять и модифицировать локальные переменные мо-
дуля.  Кроме того, с помощью меню "Отладчик/Обращения к сте-
ку" (Debug/Calls Stack) можно проверять обращения к процеду-
рам и функциям модуля.
     Переключатели  "Опции/Компоновка/Файл   МAР"   (O/L/Map
File)  и "Отладка/Автономная отладка" (Debug/Stand-Alone De-
bugging) позволяют получить информацию о локальных  символах
для данного модуля, если этот модуль компилировался в состо-
янии {$L+}.
     Для модулей информация о локальных символах записывает-
ся  в файле .TPU наряду с объектным кодом модуля. Эта инфор-
мация увеличивает  размер  файлов (требуется  дополнительное
пространство). Однако на размер и скорость  работы выполняе-
мой программы это влияния не оказывает.
     Переключатель, задающий включение информации о  локаль-
ных  символах,  обычно  используется вместе с переключателем
отладочной информации, который позволяет включить или выклю-
чить  генерацию  таблицы номеров строк для отладки. Заметим,
что в том случае, если переключатель  отладочной  информации
выключен ({$D-}), директива $L будет игнорироваться.

           Сопроцессор математических вычислений

     Синтаксис: {$N+} или {$N-}
     По умолчанию: {$N-}
     Тип: Глобальный.
     Эквивалент меню:  "Опции/Компилятор/Числовой  сопроцес-
сор" (Option/Compiler/Numeric Processing).

     Данная директива осуществляет выбор одной из двух моде-
лей генерирования кода вычисления с плавающей запятой, имею-
щихся в Турбо-Паскале. При указании директивы {$N-}  генери-
руется код для выполнения в программном обеспечении всех вы-
числений типа real с помощью вызова программ библиотеки  ис-
польняющей системы Паскаля. При указании директивы {$N+} ге-
нерируется код для выполнения всех вычислений  типа  real  с
помощью сопроцессора математических вычислений 8087.
     Заметим, что для эмуляции сопроцессора 8087  вы  можете
также  использовать также директиву {$E+}. Это дает вам воз-
можность использовать типы данных с  плавающей  запятой  без
необходимости установки микросхемы сопроцессора 8087.

                 Генерация оверлейного кода

     Синтаксис: {$O+} или {$O-}
     По умолчанию: {$O-}
     Тип: Глобальный.
     Эквивалент меню: "Опции/Компилятор/Использование  Овер-
леев" (Options/Compiler/Overlays Allowed).

     Директива $O разрешает или запрещает генерацию оверлей-
ного кода. Турбо-Паскаль разрешает использовать модуль в ка-
честве оверлейного только в том случае, если он был  скомпи-
лирован с директивой {$O+}. В этом случае генератор выполня-
емого кода принимает особые меры при передаче строки от  од-
ного оверлейного модуля другому и установке постоянных пара-
метров.
     Указание  данной директивы в  модуле  не  обязывает вас
использовать  данный  модуль  в  качестве  оврелейного.  Она
просто указывает Турбо-Паскалю, чтобы он  обеспечил  возмож-
ность  использования  данного модуля в качестве оверлейного,
если это потребуется. Если вы разрабатываете модули, которые
планируется  использовать  как в оверлейном, так и в неовер-
лейном варианте, то директива {$O+}  обеспечит  вам  возмож-
ность  использования  в  обоих случаях одной и той же версии
модуля.

           Примечание:  Директива  компилятора  {$O+}  почти
      всегда используется совместно с директивой компилятора
      {$F+}, что позволяет выполнить  требования  подсистемы
      управления  оверлеями  по  использованию дальнего типа
      вызовов.
           Более подробная информация по генерации  оверлей-
      ного кода содержится в Главе 13 ("Оверлеи").

                      Проверка границ

     Синтаксис: {$R+} или {$R-}
     По умолчанию: {$R-}
     Тип: Локальный.
     Эквивалент  меню:   "Опции/Компилятор/Проверка  границ"
(Options/Compiler/Range-Checking).

     Данный переключатель приводит в действие и отменяет ге-
нерирование  кода с проверкой границ. При указании {$R+} все
выражения с индексированными строками и массивы  проверяются
на предмет нахождения их внутри указанных границ, а все опе-
раторы присваивания скалярным величинам и переменным поддиа-
пазонов  проверяются на нахождение в заданных границах. Если
обнаруживается нарушение диапазона, программа завершает свою
работу,  выводя сообщения об ошибке времени выполнения. При-
веденная в действие проверка границ замедляет  работу  прог-
раммы и увеличивает ее размер. Используйте эту директиву при
отладке, а затем, после получения отлаженной программы, уда-
лите ее.

                Проверка переполнения стека

     Синтаксис: {$S+} или {$S-}
     По умолчанию: {$S+}
     Тип: Локальный.
     Эквивалент  меню:  "Опции/Компилятор/Проверка  перепол-
нения стека" (Options/Compiler/Stack-Checking).

     Данная директива приводит в действие или отменяет гене-
рирование  кода с проверкой переполнения стека. При указании
{$S+} компилятор генерирует в начале  каждой  процедуры  или
функции код, который проверяет, достаточное ли место в стеке
выделено для локальных переменных. Если в стеке места недос-
таточно,  то  обращение к процедуре или функции, скомпилиро-
ванное с указанием {$S+}, приводит к завершению работы прог-
раммы,  которая при этом выводит сообщение об ошибке времени
выполнения. При указании {$S-} такое обращение наиболее  ве-
роятно приведет к фатальной ошибке системы.

            Проверка параметров строкового типа

     Систаксис: {$V+} или {$V-}
     По умолчанию: {$V+}
     Тип: Локальный.
     Эквивалент меню: "Опции/Компилятор/Проверка строк-пара-
метров" (Options/Compiler/Var-String Checking).

     Проверка переменных строкового типа управляет проверкой
типа  при передаче строк в качестве параметров-переменных. В
состоянии {$V+} выполняется строгая проверка типа, при кото-
рой требуется, чтобы формальный и фактический параметр имели
идентичные строковые типы (string). В состоянии {$V-} в  ка-
честве фактического параметра допускается использовать любую
переменную строкового типа, даже если ее описанная длина  не
совпадает с длиной соответствующего формального параметра.

                  Директивы с параметрами

                       Включить файл

     Синтаксис: {$I имя_файла}
     Тип: Локальный.
     Эквивалент меню: "Опции/Оглавление/Каталоги  включаемых
файлов" (Options/Compiler/Include Directories).
     Данная директива сообщает компилятору  о  необходимости
включить в компиляцию названный файл. Фактически файл встав-
ляется в скомпилированный текст непосредственно за  директи-
вой  {$I  имя_файла}. Расширением по умолчанию для параметра
"имя_файла" является .PAS. Если параметр "имя_файла" не ука-
зывает оглавления, то в дополнение к поиску файлов в текущем
каталоге Турбо-Паскаль осуществляет поиск его  в  каталогах,
указанных  в меню "Опции/Оглавления/Каталоги включаемых фай-
лов" или в оглавлениях, указанных в опции /I командной стро-
ки ТРС.
     Турбо-Паскаль допускает открытие в любой данный  момент
времени  самое  большее пяти входных файлов. Это значит, что
для включаемых файлов допускается вложенность на глубину  до
восьми уровней.
     Имеется одно ограничение  на  использование  включаемых
файлов: включаемый файл не может быть указан в середине раз-
дела операторов. Это означает, что все операторы между  опе-
раторными  скобками  begin  и  end раздела операторов должны
постоянно находиться в одном и том же исходном файле.

                Компоновка объектного файла

     Синтаксис: {$L имя_файла }
     Тип: Локальный.
     Эквивалент  меню:   "Опции/Каталоги/Каталоги  объектных
файлов" (Options/Directories/Object Directories).
     Данная директива предписывает компилятору  скомпоновать
указанный  файл  с  компилируемой программой или программным
модулем. Директива $L используется для компоновки кода,  на-
писанного на языке ассемблера для подпрограмм, описанных как
внешние (external). Указанный файл должен быть  перемещаемым
объектным файлом в формате Intel (файл .OBJ). Расширением по
умолчанию для параметра "имя_файла" является .OBJ. Если  па-
раметр "имя_файла" каталог не задан, то в дополнение к поис-
ку файла в текущем каталоге Турбо-Паскаль просматривает  ка-
талоги,  указанные в меню "Опции/Каталоги/Каталоги объектных
файлов" или в каталогах,  указанных  в  опции  /0  командной
строки ТРС.
     Более подробно о редактировании  с  языком  ассемблера,
смотрите в Главе 15 "В среде Турбо-Паскаля".

                 Размеры выделяемой памяти

     Синтаксис: {$M раз_стек, мин_об, макс_об}
     По умолчанию: {$M 16384,0,655360}
     Тип: Глобальный.
     Эквивалент   меню:  "Опции/Компилятор/Размеры   памяти"
(Options/Compiler/Memory Sizes).

     Данная директива указывает параметры распределения  па-
мяти программы. Параметр "раз_стек" должен быть целым числом
в диапазоне от 1024 до 65520, которое указывает размер  сег-
мента стека. "Мин_об" должно быть числом в диапазоне от 0 до
655360, а  "макс_об"  должно  быть  числом  в  диапазоне  от
"мин_об" до 655360. Параметры "мин_об" и "макс_об" указывают
соответственно минимальные и максимальные размеры динамичес-
ки распределяемой области памяти.
     Сегмент стека и динамически распределяемая область  па-
мяти обсуждаются в Главе 4 "Переменные" и в Главе 15 "В сре-
де Турбо-Паскаля".

           Примечание: Директива $M не оказывает влияния при
      использовании ее в программном модуле.

                   Имя оверлейного модуля

     Синтаксис: {$O имя_модуля}
     Тип: Локальный.
     Эквивалент меню: Отсутствует.
     Указание в данной  директиве  имени  модуля  превращает
этот модуль в оверлейный.
     При использовании данной директивы в модуле она никако-
го  влияния не оказывает. При компиляции программы директива
{$O имя_модуля} задает, какой из используемых программой мо-
дулей нужно поместить в файл
     Эта директива должна указываться после предложения  ис-
пользования  программы.  При попытке использовать в качестве
оверлейного модуль, который не был скомпилирован в состоянии
{$O+},  Турбо-Паскаль  сообщает об ошибке. Любой модуль, имя
которого указывается в параметре "имя_модуля",  должен  быть
скомпилирован  с  установленным  в  интерактивной среде меню
"Разрешение  оверлеев"  (эквивалент  директивы   компилятора
{$O+}).
     Более подробно про оверлеи рассказывается  в  Главе  13
("Оверлеи").

                    Условная компиляция

     Директивы условной компиляции языка Турбо-Паскаль  поз-
воляют  получать различный код из одного и того же исходного
текста при помощи использования условных символов.
     Имеются две основные конструкции  условной  компиляции,
которые  являются  весьма  похожими  на оператор Паскаля if.
Первой конструкцийе является

     {$IFxxx} ... {$ENDIF}

которая  приводит  к  компиляции  исходного   текста   между
{$IFxxx} и {$ENDIF} только в случае, если условие, указанное
в {$IFxxx}  условеи удовлетворяется (имеет  значение  True).
Если  же это условие имеет значение False, то исходный текст
между этими двумя директивами игнорируется.
     Второй конструкцией условной компиляции является

     {$IFxxx} ... {$ELSE} ... {$ENDIF}

которая приводит к компиляции либо  исходного  текста  между
{$IFxxx}  и  {$ELSE},  или  исходного текста между {$ELSE} и
{$ENDIF} в зависимости  от  условия,  указанного  с  помощью
{$IFxxx}.

     Приведем некоторые примеры конструкций условной  компи-
ляции.

     {$IFDEF Debug}
       Writeln('X=',X);

     {$ENDIF}

     {$IFDEF CPU87}
       {$N+}
       type
      real = double;
     {$ELSE}
       {$N-}
       type
      single = real;
         double = real;
         extended = real;
         comp = real;
     {$ENDIF}

     Конструкции условной компиляции могут вкладываться одна
в  другую  (до 16 уровней вложенности). Для каждого {$IFxxx}
соответствующее {$ENDIF} должно находиться в том же исходном
файле,  что  значит, что в каждом исходном файле должно быть
равное количество {$IFxxx} и {$ENDIF}.

                      Условные символы

     Условная компиляция основывается на вычислении условных
символов.  Условные  символы  определяются и разопределяются
(становятся неопределенными) с помощью директив:

     {$DEFINE name}
     {$UNDEF name}

     Вы можете также  воспользоваться  переключателем  /D  в
компиляторе  ТРС  и выбором меню "Опции/Компилятора/Условные
определения" (O/C/Conditional Defines) в интегрированной ин-
терактивной среде.
     Условные символы лучше всего сравнить с булевскими  пе-
ременными:  они  могут  принимать значения True (определено)
или False (неопределено). Директива {$DEFINE}  устанавливает
данный   символ   в  значение  True,  а  директива  {$UNDEF}
устанавливает его в значение False.
     Условные символы следуют точно таким же правилам, что и
идентификаторы Паскаля: они должны начинаться буквой, за ко-
торой следуют сочетания букв, цифр, подчеркиваний. Они могут
иметь любую длину, но только первые 63 знака являются знача-
щими.

           Примечание:  Условные  символы  и  идентификаторы
      Паскаля  не  имеют друг с другом никакой связи. На ус-
      ловные символы не могут осуществляться ссылки  в  дей-
      ствующей  программе,  а  на  идентификаторы  программы
      нельзя осуществлять ссылки в условных директивах. Нап-
      ример, конструкция:

                 const
                   Debug = True;
                 begin
                   {$IFDEF Debug}
                   Writeln('Debug is on');
                   {$ENDIF}
                 end;

      не приведет к компиляции оператора Writeln, также  как
      и конструкция:

                 {$DEFINE Debug}
                 begin
                   if Debug then writeln ('Debug is on');
                 end;

      приведет к ошибке в операторе IF   из-за  неизвестного
      идентификатора.

     В Турбо-Паскале определены следующие стандартные симво-
лы:

     VER50 - Всегда определен, указывая, что  данная  версия
является версией 5.0 Турбо-Паскаля. Другие версии (начиная с
4.0) определяют собственные соответствующие символы  версий,
например, символ VER40 для версии 4.0 и т.д.

     MSDOS - Всегда определен, указывая, что данная операци-
онная  система  является  операционной  системой ДОС. Версии
Турбо-Паскаля для других операционных систем  будут  опреде-
лять символьное имя для конкретной операционной системы.

     CPU86 - Всегда определен, указывая, что процессор  при-
надлежит к семейству процессоров 80х86. Версии Турбо-Паскаля
для других процессоров будут определять символьное  имя  для
конкретного процессора.

     CPU87 - Определен,если числовой сопроцессор  8087  при-
сутствует  во  время  компиляции.  Если  конструкция {$IFDEF
CPU87} {$N+} {$ELSE} {$N-} {$ENDIF} появляется в начале ком-
пиляции, то Турбо-Паскаль автоматически выберет соответству-
ющую модель генерирования кода вычисления с плавающей  запя-
той для этой конкретной ЭВМ.

     Остальные условные символы могут устанавливаться  перед
компиляцией  с помощью меню "Опции/Компилятор/Условные опре-
деления" или с помощью опции /D командной строки (в  случае,
если вы используете ТРС).

                      Директива DEFINE

     Синтаксис: {$DEFINE имя}

     Директива $DEFINE определяет  условный  символ  данного
имени.  Символ  будет определюенным для оставшейся части ис-
ходного компилируемого кода или до тех пор, пока он не  поя-
вится  в  директиве {$UNDEFINE имя}. Директива {$DEFINE имя}
не вызывает никаких действий, если "имя" уже определено.

                      Директива UNDEF

     Синтаксис: {$UNDEF имя}

     Директива $UNDEF отменяет ранее  определенный  условный
символ.  Для  оставшейся части исходного компилируемого кода
или до тех пор, пока он не появится в директиве  {$DEFINE}
символ  отменяется  (становится  неопределенным).  Директива
{$UNDEF} имя не вызывает никакий действий если "имя" уже от-
менено.
                     Директива IFDEF

     Синтаксис: {$IFDEF символ}

     Директива IFDEF компилирует следующий за  ней  исходный
текст, если имя "символ" определено.

                      Директива IFNDEF

     Синтаксис: {$IFNDEF символ}

     Директива IFNDEF компилирует следующий за ней  исходный
текст, если имя "символ" не определено.

                      Директива IFOPT

     Синтаксис: {$IFOPT переключатель}

     Директива IFOPT компилирует следующий  исходный  текст,
если  "переключатель"  находится  в данное время в указанном
состоянии. Переключатель (директива) состоит из имени  опции
переключателя, за которым следует знак плюс (+) или знак ми-
нус (-). Например, конструкция:

     {$IFOPT N+}
       type real = extended;
     {$ENDIF}

скомпилирует описание типа, если опция $N является в  данное
время действующей.

                       Директива ELSE

     Синтаксис: {$ELSE}

     Директива ELSE приводит к компилированию или  игнориро-
ванию  исходного  текста, ограниченного последним {$IFxxx} и
следующим {$ENDIF}.

                      Директива ENDIF

     Синтаксис: {$ENDIF}

     Директива ENDIF заканчивает условную компиляцию,  нача-
тую последней директивой {$IFxxx}.


                        ПРИЛОЖЕНИЕ С

                    Справочные материалы

     Данная часть посвящается некоторым справочным  материа-
лам, включающим в себя таблицу ASCII, коды опроса клавиатуры
и расширенные коды.

                         Коды ASCII

     Американский стандартный  код  для  обмена  информацией
(ASCII)  -  это  код, переводящий алфавитно-цифровые знаки и
символы и управляющие инструкции в семибитовый двоичный код.
Таблица  С.1 показывает как печатаемые символы, так и управ-
ляющие знаки.

                                             Таблица Д.1
------------------------------------------------------------
DEC HEX CHAR    DEC HEX CHAR    DEC HEX CHAR    DEC HEX CHAR
------------------------------------------------------------
 0  0           32  20          64  40  @       96   60  '
 1  1           33  21          65  41  A       97   61  a
 2  2           34  22  "       66  42  B       98   62  b
 3  3           35  23  #       67  43  C       99   63  c
 4  4           36  24  $       68  44  D       100  64  d
 5  5           37  25  %       69  45  E       101  65  e
 6  6           38  26  &       70  46  F       102  66  f
 7  7           39  27  '       71  47  G       103  67  g
 8  8           40  28  (       72  48  H       104  68  h
 9  9           41  29  )       73  49  I       105  69  i
10  A           42  2A  *       74  4A  J       106  6A  j
11  B           43  2B  +       75  4B  K       107  68  k
12  C           44  2C  '       76  4C  L       108  6C  l
13  D           45  2D  -       77  4D  M       109  6D  m
14  E           46  2E  .       78  4E  N       110  6E  n
15  F           47  2F  /       79  4F  O       111  6F  o
16  10          48  30  0       80  50  P       112  70  p
17  11          49  31  1       81  51  Q       113  71  q
18  12          50  32  2       82  52  R       114  72  r
19  13          51  33  3       83  53  S       115  73  s
20  14          52  34  4       84  54  T       116  74  t
21  15          53  35  5       85  55  U       117  75  u
22  16          54  36  6       86  56  V       118  76  v
23  17          55  37  7       87  57  W       119  77  w
24  18          56  38  8       88  58  X       120  78  x
25  19          57  39  9       89  59  Y       121  79  y
26  1A          58  3A  :       90  5A  Z       122  7A  z
27  1B          59  3B  ;       91  5B  [       123  7B  {
28  1C          60  3C  <       92  5C  \       124  7C  |
29  1D          61  3D  =       93  5D  ]       125  7D  }
30  1E          62  3E  >       94  5E  ^       126  7E  ~
31  1F          63  3F  ?       95  5F  _       127  7F
128 80         160  A0         192  C0          224  E0
129 81         161  A1         193  C1          225  E1
130 82         162  A2         194  C2          226  E2
131 83         163  A3         195  C3          227  E3
132 84         164  A4         196  C4          228  E4
133 85         165  A5         197  C5          229  E5
134 86         166  A6         198  C6          230  E6
135 87         167  A7         199  C7          231  E7
136 88         168  A8         200  C8          232  E8
137 89         169  A9         201  C9          233  E9
138 8A         170  AA         202  CA          234  EA
139 8B         171  AB  1/2    203  CB          235  EB
140 8C         172  AC  1/4    204  CC          236  EC
141 8D         173  AD         205  CD          237  ED
142 8E         174  AE         206  CE          238  EE
143 8F         175  AF         207  CF          239  EF
144 90         176  B0         208  D0          240  F0
145 91         177  B1         209  D1          241  F1
146 92         178  B2         210  D2          242  F2
147 93         179  B3         211  D3          243  F3
148 94         180  B4         212  D4          244  F4
149 95         181  B5         213  D5          245  F5
150 96         182  B6         214  D6          246  F6
151 97         183  B7         215  D7          247  F7
152 98         184  B8         216  D8          248  F8
153 99         185  B9         217  D9          249  F9
154 9A         186  BA         218  DA          250  FA
155 9B         187  BB         219  DB          251  FB
156 9C         188  BC         220  DC          252  FC
157 9D         189  BD         221  DD          253  FD
158 9E         190  BE         222  DE          254  FE
159 9F         191  BF         223  DF          255  FF
----------------------------------------------------------
     DEC - десятичный; HEX - шестнадцатиричный; CHAR - знак;

           Примечание: Графические и непечатаемые символы  в
      танной  таблице  не представлены. Полная информация об
      этих символах  приведена  в  "Turbo  Pascal  Reference
      Guide".

                Расширенные коды клавиатуры

     Расширенные коды клавиатуры возвращаются теми клавишами
или  сочетаниями  клавиш, которые не могут быть представлены
стандартными кодами ASCII, приведенными в таблице С.1.
     При возвращении расширенных кодов  в  качестве  первого
знака возвращается нулевой знак, а второй знак - это код оп-
роса первой клавиши. (Описание того, как  можно  определить,
была ли нажата клавиша из расширенного набора, дается в Гла-
ве 16 в описании функции ReadKey).
     В Таблице С.2. показан второй код и то, что он  обозна-
чает.

                                               Таблица C.2.
-----------------------------------------------------------
   Второй код                Значение
-----------------------------------------------------------
   3                         Ноль (нулевой символ)
   15                       Shift Tab
   16-25                     Alt-Q/W/E/R/T/Y/U/I/O/P
   30-38                     Alt-A/S/D/F/G/H/I/J/K/L
   44-50                     Alt-Z/X/C/V/B/N/M
   59-68                     Клавиши F1-F10 (применяются
                             как функциональные клавиши)
   71                        Исходная позиция
   72                        Стрелка вверх
   73                        Страница вверх
   75                        Стрелка налево
   77                        Стрелка направо
   79                        Конец (End)
   80                        Стрелка вниз
   81                        Страница вниз (PgDn)
   82                        Вставка (Ins)
   83                        Удаление (Del)
   84-93                     F11-F20(Shift-F1 по Shift-F10)
   94-103                    F21-F30(Ctrl-F1 по F10)
   104-113                   F31_F40(Alt-F1 поF10)
   114                       Ctrl-PrtSc
   115                       Ctrl-Стрелка влево
   116                       Ctrl-Стрелка вправо
   117                       Ctrl-End
   118                       Ctrl-PgDn
   119                       Ctrl-Home
   120-131                   Alt-1/2/3/4/5/6/7/8/9/0/-/=
   132                       Ctrl-PgDn
   133                       F11
   134                       F12
   135                       Shift-F11
   136                       Shift-F12
   137                       Ctrl-F11
   138                       Ctrl-F12
   139                       Alt-F11
   140                       Alt-F12
------------------------------------------------------------

     Коды опроса клавиатуры - это коды, возвращаемые  клави-
шами на клавиатуре компьютера IBM PC, когда они анализируют-
ся языком Турбо-Паскаль. Эти клавиши бывают полезны, при ра-
боте  на  уровне  языка  ассемблера. Учтите, что коды опроса
клавиатуры, приведенные в Таблице С.3, указаны в  шестнадца-
тиричном виде.

                                                Таблица С.3.
------------------------------------------------------------
Клавиша      Код опроса    Клавиша          Код опроса
            в шестнадца-                    в шестнадцати-
            тиричном виде                   ричном виде
------------------------------------------------------------
 Esc           01          левая(правая)          0F
                           стрелка
 !1            02            Q                    10
 @2            03            W                    11
 #3            04            E                    12
 $4            05            R                    13
 %5            06            T                    14
 ^6            07            Y                    15
 &7            08            U                    16
 *8            09            I                    17
 (9            0A            O                    18
 )0            0B            P                    19
 _-            0C            {[                   1A
 +=            0D            }]                   1B
Возврат на     ОЕ          возврат                1С
одну позицию
 CTRL          1D            /...                 2B
 A             1E            Z                    2C
 S             1F            X                    2D
 D             20            C                    2E
 F             21            V                    2F
 G             22            B                    30
 H             23            N                    31
 J             24            M                    32
 K             25            <,                   33
 L             26            >.                   34
 :;            27            ?/                   35
 "'            28         Правый сдвиг            36
 ~`            29         Prtscr                  37
Левый сдвиг    2А         Alt                     38
Eml^ пробелов  39         Исходная позиция (Home) 47
CapsLock       3A         Стрелка наверх          48
 F1            3B         Страница наверх         49
 F2            3C         Знак минус  (-)         4A
 F3            3D         Стрелка налево          4Е
 F4            3E            5                    4C
 F5            3F         Стрелка направо         4D
 F6            40            +                    4E
 F7            41         Конец (End)             4F
 F8            42         Стрелка вниз            50
 F9            43         Страница вниз           51
 F10           44            0 Ins                52
 F11           D9         Удаление (Del)          53
 F12           DA         Num Lock                45
 Блокировка    46
 прокрутки
-----------------------------------------------------------


                        ПРИЛОЖЕНИЕ D

                  Сообщения и коды ошибок

              Сообщения компилятора об ошибках

     Далее приводятся возможные сообщения об ошибках,  кото-
рые  вы  можете получить от компилятора при разработке прог-
раммы. При наличии возможности компилятор будет выводить  на
экран дополнительную диагностическую информацию в виде иден-
тификатора или имени файла, например,

     Error 15: File not found (WINDOW.TPU) (Ошибка 15:  файл
не найден (WINDOW.TPU).)

     При обнаружении ошибки Турбо-Паскаль (в интегрированной
среде) автоматически загружает исходный файл и помещает кур-
сор около ошибки. Компилятор  ТРС выводит  на  экран сообще-
ние  об  ошибке,  номер  и  исходную  строку,  используя для
указания места ошибки символ каре (^). Учтите, что некоторые
ошибки в исходном тексте до определенного времени не обнару-
живаются. Например, несоответствие типов в операторе присва-
ивания  не  может  быть обнаружено до тех пор, пока не будет
вычислено целиком выражение со знаком :=.  В  таких  случаях
ищите ошибку слева от курсора или в предудущем тексте.

     1 Out memory  (Выход за границы памяти)

     Данная ошибка появляется, если  компилятор  выполняется
вне  допустимых границ памяти. Имеется ряд возможных решений
этой проблемы:
     -     Если     в      меню      "Компиляция/Назначение"
(Compile/Destination) устанавливается значение "память", ус-
тановите  его  в  интегрированной  интерактивной  среде   на
"диск".
     -  Если  буфер  в  меню   "Опция/Компилятор/Компоновка"
(Option/Compiler/Link) в интегрированной интерактивной среде
установлен на "память", установите его на "диск". Можно так-
же поместить директиву {$L-} в начало программы. Используйте
опцию /$L- для связи с диском в компиляторе ТРС.
     - Если вы используете обслуживающие программы,  находя-
щиеся  в  памяти  такие, как, например, SideKick и SuperKey,
удалите их из памяти.
     - Если вы используете TURBO.EXE, по попробуйте заменить
его компилятором ТРС.ЕХЕ. Он занимает меньше памяти.
     Если ни одна из рекомендаций не помогает,  то  возможно
ваша  программа или программный модуль просто слишком велик,
чтобы компилировать его в таком объеме памяти. В этом случае
вы должны разбить его на два или более программных модуля.

     2 Identifier expected (Не указан идентификатор)

     Идентификатор должен находиться в этом месте.  Возможно
вы пытаетесь использовать зарезервированное слово.

     3 Unknown identifier (Неизвестный идентификатор)

     Этот идентификатор не был описан.

     4 Duplicate identifier (Повторный идентификатор)

     5 Syntax error (Синтаксическая ошибка)

     В исходном тексте найден неверный  знак.  Возможно,  вы
забыли заключить в кавычки строковую константу.

     6 Error in  real  constant   (Ошибка  в  действительной
константе).

     Синтаксис констант действительного типа (типа real) оп-
ределяется в Главе 1 ("Символы и константы").

     7 Error in integer constant (Ошибка в целой константе).

     Синтаксис констант типа integer (целое) определяется  в
Главе 1. Учтите, что после целых действительных чисел превы-
шающих диапазон представления целых чисел  должны  ставиться
точка и ноль, например, 12345678912.0.

     8 String constant exceeds  line.  (Строковая  константа
превышает размеры строки)

     Вероятно, вы забыли поставить кавычку в конце строковой
константы.

     9 Too many nested files (Слишком много  вложенных  фай-
лов)

     Компилятор допускает не более пяти  вложенных  исходных
файлов. Но более вероятно, у вас имеется более четырех вклю-
чаемых файлов.

     10 Unexpected end of file (Неправильный конец файла)

     Вы могли получить это сообщение об ошибке по  одной  из
следующих причин:
     - Ваш исходный файл закончился перед последним end  ос-
новного раздела операторов. Вероятно, у вас неодинаковое ко-
личество операторов begin и end.
     - Включаемый файл закончивается в середине раздела опе-
раторов.  Каждый раздел операторов должен целиком помещаться
в одном файле.
     - Вы не закончили комментарий.

     11 Line too long (Строка слишком длинная)

     Максимальная длина строки может равняться 126 символам.

     12 Type identifier expected (Нужен идентификатор типа)

     Не указан тип идентификатора, как это должно быть.

     13 Too many open files (Слишком много открытых файлов)

     Если появляется эта ошибка, то это обозначает, что  ваш
файл CONFIG.SYS не включает параметр FILES=xx или этот пара-
метр указывает слишком мало файлов. Увеличьте  число  файлов
какого-либо подходящего значения, например, 20.

     14 Invalid file name (Неверное имя файла)

     Имя файла неверно или указывает не существующий путь.

     15 File not found (Файл не найден)

     Файл не может быть найден ни в текущем каталоге,  ни  в
каком-либо другом исследуемом каталоге, предназначенному для
этого типа файлов.

     16 Disk full (Диск заполнен)

     Удалите некоторые файлы или воспользуйтесь  новым  дис-
ком.

     17 Invalid compiler directive  (Неправильная  директива
компилятора)

     Неверная буква в директиве компилятора, один  из  пара-
метров  директивы  компилятора  неверный, или вы пользуетесь
глобальной директивой  компилятора,  когда  компиляция  тела
программы уже началась.

     18 Too many files (Слишком много файлов)

     В компиляции программы или программного модуля участву-
ют  слишком  много  файлов.  Попытайтесь не использовать так
много файлов, например, объединяя включаемые файлы или делая
короче имена файлов.

     19 Undefined type in pointer definition (Неопределенный
тип в определении ссылки)

     Была осуществлена ссылка на тип в  описании  ссылочного
типа, приведенном ранее, но он не был описан.

     20 Variable identifier  expected  (Нужен  идентификатор
переменной)

     Идентификатор не описывает переменную, как  это  должно
быть.

     21 Error in type (Ошибка в определении типа)

     Определение типа не может начинаться с этого символа.

     22 Structure too large (Слишком большая структура)

     Максимально допустимый размер структурного типа - 65520
байтов.

     23 Set base type of range (Базовый тип множества  нару-
шает границы)

     Базовый тип множества должен представлять собой отрезок
типа с границами в пределах от 0 до 255 или перечислимым ти-
пом с не более чем 256 значениями.

     24 File components may not be files (Компонентами файла
не могут быть файлы)

     Конструкции типа файл файлов не допускается.

     25 Invalid string length (Неверная длина строки)

     Максимальная описывается длина строки должна находиться
в диапазоне от 1 до 255.

     26 Type mismatch (Несоответствие типов)

     Это модет произойти по следующим причинам:

     - несовместимые типы переменной и выражения в операторе
присваивания;
     - несовместимые типы фактического и  формального  пара-
метров в обращении к процедуре или функции;
     - тип выражения, являющийся не совместимым с типом  ин-
декса при индексировании массива;
     - несовместимые типы операндов в выражении.

     27 Invalid subrange base type (Неправильный базовый тип
отрезка типа)

     Все порядковые типы являются допустимыми базовыми типа-
ми.

     28 Lower bound greater than upper bound (Нижняя граница
больше верхней)

     Описание отрезка типа указывает нижнюю границу большей,
чем верхняя.

     29 Ordinal type expected (Нужен порядковый тип)

     Типы действительные, строковые, структурные типы и ссы-
лочные в данном случае не допускаются.

     30 Integer constant expected (Нужна целая константа)

     31 Constant expected (Нужна константа)

     32 Integer or real constant expected (Нужна  целая  или
действительная константа)

     33 Type identifier expected (Нужен идентификатор типа)

     Данный идентификатор не обозначает тип, как это  требу-
ется.

     34 Invalid function result type (Неправильный  тип  ре-
зультата функции)

     Правильными  типами  результата  функции  являются  все
простые типы, строковые типы и ссылочные типы.

     35 Label identifier expected  (Нужен идентификатор мет-
ки)

     Метка не обозначена с помощью идентификатора,  как  это
требуется.

     36 BEGIN expected (Нужен BEGIN)

     37 END expected (Нужен END)

     38 Integer expression expected  (Нужно  выражение  типа
Integer)

     Предыдущее выражение должно иметь тип Integer.

     39 Ordinal expression expected (Нужно  выражение  пере-
числимого типа)

     Предшествующее выражение должно иметь перечислимый тип.

     40 Boolean expression expected  (Нужно  выражение  типа
Boolean)

     Предшествующее выражение должно иметь тип boolean.

     41 Operand types do not match operator (Типы  операндов
не соответствуют оператору)

     Данный оператор не может быть применен к операндам дан-
ного типа, например, 'A' разделить на '2'.

     42 Error in expression (Ошибка в выражении)

     Данный символ не может участвовать в выражении  указан-
ным образом. Возможно, вы забыли указать операцию между дву-
мя операндами.

     43 Illegal assignment (Неверное присваивание)

     - Файлам и переменным без типа нельзя присваивать  зна-
чения.
     - Идентификатору  функции  можно  присваивать  значения
только внутри раздела операторов данной функции.

     44 Field identifier expected (Нужен идентификато поля)

     Данный идентификатор не упоминает  поле  предшествующей
переменной типа запись.

     45 Object file too large (Объектный файл слишком  боль-
шой)

     Турбо-Паскаль не может компоновать  файлы  .OBJ  больше
64К.

     46 Undefined external (Не определенная внешняя процеду-
ра)

     Внешняя процедура или функция не имеет соответствующего
определения PUBLIC в объектном файле. Убедитесь, что вы ука-
зали все объектные файлы в директивах {$L filename}  и  про-
верьте  написание  идентификаторов  процедуры  или функции в
файле .ASM.

     47 Invalid object file record (Неправильная запись объ-
ектного файла)

     Файл .OBJ содержит неверную  объектныю  запись.  Убеди-
тесь, что данный файл является действительно файлом .OBJ.

     48 Code segment too large (Сегмент кода  слишком  боль-
шой)

     Максимальный размер кода программы или программного мо-
дуля  равняется  65520  байтам.  Если  вы компилируете прог-
раммный модуль, разбейте его на два  или  более  программных
модуля.

     49 Data segment too large (Сегмент данный  слишком  ве-
лик)

     Максимальный размер  сегмента  данных  программы  равен
65520  байтам,  включая  данные,  описываемые  используемыми
программными модулями. Если  вам  нужно  большее  количество
глобальных  данных, опишите большие структуры с помощью ука-
зателей и выделяйте для них  память  динамически  с  помощью
процедуры New.

     50 DO expected (Нужен оператор DO)

     51  Invalid  PUBLIC  definition  (Неверное  определение
PUBLIC)

     - Данный идентификатор получил тип public с помощью ди-
рективы PUBLIC в языке ассемблера, но не соответствует  опи-
санию external в программе или программном модуле Паскаля.
     - Две или более директивы PUBLIC  на  языке  ассемблера
определяют один и тот же идентификатор.
     - Файлы .OBJ определяют символы PUBLIC, не  находящиеся
в сегменте CODE.

     52 Invalid EXTRN definition  (неправильное  определение
EXTRN)

     - Идентификатор осуществил ссылку в языке ассемблера  с
помощью  директивы EXTRN, но это не было описано в программе
или программном модуле на Паскале и не было описано в интер-
фейсной секции используемых программных модулей.

     - Идентификатор обозначает абсолютную переменную.
     - Идентификатор обозначает процедуру или  функцию  типа
inline.

     53 Too many EXTRN definition (Слишком много определений
типа EXTRN)

     Турбо-Паскаль не может обрабатывать файлы .OBJ при  бо-
лее, чем 256 определениях EXTRN.

     54 OF expected (Требуется OF)

     55 INTERFACE expected (Требуется интерфейсная секция)

     56 Invalid relocatable reference (Недействительная  пе-
ремещаемая ссылка)

     - Файл .OBJ содержит данные  и  перемещаемые  ссылки  в
сегментах,  отличных от CODE. Например, вы пытаетесь описать
инициализированные переменные в сегменте DATA.
     - Файл .СOМ содержит ссылки с размерами в байтах на пе-
ремещаемые  символы.  Такая ошибка происходит в случае, если
Вы используете операторы HIGH и DOWN с перемещаемыми  симво-
лами  или если вы ссылаетесь в директивах DB на перемещаемые
символы.
     - Операнд ссылается на перемещаемый символ, который  не
был определен в сегменте CODE или в сегменте DATA.
     - Операнд ссылается  на  процедуру  EXTRN  или  функцию
EXTRN со сдвигом, например, CALL SortProc+8.

     57 THEN expected (Требуется THEN)

     58 TO or DOWNTO expected (Требуется ТО или DOWNTO)

     59 Undefined forward (Не определенное опережающее  опи-
сание)

     - Были описаны процедура  или  функция  в  интерфейсной
секции  программного модуля, но их определение отсутствует в
секции реализации.
     - Процедуры или функции были описаны с помощью опережа-
ющего описание, но их определение не найдено.

     60 Too many procedures  (Слишком много процедур) проце-
дуры или функции

     Турбо-Паскаль не допускает более 512 процедур или функ-
ций  в  одном модуле. Если вы компилируете программу, то по-
местите некоторые процедуры или функции в программные  моду-
ли. Если вы компилируете программный модуль, то разбейте его
на два или несколько программных модуля, процедуры или функ-
ции.
     61 Invalid typecast (неверное преобразование типа)

     - Размеры ссылки на переменную и тип результата отлича-
ются друг от друга при изменении типа переменной.
     - Вы пытаетесь осуществить приведение  типа  выражения,
когда разрешается только ссылка на переменную, процедуру или
функцию.

     62 Division by zero (Деление  на  ноль)

     Предшествующий операция пытается  выполнить деление  на
ноль.

     63 Invalid file type (Неверный файловый тип)

     Данный файловый тип не обслуживается  процедурой  обра-
ботки  файлов.  Например, процедура Readln  используется для
типизованного  файла,  или процедура Seek -  для  текстового
файла.

     64 Cannot Read or Write variables  of  this  type  (Нет
возможности считать или записать переменные данного типа)

     - Процедуры Read и Readln  могут  считывать  переменные
символьного, целого, действительного и строкового типа.
     - Процедуры Write и Writeln могут  выводить  переменные
символьного, целого, действительного, булевского и строково-
го типа.

     65 Pointer variable expected (Нужно использовать  пере-
менную-указатель)

     Предыдущая переменная должна иметь типа указатель.

     66 String variable expected (Нужна  строковая  перемен-
ная)

     Предшествующая переменная должна иметь строковый тип.

     67 String expression expected (Нужно выражение  строко-
вого типа)

     Предшествущее выражение должно иметь строковый тип.

     68 Unit not found (Программный модуль не найден)

     Один или несколько  программных  модулей,  используемых
данным программным модулем, не указаны в операторе uses.

     69 Unit name mismatch (Несоответствие имен  программных
модулей)

     Имя программного модуля, найденное в файле .TPU, не со-
ответствует имени, указанному в операторе uses.

     70 Unit version mismatch (Несоответствие  версий  прог-
раммных модулей)

     Один или  несколько  программных  модулей  используемых
данной  программой,  были изменены после их компиляции. Вос-
пользуйтесь        опцией        "Компиляция/Перекомпиляция"
(Compile/Make) или "Компиляция/Построение" (Compile/Build) в
интегрированной интерактивной среде и опциями /М  или  /В  в
компиляторе  ТРС,  что позволит автоматически скомпилировать
программные модули, нуждающиеся в перекомпиляции.

     71 Duplicate unit name (Повторное имя программного  мо-
дуля)

     Вы уже указали  этот  программный  модуль  в  операторе
uses.

     72 Unit file format error (Ошибка формата  файла  прог-
раммного моуля)

     Файл .TPU является недействительным. Убедитесь, что это
действительно файл .TPU.

     73 Implementation expected (Требуется  секция  реализа-
ции)

     74 Constant and case types do not match (Типы  констант
и тип выражения оператора case не соответсвуют друг другу)

     Тип константы оператора case не совместим с  выражением
в операторе варианта.

     75 Record variable expected (Нужна переменная типа  за-
пись)

     Предшествующая переменная должна иметь тип запись.

     76 Constant out of range (Константа нарушает границы)

     - Вы пытаетесь указать массив с константами, нарущающи-
ми границы.
     - Вы пытаетесь присвоить константу вне диапазона  пере-
менной.
     - Вы пытаетесь передать константу вне диапазона  в  ка-
честве параметра процедуре или функции.

     77 File variable expected (Нужна файловая переменная)

     Прешествующая переменная должна иметь файловый тип.

     78 Pointer expression expected  (Нужно  выражение  типа
указатель)

     Предшествующее выражение должно иметь ссылочный тип.

     79 Integer or real expression expected (Нужно выражение
типа real или integer).

     Предшествующее выражение должно иметь тип  integer  или
real.

     80 Label not withhin current block (Метка не  находится
внутри текущего блока)

     Оператор goto не может ссылаться на метку,  находящуюся
вне текущего блока.

     81 Label already defined (Метка уже определена)

     Данная метка уже помечает оператор.

     82 Undefined label in processing statement part  (Неоп-
ределенная метка в предшествующем разделе операторов)

     Данная метка была  описана,  и  на  нее  осуществлялась
ссылка  в предшествующем разделе операторов, но она не опре-
делена.

     83 Invalid @ argument (Недействительный аргумент опера-
тора @)

     Действительными аргументами являются ссылки на перемен-
ные и идентификаторы процедур или функций.

     84 Unit expected (Нужно UNIT)

     85 ";" expected (Нужно указать ";")

     86 ":" expected (Нужно указать ":")

     87 "," expected (Нужно указать ",")

     88 "(" expected (Нужно указать "(")

     89 ")" expected (Нужно указать ")")

     90 "=" expected (Нужно указать "=")

     91 ":=" expected (Нужно указать ":=")

     92 "[" or "(." expected (Нужно "[" или "(.")

     93 "]" or ".)" expected (Нужно "]" или ".)")

     94 "." expected (Нужно ".")

     95 ".." expected (Нужно "..")

     96 Too many variables (Слишком много переменных)

     - Общий размер глобальных переменных, описанных в прог-
рамме или программном модуле, не может превышать 64К.
     - Размер локальных переменных,  описанных  в  программе
или функции, не может превышать 64 Кбайт.

     97 Invalid FOR control variable (Неправильная управляю-
щая переменная оператора FOR)

     Управляющая переменная оператора FOR должна быть  пере-
менной  перечислимого  типа, определенной в разделе описаний
текущей подпрограммы.

     98 Integer variable expected (Нужна  переменная  целого
типа)

     Предшествующая переменная должна иметь тип integer.

     99 Files are not allowed  here  (Здесь  не  допускаются
файлы)

     Типизированная константа не может иметь файловый тип.

     100 String length mismatch (Несоответствие длины)

     Длина строковй константы  не  соответствует  количеству
элементов символьного массива.

     101 Invalid ordering of fields (Неверный порядок полей)

     Поля в константе типа запись должны записываться в  по-
рядке их описания.

     102 String constant expected (Нужна константа строково-
го типа)

     103 Integer or real variable expected (Нужна переменная
типа integer или real)

     Предшествующая переменная должна иметь  целый  или  ве-
щественный тип.

     104 Ordinal variable expected (Нужна  переменная  пере-
числимого типа)

     Предшествующая  переменная  должна  иметь  перечислимый
тип)

     105 INLINE error (Ошибка в операторе INLINE)

     Оператор < не допускается в сочетании  с  перемещаемыми
ссылками  на  переменные. Такие ссылки всегда имеют размер в
слово.

     106 Character expression expected (Предшествующее выра-
жение должно иметь символьный тип)

     107 Too many relocation items (Слишком много перемещае-
мых элементов)

     Размер раздела таблицы перемещения файла .ЕХЕ превышает
64К,  что является верхним пределом в Турбо-Паскале. Если вы
обнаружили эту ошибку, то это значит, что  программа  просто
слишком  велика для обработки редактором связей Турбо-Паска-
ля. Возможно также, что она слишком  велика  для  выполнения
ДОС. В таком случае нужно выделить в программе раздел "main"
(основной), который выполнял бы два или  несколько  разделов
"subprogram" (подпрограмм), используя процедуру Ехес в моду-
ле Dos.

     108 (*) Not enough memory to run program  (Недостаточно
памяти для выполнения программы)

     Недостаточно памяти для выполнения программы  из  среды
TURBO.  Если  вы  используете обслуживающие программы памяти
(SideKick и SuperKey), то удалите их. Если это  не  поможет,
то  скомпилируйте свою программу на диск и выйдете из TURBO,
чтобы ее выполнить.

     109 (*) Cannot find EXE  file  (Нет  возможности  найти
файл .ЕХЕ)

     По какой-то причине файл  .ЕХЕ,  сгенерированный  ранее
компилятором, исчез.

     110 (*) Cannot run a unit (Модуль выполнять нельзя)

     Вы не можете выполнить программный модуль. Чтобы прове-
рить  его, напишите программу, использующую этот программный
модуль.

     111 (*) Compilation aborted (Компиляция прервана)

     Компиляция была прервана с помощью клавиш Ctrl-Break.

     112 CASE constant out of range (Константа CASE нарушает
допустимые границы)

     Целочисленные константы оператора case должны находить-
ся в диапазоне от -32768 до 32767.

     Для операторов case типа integer константы должны нахо-
диться внутри диапазона - 32768 - 32767.

     113 Error in statement (Ошибка в операторе)

     Данный символ не может быть первым символом в  операто-
ре.

     114 Cannot call an interrupt procedure (Нет возможности
вызвать процедуру прерывания)

     Вы не можете непосредственно вызвать процедуру  преры-
вания.

     115 (*) Must have an 8087 to compile this (Для компиля-
ции необходимо наличие сопроцессора 8087)

     Компилятор требует для компилирования программ и  прог-
раммных модулей  режиме {$N+} наличия сопроцессора 8087.

     116 Must be in 8087 mode tp compile this (Для  компиля-
ции необходим режим 8087)

     Данная конструкция может быть скомпилирована  только  в
режиме  {$N+}.  В состоянии {$N-} операции с действительными
типами, одиночной и двойной точности, расширенными и совмес-
тимыми не допускаются.

     117 Target address not found (Адрес назначения не  най-
ден)

     Команда "Компиляции/Поиск ошибки" (Compile/Find  error)
в  интегрированной интерактивной среде или опции /F в коман-
дной строке компилятора не  позволяют  обнаружить  оператор,
соответствующий указанному адресу.

     118 Include files are not allowed here (В такой  ситуа-
ции включаемые файлы не допускаются)

     Каждый раздел операторов должен целиком  размещаться  в
одном файле.

     119 (*) TMP file format error   (Ошибка  формата  файла
.ТМР)

     Файл .ТМР является недействительным. Убедитесь, что это
файл является в действительности файлом .ТМР.

     120 NIL expected (Нужен NIL)

     121 Invalid qualifier (Неверный квалификатор)

     - Вы пытаетесь индексировать переменную, которая не яв-
ляется массивом.
     - Вы пытаетесь указать поля в  переменной,  которая  не
является записью.
     - Вы пытаетесь разыменовать переменную, которая не  яв-
ляется указателем.

     122 Invalid variable reference (Недействительная ссылка
на переменнную)

     Предыдущая конструкция удовлетворяет синтаксису  ссылки
на  переменную,  но  она не указывает адрес памяти. Наиболее
вероятно, что вы вызываете функцию-указатель,  но  забываете
разыменовать результат.

     123 Too many symbols (Слишком много символов)

     Программа или программный модуль  описывает  более  64К
символов. Если вы компилируете программу с помощью директивы
{$D+}, то попробуйте отключить эту директиву.  Учтите, одна-
ко, что  это не гарантирует отсутствие ошибок времени выпол-
нения в таком модуле. В противном случае вы можете попытать-
ся поместить некоторое описание в отдельный модуль.

     124 Statement part too large  (Слишком  большой  раздел
операторов)

     Турбо-Паскаль ограничивает размер раздела операторов до
величины примерно 24К. Если вы обнаружили эту ошибку, помес-
тите части разделов оператора в одну или несколько процедур.
В любом случае при наличии раздела операторов такого размера
стоит усилий сделать более ясной о понятной  структуру своей
программы.

     125 Mudule has no debug information (В модуле нет отла-
дочной информации)

     Ошибка  времени  выполнения,  обнаружившаяся  в  модуле
(программе  или программном модуле),  который не имеет отла-
дочной информации, и по этой причине Турбо-Паскаль не  может
указать  соответствующий оператор. Перекомпилируйте модуль с
включенной опцией D и воспользуйтесь меню  "Компиляция/Поиск
ошибки" (Сompile/Find Error), чтобы найти эту  ошибку в  ин-
тегрированной среде, или опцией /F в компиляторе ТРС.

     126 Files must be var parameters  (Файлы  должны  иметь
параметры var)

     Вы пытаетесь описать параметр значения файлового  типа.
Параметры  файлового типа должны быть параметрами-переменны-
ми.

     127 Too many conditional symbols (Слишком много  услов-
ных символов)

     Осутствует место для определения условных символов. По-
пытайтесь  удалить некоторые символы или сократить некоторые
из символьных имен.

     128 Misplaced conditional directive (Пропущена условная
директива)

     Компилятор обнаружил директиву {$ELSE} или {$ENDIF} без
соответствующих директив {$IFDEF}, {$IFNDEF} или {$IFOPT}.

     129 ENDIF directive missing (Пропущена директива ENDIF)

     Исходный файл закончился  внутри  конструкции  условной
компиляции.  В  исходном файле должно быть равное количество
директив {$IFxxx} и {$ENDIF}.

     130 Error in initial conditional defines (Ошибка в  на-
чальном условных определениях)

     Исходные условные символы, указанные в меню "О/К/Услов-
ные  определения"  (O/C/Conditional Defines) или в директиве
/D являются недействительными.
     Турбо-Паскаль требует нуля или  более  идентификаторов,
разделенных пробелами, запятыми или точками с запятыми.

     131 Header does not match previous definition  (Заголо-
вок не соответствует предыдущему определению)

     - Заголовок процедуры или функции, указанный  в  интер-
фейсной  секции, не соответствует самому заголовку процедуры
или функции.
     - Заголовок процедуры или функции, указанный в опережа-
ющем описании (описании forward),  не  соответствует  самому
заголовку процедуры или функции.

     131 Critical disk error (Критическая ошибка диска)

     Во время компиляции произошла критическая ошибка  диска
(например, дисковод находится в состоянии "не готов").

     132 Cannot evaluate this expression  (Нельзя  вычислить
данное выражение)

     В выражении-константе или в обладочном выражении вы пы-
таетесь  использовать неподдерживаемые средства, например, в
описании константы пытаетесь использовать  функцию  Sin  или
вызвать  в  отладочном  выражении определенную пользователем
функцию. Описание допустимого синтаксиса  выражения-констаты
содержится  в  Главе 1 ("Символы и константы"). Описание до-
пустимого синтаксиса отладочных выражений содержится в Главе
7 "Руководства пользователя" ("Отладка программ Турбо-Паска-
ля").

     134 Expression incorrectly terminated (Некорректное за-
вершение выражения)

     Турбо-Паскаль ожидает в данном месте найти конец  выра-
жения или оператор, но не находит ни того, ни другого.

     135 Invalid  format  specifier  (Неверный  спецификатор
формата)

     Используется неверный спецификатор формата или числовой
аргумент  спецификатора  формата  выходит за допустимые гра-
ницы. Список допустимых спецификаторов формата содержится  в
Главе  7  "Руководства пользователя" ("Отладка программ Тур-
бо-Паскаля").

     136 Invalid indirect reference (Недопустимая  косвенная
ссылка)

     Оператор пытается  осуществить  недопустимую  косвенную
ссылку.  Например, вы используете абсолютную переменную, ба-
зовая переменная которой в текущем  модуле  неизвестна,  или
используете программу типа inline, в которой делается ссылка
на переменную, неопределенную в текущем модуле.

     137 Structured variable are not allowed here (Здесь  не
допускается использование структурной переменной)

     Делается попытка выполнить над  структурной  переменной
неподдерживаемую  операцию.  Например, вы пытаетесь перемно-
жить две записи.

     138 Cannot evaluate without System unit (Нельзя  вычис-
лить без блока System)

     Чтобы  отладчик  смог  вычислить  выражение,  в   файле
TURBO.TPL должен содержаться модуль System.

     139 Cannot access this symbol (Доступ к данному символу
отсутствует)

     Как только вы скомпилируете программу, все множество ее
символов  становится  доступным. Однако к отдельным символам
(например, к переменным) нельзя получить доступ, пока вы  не
запустите программу.

     140 Invalid floating-point operation (Недопустимая опе-
рация с плавающей запятой)

     При операции с двумя  действительными  значениями  было
получено переполнение или деление на ноль.

     141 Cannot compile overlay to memory (Нельзя выпольнить
компиляцию оверлеев в память)

     Программа, использующая оверлеи, должна компилироваться
на диск.

     142 Procedure or function variable expected (Должна ис-
пользоваться переменная-процедура или функция)

     В этом контексте оператор получения адреса @ может  ис-
пользоваться только с переменной-процедурой или функцией.

     143 Invalid procedure or function reference (Недопусти-
мая ссылка на процедуру или функцию)

     - Попытка вызова процедуры или функции в выражении.
     - Если их нужно присвоить переменной-процедуре,  проце-
дура  или функция должны компилироваться в состоянии {$F+} и
не могут описываться с  помощью  ключевых  слов  inline  или
interrupt.

     144 Cannot overlay this unit (Этот модуль не сожет  ис-
пользоваться в качестве оверлейного)

     Попытка использовать в качестве оверлейного модуль, ко-
торый не был скомпилирован с директивой {$O+}.

     Ошибки, возникающие во время выполнения программы

     Некоторые ошибки времени выполнения  приводят  к  тому,
что  программа выводит на экран сообщение об ошибке и завер-
шает свою работу:

     Runtime error nnn at xxxx:yyyy (Ошибка времени выполне-
ния nnn по адресу xxxx:yyyy)

где nnn - номер ошибки времени выполнения, а xxxx:yyyy - это
адрес ошибки времени выполнения (сегмент и смещение). Ошибки
времени выполнения делятся на  две  категории:  ошибки  вво-
да-вывода  (коды  ошибок  с  1 до 199) и грубые ошибки (коды
ошибок с 200 до 255).

                    Ошибки ввода-вывода

     Эти ошибки вызывают завершение выполнения  программы  в
случае,  если конкретный оператор был скомпилирован в режиме
{$I+}. В режиме {$I-}  программа  продолжает  выполнение,  а
ошибка описывается функцией IOResult. Коды ошибок 1-99 соот-
ветствуют кодам ошибок ДОС, 100-149 - ошибкам  ввода-вывода,
150-199  -  критическим ошибкам, а 200-255 - фатальным ошиб-
кам.

     1 File not found (Не найден файл)

     Ошибка генерируется процедурами Reset,  Append,  Rename
или  Erase  в случае, если имя присвоенное файловой перемен-
ной, указывает несуществующий файл.

     3 Path not found (Маршрут не найден)

     - Ошибка генерируется процедурами Reset,  Rewrite,  Ap-
pend или Erase в случае, если имя присвоенное файловой пере-
менной, является недействительным или указывает на несущест-
вующий подкаталог.
     - Описывается ChDir, MkDir или  RmDir  в  случае,  если
маршрут является недействительным или указывает несуществую-
щий подкаталог.

     4 Too many open files (Слишком много открытых файлов)

     Ошибка  генерируется  процедурами  Reset,  Rewrite  или
Append в случае, если программа имеет слишком много открытых
файлов. Операционная система ДОС не  позволяет  использовать
более 15 открытых файлов для каждого процесса. Если вы полу-
чили эту ошибку при наличии менее 15 открытых файлов, то она
может указывать на то, что файл CONFIG.SYS не включает пара-
метров FILES=xxx или что этот параметр задает  слишком  мало
файлов.  Увеличьте  число  файлов до какого-либо подходящего
значения, например, до 20.

     5 File access defined (Отказано в доступе к файлу)

     -  Данная  ошибка  генерируется  процедурой  Reset  или
Append  в  случае,  если  FILEMode  допускает запись, а имя,
присвоенное   файловой  переменной,  указывает  каталог  или
файл, доступные только для чтения.
     - Данная ошибка генерируется процедурой Rewrite в  слу-
чае, если каталог заполнен, или если имя, присвоенное файло-
вой переменной, задает каталог или сущестующий файл, доступ-
ный только для чтения.
     - Данная ошибка генерируется процедурой Rename  в  слу-
чае,  если  имя,  присвоенное файловой переменной, указывает
каталог или если новое имя указывает существующий файл.
     - Данная ошибка генерируется процедурой Erase в случае,
если имя, присвоенное файловой переменной, указывает каталог
или файл, доступный только для чтения.
     - Данная ошибка генерируется процедурой MkDir в случае,
если файл с тем же именем уже существует в порождающем ката-
логе, если нет места в порождающем каталоге или если маршрут
задает устройство.
     - Данная ошибка генерируется процедурой RmDir в случае,
если каталог не является, пустым, если маршрут не определяет
каталог, или если маршрут задает корневой каталог.
     -  Данная  ошибка  генерируется  процедурой  Read   или
BlockRead  в случае типизированного или нетипизованного фай-
ла, если файл не открыт для чтения.
     -  Данная  ошибка  генерируется  процедурой  Write  или
BlockWrite  для  типизованного  или  нетипизованного файла в
случае, если этот файл не открыт для записи.

     6 Invalid file handle (Недопустимый файловый канал)

     Данная ошибка генерируется в случае  системному  вызову
ДОС  передается недопустимый файловый канал. Эта ошибка воз-
никать не должна. Если же она появляется,  то  это  является
свидетельством того, что файловая переменная является испор-
ченной каким-либо образом.

     12 Invalid file access code (Недействительный код  дос-
тупа к файлам)

     Ошибка генерируется процедурами Reset или Append в фай-
ле  с  типом  или  без типа в случае, если значение FileMode
является не действительным.

     15 Invalid drive number (Недопустимый номер дисковода)

     Ошибка генерируется процедурой GetDir  в  случае,  если
номер дисковода является недопустимым.

     16 Cannot remove current directory (Нельзя удалить  те-
кущий каталог)

     Ошибка генерируется процедурой  RmDir  в  случае,  если
путь указывает текущий каталог.

     17 Cannot rename across drives (Нельзя при переименова-
нии указывать разные дисководы)

     Описывается Rename в случае, если оба файла не находят-
ся на одном и том же диске.

                    Ошибки ввода-вывода

     Если один из  операторов  компилировался  с  директивой
{$I+}, то эта ошибка приводит к прекращению выполнения прог-
раммы. В состоянии {$I-} программа продолжает выполняться, а
ошибка генерируется функцией IOResult.

     100 Disk read error (Ошибка чтения диска)

     Описывается Read в типизированном файле в случае,  если
вы пытаетесь осуществить считывание после конца файла.

     101 Disk write error (Ошибка записи на диск)

     Ошибка генерируется процедурами Close, Write,  Writeln,
Flush или Page в случае, если диск заполнен.

     102 File not assigned (Файлу не присвоено имя)

     Ошибка генерируется процедурами Reset, Rewrite,  Append
Rename  и  Erase  в случае, если файловой переменной не было
присвоено имя с помощью обращения к процедуре Assign.

     103 File not open (Файл не открыт)

     Ошибка генерируется  процедурами  Close,  Read,  Write,
Seek,   Eof,   FilePos,   FileSize,   Flush,  BlockRead  или
BlockWrite в случае, сели файл не открыт.

     104 File not open for input (Файл не открыт для ввода)

     Ошибка  генерируется  процедурами  Read,  Readln,  Eof,
Eoln,  SeekEof или SeekEoln в текстовом файле в случае, если
файл не открыт для ввода.

     105 File not open for output (Файл не открыт для  выво-
да)

     Ошибка генерируется процедурами Write, Writeln и Page в
текстовом файле в случае, если файл не открыт для вывода.

     106 Invalid numeric format (Неверный числовой формат)

     Описывается Read или Readln  в  случае,  если  числовое
значение,  считанное  из  текстового файла, не соответствует
правильному числовому формату.

                     Критические ошибки

     150 Disk is write protected (Диск защищен от записи)

     151 Unknown unit (Неизвестный модуль)

     152 Drive not ready (Дисковод находится в состоянии "не
готов")

     153 Unknown command (Неопознанная команда)

     154 CRC error in data (Ошибка в исходных данных)

     155 Bad drive requiest structure length (При запросе  к
диску указана неверная длина структуры)

     156 Disk seek error (Ошибка при операции установки  го-
ловок на диске)

     157 Unknown media type (Неизвестный тип носителя)

     158 Sector not found (Сектор не найден)

     159 Printer out of paper (Кончилась бумага  на  устрой-
стве печати)

     160 Device write fault (Ошибка при  записи  на  устрой-
ство)

     161 Device read fault (Ошибка при чтении с устройства)

     162 Hardware failure (Сбой аппаратуры)

     Более подробная информация о критических ошибках приве-
дена  в  "Руководстве  программиста  по операционной системе
ДОС".

                      Фатальные ошибки

     Эти ошибки  всегда  приводят  к  немедленной  остановке
программы.

     200 Division by zero (Деление на ноль)

     201 Range check error (Ошибка при проверке границ)

     Ошибка генерируется процедурами операторами,  скомпили-
рованными  в состоянии {$R+},при возникновении одной из сле-
дующих ситуаций:

     - индексное выражение квалификатора массива  находилось
вне допустимого диапазона;
     - была осуществлена попытка присвоить переменной значе-
ние, находящееся вне диапазона переменной;
     - была осуществлена попытка передать значение,  находя-
щееся  вне допкустимого диапазона, в качестве параметра про-
цедуре или функции.

     202 Stack overflow error (Переполнение стека)

     Эта ошибка генерируется на входе в процедуру или  функ-
цию,  скомпилированные  в  режиме  {$S+}, в случае, если нет
достаточной области для размещения локальных переменных под-
программы.  Увеличьте размер стека, используя директиву ком-
пилятоа $M.

     203 Heap overflow error (Переполнение динамически расп-
ределяемой области памяти)

     Эта ошибка генерируется процедурами New или  GetMem,  в
том  случае,  если нет достаточно свободного места в динами-
ческой области памяти, чтобы выделить память для блока  тре-
буемого  размера. Полное описание программы управления дина-
мически распределяемой областью памяти содержится в Главе 15
("В среде Турбо-Паскаля").

     204 Invalid pointer operation (Недействительная  опера-
ция ссылки)

     Эта ошибка генерируется процедурами Dispose или FreeMem
в  случае,  если  ссылка имеет значение nil или указывает на
адрес, лежащий за пределами динамически  распределяемой  об-
ласти или если свободный список не может быть расширен.

     205 Floating point overflow (Переполнение при  операции
с плавающей запятой)

     Операция с плавающей запятой привела к переполнению.

     206 Floating point underflow  (Исчезновение  порядка  с
при операции с плавающей запятой)

     Операция с плавающей запятой привела к исчезновению по-
рядка.  Эта ошибка генерируется только в том случае, если вы
используете сопроцессор математических вычислений 8087 с уп-
равляющим  словом,  которое  демаскирует ошибки, возникающие
при исчезновении порядка. По умолчанию исчезновение  порядка
приводит к возвращению результата равного нулю.

     207 Invalid floating point operation (Недопустимая опе-
рация с плавающей запятой)

     -  Действительное  значение,  передаваемое  Trunc   или
Round,  не может быть преобразовано в целое число, находяще-
еся  внутри  диапазона  типа  longint  (от  -2147483648   до
2147483647).
     -  Аргумент,  передаваемый  функцией  Sqrt  (Извлечение
квадратного корня), отрицательный.
     - Аргумент, передаваемый функцией Ln (логарифм),  равен
нолю или имеет отрицательное значение.
     - Произошло переполнение стека 8087. Более  подробно  о
правилах программирования 8087 смотрите в части 25.

     208 Overlay manager not installed (Не установлена  под-
система управления оверлеями)

     Ваша программа вызывает оверлейную процедуру или  функ-
цию,  а подсистема управления оверлеями не инициализирована.
Вероятнее всего отсутсвует обращение  к  процедуре  OvrInit,
или  обращение к этой процедуре завершилось с ошибкой. Нужно
иметь в виду, что если в каком-либо из оверлейных модулей  у
вас  содержится  код инициализации, то вы должны создать до-
полнительный  неоверлейный  модуль,   вызывающий   процедуру
OvrInit,  и использовать этот модуль перед любым из оверлей-
ных модулей. Полное описание подсистемы управления оверлеями
содержится в Главе 6 "Руководства пользователя ("Использова-
ние оверлеев").

     209 Overlay file read error (Ошибка чтения  оверлейного
файла)

     Когда подсистема управления оверлеями пыталась  считать
оверлей из оверлейного файла, произошла ошибка чтения.



