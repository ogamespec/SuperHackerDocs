------------------------------------------------------------
 Процедура GetTime                               Модуль Dos
------------------------------------------------------------
     Функция: Возвращает установленное в операционной систе-
ме текущее время.
     Описание: GetTime(var час, минута, секунда,  сот_сек  :
word)
     Примечания: Возвращаемые параметры принимают  следующие
значения: "час" - от 0 до 23, "минута" - от 0 до 59, "секун-
да" - от 0 до 59 и "сот_сек" (сотая доля секунды) - от 0  до
99.
     Прочее: См. также процедуры SetTime, GetDate, SetDate.

------------------------------------------------------------
 Процедура GetVerify                             Модуль Dos
------------------------------------------------------------
     Функция: Возвращает состояние флага проверки ДОС.
     Описание: GetVerify(var флаг_проверки : boolean)
     Примечания: Данная процедура возвращает состояние флага
проверки  ДОС. При сброшенном флаге (False) проверка при за-
писи на диск не выполняется. При установленном флаге  (True)
для  обеспечения  правильности записи все операции записи на
диск проверяются.
     Прочее: См. также процедуру SetVerify.

------------------------------------------------------------
 Процедура GetViewSettings                     Модуль Graph
------------------------------------------------------------
     Функция: Позволяет пользователю выдать запрос о текущей
области просмотра на экране и параметрах "вырезанного" изоб-
ражения.
     Описание: GetViewSettings(var ViewPort : ViewPortType)
     Примечания: Данная процедура возвращает переменную типа
ViewPortType. Этот тип предварительно описан следующим обра-
зом:

  type
    ViewPortType = record
                     x1, y1, x2, y2: integer;
                     Clip : boolean;
                   end;
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Точки (x1,y1) и (x2,y2) представляют собой размеры  ак-
тивной  области  просмотра. Параметр Clip представляет собой
переменную булевского типа и указывает на наличие  "вырезан-
ного" (отсеченного за заданными границами) изображения.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуру SetViewPort.
     Пример:

  uses
    Graph;
  var
    Gd, Gm : integer;
   ViewPortType = ViewPortType;
  begin
    Gd := Detect;  { перевести в графический режим }
    InitGraph(Gd, Gm, '');
    if GraphResult < 0 then
       Halt(1);
    GetViewSettings(ViePort);
    with ViewPort do
    begin
      Rectangle(0, 0, x2 - x1, y2 - y1);
      if Clip then
         OutText('Отсечение изображения не активно');
      else
      OutText('Сегодня отсечение изображения не действует');
     end;
     Readln;
     CloseGraph;
  end.

------------------------------------------------------------
 Функция GetX                                Модуль Graph
------------------------------------------------------------
     Функция:  Возвращает  Х-координату  текущего  указателя
(СР).
     Описание: GetX
     Тип результата: Целый (integer).
     Примечания: Процедура GetХ зависит от области  просмот-
ра. Таким образом, ее значение всегда равно абсолютной Х-ко-
ординате СР, минус ViewPort.х1. В следующем примере:

 1 SetViewPort(0,0,GetMaxX,GetMaxY,True);
 2 MoveTo(5,5);
 3 SetViewPort(10,10,100,100,True);
 4 MoveTo(5,5);

     - в строке 1 СР перемещается в точку с абсолютными  ко-
ординатами (0,0), и процедура GetХ также возвращает значение
0;
     - в строке 2 СР перемещается в точку с абсолютными  ко-
ординатами (5,5), и процедура GetХ также возвращает значение
5;
     - в строке 3 СР перемещается в точку с абсолютными  ко-
ординатами (10,10), но процедура GetХ возвратит значение 0;
     - в строке 4 СР перемещается в точку с абсолютными  ко-
ординатами (15,15), но процедура GetХ возвратит значение 5.
     Аналогичная функция имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры GetViewSettings, GetY,  In-
itGraph, MoveTo, SetViewPort.
     Пример:

  uses Graph;
  var
    GraphDriver, GraphMode : integer;
    x, y : integer;
  begin
    GraphDiver := Detect;
    InitGraph(GraphDriver,GraphMode,'');
    if Graphesult <> grOk then
       Halt(1);
    OutText('Начнем здесь.');
    x := GetX;
    y := GetY;
    OutText(20,10,'Теперь перейдем сюда...');
    OutText(x,y,'А теперь вернемся назад.');
    Readln;
    CloseGraph;
  end.

------------------------------------------------------------
 Функция GetY                                  Модуль Graph
------------------------------------------------------------
     Функция:  Возвращает  Y-координату  текущего  указателя
(СР).
     Описание: GetY
     Тип результата: Целый (integer).
     Примечания: Процедура GetY зависит от области  просмот-
ра. Таким образом, ее значение всегда равно абсолютной Х-ко-
ординате СР, минус ViewPort.у1. В следующем примере:

 1 SetViewPort(0,0,GetMaxX,GetMaxY,True);
 2 MoveTo(5,5);
 3 SetViewPort(10,10,100,100,True);
 4 MoveTo(5,5);

     - в строке 1 СР перемещается в точку с абсолютными  ко-
ординатами (0,0), и процедура GetY также возвращает значение
0;
     - в строке 2 СР перемещается в точку с абсолютными  ко-
ординатами (5,5), и процедура GetY также возвращает значение
5;
     - в строке 3 СР перемещается в точку с абсолютными  ко-
ординатами (10,10), но процедура GetY возвратит значение 0;
     - в строке 4 СР перемещается в точку с абсолютными  ко-
ординатами (15,15), но процедура GetY возвратит значение 5.
     Аналогичная функция имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее:  См.  также  процедуры  GetViewSettings,  GetX,
InitGraph, MoveTo, SetViewPort.

     Пример:

  uses Graph;
  var
    GraphDriver, GraphMode : integer;
    x, y : integer;
  begin
    GraphDiver := Detect;
    InitGraph(GraphDriver,GraphMode,'');
    if Graphesult <> grOk then
       Halt(1);
    OutText('Начнем здесь.');
    x := GetX;
    y := GetY;
    OutText(20,10,'Теперь перейдем сюда...');
    OutText(x,y,'А теперь вернемся назад.');
    Readln;
    CloseGraph;
  end.

------------------------------------------------------------
 Процедура GotoXY                                Модуль Сrt
------------------------------------------------------------
     Функция: Позиционирует курсор.
     Описание: GoToXY(x, Y : byte)
     Примечания: корсор перемещается в ту позицию внутри те-
кущего  окна,  которая  задана  координатами Х и Y (Х задает
столбец, Y задает строку). Верхний левый угол задается  кор-
динатами (1,1).
     Эта процедура зависит от текущего окна. Например:

     Window(1,10,60,20);
     GotoXY(1,1);

переместит курсор в верхний левый угол активного окна (абсо-
лютные координаты (1,10)).
     Ограничения: Если задаются недопустимые координаты,  то
обращение к процедуре игнорируется.

     Прочее: См. также процедуры Window, WhereX, WhereY.

------------------------------------------------------------
 Процедура GraphDefaults                       Модуль Graph
------------------------------------------------------------
     Функция:  Сбрасывает  установленные   для   графических
средств параметры.
     Описание: GraphDefaults
     Примечания: Возвращает текущий указатель в нулевую точ-
ку и устанавливает для графической системы параметры:
     - область просмотра;
     - палитру;
     - фоновый и основной цвет;
     - тип линии и образец линии;
     - тип заполнителя, образец заполнителя и цвет  заполни-
теля;
принятые по умолчанию.
     Аналогичная программа имеется в версии 2.0 Турбо-Си.

------------------------------------------------------------
 Функция GraphErrorMsg                         Модуль Graph
------------------------------------------------------------

     Функция: Для заданного кода ошибки  (ErrorCode)  выдает
строку сообщения об ошибке.
     Описание: GraphErrorMsg(ErrorCode : integer)
     Тип результата: Строковый (string).
     Примечания: Данная функция возвращает строку,  содержа-
щую  сообщение об ошибке, соответствующее коду ошибки графи-
ческой системы. Это облегчает вывод описывающего ошибку  со-
общения в пользовательской программе. Например:

 "Device driver not found" (не  найден  драйвер  устройства)

вместо:

     "error code - 3" (од ошибки - 3).

     Ограничения: Должен использоваться графический режим.
     Прочее: См. также  процедуры GraphResult,  DetectGraph,
InitGraph.
     Пример:

  uses Graph;
  var
    GraphDriver, GraphMode : integer;
    ErrorCode : integer;
  begin
    GraphDiver := Detect;
    InitGraph(GraphDriver,GraphMode,'');
    if Graphesult <> grOk then
       Halt(1);
    begin
      Writeln('Ошибка графики: ',GraphErrorMsg(ErrorCode);
      Readln;
      Halt(1);
    end;
     Line(0, 0, GetMaxX, GetMaxY);
     Readln;
     CloseGraph;
  end.

------------------------------------------------------------
 Функция GraphResult                           Модуль Graph
------------------------------------------------------------
     Функция: Возвращает для последней графической  операции
код ошибки.
     Описание: GraphResult
     Тип результата: Целый (integer).
     Примечания: Возвращает код ошибки для последней  графи-
ческой операции. Определены следующие коды ошибок:

      0 нет ошибки;
     -1 (ВСI) графика не установлена (используйте  процедуру
InitGraph);
     -2 графическая аппаратура не найдена;
     -3 драйвер графического устройства не найден;
     -4 неверный файл драйвера графического устройства;
     -5 не хватает памяти для загрузки драйвера;
     -6 выход за границы памяти при просмотре  области  зак-
раски;
     -7 выход за границы памяти при закрашивании;
     -8 файл шрифта не найден;
     -9 не хватает памяти для загрузки шрифта;
     -10 недопустимый графический режим для выбранного драй-
вера.

     Код ошибки устанавливается следующими процедурами:

     DetectGraph, InitGraph, FloodFill, FillPoly,  DrawPoly,
Bar,  Bar3D,  PieSlice,  ClearViewPort,  SetTextStyle,  Set-
GrphMode,  CloseGraph,,  DetectGraph,  FillPoly,  FloodFill,
GetGraphMode, ImageSize, InstallUserDriver, InstallUserFont,
PieSlice, RegisterBGIDriver,RegisterBGIFont,  SetAllPalette,
SetFillPattern, SetFillStyle, SetGraphBufSize, SetGraphMode,
SetLineStyle, SetPalette, SetTextJustify.

     Заметим, что GraphResult (код ошибки) сбрасывается в  0
после  обращения  к  данной  процедуре  (аналогично  функции
IOResult). Таким образом пользователю следует сохранить зна-
чение  кода ошибки во временной переменной и затем проверить
ее. Определены следующие константы:

-----------------------------------------------------------
 Константа                  Код        Соответствующее
ошибки графики            ошибки       сообщение об ошибке
------------------------------------------------------------

  grOk                         =  0; { нет ошибки }
  grNoInitGraph                = -1; { графика не инициали-
                                       зована }
  grNotDetected                = -2; { графические средства
                                       не найдены }
  grFileNotFound               = -3; { файл не найден }

  grInvalidDriver              = -4; { недопустимый
                                       драйвер }
  grNoLoadMem                  = -5; { память не загружена }
  grNoScanMem                  = -6; { ошибка при просмотре
                                       памяти }
  grNoFloodMem                 = -7; { ошибка при зараске }
  grFontNotFound               = -8; { шрифт не найден }
  grNoFontMem                  = -9; { шрифт не загружен в
                                       память }
  grInvalidMode                = -10; { недопустимый режим }
  grError                      = -11; { ошибка графики }
  grIOError                    = -12; { ошибка ввода-вывода
                                        графики }
  grInvalidFont                = -13; { недопутимый файл
                                        шрифта }
  grInvalidFontNum             = -14; { недопустимый номер
                                        шрифта }
------------------------------------------------------------

     Ограничения: Предусмотрена строковая  функция  GraphEr-
rorMsg, которая возвращает строку сообщения, соответствующе-
го каждому коду ошибки.
     Прочее: См. также функцию MraphErrorMsg.
     Пример:

  uses
   Graph;
  var
   ErrorCode : integer;
   GrDriver, GrMode : integer;
  begin
    GrDriver := Detect;
    InitGraph(GrDriver,GrMode);
    ErrorCode := Grapesult;  { провера на ошибки }
    if ErorCode <> grOk then
    begin
      Writeln('Ошибка графики: ');
      Writeln(GraphErrorMsg(ErroeCode));
      Writeln('Программа аварийно завершила работу!...');
      Halt(1);
    end;
  { выполнить некоторые графические функции }
    ClearDevice;
    Rectangle(0,0,GetMaxX,GetMaxY);
    Readln;
    CloseGraph;
  end.

------------------------------------------------------------
 Процедура Halt
------------------------------------------------------------
     Функция: Останавливает выполнение программы и возвраща-
ет управление операционной системе.
     Описание: Наlt [ ( код-выхода : word) ]
     Примечания: Параметр  "код-выхода"  представляет  собой
необязательное  выражение длиной в слово, которое задает код
выхода из программы. Процедура  Наlt  без  параметров  соот-
ветствует  вызову  Наlt(0). Код выхода может проверяться по-
рождаеющим процессом с помощью функции ЕхitCode  модуля  Dos
или с помощью проверки ERRORLEVEL в файле пакетной обработки
ДОС.
     Заметим, что процедура Наlt  инициализирует  выполнение
имеющихся в модуле процедур завершения (см. Главу 26).
     Прочее: См. также процедуру Ехit.

------------------------------------------------------------
 Функция Hi
------------------------------------------------------------
     Функция: Возвращает старший байт аргумента.
     Описание: Нi(x)
     Тип результата: Байт.
     Примечания: Параметр x представляет собой выражение це-
лого  типа или слово. Функция Нi возвращает старший байт x в
виде значения без знака.
     Прочее: См. также функции Lo, Swap.
     Пример:

 var
   w : word;
 begin
   w := Hi($1234);                             { $12 }
 end;

------------------------------------------------------------
 Процедура HighVideo                             Модуль Сrt
------------------------------------------------------------
     Функция: Устанавливает для символов подсветку.
     Описание: HighVideo
     Примечания: В модуле Сrt  имеется  байтовая  переменная
ТехtАttr,  которая используется для хранения текущих атрибу-
тов изображения. Процедура HighVideo устанавливает для цвета
символов  переменной  ТехtAttr бит подсветки. Таким образом,
цвета 0..7 отображаются в цвета 8..15.
     Отличия: В версии 3.0 процедура HighVideo всегда  выби-
рала  желтый цвет на черном фоне (белый на черном фоне в мо-
нохроматическом режиме и в видеорежимах ВW80).
     Прочее: См. также процедуры NomVideo, LowVideo, TextCo-
lor, TextBackGround.
     Пример:

 uses Crt;
 begin
   TextAttr := LightGray;
   HighVideo;                   { цвет становится белым }
 end;

------------------------------------------------------------
 Процедура ImageSize                           Модуль Graph
------------------------------------------------------------
     Функция: Возвращает число байтов, необходимых для  сох-
ранения прямоугольной области экрана.
     Описание: ImageSize(x1, y1, x2, y2 : word)
     Тип результата: Слово (word).
     Примечания: Параметры x1, y1, x2 и y2 определяют прямо-
угольную  область экрана. Функция ImageSize определяет число
байтов, необходимых функции Getimage для сохранения заданной
области экрана. Размер двоичного образа области экрана вклю-
чает в себя также память, необходимую  для  двух  переменных
длиной  в  два  слова, в которых сохраняется ширина и высота
области экрана:

 width  := x2 - x1 + 1;            { ширина }
 height := y2 - y1 + 1;            { высота экрана }

     Размер памяти, необходимый для сохранения двоичного об-
раза  самой  области, вычисляется путем умножения ширины об-
ласти на ее высоту.
     Если объем памяти, необходимый для сохранения  области,
превышает ии равен 64К, то возвращается значение 0 и функция
GraphResult возвращает значение -11 (grError).
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры GetImage, PutImage.
     Пример:

  uses Graph;
  var
    Gd, Gm : integer;
    P : pointer;
    Size : word;
  begin
    Gd := Detect;
    InitGraph(Gd, Gm, '');
    if GraphResult <> grOk then
       Halt(1);
    Bar(0, 0, GetMaxX, GetMaxY);
    Size := ImageSize(10,20,30,40)
    GetMem(P, Size)    { Выделить память в динамически
                         распределяемой области }
    GetImage(10,20,30,40,P^);
    Readln;
    ClearDevice;
    PutImage(100, 100, P^, NormalPut);
    Readln;
    CloseGraph;
  end.

------------------------------------------------------------
 Процедура Inc
------------------------------------------------------------
     Функция: Увеличивает значение переменной.
     Описание: Inc(x [ ; n : longint ] )
     Примечания: Параметр x  представляет  собой  переменную
перечислимого  типа, а n - целочисленное выражение. Значение
x увеличивается на 1 (или на n в случае явного  задания  n).
То есть Inс(x) соответствует x := x+1, а Inс(x,n) соответст-
вует x := x+n. Функция Inс порождает оптимизированный код  и
особенно полезна в больших циклах.
     Прочее: См. также функции Dec. Pred.
     Пример:

 var
   IntVar  : intege;
   LongIntVar : longint;
 begin
   Inc(IntVar);         { intVar := IntVar + 1 }
   Inc(LongIntVar);     { LongIntVar := LongIntVar + 5 }

------------------------------------------------------------
 Процедура InitGraph                           Модуль Graph
------------------------------------------------------------
     Функция: Инициализирует графическую систему и переводит
аппаратуру в графический режим.
     Описание: InitGraph(var  граф_драйвер  :  integer;  var
граф_режим : integer; путь_драйвер : string)
     Примечания:  И  параметр  "граф-драйвер",  и   параметр
"граф-режим" являются параметрами-переменными (var).
     Если параметр "граф_драйвер"  равняется  Detect(0),  то
выполняется  вызов  процедуры DetectGraph, загружается соот-
ветствующий драйвер и выбирается графический режим.

     Если параметр "граф_драйвер" не равен  0,  то  значение
этого  параметра  рассматривается,  как номер драйвера. Этот
драйвер загружается и система переводится в режим, определя-
емый параметром "граф_режим". Заметим, что если значение ав-
томатического  распознавания  аппаратуры  изменено,  то   вы
должны  для  требуемого драйвера обеспечить правильный пара-
метр "граф_режим".
     Параметр "путь_драйвер" определяет путь доступа к ката-
логу  (маршрут),  в  котором находятся графические драйверы.
Если этот параметр пуст, то подразумевается, что файлы драй-
веров содержатся в текущем каталоге.
     С помощью обращения к процедуре  GetМем  в  динамически
распределяемой  области для графического драйвера выделяется
память. При обращении к процедуре CloseGraph эта память  ос-
вобождается.
     После обращения к  процедуре  InitGraph  для  параметра
"граф_драйвер"  будет  установлено значение, соответствующее
текущем графическому драйверу, а для параметра  "граф_режим"
будет  установлено значение, соответствующее текущему графи-
ческому режиму.
     Если происходит ошибка, то процедура GrapDriver и функ-
ция GraphResult возвращают одно из следующих значений:

     -2 - не обнаружена графическая плата;
     -3 - не найден файл драйвера;
     -4 - неверный драйвер;
     -5 - для загрузки памяти недостаточно памяти.

     Процедура InitGraph сбрасывает все графические парамет-
ры  (текущий  указатель,  палитру, цвет, область просмотра и
т.д.) и устанавливает для них предусмотренные  по  умолчанию
значения.
     Для установки поставляемый фирмами драйверов можно  ис-
пользовать процедуру InstallDriver (более подробная информа-
ция содержится в описании процедуры InstallUserDriver).
     Для каждого поддерживаемого графического драйвера опре-
делен ряд полезных констант:

-----------------------------------------------------------
 Константа                  Код        Соответствующее
ошибки графики            ошибки       сообщение об ошибке
-----------------------------------------------------------
  grOk                         =  0; { нет ошибки }
  grNoInitGraph                = -1; { графика не инициали-
                                       зована }
  grNotDetected                = -2; { графические средства
                                       не найдены }
  grFileNotFound               = -3; { файл не найден }
  grInvalidDriver              = -4; { недопустимый
                                       драйвер }
  grNoLoadMem                  = -5; { память не загружена }
  grNoScanMem                  = -6; { ошибка при просмотре
                                       памяти }
  grNoFloodMem                 = -7; { ошибка при зараске }
  grFontNotFound               = -8; { шрифт не найден }
  grNoFontMem                  = -9; { шрифт не загружен в
                                       память }
  grInvalidMode                = -10; { недопустимый режим }
  grError                      = -11; { ошибка графики }
  grIOError                    = -12; { ошибка ввода-вывода
                                        графики }
  grInvalidFont                = -13; { недопутимый файл
                                        шрифта }
  grInvalidFontNum             = -14; { недопустимый номер
                                        шрифта }
------------------------------------------------------------

 const
   { графические режимы для каждого драйвера }
   CGAC1        = 0; { 1 палитра цветов 320х200: красный,
                       желтый, зеленый; 1 страница }
   CGAC2        = 1; { 2 палитра цветов 320х200: светло-
                       бирюзовый, малиновый, белый; 1
                       страница }
   CGAHi        = 2; { 640х200, 1 страница }
   MCGAC1       = 0  { 1 палитра цветов 320х200: красный,
                       желтый, зеленый; 1 страница }
   MCGAC2       = 1; { 2 палитра цветов 320х200: светло-
                       бирюзовый, малиновый, белый; 1
                       страница }
   MCGAMed      = 2; { 640х200, 1 страница }
   MCGAHi       = 3; { 640х480, 2 цвета, 1 страница }
   EGALo        = 0; { 640х200, 4 страницы }
   EGAHi        = 1; { 640х350, 16 цветов, 2 страницы }
   EGA64Lo      = 0; { 640х200, 16 цветов, 1 страница }
   EGA64Hi      = 1; { 640х350, 4 цвета, 1 страница }
   EGA64MonoHi  = 3; { 640х350, 64К на плату, 1 страница -
                       256К на плату, 4 страницы }
   HercMonoHi   = 0; { 720х348, 2 страницы }
   ATT400C1     = 0; { 1 палитра цветов 320х200: красный,
                       желтый, зеленый; 1 страница }
   ATT400C2     = 1; { 2 палитра цветов 320х200: светло-
                       бирюзовый, малиновый, белый; 1
                       страница; 20 - 640х200, 1 страница }
   ATT400Med    = 2; { 640х200, 1 страница }
   ATT400Hi     = 3; { 640х200, 1 страница }
   VGALo        = 0; { 640х200, 16 цветов, 4 страницы }
   VGAMed       = 1; { 640х350, 16 цветов, 2 страницы }
   VGAHi        = 2; { 640х480, 16 цветов, 1 страница }
   VGANi2       = 3; { 640х480, 2 цвета, 1 страница }
   PC3270Hi     = 0; { 720х350, 1 страница }

     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры CloseGraph, DetectGraph,
     RestoreCrtMode, SetGraphMode, GraphResult, InstallUser-
Driver, SetGraphBufSize, RegisterBGIDriver, RegisterBGIFont,
GraphDefaults.
     Пример:

 uses  Graph;
 var
   grDriver : integer;
   grMode   : integer;
   EmCode   : integer;
 begin
  gDriver := Detect;
  InitGraph(grDiver,grMode,'');
  ErrCode := GraphResult;
  it ErrCode <> grOk then
  begin                   { выполнить графические функции }
   Line(0, 0, GetMaxX, GetMaxY);
   Readln;
   CloseGraph;
  end
  else
    Writeln('Ошибка графики : ',GraphErrorMsg(ErrCode));
  end.

------------------------------------------------------------
 Процедура Insert
------------------------------------------------------------
     Функция: Вставляет в строку подстроку.
     Описание: Insert(исх_строка : string; var s  :  string;
индекс : integer)
     Примечания: Параметр  "исх_строка"  представляет  собой
выражение строкового типа. Параметр s - переменная строково-
го типа любой длины. Параметр "индекс"  является  выражением
целого  типа.  Данная процедура вставляет строку, задаваемую
параметром "исх_строка", в строку, задаваемую параметром  s,
начиная  с  позиции,  определяемой параметром "индекс". Если
получившаяся в результате строка превышает 256 символов,  то
она усекается до 255 символов.
     Прочее: См. также процедуры Delete, Copy, ConCat, Pos.
     Пример:

 var
   s : string;
 begin
   s := 'Honest Lincoln';
   Insert('Abe',s,8);    { Honest Abe Lincoln }

------------------------------------------------------------
 Процедура InsLine                               Модуль Сrt
------------------------------------------------------------
     Функция: Начиная с  позиции  курсора  вставляет  пустую
строку.
     Описание: InsLine
     Примечания: Все строки, расположенные ниже  добавленной
строки,  перемещаются  на  одну строку вниз, а нижняя строка
исчезает с экрана (при этом используется программа "прокрут-
ки" изображения на экране базовой системы ввода-вывода).
     Всем позициям символов новой строки присваивается  зна-
чение  пробела  с текущими атрибутами текста. Таким образом,
если процедурой ТехtВаскGround не установлен фоновый  черный
цвет, то новая строка имеет черный фоновый цвет.
     Данная процедура зависит от используемого окна.  Напри-
мер:

     Window(1,10,60,20);
     InsLine;

приведет к вставке строки длиной в 60 символов в точке с аб-
солютными координатами (1,10).
     Прочее: См. также процедуры DelLine, Window.

------------------------------------------------------------
 Функция InstallUserDriver                     Модуль Graph
------------------------------------------------------------
     Функция: Включает в таблицу драйверов  устройств  фирма
BGI (Борланд) драйверы, поставляемый другими фирмами.
     Описание: InstallUserDriver(имя : string; AutoDetectPtr
: pointer)
     Тип результата: слово (word).
     Примечания: Данная процедура позволяет вам использовать
драйверы устройств, отличающиеся от драйверов фирмы Борланд.
Параметр "имя" представляет собой имя нового  драйвера  уст-
ройства.  AutoDetectPrt  -  это  указатель на необязательную
функцию автоматического распознавания, которая может  прила-
гаться  к  новому драйверу. Эта функция автоматического рас-
познавания не требует параметров и возвращает  целое  значе-
ние.
     Если внутренняя таблица драйверов заполнена, то  проце-
дура  InstallUserDriver возвращает значение -11 (grError). В
противном случае данная процедура присваивает  и  возвращает
для нового драйвера устройства номер этого драйвера.
     Драйвер пользователя можно использовать двумя  способа-
ми. Предполохим, у вас имеется новая видеоплата SGA и фирма,
изготовливающая  эту  плату,  поставляет  для  нее   драйвер
SGA.BGI. Наиболее простой способ использования этого драйве-
ра   состоит   в   его   установке   с   помощью   процедуры
InstallUserDriver и передачи возвращаемого значения (присво-
енного номера драйвера) непосредственно процедуре InitGraph:

  var
    Driver, Mode : integer;
  begin
    Driver := InstallUserDriver('SGA.BGI', Nil);
    if Driver = grError then   { таблица переполнена? }
       Halt(1);
    Mode := 0;      { каждый драйвер поддерживает режим 0 }
    InitGraph(Driver, Mode, ''); { изменить автоматическое
                                   распознавание }
    ...             { нет графики }
  end.

     Значение nil параметра AutoDetectPtr  при  обращении  к
процедуре  InstallUserDriver  показывает,  что для платы SGA
функция автоматического распознавания отсутствует.
     Другой, более общепринятый способ состоит в использова-
нии этого драйвера для связи функции автоматического распоз-
навания,  которая  будет  вызываться  при  работе  процедуры
InitGraph. Предположим, фирма-изготовитель платы SGA предос-
тавила вам функцию  автоматического  распознавания,  которая
выглядит следующим образом:

  {$F+}
  function DetectSGA : integer;
  var Found : Boolean;
  begin
    DetectSGA := grError; { предположим, плата отсутствует }
    Found := ...           { поиск соответствующего аппарат-
                             ного обеспечения }
    if not Found then
       Exit;               { код возврата = -11 }
    DetectSGA := 3;        { возвратить рекомендуемый и наз-
                             начаемый по умолчанию видео-
                             режим }
  end.
  {$F-}

     Задача функции DetectSGA состоит в поиске во время  ра-
боты  программы аппаратного обеспечения SGA. Если плата SGA
не обнаружена, то данная  функция  возвращает  значение  -11
(grError).  В  противном случае возвращаемое значение предс-
тавляет собой принятый по умолчанию видеорежим для платы SGA
(обычно он обеспечивает наилучшее сочетание цвета и разреша-
ющей сопсобности, которые можно достичь на данном аппаратном
обеспечении).
     Заметим, что эта фукнция не требует параметров и  возв-
ращает  целочисленное  значение  со знаком. Она должна иметь
дальний тип обращения. При установке драйвера (путем обраще-
ния  к  процедуре  InstallUserDriver)  вы передаете наряду с
именем  файла,   содержащего   драйвер   устройства,   адрес
DetectSGA:

  var
    Driver, Mode : integer;
    begin
      Driver := InstallUserDriver('SGA.GBI', @DetectSGA);
      if Driver = grError then
         Halt(1);
      Driver := Detect;
      { не будем учитывать драйвер SGA, доверимся средствам
        автоматического распознавания }
      InitGraph(Driver, Mode, '');
      ...
  end.

     После того, как  вы  установите  драйвер  устройства  и
функцию  автоматического распознавания, можно вызвать проце-
дуру InitGraph, которая выполнит обычный  процесс  автомати-
ческого  распознавания.  Перед  тем, как процедура InitGraph
вызывает свою встроенную функцию автоматического распознава-
ния  (DetectGraph),  она вызывает сначала функцию DetectSGA.
Если DetectSGA не найдет аппаратных средств SGA, то  возвра-
щается значение -11 (grError), а процедура InitGraph продол-
жит выполнение обычного процесса автоматического распознава-
ния (который также может включать в себы вызов пользователь-
ских функций автоматического распознавания в том порядке,  в
котором они были установлены). Если же функция DetectSGA оп-
ределит наличие SGA, то она возвращает неотрицательное  зна-
чение  режима,  а  InitGraph найдет и загрузит файл SGA.BGI,
переведет аппаратное обеспечение в нужный режим  (рекомендо-
ванный  функцией  DetectSGA) и, наконец, передаст управление
вашей программе.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Прочее: См. также процедуры  InitGraph  и  RegisterBGI-
Driver.
     Пример:

 uses Graph;
 var
   Driver, Mode,
   TestDriver,
   ErrCode : integer;
 {$F+}
 function TestDetect : integer;
 { фукнция автоматического распознавания: если имеются
   соответствующие аппаратные средства, она возвращает
   значение, равное соответствующему принимаемому по
   умолчанию режиму }
 begin
   TestDetect := 1;  { по умолчанию режим = 1 }
 end;
 {$F-}
 begin
   { установить драйвер }
   TestDriver := InstallDriver('TEST', @TestDetect);
   if GraphResult <> grOk then
   begin
     Writeln('Ошибка при установке драйвера');
     Halt(1);
   end;
   Driver := Detect; { перейти в графический режим }
   InitGraph(Driver, Mode, '');
   ErrCode := GraphResult;
   If ErrCode <> grOk then
   begin
     Writeln('Устанавливаемый драйвер поддерживается...');
     Readln;
     CloseGraph;
  end.

------------------------------------------------------------
 Функция InstallUserFont                       Модуль Graph
------------------------------------------------------------
     Функция: Устанавливает новый шрифт, не  предусмотренный
в системе фирмы Борланд.
     Описание: InstallUserFont(имя_файла_шрифта : string)
     Примечания:  Параметр  "имя_файла_шрифта"  представляет
собой имя файла "штрихового" шрифта. Фукнция InstallUserFont
возвращает номер шрифта, который  можно  передать  процедуре
SetTextStyle для выбора этого шрифта. Если внутренняя табли-
ца  шрифтов  переполнена,   то   возвращается   значение   0
(DefaultFont).
     Аналогичная функция имеется в версии 2.0 Турбо-Си.
     Прочее: См. также процедуру SetTextStyle.
     Пример:

  uses Graph;
  var
    Driver, Mode : integer;
    TestFont : integer;
  begin
   TestFont := InstallUserFont('TEST'); { установить шрифт }
   if GraphResult <> grOk then
   begin
     Writeln('Ошибка при установке шрифта TestFont; будет
 использоваться DefaultFont');
     Readln;
   end;
   Driver := Detect; { перевести в графический режим }
   InitGraph(Driver, Mode, '');
   if GraphResult <> grOk then
      Halt(1);
   SetTextStyle(TestFOnt, HorizDir, 2); { использовать новый
                                          шрифт }
   OutText('Поддерживается новый установленный шрифт...');
   Readln
   GloseGraph;
  end.

------------------------------------------------------------
 Функция Int
------------------------------------------------------------
     Функция: Возвращает целую часть аргумента.
     Описание: Int(x : real)
     Тип результата: Вещественный (real).
     Примечания: Параметр x представляет собой выражение ве-
щественного типа. Результатом будет целая часть x, то есть x
округляется в сторону нуля.
     Прочее: См. также фукнцию Frас.
     Пример:

  var
    r : real;
  begin
    r := Int(123.456);                  { 123 }
  end.

------------------------------------------------------------
 Процедура Intr                                  Модуль Dos
------------------------------------------------------------
     Функция: Выполняет заданное программное прерывание.
     Описание: Intr(номер_прер : byte; var Regs : Registers)
     Примечания: Параметр "номер_прер"  -  это  номер  прог-
раммного  прерывания  (0...255). Registers является записью,
определенной ДОС следующим образом:

 type
   Registers = record
                case integer of
                 0: (AX,BX,CX,X,BP,SI,DS,ES,Flags: word);
                 1: (AL,AH,BL,BH,CL,CH,DL,DH: byte);
               end;

     Перед выполнением  указанного  программного  прерывания
функция  Intr, используя запись Rеgs, загружает регистры АХ,
ВХ, СХ, DХ, ВР, SI, DI, DS и ЕS процессора 8086. После того,
как прерывание будет выполнено, содержимое регистров АХ, ВХ,
СХ, DХ, ВР, S1, DI, DS, ЕS и регистров флагов опять сохраня-
ется в записи Regs.
     Для получения более подробной информации по  разработке
процедур обработки прерываний см. раздел "Обработка прерыва-
ний" в Главе 15 ("Внутренняя организация Турбо-Паскаля").
     Ограничения: Программные  прерывания,  для  которых  на
входе  требуется  задание  определенных значений в SР или SS
или изменяют значения SР и SS на  выходе,  с  использованием
данной процедуры выполняться не могут.
     Отличия: В версии 3.0 Турбо-Паскаля перменная Registers
передаваемая процедуре Intr, имела тип, определяемый пользо-
вателем. В версиях 4.0 и 5.0 эта переменная должна иметь тип
Registers, определенный в модуле Dos.
     Прочее: См. также процедуру MsDos.

------------------------------------------------------------
 Функция IOResult
------------------------------------------------------------
     Функция: Возвращает целое значение, представляющее  со-
бой состояние последней выполненой операцией ввода-вывода.
     Описание: IOResult
     Тип результата: Слово (word).
     Примечания: Чтобы перехватить ошибки ввода-вывода,  ис-
пользуя  функцию IORеsult, проверка ввода-вывода должна быть
выключена (директива компилятора {$I-}). Если проверка  вво-
да-вывода  выключена  и  происходит ошибка ввода-вывода, то,
пока выполняется обращение к функции IORеsult, все последую-
щие  операции ввода-вывода игнорируются. Обращение в функции
IORеsult сбрасывает ее внутренний флаг ошибки.
     Перечень возвращаемых кодов ошибок приведен в  Приложе-
нии 1 ("Сообщения об ошибках и коды ошибок"). Значение 0 от-
ражает успешное выполнение операции ввода-вывода.
     Отличия: В версии 3.0 Турбо-Паскаля коды некоторых оши-
бок были другими.
     Пример:

 var
   f : file of byte;
 begin
   { получить командную строку с именем файла }
   Assign(f, ParamStr(1));
   {$I-}
   Reset(f);
   {$I+}
   if IOResult = 0 then
       Writeln('Размер файла в байтах :',FileSize(f));
   else
       Writeln('Файл не найден');
  end.

------------------------------------------------------------
 Процедура Keep                                  Модуль Dos
------------------------------------------------------------
     Функция: Процедура Кееp (завершить работу и оставить  в
памяти)  прерывает  работу программы и оставляет ее резиден-
тной в памяти.

     Описание: Keep(код_завершения : word)
     Примечания: Весь код программы, включая сегмент данных,
сегмент стека и динамически распределяемую область, остается
резидентным в памяти. Поэтому необходимо  убедиться  в  том,
что  с помощью директивы компилятора $М вы задали максималь-
ный  размер  динамически  распределяемой  области.  Параметр
"код_завершения" соответствует коду завершения, передаваемо-
му стандартной процедуре Наlt.
     Ограничения: Данной процедурой следует  пользоваться  с
осторожностью.  Программы,  завершающие  работу и остающиеся
резидентными в памяти, довольно сложны и для них не  предус-
мотрено никакой другой поддержки. Более подробная информация
содержится в технической документации по ДОС.
     Прочее: См. также процедуру DosExitCode.

------------------------------------------------------------
 Функция KeyPressed                              Модуль Сrt
------------------------------------------------------------
     Функция: Возвращает значение Тruе, если  на  клавиатуре
нажата клавиша и False в противном случае.
     Описание: KeyPressed
     Тип результата: Булевский (boolean).
     Примечания: Символ (или символы) остаются в буфере кла-
виатуры.  Данная процедура не распознает клавиш перевода ре-
гистра, таких, как Shift, Аlt, NumLock и т.д.
     Отличия: В версии 3.0 проверка на  ситуацию  Сtrl-Вrеак
должна была быть выключена ({$С-}), в версии 4.0 и 5.0 тако-
го ограничения нет.
     Прочее: См. также процедуру ReadKey.
     Пример:

 uses Crt;
 begin
   repeat
     Write('Xx');       { заполнять экран, пока нажата кла-
                          виша }
    until KeyPressed;
 end;

------------------------------------------------------------
 Функция Length
------------------------------------------------------------
     Функция: Возвращает динамическую длину строки.
     Описание: Length(s : string)
     Тип результата: Целый (integer).
     Примечания: Параметр  s  представляет  собой  выражение
строкового типа. Результатом будет длина s.
     Пример:

  var
    s : string;
    i : word;
  begin
    s := 'abc';
    for i := 1 to Lenth(s) do
      s[i] := UpCese(s[i]);
      Writeln(s);                       { ABC }
  end.

------------------------------------------------------------
 Процедура Line                                Модуль Graph
------------------------------------------------------------
     Функция: Рисует прямую линию из точки (x1,y1)  в  точку
(x2,y2).
     Описание: Line(x1, y1, x2, y2 : integer)
     Примечания: Рисует прямую, толщина и тип которой  зада-
ются  процедурой SetLineStyle, а цвет устанавливается проце-
дурой SetColor.
     Заметим, что

     MoveTo(100,100);
     LineTo(200,200);

эквивалентно

     LineTo(100,100,200,200);
     MoveTo(200,200);

     Используйте данную процедуру только в том случае, когда
текуший  указатель  находится  в одном из концов строки, или
когда вы хотите, чтобы позиция текущего указателя после  вы-
черчивания  линии автоматически изменилась. Заметим, что ли-
ния не изменяет текущий указатель.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры LineTo, MoveTo,  Rectangle,
SetColor, SetLineStyle.
     Пример:

  uses Crt, Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> 0 then
       Halt(1);
 Randomize;
 repeat
   Line(Random(200),Random(200),Random(200),Random(200));
 until KeyPressed;
 Readln;
 CloseGraph;
 end.

------------------------------------------------------------
 Процедура LineRel                             Модуль Graph
------------------------------------------------------------
     Функция:  Проводит прямую в точку, заданную
относительным расстоянием от текущего указателя (СР).
     Описание: LineRel(Dx,Dy)
     Примечания:  Данная  процедура вычерчивает прямую линию
из текущей точки в точку,  заданную относительным растоянием
(Dх,Dу) от текущего указателя. Процедура рисует прямую,
толщина и тип которой задаются  процедурой SetLineStyle, а
 цвет
устанавливается процедурой  SetColor.  Относительные команды
перемещения и рисования  полезны при  вычерчивании различных
объектов на экране, у которых начальная точка может быть
изменена (чтобы, например, вычертить ту же самую фигуру в
другом месте экрана).
     Ограничения: Должен использоваться графический режим.
     Прочее: См.  также  процедуры  Line,  LineTo,  MoveRel,
 MoveTo, SetLineStyle.
     Пример:

 uses Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> 0 then
       Halt(1);
 begin
  MoveTo(1,2);
  LineRel(10,10);       { провести прямую в точку (11,12) }
  end;
  Readln;
  CloseGraph;
 end.

------------------------------------------------------------
 Процедура LineTo                              Модуль Graph
------------------------------------------------------------
     Функция: Рисует прямую линию из точки, в которой  нахо-
дится текущий указатель, в точку (x,y).
     Описание: LineTo(x, y : integer)
     Примечания: Рисует прямую, толщина и тип которой  зада-
ются  процедурой SetLineStyle, а цвет устанавливается проце-
дурой SetColor.
     Заметим, что

     MoveTo(100,100);
     LineTo(200,200);

эквивалентно

     Line(100,100,200,200);

     Первый метод требует больше времени  для  выполнения  и
большего  объема  памяти  для выполняемого кода. Используйте
процедуру LineТо только когда текущий указатель находится  в
одном из концов прямой. Отметим, что второй метод не изменя-
ет значения текущего указателя.
     Процедура LinеТо перемещает текущий указатель  в  точку
(x,y).
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См.  также  процедуры  Line,  LineRel,  MoveTo,
MoveRel, SetLineStyle.
     Пример:

  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> 0 then
       Halt(1);
  Randomize;
  repeat
    LineTo(Random(200),Random(200));
  until KeyPressed;
  Readln;
  CloseGraph;
 end.

------------------------------------------------------------
 Функция Ln
------------------------------------------------------------
     Функция: Возвращает натуральный логарифм аргумента.
     Описание: Ln(x : real)
     Тип результата: Вещественный (real).
     Примечания: Параметр x является выражением вещественно-
го типа. Результатом будет натуральный логарифм x.
     Прочее: См. также функцию Еxp.

------------------------------------------------------------
 Функция  Lo
------------------------------------------------------------
     Функция: Возвращает младший байт аргумента.
     Описание: Lо(x)
     Тип результата: Байт (byte).
     Примечания: Параметр x - это параметр целого  типа  или
параметр  длиной в слово. Функция Lо возвращает младший байт
x в качестве значения без знака.
     Прочее: См. также функции Hi, Swap.
     Пример:

  var
    w : word;
  begin
    w := Lo($1234);                       { $34 }
  end.


------------------------------------------------------------
 Процедура LowVideo                              Модуль Crt
------------------------------------------------------------
     Функция: Выбирает символы с пониженной яркостью.
     Описание: LowVideo
     Примечания: В модуле Сrt  имеется  байтовая  переменная
ТехtАttr,  которая используется для хранения текущих атрибу-
тов изображения. Процедура LowVideo очищает для цвета симво-
лов  переменной ТехtАttr бит подсветки. Таким образом, цвета
0..7 отображаются в цвета 8..15.
     Отличия: В версии 3.0 процедура LowVideo всегда выбира-
ла желтый цвет на черном фоне.
     Прочее:  См.  также  процедуры  HighVideo,   NormVideo,
TextColor, TextBackGround.
     Пример:

 uses Crt;
 begin
   TextAttr := White;
   LowVideo;               { цвет становится светло-серым }
 end.

------------------------------------------------------------
 Процедура Маrk
------------------------------------------------------------
     Функция: Записывает  в  переменной-указателе  состояние
динамически распределяемой области памяти.
     Описание: Mark(var p: Pointer)
     Примечания: Параметр p является  переменной-указателем,
соответствующей любому типу указателя. Текущее значение ука-
зателя динамически распределяемой области памяти записывает-
ся в p и может в последствии использоваться в качестве аргу-
мента процедуры Rеlease.
     Ограничения: Если не  соблюдены  определенные  правила,
процедуры Маrк и Rеlease нельзя использовать вместо процедур
Dispose и FrееМем. Полное обсуждение этого вопроса приводит-
ся в Главе 26, в разделе под заглавием "Программа управления
динамически распределяемой областью".
     Прочее: См. также процедуры Release, FreeMem, Dispose.

------------------------------------------------------------
 Функция MaxAvail
------------------------------------------------------------
     Функция:  Возвращает  размер  наибольшего  непрерывного
свободного блока в динамически распределяемой области, соот-
ветствующий размеру наибольшей динамической переменной,  для
которой в данный момент может быть выделена память.
     Описание: MaxAvail
     Тип результата: Длинный целый (longint).
     Примечания: Данное значение вычисляется путем сравнения
всех  свободных блоков, расположенных ниже указателя динами-
чески распределяемой области памяти. Для  получения  полного
объема свободной памяти в динамически распределяемой области
используйте процедуру МемАvail. Минимальный размер  блока  в
динамически распределяемой области равняется одному байту. С
помощью директивы компилятора {$М} в вашей  программе  можно
задавать минимальные и максимальные потребности в динамичес-
ки распределяемой области (см. Приложение С).
     Отличия: В версии 3.0 возвращаемое значение имело целый
тип и представляло собой размер наибольшего свободного блока
в байтах.
     Прочее: См. также процедуру MemAvail.
     Пример:

 type
   FriendRec = record
     Name  : string[30];
     Age   : byte;
    end;
 var
   p : pointer;
  begin
    if MaxAvail < SizeOf(FriendRec) then
    Writeln('Не хватает памяти');
    else
    begin

  { выделить память в динамически распределяемой области }
    GetMem(p, SizeOf(FriendRec));
     .
     .
     .
    end;
   end.

------------------------------------------------------------
 Функция MemAvail
------------------------------------------------------------
     Функция: Возвращает число свободных блоков в динамичес-
ки распределяемой области памяти.
     Описание: MemAvail
     Тип результата: Длинный целый (longint).
     Примечания: Данное число определяется путем путем  сло-
жения  размеров  всех  свободных  блоков, расположенных ниже
указателя динамически распределяемой области памяти, с  объ-
емом  свободной памяти, расположенной выше указателя динами-
чески распределяемой области. Заметим, что пока нет  обраще-
ний к процедурам Dispose и FrееМем, из-за фрагментации дина-
мически распределяемой области памяти маловероятно, что  бу-
дет  доступен  блок  памяти,  размер  которого соответствует
возвращаемому значению. Для  получения  размера  наибольшего
свободного блока используйте функцию МахАvail. С помощью ди-
рективы компилятора {$М} в вашей программе можно  определить
максимальные  и минимальные требования к динамически распре-
деляемой области памяти (см. Приложение С).
     Отличия: В версии 3
error in text...............

     Прочее: См. также процедуру FillChar.
     Пример:

 var
   a : array[1..4] of char;
   b : longint;
  begin
    Move(a, b, SizeOf(a));         { для надежности исполь-
                                     зуется функция SizeOf }
  end.

------------------------------------------------------------
 Процедура MoveRel                             Модуль Graph
------------------------------------------------------------
     Функция: Перемещает текущий указатель (СР) на  расстоя-
ние, заданное относительными координатами от его текущей по-
зиции.
     Описание: MoveRel(Dx, Dy : integer)
     Примечания: Процедура МоvеRеl перемещает текущий указа-
тель  (СР)  в  точку,  заданную   относительным  расстоянием
(Dх,Dy) от точки, в которой находится текущий указатель.
     Относительные  команды  перемещения и рисования полезны
при вычерчивании различных объектов на экране, у которых на-
чальная точка может быть изменена  (чтобы,  например, вычер-
тить ту же самую фигуру в другом месте экрана).
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры LineRel, LineTo, MoveTo.

     Пример:

 uses Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> 0 then
       Halt(1);
   MoveTo(1,2);
   MoveRel(10,10)     { переместить в точку с координатами
                        (11,12) }
   PutPixel(GeyX, GetY, GetMaxColor);
  Readln;
  CloseGraph;
 end.

------------------------------------------------------------
 Процедура MoveTo                              Модуль Graph
------------------------------------------------------------
     Функция: Перемещает текущий графический указатель  (СР)
в точку (x,y).
     Описание: MoveTo(x, y : integer)
     Примечания: Текущий указатель (СР) пермещается в  точку
с  координатами (x,y). Текущий указатель аналогичен курсору,
который используется в текстовом режиме.  Различает  их  то,
что  текущий указатель невидим. Текущий указатель (СР) пере-
мещают следующие процедуры:

     InitGraph, MoveTo, MoveRel, LineTo,  LineRel,  OutText,
SetGraphMode

     Если активна текущая область просмотра, то  СР  зависит
от  данной  области  (значения  x и y будут суммироваться со
значениями x1, y1 текущей области просмотра). В границах те-
кущей области просмотра текущий указатель никогда не отсека-
ется.

     Прочее: См. также процедуры  GeetMaxX,  GetMaxY,  GetX,
GetY, MoveRel.
     Пример:

 uses Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> 0 then
       Halt(1);
 MoveTo(0,0);           { левый верхний угол окна }
 LineTo(GetMaxX, GetMaxY);
   Readln;
   CloseGraph;
  end.

------------------------------------------------------------
 Rrliug~ MsDos                                   Модуль Dos
------------------------------------------------------------
     Функция: Выполняет функциональный вызов ДОС.
     Описание: MsDos(var Regs : Registers)
     Примечания: Результат обращения к функции  MsDos  будет
тот  же самый, что и обращение к функции Intr с номером пре-
рывания IntNo $21. Registers представляет собой запись, опи-
санную в модуле Dos следующим образом:

  type
   Registers = record
                case integer of
                 0: (AX,BX,CX,X,BP,SI,DS,ES,Flags: word);
                 1: (AL,AH,BL,BH,CL,CH,DL,DH: byte);
               end;

     Ограничения: Программные  прерывания,  для  которых  на
входе  требуется  задание  определенных значений в SР или SS
или изменяют значения SР и SS на  выходе,  с  использованием
данной функции выполняться не могут.
     Прочее: См. также функцию Intr.

------------------------------------------------------------
 Процедура New
------------------------------------------------------------
     Функция: Создает новую динамическую переменную и  уста-
навливает на нее указатель.
     Описание: New(var : pointer)
     Примечания: Параметр р является указателем-переменной и
относится к указателям любого типа. Размер выделяемого блока
памяти соответствует размеру того типа, на который указывает
р.  На  вновь созданную переменную можно ссылаться с помощью
р. Если для выделения памяти под новую динамическую перемен-
ную  в  динамически распределяемой области недостаточно сво-
бодной памяти, то во время выполнения  программы  происходит
ошибка.  (Этой  ошибки  можно избежать - см. раздел "Функция
обработки ошибки динамически распределяемой области  памяти"
в Главе 26.)
     Прочее: См. также процедуры GetMem, Dispose.

------------------------------------------------------------
 Процедура NormVideo                             Модуль Сrt
------------------------------------------------------------
     Функция: Задает необходимость считывания текущего атри-
бута  текста  из позиции курсора во время загрузки и запуска
программы.
     Описание: NormVideo
     Примечания: В блоке  Сrt  имеется  байтовая  переменная
(ТехtАttr), которая используется для сохранения текущего ви-
деоатрибута. Данная процедура восстанавливает  для  ТехtAttr
то  значение,  которое эта переменная имела до запуска прог-
раммы.
     Отличия: В версии 3.0 Турбо-Паскаля процедуры NormVideo
и HighVideo были идентичными. См. процедуру HigVdeo.
     Прочее: См. также процедуры HighVieo, LowVideo, TextCo-
lor, TextBackGround.

------------------------------------------------------------
 Процедура NoSound                               Модуль Сrt
------------------------------------------------------------
     Функция: Выключает внутренний динамик.
     Описание: NoSound
     Примечания: Следующий фрагмент программы вызывает  зву-
чание сигнала частотой 440 герц в течении половины секунды.

     Sound(440); Delay(500); NoSound;

     Прочее: См. также процедуру Sound.

------------------------------------------------------------
 Функция Odd
------------------------------------------------------------
     Функция: Проверяет, является ли аргумент нечетным  чис-
лом.
     Описание: Odd(x : longint)
     Тип результата: Булевский (boolean).
     Примечания: Параметр x - это выражение длинного  целого
типа. Результат принимает значение Тruе, если x представляет
собой нечетное число и False - в противном случае.

------------------------------------------------------------
 Функция Ofs
------------------------------------------------------------
     Функция: Возвращает для заданного объекта смещение.
     Описание: Ofs(x)
     Тип результата: Слово (word).
     Примечания: Параметр x представляет собой  любую  пере-
менную  или  идентификатор  процедуры или функции. Результат
длиной в слово представляет собой смещение для x.
     Прочее: См. также процедуры Seg, Addr.

------------------------------------------------------------
 Функция Ord
------------------------------------------------------------
     Функция: Возвращает порядковый номер для значения пере-
числимого типа.
     Описание: Ord(x)
     Тип результата: Длинный целый (longint).
     Примечания: Параметр x представляет собой выражение пе-
речислимого  типа.  Результат  имеет длинный целый тип и его
значение является порядковым значением для x.
     Прочее: См. также функцию Chr.

------------------------------------------------------------
 Процедура OutText                             Модуль Graph
------------------------------------------------------------
     Функция: Пересылает строку на устройство  вывода  в  то
место, в котором находится текущий указатель.
     Описание: ОutТехt(строка : string)
     Примечания: Параметр "строка" выводится в месте  распо-
ложения  текущего  указателя.  При этом используются текущие
параметры выравнивания. Если строка  слишком  длинная  и  не
умещается  на экране или в текущей области просмотра, то она
усекается. Если активен  шрифт,  используемый  по  умолчанию
(шрифт  с побитовым отображением), а строка слишком велика и
не умещается на экране, то она не выводится.
     В данной процедуре  используется  шрифт,  установленный
процедурой SetTextStyle. Чтобы обеспечеить совместимость вы-
полняемого кода при использовании  нескольких  шрифтов,  для
определения  размеров  строки  используйте  вызовы  процедур
ТехtWidth и ТехtHeight.
     Процедура OutText использует параметры вывода, установ-
ленные  процедурой SetTextJustify (выравнивание, центрирова-
ние, вращение на 90 градусов и т.д.).
     Текущий указатель изменяется процедурой OutText  только
в  том случае, если направление вывода текста горизонтальное
и задано выравнивание по левой границе.  Направление  вывода
текста  (горизонтальное или вертикальное) задается с помощью
процедуры SetTextStyle, а выравнивание - с помощью процедуры
SetTextJustify (текущий указатель слева от строки, центриру-
ется или расположен справа от строки, записывается наж стро-
кой, под строкой).
     Если параметр горизонтального выравнивания текста,  ус-
тановленный  с  помощью процедуры SetTextJustify, равен Cen-
terText или RightText, то  Y  элементов  текущего  указателя
(СРY) будут смещены следующим образом:

     CPY := CPY + TextHeight(TextString)

     Если параметр горизонтального выравнивания текста,  ус-
тановленный  с помощью процедуры SetTextJustify, равен Left-
Text, то Х элементов текущего указателя (СРХ) будут  смещены
следующим образом:

     CPX := CPX + TextWidth(TextString)

     В следующем примере в блоке 1 выводится ABCDEF и  теку-
щий  укахатель перемещается (текст выводится горизонтально и
выравнивается слева), в блоке 2 выводится ABC а DEF  записы-
вается  справа над этим текстом, так как текст выравнивается
справа, аналогично, в блоке 3 выводится текст ABC и над  ним
справа выводится DEF (так как текст выводится вертикально).

  program CPupdate;
  uses Graph;
  var
    Driver, Mode : integer;
  begin
    Driver := Detect;
    InitGraph(Driver, Mode, '');
    if GraphResult < 0 then
       Halt(1);
   { блок 1 }
   MoveTo(0, 0);
   SetTextStyle(DefaultFont, HorizDir, 1) { разм. симв. =1 }
   SetTextJustify(LeftText, TopText);
   OutText('ABC');                    { CP изменяется }
   OutText('DEF');                    { СР изменяется }
   { блок 2 }
   MoveTo(100, 50);
   SetTextStyle(DefaultFont, HorizDir, 1) { разм. симв. =1 }
   SetTextJustify(RightText, TopText);
   OutText('ABC');                    { CP изменяется }
   OutText('DEF');                    { СР изменяется }
   { блок 3 }
   MoveTo(100, 100);
   SetTextStyle(DefaultFont, VerDir, 1) { разм. симв. =1 }
   SetTextJustify(LeftText, TopText);
   OutText('ABC');                    { CP не изменяется }
   OutText('DEF');                    { СР не изменяется }
   Readln;
   CloseGraph;
  end.

     Процедурой OutTextXY текущий указатель никогда не изме-
няется.
     Выбираемый по умолчанию шрифт (шрифт с битовым  образом
8х8)  не  границе  экране не отсекается. В этом случае, если
какая-либо часть строки не может  быть  помещена  на  экран,
текст просто не выводится. Следующие операторы, например, не
приведут к выводу текста:

  SetViewPort(0, 0, GetMaxX, GetMaxY, ClipOn);
  SetTextJustify(LeftText, TopText);
  OutTextXY(-5, 0); { эта точка выходит за границу экрана }
  OutText(GetMaxX -1, 0, 'ABC'); { часть 'A' }
                                 { 'BC' не помещается }

     Однако "штриховые" шрифты отсекаются на границе экрана.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также  процедуры  OutTextXY,  SetTextStyle,
SetTextJustify, GetTextSettings, TextHeight, TextWidth.
     Пример:

 uses Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> grOk then
       Halt(1);
    OutText('Легко использовать');
    Readln;
    CloseGraph;
  end.

------------------------------------------------------------
 Процедура OutTextXY                           Модуль Graph
------------------------------------------------------------
     Функция: Пересылает строку на устройство вывода.
     Описание:  OutTextXY(Х,Y  :  integer;  текст_строка   :
string)
     Примечания: Строка, заданная параметром "текст_строка",
выводится в точке (Х,У). Если строка слишком длинная и выхо-
дит за пределы экрана или текущей области просмотра, то  она
усекается.
     Процедура OutText используется для вывода текста в мес-
те  расположения текущего указателя, процедура OutTextXY ис-
пользуется для вывода текста в любом заданном месте экрана.
     Прочее: См. также процедуры OutText, SetTextStyle, Set-
TextJustify, GetTxtSettings, TextHeight, TextWidth.
     Пример:

 uses Graph;
  var
    Gd, Gm : integer;
  begin
    Gd := Detect;
    InitGraph(gd, Gm, '');
    if GraphResult <> grOk then
       Halt(1);
  MoveTo(0,0);
 OutText('Неэфффективно');
 OutTextXY(GetX,GetY,'Также неэффективно');
 OutTextXY(0,0,'Превосходно!');{ заменяет выведенное ранее }
 Readln;
 CloseGraph;
 end.

------------------------------------------------------------
 Процедура OvrClearBuf                       Модуль Overlay
------------------------------------------------------------
     Фукнция: Очищает оверлейный буфер.
     Описание: OvrClearBuf
     Примечания: Перед вызовом процедуры из оверлейного  бу-
фера  выводятся все загруженные в данный момент оверлеи. Это
приведет к тому, что при последующих обращениях к оверлейным
программам  оверлеи  будут  загружаться из оверлейного файла
(или из расширенной памяти). Если процедура OvrClearBuf  вы-
зывается  из оверлея, то перед возвратом из OvrClearBuf этот
оверлей будет немедленно перезагружен. Подсистема управления
оверлеями  не  требует  от вас вызова процедуры OvrClearBuf.
Фактически, при обращениях к этой  процедуре  производитель-
ность вашей прикладной программы только ухудшится, поскольку
это приведет к необходимости перезагрузки оверлеев. Процеду-
ра OvrClearBuf предназначена только для особых случаев, нап-
ример, для временного освобождения памяти, занимаемой  овер-
лейным буфером.
     Прочее: См. также процедуры OvrGetBuf, OvrSetBuf.

------------------------------------------------------------
 Процедура OvrGetBuf                         Модуль Overlay
------------------------------------------------------------
     Функция: Возвращает текущий размер оверлейного буфера.
     Описание: OvrGetBuf
     Тип результата: Длинный целый (longint).
     Примечания: Размер оверлейного буфера устанавливается с
помощью обращения к процедуре OvrSetBuf. Первоначально овер-
лейный буфер имеет минимальный возможный размер,  соответст-
вующий  размеру наибольшего оверлея. При выполнении оверлей-
ной программы буфер такого размера выделяется автоматически.
(Замечание:  Начальный  размер  буфера  может превышать 64К,
поскольку он включает в себя и код  наибольшего  оверлея,  и
его корректировочную информацию).
     Прочее:  См.  также  процедуры   OvrInit,   OvrInitEMS,
OvrSetBuf.
     Пример:

  {$M 16384,65536,655360 }
  use Overlay;
  const
    ExtractSize = 49152; { 48K }
  begin
    OvrInit('EDITOR.OVR');
    Writeln('Начальный размер оверлейного буфера = ',
             OvrGetBuf, 'байтов');
    OvrSetBuf(OvrGetBuf+ExtractSize);
    Writeln('Размер оверлейного буфера увеличен теперь до ',
             OvrGetBuf, 'байтов');
  end.

------------------------------------------------------------
 Процедура OvrInit                           Модуль Overlay
------------------------------------------------------------
     Фукнция: Инициализирует подсистему управления оверлеями
и открывает оверлейный файл.
     Описание: OvrInit(имя_файла : string)
     Примечания: Если в параметре "имя_файла" буквенная мет-
ка  дисковода или подкаталог не заданы, то подсистема управ-
ления оверлеями ищет файл в текущем  каталоге,  в  каталоге,
содержащем  файлы .ЕХЕ (при работе в ДОС версии 3.х) и в ка-
талогах, заданных с помощью  переменной  операционной  среды
PATH.  Возможные  ошибки могут быть получены с помощью пере-
менной операционной среды OvrResult. Значение ovrOk  говорит
об  успешном завершении, ovrError показывает, что оверлейный
файл имеет неправильный формат, или что программа не  содер-
жит  оверлеев.  Значение ovrNotFound означает, что не найден
оверлейный файл.
     В случае ошибки подсистема управления оверлеями остает-
ся  неустановленной  и  попытки  вызова оверлейной программы
приведут к ошибке времени выполнения  208  (Overlay  manager
not  installed - подсистема управления оверлеями не установ-
лена).
     Процедура OvrInit должна вызываться перед любыми други-
ми процедурами подсистемы управления оверлеями.
     Прочее:  См.  также  процедуры  OvrGetBuf,  OvrInitEMS,
OvrSetBuf.
     Пример:

  use Overlay;
  const
  begin
    OvrInit('EDITOR.OVR');
    if OvrResult <> ovrOk then
    begin
      case OvrResult of
       ovrError: Writeln('Программа не содержимт оверлеев');
       ovrNotFound: Writeln('Оверлейный файл не найден');
      end;
    Halt(1);
    end;
  end.

------------------------------------------------------------
 Процедура OvrInitEMS                        Модуль Overlay
------------------------------------------------------------
     Фукнция: Если это возможно, загружает оверлейный файл в
расширенную память (EMS).
     Описание: OvrInitEMS
     Примечания: Если имеется драйвер расширенной  памяти  и
имеется  достаточный объем такой памяти, то данная процедура
загружает все оверлеи в расширенную память и закрывает овер-
лейный файл. Последующие загрузки оверлеев сводятся просто к
быстрой  пересылке  их  из  памяти   в   память.   Процедура
OvrInitEMS  устанавливает  также  процедуру выхода, котороая
при завершении работы  программы  автоматически  освобождает
выделенную расширенную память.
     Возможные ошибки могут быть получены с помощью перемен-
ной  операционной среды OvrResult. Значение ovrOk говорит об
успешном  завершении,  ovrError  показывает,  что  процедура
OvrInit завершилась неудачно или не была вызвана, ovrIOError
говорит о том, что при чтении  оверлейного  файла  произошла
ошибка,  ovrNoEMSDriver означает, что не найден драйвер рас-
ширенной памяти, ovrNoEMSMemory - что для загрузки  оверлей-
ного  файла  в расширенной памяти нет достаточного простран-
ства.
     В случае ошибки подсистема управления  оверлеями  будет
продолжать работу, но оверлеи будут считываться с диска.
     Драйвер расширенной памяти должен отвечать  соглашениям
фирм Лотус, Интел и Микрософт (Expamded Memory Specification
- EMS). Если вы используете псевдодиск, размещенный в расши-
ренной  памяти, нужно убедиться в том, что команда, содержа-
щаяся в файле CONFIG.SYS и загружающая  драйвер  псевдодиска
оставляет  некоторый свободный объем расширенной памяти, ко-
торый может использовать ваша прикладная задача.
     Прочее:   См.   также   процедуры  OvrGetBuf,  OvrInit,
OvrSetBuf.
     Пример:

  use Overlay;
  const
  begin
    OvrInit('EDITOR.OVR');
    if OvrResult <> ovrOk then
    begin
       Writeln('Подсистема управления управления оверлеями
 не установлена из-за ошибки');
       Halt(1);
    end;
    OvrInitEMS;
    case OvrResult of
     ovrIOError: Writeln('Ошибка ввода-вывода при чтении
                          оверлейного файла');
     ovrNoEMSDriver: Writeln('Не установлен драйвер
                              расширенной памяти');
     ovrNoEMSMemory('Не хватает объема расширенной памяти');
    else
     Writeln('Для более быстрой работы с оверляеми
              используется расширенная память');
   end;
  end.

------------------------------------------------------------
 Процедура OvrSetBuf                         Модуль Overlay
------------------------------------------------------------
     Фукнция: Устанавливает размер оверлейного буфера.
     Описание: OvrSetBuf(разм_буфера : longint)
     Примечания: Параметр "разм_буфера" должен  быть  больше
или равен начальному размеру оверлейного буфера и меньше или
равер MemAvail + OvrGetBuf. Начальный размер оверлейного бу-
фера  представляет  собой  размер,  возвращаемый  процедурой
OvrGetBuf перед обращениями к OvrSetBuf. Если заданный  раз-
мер превышает текущий размер, то из начала динамически расп-
ределяемой области добавляется дополнительная память, и, та-
ким образом, размер динамически распределяемой области памя-
ти уменьшается. Если же заданный размер меньше текущего,  то
избыточное пространство присоединяется к динамически распре-
деляемой области.
     Процедура OverSetBuf требует, чтобы динамически распре-
деляемая область памяти была пустой. Если с помощью процедур
New  и GetMem уже выделены динамические переменные, то  воз-
никает  ошибка. Поэтому необходимо убедиться в том, что про-
цедура  OvrSetBuf  используется  перед   вызовом   процедуры
InitGraph,  поскольку  процедура InitGraph выделяет память в
динамически распределяемой области, после чего все обращения
к процедуре OvrSetBuf игнорируются.
     Если для увеличения размера оверлейного буфера  вы  ис-
пользуете  процедуру OvrSetBuf, то для соответствующего уве-
личения минимального размера динамически распределяемой  об-
ласти в программу необходимо также включить директиву компи-
лятора $M.
     Возможные ошибки могут быть получены с помощью перемен-
ной  OvrResult.  Значение ovrOk говорит об успешном заверше-
нии, ovrError - о том, что процедура OvrInit завершилась  не
удачно или не была вызвана, что значение "разм_буфера" слиш-
ком мало или что для увеличения размера  оверлейного  буфера
не хватает памяти.
     Прочее:   См.  также  процедуры   OvrGetBuf,   OvrInit,
OvrInitEMS.
     Пример:

 {$M 16384,65536,655360 }
  use Overlay;
  const
    ExtractSize = 49152; { 48K }
  begin
    OvrInit('EDITOR.OVR');
    OvrSetBuf(OvrGetBuf + ExtactSize);
  end.

------------------------------------------------------------
 Процедура PackTime                              Модуль Dos
------------------------------------------------------------
     Функция: Преобразует запись DateTime (дата и  время)  в
четырехбайтовое   значение,  преобразуя  длинный  целый  тип
представления даты и времени, используемый  процедурой  Set-
Time.
     Описание: PackTime(var DT: DateTime; var  Time  :  lon-
gint)
     Примечания: Запись DateTime описана в модуле Dos следу-
ющим образом:

 DateTime = record
               Year, Month, Day, Hour, Min, Sec : word;
            end;

     Для полей данной записи не выполняется проверка на пра-
вильность границ.
     Прочее:   См.  также  процедуры  UnPackTime,   GetTime,
SetTime, GetFTime, SetFTime.

------------------------------------------------------------
 Функция ParamCount
------------------------------------------------------------
     Функция: Возвращает число параметров,  переданных  в  в
командной строке.
     Описание: ParamCount
     Тип результата: Слово (word).
     Примечания: Разделителями служат пробелы и символы  та-
буляции.
     Прочее: См. также функцию ParamStr.
     Пример:

 begin
   if ParamCount < 1 then
      Writeln('В командной строке нет параметров');
   else
      Writeln(ParamCount,' параметров');
 end.

------------------------------------------------------------
 Функция ParamStr
------------------------------------------------------------
     Функция: Возвращает заданный параметр командной строки.
     Описание: РаrамStr(индекс)
     Примечания: Параметр "индекс" представляет собой  выра-
жение длиной в слово. Данная функция возвращает из командной
строки параметр, номер  которого  задается  параметром  "ин-
декс",  или  пустую строку, если "индекс" равняется нулю или
больше, чем РаrамСоunt.
     Прочее: См. также функцию ParamCount.
     Пример:

 var i : word;
 begin
   for i := 1 to ParamCount do
        Writeln(PaamStr(i));
 end.

------------------------------------------------------------
 Функия Pi
------------------------------------------------------------
     Функция:    Возвращает    значение    числа          Pi
(3,1415926535897932385).
     Описание: Pi
     Тип результата: Вещественный (real).
     Примечания: В зависимости от того, работает ли компиля-
тор  в  режиме  процессора 8087 (80287, 80387), или только в
режиме программного обеспечения, точность может меняться.
     Отличия: В версии 3.0 число Рi представляло собой конс-
танту.

------------------------------------------------------------
 Процедура PieSlice                            Модуль Graph
------------------------------------------------------------
     Функция: Рисует и заполняет цветом сектор круга.  Точка
(Х,Y)  при этом используется в качестве центра окружности, а
сектор рисуется от начального угла до конечного угла.
     Описание: PieSlice(х, у : integer; нач_угол,  кон_угол,
радиус : word)
     Примечания: Контур сектора вычерчивается  текущим  цве-
том,  а  при  закрашивании используются тип и цвет закраски,
заданные процедурами SetFillStyle и SetFillPattern.
     В каждом графическом  драйвере  содержится  коэффициент
относительного удлиннения, который используется в процедурах
Сircle, Аrс и РieSlice. Начальный угол, равный 0 и  конечный
угол, равный 359, задают вычерчивание полной окружности.
     Ограничения: Должен использоваться графический режим.
     Прочее:  См.  также  процедуры  Arc,  Circle,  Ellipse,
GetArcCoods, GetAspectRatio, SetFillStyle, SetFillPatern.
     Пример:

 uses Graph;
 const
   Radius = 30;
 var
   Gr, Gm : integer;
 begin
   Gd := Detect;
   InitGraph(Gd, Gm, '');
   if GraphResult <> grOk then
      Halt(1);
 PieSlice(100, 100, 0, 270, Radius);
 Readln;
 CloseGraph;
 end.

------------------------------------------------------------
 Функция Pos
------------------------------------------------------------
     Функция: Производит поиск подстроки в строке.
     Описание: Pos(подстрока, s : string)
     Тип результата: Байт (byte).
     Примечания: Параметры "подстрока" и s являются  выраже-
ниями строкового типа. Данная функция ищет подстроку, задан-
ную параметром "подстрока", в строке s  и  возвращает  целое
значение,  являющееся  позицией  первого символа подстроки в
строке s. Если подстрока не найдена, то  функция  возвращает
значение 0.
     Пример:

 var
   s : string;
  begin
   s := '    123.5';
 { преобразует пробелы в нули }
   while Pos(' ',s) > 0  do
     s[Pos(' ',s)] := '0';
   end;

------------------------------------------------------------
 Функция Pred
------------------------------------------------------------
     Функция: Возвращает предшествующее значение аргумента.
     Описание: Pred(x)
     Тип результата: Совпадает с типом параметра.
     Примечания: Параметр x - выражение перечислимого  типа.

Результат, имеющий тот же тип, что и x, является предществу-
ющим значением x.
     Прочее: См. также функции Succ, Dec.

------------------------------------------------------------
 Функция Ptr
------------------------------------------------------------
     Функция: Преобразует адрес, заданный  в  виде  базового
сегмента и смещения, в значение типа указатель.
     Описание: Рtr(сегм, смещ : word)
     Примечания: Параметры "сегм" и "смещ" представляют  со-
бой выражения длиной в слово. Результатом является указатель
на адрес, заданный параметрами "сегм" и "смещ". Как и указа-
тель типа nil, результат функции Рtr совместим по присваива-
нию с указателями любых типов.
     Результат функции можно проанализировать, например:

 if Prt($40, $49)^ = 7 then
    Writeln('видеорежим = моно');

     Прочее: См. также функцию Addr.
     Пример:

 var
   p : ^byte;
 begin
   p := Ptr($40, $49);
   Writeln('Текущим видеорежимом является ', p^);
 end;

------------------------------------------------------------
 Процедура PutImage                            Модуль Graph
------------------------------------------------------------
     Функция: Выводит из буфера на экран двоичный образ  за-
данной области экрана.
     Описание:  PutImage(х1,  у1,  х2,  у2,  :   word;   var
бит_масс; дв_опер : word)
     Примечания: Точка с координатами (х,у) определяет верх-
ний   левый  угол  прямоугольной  области  экрана.  Параметр
"бит_масс" является нетипизованным параметром, который опре-
деляет  ширину  и  высоту области экрана. Параметр "дв_опер"
определяет, какой двоичный оператор будет использоваться для
вывода двоичного образа области на экран.
     Определены следующие константы:

 const
   NormalPut  = 0;                         { MOV }
   XORPut     = 1;                         { XOR }
   OrPut      = 2;                         { OR  }
   AndPut     = 3;                         { AND }
   NotPut     = 4;                         { NOT }

     Каждая константа соотвествует двоичной операции. Напри-
мер, PutImage(x,y,BitMap,NormalPut) выводит на экран  двоич-
ный  образ,  сохраненный  в  массиве BitMap, начиная с точки
(x,y). При этом для вывода каждого  байта  двоичного  образа
используется инструкция ассемблера МОV.
     Аналогично:

     PutImage(x,y,BitMap,XORPut)

выводит на экран двоичный образ, сохраненный в массиве  Bit-
Map, начиная с точки (x,y). При этом для вывода каждого бай-
та двоичного образа используется инструкция ассемблера  ХОR.
Этот метод часто используется для мультипликации и перемеще-
ния изображения по экрану.

     PutImage(x,y,BitMap,NotPut)

инвертирует биты в BitMap и выводит двоичных  образ,  сохра-
ненный в BitMap, начиная с точки (x,y). При этом для каждого
байта двоичного  образа  используется  инстркция  ассемблера
MOV.  Таким образом двоичных образ при выводе получает нега-
тивное по отношению к исходному изображение.
     Заметим, что процедра PutImage никогда не выполняет от-
сечение  изображения  на границах текущей области просмотра.
Более того, за одним исключнием оно не отсекается  также  на
границе  всего  экрана. В этом случае, если какая-либо часть
изображения не помещается в поле экрана, оно вообще не выво-
дится.  В  следующем примере первый образ экрана будет выве-
ден, а средние три вызова  PutImage  не  приведут  к  выводу
изображения.

  program NoClip;
  uses Graph;
  var
    Driver, Mode : integer;
    p : pointer;
  begin
    Driver := Detect;
    InitGraph(Driver, Mode, '');
    if GraphResult <> grOk then
       Halt(1);
    SetViewPort(0, 0, GetMaxX, GetMaxY, ClipOn);
    GetMem(p, ImageSize(0, 0, 0, 99, 49));
    PieSlice(50, 25, 0, 360, 45);
    GetImage(0, 0, 99, 49, p^);  { ширина = 100,
                                   высота = 50 }
    ClearDevice;
    PutImage(GetMaxX - 99, 0, p^, NormalPut);
             { x + высота > GetMaxX }
    PutImage(-1, 0, p^, NormalPut); { -1,0 не находится на
                                      экране }
    PutImage(0, -1, p^, NormalPut); { 0,-1 не находится на
                                      экране }
    PutImage(0, GetMaxY - 30, p^, NormalPut)
             { выведет 31 "строку" }
    Readln;
    CloseGraph;
    end.

     В последнем обращении к PutImage высота  отсекается  по
нижнему  краю  экрана  и  часть  изображения  выводится. Это
единственных случай, когда процедура PutImage отсекает выво-
димое изображение.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры GetImage, ImageSize.
     Пример:

 uses Graph;
 var
    p  : pointer;
  Size : word;
 begin
  Gd := Detect;
  InitGraph(Gd, Gm, '');
  ig GraphResult <> grOk then
     Halt(1);
  Bar(0, 0, GetMaxX, GetMaxY);
  Size := ImageSize(10,20,30,40);
  GetMem(p, Size);  { выделить память в динамически распре-
                       деляемой области }
  GetImage(10,20,30,40,p^); { считать двоичный образ }
  PutImage(100,100,p^,NormalPut); { скопировать двоичный
                                      образ }
  Readln;
  CloseGraph;
 end.

------------------------------------------------------------
 Процедура PutPixel
------------------------------------------------------------
     Функция: Строит элемент изображения) в точке (x,y).
     Описание: PutPixel(x,y : integer; эл_изображ : word).
     Примечания: Строит в (x,y) точку, цвет которой  опреде-
ляется параметром "эл_изобр".
     Ограничения: Должен использоваться графический режим.
     Прочее: См. также процедуры GetImage, GetPixel,  PutIm-
age.
     Пример:

 uses Graph;
 var
    p  : pointer;
 Color : word;
 begin
  Gd := Detect;
  InitGraph(Gd, Gm, '');
  ig GraphResult <> grOk then
     Halt(1);
  Color := GetMaxColor;
 Randomize;
 repeat
   PutPixel(Random(100),Random(100),Color); { строит
                                              "звездочки" }
   Delay(10);
 until KeyPressed;
 Readln;
 CloseGraph;
 end.

------------------------------------------------------------
 Функция Random
------------------------------------------------------------
     Функция: Возвращает случайное число.
     Описание: Random(диапазон : word)
     Тип результата: Совпадает с типом параметра.
     Примечания: Если параметр "диапазон" не задан,  то  ре-
зультатом будет вещественное число x в диапазоне 0 <= х < 1.
Если задан параметр "диапазон", то  он  должен  представлять
собой  выражение  целого типа, а результатом будет случайное
число длиной в слово в диапазоне 0 <= х < N, где N -  значе-
ние,  заданное  параметром "диапазон". Если параметр "диапа-
зон" меньше или равен нулю, то  вовращаемое  значение  будет
равно нулю.
     Генератор случайных чисел Random  должен  инициализиро-
ваться обращением к процедуре Randomize.
     Прочее: См. также процедуру Randomize.

     Пример:

 uses Crt;
  begin
    Randomize;
    repeat
  { вывести текст со случайно выбранным цветом }
    TexAttr := Random(256);
    Write('!');
  until KeyPressed;
 end.

------------------------------------------------------------
 Процедура Randomize
------------------------------------------------------------
     Функция: Инициализирует встроенный генератор  случайных
чисел случайным значением.
     Описание: Randomize
     Примечания: Случайное значение получается от системного
таймера.

           Замечание: Число, получаемое в результате  работы
      генератора  случайных  чисел,  хранится в предописаной
      переменной с именем RandSeed. Путем присваивания  этой
      переменной  конкретного значения можно получать каждый
      раз заданную последовательность случайных  чисел.  Это
      особено полезно в прикладных задачах, где используется
      кодирование данных.
           Прочее: См. также процедуру Random.

------------------------------------------------------------
 Процедура Read (типизованные файлы)
------------------------------------------------------------
     Функция: Считывает в переменную элемент файла.
     Описание: Read(f, v1, [, v2,...,vn])
     Примечания: Параметр f  является  файловой  переменной,
соответствующей  любому типу файла, кроме текстового, а каж-
дый элемент v представляет собой переменную  того  же  типа,
что  и  элемент  файла f. При каждом считывании в переменную
текущая позиция в файле продвигается к следующему  элементу.
Попытка  считывания  следующего элемента файла в тот момент,
когда текущая позиция файла находится в конце файла (то есть
когда Еоf(f) имеет значение Тruе) является ошибкой.
     При  указании  директивы  компилятора   {$I-}   функция
IORеsult будет возвращать значение 0 в том случае, если опе-
рация завершилась успешно, и ненулевой код ошибки в  против-
ном случае.
     Ограничения: Файл должен быть открыт.
     Прочее: См. также процедуру Write.

------------------------------------------------------------
 Процедура Read (текстовые файлы)
------------------------------------------------------------
     Функция: Считывает одно или более значений из текстово-
го файла в одну или более переменных.
     Описание: Read( [ var f : text; ] v1, [, v2,...,vn ] )
     Примечания: Параметр f (если он указан) является файло-
вой  переменой,  соответствующей  текстовому  файлу. Если он
опущен, то подразумевается использование стандартной  файло-
вой  переменной Input. Каждый параметр v является переменной
символьного, строкового, целого или вещественного типа.
     В случае строкового типа процедура  Rеаd  считывает  из
файла  один  символ и присваивает его переменной. Если перед
выполнением процедуры Rеаd функция Еоf(f) принимала значение
Тruе,  то  переменной присваивается значение Сhr(26) (символ
Сtrl-Z). Если функция Еоln(f)  принимала  истинное  значение
(Тruе),  то переменной присваивается значение Сhr(3) (символ
возврата каретки). Следующая операция Rеаd начнется со  сле-
дующего символа в файле.
     В случае переменной целого типа процедура Rеаd  ожидает
поступления последовательности символов, образующих число со
знаком, согласно синтаксису, указанному  в  разделе  "Числа"
Главы 17 ("Символы и константы"). Любые пробелы, знаки табу-
ляции или метки конца строки, предшествующие числовой  стро-
ке,  пропускаются.  Считывание  прекращается при обнаружении
первого пробела, символа табуляции или метки  конца  строки,
которые  следуют за числовой строкой, или в том случае, если
функция Еоf(f) принимает значение Тruе. Если числовая строка
не  соответствует  ожидаемому  формату, то происходит ошибка
ввода-вывода. В противном  случае  переменной  присваивается
значение.  Если функция Еоf(f) имела значение Тruе перед вы-
полнением процедуры Rеаd, или функция Еоf(f) приняла  значе-
ние  Тruе  при пропуске начальных пробелов, знаков табуляции
или меток конца строки, то переменной присваивается  нулевое
значение. Следующая операция Rеаd начнется с пробела, симво-
ла табуляции или метки конца  строки,  которыми  завершилась
числовая строка.
     В случае переменной вещественного типа  процедура  Rеаd
ожидает поступления последовательности символов, которые об-
разуют число в соответствии с синтаксисом, показанным в раз-
деле "Числа" Главы 17 ("Символы и константы"), за исключени-
ем того, что шестнадцатиричное представление не допускается.
Любые пробелы, знаки табуляции или метки конца строки, пред-
шествующие цисловой строке, пропускаются. Считывание прекра-
щается  при  обнаружении  первого пробела, символа табуляции
или метки конца строки, которые следуют за числовой строкой,
или  в  том  случае,  если функция Еоf(f) принимает значение
Тruе. Если числовая строка не соответствует ожидаемому  фор-
мату,  то происходит ошибка ввода-вывода. В противном случае
переменной присваивается значение. Если функция Еоf(f) имела
значение  Тruе перед выполнением процедуры Rеаd, или функция
Еоf(f) приняла значение Тruе при пропуске  начальных  пробе-
лов,  знаков табуляции или меток конца строки, то переменной
присваивается нулевое значение. Следующая операция Rеаd нач-
нется  с  пробела, символа табуляции или метки конца строки,
которыми завершилась числовая строка.
     В случае переменной строкового типа процедура Rеаd счи-
тывает  все  символы, вплоть до следующей метки конца строки
(но не включая ее), или пока функция Еоf(f) не примет значе-
ние Тruе. Переменной присваивается получившаяся в результате
символьная строка. Если длина результирующей строки превыша-
ет  длину,  максимально допустимую для строковой переменной,
то она усекается. Следующая операция Rеаd начинается с метки
конца строки, которой завершилась предыдущая строка.
     При  указании  директивы  компилятора   {$I-}   функция
IORеsult будет возвращать значение 0 в том случае, если опе-
рация завершилась успешно, и ненулевой код ошибки в  против-
ном случае.
     Ограничения: Процедура Rеаd со строковой переменной  не
делает после считывания пропуск до следующей строки. Поэтому
для считывания последовательности строк нельзя  использовать
последовательные  обращения  к процедуре Rеаd, поскольку при
этом вы никогда не перейдете  дальше  первой  строки.  После
первого обращения к процедуре Rеаd последующие операции Rеаd
будут обнаруживать метку конца строки  и  возвращать  строку
нулевой  длины.  Поэтому  для  считывания последовательности
строк используйте обращения процедуре Rеаdln.
     Отличия: См. Приложение А.
     Прочее: См. также процедуры Readln, ReadKey.

------------------------------------------------------------
 Функция ReadKey                                 Модуль Сrt
------------------------------------------------------------
     Функция: Считывает символ с клавиатуры.
     Описание: ReadKey
     Тип результата: Символьный (char).
     Примечания: Считываемый символ не отображается на экра-
не.   Если   перед  обращением  к  функции  RеаdКеу  функция
КеyРressed имела значение Тruе, то символ считывается немед-
ленно, в противном случае фукнция ожидает нажатия клавиши.
     Специальные клавиши на клавиатуре компьютера РС генери-
руют  расширенные коды клавиш. (Расширенные коды клавиш при-
ведены в  Приложении  Е.)  Специальными  клавишами  являются
функциональные клавиши, клавиши управления курсором, клавиши
Аlt и т.д. При нажатии специальной  клавиши  фунция  RеаdКеу
возвращает  сначала  нулевой символ ( 0), а затем расшренный
код клавиши. Нулевые символы не могут быть получены  никаким
другим путем. Этим обеспечивается то, что следующим символом
будет расширенный код клавиши.
     В следующем фрагменте программы в переменную  с  именем
Сh  считывается символ или расширенный код клавиши и для пе-
ременной FuncKey булевского  типа  устанавливается  значение
Тruе, если символ является кодом специальной клавиши.

 Ch := ReadKey;
 if Ch <> #0 then FuncKey := False else
 begin
   FuncKey := True;
   Ch := ReadKey;
 end;

     Переменная СhеаkВrеак управляет тем, будет ли программа
прекращать работу при нажатии клавиш Сtrl-Вrеаk, или они бу-
дут рассматриваться, как любые другие клавиши.  Когда  пере-
менная  СhеакВrеаk  имеет  значение  False,  функция ReаdКеy
возвращает для клавиш Сtrl-Вrеаk значение Сtrl-С ( 3).
     Прочее: См. также функцию KeyPressed.

------------------------------------------------------------
 Процедура Readln
------------------------------------------------------------
     Функция: Выполняет процедуру Rеаd,  затем  переходит  к
следующей строке файла.
     Описание: Readln( [ var f : text; ] v1 [, v2,...,vn ] )
     Примечания: Процедура Rеаdln является расширением  про-
цедуры  Rеаd и определена для текстовых файлов. После выпол-
нения процедуры Rеаd процедура Rеаdln делает пропуск до  на-
чала следующей строки.
     Вызов функции Rеаdln(f) без параметров приводит к пере-
мещению  текущей  позиции  файла  на начало следующей строки
(если она имеется, в противном случае происходит  переход  к
концу файла). Функция Rеаdln без списка параметров полностью
соответствует обращению Rеаdln(Input).
     При  указании  директивы  компилятора   {$I-}   функция
IORеsult будет возвращать значение 0 в том случае, если опе-
рация завершилась успешно, и ненулевой код ошибки в  против-
ном случае.
     Ограничения: Функция работает только для текстовых фай-
лов,  включая станадартный ввод. Файл должен быть открыт для
ввода.

     Прочее: См. также фукнцию Read.

------------------------------------------------------------
 Процедура Rectangle                           Модуль Graph
------------------------------------------------------------
     Функция: Рисует прямоугольник, используя текущий цвет и
тип строки.
     Описание: Rectangle(x1, y1, x2, x2 : integer)
     Примечания: Точка  с  координатами  (х1,у1)  определяет
верхний  левый  угол  прямоугольника, а точка с координатами
(х2,у2) определяет нижний правый угол  (0  <=  х1  <  х2  <=
GetМахХ и 0 <= у1 < у2 <= GetМахY).
     При вычерчивании  прямоугольника  будут  использоваться
текущий   тип   строки   и   цвет,  которые  устанавливаются
процедурой SetLineStyle.
     Аналогичная процедура имеется в версии 2.0 Турбо-Си.
     Ограничения: Должен использоваться графический режим.
     Прочее: См.  также  процедуры  InitGraph,  SetViewPort,
Bar, GetViewSettings, Bar3D.
     Пример:

 uses Graph;
 var
   GraphDriver, GraphMode : integer;
   x1, y1, x2, y2 : integer;
 begin
   GraphDriver := Detect;
   InitGraph(GraphDriver,GraphMode,'');
   if GraphResult <> grOk then
      Halt(1);
   Randomize;
   repeat
       x1 := Random(GetMaxX);
       y1 := Random(GetMaxY);
       x2 := Random(GetMaxX - x1) + x1;
       y2 := Random(GetMaxY - y1) + y1;
   Rectangle(x1,y1,x2,y2);
  until KeyPressed;

    CloseGraph;
 end.

------------------------------------------------------------
 Функция RegisterBGIdriver
------------------------------------------------------------
     Функция: Регистрирует в графической системе загруженный
пользователем или скомпонованный с программой драйвер форма-
та BGI (формат фирмы Борланд).
     Описание: RegisterBGIdriver(драйвер :  pointer)  :  in-
teger;
     Примечания: В случае ошибок возвращаемое значение мень-
ше  нуля.  В  противном случае возвращается внутренний номер
драйвера. Эта  программа  позволяет  пользователю  загрузить
файл  драйвера и зарегистрировать драйвер, передав его адрес
в памяти функции RegisterBGIdriver. После этого драйвер  мо-
жет  непосредственно  использоваться процедурой InitGraph, а
не загружаться с диска модулем Graph.  Драйвер  пользователя
можно загрузить с диска в динамически распределяемую область
памяти или преобразовать в  файл  .OBJ  (с  помощью  утилиты
BINOBJ.EXE),  после  чего  скомпоновать  с программой в файл
.EXE.
     Возможной возвращаемой ошибкой является grInvalidDriver
(недопустимый  графический драйвер). При этом код ошибки ра-
вен -4 и заголовок драйвера оказывается неопознанным.
     Следующая программа загружает в динаимчески распределя-
емую  область  памяти драйвер CGA, регистрирует его в графи-
ческой системе и вызывает процедуру InitGraph.

  program LoadDriv;
  uses Graph;
 var
   Driver, Mode : integer;
   DriverF : file;
   DriverP : pointer;
 begin
 { открыть файл драйвера, считать его в память и
   зарегистрировать }
   Assign(DriverF, 'CGA.BGI');
   Reset(DriverF, 1);
   GetMem(DriverP, FileSize(DriverF));
   if RegisterBGIdriver < 0 then
   begin
     Writeln('Ошибка регистрации драйвера: ',
              GraphErrorMSG(GraphResult));
     Halt(1);
   end;
   { инициализация графики }
   Driver := CGA;
   Mode := CGAHi;
   InitGraph(Driver,Mode,'');
   if GraphResult <> grOk then
      Halt(1);
   OutText('Драйвер загружен программой пользователя');
   Readln;
   CloseGraph;
  end.

     Эта программа начинает работу с загрузки драйвера CGA с
диска  и  регистрации  его с помощью модуля Graph. Затем для
инициализации графической системы  выполняется  обращение  к
процедуре  InitGraph. Вы можете захотеть разместить один или
более файлов непосредственно в файле .EXE. При  этом  графи-
ческие драйверы, которые требуются вашей программе, окажутся
встроенными и для работы потребуется только файл .EXE.  Про-
цесс  размещения драйвера в выполняемом файле довольно прост
и состоит в следующем:

     1.  Выполнить для файла (или файлов) программу BINOBJ.
     2.  Скомпоновать  результирующие  файлы  ,OBJ  с  вашей
         программой.
     3.  Перед вызовом процедуры Init зарегистрировать ском-
         понованные файлы (файл) драйвера.

     Более подробное описание этого процесса можно  найти  в
комментариях,   содержащихся   в   шапке   программы-примера
GRLINK.PAS на диске 3. Документация по утилите BINOBJ содер-
жится в Приложении С "Руководства пользователя".
     Имеется также возможность регистрации в системе  файлов
шрифтов (см. описание функции RegisterBGIfont).
     Аналогичная функция имеется в версии 2.0 Турбо-Си.
     Ограничения: Заметим, что драйвер должен быть зарегист-
рирован перед обращением к процедуре InitGraph. Если функция
RegisterBGIdriver вызывается, когда средства графики уже ак-
тивизированы, то возвращается значение -11 (grError).
     Прочее:    См.    также    процедуры    InitGraph     и
InstallUserDriver.

------------------------------------------------------------
 Функция RegisterBGIfont
------------------------------------------------------------
     Функция:  Регистрирует  загружаемый  пользователем  или
скомпонованный  с программой шрифт формата BGI (формат фирмы
Борланд) в графической системе.
     Описание: RegisterBGIfonr(шрифт : pointer) : integer;
     Примечания: В случае ошибки возвращаемое значение будет
меньше  0.  В противном случае возвращается внутренний номер
шрифта. Эта программа позволяет пользователю загрузить  файл
шрифта и "зарегистрировать" шрифт, передав его адрес в памя-
ти процедуре RagisterBGIfont. После этого данный шрифт можно
выбирать  с помощью обращения к процедуре SetTextStyle. Выб-
ранный шрифт будет непосредственно использоваться без  необ-
ходимости  загрузки его с диска модулем Graph. Зарегистриро-
ванный пользователем шрифт можно загрузить с диска в динами-
чески распределяемую область памяти или преобразовать (с по-
мощью утилиты BINOBJ.EXE) в файл .OBJ, а затем  скомпоновать
с программой в выполняемый файл.
     Приведем перечень некоторых возможных ошибок:

------------------------------------------------------------
 Код ошибки  Идентификатор ошибки         Комментарий
------------------------------------------------------------
 -11            grError            При регистрации еще одно-
                                   го шрифта не хватает мес-
                                   та для таблицы шрифтов.
                                   (Таблица шрифтов может
                                   содержать до 10 шрифтов,
                                   из них в стандартной кон-
                                   фигурации имеется только
                                   4, поэтому эта ошибка
                                   возникать не должна.)

 -13           grInvalidFont       Не распознан заголовок
                                   шрифта.

 -14         grInvalidFontNum      Не распознан номер шрифта
                                   в заголовке шрифта.
------------------------------------------------------------

     Следующая программа загружает в динамически распределя-
емую  область  шрифт triplex, регистрирует его в графической
системе, а зетем предоставляет возможность выбора между этим
шрифтом  и  другим  штриховым  шрифтом, который модуль Graph
загружает с диска (SansSerifFont).

  program LoadFont;
  uses Graph;
  var Driver, Mode : integer;
      FontF : file;
      FontP : pointer;
  begin
  { открыть файл шрифта, считать его в память и
    зарегистрировать }
    Assign(FontF, 'TRIP.CHR');
    Reset(FontF, 1);
    GetMem(FontP, FontP^, FileSize(FontF));
    if RegisterBGIfont(FontP) < 0 then
    begin
      Writeln('Ошибка регистрации шрифта: ',
               GraphErrorMsg(GraphResult));
      Halt(1);
    end;
    { инициализировать графику }
    Driver := Detect;
    InitGraph(Driver, Mode, '..\');
    if GraphResult < 0 then
       Halt(1);
    Readln;
    { выбрать зарегистрированный шрифт }
    SetTextStyle(TriplexFont, HorizDir, 4);
    OutText('Программой загружен шрифт Triplex');
    MoveTo(0, TextHeight('a'));
    Readln;
    { Повторно выбрать зарегистрированный шрифт
      (уже загруженный в память }
    SetTextStyle(TriplexFont, HorizDir, 4);
    OutText('Программой снова выбран шрифт Triplex');
    Readln;
    CloseGraph;
  end.

     Программа начинает свою работу с загрузки с диска шриф-
та Triplex и регистрации его модулем Graph. Затем для иници-
ализации графической системы вызывается процедура InitGraph.
Проверьте,  есть  ли  обращение  к  диску  и нажмите клавишу
ENTER. Поскольку теперь шрифт Triplex уже загруже в память и
зарегистрирован, модулю Graph не нужно считывать его с диска
(таким образом, отпадает необходимость обращения к  дисково-
ду).  Затем программа активизирует шрифт SansSerifFont, заг-
ружая его с диска (он  не  зарегистрирован).  Снова  нажмите
клавишу  ENTER  и посмотрите, есть ли обрашение к диску (при
обращении к диску загорается  лампочка-индикатор  на  панели
компьютера).   Наконец,   программа   снова  выбирает  шрифт
Triplex. Поскольку он уже зарегистрирован, то при этом прог-
рамма, когда вы нажмете клавишу ENTER, обращаться к диску не
будет.
     Для загрузки и регистрации файлов шрифтов имеется  нес-
колько  причин. Во-первых, модель Graph в каждый момент вре-
 мени хранит в памяти только один штриховой шрифт. Если у вас
имеется программа, которая должна быстро переключаться с од-
ного шрифта не другой, то возможно вы предпочтете  в  начале
программы  выполнить регистрацию и загрузку шрифта. При этом
при обращении к процедуре SetTextStyle модулю Graph не пона-
добится каждый раз загружать и разгружать шрифт.
     Во-вторых, вы можете захотеть  разместить  файл  шрифта
непосредственно  в  вашем  файле  .EXE.  Таким образом, файл
шрифта, который использует ваша программа, окажется встроен-
ным,  и для запуска программы потребуется только выполняемый
файл (файл .EXE). Процесс размещения файла шрифта в выполня-
емом файле довольно прост и состоит в следующем:

     1.  Выполнить для файла (или файлов) программу BINOBJ.
     2.  Скомпоновать  результирующие  файлы  ,OBJ  с  вашей
         программой.
     3.  Перед вызовом процедуры Init зарегистрировать ском-
         понованные файлы (файл) драйвера.

     Более подробное описание этого процесса можно  найти  в
комментариях,   содержащихся   в   шапке   программы-примера
GRLINK.PAS на диске 3. Документация по утилите BINOBJ содер-
жится в Приложении С "Руководства пользователя".
     Заметим, что в используемый по умолчанию шрифт (с бито-
вым  отображением  8х8)  встроен в модель GRAPH.TPU и, таким
образом, все время находится в памяти. При выборе и загрузке
штрихового  шрифта ваша программа имеет возвожность переклю-
чаться между используемым по умолчанию и  штриховым  шрифтом
без необходимости перезагружать какой-либо из них.
     Можно также регистрировать файлы драйверов (см.  описа-
ние функции RegisterBGIdriver.
     Аналогичная функция имеется в версии 2.0 Турбо-Си.
     Прочее:   См.   также    процедуры    SetTextStyle    и
InstallUserFont.

------------------------------------------------------------
 Процедура Release
------------------------------------------------------------
     Функция: Возвращает динамически распределяемую  область
памяти в указанное состояние.
     Описание: Release(var p : pointer)
     Примечания: Параметр p является  указателем-переменной,
соответствующей  любому  типу  указателей, для которой ранее
было  выполнено  присваивание  с  помощью  процедуры   Маrk.
Процедура  Release отменяет все динамические переменные, для
которых была выделена память  с  помощью  процедур  New  или
GetMem, начиная с того момента, когда была выполнено присва-
ивание для р процедурой Маrk.
     Ограничения: Если не  соблюдены  определенные  правила,
обращения  к  процедурам  Маrk и Release нельзя перемежать с
обращениями к процедурам Dispose и FrееМем. Полное  обсужде-
ние  этой  темы  дается  в  разделе "Программа динамического
распределения памяти" в Главе 15.
     Прочее: См. также процедуры Mark, Dispose, FreeMem.

------------------------------------------------------------
 Процедура Rename
------------------------------------------------------------
     Функция: Переименовывает внешний файл.
     Описание: Rename(f; нов_имя : string)
     Примечания: Параметр f представляет собой файловую  пе-
ременную, соответствующую любому файлу любого типа. Параметр
"нов_имя" является выражением строкового типа. Внешнему фай-
лу,  связанному с переменной f, присваивается новое имя, за-
данное параметром "нов_имя". Дальнейшие операции с  f  будут
выполняться с внешним файлом с новым именем.
     При  указании  директивы  компилятора   {$I-}   функция
IORеsult будет возвращать значение 0 в том случае, если опе-
рация завершилась успешно, и ненулевой код ошибки в  против-
ном случае.
     Ограничения: Процедура Rename не должна  использоваться
для открытого файла.
     Прочее: См. также процедуру Erase.

------------------------------------------------------------
 Процедура Reset
------------------------------------------------------------
     Функция: Открывает существующий файл.
     Описание: Reset(f [ : file; разм_записи : word ] )
     Примечания: Параметр f  является  файловой  переменной,
соответствующей  любому  типу файла. Он должен быть связан с
внешним  файлом  с  помощью   процедуры   Assign.   Параметр
"разм_записи"  представляет  собой  необязательное выражение
длиной в слово и может указываться только в том случае, если
f является нетипизованным файлом.
     Процедура Reset открывает  существующий  внешний  файл,
имя которого было присвоено f. Если внешний файл с указанным
именем отсутствует, то это является ошибкой. Если файл f уже
открыт,  то  он  сначала  закрывается,  а  затем открывается
вновь. Текущая позиция в  файле  устанавливается  на  начало
файла.   Если   f   было  присвоено  пустое  имя  (например,
Assign(f'')), то после обращения к процедуре Reset  f  будет
ссылкой на стандартный файл ввода (стандартный канал 0).
     Если f - текстовый файл,  то  он  становится  доступным
только  по  чтению. После обращения к процедуре Reset Еоf(f)
принимает значение Тruе, если файл пуст, и значение False  в
противном случае.
     Если f  является  нетипизованным  файлом,  то  параметр
"разм-записи"  определяет  размер записи, который должен ис-
пользоваться при передаче данных. Если этот параметр опущен,
то он подразумевается равным по умолчанию 128 байтам.
     При  указании  директивы  компилятора   {$I-}   функция
IORеsult будет возвращать значение 0 в том случае, если опе-
рация завершилась успешно, и ненулевой код ошибки в  против-
ном случае.
     Отличия: В версии 3.0 пустое имя файла было  недопусти-
мо.
     Прочее: См. также процедуры Rewrite, Append, Assign.
     Пример:

 function FileExists(FileName: string) : boolean;
 { булевская функция, возвращающая значение Тruе, если файл
   существует и значение False в противном случае }
 var
   f : file;
 begin

