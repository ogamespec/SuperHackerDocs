


    EПРИЛОЖЕНИЕ F

    EСИСТЕМНЫЕ ОПЕРАЦИИF



    В  приложении дается краткий обзор функций системы UNIX. Полное описание
этих функций содержится в  руководстве  программиста-пользователя  версии  V
системы UNIX. Сведений, приведенных здесь, вполне достаточно для того, чтобы
разобраться в примерах программ, представленных в книге.
    Имена файлов, упоминаемые в тексте, представляют собой последовательнос-
ти  символов, завершающиеся пустым символом и состоящие из компонент, разде-
ленных наклонной чертой. В случае ошибки все функции возвращают код заверше-
ния, равный -1, а код самой ошибки засылается в  переменную  errno,  имеющую
тип  external.  В  случае  успешного завершения код возврата имеет значение,
равное 0. Некоторые из обращений к операционной системе являются точкой вхо-
да сразу для нескольких функций: это означает, что данные функции используют
один и тот же ассемблерный интерфейс. Приводимый список функций удовлетворя-
ет стандартным условиям, принятым в справочных руководствах по системе UNIX,
при этом вопросы, связанные с тем, является ли одно обращение к операционной
системе точкой входа для одной или нескольких функций,  рассматриваются  от-
дельно.


    EaccessF
      ______________________________

      access(filename,mode)
      char *filename;
      int mode;

    Функция  access проверяет, имеет ли процесс разрешение на чтение, запись
или исполнение файла (проверяемый тип доступа зависит от значения  параметра
mode).  Значение  mode является комбинацией двоичных масок 4 (для чтения), 2
(для записи) и 1 (для исполнения). Вместо исполнительного кода идентификации
пользователя в проверке участвует фактический код.


    EacctF
      ______________________________

      acct(filename)
      char *filename;

    Функция acct включает учет системных ресурсов,  если  параметр  filename
непустой, и выключает - в противном случае.


    EalarmF
      ______________________________

      unsigned alarm(seconds)
      unsigned seconds;

    Функция  alarm планирует посылку вызывающему ее процессу сигнала тревоги
через указанное количество секунд (seconds). Она  возвращает  число  секунд,
оставшееся до посылки сигнала от момента вызова функции.


                                    400

    EbrkF
      ______________________________

      int brk(end_data_seg)
      char *end_data_seg;

    Функция brk устанавливает верхнюю границу (старший адрес) области данных
процесса  в соответствии со значением параметра end_data_seg. Еще одна функ-
ция, sbrk, использует ту же точку входа и увеличивает адрес верхней  границы
области на указанную величину.


    EchdirF
      ______________________________

      chdir(filename)
      char *filename;

    Функция  chdir  делает  текущим  каталогом вызывающего процесса каталог,
указанный в параметре filename.


    EchmodF
      ______________________________

      chmod(filename,mode)
      char *filename;

    Функция chmod изменяет права доступа к указанному файлу  в  соответствии
со  значением  параметра  mode, являющимся комбинацией из следующих кодов (в
восьмеричной системе):
      04000    бит установки кода идентификации пользователя
      02000    бит установки группового кода идентификации
      01000    признак sticky bit
      00400    чтение владельцем
      00200    запись владельцем
      00100    исполнение владельцем
      00040    чтение групповым пользователем
      00020    запись групповым пользователем
      00010    исполнение групповым пользователем
      00004    чтение прочим пользователем
      00002    запись прочим пользователем
      00001    исполнение прочим пользователем


    EchownF
      ______________________________

      chown(filename,owner,group)
      char *filename;
      int owner,group;

    Функция chown меняет коды идентификации владельца и группы для указанно-
го файла на коды, указанные в параметрах owner и group.


    EchrootF
      ______________________________


                                    401

      chroot(filename)
      char *filename;

    Функция chroot изменяет частный корень вызывающего процесса в соответст-
вии со значением параметра filename.


    EcloseF
      ______________________________

      close(fildes)
      int fildes;

    Функция close закрывает дескриптор файла, полученный в результате выпол-
нения функций open, creat, dup, pipe или fcntl, или унаследованный от  функ-
ции fork.


    EcreatF
      ______________________________

      creat(filename,mode)
      char *filename;
      int mode;

    Функция  creat создает новый файл с указанными именем и правами доступа.
Параметр mode имеет тот же смысл, что и в функции access, при  этом  признак
sticky-bit  очищен, а разряды, установленные функцией umask, сброшены. Функ-
ция возвращает дескриптор файла для последующего использования в других фун-
кциях.


    EdupF
      ______________________________

      dup(fildes)
      int fildes;

    Функция dup создает копию указанного дескриптора файла, возвращая  деск-
риптор  с наименьшим номером из имеющихся в системе. Старый и новый дескрип-
торы используют один и тот же указатель на файл, а также и другие  совпадаю-
щие атрибуты.


    EexecF
      ______________________________

      execve(filename,argv,envp)
      char *filename;
      char *argv[];
      char *envp[];

    Функция execve исполняет файл с именем filename, загружая его в адресное
пространство  текущего процесса. Параметр argv соответствует списку аргумен-
тов символьного типа, передаваемых запускаемой программе, параметр envp  со-
ответствует массиву, описывающему среду выполнения нового процесса.




                                    402
    EexitF
      ______________________________

      exit(status)
      int status;

    Функция  exit  завершает  вызывающий  процесс,  возвращая его родителю 8
младших разрядов из слова состояния процесса. Ядро само может  вызывать  эту
функцию в ответ на поступление определенных сигналов.


    EfcntlF
      ______________________________

      fcntl(fildes,cmd,arg)
      int fildes,cmd,arg;

    Функция  fcntl  обеспечивает выполнение набора разнообразных операций по
отношению к открытым файлам, идентифицируемым с помощью дескриптора  fildes.
Параметры  cmd и arg интерпретируются следующим образом (определение буквен-
ных констант хранится в файле "/usr/include/fcntl.h"):

      F_DUPFD    вернуть наименьшее значение дескриптора,  большее
                 или  равное значению arg
      F_SETFD    установить флаг "close-on-exec" в младшем разря-
                 де arg (файл будет закрыт функцией exec)
      F_GETFD    вернуть состояние флага "close-on-exec"
      F_SETFL    установить  флаги,  управляющие состоянием файла
                 (O_NDELAY - не приостанавливаться в ожидании за-
                 вершения ввода-вывода,   O_APPEND - записываемые
                 данные добавлять в конец файла)
      F_GETFL    получить значения флагов, управляющих состоянием
                 файла

      struct flock
              short l_type;   /* F_RDLCK - блокировка     чтения,
                                 F_WRLCK - блокировка     записи,
                                 F_UNLCK - снятие блокировки */
              short l_whence; /* адрес начала блокируемого участ-
                                 ка дается в виде смещения  отно-
                                 сительно начала файла (0), отно-
                                 сительно текущей позиции  указа-
                                 теля (1),    относительно  конца
                                 файла (2) */
              long l_start;   /* смещение в байтах, интерпретиру-
                                 емое в соответствии со значением
                                 l_whence */
              long l_len;     /* длина  блокируемого  участка   в
                                 байтах. Если указан 0,  блокиру-
                                 ется участок от l_start до конца
                                 файла */
              long l_pid;     /* идентификатор процесса, блокиру-
                                 ющего файл */
              long l_sysid;   /* системный идентификатор  процес-
                                 са, блокирующего файл */

      F_GETLK    прочитать  первый код блокировки,  мешающей  ис-
                 пользовать значение arg и  затирать  его.   Если
                 блокировка отсутствует, поменять значение l_type
                 в arg на F_UNLCK

                                    403

      F_SETLK    установить или снять блокировку файла в  зависи-
                 мости от значения arg.  В  случае  невозможности
                 установить блокировку вернуть -1
      F_SETLKW   установить или снять блокировку  содержащихся  в
                 файле данных  в  зависимости от значения arg.  В
                 случае невозможности установить блокировку  при-
                 остановить выполнение

      Блокировки,  связанные с чтением из файла, могут перекрывать друг дру-
га. Блокировки, связанные с записью, перекрываться не могут.


    EforkF
      ______________________________

      fork()

    Функция fork создает новый процесс. Порождаемый процесс представляет со-
бой логическую копию процесса-родителя. На выходе из функции  процессу-роди-
телю возвращается код идентификации потомка, потомку - нулевое значение.


    EgetpidF
      ______________________________

      getpid()

    Функция  getpid  возвращает  идентификатор  вызывающего процесса. Эту же
точку входа используют функции: getpgrp, возвращающая идентификатор  группы,
в  которую  входит вызывающий процесс, и getppid, возвращающая идентификатор
процесса, который является родителем текущего процесса.


    EgetuidF
      ______________________________

      getuid()

    Функция getuid возвращает фактический код идентификации пользователя вы-
зывающего процесса. Эту же точку входа используют функции: geteuid,  возвра-
щающая  исполнительный  код идентификации пользователя, getgid, возвращающая
групповой код, и getegid, возвращающая исполнительный групповой код  иденти-
фикации вызывающего процесса.


    EioctlF
      ______________________________

      ioctl(fildes,cmd,arg)
      int fildes,cmd;

    Функция ioctl выполняет набор специальных операций по отношению к откры-
тому устройству, дескриптор которого указан в параметре fildes. Тип команды,
выполняемой  по  отношению к устройству, описывается параметром cmd, а пара-
метр arg является аргументом команды.


    EkillF
      ______________________________

                                    404

      kill(pid,sig)
      int pid,sig;

    Функция kill посылает процессам, идентификаторы которых указаны в  пара-
метре pid, сигнал, описываемый параметром sig.

      pid   имеет        сигнал посылается процессу с идентифика-
      положитель-        тором pid
      ное значение
      pid = 0            сигнал посылается  процессам,  групповой
                         идентификатор которых  совпадает с иден-
                         тификатором отправителя
      pid = -1           если процесс-отправитель исполняется под
                         идентификатором суперпользователя,  сиг-
                         нал посылается всем процессам, в против-
                         ном случае, сигнал посылается процессам,
                         фактический код  идентификации пользова-
                         теля у которых совпадает с идентификато-
                         ром суперпользователя
      pid < -1           сигнал посылается  процессам,  групповой
                         идентификатор которых совпадает с pid

    Исполнительный  код идентификации пользователя процесса-отправителя дол-
жен указывать на суперпользователя, в противном случае, фактический или  ис-
полнительный коды идентификации отправителя должны совпадать с соответствую-
щими кодами процессов-получателей.


    ElinkF
      ______________________________

      link(filename1,filename2)
      char *filename1,*filename2;

    Функция  link присваивает файлу filename1 новое имя filename2. Файл ста-
новится доступным под любым из этих имен.


    ElseekF
      ______________________________

      lseek(fildes,offset,origin)
      int fildes,origin;
      long offset;

    Функция lseek изменяет положение указателя  чтения-записи  для  файла  с
дескриптором fildes и возвращает новое значение. Положение указателя зависит
от значения параметра origin:

      0    установить указатель на позицию,  соответствующую ука-
           занному смещению в байтах от начала файла
      1    сдвинуть указатель с его текущей позиции  на указанное
           смещение
      2    установить указатель на позицию,  соответствующую ука-
           занному смещению в байтах от конца файла


    EmknodF
      ______________________________

                                    405

      mknod(filename,modes,dev)
      char *filename;
      int mode,dev;

    Функция  mknod создает специальный файл, каталог или поименованный канал
(очередь по принципу "первым пришел - первым вышел") в зависимости от значе-
ния параметра modes:

      010000   поименованный канал
      020000   специальный файл устройства ввода-вывода символами
      040000   каталог
      060000   специальный файл устройства ввода-вывода блоками

    12 младших разрядов параметра modes имеют тот же самый смысл,  что  и  в
функции  chmod. Если файл имеет специальный тип, параметр dev содержит стар-
ший и младший номера устройства.


    EmountF
      ______________________________

      mount(specialfile,dir,rwflag)
      char *specialfile,*dir;
      int rwflag;

    Функция mount выполняет монтирование файловой системы, на которую указы-
вает параметр specialfile, в каталоге dir. Если младший бит параметра rwflag
установлен, файловая система монтируется только для чтения.


    EmsgctlF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>

      msgctl(id,cmd,buf)
      int id,cmd;
      struct msgid_ds *buf;

    В зависимости от операции, указанной в параметре cmd, функция msgctl да-
ет процессам возможность устанавливать или запрашивать информацию о  статусе
очереди  сообщений с идентификатором id, а также удалять очередь из системы.
Структура msquid_ds определена следующим образом:

    struct ipc_perm {
         ushort  uid;  /* идентификатор текущего пользователя */
         ushort  gid;  /* идентификатор текущей группы */
         ushort cuid;  /* идентификатор пользователя-создателя */
         ushort cgid;  /* идентификатор группы создателя */
         ushort mode;  /* права доступа */
         short  pad1;  /* используется системой */
         long   pad2;  /* используется системой */
    };

    struct msquid_ds {
          struct ipc_perm   msg_perm; /* структура,   описывающая
                                         права доступа */

                                    406

          short             pad1[7];  /* используется системой */
          ushort            msg_qnum; /* количество  сообщений  в
                                         очереди */
          ushort            msg_qbytes; /* максимальный    размер
                                           очереди в байтах */
          ushort            msg_lspid; /* идентификатор процесса,
                                          связанного  с последней
                                          посылкой сообщения */
          ushort            msg_lrpid; /* идентификатор процесса,
                                          связанного  с последним
                                          получением сообщения */
          time_t            msg_stime; /* время последней посылки
                                          сообщения */
          time_t            msg_rtime; /* время последнего  полу-
                                          чения сообщения */
          time_t            msg_ctime; /* время последнего  изме-
                                          нения */
    };

    Типы операций:

    IPC_STAT   Прочитать в буфер заголовок очереди сообщений, ас-
               социированный с идентификатором id
    IPC_SET    Установить   значения  переменных    msg_perm.uid,
               msg_perm.gid, msg_perm.mode  (9  младших  разрядов
               структуры msg_perm) и mgr_qbytes в соответствии со
               значениями, содержащимися в буфере
    IPC_RMID   Удалить из системы очередь сообщений с идентифика-
               тором id


    EmsggetF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>

      msgget(key,flag)
      key_t key;
      int flag;

    Функция msgget возвращает идентификатор очереди сообщений,  имя  которой
указано  в key. Параметр key может указывать на то, что возвращаемый иденти-
фикатор относится к частной очереди (IPC_PRIVATE), в этом  случае  создается
новая  очередь  сообщений. С помощью параметра flag можно сделать указание о
необходимости создания очереди (IPC_CREAT), а также о том, что создание оче-
реди должно выполняться монопольно (IPC_EXCL). В последнем случае, если оче-
редь уже существует, функция msgget дает отказ.


    Emsgsnd и msgrcvF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/msg.h>

      msgsnd(id,msgp,size,flag)

                                    407

      int id,size,flag;
      struct msgbuf *msgp;

      msgrcv(id,msgp,size,type,flag)
      int id,size,type,flag;
      struct msgbuf *msgmp;

    Функция msgsnd посылает сообщение указанного размера в байтах (size)  из
буфера msgp в очередь сообщений с идентификатором id. Структура msgbuf опре-
делена следующим образом:

      struct msgbuf {
              long mtype;
              char mtext[];
      };

    Если  в параметре flag бит IPC_NOWAIT сброшен, функция msgsnd будет при-
останавливаться в тех случаях, когда размер отдельного сообщения  или  число
сообщений в системе превышают допустимый максимум. Если бит IPC_NOWAIT уста-
новлен, функция msgsnd в этих случаях прерывает свое выполнение.
    Функция msgrcv принимает сообщение из очереди с идентификатором id. Если
параметр  type  имеет  нулевое значение, из очереди будет выбрано сообщение,
первое по счету; если положительное значение, из очереди  выбирается  первое
сообщение  данного  типа; если отрицательное значение, из очереди выбирается
сообщение, имеющее самый младший тип среди тех типов,  значение  которых  не
превышает  абсолютное  значение параметра type. В параметре size указывается
максимальный размер сообщения, ожидаемого пользователем.  Если  в  параметре
flag  установлен бит MSG_NOERROR, в том случае, когда размер получаемого со-
общения превысит предел, установленный параметром size, ядро обрежет это со-
общение. Если же соответствующий бит сброшен, в подобных случаях функция бу-
дет возвращать ошибку. Если в параметре flag бит IPC_NOWAIT сброшен, функция
msgrcv приостановит свое выполнение до тех пор, пока сообщение, удовлетворя-
ющее указанному в параметре type условию, не будет получено. Если соответст-
вующий бит сброшен, функция завершит свою работу немедленно. Функция  msgrcv
возвращает размер полученного сообщения (в байтах).


    EniceF
      ______________________________

      nice(increment)
      int increment;

    Функция  nice увеличивает значение соответствующей компоненты, участвую-
щей в вычислении приоритета  планирования  текущего  процесса,  на  величину
increment.  Увеличение  значения nice ведет к снижению приоритета планирова-
ния.


    EopenF
      ______________________________

      #include <fcntl.h>

      open(filename,flag,mode)
      char *filename;
      int flag,mode;

    Функция open выполняет открытие указанного файла в соответствии со  зна-

                                    408

чением параметра flag. Значение параметра flag представляет собой комбинацию
из следующих разрядов (причем из первых трех разрядов может быть использован
только один):

      O_RDONLY   открыть только для чтения
      O_WRONLY   открыть только для записи
      O_RDWR     открыть для чтения и записи
      O_NDELAY   если  файл  является  специальным файлом устрой-
                 ства, функция возвращает управление,  не дожида-
                 ясь ответного сигнала; если файл является поиме-
                 нованным каналом,   функция  в  случае   неудачи
                 возвращает управление  немедленно  (с индикацией
                 ошибки, когда бит O_WRONLY установлен), не дожи-
                 даясь открытия файла другим процессом
      O_APPEND   добавляемые данные записывать в конец файла
      O_CREAT    если файл не существует, создать его; режим соз-
                 дания (mode) имеет тот же смысл, что и в функции
                 creat; если файл уже существует, данный флаг иг-
                 норируется
      O_TRUNC    укоротить длину файла до 0
      O_EXCL     если  этот бит и бит O_CREAT установлены  и файл
                 существует, функция  не  будет  выполняться; это
                 так называемое "монопольное открытие"

    Функция  open возвращает дескриптор файла для последующего использования
в других системных функциях.


    EpauseF
      ______________________________

      pause()

    Функция pause приостанавливает выполнение текущего процесса до получения
сигнала.


    EpipeF
      ______________________________

      pipe(fildes)
      int fildes[2];

    Функция pipe возвращает дескрипторы чтения и записи  (соответственно,  в
fildes[0]  и  fildes[1]) для данного канала. Данные передаются через канал в
порядке поступления; одни и те же данные не могут быть прочитаны дважды.


    EplockF
      ______________________________

      #include <sys/lock.h>

      plock(op)
      int op;

    Функция plock устанавливает и снимает блокировку областей процесса в па-
мяти в зависимости от значения параметра op:


                                    409

      PROCLOCK   заблокировать в памяти области команд и данных
      TXTLOCK    заблокировать в памяти область команд
      DATLOCK    заблокировать в памяти область данных
      UNLOCK     снять блокировку всех областей


    EprofilF
      ______________________________

      profil(buf,size,offset,scale)
      char *buf;
      int size,offset,scale;

    Функция profil запрашивает у ядра профиль выполнения процесса.  Параметр
buf  определяет  массив, накапливающий число копий процесса, выполняющихся в
разных адресах. Параметр size определяет размер массива buf,  offset  -  на-
чальный адрес участка профилирования, scale - коэффициент масштабирования.


    EptraceF
      ______________________________

      ptrace(cmd,pid,addr,data)
      int cmd,pid,addr,data;

    Функция  ptrace дает текущему процессу возможность выполнять трассировку
другого процесса, имеющего идентификатор pid, в  соответствии  со  значением
параметра cmd:

      0     разрешить трассировку потомку (по его указанию)
      1,2   вернуть слово,  расположенное по адресу addr в прост-
            ранстве трассируемого процесса с идентификатором pid
      3     вернуть слово, расположенное в пространстве трассиру-
            емого процесса по адресу со смещением addr
      4,5   записать значение по адресу addr в пространстве трас-
            сируемого процесса
      6     записать значение по адресу со смещением addr
      7     заставить трассируемый процесс  возобновить  свое вы-
            полнение
      8     заставить трассируемый процесс завершить  свое выпол-
            нение
      9     машинно-зависимая команда - установить в слове состо-
            яния программы  бит  для  отладки в режиме пошагового
            выполнения


    EreadF
      ______________________________

      read(fildes,buf,size)
      int fildes;
      char *buf;
      int size;

    Функция read выполняет чтение из файла с дескриптором fildes в пользова-
тельский буфер buf указанного в параметре size количества байт. Функция воз-
вращает  число  фактически  прочитанных байт. Если файл является специальным
файлом устройства или каналом и если в вызове функции  open  был  установлен
бит  O_NDELAY,  функция read в случае отсутствия доступных для чтения данных

                                    410

возвратит управление немедленно.


    EsemctlF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/sem.h>

      semctl(id,num,cmd,arg)
      int id,num,cmd;
      union semun {
              int val;
              struct semid_ds *buf;
              ushort *array;
      } arg;

    Функция semctl выполняет указанную в параметре cmd операцию над очередью
семафоров с идентификатором id.

      GETVAL    вернуть значение того семафора, на который указы-
                вает параметр num
      SETVAL    установить значение семафора, на который указыва-
                ет параметр num, равным значению arg.val
      GETPID    вернуть идентификатор процесса, выполнявшего пос-
                ледним функцию semop  по отношению к тому семафо-
                ру, на который указывает параметр num
      GETNCNT   вернуть число  процессов, ожидающих того момента,
                когда значение семафора станет положительным
      GETZCNT   вернуть число  процессов, ожидающих того момента,
                когда значение семафора станет нулевым
      GETALL    вернуть  значения   всех  семафоров   в   массиве
                arg.array
      SETALL    установить значения всех семафоров в соответствие
                с содержимым массива arg.array
      IPC_STAT  считать структуру заголовка семафора с  идентифи-
                катором id в буфер arg.buf
      IPC_SET   установить   значения   переменных  sem_perm.uid,
                sem_perm.gid и sem_perm.mode (младшие 9  разрядов
                структуры sem_perm)   в соответствии с содержимым
                буфера arg.buf
      IPC_RMID  удалить семафоры, связанные с идентификатором id,
                из системы

    Параметр num возвращает на количество семафоров в обрабатываемом наборе.
Структура semid_ds определена следующим образом:

      struct semid_ds {
             struct ipc_perm   sem_perm;   /* структура, описыва-
                                              ющая  права  досту-
                                              па */
             int *             pad;        /* используется систе-
                                              мой */
             ushort            sem_nsems;  /* количество  семафо-
                                              ров в наборе */
             time_t            sem_otime;  /* время    выполнения
                                              последней  операции
                                              над семафором */

                                    411

             time_t            sem_ctime;  /* время    последнего
                                              изменения */
      };

    Структура ipc_perm имеет тот же вид, что и в функции msgctl.


    EsemgetF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/sem.h>

      semget(key,nsems,flag)
      key_t key;
      int nsems,flag;

    Функция semget создает массив семафоров, корреспондирующий с  параметром
key. Параметры key и flag имеют тот же смысл, что и в функции msgget.


    EsemopF
      ______________________________

      semop(id,ops,num)
      int id,num;
      struct sembuf **ops;

    Функция  semop  выполняет  набор операций, содержащихся в структуре ops,
над массивом семафоров, связанных с идентификатором id. Параметр num  содер-
жит количество записей, составляющих структуру ops. Структура sembuf опреде-
лена следующим образом:

      struct sembuf {
             short    sem_num;   /* номер семафора */
             short    sem_op;    /* тип операции над семафором */
             short    sem_flg;   /* флаг */
      };

    Переменная sem_num содержит указатель в массиве семафоров, ассоциирован-
ный  с  данной  операцией, а переменная sem_flg - флаги для данной операции.
Переменная sem_op может принимать следующие значения:

      отрицательное     если сумма значения семафора  и  значения
                        sem_op >= 0, значение семафора изменяется
                        на величину sem_op; в  противном  случае,
                        функция приостанавливает свое выполнение,
                        если это разрешено флагом
      положительное     увеличить значение семафора  на  величину
                        sem_op
      нулевое           если  значение  семафора равно 0, продол-
                        жить выполнение; в противном случае, при-
                        остановить выполнение,  если это разреша-
                        ется флагом

    Если  для  данной  операции  в  переменной   sem_flg   установлен   флаг
IPC_NOWAIT,  функция  semop  возвращает управление немедленно в тех случаях,
когда она должна была бы приостановиться.  Если  установлен  флаг  SEM_UNDO,

                                    412

восстанавливается предыдущее значение семафора (sem_op вычитается из текущей
суммы  типов  операций).  Когда  процесс завершится, значение семафора будет
увеличено на эту сумму. Функция semop возвращает значение последней операции
над семафором.


    EsetpgrpF
      ______________________________

      setpgrp()

    Функция setpgrp приравнивает значение идентификатора группы,  к  которой
принадлежит текущий процесс, значению идентификатора самого процесса и возв-
ращает новое значение идентификатора группы.


    EsetuidF
      ______________________________

      setuid(uid)
      int uid;

      setgid(gid)
      int gid;

    Функция setuid устанавливает значения фактического и исполнительного ко-
дов  идентификации  пользователя  текущего процесса. Если вызывающий процесс
исполняется под управлением суперпользователя, функция  сбрасывает  значения
указанных  кодов.  В  противном  случае,  если фактический код идентификации
пользователя имеет значение, равное значению uid, функция setuid делает рав-
ным этому значению и исполнительный код идентификации  пользователя.  То  же
самое  происходит, если значению uid равен код, сохраненный после выполнения
setuid-программы, запускаемой с помощью функции exec. Функция  setgid  имеет
тот же смысл по отношению к аналогичным групповым кодам.


    EshmctlF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>

      shmctl(id,cmd,buf)
      int id,cmd;
      struct shmid_ds *buf;

    Функция shmctl выполняет различные операции над областью разделяемой па-
мяти,  ассоциированной  с  идентификатором id. Структура shmid_ds определена
следующим образом:

      struct shmid_ds {
            struct ipc_perm   shm_perm;   /* структура, описываю-
                                             щая права доступа */
            int               shm_segsz;  /* размер сегмента */
            int *             pad1;       /* используется  систе-
                                             мой */
            ushort            shm_lpid;   /* идентификатор   про-
                                             цесса, связанного  с

                                    413

                                             последней  операцией
                                             над областью */
            ushort            shm_cpid;   /* идентификатор   про-
                                             цесса-создателя */
            ushort            shm_nattch; /* количество присоеди-
                                             нений к процессам */
            short             pad2;       /* используется  систе-
                                             мой */
            time_t            shm_atime;  /* время     последнего
                                             присоединения */
            time_t            shm_dtime;  /* время     последнего
                                             отсоединения */
            time_t            shm_ctime;  /* время     последнего
                                             внесения     измене-
                                             ний */
      };

    Операции:

      IPC_STAT    прочитать  в буфер buf содержимое заголовка об-
                  ласти, ассоциированной с идентификатором id
      IPC_SET     установить  значения  переменных  shm_perm.uid,
                  shm_perm.gid и shm_perm.mode (9 младших  разря-
                  дов структуры)  в заголовке области в соответс-
                  твии с содержимым буфера buf
      IPC_RMID    удалить из системы область  разделяемой памяти,
                  ассоциированной с идентификатором id


    EshmgetF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>

      shmget(key,size,flag)
      key_t key;
      int size,flag;

    Функция shmget обращается к области разделяемой памяти или  создает  ее.
Параметр size задает размер области в байтах. Параметры key и flag имеют тот
же смысл, что и в функции msgget.


    EshmopF
      ______________________________

      #include <sys/types.h>
      #include <sys/ipc.h>
      #include <sys/shm.h>

      shmat(id,addr,flag)
      int id,flag;
      char *addr;

      shmdt(addr)
      char *addr;


                                    414

    Функция shmat присоединяет область разделяемой памяти, ассоциированную с
идентификатором  id,  к  адресному пространству процесса. Если параметр addr
имеет нулевое значение, ядро само выбирает для присоединения области  подхо-
дящий адрес. В противном случае оно пытается присоединить область, используя
в  качестве значение параметра addr в качестве адреса. Если в параметре flag
установлен бит SHM_RND, ядро в случае необходимости округляет адрес. Функция
shmat возвращает адрес, по которому область присоединяется фактически.
    Функция shmdt отсоединяет область разделяемой памяти, присоединенную ра-
нее по адресу addr.


    EsignalF
      ______________________________

      #include <signal.h>

      signal(sig,function)
      int sig;
      void (*func)();

    Функция signal дает текущему процессу возможность  управлять  обработкой
сигналов. Параметр sig может принимать следующие значения:

      SIGHUP    "зависание"
      SIGINT    прерывание
      SIGQUIT   прекращение работы
      SIGILL    запрещенная команда
      SIGTRAP   внутреннее прерывание, связанное с трассировкой
      SIGIOT    инструкция IOT
      SIGEMT    инструкция EMT
      SIGFPE    особая ситуация при работе  с числами с плавающей запятой
      SIGKILL   удаление из системы
      SIGBUS    ошибка в шине
      SIGSEGV   нарушение сегментации
      SIGSYS    недопустимый аргумент в вызове системной функции
      SIGPIPE   запись в канал при отсутствии считывающих процессов
      SIGALRM   сигнал тревоги
      SIGTERM   завершение программы
      SIGUSR1   сигнал, определяемый пользователем
      SIGUSR2   второй сигнал, определяемый пользователем
      SIGCLD    гибель потомка
      SIGPWR    отказ питания

    Параметр function интерпретируется следующим образом:
      SIG_DFL   действие  по  умолчанию. Означает завершение про-
                цесса в случае поступления любых сигналов, за ис-
                ключением SIGPWR и SIGCLD.  Если сигнал имеет тип
                SIGQUIT, SIGILL, SIGTRAP, SIGIOT, SIGEMT, SIGFPE,
                SIGBUS, SIGSEGV   или   SIGSYS,   создается  файл
                "core", содержащий дамп образа процесса в памяти
      SIG_IGN   игнорировать поступление сигнала
      функция   адрес процедуры в пространстве процесса.  По воз-
                вращении в  режим задачи производится обращение к
                указанной функции с передачей ей номера сигнала в
                качестве аргумента. Если сигнал имеет тип, отлич-
                ный от SIGILL,  SIGTRAP и SIGPWR,  ядро автомати-
                чески переустанавливает  имя  программы обработки
                сигнала в SIG_DFL. Сигналы типа SIGKILL процессом
                не обрабатываются

                                    415



.te1    EstatF
      ______________________________

      stat(filename,statbuf)
      char *filename;
      struct stat *statbuf;

      fstat(fd,statbuf)
      int fd;
      struct stat *statbuf;

    Функция stat возвращает информацию о статусе (состоянии) указанного фай-
ла. Функция fstat выполняет то же самое в отношении открытого файла, имеюще-
го дескриптор fd. Структура statbuf определена следующим образом:

      struct stat {
            dev_t   st_dev;   /* номер устройства, на котором на-
                                 ходится файл */
            ino_t   st_ino;   /* номер индекса */
            ushort  st_mode;  /* тип файла  (см. mknod)  и  права
                                 доступа к нему (см. chmod) */
            short   st_nlink; /* число  связей,  указывающих на файл */
            ushort  st_uid;   /* код идентификации владельца файла */
            ushort  st_gid;   /* код идентификации группы */
            dev_t   st_rdev;  /* старший и младший номера устройства */
            off_t   st_size;  /* размер в байтах */
            time_t  st_atime; /* время последнего обращения */
            time_t  st_mtime; /* время последнего внесения  изменений */
            time_t  st_ctime; /* время последнего изменения  статуса */
      };


    EstimeF
      ______________________________

      stime(tptr)
      long *tptr;

    Функция  stime  устанавливает  системное  время и дату в соответствие со
значением, указанным в параметре  tptr.  Время  указывается  в  секундах  от
00:00:00 1 января 1970 года по Гринвичу.


    EsyncF
      ______________________________

      sync()

    Функция  sync выгружает содержащуюся в системных буферах информацию (от-
носящуюся к файловой системе) на диск.


    EtimeF
      ______________________________

      time(tloc)


                                    416

      long *tloc;

    Функция time возвращает системное время в секундах от 00:00:00 1  января
1970 года по Гринвичу.


    EtimesF
      ______________________________

      #include <sys/types.h>
      #include <sys/times.h>

      times(tbuf)
      struct tms *tbuf;

    Функция  times  возвращает  время в таймерных тиках, реально прошедшее с
любого произвольного момента в прошлом, и  заполняет  буфер  tbuf  следующей
учетной информацией:

      struct tms {
            time_t   tms_utime;  /* продолжительность использова-
                                    ния ЦП в режиме задачи */
            time_t   tms_stime;  /* продолжительность использова-
                                    ния ЦП в режиме ядра */
            time_t   tms_cutime; /* сумма  значений  tms_utime  и
                                    tms_cutime у потомков */
            time_t   tms_sutime; /* сумма  значений  tms_stime  и
                                    tms_sutime у потомков */
      };


    EulimitF
      ______________________________

      ulimit(cmd,limit)
      int cmd;
      long limit;

    Функция ulimit дает процессу возможность устанавливать различные ограни-
чения в зависимости от значения параметра cmd:

      1  вернуть максимальный размер файла (в блоках по 512 байт), в который
           процесс может вести запись
      2 установить ограничение сверху на размер файла равным значению  пара-
           метра limit
      3  вернуть  значение  верхней точки прерывания (максимальный доступный
           адрес в области данных)


    EumaskF
      ______________________________

      umask(mask)
      int mask;

    Функция umask устанавливает значение маски, описывающей  режим  создания
файла (mask), и возвращает старое значение. При создании файла биты разреше-
ния доступа, которым соответствуют установленные разряды в mask, будут сбро-
шены.

                                    417


    EumountF
      ______________________________

      umount(specialfile)
      char *specialfile

    Функция  umount выполняет демонтирование файловой системы, расположенной
на устройстве ввода-вывода блоками specialfile.


    EunameF
      ______________________________

      #include <sys/utsname.h>

      uname(name)
      struct utsname *name;

    Функция uname возвращает информацию, идентифицирующую систему в соответ-
ствии со следующей структурой:

      struct utsname {
            char   sysname[9];  /* наименование */
            char   nodename[9]; /* имя сетевого узла */
            char   release[9];  /* информация о версии системы */
            char   version[9];  /* дополнительная  информация о версии */
            char   machine[9];  /* технический комплекс */
      };


    EunlinkF
      ______________________________

      unlink(filename)
      char *filename;

    Функция unlink удаляет из каталога запись об указанном файле.


    EustatF
      ______________________________

      #include <sys/types.h>
      #include <ustat.h>

      ustat(dev,ubuf)
      int dev;
      struct ustat *ubuf;

    Функция ustat возвращает статистические данные, характеризующие файловую
систему с идентификатором dev (старший и младший номера устройства).  Струк-
тура ustat определена следующим образом:

      struct ustat {
            daddr_t  f_tfree;     /* количество  свободных   блоков */
            ino_t    f_tinode;    /* количество  свободных индексов */
            char     f_fname[6];  /* наименование файловой системы */
            char     f_fpack[6];  /* сокращенное    (упакованное)

                                    418

                                     имя файловой системы */
      };


    EutimeF
      ______________________________

      #include <sys/types.h>

      utime(filename,times)
      char *filename;
      struct utimbuf *times;

    Функция  utime переустанавливает время последнего обращения к указанному
файлу и последнего внесения изменений в соответствии со значениями, на кото-
рые указывает параметр times. Если параметр содержит нулевое  значение,  ис-
пользуется текущее время. В противном случае параметр указывает на следующую
структуру:

      struct utimbuf {
            time_t   axtime;   /* время последнего обращения */
            time_t   modtime;  /* время последнего внесения изменений */
      };

    Все значения отсчитываются от 00:00:00 1 января 1970 года по Гринвичу.


    EwaitF
      ______________________________

      wait(wait_stat)
      int *wait_stat;

    Функция  wait побуждает процесс приостановить свое выполнение до момента
завершения потомка или до момента приостанова трассируемого  процесса.  Если
значение параметра wait_stat ненулевое, оно представляет собой адрес, по ко-
торому функция записывает возвращаемую процессу информацию. При этом исполь-
зуются  только 16 младших разрядов кода возврата. Если обнаружен завершивший
свое выполнение потомок, 8 младших разрядов кода возврата содержат  0,  а  8
старших разрядов - код возврата (аргумент) функции exit. Если потомок завер-
шил  свое  выполнение  в  результате получения сигнала, код возврата функции
exit содержит номер сигнала. Кроме того, если образ процесса-потомка  сохра-
нен  в файле "core", производится установка бита 0200. Если обнаружен приос-
тановивший свое выполнение трассируемый процесс,  8  старших  разрядов  кода
возврата функции wait содержат номер приведшего к его приостанову сигнала, а
8 младших разрядов - восьмиричное число 0177.


    EwriteF
      ______________________________

      write(fd,buf,count)
      int fd,count;
      char *buf;

    Функция  write  выполняет запись указанного в count количества байт дан-
ных, начиная с адреса buf, в файл с дескриптором fd.



                                    419


    EБИБЛИОГРАФИЯF


    [Babaoglu 81] Babaoglu, O., and W.Joy, "Converting a  Swap-Based  System
          to  do  Paging  in  an Architecture Lacking Page-Referenced Bits",
          Proceedings of the 8th Symposium on Operating Systems  Principles,
          ACM Operating Systems Review, Vol. 15(5), Dec. 1981, pp. 78-86.
    [Bach  84]  Bach,  M.J.,  and S.J.Buroff, "Multiprocessor UNIX Systems",
          AT&T Bell Laboratories Technical Journal, Oct. 1984, Vol. 63,  No.
          8, Part 2, pp. 1733-1750.
    [Barak  80]  Barak, A.B. and Aapir, "UNIX with Satellite Processors",
          Software - Practice and Experience, Vol. 10, 1980, pp. 383-392.
    [Beck  85]  Beck,  B.  and  B.Kasten,  "VLSI  Assist   in   Building   a
          Multiprocessor UNIX System", Proceedings of the USENIX Association
          Summer Conference, June 1985, pp. 255-275.
    [Berkeley   83]   UNIX   Programmer's   Manual,  4.2  Berkeley  Software
          Distribution, Virtual VAX-11 Version, Computer  Science  Division,
          Department   of   Electrical  Engineering  and  Computer  Science,
          University of California at Berkeley, August 1983.
    [Birrell  84]  Birrell,  A.D.  and  B.J.Nelson,   "Implementing   Remote
          Procedure  Calls",  ACM  Transactions on Computer Systems, Vol. 2,
          No. 1, Feb. 1984, pp. 39-59.
    [Bodenstab 84] Bodenstab, D.E.,  T.F.Houghton,  K.A.Kelleman,  G.Ronkin,
          and  E.P.Schan,  "UNIX Operating System Porting Experiences", AT&T
          Bell Laboratories Technical Journal, Vol. 63, No.  8,  Oct.  1984,
          pp. 1769-1790.
    [Bourne  78]  Bourne,  S.R., "The UNIX Shell", The Bell System Technical
          Journal, July-August 1978, Vol. 57, No. 6, Part 2, pp. 1971-1990.
    [Bourne 83] Bourne, S.R., The UNIX System, Addison-Wesley, Reading,  MA,
          1983.
    [Brownbridge  82]  Brownbridge,  D.R., L.F.Marshall, and B.Randell, "The
          Newcastle Connection or UNIXes of the World Unite!" in Software  -
          Practice and Experience, Vol. 12, 1982, pp. 1147-1162.
    [Bunt  76]  Bunt,  R.B.,  "Scheduling Techniques for Operating Systems",
          Computer, Oct. 1976, pp. 10-17.
    [Christian 83] Christian, K., The UNIX Operating System,  John  Wiley  &
          Sons Inc., New York, NY, 1983.
    [Coffman  73]  Coffman, E.G., and P.J.Denning, Operating Systems Theory,
          Prentice-Hall Inc., Englewood Cliffs, NJ, 1973.
    [Cole 85] Cole, C.T., P.B.Flinn, and A.B.Atlas, "An Implementation of an
          Extended  File  System  for  UNIX",  Proceedings  of  the   USENIX
          Conference, Summer 1985, pp. 131-149.
    [Denning 68] Denning, P.J., "The Working Set Model for Program Behavior,
          Communications  of  the  ACM,  Volume  11,  No.  5,  May 1968, pp.
          323-333.
    [Dijkstra 65] Dijkstra, E.W.,  "Solution  of  a  Problem  in  Concurrent
          Program Control", CACM, Vol. 8, No. 9, Sept. 1965, p. 569.
    [Dijkstra  68]  Dijkstra,  E.W.,  "Cooperating Sequential Processes", in
          Programming Languages, ed. F.Genuys, Academic Press, New York, NY,
          1968.
    [Felton  84]  Felton,  W.A.,  G.L.Miller,  and   J.M.Milner,   "A   UNIX
          Implementation  for  System/370", AT&T Bell Laboratories Technical
          Journal, Vol. 63, No. 8, Oct. 1984, pp. 1751- 1767.
    [Goble 81] Goble, G.H. and M.H.Marsh, "A  Dual  Processor  VAX  11/780",
          Purdue University Technical Report, TR-EE 81-31, Sept. 1981.
    [Henry   84]   Henry,  G.J.,  "The  Fair  Share  Scheduler",  AT&T  Bell
          Laboratories Technical Journal, Oct. 1984, Vol. 63, No. 8, Part 2,
          pp. 1845-1858.

                                    420

    [Holley 79] Holley, L.H., R.P421rmelee, C.A.Salisbury,  and  D.  N.Saul,
          "VM/370 Asymmetric Multiprocessing", IBM Systems Journal, Vol. 18,
          No. 1, 1979, pp. 47-70.
    [Holt  83]  Holt,  R.C.,  Concurrent Euclid, the UNIX System, and Tunis,
          Addison-Wesley, Reading, MA, 1983.
    [Horning  73]  Horning,  J.J.,  and  B.Randell,  "Process  Structuring",
          Computing Surveys, Vol. 5, No. 1, March 1973, pp. 5-30.
    [Hunter  84]  Hunter, C.B. and E.Farquhar, "Introduction to the NSI16000
          Architecture", IEEE Micro, April 1984, pp. 26- 47.
    [Johnson 78] Johnson, S.C. and D.M.Ritchie, "Portability of  C  Programs
          and  the UNIX System", The Bell System Technical Journal, Vol. 57,
          No. 6, Part 2, July-August, 1978, pp. 2021-2048.
    [Kavaler 83] Kavaler, P. and A.Greenspan, "Extending UNIX to  Local-Area
          Networks", Mini-Micro Systems, Sept. 1983, pp. 197-202.
    [Kernighan  78]  Kernighan,  B.W.,  and  D.M.Ritchie,  The C Programming
          Language, Prentice-Hall, Englewood Cliffs, NJ, 1978.
    [Kernighan  84]  Kernighan,  B.W.,  and  R.Pike,  The  UNIX  Programming
          Environment, Prentice-Hall, Englewood Cliffs, NJ, 1984.
    [Killian  84]  Killian,  T.J.,  "Processes as Files", Proceedings of the
          USENIX Conference, Summer 1984, pp. 203-207.
    [Levy  80]  Levy,  H.M.,  and  R.H.Eckhouse,  Computer  Programming  and
          Architecture: The VAX-11, Digital Press, Bedford, MA, 1980.
    [levy  82] Levy, H.M., and P.H.Lipman, "Virtual Memory Management in the
          VAX/VMS Operating System", Computer, Vol. 15, No. 3,  March  1982,
          pp. 35-41.
    [Lu 83] Lu, P.M., W.A.Dietrich, et. al., "Architecture of a VLSI MAP for
          BELLMAC-32 Microprocessor", Proc. of IEEE Spring Compcon, Feb. 28,
          1983, pp. 213-217.
    [Luderer  81]  Luderer,  G.W.R.,  H.Che,  J.P.Haggerty, P.A.Kirslis, and
          W.T.Marshall, "A  Distributed  UNIX  System  Based  on  a  Virtual
          Circuit  Switch", Proceedings of the Eighth Symposium on Operating
          Systems Principles, Asilomar, California, December 14-16, 1981.
    [Lycklama 78a] Lycklama, H. and D.L.Bayer, "The MERT Operating  System",
          The  Bell  System  Technical  Journal,  Vol.  57,  No.  6, Part 2,
          July-August 1978, pp. 2049-2086.
    [Lycklama 78b] Lycklama, H. and C.Christensen, "A Minicomputer Satellite
          Processor System", The Bell System Technical Journal, Vol. 57, No.
          6, Part 2, July- August 1978, pp. 2103-2114.
    [McKusick 84] McKusick, M.K., W.N.Joy, S.J.Leffler, and R.S.  Fabry,  "A
          Fast  File System for UNIX", ACM Transactions on Computer Systems,
          Vol. 2(3), August 1984, pp. 181-197.
    [Mullender 84] Mullender, S.J.  and  A.S.Tanenbaum,  "Immediate  Files",
          Software  -  Practice  and Experience, Vol. 14(4), April 1984, pp.
          365-368.
    [Nowitz 80] Nowitz, D.A. and  M.E.Lesk,  "Implementation  of  a  Dial-Up
          Network  of  UNIX Systems", IEEE Proceedings of Fall 1980 COMPCON,
          Washington, D.C., pp. 483-486.
    [Organick 72] Organick, E.J., The Multics System: An Examination of  Its
          Structure", The MIT Press, Cambridge, MA, 1972.
    [Peachey  84]  Peachey,  D.R., R.B.Bunt, C.L.Williamson, and T.B.Brecht,
          "An Experimental Investigation of Scheduling Strategies for UNIX",
          Performance  Evaluation  Review,  1984  SIGMETRICS  Conference  on
          Measurement and Evaluation of Computer Systems, Vol. 12(3), August
          1984, pp. 158-166.
    [Peterson  83]  Peterson,  James L. and A.Silberschatz, Operating System
          Concepts, Addison-Wesley, Reading, MA, 1983.
    [Pike 84] Pike, R., "The Blit: A Multiplexed  Graphics  Terminal",  AT&T
          Bell  Laboratories  Technical  Journal, Oct. 1984, Vol. 63, No. 8,
          Part 2, pp. 1607-1632.

                                    421

    [Pike 85] Pike, R., and P.Weinberger, "The Hideous Name", Proceedings of
          the USENIX Conference, Summer 1985, pp. 563-568.
    [Postel  80]  Postel,  J.  (ed.),  "DOD  Standart  Transmission  Control
          Protocol", ACM Computer Communication Review, Vol. 10, No. 4, Oct.
          1980, pp. 52-132.
    [Postel  81]  Postel,  J., C.A.Sunshine, and D.Cohen, "The ARPA Internet
          Protocol", Computer Networks,  Vol.  5,  No.  4,  July  1981,  pp.
          261-271.
    [Raleigh  76]  Raleigh,  T.M., "Introduction to Scheduling and Switching
          under UNIX", Proceedings of the Digital Equipment  Computer  Users
          Society, Atlanta, Ga., May 1976, pp. 867-877.
    [Richards  69]  Richards,  M.,  "BCPL:  A  Tool for Compiler Writing and
          Systems Programming", Proc. AFIPS SJCC 34, 1969, pp. 557-566.
    [Ritchie 78a] Ritchie,  D.M.  and  K.Thompson,  "The  UNIX  Time-Sharing
          System", The Bell System Technical Journal, July-August 1978, Vol.
          57, No. 6, Part 2, pp. 1905-1930.
    [Ritchie   78b]  Ritchie,  D.M.,  "A  Retrospective",  The  Bell  System
          Technical Journal, July-August 1978, Vol. 57, No. 6, Part  2,  pp.
          1947-1970.
    [Ritchie  81] Ritchie, D.M. and K.Thompson, "Some Further Aspects of the
          UNIX Time-Sharing System", Mini-Micro Software,  Vol.  6,  No.  3,
          1981, pp. 9-12.
    [Ritchie  84a]  Ritchie,  D.M., "The Evolution of the UNIX Time- sharing
          System", AT&T Bell Laboratories Technical Journal, Oct. 1984, Vol.
          63, No. 8, Part 2, pp. 1577-1594.
    [Ritchie 84b] Ritchie, D.M., "A Stream Input Output System",  AT&T  Bell
          Laboratories Technical Journal, Oct. 1984, Vol. 63, No. 8, Part 2,
          pp. 1897-1910.
    [Rochkind  85] Rochkind, M.J., Advanced UNIX Programming, Prentice-Hall,
          1985.
    [Saltzer 66] Saltzer, J.H., Traffic Control in  a  Multiplexed  Computer
          System, Ph.D. Thesis, MIT, 1966.
    [Sandberg  85] Sandberg, R., D.Goldberg, S.Kleiman, D.Walsh, and B.Lyon,
          "Design  and  Implementation  of  the  Sun  Network   Filesystem",
          Proceedings of the USENIX Conference, Summer 1985, pp. 119-131.
    [SVID  85]  System  V  Interface  Definition, Spring 1985, Issue 1, AT&T
          Customer Information Center, Indianapolis, IN.
    [System V 84a] UNIX System V User Reference Manual.
    [System V 84b] UNIX System V Administrator's Manual.
    [Thompson 74] Thompson,  K.  and  D.M.Ritchie,  "The  UNIX  Time-Sharing
          System",  Communications  of  the ACM, Vol. 17, No. 7, July, 1974,
          pp. 365-375 (исправлено и перепечатано в [Ritchie 78a]).
    [Thompson 78] Thompson,  K.,  "UNIX  Implementation",  The  Bell  System
          Technical Journal, Vol. 57, No. 6, Part 2, July- August, 1978, pp.
          1931-1946.
    [Weinberger  84] Weinberger, P.J., "Cheap Dynamic Instruction Counting",
          The AT&T Bell Laboratories Technical Journal, Vol. 63, No. 6, Part
          2, October 1984, pp. 1815-1826.












                                    422
