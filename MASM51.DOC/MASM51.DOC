                          Contens                              
                                                               
                                                               
1.            Instructions   . . . . . . . . . . . . . . .  11 
1.1.          Arithmetic Instructions    . . . . . . . . .  11 
1.1.1.        ADD    . . . . . . . . . . . . . . . . . . .  12 
1.1.2.        AddLong    . . . . . . . . . . . . . . . . .  12 
1.1.3.        ADC    . . . . . . . . . . . . . . . . . . .  13 
1.1.4.        INC    . . . . . . . . . . . . . . . . . . .  14 
1.1.5.        SUB    . . . . . . . . . . . . . . . . . . .  14 
1.1.6.        SBB    . . . . . . . . . . . . . . . . . . .  15 
1.1.7.        SubLong    . . . . . . . . . . . . . . . . .  16 
1.1.8.        DEC    . . . . . . . . . . . . . . . . . . .  16 
1.1.9.        NEG    . . . . . . . . . . . . . . . . . . .  17 
1.1.10.       IMUL   . . . . . . . . . . . . . . . . . . .  17 
1.1.11.       MUL    . . . . . . . . . . . . . . . . . . .  18 
1.1.12.       IDIV   . . . . . . . . . . . . . . . . . . .  19 
1.1.13.       DIV    . . . . . . . . . . . . . . . . . . .  19 
1.2.          BCD Adjust Instructions    . . . . . . . . .  20 
1.2.1.        AAA    . . . . . . . . . . . . . . . . . . .  20 
1.2.2.        AAS    . . . . . . . . . . . . . . . . . . .  21 
1.2.3.        AAS    . . . . . . . . . . . . . . . . . . .  21 
1.2.4.        AAM    . . . . . . . . . . . . . . . . . . .  21 
1.2.5.        IntToAsc   . . . . . . . . . . . . . . . . .  21 
1.2.6.        AAD    . . . . . . . . . . . . . . . . . . .  22 
1.2.7.        DAA    . . . . . . . . . . . . . . . . . . .  22 
1.2.8.        DAS    . . . . . . . . . . . . . . . . . . .  23 
1.3.          Bit Shifting Instructions    . . . . . . . .  23 
1.3.1.        RCL/RCR/ROL/ROR    . . . . . . . . . . . . .  24 
1.3.2.        SAL/SAR/SHL/SHR    . . . . . . . . . . . . .  25 
1.4.          Compare Instructions   . . . . . . . . . . .  26 
1.4.1.        CMP    . . . . . . . . . . . . . . . . . . .  26 
1.4.2.        SetLineMode    . . . . . . . . . . . . . . .  27 
1.4.3.        CMPS/CMPSB/CMPSW   . . . . . . . . . . . . .  29 
1.4.4.        StrCompare   . . . . . . . . . . . . . . . .  30 
1.4.5.        TEST   . . . . . . . . . . . . . . . . . . .  30 
1.5.          Control-Flow Instructions    . . . . . . . .  31 
1.5.1.        JMP    . . . . . . . . . . . . . . . . . . .  32 
1.5.2.        JUMP.ASM   . . . . . . . . . . . . . . . . .  33 
1.5.3.        JCXZ/JECXZ   . . . . . . . . . . . . . . . .  34 
1.5.4.        Jcondition   . . . . . . . . . . . . . . . .  34 
1.5.5.        JCOND.ASM    . . . . . . . . . . . . . . . .  35 
1.5.6.        LOOP   . . . . . . . . . . . . . . . . . . .  37 
1.5.7.        WriteTTY   . . . . . . . . . . . . . . . . .  37 
1.5.8.        LOOPcondition    . . . . . . . . . . . . . .  38 
1.5.9.        CALL   . . . . . . . . . . . . . . . . . . .  38 
1.5.10.       HELLOM.ASM   . . . . . . . . . . . . . . . .  39 
1.5.11.       RET/RETN/RETF    . . . . . . . . . . . . . .  40 
1.5.12.       INT    . . . . . . . . . . . . . . . . . . .  41 
1.5.13.       IRET   . . . . . . . . . . . . . . . . . . .  42 
1.5.14.       NewBreak   . . . . . . . . . . . . . . . . .  42 
1.5.15.       ENTER    . . . . . . . . . . . . . . . . . .  43 
1.5.16.       LEAVE    . . . . . . . . . . . . . . . . . .  43 
1.6.          Data Transfer Instructions   . . . . . . . .  44 
1.6.1.        MOV    . . . . . . . . . . . . . . . . . . .  44 
1.6.2.        MOVS/MOVSB/MOVSW   . . . . . . . . . . . . .  45 
1.6.3.        WinOpen    . . . . . . . . . . . . . . . . .  46 
1.6.4.        XCHG   . . . . . . . . . . . . . . . . . . .  48 
1.6.5.        IntToAsc   . . . . . . . . . . . . . . . . .  48 
1.6.6.        LODS/LODSB/LODSW   . . . . . . . . . . . . .  49 
1.6.7.        WinClose   . . . . . . . . . . . . . . . . .  49 
1.6.8.        STOS/STOSB/STOSW   . . . . . . . . . . . . .  50 
                                                               
                                                               
                                                               
                                                               
                            - 2 -                              
                           MASM 5.1                            
1.6.9.        LEA    . . . . . . . . . . . . . . . . . . .  51 
1.6.10.       VeriAnsi   . . . . . . . . . . . . . . . . .  51 
1.6.11.       LDS/LES    . . . . . . . . . . . . . . . . .  52 
1.6.12.       LoadPtr    . . . . . . . . . . . . . . . . .  52 
1.6.13.       XLAT/XLATB   . . . . . . . . . . . . . . . .  53 
1.6.14.       BinToHex   . . . . . . . . . . . . . . . . .  54 
1.7.          Flag-Setting Instructions    . . . . . . . .  54 
1.7.1.        CLC    . . . . . . . . . . . . . . . . . . .  55 
1.7.2.        CopyFile   . . . . . . . . . . . . . . . . .  55 
1.7.3.        CLD    . . . . . . . . . . . . . . . . . . .  57 
1.7.4.        StrFindChar    . . . . . . . . . . . . . . .  57 
1.7.5.        CLI    . . . . . . . . . . . . . . . . . . .  58 
1.7.6.        DisableCGA   . . . . . . . . . . . . . . . .  59 
1.7.7.        CMC    . . . . . . . . . . . . . . . . . . .  59 
1.7.8.        STC    . . . . . . . . . . . . . . . . . . .  60 
1.7.9.        STD    . . . . . . . . . . . . . . . . . . .  60 
1.7.10.       STI    . . . . . . . . . . . . . . . . . . .  60 
1.7.11.       POPF   . . . . . . . . . . . . . . . . . . .  61 
1.7.12.       PUSHF    . . . . . . . . . . . . . . . . . .  61 
1.7.13.       FindFirst    . . . . . . . . . . . . . . . .  61 
1.7.14.       LAHF   . . . . . . . . . . . . . . . . . . .  62 
1.7.15.       SAHF   . . . . . . . . . . . . . . . . . . .  63 
1.7.16.       Quadratic    . . . . . . . . . . . . . . . .  63 
1.8.          Logic Instructions   . . . . . . . . . . . .  65 
1.8.1.        AND    . . . . . . . . . . . . . . . . . . .  65 
1.8.2.        Colors   . . . . . . . . . . . . . . . . . .  66 
1.8.3.        OR   . . . . . . . . . . . . . . . . . . . .  67 
1.8.4.        XOR    . . . . . . . . . . . . . . . . . . .  68 
1.8.5.        NOT    . . . . . . . . . . . . . . . . . . .  69 
1.9.          Port I/O Instructions    . . . . . . . . . .  70 
1.9.1.        IN   . . . . . . . . . . . . . . . . . . . .  70 
1.9.2.        Sound    . . . . . . . . . . . . . . . . . .  70 
1.9.3.        INS/INSB/INSW    . . . . . . . . . . . . . .  71 
1.9.4.        OUT    . . . . . . . . . . . . . . . . . . .  72 
1.9.5.        OUTS/OUTSB/OUTSW   . . . . . . . . . . . . .  72 
1.10.         Processor-Control Instructions   . . . . . .  73 
1.10.1.       NOP    . . . . . . . . . . . . . . . . . . .  73 
1.10.2.       ESC    . . . . . . . . . . . . . . . . . . .  73 
1.10.3.       WAIT   . . . . . . . . . . . . . . . . . . .  74 
1.10.4.       LOCK   . . . . . . . . . . . . . . . . . . .  74 
1.10.5.       HLT    . . . . . . . . . . . . . . . . . . .  75 
1.11.         Stack-Oriented Instructions    . . . . . . .  75 
1.11.1.       PUSH   . . . . . . . . . . . . . . . . . . .  75 
1.11.2.       GetMem   . . . . . . . . . . . . . . . . . .  76 
1.11.3.       PUSHA    . . . . . . . . . . . . . . . . . .  77 
1.11.4.       POP    . . . . . . . . . . . . . . . . . . .  77 
1.11.5.       POPA   . . . . . . . . . . . . . . . . . . .  78 
1.11.6.       PopAll   . . . . . . . . . . . . . . . . . .  78 
1.12.         String Operations    . . . . . . . . . . . .  78 
1.12.1.       MOVS/MOVSB/MOVSW   . . . . . . . . . . . . .  79 
1.12.2.       LODS/LODSB/LODSW   . . . . . . . . . . . . .  80 
1.12.3.       STOS/STOSB/STOSW   . . . . . . . . . . . . .  80 
1.12.4.       SCAS/SCASB/SCASW   . . . . . . . . . . . . .  81 
1.12.5.       CMPS/CMPSB/CMPSW   . . . . . . . . . . . . .  81 
1.12.6.       REP    . . . . . . . . . . . . . . . . . . .  82 
1.12.7.       REPcondition   . . . . . . . . . . . . . . .  83 
1.13.         Type-Conversion Instructions   . . . . . . .  84 
1.13.1.       CBW    . . . . . . . . . . . . . . . . . . .  84 
1.13.2.       GetCurDisk   . . . . . . . . . . . . . . . .  85 
1.13.3.       CWD    . . . . . . . . . . . . . . . . . . .  85 
2.            Directive Summary    . . . . . . . . . . . .  86 
2.1.          Conditional-Assembly Directives    . . . . .  86 
                            - 3 -                              
                           MASM 5.1                            
                                                               
                                                               
2.1.1.        IF block syntax    . . . . . . . . . . . . .  87 
2.1.2.        LoadPtr    . . . . . . . . . . . . . . . . .  87 
2.1.3.        IF   . . . . . . . . . . . . . . . . . . . .  88 
2.1.4.        IF1, IF2   . . . . . . . . . . . . . . . . .  88 
2.1.5.        IFB    . . . . . . . . . . . . . . . . . . .  89 
2.1.6.        IFDEF    . . . . . . . . . . . . . . . . . .  89 
2.1.7.        IFDIF    . . . . . . . . . . . . . . . . . .  90 
2.2.          Conditional-Error Directives   . . . . . . .  90 
2.2.1.        .ERR   . . . . . . . . . . . . . . . . . . .  91 
2.2.2.        .ERR1/.ERR2    . . . . . . . . . . . . . . .  91 
2.2.3.        .ERRE/.ERRNZ   . . . . . . . . . . . . . . .  91 
2.2.4.        .ERRB/.ERRNB   . . . . . . . . . . . . . . .  92 
2.2.5.        .ERRDEF/.ERRNDEF   . . . . . . . . . . . . .  92 
2.2.6.        .ERRDIF/.ERRIDN    . . . . . . . . . . . . .  92 
2.3.          Code-Label Directives    . . . . . . . . . .  93 
2.3.1.        PROC   . . . . . . . . . . . . . . . . . . .  93 
2.3.2.        PUTSTR.ASM   . . . . . . . . . . . . . . . .  94 
2.3.3.        ENDP   . . . . . . . . . . . . . . . . . . .  94 
2.3.4.        LABEL    . . . . . . . . . . . . . . . . . .  95 
2.3.5.        ALIGN    . . . . . . . . . . . . . . . . . .  95 
2.3.6.        EVEN   . . . . . . . . . . . . . . . . . . .  95 
2.3.7.        ORG    . . . . . . . . . . . . . . . . . . .  96 
2.4.          Data-Allocation Directives   . . . . . . . .  96 
2.4.1.        DB   . . . . . . . . . . . . . . . . . . . .  96 
2.4.2.        data.asm   . . . . . . . . . . . . . . . . .  97 
2.4.3.        DW   . . . . . . . . . . . . . . . . . . . .  98 
2.4.4.        DD   . . . . . . . . . . . . . . . . . . . .  98 
2.4.5.        DQ   . . . . . . . . . . . . . . . . . . . .  98 
2.4.6.        DT   . . . . . . . . . . . . . . . . . . . .  99 
2.5.          Listing-File Directives    . . . . . . . . .  99 
2.5.1.        .LIST    . . . . . . . . . . . . . . . . . . 100 
2.5.2.        .XLIST   . . . . . . . . . . . . . . . . . . 100 
2.5.3.        .LFCOND    . . . . . . . . . . . . . . . . . 100 
2.5.4.        .SFCOND    . . . . . . . . . . . . . . . . . 100 
2.5.5.        .TFCOND    . . . . . . . . . . . . . . . . . 101 
2.5.6.        .LALL    . . . . . . . . . . . . . . . . . . 101 
2.5.7.        .SALL    . . . . . . . . . . . . . . . . . . 101 
2.5.8.        .XALL    . . . . . . . . . . . . . . . . . . 101 
2.5.9.        TITLE    . . . . . . . . . . . . . . . . . . 102 
2.5.10.       SUBTTL   . . . . . . . . . . . . . . . . . . 102 
2.5.11.       PAGE   . . . . . . . . . . . . . . . . . . . 102 
2.6.          Macro    . . . . . . . . . . . . . . . . . . 103 
2.6.1.        MACRO    . . . . . . . . . . . . . . . . . . 103 
2.6.2.        ENDM   . . . . . . . . . . . . . . . . . . . 103 
2.6.3.        EXITM    . . . . . . . . . . . . . . . . . . 104 
2.6.4.        LOCAL (in macros)    . . . . . . . . . . . . 104 
2.6.5.        PURGE    . . . . . . . . . . . . . . . . . . 104 
2.6.6.        REPT   . . . . . . . . . . . . . . . . . . . 105 
2.6.7.        IRP    . . . . . . . . . . . . . . . . . . . 105 
2.6.8.        IRPC   . . . . . . . . . . . . . . . . . . . 105 
2.7.          Miscellaneous Directives   . . . . . . . . . 106 
2.7.1.        COMMENT    . . . . . . . . . . . . . . . . . 106 
2.7.2.        END    . . . . . . . . . . . . . . . . . . . 107 
2.7.3.        INCLUDE    . . . . . . . . . . . . . . . . . 107 
2.7.4.        INCLUDELIB   . . . . . . . . . . . . . . . . 107 
2.7.5.        %OUT Directive   . . . . . . . . . . . . . . 107 
2.7.6.        .RADIX   . . . . . . . . . . . . . . . . . . 108 
2.8.          Multimodule Directives   . . . . . . . . . . 108 
2.8.1.        PUBLIC   . . . . . . . . . . . . . . . . . . 109 
2.8.2.        EXTRN    . . . . . . . . . . . . . . . . . . 109 
2.8.3.        COMM   . . . . . . . . . . . . . . . . . . . 109 
2.8.4.        INCLUDELIB   . . . . . . . . . . . . . . . . 110 
                            - 4 -                              
                           MASM 5.1                            
2.9.          Processor Directives   . . . . . . . . . . . 110 
2.9.1.        .186   . . . . . . . . . . . . . . . . . . . 111 
2.9.2.        .286   . . . . . . . . . . . . . . . . . . . 111 
2.9.3.        .287   . . . . . . . . . . . . . . . . . . . 111 
2.9.4.        .8086    . . . . . . . . . . . . . . . . . . 111 
2.9.5.        .8087    . . . . . . . . . . . . . . . . . . 112 
2.10.         Segment Directives   . . . . . . . . . . . . 112 
2.10.1.       SEGMENT    . . . . . . . . . . . . . . . . . 112 
2.10.2.       HELLOF.ASM   . . . . . . . . . . . . . . . . 113 
2.10.3.       ENDS   . . . . . . . . . . . . . . . . . . . 114 
2.10.4.       GROUP    . . . . . . . . . . . . . . . . . . 114 
2.10.5.       ASSUME   . . . . . . . . . . . . . . . . . . 114 
2.10.6.       HELLOC.ASM   . . . . . . . . . . . . . . . . 115 
2.10.7.       DOSSEG   . . . . . . . . . . . . . . . . . . 115 
2.10.8.       HELLO.ASM    . . . . . . . . . . . . . . . . 115 
2.10.9.       .ALPHA   . . . . . . . . . . . . . . . . . . 116 
2.10.10.      .SEQ   . . . . . . . . . . . . . . . . . . . 116 
2.11.         Simplified Segment Directives    . . . . . . 117 
2.11.1.       .MODEL   . . . . . . . . . . . . . . . . . . 117 
2.11.2.       .STARTUP   . . . . . . . . . . . . . . . . . 118 
2.11.3.       EXIT   . . . . . . . . . . . . . . . . . . . 118 
2.11.4.       .CODE    . . . . . . . . . . . . . . . . . . 118 
2.11.5.       .STACK   . . . . . . . . . . . . . . . . . . 119 
2.11.6.       .DATA    . . . . . . . . . . . . . . . . . . 119 
2.11.7.       .DATA?   . . . . . . . . . . . . . . . . . . 120 
2.11.8.       .CONST   . . . . . . . . . . . . . . . . . . 120 
2.11.9.       .FARDATA   . . . . . . . . . . . . . . . . . 120 
2.11.10.      .FARDATA?    . . . . . . . . . . . . . . . . 121 
2.12.         Record and Structure Directives    . . . . . 121 
2.12.1.       RECORD   . . . . . . . . . . . . . . . . . . 121 
2.12.2.       STRUC    . . . . . . . . . . . . . . . . . . 122 
2.12.3.       ENDS   . . . . . . . . . . . . . . . . . . . 122 
3.            Operator Summary   . . . . . . . . . . . . . 123 
3.1.          Arithmetic Operator Summary    . . . . . . . 123 
3.1.1.        + (Plus, Binary)   . . . . . . . . . . . . . 123 
3.1.2.        + (Plus, Unary)    . . . . . . . . . . . . . 124 
3.1.3.        - (Minus, Binary)    . . . . . . . . . . . . 124 
3.1.4.        - (Minus, Unary)   . . . . . . . . . . . . . 124 
3.1.5.        * (Multiplication)   . . . . . . . . . . . . 125 
3.1.6.        / (Division)   . . . . . . . . . . . . . . . 125 
3.1.7.        MOD    . . . . . . . . . . . . . . . . . . . 125 
3.1.8.        . (Structure-Field Reference)    . . . . . . 126 
3.1.9.        [] (Index Operator)    . . . . . . . . . . . 126 
3.2.          Macro Operator Summary   . . . . . . . . . . 126 
3.2.1.        <> (Literal Text Operator)   . . . . . . . . 127 
3.2.2.        ! (Literal Character Operator)   . . . . . . 127 
3.2.3.        ;; (Macro Comment Delimeter)   . . . . . . . 127 
3.2.4.        % (Expression Operator)    . . . . . . . . . 128 
3.2.5.        & (Substitute Operator)    . . . . . . . . . 128 
3.3.          Logic/Shift Operator Summary   . . . . . . . 128 
3.3.1.        AND    . . . . . . . . . . . . . . . . . . . 129 
3.3.2.        OR   . . . . . . . . . . . . . . . . . . . . 129 
3.3.3.        XOR    . . . . . . . . . . . . . . . . . . . 130 
3.3.4.        NOT    . . . . . . . . . . . . . . . . . . . 131 
3.3.5.        SAL/SAR/SHL/SHR    . . . . . . . . . . . . . 131 
3.4.          Record Operator Summary    . . . . . . . . . 133 
3.4.1.        MASK   . . . . . . . . . . . . . . . . . . . 133 
3.4.2.        WIDTH    . . . . . . . . . . . . . . . . . . 134 
3.5.          Type Operator Summary    . . . . . . . . . . 134 
3.5.1.        HIGH   . . . . . . . . . . . . . . . . . . . 134 
3.5.2.        LOW    . . . . . . . . . . . . . . . . . . . 135 
3.5.3.        PTR    . . . . . . . . . . . . . . . . . . . 135 
                           MASM 5.1                            
                                                               
                                                               
3.5.4.        SHORT    . . . . . . . . . . . . . . . . . . 135 
3.5.5.        SIZE   . . . . . . . . . . . . . . . . . . . 136 
3.5.6.        THIS   . . . . . . . . . . . . . . . . . . . 136 
3.5.7.        TYPE   . . . . . . . . . . . . . . . . . . . 137 
3.5.8.        .TYPE    . . . . . . . . . . . . . . . . . . 137 
3.6.          Address Operator Summary   . . . . . . . . . 138 
3.6.1.        SEG    . . . . . . . . . . . . . . . . . . . 138 
3.6.2.        OFFSET   . . . . . . . . . . . . . . . . . . 138 
3.7.          Relational Operator Summary    . . . . . . . 139 
3.7.1.        EQ   . . . . . . . . . . . . . . . . . . . . 139 
3.7.2.        NE   . . . . . . . . . . . . . . . . . . . . 139 
3.7.3.        GT   . . . . . . . . . . . . . . . . . . . . 140 
3.7.4.        GE   . . . . . . . . . . . . . . . . . . . . 140 
3.7.5.        LT   . . . . . . . . . . . . . . . . . . . . 140 
3.7.6.        LE   . . . . . . . . . . . . . . . . . . . . 141 
3.8.          Miscellaneous Operator Summary   . . . . . . 141 
3.8.1.        ; (Comment Delimeter)    . . . . . . . . . . 141 
3.8.2.        DUP    . . . . . . . . . . . . . . . . . . . 142 
3.8.3.        ? (Uninitialized Value)    . . . . . . . . . 142 
3.8.4.        \ (Line Continutation)   . . . . . . . . . . 142 
4.            Predefined Equates   . . . . . . . . . . . . 143 
4.1.          @code    . . . . . . . . . . . . . . . . . . 143 
4.2.          Vector   . . . . . . . . . . . . . . . . . . 143 
4.3.          @CurSeg    . . . . . . . . . . . . . . . . . 144 
4.4.          @FileName    . . . . . . . . . . . . . . . . 144 
4.5.          @WordSize    . . . . . . . . . . . . . . . . 145 
4.6.          @CodeSize    . . . . . . . . . . . . . . . . 145 
4.7.          @data    . . . . . . . . . . . . . . . . . . 145 
4.8.          @Model   . . . . . . . . . . . . . . . . . . 145 
4.9.          @Cpu   . . . . . . . . . . . . . . . . . . . 146 
4.10.         @DataSize    . . . . . . . . . . . . . . . . 146 
4.11.         @Version   . . . . . . . . . . . . . . . . . 146 
5.            Specifying Radixes   . . . . . . . . . . . . 147 
6.            Useful Tables    . . . . . . . . . . . . . . 148 
6.1.          Regular Expressions    . . . . . . . . . . . 148 
6.2.          Data Types   . . . . . . . . . . . . . . . . 149 
6.3.          Register Summary   . . . . . . . . . . . . . 149 
6.4.          Flags Summary    . . . . . . . . . . . . . . 149 
6.5.          Register Setup   . . . . . . . . . . . . . . 150 
6.6.          Keyboard Scan Codes    . . . . . . . . . . . 150 
6.7.          Program Segment Prefix   . . . . . . . . . . 151 
6.8.          Color Display Attributes   . . . . . . . . . 151 
7.            Interrupt 21H Summary (DOS)    . . . . . . . 153 
7.1.          Interrupt 21H, Character-Oriented Functions  153 
7.1.1.        Int 21H Function 01H   . . . . . . . . . . . 153 
7.1.2.        Int 21H Function 02H   . . . . . . . . . . . 154 
7.1.3.        PUTSTR.ASM   . . . . . . . . . . . . . . . . 155 
7.1.4.        Int 21H Function 03H   . . . . . . . . . . . 156 
7.1.5.        Int 21H Function 04H   . . . . . . . . . . . 156 
7.1.6.        Int 21H Function 05H   . . . . . . . . . . . 157 
7.1.7.        Int 21H Function 06H   . . . . . . . . . . . 157 
7.1.8.        Int 21H Function 07H   . . . . . . . . . . . 158 
7.1.9.        Int 21H Function 08H   . . . . . . . . . . . 159 
7.1.10.       Int 21H Function 09H   . . . . . . . . . . . 159 
7.1.11.       Int 21H Function 0AH   . . . . . . . . . . . 160 
7.1.12.       Int 21H Function 0BH   . . . . . . . . . . . 161 
7.1.13.       Int 21H Function 0CH   . . . . . . . . . . . 161 
7.2.          Interrupt 21H, Directory-Control Functions   162 
7.2.1.        Int 21H Function 39H   . . . . . . . . . . . 162 
7.2.2.        Int 21H Function 3AH   . . . . . . . . . . . 163 
7.2.3.        Int 21H Function 3BH   . . . . . . . . . . . 163 
7.2.4.        Int 21H Function 47H   . . . . . . . . . . . 164 
                           MASM 5.1                            
7.3.          Interrupt 21H, Disk-Management Functions   . 164 
7.3.1.        Int 21H Function 0DH   . . . . . . . . . . . 165 
7.3.2.        Int 21H Function 0EH   . . . . . . . . . . . 165 
7.3.3.        Int 21H Function 19H   . . . . . . . . . . . 166 
7.3.4.        Int 21H Function 1BH   . . . . . . . . . . . 166 
7.3.5.        Int 21H Function 1CH   . . . . . . . . . . . 167 
7.3.6.        Int 21H Function 2EH   . . . . . . . . . . . 168 
7.3.7.        Int 21H Function 36H   . . . . . . . . . . . 168 
7.3.8.        Int 21H Function 54H   . . . . . . . . . . . 169 
7.4.          Interrupt 21H, File Operations   . . . . . . 169 
7.4.1.        Int 21H Function 3CH   . . . . . . . . . . . 170 
7.4.2.        CreateFile   . . . . . . . . . . . . . . . . 170 
7.4.3.        Int 21H Function 3DH   . . . . . . . . . . . 171 
7.4.4.        Int 21H Function 3EH   . . . . . . . . . . . 171 
7.4.5.        Int 21H Function 41H   . . . . . . . . . . . 172 
7.4.6.        Int 21H Function 43H   . . . . . . . . . . . 173 
7.4.7.        Int 21H Function 45H   . . . . . . . . . . . 173 
7.4.8.        Int 21H Function 45H   . . . . . . . . . . . 174 
7.4.9.        Int 21H Function 46H   . . . . . . . . . . . 174 
7.4.10.       Int 21H Function 4EH   . . . . . . . . . . . 175 
7.4.11.       Int 21H Function 4FH   . . . . . . . . . . . 176 
7.4.12.       FindNext   . . . . . . . . . . . . . . . . . 177 
7.4.13.       Int 21H Function 56H   . . . . . . . . . . . 178 
7.4.14.       Int 21H Function 57H   . . . . . . . . . . . 179 
7.4.15.       Int 21H Function 5AH   . . . . . . . . . . . 179 
7.4.16.       Int 21H Function 5BH   . . . . . . . . . . . 180 
7.4.17.       CreateNewFile    . . . . . . . . . . . . . . 181 
7.4.18.       Int 21H Function 67H   . . . . . . . . . . . 182 
7.5.          Interrupt 21H, File Operations, FCB    . . . 182 
7.5.1.        Int 21H Function 0FH   . . . . . . . . . . . 183 
7.5.2.        Int 21H Function 10H   . . . . . . . . . . . 183 
7.5.3.        Int 21H Function 11H   . . . . . . . . . . . 184 
7.5.4.        Int 21H Function 12H   . . . . . . . . . . . 185 
7.5.5.        Int 21H Function 13H   . . . . . . . . . . . 185 
7.5.6.        Int 21H Function 16H   . . . . . . . . . . . 186 
7.5.7.        Int 21H Function 17H   . . . . . . . . . . . 187 
7.5.8.        Int 21H Function 23H   . . . . . . . . . . . 187 
7.5.9.        Int 21H Function 29H   . . . . . . . . . . . 188 
7.6.          Interrupt 21H, Memory-Allocation Functions   189 
7.6.1.        Int 21H Function 48H   . . . . . . . . . . . 190 
7.6.2.        Int 21H Function 49H   . . . . . . . . . . . 190 
7.6.3.        Int 21H Function 4AH   . . . . . . . . . . . 191 
7.6.4.        Int 21H Function 58H   . . . . . . . . . . . 191 
7.7.          Interrupt 21H, Miscellaneous System              
              Functions    . . . . . . . . . . . . . . . . 192 
7.7.1.        Int 21H Function 25H   . . . . . . . . . . . 192 
7.7.2.        Exec   . . . . . . . . . . . . . . . . . . . 193 
7.7.3.        Int 21H Function 30H   . . . . . . . . . . . 195 
7.7.4.        Int 21H Function 33H   . . . . . . . . . . . 195 
7.7.5.        Int 21H Function 35H   . . . . . . . . . . . 196 
7.7.6.        Int 21H Function 38H   . . . . . . . . . . . 196 
7.7.7.        Int 21H Function 44H   . . . . . . . . . . . 198 
7.7.8.        Int 21H Function 59H   . . . . . . . . . . . 199 
7.7.9.        Interrupt 21H, Function 5EH                      
              (Machine/Printer)    . . . . . . . . . . . . 201 
7.7.9.1.      Int 21H Function 5EH Subfunction 00H   . . . 201 
7.7.9.2.      Int 21H Function 5EH Subfunction 02H   . . . 201 
7.7.9.3.      Int 21H Function 5EH Subfunction 03H   . . . 202 
7.7.10.       Interrupt 21H, Function 5FH (Device              
              Redirection)   . . . . . . . . . . . . . . . 203 
7.7.10.1.     Int 21H Function 5FH Subfunction 02H   . . . 203 
7.7.10.2.     Int 21H Function 5FH Subfunction 03H   . . . 204 
                           MASM 5.1                            
                                                               
                                                               
7.7.10.3.     Int 21H Function 5FH Subfunction 04H   . . . 204 
7.7.11.       Int 21H Function 63H   . . . . . . . . . . . 205 
7.7.12.       Int 21H Function 65H   . . . . . . . . . . . 206 
7.7.13.       Int 21H Function 66H   . . . . . . . . . . . 208 
7.8.          Interrupt 21H, Process-Control Functions   . 209 
7.8.1.        Int 21H Function 00H   . . . . . . . . . . . 209 
7.8.2.        Int 21H Function 26H   . . . . . . . . . . . 210 
7.8.3.        Int 21H Function 31H   . . . . . . . . . . . 210 
7.8.4.        Int 21H Function 4BH   . . . . . . . . . . . 212 
7.8.5.        Int 21H Function 4CH   . . . . . . . . . . . 213 
7.8.6.        Int 21H Function 4DH   . . . . . . . . . . . 214 
7.8.7.        Int 21H Function 62H   . . . . . . . . . . . 215 
7.9.          Interrupt 21H, Record Functions    . . . . . 215 
7.9.1.        Int 21H Function 1AH   . . . . . . . . . . . 215 
7.9.2.        SetDTA   . . . . . . . . . . . . . . . . . . 216 
7.9.3.        Int 21H Function 2FH   . . . . . . . . . . . 216 
7.9.4.        Int 21H Function 3FH   . . . . . . . . . . . 217 
7.9.5.        ReadFile   . . . . . . . . . . . . . . . . . 217 
7.9.6.        Int 21H Function 40H   . . . . . . . . . . . 218 
7.9.7.        Int 21H Function 42H   . . . . . . . . . . . 219 
7.9.8.        Int 21H Function 5CH   . . . . . . . . . . . 219 
7.9.9.        Int 21H Function 5CH   . . . . . . . . . . . 220 
7.9.10.       Int 21H Function 68H   . . . . . . . . . . . 221 
7.10.         Interrupt 21H, Record Functions, FCB   . . . 222 
7.10.1.       Int 21H Function 14H   . . . . . . . . . . . 222 
7.10.2.       Int 21H Function 15H   . . . . . . . . . . . 223 
7.10.3.       Int 21H Function 21H   . . . . . . . . . . . 224 
7.10.4.       Int 21H Function 22H   . . . . . . . . . . . 224 
7.10.5.       Int 21H Function 24H   . . . . . . . . . . . 225 
7.10.6.       Int 21H Function 24H   . . . . . . . . . . . 226 
7.10.7.       Int 21H Function 27H   . . . . . . . . . . . 226 
7.10.8.       Int 21H Function 28H   . . . . . . . . . . . 227 
7.11.         Interrupt 21H, Time and Date Functions   . . 228 
7.11.1.       Int 21H Function 2AH   . . . . . . . . . . . 228 
7.11.2.       Int 21H Function 2BH   . . . . . . . . . . . 229 
7.11.3.       Int 21H Function 2CH   . . . . . . . . . . . 229 
7.11.4.       Int 21H Function 2DH   . . . . . . . . . . . 229 
8.            Miscellaneous DOS Interrupts   . . . . . . . 231 
8.1.          Interrupt 20H    . . . . . . . . . . . . . . 231 
8.2.          Interrupt 25H    . . . . . . . . . . . . . . 232 
8.3.          Interrupt 26H    . . . . . . . . . . . . . . 233 
8.4.          Interrupt 27H    . . . . . . . . . . . . . . 234 
8.5.          Interrupt 2FH    . . . . . . . . . . . . . . 235 
9.            BIOS Interrupts    . . . . . . . . . . . . . 236 
9.1.          Interrupt 10H (All Monitors)   . . . . . . . 236 
9.1.1.        Int 10H Function 00H   . . . . . . . . . . . 236 
9.1.2.        GetVidConfig   . . . . . . . . . . . . . . . 237 
9.1.3.        Int 10H Function 01H   . . . . . . . . . . . 239 
9.1.4.        SetCurSize   . . . . . . . . . . . . . . . . 240 
9.1.5.        Int 10H Function 02H   . . . . . . . . . . . 240 
9.1.6.        SetCurPos    . . . . . . . . . . . . . . . . 241 
9.1.7.        Int 10H Function 03H   . . . . . . . . . . . 242 
9.1.8.        Int 10H Function 04H   . . . . . . . . . . . 242 
9.1.9.        Int 10H Function 05H   . . . . . . . . . . . 243 
9.1.10.       Int 10H Function 06H   . . . . . . . . . . . 243 
9.1.11.       Int 10H Function 07H   . . . . . . . . . . . 244 
9.1.12.       Int 10H Function 08H   . . . . . . . . . . . 244 
9.1.13.       ReadCharAttr   . . . . . . . . . . . . . . . 245 
9.1.14.       Int 10H Function 09H   . . . . . . . . . . . 245 
9.1.15.       Int 10H Function 0AH   . . . . . . . . . . . 246 
9.1.16.       Int 10H Function 0EH   . . . . . . . . . . . 247 
9.1.17.       Int 10H Function 0FH   . . . . . . . . . . . 247 
                           MASM 5.1                            
9.1.18.       Int 10H Function 13H   . . . . . . . . . . . 248 
9.2.          Interrupt 10H (Graphics Monitors)    . . . . 249 
9.2.1.        Int 10H Function 0BH   . . . . . . . . . . . 249 
9.2.2.        Int 10H Function 0CH   . . . . . . . . . . . 250 
9.2.3.        Int 10H Function 0DH   . . . . . . . . . . . 250 
9.2.4.        Int 10H Function 1AH   . . . . . . . . . . . 251 
9.2.5.        Int 10H Function 1BH   . . . . . . . . . . . 251 
9.2.6.        Int 10H Function 1CH   . . . . . . . . . . . 255 
9.3.          Interrupt 10H, Function 10H (Colors)   . . . 256 
9.3.1.        Int 10H Function 10H Subfunction 00H   . . . 256 
9.3.2.        Int 10H Function 10H Subfunction 01H   . . . 257 
9.3.3.        Int 10H Function 10H Subfunction 02H   . . . 257 
9.3.4.        Int 10H Function 10H Subfunction 03H   . . . 258 
9.3.5.        Int 10H Function 10H Subfunction 07H   . . . 258 
9.3.6.        Int 10H Function 10H Subfunction 08H   . . . 259 
9.3.7.        Int 10H Function 10H Subfunction 09H   . . . 259 
9.3.8.        Int 10H Function 10H Subfunction 10H   . . . 259 
9.3.9.        Int 10H Function 10H Subfunction 10H   . . . 260 
9.3.10.       Int 10H Function 10H Subfunction 12H   . . . 260 
9.3.11.       Int 10H Function 10H Subfunction 13H   . . . 260 
9.3.12.       Int 10H Function 10H Subfunction 15H   . . . 261 
9.3.13.       Int 10H Function 10H Subfunction 17H   . . . 261 
9.3.14.       Int 10H Function 10H Subfunction 1AH   . . . 262 
9.3.15.       Int 10H Function 10H Subfunction 1BH   . . . 262 
9.4.          Interrupt 10H, Function 11H (Fonts)    . . . 262 
9.4.1.        Int 10H Function 11H Subfunction 00H/10H   . 263 
9.4.2.        SetLineMode    . . . . . . . . . . . . . . . 264 
9.4.3.        Int 10H Function 11H Subfunction 01H/11H   . 265 
9.4.4.        Int 10H Function 11H Subfunction 02H/12H   . 266 
9.4.5.        Int 10H Function 11H Subfunction 03H   . . . 267 
9.4.6.        Int 10H Function 11H Subfunction 04H   . . . 267 
9.4.7.        Int 10H Function 11H Subfunction 14H   . . . 268 
9.4.8.        Int 10H Function 11H Subfunction 20H   . . . 269 
9.4.9.        Int 10H Function 11H Subfunction 21H   . . . 269 
9.4.10.       Int 10H Function 11H Subfunction 22H   . . . 270 
9.4.11.       Int 10H Function 11H Subfunction 23H   . . . 270 
9.4.12.       Int 10H Function 11H Subfunction 24H   . . . 271 
9.4.13.       Int 10H Function 11H Subfunction 30H   . . . 271 
9.5.          Interrupt 10H, Function 12H (Video Config.)  272 
9.5.1.        Int 10H Function 12H Subfunction 10H   . . . 272 
9.5.2.        Int 10H Function 12H Subfunction 20H   . . . 273 
9.5.3.        Int 10H Function 12H Subfunction 30H   . . . 273 
9.5.4.        Int 10H Function 12H Subfunction 31H   . . . 273 
9.5.5.        Int 10H Function 12H Subfunction 32H   . . . 274 
9.5.6.        Int 10H Function 12H Subfunction 33H   . . . 274 
9.5.7.        Int 10H Function 12H Subfunction 34H   . . . 274 
9.5.8.        Int 10H Function 12H Subfunction 35H   . . . 275 
9.5.9.        Int 10H Function 12H Subfunction 36H   . . . 275 
9.6.          Function 13H (Disk I/O)    . . . . . . . . . 276 
9.6.1.        Int 13H Function 00H   . . . . . . . . . . . 277 
9.6.2.        Int 13H Function 01H   . . . . . . . . . . . 277 
9.6.3.        Int 13H Function 02H   . . . . . . . . . . . 278 
9.6.4.        Int 13H Function 03H   . . . . . . . . . . . 279 
9.6.5.        Int 13H Function 04H   . . . . . . . . . . . 279 
9.6.6.        Int 13H Function 05H   . . . . . . . . . . . 280 
9.6.7.        Int 13H Function 06H   . . . . . . . . . . . 281 
9.6.8.        Int 13H Function 07H   . . . . . . . . . . . 281 
9.6.9.        Int 13H Function 08H   . . . . . . . . . . . 282 
9.6.10.       Int 13H Function 09H   . . . . . . . . . . . 282 
9.6.11.       Int 13H Function 0AH   . . . . . . . . . . . 284 
9.6.12.       Int 13H Function 0BH   . . . . . . . . . . . 284 
9.6.13.       Int 13H Function 0CH   . . . . . . . . . . . 285 
                           MASM 5.1                            
                                                               
                                                               
9.6.14.       Int 13H Function 0DH   . . . . . . . . . . . 285 
9.6.15.       Int 13H Function 0EH   . . . . . . . . . . . 285 
9.6.16.       Int 13H Function 0FH   . . . . . . . . . . . 286 
9.6.17.       Int 13H Function 10H   . . . . . . . . . . . 286 
9.6.18.       Int 13H Function 11H   . . . . . . . . . . . 287 
9.6.19.       Int 13H Function 12H   . . . . . . . . . . . 287 
9.6.20.       Int 13H Function 13H   . . . . . . . . . . . 288 
9.6.21.       Int 13H Function 14H   . . . . . . . . . . . 288 
9.6.22.       Int 13H Function 15H   . . . . . . . . . . . 288 
9.6.23.       Int 13H Function 16H   . . . . . . . . . . . 289 
9.6.24.       Int 13H Function 17H   . . . . . . . . . . . 289 
9.6.25.       Int 13H Function 18H   . . . . . . . . . . . 290 
9.6.26.       Int 13H Function 19H   . . . . . . . . . . . 290 
9.6.27.       Int 13H Function 1AH   . . . . . . . . . . . 291 
9.7.          Interrupt 14H (COM Port)   . . . . . . . . . 292 
9.7.1.        Int 14H Function 00H   . . . . . . . . . . . 292 
9.7.2.        Int 14H Function 01H   . . . . . . . . . . . 293 
9.7.3.        Int 14H Function 02H   . . . . . . . . . . . 294 
9.7.4.        Int 14H Function 03H   . . . . . . . . . . . 294 
9.7.5.        Int 14H Function 04H   . . . . . . . . . . . 295 
9.7.6.        Int 14H Function 05H   . . . . . . . . . . . 296 
9.8.          Interrupt 15H (I/O Subsystem)    . . . . . . 296 
9.8.1.        Int 15H Function 00H   . . . . . . . . . . . 297 
9.8.2.        Int 15H Function 01H   . . . . . . . . . . . 297 
9.8.3.        Int 15H Function 02H   . . . . . . . . . . . 298 
9.8.4.        Int 15H Function 03H   . . . . . . . . . . . 298 
9.8.5.        Int 15H Function 0FH   . . . . . . . . . . . 299 
9.8.6.        Int 15H Function 21H Subfunction 00H   . . . 299 
9.8.7.        Int 15H Function 21H Subfunction 01H   . . . 300 
9.8.8.        Int 15H Function 4FH   . . . . . . . . . . . 300 
9.8.9.        Int 15H Function 80H   . . . . . . . . . . . 301 
9.8.10.       Int 15H Function 81H   . . . . . . . . . . . 301 
9.8.11.       Int 15H Function 82H   . . . . . . . . . . . 302 
9.8.12.       Int 15H Function 83H   . . . . . . . . . . . 302 
9.8.13.       Int 15H Function 84H   . . . . . . . . . . . 303 
9.8.14.       Int 15H Function 85H   . . . . . . . . . . . 304 
9.8.15.       Int 15H Function 86H   . . . . . . . . . . . 304 
9.8.16.       Int 15H Function 87H   . . . . . . . . . . . 305 
9.8.17.       Int 15H Function 88H   . . . . . . . . . . . 306 
9.8.18.       Int 15H Function 89H   . . . . . . . . . . . 306 
9.8.19.       Int 15H Function 90H   . . . . . . . . . . . 307 
9.8.20.       Int 15H Function 91H   . . . . . . . . . . . 308 
9.8.21.       Int 15H Function C0H   . . . . . . . . . . . 308 
9.8.22.       Int 15H Function C1H   . . . . . . . . . . . 309 
9.8.23.       Int 15H Function C3H   . . . . . . . . . . . 310 
9.8.24.       Int 15H Function C4H   . . . . . . . . . . . 310 
9.8.25.       Interrupt 15H (Mouse Pointer)    . . . . . . 311 
9.8.25.1.     Int 15H Function C2H Subfunction 00H   . . . 311 
9.8.25.2.     Int 15H Function C2H Subfunction 01H   . . . 312 
9.8.25.3.     Int 15H Function C2H Subfunction 02H   . . . 312 
9.8.25.4.     Int 15H Function C2H Subfunction 03H   . . . 313 
9.8.25.5.     Int 15H Function C2H Subfunction 04H   . . . 313 
9.8.25.6.     Int 15H Function C2H Subfunction 05H   . . . 313 
9.8.25.7.     Int 15H Function C2H Subfunction 06H   . . . 314 
9.8.25.8.     Int 15H Function C2H Subfunction 07H   . . . 315 
9.9.          Interrupt 16H (Keyboard)   . . . . . . . . . 316 
9.9.1.        Int 16H Function 00H   . . . . . . . . . . . 316 
9.9.2.        GetKeyClock    . . . . . . . . . . . . . . . 316 
9.9.3.        Int 16H Function 01H   . . . . . . . . . . . 318 
9.9.4.        Int 16H Function 02H   . . . . . . . . . . . 318 
9.9.5.        Int 16H Function 03H   . . . . . . . . . . . 319 
9.9.6.        Int 16H Function 04H   . . . . . . . . . . . 320 
                           MASM 5.1                            
9.9.7.        Int 16H Function 05H   . . . . . . . . . . . 320 
9.9.8.        Int 16H Function 10H   . . . . . . . . . . . 321 
9.9.9.        Int 16H Function 11H   . . . . . . . . . . . 321 
9.9.10.       Int 16H Function 12H   . . . . . . . . . . . 321 
9.10.         Interrupt 17H (Parallel Printer Port)    . . 322 
9.10.1.       Int 17H Function 00H   . . . . . . . . . . . 322 
9.10.2.       Int 17H Function 01H   . . . . . . . . . . . 323 
9.10.3.       Int 17H Function 02H   . . . . . . . . . . . 323 
9.10.4.       VeriPrint    . . . . . . . . . . . . . . . . 323 
9.11.         Interrupt 1AH (Clock)    . . . . . . . . . . 324 
9.11.1.       Int 1AH Function 00H   . . . . . . . . . . . 324 
9.11.2.       Pause    . . . . . . . . . . . . . . . . . . 325 
9.11.3.       Int 1AH Function 01H   . . . . . . . . . . . 326 
9.11.4.       Int 1AH Function 02H   . . . . . . . . . . . 326 
9.11.5.       Int 1AH Function 03H   . . . . . . . . . . . 326 
9.11.6.       Int 1AH Function 04H   . . . . . . . . . . . 327 
9.11.7.       Int 1AH Function 05H   . . . . . . . . . . . 327 
9.11.8.       Int 1AH Function 06H   . . . . . . . . . . . 328 
9.11.9.       Int 1AH Function 07H   . . . . . . . . . . . 328 
9.11.10.      Int 1AH Function 0AH   . . . . . . . . . . . 328 
9.11.11.      Int 1AH Function 0BH   . . . . . . . . . . . 329 
9.11.12.      Int 1AH Function 80H   . . . . . . . . . . . 329 
9.12.         Int 11H    . . . . . . . . . . . . . . . . . 329 
9.13.         VeriCop    . . . . . . . . . . . . . . . . . 330 
9.14.         Int 12H    . . . . . . . . . . . . . . . . . 331 
9.15.         GetMem   . . . . . . . . . . . . . . . . . . 331 
9.16.         Int 18H    . . . . . . . . . . . . . . . . . 332 
9.17.         Int 19H    . . . . . . . . . . . . . . . . . 332 
I n d e x    . . . . . . . . . . . . . . . . . . . . . . . 333 
                    Instructions by Topic                      
                                                               
                                                               
                        1. Instructions                        
                                                               
                                                               
Category                                                       
            Description                                        
Arithmetic                                                     
            Arithmetic calculations: add, subtract, etc.       
BCD Conversion                                                 
            Adjust result of Binary Coded Decimal operation    
Bit Shifting                                                   
            Shift or rotate bits left or right                 
Compare                                                        
            Compare or test, for upcoming conditional jump     
Control Flow                                                   
            Jump or execute procedure                          
Data Transfer                                                  
            Load or store values in registers                  
Flags                                                          
            Clear or set processor flags                       
Logic                                                          
            Logical operations: AND, OR, etc.                  
Port Input/Output                                              
            Read or write data to hardware ports               
Processor Control                                              
            Control basic operation of the processor           
Stack Operations                                               
            Push or pop values from stack                      
String Operations                                              
            Perform block operation (move, store, load)        
Type Conversion                                                
            Cast data to new size while preserving sign        
                                                               
                                                               
                                                               
   1.1. Arithmetic Instructions                                
                                                               
                                                               
Mnemonic                                                       
            Name                                               
ADD                                                            
            Add                                                
ADC                                                            
            Add with Carry (add values in multiple registers)  
INC                                                            
            Increment (add 1)                                  
SUB                                                            
            Subtract                                           
SBB                                                            
            Subtract with Borrow (subtract values  in  multiple
            registers)                                         
DEC                                                            
            Decrement (subtract 1)                             
NEG                                                            
            Two's Complement Negation                          
IMUL                                                           
            Signed Multiply                                    
MUL                                                            
            Unsigned Multiply                                  
IDIV                                                           
            Signed Division                                    
DIV                                                            
            Unsigned Division                                  
                   Arithmetic Instructions                     
   1.1.1. ADD                                                  
ADD                                 Flags:  O D I T S Z A P C  
                                            -----------------  
Syntax:  ADD dest,src                       *       * * * * *  
   Adds the source and destination operands and puts the sum in
the destination operand.                                       
 000000dw     mod,reg,r/m       disp (0 or 2)                  
-------------------+---------------------------+---------------
 ADD  reg,reg      | add   ax,bx               | 88/86 3       
                   |                           | 286   2       
                   |                           | 386   2       
-------------------+---------------------------+---------------
 ADD  mem,reg      | add   total,cx            | 88/86 16+EA   
                   |                           | (W88=24+EA)   
                   | add   array[bx+di],dx     | 286   7       
                   |                           | 386   7       
-------------------+---------------------------+---------------
 ADD  reg,mem      | add   cx,incr             | 88/86 9+EA    
                   |                           | (W88=13+EA)   
                   | add   dx,[bp+6]           | 286   7       
                   |                           | 386   6       
-------------------+---------------------------+---------------
 100000sw     mod,000,r/m       disp (0 or 2)     data (1 or 2)
-------------------+---------------------------+---------------
 ADD  reg,immed    | add   bx,6                | 88/86 4       
                   |                           | 286   3       
                   |                           | 386   2       
-------------------+---------------------------+---------------
 ADD  mem,immed    | add   amount,27           | 88/86 17+EA   
                   |                           | (W88=23+EA)   
                   | add   pointers[bx][si],6  | 286   7       
                   |                           | 386   7       
-------------------+---------------------------+---------------
 0000010w     data (1 or 2)                                    
-------------------+---------------------------+---------------
 ADD  accum,immed  | add   ax,10               | 88/86 4       
                   |                           | 286   3       
                   |                           | 386   2       
-------------------+---------------------------+---------------
   1.1.2. AddLong                                              
;* AddLong - Adds two double-word (long) integers.             
;*                                                             
;* Shows:   Instructions - add     adc                         
;*                                                             
;* Params:  long1 - First integer                              
;*          long2 - Second integer                             
;*                                                             
;* Return:  Sum as long integer                                
AddLong PROC \                                                 
        long1:DWORD, long2:DWORD                               
        mov     ax, WORD PTR long1[0] ; AX = low word, long1   
                   Arithmetic Instructions                     
                                                               
                                                               
        mov     dx, WORD PTR long1[2] ; DX = high word, long1  
        add     ax, WORD PTR long2[0] ; Add low word, long2    
        adc     dx, WORD PTR long2[2] ; Add high word, long2   
        ret                           ; Result returned as DX:A
                                                               
AddLong ENDP                                                   
                                                               
                                                               
                                                               
   1.1.3. ADC                                                  
                                                               
                                                               
                                                               
Add with Carry                       Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  ADC dest,src                        *       * * * * * 
                                                               
   Adds the source operand, the destination  operand,  and  the
value of  the  carry  flag.  The  result  is  assigned  to  the
destination operand. This instruction is used to add  the  more
significant portions of numbers that must be added in  multiple
registers.                                                     
                                                               
 000100dw    mod,reg,r/m    disp(0 or 2)                       
---------------------------------------------------------------
 ADC  reg,reg      | adc   dx,cx               | 88/86 3       
                   |                           | 286   2       
                   |                           | 386   2       
---------------------------------------------------------------
 ADC  mem,reg      | adc   WORD PTR m32[2],dx  | 88/86 16+EA   
                   |                           | (W88=24+EA)   
                   |                           | 286   7       
                   |                           | 386   7       
---------------------------------------------------------------
 ADC  reg,mem      | adc   dx,WORD PTR m32[2]  | 88/86 9+EA    
                   |                           | (W88=13+EA)   
                   |                           | 286   7       
                   |                           | 386   6       
---------------------------------------------------------------
 100000sw    mod,010,r/m    disp (0 or 2)     data (1 or 2)    
---------------------------------------------------------------
 ADC  reg,immed    | adc   dx,12              | 88/86 4        
                   |                          | 286   3        
                   |                          | 386   2        
---------------------------------------------------------------
 ADC  mem,immed    | adc   WORD PTR m32[2],16 | 88/86 17+EA    
                   |                          | (W88=23+EA)    
                   |                          | 286   7        
                   |                          | 386   7        
---------------------------------------------------------------
 0001010w    data (1 or 2)                                     
---------------------------------------------------------------
 ADC  accum,immed  |  adc   ax,5              | 88/86 4        
                   |                          | 286   3        
                   |                          | 386   2        
---------------------------------------------------------------
                                                               
                                                               
                                                               
                   Arithmetic Instructions                     
   1.1.4. INC                                                  
Increment                            Flags:  O D I T S Z A P C 
Syntax:  INC dest                            ----------------- 
                                             *       * * * *   
   Adds 1 to the destination operand. Because  the  operand  is
treated as an unsigned integer, the INC  instruction  does  not
affect the carry flag. If a signed  carry  requires  detection,
use the ADD instruction.                                       
 1111111w     mod,000,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 INC  reg8        | inc   cl                | 88/86 3          
                  |                         | (W88=23+EA)      
                  |                         | 286   2          
                  |                         | 386   2          
---------------------------------------------------------------
 INC  mem         | inc   vpage             | 88/86 15+EA      
                  |                         | 286   7          
                  |                         | 386   6          
---------------------------------------------------------------
 01000 reg                                                     
---------------------------------------------------------------
 INC  reg16       | inc   bx                | 88/86 3          
                  |                         | 286   2          
                  |                         | 386   2          
---------------------------------------------------------------
   1.1.5. SUB                                                  
Subtract                             Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  SUB dest,src                        *       * * * * * 
   Subtracts the source operand from  the  destination  operand
and stores the result in the destination operand.              
 001010dw    mod,reg,r/m      disp (0 or 2)                    
---------------------------------------------------------------
 SUB  reg,reg      | sub    ax,bx              | 88/86 3       
                   | sub    bh,dh              | 286   2       
                   |                           | 386   2       
---------------------------------------------------------------
 SUB  mem,reg      | sub    tally,bx           | 88/86 16+EA   
                   |                           | (W88=24+EA)   
                   | sub    array[di],bl       | 286   7       
                   |                           | 386   6       
---------------------------------------------------------------
 SUB  reg,mem      | sub    cx,discard         | 88/86 9+EA    
                   |                           | (W88=13+EA)   
                   | sub    al,[bx]            | 286   7       
                   |                           | 386   7       
---------------------------------------------------------------
                   Arithmetic Instructions                     
                                                               
                                                               
 100000sw    mod,101,r/m      disp (0 or 2)     data (1 or 2)  
---------------------------------------------------------------
 SUB  reg,immed    | sub    dx,45              | 88/86 4       
                   | sub    bl,7               | 286   3       
                   |                           | 386   2       
---------------------------------------------------------------
 SUB  mem,immed    | sub    total,4000         | 88/86 17+EA   
                   |                           | (W88=25+EA)   
                   | sub    BYTE PTR [bx+di],2 | 286   7       
                   |                           | 386   7       
---------------------------------------------------------------
 0010110w    data (1 or 2)                                     
---------------------------------------------------------------
 SUB  accum,immed  | sub    ax,32000           | 88/86 4       
                   |                           | 286   3       
                   |                           | 386   2       
---------------------------------------------------------------
                                                               
                                                               
                                                               
   1.1.6. SBB                                                  
                                                               
                                                               
Subtract with Borrow                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  SBB dest,src                        *       * * * * * 
                                                               
   Subtracts the source from the  destination,  then  subtracts
the value of the carry flag from the  result.  This  result  is
assigned to the destination. SBB is used to subtract the  least
significant portions of  numbers  that  must  be  processed  in
multiple registers.                                            
                                                               
 000110dw     mod,reg,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 SBB  reg,reg       | sbb    dx,cx              | 88/86 3      
                    |                           | 286   2      
                    |                           | 386   2      
---------------------------------------------------------------
 SBB  mem,reg       | sbb    WORD PTR m32[2],dx | 88/86 16+EA  
                    |                           | (W88=24+EA)  
                    |                           | 286   7      
                    |                           | 386   6      
---------------------------------------------------------------
 SBB  reg,mem       | sbb    dx,WORD PTR m32[2] | 88/86 9+EA   
                    |                           | (W88=13+EA)  
                    |                           | 286   7      
                    |                           | 386   7      
---------------------------------------------------------------
 100000sw     mod,011,r/m      disp (0 or 2)     data (1 or 2) 
---------------------------------------------------------------
 SBB  reg,immed     | sbb    dx,45              | 88/86 4      
                    |                           | 286   3      
                    |                           | 386   2      
---------------------------------------------------------------
 SBB  mem,immed     | sbb    WORD PTR m32[2],40 | 88/86 17+EA  
                    |                           | (W88=25+EA)  
                    |                           | 286   7      
                    |                           | 386   7      
---------------------------------------------------------------
                                                               
                   Arithmetic Instructions                     
 0001110w     data (1 or 2)                                    
---------------------------------------------------------------
 SBB  accum,immed   | sb     ax,320             | 88/86 4      
                    |                           | 286   3      
                    |                           | 386   2      
---------------------------------------------------------------
   1.1.7. SubLong                                              
;* SubLong - Subtracts a double-word (long) integer from anothe
;*                                                             
;* Shows:   Instructions -  sub     sbb                        
;*                                                             
;* Params:  long1 - First integer                              
;*          long2 - Second integer                             
;*                                                             
;* Return:  Difference as long integer                         
SubLong PROC \                                                 
        long1:DWORD, long2:DWORD                               
    mov     ax, WORD PTR long1[0]   ; AX = low word, long1     
    mov     dx, WORD PTR long1[2]   ; DX = high word, long1    
    sub     ax, WORD PTR long2[0]   ; Subtract low word, long2 
    sbb     dx, WORD PTR long2[2]   ; Subtract high word, long2
    ret                             ; Result returned as DX:AX 
SubLong ENDP                                                   
   1.1.8. DEC                                                  
Decrement                            Flags:  O D I T S Z A P C 
Syntax:  DEC dest                            ----------------- 
                                             *       * * * *   
   Subtracts  1  from  the  destination  operand.  Because  the
operand is treated as an unsigned integer, the DEC  instruction
does not affect the carry flag. If  a  signed  borrow  requires
detection, use the SUB instruction.                            
 1111111w    mod,001,r/m      disp (0 or 2)                    
---------------------------------------------------------------
 DEC  reg8    | dec   cl            | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
---------------------------------------------------------------
 DEC  mem     | dec   counter       | 88/86 15+EA (W88=23+EA)  
              |                     | 286   7                  
              |                     | 386   6                  
---------------------------------------------------------------
                   Arithmetic Instructions                     
                                                               
                                                               
 01001,reg                                                     
---------------------------------------------------------------
 DEC  reg16   | dec   ax            | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
---------------------------------------------------------------
                                                               
                                                               
                                                               
   1.1.9. NEG                                                  
                                                               
                                                               
Two's Complement Negation            Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             *       * * * * * 
Syntax:  NEG dest                                              
                                                               
   Replaces the operand with its  two's  complement.  NEG  does
this by subtracting the operand from 0. If the  operand  is  0,
the carry flag is cleared. Otherwise the carry flag is set.  If
the operand contains the maximum possible negative value  (-128
for 8-bit operands or -32768 for 16-bit  operands),  the  value
does not change, but the overflow and carry flags are set.     
                                                               
 1111011w    mod, 011,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 NEG  reg     | neg   ax            | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
---------------------------------------------------------------
 NEG  mem     | neg   balance       | 88/86 16+EA (W88=24+EA)  
              |                     | 286   7                  
              |                     | 386   6                  
---------------------------------------------------------------
                                                               
                                                               
                                                               
   1.1.10. IMUL                                                
                                                               
                                                               
                                                               
Signed Multiply                      Flags:  O D I T S Z A P C 
Syntax:  IMUL src                            ----------------- 
                                             *       ? ? ? ? * 
                                                               
   Multiplies an implied destination  operand  by  a  specified
source operand. Both operands are treated as signed numbers. If
a single 16-bit operand is given, the implied destination is AX
and the product goes into the DX:AX register pair. If a  single
8-bit operand is given, the implied destination is AL  and  the
product goes into AX. On the 80386, if the operand is EAX,  the
product goes into the EDX:EAX  register  pair.  The  carry  and
overflow flags are set if the product is sign extended into  DX
for 16-bit operands, into AH for 8-bit operands,  or  into  EDX
for 32-bit operands.                                           
   Two additional syntaxes are  available  on  the  80186-80386
processors. In the two-operand form, a  16-bit  register  gives
one of the factors  and  serves  as  the  destination  for  the
result; a source constant specifies the other  factor.  In  the
three-operand form, the first  operand  is  a  16-bit  register
where the result  will  be  stored,  the  second  is  a  16-bit
register or memory operand containing one of the  factors,  and
                                                               
                   Arithmetic Instructions                     
the third is a constant representing  the  other  factor.  With
both variations, the overflow and carry flags are  set  if  the
result  is  too  large  to  fit  into  the  16-bit  destination
register. Since the low 16 bits of the product are the same for
both signed and unsigned multiplication, these syntaxes can  be
used for either signed or unsigned numbers.                    
 1111011w     mod,101,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 IMUL  reg    | imul  dx       | 88/86 b=80-98,w=128-154       
              |                | 286   b=13,w=21               
              |                | 386   b=9-14,w=9-22,d=9-38*   
---------------------------------------------------------------
 IMUL  mem    | imul  factor   | 88/86 (b=86-104,w=134-160)+EA*
              |                | 286   b=16,w=24               
              |                | 386   b=12-17,w=12-25,d=12-41*
---------------------------------------------------------------
   * The  80386  has  an  early-out  multiplication  algorithm.
Therefore multiplying an 8-bit or 16-bit value in EAX takes the
same time as multiplying the value in AL or AX.                
   ** Word  memory  operands  on  the  8088  take  (138-164)+EA
clocks.                                                        
                                                               
 011010s1     mod,reg,r/m      disp (0 or 2)     data (1 or 2) 
---------------------------------------------------------------
 IMUL  reg16,immed       | imul  cx,25    | 88/86 -            
                         |                | 286   21           
                         |                | 386                
                         |                | b=9-14,w=9-22,d=9-3
---------------------------------------------------------------
 IMUL  reg16,reg16,immed | imul  dx,ax,18 | 88/86 -            
                         |                | 286   21           
                         |                | 386                
                         |                | b=9-14,w=9-22,d=9-3
---------------------------------------------------------------
 IMUL  reg16,mem16,immed |imul  bx,[si],60| 88/86 -            
                         |                | 286   24           
                         |                | 386                
                         |                |    b=12-17,        
                         |                |    w=12-25,d=12-41 
---------------------------------------------------------------
   1.1.11. MUL                                                 
Unsigned Multiply                    Flags:  O D I T S Z A P C 
Syntax:  MUL src                             ----------------- 
                                             *       ? ? ? ? * 
   Multiplies an implied destination  operand  by  a  specified
source operand. Both operands are treated as unsigned  numbers.
If a single 16-bit operand is given, the implied destination is
AX and the product goes into the  DX:AX  register  pair.  If  a
single 8-bit operand is given, the implied  destination  is  AL
and the product goes into AX. The carry and overflow flags  are
set if DX is not 0 for 16-bit operands or if AH is not zero for
8-bit operands.                                                
                   Arithmetic Instructions                     
                                                               
                                                               
                                                               
 1111011w    mod, 100,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 MUL  reg        | mul   bx        | 88/86 b=70-77,w=118-113   
                 | mul   dl        | 286   b=13,w=21           
                 |                 | 386   b=9-14,w=9-22,d=9-38
---------------------------------------------------------------
 MUL  mem        | mul   factor  | 88/86 (b=76-83,w=124-139)+EA
                 | mul   WORD PTR [bx]    | 286   b=16,w=24    
                 |               | 386   b=12-17,w=12-25,d=12-4
---------------------------------------------------------------
*  Word memory operands on the 8088 take (128-143)+EA clocks.  
                                                               
                                                               
                                                               
   1.1.12. IDIV                                                
                                                               
                                                               
                                                               
Signed Divide                        Flags:  O D I T S Z A P C 
Syntax:  IDIV src                            ----------------- 
                                             ?       ? ? ? ? ? 
                                                               
   Divides an implied destination operand by a specified source
operand. Both operands are treated as signed  numbers.  If  the
source (divisor) is 16 bits wide, then the implied  destination
(dividend) is the DX:AX register pair. The quotient  goes  into
AX and the remainder into DX. If the source is 8 bits wide, the
implied destination is AX. The quotient goes into  AL  and  the
remainder into AH.                                             
                                                               
 1111011w     mod,111,r/m      disp (0 or 2)                   
---------------------------------------------------------------
 IDIV  reg    | idiv  bx        | 88/86 b=101-112,w=165-184    
              | div   dl        | 286   b=17,w=25              
              |                 | 386   b=19,w=27,d=43         
---------------------------------------------------------------
 IDIV  mem    | idiv  itemp     | 88/86 (b=107-118,w=171-190)+E
              |                 | 286   b=20,w=28              
              |                 | 386   b=22,w=30,d=46         
---------------------------------------------------------------
                                                               
* Word memory operands on the 8088 take (175-194)+EA clocks.   
                                                               
                                                               
                                                               
   1.1.13. DIV                                                 
                                                               
                                                               
                                                               
Unsigned Divide                      Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  DIV src                             ?       ? ? ? ? ? 
                                                               
   Divides an implied destination operand by a specified source
operand. Both operands are treated as unsigned numbers. If  the
source (divisor) is 16 bits wide, then the implied  destination
(dividend) is the DX:AX register pair. The quotient  goes  into
AX and the remainder into DX. If the source is 8 bits wide, the
implied destination operand is AX. The quotient  goes  into  AL
and the remainder into AH.                                     
                   Arithmetic Instructions                     
 1111011w    mod,110,r/m      disp (0 or 2)                    
-----------+---------------------+-----------------------------
 DIV  reg  | div   cx            | 88/86 b=80-90,w=144-162     
           | div   dl            | 286   b=14,w=22             
           |                     | 386   b=14,w=22,w=38        
-----------+---------------------+-----------------------------
 DIV  mem  | div   [bx]          | 88/86 (b=86-96,w=150-168)+EA
           | div   fsize         | 286   b=17,w=25             
           |                     | 386   b=17,w=25,d=41        
-----------+---------------------+-----------------------------
   * Word memory operands on the 8088 take (158-176)+EA clocks.
   1.2. BCD Adjust Instructions                                
   The ASCII instructions assume unpacked BCD values--one value
per  word.  The  DECIMAL   instructions   assume   packed   BCD
values--one value per byte.                                    
Mnemonic                                                       
            Name                                               
AAA                                                            
            ASCII Adjust After Addition                        
AAS                                                            
            ASCII Adjust After Subtraction                     
AAM                                                            
            ASCII Adjust After Multiply                        
AAD                                                            
            ASCII Adjust Before Division                       
DAA                                                            
            Decimal Adjust After Division                      
DAS                                                            
            Decimal Adjust After Subtraction                   
   1.2.1. AAA                                                  
ASCII Adjust After Addition          Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AAA                                 ?       ? ? * ? * 
   Adjusts the result of an addition to a decimal digit  (0-9).
The previous addition instruction should place its 8-bit sum in
AL. If the sum is greater than 9h, AH is  incremented  and  the
carry and auxiliary carry flags are set. Otherwise,  the  carry
and auxiliary carry flags are cleared.                         
 00110111                                                      
----------+------------------------+---------------------------
 AAA      | aaa                    | 88/86  8                  
          |                        | 286    3                  
          |                        | 386    4                  
----------+------------------------+---------------------------
                   BCD Adjust Instructions                     
                                                               
                                                               
   1.2.2. AAS                                                  
                                                               
                                                               
ASCII Adjust After Subtraction       Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AAS                                 ?       ? ? * ? * 
                                                               
   Adjusts the result of  a  subtraction  to  a  decimal  digit
(0-9). The previous subtraction instruction  should  place  its
8-bit result in AL. If the result is greater than 9h,  then  AH
is decremented and the carry and auxiliary carry flags are set.
Otherwise, the carry and auxiliary carry flags are cleared.    
                                                               
                                                               
                                                               
   1.2.3. AAS                                                  
                                                               
                                                               
                                                               
 00111111                                                      
--------------+--------------------+---------------------------
 AAS          | aas                | 88/86 8                   
              |                    | 286   3                   
              |                    | 386   4                   
--------------+--------------------+---------------------------
                                                               
                                                               
                                                               
   1.2.4. AAM                                                  
                                                               
                                                               
ASCII Adjust After Multiply          Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AAM                                 ?       * * ? * ? 
                                                               
   Converts an 8-bit binary number less than 100 decimal in  AL
to an unpacked BCD number in AX.  The  most  significant  digit
goes in AH and the least significant in AL. This instruction is
often used to adjust the product after a MUL  instruction  that
multiplies unpacked BCD digits in AH and AL. It is also used to
adjust the quotient after a  DIV  instruction  that  divides  a
binary number less than 100 decimal in AX by  an  unpacked  BCD
number.                                                        
                                                               
 11010100     00001010                                         
--------------+--------------------+---------------------------
 AAM          | aam                | 88/86 83                  
              |                    | 286   16                  
              |                    | 386   17                  
--------------+--------------------+---------------------------
                                                               
                                                               
                                                               
   1.2.5. IntToAsc                                             
                                                               
                                                               
                   BCD Adjust Instructions                     
;* IntToAsc - Converts integer to ASCII string.                
;* This procedure is useful only for assembly language,        
;* and is not intended to be C-callable.                       
;*                                                             
;* Shows:   Instructions - cwd     aam     xchg                
;*                                                             
;* Entry:   AX = integer (9999 max)                            
;*                                                             
;* Return:  DX:AX = 4-digit ASCII number                       
IntToAsc PROC                                                  
        cwd                     ; Zero DX register             
        mov     cx, 100         ; Divide AX by 100, yields     
        div     cx              ;   AX=quotient, DX=remainder  
        aam                     ; Make digits unpacked BCD     
        or      ax, '00'        ; Convert to ASCII             
        xchg    ax, dx          ; Do same thing for DX         
        aam                                                    
        or      ax, '00'                                       
        ret                     ; Return DX:AX = ASCII number  
IntToAsc ENDP                                                  
   1.2.6. AAD                                                  
ASCII Adjust Before Division         Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AAD                                 ?       * * ? * ? 
   Converts unpacked BCD digits in AH (most significant  digit)
and AL (least significant digit) to a binary number in AX.  The
instruction is often used to prepare an unpacked BCD number  in
AX for division by an unpacked BCD digit in an 8-bit  register.
 11010101     00001010                                         
----------+------------------------+---------------------------
 AAD      | aad                    | 88/86  60                 
          |                        | 286    14                 
          |                        | 386    19                 
----------+------------------------+---------------------------
   1.2.7. DAA                                                  
Decimal Adjust After Addition        Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  DAA                                 ?       * * * * * 
   Adjusts the result of an addition to  a  packed  BCD  number
(less than 100  decimal).  The  previous  addition  instruction
should place its 8-bit binary sum  in  AL.  DAA  converts  this
binary sum to packed BCD  format  with  the  least  significant
decimal digit in the lower four bits and the  most  significant
digit in the upper four bits. If the sum is  greater  than  99h
after adjustment, then the carry and auxiliary carry flags  are
                   BCD Adjust Instructions                     
                                                               
                                                               
set.  Otherwise,  the  carry  and  auxiliary  carry  flags  are
cleared.                                                       
                                                               
 00100111                                                      
--------------+---------------------+--------------------------
 DAA          | daa                 | 88/86 4                  
              |                     | 286   3                  
              |                     | 386   4                  
--------------+---------------------+--------------------------
                                                               
                                                               
                                                               
   1.2.8. DAS                                                  
                                                               
                                                               
Decimal Adjust after Subtraction     Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  DAS                                 ?       * * * * * 
                                                               
   Adjusts the result of a subtraction to a packed  BCD  number
(less than 100 decimal). The previous  subtraction  instruction
should place its 8-bit binary result in AL. DAS  converts  this
binary sum to packed BCD  format  with  the  least  significant
decimal digit in the lower four bits and the  most  significant
digit in the upper four bits. If the sum is  greater  than  99h
after adjustment, then the carry and auxiliary carry flags  are
set. Otherwise, carry and auxiliary carry flags are cleared.   
                                                               
 00101111                                                      
--------------+---------------------+--------------------------
 DAS          | das                 | 88/86 4                  
              |                     | 286   3                  
              |                     | 386   4                  
--------------+---------------------+--------------------------
                                                               
                                                               
                                                               
   1.3. Bit Shifting Instructions                              
                                                               
                                                               
   The ROTATE instructions cycle bit values through a  register
if done repeatedly. The SHIFT instructions do not recycle  bits
shifted out.                                                   
                                                               
                                                               
Mnemonic                                                       
            Name                                               
RCL                                                            
            Rotate Through Carry Left                          
RCR                                                            
            Rotate Through Carry Right                         
ROL                                                            
            Rotate Left                                        
ROR                                                            
            Rotate Right                                       
SAL                                                            
            Shift Arithmetic Left (identical to SHL)           
SAR                                                            
            Shift Arithmetic Right (preserves sign)            
SHL                                                            
            Shift Left                                         
SHR                                                            
                                                               
                  Bit Shifting Instructions                    
            Shift Right (does not preserve sign)               
   1.3.1. RCL/RCR/ROL/ROR                                      
Rotate                               Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             *               * 
Syntax:  RCL dest,1                                            
         RCL dest,CL                                           
         RCL dest,number (80186/286/386 Only)                  
   Rotates the bits in the destination operand  the  number  of
times specified in the source operand. RCL and ROL  rotate  the
bits left; RCR and ROR rotate right.                           
   ROL and ROR rotate the number of bits in  the  operand.  For
each rotation, the leftmost or rightmost bit is copied  to  the
carry flag as well as rotated. RCL and RCR rotate  through  the
carry flag. The carry flag becomes an extension of the  operand
so that a 9-bit rotation is  done  for  8-bit  operands,  or  a
17-bit rotation for 16-bit operands.                           
   On the 8088 and 8086, the source operand can be either CL or
1. On the 80186-80386, the source operand can be CL or an 8-bit
constant. On the 80186-80386, rotate counts larger than 31  are
masked off, but on the 8088 and 8086, larger rotate counts  are
performed despite the inefficiency involved. The overflow  flag
is only modified by single-bit variations of  the  instruction;
for multiple-bit variations it is undefined.                   
 1101000w    mod,TTT*,r/m     disp (0 or 2)                    
*  TTT represents one of the following bit codes: 000 for ROL, 
   001 for ROR, 010 for RCL, or 011 for RCR.                   
-------------+-------------------------+-----------------------
 ROL reg,1   | ror   ax,1              | 88/86 2               
 ROR reg,1   | rol   dl,1              | 286   2               
             |                         | 386   3               
-------------+-------------------------+-----------------------
 RCL reg,1   | rcl   dx,1              | 88/86 2               
 RCR reg,1   | rcr   bl,1              | 286   2               
             |                         | 386   9               
-------------+-------------------------+-----------------------
 ROL mem,1   | ror   bits,1            | 88/86 15+EA (W88=23+EA
 ROR mem,1   | rol   WORD PTR [bx],1   | 286   7               
             |                         | 386   7               
-------------+-------------------------+-----------------------
 RCL mem,1   | rcl   WORD PTR [si],1   | 88/86 15+EA (W88=23+EA
 RCR mem,1   | rcr   WORD PTR m32[0],1 | 286   7               
             |                         | 386   10              
-------------+-------------------------+-----------------------
                  Bit Shifting Instructions                    
                                                               
                                                               
 1101001w    mod,TTT*,r/m      disp (0 or 2)                   
                                                               
*  TTT represents one of the following bit codes: 000 for ROL, 
   001 for ROR, 010 for RCL, or 011 for RCR.                   
-------------+-------------------------+-----------------------
 ROL  reg,CL | ror   ax,cl             | 88/86 8+4n            
 ROR  reg,CL | rol   dx,cl             | 286   5+n             
             |                         | 386   3               
-------------+-------------------------+-----------------------
 RCL  reg,CL | rcl   dx,cl             | 88/86 8+4n            
 RCR  reg,CL | rcr   bl,cl             | 286   5+n             
             |                         | 386   9               
-------------+-------------------------+-----------------------
 ROL  mem,CL | ror   color,cl          | 88/86 20+EA+4n        
             |                         | (W88=28+EA+4n)        
 ROR  mem,CL | rol   WORD PTR [bp+6],cl| 286   8+n             
             |                         | 386   7               
-------------+-------------------------+-----------------------
 RCL  mem,CL | rcr  WORD PTR [bx+di],cl| 88/86 20+EA+4n        
             |                         | (W88=28+EA+4n)        
 RCR  mem,CL | rcl  masker             | 286   8+n             
             |                         | 386   10              
-------------+-------------------------+-----------------------
 1100000w    mod,TTT*,r/m       disp (0 or 2)     data (1)     
                                                               
*  TTT represents one of the following bit codes: 000 for ROL, 
   001 for ROR, 010 for RCL, or 011 for RCR.                   
------------------+-------------------------+------------------
 ROL  reg,immed8  | rol   ax,13             | 88/86 -          
 ROR  reg,immed8  | ror   bl,3              | 286   5+n        
                  |                         | 386   3          
------------------+-------------------------+------------------
 RCL  reg,immed8  | rcl   bx,5              | 88/86 -          
 RCR  reg,immed8  | rcr   si,9              | 286   5+n        
                  |                         | 386   9          
------------------+-------------------------+------------------
 ROL  mem,immed8  | rol   BYTE PTR [bx],10  | 88/86 -          
 ROR  mem,immed8  | ror   bits,6            | 286   8+n        
                  |                         | 386   7          
------------------+-------------------------+------------------
 RCL  mem,immed8  | rcl   WORD PTR [bp+8],5 | 88/86 -          
 RCR  mem,immed8  | rcr   masker,3          | 286   8+n        
                  |                         | 386   10         
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
   1.3.2. SAL/SAR/SHL/SHR                                      
                                                               
                                                               
Shift                                Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  SHL dest,1                          *       * * ? * * 
         SHL dest,CL                                           
         SHL dest,number (80186/286/386 Only)                  
                                                               
   Shifts the bits in the destination  operand  the  number  of
times specified by the source operand. SAL and  SHL  shift  the
bits left; SAR and SHR shift right.                            
   With SHL, SAL, and SHR, the bit shifted off the end  of  the
operand is copied into the  carry  flag  and  the  leftmost  or
rightmost bit opened by the shift is set to 0.  With  SAR,  the
                                                               
                  Bit Shifting Instructions                    
bit shifted off the end of the operand is copied into the carry
flag and the leftmost bit  opened  by  the  shift  retains  its
previous value (thus preserving the sign of the  operand).  SAL
and SHL are synonyms; they have the same effect.               
   On the 8088 and 8086, the source operand can be either CL or
1. On the 80186-80386 processors, the source operand can be  CL
or an 8-bit constant.  On  the  80186-80386  processors,  shift
counts larger than 31 are masked off, but on the 8088 and 8086,
larger shift counts  are  performed  despite  the  inefficiency
involved. The overflow flag  is  only  modified  by  single-bit
variations of the instruction; for multiple-bit  variations  it
is undefined.                                                  
   1.4. Compare Instructions                                   
   The compare instructions are similar to arithmetic and logic
instructions, except that the  result  is  not  stored  in  the
destination  operand.  Like  arithmetic   instructions,   these
instructions set processor flags and can set up a  test  for  a
subsequent conditional jump.                                   
Mnemonic                                                       
            Name                                               
CMP                                                            
            Compare (same as SUB but result is ignored)        
CMPS                                                           
            Compare String                                     
TEST                                                           
            Logical Compare (same as AND but result is ignored)
   1.4.1. CMP                                                  
Compare Two Operands                 Flags:  O D I T S Z A P C 
Syntax:  CMP dest,src                        ----------------- 
                                             *       * * * * * 
   Compares two operands as a test for a subsequent conditional
jump or set instruction.  CMP  does  this  by  subtracting  the
source operand from the destination  operand  and  setting  the
flags according to the result. CMP  is  the  same  as  the  SUB
instruction, except that the result is not stored.             
                     Compare Instructions                      
                                                               
                                                               
                                                               
 001110dw    mod,reg,r/m       disp (0 or 2)                   
-------------+---------------------+---------------------------
 CMP  reg,reg| cmp   di,bx         | 88/86 3                   
             | cmp   dl,cl         | 286   2                   
             |                     | 386   2                   
-------------+---------------------+---------------------------
 CMP  mem,reg| cmp   maximum,dx    | 88/86 9+EA (W88=13+EA)    
             | cmp   array[si],bl  | 286   7                   
             |                     | 386   5                   
-------------+---------------------+---------------------------
 CMP  reg,mem| cmp   dx,minimum    | 88/86 9+EA (W88=13+EA)    
             | cmp   bh,array[si]  | 286   6                   
             |                     | 386   6                   
-------------+---------------------+---------------------------
 100000sw    mod,111,r/m       disp (0 or 2)     data (1 or 2) 
-----------------+---------------------+-----------------------
 CMP  reg,immed  | cmp  ax,24          | 88/86 4               
                 |                     | 286   3               
                 |                     | 386   2               
-----------------+---------------------+-----------------------
 CMP  mem,immed  | cmp  WORD PTR [di],4| 88/86 10+EA (W88=14+EA
                 | cmp  tester,4000    | 286   6               
                 |                     | 386   5               
-----------------+---------------------+-----------------------
 0011110w    data (1 or 2)                                     
-----------------+-------------------------+-------------------
 CMP  accum,immed| cmp   ax,1000           | 88/86 4           
                 |                         | 286   3           
                 |                         | 386   2           
-----------------+-------------------------+-------------------
                                                               
                                                               
                                                               
   1.4.2. SetLineMode                                          
                                                               
                                                               
                                                               
;* SetLineMode - Sets line mode for EGA or VGA.                
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 11h                 
;*                            (Character Generator Interface)  
;*                           10h, Function 12h                 
;*                            (Video Subsystem Configuration)  
;*          Instruction - cmp                                  
;*                                                             
;* Uses:    vconfig - Video configuration structure, declared i
;*          the DEMO.INC include file. The structure must first
;*          be initialized by calling the GetVidConfig procedur
;*                                                             
;* Params:  line - Requested line mode (25, 43, or 50)         
;*                                                             
;* Return:  Short integer with error code                      
;*          0 if successful                                    
;*          1 if error                                         
                                                               
SetLineMode PROC \                                             
        line:WORD                                              
                                                               
        cmp     vconfig.adapter, EGA    ; EGA or VGA?          
        jge     @F              ; Yes?  Continue               
        jmp     e_exit          ; No?  Exit with error         
                     Compare Instructions                      
@@:     mov     ax, line        ; Check for valid parameter    
        cmp     al, 25                                         
        je      line25                                         
        cmp     al, 43                                         
        je      line43                                         
        cmp     al, 50                                         
        je      line50                                         
        jmp     SHORT e_exit                                   
                ; If not 25, 43, or 50, exit w/ error          
line25: mov     al, 11h         ; Set for EGA 25-line mode     
        cmp     vconfig.adapter, EGA    ; EGA?                 
        je      lmode           ; Yes?  Continue               
        mov     ax, 1202h       ; No?  Function 12h for VGA    
        mov     bl, 30h         ; AL = 2 for 400 scan lines    
        int     10h             ; Reset to 400 scan lines      
        mov     ax, 0003        ; Reset mode (Function 0)      
        int     10h             ;   to mode 3 (80-col text)    
        mov     al, 14h         ; Request 8x16 char matrix     
        jmp     SHORT lmode                                    
line43: mov     al, 12h         ; Set for EGA 43-line mode     
        cmp     vconfig.adapter, EGA    ; EGA?                 
        je      lmode           ; Yes?  Continue               
        mov     ax, 1201h       ; No?  Function 12h for VGA    
        mov     bl, 30h         ; AL = 1 for 350 scan lines    
        int     10h             ; Reset to 350 scan lines      
        mov     ax, 0003        ; Reset mode (Function 0)      
        int     10h             ;   to mode 3 (80-col text)    
        mov     al, 12h         ; Request 8x8 character matrix 
        jmp     SHORT lmode                                    
line50: cmp     vconfig.adapter, VGA    ; VGA?                 
        jne     e_exit          ; No?  Exit with error         
        mov     ax, 1202h       ; Yes?  Function 12h           
        mov     bl, 30h         ; AL = 2 for 400 scan lines    
        int     10h             ; Reset to 400 scan lines      
        mov     ax, 0003        ; Reset mode (Function 0)      
        int     10h             ;   to mode 3 (80-col text)    
        mov     al, 12h         ; Request 8x8 character matrix 
lmode:  sub     bl, bl          ; Use table 0                  
        mov     ah, 11h         ; Request Function 11h         
        int     10h             ; Set new line mode            
        mov     ah, 12h         ; Select alternate print       
        mov     bl, 20h         ;    screen for EGA and VGA    
        int     10h                                            
        cmp     vconfig.adapter, VGA    ; VGA?                 
        je      exit            ; Yes?  Then exit              
        cmp     line, 12h       ; If EGA 43-line mode, set     
        je      port            ;   cursor through port to     
                                ;   avoid cursor emulation bug 
        mov     al, 7           ; Else use BIOS to set cursor  
        push    ax              ; Pass bottom scan line        
        mov     al, 6                                          
        push    ax              ; Pass top scan line           
        call    SetCurSize      ; Set normal cursor            
        add     sp, 4           ; Clean stack                  
        jmp     SHORT exit      ; Exit                         
                     Compare Instructions                      
                                                               
                                                               
port:   mov     dx, 03D4h       ; Video controller address     
        mov     ax, 060Ah       ; Set AH = 06h (cursor start)  
                                ;     AL = 0Ah (register #)    
        out     dx, ax          ; Update port                  
        mov     ax, 000Bh       ; Set AH = 00h (cursor end)    
                                ;     AL = 0Bh (register #)    
        out     dx, ax          ; Update port                  
        jmp     SHORT exit      ; Normal exit                  
                                                               
e_exit: mov     ax, 1           ; Set error code               
        jmp     SHORT @F                                       
exit:   sub     ax, ax          ; Clear error code             
@@:     ret                                                    
                                                               
SetLineMode ENDP                                               
                                                               
                                                               
                                                               
                                                               
   1.4.3. CMPS/CMPSB/CMPSW                                     
                                                               
                                                               
Compare String                       Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             *       * * * * * 
Syntax:  CMPS dest,src                                         
         CMPSB                                                 
         CMPSW                                                 
                                                               
   Compares two strings. DS:SI must point to the source  string
and ES:DI  must  point  to  the  destination  string  (even  if
operands are  given).  For  each  comparison,  the  destination
element is subtracted from the source element and the flags are
updated to reflect the  result  (although  the  result  is  not
stored). DI and SI are adjusted according to the  size  of  the
operands and  the  status  of  the  direction  flag.  They  are
increased if the direction flag has been cleared  with  CLD  or
decreased if the direction flag has been set with STD.         
   If the CMPS form of the instruction is used,  operands  must
be provided to indicate the size of the  data  elements  to  be
processed. A segment override can be given for the source  (but
not for the destination). If CMPSB (bytes) or CMPSW (words)  is
used, the instruction determines the size of the data  elements
to be processed. Operands are not allowed with CMPSB or  CMPSW.
   CMPS  and  its  variations  are  usually  used  with  repeat
prefixes. REPNE (or REPNZ) is used  to  find  the  first  match
between two strings. REPE (or REPZ) is used to find  the  first
nonmatch. Before the comparison, CX should contain the  maximum
number of elements to compare. After a  REPNE  CMPS,  the  zero
flag will be cleared if no match was found. After a REPE  CMPS,
the zero flag will be set if no nonmatch was  found.  Otherwise
SI and DI will point to the element after the  first  match  or
nonmatch.                                                      
                                                               
 1010011w                                                      
------------------------------+--------------------+-----------
 CMPS  [segreg:]src,[ES:]dest |cmps  source,es:dest| 88/86 22 (
 CMPSB                        |repne cmpsw         | 286   8   
 CMPSW                        |repe  cmpsb         | 386   10  
------------------------------+--------------------+-----------
                                                               
                                                               
                     Compare Instructions                      
   1.4.4. StrCompare                                           
;* StrCompare - Compares two strings for equality.             
;* See StrWrite, StrFindChar, WinOpen, and WinClose            
;* procedures for other examples of string instructions.       
;*                                                             
;* Shows:   Instructions - cmpsb   cmpsw   repe   test   jcxz  
;*                                                             
;* Params:  str1 - Pointer to first string                     
;*          str2 - Pointer to second string                    
;*          len  - Length in bytes for comparison.             
;*                  Strings need not be of equal length;       
;*                  however if len is an even number,          
;*                  comparison is made on a word-by-word       
;*                  basis and thus is more efficient.          
;*                                                             
;* Return:  Null pointer if strings match;                     
;*                  else pointer to string #1 where match faile
StrCompare PROC \                                              
        USES ds di si, \                                       
        str1:PTR BYTE, str2:PTR BYTE, len:WORD                 
        LoadPtr es, di, str1    ; ES:DI points to string #1    
        LoadPtr ds, si, str2    ; DS:SI points to string #2    
        mov     cx, len         ; Length of search in bytes    
        and     al, 0           ; Set ZR flag in case CX = 0   
        jcxz    nullp           ; Assume success if length = 0 
        test    cl, 1           ; Even number?                 
        jz      wrdcmp          ; Yes?  Compare word-by-word   
        repe    cmpsb           ; No?  Compare byte-by-byte    
        jmp     SHORT nullp                                    
wrdcmp: shr     cx, 1           ; Decrease count by half       
        repe    cmpsw           ; Compare word-by-word         
        sub     di, 2           ; Back up 2 characters         
        sub     si, 2                                          
        cmpsb                   ; Match?                       
        jne     nullp           ; No?  Then failure            
        cmpsb                   ; Compare last characters      
nullp:  mov     ax, 0           ; Set null pointer without     
        mov     dx, 0           ;   disturbing flags           
        je      exit            ; If strings match, exit       
        dec     di              ; Else point to failure        
        mov     ax, di                                         
        mov     dx, es                                         
exit:   ret                                                    
StrCompare ENDP                                                
   1.4.5. TEST                                                 
Logical Compare                      Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  TEST dest,src                       0       * * ? * 0 
                     Compare Instructions                      
                                                               
                                                               
   Tests specified bits of an operand and sets the flags for  a
subsequent conditional jump or  set  instruction.  One  of  the
operands contains the value to be tested. The other contains  a
bit mask indicating the bits to be tested. TEST works by  doing
a logical bitwise AND on the source and  destination  operands.
The flags  are  modified  according  to  the  result,  but  the
destination operand is not changed.  This  instruction  is  the
same as the AND instruction, except  that  the  result  is  not
stored.                                                        
                                                               
 1000011w    mod,reg,r/m      disp (0 or 2)                    
---------------+-----------------------+-----------------------
 TEST  reg,reg | test   dx,bx          | 88/86 3               
               | test   bl,ch          | 286   2               
               |                       | 386   2               
---------------+-----------------------+-----------------------
 TEST  mem,reg*| test   dx,flags       | 88/86 9+EA (W88=13+EA)
 TEST  reg,mem | test   bl,bitarray[bx]| 286   6               
               |                       | 386   5               
---------------+-----------------------+-----------------------
   *The assembler transposes TEST mem,reg so that it is encoded
as TEST reg,mem                                                
                                                               
 1111011w    mod,000,r/m      disp (0 or 2)     data (1 or 2)  
-------------------+--------------------------+----------------
 TEST  reg,immed   | test   cx,30h            | 88/86 5        
                   | test   cl,1011b          | 286   3        
                   |                          | 386   2        
-------------------+--------------------------+----------------
 TEST  mem,immed   | test   masker,1          | 88/86 11+EA    
                   | test   BYTE PTR [bx],03h | 286   6        
                   |                          | 386   5        
-------------------+--------------------------+----------------
 1010100s    data (1 or 2)                                     
-------------------+--------------------------+----------------
 TEST  accum,immed | test   ax,90h            | 88/86 4        
                   |                          | 286   3        
                   |                          | 386   2        
-------------------+--------------------------+----------------
                                                               
                                                               
                                                               
   1.5. Control-Flow Instructions                              
                                                               
                                                               
Mnemonic                                                       
            Name                                               
JMP                                                            
            Jump Unconditionally                               
JCXZ/JECXZ                                                     
            Jump If CX is Zero                                 
Jcond                                                          
            Jump conditionally                                 
LOOP                                                           
            Loop (decrement CX, then jump if CX is not 0)      
LOOPE/LOOPZ                                                    
            Loop If (loop while condition is met and CX is  not
            0)                                                 
CALL                                                           
            Call Procedure                                     
RET                                                            
            Return from Procedure                              
                  Control-Flow Instructions                    
RETN/RETF                                                      
            Return from Procedure (near or far)                
INT                                                            
            Interrupt (call interrupt procedure)               
IRET                                                           
            Interrupt Return                                   
ENTER                                                          
            Make Stack Frame (80186/286/386 Only)              
LEAVE                                                          
            High Level Procedure Exit (80186/286/386 Only)     
   1.5.1. JMP                                                  
Jump Unconditionally                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  JMP label                                             
   Transfers program execution to the address specified by  the
destination operand. By default, jumps are near (between -32768
and 32767 bytes from the instruction following the  jump),  but
you can use an override to make them short  (between  -128  and
127 bytes) or far (in a different code segment). With near  and
short jumps, the operand specifies a new IP address.  With  far
jumps, the operand specifies new IP and CS addresses.          
 11101011       disp (1)                                       
------------------+-------------------------+------------------
 JMP  label       | jmp   SHORT exit        | 88/86 15         
                  |                         | 286   7+m        
                  |                         | 386   7+m        
------------------+-------------------------+------------------
 11101001    disp (2)                                          
------------------+-------------------------+------------------
 JMP  label       | jmp   close             | 88/86 15         
                  | jmp   NEAR PTR distant  | 286   7+m        
                  |                         | 386   7+m        
------------------+-------------------------+------------------
 11101010    disp (4)                                          
-----------------+-------------------------+-------------------
 JMP  label      | jmp   FAR PTR close     | 88/86 15          
                 | jmp   distant           | 286   11+m*       
                 |                         | 386   12+m*       
-----------------+-------------------------+-------------------
   * Timings for jumps through  call  or  task  gates  are  not
shown, since they are normally used only in operating  systems.
 11111111    mod,100,r/m      disp(0 or 2)                     
------------------+-------------------------+------------------
 JMP  reg16       | jmp   ax                | 88/86 11         
                  |                         | 286   7+m        
                  |                         | 386   7+m        
------------------+-------------------------+------------------
 JMP  mem16       | jmp   WORD [bx]         | 88/86 18+EA      
                  | jmp   table[di]         | 286   11+m       
                  | jmp   DWORD [si]        | 386   10+m       
------------------+-------------------------+------------------
                  Control-Flow Instructions                    
                                                               
                                                               
 11111111    mod,101,r/m      disp(4)                          
------------------+-------------------------+------------------
 JMP  mem32       | jmp   fpointer[si]      | 88/86 24+EA      
                  |                         | 286   15+m       
                  |                         | 386   12+m       
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
   1.5.2. JUMP.ASM                                             
                                                               
                                                               
                                                               
;* JUMP.ASM (unconditional jump) - The following code illustrat
;* how to transfer execution to another statement with the JMP 
;* instruction. The code is arranged as a program so that you  
;* can trace through it with a debugger.                       
;* See JCOND.ASM for examples of conditional jump instructions.
;*                                                             
;* Shows:   jmp                                                
                                                               
        .MODEL small                                           
        .STACK                                                 
        .CODE                                                  
        .STARTUP                                               
                                                               
; Jump to a destination (LBL2) within 128 bytes. Use SHORT oper
        mov     ax, 1           ; Make AX = 1                  
        jmp     SHORT lbl2      ; Skip short                   
lbl1:   mov     ax, 2           ; Never executed               
                                                               
lbl2:                           ; SHORT destination            
                                                               
; Jump to a "near" destination (between 128 and 32,767 bytes aw
        mov     bx, 2                                          
        jmp     label3          ; Jump near over the next secti
;       .                       ; Represents more than         
;       .                       ;   128 bytes                  
;       .                       ;   of code                    
        mov     bx, 5           ; Never executed               
label3:                         ; Near destination             
                                                               
; A dispatch table (jump table in this case).                  
; See the MISCDEMO.ASM example program for a similar call table
; Dispatch tables are arrays of addresses.                     
; An input value (such as a keystroke) is used to calculate    
; the index of the destination address.                        
                                                               
        .DATA                                                  
table   DW      dst4            ; Offset for dst4 (index 0)    
        DW      dst5            ; Offset for dst5 (index 2)    
        DW      dst6            ; Offset for dst6 (index 4)    
prompt  DB      13, 10, 'Type a number between 4 and 6 . . .  $
disp    DB      13, 10, 13, 10, 'You chose '                   
num     DB      ?, 13, 10, '$'                                 
                                                               
        .CODE                                                  
        mov     ah, 9       ; Request string display           
        mov     dx, OFFSET prompt                              
        int     21h         ; Display String                   
cons:   mov     ah, 7       ; Request console input without ech
        int     21h         ; Get Console Input                
                  Control-Flow Instructions                    
        cmp     al, '4'     ; Make sure it's between 4 and 6   
        jb      cons                                           
        cmp     al, '6'                                        
        ja      cons                                           
        sub     al, '4'     ; Convert to binary number         
        shl     al, 1       ; Convert byte index to word index 
        sub     ah, ah      ; Clear AX high byte               
        mov     bx, ax      ; Copy to BX for index             
        jmp     table[bx]   ; Jump to table address            
                            ; with correct label               
dst4:   mov     num, '4'    ; Copy 4 to string                 
        jmp     SHORT exit                                     
dst5:   mov     num, '5'    ; Copy 5 to string                 
        jmp     SHORT exit                                     
dst6:   mov     num, '6'    ; Copy 6 to string                 
exit:   mov     ah, 9   ; Request $-terminated string display  
        mov     dx, OFFSET disp                                
        int     21h     ; Display String                       
        .EXIT   num     ; Terminate program                    
                        ; with num as return code              
        END                                                    
   1.5.3. JCXZ/JECXZ                                           
Jump if CX is Zero                   Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  JCXZ label                                            
   Transfers program execution to the specified label if CX  is
0. If the count register is not 0, execution continues  at  the
next instruction. The label given as the operand must be  short
(between -128 and 127 bytes from the instruction following  the
jump).                                                         
 11100011       disp (1)                                       
------------------+-------------------------+------------------
 JCXZ  label      | jcxz  notfound          | 88/86 18,noj=6   
                  |                         | 286   8+m,noj=4  
                  |                         | 386   9+m,noj=5  
------------------+-------------------------+------------------
   1.5.4. Jcondition                                           
Jump Conditionally                   Flags:  O D I T S Z A P C 
                                             ----------------- 
   Transfers execution to the  specified  label  if  the  flags
condition is true. The condition  is  tested  by  checking  the
flags shown  in  the  table  on  the  following  page.  If  the
                  Control-Flow Instructions                    
                                                               
                                                               
condition is false, then no jump is taken and program execution
continues  at  the  next   instruction.   On   the   8088-80286
processors, the label  given  as  the  operand  must  be  short
(between -128 and 127 bytes from the instruction following  the
jump).                                                         
                                                               
 0111cond       disp (1)                                       
---------------------+-------------------------+---------------
                     | jg    bigger            | 88/86 16,noj=4
 Jcondition  label   | jo    SHORT too_big     | 286   7+m,noj=
                     | jpe   p_even            | 386   7+m,noj=
---------------------+-------------------------+---------------
                                                               
 00001111     1000cond       disp (2)                          
---------------------+-------------------------+---------------
                     | je    next              | 88/86 -       
 Jcondition  label   | jnae  lesser            | 286   -       
                     | js    negative          | 386   7+m,noj=
---------------------+-------------------------+---------------
                                                               
                                                               
                        JUMP CONDITIONS                        
                                                               
                                                               
Opcode      Mnemonic  Flags Checked   Description              
---------------------------------------------------------------
                                                               
size 0010   JB/JNAE   CF=1      Jump if below/not above or equa
size 0011   JAE/JNB   CF=0      Jump if above or equal/not belo
size 0110   JBE/JNA   CF=1 or                                  
                      ZF=1      Jump if below or equal/not abov
size 0111   JA/JNBE   CF=0 and                                 
                      ZF=0      Jump if above/not below or equa
size 0100   JE/JZ     ZF=1      Jump if equal (zero)           
size 0101   JNE/JNZ   ZF=0      Jump if not equal (not zero)   
size 1100   JL/JNGE   SF<>OF    Jump if less/not greater or equ
size 1101   JGE/JNL   SF=OF     Jump if greater or equal/not le
size 1110   JLE/JNG   ZF=1 or                                  
                      SF<>OF    Jump if less or equal/not great
size 1111   JG/JNLE   ZF=0 or                                  
                      SF=OF     Jump if greater/not less or equ
size 1000   JS        SF=1      Jump if sign                   
size 1001   JNS       SF=0      Jump if not sign               
size 0010   JC        CF=1      Jump if carry                  
size 0011   JNC       CF=0      Jump if not carry              
size 0000   JO        OF=1      Jump if overflow               
size 0001   JNO       OF=0      Jump if not overflow           
size 1010   JP/JPE    PF=1      Jump if parity/parity even     
size 1011   JNP/JPO   PF=0      Jump if no parity/parity odd   
                                                               
Note: The size bits are 0111 for short jumps.                  
                                                               
                                                               
                                                               
   1.5.5. JCOND.ASM                                            
                                                               
                                                               
;* JCOND.ASM (conditional jump) shows how to transfer execution
;* conditionally with jump instructions. The code is arranged  
;* as a program so that you can trace through it and change    
;* registers to test alternate results. Many (but not          
;* all) of the conditional jump instructions are illustrated.  
                                                               
                  Control-Flow Instructions                    
;*                                                             
;* See JUMP.ASM for an example of the related JMP instruction  
;* and StrCompare for an example of JCXZ.                      
;*                                                             
;* Shows: jb/jnae  jae/jnb  jbe/jna  ja/jnbe  (unsigned)       
;*        jl/jnge  jge/jnl  jle/jng  jg/jnle  (signed)         
;*        je/jz    js       jns             (equality and sign)
;*        jc       jnc      jo       jno   (carry and overflow)
;*        jp/jpe   jnp/jpo                          (parity)   
        .MODEL small                                           
        .STACK                                                 
        .CODE                                                  
        .STARTUP                                               
        mov     ax, 1   ; Initialize arbitrary registers       
                        ; for comparisons                      
        mov     bx, 2                                          
        mov     cx, 3                                          
        cmp     ax, bx  ; Compare unsigned relative values     
        jb      below   ; Jump if unsigned AX                  
                        ;  is below unsigned BX                
        je      equal                                          
above:  add     cx, 2   ; If not below and not equal,          
                        ;  must be above                       
equal:  add     cx, 2   ; Jump to here if equal                
below:  add     cx, 2   ; Jump here if below                   
        cmp     ax, bx  ; Compare signed relative values       
        jl      less    ; Jump if signed AX                    
        jg      more    ;  is less than signed BX              
        add     cx, 2   ; If not less or more, must be equal   
less:   add     cx, 2   ; Jump here if less                    
more:   add     cx, 2   ; Jump here if more                    
        sub     ax, 2   ; Set flags for sign test              
        js      sign    ; Jump if sign flag is set             
nosign: add     cx, 1   ; Sign not set, so positive number     
sign:   add     cx, -1  ; Sign set for negative.               
        sub     bx, 3   ; Set flags for carry test (make BX = -
        jc      carry   ; Jump if carry flag is set            
nocarry:add     cx, 1   ; Subtraction causes carry             
carry:  add     cx, -1  ; Subtraction doesn't cause carry      
        mov     al, 254 ; Prepare for multiply                 
        mul     bl      ; Set flags with multiply of AL x BL   
        jo      over    ; Jump if overflow flag is set         
ok:     add     cx, 2   ; No overflow                          
over:   add     cx, 2   ; Jump not taken,                      
                        ;  so this line is executed            
        cmp     ax, bx  ; Set flags for parity check           
        jp      peven   ; Jump if parity flag is set           
                        ;  (parity even)                       
podd:   add     cx, 2   ; Odd number of set bits in            
                        ;  low byte of result                  
peven:  add     cx, 2   ; Even number of set bits in           
                        ;  low byte of result                  
exit:   .EXIT           ; Terminate program                    
                  Control-Flow Instructions                    
                                                               
                                                               
                                                               
        END                                                    
                                                               
                                                               
                                                               
   1.5.6. LOOP                                                 
                                                               
                                                               
Loop                                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  LOOP label                                            
                                                               
   Loops repeatedly to a specified label.  LOOP  decrements  CX
(without changing any flags)  and  if  the  result  is  not  0,
transfers execution to the address specified by the operand. If
CX is 0 after being decremented,  execution  continues  at  the
next instruction.  The  operand  must  specify  a  short  label
(between -128 and 127 bytes from the instruction following  the
LOOP instruction).                                             
                                                               
 11100010       disp (1)                                       
------------------+-------------------------+------------------
 LOOP  label      | loop  wend              | 88/86 17,noj=5   
                  |                         | 286   8+m,noj=4  
                  |                         | 386   11+m       
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
   1.5.7. WriteTTY                                             
                                                               
                                                               
;* WriteTTY - Displays ASCIIZ string at cursor position,       
;* in either text or graphics mode.                            
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 0Eh                 
;*           (Write Character in TTY mode)                     
;*          Instruction - loop                                 
;*                                                             
;* Uses:    vconfig - Video configuration structure, declared  
;*          in the DEMO.INC include file.                      
;*          The structure must first be initialized            
;*          by calling the GetVidConfig procedure.             
;*                                                             
;* Params:  str - Pointer to ASCIIZ string                     
;*          icolor - Color index (for graphics mode only)      
;*                                                             
;* Return:  None                                               
                                                               
WriteTTY PROC \                                                
        USES ds si, \                                          
        str:PTR BYTE, icolor:WORD                              
                                                               
        mov     bx, icolor          ; BL = color index         
        mov     bh, vconfig.dpage   ; BH = current display page
        LoadPtr ds, si, str                                    
        mov     cx, -1          ; Set loop counter to maximum  
        mov     ah, 14          ; Function 14                  
loop1:  lodsb                   ; Get character from string    
        or      al, al          ; NULL string terminator?      
        jz      exit            ; Yes?  Exit                   
        int     10h             ; No?  Display, advance cursor 
                                                               
                  Control-Flow Instructions                    
        loop    loop1           ; Loop to get next character   
exit:   ret                                                    
WriteTTY ENDP                                                  
   1.5.8. LOOPcondition                                        
Loop If                              Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  LOOPE label                                           
         LOOPNE label                                          
   Loops repeatedly to a specified label if  condition  is  met
and if CX is not 0.  The  instruction  decrements  CX  (without
changing any flags) and tests to see if the zero flag  was  set
by a previous instruction (such as CMP). With LOOPE  and  LOOPZ
(they are synonyms), execution is transferred to the  label  if
the zero flag is set and CX is not 0. With  LOOPNE  and  LOOPNZ
(they are synonyms), execution is transferred to the  label  if
the zero flag is cleared and CX is not 0.  Execution  continues
at the next instruction if the condition  is  not  met.  Before
entering the loop, CX should be set to the  maximum  number  of
repetitions desired.                                           
 11100001       disp (1)                                       
-----------------+-------------------------+-------------------
 LOOPE label     | loopz again             | 88/86     18,noj=6
 LOOPZ label     |                         | 286       8+m,noj=
                 |                         | 386       11+m    
-----------------+-------------------------+-------------------
   11100000       disp (1)                                     
-----------------+-------------------------+-------------------
 LOOPNE label    | loopnzfor_next          | 88/86     19,noj=5
 LOOPNZ label    |                         |   286     8,noj=4 
                 |                         |   386     11+m    
-----------------+-------------------------+-------------------
   1.5.9. CALL                                                 
Call Procedure                       Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  CALL label                                            
   Calls a procedure. The instruction does this by pushing  the
address of the next instruction onto the stack and transferring
to the address specified by the operand. For NEAR calls, SP  is
decreased by 2, the offset (IP) is pushed, and the  new  offset
is loaded into IP.                                             
   For FAR calls, SP is decreased by 2,  the  segment  (CS)  is
pushed, and the new segment is  loaded  into  CS.  Then  SP  is
decreased by 2 again, the offset (IP) is pushed,  and  the  new
offset is loaded into IP. A subsequent RET instruction can  pop
the address so that execution continues  with  the  instruction
following the call.                                            
                  Control-Flow Instructions                    
                                                               
                                                               
                                                               
 11101000       disp (2)                                       
-----------------+-------------------------+-------------------
 CALL  label     | call  upcase            | 88/86     19 (88=2
                 |                         | 286       7+m     
                 |                         | 386       7+m     
-----------------+-------------------------+-------------------
 10011010       disp (4)                                       
-------------+---------------------+---------------------------
 CALL  label | call  FAR PTR job   | 88/86     28 (88=36)      
             | call  distant       | 286       13+m,pm=26+m    
             |                     | 386       17+m,pm=34+m    
-------------+---------------------+---------------------------
 11111111       mod,010,r/m      disp(0 or 2)                  
-------------+---------------------+---------------------------
 CALL  reg   | call  ax            | 88/86     16 (88=20)      
             |                     | 286       7+m             
             |                     | 386       7+m             
-------------+---------------------+---------------------------
 CALL  mem16 | call  pointer       | 88/86     21+EA (88=29+EA)
             | call  [bx]          | 286       11+m            
             |                     | 386       10+m            
-------------+---------------------+---------------------------
 11111111       mod,011,r/m      disp(4)                       
-------------+---------------------+-------------------------- 
 CALL  mem32 | call  far_table[di] | 88/86     37+EA (88=53+EA)
             | call  DWORD PTR [bx]| 286       16+m,pm=29+m    
             |                     | 386       22+m,pm=38+m    
-------------+---------------------+-------------------------- 
                                                               
                                                               
                                                               
   1.5.10. HELLOM.ASM                                          
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                  Control-Flow Instructions                    
;* HELLOM.ASM illustrates multiple-modules and memory model    
;* independent techniques. To create the program, paste this   
;* module and PUTSTR.ASM (get help on PUTSTR.ASM to open it)   
;* into separate program files. In the environment, you must   
;* also create a program list for the program and define a mode
;* in the Defines field of the Assembler Flags dialog box.     
;* For example, use "model=large". Alternately, you could assem
;* outside the environment with the following command line:    
;*      qcl /Dmodel=large hellom.asm putstr.asm                
;*                                                             
;* Shows:   Instruction - call                                 
;*          Directives - EXTRN                                 
;*          Equates - @DataSize     @CodeSize                  
;*          Operators - %                                      
; Model is symbol passed from command line or environment.     
; Note that the % operator is required to receive              
; external constant symbols.                                   
%       .MODEL  model, c                                       
        DOSSEG                                                 
        .STACK  100h                                           
        .DATA                                                  
msg     DB "Hello, world.",13,10,0  ; Null-terminated string   
        .CODE                                                  
        .STARTUP         ; Initialize data and stack segments  
; Tell assembler that PutStr is elsewhere (in another module). 
        EXTRN   PutStr:PROC     ; PROC evalutes to NEAR or FAR 
                                ;   code depending on model    
        IF      @DataSize       ; If data is far (compact, larg
        push    ds              ;   or huge), push data segment
        ENDIF                                                  
        mov     ax, OFFSET msg  ; Always push the offset       
        push    ax                                             
        call    PutStr          ; Call external procedure      
        .EXIT                   ; Exit program                 
        END                                                    
   1.5.11. RET/RETN/RETF                                       
Return from Procedure                Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  RET [number]                                          
   Returns from a  procedure  by  transferring  control  to  an
address popped from the top of the stack.  A  constant  operand
can be given indicating  the  number  of  additional  bytes  to
release. The constant is normally used to adjust the stack  for
arguments pushed before the procedure was called. The size of a
return (near or far) is the size of the procedure in which  the
RET is defined with the PROC directive.                        
   RETN can be used to specify a near return; RETF can  specify
a far return. A near return works by popping a word into IP.  A
                  Control-Flow Instructions                    
                                                               
                                                               
far return works by popping a word into IP and then  popping  a
word into CS. After the return, the number of  bytes  given  in
the operand (if any) is added to SP.                           
                                                               
 11000011                                                      
------------------+-------------------------+------------------
 RET              | ret                     | 88/86 16 (88=20) 
 RETN             | retn                    | 286   11+m       
                  |                         | 386   10+m       
------------------+-------------------------+------------------
 11000010    data (2)                                          
------------------+-------------------------+------------------
 RET  immed16     | ret   2                 | 88/86 20 (88=24) 
 RETN  immed16    | retn  8                 | 286   11+m       
                  |                         | 386   10+m       
------------------+-------------------------+------------------
 11001011                                                      
------------------+-------------------------+------------------
 RET              | ret                     | 88/86 26 (88=34) 
 RETF             | retf                    | 286   15+m       
                  |                         | 386   18+m       
------------------+-------------------------+------------------
                                                               
 11001010    data (2)                                          
------------------+-------------------------+------------------
 RET  immed16     | ret   8                 | 88/86 25 (88=33) 
 RETF  immed16    | retf  32                | 286   15+m       
                  |                         | 386   18+m       
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
   1.5.12. INT                                                 
                                                               
                                                               
Interrupt                            Flags:  O D I T S Z A P C 
                                             ----------------- 
                                                 0 0           
Syntax:  INT number                                            
                                                               
   Generates a software interrupt. An 8-bit constant operand (0
to 255) specifies the interrupt procedure  to  be  called.  The
call  is  made  by  indexing  the  interrupt  number  into  the
Interrupt Descriptor Table (IDT) starting at segment 0,  offset
0. The IDT contains 4-byte pointers  to  interrupt  procedures.
When an interrupt is called, the flags CS  and  IP  are  pushed
onto the stack (in that order) and the trap and interrupt flags
are cleared. STI can be used to restore interrupts.  To  return
from an interrupt, use the IRET instruction.                   
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                  Control-Flow Instructions                    
 11001101       data (1)                                       
------------------+-------------------------+------------------
 INT  immed8      | int   25h               | 88/86 51 (88=71) 
                  |                         | 286   23+m       
                  |                         | 386   37         
------------------+-------------------------+------------------
 11001100                                                      
------------------+-------------------------+------------------
 INT  3           | int   3                 | 88/86 52 (88=72) 
                  |                         | 286   23+m       
                  |                         | 386   33         
------------------+-------------------------+------------------
   1.5.13. IRET                                                
Interrupt Return                     Flags:  O D I T S Z A P C 
Syntax:  IRET                                ----------------- 
                                             * * * * * * * * * 
   Returns  control  from  an  interrupt   procedure   to   the
interrupted code. The IRET instruction pops  IP,  CS,  and  the
flags (in that order) and resumes execution.                   
 11001111                                                      
------------------+------------------+-------------------------
 IRET             | iret             | 88/86 32 (88=44)        
                  |                  | 286   17+m              
                  |                  | 386   22                
------------------+------------------+-------------------------
   1.5.14. NewBreak                                            
;* NewBreak - A primitive handler for Interrupt 1Bh that can ta
;* control when the Ctrl-Break keyboard sequence is pressed.   
;* For an example of how to use such a handler and install its 
;* address into the interrupt vector table,                    
;* see the MiscDemo program and the Exec example procedure.    
;*                                                             
;* Shows:   BIOS Interrupt - 1Bh (Ctrl-Break Handler Address)  
;*          Instruction - iret                                 
NewBreak PROC                                                  
        sti                 ; Reenable interrupts              
        push    ax          ; Preserve AX register             
        mov     al, 20h     ; Send end-of-interrupt signal     
        out     20h, al     ;   to interrupt controller        
        pop     ax          ; Recover AX register              
        iret                ; Return from handler              
                            ;   without taking action          
NewBreak ENDP                                                  
                  Control-Flow Instructions                    
                                                               
                                                               
   1.5.15. ENTER                                               
                                                               
                                                               
Make Stack Frame                     Flags:  O D I T S Z A P C 
80186/286/386 Only                           ----------------- 
                                                               
Syntax:  ENTER bytes,nesting                                   
                                                               
   Creates  a  stack  frame  for  a  procedure  that   receives
parameters passed on the stack. The BP register is  pushed  and
BP is set as the stack frame through which parameters and local
variables can be accessed.  The  first  operand  of  the  ENTER
instruction specifies the number of bytes to reserve for  local
variables. The second operand specifies the nesting  level  for
the procedure. The nesting level should be 0 for languages that
do  not  allow  access  to  local  variables  of  higher  level
procedures  (such  as  C,  BASIC,   and   FORTRAN).   See   the
complementary instruction LEAVE for a method of exiting from  a
procedure.                                                     
                                                               
 11001000       data (2)     data (1)                          
------------------------+----------------------+---------------
 ENTER  immed16,0       | enter 4,0            | 88/86 -       
                        |                      | 286   11      
                        |                      | 386   10      
------------------------+----------------------+---------------
 ENTER  immed16,1       | enter 0,1            | 88/86 -       
                        |                      | 286   15      
                        |                      | 386   12      
------------------------+----------------------+---------------
 ENTER  immed16,immed8  | enter 6,4            | 88/86 -       
                        |                      | 286   12+4(n-1
                        |                      | 386   15+4(n-1
------------------------+----------------------+---------------
                                                               
                                                               
                                                               
   1.5.16. LEAVE                                               
                                                               
                                                               
High Level Procedure Exit            Flags:  O D I T S Z A P C 
80186/286/386 Only                           ----------------- 
                                                               
Syntax:  LEAVE                                                 
                                                               
   Terminates the stack frame of a  procedure.  LEAVE  reverses
the action of a previous ENTER instruction by restoring SP  and
BP to the values they had before the procedure stack frame  was
initialized.                                                   
                                                               
 11001001                                                      
------------------+-------------------------+------------------
 LEAVE            | leave                   | 88/86 -          
                  |                         | 286   5          
                  |                         | 386   4          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                  Data Transfer Instructions                   
   1.6. Data Transfer Instructions                             
Mnemonic                                                       
            Name                                               
MOV                                                            
            Move Data                                          
MOVS                                                           
            Move String Data                                   
XCHG                                                           
            Exchange (switch values between two operands)      
LODS                                                           
            Load String Data                                   
STOS                                                           
            Store String Data                                  
LEA                                                            
            Load Effective Address (calculate address of memory
            operand)                                           
LES                                                            
            Load Far Pointer to Extra Segment (ES)             
LDS                                                            
            Load Far Pointer to Data Segment (DS)              
XLAT/XLATB                                                     
            Translate (translate a value by using  a  table  in
            memory)                                            
               1.6.1. MOV                                      
Move Data                                                      
                                     Flags:  O D I T S Z A P C 
Syntax:  MOV dest,src                        ----------------- 
               Copies the value in the source  operand  to  the
            destination operand. If the destination operand  is
            SS, then interrupts are  disabled  until  the  next
            instruction is executed (except on  early  versions
            of the 8088 and 8086).                             
 100010dw       mod, reg, r/m     disp (0 or 2)                
-------------+-------------------------+-----------------------
 MOV  reg,reg| mov   dh,bh             | 88/86 2               
             | mov   dx,cx             | 286   2               
             | mov   bp,sp             | 386   2               
-------------+-------------------------+-----------------------
 MOV  mem,reg| mov   array[di],bx      | 88/86 9+EA (W88=13+EA)
             | mov   count,cx          | 286   3               
             |                         | 386   2               
-------------+-------------------------+-----------------------
 MOV  reg,mem| mov   bx,pointer        | 88/86 8+EA (W88=12+EA)
             | mov   dx,matrix[bx+di]  | 286   5               
             |                         | 386   4               
-------------+-------------------------+-----------------------
 1100011w       mod, 000,r/m      disp (0 or 2)     data (1 or 
-----------------+----------------------+----------------------
 MOV  mem,immed  | mov   [bx],15        | 88/86 10+EA (W88=14+E
                 | mov   color,7        | 286   3              
                 |                      | 386   2              
-----------------+----------------------+----------------------
                  Data Transfer Instructions                   
                                                               
                                                               
 1011w reg      data (1 or 2)                                  
----------------------+-------------------------+--------------
 MOV  reg,immed       | mov   cx,256            | 88/86 4      
                      | mov   dx,OFFSET string  | 286   2      
                      |                         | 386   2      
----------------------+-------------------------+--------------
 101000dw       disp (0 or 2)                                  
------------------+---------------------+----------------------
 MOV  mem,accum   | mov   total,ax      | 88/86 10 (W88=14)    
                  | mov   [di],al       | 286   3              
                  |                     | 386   2              
------------------+---------------------+----------------------
 MOV  accum,mem   | mov   al,string[bx] | 88/86 10 (W88=14)    
                  | mov   ax,fsize      | 286   5              
                  |                     | 386   4              
------------------+---------------------+----------------------
 100011d0       mod,sreg, r/m     disp (0 or 2)                
------------------+---------------------+----------------------
 MOV  segreg,reg16| mov   ds,ax         | 88/86 2              
                  |                     | 286   2              
                  |                     | 386   2              
------------------+---------------------+----------------------
 MOV  segreg,mem16| mov   es,psp        | 88/86 8+EA (88=12+EA)
                  |                     | 286   5              
                  |                     | 386   5              
------------------+---------------------+----------------------
 MOV  reg16,segreg| mov   ax,ds         | 88/86 2              
                  |                     | 286   2              
                  |                     | 386   2              
------------------+---------------------+----------------------
 MOV  mem16,segreg| mov   stack_save,ss | 88/86 9+EA (88=13+EA)
                  |                     | 286   3              
                  |                     | 386   2              
------------------+---------------------+----------------------
                                                               
                                                               
                                                               
               1.6.2. MOVS/MOVSB/MOVSW                         
                                                               
                                                               
Move String Data                     Flags:  O D I T S Z A P C 
                                             ----------------- 
                                                               
Syntax:  MOVS dest,src                                         
         MOVSB                                                 
         MOVSW                                                 
                                                               
               Moves a  string  from  one  area  of  memory  to
            another. The source string must be  pointed  to  by
            DS:SI and the destination address must  be  pointed
            to by ES:DI (even if operands are given). For  each
            element moved, DI and SI are adjusted according  to
            the size of the operands  and  the  status  of  the
            direction flag. They are increased if the direction
            flag has been cleared with CLD, or decreased if the
            direction flag has been set with STD.              
               If the MOVS form of  the  instruction  is  used,
            operands must be provided to indicate the  size  of
            the  data  elements  to  be  processed.  A  segment
            override can be given for the source  operand  (but
            not for the destination). If MOVSB (bytes) or MOVSW
            (words) is used,  the  instruction  determines  the
                                                               
                  Data Transfer Instructions                   
            size of the data elements to be processed. Operands
            are not allowed in MOVSB or MOVSW.                 
               MOVS and its variations are  usually  used  with
            the REP  prefix.  Before  a  move  using  a  repeat
            prefix, CX should contain the number of elements to
            move.                                              
 1010010w                                                      
-----------------------------+----------------------+----------
 MOVS [ES:]dest,[segreg:]src | rep   movsb          | 88/86 18 
                             |                      |  (W88=26)
 MOVSB                       | movs  dest,es:source | 286   5  
 MOVSW                       |                      | 386   7  
-----------------------------+----------------------+----------
               1.6.3. WinOpen                                  
;* WinOpen - Saves portion of screen to allocated memory,      
;* then opens a window with specified fill attribute.          
;* See also the WinClose procedure.                            
;*                                                             
;* Shows:   DOS Function - 48h (Allocate Memory Block)         
;*          BIOS Interrupt - 10h,                              
;*           Function 6 (Initialize or Scroll Up Window)       
;*          Instructions - movsw     stosw     rep             
;*                                                             
;* Uses:    vconfig - Video configuration structure, declared  
;*          in the DEMO.INC include file.                      
;*          The structure must first be initialized            
;*          by calling the GetVidConfig procedure.             
;*                                                             
;* Params:  row1 - Row at top of window                        
;*          col1 - Column at left edge of window               
;*          row2 - Row at bottom of window                     
;*          col2 - Column at right edge of window              
;*          attr - Fill attribute for window                   
;*                                                             
;* Return:  Short integer with segment address of allocated    
;*          buffer, or 0 if unable to allocate memory          
WinOpen PROC \                                                 
        USES ds di si, \                                       
        row1:WORD, col1:WORD, row2:WORD, col2:WORD, attr:WORD  
        GetVidOffset row1, col1 ; Get offset in video segment  
        mov     si, ax          ; SI = video offset for window 
        mov     bx, row2                                       
        sub     bx, row1                                       
        inc     bx              ; BX = number of window rows   
        mov     cx, col2                                       
        sub     cx, col1                                       
        inc     cx              ; CX = number of columns       
        mov     ax, cx          ; Compute number of video      
        mul     bl              ;   cells in window            
        add     ax, 3           ; Plus 3 additional entries    
        shr     ax, 1           ; Shift right 3 times to       
        shr     ax, 1           ;   multiply by 2 bytes/cell,  
        shr     ax, 1           ;   divide by 16 bytes/para    
                  Data Transfer Instructions                   
                                                               
                                                               
        inc     ax              ; Add a paragraph              
        push    bx              ; Save number of rows          
        mov     bx, ax          ; BX = number of paragraphs    
        mov     ah, 48h         ; Request DOS Function 48h     
        int     21h             ; Allocate Memory Block        
        pop     bx                                             
        jnc     @F              ; If successful, continue      
        sub     ax, ax          ; Else return null pointer     
        jmp     SHORT exit                                     
                                                               
@@:     mov     es, ax          ; Point ES:DI to allocated     
        sub     di, di          ;   buffer                     
        mov     ax, si                                         
        stosw                   ; Copy video offset to buffer  
        mov     ax, bx                                         
        stosw                   ; Number of rows to buffer     
        mov     ax, cx                                         
        stosw                       ; Number of cols to buffer 
        mov     ax, 160             ; Number of video cells/row
        mov     ds, vconfig.sgmnt   ; DS = video segment       
loop1:  push    si                  ; Save ptr to start of line
        push    cx                  ;   and number of columns  
        cmp     vconfig.adapter, CGA    ; CGA adapter?         
        jne     @F                  ; No?  Skip video disable  
                                                               
               For CGA adapters, WinOpen avoids  screen  "snow"
            by disabling the video prior  block  memory  moves,
            then reenabling it.  Although  this  technique  can
            result in brief  flickering,  it  demonstrates  the
            fastest way to access a  block  in  the  CGA  video
            buffer without causing display snow. See  also  the
            StrWrite procedure  for  another  solution  to  the
            problem of CGA snow.                               
                                                               
        call    DisableCGA      ; Yes?  Disable video          
@@:     rep     movsw           ; Copy one row to buffer       
        cmp     vconfig.adapter, CGA                           
        jne     @F                                             
        call    EnableCGA       ; Reenable CGA video           
@@:     pop     cx              ; Recover number of columns    
        pop     si              ;   and start of line          
        add     si, ax          ; Point to start of next line  
        dec     bx              ; Decrement row counter        
        jnz     loop1           ; Loop while rows remain       
                                                               
; Screen contents (including display attributes)               
; are now copied to buffer.                                    
; Next open window, overwriting the screen portion just saved. 
                                                               
        mov     ax, 0600h           ; Scroll service           
        mov     bh, BYTE PTR attr   ; Fill attribute           
        mov     cx, col1        ; CX = row/col for upper left  
        mov     ch, BYTE PTR row1                              
        mov     dx, col2        ; DX = row/col for lower right 
        mov     dh, BYTE PTR row2                              
        int     10h             ; Blank window area on screen  
        mov     ax, es          ; Return address of allocated  
exit:   ret                     ;   segment                    
                                                               
WinOpen ENDP                                                   
                                                               
                                                               
                  Data Transfer Instructions                   
               1.6.4. XCHG                                     
Exchange                             Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  XCHG dest,src                                         
               Exchanges  the  values   of   the   source   and
            destination operands.                              
 1000011w    mod,reg,r/m      disp (0 or 2)                    
-----------------+---------------------+-----------------------
 XCHG  reg,reg   | xchg   cx,dx        | 88/86 4               
                 | xchg   l,dh         | 286   3               
                 | xchg   al,ah        | 386   3               
-----------------+---------------------+-----------------------
 XCHG  reg,mem   | xchg   [bx],ax      | 88/86 17+EA (W88=25+EA
 XCHG  mem,reg   | xchg   bx,pointer   | 286   5               
                 |                     | 386   5               
-----------------+---------------------+-----------------------
 10010 reg                                                     
---------------------+------------------+----------------------
 XCHG  accum,reg16   | xchg  ax,cx      |  88/86 3             
 XCHG  reg16,accum   | xchg  cx,ax      |  286   3             
                     |                  |  386   3             
---------------------+------------------+----------------------
               1.6.5. IntToAsc                                 
;* IntToAsc - Converts integer to ASCII string.                
;* This procedure is useful only for assembly language,        
;* and is not intended to be C-callable.                       
;*                                                             
;* Shows:   Instructions - cwd     aam     xchg                
;*                                                             
;* Entry:   AX = integer (9999 max)                            
;*                                                             
;* Return:  DX:AX = 4-digit ASCII number                       
IntToAsc PROC                                                  
        cwd                     ; Zero DX register             
        mov     cx, 100         ; Divide AX by 100, yields     
        div     cx              ;   AX=quotient, DX=remainder  
        aam                     ; Make digits unpacked BCD     
        or      ax, '00'        ; Convert to ASCII             
        xchg    ax, dx          ; Do same thing for DX         
        aam                                                    
        or      ax, '00'                                       
        ret                     ; Return DX:AX = ASCII number  
IntToAsc ENDP                                                  
                  Data Transfer Instructions                   
                                                               
                                                               
               1.6.6. LODS/LODSB/LODSW                         
                                                               
                                                               
Load String Operand                  Flags:  O D I T S Z A P C 
                                             ----------------- 
                                                               
Syntax: LODS src                                               
        LODSB                                                  
        LODSW                                                  
                                                               
               Loads a string from memory into the  accumulator
            register. The string to be loaded is the source and
            must be pointed to by DS:SI (even if an operand  is
            given). For  each  source  element  loaded,  SI  is
            adjusted according to the size of the operands  and
            the status of the direction flag. SI  is  increased
            if the direction flag has been cleared with CLD  or
            decreased if the direction flag has been  set  with
            STD.                                               
               If the LODS form of the instruction is used,  an
            operand must be provided to indicate  the  size  of
            the  data  elements  to  be  processed.  A  segment
            override can be given. If LODSB  (bytes)  or  LODSW
            (words) is used,  the  instruction  determines  the
            size of the  data  elements  to  be  processed  and
            whether the element will be loaded  to  AL  or  AX.
            Operands are not allowed with LODSB or LODSW.      
               LODS and its variations are  not  normally  used
            with repeat prefixes, since there is no  reason  to
            repeatedly load memory values to a register.       
                                                               
 1010110w                                                      
----------------------+-------------------+--------------------
 LODS  [segreg:]src   | lods  es:source   | 88/86 12 (W88=16)  
 LODSB                | lodsw             | 286   5            
 LODSW                |                   | 386   5            
----------------------+-------------------+--------------------
                                                               
                                                               
                                                               
               1.6.7. WinClose                                 
                                                               
                                                               
;* WinClose - "Closes" a window previously opened by the WinOpe
;* procedure. See also the WinOpen procedure.                  
;*                                                             
;* Shows:   DOS Function - 49h (Release Memory Block)          
;*          Instructions - lodsw                               
;*          Operators - : (segment override)     SEG           
;*                                                             
;* Uses:    vconfig - Video configuration structure, declared i
;*          the DEMO.INC include file. The structure must first
;*          be initialized by calling the GetVidConfig procedur
;*                                                             
;* Params:  addr - Segment address of buffer that holds screen 
;*                 contents saved in WinOpen procedure         
;*                                                             
;* Return:  None                                               
                                                               
WinClose PROC \                                                
        USES ds di si, \                                       
        addr:WORD                                              
                  Data Transfer Instructions                   
        mov     ds, addr            ; DS:SI points to buffer   
        sub     si, si                                         
        lodsw                                                  
        mov     di, ax              ; DI = video offset of wind
        lodsw                                                  
        mov     bx, ax              ; BX = number of window row
        lodsw                                                  
        mov     cx, ax              ; CX = number of columns   
        mov     ax, SEG vconfig.sgmnt                          
        mov     es, ax              ; Point ES to data segment 
        push    es:vconfig.sgmnt                               
        pop     es                  ; ES = video segment       
        mov     ax, 160             ; Number of video cells/row
loop1:  push    di                  ; Save ptr to start of line
        push    cx                  ;   and number of columns  
        cmp     vconfig.adapter, CGA    ; CGA adapter?         
        jne     @F                  ; No?  Skip video disable  
; Disable CGA video prior to memory move to avoid screen snow. 
; (See the WinOpen and StrWrite procedures for further         
; discussions on CGA snow.)                                    
        call    DisableCGA          ; Yes?  Disable video      
@@:     rep     movsw               ; Copy one row to buffer   
        cmp     vconfig.adapter, CGA                           
        jne     @F                                             
        call    EnableCGA           ; Reenable CGA video       
@@:     pop     cx                  ; Recover number of columns
        pop     di                  ;   and start of line      
        add     di, ax              ; Point to start of next li
        dec     bx                  ; Decrement row counter    
        jnz     loop1               ; Loop while rows remain   
        mov     ah, 49h             ; Request DOS Function 49h 
        mov     es, addr                                       
        int     21h                 ; Release Memory Block     
        ret                                                    
WinClose ENDP                                                  
               1.6.8. STOS/STOSB/STOSW                         
Store String Data                    Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax: STOS dest                                              
        STOSB                                                  
        STOSW                                                  
               Stores the value in the accumulator to a string.
            The string to be filled is the destination and must
            be pointed to by  ES:DI  (even  if  an  operand  is
            given). For  each  source  element  loaded,  DI  is
            adjusted according to the size of the operands  and
            the status of the direction flag. DI  is  increased
            if the direction flag has been cleared with CLD  or
            decreased if the direction flag has been  set  with
            STD.                                               
                  Data Transfer Instructions                   
                                                               
                                                               
               If the STOS form of the instruction is used,  an
            operand must be provided to indicate  the  size  of
            the data  elements  to  be  processed.  No  segment
            override is allowed.  If  STOSB  (bytes)  or  STOSW
            (words) is used,  the  instruction  determines  the
            size of the  data  elements  to  be  processed  and
            whether the element will  be  from  AL  or  AX.  No
            operand is allowed with STOSB or STOSW.            
               STOS and its variations are often used with  the
            REP prefix.  Before  the  repeated  instruction  is
            executed, CX should contain the number of  elements
            to store.                                          
                                                               
 1010101w                                                      
------------------+------------------------+-------------------
 STOS  [ES:]dest  | stos  es:dstring       | 88/86 11 (W88=15) 
 STOSB            | rep    stosw           | 286   3           
 STOSW            | rep    stosb           | 386   4           
------------------+------------------------+-------------------
                                                               
                                                               
                                                               
               1.6.9. LEA                                      
                                                               
                                                               
                                                               
Load Effective Address               Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  LEA reg,mem                                           
                                                               
               Calculates the effective address (offset) of the
            source memory operand and stores  the  result  into
            the destination register.                          
                                                               
 10001101    mod, reg, r/m      disp (2)                       
------------------+-------------------------+------------------
 LEA  reg,mem     | lea   bx,npointer       | 88/86 2+EA       
                  |                         | 286   3          
                  |                         | 386   2          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
               1.6.10. VeriAnsi                                
                                                               
                                                               
;* VeriAnsi - Checks for ANSI driver by writing ANSI sequence  
;* to report cursor position. If report compares with position 
;* returned from GetCurPos procedure,                          
;* then ANSI driver is operating.                              
;*                                                             
;* Shows:   DOS Functions - 06h (Direct Console I/O)           
;*                          0Ch (Flush Input Buffer then Input)
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Short integer, 1 for yes or 0 for no               
                                                               
        .DATA                                                  
        PUBLIC report                                          
report  DB      ESCAPE, '[6n$'  ; ANSI Report Cursor sequence  
        .CODE                                                  
                  Data Transfer Instructions                   
VeriAnsi PROC                                                  
        mov     al, ch          ; Get original row # in AL     
        cbw                     ; AX = row # from GetCurPos    
        inc     ax              ; Add 1 to it                  
        call    IntToAsc        ; Make ASCII digits            
        cmp     ax, bx          ; ANSI and BIOS reports match? 
        jne     e_exit          ; No?  Then ANSI not loaded    
        mov     ax, 0C06h       ; Flush remaining ANSI keys    
        mov     dl, 0FFh        ;   from buffer                
        int     21h                                            
        mov     ax, 1           ; Set 1 for true               
        jmp     SHORT exit      ;   and exit                   
e_exit: sub     ax, ax          ; Set 0 return code if no      
exit:   ret                     ;   ANSI driver installed      
VeriAnsi ENDP                                                  
               1.6.11. LDS/LES                                 
Load Far Pointer                     Flags:  O D I T S Z A P C 
Syntax:  LDS reg,mem                         ----------------- 
               Reads and stores the far  pointer  specified  by
            the source memory operand.  The  pointer's  segment
            value is stored in  the  segment  register  segment
            specified by the instruction name. The offset value
            is  stored  in  the  register  specified   by   the
            destination operand. The LDS and  LES  instructions
            are available on all processors.                   
 11000101     mod, reg, r/m      disp (2)                      
--------------+---------------------+--------------------------
 LDS  reg,mem | lds   si,fpointer   | 88/86 16+EA (88=24+EA)   
              |                     | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
 11000100     mod, reg, r/m      disp (2)                      
--------------+---------------------+--------------------------
 LES  reg,mem | les   di,fpointer   | 88/86 16+EA (88=24+EA)   
              |                     | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
               1.6.12. LoadPtr                                 
;* LoadPtr - Macro to load far address into segment:register   
;* pair, or near address into register.                        
;*                                                             
;* Params:  sgmnt - Segment to be loaded with segment address  
;*          reg - Register to be loaded with offset address    
                  Data Transfer Instructions                   
                                                               
                                                               
;*          ptr - Pointer to address                           
;*                                                             
;* Shows:   Instructions - lds   les                           
;*          Directives - MACRO   IF      IFIDNI   ELSE    ELSEI
;*                       ENDIF   .ERR    %OUT     EXITM   ENDM 
;*          Operators - < >       ;;                           
                                                               
LoadPtr MACRO sgmnt, reg, ptr   ;; Macro definition            
    IF @DataSize                ;; If far pointer, and         
        IFIDNI <sgmnt>, <ds>    ;;   if 1st argument is DS,    
            lds reg, ptr        ;;   load DS:reg with far addre
            EXITM                                              
        ENDIF                                                  
        IFIDNI <sgmnt>, <es>    ;;   or if 1st argument is ES, 
            les reg, ptr        ;;   load ES:reg with far addre
            EXITM                                              
        ENDIF                                                  
        .ERR                    ;; Generate error if not DS or 
        %OUT 1st macro argument must be DS or ES               
                                                               
    ELSE                        ;; If near pointer,            
        IFIDNI <sgmnt>, <es>    ;;   and if segment is ES,     
            push ds             ;;   ensure ES points to       
            pop  es             ;;   same segment as DS        
        ENDIF                                                  
        mov reg, ptr        ;; Then load reg with near address 
    ENDIF                                                      
ENDM                                                           
                                                               
                                                               
                                                               
               1.6.13. XLAT/XLATB                              
                                                               
                                                               
Translate                            Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  XLAT [table]                                          
                                                               
               Translates a value from  one  coding  system  to
            another by looking up the value to be translated in
            a table stored in memory. Before the instruction is
            executed, BX should point to a table in memory  and
            AL should contain  the  unsigned  position  of  the
            value to be translated from the  table.  After  the
            instruction, AL will contain the table  value  with
            the specified position. No operand is required, but
            one can be given in  order  to  specify  a  segment
            override. DS is assumed unless a  segment  override
            is given. XLATB is  recognized  as  a  synonym  for
            XLAT.                                              
                                                               
 11010111                                                      
-------------------------+----------------------+--------------
 XLAT  [[segreg]:mem]    | xlat                 | 88/86 11     
 XLATB  [[segreg]:mem]   | xlatb  es:table      | 286   5      
                         |                      | 386   5      
-------------------------+----------------------+--------------
                                                               
                                                               
                                                               
                                                               
                                                               
                  Data Transfer Instructions                   
               1.6.14. BinToHex                                
;* BinToHex - Converts binary word to 6-byte hexadecimal       
;*  number in ASCIIZ string.                                   
;* String is right-justified and includes "h" radix.           
;*                                                             
;* Shows:   Instruction - xlat                                 
;*                                                             
;* Params:  num - Number to convert to hex string              
;*          str - Pointer to 6-byte string                     
;*                                                             
;* Return:  None                                               
        .DATA                                                  
hex     DB      '0123456789ABCDEF'      ; String of hex numbers
        .CODE                                                  
BinToHex PROC \                                                
        USES di, \                                             
        num:WORD, str:PTR BYTE                                 
        LoadPtr es, di, str     ; Point ES:DI to 6-byte string 
        mov     bx, OFFSET hex  ; Point DS:BX to hex numbers   
        mov     ax, num         ; Number in AX                 
        mov     cx, 2           ; Loop twice for two bytes     
loop1:  xchg    ah, al          ; Switch bytes                 
        push    ax              ; Save number                  
        shr     al, 1           ; Shift high nibble to low     
        shr     al, 1                                          
        shr     al, 1                                          
        shr     al, 1                                          
        xlat                ; Get equivalent ASCII number in AL
        stosb               ; Copy to 6-byte string, increment 
        pop     ax          ; Recover number                   
        push    ax          ; Save it again                    
        and     al, 00001111b   ; Mask out high nibble         
        xlat                ; Get equivalent ASCII number in AL
        stosb               ; Copy to 6-byte string, increment 
        pop     ax          ; Recover number                   
        loop    loop1       ; Do next byte                     
        mov     ax, 'h'     ; Put null, 'h' radix in AX        
        stosw               ; Copy to last two bytes in string 
        ret                                                    
BinToHex ENDP                                                  
                                                               
   1.7. Flag-Setting Instructions                              
Mnemonic                                                       
            Name                                               
CLC                                                            
            Clear Carry Flag                                   
CLD                                                            
            Clear Direction Flag                               
CLI                                                            
            Clear Interrupt Flag (disable maskable  interrupts)
                  Flag-Setting Instructions                    
                                                               
                                                               
CMC                                                            
            Complement Carry Flag                              
STC                                                            
            Set Carry Flag                                     
STD                                                            
            Set Direction Flag                                 
STI                                                            
            Set Interrupt Flag (recognize interrupts again)    
POPF                                                           
            Pop Flags (pop value at top  of  stack  into  flags
            register)                                          
PUSHF                                                          
            Push Flags (push value  of  entire  flags  register
            onto stack)                                        
LAHF                                                           
            Load Flags into AH Register                        
SAHF                                                           
            Store AH into Flags (does not include all flags)   
                                                               
                                                               
                                                               
               1.7.1. CLC                                      
                                                               
                                                               
Clear Carry Flag                     Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  CLC                                                 0 
                                                               
               Clears the carry flag.                          
                                                               
 11111000                                                      
-----------------+-------------------------+-------------------
 CLC             | clc                     | 88/86 2           
                 |                         | 286   2           
                 |                         | 386   2           
-----------------+-------------------------+-------------------
                                                               
                                                               
                                                               
               1.7.2. CopyFile                                 
                                                               
                                                               
;* CopyFile - Copies a file from a specified directory to      
;* another. Allows two different copy methods. See the OpenFile
;* CloseFile, ReadFile, and WriteFile procedures for specific  
;* examples on opening, closing, reading from,                 
;* and writing to files.                                       
;*                                                             
;* Shows:   DOS Functions - 3Ch (Create File)                  
;*                          5Bh (Create New File)              
;*          Instruction - clc                                  
;*                                                             
;* Params:  imode  - 0 = Create new target file or             
;*                        overwrite existing file              
;*                   1 = Abort and return error code if target 
;*                        file already exists (only for DOS    
;*                        versions 3.0 and higher)             
;*          fspec1 - Pointer to ASCIIZ source file specificatio
;*          fspec2 - Pointer to ASCIIZ target file specificatio
;*                                                             
;* Return:  Short integer with error code                      
;*          0 if successful                                    
                                                               
                  Flag-Setting Instructions                    
;*          1 if error                                         
        .DATA                                                  
buffer  DB      BUFFER_SIZE DUP(?)  ; Buffer for diskette read 
        .CODE                                                  
        EXTRN GetVer:PROC                                      
CopyFile PROC \                                                
        USES ds si di, \                                       
        imode:WORD, fspec1:PTR BYTE, fspec2:PTR BYTE           
        LOCAL eof_flag:BYTE                                    
; Open source file for read only                               
        LoadPtr ds, dx, fspec1  ; Point DS:DX to source file   
        mov     ax, 3D00h   ; AH = function #, AL = access code
        int     21h         ; Open File (for read only)        
        jc      e_exit                                         
        mov     si, ax          ; SI = file handle for source  
; Open target file according to copy mode                      
        LoadPtr ds, dx, fspec2  ; Point DS:DX to target file   
        cmp     imode, 1        ; Determine DOS function       
        je      check           ; Imode = 1?                   
        mov     ah, 3Ch         ; No?  Request Create File     
        jmp     SHORT set       ;   (destroy existing)         
check:  call    GetVer          ; Yes?  First check DOS version
        cmp     ax, 300         ; 3.0 or higher?               
        jb      close           ; No?  Abort with error code   
        mov     ah, 5Bh         ; Request Create New File      
set:    sub     cx, cx          ; Normal attribute for target  
        int     21h             ; DOS function for target file 
        jc      close           ; If open error, abort         
        mov     di, ax          ; DI = file handle for target  
; Both files successfully opened.                              
; Now read from source and copy to target.                     
        mov     ax, @data                                      
        mov     ds, ax              ; DS:DX = buffer. Read/writ
        mov     dx, OFFSET buffer   ;   to and from here.      
        mov     eof_flag, 0         ; Initialize end-of-file fl
loop1:  mov     bx, si              ; Handle for source file   
        mov     cx, BUFFER_SIZE ; CX = number of bytes to read 
        mov     ah, 3Fh         ; Request DOS read             
        int     21h             ; Read from File               
        jc      close           ; If error, exit               
        cmp     ax, cx          ; All bytes read successfully? 
        je      @F              ; Yes?  Continue               
        inc     eof_flag        ; No?  Raise flag              
@@:     mov     bx, di          ; Handle for target file       
        mov     cx, ax          ; Write number of bytes read   
        mov     ah, 40h         ; Request DOS write            
        int     21h         ; Write from buffer to target file 
        jc      close           ; If error, exit               
        cmp     eof_flag, 0     ; Finished?                    
        je      loop1           ; No?  Loop to read next block 
        clc                     ; Yes?  Clear CY to indicate   
                  Flag-Setting Instructions                    
                                                               
                                                               
                                ;   success                    
close:  pushf                   ; Preserve flags while closing 
        mov     bx, di          ; Handle for target file       
        mov     ah, 3Eh         ; Request DOS Function 3Eh     
        int     21h             ; Close File                   
        sub     ax, ax          ; Clear error code             
        popf                    ; Recover flags                
        jnc     exit            ; If successful, exit          
                                                               
e_exit: mov     ax, 1           ; Else set error code          
exit:   ret                                                    
                                                               
CopyFile ENDP                                                  
                                                               
                                                               
                                                               
               1.7.3. CLD                                      
                                                               
                                                               
                                                               
Clear Direction Flag                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  CLD                                   0               
                                                               
               Clears the direction flag. All subsequent string
            instructions will process up (from low addresses to
            high  addresses),  by  increasing  the  appropriate
            index registers.                                   
                                                               
 11111100                                                      
-----------------+--------------------------+------------------
 CLD             | cld                      | 88/86 2          
                 |                          | 286   2          
                 |                          | 386   2          
-----------------+--------------------------+------------------
                                                               
                                                               
                                                               
               1.7.4. StrFindChar                              
                                                               
                                                               
                                                               
;* StrFindChar - Finds first occurence of character in given   
;* ASCIIZ string, searching either from beginning or end of    
;* string. See StrWrite, WinOpen, WinClose, and StrCompare     
;* procedures for other examples of string instructions.       
;*                                                             
;* Shows:   Instructions - repne     scasb    cld     std      
;*                                                             
;* Params:  ichar - Character to search for                    
;*          str - Pointer to ASCIIZ string in which to search  
;*          direct - Direction flag:                           
;*                   0 = search from start to end              
;*                   1 = search from end to start              
;*                                                             
;* Return:  Null pointer if character not found, else pointer  
;*           to string where character first encountered       
                                                               
StrFindChar PROC \                                             
        USES ds di si, \                                       
        ichar:BYTE, str:PTR BYTE, direct:WORD                  
                                                               
                  Flag-Setting Instructions                    
        LoadPtr es, di, str     ; ES:DI points to string       
        LoadPtr ds, si, str     ;   as does DS:SI              
        mov     cx, -1          ; Set scan counter to maximum  
        mov     bx, cx          ; BX = max string tail         
        cld                     ; Assume head-to-tail search   
        cmp     direct, 0       ; Assumption correct?          
        je      loop1           ; Yes?  Continue               
        mov     bx, di          ; No?  Set BX to byte before   
        dec     bx              ;   string head and scan       
        sub     al, al          ;   string for null terminator 
        push    cx              ;   to find string tail        
        repne   scasb                                          
        pop     cx              ; Recover scan counter         
        dec     di              ; Backup pointer to last       
        dec     di              ;   character in string and    
        mov     si, di          ;   begin search from there    
        std                     ; Set direction flag           
loop1:  lodsb                   ; Get first char from string   
        cmp     si, bx          ; At head limit?               
        je      xmatch          ; Yes?  Then no match          
        or      al, al          ; At tail limit?               
        je      xmatch          ; Yes?  Then no match          
        cmp     al, ichar       ; Character match?             
        je      match           ; Yes?  Then exit              
        loop    loop1           ; No?  Resume search           
xmatch: sub     ax, ax          ; Set null pointer if no match 
        sub     dx, dx                                         
        jmp     SHORT exit                                     
match:  mov     ax, si          ; If match, point to first     
        dec     ax              ;   occurence                  
        cmp     direct, 0       ; Head-to-tail search?         
        je      exit            ; Yes?  Then exit              
        inc     ax              ; No?  Then adjust pointer     
        inc     ax              ;   forward                    
        mov     dx, ds          ; Pointer segment              
exit:   ret                                                    
StrFindChar ENDP                                               
               1.7.5. CLI                                      
Clear Interrupt Flag                 Flags:  O D I T S Z A P C 
Syntax:  CLI                                 ----------------- 
                                                 0             
               Clears the interrupt flag.  When  the  interrupt
            flag  is  cleared,  maskable  interrupts  are   not
            recognized until the flag is set again with the STI
            instruction.                                       
 11111010                                                      
-----------------+-------------------------+-------------------
 CLI             | cli                     | 88/86 2           
                 |                         | 286   3           
                 |                         | 386   3           
-----------------+-------------------------+-------------------
                  Flag-Setting Instructions                    
                                                               
                                                               
               1.7.6. DisableCGA                               
                                                               
                                                               
;* DisableCGA - Disables CGA video by reprogramming            
;* the control register.                                       
;*                                                             
;* Shows:   Instructions - cli     sti     loopz     loopnz    
;*                                                             
;* Uses:    vconfig - Video configuration structure, declared  
;*          in the DEMO.INC include file. The structure must   
;*          first be initialized by calling the GetVidConfig   
;*          procedure.                                         
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  None                                               
                                                               
DisableCGA PROC \                                              
        USES ax cx dx                   ; Preserve registers   
                                                               
        mov     cx, -1          ; Set maximum loop count       
        mov     dx, 03DAh       ; Address of status register   
wait1:  in      al, dx          ; Get video status             
        test    al, 8           ; Vertical retrace active?     
        loopnz  wait1           ; Yes?  Wait for end/timeout   
        cli                     ; Disallow interruptions       
        mov     cx, -1          ; Reset loop count             
wait2:  in      al, dx          ; Get video status             
        test    al, 8           ; Start of vertical retrace?   
        loopz   wait2           ; No?  Wait for start/timeout  
        sub     dx, 2           ; DX = address of control reg  
        mov     al, 1           ; Value to disable CGA video   
        out     dx, al          ; Disable video                
        sti                     ; Reenable interrupts          
        ret                                                    
                                                               
DisableCGA ENDP                                                
                                                               
                                                               
                                                               
               1.7.7. CMC                                      
                                                               
                                                               
Complement Carry Flag                Flags:  O D I T S Z A P C 
Syntax:  CMC                                 ----------------- 
                                                             * 
                                                               
               Complements (toggles) the carry flag.           
                                                               
 11110101                                                      
----------------+--------------------------+-------------------
 CMC            | cmc                      | 88/86 2           
                |                          | 286   2           
                |                          | 386   2           
----------------+--------------------------+-------------------
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                  Flag-Setting Instructions                    
               1.7.8. STC                                      
Set Carry Flag                                                 
                                     Flags:  O D I T S Z A P C 
Syntax:  STC                                 ----------------- 
                                                             1 
               Sets the carry flag.                            
 11111001                                                      
-----------------+-------------------------+-------------------
 STC             | stc                     | 88/86 2           
                 |                         | 286   2           
                 |                         | 386   2           
-----------------+-------------------------+-------------------
               1.7.9. STD                                      
Set Direction Flag                   Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  STD                                   1               
               Sets the direction flag. All  subsequent  string
            instructions will process down (from high addresses
            to low addresses).                                 
 11111101                                                      
-----------------+-------------------------+-------------------
 STD             | std                     | 88/86 2           
                 |                         | 286   2           
                 |                         | 386   2           
-----------------+-------------------------+-------------------
               1.7.10. STI                                     
Set Interrupt Flag                   Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  STI                                     1             
               Sets the interrupt flag. When the interrupt flag
            is set,  maskable  interrupts  are  recognized.  If
            interrupts  were  disabled  by   a   previous   CLI
            instruction,  pending  interrupts   will   not   be
            executed immediately; they will be  executed  after
            the instruction following STI.                     
 11111011                                                      
-----------------+-------------------------+-------------------
 STI             | sti                     | 88/86 2           
                 |                         | 286   2           
                 |                         | 386   3           
-----------------+-------------------------+-------------------
                  Flag-Setting Instructions                    
                                                               
                                                               
               1.7.11. POPF                                    
                                                               
                                                               
Pop Flags                            Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             * * * * * * * * * 
Syntax:  POPF                                                  
                                                               
               Pops the value on the top of the stack into  the
            flags register. POPF always pops  into  the  16-bit
            flags register.                                    
                                                               
 10011101                                                      
------------------+-------------------------+------------------
 POPF             | popf                    | 88/86 8 (88=12)  
                  |                         | 286   5          
                  |                         | 386   5          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
               1.7.12. PUSHF                                   
                                                               
                                                               
Push Flags                           Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  PUSHF                                                 
                                                               
               Pushes the flags register onto the stack.  PUSHF
            always pushes the 16-bit flags register.           
                                                               
 10011100                                                      
------------------+-------------------------+------------------
 PUSHF            | pushf                   | 88/86 10 (88=14) 
                  |                         | 286   3          
                  |                         | 386   4          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
               1.7.13. FindFirst                               
                                                               
                                                               
                                                               
;* FindFirst - Finds first entry in given directory            
;* matching specification.                                     
;*                                                             
;* Shows:   DOS Function - 4Eh (Find First File)               
;*          Keywords - USES                                    
;*          Instructions - ret     pushf    popf               
;*                                                             
;* Params:  attr - Attribute code                              
;*           (see header comments for CreateFile)              
;*          fspec - Pointer to ASCIIZ file specification       
;*          finfo - Pointer to 43-byte buffer to receive       
;*                  data from matched entry                    
;*                                                             
;* Return:  Short integer with error code                      
;*          0 if successful                                    
;*          1 if no match found                                
                                                               
        .DATA                                                  
                  Flag-Setting Instructions                    
old_dta DD      WORD PTR ?     ; Storage for old DTA address   
        .CODE                                                  
FindFirst PROC \                                               
        USES ds, \                                             
        attr:WORD, fspec:PTR BYTE, finfo:PTR BYTE              
        push    ds                      ; Pass far pointer     
        mov     ax, OFFSET @data:old_dta;   to old_dta         
        push    ax                                             
        call    GetDTA          ; Get current DTA address      
        add     sp, 4           ; Adjust stack                 
        mov     cx, attr        ; Load CX with file attribute  
        LoadPtr ds, dx, finfo   ; DS:DX points to 43-byte buffe
        push    ds              ; Make this new DTA            
        push    dx                                             
        call    SetDTA          ; Set 43-byte buffer as DTA    
        add     sp, 4           ; Adjust stack                 
        LoadPtr ds, dx, fspec   ; Point DS:DX to file spec     
        mov     ah, 4Eh         ; AH = function number         
        int     21h             ; Find First File              
        pushf                           ; Preserve flags       
        push    WORD PTR @data:old_dta[2] ; Pass far pointer to
        push    WORD PTR @data:old_dta[0] ;   SetDTA procedure 
        call    SetDTA          ; Restore DTA address to orig  
        sub     ax, ax          ; Set error code               
        add     sp, 4           ; Adjust stack                 
        popf                    ; Recover flags                
        jnc     exit            ; Exit if successful match     
        inc     ax              ; Else set error code to 1     
exit:   ret                                                    
FindFirst ENDP                                                 
               1.7.14. LAHF                                    
Load Flags into AH Register          Flags:  O D I T S Z A P C 
Syntax:  LAHF                                ----------------- 
               Transfers bits 0 to 7 of the flags  register  to
            AH. This  includes  the  carry,  parity,  auxiliary
            carry, zero, and sign  flags,  but  not  the  trap,
            interrupt, direction, or overflow flags.           
 10011111                                                      
------------------+-------------------------+------------------
 LAHF             | lahf                    | 88/86 4          
                  |                         | 286   2          
                  |                         | 386   2          
------------------+-------------------------+------------------
                  Flag-Setting Instructions                    
                                                               
                                                               
               1.7.15. SAHF                                    
                                                               
                                                               
Store AH into Flags                  Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  SAHF                                        * * * * * 
                                                               
                                                               
               Transfers AH into bits  0  to  7  of  the  flags
            register.  This   includes   the   carry,   parity,
            auxiliary carry, zero, and sign flags, but not  the
            trap, interrupt, direction, or overflow flags.     
                                                               
 10011110                                                      
-----------------+-------------------------+-------------------
 SAHF            | sahf                    | 88/86 4           
                 |                         | 286   2           
                 |                         | 386   3           
-----------------+-------------------------+-------------------
                                                               
                                                               
                                                               
               1.7.16. Quadratic                               
                                                               
                                                               
;* Quadratic - Solves for the roots of                         
;*  a quadratic equation of form                               
;*                        A*x*x + B*x + C = 0                  
;* using floating-point instructions. This procedure requires  
;* either a math coprocessor or emulation code. If executing   
;* within the QuickAssembler environment, emulation is         
;* automatically provided if a coprocessor is not installed.   
;* If executing from the QCL command line, the /FPi switch must
;* be specified if a coprocessor is not installed. For example,
;* to create the MATHDEMO.EXE example program with floating-poi
;* emulation, enter the following line:                        
;*                 QCL /Cx mathdemo.c /FPi math.asm common.asm 
;*                                                             
;* Shows: Instructions - sahf    fld1    fld    fadd    fmul   
;*                       fxch    fsubr   fchs   fsubp   fstp   
;*                       fst     fdivr   fwait  ftst           
;*                                                             
;* Params:  a - Constant for 2nd-order term                    
;*          b - Constant for 1st-order term                    
;*          c - Equation constant                              
;*          r1 - Pointer to 1st root                           
;*          r2 - Pointer to 2nd root                           
;*                                                             
;* Return:  Short integer with return code                     
;*          0 if both roots found                              
;*          1 if single root (placed in r1)                    
;*          2 if indeterminate                                 
                                                               
Quadratic PROC \                                               
        USES ds di si, \                                       
        a:DWORD, b:DWORD, c:DWORD, r1:PTR DWORD, r2:PTR DWORD  
                                                               
        LOCAL status:WORD       ; Intermediate status          
                                                               
        LoadPtr es, di, r1      ; ES:DI points to 1st root     
        LoadPtr ds, si, r2      ; DS:SI points to 2nd root     
        sub     bx, bx          ; Clear error code             
                  Flag-Setting Instructions                    
        fld1                    ; Load top of stack with 1     
        fadd    st, st          ; Double it to make 2          
        fld     st              ; Copy to next register        
        fmul    a               ; ST register = 2a             
        ftst                    ; Test current ST value        
        fstsw   status          ; Copy status to local word    
        fwait                   ; Ensure coprocessor is done   
        mov     ax, status      ; Copy status into AX          
        sahf                    ; Load flag register           
        jnz     @F          ; If C3 set, a = 0, in which case  
                            ;   solution is x = -c / b         
        fld     b               ; Load b parameter             
        ftst                    ; Test current ST value        
        fstsw   status          ; Copy status to local word    
        fwait                   ; Ensure coprocessor is done   
        mov     ax, status      ; Copy status into AX          
        sahf                    ; Load flag register           
        jz      exit2       ; If C3 set, b = 0, so don't divide
        fld     st              ; Copy b to next register      
        fld     c               ; Load C parameter             
        fchs                    ; Reverse sign                 
        fxch                    ; Exchange ST and ST(1)        
        fdiv                        ; Divide c by b            
        fst     DWORD PTR es:[di]   ; Copy result              
        jmp     SHORT exit1         ; Return with code = 1     
@@:     fmul    st(1), st       ; ST(1) register = 4a          
        fxch                    ; Exchange ST and ST(1)        
        fmul    c               ; ST register = 4ac            
        ftst                    ; Test current ST value        
        fstsw   status          ; Copy status to local word    
        fwait                   ; Ensure coprocessor is done   
        mov     ax, status      ; Copy status into AX          
        sahf                    ; Load flag register           
        jp      exit2           ; If C2 set, 4*a*c is infinite 
        fld     b               ; Else load b parameter        
        fmul    st, st          ; Square it; ST register = b*b 
        fsubr                   ; ST register = b*b - 4*a*c    
        ftst                    ; Test current ST value        
        fstsw   status          ; Copy status to local word    
        fwait                   ; Ensure coprocessor is done   
        mov     ax, status      ; Copy status into AX          
        sahf                    ; Load flag register           
        jc      exit2           ; If C0 set, b*b < 4ac         
        jnz     @F              ; If C3 set, b*b = 4ac, in whic
        inc     bx              ;   case only 1 root so set fla
@@:     fsqrt                   ; Get square root              
        fld     b               ; Load b parameter             
        fchs                    ; Reverse sign                 
        fxch                    ; Exchange ST and ST1          
        fld     st              ; Copy square root to next reg 
        fadd    st, st(2)       ; ST = -b + sqrt(b*b - 4*a*c)  
        fxch                    ; Exchange ST and ST1          
        fsubp   st(2), st       ; ST = -b - sqrt(b*b - 4*a*c)  
        fdiv    st, st(2)           ; Divide 1st dividend by 2*
        fstp    WORD PTR es:[di]    ; Copy result, pop stack   
        fdivr                       ; Divide 2nd dividend by 2*
        fstp    WORD PTR ds:[si]    ; Copy result, pop stack   
        jmp     SHORT exit          ; Return with code         
                  Flag-Setting Instructions                    
                                                               
                                                               
                                                               
exit2:  inc     bx          ; Error code = 2 for indeterminancy
exit1:  inc     bx          ; Error code = 1 for single root   
exit:   mov     ax, bx                                         
        ret                                                    
                                                               
Quadratic ENDP                                                 
                                                               
                                                               
                                                               
                                                               
   1.8. Logic Instructions                                     
                                                               
                                                               
   The logic operations all perform bitwise operations  between
each bit in the source operand and the corresponding bit in the
destination operand.                                           
                                                               
                                                               
Mnemonic                                                       
            Name                                               
AND                                                            
            And                                                
OR                                                             
            Inclusive OR                                       
XOR                                                            
            Exclusive OR                                       
NOT                                                            
            One's Complement Negation                          
                                                               
                                                               
                                                               
   1.8.1. AND                                                  
                                                               
                                                               
Logical AND                          Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AND dest,src                        0       * * ? * 0 
                                                               
   Performs a bitwise logical AND on the source and destination
operands and stores the result in the destination operand.  For
each bit position in the operands, if both bits are  set,  then
the corresponding bit of the  result  is  set.  Otherwise,  the
corresponding bit of the result is cleared.                    
                                                               
 001000dw     mod,reg,r/m       disp (0 or 2)                  
---------------+------------------------+----------------------
 AND  reg,reg  | and   dx,bx            | 88/86 3              
               |                        | 286   2              
               |                        | 386   2              
---------------+------------------------+----------------------
 AND  mem,reg  | and   bitmask,bx       | 88/86 16+EA (W88=24+E
               | and   [bp+2],dx        | 286   7              
               |                        | 386   7              
---------------+------------------------+----------------------
 AND  reg,mem  | and   bx,masker        | 88/86 9+EA (W88=13+EA
               | and   dx,marray[bx+di] | 286   7              
               |                        | 386   6              
---------------+------------------------+----------------------
                                                               
                      Logic Instructions                       
 100000sw     mod,100,r/m       disp (0 or 2)     data (1 or 2)
---------------+---------------------+-------------------------
 AND  reg,immed| and   dx,0F7h       | 88/86 4                 
               |                     | 286   3                 
               |                     | 386   2                 
---------------+---------------------+-------------------------
 AND  mem,immed| and   masker,1001b  | 88/86 17+EA (W88=23+EA) 
               |                     | 286   7                 
               |                     | 386   7                 
---------------+---------------------+-------------------------
 0010010w     data (1 or 2)                                    
-------------------+-------------------------+-----------------
 AND  accum,immed  | and   ax,0B6h           | 88/86     4     
                   |                         | 286       3     
                   |                         | 386       2     
-------------------+-------------------------+-----------------
   1.8.2. Colors                                               
;* Colors - Alters screen colors within a                      
;* specified area by using bit or move operations              
;* on display attribute bytes in video memory.                 
;*                                                             
;* Shows:   Instructions - not   rol   ror   and   xor   or    
;*                                                             
;* Params:  logic - Code number, 0 = NOT 2 = ROR 4 = XOR 6 = MO
;*                               1 = ROL 3 = AND 5 = OR        
;*          attr - Attribute mask                              
;*          row1 - Row at top of window                        
;*          col1 - Column at left edge of window               
;*          row2 - Row at bottom of window                     
;*          col2 - Column at right edge of window              
;*                                                             
;* Return:  None                                               
Colors  PROC \                                                 
        USES ds si, \                                          
logic:WORD, attr:WORD, row1:WORD, col1:WORD, row2:WORD, col2:WO
        GetVidOffset row1, col1     ; Get offset in video segme
        inc     ax                                             
        mov     si, ax              ; SI = offset for 1st attr 
        mov     bx, row2                                       
        sub     bx, row1                                       
        inc     bx                  ; BX = number of window row
        mov     cx, col2                                       
        sub     cx, col1                                       
        inc     cx                  ; CX = number of columns   
        mov     ds, vconfig.sgmnt   ; DS = video segment       
        mov     ax, attr            ; AL = mask for and, xor, a
loop1:  push    si                  ; Save ptr to start of line
        push    cx                  ;   and number of columns  
        cmp     vconfig.adapter, CGA    ; CGA adapter?         
        jne     @F                  ; No?  Skip video disable  
; Disable CGA video prior to memory access to avoid screen     
; snow. (See the WinOpen and StrWrite procedures for further   
; discussions on CGA snow.)                                    
                      Logic Instructions                       
                                                               
                                                               
                                                               
        call    DisableCGA          ; Yes?  Disable video      
@@:     cmp     logic, 1            ; Rotate left?             
        jl      c_not               ; If less, do NOT          
        je      c_rol               ; If equal, do ROL         
        cmp     logic, 3            ; And?                     
        jl      c_ror               ; If less, do ROR          
        je      c_and               ; If equal, do AND         
        cmp     logic, 5            ; Or?                      
        jl      c_xor               ; If less, do XOR          
        je      c_or                ; If equal, do OR          
                                    ; Otherwise, do MOV        
c_mov:  mov     BYTE PTR [si], al   ; MOV attr parameter       
        add     si, 2               ;   into attribute byte    
        loop    c_mov                                          
        jmp     SHORT c_done                                   
c_or:   or      BYTE PTR [si], al   ; OR with attr parameter   
        add     si, 2                                          
        loop    c_or                                           
        jmp     SHORT c_done                                   
c_xor:  xor     BYTE PTR [si], al   ; XOR with attr parameter  
        add     si, 2                                          
        loop    c_xor                                          
        jmp     SHORT c_done                                   
c_and:  and     BYTE PTR [si], al   ; AND with attr parameter  
        add     si, 2                                          
        loop    c_and                                          
        jmp     SHORT c_done                                   
c_ror:  ror     BYTE PTR [si], 1    ; Rotate right 1 bit       
        add     si, 2                                          
        loop    c_ror                                          
        jmp     SHORT c_done                                   
c_rol:  rol     BYTE PTR [si], 1    ; Rotate left 1 bit        
        add     si, 2                                          
        loop    c_rol                                          
        jmp     SHORT c_done                                   
c_not:  not     BYTE PTR [si]       ; Flip bits                
        add     si, 2                                          
        loop    c_not                                          
                                                               
c_done: cmp     vconfig.adapter, CGA                           
        jne     @F                                             
        call    EnableCGA   ; Reenable CGA video               
@@:     pop     cx          ; Recover number of columns        
        pop     si          ; Recover offset for start of line 
        add     si, 160     ; Point to start of next line      
        dec     bx          ; Decrement row counter            
        jnz     loop1       ; Loop while rows remain           
        ret                 ; Exit when all lines complete     
                                                               
Colors  ENDP                                                   
                                                               
                                                               
                                                               
   1.8.3. OR                                                   
                                                               
                                                               
Inclusive OR                         Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             0       * * ? * 0 
Syntax:  OR dest,src                                           
                                                               
                      Logic Instructions                       
   Performs a bitwise logical OR on the source and  destination
operands and stores the result to the destination operand.  For
each bit position in the operands, if either or both  bits  are
set, the corresponding bit of the result it set. Otherwise, the
corresponding bit of the result is cleared.                    
 000010dw    mod, reg, r/m      disp (0 or 2)                  
--------------+---------------------+--------------------------
 OR  reg,reg  | or    ax,dx         | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 OR  mem,reg  | or    [bp+6],cx     | 88/86 16+EA (W88=24+EA)  
              | or    bits,dx       | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
 OR  reg,mem  | or    bx,masker     | 88/86 9+EA (W88=13+EA)   
              | or    dx,color[di]  | 286   7                  
              |                     | 386   6                  
--------------+---------------------+--------------------------
 100000sw    mod,001, r/m       disp (0 or 2)     data (1 or 2)
--------------+---------------------+--------------------------
 OR  reg,immed| or    dx,110110b    | 88/86 4                  
              |                     | 286   3                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 OR  mem,immed| or    flag_rec,8    | 88/86 (b=17,w=25)+EA     
              |                     | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
 0000110w    data (1 or 2)                                     
------------------+-------------------------+------------------
 OR  accum,immed  | or    ax,40h            | 88/86 4          
                  |                         | 286   3          
                  |                         | 386   2          
------------------+-------------------------+------------------
   1.8.4. XOR                                                  
Exclusive OR                         Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  XOR dest,src                        0       * * ? * 0 
   Performs  a  bitwise  exclusive  OR  on   the   source   and
destination operands and stores the result to the  destination.
For each bit position in the operands, if both bits are set  or
if both bits are cleared, the corresponding bit of  the  result
is cleared. Otherwise, the corresponding bit of the  result  is
set.                                                           
                      Logic Instructions                       
                                                               
                                                               
                                                               
 001100dw    mod,reg,r/m      disp (0 or 2)                    
-------------+---------------------+---------------------------
 XOR  reg,reg| xor    cx,bx        | 88/86 3                   
             | xor    ah,al        | 286   2                   
             |                     | 386   2                   
-------------+---------------------+---------------------------
 XOR  mem,reg| xor    [bp+10],cx   | 88/86 16+EA (W88=24+EA)   
             | xor    masked,bx    | 286   7                   
             |                     | 386   6                   
-------------+---------------------+---------------------------
 XOR  reg,mem| xor    cx,flags     | 88/86 9+EA (W88=13+EA)    
             | xor  bl,bitarray[di]| 286   7                   
             |                     | 386   7                   
-------------+---------------------+---------------------------
 100000sw    mod,110,r/m      disp (0 or 2)     data (1 or 2)  
-----------------+-------------------------+-------------------
 XOR  reg,immed  | xor    bx,10h           | 88/86 4           
                 | xor    bl,1             | 286   3           
                 |                         | 386   2           
-----------------+-------------------------+-------------------
 XOR  mem,immed  | xor    Boolean,1        | 88/86 17+EA       
                 |                         | (W88=25+EA)       
                 | xor    switches[bx],101b| 286   7           
                 |                         | 386   7           
-----------------+-------------------------+-------------------
 0011010w    data (1 or 2)                                     
---------------------+---------------------+-------------------
 XOR  accum,immed    | xor    ax,01010101b | 88/86 4           
                     |                     | 286   3           
                     |                     | 386   2           
---------------------+---------------------+-------------------
                                                               
                                                               
                                                               
   1.8.5. NOT                                                  
                                                               
                                                               
One's Complement Negation            Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  NOT dest                                              
                                                               
   Toggles each bit of the operand by  clearing  set  bits  and
setting cleared bits.                                          
                                                               
 1111011w    mod, 010,r/m      disp (0 or 2)                   
--------------+---------------------+--------------------------
 NOT  reg     | not   ax            | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 NOT  mem     | not   masker        | 88/86 16+EA (W88=24+EA)  
              |                     | 286   7                  
              |                     | 386   6                  
--------------+---------------------+--------------------------
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                    Port I/O Instructions                      
   1.9. Port I/O Instructions                                  
Mnemonic                                                       
            Name                                               
IN                                                             
            Input from Port                                    
INS                                                            
            Input from Port to String (80186/286/386 Only)     
OUT                                                            
            Output to Port                                     
OUTS                                                           
            Output String to Port (80186/286/386 Only)         
   1.9.1. IN                                                   
Input from Port                      Flags:  O D I T S Z A P C 
Syntax:  IN accumulator,port                 ----------------- 
   Transfers a byte or word from  a  port  to  the  accumulator
register. The port address is specified by the source  operand,
which can be DX or an 8-bit constant.  Constants  can  only  be
used for port numbers less than 255; use  DX  for  higher  port
numbers.                                                       
 1110010w       data (1)                                       
------------------+-------------------------+------------------
 IN  accum,immed  | in    ax,60h            | 88/86 10 (W88=14)
                  |                         | 286   5          
                  |                         | 386   12         
------------------+-------------------------+------------------
 1110110w                                                      
------------------+-------------------------+------------------
 IN  accum,DX     | in    ax,dx             | 88/86 8 (W88=12) 
                  | in    al,dx             | 286   5          
                  |                         | 386   13         
------------------+-------------------------+------------------
   1.9.2. Sound                                                
                    Port I/O Instructions                      
                                                               
                                                               
;* Sound - Sounds speaker with specified frequency and duration
;*                                                             
;* Shows:   Instructions - in     out                          
;*                                                             
;* Params:  freq - Desired frequency of sound in Hertz         
;*          duration - Desired duration in clocks, where       
;*                     18 clocks = approx 1 second             
;*                                                             
;* Return:  None                                               
                                                               
Sound   PROC \                                                 
        freq:WORD, duration:WORD                               
                                                               
        mov     al, 0B6h            ; Initialize channel 2 of  
        out     43h, al             ;   timer chip             
        mov     dx, 12h             ; Divide 1,193,182 Hertz   
        mov     ax, 34DEh           ;   (clock frequency) by   
        div     freq                ;   desired frequency      
                                    ; Result is timer clock cou
        out     42h, al             ; Low byte of count to time
        mov     al, ah                                         
        out     42h, al             ; High byte of count to tim
        in      al, 61h             ; Read value from port 61h 
        or      al, 3               ; Set first two bits       
        out     61h, al             ; Turn speaker on          
        push    duration                                       
        call    Pause               ; Pause for specified time 
        add     sp, 2               ; Clean stack on return    
        in      al, 61h             ; Get port value           
        xor     al, 3               ; Kill bits 0-1 to turn    
        out     61h, al             ;   speaker off            
        ret                                                    
                                                               
Sound   ENDP                                                   
                                                               
                                                               
                                                               
   1.9.3. INS/INSB/INSW                                        
                                                               
                                                               
Input from Port to String            Flags:  O D I T S Z A P C 
80186/286/386 Only                           ----------------- 
                                                               
Syntax:  INS dest,src                                          
         INSB                                                  
         INSW                                                  
                                                               
   Receives a string from a port. The string is considered  the
destination and must be pointed to by ES:DI (even if an operand
is given). The input port is specified in DX. For each  element
received, DI is adjusted according to the size of  the  operand
and the status of the direction flag. DI is  increased  if  the
direction flag has been cleared with CLD or  decreased  if  the
direction flag has been set with STD.                          
   If the INS form of the instruction is  used,  a  destination
operand must be provided to  indicate  the  size  of  the  data
elements to be processed and DX must be specified as the source
operand containing the port number. A segment override  is  not
allowed.  If  INSB  (bytes)  or  INSW  (words)  is  used,   the
instruction determines the size of  the  data  elements  to  be
received. No operands are allowed with INSB or INSW.           
   INS and its variations are usually used with the REP prefix.
                                                               
                    Port I/O Instructions                      
Before the repeated instruction is executed, CX should  contain
the number of elements to be received.                         
 0110110w                                                      
--------------------+-------------------------+----------------
 INS  [ES:]dest,DX  | rep   insb              | 88/86 -        
 INSB               | ins   es:instr,dx       | 286   5        
 INSW               | rep   insw              | 386   15       
--------------------+-------------------------+----------------
   1.9.4. OUT                                                  
Output to Port                       Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  OUT port,accumulator                                  
   Transfers a byte or word to  a  port  from  the  accumulator
register. The port address  is  specified  by  the  destination
operand, which can be DX or an 8-bit constant.                 
 1110011w       data (1)                                       
------------------+--------------------------+-----------------
 OUT immed8,accum | out   60h,al             | 88/86 10 (88=14)
                  |                          | 286   3         
                  |                          | 386   10        
------------------+--------------------------+-----------------
 1110111w                                                      
------------------+--------------------------+-----------------
 OUT  DX,accum    | out   dx,ax              | 88/86 8 (88=12) 
                  | out   dx,al              | 286   3         
                  |                          | 386   11        
------------------+--------------------------+-----------------
   1.9.5. OUTS/OUTSB/OUTSW                                     
Output String to Port                Flags:  O D I T S Z A P C 
                                             ----------------- 
80186/286/386 Only                                             
Syntax:  OUTS DX,src                                           
         OUTSB                                                 
         OUTSW                                                 
   Sends a string to a  port.  The  string  is  considered  the
source and must be pointed to by DS:SI (even if an  operand  is
given). The output port is specified in DX.  For  each  element
sent, SI is adjusted according to the size of the  operand  and
the status of the  direction  flag.  SI  is  increased  if  the
direction flag has been cleared with CLD or  decreased  if  the
direction flag has been set with STD.                          
   If the OUTS form of the instruction is used, an operand must
be provided to indicate the size of data elements to be sent. A
segment override can  be  given.  If  OUTSB  (bytes)  or  OUTSW
(words) is used, the instruction determines  the  size  of  the
data elements to be sent. No operand is allowed with  OUTSB  or
                    Port I/O Instructions                      
                                                               
                                                               
OUTSW.                                                         
   OUTS and its  variations  are  usually  used  with  the  REP
prefix. Before the instruction is executed, CX  should  contain
the number of elements to send.                                
                                                               
 0110111w                                                      
--------------------------+---------------------+--------------
 OUTS  DX, [segreg:]src   | rep  outs  dx,buffer| 88/86 -      
 OUTSB                    | outsb               | 286   5      
 OUTSW                    | rep  outw           | 386   14     
--------------------------+---------------------+--------------
                                                               
                                                               
                                                               
   1.10. Processor-Control Instructions                        
                                                               
                                                               
   This group of instructions (except for NOP) generally  deals
with interactions in multiprocessor situations.                
                                                               
                                                               
Mnemonic                                                       
            Name                                               
NOP                                                            
            No Operation                                       
ESC                                                            
            Escape (sends an instruction to the coprocessor)   
WAIT                                                           
            Wait (stops and waits for coprocessor signal)      
LOCK                                                           
            Lock the Bus (locks out other processors)          
HLT                                                            
            Halt (stops execution until interrupt received)    
                                                               
                                                               
                                                               
   1.10.1. NOP                                                 
                                                               
                                                               
No Operation                         Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  NOP                                                   
                                                               
   Performs no operation. NOP can be used for timing delays  or
alignment.                                                     
                                                               
 10010000                                                      
------------------+-------------------------+------------------
 NOP              | nop                     | 88/86 3          
                  |                         | 286   3          
                  |                         | 386   3          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
   1.10.2. ESC                                                 
                                                               
                                                               
Escape                               Flags:  O D I T S Z A P C 
Syntax:  ESC                                 ----------------- 
                                                               
   Provides an instruction, and optionally a memory or register
                                                               
                Processor-Control Instructions                 
operand, for use by a coprocessor (such as the 8087, 80287,  or
80387). The  first  operand  must  be  a  6-bit  constant  that
specifies the bits of the coprocessor instruction.  The  second
operand can be either a register or memory operand to  be  used
by the coprocessor instruction.  The  CPU  puts  the  specified
information on the data bus where it can  be  accessed  by  the
coprocessor.   The   assembler   automatically   inserts    ESC
instructions in coprocessor instructions.                      
 11011TTT      mod,LLL,r/m                                     
TTT specifies the top three bits of the coprocessor opcode     
and LLL specifies the lower three bits.                        
----------------+---------------------------+------------------
 ESC  immed,reg | esc   5,al                | 88/86     2      
                |                           | 286       9-20   
                |                           | 386              
----------------+---------------------------+------------------
 ESC  immed,mem | esc   29,[bx]             | 88/86     8+EA   
                |                           | (W88=12+EA)      
                |                           | 286       9-20   
                |                           | 386              
----------------+---------------------------+------------------
   1.10.3. WAIT                                                
Wait                                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  WAIT                                                  
   Suspends CPU execution until a signal  is  received  that  a
coprocessor has finished a simultaneous operation. It should be
used to prevent a  coprocessor  instruction  from  modifying  a
memory location that is being modified at the same  time  by  a
processor instruction. WAIT is  the  same  as  the  coprocessor
FWAIT instruction.                                             
 10011011                                                      
-----------------+-------------------------+-------------------
 WAIT            | wait                    | 88/86 4           
                 |                         | 286   3           
                 |                         | 386   6           
-----------------+-------------------------+-------------------
   1.10.4. LOCK                                                
Lock the Bus                         Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  LOCK instruction                                      
   Locks out other processors  during  execution  of  the  next
instruction. This instruction is a prefix. It usually  precedes
an instruction that modifies a  memory  location  that  another
processor might attempt to modify at the same time.  See  Intel
documentation for details on multiprocessor environments.      
                Processor-Control Instructions                 
                                                               
                                                               
                                                               
 11110000                                                      
---------------------+-------------------------+---------------
 LOCK  instruction   | lock  xchg ax,sem       | 88/86 2       
                     |                         | 286   0       
                     |                         | 386   0       
---------------------+-------------------------+---------------
                                                               
                                                               
                                                               
   1.10.5. HLT                                                 
                                                               
                                                               
Halt                                 Flags:  O D I T S Z A P C 
Syntax:  HLT                                 ----------------- 
                                                               
   Stops CPU execution until an interrupt restarts execution at
the instruction following HLT.                                 
                                                               
 11110100                                                      
-----------------+--------------------------+------------------
 HLT             | hlt                      | 88/86 2          
                 |                          | 286   2          
                 |                          | 386   5          
-----------------+--------------------------+------------------
                                                               
                                                               
                                                               
   1.11. Stack-Oriented Instructions                           
                                                               
                                                               
Mnemonic                                                       
            Name                                               
PUSH                                                           
            Push                                               
PUSHF                                                          
            Push Flags                                         
PUSHA                                                          
            Push All (80186/286/386 Only)                      
POP                                                            
            Pop                                                
POPF                                                           
            Pop Flags                                          
POPA                                                           
            Pop All (80186/286/386 Only)                       
                                                               
                                                               
                                                               
   1.11.1. PUSH                                                
                                                               
                                                               
Push                                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  PUSH src                                              
                                                               
   Pushes the source operand onto the stack. This means that SP
is decreased by 2 and the source value is copied to SS:SP.  The
operand can be a memory  location,  a  general  purpose  16-bit
register, or a segment register. On the 80186-80386 processors,
the operand can also be a constant. On the 8088 and 8086,  PUSH
SP copies the value of SP after the push.  On  the  80186-80386
processors, PUSH SP copies the value of SP before the push.    
                 Stack-Oriented Instructions                   
 01010,reg                                                     
----------------+-------------------------+--------------------
 PUSH reg16     | push  dx                | 88/86 11 (88=15)   
                |                         | 286   3            
                |                         | 386   2            
----------------+-------------------------+--------------------
 11111111    mod,110,r/m      disp (2)                         
---------------+-------------------------+---------------------
 PUSH mem16    | push  [di]              | 88/86 16+EA (88=24+E
               | push  fcount            | 286   5             
               |                         | 386   5             
---------------+-------------------------+---------------------
 00,sreg,110                                                   
------------------+-------------------------+------------------
 PUSH  segreg     | push  es                | 88/86 10 (88=14) 
                  | push  ss                | 286   3          
                  | push  cs                | 386   2          
------------------+-------------------------+------------------
 00001111    10,sreg,000                                       
------------------+-------------------------+------------------
 PUSH  segreg     | push  fs                | 88/86 -          
                  | push  gs                | 286   -          
                  |                         | 386   2          
------------------+-------------------------+------------------
 011010s0    data (1 or 2)                                     
------------------+-------------------------+------------------
 PUSH  immed      | push  'a'               | 88/86 -          
                  | push  15000             | 286   3          
                  |                         | 386   2          
------------------+-------------------------+------------------
   1.11.2. GetMem                                              
;* GetMem - Gets total size of memory and determines the larges
;* amount of unallocated memory available. GetMem invokes DOS  
;* Function 48h (Allocate Memory) to request an impossibly larg
;* memory block. DOS denies the request, but returns instead th
;* size of the largest block available. This is the amount that
;* GetMem returns to the calling program. See the WinOpen      
;* procedure for an example of calling Function 48h to allocate
;* unused memory.                                              
;*                                                             
;* Shows:   BIOS Interrupt - 12h (Get Conventional Memory Size)
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Long integer,                                      
;*          high word = total memory in kilobytes (KB)         
;*          low word  = largest block of available memory (KB) 
GetMem  PROC                                                   
        int     12h         ; Get total memory in K            
        push    ax          ; Save size of memory              
        mov     ah, 48h     ; Request memory allocation        
        mov     bx, 0FFFFh  ; Ensure request is denied for     
                            ;   impossibly large block         
        int     21h         ; Get largest available block in BX
                 Stack-Oriented Instructions                   
                                                               
                                                               
        mov     ax, bx      ; Copy to AX                       
        mov     cl, 6       ; Convert paragraphs to kilobytes b
        shr     ax, cl      ;   dividing by 64                 
        pop     dx          ; Recover total in DX              
        ret                 ; Return long integer DX:AX        
                                                               
GetMem  ENDP                                                   
                                                               
                                                               
                                                               
   1.11.3. PUSHA                                               
                                                               
                                                               
Push All                             Flags:  O D I T S Z A P C 
80186/286/386 Only                           ----------------- 
                                                               
Syntax: PUSHA                                                  
                                                               
   Pushes the general-purpose registers  onto  the  stack.  The
registers are pushed in the following order: AX,  CX,  DX,  BX,
SP, BP, SI, DI. The value pushed for SP is the value before the
instruction. PUSHA always pushes 16-bit registers.             
                                                               
                                                               
                                                               
   1.11.4. POP                                                 
                                                               
                                                               
Pop                                  Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  POP dest                                              
                                                               
   Pops the top of the stack into the destination operand. This
means that the value at SS:SP  is  copied  to  the  destination
operand and SP is increased by 2. The destination  operand  can
be a memory location, a general purpose 16-bit register, or any
segment register except CS. Use RET to pop CS.                 
                                                               
 01011 reg                                                     
----------------+-------------------------+--------------------
 POP  reg16     | pop   cx                | 88/86 8 (88=12)    
                |                         | 286   5            
                |                         | 386   4            
----------------+-------------------------+--------------------
 10001111     mod, 000,r/m      disp (2)                       
----------------+------------------------+---------------------
 POP  mem16     | pop   param            | 88/86 17+EA (88=25+E
                |                        | 286   5             
                |                        | 386   5             
----------------+------------------------+---------------------
 000,sreg,111                                                  
------------------+-------------------------+------------------
 POP  segreg      | pop   es                | 88/86 8 (88=12)  
                  | pop   ds                | 286   5          
                  | pop   ss                | 386   7          
------------------+-------------------------+------------------
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                 Stack-Oriented Instructions                   
   1.11.5. POPA                                                
Pop All                              Flags:  O D I T S Z A P C 
80186/286/386 Only                           ----------------- 
Syntax:  POPA                                                  
   Pops  the  top  16  bytes  on  the  stack  into  the   eight
general-purpose registers. The  registers  are  popped  in  the
following order: DI, SI, BP, SP, BX, DX, CX, AX. The value  for
the SP register is actually discarded rather than copied to SP.
POPA always pops into 16-bit registers.                        
 01100001                                                      
------------------+-------------------------+------------------
 POPA             | popa                    | 88/86 -          
                  |                         | 286   19         
                  |                         | 386   24         
------------------+-------------------------+------------------
   1.11.6. PopAll                                              
;* PopAll - Macro to restore registers pushed by the PushAll ma
;* the PushAll macro, PopAll uses the most efficient method ava
;* assembly time (not at run time).                            
;*                                                             
;* Shows:   Instruction - popa                                 
;*                                                             
;* Params:  None                                               
PopAll MACRO                                                   
    IF @Cpu AND 2                       ;; If assembling on 801
        popa                            ;;    use the efficient
    ELSE                                ;;    instruction      
        pop ax                          ;; Otherwise pop the re
        pop cx                          ;;    individually     
        pop dx                                                 
        pop bx                                                 
        pop sp                                                 
        pop bp                                                 
        pop si                                                 
        pop di                                                 
    ENDIF                                                      
ENDM                                                           
   1.12. String Operations                                     
   In all the string instructions, DS:SI points to  the  source
operand and ES:DI points to the destination operand.           
Mnemonic                                                       
            Name                                               
MOVS                                                           
            Move String Data                                   
                 Stack-Oriented Instructions                   
                                                               
                                                               
LODS                                                           
            Load String Operand                                
STOS                                                           
            Store String Data                                  
SCAS                                                           
            Scan String (compares to accumulator)              
CMPS                                                           
            Compare Strings                                    
INS                                                            
            Input to String from Port (80186/286/386 only)     
OUTS                                                           
            Input String to Port (80186/286/386 only)          
REP                                                            
            Repeat String (instruction prefix)                 
REPE/REPZ                                                      
            Repeat While Equal                                 
REPNE/REPNZ                                                    
            Repeat While Not Equal                             
                                                               
                                                               
                                                               
   1.12.1. MOVS/MOVSB/MOVSW                                    
                                                               
                                                               
Move String Data                     Flags:  O D I T S Z A P C 
                                             ----------------- 
                                                               
Syntax:  MOVS dest,src                                         
         MOVSB                                                 
         MOVSW                                                 
                                                               
   Moves a string from one  area  of  memory  to  another.  The
source string must be pointed to by DS:SI and  the  destination
address must be pointed to  by  ES:DI  (even  if  operands  are
given).  For  each  element  moved,  DI  and  SI  are  adjusted
according to the size of the operands and  the  status  of  the
direction flag. They are increased if the  direction  flag  has
been cleared with CLD, or decreased if the direction  flag  has
been set with STD.                                             
   If the MOVS form of the instruction is used,  operands  must
be provided to indicate the size of the  data  elements  to  be
processed. A segment override  can  be  given  for  the  source
operand (but not for the  destination).  If  MOVSB  (bytes)  or
MOVSW (words) is used, the instruction determines the  size  of
the data elements to be processed. Operands are not allowed  in
MOVSB or MOVSW.                                                
   MOVS and its  variations  are  usually  used  with  the  REP
prefix. Before a move using a repeat prefix, CX should  contain
the number of elements to move.                                
                                                               
 1010010w                                                      
-------------------------------+----------------------+--------
 MOVS [ES:]dest,[segreg:]src   | rep   movsb          | 88/86 1
                               |                      | (W88=26
 MOVSB                         | movs  dest,es:source | 286   5
 MOVSW                         |                      | 386   7
-------------------------------+----------------------+--------
                                                               
                                                               
                                                               
                                                               
                                                               
                 Stack-Oriented Instructions                   
   1.12.2. LODS/LODSB/LODSW                                    
Load String Operand                  Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax: LODS src                                               
        LODSB                                                  
        LODSW                                                  
   Loads a string from memory into  the  accumulator  register.
The string to be loaded is the source and must be pointed to by
DS:SI (even if an operand is given). For  each  source  element
loaded, SI is adjusted according to the size  of  the  operands
and the status of the direction flag. SI is  increased  if  the
direction flag has been cleared with CLD or  decreased  if  the
direction flag has been set with STD.                          
   If the LODS form of the instruction is used, an operand must
be provided to indicate the size of the  data  elements  to  be
processed. A segment override can be given. If LODSB (bytes) or
LODSW (words) is used, the instruction determines the  size  of
the data elements to be processed and whether the element  will
be loaded to AL or AX. Operands are not allowed with  LODSB  or
LODSW.                                                         
   LODS and its variations are not normally  used  with  repeat
prefixes, since there is no reason to  repeatedly  load  memory
values to a register.                                          
 1010110w                                                      
--------------------------+----------------------+-------------
 LODS  [segreg:]src       | lods  es:source      | 88/86 12    
                          |                      | (W88=26)    
 LODSB                    | lodsw                | 286   5     
 LODSW                    |                      | 386   5     
--------------------------+----------------------+-------------
   1.12.3. STOS/STOSB/STOSW                                    
Store String Data                    Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax: STOS dest                                              
        STOSB                                                  
        STOSW                                                  
   Stores the value in the accumulator to a string. The  string
to be filled is the destination and must be pointed to by ES:DI
(even if an operand is given). For each source element  loaded,
DI is adjusted according to the size of the  operands  and  the
status of the direction flag. DI is increased if the  direction
flag has been cleared with CLD or decreased  if  the  direction
flag has been set with STD.                                    
   If the STOS form of the instruction is used, an operand must
be provided to indicate the size of the  data  elements  to  be
processed. No segment override is allowed. If STOSB (bytes)  or
STOSW (words) is used, the instruction determines the  size  of
the data elements to be processed and whether the element  will
be from AL or AX. No operand is allowed with STOSB or STOSW.   
   STOS and its variations are often used with the REP  prefix.
Before the repeated instruction is executed, CX should  contain
                 Stack-Oriented Instructions                   
                                                               
                                                               
the number of elements to store.                               
                                                               
 1010101w                                                      
------------------+------------------------+-------------------
 STOS  [ES:]dest  | stos  es:dstring       | 88/86 11 (W88=15) 
 STOSB            | rep    stosw           | 286   3           
 STOSW            | rep    stosb           | 386   4           
------------------+------------------------+-------------------
                                                               
                                                               
                                                               
   1.12.4. SCAS/SCASB/SCASW                                    
                                                               
                                                               
Scan String Flags                    Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             *       * * * * * 
Syntax:  SCAS dest                                             
         SCASB                                                 
         SCASW                                                 
                                                               
   Scans a string to find a value specified in the  accumulator
register.  The  string  to  be  scanned   is   considered   the
destination and must be pointed to by ES:DI (even if an operand
is specified). For each element,  the  destination  element  is
subtracted from the accumulator value and the flags are updated
to reflect the result (although the result is not  stored).  DI
is adjusted according to the  size  of  the  operands  and  the
status of the direction flag. DI is increased if the  direction
flag has been cleared with CLD or decreased  if  the  direction
flag has been set with STD.                                    
   If the SCAS form of the instruction is used, an operand must
be provided to indicate the size of the  data  elements  to  be
processed. No segment override is allowed. If SCASB (bytes)  or
SCASW (words) is used, the instruction determines the  size  of
the data elements to  be  processed  and  whether  the  element
scanned for is in AL, AX. No operand is allowed with  SCASB  or
SCASW.                                                         
   SCAS  and  its  variations  are  usually  used  with  repeat
prefixes. REPNE (or REPNZ) is used to find the first  match  of
the accumulator value. REPE (or REPZ) is used to find the first
nonmatch. Before the comparison, CX should contain the  maximum
number of elements to compare. After the comparison, CX will be
0 if no match or nonmatch was found. Otherwise SI and  DI  will
point to the element after the first match or nonmatch.        
                                                               
 1010111w                                                      
-------------------+-------------------------+-----------------
 SCAS  [ES:]dest   | repne  scasw            | 88/86 15 (W88=19
 SCASB             | repe   scasb            | 286   7         
 SCASW             | scas   es:destin        | 386   7         
-------------------+-------------------------+-----------------
                                                               
                                                               
                                                               
   1.12.5. CMPS/CMPSB/CMPSW                                    
                                                               
                                                               
                                                               
                                                               
                                                               
                 Stack-Oriented Instructions                   
Compare String                       Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             *       * * * * * 
Syntax:  CMPS dest,src                                         
         CMPSB                                                 
         CMPSW                                                 
   Compares two strings. DS:SI must point to the source  string
and ES:DI  must  point  to  the  destination  string  (even  if
operands are  given).  For  each  comparison,  the  destination
element is subtracted from the source element and the flags are
updated to reflect the  result  (although  the  result  is  not
stored). DI and SI are adjusted according to the  size  of  the
operands and  the  status  of  the  direction  flag.  They  are
increased if the direction flag has been cleared  with  CLD  or
decreased if the direction flag has been set with STD.         
   If the CMPS form of the instruction is used,  operands  must
be provided to indicate the size of the  data  elements  to  be
processed. A segment override can be given for the source  (but
not for the destination). If CMPSB (bytes) or CMPSW (words)  is
used, the instruction determines the size of the data  elements
to be processed. Operands are not allowed with CMPSB or  CMPSW.
   CMPS  and  its  variations  are  usually  used  with  repeat
prefixes. REPNE (or REPNZ) is used  to  find  the  first  match
between two strings. REPE (or REPZ) is used to find  the  first
nonmatch. Before the comparison, CX should contain the  maximum
number of elements to compare. After a  REPNE  CMPS,  the  zero
flag will be cleared if no match was found. After a REPE  CMPS,
the zero flag will be set if no nonmatch was  found.  Otherwise
SI and DI will point to the element after the  first  match  or
nonmatch.                                                      
 1010011w                                                      
------------------------------+--------------------+-----------
 CMPS  [segreg:]src,[ES:]dest |cmps  source,es:dest| 88/86 22  
                              |                    |(W88=30)   
 CMPSB                        |repne cmpsw         | 286   8   
 CMPSW                        |repe  cmpsb         | 386   10  
------------------------------+--------------------+-----------
   1.12.6. REP                                                 
Repeat String                        Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  REP instruction                                       
   Repeats the string instruction the number of times indicated
by CX. For each  string  element,  the  string  instruction  is
performed and CX is decremented. When CX reaches  0,  execution
continues with the next instruction. REP is normally used  with
MOVS and STOS. (REP LODS is legal, but has the same  effect  as
LODS.) REP is additionally  used  with  INS  and  OUTS  on  the
80186-80386 processors. On all  processors  except  the  80386,
combining a repeat prefix with a  segment  override  may  cause
errors if an interrupt occurs during a string operation.       
                 Stack-Oriented Instructions                   
                                                               
                                                               
                                                               
 11110010    1010010w                                          
--------------------+-------------------------+----------------
 REP  MOVS dest,src | rep   movs source,destin| 88/86 9+17n    
                    |                         |  (W88=9+25n)   
 REP  MOVSB         | rep   movsw             | 286   5+4n     
 REP  MOVSW         |                         | 386   7+4n     
--------------------+-------------------------+----------------
 11110010    1010101w                                          
--------------------+-------------------------+----------------
 REP  STOS dest     | rep   stosb             | 88/86 9+10n    
                    |                         |(W88=9+14n)     
 REP  STOSB         | rep   stos destin       | 286   4+3n     
 REP  STOSW         |                         | 386   5+5n     
--------------------+-------------------------+----------------
 11110010    0110110w                                          
--------------------+-------------------------+----------------
 REP  INS dest,DX   | rep   insb              | 88/86 -        
 REP  INSB          | rep   ins destin,dx     | 286   5+4n     
 REP  INSW          |                         | 386   13+6n    
--------------------+-------------------------+----------------
 11110010    0110111w                                          
---------------------+-------------------------+---------------
 REP  OUTS DX,src    | rep   outs dx,source    | 88/86 -       
 REP  OUTSB          | rep   outsw             | 286   5+4n    
 REP  OUTSW          |                         | 386   12+5n   
---------------------+-------------------------+---------------
                                                               
                                                               
                                                               
   1.12.7. REPcondition                                        
                                                               
                                                               
Repeat String Conditionally          Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  REPE instruction                              *       
         REPNE instruction                                     
                                                               
   Repeats a string instruction as long as  condition  is  true
and the maximum count has not been reached. REPE and REPZ  (the
names are synonyms) repeat while the zero flag  is  set.  REPNE
and REPNZ (the names are synonyms) repeat while the  zero  flag
is cleared. The conditional repeat prefixes should only be used
with  SCAS  and  CMPS,  since  these  are   the   only   string
instructions that modify the zero flag.  Before  executing  the
instruction, CX should be set to the maximum  allowable  number
of repetitions. For each string element, the string instruction
is performed, CX is decremented, and the zero flag  is  tested.
On all processors except the 80386, combining a  repeat  prefix
with a segment override may cause errors if an interrupt occurs
during a string operation.                                     
                                                               
 11110011     1010011w                                         
-----------------------+-------------------------+-------------
 REPE  CMPS dest,src   | repz   cmpsb            | 88/86 9+22n 
                       |                         | (W88=9+30n) 
 REPE  CMPSB           | repe   cmps destin,src  | 286   5+9n  
 REPE  CMPSW           |                         | 386   5+9n  
-----------------------+-------------------------+-------------
                                                               
                 Stack-Oriented Instructions                   
 11110011     1010111w                                         
-----------------------+-------------------------+-------------
 REPE  SCAS dest       | repe   scas destin      | 88/86 9+15n 
                       |                         | (W88=9+19n) 
 REPE  SCASB           | repz   scasw            | 286   5+8n  
 REPE  SCASW           |                         | 386   5+8n  
-----------------------+-------------------------+-------------
 11110010     1010011w                                         
-----------------------+-------------------------+-------------
 REPNE  CMPS dest,src  | repne   cmpsw           | 88/86 9+22n 
                       |                         | (W88=9+30n) 
 REPNE  CMPSB          | repnz   cmps destin,src | 286   5+9n  
 REPNE  CMPSW          |                         | 386   5+9n  
-----------------------+-------------------------+-------------
 11110010     1010111w                                         
-----------------------+-------------------------+-------------
 REPNE  SCAS dest      | repne    scas destin    | 88/86 9+15n 
                       |                         | (W88=9+19n) 
 REPNE  SCASB          | repnz    scasb          | 286   5+8n  
 REPNE  SCASW          |                         | 386   5+8n  
-----------------------+-------------------------+-------------
   1.13. Type-Conversion Instructions                          
   These instructions offer a fast way to convert from one data
type to another, while  preserving  the  sign.  Use  only  with
signed integer values. These instructions always use a value in
the accumulator (AL or AX).                                    
Mnemonic                                                       
            Name                                               
CBW                                                            
            Convert Byte to Word                               
CWD                                                            
            Convert Word to Double                             
   1.13.1. CBW                                                 
Convert Byte to Word                 Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  CBW                                                   
   Converts a signed byte in AL to  a  signed  word  in  AX  by
extending the sign bit of AL into all bits of AH.              
 10011000                                                      
-----------------+-------------------------+------------------ 
 CBW             | cbw                     | 88/86 2           
                 |                         | 286   2           
                 |                         | 386   3           
-----------------+-------------------------+------------------ 
                 Type-Conversion Instructions                  
                                                               
                                                               
   1.13.2. GetCurDisk                                          
                                                               
                                                               
;* GetCurDisk - Gets designation of current disk.              
;*                                                             
;* Shows:   DOS Function - 19h (Get Current Disk)              
;*          Instruction - cbw                                  
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Short integer with drive designation               
;*          0 = A, 1 = B, 2 = C, etc.                          
                                                               
GetCurDisk PROC                                                
                                                               
        mov     ah, 19h                 ; DOS Function 19h     
        int     21h                     ; Get Current Disk     
        cbw                             ; AX = drive designatio
        ret                                                    
                                                               
GetCurDisk ENDP                                                
                                                               
                                                               
                                                               
   1.13.3. CWD                                                 
                                                               
                                                               
Convert Word to Double               Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  CWD                                                   
                                                               
   Converts the signed word in AX to a signed word in the DX:AX
register pair by extending the sign bit of AX into all bits  of
DX.                                                            
                                                               
 10011001                                                      
-----------------+-------------------------+------------------ 
 CWD             | cwd                     | 88/86 5           
                 |                         | 286   2           
                 |                         | 386   2           
-----------------+-------------------------+------------------ 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
                     2. Directive Summary                      
Category                                                       
            Description                                        
Conditional Assembly                                           
            Assemble blocks of code on certain conditions      
Conditional Error                                              
            Generate assemble-time error on certain  conditions
Code Labels                                                    
            Define code addresses and alignment                
Data Allocation                                                
            Define global data items of various sizes          
Listing Control                                                
            Control what is included in listing file           
Macro                                                          
            Define macros, equates, and repeat blocks          
Miscellaneous                                                  
            Comment, output, radix, and include directives     
Multimodule                                                    
            Declare items public for other modules             
Processor                                                      
            Enable instruction set of another processor        
Segment                                                        
            Give full segment definitions                      
Simplified Segment                                             
            Define segments using Microsoft conventions        
Structure and Record                                           
            Define structure or record data types              
   2.1. Conditional-Assembly Directives                        
Mnemonic                                                       
            Description                                        
IF                                                             
            Assembles block if expression is nonzero           
IF1                                                            
            Assembles block on pass 1                          
IF2                                                            
            Assembles block on pass 2                          
IFE                                                            
            Assembles block if expression is false             
IFB                                                            
            Assembles block if expression is blank             
IFNB                                                           
            Assembles block if expression is not blank         
IFDEF                                                          
            Assembles block if expression is defined           
IFNDEF                                                         
            Assembles block if expression is not defined       
IFDIF[I]                                                       
            Assembles block if arguments are different         
IFIDN[I]                                                       
            Assembles block if arguments are identical         
ELSE                                                           
            Marks beginning of alternate conditional block     
ELSEIF                                                         
            Marks alternate block with a new condition         
ENDIF                                                          
                      Directive Summary                        
                                                               
                                                               
            Terminates conditional block                       
                                                               
                                                               
                                                               
   2.1.1. IF block syntax                                      
                                                               
                                                               
                                                               
  Syntax:  IFcondition                                         
            ifstatements                                       
           [ELSEIFcondition                                    
            elseifstatements]                                  
            .                                                  
            .                                                  
            .                                                  
           [ELSE                                               
            elsestatements]                                    
           ENDIF                                               
                                                               
                                                               
                                                               
   IFcondition may be any directive beginning with the  letters
"IF." There is a corresponding ELSEIF  directive  for  each  IF
directive.                                                     
   The ifstatements, elseifstatements, and  elsestatements  are
each a series of one  or  more  assembly-code  statements.  The
respective conditions determine which block  is  assembled,  if
any. The ELSE and ELSEIF blocks are optional.                  
                                                               
                                                               
See Also:                                                      
            IF, IFE, IF1, IFB, IFDEF, IFDIF                    
                                                               
                                                               
                                                               
   2.1.2. LoadPtr                                              
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
;* LoadPtr - Macro to load far address into segment:register   
;*  pair, or near address into register.                       
;*                                                             
;* Params:  sgmnt - Segment to be loaded with segment address  
;*          reg - Register to be loaded with offset address    
;*          ptr - Pointer to address                           
;*                                                             
;* Shows:   Instructions - lds     les                         
;*          Directives - MACRO  IF     IFIDNI  ELSE   ELSEIF   
;*                       ENDIF  .ERR   %OUT    EXITM  ENDM     
;*          Operators - < >       ;;                           
LoadPtr MACRO sgmnt, reg, ptr  ;; Macro definition             
    IF @DataSize               ;; If far pointer, and          
        IFIDNI <sgmnt>, <ds>   ;;   if 1st argument is DS,     
            lds reg, ptr       ;;   load DS:reg with far addres
            EXITM                                              
        ENDIF                                                  
        .ERR                   ;; Generate error if not DS or E
        %OUT 1st macro argument must be DS or ES               
    ELSE                                ;; If near pointer,    
        IFIDNI <sgmnt>, <es>            ;;   and if segment is 
            push ds                     ;;   ensure ES points t
            pop  es                     ;;   same segment as DS
        ENDIF                                                  
        mov reg, ptr           ;; Then load reg with near addre
    ENDIF                                                      
ENDM                                                           
   2.1.3. IF                                                   
Syntax:                                                        
            IF expression                                      
            IFE expression                                     
   IF causes assembly of a block of statements  (see  IF  Block
Syntax) if expression is true (nonzero). IFE causes assembly of
a block of statements if expression is false (zero).           
   ELSEIF and ELSEIFE correspond to IF and IFE, respectively.  
See Also:                                                      
            IF1, IFB, IFDEF, IFDIF                             
   2.1.4. IF1, IF2                                             
Syntax:                                                        
            IF1                                                
            IF2                                                
   IF1 causes assembly of a block of statements (see  IF  Block
Syntax) during pass 1.  IF2  causes  assembly  of  a  block  of
statements during pass 2. These directives  conflict  with  the
One Pass Assembly option.                                      
   ELSEIF1 and ELSEIF2 correspond to IF1 and IF2, respectively.
                      Directive Summary                        
                                                               
                                                               
See Also:                                                      
            IF, IFE, IFB, IFDEF, IFDIF                         
                                                               
                                                               
                                                               
   2.1.5. IFB                                                  
                                                               
                                                               
Syntax:                                                        
            IFB <argument>                                     
            IFNB <argument>                                    
   IFB causes assembly of a block of statements (see  IF  Block
Syntax) if argument is blank. IFNB causes assembly of  a  block
of statements if argument is not blank.                        
   Within a macro, a parameter name is  replaced  by  an  empty
string if you call the macro  without  giving  a  corresponding
argument.  IFB  and  IFNB  therefore  let  you  define  default
behavior when an argument is missing.                          
   The  ELSEIFB  and  ELSEIFNB  correspond  to  IFB  and  IFNB,
respectively.                                                  
                                                               
                                                               
argument                                                       
            Any name, number,  or  expression;  typically,  the
            name of a parameter of a macro.                    
                                                               
                                                               
See Also:                                                      
            IF, IFE, IF1, IFDEF, IFDIF                         
                                                               
                                                               
                                                               
   2.1.6. IFDEF                                                
                                                               
                                                               
Syntax:                                                        
            IFDEF name                                         
            IFNDEF name                                        
   IFDEF causes assembly of a block of statements (see IF Block
Syntax) if name is a previously defined symbol.  IFNDEF  causes
assembly of a block of statements if name has not been defined.
   You can define symbols on the command line (or in  Assembler
Flags dialog box). Use of  this  feature  with  the  IFDEF  and
IFNDEF  directives  lets  you  control  which  statements   are
assembled from the command line.                               
   ELSEIFDEF and ELSEIFNDEF correspond to IFDEF and IFNDEF.    
name                                                           
            Any valid name. If it is a forward reference, it is
            undefined on Pass 1, but defined on  Pass  2.  This
            may cause conflicts with one-pass assembly.        
                                                               
                                                               
See Also:                                                      
            IF, IFE, IF1, IFB, IFDEF, IFDIF                    
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.1.7. IFDIF                                                
Syntax:                                                        
            IFDIF[I] <argument1>, <argument2>                  
            IFIDN[I] <argument1>, <argument2>                  
   Causes assembly of a  block  of  statements  (see  IF  Block
Syntax), depending on whether two arguments  are  different  or
identical. IFDIF assembles the block if argument1 and argument2
are different. IFIDN assembles the block if they are the  same.
IFDIFI   and   IFIDNI   do   the   same   actions,   but    are
case-insensitive.                                              
   ELSEIFDIF[I] and ELSEIFIDN[I]  correspond  to  IFDIF[I]  and
IFIDN[I].                                                      
argument                                                       
            Any valid name,  number,  or  expression.  Must  be
            enclosed in angle brackets.                        
See Also:                                                      
            IF, IFE, IF1, IFB, IFDEF                           
   2.2. Conditional-Error Directives                           
   These directives generate error messages at run time and are
typically used for error checking within macro  calls  and  for
debugging.                                                     
Mnemonic                                                       
            Generates error:                                   
.ERR                                                           
            If expression evaluates to nonzero                 
.ERR1                                                          
            On pass 1                                          
.ERR2                                                          
            On pass 2                                          
.ERRE                                                          
            If expression is false                             
.ERRB                                                          
            If expression is blank                             
.ERRNB                                                         
            If expression is not blank                         
.ERRDEF                                                        
            If expression is defined                           
.ERRNDEF                                                       
            If expression is not defined                       
.ERRDIF[I]                                                     
            If arguments are different                         
.ERRIDN[I]                                                     
            If arguments are identical                         
                      Directive Summary                        
                                                               
                                                               
   2.2.1. .ERR                                                 
                                                               
                                                               
Syntax:                                                        
            .ERR                                               
   Generates a severe error message when assembled.  Generally,
this directive occurs in a conditional-assembly  block  and  is
used to indicate some error condition  discovered  at  assembly
time. Though this directive does not  add  functionality  to  a
program, it can  be  useful  for  verifying  that  the  program
assembled correctly.                                           
                                                               
                                                               
See Also:                                                      
            .ERR1, .ERRB, .ERRDEF, .ERRDIF, .ERRE, .ERRNZ      
                                                               
                                                               
                                                               
   2.2.2. .ERR1/.ERR2                                          
                                                               
                                                               
Syntax:                                                        
            .ERR1                                              
            .ERR2                                              
   .ERR1 generates a severe error message when assembled during
pass 1. .ERR2 generates a severe error message  when  assembled
during  pass  2.  Generally,  these  directives  occur   in   a
conditional-assembly block and are used to indicate some  error
condition discovered at assembly time.                         
   Unlike the .ERR directive, .ERR1 and .ERR2 conflict with the
One-Pass Assembly option.                                      
                                                               
                                                               
See Also:                                                      
            .ERR, .ERRB, .ERRDEF, .ERRDIF, .ERRE, .ERRNZ       
                                                               
                                                               
                                                               
   2.2.3. .ERRE/.ERRNZ                                         
                                                               
                                                               
Syntax:                                                        
            .ERRE expression                                   
            .ERRNZ expression                                  
   Tests value of  expression  and  generates  a  severe  error
depending on the resulting value. .ERRE generates an  error  if
expression evaluates to false (zero). .ERRNZ generates an error
if expression evaluates to true (nonzero).                     
expression                                                     
            An expression that evaluates to true or  false,  or
            as  a  numeric  constant.  The  expression   cannot
            contain forward references.                        
                                                               
                                                               
See Also:                                                      
            .ERR, .ERR1, .ERRB, .ERRDEF, .ERRDIF               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.2.4. .ERRB/.ERRNB                                         
Syntax:                                                        
            .ERRB <argument>                                   
            .ERRNB <argument>                                  
   .ERRB generates a severe error if argument is blank.  .ERRNB
generates an error if argument is not  blank.  Normally,  these
directives are used within macro definitions; a macro parameter
is replaced by an empty string if you call the macro and do not
give a corresponding argument. These directives let  you  write
macros that generate an error if the wrong number of  arguments
are used in the macro call.                                    
argument                                                       
            A name, number, or expression, though normally  the
            name of a macro parameter.                         
See Also:                                                      
            .ERR, .ERR1, .ERRDEF, .ERRDIF, .ERRE, .ERRNZ       
   2.2.5. .ERRDEF/.ERRNDEF                                     
Syntax:                                                        
            .ERRDEF name                                       
            .ERRNDEF name                                      
   .ERRDEF generates a  severe  error  message  if  name  is  a
previously defined symbol. .ERRNDEF generates  a  severe  error
message if name has not been defined.                          
   One of the most common uses of the .ERRNDEF directive is  to
ensure that a symbol has been defined before you attempt to use
it. This situation may arise if the source code depends on  the
command line or Assembler Flags dialog box to define a  symbol.
See Also:                                                      
            .ERR, .ERR1, .ERRB, .ERRDIF, .ERRE, .ERRNZ         
   2.2.6. .ERRDIF/.ERRIDN                                      
Syntax:                                                        
            .ERRDIF[I] <argument1>, <argument2>                
            .ERRIDN[I] <argument1>, <argument2>                
   .ERRDIF generates a severe error if argument1 and  argument2
are  different.  .ERRIDN  generates  an  error  if   they   are
identical. These directives are commonly used inside macros, to
test for bad values passed as parameters. .ERRDIFI and .ERRIDNI
do the same actions, but are case-insensitive.                 
   argument1 and argument2 can each be a symbolic name, number,
or expression.                                                 
See Also:                                                      
            .ERR, .ERR1, .ERRB, .ERRDEF, .ERRE, .ERRNZ         
                      Directive Summary                        
                                                               
                                                               
   2.3. Code-Label Directives                                  
                                                               
                                                               
Mnemonic                                                       
            Description                                        
PROC                                                           
            Declares start of procedure                        
ENDP                                                           
            Declares end of procedure                          
LABEL                                                          
            Declares a  label  of  specified  type  at  current
            location                                           
ALIGN                                                          
            Starts location counter at next multiple of  number
            given                                              
EVEN                                                           
            Starts location counter at next even address       
ORG                                                            
            Sets location counter to a specific offset  address
                                                               
                                                               
                                                               
   2.3.1. PROC                                                 
                                                               
                                                               
                                                               
 Syntax:  label PROC [NEAR|FAR] [langtype] [USES reglist], [arg
                 statements                                    
                 RET [constant]                                
           label ENDP                                          
                                                               
   Defines a  procedure  with  name  label.  To  use  langtype,
reglist, or arguments, you must first use .MODEL and include  a
langtype.                                                      
                                                               
                                                               
langtype                                                       
            C, BASIC,  PASCAL,  or  FORTRAN.  Overrides  .MODEL
            langtype.                                          
reglist                                                        
            An optional list of registers  that  the  assembler
            preserves   with   PUSH   instructions   (and   POP
            instructions   upon   exit).   Separate    multiple
            registers with spaces.                             
arguments                                                      
            List  of  arguments.   The   assembler   translates
            references to arguments into the  actual  reference
            to  the  stack  location.  Each  argument  can   be
            optionally  followed  by  a  colon  (:)  and  type.
            Separate multiple arguments with commas.           
RET                                                            
            Return instruction. Size is NEAR or FAR,  depending
            on the distance attribute of the procedure.        
                                                               
                                                               
See Also:                                                      
            LABEL, PUBLIC, EXTRN, ENDP, RET                    
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.3.2. PUTSTR.ASM                                           
;* PUTSTR.ASM illustrates multiple-modules and memory model    
;* independent techniques. To create the program, paste this   
;* module and HELLOM.ASM (get help on HELLOM.ASM to open it)   
;* into separate program files. In the environment, you must   
;* also create a program list for the program and define a mode
;* in the Defines field of the Assembler Flags dialog box.     
;* For example, use "model=large". Alternately, you could assem
;* outside the environment with the following command line:    
;*      qcl /Dmodel=large hellom.asm putstr.asm                
;*                                                             
;* Shows:   Directives - PUBLIC    PROC     ENDP   PTR         
;*          DOS function - 02h (Character Output)              
; Model is symbol passed from command line or environment.     
; Note that the % operator                                     
; is required to receive external constant symbols.            
%       .MODEL  model, c                                       
; With simplified segment directives, procedures such as PutStr
; are automatically PUBLIC. Data is not automatically public   
; and must be declared with PUBLIC in order to be accessed     
; from other modules. With full segment directives,            
; the following line would be required to make                 
; PutStr known to other modules.                               
        ;PUBLIC PutStr                                         
        .CODE                 ; Address of string (near or far 
PutStr  PROC    str:PTR BYTE  ;   depending on model) is passed
                              ;   the stack                    
        mov     ah, 02h       ; Character output function      
        IF      @DataSize     ; If data is far (compact, large,
        les     di, str       ;   or huge), address is ES:DI   
next:   mov     dl, es:[di] ; Load each character through ES:[D
        ELSE                  ; If data is near (tiny, small,  
        mov     di, str       ;   or medium), address is DI onl
next:   mov     dl, [di]      ; Load each character through [DI
        ENDIF                                                  
        or      dl, dl        ; Check to see if character is ze
        jz      exit          ; If zero, done                  
        int     21h           ; DOS displays character         
        inc     di            ; Point to next character        
        jmp     SHORT next    ; Loop back to load character    
exit:   ret                                                    
PutStr  ENDP                                                   
        END                                                    
   2.3.3. ENDP                                                 
Syntax:                                                        
            label ENDP                                         
   Labels the ending address of a  procedure  previously  begun
                      Directive Summary                        
                                                               
                                                               
with PROC.                                                     
                                                               
                                                               
See Also:                                                      
            PROC, RET                                          
                                                               
                                                               
                                                               
   2.3.4. LABEL                                                
                                                               
                                                               
Syntax:                                                        
            name LABEL type                                    
                                                               
                                                               
   Creates a new variable or label of a given size (type) at  a
specified location by assigning  the  current  location-counter
value and the given type to name.  Can  be  used  to  define  a
second entry point into a procedure.                           
name                                                           
            Symbol assigned to the label.                      
type                                                           
            BYTE, WORD, DWORD, QWORD, TBYTE, NEAR,  FAR,  PROC,
            or a previously defined structure.                 
                                                               
                                                               
See Also:                                                      
            PROC, THIS                                         
                                                               
                                                               
                                                               
   2.3.5. ALIGN                                                
                                                               
                                                               
Syntax:                                                        
            ALIGN number                                       
                                                               
                                                               
   Aligns next variable or instruction  on  an  offset  address
that is a multiple of number. The assembler pads  each  skipped
byte with a NOP (in code segment) or 0  (in  data  segment)  as
needed.                                                        
number                                                         
            Must be a power of 2 (i.e., 2,4,8...) and should be
            equal to or greater than the size of the align type
            of the current segment.                            
                                                               
                                                               
See Also:                                                      
            EVEN                                               
                                                               
                                                               
                                                               
   2.3.6. EVEN                                                 
                                                               
                                                               
Syntax:                                                        
            EVEN                                               
                                                               
                                                               
   Aligns next  variable  or  instruction  on  an  even  offset
address, padding a byte with a NOP (in code segment) or  0  (in
                                                               
                      Directive Summary                        
data segment) if necessary. The current  segment  must  not  be
BYTE-aligned.                                                  
See Also:                                                      
            ALIGN                                              
   2.3.7. ORG                                                  
Syntax:                                                        
            ORG expression                                     
   Begins assembly at a specific offset  address;  particularly
useful for COM-format programs, which must  begin  assembly  at
100H. The assembler implements this directive by adjusting  the
location counter.                                              
expression                                                     
            An expression that evaluates to a constant  number.
See Also:                                                      
            AT, ALIGN, EVEN                                    
   2.4. Data-Allocation Directives                             
Mnemonic                                                       
            Defines objects of type:                           
DB                                                             
            Byte                                               
DW                                                             
            Word (2 bytes)                                     
DD                                                             
            Doubleword (4 bytes)                               
DQ                                                             
            Quadword (8 bytes)                                 
DT                                                             
            Ten-Byte                                           
   2.4.1. DB                                                   
Syntax:                                                        
            [name] DB initializer [,initializer]...            
   Allocates and optionally initializes one or  more  bytes  of
global data.                                                   
name                                                           
            The symbol name assigned to  the  variable.  If  no
            name is assigned, the data is  allocated,  but  the
            starting address of the variable  has  no  symbolic
            name.                                              
initializer                                                    
            A constant expression or question mark  (indicating
            uninitialized data). Separate  multiple  values  by
                      Directive Summary                        
                                                               
                                                               
            commas, or use the DUP operator.                   
                                                               
                                                               
See Also:                                                      
            DW, DD, DQ, DT, DUP                                
                                                               
                                                               
                                                               
   2.4.2. data.asm                                             
                                                               
                                                               
;* DATA.ASM illustrates how to declare variables with          
;* data-definition directives.                                 
;*                                                             
;* Shows:   Directives - DB    DW    DD    DQ    DT   LABEL    
;*          Operator - DUP                                     
                                                               
        .MODEL small                                           
        .STACK                                                 
        .DATA                                                  
; Integers                                                     
bvar    DB      16             ; Byte initialized as 16        
wvar    DW      4 * 3          ; Word initialized as 12        
dvar    DD      4294967295     ; Double word as 4,294,967,295  
qvar    DQ      ?              ; Quad word (8-byte) uninitializ
        DB      1, 2, 3, 4, 5  ; Five initialized bytes        
ten     DT      2345           ; 10-byte integer as 2,345      
fp      DD      6.3153         ; 8-byte real number            
                               ; Strings and characters        
abc     DB      'a', 'b', 'c'                                  
                ; Three characters (same as 'abc')             
hello   DB      'Hello', 13, 10, '$'                           
                ; String for DOS Function 9h                   
msg     DB      13, 10, "Another hello"                        
                ; String for DOS Function 40h                  
len     EQU     $ - msg         ; Length in bytes of msg       
dir     DB      "\C\CPROGS", 0  ; String data for C            
npdir   DW      BYTE PTR dir    ; Near pointer to char (C strin
fpdir   DD      BYTE PTR dir    ; Far pointer to char (C string
                                                               
; Arrays and buffers                                           
dbuf    DW      25 DUP (?)      ; 25 uninitialized doublewords 
bbuf    DB      12 DUP ('month'); 60-byte array, each 5-byte   
                                ;   group initialized to 'month
fpdbuf  DD      WORD PTR dbuf   ; C array is pointer to array d
two_d   DW      5 DUP (5 DUP (0))                              
                ; Allocate 25 words initialized to 0           
warr    LABEL   WORD                                           
                ; Access next array as 50 words                
darr    LABEL   DWORD                                          
                ; Access same array as 25 doublewords          
barr    DB      100 DUP (0, 16, 33, 48)                        
                ; Access array as 100 bytes, each              
                ;   group initialize to bit mask               
        .CODE                                                  
        .STARTUP                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.4.3. DW                                                   
Syntax:                                                        
            [name] DW initializer [,initializer]...            
   Allocates and optionally initializes one or  more  words  of
global data.                                                   
name                                                           
            The symbol name assigned to  the  variable.  If  no
            name is assigned, the data is  allocated,  but  the
            starting address of the variable  has  no  symbolic
            name.                                              
initializer                                                    
            A constant expression or question mark  (indicating
            uninitialized data). Separate  multiple  values  by
            commas, or use the DUP operator.                   
See Also:                                                      
            DB, DD, DQ, DT, DUP                                
   2.4.4. DD                                                   
Syntax:                                                        
            [name] DD initializer [,initializer]...            
   Allocates and optionally initializes one or more doublewords
(4 bytes) of global data.                                      
name                                                           
            The symbol name assigned to  the  variable.  If  no
            name is assigned, the data is  allocated,  but  the
            starting address of the variable  has  no  symbolic
            name.                                              
initializer                                                    
            A constant expression or question mark  (indicating
            uninitialized data). Separate  multiple  values  by
            commas, or use the DUP operator.                   
See Also:                                                      
            DB, DW, DQ, DT, DUP                                
   2.4.5. DQ                                                   
Syntax:                                                        
            [name] DQ initializer [,initializer]...            
   Allocates and optionally initializes one or more quad  words
(8 bytes) of global data.                                      
name                                                           
            The symbol name assigned to  the  variable.  If  no
            name is assigned, the data is  allocated,  but  the
            starting address of the variable  has  no  symbolic
            name.                                              
initializer                                                    
            A constant expression or question mark  (indicating
            uninitialized data). Separate  multiple  values  by
            commas, or use the DUP operator.                   
                      Directive Summary                        
                                                               
                                                               
See Also:                                                      
            DB, DW, DD, DT, DUP                                
                                                               
                                                               
                                                               
   2.4.6. DT                                                   
                                                               
                                                               
Syntax:                                                        
            [name] DT initializer [,initializer]...            
   Allocates and optionally initializes 10 bytes of storage for
each initializer.                                              
name                                                           
            The symbol name assigned to  the  variable.  If  no
            name is assigned, the data is  allocated,  but  the
            starting address of the variable  has  no  symbolic
            name.                                              
initializer                                                    
            A constant expression or question mark  (indicating
            uninitialized data). Separate  multiple  values  by
            commas, or use the DUP operator.                   
                                                               
                                                               
See Also:                                                      
            DB, DW, DD, DQ, DUP                                
                                                               
                                                               
                                                               
   2.5. Listing-File Directives                                
                                                               
                                                               
Mnemonic                                                       
            Description                                        
.LIST                                                          
            Turns on listing of statements                     
.XLIST                                                         
            Turns on macro expansion statements in listings    
.LFCOND                                                        
            Turns on listing of statements in false conditional
            blocks                                             
.SFCOND                                                        
            Suppresses listing of false conditional blocks     
.TFCOND                                                        
            Toggles listing of false conditional blocks        
.LALL                                                          
            Turns on listing of all statements in macros       
.SALL                                                          
            Suppresses listing of all macro expansions         
.XALL                                                          
            Lists macro statements that generate code or data  
TITLE                                                          
            Defines program listing title                      
SUBTTL                                                         
            Defines program listing subtitle                   
PAGE                                                           
            Increments page number (printer-oriented LST  files
            only)                                              
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.5.1. .LIST                                                
Syntax:                                                        
            .LIST                                              
   Turns on listing of most  source  statements.  This  is  the
default. Listing file must be enabled with an Assembler Flag or
command-line option.                                           
See Also:                                                      
            .XLIST, .LFCOND, .SFCOND, .TFCOND                  
   2.5.2. .XLIST                                               
Syntax:                                                        
            .XLIST                                             
   Suppresses program listing. Used in conjunction  with  .LIST
to prevent a particular section of a  source  file  from  being
listed.                                                        
See Also:                                                      
            .LIST, .LFCOND, .SFCOND, .TFCOND                   
   2.5.3. .LFCOND                                              
Syntax:                                                        
            .LFCOND                                            
   Enables listing of  statements  in  conditional  blocks  for
which the condition evaluates to false (0).                    
See Also:                                                      
            .SFCOND, .TFCOND, .LIST, .XLIST                    
   2.5.4. .SFCOND                                              
Syntax:                                                        
            .SFCOND                                            
   Suppresses listing of statements in conditional blocks whose
condition  evaluates  to  false  (0)  and  were  therefore  not
assembled. This is the default behavior.                       
See Also:                                                      
            .LFCOND, .TFCOND, .LIST, .XLIST                    
                      Directive Summary                        
                                                               
                                                               
   2.5.5. .TFCOND                                              
                                                               
                                                               
Syntax:                                                        
            .TFCOND                                            
   Toggles the state  of  the  assembler  between  .LFCOND  and
.SFCOND; these two directives determine whether  or  not  false
conditional blocks are included in assembler listings.         
                                                               
                                                               
See Also:                                                      
            .LFCOND, .SFCOND, .LIST, .XLIST                    
                                                               
                                                               
                                                               
   2.5.6. .LALL                                                
                                                               
                                                               
Syntax:                                                        
            .LALL                                              
               Enables listing of all source  statements  in  a
            macro expansion,  including  normal  comments,  but
            excluding macro comments.                          
                                                               
                                                               
See Also:                                                      
            .SALL, .XALL, .LIST, .XLIST                        
                                                               
                                                               
                                                               
   2.5.7. .SALL                                                
                                                               
                                                               
Syntax:                                                        
            .SALL                                              
   Suppresses listing of macro expansions in  a  listing  file.
Macro calls are listed, but not the source  code  generated  by
the call.                                                      
                                                               
                                                               
See Also:                                                      
            .LALL, .XALL                                       
                                                               
                                                               
                                                               
   2.5.8. .XALL                                                
                                                               
                                                               
Syntax:                                                        
            .XALL                                              
   Enables an assembly listing file  including  macro-expansion
statements that generate code or data. Comments,  equates,  and
segment definitions are ignored. This is the default.          
                                                               
                                                               
See Also:                                                      
            .LALL, .SALL                                       
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.5.9. TITLE                                                
Syntax:                                                        
            TITLE text                                         
   Specifies  title  to  be  used  on  each  page  of  assembly
listings. Specified text is printed flush left  on  the  second
line of each page of the listing. This directive is only useful
with printer-oriented listings.                                
   Only one TITLE per  module  is  allowed.  Default  title  is
blank.                                                         
text                                                           
            Any combination of up to 60 characters.            
See Also:                                                      
            PAGE, PAGE +, SUBTTL                               
   2.5.10. SUBTTL                                              
Syntax:                                                        
            SUBTTL text                                        
   Specifies  the  subtitle  used  on  each  page  of  assembly
listings. Specified text is printed flush  left  on  the  third
line of the listing pages. This directive is useful  only  with
printer-oriented listing files.                                
   Any number of subtitles can be given in a program. Each  new
SUBTTL replaces  the  current  subtitle.  Default  subtitle  is
blank.                                                         
text                                                           
            Any combination of up to 60 characters.            
See Also:                                                      
            PAGE, PAGE +, TITLE                                
   2.5.11. PAGE                                                
Syntax:                                                        
            PAGE [[length],width]                              
   For listing files, sets maximum number  of  lines  per  page
(length) and maximum number of  characters  per  line  (width).
Generates  a  page  break  if  no  arguments  are  given.  This
directive is useful only with printer-oriented listings.       
length                                                         
            A number in the range 10 to 255 lines  (default  is
            50).                                               
width                                                          
            A number in the range 60 to 132 characters (default
            is 80).  To  specify  width  without  changing  the
            default length, use a comma before width.          
See Also:                                                      
            PAGE +                                             
                      Directive Summary                        
                                                               
                                                               
   2.6. Macro                                                  
                                                               
                                                               
Directives                                                     
            Description                                        
MACRO                                                          
            Marks  beginning  of  macro,  specifying  name  and
            parameters                                         
ENDM                                                           
            Ends macro definition or repeat block              
EXITM                                                          
            Terminates expansion of the macro                  
LOCAL                                                          
            Declares name to be local to macro                 
PURGE                                                          
            Purges macro definitions from memory               
REPT                                                           
            Starts a block repeated n times                    
IRP                                                            
            Starts a block  repeated  once  for  each  argument
            given                                              
IRPC                                                           
            Starts a block repeated once for each character  in
            a string                                           
                                                               
                                                               
                                                               
               2.6.1. MACRO                                    
                                                               
                                                               
Syntax:                                                        
            name MACRO [parameter [,parameter]...]             
            statements                                         
            ENDM                                               
   Marks beginning of a  macro  block  called  name  and  takes
optional parameters. The assembler generates the statements  in
the macro block each time the macro is called in source code.  
name                                                           
            A unique symbol name. Can appear  later  in  source
            code, to call the macro.                           
parameter                                                      
            A valid symbol name. Each parameter can  appear  in
            the statements and is replaced by the corresponding
            item in the argument list  whenever  the  macro  is
            called.                                            
                                                               
                                                               
See Also:                                                      
            ENDM, LOCAL, EXITM                                 
                                                               
                                                               
                                                               
               2.6.2. ENDM                                     
                                                               
                                                               
Syntax:                                                        
            ENDM                                               
   Terminates macro and repeat blocks.                         
                                                               
                                                               
See Also:                                                      
            MACRO, REPT, IRP, IRPC                             
                      Directive Summary                        
               2.6.3. EXITM                                    
Syntax:                                                        
            EXITM                                              
   Terminates expansion of the current macro  or  repeat  block
and begins assembly of the next statement outside the block. If
encountered in a nested macro block, the assembler  returns  to
expanding the outer block.                                     
See Also:                                                      
            IRP, IRPC, REPT, MACRO, ENDM                       
               2.6.4. LOCAL (in macros)                        
Syntax:                                                        
            LOCAL localname [,localname]...                    
               Declares that a  label  or  symbol  to  be  used
            locally  within  a  macro  or  repeat  block.   The
            assembler generates a different name for the symbol
            each time it expands the macro, thus permitting you
            to  call  a  macro  that  may  contain  local  jump
            statements without generating the same label twice.
localname                                                      
            The name of a  label  or  symbol  that  can  appear
            elsewhere   in   the   macro.   Separate   multiple
            localnames with commas.                            
See Also:                                                      
            MACRO, ENDM, EXITM, REPT, IRP, IRPC                
               2.6.5. PURGE                                    
Syntax:                                                        
            PURGE macroname [,macroname]...                    
   Deletes the specified macros or group of macros from memory.
A macro can purge itself if PURGE is on the last  line  of  the
macro. This directive should be used if your  system  does  not
have enough memory to keep all the macros needed for  a  source
file in memory at the same time.                               
   Redefining  a  macro  automatically  purges   the   previous
definition.                                                    
macroname                                                      
            A currently defined macro.                         
See Also:                                                      
            MACRO, ENDM, EXITM                                 
                      Directive Summary                        
                                                               
                                                               
               2.6.6. REPT                                     
                                                               
                                                               
Syntax:                                                        
            REPT expression                                    
            statements                                         
            ENDM                                               
   Marks a block of statements to be assembled a  fixed  number
of times (determined by value of expression).                  
   Repeat blocks must be terminated with ENDM.                 
                                                               
                                                               
expression                                                     
            Must evaluate to a numeric constant.               
statements                                                     
            Any valid assembler statements.                    
                                                               
                                                               
See Also:                                                      
            IRP, IRPC                                          
                                                               
                                                               
                                                               
               2.6.7. IRP                                      
                                                               
                                                               
Syntax:                                                        
            IRP parameter,<argument [,argument]...>            
            statements                                         
            ENDM                                               
   Marks a block repeated once  for  each  argument  specified,
with  the  current  argument  replacing   parameter   on   each
repetition.                                                    
                                                               
                                                               
parameter                                                      
            A valid symbol name. If the  parameter  appears  in
            statements, then it  is  replaced  by  a  different
            argument each time.                                
argument                                                       
            Text, symbol, string, or numeric constant. Multiple
            arguments must be separated by commas.             
                                                               
                                                               
See Also:                                                      
            ENDM, EXITM, IRPC, REPT                            
                                                               
                                                               
                                                               
               2.6.8. IRPC                                     
                                                               
                                                               
Syntax:                                                        
            IRPC parameter,string                              
            statements                                         
            ENDM                                               
   Marks a block  repeated  once  for  each  character  in  the
string, with the character  replacing  the  parameter  on  each
repetition.                                                    
                                                               
                                                               
parameter                                                      
                      Directive Summary                        
            A valid symbol name. If the  parameter  appears  in
            statements, then it  is  replaced  by  a  different
            character each time.                               
string                                                         
            A literal string or a symbol defined with a  string
            equate.                                            
See Also:                                                      
            ENDM, EXITM, IRP, REPT                             
   2.7. Miscellaneous Directives                               
Mnemonic                                                       
            Description                                        
COMMENT                                                        
            Marks beginning of a comment block                 
END                                                            
            Marks end of source file and optionally sets  start
            address                                            
INCLUDE                                                        
            Includes contents of another source file           
INCLUDELIB                                                     
            Declares default library to be searched by linker  
%OUT                                                           
            Displays a message during assembly                 
.RADIX                                                         
            Sets default radix for constants                   
   2.7.1. COMMENT                                              
Syntax:                                                        
            COMMENT delimiter [text]                           
            text                                               
            [text] delimiter [text]                            
   Treats  all  text  between  or  on  the  same  line  as  the
delimiters as a comment.                                       
delimiter                                                      
            First  nonblank  character  following  the  COMMENT
            directive.                                         
text                                                           
            All text up to and including  the  line  containing
            the next occurrence of the delimiter.              
See Also:                                                      
            semicolon (;), semicolon (;;)                      
                      Directive Summary                        
                                                               
                                                               
   2.7.2. END                                                  
                                                               
                                                               
Syntax:                                                        
            END [startaddress]                                 
   Marks the end of  a  module  and  optionally  indicates  the
address where execution will begin when the program is  loaded.
Only one module in a program can define a startaddress. Use  of
the .STARTUP directive removes the need to give a startaddress.
   END also closes the last segment in the source file.        
                                                               
                                                               
startaddress                                                   
            Label or expression identifying the  address  where
            you want program execution to begin.               
                                                               
                                                               
See Also:                                                      
            .STARTUP                                           
                                                               
                                                               
                                                               
   2.7.3. INCLUDE                                              
                                                               
                                                               
Syntax:                                                        
            INCLUDE filespec                                   
   Inserts source code from the include file filespec into  the
current source file during assembly. Nested INCLUDE  directives
are allowed.                                                   
filespec                                                       
            Must specify  an  existing  file  containing  valid
            assembly-language statements. Can be a filename  or
            a complete or relative file specification including
            drive or directory name.                           
                                                               
                                                               
                                                               
   2.7.4. INCLUDELIB                                           
                                                               
                                                               
Syntax:                                                        
            INCLUDELIB libraryname                             
   Informs the linker that the current module should be  linked
with a specified library file.  Can  be  used  to  specify  the
library file in the assembly source file instead of in the LINK
command line.                                                  
libraryname                                                    
            Must be a valid filename or full path name.  If  no
            extension is specified, the default extension  .LIB
            is assumed.                                        
                                                               
                                                               
                                                               
   2.7.5. %OUT Directive                                       
                                                               
                                                               
Syntax:                                                        
            %OUT text                                          
   Displays text to the standard  output  device.  Though  this
device is normally the screen, at the DOS command level you can
redirect it to a file or another  device.  This  directive  can
                                                               
                      Directive Summary                        
help show which statements were assembled and can be useful for
debugging.                                                     
text                                                           
            Any line of ASCII characters. For  multiple  lines,
            use a separate %OUT directive for each.            
See Also:                                                      
            .ERR                                               
   2.7.6. .RADIX                                               
Syntax:                                                        
            .RADIX expression                                  
   Sets the default radix (base) for integer constants  to  the
value of expression. Expression defines whether the numbers are
binary, octal, decimal, hexadecimal, or numbers of  some  other
base.  Numbers  given  in  expression  are  always   considered
decimal.                                                       
   Does not affect real numbers initialized as  variables  with
the DD, DQ, or DT directives; these always use decimal radix.  
expression                                                     
            Must evaluate to a number in the range 2 to 16.    
See Also:                                                      
            DD, DQ, DT                                         
   2.8. Multimodule Directives                                 
   To share variables between  modules,  declare  the  variable
PUBLIC in the module where it is defined  and  EXTRN  in  other
modules.                                                       
Mnemonic                                                       
            Description                                        
PUBLIC                                                         
            Makes  each  variable  specified  public  to  other
            modules                                            
EXTRN                                                          
            Defines one or more external variables             
COMM                                                           
            Declares one or more communal variables            
INCLUDELIB                                                     
            Declares default library to be searched by linker  
                      Directive Summary                        
                                                               
                                                               
   2.8.1. PUBLIC                                               
                                                               
                                                               
Syntax:                                                        
            PUBLIC [langtype] name [,[langtype] name]...       
   Makes one or more variables available to  other  modules  in
the program.                                                   
   PUBLIC declarations can be placed  anywhere  in  the  source
module in which the symbol is  defined.  Text  macros  or  text
equates cannot be declared public.                             
                                                               
                                                               
langtype                                                       
            C,  BASIC,  PASCAL,  or  FORTRAN.  The  C  langtype
            appends an underscore to the name as output to  the
            object file.                                       
name                                                           
            The name of a variable, label,  or  numeric  equate
            defined within the current source file.            
                                                               
                                                               
See Also:                                                      
            EXTRN, COMM                                        
                                                               
                                                               
                                                               
   2.8.2. EXTRN                                                
                                                               
                                                               
Syntax:                                                        
            EXTRN     [langtype]     name:type     [,[langtype]
            name:type]...                                      
   Defines one or more external variables, labels, or  symbols,
each having a name and a specific  type.  The  symbol  must  be
defined and declared PUBLIC in another module in the program.  
                                                               
                                                               
langtype                                                       
            C,  BASIC,  PASCAL,  or  FORTRAN.  The  C  langtype
            appends an underscore to the name as output to  the
            object file.                                       
name                                                           
            A unique symbolic name                             
type                                                           
            The same type given to the item in the module where
            defined: i.e., NEAR, FAR, PROC, BYTE, WORD,  DWORD,
            QWORD, TBYTE, or ABS                               
                                                               
                                                               
See Also:                                                      
            PUBLIC, COMM                                       
                                                               
                                                               
                                                               
   2.8.3. COMM                                                 
                                                               
                                                               
Syntax:                                                        
            COMM definition [,definition]...                   
   Creates one  or  more  communal  variables,  in  which  each
variable definition has the following form:                    
                                                               
                                                               
                      Directive Summary                        
[NEAR|FAR] [langtype]label:size[:count]                        
langtype                                                       
            C,  BASIC,  PASCAL,  or  FORTRAN.  The  C  langtype
            appends an underscore to the name as output to  the
            object file.                                       
label                                                          
            The name of the variable.                          
size                                                           
            A size specifier (BYTE, WORD,  etc.)  or  structure
            name.                                              
count                                                          
            Specifies the number of  data  objects  (1  is  the
            default).                                          
See Also:                                                      
            EXTRN, PUBLIC, PROC                                
   2.8.4. INCLUDELIB                                           
Syntax:                                                        
            INCLUDELIB libraryname                             
               Informs  the  linker  that  the  current  module
            should be linked with a specified library file. Can
            be used to specify the library file in the assembly
            source file instead of in the LINK command line.   
libraryname                                                    
            Must be a valid filename or full path name.  If  no
            extension is specified, the default extension  .LIB
            is assumed.                                        
   2.9. Processor Directives                                   
Mnemonic                                                       
            Description                                        
.186                                                           
            Enables instruction set of 80186 processor         
.286                                                           
            Enables instruction set of 80286 processor         
.287                                                           
            Enables instruction set of 80287 math coprocessor  
.8086                                                          
            Disables processor instructions except for 8086 set
.8087                                                          
            Disables coprocessor instructions except  for  8087
            set                                                
                      Directive Summary                        
                                                               
                                                               
   2.9.1. .186                                                 
                                                               
                                                               
Syntax:                                                        
            .186                                               
   Enables assembly of instructions for the 8086 processor, the
8087  coprocessor,  and  the  80186  processor,  and   disables
instructions specific to the 80286 and 80287 processors.       
                                                               
                                                               
See Also:                                                      
            .286, .287, .8086, .8087                           
                                                               
                                                               
                                                               
   2.9.2. .286                                                 
                                                               
                                                               
Syntax:                                                        
            .286                                               
   Enables assembly of instructions for the 8086 processor plus
the additional real mode instructions for the 80286  processor,
and instructions for  the  80287  coprocessor.  This  directive
should be used only in programs executing on  .80286  or  80386
processors.                                                    
                                                               
                                                               
See Also:                                                      
            .186, .287, .8086, .8087                           
                                                               
                                                               
                                                               
   2.9.3. .287                                                 
                                                               
                                                               
Syntax:                                                        
            .287                                               
   Enables assembly of instructions for the 8087 floating-point
coprocessor and of the additional instructions for  the  80287.
Specifies IEEE format for encoding floating-point variables.   
   This directive takes advantage of the 80287 to optimize some
coprocessor instructions.  The  8087  does  not  support  these
optimized instructions.                                        
                                                               
                                                               
See Also:                                                      
            .186, .286, .8086, .8087                           
                                                               
                                                               
                                                               
   2.9.4. .8086                                                
                                                               
                                                               
Syntax:                                                        
            .8086                                              
   Enables assembly of  instructions  for  the  8086  and  8088
processors and  the  8087  coprocessor.  Disables  assembly  of
instructions unique to later processors. This directive  is  in
effect by default.                                             
                                                               
                                                               
See Also:                                                      
                      Directive Summary                        
            .186, .286, .287, .8087                            
   2.9.5. .8087                                                
Syntax:                                                        
            .8087                                              
   Enables  assembly  of  instructions  for   the   8087   math
coprocessor, and disables assembly of the  instructions  unique
to later coprocessors. It specifies IEEE  format  for  encoding
floating-point  variables.  This  directive  is  in  effect  by
default.                                                       
See Also:                                                      
            .186, .286, .287, .8086, .MSFLOAT                  
   2.10. Segment Directives                                    
Mnemonic                                                       
            Description                                        
SEGMENT                                                        
            Marks beginning of a segment and defines attributes
ENDS                                                           
            Marks end of a segment                             
GROUP                                                          
            Groups one or more segments into a single  physical
            segment                                            
ASSUME                                                         
            Informs assembler where  a  segment  register  will
            point to                                           
DOSSEG                                                         
            Orders segments according to DOS segment convention
.ALPHA                                                         
            Orders segments alphabetically by name             
.SEQ                                                           
            Orders segments according to source-code sequence  
   2.10.1. SEGMENT                                             
Syntax:                                                        
            name SEGMENT [align] [combine] ['class']           
            statements                                         
            name ENDS                                          
   Defines  a  program  segment  called  name  having  optional
segment attributes:  align,  combine,  use,  and  class.  These
attributes give the linker and assembler information on how  to
set up and combine segments.                                   
name                                                           
            Defines the name of the segment.                   
align                                                          
            PARA (default), BYTE, WORD, DWORD, or PAGE         
combine                                                        
            PRIVATE (default), PUBLIC, STACK,  COMMON,  MEMORY,
                      Directive Summary                        
                                                               
                                                               
            or AT address                                      
class                                                          
            Can contain a valid symbolic  name.  The  name  has
            special meaning to the linker, indicating a segment
            containing executable code.                        
                                                               
                                                               
See Also:                                                      
            ENDS, ASSUME, GROUP                                
                                                               
                                                               
                                                               
   2.10.2. HELLOF.ASM                                          
                                                               
                                                               
;* HELLOF.ASM - Illustrates full segment directives.           
;*                                                             
;* Shows:   Directives - SEGMENT     ENDS       GROUP          
;*          DOS Functions - 4Ch (Terminate Process             
;*                               with Return Code)             
;*                                                             
;* See HELLO.ASM for a simplified segment version or HELLOC.ASM
;* for a full-segment .COM file version.                       
                                                               
        DOSSEG                      ; Force DOS segment order  
DGROUP  GROUP   _DATA, STACK        ; Stack and data in DGROUP 
                                                               
STACK   SEGMENT PARA STACK 'STACK'                             
        DB      100h DUP (?)            ; 256-byte stack       
STACK   ENDS                                                   
                                                               
_DATA   SEGMENT WORD PUBLIC 'DATA'; Data segment with string da
msg     DB      "Hello, world.", 13, 10, "$"                   
_DATA   ENDS                                                   
                                                               
_TEXT   SEGMENT WORD PUBLIC 'CODE'      ; Code segment         
        ASSUME  cs:_TEXT, ds:DGROUP, ss:DGROUP                 
                                                               
start:  mov     ax, DGROUP   ; Initialize data segment         
        mov     ds, ax                                         
                                                               
        cli                  ; Turn off interrupts             
        mov     ss, ax       ; Make SS and                     
        mov     sp, OFFSET STACK  ; SP relative to DGROUP      
        sti                       ; SS now equals DS           
                                                               
        mov     ah, 9h       ; Request DOS Function 9          
        mov     dx, OFFSET msg                                 
       ; Load DX with offset of string (segment already in DS) 
        int     21h   ; Display String to Standard Output      
                                                               
        mov     ax, 4C00h  ; Exit functions with 0 in AL       
        int     21h  ; Terminate Process with Return Code      
                                                               
_TEXT   ENDS                                                   
        END     start ; End with reference to first            
                      ;   executable statement (CS:IP)         
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.10.3. ENDS                                                
Syntax:                                                        
            name ENDS                                          
   Marks the  end  of  a  segment  name  or  a  structure  name
previously begun with SEGMENT or STRUC.                        
See Also:                                                      
            SEGMENT, STRUC                                     
   2.10.4. GROUP                                               
Syntax:                                                        
            name GROUP segment [,segment]...                   
   Causes linker to recombine several segments into one  larger
segment, so that the items  in  all  segments  share  a  common
segment address. The total of all segments in the group must be
no larger than 64k.                                            
name                                                           
            Unique symbolic name, or previously defined  group.
            If the same group name appears  in  more  than  one
            GROUP statement, then the effect is cumulative; the
            new segments are added to the group.               
segment                                                        
            Any previously defined segment or SEG expression.  
See Also:                                                      
            ASSUME, SEGMENT, SEG                               
   2.10.5. ASSUME                                              
Syntax:                                                        
            ASSUME segregister:name [,segregister:name]...     
   Informs the assembler that at run time,  the  given  segment
register  will  point  to  the  named  segment  or  group.  The
assembler uses this information to correctly calculate offsets.
   Each time you load a new value into a segment register,  you
should inform the assembler of this fact  by  using  an  ASSUME
statement.                                                     
segregister                                                    
            CS, DS, ES, or SS                                  
name                                                           
            The name of a previously defined segment or  group,
            or NOTHING,  will  tells  the  assembler  that  the
            segment register currently holds no useful value.  
See Also:                                                      
            SEGMENT, GROUP                                     
                      Directive Summary                        
                                                               
                                                               
   2.10.6. HELLOC.ASM                                          
                                                               
                                                               
;* illustratesfiles with full segment directives.              
;* Assemble with the "Generate .COM File" linker flag or the   
;* /TINY QCL option.                                           
;*                                                             
;* Shows:    Directives - SEGMENT   ASSUME    ORG              
;*                                                             
;* See HELLO.ASM for a simplified segment version or           
;* HELLOF.ASM for a full-segment .EXE file version.            
                                                               
_TEXT   SEGMENT WORD PUBLIC 'CODE'                             
        ASSUME  cs:_TEXT, ds:_TEXT                             
        ORG     100h                                           
                                                               
first:  jmp     start                   ; Jump over data       
                                                               
msg     DB      "Hello, world.", 13, 10, "$"                   
                                                               
start:  mov     ah, 9h     ; Request DOS Function 9            
        mov     dx, OFFSET msg ; Load DX with offset of string 
                               ;   (segment already in DS)     
        int     21h   ; Display String to Standard Output      
                                                               
        mov     ax, 4C00h  ; Exit functions with 0 in AL       
        int     21h        ; Exit Program with Return Code     
                                                               
_TEXT   ENDS                                                   
        END     first                                          
                                                               
                                                               
                                                               
   2.10.7. DOSSEG                                              
                                                               
                                                               
Syntax:                                                        
            DOSSEG                                             
   Orders segments according to the  standard  DOS  convention;
overrides any other segment-order directives or  options.  This
convention places segments with class name 'CODE'  first,  then
other segments not part of DGROUP, and then DGROUP segments  in
this order: BEGDATA, BSS,  STACK.  Other  DGROUP  segments  are
placed between BEGDATA and BSS.                                
   The DOSSEG directive also causes the linker to generate  two
special symbols, _end and _edata. Avoid using these  names  for
your own symbols.                                              
                                                               
                                                               
See Also:                                                      
            .SEQ, .ALPHA                                       
                                                               
                                                               
                                                               
   2.10.8. HELLO.ASM                                           
                                                               
                                                               
;* HELLO.ASM - Illustrates simplified segment directives.      
;*                                                             
;* Shows:  Directives - TITLE     .MODEL    DOSSEG      .STACK 
;*                      .DATA     .CODE     .STARTUP    OFFSET 
;*                      .EXIT     END                          
                      Directive Summary                        
;*         DOS Functions - 09h (Display String)                
;*                                                             
;* See HELLOF.ASM for a full-segment .EXE file version or      
;* HELLOC.ASM for a full-segment .COM file version.            
        TITLE   HELLO                                          
        .MODEL  small, c  ; Small model (could be any model)   
        DOSSEG            ; Force DOS segment order            
        .STACK  100h      ; 256-byte stack                     
        .DATA             ; Data segment                       
msg     DB      "Hello, world.", 13, 10, "$"                   
        .CODE             ; Code segment                       
        .STARTUP          ; Initialize data segment and        
                          ;   set SS = DS                      
        mov     ah, 9h    ; Request DOS Function 9             
        mov     dx, OFFSET msg ; Load DX with offset of string 
                               ;   (segment already in DS)     
        int     21h       ; Display String                     
        .EXIT   0         ; Exit  with return code 0           
        END                                                    
   2.10.9. .ALPHA                                              
Syntax:                                                        
            .ALPHA                                             
   Outputs segments to the object file  by  alphabetical  order
(using the  names  of  the  segments).  The  default  order  is
sequential, which outputs segments in the order they appear  in
source code.                                                   
See Also:                                                      
            .SEQ and DOSSEG                                    
   2.10.10. .SEQ                                               
Syntax:                                                        
            .SEQ                                               
   Outputs segments to the object file in the same  order  they
appeared in source code. This is the default order, but you can
use this directive to override the effect of the QCL /a option.
See Also:                                                      
            DOSSEG, .ALPHA                                     
                      Directive Summary                        
                                                               
                                                               
   2.11. Simplified Segment Directives                         
                                                               
                                                               
Mnemonic                                                       
            Description                                        
.MODEL                                                         
            Defines basic attributes of  the  module,  such  as
            memory model                                       
.STARTUP                                                       
            Declares start address and initializes registers   
.EXIT                                                          
            Generates code to exit from program                
.CODE                                                          
            Starts a code segment                              
.STACK                                                         
            Defines stack and optionally gives size of stack   
.DATA                                                          
            Starts a near-data segment                         
.DATA?                                                         
            Starts a near-data segment for uninitialized data  
.CONST                                                         
            Starts a near-data segment for constant data       
.FARDATA                                                       
            Starts a far-data segment                          
.FARDATA?                                                      
            Starts a far-data segment for uninitialized data   
                                                               
                                                               
                                                               
   2.11.1. .MODEL                                              
                                                               
                                                               
Syntax:                                                        
            .MODEL memorymodel [,langtype] [,stacktype]        
                                                               
                                                               
   Initializes the program memory model. Should  be  placed  at
the beginning of the source file before  any  other  simplified
segment directive. .MODEL can only occur once.  Creates  ASSUME
and GROUP statements used by specified memory model.           
   If you use the language argument with .MODEL, all  procedure
names are public.                                              
                                                               
                                                               
memorymodel                                                    
            TINY, SMALL, COMPACT, MEDIUM, LARGE,  or  HUGE.  If
            you  are  writing  an  assembler  routine   for   a
            high-level  language,   this   should   match   the
            memorymodel used by the compiler or interpreter.   
langtype                                                       
            C,  Pascal,  FORTRAN,  or  BASIC.   Instructs   the
            assembler to follow the naming, calling, and return
            conventions for the indicated language.            
stacktype                                                      
            Legal  values:  nearStack   (SS=DS)   or   farStack
            (SS!=DS). nearStack is default.                    
                                                               
                                                               
See Also:                                                      
            @DataSize, .CODE, .DATA, ASSUME, GROUP, EXTRN      
                                                               
                                                               
                      Directive Summary                        
   2.11.2. .STARTUP                                            
Syntax:                                                        
            .STARTUP                                           
   Generates startup code for the given model  and  stack  type
(default is nearStack) defined by .MODEL. Initializes  DS,  SS,
and SP as needed. Defines a start-address label,  so  that  you
don't need to give a start  address  with  END.  Use  only  for
stand-alone programs.                                          
   With TINY model, .STARTUP also generates ORG 100h.          
   If you use the .STARTUP directive, you should also  use  the
.EXIT directive at the  end  of  the  program.  Otherwise,  the
assembler generates an advisory warning.                       
See Also:                                                      
            .MODEL, END, ORG, .EXIT                            
   2.11.3. EXIT                                                
Syntax:                                                        
            .EXIT [exitcode]                                   
   Generates a call to interrupt 21H,  function  4CH,  to  exit
from the  program.  Use  of  the  optional  exitcode  parameter
returns an exit code to DOS. The  .MODEL  directive  must  have
previously been used. This directive  should  be  used  in  any
module  that  uses  the  .STARTUP  directive;   the   assembler
generates an advisory warning if you use .STARTUP without using
.EXIT.                                                         
exitcode                                                       
            Optional return code. Can be a byte-sized register,
            memory location or constant.  The  .EXIT  directive
            moves this value into AL.                          
See Also:                                                      
            .STARTUP                                           
   2.11.4. .CODE                                               
Syntax:                                                        
            .CODE [name]                                       
   Indicates the start of a  code  segment  and  ends  previous
segment, if any. The .MODEL directive must have previously been
used.  Each  .CODE  directive  generates  an  ASSUME  statement
associating CS with the current segment.                       
                      Directive Summary                        
                                                               
                                                               
name                                                           
            Optional parameter  for  medium,  large,  and  huge
            models: uses name_TEXT for the code  segment  name.
            If name is not specified, the  assembler  generates
            the  segment  name  _TEXT  (tiny,  small,   compact
            models) or module_TEXT (other models).             
                                                               
                                                               
See Also:                                                      
            @code, .MODEL                                      
                                                               
                                                               
                                                               
   2.11.5. .STACK                                              
                                                               
                                                               
Syntax:                                                        
            .STACK [size]                                      
                                                               
                                                               
   Defines the program stack segment (STACK) and ends  previous
segment, if any. The .MODEL directive must have previously been
used. You should generally not place any code or data  in  this
segment; the processor uses the stack  segment  to  store  data
during procedure and interrupt calls.                          
   The .MODEL directive generates a GROUP statement that places
the STACK segment in DGROUP, unless the farStack  attribute  is
given.                                                         
                                                               
                                                               
size                                                           
            Optional; specifies size of the stack in bytes.  If
            none is given, the default is 1024.                
                                                               
                                                               
See Also:                                                      
            .DATA, .DATA?, .FARDATA, .MODEL, .CONST            
                                                               
                                                               
                                                               
   2.11.6. .DATA                                               
                                                               
                                                               
Syntax:                                                        
            .DATA                                              
                                                               
                                                               
   Starts  the  initialized  data  segment  (_DATA)  and   ends
previous segment,  if  any.  The  .MODEL  directive  must  have
previously been used. This segment should  contain  all  global
data that have initial values.                                 
   The .MODEL directive generates a GROUP statement that places
_DATA in DGROUP.                                               
                                                               
                                                               
See Also:                                                      
            .FARDATA, .MODEL, .CONST, .STACK                   
                                                               
                                                               
                                                               
                                                               
                                                               
                      Directive Summary                        
   2.11.7. .DATA?                                              
Syntax:                                                        
            .DATA?                                             
   Starts  the  uninitialized  data  segment  (_BSS)  and  ends
previous segment,  if  any.  The  .MODEL  directive  must  have
previously been used. This segment should  contain  all  global
data that have no initial values.                              
   Although uninitialized data  can  be  placed  in  the  .DATA
segment, use of .DATA? is recommended for maximum compatability
with high-level languages.                                     
   The .MODEL directive generates a GROUP statement that places
_DATA in DGROUP.                                               
See Also:                                                      
            .MODEL                                             
   2.11.8. .CONST                                              
Syntax:                                                        
            .CONST                                             
   Starts a constant data segment (with segment name CONST) and
ends previous segment, if any. The .MODEL directive  must  have
previously been used. This segment should contain strings, real
numbers, and other constant data that  may  be  accessed  by  a
high-level language.                                           
   The .MODEL directive generates a GROUP statement that places
CONST in DGROUP.                                               
See Also:                                                      
            .MODEL, .STACK, .DATA                              
   2.11.9. .FARDATA                                            
Syntax:                                                        
            .FARDATA [name]                                    
   Starts a far-data segment for initialized data (segment name
FAR_DATA or name) ending previous segment, if any.  The  .MODEL
directive must have previously  been  used.  Data  in  segments
defined with .FARDATA is not placed in a group or combined with
.FARDATA segments for other source modules.                    
name                                                           
            A unique  segment  name.  This  optional  parameter
            allows you to  create  multiple  far-data  segments
            within a source module.                            
                      Directive Summary                        
                                                               
                                                               
See Also:                                                      
            .DATA, .MODEL                                      
                                                               
                                                               
                                                               
   2.11.10. .FARDATA?                                          
                                                               
                                                               
Syntax:                                                        
            .FARDATA? [name]                                   
                                                               
                                                               
   Starts a far-data segment for  uninitialized  data  (segment
name FAR_BSS or name) ending  previous  segment,  if  any.  The
.MODEL directive  must  have  previously  been  used.  Data  in
segments defined with .FARDATA? is not placed  in  a  group  or
combined with .FARDATA? segments for other source modules.     
                                                               
                                                               
name                                                           
            A unique  segment  name.  This  optional  parameter
            allows you to  create  multiple  far-data  segments
            within a source module.                            
                                                               
                                                               
See Also:                                                      
            .DATA, .MODEL                                      
                                                               
                                                               
                                                               
   2.12. Record and Structure Directives                       
                                                               
                                                               
   A record consists of bit fields. A structure is a collection
of any series of data types and can include other structures.  
                                                               
                                                               
Mnemonic                                                       
            Description                                        
RECORD                                                         
            Declares a  record  type  consisting  of  specified
            fields                                             
STRUC                                                          
            Declares a structure type having specified fields  
ENDS                                                           
            Ends a structure definition                        
                                                               
                                                               
                                                               
   2.12.1. RECORD                                              
                                                               
                                                               
Syntax:                                                        
            recordname RECORD field [,field]...                
                                                               
                                                               
   Declares a record  type  consisting  of  the  specified  bit
fields. Multiple fields must be separated by a comma.  The  sum
of the widths for all fields must not exceed 16 bits.          
                                                               
                                                               
recordname                                                     
                      Directive Summary                        
            A unique symbolic name.                            
field                                                          
            Each field has the following form, in  which  width
            is a constant giving the  number  of  bits  in  the
            field, and expression optionally sets an initial or
            default value.                                     
            fieldname:width[= expression]                      
See Also:                                                      
            STRUC, MASK, WIDTH                                 
   2.12.2. STRUC                                               
Syntax:                                                        
            name STRUC                                         
            fielddeclarations                                  
            name ENDS                                          
   Declares  a  structure  as  a  new  data  type.  Conditional
assembly blocks and comments are  legal,  but  not  nesting  of
other structures.                                              
name                                                           
            A unique symbolic name;  represents  the  structure
            type. Structure variables can then be defined.     
fielddeclarations                                              
            Any valid data definitions (using  DB,  DW,  etc.).
            Initializers specify default values.               
   Once a structure type is declared, you can use it to  define
variables, in which each  field  not  initialized  assumes  the
default value:                                                 
[name] structuretype <[initializer [,initializer]...>          
See Also:                                                      
            RECORD, ENDS                                       
   2.12.3. ENDS                                                
Syntax:                                                        
            name ENDS                                          
   Marks the  end  of  a  segment  name  or  a  structure  name
previously begun with SEGMENT or STRUC.                        
See Also:                                                      
            SEGMENT, STRUC                                     
                       Operator Summary                        
                                                               
                                                               
                      3. Operator Summary                      
                                                               
                                                               
Category                                                       
            Description                                        
Arithmetic                                                     
            Perform arithmetic calculations at assemble time   
Macro                                                          
            Alter evaluation within a macro definition         
Logical and shift                                              
            Perform logic calculations at assemble time        
Record                                                         
            Generate bit mask or determine size of record      
Type                                                           
            Specify or analyze type of a variable              
Address                                                        
            Extract segment or offset address                  
Relational                                                     
            Compare two values at assemble time                
Miscellaneous                                                  
            Comment and DUP (repeated initial values)          
                                                               
                                                               
                                                               
   3.1. Arithmetic Operator Summary                            
                                                               
                                                               
+                                                              
            Addition                                           
-                                                              
            Subtraction                                        
*                                                              
            Multiplication                                     
/                                                              
            Division                                           
MOD                                                            
            Modular division                                   
.                                                              
            Field operator                                     
[]                                                             
            Index operator                                     
                                                               
                                                               
                                                               
   3.1.1. + (Plus, Binary)                                     
                                                               
                                                               
Syntax:                                                        
            expression1 + expression2                          
                                                               
                                                               
   Plus   (binary).   Returns   value   of   expression1   plus
expression2.                                                   
                                                               
                                                               
expression                                                     
            An integer constant or memory operand.  The  result
            can be used as a memory operand.                   
                                                               
                                                               
See Also:                                                      
            minus (-)                                          
                       Operator Summary                        
   3.1.2. + (Plus, Unary)                                      
Syntax:                                                        
            +expression                                        
   Plus (unary). Designates a positive number. Has higher level
of precedence than the binary (addition) plus.                 
expression An integer constant.                                
See Also:                                                      
            minus (-)                                          
   3.1.3. - (Minus, Binary)                                    
Syntax:                                                        
            expression1 - expression2                          
   Binary   minus.   Returns   value   of   expression1   minus
expression2. Has lower precedence  than  the  unary  (negative)
minus. Can be used to subtract one memory operand from another,
but only if the operands refer to  locations  within  the  same
segment. The result is a constant.                             
expression An integer constant or memory  operand.  The  result
can be used as a memory operand.                               
See Also:                                                      
            plus (+)                                           
   3.1.4. - (Minus, Unary)                                     
Syntax:                                                        
            -expression                                        
   Unary minus. Reverses sign of expression. Has  higher  level
of precedence than the binary (subtraction) minus.             
expression                                                     
            An integer constant.                               
See Also:                                                      
            plus (+)                                           
                       Operator Summary                        
                                                               
                                                               
   3.1.5. * (Multiplication)                                   
                                                               
                                                               
Syntax:                                                        
            expression1 * expression2                          
                                                               
                                                               
   Multiplication operator. Returns product of two expressions.
                                                               
                                                               
expression1                                                    
            Must be an integer constant.                       
expression2                                                    
            Must be an integer constant.                       
                                                               
                                                               
See Also:                                                      
            slash (/)                                          
                                                               
                                                               
                                                               
   3.1.6. / (Division)                                         
                                                               
                                                               
Syntax:                                                        
            expression1 / expression2                          
                                                               
                                                               
   Integer division. Returns quotient of expression1 divided by
expression2.                                                   
                                                               
                                                               
expression                                                     
            An integer constant.                               
                                                               
                                                               
See Also:                                                      
            asterisk (*)                                       
                                                               
                                                               
                                                               
   3.1.7. MOD                                                  
                                                               
                                                               
Syntax:                                                        
            expression1 MOD expression2                        
                                                               
                                                               
   Returns the remainder (modulus) of dividing  expression1  by
expression2.                                                   
                                                               
                                                               
expression1                                                    
            Must be an integer constant.                       
expression2                                                    
            Must be an integer constant.                       
                                                               
                                                               
See Also:                                                      
            slash (/)                                          
                                                               
                                                               
                       Operator Summary                        
   3.1.8. . (Structure-Field Reference)                        
Syntax:                                                        
            variable.field                                     
   Returns the offset of field plus  the  offset  of  variable.
This operator is normally used to access a field of data within
a structure variable.                                          
variable                                                       
            A previously defined data item; usually a structure
            variable.                                          
field                                                          
            A field within a previously defined structure type.
            Each such field has an offset from the beginning of
            the structure.                                     
See Also:                                                      
            STRUC                                              
   3.1.9. [] (Index Operator)                                  
Syntax:                                                        
            expression1[expression2]                           
            [expression2]                                      
   In the syntax above, the brackets  are  intended  literally.
The expression outside the brackets is optional.               
   The brackets (also called the "index operator")  return  the
sum of expression1 and expression2. If expression  in  brackets
is a register, then the brackets indicate  an  indirect  memory
operand rather than a register-direct operand.                 
   Two direct memory operands cannot be added.  Typically,  the
expression outside the brackets is an array  address,  and  the
expression inside is an offset to an array element  (always  in
terms of bytes).                                               
See Also:                                                      
            plus (+), period (.)                               
   3.2. Macro Operator Summary                                 
<>                                                             
            Literal-text operator                              
!                                                              
            Literal-character operator                         
;;                                                             
            Macro comment (is not expanded in macro call)      
%                                                              
            Expression operator                                
                       Operator Summary                        
                                                               
                                                               
&                                                              
            Substitute operator                                
                                                               
                                                               
                                                               
   3.2.1. <> (Literal Text Operator)                           
                                                               
                                                               
Syntax:                                                        
            <text>                                             
                                                               
                                                               
   Treats text in a macro argument as a single literal  string.
Most often used in macro calls and with the  IRP  directive  to
ensure that values in a parameter list are treated as a  single
parameter. The assembler removes one set of angle brackets each
time it inserts an argument into a macro expansion.            
                                                               
                                                               
text                                                           
            Any  name,  number,  or  expression.  Can   contain
            commas, spaces, tabs, or semicolons.               
                                                               
                                                               
See Also:                                                      
            EQU, IRP, exclamation (!)                          
                                                               
                                                               
                                                               
   3.2.2. ! (Literal Character Operator)                       
                                                               
                                                               
Syntax:                                                        
            !character                                         
                                                               
                                                               
   Treats character in a macro argument as a literal  character
rather than  as  an  operator  or  symbol.  Used  with  special
characters such as the semicolon or ampersand  when  the  usual
assembly language meaning of the character must be  suppressed.
                                                               
                                                               
See Also:                                                      
            anglebrackets (<>)                                 
                                                               
                                                               
                                                               
   3.2.3. ;; (Macro Comment Delimeter)                         
                                                               
                                                               
Syntax:                                                        
            ;;text                                             
                                                               
                                                               
   Treats text to end of line as a macro comment.  The  comment
appears  in  the  macro  definition,  but  not  in   statements
generated by macro expansion.                                  
                                                               
                                                               
See Also:                                                      
            COMMENT, semicolon (;)                             
                                                               
                       Operator Summary                        
   3.2.4. % (Expression Operator)                              
Syntax:                                                        
            %text                                              
   Treats  text  in  macro  argument  as  an  expression.   The
assembler computes the expression's  value  and  replaces  text
with the result. Used in macro calls when the programmer  needs
to pass the result of an  expression  rather  than  the  actual
expression to a macro.                                         
   When placed at beginnning of the line, % causes substitution
of all text macros on that line.                               
text                                                           
            Can be  either  a  numeric  expression  or  a  text
            equate.                                            
See Also:                                                      
            ampersand (&)                                      
   3.2.5. & (Substitute Operator)                              
Syntax:                                                        
            parm1&parm2                                        
            &parm                                              
            parm&                                              
   Used within a  macro  or  repeat  block;  enables  parameter
substitution to take  place  for  both  parm1  and  parm2.  The
resulting strings are then joined together to form one  symbol.
You can join any number of strings with &.  This  operator  can
also be used to force parameter substitution  within  a  quoted
string.                                                        
See Also:                                                      
            percent (%)                                        
   3.3. Logic/Shift Operator Summary                           
AND                                                            
            Bitwise AND                                        
OR                                                             
            Bitwise inclusive OR                               
XOR                                                            
            Bitwise exclusive OR                               
NOT                                                            
            Logical negation of each bit                       
SHL                                                            
            Shift bits left                                    
SHR                                                            
            Shift bits right                                   
                       Operator Summary                        
                                                               
                                                               
   3.3.1. AND                                                  
                                                               
                                                               
                                                               
Logical AND                          Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  AND dest,src                        0       * * ? * 0 
                                                               
   Performs a bitwise logical AND on the source and destination
operands and stores the result in the destination operand.  For
each bit position in the operands, if both bits are  set,  then
the corresponding bit of the  result  is  set.  Otherwise,  the
corresponding bit of the result is cleared.                    
                                                               
 001000dw     mod,reg,r/m       disp (0 or 2)                  
--------------+------------------------+-----------------------
 AND  reg,reg | and   dx,bx            | 88/86 3               
              |                        | 286   2               
              |                        | 386   2               
--------------+------------------------+-----------------------
 AND  mem,reg | and   bitmask,bx       | 88/86 16+EA (W88=24+EA
              | and   [bp+2],dx        | 286   7               
              |                        | 386   7               
--------------+------------------------+-----------------------
 AND  reg,mem | and   bx,masker        | 88/86 9+EA (W88=13+EA)
              | and   dx,marray[bx+di] | 286   7               
              |                        | 386   6               
--------------+------------------------+-----------------------
 100000sw     mod,100,r/m       disp (0 or 2)     data (1 or 2)
---------------+---------------------+-------------------------
 AND  reg,immed| and   dx,0F7h       | 88/86 4                 
               |                     | 286   3                 
               |                     | 386   2                 
---------------+---------------------+-------------------------
 AND  mem,immed| and   masker,1001b  | 88/86 17+EA (W88=23+EA) 
               |                     | 286   7                 
               |                     | 386   7                 
---------------+---------------------+-------------------------
 0010010w     data (1 or 2)                                    
-------------------+-------------------------+-----------------
 AND  accum,immed  | and   ax,0B6h           | 88/86     4     
                   |                         | 286       3     
                   |                         | 386       2     
-------------------+-------------------------+-----------------
                                                               
                                                               
                                                               
   3.3.2. OR                                                   
                                                               
                                                               
                                                               
Inclusive OR                         Flags:  O D I T S Z A P C 
                                             ----------------- 
                                             0       * * ? * 0 
Syntax:  OR dest,src                                           
                                                               
   Performs a bitwise logical OR on the source and  destination
operands and stores the result to the destination operand.  For
each bit position in the operands, if either or both  bits  are
set, the corresponding bit of the result it set. Otherwise, the
corresponding bit of the result is cleared.                    
                       Operator Summary                        
 000010dw    mod, reg, r/m      disp (0 or 2)                  
--------------+---------------------+--------------------------
 OR  reg,reg  | or    ax,dx         | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 OR  mem,reg  | or    [bp+6],cx     | 88/86 16+EA (W88=24+EA)  
              | or    bits,dx       | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
 OR  reg,mem  | or    bx,masker     | 88/86 9+EA (W88=13+EA)   
              | or    dx,color[di]  | 286   7                  
              |                     | 386   6                  
--------------+---------------------+--------------------------
 100000sw    mod,001, r/m       disp (0 or 2)     data (1 or 2)
--------------+---------------------+--------------------------
 OR  reg,immed| or    dx,110110b    | 88/86 4                  
              |                     | 286   3                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 OR  mem,immed| or    flag_rec,8    | 88/86 (b=17,w=25)+EA     
              |                     | 286   7                  
              |                     | 386   7                  
--------------+---------------------+--------------------------
 0000110w    data (1 or 2)                                     
------------------+-------------------------+------------------
 OR  accum,immed  | or    ax,40h            | 88/86 4          
                  |                         | 286   3          
                  |                         | 386   2          
------------------+-------------------------+------------------
   3.3.3. XOR                                                  
Exclusive OR                         Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  XOR dest,src                        0       * * ? * 0 
   Performs  a  bitwise  exclusive  OR  on   the   source   and
destination operands and stores the result to the  destination.
For each bit position in the operands, if both bits are set  or
if both bits are cleared, the corresponding bit of  the  result
is cleared. Otherwise, the corresponding bit of the  result  is
set.                                                           
 001100dw    mod,reg,r/m      disp (0 or 2)                    
-------------+-------------------------+-----------------------
 XOR  reg,reg| xor    cx,bx            | 88/86 3               
             | xor    ah,al            | 286   2               
             |                         | 386   2               
-------------+-------------------------+-----------------------
 XOR  mem,reg| xor    [bp+10],cx       | 88/86 16+EA (W88=24+EA
             | xor    masked,bx        | 286   7               
             |                         | 386   6               
-------------+-------------------------+-----------------------
 XOR  reg,mem| xor    cx,flags         | 88/86 9+EA (W88=13+EA)
             | xor    bl,bitarray[di]  | 286   7               
             |                         | 386   7               
-------------+-------------------------+-----------------------
                       Operator Summary                        
                                                               
                                                               
 100000sw    mod,110,r/m      disp (0 or 2)     data (1 or 2)  
-----------------+----------------------+----------------------
 XOR  reg,immed  | xor bx,10h           | 88/86 4              
                 | xor bl,1             | 286   3              
                 |                      | 386   2              
-----------------+----------------------+----------------------
 XOR  mem,immed  | xor Boolean,1        | 88/86 17+EA (W88=25+E
                 | xor switches[bx],101b| 286   7              
                 |                      | 386   7              
-----------------+----------------------+----------------------
 0011010w    data (1 or 2)                                     
-----------------+---------------------+-----------------------
 XOR  accum,immed| xor    ax,01010101b | 88/86 4               
                 |                     | 286   3               
                 |                     | 386   2               
-----------------+---------------------+-----------------------
                                                               
                                                               
                                                               
   3.3.4. NOT                                                  
                                                               
                                                               
One's Complement Negation            Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  NOT dest                                              
                                                               
   Toggles each bit of the operand by  clearing  set  bits  and
setting cleared bits.                                          
                                                               
 1111011w    mod, 010,r/m      disp (0 or 2)                   
--------------+---------------------+--------------------------
 NOT  reg     | not   ax            | 88/86 3                  
              |                     | 286   2                  
              |                     | 386   2                  
--------------+---------------------+--------------------------
 NOT  mem     | not   masker        | 88/86 16+EA (W88=24+EA)  
              |                     | 286   7                  
              |                     | 386   6                  
--------------+---------------------+--------------------------
                                                               
                                                               
                                                               
   3.3.5. SAL/SAR/SHL/SHR                                      
                                                               
                                                               
Shift                                Flags:  O D I T S Z A P C 
                                             ----------------- 
Syntax:  SHL dest,1                          *       * * ? * * 
         SHL dest,CL                                           
         SHL dest,number (80186/286/386 Only)                  
                                                               
   Shifts the bits in the destination  operand  the  number  of
times specified by the source operand. SAL and  SHL  shift  the
bits left; SAR and SHR shift right.                            
   With SHL, SAL, and SHR, the bit shifted off the end  of  the
operand is copied into the  carry  flag  and  the  leftmost  or
rightmost bit opened by the shift is set to 0.  With  SAR,  the
bit shifted off the end of the operand is copied into the carry
flag and the leftmost bit  opened  by  the  shift  retains  its
previous value (thus preserving the sign of the  operand).  SAL
and SHL are synonyms; they have the same effect.               
   On the 8088 and 8086, the source operand can be either CL or
                                                               
                       Operator Summary                        
1. On the 80186-80386 processors, the source operand can be  CL
or an 8-bit constant.  On  the  80186-80386  processors,  shift
counts larger than 31 are masked off, but on the 8088 and 8086,
larger shift counts  are  performed  despite  the  inefficiency
involved. The overflow flag  is  only  modified  by  single-bit
variations of the instruction; for multiple-bit  variations  it
is undefined.                                                  
 1101000w     mod,TTT*,r/m      disp (0 or 2)                  
  * TTT represents one of the following bit codes:             
    100 for SHL or SAL,                                        
    101 for SHR, or 111 for SAR.                               
-------------+--------------------------+----------------------
 SAR  reg,1  | sar    di,1              | 88/86 2              
             | sar    cl,1              | 286   2              
             |                          | 386   3              
-------------+--------------------------+----------------------
 SAL  reg,1  | shr    dh,1              | 88/86 2              
 SHL  reg,1  | shl    si,1              | 286   2              
 SHR  reg,1  | sal    bx,1              | 386   3              
-------------+--------------------------+----------------------
 SAR  mem,1  | sar    count,1           | 88/86 15+EA (W88=23+E
             |                          | 286   7              
             |                          | 386   7              
-------------+--------------------------+----------------------
 SAL  mem,1  | sal    WORD PTR m32[0],1 | 80/86 15+EA (W88=23+E
 SHL  mem,1  | shl    index,1           | 286   7              
 SHR  mem,1  | shr    unsign[di],1      | 386   7              
-------------+--------------------------+----------------------
 1101001w     mod,TTT*,r/m      disp (0 or 2)                  
  *TTT represents one of the following bit codes:              
   100 for SHL or SAL, 101                                     
   for SHR,  or 111 for SAR.                                   
-------------+---------------------------+---------------------
 SAR  reg,CL | sar    bx,cl              | 88/86 8+4n          
             | sar    dx,cl              | 286   5+n           
             |                           | 386   3             
-------------+---------------------------+---------------------
 SAL  reg,CL | shr    dx,cl              | 88/86 8+4n          
 SHL  reg,CL | shl    di,cl              | 286   5+n           
 SHR  reg,CL | sal    ah,cl              | 386   3             
-------------+---------------------------+---------------------
 SAR  mem,CL | sar    sign,cl            | 88/86 20+EA+4n      
             |                           | (W88=28+EA+4n)      
             | sar    WORD PTR [bp+8],cl | 286   8+n           
             |                           | 386   7             
-------------+---------------------------+---------------------
 SAL  mem,CL | shr    WORD PTR m32[2],cl | 88/86 20+EA+4n      
             |                           | (W88=28+EA+4n)      
 SHL  mem,CL | sal    BYTE PTR [di],cl   | 286   8+n           
 SHR  mem,CL | shl    index,cl           | 386   7             
-------------+---------------------------+---------------------
                       Operator Summary                        
                                                               
                                                               
 11000000w    mod,TTT*,r/m      disp (0 or 2)     data (1)     
                                                               
  *TTT represents one of the following bit codes:              
   100 for SHL or SAL,                                         
   101 for SHR,  or 111 for SAR.                               
-----------------+-----------------------+---------------------
 SAR  reg,immed8 | sar    bx,5           | 88/86 -             
                 | sar    cl,5           | 286   5+n           
                 |                       | 386   3             
-----------------+-----------------------+---------------------
 SAL  reg,immed8 | sal    cx,6           | 88/86 -             
 SHL  reg,immed8 | shl    di,2           | 286   5+n           
 SHR  reg,immed8 | shr    bx,8           | 386   3             
-----------------+-----------------------+---------------------
 SAR  mem,immed8 | sar    sign_count,3   | 88/86 -             
                 | sar    WORD PTR [bx],5| 286   8+n           
                 |                       | 386   7             
-----------------+-----------------------+---------------------
 SAL  mem,immed8 | shr    mem16,11       | 88/86 -             
 SHL  mem,immed8 | shl    unsign,4       | 286   8+n           
 SHR  mem,immed8 | sal    array[bx+di],14| 386   7             
-----------------+-----------------------+---------------------
                                                               
                                                               
                                                               
   3.4. Record Operator Summary                                
                                                               
                                                               
MASK                                                           
            Constructs bit mask                                
WIDTH                                                          
            Returns width of record                            
                                                               
                                                               
                                                               
   3.4.1. MASK                                                 
                                                               
                                                               
Syntax:                                                        
            MASK {recordfieldname|record}                      
                                                               
                                                               
   Returns a bit  mask  for  the  bit  positions  in  a  record
occupied by the given record field. A bit in the mask  contains
a 1 if that bit corresponds to a  field  bit.  All  other  bits
contain 0.                                                     
                                                               
                                                               
recordfieldname                                                
            The name of  any  field  in  a  previously  defined
            record.                                            
record                                                         
            The name of any previously defined record.         
                                                               
                                                               
See Also:                                                      
            WIDTH, NOT, RECORD                                 
                                                               
                                                               
                                                               
                       Operator Summary                        
   3.4.2. WIDTH                                                
Syntax:                                                        
            WIDTH {recordfieldname|record}                     
   Returns width (in bits) of a record  or  record  field.  The
width of a field is the number of bits assigned for that field;
the value of the field  is  the  starting  position  (from  the
right) of the field.                                           
recordfieldname                                                
            The name of any field defined in any record.       
record                                                         
            Any defined record.                                
See Also:                                                      
            MASK, RECORD                                       
   3.5. Type Operator Summary                                  
HIGH                                                           
            Returns high byte                                  
LOW                                                            
            Returns low byte                                   
PTR                                                            
            Temporarily alters type of data                    
SHORT                                                          
            Specifies SHORT (* 128 bytes)                      
SIZE                                                           
            Returns size of type                               
THIS                                                           
            Creates symbol of specified type                   
TYPE                                                           
            Returns number of bytes in variable                
.TYPE                                                          
            Returns a byte giving information on variable      
   3.5.1. HIGH                                                 
Syntax:                                                        
            HIGH expression                                    
   Returns high-order (most significant)  byte  of  expression.
Cannot be used on  contents  of  a  memory  operand  or  on  an
address.                                                       
expression                                                     
            Must evaluate to a constant value.                 
                       Operator Summary                        
                                                               
                                                               
See Also:                                                      
            LOW                                                
                                                               
                                                               
                                                               
   3.5.2. LOW                                                  
                                                               
                                                               
Syntax:                                                        
            LOW expression                                     
                                                               
                                                               
   Returns low-order byte of  expression.  Cannot  be  used  on
contents of a memory operand or on an address.                 
                                                               
                                                               
expression                                                     
            Must evaluate to a constant.                       
                                                               
                                                               
See Also:                                                      
            HIGH                                               
                                                               
                                                               
                                                               
   3.5.3. PTR                                                  
                                                               
                                                               
Syntax:                                                        
            type PTR expression                                
                                                               
                                                               
   Treats expression as having the specified  type.  Used  with
forward references to define explicitly what size or distance a
reference has. Also  used  to  enable  instructions  to  access
variables that would otherwise generate errors.                
   The PTR keyword can also appear in the argument  list  of  a
PROC statement, to indicate that the  parameter  is  a  pointer
variable.                                                      
                                                               
                                                               
type                                                           
            For memory operands,  can  be  BYTE,  WORD,  DWORD,
            QWORD, TBYTE. For labels,  can  be  NEAR,  FAR,  or
            PROC.                                              
expression                                                     
            Any operand.                                       
                                                               
                                                               
See Also:                                                      
            TYPE, THIS                                         
                                                               
                                                               
                                                               
   3.5.4. SHORT                                                
                                                               
                                                               
Syntax:                                                        
            SHORT label                                        
                                                               
                                                               
   Sets label type to SHORT. Short labels can be  used  in  JMP
                                                               
                       Operator Summary                        
instructions when the distance is less than 128 bytes from  the
start of the next instruction. Instructions using short  labels
are a  byte  smaller  than  identical  instructions  using  the
default near labels.                                           
See Also:                                                      
            JMP                                                
   3.5.5. SIZE                                                 
Syntax:                                                        
            SIZE variable                                      
   Returns the total number of bytes allocated for variable  if
variable was defined with the DUP operator. The returned  value
is equal to the value of LENGTH variable  times  the  value  of
TYPE variable.                                                 
   If the variable was not declared with the DUP operator,  the
value returned is the same as TYPE variable;  it  simply  gives
the number of bytes in the data type.                          
variable                                                       
            Array or other variable.                           
See Also:                                                      
            DUP, LENGTH, TYPE                                  
   3.5.6. THIS                                                 
Syntax:                                                        
            THIS type                                          
   Creates an operand of specified type with offset and segment
values equal to the current location-counter value.  Used  with
EQU or = to create labels and variables.                       
type                                                           
            For memory operands,  can  be  BYTE,  WORD,  DWORD,
            QWORD, or TBYTE. For labels, can be NEAR,  FAR,  or
            PROC.                                              
See Also:                                                      
            EQU, equalsign (=), LABEL                          
                       Operator Summary                        
                                                               
                                                               
   3.5.7. TYPE                                                 
                                                               
                                                               
Syntax:                                                        
            TYPE expression                                    
                                                               
                                                               
   Returns a different result depending on type of  expression:
                                                               
                                                               
Expression                                                     
            TYPE Operator returns                              
variable                                                       
            Number of bytes in data object.                    
structure                                                      
            Total size in bytes of the structure.              
label                                                          
            0FFFFh=NEAR label, 0FFFEh=FAR label.               
constant                                                       
            0.                                                 
                                                               
                                                               
   The returned value can be used to specify the type for  PTR.
                                                               
                                                               
See Also:                                                      
            PTR                                                
                                                               
                                                               
                                                               
   3.5.8. .TYPE                                                
                                                               
                                                               
Syntax:                                                        
            .TYPE expression                                   
                                                               
                                                               
   Returns a byte defining the mode and scope of expression. If
expression is not valid, a 0  is  returned.  If  expression  is
valid, a byte is  returned  in  which  the  contents  mean  the
following:                                                     
                                                               
  Bit position   Bit Value = 0         Bit Value = 1           
                                                               
       0         Not program related   Program related         
       1         Not data related      Data related            
       2         Not a consant         Constant value          
       3         Addressing mode is    Addressing mode is direc
                  not direct                                   
       4         Not a register        Expression is a register
       5         Not defined           Defined                 
       7         Local/public scope    External scope          
                                                               
                                                               
                                                               
See Also:                                                      
            MACRO                                              
                                                               
                                                               
                                                               
                                                               
                                                               
                       Operator Summary                        
   3.6. Address Operator Summary                               
SEG                                                            
            Returns segment of object in memory                
OFFSET                                                         
            Returns offset of object in memory                 
   3.6.1. SEG                                                  
Syntax:                                                        
            SEG expression                                     
   Returns the segment  address  of  expression.  The  returned
value can be used as a memory operand.                         
expression                                                     
            Any label, variable, segment name, group  name,  or
            other memory operand. Cannot be a constant.        
See Also:                                                      
            OFFSET                                             
   3.6.2. OFFSET                                               
Syntax:                                                        
            OFFSET expression                                  
   Returns offset address of expression (usually  a  variable).
The value returned by  the  OFFSET  operator  is  an  immediate
operand.                                                       
   If you use simplified segment directives, then the offset of
an item in one of the near data segments (DATA,  STACK,  CONST)
is calculated relative to the beginning of  DGROUP,  the  group
containing  all  these  segments.  If  you  give  full  segment
definitions, the returned value is a memory  operand  equal  to
the number of bytes between the item and the beginning  of  the
segment in which it is defined.                                
expression                                                     
            Any  label,  variable,  or  other   direct   memory
            operand.                                           
See Also:                                                      
            : (segment-override)                               
                       Operator Summary                        
                                                               
                                                               
   3.7. Relational Operator Summary                            
                                                               
                                                               
   These   operators    are    typically    used    with    the
conditional-assembly IF statement and return Boolean results.  
                                                               
                                                               
EQ                                                             
            Equal                                              
NE                                                             
            Not Equal                                          
GT                                                             
            Greater Than                                       
GE                                                             
            Greater Than or Equal to                           
LT                                                             
            Less Than                                          
LE                                                             
            Less Than or Equal to                              
                                                               
                                                               
                                                               
               3.7.1. EQ                                       
                                                               
                                                               
Syntax:                                                        
            expression1 EQ expression2                         
                                                               
                                                               
   Verifies equality. Returns true (-1) if  expression1  equals
expression2, or false (0) if it does not. Typically  used  with
conditional directives.                                        
expression1                                                    
            Must evaluate to a constant value.                 
expression2                                                    
            Must evaluate to a constant value.                 
                                                               
                                                               
See Also:                                                      
            equalsign (=), NE, LT, LE, GT, GE                  
                                                               
                                                               
                                                               
               3.7.2. NE                                       
                                                               
                                                               
Syntax:                                                        
            expression1 NE expression2                         
                                                               
                                                               
   Returns true (-1) if expression1 does not equal expression2,
or  returns  false  (0)  if  it  does.  Typically   used   with
conditional directives.                                        
                                                               
                                                               
expression1                                                    
            Must evaluate to a constant value.                 
expression2                                                    
            Must evaluate to a constant value.                 
                                                               
                                                               
See Also:                                                      
                       Operator Summary                        
            EQ, LT, LE, GT, GE                                 
               3.7.3. GT                                       
Syntax:                                                        
            expression1 GT expression2                         
   Returns  true  (-1)   if   expression1   is   greater   than
expression2, or returns false (0) if it is not. Typically  used
with conditional directives.                                   
expression1                                                    
            Must evaluate to a constant value.                 
expression2                                                    
            Must evaluate to a constant value.                 
See Also:                                                      
            EQ, NE, LT, LE, GE                                 
               3.7.4. GE                                       
Syntax:                                                        
            expression1 GE expression2                         
   Returns true (-1) if expression1 is greater than or equal to
expression2, or returns false (0) if it is not. Typically  used
with conditional directives.                                   
expression1                                                    
            Must evaluate to a constant value.                 
expression2                                                    
            Must evaluate to a constant value.                 
See Also:                                                      
            EQ, NE, LT, LE, GT                                 
               3.7.5. LT                                       
Syntax:                                                        
            expression1 LT expression2                         
   Returns true (-1) if expression1 is less  than  expression2,
or returns  false  (0)  if  it  is  not.  Typically  used  with
conditional directives.                                        
expression1                                                    
            Must evaluate to a constant value.                 
                       Operator Summary                        
                                                               
                                                               
expression2                                                    
            Must evaluate to a constant value.                 
                                                               
                                                               
See Also:                                                      
            EQ, NE, LE, GT, GE                                 
                                                               
                                                               
                                                               
               3.7.6. LE                                       
                                                               
                                                               
Syntax:                                                        
            expression1 LE expression2                         
                                                               
                                                               
   Returns true (-1) if expression1 is less than  or  equal  to
expression2, or false (0) if it is  not.  Typically  used  with
conditional directives.                                        
                                                               
                                                               
expression1                                                    
            Must evaluate to a constant value.                 
expression2                                                    
            Must evaluate to a constant value.                 
                                                               
                                                               
See Also:                                                      
            EQ, NE, LT, GT, GE                                 
                                                               
                                                               
                                                               
   3.8. Miscellaneous Operator Summary                         
                                                               
                                                               
;                                                              
            Comment (not assembled)                            
DUP                                                            
            Repeat initialization values                       
?                                                              
            Uninitialized value                                
\                                                              
            Line continuation                                  
$                                                              
            Current location indicator                         
                                                               
                                                               
                                                               
   3.8.1. ; (Comment Delimeter)                                
                                                               
                                                               
Syntax:                                                        
            ;text                                              
                                                               
                                                               
   Treats text to end of line as a comment.  The  comment  must
follow all other fields in the statement.                      
                                                               
                                                               
See Also:                                                      
            COMMENT, semicolons (;;)                           
                                                               
                       Operator Summary                        
   3.8.2. DUP                                                  
Syntax:                                                        
            count DUP (initialvalue [,initialvalue]...)        
   Defines  data  structures.  Specifies  (count)   number   of
declarations of initialvalue. Arrays, buffers, and  other  data
structures consisting of multiple data objects of the same size
can be defined with the DUP operator. Creates  an  operand  for
use with data-definition directives.                           
   DUP operators can be nested up to 17 levels.                
count                                                          
            Number of declarations of initialvalue.            
initialvalue                                                   
            The undefined symbol (?), another DUP operator,  or
            expression that evaluates to an  integer  value  or
            character constant. Multiple initial values must be
            separated by commas.                               
See Also:                                                      
            DB, DW, DD, DT, DQ                                 
   3.8.3. ? (Uninitialized Value)                              
Syntax:                                                        
            ?                                                  
   Used as an initializer in  data  declarations;  indicates  a
value that the assembler allocates but does not initialize. Can
be used alone or with DUP, as in the following examples:       
   foo      DW      ?           ; Allocate one uninitialized wo
   foo2     DB      ?,?,?       ; Allocate three uninitialized 
   foo3     DB      20 DUP (?)  ; Allocate 20 uninitialized byt
   3.8.4. \ (Line Continutation)                               
Syntax:                                                        
            text \                                             
            text                                               
   Enables an assmebly-language statement to continue  to  next
line, so that the line-break is ignored. Any  number  of  lines
can be joined with this method. A backslash is not considered a
line-continuation character if it occurs inside a comment.     
                      Predefined Equates                       
                                                               
                                                               
                     4. Predefined Equates                     
                                                               
                                                               
   Each of the following predefined equates has  its  own  help
topic:                                                         
                                                               
       @code              @CodeSize            @Cpu            
       @CurSeg            @data                @DataSize       
       @FileName          @Model               @Version        
       @WordSize                                               
                                                               
   In addition to these equates, each of the  other  simplified
segment  directives  (.CONST,  .STACK,  .DATA?,  .FARDATA,  and
.FARDATA?) has a corresponding equate. For example, @fardata is
an equate giving the segment address generated by the  .FARDATA
directive.                                                     
                                                               
                                                               
                                                               
   4.1. @code                                                  
                                                               
                                                               
Syntax:                                                        
            @code                                              
   Predefined equate representing the segment name  defined  by
.CODE; Can be used in ASSUME statements or any place a  segment
name would be valid.                                           
                                                               
                                                               
See Also:                                                      
            @CodeSize, @data                                   
                                                               
                                                               
                                                               
   4.2. Vector                                                 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                      Predefined Equates                       
;* Vector - Macro to read current interrupt vector,            
;* store it, and replace it.                                   
;*                                                             
;* Shows:   Equates - @CodeSize     @code                      
;*                                                             
;* Params:  num - Vector number                                
;*          old - Pointer to doubleword for storing old vector 
;*          new - Pointer to new handler                       
Vector MACRO num, old, new       ;; Macro definition           
    push ds                      ;; Save DS and ES registers   
    push es                                                    
    mov ah, 35h                  ;; AH = DOS function number   
    mov al, num                  ;; AL = interrupt number      
    int 21h                      ;; Get Interrupt Vector       
    mov WORD PTR old[0], bx      ;; Store it                   
    mov WORD PTR old[2], es                                    
    IF @CodeSize                 ;; If medium or large model,  
        lds dx, new              ;;    load DS from parameter  
    ELSE                                                       
        mov bx, @code            ;; Else ensure DS points to   
        mov ds, bx               ;;    to code segment         
        mov dx, new              ;; DS:DX equals new vector    
    ENDIF                                                      
    mov ah, 25h                  ;; AH = DOS function number   
    int 21h                      ;; Set Interrupt Vector       
    pop es                       ;; Restore ES and DS          
    pop ds                                                     
ENDM                                                           
   4.3. @CurSeg                                                
Syntax:                                                        
            @CurSeg                                            
   Predefined equate returning the name of the current segment.
This equate may be useful for  ASSUME  statements  and  segment
overrides (especially inside of macros), as well as for  ending
the current segment:                                           
@CurSeg ENDS                                                   
   4.4. @FileName                                              
Syntax:                                                        
            @FileName                                          
   Predefined equate returning the base  name  of  the  current
source file. This directive is  useful  for  any  situation  in
which you want a name to change whenever the name of  the  file
changes.                                                       
                      Predefined Equates                       
                                                               
                                                               
   4.5. @WordSize                                              
                                                               
                                                               
Syntax:                                                        
            @WordSize                                          
   Predefined text macro returning the size  of  a  word.  With
Quick-Assembler, this number is always 2. When the  program  is
assembled with the Microsoft Macro Assembler, then a value of 4
is possible. A value of 4 would indicate that  the  program  is
running in the 32-bit mode supported on 80386 processors.      
                                                               
                                                               
                                                               
   4.6. @CodeSize                                              
                                                               
                                                               
Syntax:                                                        
            @CodeSize                                          
   Predefined equate giving a value of 0 for tiny,  small,  and
compact models, or 1 for medium, large, and  huge  models.  The
.MODEL directive must have previously been given.              
                                                               
                                                               
See Also:                                                      
            @DataSize, .MODEL                                  
                                                               
                                                               
                                                               
   4.7. @data                                                  
                                                               
                                                               
Syntax:                                                        
            @data                                              
   Predefined equate representing the group (DGROUP) containing
all near data segments: .DATA, .DATA?, .CONST., and .STACK.  To
access data in any of these segments, DS must contain the value
@data.  (The  .STARTUP  directive   automatically   does   this
initialization.) The .MODEL directive must have previously been
given.                                                         
                                                               
                                                               
See Also:                                                      
            .CONST, .STACK, .STARTUP                           
                                                               
                                                               
                                                               
   4.8. @Model                                                 
                                                               
                                                               
Syntax:                                                        
            @Model                                             
   A predefined  equate  that  returns  one  of  the  following
values, depending on memory model previously defined  with  the
.MODEL directive:                                              
                                                               
    1) TINY                                                    
    2) SMALL                                                   
    3) COMPACT                                                 
    4) MEDIUM                                                  
    5) LARGE                                                   
    6) HUGE                                                    
                                                               
                      Predefined Equates                       
See Also:                                                      
            @CodeSize, @DataSize                               
   4.9. @Cpu                                                   
Syntax:                                                        
            @Cpu                                               
   Predefined equate returning a different number, depending on
processor, as selected by previous processor directive (8086 is
default).                                                      
1                                                              
            8086 processor enabled                             
3                                                              
            80186 processor enabled                            
7                                                              
            80286 processor enabled                            
   4.10. @DataSize                                             
Syntax:                                                        
            @DataSize                                          
   Predefined equate giving a value of 0 for tiny,  small,  and
medium models, or 1 for compact, large, and  huge  models.  The
.MODEL directive must have previously been given.              
See Also:                                                      
            @CodeSize, .MODEL                                  
   4.11. @Version                                              
Syntax:                                                        
            @Version                                           
               Prefined macro returning  a  three-digit  string
            giving the name  of  the  current  version  of  the
            assembler.   For   QuickAssembler   Version   2.01,
            @Version returns the string "520". For Version  5.1
            of the Microsoft Macro Assembler, @Version  returns
            the string "510".                                  
                      Specifying Radixes                       
                                                               
                                                               
                     5. Specifying Radixes                     
                                                               
                                                               
                                                               
Name           Base   Specifier       Digits                   
Binary           2      B             0 1                      
Octal            8      Q or O        0 1 2 3 4 5 6 7          
Decimal         10      D             0 1 2 3 4 5 6 7 8 9      
Hexadecimal     16      H             0 1 2 3 4 5 6 7 8 9      
                                      A B C D E F              
                                                               
   To indicate the radix of a constant, place the specifier  at
the end of the number. Specifiers and hexadecimal digits can be
uppercase or lowercase. Hexadecimal numbers must  always  start
with a decimal digit (0 to 9). If the first digit is one of the
letters A  to  F,  prefix  the  number  with  a  leading  0  to
distinguish it from a symbolic name.                           
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                        Useful Tables                          
                       6. Useful Tables                        
   - Regular Expressions                                       
   - Assembly Operator Precedence                              
   - Data Types and Specifiers                                 
   - Register and Flag Summary                                 
   - Key Scan Chart                                            
   - Program Segment Prefix                                    
   - Color Display Attributes                                  
   6.1. Regular Expressions                                    
           Special Characters in Regular Expressions           
Period       .   Matches any single character.                 
Caret        ^   Matches text at the beginning of a line.      
Dollar sign  $   Matches text at the end of a line. The dollar 
                 sign must appear at the end of the text.      
Asterisk     *   Matches zero or more repetitions of the       
                 character preceding the asterisk.             
Brackets    [ ]  Matches sets of the characters specified      
                 within the brackets.                          
                 Caret ^  Matches any character EXCEPT those   
                          specified within the brackets.       
                          It must be the first character within
                          the brackets.                        
                 Dash  -  Matches characters in the ASCII order
                          between the characters on either side
                          inclusive.                           
Backslash   \    Removes special meaning from next character.  
                 Assembler Operator Precedence                 
    1) LENGTH, SIZE, WIDTH, MASK, (), [], <>                   
    2) . (structure-field operator)                            
    3) :                                                       
    4) PTR, OFFSET, SEG, TYPE, THIS                            
    5) HIGH, LOW                                               
    6) +, - (unary)                                            
    7) *, /, MOD, SHL, SHR                                     
    8) +, - (binary)                                           
    9) EQ, NE, LT, LE, GT, GE                                  
   10) NOT                                                     
   11) AND                                                     
   12) OR, XOR                                                 
   13) SHORT, .TYPE                                            
                        Useful Tables                          
                                                               
                                                               
   6.2. Data Types                                             
                                                               
                                                               
   The LABEL, PROC, EXTRN, LOCAL, and COMM directives  can  all
use the type specifiers listed in the first column. The  second
and third columns show corresponding data  directive  (if  any)
and number of bytes per element.                               
                                                               
BYTE       DB       1                                          
WORD       DW       2                                          
DWORD      DD       4                                          
QWORD      DQ       8                                          
TBYTE      DT      10                                          
FAR                 4                                          
NEAR                2                                          
PROC               code size of memory model (2 or 4)          
                                                               
                                                               
                                                               
                                                               
   6.3. Register Summary                                       
                                                               
                                                               
Accumulator                                                    
            AX (AH/AL) Multiply, divide, I/O, fast arithmetic  
Base                                                           
            BX (BH/BL) Pointer to base address (data segment)  
Count                                                          
            CX (CH/CL) Count for loops, repeats, and shifts    
Data                                                           
            DX (DH/DL) Multiply, divide, and I/O               
                                                               
                                                               
Source Index                                                   
            SI Source string and index pointer                 
Destination Index                                              
            DI Destination string and index pointer            
Base Pointer                                                   
            BP Pointer to base address (stack segment)         
Stack Pointer                                                  
            SP Pointer to top of stack                         
                                                               
                                                               
Code Segment                                                   
            CS Flags Flags                                     
Data Segment                                                   
            DS Instruction Pointer IP                          
Stack Segment                                                  
            SS                                                 
Extra Segment                                                  
            ES                                                 
                                                               
                                                               
                                                               
   6.4. Flags Summary                                          
                                                               
                                                               
                                                               
15               7             0                               
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              
| | | | |O|D|I|T|S|Z| |A| |P| |C|  Layout of flags register    
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                              
                        Useful Tables                          
Flag If                                                        
            set:                                               
O Overflow                                                     
            Indicates result too large or small for destination
D Direction                                                    
            String operations process down rather than up      
I Interrupt                                                    
            Enables interrupts (disables if cleared)           
T Trap                                                         
            Switches to single-step mode                       
S Sign                                                         
            Indicates result has negative sign                 
Z Zero                                                         
            Indicates result equal to 0                        
A Auxiliary Carry                                              
            Indicates carry or borrow to low four-order bits   
P Parity                                                       
            Indicates even number of bits in result            
C Carry                                                        
            Indicates carry or borrow to destination operand   
   6.5. Register Setup                                         
   When DOS loads an EXE program, it sets registers as follows:
ES                                                             
            Points to segment of Program Segment Prefix (PSP)  
DS                                                             
            Points to segment of PSP                           
CS:IP                                                          
            Points to CS:IP address in EXE header              
SS:SP                                                          
            Points to SS:SP address in EXE header              
               When DOS  loads  a  COM  program,  it  sets  all
            segment registers to the beginning of the  program,
            and IP to 100H.                                    
   6.6. Keyboard Scan Codes                                    
                        Useful Tables                          
                                                               
                                                               
                                                               
ESC       01    U          16   | or \      2B   F6          40
! or 1    02    I          17   Z           2C   F7          41
@ or 2    03    O          18   X           2D   F8          42
# or 3    04    P          19   C           2E   F9          43
$ or 4    05    { or [     1A   V           2F   F10         44
% or 5    06    } or ]     1B   B           30   NUMLOCK     45
^ or 6    07    ENTER      1C   N           31   SCROLL LOCK 46
& or 7    08    CTRL       1D   M           32   HOME or 7   47
* or 8    09    A          1E   < or ,      33   UP or 8     48
( or 9    0A    S          1F   > or .      34   PGUP or 9   49
) or 0    0B    D          20   ? or /      35   -           4A
_ or -    0C    F          21   RIGHT SHIFT 36   LEFT or 4   4B
+ or =    0D    G          22   PRTSC or *  37   5           4C
LEFT      0E    H          23   ALT         38   RIGHT or 6  4D
TAB       0F    J          24   SPACEBAR    39   +           4E
Q         10    K          25   CAPSLOCK    3A   END or 1    4F
W         11    L          26   F1          3B   DOWN or 2   50
E         12    : or ;     27   F2          3C   PGDN or 3   51
R         13    " or '     28   F3          3D   INS or 0    52
T         14      or `     29   F4          3E   DEL or .    53
Y         15    LEFT SHIFT 2A   F5          3F                 
                                                               
                                                               
                                                               
   6.7. Program Segment Prefix                                 
                                                               
                                                               
                                                               
Range       Size of Area    Description                        
00H - 01H   02H   (2)       INT 20H                            
02H - 03H   02H   (2)       Segment of first address after     
                            end of block                       
04H - 04H   01H   (1)       Reserved                           
05H - 09H   05H   (5)       Opcode for far call to             
                            DOS function dispatcher            
0AH - 0DH   04H   (4)       Saved contents of terminate        
                            routine vector                     
0EH - 11H   04H   (4)       Saved contents of CTRL+BREAK vector
12H - 15H   04H   (4)       Saved contents of error            
                            routine vector                     
16H - 2BH   14H  (22)       Reserved                           
2CH - 2DH   02H   (2)       Segment address of environment     
2EH - 5BH   28H  (40)       Reserved                           
5CH - 6BH   10H  (16)       First command-line argument        
6CH - 7FH   10H  (16)       Second command-line argument       
80H - FFH   80H (128)       Command line and/or Disk           
                            Transfer Area (DTA)                
                                                               
                                                               
                                                               
                                                               
   6.8. Color Display Attributes                               
                                                               
                                                               
                        Useful Tables                          
   Key to Bits: I=Intensity G=Green F=Flashing R=Red B=Blue    
Background                              Foreground             
Bits      Num  Color              Bits      Num  Color         
F R G B                           I R G B                      
0 0 0 0   0    Black              0 0 0 0   0    Black         
0 0 0 1   1    Blue               0 0 0 1   1    Blue          
0 0 1 0   2    Green              0 0 1 0   2    Green         
0 0 1 1   3    Cyan               0 0 1 1   3    Cyan          
0 1 0 0   4    Red                0 1 0 0   4    Red           
0 1 0 1   5    Magenta            0 1 0 1   5    Magenta       
0 1 1 0   6    Brown              0 1 1 0   6    Brown         
0 1 1 1   7    White              0 1 1 1   7    White         
1 0 0 0   8    Black blink        1 0 0 0   8    Dark grey     
1 0 0 1   9    Blue blink         1 0 0 1   9    Light blue    
1 0 1 0   A    Green blink        1 0 1 0   A    Light green   
1 0 1 1   B    Cyan blink         1 0 1 1   B    Light cyan    
1 1 0 0   C    Red blink          1 1 0 0   C    Light red     
1 1 0 1   D    Magenta blink      1 1 0 1   D    Light magenta 
1 1 1 0   E    Brown blink        1 1 1 0   E    Yellow        
1 1 1 1   F    White blink        1 1 1 1   F    Bright white  
                 Interrupt 21H Summary (DOS)                   
                                                               
                                                               
                7. Interrupt 21H Summary (DOS)                 
                                                               
                                                               
Category                                                       
            Description                                        
Character I/O                                                  
            Old-style (DOS1) read and write to devices         
Directory Operations                                           
            Get, set, create, and delete directory             
Disk Management                                                
            Select drive and get drive status                  
File Operations                                                
            Open, close, and manage files                      
File Operations (FCB)                                          
            Functions use File Control Block--not recommended  
Memory Management                                              
            Allocate or resize memory block                    
Miscellaneous                                                  
            Miscellaneous system functions                     
Process Management                                             
            Execute or terminate process                       
Record Operations                                              
            Read and write to file                             
Record Operations (FCB)                                        
            Functions use File Control Block--not recommended  
Time and Date                                                  
            Get or set date and time                           
                                                               
                                                               
                                                               
   7.1.    Interrupt    21H,    Character-Oriented             
   Functions                                                   
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
01H     1        Character Input with Echo                     
02H     2        Character Output                              
03H     3        Auxiliary Input                               
04H     4        Auxiliary Output                              
05H     5        Printer Output                                
06H     6        Direct Console I/O                            
07H     7        Unfiltered Character Input without Echo       
08H     8        Character Input without Echo                  
09H     9        Display String                                
0AH    10        Buffered Keyboard Input                       
0BH    11        Check Input Status                            
0CH    12        Flush Input Buffer, Then Input                
                                                               
                                                               
                                                               
                                                               
   7.1.1. Int 21H Function 01H                                 
                                                               
                                                               
Description:                                                   
            Character Input with Echo                          
                                                               
                                                               
   Reads a character from the standard input device and  echoes
it to the standard output device. If  no  character  is  ready,
waits until one is available. Input can be redirected (if input
                                                               
         Interrupt 21H, Character-Oriented Functions           
has been redirected, there is no way to detect EOF).           
Input                                                          
            Output                                             
AH=01H                                                         
            AL=8-bit input data                                
   - If the standard input is not redirected and the  character
     read is a CTRL+C, an Int 23H is executed. If the  standard
     input is redirected, a CTRL+C is detected at the  console,
     and BREAK is ON, an Int 23H is executed.                  
   - To read extended ASCII codes (such as the special function
     keys F1 to F10) on the IBM PC and  compatibles,  you  must
     call this function twice. The first call returns the value
     00H to signal the presence of an extended code.           
   - See also Int  21H  Functions  06H,  07H,  and  08H,  which
     provide character input with various combinations of  echo
     and/or CTRL+C sensing.                                    
   - You can also read the keyboard by issuing a read (Int  21H
     Function 3FH) using the predefined handle for the standard
     input (0000H), if input has not been redirected, or  using
     a handle obtained by opening the logical device CON.      
   7.1.2. Int 21H Function 02H                                 
Description:                                                   
            Character Output                                   
   Outputs a character to the standard  output  device.  Output
can be redirected (if output is redirected, there is no way  to
detect disk full).                                             
Input                               Output                     
------------------------            -------                    
AH=02H                              Nothing                    
DL=8-bit data for output                                       
   - If  a  CTRL+C  is  detected  at  the  keyboard  after  the
     requested character is output, an Int 23H is executed.    
   - If  the  standard  output  has  not  been  redirected,   a
     backspace code (08H) causes the cursor to  move  left  one
     position. If output has  been  redirected,  the  backspace
     code does not receive any special treatment.              
   - You can also send strings to the display by  performing  a
     write (Int 21H Function 40H) using the  predefined  handle
     for the standard output (0001H), if output  has  not  been
     redirected, or using a  handle  obtained  by  opening  the
     logical device CON.                                       
         Interrupt 21H, Character-Oriented Functions           
                                                               
                                                               
   7.1.3. PUTSTR.ASM                                           
                                                               
                                                               
                                                               
;* PUTSTR.ASM illustrates multiple-modules and memory model    
;* independent techniques. To create the program, paste this   
;* module and HELLOM.ASM (get help on HELLOM.ASM to open it)   
;* into separate program files. In the environment, you must   
;* also create a program list for the program and define a mode
;* in the Defines field of the Assembler Flags dialog box.     
;* For example, use "model=large". Alternately, you could assem
;* outside the environment with the following command line:    
;*      qcl /Dmodel=large hellom.asm putstr.asm                
;*                                                             
;* Shows:   Directives - PUBLIC    PROC     ENDP   PTR         
;*          DOS function - 02h (Character Output)              
                                                               
; Model is symbol passed from command line or environment.     
; Note that the % operator is required to receive external     
; constant symbols.                                            
%       .MODEL  model, c                                       
                                                               
; With simplified segment directives, procedures such          
; as PutStr are automatically PUBLIC.                          
; Data is not automatically public and must be declared with   
; PUBLIC in order to be accessed from other modules. With      
; full segment directives, the following line would            
; be required to make PutStr known to other modules.           
        ;PUBLIC PutStr                                         
                                                               
        .CODE                ; Address of string (near or far  
PutStr  PROC    str:PTR BYTE ;   depending on model) is passed 
                             ;   the stack                     
        mov     ah, 02h      ; Character output function       
                                                               
        IF      @DataSize    ; If data is far (compact, large, 
        les     di, str      ;   or huge), address is ES:DI    
next:   mov     dl, es:[di]  ; Load each character through ES:[
        ELSE                 ; If data is near (tiny, small,   
        mov     di, str      ;   or medium), address is DI only
next:   mov     dl, [di]     ; Load each character through [DI]
        ENDIF                                                  
                                                               
        or      dl, dl       ; Check to see if character is zer
        jz      exit         ; If zero, done                   
        int     21h          ; DOS displays character          
        inc     di           ; Point to next character         
        jmp     SHORT next   ; Loop back to load character     
                                                               
exit:   ret                                                    
                                                               
PutStr  ENDP                                                   
                                                               
        END                                                    
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
         Interrupt 21H, Character-Oriented Functions           
   7.1.4. Int 21H Function 03H                                 
Description:                                                   
            Auxiliary Input                                    
   Reads a character from the standard  auxiliary  device.  The
default is the first serial port (COM1).                       
Input             Output                                       
------            -------------------                          
AH=03H            AL=8-bit input data                          
   - In most MS-DOS systems, the serial  device  is  unbuffered
     and is not interrupt driven. If the auxiliary device sends
     data faster than your program can process  it,  characters
     may be lost.                                              
   - At startup on the IBM PC,  PC-DOS  initializes  the  first
     serial port to 2400 baud, no parity, 1  stop  bit,  and  8
     data bits. Other implementations of MS-DOS may  initialize
     the serial device differently.                            
   - There is no way for a user program to read the  status  of
     the auxiliary device or to detect I/O errors (such as lost
     characters) through this function call.  On  the  IBM  PC,
     more precise control may be obtained by calling  ROM  BIOS
     Int  14H  or  by  driving  the  communications  controller
     directly.                                                 
   - If a CTRL+C is detected at the keyboard,  an  Int  23H  is
     executed.                                                 
   - You can also input from the auxiliary device by requesting
     a read (Int 21H Function 3FH) using the predefined  handle
     for the standard  auxiliary  device  (0003H)  or  using  a
     handle obtained by opening the logical device AUX.        
   7.1.5. Int 21H Function 04H                                 
Description:                                                   
            Auxiliary Output                                   
   Outputs a character to the standard  auxiliary  device.  The
default is the first serial port (COM1).:                      
Input                               Output                     
------------------------            -------                    
AH=04H                              Nothing                    
DL=8-bit data for output                                       
   - If the output device is busy, this  function  waits  until
     the device is ready to accept a character.                
   - There is no way to poll the status of the auxiliary device
     using this function. On the IBM PC, more  precise  control
     can be obtained by calling ROM BIOS Int 14H or by  driving
     the communications controller directly.                   
   - If a CTRL+C is detected at the keyboard,  an  Int  23H  is
         Interrupt 21H, Character-Oriented Functions           
                                                               
                                                               
     executed.                                                 
   - You can also send  strings  to  the  auxiliary  device  by
     performing a  write  (Int  21H  Function  40H)  using  the
     predefined  handle  for  the  standard  auxiliary   device
     (0003H) or using a handle obtained by opening the  logical
     device AUX.                                               
                                                               
                                                               
                                                               
                                                               
   7.1.6. Int 21H Function 05H                                 
                                                               
                                                               
Description:                                                   
            Printer Output                                     
                                                               
                                                               
   Sends a character to the standard list device.  The  default
is the printer  on  the  first  parallel  port  (LPT1),  unless
explicitly redirected by the user with the MODE command.       
                                                               
Input                                Output                    
-------------------------            -------                   
AH=05H                               Nothing                   
DL=8-bit data for output                                       
                                                               
                                                               
   - If the printer is busy,  this  function  waits  until  the
     printer is ready to accept the character.                 
   - There is no standardized way to poll  the  status  of  the
     printer under MS-DOS.                                     
   - If a CTRL+C is detected at the keyboard,  an  Int  23H  is
     executed.                                                 
   - You can also send strings to the printer by  performing  a
     write (Int 21H Function 40H) using the  predefined  handle
     for the standard printer device (0004H) or using a  handle
     obtained by opening the logical device PRN or LPT1.       
                                                               
                                                               
                                                               
                                                               
   7.1.7. Int 21H Function 06H                                 
                                                               
                                                               
Description:                                                   
            Direct Console I/O                                 
                                                               
                                                               
   Used by programs that need to read and  write  all  possible
characters and control codes without any interference from  the
operating system. Reads a character  from  the  standard  input
device or writes a character to the standard output device. I/O
may be redirected (if I/O has been redirected, there is no  way
to detect EOF or disk full).                                   
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
         Interrupt 21H, Character-Oriented Functions           
Input                             Output                       
-----------------------------     -----------------------------
AH=06H                            If called with DL=00H-0FEH   
DL=function requested             Nothing                      
  =00H-FEH  if output request                                  
  =0FFH     if input request      If called with DL=FFH and a  
                                  character is ready           
                                  Zero flag=clear              
                                  AL=8-bit input data          
                                  If called with DL=FFH and a  
                                  character is ready           
                                  Zero flag=set                
   - No special action is taken upon entry  of  a  CTRL+C  when
     this service is used.                                     
   - To read extended ASCII codes (such as the special function
     keys F1 to F10) on the IBM PC and  compatibles,  you  must
     call this function twice. The first call returns the value
     00H to signal the presence of an extended code.           
   - See also Int  21H  Functions  01H,  07H,  and  08H,  which
     provide character input with various combinations of  echo
     and/or CTRL+C sensing, and Functions 02H  and  09H,  which
     may be used to write characters to the standard output.   
   - You can also read the keyboard by issuing a read (Int  21H
     Function 3FH) using the predefined handle for the standard
     input (0000H), if input has  not  been  redirected,  or  a
     handle obtained by opening the logical device CON.        
   - You can also send characters to the display by  issuing  a
     write (Int 21H Function 40H) using the  predefined  handle
     for the standard output (0001H), if output  has  not  been
     redirected, or using a  handle  obtained  by  opening  the
     logical device CON.                                       
   7.1.8. Int 21H Function 07H                                 
Description:                                                   
            Unfiltered Character Input Without Echo            
   Reads a character from the  standard  input  device  without
echoing it to the standard output device. If  no  character  is
ready, waits until one is available. Input  may  be  redirected
(if input has been redirected, there is no way to detect  EOF).
Input             Output                                       
------            -------------------                          
AH=07H            AL=8-bit input data                          
   - No special action is taken upon entry  of  a  CTRL+C  when
     this function is used. If CTRL+C checking is required, use
     Int 21H Function 08H instead.                             
   - To read extended ASCII codes (such as the special function
     keys F1 to F10) on the IBM PC and  compatibles,  you  must
     call this function twice. The first call returns the value
     00H to signal the presence of an extended code.           
         Interrupt 21H, Character-Oriented Functions           
                                                               
                                                               
   - See also Int  21H  Functions  01H,  06H,  and  08H,  which
     provide character input with various combinations of  echo
     and/or CTRL+C sensing.                                    
   - You can also read the keyboard by issuing a read (Int  21H
     Function 3FH) using the predefined handle for the standard
     input (0000H), if input has not been redirected, or  using
     a handle obtained by opening the logical device CON.      
                                                               
                                                               
                                                               
                                                               
   7.1.9. Int 21H Function 08H                                 
                                                               
                                                               
Description:                                                   
            Character Input Without Echo                       
                                                               
                                                               
   Reads a character from the  standard  input  device  without
echoing it to the standard output device. If  no  character  is
ready, waits until one is available. Input  may  be  redirected
(if input has been redirected, there is no way to detect  EOF).
                                                               
Input             Output                                       
------            -------------------                          
AH=08H            AL=8-bit input data                          
                                                               
                                                               
   - If the standard input is not redirected, and the character
     read is a CTRL+C, an Int 23H is executed. If the  standard
     input is redirected, a CTRL+C is detected at the  console,
     and BREAK is ON, an Int 23H is executed. To avoid possible
     interruption  by  a  CTRL+C,  use  Int  21H  Function  07H
     instead.                                                  
   - To read extended ASCII codes (such as the special function
     keys F1 to F10) on the IBM PC and  compatibles,  you  must
     call this function twice. The first call returns the value
     00H to signal the presence of an extended code.           
   - See also Int  21H  Functions  01H,  06H,  and  07H,  which
     provide character input with various combinations of  echo
     and/or CTRL+C sensing.                                    
   - You can also read the keyboard by issuing a read (Int  21H
     Function 3FH) using the predefined handle for the standard
     input (0000H), if input has not been redirected, or  using
     a handle obtained by opening the logical device CON.      
                                                               
                                                               
                                                               
                                                               
   7.1.10. Int 21H Function 09H                                
                                                               
                                                               
Description:                                                   
            Display String                                     
                                                               
                                                               
   Sends a string of characters to the standard output  device.
Output may be redirected (if output has been redirected,  there
is no way to detect disk full).                                
                                                               
                                                               
                                                               
         Interrupt 21H, Character-Oriented Functions           
Input                                     Output               
------------------------------            -------              
AH=09H                                    Nothing              
DS:DX=segment:offset of string                                 
   - The string must be terminated with the character $  (24H),
     which is not transmitted. Any other ASCII codes, including
     control codes, can be embedded in the string.             
   - See Int 21H Functions 02H  and  06H  for  single-character
     output to the video display or standard output device.    
   - If a CTRL+C is detected at the keyboard,  an  Int  23H  is
     executed.                                                 
   - You can also send strings to the display by  performing  a
     write (Int 21H Function 40H) using the  predefined  handle
     for the standard  output  (0001H),  if  it  has  not  been
     redirected, or using a  handle  obtained  by  opening  the
     logical device CON.                                       
   7.1.11. Int 21H Function 0AH                                
Description:                                                   
            Buffered Keyboard Input                            
   Reads a string of bytes from the standard input  device,  up
to and including an ASCII carriage  return  (0DH),  and  places
them in a user-designated buffer. The characters are echoed  to
the standard output device. Input may be redirected  (if  input
has been redirected, there is no way to detect EOF).           
Input                                     Output               
------------------------------            ------               
AH=0AH                                    Nothing              
DS:DX=segment:offset of buffer                                 
   - The buffer used by this function has the following format:
     Byte                                                      
                 Contents                                      
     0                                                         
                 maximum number of characters to read,  set  by
                 program                                       
     1                                                         
                 number of characters actually read  (excluding
                 carriage return), set by MS-DOS               
     2+                                                        
                 string read from keyboard or  standard  input,
                 terminated by a carriage return (0DH)         
   - If the buffer fills to one fewer than the  maximum  number
     of characters it can hold, subsequent input is ignored and
     the bell is sounded until a carriage return is detected.  
   - This  input   function   is   buffered   with   type-ahead
     capability, and  all  of  the  standard  keyboard  editing
     commands are active.                                      
         Interrupt 21H, Character-Oriented Functions           
                                                               
                                                               
   - If the standard input is not redirected, and a  CTRL+C  is
     detected at the console, an Int 23H is  executed.  If  the
     standard input is redirected, a CTRL+C is detected at  the
     console, and BREAK is ON, an Int 23H is executed.         
   - See  Int  21H  Functions  01H,  06H,  07H,  and  08H   for
     single-character input from the keyboard or standard input
     device.                                                   
   - You can also read strings from the keyboard by  performing
     a read (Int 21H Function 3FH) using the predefined  handle
     for the  standard  input  (0000H),  if  it  has  not  been
     redirected, or using a  handle  obtained  by  opening  the
     logical device CON.                                       
                                                               
                                                               
                                                               
                                                               
   7.1.12. Int 21H Function 0BH                                
                                                               
                                                               
Description:                                                   
            Check Input Status                                 
                                                               
                                                               
   Checks whether a character is available  from  the  standard
input device. Input can be redirected.                         
                                                               
Input          Output                                          
------         ---------------------------------------------   
AH=0BH         AL=00H if no character is available             
                 =FFH if at least one character is available   
                                                               
                                                               
   - If a CTRL+C is detected, an Int 23H is executed.          
   - If the standard input is not redirected, and a  CTRL+C  is
     detected at the console, an Int 23H is  executed.  If  the
     standard input is redirected, a CTRL+C is detected at  the
     console, and BREAK is ON, an Int 23H is executed.         
   - If a character is waiting, this function will continue  to
     return a true flag until the character is consumed with  a
     call to Int 21H Function 01H, 06H, 07H, 08H, 0AH, or  3FH.
   - This function is equivalent to IOCTL Int 21H Function  44H
     Subfunction 06H.                                          
                                                               
                                                               
                                                               
                                                               
   7.1.13. Int 21H Function 0CH                                
                                                               
                                                               
Description:                                                   
            Flush Input Buffer and Then Input                  
                                                               
                                                               
   Clears the standard input buffer and then invokes one of the
character input functions. Input can be redirected.            
                                                               
                                                               
                                                               
         Interrupt 21H, Character-Oriented Functions           
Input                                     Output               
------------------------------            ---------------------
AH=0CH                                    If called with AL=01H
AL=number of input function to             07H, or 08H         
   be invoked after resetting             AL=8-bit input data  
   buffer (must be 01H, 06H,                                   
   07H, 08H, or 0AH)                      If called with AL=0AH
If AL=0AH                                 Nothing              
DS:DX=segment:offset of input                                  
      buffer                                                   
   - The function exists to allow a program to defeat  MS-DOS's
     type-ahead feature. It discards any  characters  that  are
     waiting in MS-DOS's internal  type-ahead  buffer,  forcing
     the specified input  function  to  wait  for  a  character
     (usually a keyboard entry) that is truly entered after the
     program's request.                                        
   - The  presence  or  absence  of  CTRL+C   checking   during
     execution of this function depends on the function  number
     in register AL.                                           
   - A function number in AL other than 01H, 06H, 07H, 08H,  or
     0AH simply flushes the input buffer and returns control to
     the calling program.                                      
   7.2. Interrupt 21H, Directory-Control Functions             
Hex #  Dec #     Name                                          
39H     57       Create Directory                              
3AH     58       Delete Directory                              
3BH     59       Set Current Directory                         
47H     71       Get Current Directory                         
   7.2.1. Int 21H Function 39H                                 
Description:                                                   
            Create Directory                                   
   Creates a directory using the specified drive and path.     
Input                                 Output                   
------------------------------        ------------------------ 
AH=39H                                If function successful   
DS:DX=segment:offset of ASCIIZ        Cary flag=clear          
      pathname                        If function unsuccessful 
                                      Carry flag=set           
                                      AX=error code            
   - The function fails if:                                    
        - any element of the pathname does not exist.          
          Interrupt 21H, Directory-Control Functions           
                                                               
                                                               
        - a directory with the same name at the end of the same
     path already exists.                                      
        - the parent directory for the  new  directory  is  the
     root directory and is full.                               
        - [3.0+] the program is running on a  network  and  the
     user running the program has insufficient access rights.  
                                                               
                                                               
                                                               
                                                               
   7.2.2. Int 21H Function 3AH                                 
                                                               
                                                               
Description:                                                   
            Delete Directory                                   
                                                               
                                                               
   Removes a directory using the specified drive and path.     
                                                               
Input                                 Output                   
------------------------------        ------------------------ 
AH=3AH                                If function successful   
DS:DX=segment:offset of ASCIIZ        Carry flag=clear         
      pathname                        If function unsuccessful 
                                      Carry flag= set          
                                      AX=error code            
                                                               
                                                               
   - The function fails if:                                    
        - any element of the pathname does not exist.          
        -  the  specified  directory  is   also   the   current
     directory.                                                
        - the specified directory contains any files.          
        - [3.0+] the program is running on a  network  and  the
     user running the program has insufficient access rights.  
                                                               
                                                               
                                                               
                                                               
   7.2.3. Int 21H Function 3BH                                 
                                                               
                                                               
Description:                                                   
            Set Current Directory                              
                                                               
                                                               
   Sets the current, or default, directory using the  specified
drive and path.                                                
                                                               
Input                                 Output                   
------------------------------        ------------------------ 
AH=3BH                                If function successful   
DS:DX=segment:offset of ASCIIZ        Carry flag=clear         
      pathname                        If function unsuccessful 
                                      Carry flag= set          
                                      AX=error code            
                                                               
                                                               
                                                               
   - The function fails if any element of the pathname does not
     exist.                                                    
   - Int 21H Function 47H can be used to obtain the name of the
                                                               
          Interrupt 21H, Directory-Control Functions           
     current directory before using Int  21H  Function  3BH  to
     select another so  that  the  original  directory  can  be
     restored later.                                           
   7.2.4. Int 21H Function 47H                                 
Description:                                                   
            Get Current Directory                              
   Obtains an ASCIIZ string that describes the  path  from  the
root to the current directory, and the name of that  directory.
Input                             Output                       
-----------------------------     ---------------------------- 
AH=47H                            If function successful       
DL=drive code (0=default,1=A,     Carry flag=clear             
     etc.)                         and buffer is filled in with
DS:SI=segment:offset of 64-        full pathname from root of  
       byte buffer                 current directory           
                                  If function unsuccessful     
                                   Carry flag=set              
                                   AX=error code               
   - The  returned  path  name  does  not  include  the   drive
     identifier or a leading backslash (\).  It  is  terminated
     with a null  (00H)  byte.  Consequently,  if  the  current
     directory is the root directory, the  first  byte  in  the
     buffer will contain 00H.                                  
   - The function fails if the drive code is invalid.          
   - The current directory may be set  with  Int  21H  Function
     3BH.                                                      
   7.3. Interrupt 21H, Disk-Management Functions               
Hex #  Dec #     Name                                          
0DH     13       Disk Reset                                    
0EH     14       Select Disk                                   
19H     25       Get Current Disk                              
1BH     27       Get Default Drive Data                        
1CH     28       Get Drive Data                                
2EH     46       Set Verify Flag                               
36H     54       Get Drive Allocation Information              
54H     84       Get Verify Flag                               
           Interrupt 21H, Disk-Management Functions            
                                                               
                                                               
   7.3.1. Int 21H Function 0DH                                 
                                                               
                                                               
Description:                                                   
            Disk Reset                                         
                                                               
                                                               
   Flushes all file buffers. All data that has  been  logically
written by user programs  but  has  been  temporarily  buffered
within MS-DOS is physically written to the disk.               
                                                               
  Input             Output                                     
  ------            -------                                    
  AH=0DH            Nothing                                    
                                                               
                                                               
   - This function does not update the disk directory  for  any
     files that are  still  open.  If  your  program  fails  to
     properly close all files before the disk is  removed,  and
     files have changed size, the data forced out to  the  disk
     by this function may still  be  inaccessible  because  the
     directory entries will not be correct.                    
   - [3.3+] Int 21H Function 68H (Commit File) should  be  used
     in preference to this function because it also updates the
     disk directory and file allocation table.                 
                                                               
                                                               
                                                               
                                                               
   7.3.2. Int 21H Function 0EH                                 
                                                               
                                                               
Description:                                                   
            Select Disk                                        
                                                               
                                                               
   Selects the specified drive to be the current,  or  default,
disk drive and returns the total number of  logical  drives  in
the system.                                                    
                                                               
Input                             Output                       
------------------------------    -----------------------------
AH=0EH                            AL=number of logical drives i
DL=drive code (0=A, 1=B, etc.)    system                       
                                                               
                                                               
   - 63 drive designators (0 through 3FH) are available.       
   - [3.0+] 26 drive designators (0 through 19H) are available.
   - To preserve upward compatibility, new applications  should
     limit themselves to  the  drive  letters  A-Z  (0=A,  1=B,
     etc.).                                                    
   - Logical drives means the total number  of  block  devices:
     floppy  disks,  simulated  disk  drives  (RAMdisks),   and
     hard-disk drives. A single  physical  hard-disk  drive  is
     frequently partitioned into two or more logical drives.   
   - In single-drive IBM PC-compatible systems, the value 2  is
     returned in AL, because PC-DOS supports two logical drives
     (A: and B:) on the single physical floppy-disk drive.  The
     actual number of physical drives  in  the  system  can  be
     determined with ROM BIOS Int 11H.                         
   - [3.0+] The value returned in AL is either 5 or  the  drive
     code corresponding to the  LASTDRIVE  entry  (if  any)  in
                                                               
           Interrupt 21H, Disk-Management Functions            
     CONFIG.SYS, whichever is greater.                         
   7.3.3. Int 21H Function 19H                                 
Description:                                                   
            Get Current Disk                                   
   Returns the drive code of  the  current,  or  default,  disk
drive.                                                         
Input             Output                                       
------            ------------------------------               
AH=19H            AL=drive code (0=A, 1=B, etc.)               
   - To set the default drive, use Int 21H Function 0EH.       
   - Some other Int 21H functions use drive codes beginning  at
     1 (that is, 1=A, 2=B, etc.) and reserve  drive  code  zero
     for the default drive.                                    
   7.3.4. Int 21H Function 1BH                                 
Description:                                                   
            Get Default Drive Data                             
   Obtains selected information about the  default  disk  drive
and a pointer to the media identification byte  from  its  file
allocation table.                                              
Input        Output                                            
------       ------------------------------------------------- 
AH=1BH       If function successful                            
             AL=sectors per cluster                            
             DS:BX=segment:offset of media ID byte             
             CX=size of physical sector (bytes)                
             DX=number of clusters for default drive           
             If function unsuccessful                          
             (invalid drive or critical error)                 
             AL=FFH                                            
   - The media ID byte has the following meanings:             
     0F0H                                                      
                 3.5-inch double-sided, 18 sectors or "other"  
     0F8H                                                      
                 fixed disk                                    
     0F9H                                                      
                 5.25-inch double-sided, 15 sectors or 3.5-inch
                 double-sided, 9 sectors                       
     0FCH                                                      
                 5.25-inch single-sided, 9 sectors             
     0FDH                                                      
           Interrupt 21H, Disk-Management Functions            
                                                               
                                                               
                 5.25-inch double-sided, 9 sectors             
     0FEH                                                      
                 5.25-inch single-sided, 8 sectors             
     0FFH                                                      
                 5.25-inch double-sided, 8 sectors             
   - To obtain information about disks other than  the  one  in
     the default drive, use Int 21H Function 1CH or 36H.       
   - The address returned in DS:BX points only to a copy of the
     media ID byte from the disk's FAT; the memory  above  that
     address cannot be assumed to contain the FAT or any  other
     useful  information.  If  direct  access  to  the  FAT  is
     required, use Int 25H to read it into memory.             
                                                               
                                                               
                                                               
                                                               
   7.3.5. Int 21H Function 1CH                                 
                                                               
                                                               
Description:                                                   
            Get Drive Data                                     
                                                               
                                                               
   Obtains allocation  information  about  the  specified  disk
drive and a pointer to the media identification byte  from  its
file allocation table.                                         
                                                               
Input              Output                                      
--------------     --------------------------------------------
AH=1CH             If function successful                      
DL=drive code      AL=sectors per cluster                      
   (0=default,     DS:BX=segment:offset of media ID byte       
   1=A, etc.)      CX=size of physical sector (bytes)          
                   DX=number of clusters for default or        
                      specified drive                          
                   If function unsuccessful (invalid drive or  
                      critical error)                          
                    AL=FFH                                     
                                                               
                                                               
   - The media ID byte has the following meanings:             
     0F0H                                                      
                 3.5-inch double-sided, 18 sectors or "other"  
     0F8H                                                      
                 fixed disk                                    
     0F9H                                                      
                 5.25-inch double-sided, 15 sectors or 3.5-inch
                 double-sided, 9 sectors                       
     0FCH                                                      
                 5.25-inch single-sided, 9 sectors             
     0FDH                                                      
                 5.25-inch double-sided, 9 sectors             
     0FEH                                                      
                 5.25-inch single-sided, 8 sectors             
     0FFH                                                      
                 5.25-inch double-sided, 8 sectors             
   - In general, this call is identical  to  Int  21H  Function
     1BH, except for the ability to designate a  specific  disk
     drive. See  also  Int  21H  Function  36H,  which  returns
     similar information.                                      
   - The address returned in DS:BX points only to a copy of the
     media ID byte from the disk's FAT; the memory  above  that
                                                               
           Interrupt 21H, Disk-Management Functions            
     address cannot be assumed to contain the FAT or any  other
     useful  information.  If  direct  access  to  the  FAT  is
     required, use Int 25H to read it into memory.             
   7.3.6. Int 21H Function 2EH                                 
Description:                                                   
            Set Verify Flag                                    
   Turns  off  or  turns  on  the  operating-system  flag   for
automatic read-after-write verification of data.               
  Input                                         Output         
  ----------------------------------            -------        
  AH=2EH                                        Nothing        
  AL=00H  if turning off verify flag                           
     01H  if turning on verify flag                            
  DL=00H                                                       
   - This  function  provides  increased  data   integrity   by
     allowing the user to force a  read-after-write  verify  of
     all data written  to  the  disk,  if  that  capability  is
     supported by the manufacturer's disk driver.              
   - Because   read-after-write   verification    slows    disk
     operations, the default setting of the verify flag is OFF.
   - The current state of the verify  flag  can  be  determined
     using Int 21H Function 54H.                               
   - The state of the verify flag is  also  controlled  by  the
     MS-DOS commands VERIFY OFF and VERIFY ON.                 
   7.3.7. Int 21H Function 36H                                 
Description:                                                   
            Get Drive Allocation Information                   
   Obtains selected information about a disk drive, from  which
the  drive's  capacity  and  remaining  free   space   can   be
calculated.                                                    
Input                          Output                          
-------------------------      ------------------------------- 
AH=36H                         If function successful          
DL=drive code (0=default,      AX=sectors per cluster          
    1=A, etc.)                 BX=number of available clusters 
                               CX=bytes per sector             
                               DX=clusters per drive           
                               If function unsuccessful        
                                  (drive invalid)              
                               AX=FFFFH                        
           Interrupt 21H, Disk-Management Functions            
                                                               
                                                               
   - This function regards "lost" clusters as being in use  and
     does not report them as part of the  number  of  available
     clusters, even though they are not assigned to a file.    
   - Similar information is returned by Int 21H  Functions  1BH
     and 1CH.                                                  
                                                               
                                                               
                                                               
                                                               
   7.3.8. Int 21H Function 54H                                 
                                                               
                                                               
Description:                                                   
            Get Verify Flag                                    
                                                               
                                                               
   Obtains   the   current   value   of   the   system   verify
(read-after-write) flag.                                       
                                                               
Input             Output                                       
------            ----------------------------                 
AH=54H            AL=current verify flag value                 
                  00H  if verify off                           
                  01H  if verify on                            
                                                               
                                                               
   - Because   read-after-write   verification    slows    disk
     operations, the default state of the system verify flag is
     OFF.                                                      
   - The state of the system verify flag can be changed through
     a call to Int 21H Function 2EH or by the  MS-DOS  commands
     VERIFY ON and VERIFY OFF.                                 
                                                               
                                                               
                                                               
                                                               
   7.4. Interrupt 21H, File Operations                         
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
3CH     60       Create File                                   
3DH     61       Open File                                     
3EH     62       Close File                                    
41H     65       Delete File                                   
43H     67       Get or Set File Attributes                    
45H     69       Duplicate Handle                              
46H     70       Redirect Handle                               
4EH     78       Find First File                               
4FH     79       Find Next File                                
56H     86       Rename File                                   
57H     87       Get or Set File Date and Time                 
5AH     90       Create Temporary File                         
5BH     91       Create New File                               
67H    103       Set Handle Count (sets maximum number of files
                                                               
                                                               
                                                               
                                                               
                Interrupt 21H, File Operations                 
   7.4.1. Int 21H Function 3CH                                 
Description:                                                   
            Create File                                        
   Given  an  ASCIIZ  pathname,  creates  a  new  file  in  the
designated or default directory on the  designated  or  default
disk drive.  If  the  specified  file  already  exists,  it  is
truncated to zero length. In either case, the  file  is  opened
and a handle is returned that can be used by  the  program  for
subsequent access to the file.                                 
Input                                   Output                 
----------------------------------      ---------------------- 
AH=3CH                                  If function successful 
CX=file attribute                       Carry flag=clear       
   (bits can be combined)               AX=handle              
Bit(s)  Significance (if set)                                  
  0       read-only                                            
  1       hidden                        If function failed     
  2       system                        Carry flag=set         
  3       volume label                  AX=error code          
  4       reserved (0)                                         
  5       archive                                              
  6-15    reserved (0)                                         
DS:DX=segment:offset of ASCIIZ pathname                        
   7.4.2. CreateFile                                           
;* CreateFile - Creates file with specified attribute.         
;*                                                             
;* Shows:   DOS Function - 3Ch (Create File)                   
;*                                                             
;* Params:                                                     
;* attr - Attribute code:  0 = normal        8 = volume label  
;*                         1 = read only    16 = subdirectory  
;*                         2 = hidden       32 = archive       
;*                         4 = system                          
;* fspec - Pointer to ASCIIZ file specification                
;*                                                             
;* Return:  Short integer with file handle or -1 for error     
CreateFile PROC \                                              
        USES ds, \                                             
        attr:WORD, fspec:PTR BYTE                              
        LoadPtr ds, dx, fspec  ; Point DS:DX to file spec      
        mov     cx, attr       ; CX = attribute                
        mov     ah, 3Ch        ; AH = function number          
        int     21h            ; Create File                   
        jnc     exit           ; If ok, return AX = handle     
        mov     ax, -1         ; Else set error code           
exit:   ret                                                    
CreateFile ENDP                                                
                Interrupt 21H, File Operations                 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
   7.4.3. Int 21H Function 3DH                                 
                                                               
                                                               
Description:                                                   
            Open File                                          
                                                               
                                                               
   Given an ASCIIZ pathname, opens the specified  file  in  the
designated or default directory on the  designated  or  default
disk drive. A handle is  returned  that  can  be  used  by  the
program for subsequent access to the file.                     
                                                               
Input                                Output                    
------------------------------       --------------------------
AH=3DH                               If function successful    
AL=access mode                         Carry flag=clear        
  Bit(s)   Significance                AX=handle               
  0-2      access mode               If function unsuccessful  
           000=read access             Carry flag=set          
           001=write access            AX=error code           
           010=read/write access                               
  3        reserved (0)                                        
  4-6      sharing mode                                        
            (MS-DOS versions                                   
            3.0 and later)                                     
           000=compatibility mode                              
           001=deny all                                        
           010=deny write                                      
           011=deny read                                       
           100=deny none                                       
  7        inheritance flag                                    
            (MS-DOS versions                                   
            3.0 and later)                                     
  0=child process inherits handle                              
  1=child does not inherit handle                              
DS:DX=segment:offset of ASCIIZ pathname                        
                                                               
                                                               
                                                               
                                                               
   7.4.4. Int 21H Function 3EH                                 
                                                               
                                                               
Description:                                                   
            Close File                                         
                                                               
                                                               
   Given a handle that was obtained by  a  previous  successful
open  or  create  operation,  flushes  all   internal   buffers
associated with the file to disk, closes the file, and releases
the handle for reuse. If the file was modified,  the  time  and
date stamp and file size are updated in  the  file's  directory
entry.                                                         
                                                               
                                                               
                                                               
                                                               
                                                               
                Interrupt 21H, File Operations                 
Input                Output                                    
---------            ------------------------                  
AH=3EH               If function successful                    
BX=handle              Carry Flag=clear                        
                     If function unsuccessful                  
                       Carry flag= set                         
                       AX=error code                           
   - If you accidentally call this function with a zero handle,
     the standard input device  is  closed,  and  the  keyboard
     appears to go dead. Be sure  you  always  call  the  close
     function with a valid, non-zero handle.                   
   7.4.5. Int 21H Function 41H                                 
Description:                                                   
            Delete File                                        
   Deletes a file  from  the  specified  or  default  disk  and
directory.                                                     
Input                             Output                       
------------------------------    ------------------------     
AH=41H                            If function successful       
DS:DX=segment:offset of ASCIIZ       Carry flag=clear          
      pathname                    If function unsuccessful     
                                     Carry flag= set           
                                     AX=error code             
    1) This function deletes a  file  by  replacing  the  first
       character of its filename  in  the  directory  with  the
       character e (E5H) and marking  the  file's  clusters  as
       "free" in the disk's file allocation table.  The  actual
       data stored in those clusters is not overwritten.       
    2) Only one file  at  a  time  may  be  deleted  with  this
       function. Unlike the FCB-related  Delete  File  function
       (Int 21H Function 13H), the * and ? wildcard  characters
       are not allowed in the file specification.              
    3) The function fails if:                                  
          - any element of the pathname does not exist.        
          - the designated file exists but  has  the  read-only
       attribute (Int 21H Function 43H can be used  to  examine
       and modify  a  file's  attribute  before  attempting  to
       delete it).                                             
          - [3.0+] the program is running on a network, and the
       user running the program has insufficient access rights.
                Interrupt 21H, File Operations                 
                                                               
                                                               
   7.4.6. Int 21H Function 43H                                 
                                                               
                                                               
Description:                                                   
            Get or Set File Attributes                         
                                                               
                                                               
   Obtains or alters  the  attributes  of  a  file  (read-only,
hidden, system, or archive).                                   
                                                               
Input                                Output                    
----------------------------------   --------------------------
AH=43H                               If function successful    
AL=00H if getting file attribute        Carry flag=clear       
   01H if setting file attribute        CX=file attribute (see 
CX=new file attribute, if AL = 01H         above)              
   (bits can be combined)            If function unsuccessful  
     bit 5=archive                      Carry flag=set         
     bit 2=system                       AX=error code          
     bit 1=hidden                                              
     bit 0=read-only                                           
  DS:DX=segment:offset of ASCIIZ                               
         pathname                                              
                                                               
                                                               
   - Bits 3 and 4 of register CX must always be clear (0)  when
     this function is called; in other words, you cannot change
     an  existing  file  into  a  directory  or  volume  label.
     However, you can  assign  the  "hidden"  attribute  to  an
     existing directory with this function.                    
   - [3.0+] If the program is running on a  network,  the  user
     must have Create access rights to the directory containing
     the file whose attribute is to be modified.               
                                                               
                                                               
                                                               
                                                               
   7.4.7. Int 21H Function 45H                                 
                                                               
                                                               
Description:                                                   
            Duplicate Handle                                   
                                                               
                                                               
   Given a handle for a currently open device or file,  returns
a new handle that refers to the same device or file at the same
position.                                                      
                                                               
Input                           Output                         
--------------------------      ------------------------       
AH=45H                          If function successful         
BX=handle to be duplicated         Carry flag=clear            
                                   AX=new handle               
                                If function unsuccessful       
                                   Carry flag=set              
                                   AX=error code               
                                                               
                                                               
   - A seek, read, or  write  operation  that  moves  the  file
     pointer for one of the two handles  also  moves  the  file
     pointer associated with the other.                        
   - This function  can  be  used  to  efficiently  update  the
                                                               
                Interrupt 21H, File Operations                 
     directory for a file that has changed in  length,  without
     incurring the overhead of closing and then  reopening  the
     file. The handle for the file is  simply  duplicated  with
     this function and the duplicate  is  closed,  leaving  the
     original handle open for further read/write operations.   
   - [3.3+] See also Int 21H Function 68H (Commit File).       
   7.4.8. Int 21H Function 45H                                 
Description:                                                   
            Duplicate Handle                                   
   Given a handle for a currently open device or file,  returns
a new handle that refers to the same device or file at the same
position.                                                      
Input                                 Output                   
--------------------------            ------------------------ 
AH=45H                                If function successful   
BX=handle to be duplicated              Carry flag=clear       
                                        AX=new handle          
                                      If function unsuccessful 
                                        Carry flag=set         
                                        AX=error code          
   - A seek, read, or  write  operation  that  moves  the  file
     pointer for one of the two handles  also  moves  the  file
     pointer associated with the other.                        
   - This function  can  be  used  to  efficiently  update  the
     directory for a file that has changed in  length,  without
     incurring the overhead of closing and then  reopening  the
     file. The handle for the file is  simply  duplicated  with
     this function and the duplicate  is  closed,  leaving  the
     original handle open for further read/write operations.   
   - [3.3+] See also Int 21H Function 68H (Commit File).       
   7.4.9. Int 21H Function 46H                                 
Description:                                                   
            Redirect Handle                                    
   Given two handles, makes the second handle refer to the same
device or file at the same location as the  first  handle.  The
second handle is then said to be redirected.                   
                Interrupt 21H, File Operations                 
                                                               
                                                               
                                                               
Input                            Output                        
----------------------------     ----------------------------- 
AH=46H                           If function successful        
BX=handle for file or device        Carry flag=clear           
CX=handle to be redirected       If function unsuccessful      
                                    Carry flag=set             
                                    AX=error code              
                                                               
                                                               
   - If the handle passed in CX already refers to an open file,
     that file is closed first.                                
   - A seek, read, or  write  operation  that  moves  the  file
     pointer for one of the two handles  also  moves  the  file
     pointer associated with the other.                        
   - This function is commonly used to  redirect  the  standard
     input and output handles to another file or device  before
     a child process is executed with Int 21H Function 4BH.    
                                                               
                                                               
                                                               
                                                               
   7.4.10. Int 21H Function 4EH                                
                                                               
                                                               
Description:                                                   
            Find First File                                    
                                                               
                                                               
   Given a file specification in the form of an ASCIIZ  string,
searches the default or specified directory on the  default  or
specified drive for the first matching file.                   
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                Interrupt 21H, File Operations                 
Input                                     Output               
------------------------------            ---------------------
AH=4EH                                    If function successfu
CX=attribute to use in search              ing file found)     
(bits can be combined)                   Carry flag=clear      
Bit(s)   Significance (if set)            and current disk tran
  0        read-only                         filled in as follo
  1        hidden                           Byte(s)   Descripti
  2        system                           00H-14H   reserved 
  3        volume label                     15H       attribute
  4        directory                                   file or 
  5        archive                          16H-17H   file time
  6-15     reserved (0)                               bits 00H-
  DS:DX=segment:offset of ASCIIZ                       ond incr
   pathname                                            (0-29)  
                                                      bits 05H-
                                                       (0-59)  
                                                      bits 0BH-
                                                       (0-23)  
                                            18H-19H   file date
                                                      bits 00H-
                                                       (1-31)  
                                                      bits 05H-
                                                       (1-12)  
                                                      bits 09H-
                                                       (relativ
                                            1AH-1DH   file size
                                            1EH-2AH   ASCIIZ fi
                                                       extensio
                                            If function unsucce
                                             matching files)   
                                            Carry flag=set     
                                            AX=error code      
                                            AX=error code      
   7.4.11. Int 21H Function 4FH                                
Description:                                                   
            Find Next File                                     
   Assuming a previous successful call to Int 21H Function 4EH,
finds the next file in the default or  specified  directory  on
the default or specified drive that matches the  original  file
specification.                                                 
                Interrupt 21H, File Operations                 
                                                               
                                                               
                                                               
Input                           Output                         
--------------------            -------------------------------
AH=4FH                          If function successful (matchin
Assumes DTA points               found)                        
to working buffer               Carry flag=clear               
used by previous                and current disk transfer area 
successful Int 21H               as follows:                   
Function 4EH or 4FH             Byte(s)   Description          
                                00H-14H   reserved (0)         
                                  15H       attribute of matche
                                             directory         
                                  16H-17H   file time          
                                            bits 00H-04H=2-seco
                                             ments (0-29)      
                                            bits 05H-0AH=minute
                                            bits 0BH-0FH=hours 
                                  18H-19H   file date          
                                            bits 00H-04H=day (1
                                            bits 05H-08H=month 
                                            bits 09H-0FH=year (
                                             to 1980)          
                                  1AH-1DH   file size          
                                  1EH-2AH   ASCIIZ filename and
                                  If function unsuccessful (no 
                                   matching files)             
                                  Carry flag= set              
                                  AX=error code                
                                                               
                                                               
   - Use  of  this  call  assumes  that   the   original   file
     specification passed to Int 21H Function 4EH contained one
     or more * or ? wildcard characters.                       
   - When this function is called, the  current  disk  transfer
     area  (DTA)  must  contain  information  from  a  previous
     successful call to Int 21H Function 4EH or 4FH.           
                                                               
                                                               
                                                               
                                                               
   7.4.12. FindNext                                            
                                                               
                                                               
;* FindNext - Finds next entry in given directory              
;* matching specification.                                     
;* (Should be called only after successfully                   
;* calling the FindFirst procedure.)                           
;*                                                             
;* Shows:   DOS Function - 4Fh (Find Next File)                
;*          Operator - OFFSET                                  
;*                                                             
;* Params:  finfo - Pointer to 43-byte buffer.                 
;*                This must be the same buffer (or a duplicate)
;*                returned from the FindFirst procedure.       
;*                                                             
;* Return:  Short integer with error code                      
;*          0 if successful                                    
;*          1 if no more matches found                         
                                                               
FindNext PROC \                                                
        USES ds, \                                             
        finfo:PTR BYTE                                         
                Interrupt 21H, File Operations                 
        push    ds                      ; Pass far pointer     
        mov     ax, OFFSET @data:old_dta;   to old_dta         
        push    ax                                             
        call    GetDTA     ; Get current DTA address           
        add     sp, 4      ; Adjust stack                      
        LoadPtr ds, dx, finfo ; DS:DX points to 43-byte buffer 
        push    ds            ; Make this new DTA              
        push    dx                                             
        call    SetDTA        ; Set 43-byte buffer as DTA      
        add     sp, 4         ; Adjust stack                   
        mov     ah, 4Fh       ; AH = function number           
        int     21h           ; Find Next File                 
        pushf                 ; Preserve flags                 
        push    WORD PTR @data:old_dta[2] ; Pass far pointer to
        push    WORD PTR @data:old_dta[0] ;   SetDTA procedure 
        call    SetDTA        ; Restore DTA address to orig    
        sub     ax, ax        ; Set error code                 
        add     sp, 4         ; Adjust stack                   
        popf                  ; Recover flags                  
        jnc     exit          ; Exit if successful match       
        inc     ax            ; Else set error code to 1       
exit:   ret                                                    
FindNext ENDP                                                  
   7.4.13. Int 21H Function 56H                                
Description:                                                   
            Rename File                                        
   Renames a  file  and/or  moves  its  directory  entry  to  a
different directory on the same disk. In  MS-DOS  versions  3.0
and  later,  this  function  can  also  be  used  to  rename  a
directory.                                                     
Input                               Output                     
-------------------------------     -------------------------- 
AH=56H                              If function successful     
DS:DX=segment:offset of current       Carry flag=clear         
 ASCIIZ pathname                    If function unsuccessful   
ES:DI=segment:offset of new           Carry flag=set           
 ASCIIZ pathname                      AX=error code            
    1) The function fails if:                                  
          - any element of the pathname does not exist.        
          - a file with the new pathname already exists.       
          -  the  current  pathname  specification  contains  a
       different disk drive than does the new pathname.        
          - the file is being moved to the root  directory  and
       the root directory is full.                             
          - [3.0+] the program is running on a network and  the
       user  has  insufficient  access  rights  to  either  the
       existing file or the new directory.                     
    2) The * and ?  wildcard  characters  are  not  allowed  in
                Interrupt 21H, File Operations                 
                                                               
                                                               
       either the current or new pathname specifications.      
                                                               
                                                               
                                                               
                                                               
   7.4.14. Int 21H Function 57H                                
                                                               
                                                               
Description:                                                   
            Get or Set File Date and Time                      
                                                               
                                                               
   Obtains or modifies the date and  time  stamp  in  a  file's
directory entry.                                               
                                                               
Input                                  Output                  
---------------------------------      ----------------------  
If getting date and time               If function successful  
AH=57H                                   Carry flag=clear      
AL=00H                                   and, if called with   
BX=handle                                AL=00H                
If setting date and time                 CX=time               
AH=57H                                   DX=date               
AL=01H                                 If function unsuccessful
BX=handle                                Carry flag=set        
CX=time                                  AX=error code         
   bits 0BH-0FH=hours (0-23)                                   
   bits 05H-0AH=minutes (0-59)                                 
   bits 00H-04H=2-second increments (0-29)                     
DX=date                                                        
   bits 09H-0FH=year (relative to 1980)                        
   bits 05H-08H=month (1-12)                                   
   bits 00H-04H=day (1-31)                                     
                                                               
                                                               
   - The file must have been previously opened or created via a
     successful call to Int 21H Function 3CH, 3DH, 5AH, 5BH, or
     6CH.                                                      
   - If the 16-bit date for a file is set to zero, that  file's
     date and time are not displayed on directory listings.    
   - A date and time set with this function will prevail,  even
     if the file is modified afterwards before  the  handle  is
     closed.                                                   
                                                               
                                                               
                                                               
                                                               
   7.4.15. Int 21H Function 5AH                                
                                                               
                                                               
Description:                                                   
            Create Temporary File DOS 3 Only                   
                                                               
                                                               
   Creates a file  with  a  unique  name,  in  the  current  or
specified directory on the default or specified disk drive, and
returns a handle that can be used by the program for subsequent
access to the file. The name generated for  the  file  is  also
returned in a buffer specified by the program.                 
                                                               
                                                               
                                                               
                                                               
                Interrupt 21H, File Operations                 
Input                                 Output                   
-----------------------------------   -------------------------
AH=5AH                                If function successful   
CX=attribute (bits can be combined)     Carry flag=clear       
 Bit(s)  Significance (if set)          AX=handle              
  0       read-only                     DS:DX=segment:offset of
  1       hidden                        complete ASCIIZ pathnam
  2       system                      If function unsuccessful 
  3-4     reserved (0)                  Carry flag=set         
  5       archive                       AX=error code          
  6-15    reserved (0)                                         
DS:DX=segment:offset of ASCIIZ path                            
    1) The ASCIIZ path supplied  to  this  function  should  be
       followed by at  least  13  additional  bytes  of  buffer
       space. MS-DOS adds a backslash (\) to the supplied path,
       if necessary, then appends  a  null-terminated  filename
       that is a function of the current time.                 
    2) Files created with this function are  not  automatically
       deleted when the calling program terminates.            
    3) The function fails if                                   
          - any element of the pathname does not exist.        
          - the file is being created in the root directory and
       the root directory is full.                             
    4) [3.0+] If the program is running on a network, the  file
       is  created  and  opened  for   read/write   access   in
       compatibility sharing mode.                             
    5) See also Int 21H Functions  3CH,  5BH,  and  6CH,  which
       provide additional facilities for creating files.       
   7.4.16. Int 21H Function 5BH                                
Description:                                                   
            Create New File DOS 3 Only                         
   Given an ASCIIZ pathname, creates a file in  the  designated
or default directory on the designated  or  default  drive  and
returns a handle that can be used by the program for subsequent
access to the file. If  a  file  with  the  same  name  already
exists, the function fails.                                    
Input                                Output                    
-----------------------------------  ------------------------- 
AH=5BH                               AH=5BH                    
CX=attribute (bits can be combined)  If function sucessful     
  Bit(s)   Significance (if set)        Carry flag=clear       
    0        read-only                  AX=handle              
    1        hidden                  If function unsucessful   
    2        system                     Carry flag=set         
    3        volume label               AX=error code          
    4        reserved (0)                                      
    5        archive                                           
    6-15     reserved (0)                                      
DS:DX=segment:offset of ASCIIZ pathname                        
                Interrupt 21H, File Operations                 
                                                               
                                                               
    1) The function fails if:                                  
          - any element of the specified path does not exist.  
          - a file with the identical pathname (i.e., the  same
       filename and extension  in  the  same  location  in  the
       directory structure) already exists.                    
          - the file is being created in the root directory and
       the root directory is full.                             
          - [3.0+] the program is running on a network and  the
       user has insufficient access  rights  to  the  directory
       that will contain the file.                             
    2) The file is usually given the normal attribute (0)  when
       it is created, and is opened for  both  read  and  write
       operations. The attribute can subsequently  be  modified
       with Int 21H Function 43H.                              
    3) See also Int 21H Functions  3CH,  5AH,  and  6CH,  which
       provide alternative ways of creating files.             
    4) This function may be used to implement semaphores  in  a
       network or multitasking  environment.  If  the  function
       succeeds, the program has  acquired  the  semaphore.  To
       release the semaphore, the program  simply  deletes  the
       file.                                                   
                                                               
                                                               
                                                               
                                                               
   7.4.17. CreateNewFile                                       
                                                               
                                                               
;* CreateNewFile - Creates a new file with specified attribute.
;* Differs from the CreateFile procedure in that it returns an 
;* error if file already exists. For DOS versions 3.0 and highe
;*                                                             
;* Shows:   DOS Function - 5Bh (Create New File)               
;*                                                             
;* Params:  attr - Attribute code                              
;*          (see header comments for CreateFile)               
;*          fspec - Pointer to ASCIIZ file specification       
;*                                                             
;* Return:  Short integer with file handle or -1 for error     
                                                               
CreateNewFile PROC \                                           
        USES ds, \                                             
        attr:WORD, fspec:PTR BYTE                              
                                                               
        LoadPtr ds, dx, fspec       ; Point DS:DX to file spec 
        mov     cx, attr            ; CX = attribute           
        mov     ah, 5Bh             ; AH = function number     
        int     21h                 ; Create New File          
        jnc     exit                ; Return AX = handle if ok 
        mov     ax, -1              ; Else set error code      
exit:   ret                                                    
                                                               
CreateNewFile ENDP                                             
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                Interrupt 21H, File Operations                 
   7.4.18. Int 21H Function 67H                                
Description:                                                   
            Set Handle Count DOS 3.3 Only                      
   Sets the maximum number of files and  devices  that  may  be
opened simultaneously using handles by the current process.    
Input                                 Output                   
------------------------------        ------------------------ 
AH=67H                                If function successful   
BX=number of desired handles          Carry flag=clear         
                                      If function unsuccessful 
                                      Carry flag=set           
                                      AX=error code            
   - This function call controls the size  of  the  table  that
     relates handle numbers for the current process to MS-DOS's
     internal, global table for  all  of  the  open  files  and
     devices in the system. The default table is located in the
     reserved area of the process's PSP and is large enough for
     20 handles.                                               
   - The function fails if the requested number of  handles  is
     greater than 20 and there is not sufficient free memory in
     the system to allocate a new block to  hold  the  enlarged
     table.                                                    
   - If the number of handles  requested  is  larger  than  the
     available entries in the system's global  table  for  file
     and device handles  (controlled  by  the  FILES  entry  in
     CONFIG.SYS), no error is returned. However,  a  subsequent
     attempt to open a file or device, or create  a  new  file,
     will fail if all of the entries  in  the  system's  global
     file table are in use, even if the requesting process  has
     not used up all of its own handles.                       
   7.5. Interrupt 21H, File Operations, FCB                    
   You can perform all the functions  below  more  easily  with
DOS2 functions. The services below are documented  so  you  can
analyze code written for DOS1.                                 
Hex #  Dec #     Name                                          
0FH     15       Open File                                     
10H     16       Close File                                    
11H     17       Find First File                               
12H     18       Find Next File                                
13H     19       Delete File                                   
16H     22       Create File                                   
17H     23       Rename File                                   
23H     35       Get File Size                                 
29H     41       Parse Filename                                
             Interrupt 21H, File Operations, FCB               
                                                               
                                                               
   7.5.1. Int 21H Function 0FH                                 
                                                               
                                                               
Description:                                                   
            Open File                                          
                                                               
                                                               
   Opens  a  file  and  makes  it  available   for   subsequent
read/write operations.                                         
                                                               
Input                  Output                                  
---------------------  --------------------------------------- 
AH=0FH                 If function successful (file found)     
DS:DX=segment:offset    AL=00                                  
      of file control   and FCB filled in by MS-DOS as follows:
      block             drive field (offset 00H0=1 for drive A,
                          2 for drive B, etc.                  
                        current block field (offset 0CH)=00H   
                        record size field (offset 0EH)=0080H   
                        size field (offset 10H)=file size from 
                                                     directory 
                        date field (offset 14H)=date stamp from
                                                    directory  
                        time field (offset 16H)=time stamp from
                                                    directory  
                       If function unsuccessful (file not found
                         AL=0FFH                               
                                                               
                                                               
   - If your program is going to use a record size  other  than
     128 bytes, it should set the  record  size  field  at  FCB
     offset 0EH after  the  file  is  successfully  opened  and
     before any other disk operation.                          
   - If random access is to be performed, the  calling  program
     must also set the FCB relative-record field  (offset  21H)
     after successfully opening the file.                      
   - For format  of  directory  time  and  date,  see  Int  21H
     Function 57H.                                             
   - Int 21H Function 3DH, which  allows  full  access  to  the
     hierarchical  directory  structure,  should  be  used   in
     preference to this function.                              
   - [3.0+] If the program is running on a network, the file is
     opened for  read/write  access  in  compatibility  sharing
     mode.                                                     
                                                               
                                                               
                                                               
                                                               
   7.5.2. Int 21H Function 10H                                 
                                                               
                                                               
Description:                                                   
            Close File                                         
                                                               
                                                               
   Closes a file, flushes  all  MS-DOS  internal  disk  buffers
associated  with  the  file  to  disk,  and  updates  the  disk
directory if the file has been modified or extended.           
                                                               
                                                               
                                                               
                                                               
             Interrupt 21H, File Operations, FCB               
Input                          Output                          
----------------------------   --------------------------------
AH=10H                         If function successful (director
DS:DX=segment:offset of file      update successful)           
      control block              AL=00H                        
                               If function unsuccessful (file  
                                  not found in directory)      
                                 AL=FFH                        
   - MS-DOS versions 1.x and 2.x do not reliably detect a  disk
     change, and an error can occur if the user  changes  disks
     while a file is still open on that  drive.  In  the  worst
     case, the directory and file allocation table of the newly
     inserted disk may be damaged or destroyed.                
   - Int 21H Function 3EH should be used in preference to  this
     function.                                                 
   7.5.3. Int 21H Function 11H                                 
Description:                                                   
            Find First File                                    
   Searches the current directory on the designated drive for a
matching filename.                                             
Input                      Output                              
------------------------   --------------------------------    
AH=11H                     If function successful (matching    
DS:DX=segment:offset of       filename found)                  
      file control block     AL=00H                            
                             and buffer at current disk trans- 
                             fer area (DTA) address filled     
                             in as an unopened normal FCB      
                             or extended FCB, depending on     
                             which type of FCB was input to    
                             function                          
                           If function unsuccessful (no        
                               matching filename found)        
                             AL=FFH                            
   - Use Int 21H Function 1AH to set the  DTA  to  point  to  a
     buffer of adequate size before using this function call.  
   - The wildcard character ? is allowed in the filename in all
     versions  of  MS-DOS.  In  versions  3.0  and  later,  the
     wildcard character * may also be used in a filename. If  ?
     or * is used, this function  returns  the  first  matching
     filename.                                                 
   - An extended FCB must be used to search for files that have
     the system, hidden, read-only, directory, or  volume-label
     attributes.                                               
   - If an extended FCB is used, its attribute byte  determines
     the  type  of  search  that  will  be  performed.  If  the
     attribute byte (byte 0) contains 00H, only ordinary  files
     are found. If the volume-label attribute bit is set,  only
             Interrupt 21H, File Operations, FCB               
                                                               
                                                               
     volume labels will be returned (if any  are  present).  If
     any other attribute or combination of  attributes  is  set
     (such as hidden, system, or read-only),  those  files  and
     all ordinary files will be matched.                       
   - Int 21H Function 4EH, which  allows  full  access  to  the
     hierarchical  directory  structure,  should  be  used   in
     preference to this function.                              
                                                               
                                                               
                                                               
                                                               
   7.5.4. Int 21H Function 12H                                 
                                                               
                                                               
Description:                                                   
            Find Next File                                     
                                                               
                                                               
   Given that a previous call to Int 21H Function 11H has  been
successful, returns the next matching filename (if any).       
                                                               
Input                       Output                             
------------------------    --------------------------------   
AH=12H                      If function successful (matching   
DS:DX=segment:offset of        filename found)                 
     file control block       AL=00H                           
                              and buffer at current disk trans-
                              fer area (DTA) address set up    
                              as an unopened normal FCB or     
                              extended FCB, depending on       
                              which type of FCB was originally 
                              input to Int 21H Function 11H    
                            If function unsuccessful (no more  
                                    matching filenames found)  
                              AL=FFH                           
                                                               
                                                               
   - This function assumes that the FCB used as input has  been
     properly  initialized  by  a  previous  call  to  Int  21H
     Function 11H (and possible subsequent  calls  to  Int  21H
     Function 12H) and that the  filename  or  extension  being
     searched for contained at least one wildcard character.   
   - As with Int 21H Function 11H, it is important to  use  Int
     21H Function 1AH to set the DTA to a  buffer  of  adequate
     size before using this function.                          
   - Int 21H Functions 4EH and 4FH, which allow full access  to
     the hierarchical directory structure, should  be  used  in
     preference to this function.                              
                                                               
                                                               
                                                               
                                                               
   7.5.5. Int 21H Function 13H                                 
                                                               
                                                               
Description:                                                   
            Delete File                                        
                                                               
                                                               
   Deletes all matching files from the current directory on the
default or specified disk drive.                               
             Interrupt 21H, File Operations, FCB               
Input                        Output                            
--------------------------   --------------------------------  
AH=13H                       If function successful (file or   
DS:DX=segment:offset of                        files deleted)  
       file control block      AL=00H                          
                             If function unsuccessful (no      
                                matching files were found, or  
                                at least one matching file was 
                                read-only)                     
                               AL=FFH                          
   - The wildcard character ? is allowed in the filename; if  ?
     is present and there is more than one  matching  filename,
     all matching files will be deleted.                       
   - Int 21H Function 41H, which  allows  full  access  to  the
     hierarchical  directory  structure,  should  be  used   in
     preference to this function.                              
   - [3.0+] If the program is running on a  network,  the  user
     must have Create rights to the  directory  containing  the
     file to be deleted.                                       
   7.5.6. Int 21H Function 16H                                 
Description:                                                   
            Create File                                        
   Creates a new directory entry in the  current  directory  or
truncates any existing file with the same name to zero  length.
Opens the file for subsequent read/write operations.           
Input                 Output                                   
--------------------  ---------------------------------------- 
AH=16H                If function successful (file was created 
DS:DX=segment:offset     or truncated)                         
    of unopened file    AL=00H                                 
    control block       and FCB filled in by MS-DOS as follows:
                        drive field (offset 00H)=1 for drive A,
                                            2 for drive B, etc.
                        current block field (offset 0CH)=00H   
                        record size field (offset 0EH)=0080H   
                        size field (offset 10H)=file size      
                                           from directory      
                        date field (offset 14H)=date stamp     
                                            from directory     
                        time field (offset 16H)=time stamp     
                                            from directory     
                      If function unsuccessful (directory full)
                        AL=FFH                                 
             Interrupt 21H, File Operations, FCB               
                                                               
                                                               
   7.5.7. Int 21H Function 17H                                 
                                                               
                                                               
Description:                                                   
            Rename File                                        
                                                               
                                                               
   Alters the  name  of  all  matching  files  in  the  current
directory on the disk in the specified drive.                  
                                                               
Input                   Output                                 
---------------------   -------------------------------------  
AH=17H                  If function successful (one or more    
DS:DX=segment:offset       files renamed)                      
    of "special" file     AL=00H                               
    control block       If function unsuccessful (no matching  
                           files, or new filename matched an   
                           existing file)                      
                         AL=FFH                                
                                                               
                                                               
   - The special file control block has a drive code, filename,
     and extension in the usual position (bytes 0 through  0BH)
     and a second filename starting 6  bytes  after  the  first
     (offset 11H).                                             
   - The  ?  wildcard  character  can  be  used  in  the  first
     filename. Every file matching the first file specification
     will be renamed to match the second file specification.   
   - If the second file specification contains any  ?  wildcard
     characters,  the  corresponding  letters  in   the   first
     filename are left unchanged.                              
   - The function terminates if the new name to be assigned  to
     a file matches that of an existing file.                  
   - An extended FCB can be used with this function to rename a
     directory.                                                
   - Int 21H Function 56H, which  allows  full  access  to  the
     hierarchical  directory  structure,  should  be  used   in
     preference to this function.                              
                                                               
                                                               
                                                               
                                                               
   7.5.8. Int 21H Function 23H                                 
                                                               
                                                               
Description:                                                   
            Get File Size                                      
                                                               
                                                               
   Searches for a matching file in the  current  directory;  if
one is found, updates the FCB with the file's size in terms  of
number of records.                                             
                                                               
                                                               
                                                               
                                                               
                                                               
             Interrupt 21H, File Operations, FCB               
Input                    Output                                
----------------------   ------------------------------------- 
AH=23H                   If function successful (matching file 
DS:DX=segment:offset                            found)         
    of unopened file       AL=00                               
      control block        and FCB relative-record field (offse
                           21H) set to the number of records in
                           the file, rounded up if necessary to
                           the next complete record            
                         If function unsuccessful (no matching 
                                                  file found)  
                           AL=FFH                              
   - An appropriate value must be placed in the FCB record size
     field (offset 0EH) before calling this function. There  is
     no default record size for this function. Compare with the
     FCB-related open and create functions (Int  21H  Functions
     0FH and 16H), which  initialize  the  FCB  for  a  default
     record size of 128 bytes.                                 
   - The record size field can be set to 1 to find the size  of
     the file in bytes.                                        
   - Because record numbers are zero based, this  function  can
     be used to position the FCB's file pointer to the  end  of
     file.                                                     
   7.5.9. Int 21H Function 29H                                 
Description:                                                   
            Parse Filename                                     
   Parses a text string into  the  various  fields  of  a  file
control block (FCB).                                           
             Interrupt 21H, File Operations, FCB               
                                                               
                                                               
                                                               
Input                                Output                    
-----------------------------------  --------------------------
AH=29H                               AL=00H  if no wildcard cha
AL=flags to control parsing                  acters encountered
Bit 3=1  if the extension field in                             
         FCB will be modified only      01H  if parsed string  
         if an extension is speci-           contained wild-   
         fied in the string being            card characters   
         parsed.                                               
     =0  if the extension field in                             
         FCB will be modified re-       FFH  if drive specifier
         gardless; if no extension           invalid           
         is present in the parsed                              
         string, FCB extension is    DS:SI=segment:offset of   
         set to ASCII blanks.              first character afte
Bit 2=1  if the filename field in          parsed filename     
         FCB will be modified only                             
         if a filename is specified  ES:DI=segment:offset of   
         in the string being parsed.       formatted unopened  
     =0  if the filename field in          file control block  
         FCB will be modified regard-                          
         less; if no filename is pre-                          
         sent in the parsed string,                            
         FCB filename is set to ASCII                          
         blanks.                                               
Bit 1=1  if the drive ID byte in FCB                           
         will be modified only if a                            
         drive was specified in the                            
         string being parsed.                                  
     =0  if the drive ID byte in FCB                           
         will be modified regardless;                          
         if no drive specifier is pre-                         
         sent in the parsed                                    
         string, FCB drive-code field                          
         is set to 0 (default).                                
Bit 0=1  if the leading separators will                        
         be scanned off (ignored).                             
     =0  if the leading separators will                        
         not be scanned off.                                   
DS:SI=segment:offset of text string                            
ES:DI=segment:offset of file controlblock                      
                                                               
                                                               
                                                               
                                                               
   7.6. Interrupt 21H, Memory-Allocation Functions             
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
48H     72       Allocate Memory Block                         
49H     73       Release Memory Block                          
4AH     74       Resize Memory Block                           
58H     88       Get or Set Allocation Strategy                
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
          Interrupt 21H, Memory-Allocation Functions           
   7.6.1. Int 21H Function 48H                                 
Description:                                                   
            Allocate Memory Block                              
   Allocates a block of memory and returns  a  pointer  to  the
beginning of the allocated area.                               
Input                     Output                               
-----------------------   ----------------------------------   
AH=48H                    If function successful               
BX=number of paragraphs     Carry flag=clear                   
   of memory needed         AX=initial segment of allocated    
                            block                              
                          If function unsuccessful             
                            Carry flag=set                     
                            AX=error code                      
                            BX=size of largest available block 
                               (paragraphs)                    
   - If the function succeeds, the base address  of  the  newly
     allocated block is AX:0000.                               
   - The default allocation strategy used by MS-DOS  is  "first
     fit"; that is, the memory block at the lowest address that
     is large enough to satisfy the request is  allocated.  The
     allocation strategy can be altered with Int  21H  Function
     58H.                                                      
   - When a .COM  program  is  loaded,  it  ordinarily  already
     "owns" all of the memory in the  transient  program  area,
     leaving none for dynamic allocation. The amount of  memory
     initially allocated to a .EXE program at load time depends
     on the MINALLOC and  MAXALLOC  fields  in  the  .EXE  file
     header. See Int 21H Function 4AH.                         
   7.6.2. Int 21H Function 49H                                 
Description:                                                   
            Release Memory Block                               
   Releases a memory block and makes it available  for  use  by
other programs.                                                
Input                         Output                           
-------------------------     ------------------------         
AH=49H                        If function successful           
ES=segment of block to be       Carry flag=clear               
   released                   If function unsuccessful         
                                Carry flag=set                 
                                AX=error code                  
    1) This  function  assumes  that  the  memory  block  being
       released was previously obtained by a successful call to
       Int 21H Function 48H.                                   
          Interrupt 21H, Memory-Allocation Functions           
                                                               
                                                               
    2) The function will fail or can cause unpredictable system
       errors if:                                              
          - the program releases a memory block that  does  not
       belong to it.                                           
          - the segment address passed in register ES is not  a
       valid base address for an existing memory block.        
                                                               
                                                               
                                                               
                                                               
   7.6.3. Int 21H Function 4AH                                 
                                                               
                                                               
Description:                                                   
            Resize Memory Block                                
                                                               
                                                               
   Dynamically shrinks or extends a memory block, according  to
the needs of an application program.                           
                                                               
Input                          Output                          
----------------------------   --------------------------------
AH=4AH                         If function successful          
BX=desired new block size in     Carry flag=clear              
   paragraphs                  If function unsuccessful        
ES=segment of block to be        Carry flag=set                
   modified                      AX=error code                 
                                 BX=maximum block size availabl
                                    (paragraphs)               
                                                               
                                                               
   - This function modifies the size of a memory block that was
     previously allocated with a call to Int 21H Function  48H.
   - If the program is requesting an increase in the size of an
     allocated block, and  this  function  fails,  the  maximum
     possible size for  the  specified  block  is  returned  in
     register BX. The program can use this value  to  determine
     whether it should terminate, or  continue  in  a  degraded
     fashion with less memory.                                 
   - A program that uses EXEC (Int 21H Function  4BH)  to  load
     and execute a child program must call this function first,
     passing the address of its own PSP in register ES and  the
     amount of memory needed for its own code, data, and stacks
     in register BX.                                           
                                                               
                                                               
                                                               
                                                               
   7.6.4. Int 21H Function 58H                                 
                                                               
                                                               
Description:                                                   
            Get or Set Allocation Strategy DOS 3 Only          
                                                               
                                                               
   Obtains or changes the code indicating  the  current  MS-DOS
strategy for allocating memory blocks.                         
                                                               
                                                               
                                                               
                                                               
                                                               
          Interrupt 21H, Memory-Allocation Functions           
Input                               Output                     
------------------------            ---------------------------
If getting strategy code            If function successful     
AH=58H                              Carry flag=clear           
AL=00H                              and, if called with AL=00H 
If setting strategy code            AX=error code              
AH=58H                              If function unsuccessful   
AL=01H                              Carry flag=set             
BX=desired strategy code            AX=error code              
     00H=first fit                                             
     01H=best fit                                              
     02H=last fit                                              
   - The memory allocation strategies are:                     
        First Fit: MS-DOS searches the available memory  blocks
     from low addresses to high addresses, assigning the  first
     one large enough to satisfy the block allocation  request.
        Best Fit: MS-DOS searches all available  memory  blocks
     and assigns the smallest available block that will satisfy
     the request, regardless of its position.                  
        Last Fit: MS-DOS searches the available  memory  blocks
     from  high  addresses  to  low  addresses,  assigning  the
     highest one large enough to satisfy the  block  allocation
     request.                                                  
   - The default MS-DOS memory allocation strategy is First Fit
     (code 0).                                                 
   7.7.  Interrupt   21H,   Miscellaneous   System             
   Functions                                                   
Hex #  Dec #     Name                                          
25H     37       Set Interrupt Vector                          
30H     48       Get MS-DOS Version Number                     
33H     51       Get or Set Break Flag                         
35H     53       Get Interrupt Vector                          
38H     56       Get or Set Country Information                
44H     68       IOCTL (I/O Control)                           
59H     89       Get Extended Error Information                
5EH     94       Get Machine Name, Get or Set Printer Setup    
5FH     95       Device Reallocation                           
63H     99       Get Lead Byte Table                           
65H    101       Get Extended Country Information              
66H    102       Get or Set Code Page                          
   7.7.1. Int 21H Function 25H                                 
Description:                                                   
            Set Interrupt Vector                               
   Initializes a CPU interrupt vector to point to an  interrupt
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
handling routine.                                              
                                                               
Input                                        Output            
---------------------------------            -------           
AH=25H                                       Nothing           
AL=interrupt number                                            
DS:DX=segment:offset of interrupt                              
      handling routine                                         
                                                               
                                                               
   - This function should  be  used  in  preference  to  direct
     editing of the  interrupt  vector  table  by  well-behaved
     applications.                                             
   - Before an interrupt vector is modified, its original value
     should be obtained with Int 21H Function 35H and saved, so
     that it can be restored using this function before program
     termination.                                              
                                                               
                                                               
                                                               
                                                               
   7.7.2. Exec                                                 
                                                               
                                                               
                                                               
;* Exec - Executes a child process.                            
;* Exec handles the usual chores associated                    
;* with spawning a process:                                    
;* (1) parsing the command line tail and loading the           
;* FCBs with the first two arguments;                          
;* (2) setting and restoring the vectors                       
;* for Interrupts 1Bh, 23h, and 24h; and                       
;* (3) querying DOS for the child's return code.               
;*                                                             
;* Shows:   DOS Functions - 29h (Parse Filename)               
;*                          25h (Set Interrupt Vector)         
;*                          35h (Get Interrupt Vector)         
;*                          4Bh (Execute Program)              
;*                          4Dh (Get Return Code)              
;*                                                             
;* Params:  spec - Pointer to ASCIIZ specification             
;*                 for program file                            
;*                 (must include .COM or .EXE extension)       
;*          block - Pointer to parameter block structure       
;*          break - Pointer to new Ctrl-Break                  
;*                  (Interrupt 1Bh) handler                    
;*          ctrlc - Pointer to new Ctrl-C                      
;*                  (Interrupt 23h) handler                    
;*          criterr - Pointer to new Critical Error            
;*                  (Interrupt 24h) handler                    
;*                                                             
;* Return:  Short integer with child return code,              
;*                or -1 for EXEC error                         
                                                               
Exec    PROC \                                                 
        USES ds si di, \                                       
        spec:PTR BYTE, block:PTR parmblk, break:PTR BYTE, \    
        ctrlc:PTR BYTE, criterr:PTR BYTE                       
                                                               
        jmp     SHORT @F      ; Jump over data area            
                                                               
old_1Bh DD      WORD PTR ?    ; Keep vectors for Interrupts    
        Interrupt 21H, Miscellaneous System Functions          
old_23h DD      WORD PTR ?    ;   1Bh, 23h, and 24h in         
old_24h DD      WORD PTR ?    ;   code segment                 
old_stk DD      WORD PTR ?    ; Keep stack pointer             
@@:     Vector 1Bh, cs:old_1Bh, break                          
                    ; Save, replace Int 1Bh vector             
        Vector 23h, cs:old_23h, ctrlc                          
                    ; Save, replace Int 23h vector             
        Vector 24h, cs:old_24h, criterr                        
                    ; Save, replace Int 24h vector             
        LoadPtr ds, bx, block ; Point DS:BX to parameter block 
        push    ds            ; Save segment address           
        les     di, [bx].fcb1 ; Point ES:DI to first FCB       
        lds     si, [bx].taddr; Point DS:SI to command line tai
        inc     si            ; Skip over count byte           
        mov     ax, 2901h     ; Set AH to request Function 29h 
                              ; AL = flag to skip leading blank
        int     21h        ; Parse command-line into first FCB 
        pop     es         ; Recover seg addr of parameter bloc
        les     di, es:[bx].fcb2 ; Point ES:DI to second FCB   
        mov     ax, 2901h  ; Request DOS Function #29h again   
        int     21h        ; Parse command-line into second FCB
        push    bp         ; Save only important register      
        mov     WORD PTR cs:old_stk[0], sp                     
        mov     WORD PTR cs:old_stk[2], ss                     
        LoadPtr es, bx, block  ; ES:BX points to param block   
        LoadPtr ds, dx, spec   ; DS:DX points to path spec     
        mov     ax, 4B00h      ; AH = DOS Function 4Bh         
                               ; AL = 0 for load and execute   
        int     21h            ; Execute Program               
                               ; Reset stack pointers          
        mov     sp, WORD PTR cs:old_stk[0]                     
        mov     ss, WORD PTR cs:old_stk[2]                     
        pop     bp             ; Recover saved register        
; Restore vectors for Interrupts 1Bh, 23h, and 24h.            
        mov     ax, 251Bh      ; AH = DOS Function 25h         
                               ; AL = interrupt number         
        lds     dx, cs:old_1Bh ; DS:DX = original vector       
        int     21h            ; Set Interrupt 1Bh Vector      
        mov     al, 23h        ; AL = interrupt number         
        lds     dx, cs:old_23h ; DS:DX = original vector       
        int     21h            ; Set Interrupt 23h Vector      
        mov     al, 24h        ; AL = interrupt number         
        lds     dx, cs:old_24h ; DS:DX = original vector       
        int     21h            ; Set Interrupt 24h Vector      
        mov     ax, -1         ; Set error code                
        jc      exit           ; If EXEC error, exit           
        mov     ah, 4Dh        ; Else request child's code     
        int     21h            ; Get Return Code               
        sub     ah, ah         ; Make short integer            
exit:   ret                                                    
Exec    ENDP                                                   
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
   7.7.3. Int 21H Function 30H                                 
                                                               
                                                               
Description:                                                   
            Get MS-DOS Version Number                          
                                                               
                                                               
   Returns the version number  of  the  host  MS-DOS  operating
system. This  function  is  used  by  application  programs  to
determine the capabilities of their environment.               
                                                               
Input    Output                                                
------   ---------------------------------------------------   
AH=30H   If running under MS-DOS version 1                     
AL=00H   If running under MS-DOS version 2.0 and later         
            AL=major version number (MS-DOS 3.1 = 3, etc.)     
            AH=minor version number (MS-DOS 3.1 = 0AH, etc.)   
            BH=Original Equipment Manufacturer's (OEM's) serial
               number (OEM dependent--usually 00H for IBM's    
               PC-DOS, 0FFH or other values for MS-DOS)        
            BL:CX=24-bit user serial number (optional, OEM     
                  dependent)                                   
                                                               
                                                               
   - Because this function was not defined under MS-DOS 1.x, it
     should always be called with AL = 00.  In  an  MS-DOS  1.x
     environment, AL will be returned unchanged.               
   - Care must be taken not to exit in an unacceptable  fashion
     if an MS-DOS 1.x environment is detected. For example, Int
     21H Function 4CH (Terminate Process with Return Code), Int
     21H Function 40H  (Write  to  File  or  Device),  and  the
     standard error handle are not available in MS-DOS 1.x.  In
     such cases a program should display an error message using
     Int 21H Function 09H and then terminate with  Int  20H  or
     Int 21H Function 00H.                                     
                                                               
                                                               
                                                               
                                                               
   7.7.4. Int 21H Function 33H                                 
                                                               
                                                               
Description:                                                   
            Get or Set Break Flag                              
                                                               
                                                               
   Obtains or changes the  status  of  the  operating  system's
Break flag, which influences CTRL+C  checking  during  function
calls. Also returns the system boot drive in version 4.0.      
                                                               
Input                               Output                     
--------------------------------    -------------------------- 
If getting Break flag               DL=00H  Break flag is OFF  
AH=33H                                 01H  Break flag is ON   
AL=00H                                                         
If setting Break flag                                          
AH=33H                                                         
AL=01H                                                         
DL=00H  if turning Break flag OFF                              
   01H  if turning Break flag ON                               
                                                               
                                                               
        Interrupt 21H, Miscellaneous System Functions          
   - When the system Break flag is on, the keyboard is examined
     for a CTRL+C entry whenever any operating system input  or
     output is  requested;  if  one  is  detected,  control  is
     transferred to the CTRL+C  handler  (Int  23H).  When  the
     Break flag is off, MS-DOS checks for a CTRL+C  entry  only
     when executing the  traditional  character  I/O  functions
     (Int 21H Functions 01H through 0CH).                      
   - The Break flag is not part of the local environment of the
     currently executing program; it affects all  programs.  An
     application that alters the flag  should  first  save  the
     flag's original status and then restore  the  flag  before
     terminating.                                              
   7.7.5. Int 21H Function 35H                                 
Description:                                                   
            Get Interrupt Vector                               
   Obtains the address of the current interrupt handler routine
for the specified machine interrupt.                           
Input                 Output                                   
-------------------   -----------------------------------------
AH=35H                ES:BX=segment:offset of interrupt handler
AL=interrupt number                                            
   - Together with Int 21H Function 25H (Set Interrupt Vector),
     this function is used by well-behaved application programs
     to modify or inspect the machine interrupt vector table.  
   7.7.6. Int 21H Function 38H                                 
Description:                                                   
            Get or Set Country Information                     
   Obtains internationalization  information  for  the  current
country. [3.0+] Obtains  internationalization  information  for
the current or specified country, or sets the  current  country
code.                                                          
Input                            Output                        
------------------------------   ----------------------------- 
If getting internationaliza-     If function successful        
tion information                   Carry Flag=clear            
AH=38H                             and, if getting internationa
AL=0  to get "current" coun-       ization information         
      try information             BX=country code              
DS:DX=segment:offset of buffer    DS:DX=segment:offset of buffe
      for returned information      holding internationalizatio
[3.0+]                              information filled in as   
AH=38H                              follows:                   
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
AL=0  to get "current" coun-        (for PC-DOS 2.0 and 2.1)   
      try information               Byte(s)   Contents         
 1-FEH  to get information          00H-01H   date format      
        for countries with            0=USA    m d y           
        code < 255                    1=Europe d m y           
 FFH    to get information            2=Japan  y m d           
        for countries with          02H-03H   ASCIIZ currency  
        code >= 255                           symbol           
BX=country code, if AL = FFH        04H-05H   ASCIIZ thousands 
DS:DX=segment:offset of buffer                separator        
      for returned information      06H-07H   ASCIIZ decimal   
If setting current country code               separator        
(MS-DOS versions 3.0 and later)     08H-1FH  reserved          
AH=38H                              (for MS-DOS versions 2.0 an
AL=1-0FEH  country code for coun-    later, PC-DOS versions 3.0
           tries with code < 255     and later)                
   0FFH  for countries with code    Byte(s)   Contents         
         >= 255                     00H-01H   date format      
BX=country code, if AL = 0FFH         0=USA    m d y           
DX=FFFFH                              1=Europe d m y           
                                      2=Japan  y m d           
                                    02H-06H   ASCIIZ currency  
                                              symbol string    
                                    07H-08H   ASCIIZ thousands 
                                              separator char-  
                                              acter            
                                    09H-0AH   ASCIIZ decimal   
                                              separator char-  
                                              acter            
                                    0BH-0CH   ASCIIZ date sep- 
                                              arator charactor 
                                    0DH-0EH   ASCIIZ time sep- 
                                              arator charactor 
                                    0FH       currency format  
                                      bit 0=0 if currency symbo
                                              precedes value   
                                      bit 0=1 if currency symbo
                                              follows value    
                                      bit 1=0 if no space betwe
                                              value and currenc
                                              symbol           
                                      bit 1=1 if one space betw
                                              value and cur-   
                                              rency symbol     
                                      bit 2=0 if currency symbo
                                              and decimal are  
                                              separate         
                                      bit 2=1 if currency symbo
                                              replaces dec-    
                                              imal separator   
                                    10H      number of digits  
                                             after decimal in  
                                             currency          
                                    11H      time format       
                                      bit0=0 if 12-hour clock  
                                      bit0=1 if 24-hour clock  
                                    12H-15H  case-map call     
                                             address           
                                    16H-17H  ASCIIZ data-list  
                                             separator         
                                    18H-21H  reserved          
                                 If function unsuccessful      
                                                               
        Interrupt 21H, Miscellaneous System Functions          
                                   Carry flag=set              
                                   AX=error code               
   7.7.7. Int 21H Function 44H                                 
Description:                                                   
            IOCTL (I/O Control)                                
   Provides  a  direct  path  of   communication   between   an
application program and a device driver. Allows  a  program  to
obtain hardware-dependent information and to request operations
that are not supported by other MS-DOS function calls.         
   The IOCTL subfunctions and the MS-DOS versions in which they
first became available are:                                    
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
                                                               
                                                MS-DOS         
Subfunction  Name                               version        
-----------  ---------------------------------  -------        
00H          Get Device Information             2.0            
01H          Set Device Information             2.0            
02H          Receive Control Data from          2.0            
             Character Device Driver                           
03H          Send Control Data to Character     2.0            
             Device Driver                                     
04H          Receive Control Data from Block    2.0            
             Device Driver                                     
05H          Send Control Data to Block         2.0            
             Device Driver                                     
06H          Check Input Status                 2.0            
07H          Check Output Status                2.0            
08H          Check If Block Device Is           3.0            
             Removable                                         
09H          Check If Block Device Is Remote    3.1            
0AH          Check If Handle Is Remote          3.1            
0BH          Change Sharing Retry Count         3.1            
0CH          Generic I/O Control for Character                 
             Devices                                           
             CL = 45H: Set Iteration Count      3.2            
             CL = 4AH: Select Code Page         3.3            
             CL = 4CH: Start Code Page          3.3            
                       Preparation                             
             CL = 4DH: End Code Page            3.3            
                       Preparation                             
             CL = 5FH: Set Display Information  4.0            
             CL = 65H: Get Iteration Count      3.2            
             CL = 6AH: Query Selected Code Page 3.3            
             CL = 6BH: Query Prepare List       3.3            
             CL = 7FH: Get Display Information  4.0            
0DH          Generic I/O Control for Block Devices             
             CL = 40H: Set Device Parameters    3.2            
             CL = 41H: Write Track              3.2            
             CL = 42H: Format and Verify Track  3.2            
             CL = 47H: Set Access Flag          4.0            
             CL = 60H: Get Device Parameters    3.2            
             CL = 61H: Read Track               3.2            
             CL = 62H: Verify Track             3.2            
             CL = 67H: Get Access Flag          4.0            
0EH          Get Logical Drive Map              3.2            
0FH          Set Logical Drive Map              3.2            
                                                               
   Only IOCTL Subfunctions 00H, 06H, and 07H may  be  used  for
handles associated with files.  Subfunctions  00H-08H  are  not
supported on network devices.                                  
                                                               
                                                               
                                                               
   7.7.8. Int 21H Function 59H                                 
                                                               
                                                               
Description:                                                   
            Get Extended Error Information DOS 3 Only          
                                                               
                                                               
   Obtains  detailed  error  information   after   a   previous
unsuccessful Int 21H function call, including  the  recommended
remedial action.                                               
        Interrupt 21H, Miscellaneous System Functions          
Input     Output                                               
------    --------------------------------------------------   
AH=59H    AX=extended error code                               
BX=00     BH=error class                                       
             01H      if out of resource (such as storage      
                      or handles)                              
             02H      if not error, but temporary situation    
                      (such as locked region in file) that     
                      can be expected to end                   
             03H      if authorization problem                 
             04H      if internal error in system software     
             05H      if hardware failure                      
             06H      if system software failure not the       
                      fault of the active process (such        
                      as missing configuration files)          
             07H      if application program error             
             08H      if file or item not found                
             09H      if file or item of invalid type or format
             0AH (10) if file or item interlocked              
             0BH (11) if wrong disk in drive, bad spot on      
                      disk, or storage medium problem          
             0CH (12) if other error                           
          BL=recommended action                                
             01H      retry reasonable number of times,        
                      then prompt user to select abort or ignor
             02H      retry reasonable number of times         
                      with delay between retries, then         
                      prompt user to select abort or ignore    
             03H      get corrected information from user      
                      (typically caused by incorrect           
                      filename or drive specification)         
             04H      abort application with cleanup           
                      (i.e., terminate the program in as       
                      orderly a manner as possible,            
                      releasing locks, closing files, etc.)    
             05H      perform immediate exit without cleanup   
             06H      ignore error                             
             07H      retry after user intervention to         
                      remove cause of error                    
           CH=error locus                                      
             01H       unknown                                 
             02H       block device (disk or disk emulator)    
             03H       network                                 
             04H       serial device                           
             05H       memory                                  
and, for MS-DOS versions 3.0 and later                         
ES:DI=ASCIIZ volume label of disk to insert, if                
AX=0022H (invalid disk change)                                 
   - This function may  be  called  after  any  other  Int  21H
     function call that returned an error status, in  order  to
     obtain more detailed information about the error type  and
     the recommended action. If the previous Int  21H  function
     call had no error, 0000H is returned in register AX.  This
     function may also be called  during  the  execution  of  a
     critical-error (Int 24H) handler.                         
   - The contents of registers CL, DX, SI, DI, BP, DS,  and  ES
     are destroyed by this function.                           
   - Note that extended error codes  13H-1FH  (19-31)  and  22H
     (34) correspond exactly to the error  codes  0-0CH  (0-12)
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
     and 0FH (15) returned by Int 24H.                         
   - You should  not  code  your  programs  to  recognize  only
     specific error  numbers  if  you  want  to  ensure  upward
     compatibility, because new error codes are added  in  each
     new version of MS-DOS.                                    
                                                               
                                                               
                                                               
                                                               
   7.7.9.    Interrupt    21H,    Function     5EH             
   (Machine/Printer)                                           
                                                               
                                                               
                                                               
Interrupt  Fnct  Subfnct    Name                               
21H        5EH   00H        Get Machine Name                   
21H        5EH   02H        Set Printer Setup String           
21H        5EH   03H        Get Printer Setup String           
                                                               
                                                               
                                                               
                                                               
   7.7.9.1. Int 21H Function 5EH Subfunction 00H               
                                                               
                                                               
Description:                                                   
            Get Machine Name DOS 3.1 Only                      
                                                               
                                                               
   Returns the address of an  ASCIIZ  (null-terminated)  string
identifying the local computer.  This  function  call  is  only
available when Microsoft Networks is running.                  
                                                               
Input                    Output                                
---------------------    --------------------------------------
AH=5EH                   If function successful                
AL=00H                     Carry flag=clear                    
DS:DX=segment:offset       CH=00H     if name not defined      
 of buffer to receive      <> 00H if name defined              
 string                    CL=netBIOS name number (if CH < > 0)
                           DX:DX=segment:offset of identifier  
                           (if CH <> 0)                        
                         If function unsuccessful              
                              Carry flag=set                   
                              AX=error code                    
                                                               
                                                               
   - The computer identifier is a 15-byte string,  padded  with
     spaces and terminated with a null (00H) byte.             
   - The  effect  of  this  call  is   unpredictable   if   the
     file-sharing support module is not loaded.                
                                                               
                                                               
                                                               
                                                               
   7.7.9.2. Int 21H Function 5EH Subfunction 02H               
                                                               
                                                               
Description:                                                   
            Set Printer Setup String DOS 3.1 Only              
                                                               
                                                               
        Interrupt 21H, Miscellaneous System Functions          
   Specifies a string to be sent in front of all files directed
to a particular network printer, allowing  users  at  different
network nodes to specify individualized operating modes on  the
same  printer.  This  function  call  is  only  available  when
Microsoft Networks is running.                                 
Input                       Output                             
-------------------------   ---------------------------------- 
AH=5EH                      If function successful             
AL=02H                        Carry flag=clear                 
BX=redirection list index   If function unsuccessful           
CX=length of setup string     Carry flag=set                   
DS:SI=segment:offset of       AX=error code                    
  setup string                                                 
   - The redirection  list  index  passed  in  register  BX  is
     obtained  with   Function   5FH   Subfunction   02H   (Get
     Redirection List Entry).                                  
   - See also Function 5EH Subfunction 03H, which may  be  used
     to obtain the  existing  setup  string  for  a  particular
     network printer.                                          
   7.7.9.3. Int 21H Function 5EH Subfunction 03H               
Description:                                                   
            Get Printer Setup String DOS 3.1 Only              
   Obtains the printer setup string for  a  particular  network
printer. This function call is only  available  when  Microsoft
Networks is running.                                           
Input                            Output                        
------------------------------   ------------------------------
AH=5EH                           If function successful        
AL=03H                             Carry flag=clear            
BX=redirection list index          CX=length of printer setup  
ES:DI=segment:offset of buffer        string                   
 to receive setup string         If function unsuccessful      
                                   Carry flag=set              
                                   AX=error code               
   - The redirection  list  index  passed  in  register  BX  is
     obtained  with   Function   5FH   Subfunction   02H   (Get
     Redirection List Entry).                                  
   - See also Int 21H Function 5EH Subfunction  02H,  which  is
     used to specify a setup string for a network printer.     
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
   7.7.10. Interrupt  21H,  Function  5FH  (Device             
   Redirection)                                                
                                                               
                                                               
                                                               
Interrupt  Fnct  Subfnct    Name                               
21H        5FH   02H        Get Redirection List Entry         
21H        5FH   03H        Redirect Device                    
21H        5FH   04H        Cancel Device Redirection          
                                                               
                                                               
                                                               
                                                               
   7.7.10.1. Int 21H Function 5FH Subfunction  02H             
                                                               
                                                               
Description:                                                   
            Get Redirection List Entry DOS 3.1 Only            
                                                               
                                                               
   Allows inspection of  the  system  redirection  list,  which
associates local logical names with network files, directories,
or  printers.  This  function  call  is  only  available   when
Microsoft  Networks  is  running  and  the  filesharing  module
(SHARE.EXE) has been loaded.                                   
                                                               
Input                         Output                           
---------------------------   ---------------------------------
AH=5FH                        If function successful           
AL=02H                          Carry flag=clear               
BX=redirection list index       BH=device status flag          
DS:SI=segment:offset of            bit 0=0 if device valid     
 16-byte buffer to receive              =1 if not valid        
 local device name              BL=device type                 
ES:DI=segment:offset of            03H if printer              
 128-byte buffer to receive        04H if drive                
 network name                   CX=stored parameter value      
                                DX=destroyed                   
                                BP=destroyed                   
                                DS:SI=segment:offset of ASCIIZ 
                                      local device name        
                                ES:DI=segment:offset of ASCIIZ 
                                      network name             
                              If function unsuccessful         
                                Carry flag=set                 
                                AX=error code                  
                                                               
                                                               
   - The  parameter  returned  in  CX  is  a  value  that   was
     previously passed to MS-DOS in register CX  with  Int  21H
     Function  5FH  Subfunction  03H  (Redirect   Device).   It
     represents data that is private to the applications  which
     store and retrieve it, and has no meaning to MS-DOS.      
                                                               
                                                               
                                                               
                                                               
        Interrupt 21H, Miscellaneous System Functions          
   7.7.10.2. Int 21H Function 5FH Subfunction  03H             
Description:                                                   
            Redirect Device DOS 3.1 Only                       
   Establishes redirection across the network by associating  a
local device name with a network name. This  function  call  is
available only when  Microsoft  Networks  is  running  and  the
file-sharing module (SHARE.EXE) has been loaded.               
Input                             Output                       
------------------------------    ---------------------------- 
AH=5FH                            If function successful       
AL=03H                              Carry flag=clear           
BL=device type                    If function unsuccessful     
   03H  if printer                  Carry flag=set             
   04H  if drive                    AX=error code              
CX=parameter to save for caller                                
DS:SI=segment:offset of ASCIIZ                                 
  local device name                                            
ES:DI=segment:offset of ASCIIZ                                 
   network name, followed by                                   
   ASCIIZ password                                             
   - The local  name  can  be  a  drive  designator  (a  letter
     followed by a colon, such as "D:"), a printer name,  or  a
     null string. Printer names must be one of  the  following:
     PRN, LPT1, LPT2, or LPT3. If a null string followed  by  a
     password is used, MS-DOS attempts to grant access  to  the
     network directory with the specified password.            
   - The parameter passed in CX can be retrieved by later calls
     to Int 21H Function 5FH  Subfunction  02H.  It  represents
     data that is private to the applications which  store  and
     retrieve it, and has no meaning to MS-DOS.                
   7.7.10.3. Int 21H Function 5FH Subfunction  04H             
Description:                                                   
            Cancel Device Redirection DOS 3.1 Only             
   Cancels a  previous  redirection  request  by  removing  the
association of a local device name with a  network  name.  This
function call is only  available  when  Microsoft  Networks  is
running  and  the  file-sharing  module  (SHARE.EXE)  has  been
loaded.                                                        
Input                         Output                           
-------------------------     ------------------------------   
AH=5FH                        If function successful           
AL=04H                          Carry flag=clear               
DS:SI=segment:offset of       If function unsuccessful         
 ASCIIZ local device name       Carry flag=set                 
                                AX=error code                  
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
   - The supplied name can be  a  drive  designator  (a  letter
     followed by a colon, such as "D:"), a printer name,  or  a
     string starting with two backslashes  (\).  Printer  names
     must be one of the following: PRN, LPT1, LPT2, or LPT3. If
     the string with two backslashes is  used,  the  connection
     between the local machine and  the  network  directory  is
     terminated.                                               
                                                               
                                                               
                                                               
                                                               
   7.7.11. Int 21H Function 63H                                
                                                               
                                                               
Description:                                                   
            Get Lead Byte Table                                
                                                               
                                                               
   Obtains the address of the system table of legal  lead  byte
ranges for extended character sets,  or  sets  or  obtains  the
interim console flag. Int 21H Function 63H is available only in
MS-DOS version 2.25; it is not supported in MS-DOS versions 3.0
and later.                                                     
                                                               
Input                             Output                       
-------------------------------   -----------------------------
AH=63H                            If function successful       
AL=subfunction                      Carry flag=clear           
  00H  if getting address of        and, if called with AL=00H 
       system lead byte table       DS:SI=segment:offset of lea
  01H  if setting or clearing             byte table           
       interim console flag         or, if called with AL=02H  
  02H  if obtaining value of        DL=value of interim console
       interim console flag            flag                    
If AL=01H                         If function unsuccessful     
DL=00H  if clearing interim         Carry flag=set             
        console flag                AX=error code              
   01H  if setting interim                                     
        console flag                                           
                                                               
                                                               
   - The lead byte table  consists  of  a  variable  number  of
     2-byte entries, terminated by 2  null  (00H)  bytes.  Each
     pair defines the beginning and ending value for a range of
     lead bytes. The value of a legal lead byte  is  always  in
     the range 80-0FFH.                                        
   - Entries in the lead byte table must be in ascending order.
     If no legal lead bytes are defined in a given system,  the
     table consists only of the two null bytes.                
   - If the interim console flag is set, Int 21H Functions  07H
     (Unfiltered Character Input), 08H (Character Input without
     Echo), and 0BH  (Keyboard  Status)  will  support  interim
     characters.                                               
   - Unlike most other MS-DOS services, this function call does
     not necessarily preserve any registers except SS:SP.      
   - [4.0] The address of the DBCS lead byte table can also  be
     obtained with Int 21H Function 65H.                       
                                                               
                                                               
                                                               
                                                               
        Interrupt 21H, Miscellaneous System Functions          
   7.7.12. Int 21H Function 65H                                
Description:                                                   
            Get Extended Country Information DOS 3.3 Only      
   Obtains information about the specified country and/or  code
page.                                                          
Input                                      Output              
----------------------------------------   --------------------
AH=65H                                     If function success-
AL=subfunction                                         ful     
  01H=Get General Internationalization       Carry flag=clear  
      Information                            and requested data
  02H=Get Pointer to Uppercase Table         placed in calling 
  04H=Get Pointer to Filename Uppercase      program's buffer  
      Table                                If function unsuc-  
  06H=Get Pointer to Collating Table          cessful          
  07H=Get Pointer to DBCS Vector (MS-DOS     Carry flag=set    
      versions 4.0 and later)                AX=error code     
BX=code page of interest (-1 = active CON device)              
CX=length of buffer to receive information                     
DX=country ID (-1 = default)                                   
ES:DI=address of buffer to receive information                 
   - The information returned by this function is a superset of
     the information returned by Int 21H Function 38H.         
   - This function may fail if either the country code  or  the
     code page number is invalid or if the code page  does  not
     match the country code.                                   
   - The function fails if the specified buffer length is  less
     than five bytes. If the buffer to receive the  information
     is at least five bytes long  but  is  too  short  for  the
     requested information, the data is truncated and no  error
     is returned.                                              
   - The format of the data returned by Subfunction 01H is:    
        Interrupt 21H, Miscellaneous System Functions          
                                                               
                                                               
                                                               
  Byte(s)   Contents                                           
  -------   ----------------------------------------           
  00H       Information ID code (1)                            
  01H-02H   Length of following buffer                         
  03H-04H   Country ID                                         
  05H-06H   Code page number                                   
  07H-08H   Date format                                        
            0 = USA    m d y                                   
            1 = Europe d m y                                   
            2 = Japan  y m d                                   
  09H-0DH   ASCIIZ currency symbol                             
  0EH-0FH   ASCIIZ thousands separator                         
  10H-11H   ASCIIZ decimal separator                           
  12H-13H   ASCIIZ date separator                              
  14H-15H   ASCIIZ time separator                              
  16H       Currency format flags                              
            bit 0=0 if currency symbol precedes value          
                 =1 if currency symbol follows value           
            bit 1=0 if no space between value and              
                     currency 0 symbol                         
                 =1 if one space between value and             
                     currency symbol                           
            bit 2=0 if currency symbol and decimal             
                     are separate                              
                 =1 if currency symbol replaces                
                     decimal separator                         
  17H       Number of digits after decimal in                  
             currency                                          
  18H       Time format                                        
            bit 0=0 if 12-hour clock                           
                 =1 if 24-hour clock                           
  19H-1CH   Case-map routine call address                      
  1DH-1EH   ASCIIZ data list separator                         
  1FH-28H   Reserved                                           
                                                               
   - The format of the data returned by Subfunctions 02H,  04H,
     06H, and 07H is:                                          
                                                               
  Byte(s)   Contents                                           
  -------   -----------------------------------                
  00H       Information ID code (2, 4, 6, or 7)                
  01H-04H   Double-word pointer to table                       
                                                               
   - The uppercase and filename uppercase tables are a  maximum
     of 130 bytes long. The first two bytes contain the size of
     the table;  the  following  bytes  contain  the  uppercase
     equivalents, if any, for character codes 80H-FFH. The main
     use of these  tables  is  to  map  accented  or  otherwise
     modified vowels to their  plain  vowel  equivalents.  Text
     translated with the help of this  table  can  be  sent  to
     devices that do not support  the  IBM  graphics  character
     set, or used to create filenames that  do  not  require  a
     special keyboard configuration for entry.                 
   - The collating table is a maximum of 258  bytes  long.  The
     first  two  bytes  contain  the  table  length,  and   the
     subsequent bytes contain the values to  be  used  for  the
     corresponding  character  codes  (0-FFH)  during  a   sort
     operation. This table maps uppercase and  lowercase  ASCII
     characters to the same collating codes so that sorts  will
     be case-insensitive, and it maps accented vowels to  their
     plain vowel equivalents.                                  
        Interrupt 21H, Miscellaneous System Functions          
   - [4.0+]  Subfunction   07H   returns   a   pointer   to   a
     variable-length table that defines ranges for  double-byte
     character set (DBCS) lead bytes. The table  is  terminated
     by a pair of zero bytes, unless it must  be  truncated  to
     fit in the buffer, and has the following format:          
  dw     length                                                
  db     start1,end1                                           
  db     start2,end2                                           
  (3-vertical ellipsis)                                        
  db     0,0                                                   
  For example:                                                 
  dw     4                                                     
  db     81h,9fh                                               
  db     0e0h,0fch                                             
  db     0,0                                                   
   - In  some  cases  a  truncated  translation  table  may  be
     presented to the program by  MS-DOS.  Applications  should
     always check the length at the beginning of the  table  to
     ensure  that  it  contains  a  translation  code  for  the
     particular character of interest.                         
   7.7.13. Int 21H Function 66H                                
Description:                                                   
            Get or Set Code Page DOS 3.3 Only                  
   Obtains or selects the current code page.                   
Input                          Output                          
----------------------------   ------------------------------  
AH=66H                         If function successful          
AL=subfunction                   Carry flag=clear              
   01H=Get Code Page             and, if called with AL=01H    
   02H=Select Code Page          BX=active code page           
BX=code page to select, if       DX=default code page          
   AL=02H                      If function unsuccessful        
                                 Carry flag=set                
                                 AX=error code                 
   - When the Select Code Page subfunction is used, MS-DOS gets
     the new code page from the COUNTRY.SYS  file.  The  device
     must be previously prepared for code page  switching  with
     the appropriate DEVICE= directive in the  CONFIG.SYS  file
     and NLSFUNC and MODE CP PREPARE commands  (usually  placed
     in the AUTOEXEC.BAT file).                                
           Interrupt 21H, Process-Control Functions            
                                                               
                                                               
   7.8. Interrupt 21H, Process-Control Functions               
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
00H      0       Terminate Process                             
26H     38       Create New Program Segment Prefix (PSP)       
31H     49       Terminate and Stay Resident                   
4BH     75       Execute Program (EXEC)                        
4CH     76       Terminate Process with Return Code            
4DH     77       Get Return Code                               
62H     98       Get PSP Address                               
                                                               
                                                               
                                                               
                                                               
   7.8.1. Int 21H Function 00H                                 
                                                               
                                                               
Description:                                                   
            Terminate Process                                  
                                                               
                                                               
   Terminates the current  process.  This  is  one  of  several
methods that a program can use to perform a final exit.        
                                                               
Input                                Output                    
-------------------------            -------                   
AH=00H                               Nothing                   
CS=segment address of                                          
   program segment prefix                                      
                                                               
                                                               
    1) MS-DOS then takes the following actions:                
            All memory belonging to the process is released.   
            File buffers are flushed, and any open handles  for
       files or devices owned by the process are closed.       
             The  termination  handler  vector  (Int  22H)   is
       restored from PSP:000AH.                                
            The CTRL+C handler vector  (Int  23H)  is  restored
       from PSP:000EH.                                         
            The critical-error  handler  vector  (Int  24H)  is
       restored from PSP:0012H.                                
            Control is transferred to the termination  handler.
          If the program is returning to  COMMAND.COM,  control
       transfers to the resident  portion,  and  the  transient
       portion is reloaded if necessary. If a batch file is  in
       progress, the next line  of  the  file  is  fetched  and
       interpreted; otherwise, a prompt is issued for the  next
       user command.                                           
    2) Any files that have been written to using FCBs should be
       closed before performing this exit call; otherwise, data
       may be lost.                                            
    3) Other methods of performing a final exit are:           
          - Int 20H                                            
          - Int 21H Function 31H                               
          - Int 21H Function 4CH                               
          - Int 27H                                            
    4) Int 21H Functions 31H and 4CH are the  preferred  method
       for termination because they allow a return code  to  be
       passed to the parent process.                           
    5) [3.0+] If the program is running on a network, it should
                                                               
           Interrupt 21H, Process-Control Functions            
       remove all locks it has placed on  file  regions  before
       terminating.                                            
   7.8.2. Int 21H Function 26H                                 
Description:                                                   
            Create New PSP                                     
   Copies the program segment prefix  (PSP)  of  the  currently
executing program to a specified segment address in free memory
and then updates the new PSP  to  make  it  usable  by  another
program.                                                       
Input                                               Output     
----------------------------------------            -------    
AH=26H                                              Nothing    
DX=segment of new program segment prefix                       
   - After the executing program's PSP is copied into  the  new
     segment, the memory size information in  the  new  PSP  is
     updated appropriately and  the  current  contents  of  the
     termination (Int  22H),  CTRL+C  handler  (Int  23H),  and
     critical-error  handler  (Int  24H)  vectors   are   saved
     starting at offset 0AH.                                   
   - This function does not load another program or  in  itself
     cause one to be executed.                                 
   - Int 21H Function 4BH (EXEC), which can be used to load and
     execute programs  or  overlays  in  either  .COM  or  .EXE
     format, should be used in preference to this function.    
   7.8.3. Int 21H Function 31H                                 
Description:                                                   
            Terminate and Stay Resident                        
               Terminates execution of the currently  executing
            program,  passing  a  return  code  to  the  parent
            process, but reserves part or all of the  program's
            memory so that it will not be overlaid by the  next
            transient program to be loaded.                    
Input                                                     Outpu
----------------------------------------------            -----
AH=31H                                                    Nothi
AL=return code                                                 
DX=amount of memory to reserve (in paragraphs)                 
            MS-DOS then takes the following actions:           
                1) Flushes the file buffers and closes any open
                   handles for files or devices  owned  by  the
           Interrupt 21H, Process-Control Functions            
                                                               
                                                               
                   process.                                    
                2) Restores the termination handler vector (Int
                   22H) from PSP:000AH.                        
                3) Restores the CTRL+C handler vector (Int 23H)
                   from PSP:000EH.                             
                4) Restores the critical-error  handler  vector
                   (Int 24H) from PSP:0012H.                   
                5) Transfers   control   to   the   termination
                   handler.                                    
                6) If the program is returning to  COMMAND.COM,
                   control transfers to the  resident  portion,
                   and the transient  portion  is  reloaded  if
                   necessary. If a batch file is  in  progress,
                   the next line of the  file  is  fetched  and
                   interpreted; otherwise, a prompt  is  issued
                   for the next user command.                  
                7) This function  call  is  typically  used  to
                   allow user-written  utilities,  drivers,  or
                   interrupt handlers to be loaded as  ordinary
                   .COM  or  .EXE  programs  and  then   remain
                   resident. Subsequent entrance to the code is
                   via a hardware or software interrupt.       
                8) This function attempts to  set  the  initial
                   memory allocation block  to  the  length  in
                   paragraphs  specified  in  register  DX.  If
                   other memory blocks have been  requested  by
                   the application using Int 21H Function  48H,
                   they will not be released by this  function.
                9) Other methods of  performing  a  final  exit
                   are:                                        
                      - Int 20H                                
                      - Int 21H Function 00H                   
                      - Int 21H Function 4CH                   
                      - Int 27H                                
               10) The return code may be retrieved by a parent
                   process through Int 21H  Function  4DH  (Get
                   Return Code). It can also  be  tested  in  a
                   batch file with an IF ERRORLEVEL  statement.
                   By  convention,  a  return  code   of   zero
                   indicates  successful   execution,   and   a
                   non-zero return code indicates an error.    
               11) This function should not be called  by  .EXE
                   programs that are loaded at the high end  of
                   the transient  program  area  (i.e.,  linked
                   with the  /HIGH  switch)  because  doing  so
                   reserves the memory that is normally used by
                   the  transient  part  of   COMMAND.COM.   If
                   COMMAND.COM cannot be reloaded,  the  system
                   will fail.                                  
               12) This function should be used  in  preference
                   to Int 27H because it supports return codes,
                   allows  larger  amounts  of  memory  to   be
                   reserved, and does not require CS to contain
                   the segment of the program segment prefix.  
               13) [3.0+]  If  the  program  is  running  on  a
                   network, it should remove all locks  it  has
                   placed on file regions before terminating.  
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
           Interrupt 21H, Process-Control Functions            
   7.8.4. Int 21H Function 4BH                                 
Description:                                                   
            Execute Program (EXEC)                             
   Allows  an  application  program  to  run  another  program,
regaining control when it is finished. Can also be used to load
overlays, although this use is uncommon.                       
Input                              Output                      
---------------------------------  ----------------------------
AH=4BH                             If function successful      
AL=subfunction                       Carry flag=clear          
  00H=Load and Execute Program       all registers except for C
  03H=Load Overlay                   IP may be destroyed       
ES:BX=segment:offset of parameter    [3.0+] registers are pre- 
  block                              served in the usual fashio
DS:DX=segment:offset of program    If function unsuccessful    
  specification                      Carry flag=set            
                                     AX=error code             
   - The parameter block format for Subfunction 00H  (Load  and
     Execute Program) is as follows:                           
Bytes    Contents                                              
-------  ---------------------------------------------------   
00H-01H  Segment pointer to environment block                  
02H-03H  Offset of command line tail                           
04H-05H  Segment of command line tail                          
06H-07H  Offset of first FCB to be copied into new PSP+5CH     
08H-09H  Segment of first FCB                                  
0AH-0BH  Offset of second FCB to be copied into new PSP+6CH    
0CH-0DH  Segment of second FCB                                 
   - The parameter  block  format  for  Subfunction  03H  (Load
     Overlay) is as follows:                                   
Bytes    Contents                                              
-------  ---------------------------------------------         
00H-01H  Segment address where overlay is to be loaded         
02H-03H  Relocation factor to apply to loaded image            
   - The  environment  block  must  be  paragraph  aligned.  It
     consists of a sequence of ASCIIZ strings in the form:     
     db 'COMSPEC=A:COMMAND.COM',0                              
        The entire set of strings is  terminated  by  an  extra
     null (00H) byte.                                          
   - The command tail format consists of a count byte, followed
     by an ASCII string, terminated by a carriage return (which
     is not included in the count). The first character in  the
     string should be an ASCII space  (20H)  for  compatibility
     with the command tail passed to programs  by  COMMAND.COM.
     For example:                                              
     db 6,' *.DAT',0dh                                         
   - Before a program uses Int 21H Function 4BH to run  another
           Interrupt 21H, Process-Control Functions            
                                                               
                                                               
     program, it must release all memory  it  is  not  actually
     using with a call to Int 21H  Function  4AH,  passing  the
     segment  address  of  its  own  PSP  and  the  number   of
     paragraphs to retain.                                     
   - Ordinarily, all active handles of the parent  program  are
     inherited by the child program, although  the  parent  can
     prevent this in  MS-DOS  3.0  and  later  by  setting  the
     inheritance bit when the file or  device  is  opened.  Any
     redirection of the standard input  and/or  output  in  the
     parent process also affects the child process.            
   - The environment block can be used to pass  information  to
     the child process. If the environment block pointer in the
     parameter block is zero, the  child  program  inherits  an
     exact copy of the parent's environment. In any  case,  the
     segment address of the child's  environment  is  found  at
     offset 002CH in the child's PSP.                          
   - After return from the EXEC function call, the  termination
     type and return code of the child program may be  obtained
     with Int 21H Function 4DH.                                
                                                               
                                                               
                                                               
                                                               
   7.8.5. Int 21H Function 4CH                                 
                                                               
                                                               
Description:                                                   
            Terminate Process with Return Code                 
                                                               
                                                               
   Terminates the current process, passing a return code to the
parent process. This is one of several methods that  a  program
can use to perform a final exit.                               
   If you use the .STARTUP directive, you should also  use  the
.EXIT directive, which automatically  generates  code  to  call
this function.                                                 
                                                               
  Input                      Output                            
  ---------------            -------                           
  AH=4CH                     Nothing                           
  AL=return code                                               
                                                               
                                                               
   - MS-DOS then takes the following actions:                  
   - All memory belonging to the process is released.          
   - File buffers are flushed and any open handles for files or
     devices owned by the process are closed.                  
   - The termination handler vector (Int 22H) is restored  from
     PSP:000AH.                                                
   - The CTRL+C handler  vector  (Int  23H)  is  restored  from
     PSP:000EH.                                                
   - The critical-error handler vector (Int  24H)  is  restored
     from PSP:0012H.                                           
   - Control is transferred to the termination handler.        
                                                               
                                                               
    1) If the program  is  returning  to  COMMAND.COM,  control
       transfers to the  resident  portion  and  the  transient
       portion is reloaded if necessary. If a batch file is  in
       progress, the next line  of  the  file  is  fetched  and
       interpreted; otherwise, a prompt is issued for the  next
       user command.                                           
           Interrupt 21H, Process-Control Functions            
    2) This  is  the  preferred  method  of   termination   for
       application programs because it allows a return code  to
       be passed to the parent program and does not rely on the
       contents of  any  segment  register.  Other  methods  of
       performing a final exit are:                            
          - Int 20H                                            
          - Int 21H Function 00H                               
          - Int 21H Function 31H                               
          - Int 27H                                            
    3) Any files that have been opened using FCBs and  modified
       by  the  program  should  be   closed   before   program
       termination; otherwise, data may be lost.               
    4) The return code can be retrieved by the  parent  process
       with Int 21H Function 4DH (Get Return Code). It can also
       be  tested  in  a  batch  file  with  an  IF  ERRORLEVEL
       statement.  By  convention,  a  return  code   of   zero
       indicates successful execution, and  a  non-zero  return
       code indicates an error.                                
    5) [3.0+] If the program is running on a network, it should
       remove all locks it has placed on  file  regions  before
       terminating.                                            
   7.8.6. Int 21H Function 4DH                                 
Description:                                                   
            Get Return Code                                    
   Used by a parent process, after the successful execution  of
an EXEC call (Int 21H Function 4BH), to obtain the return  code
and termination type of a child process.                       
Input         Output                                           
------        -------------------------------------------------
AH=4DH        AH=exit type                                     
                 00H if normal termination by Int 20H, Int 21H 
                 00H Function 0, or Int 21H Function 4CH       
                 01H if termination by user's entry of CTRL+C  
                 02H if termination by critical-error handler  
                 03H if termination by Int 21H Function 31H or 
                     03H Int 27H                               
               AL=return code passed by child process (0 if chi
                  terminated by Int 20H, Int 21H Function 0, or
                  Int 27H)                                     
   - This function will  yield  the  return  code  of  a  child
     process  only  once.  A   subsequent   call   without   an
     intervening  EXEC  (Int  21H  Function   4BH)   will   not
     necessarily return any valid information.                 
   - This function does not set the carry flag to  indicate  an
     error. If no previous child process has been executed, the
     values returned in AL and AH are undefined.               
           Interrupt 21H, Process-Control Functions            
                                                               
                                                               
   7.8.7. Int 21H Function 62H                                 
                                                               
                                                               
Description:                                                   
            Get PSP Address DOS 3 Only                         
                                                               
                                                               
   Obtains the  segment  (paragraph)  address  of  the  program
segment prefix (PSP) for the currently executing program.      
                                                               
Input             Output                                       
------            -------------------------------------------- 
AH=62H            BX=segment address of program segment prefix 
                                                               
                                                               
    1) Before a  program  receives  control  from  MS-DOS,  its
       program segment prefix is  set  up  to  contain  certain
       vital information, such as:                             
          - the segment address of  the  program's  environment
       block;                                                  
          - the command line originally entered by the user;   
          - the original contents of the terminate, CTRL+C, and
       critical-error handler vectors;                         
          - and the top address of available RAM.              
    2) The segment address of the PSP is normally passed to the
       program  in  registers  DS  and  ES  when  it  initially
       receives control from MS-DOS.  This  function  allows  a
       program to conveniently recover the PSP address  at  any
       point during its execution, without having to save it at
       program entry.                                          
                                                               
                                                               
                                                               
                                                               
   7.9. Interrupt 21H, Record Functions                        
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
1AH      26      Set Data Transfer Area (DTA) Address          
2FH      47      Get DTA Address                               
3FH      63      Read File or Device                           
40H      64      Write to File or Device                       
42H      66      Set File Pointer (current location in file)   
5CH      92      Lock or Unlock Region of File                 
68H     104      Commit File (forces buffer to be written out) 
                                                               
                                                               
                                                               
                                                               
   7.9.1. Int 21H Function 1AH                                 
                                                               
                                                               
Description:                                                   
            Set DTA Address                                    
                                                               
                                                               
   Specifies the address of the disk transfer area (DTA) to  be
used for subsequent FCB-related function calls.                
                                                               
                                                               
               Interrupt 21H, Record Functions                 
  Input                                   Output               
  ----------------------------            -------              
  AH=1AH                                  Nothing              
  DS:DX=segment:offset of disk                                 
        transfer area                                          
   - If this function is never called by the program,  the  DTA
     defaults to a 128-byte  buffer  at  offset  0080H  in  the
     program segment prefix.                                   
   - In general,  it  is  the  programmer's  responsibility  to
     ensure that the buffer area specified is large enough  for
     any disk operation that will use it. The only exception to
     this is that MS-DOS will detect and abort  disk  transfers
     that would cause a segment wrap.                          
   - Int 21H Function 2FH can be used to determine the  current
     disk transfer address.                                    
   - The only handle-type operations that rely on  the  current
     DTA address are the directory search  functions,  Int  21H
     Functions 4EH and 4FH.                                    
   7.9.2. SetDTA                                               
;* SetDTA - Sets address for new Disk Transfer Area.           
;*                                                             
;* Shows:   DOS Function - 1Ah (Set DTA Address)               
;*                                                             
;* Params:  dta - Far pointer to new transfer address          
;*                                                             
;* Return:  None                                               
SetDTA  PROC \                                                 
        USES ds, \                                             
        dta:FAR PTR BYTE                                       
        lds     dx, [dta]               ; Point DS:DX to DTA   
        mov     ah, 1Ah                 ; DOS Function 1Ah     
        int     21h                     ; Set DTA Address      
        ret                                                    
SetDTA  ENDP                                                   
   7.9.3. Int 21H Function 2FH                                 
Description:                                                   
            Get DTA Address                                    
   Obtains the current address of the disk transfer area  (DTA)
for FCB read/write operations.                                 
               Interrupt 21H, Record Functions                 
                                                               
                                                               
                                                               
  Input             Output                                     
  ------            ------------------------------------------ 
  AH=2FH            ES:BX=segment:offset of disk transfer area 
                                                               
                                                               
                                                               
The disk transfer area address is set  with  Int  21H  Function
1AH. The default DTA is a 128-byte buffer at offset 80H in  the
program segment prefix.                                        
                                                               
                                                               
                                                               
   7.9.4. Int 21H Function 3FH                                 
                                                               
                                                               
Description:                                                   
            Read File or Device                                
                                                               
                                                               
   Given a valid file handle from a  previous  open  or  create
operation, a buffer address, and a length in  bytes,  transfers
data at the current file pointer position from  the  file  into
the buffer and then updates the file pointer position.         
                                                               
Input                                  Output                  
------------------------------         ----------------------- 
AH=3FH                                 If function successful  
BX=handle                              Carry flag=clear        
CX=number of bytes to read             AX=bytes transferred    
DS:DX=segment:offset of buffer         If function unsuccessful
                                       Carry flag= set         
                                       AX=error code           
                                                               
                                                               
   - If reading from a character device (such as  the  standard
     input) in cooked mode, at most one line of input  will  be
     read (i.e., up to a carriage re-  turn  character  or  the
     specified length, whichever comes first).                 
   - If the carry flag is returned clear but AX = 0,  then  the
     file pointer was already at end of file when  the  program
     requested the read.                                       
   - If the carry flag is returned clear but AX <  CX,  then  a
     partial record was read at end of  file  or  there  is  an
     error.                                                    
   - [3.0+] If the program is running on a  network,  the  user
     must have Read access rights to the directory and file.   
                                                               
                                                               
                                                               
                                                               
   7.9.5. ReadFile                                             
                                                               
                                                               
;* ReadFile - Read from open file to specified buffer.         
;* See the CopyFile procedure for another example of using     
;* DOS Function 3Fh to read files.                             
;*                                                             
;* Shows:   DOS Function - 3Fh (Read File or Device)           
;*                                                             
;* Params:  handle - File handle                               
;*          len - Number of bytes to read                      
               Interrupt 21H, Record Functions                 
;*          pbuff - Pointer to buffer                          
;*                                                             
;* Return:  Short integer with number of bytes read,           
;*  or 0 if read error                                         
ReadFile PROC \                                                
        USES ds di, \                                          
        handle:WORD, len:WORD, pbuff:PTR BYTE                  
        LoadPtr ds, dx, pbuff  ; Point DS:DX to buffer         
        mov     di, dx         ; Keep string offset in DI      
        mov     bx, handle     ; BX = handle                   
        mov     cx, len        ; CX = number of bytes to read  
        mov     ah, 3Fh        ; Request DOS read              
        int     21h            ; Read File or Device           
        jnc     exit           ; If ok, exit with bytes read   
        sub     ax, ax         ; Else set error code           
exit:   ret                                                    
ReadFile ENDP                                                  
   7.9.6. Int 21H Function 40H                                 
Description:                                                   
            Write File or Device                               
   Given a valid file handle from a  previous  open  or  create
operation, a buffer address, and a length in  bytes,  transfers
data from the buffer into the file and then  updates  the  file
pointer position.                                              
Input                                     Output               
------------------------------            ---------------------
AH=40H                                    If function successfu
BX=handle                                 Carry Flag=clear     
CX=number of bytes to write               AX=bytes transferred 
DS:DX=segment:offset of buffer            Carry flag=set       
                                          AX=error code        
   - If the carry flag is returned clear but AX <  CX,  then  a
     partial record was written or there is an error. This  can
     be caused by a CTRL+Z (1AH) embedded in the  data  if  the
     destination is a character device in cooked mode or  by  a
     disk-full condition if the destination is a file.         
   - If the function is  called  with  CX  =  0,  the  file  is
     truncated  or  extended  to  the  current   file   pointer
     position.                                                 
   - [3.0+] If the program is running on a  network,  the  user
     must have Write access rights to the directory and file.  
               Interrupt 21H, Record Functions                 
                                                               
                                                               
   7.9.7. Int 21H Function 42H                                 
                                                               
                                                               
Description:                                                   
            Set File Pointer                                   
                                                               
                                                               
   Sets the file location pointer  relative  to  the  start  of
file, end of file, or current file position.                   
                                                               
Input                             Output                       
------------------------------    ---------------------------- 
AH=42H                            If function successful       
AL=method code                     Carry flag=clear            
 00H absolute offset from          DX=most significant half of 
     start of file                    resulting file pointer   
 01H signed offset from            AX=least significant half of
     current file pointer             resulting file pointer   
 02H signed offset from end       If function unsuccessful     
    of file                        Carry flag=set              
BX=handle                          AX=error code               
CX=most significant half of offset                             
DX=least significant half of offset                            
                                                               
                                                               
   - This function uses a method code  and  a  double-precision
     (32-bit) value to set the file pointer.  The  next  record
     read or written in the file will begin  at  the  new  file
     pointer location.                                         
   - Method 02H may be used to find the size  of  the  file  by
     calling Int 21H Function 42H  with  an  offset  of  0  and
     examining the pointer location that is returned.          
   - Using methods 01H or 02H, it is possible to set  the  file
     pointer to a location that is before the start of file. If
     this is done, no error is returned by this  function,  but
     an error will be encountered upon a subsequent attempt  to
     read or write the file.                                   
   - No matter  what  method  is  used  in  the  call  to  this
     function, the file pointer returned in DX:AX is always the
     resulting absolute byte offset from the start of file.    
                                                               
                                                               
                                                               
                                                               
   7.9.8. Int 21H Function 5CH                                 
                                                               
                                                               
Description:                                                   
            Lock or Unlock File Region DOS 3 Only              
                                                               
                                                               
   Locks or unlocks a specified  region  of  a  file  that  was
previously opened or created with Int 21H Functions  3CH,  3DH,
5AH,  or  5BH.  This  function  is  not  available  unless  the
file-sharing module (SHARE.EXE) is loaded.                     
                                                               
                                                               
                                                               
                                                               
               Interrupt 21H, Record Functions                 
Input                            Output                        
------------------------------   ----------------------------- 
AH=5CH                           If function successful        
AL=00H  if locking region          Carry flag=clear            
   01H  if unlocking region      If function unsuccessful      
BX=handle                          Carry flag=set              
CX=high part of region offset      AX=error code               
DX=low part of region offset                                   
SI=high part of region length                                  
DI=low part of region length                                   
   - This   function   is   useful   for   file   and    record
     synchronization  in  a  multi-  tasking   environment   or
     network. Access to the file as a whole is control- led  by
     the attribute and file-sharing parameters passed  in  open
     or create calls, and by the file's attributes,  which  are
     stored in its directory entry.                            
   - The beginning  location  in  the  file  to  be  locked  or
     unlocked  is  supplied  as  a  positive   double-precision
     integer, which is a byte offset into the file. The  length
     of the region to be locked or unlocked is  similarly  sup-
     plied as a positive double-precision integer.             
   - For every call to lock a region of a file, there must be a
     subsequent un- lock call with exactly the same file offset
     and length.                                               
   - Locking beyond the current end of file is not an error.   
   - If a process terminates without releasing active locks  on
     a file, the re- sult  is  undefined.  Therefore,  programs
     using this function should install their own Int  23H  and
     Int 24H handlers so the processes cannot be  termin-  ated
     unexpectedly.                                             
   - Programs that are loaded  with  the  EXEC  call  (Int  21H
     Function 4BH) inherit the handles of their parent but  not
     any active locks.                                         
   - Duplicate handles created with Int 21H  Function  45H,  or
     handles redirected to the file with Int 21H Function  46H,
     are allowed access  to  locked  regions  within  the  same
     process.                                                  
   7.9.9. Int 21H Function 5CH                                 
Description:                                                   
            Lock or Unlock File Region DOS 3 Only              
   Locks or unlocks a specified  region  of  a  file  that  was
previously opened or created with Int 21H Functions  3CH,  3DH,
5AH,  or  5BH.  This  function  is  not  available  unless  the
file-sharing module (SHARE.EXE) is loaded.                     
               Interrupt 21H, Record Functions                 
                                                               
                                                               
                                                               
Input                            Output                        
------------------------------   ----------------------------- 
AH=5CH                           If function successful        
AL=00H  if locking region          Carry flag=clear            
   01H  if unlocking region      If function unsuccessful      
BX=handle                          Carry flag=set              
CX=high part of region offset      AX=error code               
DX=low part of region offset                                   
SI=high part of region length                                  
DI=low part of region length                                   
                                                               
                                                               
   - This   function   is   useful   for   file   and    record
     synchronization  in  a  multi-  tasking   environment   or
     network. Access to the file as a whole is control- led  by
     the attribute and file-sharing parameters passed  in  open
     or create calls, and by the file's attributes,  which  are
     stored in its directory entry.                            
   - The beginning  location  in  the  file  to  be  locked  or
     unlocked  is  supplied  as  a  positive   double-precision
     integer, which is a byte offset into the file. The  length
     of the region to be locked or unlocked is  similarly  sup-
     plied as a positive double-precision integer.             
   - For every call to lock a region of a file, there must be a
     subsequent un- lock call with exactly the same file offset
     and length.                                               
   - Locking beyond the current end of file is not an error.   
   - If a process terminates without releasing active locks  on
     a file, the re- sult  is  undefined.  Therefore,  programs
     using this function should install their own Int  23H  and
     Int 24H handlers so the processes cannot be  termin-  ated
     unexpectedly.                                             
   - Programs that are loaded  with  the  EXEC  call  (Int  21H
     Function 4BH) inherit the handles of their parent but  not
     any active locks.                                         
   - Duplicate handles created with Int 21H  Function  45H,  or
     handles redirected to the file with Int 21H Function  46H,
     are allowed access  to  locked  regions  within  the  same
     process.                                                  
                                                               
                                                               
                                                               
                                                               
   7.9.10. Int 21H Function 68H                                
                                                               
                                                               
Description:                                                   
            Commit File DOS 3.3 Only                           
                                                               
                                                               
   Forces all data in MS-DOS's internal buffers associated with
a specified handle to be physically written to the  device.  If
the handle refers to a file, and the file  has  been  modified,
the time and date stamp and file size in the  file's  directory
entry are updated.                                             
                                                               
               Interrupt 21H, Record Functions                 
Input                Output                                    
---------            ------------------------------            
AH=68H               If function successful                    
BX=handle              Carry flag=clear                        
                     If function unsuccessful                  
                       Carry flag= set                         
                       AX=error code                           
   - The effect of this function is equivalent to  closing  and
     reopening a file, or to duplicating a handle for the  file
     with Int 21H Function 45H and then closing the  duplicate.
     However, this function has the advantage that it will  not
     fail due to lack of handles, and the application does  not
     risk losing control of the file in multitasking or network
     environments.                                             
   - If this function is requested for a handle associated with
     a character device, a success flag is returned  but  there
     is no other effect.                                       
   7.10. Interrupt 21H, Record Functions, FCB                  
   You can perform all the functions  below  more  easily  with
DOS2 functions. The services below are documented  so  you  can
analyze code written for DOS1.                                 
Hex #  Dec #     Name                                          
14H     20       Sequential Read                               
15H     21       Sequential Write                              
21H     33       Random Read                                   
22H     34       Random Write                                  
24H     36       Set Relative Record Number                    
27H     39       Random Block Read                             
28H     40       Random Block Write                            
   7.10.1. Int 21H Function 14H                                
Description:                                                   
            Sequential Read                                    
   Reads the next sequential block of data from a file and then
increments the file pointer appropriately.                     
Input                             Output                       
------------------------------    ---------------------------- 
AH=14H                            AL=00H  if read successful   
DS:DX=segment:offset of prev-        01H  if end of file       
      iously opened file con-        02H  if segment wrap      
      trol block                     03H  if partial record at 
                                          end of file          
             Interrupt 21H, Record Functions, FCB              
                                                               
                                                               
   - The record  is  read  into  memory  at  the  current  disk
     transfer area (DTA) address, specified by the most  recent
     call to Int 21H Function 1AH. If the size  of  the  record
     and the location of the buffer are  such  that  a  segment
     overflow or wraparound would  occur,  the  function  fails
     with a return code of 02H.                                
   - The number of bytes of data to be read is specified by the
     record size field (offset 0EH) of the file  control  block
     (FCB).                                                    
   - The file location  of  the  data  that  will  be  read  is
     specified by the com- bination of the current block  field
     (offset 0CH) and current record field (offset 20H) of  the
     file  control  block  (FCB).   These   fields   are   also
     automatically incremented by this function.               
   - If a partial record is read at the  end  of  file,  it  is
     padded to the requested record length with zeros.         
   - [3.0+] If the program is running on a  network,  the  user
     must have Read access rights to the  directory  containing
     the file to be read.                                      
                                                               
                                                               
                                                               
                                                               
   7.10.2. Int 21H Function 15H                                
                                                               
                                                               
Description:                                                   
            Sequential Write                                   
                                                               
                                                               
   Writes the next sequential block of data  into  a  file  and
then increments the file pointer appropriately.                
                                                               
Input                            Output                        
------------------------------   ----------------------------- 
AH=15H                           AL=00H  if write successful   
DS:DX=segment:offset of prev-       01H  if disk is full       
      iously opened file con-       02H  if segment wrap       
      trol block                                               
                                                               
                                                               
   - The  record  is  written   (logically,   not   necessarily
     physically) to the disk from memory at  the  current  disk
     transfer area (DTA)  address,  spec-  ified  by  the  most
     recent call to Int 21H Function 1AH. If the  size  of  the
     record and the location of the  buffer  are  such  that  a
     segment over- flow or wraparound would occur, the function
     fails with a return code of 02H.                          
   - The number of bytes of data to be written is specified  by
     the record size field (offset 0EH)  of  the  file  control
     block (FCB).                                              
   - The file location of the data  that  will  be  written  is
     specified by the combination of the  current  block  field
     (offset 0CH) and current record field (offset 20H) of  the
     file  control  block  (FCB).   These   fields   are   also
     automatically incremented by this function.               
   - [3.0+] If the program is running on a  network,  the  user
     must have Write access rights to the directory  containing
     the file to be written.                                   
                                                               
                                                               
                                                               
             Interrupt 21H, Record Functions, FCB              
   7.10.3. Int 21H Function 21H                                
Description:                                                   
            Random Read                                        
   Reads a selected record from a file into memory.            
Input                   Output                                 
--------------------    -------------------------------------- 
AH=21H                  AL=00H  if read successful             
DS:DX=segment:offset       01H  if end of file                 
      of previously        02H  if segment wrap, read canceled 
      opened file          03H  if partial record read at end  
      control block                      of file               
   - The record  is  read  into  memory  at  the  current  disk
     transfer area ad- dress, specified by the most recent call
     to  Int  21H  Function  1AH.  It   is   the   programmer's
     responsibility to ensure that this area  is  large  enough
     for any record that will be transferred. If the  size  and
     loca- tion of the buffer are such that a segment  overflow
     or wraparound would  occur,  the  function  fails  with  a
     return code of 02H.                                       
   - The file location of the data to be read is determined  by
     the combina- tion of  the  relative-record  field  (offset
     21H) and the record size field (offset 0EH)  of  the  FCB.
     The default record size is 128 bytes.                     
   - The current block field (offset 0CH)  and  current  record
     field  (offset  20H)  are  updated  to  agree   with   the
     relative-record field as a side effect of the function.   
   - The relative-record field of the FCB is not incremented by
     this  func-  tion;  it  is  the  responsibility   of   the
     application to update the FCB appropriately if  it  wishes
     to read successive records. Compare with Int 21H  Function
     27H, which can read multiple  records  with  one  function
     call  and  automatically  increments  the  relative-record
     field.                                                    
   - If a partial record is read at end of file, it  is  padded
     to the requested record length with zeros.                
   - [3.0+] If the program is running on a  network,  the  user
     must have Read access rights to the  directory  containing
     the file to be read.                                      
   7.10.4. Int 21H Function 22H                                
Description:                                                   
            Random Write                                       
   Writes data from memory into a selected record in a file.   
             Interrupt 21H, Record Functions, FCB              
                                                               
                                                               
                                                               
Input                   Output                                 
--------------------    ---------------------------------------
AH=22H                  AL=00H  if write successful            
DS:DX=segment:offset       01H  if disk full                   
      of previously        02H  if segment wrap, write canceled
      opened file                                              
      control block                                            
                                                               
                                                               
   - The  record  is  written   (logically,   not   necessarily
     physically) to the file from memory at  the  current  disk
     transfer address, specified by the most recent call to Int
     21H Function 1AH. If the size and location of  the  buffer
     are such that  a  segment  overflow  or  wraparound  would
     occur, the function fails with a return code of 02H.      
   - The file location of the data to be written is  determined
     by the combin- ation of the relative-record field  (offset
     21H) and the record size field (offset 0EH)  of  the  FCB.
     The default record size is 128 bytes.                     
   - The current block field (offset 0CH)  and  current  record
     field  (offset  20H)  are  updated  to  agree   with   the
     relative-record field as a side effect of the function.   
   - The relative-record field of the FCB is not incremented by
     this  func-  tion;  it  is  the  responsibility   of   the
     application to update the FCB appropriately if  it  wishes
     to write successive records. Compare with Int 21H Function
     28H, which can write multiple records with one func-  tion
     call  and  automatically  increments  the  relative-record
     field.                                                    
   - If a record is written beyond the current end of file, the
     space between the old end of file and the  new  record  is
     allocated but not initialized.                            
   - [3.0+] If the program is running on a  network,  the  user
     must have Write access rights to the directory  containing
     the file to be written.                                   
                                                               
                                                               
                                                               
                                                               
   7.10.5. Int 21H Function 24H                                
                                                               
                                                               
Description:                                                   
            Set Relative-Record Number                         
                                                               
                                                               
   Sets the relative-record-number  field  of  a  file  control
block (FCB) to correspond  to  the  current  file  position  as
recorded in the opened FCB.                                    
                                                               
Input                       Output                             
------------------------    -----------------------------------
AH=24H                      AL is destroyed (other registers no
DS:DX=segment:offset of        affected)                       
      previously opened     FCB relative-record field (offset  
      file control block       21H) updated                    
                                                               
                                                               
   - This function is used when switching  from  sequential  to
     random  I/O  within  a   file.   The   contents   of   the
     relative-record field (offset 21H) are  derived  from  the
                                                               
             Interrupt 21H, Record Functions, FCB              
     record size (offset 0EH), current block (offset 0CH),  and
     current record (offset 20H) fields  of  the  file  control
     block.                                                    
   - All four bytes of the FCB  relative-record  field  (offset
     21H) should be initialized to  zero  before  calling  this
     function.                                                 
   7.10.6. Int 21H Function 24H                                
Description:                                                   
            Set Relative-Record Number                         
   Sets the relative-record-number  field  of  a  file  control
block (FCB) to correspond  to  the  current  file  position  as
recorded in the opened FCB.                                    
Input                       Output                             
------------------------    -----------------------------------
AH=24H                      AL is destroyed (other registers no
DS:DX=segment:offset of        affected)                       
      previously opened     FCB relative-record field (offset  
      file control block       21H) updated                    
   - This function is used when switching  from  sequential  to
     random  I/O  within  a   file.   The   contents   of   the
     relative-record field (offset 21H) are  derived  from  the
     record size (offset 0EH), current block (offset 0CH),  and
     current record (offset 20H) fields  of  the  file  control
     block.                                                    
   - All four bytes of the FCB  relative-record  field  (offset
     21H) should be initialized to  zero  before  calling  this
     function.                                                 
   7.10.7. Int 21H Function 27H                                
Description:                                                   
            Random Block Read                                  
   Reads one or  more  sequential  records  from  a  file  into
memory, starting at a designated file location.                
Input                           Output                         
-----------------------------   -------------------------------
AH=27H                          AL=00H  if all requested re-   
CX=number of records to read                   cords read      
DS:DX=segment:offset of prev-      01H  if end of file         
      iously opened file con-      02H  if segment wrap        
      trol block                   03H  if partial record read 
                                        at end of file         
                                CX=actual number of records rea
             Interrupt 21H, Record Functions, FCB              
                                                               
                                                               
   - The records are read  into  memory  at  the  current  disk
     transfer area ad- dress, specified by the most recent call
     to  Int  21H  Function  1AH.  It   is   the   programmer's
     responsibility to ensure that this area  is  large  enough
     for the group of records that will be transferred. If  the
     size and location of the buffer are such  that  a  segment
     overflow or wrapa- round would occur, the  function  fails
     with a return code of 02H.                                
   - The file location of the data to be read is determined  by
     the combina- tion of  the  relative-record  field  (offset
     21H) and the record size field (offset 0EH)  of  the  FCB.
     The default record size is 128 bytes.                     
   - After the disk transfer is performed,  the  current  block
     (offset  0CH),   current   record   (offset   020H),   and
     relative-record (offset 21H) fields of the FCB are updated
     to point to the next record in the file.                  
   - If a partial record is  read  at  the  end  of  file,  the
     remainder of the record is padded with zeros.             
   - Compare with Int 21H Function 21H,  which  transfers  only
     one record per function call and does not update  the  FCB
     relative-record field.                                    
   - [3.0+] If the program is running on a  network,  the  user
     must have Read access rights to the  directory  containing
     the file to be read.                                      
                                                               
                                                               
                                                               
                                                               
   7.10.8. Int 21H Function 28H                                
                                                               
                                                               
Description:                                                   
            Random Block Write                                 
                                                               
                                                               
   Writes one or more sequential records from memory to a file,
starting at a designated file location.                        
                                                               
Input                            Output                        
------------------------------   ----------------------------- 
AH=28H                           AL=00H  if all requested      
CX=number of records to write            records written       
DS:DX=segment:offset of prev-       01H  if disk full          
      iously opened file con-       02H  if segment wrap       
      trol block                 CX=actual number of records   
                                    written                    
                                                               
                                                               
   - The  records  are  written  (logically,  not   necessarily
     physically) to  disk  from  memory  at  the  current  disk
     transfer area address, specified by the most  recent  call
     to Int 21H Function 1AH. If the size and location  of  the
     buffer are such that  a  segment  overflow  or  wraparound
     would occur, the function fails with a return code of 02H.
   - The file location of the data to be written is  determined
     by the combi- nation of the relative-record field  (offset
     21H) and the record size field (offset 0EH)  of  the  FCB.
     The default record size is 128 bytes.                     
   - After the disk transfer is performed,  the  current  block
     (offset  0CH),   current   record   (offset   020H),   and
     relative-record (offset 21H) fields of the FCB are updated
     to point to the next record in the file.                  
             Interrupt 21H, Record Functions, FCB              
   - If this function is called with  CX  =  00H,  no  data  is
     written to the disk but the file is extended or  truncated
     to the length specified by combination of the record  size
     (offset 0EH) and the relative-record (offset  21H)  fields
     of the FCB.                                               
   - Compare with Int 21H Function 22H,  which  transfers  only
     one record per function call and does not update  the  FCB
     relative-record field.                                    
   - [3.0+] If the program is running on a  network,  the  user
     must have Write access rights to the directory  containing
     the file to be written.                                   
   7.11. Interrupt 21H, Time and Date Functions                
Hex #  Dec #     Name                                          
2AH     42       Get Date                                      
2BH     43       Set Date                                      
2CH     44       Get Time                                      
2DH     45       Set Time                                      
   7.11.1. Int 21H Function 2AH                                
Description:                                                   
            Get Date                                           
   Obtains the system day of the month, day of the week, month,
and year.                                                      
Input             Output                                       
------            ---------------------------------------------
AH=2AH            CX=year (1980 through 2099)                  
                  DH=month (1 through 12)                      
                  DL=day (1 through 31)                        
                  Under MS-DOS versions 1.1 and later          
                  AL=day of the week (0=Sunday, 1=Monday, etc.)
   - This function's  register  format  is  the  same  as  that
     required for Int 21H Function 2BH (Set Date).             
   - This function can be used together with Int  21H  Function
     2BH to find the day of the week for an arbitrary date. The
     current date is  first  obtained  with  Function  2AH  and
     saved. The date of interest is then set with Function 2BH,
     and the day of the week for that date is obtained  with  a
     subsequent call to Function 2AH. Finally, the current date
     is restored with an additional call to Function 2BH, using
     the values ob- tained with the original Function 2AH call.
            Interrupt 21H, Time and Date Functions             
                                                               
                                                               
   7.11.2. Int 21H Function 2BH                                
                                                               
                                                               
Description:                                                   
            Set Date                                           
                                                               
                                                               
   Initializes the system clock driver to a specific date.  The
system time is not affected.                                   
                                                               
Input                         Output                           
---------------------------   ---------------------------------
AH=2BH                        AL=00H  if date set successfully 
CX=year (1980 through 2099)      FFH  if date not valid (ignore
DH=month (1 through 12)                                        
DL=day (1 through 31)                                          
                                                               
   This function's register format is the same as that required
   for Int 21H Function 2AH (Get Date).                        
                                                               
                                                               
                                                               
   7.11.3. Int 21H Function 2CH                                
                                                               
                                                               
Description:                                                   
            Get Time                                           
                                                               
                                                               
   Obtains the time of day  from  the  system  real-time  clock
driver, con- verted to hours, minutes, seconds, and  hundredths
of seconds.                                                    
                                                               
Input             Output                                       
------            ---------------------------------------      
AH=2CH            CH=hours (0 through 23)                      
                  CL=minutes (0 through 59)                    
                  DH=seconds (0 through 59)                    
                  DL=hundredths of seconds (0 through 99)      
                                                               
                                                               
   - This function's  register  format  is  the  same  as  that
     required for Int 21H Function 2DH (Set Time).             
   - On most IBM PC-compatible  systems,  the  real-time  clock
     does  not  have  a  resolution  of  single  hundredths  of
     seconds. On such machines, the  values  returned  by  this
     function in register DL are discontinuous.                
                                                               
                                                               
                                                               
                                                               
   7.11.4. Int 21H Function 2DH                                
                                                               
                                                               
Description:                                                   
            Set Time                                           
                                                               
                                                               
   Initializes the system real-time clock to a specified  hour,
minute, second, and hundredth of second. The system date is not
affected.                                                      
                                                               
            Interrupt 21H, Time and Date Functions             
Input                       Output                             
-------------------------   -----------------------------------
AH=2DH                      AL=00H  if time set successfully   
CH=hours (0 through 23)        FFH  if time not valid (ignored)
CL=minutes (0 through 59)                                      
DH=seconds (0 through 59)                                      
DL=hundredths of seconds                                       
   (0 through 99)                                              
   This function's register format is the same as that required
   for Int 21H Function 2CH (Get Time).                        
                 Miscellaneous DOS Interrupts                  
                                                               
                                                               
                8. Miscellaneous DOS Interrupts                
                                                               
                                                               
                                                               
Hex #  Dec #     Name                                          
20H     32       Terminate Program                             
25H     37       Read Disk Sector (ignore logical structure)   
26H     38       Write Disk Sector (ignore logical structure)  
27H     39       Terminate but Stay Resident                   
2FH     47       Print Spool Control (DOS3 only)               
                                                               
                                                               
                                                               
                                                               
   8.1. Interrupt 20H                                          
                                                               
                                                               
Description:                                                   
            Terminate Process                                  
                                                               
                                                               
   Terminates the current  process.  This  is  one  of  several
methods that a program can use to perform a final exit.        
                                                               
Input                                                   Output 
------------------                                      -------
CS=segment address of program segment prefix            Nothing
                                                               
   If  the  program  is  returning  to   COMMAND.COM,   control
transfers to the resident portion, and the transient portion is
reloaded if necessary. If a batch file is in progress, the next
line of the file  is  fetched  and  interpreted;  otherwise,  a
prompt is issued for the next user command.                    
   MS-DOS then takes the following actions:                    
                                                               
    1) All memory belonging to the process is released.        
    2) File buffers are flushed, and any open handles for files
       or devices owned by the process are closed.             
    3) The termination handler vector  (Int  22H)  is  restored
       from PSP:000AH.                                         
    4) The CTRL+C handler vector (Int  23H)  is  restored  from
       PSP:000EH.                                              
    5) The critical-error handler vector (Int 24H) is  restored
       from PSP:0012H (MS-DOS versions 2.0 and later).         
    6) Control is transferred to the termination handler.      
    7) Any files that have been written to using FCBs should be
       closed before performing this exit call; otherwise, data
       may be lost.                                            
    8) Other methods of performing a final exit are:           
          - Int 21H Function 00H                               
          - Int 21H Function 31H                               
          - Int 21H Function 4CH                               
          - Int 27H                                            
    9) [3] If the program is running on a  network,  it  should
       remove all locks it has placed on  file  regions  before
       terminating.                                            
   10) Int 21H Functions 31H and 4CH are the  preferred  method
       for termination because they allow a return code  to  be
       passed to the parent process.                           
                                                               
                                                               
                                                               
                 Miscellaneous DOS Interrupts                  
   8.2. Interrupt 25H                                          
Description:                                                   
            Absolute Disk Read                                 
   Provides a direct linkage to the MS-DOS BIOS module to  read
data from a logical disk sector into memory.                   
Input                                  Output                  
------------------------------         ------------------------
For access to partitions               If function successful  
 <= 32 MB                              Carry flag=set          
AL=drive number (0=A, 1=B,             If function unsuccessful
 etc.)                                 Carry flag=set          
CX=number of sectors to read           AX=error code (see Notes
DX=starting sector number                                      
DS:BX=segment:offset of buffer                                 
For access to partitions                                       
> 32 MB (MS-DOS 4.0 and later)                                 
AL=drive number (0=A, 1=B, etc.)                               
CX=-1                                                          
DS:BX=segment:offset of para-                                  
meter block (see Notes)                                        
   - All  registers  except  the  segment  registers   may   be
     destroyed.                                                
   - When this  function  returns,  the  CPU  flags  originally
     pushed on the stack by the INT 25H instruction  are  still
     on the stack. The stack must be cleared by a POPF  or  ADD
     SP,2 to prevent uncontrolled  stack  growth  and  to  make
     accessible any other values that were pushed on the  stack
     before the call to INT 25H.                               
   - Logical sector numbers are obtained by numbering each disk
     sector sequentially from track 0, head 0,  sector  1,  and
     continuing until the last sector on the disk  is  counted.
     The head number is incremented before  the  track  number.
     Logically adjacent sectors may not be physically adjacent,
     due to interleaving that occurs at the device-driver level
     for some disk types.                                      
   - The error code is interpreted as follows: The  lower  byte
     (AL) is the same error code that is returned in the  lower
     byte of DI when an Int 24H is issued. The upper byte  (AH)
     contains:                                                 
     80H                                                       
                 if attachment failed to respond               
     40H                                                       
                 if seek operation failed                      
     20H                                                       
                 if controller failed                          
     10H                                                       
                 data error (bad CRC)                          
     08H                                                       
                 if direct memory access (DMA) failure         
     04H                                                       
                 if requested sector not found                 
     02H                                                       
                 if bad address mark                           
     01H                                                       
                 if bad command                                
                 Miscellaneous DOS Interrupts                  
                                                               
                                                               
   - [4.0+] When accessing partitions larger than 32  MB  under
     MS-DOS version 4, this function  uses  a  parameter  block
     with the following format:                                
                                                               
  Bytes       Description                                      
  -------     -------------------------                        
  00H-03H     32-bit sector number                             
  04H-05H     number of sectors to read                        
  06H-07H     offset of buffer                                 
  08H-09H     segment of buffer                                
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
   8.3. Interrupt 26H                                          
                                                               
                                                               
Description:                                                   
            Absolute Disk Write                                
                                                               
                                                               
   Provides a direct linkage to the MS-DOS BIOS module to write
data from memory to a logical disk sector.                     
                                                               
Input                                 Output                   
------------------------------        -------------------------
For access to partitions              If function successful   
<= 32 MB                               Carry flag=clear        
AL=drive number (0=A, 1=B,            If function unsuccessful 
etc.)                                  Carry flag=set          
CX=number of sectors to write         AX=error code (see Notes)
DX=starting sector number                                      
DS:BX=segment:offset of buffer                                 
For access to partitions                                       
> 32 MB (MS-DOS 4.0 and later)                                 
AL=drive number (0=A, 1=B,                                     
etc.)                                                          
CX=-1                                                          
DS:BX=segment:offset of para-                                  
meter block (see Notes)                                        
                                                               
                                                               
   - All  registers  except  the  segment  registers   may   be
     destroyed.                                                
   - When this  function  returns,  the  CPU  flags  originally
     pushed onto the stack by the INT 26H instruction are still
     on the stack. The stack must be cleared by a POPF  or  ADD
     SP,2 to prevent uncontrolled  stack  growth  and  to  make
     accessible any other values that were pushed on the  stack
     before the call to INT 26H.                               
   - Logical sector numbers are obtained by numbering each disk
     sector sequentially from track 0, head 0,  sector  1,  and
     continuing until the last sector on the disk  is  counted.
     The head number is incremented before  the  track  number.
     Logically adjacent sectors may not be physically adjacent,
     due to interleaving that occurs at the device-driver level
     for some disk types.                                      
   - The error code is interpreted as follows: The  lower  byte
     (AL) is the same error code that is returned in the  lower
     byte of DI when an Int 24H is issued. The upper byte  (AH)
                                                               
                 Miscellaneous DOS Interrupts                  
     contains:                                                 
     80H                                                       
                 if attachment failed to respond               
                 40H if seek operation failed                  
                 20H if controller failed                      
                 10H if data error (bad CRC)                   
                 08H if direct memory access (DMA) failure     
                 04H if requested sector not found             
                 03H if write-protect fault                    
                 02H if bad address mark                       
                 01H if bad command                            
   - [4.0+] When accessing partitions larger than 32  MB  under
     MS-DOS version 4, this function  uses  a  parameter  block
     with the following format:                                
  Bytes       Description                                      
  -------     -------------------------                        
  00H-03H     32-bit sector number                             
  04H-05H     number of sectors to read                        
  06H-07H     offset of buffer                                 
  08H-09H     segment of buffer                                
                                                               
   8.4. Interrupt 27H                                          
Description:                                                   
            Terminate and Stay Resident                        
   Terminates execution of the currently executing program, but
reserves part or all of its memory  so  that  it  will  not  be
overlaid by the next transient program to be loaded.           
Input                                            Output        
-------------------------------------            -------       
DX=offset of the last byte plus one              Nothing       
   (relative to the program segment                            
   prefix) of program to be protected                          
CS=segment of program segment prefix                           
    1) MS-DOS then takes the following actions:                
          - File buffers are flushed and any open  handles  for
       files or devices owned by the process are closed.       
          -  The  termination  handler  vector  (Int  22H)   is
       restored from PSP:000AH.                                
          - The CTRL+C handler vector  (Int  23H)  is  restored
       from PSP:000EH.                                         
          - The critical-error  handler  vector  (Int  24H)  is
       restored from PSP:0012H.                                
          - Control is transferred to the termination  handler.
    2) If the program  is  returning  to  COMMAND.COM,  control
       transfers to the  resident  portion  and  the  transient
       portion is reloaded if necessary. If a batch file is  in
       progress, the next line  of  the  file  is  fetched  and
       interpreted; otherwise a prompt is issued for  the  next
       user command.                                           
                 Miscellaneous DOS Interrupts                  
                                                               
                                                               
    3) This  function  call  is   typically   used   to   allow
       user-written utilities, drivers, or  interrupt  handlers
       to be loaded as ordinary .COM or .EXE programs, and then
       remain resident. Subsequent entrance to the code is  via
       a hardware or software interrupt.                       
    4) This  function  attempts  to  set  the  initial   memory
       allocation block to the length  in  bytes  specified  in
       register DX. If other memory blocks have been  requested
       by the application via Int 21H Function 48H,  they  will
       not be released by this function.                       
    5) Other methods of performing a final exit are:           
          - Int 20H                                            
          - Int 21H Function 00H                               
          - Int 21H Function 31H                               
          - Int 21H Function 4CH                               
    6) This function should not be called by .EXE programs that
       are loaded at the high end of the transient program area
       (i.e., linked with the /HIGH switch)  because  doing  so
       reserves  the  memory  that  is  normally  used  by  the
       transient part of COMMAND.COM. If COMMAND.COM cannot  be
       reloaded, the system will fail.                         
    7) This function does not work correctly when  DX  contains
       values in the range 0FFF1H-0FFFFH. In this case,  MS-DOS
       discards the high bit of the value in DX,  resulting  in
       the reservation of 32 KB less memory than was  requested
       by the program.                                         
    8) Int 21H Function 31H should be  used  in  preference  to
       this function because it supports return  codes,  allows
       larger amounts of memory to be reserved,  and  does  not
       require CS to contain the segment of the program segment
       prefix.                                                 
    9) [3.0+] If the program is running on a network, it should
       remove all locks it has placed on  file  regions  before
       terminating.                                            
                                                               
                                                               
                                                               
                                                               
   8.5. Interrupt 2FH                                          
                                                               
                                                               
Description:                                                   
            Multiplex Interrupt                                
                                                               
                                                               
   Provides a  general-purpose  avenue  of  communication  with
another process or with MS-DOS extensions, such  as  the  print
spooler, ASSIGN, SHARE, and APPEND.  The  multiplex  number  in
register AH specifies the process being communicated with.  The
range 00H-BFH is reserved for MS-DOS; applications may use  the
range C0H-FFH.                                                 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                       BIOS Interrupts                         
                      9. BIOS Interrupts                       
Interrupt    Function        Description                       
10H                          Video driver, all monitors        
10H                          Video driver, graphics monitors   
10H          10H             Video driver, colors              
10H          11H             Video driver, fonts               
10H          12H             Video configuration               
13H                          Disk driver (input/output)        
13H                          Disk driver (diagnostics)         
14H                          Serial communications port driver 
15H                          I/O subsystem                     
15H          C2H             I/O subsystem, mouse pointer (PS/2
16H                          Keyboard driver                   
17H                          Parallel port printer driver      
1AH                          Clock                             
miscellaneous                                                  
   9.1. Interrupt 10H (All Monitors)                           
Interrupt  Function   Name                                     
10H        00H        Set Video Mode                           
10H        01H        Set Cursor Type                          
10H        02H        Set Cursor Position                      
10H        03H        Get Cursor Position                      
10H        04H        Get Light Pen Position                   
10H        05H        Set Display Page                         
10H        06H        Initialize or Scroll Up Window           
10H        07H        Initialize or Scroll Down Window         
10H        08H        Read Character and Attribute at Cursor   
10H        09H        Write Character and Attribute at Cursor  
10H        0AH        Write Character at Cursor                
10H        0EH        Write Character in Teletype Mode         
10H        0FH        Get Video Mode                           
10H        13H        Write String in Teletype Mode            
   9.1.1. Int 10H Function 00H                                 
Description:                                                   
            Set Video Mode  [MDA]  [CGA]  [PCjr]  [EGA]  [MCGA]
            [VGA]                                              
   Selects the current video display  mode.  Also  selects  the
active video controller, if more than one is present.          
  Input                                Output                  
  -------------------------            -------                 
  AH=00H                               Nothing                 
  AL=video mode (see Notes)                                    
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
   The video modes applicable to the various IBM machine models
and video adapters are as follows:                             
                                                               
    Mode    Resolution            Colors  Text/Graphics        
    ----    -----------------     ------  -------------        
    00H     40-by-25                                           
             color burst off      16      text                 
    01H     40-by-25              16      text                 
    02H     80-by-25                                           
             color burst off      16      text                 
    03H     80-by-25              16      text                 
    04H     320-by-200             4      graphics             
    05H     320-by-200                                         
             color burst off       4      graphics             
    06H     640-by-200             2      graphics             
    07H     80-by-25               2*     text                 
    08H     160-by-200            16      graphics             
    09H     320-by-200            16      graphics             
    0AH     640-by-200             4      graphics             
    0BH     reserved                                           
    0CH     reserved                                           
    0DH     320-by-200            16      graphics             
    0EH     640-by-200            16      graphics             
    0FH     640-by-350             2*     graphics             
    10H     640-by-350             4**    graphics             
    10H     640-by-350            16***   graphics             
    11H     640-by-480             2      graphics             
    12H     640-by-480            16      graphics             
    13H     320-by-200           256      graphics             
                                                               
    *   Monochrome monitor only.                               
    **  EGA with 64 KB of RAM.                                 
    *** EGA with 128 KB or more of RAM.                        
                                                               
   The presence or absence of color burst is  only  significant
when a composite monitor is being used. For RGB monitors, there
is no functional difference between modes 00H and 01H or  modes
02H and 03H. On the CGA, two palettes are available in mode 04H
and one in mode 05H.                                           
   On the PC/AT, PCjr, and PS/2, if bit 7 of  AL  is  set,  the
display buffer is not cleared when a new mode is  selected.  On
the PC or PC/XT, this capability is available only when an  EGA
(which has its own ROM BIOS) is installed.                     
                                                               
                                                               
                                                               
   9.1.2. GetVidConfig                                         
                                                               
                                                               
                                                               
;* GetVidConfig - Determines current video configuration and   
;* initializes the vconfig structure.                          
;*                                                             
;* Shows: BIOS Interrupt - 10h, Function 0 (Set Video Mode)    
;*                         10h, Function 0Fh (Get Video Mode)  
;*                         10h, Function 1Ah (Get or Set Displa
;*                              Combination Code)              
;*                                                             
;* Uses:    vconfig - Video configuration structure,           
;*          declared in the DEMO.INC include file.             
;*                                                             
;* Params:  None                                               
                 Interrupt 10H (All Monitors)                  
;*                                                             
;* Return:  None                                               
GetVidConfig PROC                                              
        mov     ax, 1A00h  ; Request video info for VGA        
        int     10h        ; Get Display Combination Code      
chkVGA: cmp     al, 1Ah    ; Is VGA or MCGA present?           
        jne     chkEGA     ; No?  Then check for EGA           
        cmp     bl, 2      ; If VGA exists as secondary adapter
        je      isCGA      ;   check for CGA and mono as primar
        jb      isMONO                                         
        cmp     bl, 5      ; If EGA is primary, do normal      
        jbe     chkEGA     ;   EGA checking                    
chkMCGA:mov     vconfig.adapter, MCGA   ; Yes?  Assume MCGA    
        mov     vconfig.display, COLOR                         
        cmp     bl, 8                ; Correct assumption?     
        ja      gmode                ; Yes?  Continue          
isVGA:  mov     vconfig.adapter, VGA ; Assume it's VGA color   
        je      gmode                ; Yes?  Continue          
        mov     vconfig.display, MONO; No?  Must be VGA mono   
        jmp     SHORT gmode          ; Finished with VGA, so ju
chkEGA: mov     ah, 12h    ; Call EGA status function          
        mov     bl, 10h                                        
        sub     cx, cx     ; Clear status bits                 
        int     10h        ; Get Configuration Information     
        jcxz    chkCGA     ; If CX is unchanged, not EGA       
                           ; Set structure fields for EGA      
isEGA:  mov     vconfig.adapter, EGA                           
        mov     vconfig.display, MONO   ; Assume EGA mono      
        or      bh, bh     ; Correct assumption?               
        jnz     gmode      ; Yes?  Continue                    
        mov     vconfig.display, COLOR  ; No?  Must be EGA colo
        jmp     SHORT gmode    ; Finished with EGA, so jump    
chkCGA: int     11h            ; Get equipment list            
        and     al, 30h        ; If bits 4-5 set, monochrome   
        cmp     al, 30h        ; Monochrome text mode?         
        je      isMONO         ; Yes?  Continue                
isCGA:  mov     vconfig.adapter, CGA    ; No?  Must be CGA     
        mov     vconfig.display, COLOR                         
        mov     vconfig.CGAvalue, 29h ; Value for CGA 80x25 tex
        jmp     SHORT gmode           ;   color, blink enable  
isMONO: mov     vconfig.adapter, MDA    ; Set MONO             
        mov     vconfig.display, MONO                          
gmode:  mov     ah, 0Fh                                        
        int     10h               ; Get Video Mode             
        mov     vconfig.mode, al  ; Record mode                
        mov     vconfig.dpage, bh ;   and current page         
        cmp     al, 7             ; Monochrome text mode?      
        je      @F                ; Yes?  Continue             
        cmp     al, 3             ; Color text mode?           
        je      @F                ; Yes?  Continue             
        cmp     al, 2             ; Black/white 80-col mode?   
        je      @F                ; Yes?  Continue             
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
        mov     ax, 0003h         ; If not 80-col text mode,   
        mov     vconfig.mode, al  ;   request Function 0, mode 
        int     10h               ; Set Video Mode to 80-col   
                                                               
@@:     mov     al, vconfig.display ; Multiply display value   
        cbw                       ;   (which is either 0 or 1) 
        mov     bx, 800h          ;   by 800h, then add to B000
        mul     bx                ;   for segment address of   
        add     ax, 0B000h        ;   video buffer             
        add     ah, vconfig.dpage ; Adding display page gives  
        mov     vconfig.sgmnt, ax ;   address of current page  
                                                               
        mov     vconfig.rows, 24  ; Assume bottom row # = 24   
        cmp     vconfig.adapter, EGA    ; EGA or VGA?          
        jl      exit              ; No?  Exit                  
        mov     ax, 1130h         ; Yes?  Request character inf
        sub     bh, bh            ; Set BH to valid value      
        push    bp                ; BP will change, so save it 
        int     10h               ; Get number of rows/screen  
        mov     vconfig.rows, dl  ; Keep in structure          
        pop     bp                ; Restore BP                 
                                                               
exit:   ret                                                    
                                                               
GetVidConfig ENDP                                              
                                                               
                                                               
                                                               
                                                               
   9.1.3. Int 10H Function 01H                                 
                                                               
                                                               
Description:                                                   
            Set Cursor Type [MDA]  [CGA]  [PCjr]  [EGA]  [MCGA]
            [VGA]                                              
                                                               
                                                               
   Selects the starting  and  ending  lines  for  the  blinking
hardware cursor in text display modes.                         
                                                               
  Input                                           Output       
  ------------------------------------            -------      
  AH=01H                                          Nothing      
  CH bits 0-4=starting line for cursor                         
  CL bits 0-4=ending line for cursor                           
                                                               
   In text display modes, the video hardware causes the  cursor
to blink, and the blink cannot be disabled. In graphics  modes,
the hardware cursor is not available.                          
   The default values set by the ROM BIOS are:                 
                                                               
    Display                     Start         End              
    -------------------         -----         ---              
    monochrome mode 07H         11            12               
    text modes 00H-03H          6             7                
                                                               
   On the EGA, MCGA, and VGA in text  modes  00H-03H,  the  ROM
BIOS  accepts  cursor  start  and  end  values  as  though  the
character  cell  were  8-by-8,  and  remaps   the   values   as
appropriate  for  the  true  character  cell  dimensions.  This
mapping is called cursor emulation.                            
   You can turn off the cursor in several  ways.  On  the  MDA,
                                                               
                 Interrupt 10H (All Monitors)                  
CGA, and VGA, setting register CH =20H  causes  the  cursor  to
disappear. Techniques that involve setting illegal starting and
ending  lines  for  the  current  display  mode  tend   to   be
unreliable. An alternative method is to position the cursor  to
a nondisplayable address, such as (x,y)=(0,25).                
   9.1.4. SetCurSize                                           
;* SetCurSize - Sets cursor size.                              
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 1 (Set Cursor Type) 
;*                                                             
;* Params:  scan1 - Starting scan line                         
;*          scan2 - Ending scan line                           
;*                                                             
;* Return:  None                                               
SetCurSize PROC \                                              
        scan1:WORD, scan2:WORD                                 
        mov     cx, scan2          ; CL = ending scan line     
        mov     ch, BYTE PTR scan1 ; CH = starting scan line   
        mov     ah, 1              ; Function 1                
        int     10h                ; Set Cursor Type           
        ret                                                    
SetCurSize ENDP                                                
   9.1.5. Int 10H Function 02H                                 
Description: Set  Cursor  Position  [MDA]  [CGA]  [PCjr]  [EGA]
[MCGA] [VGA]                                                   
   Positions the cursor on the display, using text coordinates.
  Input                              Output                    
  -----------------------            -------                   
  AH=02H                             Nothing                   
  BH=page                                                      
  DH=row (y coordinate)                                        
  DL=column (x coordinate)                                     
   A separate cursor is maintained for each display  page,  and
each can be set independently with this function regardless  of
the currently active page.  The  number  of  available  display
pages depends on the video adapter and  current  display  mode.
See Int 10H Function 05H.                                      
   Text coordinates (x,y)=(0,0) are the  upper-left  corner  of
the screen.                                                    
   The maximum value for each text coordinate  depends  on  the
video adapter and current display mode, as follows:            
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
                                                               
    Mode    Maximum x    Maximum y                             
    ----    ---------    ---------                             
    00H     39           24                                    
    01H     39           24                                    
    02H     79           24                                    
    03H     79           24                                    
    04H     39           24                                    
    05H     39           24                                    
    06H     79           24                                    
    07H     79           24                                    
    08H     19           24                                    
    09H     39           24                                    
    0AH     79           24                                    
    0BH     reserved                                           
    0CH     reserved                                           
    0DH     39           24                                    
    0EH     79           24                                    
    0FH     79           24                                    
    10H     79           24                                    
    11H     79           29                                    
    12H     79           29                                    
    13H     39           24                                    
                                                               
                                                               
                                                               
                                                               
   9.1.6. SetCurPos                                            
                                                               
                                                               
                                                               
;* SetCurPos - Sets cursor position.                           
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 2                   
;*           (Set Cursor Position)                             
;*                                                             
;* Uses:    vconfig - Video configuration structure,           
;*          declared in the DEMO.INC include file.             
;*          The structure must first be initialized            
;*          by calling the GetVidConfig procedure.             
;*                                                             
;* Params:  row - Target row                                   
;*          col - Target column                                
;*                                                             
;* Return:  None                                               
                                                               
SetCurPos PROC \                                               
        row:WORD, col:WORD                                     
                                                               
        mov     dx, col           ; DL = column                
        mov     dh, BYTE PTR row  ; DH = row                   
        mov     ah, 2             ; Function 2                 
        mov     bh, vconfig.dpage ; Current page               
        int     10h               ; Set Cursor Position        
        ret                                                    
                                                               
SetCurPos ENDP                                                 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
                 Interrupt 10H (All Monitors)                  
   9.1.7. Int 10H Function 03H                                 
Description: Get  Cursor  Position  [MDA]  [CGA]  [PCjr]  [EGA]
[MCGA] [VGA]                                                   
   Obtains the current position of the cursor on  the  display,
in text coordinates.                                           
  Input              Output                                    
  -------            ------------------------------            
  AH=03H             CH=starting line for cursor               
  BH=page            CL=ending line for cursor                 
                     DH=row ( y coordinate)                    
                     DL=column (x coordinate)                  
   A separate cursor is maintained for each display  page,  and
each  can  be  inspected  independently  with   this   function
regardless  of  the  currently  active  page.  The  number   of
available display  pages  depends  on  the  video  adapter  and
current display mode. See Int 10H Function 05H.                
   9.1.8. Int 10H Function 04H                                 
Description:                                                   
            Get Light Pen Position [CGA] [PCjr] [EGA]          
   Obtains the current status and position of the light pen.   
Input     Output                                               
------    ---------------------------------------------------  
AH=04H    AH=00H if light pen not down/not triggered           
            =01H if light pen down/triggered                   
          BX=pixel column (graphics x coordinate)              
          CH=pixel row (graphics y coordinate, modes 04H-06H)  
          CX=pixel row (graphics y coordinate, modes 0DH-10H)  
          DH=character row (text y coordinate)                 
          DL=character column (text x coordinate)              
   The range of text and graphics coordinates returned by  this
function depends on the current display mode.                  
   On the  CGA,  the  graphics  coordinates  returned  by  this
function are not continuous.  The  y  coordinate  is  always  a
multiple of two; the x coordinate is either a multiple of  four
(for 320-by-200 graphics modes) or a  multiple  of  eight  (for
640-by-200 graphics modes).                                    
   Careful selection of background  and  foreground  colors  is
necessary to obtain maximum  sensitivity  from  the  light  pen
across the full screen width.                                  
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
   9.1.9. Int 10H Function 05H                                 
                                                               
                                                               
Description: Set Display Page [CGA] [PCjr] [EGA] [MCGA] [VGA]  
                                                               
                                                               
   Selects the active display page for the video display.      
                                                               
Input                               Output                     
----------------------------------  --------------------       
For CGA, EGA, MCGA, VGA             If CGA, EGA, MCGA, or      
AH=05H                              VGA adapter: nothing       
AL=page                                                        
  0-7 for modes 00H and 01H (CGA,   If PCjr and if function    
      EGA, MCGA, VGA)               called with AL=80H-83H:    
  0-3 for modes 02H and 03H (CGA)                              
  0-7 for modes 02H and 03H (EGA,   BH=CRT page register       
      MCGA, VGA)                                               
  0-7 for mode 07H (EGA, VGA)       BL=CPU page register       
  0-7 for mode 0DH (EGA, VGA)                                  
  0-3 for mode 0EH (EGA, VGA)                                  
  0-1 for mode 0FH (EGA, VGA)                                  
  0-1 or mode 10H (EGA, VGA)                                   
For PCjr only                                                  
AH=05H                                                         
AL=subfunction                                                 
  80H =read CRT/CPU page registers                             
  81H =set CPU page register                                   
  82H =set CRT page register                                   
  83H =set both CPU and CRT page registers                     
BH=CRT page (Subfunctions 82H and 83H)                         
BL=CPU page (Subfunctions 81H and 83H)                         
                                                               
                                                               
                                                               
                                                               
   9.1.10. Int 10H Function 06H                                
                                                               
                                                               
Description:                                                   
            Initialize or Scroll Up Window [MDA]  [CGA]  [PCjr]
            [EGA] [MCGA] [VGA]                                 
                                                               
                                                               
   Initializes a specified window of the display to ASCII blank
characters with a given attribute, or scrolls up  the  contents
of a window by a specified number of lines.                    
                                                               
Input                                          Output          
---------------------------------------------  -------         
AH=06H                                         Nothing         
AL=number of lines to scroll (if zero, entire                  
   window is blanked)                                          
BH=attribute to be used for blanked area                       
CH=y coordinate, upper-left corner of window                   
CL=x coordinate, upper-left corner of window                   
DH=y coordinate, lower-right corner of window                  
DL=x coordinate, lower-right corner of window                  
                                                               
   In video modes that support multiple  pages,  this  function
affects only the page currently being displayed.               
   If AL contains a value other than 00H, the area  within  the
                                                               
                 Interrupt 10H (All Monitors)                  
specified window is scrolled up  by  the  requested  number  of
lines. Text that is scrolled beyond the top of  the  window  is
lost. The new lines that appear at the bottom of the window are
filled with ASCII blanks carrying the  attribute  specified  by
register BH.                                                   
   To scroll down  the  contents  of  a  window,  see  Int  10H
Function 07H.                                                  
   9.1.11. Int 10H Function 07H                                
Description: Initialize  or  Scroll  Down  Window  [MDA]  [CGA]
[PCjr] [EGA] [MCGA] [VGA]                                      
   Initializes a specified window of the display to ASCII blank
characters with a given attribute, or scrolls down the contents
of a window by a specified number of lines.                    
  Input                                           Output       
  ----------------------------------------------  -------      
  AH=07H                                          Nothing      
  AL=number of lines to scroll (if zero, entire                
   window is blanked)                                          
  BH=attribute to be used for blanked area                     
  CH=y coordinate, upper-left corner of window                 
  CL=x coordinate, upper-left corner of window                 
  DH=y coordinate, lower-right corner of window                
  DL=x coordinate, lower-right corner of window                
   In video modes that support multiple  pages,  this  function
affects only the page currently being displayed.               
   If AL contains a value other than 00H, the area  within  the
specified window is scrolled down by the  requested  number  of
lines. Text that is scrolled beyond the bottom of the window is
lost. The new lines that appear at the top of  the  window  are
filled with ASCII blanks carrying the  attribute  specified  by
register BH.                                                   
   To scroll up the contents of a window, see Int 10H  Function
06H.                                                           
   9.1.12. Int 10H Function 08H                                
Description: Read Character and Attribute at Cursor [MDA] [CGA]
[PCjr] [EGA] [MCGA] [VGA]                                      
   Obtains the ASCII character and its attribute at the current
cursor position for the specified display page.                
  Input              Output                                    
  -------            ------------------------------            
  AH=08H             AH=attribute                              
  BH=page            AL=character                              
   In video modes that support multiple pages,  characters  and
their attributes can be read from any page, regardless  of  the
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
page currently being displayed.                                
                                                               
   9.1.13. ReadCharAttr                                        
                                                               
                                                               
                                                               
;* ReadCharAttr - Reads character and display attribute        
;*                      at cursor location.                    
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 8                   
;*          (Read Character and Attribute at Cursor)           
;*                                                             
;* Uses:    vconfig - Video configuration structure,           
;*          declared in the DEMO.INC include file.             
;*          The structure must first be initialized            
;*          by calling the GetVidConfig procedure.             
;*                                                             
;* Params:  attr - Pointer to short integer for display attribu
;*                                                             
;* Return:  Short integer with ASCII value of character        
                                                               
ReadCharAttr PROC \                                            
        USES di, \                                             
        attr:PTR WORD                                          
                                                               
        mov     ah, 8      ; Function 8                        
        mov     bh, vconfig.dpage ; Current page               
        int     10h        ; Read Character and Attribute      
        sub     bh, bh                                         
        mov     bl, ah        ; BX = attribute                 
        cbw                   ; AX = character                 
        LoadPtr es, di, attr  ; ES:DI = pointer to int         
        mov     es:[di], bx   ; Copy attribute                 
        ret                                                    
                                                               
ReadCharAttr ENDP                                              
                                                               
                                                               
                                                               
                                                               
   9.1.14. Int 10H Function 09H                                
                                                               
                                                               
Description: Write Character  and  Attribute  at  Cursor  [MDA]
[CGA] [PCjr] [EGA] [MCGA] [VGA]                                
                                                               
                                                               
   Writes an ASCII character and its attribute to  the  display
at the current cursor position.                                
                                                               
Input                                                 Output   
----------------------------------------------------  -------  
AH=09H                                                Nothing  
AL=character                                                   
BH=page                                                        
BL=attribute (text modes) or color (graphics modes)            
CX=count of characters to write (replication factor)           
                                                               
   In graphics modes, the replication factor in CX  produces  a
valid result only for the current row. If more  characters  are
written than there are remaining columns in  the  current  row,
the result is unpredictable.                                   
                 Interrupt 10H (All Monitors)                  
   All values of AL result in some  sort  of  display;  control
characters, including bell,  backspace,  carriage  return,  and
line feed, are not recognized as special characters and do  not
affect the cursor position.                                    
   After a character is  written,  the  cursor  must  be  moved
explicitly with Int 10H Function 02H to the next position.     
   To write a character without changing the attribute  at  the
current cursor position, use Int 10H Function 0AH.             
   If this function is used to  write  characters  in  graphics
mode and bit 7  of  BL  is  set  (1),  the  character  will  be
exclusive-OR'd (XOR) with the current  display  contents.  This
feature can be used to write characters and then "erase"  them.
   For the CGA and PCjr in  graphics  modes  04H-06H,  the  bit
patterns for character codes 80H-FFH are obtained from a  table
whose address is stored in the vector for Int 1FH. On the PCjr,
the address of the table for character codes 00-7FH  is  stored
in the vector for Int 44H. Alternative character  sets  can  be
installed by loading them into memory and updating this vector.
   For the EGA, MCGA, and VGA in graphics modes, the address of
the character definition table is stored in the vector for  Int
43H. See Int 10H Function 11H.                                 
   9.1.15. Int 10H Function 0AH                                
Description: Write Character at Cursor [MDA] [CGA] [PCjr] [EGA]
[MCGA] [VGA]                                                   
   Writes an ASCII character to  the  display  at  the  current
cursor position. The character receives the  attribute  of  the
previous character displayed at the same position.             
Input                                                 Output   
----------------------------------------------------  -------  
AH=0AH                                                Nothing  
AL=character                                                   
BH=page                                                        
BL=color (graphics modes, PCjr only)                           
CX=count of characters to write (replication factor)           
   In graphics modes, the replication factor in CX  produces  a
valid result only for the current row. If more  characters  are
written than there are remaining columns in  the  current  row,
the result is unpredictable.                                   
   All values of AL result in some  sort  of  display;  control
characters, including bell,  backspace,  carriage  return,  and
line feed, are not recognized as special characters and do  not
affect the cursor position.                                    
   After a character is  written,  the  cursor  must  be  moved
explicitly with Int 10H Function 02H to the next position.     
   To write a character and attribute  at  the  current  cursor
position, use Int 10H Function 09H.                            
   If this function is used to  write  characters  in  graphics
mode and bit 7  of  BL  is  set  (1),  the  character  will  be
exclusive-OR'd (XOR) with the current  display  contents.  This
feature can be used to write characters and then "erase"  them.
   For the CGA and PCjr in  graphics  modes  04H-06H,  the  bit
patterns for character codes 80H-FFH are obtained from a  table
whose address is stored in the vector for Int 1FH. On the PCjr,
the address of the table for character codes 00-7FH  is  stored
in the vector for Int 44H. Alternative character  sets  can  be
                 Interrupt 10H (All Monitors)                  
                                                               
                                                               
installed by loading them into memory and updating this vector.
   For the EGA, MCGA, and VGA in graphics modes, the address of
the character definition table is stored in the vector for  Int
43H. See Int 10H Function 11H.                                 
                                                               
                                                               
                                                               
   9.1.16. Int 10H Function 0EH                                
                                                               
                                                               
Description:                                                   
            Write Character in Teletype Mode [MDA] [CGA] [PCjr]
            [EGA] [MCGA] [VGA]                                 
                                                               
                                                               
   Writes an ASCII character to  the  display  at  the  current
cursor position, using the  specified  color  (if  in  graphics
modes), and then increments the cursor position  appropriately.
                                                               
  Input                                           Output       
  ------------------------------------            -------      
  AH=0EH                                          Nothing      
  AL=character                                                 
  BH=page                                                      
  BL=foreground color (graphics modes)                         
                                                               
   The special ASCII codes for  bell  (07H),  backspace  (08H),
carriage return (0DH), and line feed (0AH) are recognized,  and
the appropriate action  is  taken.  All  other  characters  are
written to the display (even if they are  control  characters),
and the cursor is moved to the next position.                  
   In video modes that support multiple pages,  characters  can
be written to any page, regardless of the page currently  being
displayed.                                                     
   Line wrapping and scrolling are provided. If the  cursor  is
at the end of a line, it is moved to the beginning of the  next
line. If the cursor reaches the end of the  last  line  on  the
screen, the screen is scrolled up by one line and the cursor is
placed at the beginning of a new blank line. The attribute  for
the entire new line is taken from the last character  that  was
written on the preceding line.                                 
   The default MS-DOS console driver (CON) uses  this  function
to write text to the screen. You cannot use  this  function  to
specify the attribute of a character. One method of  writing  a
character to the screen with a specific attribute is  to  first
write an ASCII blank (20H) with the desired  attribute  at  the
current cursor location using Int 10H Function 09H, then  write
the actual character with Int 10H Function 0EH. This technique,
although somewhat clumsy,  does  not  require  the  program  to
explicitly handle line wrapping and scrolling.                 
   See also Int 10H Function 13H.                              
                                                               
                                                               
                                                               
   9.1.17. Int 10H Function 0FH                                
                                                               
                                                               
Description: Get Video Mode [MDA]  [CGA]  [PCjr]  [EGA]  [MCGA]
[VGA]                                                          
                                                               
                                                               
   Obtains  the  current  display  mode  of  the  active  video
                                                               
                 Interrupt 10H (All Monitors)                  
controller.                                                    
  Input             Output                                     
  ------            ------------------------------------------ 
  AH=0FH            AH=number of character columns on screen   
                    AL=display mode (see Int 10H Function 00H) 
                    BH=active display page                     
   This function can be  called  to  obtain  the  screen  width
before clearing the screen with Int 10H Functions 06H or 07H.  
   9.1.18. Int 10H Function 13H                                
Description: Write String in Teletype Mode [MDA]  [CGA]  [PCjr]
[EGA] [MCGA] [VGA]                                             
   Transfers a string to the video  buffer  for  the  currently
active display, starting at the specified position.            
  Input                                         Output         
  --------------------------------------------  -------        
  AH=13H                                        Nothing        
  AL=write mode                                                
     0  attribute in BL;                                       
        string contains character codes only;                  
        and cursor position is not updated                     
        after write                                            
     1  attribute in BL; string contains                       
        character codes only; and cursor                       
        position is updated after write                        
     2  string contains alternating character                  
        codes and attribute bytes; and cursor                  
        position is not updated after write                    
     3  string contains alternating character                  
        codes and attribute bytes; and cursor                  
        position is updated after write                        
  BH=page                                                      
  BL=attribute, if AL=00H or 01H                               
  CX=length of character string                                
  DH=y coordinate (row)                                        
  DL=x coordinate (column)                                     
  ES:BP=segment:offset of string                               
   This function is not available on the  original  IBM  PC  or
PC/XT unless an EGA video adapter (which contains its  own  ROM
BIOS) is installed.                                            
   This function can be thought of as an extension to  Int  10H
Function 0EH. The  control  characters  bell  (07H),  backspace
(08H),  line  feed  (0AH),  and  carriage  return   (0DH)   are
recognized and handled appropriately.                          
              Interrupt 10H (Graphics Monitors)                
                                                               
                                                               
   9.2. Interrupt 10H (Graphics Monitors)                      
                                                               
                                                               
                                                               
Interrupt  Function         Name                               
10H        0BH              Set Palette, Background, or Border 
10H        0CH              Write Graphics Pixel               
10H        0DH              Read Graphics Pixel                
10H        10H              Color (summary screen)             
10H        11H              Fonts (summary screen)             
10H        12H              Video Configuration (summary screen
10H        1AH              Get or Set Display Combination Code
10H        1BH              Get Functionality/State Information
10H        1CH              Save or Restore Video State        
                                                               
                                                               
                                                               
                                                               
   9.2.1. Int 10H Function 0BH                                 
                                                               
                                                               
Description: Set Palette, Background, or  Border  [CGA]  [PCjr]
[EGA] [MCGA] [VGA]                                             
                                                               
                                                               
   Selects a palette, background, or border color.             
                                                               
Input                                               Output     
--------------------------------------------------  -------    
To set the background color and border color for    Nothing    
graphics modes or the border color for text modes              
AH=0BH                                                         
BH=00H                                                         
BL=color                                                       
To select the palette (320-by-200 4-color graphics modes)      
AH=0BH                                                         
BH=01H                                                         
BL=palette (see Notes)                                         
                                                               
   In text modes, this function selects only the border  color.
The background color of each individual character is controlled
by the upper 4 bits of that character's attribute byte.        
   On the CGA and EGA,  this  function  is  valid  for  palette
selection only in 320-by-200 4-color graphics modes.           
   In 320-by-200 4-color graphics modes, if register  BH  =01H,
the following palettes may be selected:                        
                                                               
    Palette  Pixel value  Color                                
    -------  -----------  ------------------                   
    0        0            same as background                   
             1            green                                
             2            red                                  
             3            brown or yellow                      
    1        0            same as background                   
             1            cyan                                 
             2            magenta                              
             3            white                                
                                                               
   On  the  CGA  in  640-by-200  2-color  graphics  mode,   the
background color selected with this function actually  controls
the display color for non-zero pixels; zero pixels  are  always
displayed as black.                                            
              Interrupt 10H (Graphics Monitors)                
   On the PCjr in 640-by-200 2-color graphics mode, if BH  =00H
and bit 0 of register BL is cleared, pixel value 1 is displayed
as white; if bit 0 is set, pixel value 1 is displayed as black.
   See also Int 10H Function 10H, which  is  used  for  palette
programming on the PCjr, EGA, MCGA, and VGA.                   
   9.2.2. Int 10H Function 0CH                                 
Description:                                                   
            Write Graphics  Pixel  [CGA]  [PCjr]  [EGA]  [MCGA]
            [VGA]                                              
   Draws a point on  the  display  at  the  specified  graphics
coordinates.                                                   
  Input                                        Output          
  ---------------------------------            -------         
  AH=0CH                                       Nothing         
  AL=pixel value                                               
  BH=page                                                      
  CX=column (graphics x coordinate)                            
  DX=row (graphics y coordinate)                               
   The range  of  valid  pixel  values  and  (x,y)  coordinates
depends on the current video mode.                             
   If bit 7  of  AL  is  set,  the  new  pixel  value  will  be
exclusive-OR'd (XOR) with the current contents of the pixel.   
   Register BH is ignored for display modes that  support  only
one page.                                                      
   9.2.3. Int 10H Function 0DH                                 
Description: Read Graphics  Pixel  [CGA]  [PCjr]  [EGA]  [MCGA]
[VGA]                                                          
   Obtains the current value of the pixel on the display at the
specified graphics coordinates.                                
  Input                                        Output          
  ---------------------------------            --------------  
  AH=0DH                                       AL=pixel value  
  BH=page                                                      
  CX=column (graphics x coordinate)                            
  DX=row (graphics y coordinate)                               
   The range of valid  (x,y)  coordinates  and  possible  pixel
values depends on the current video mode.                      
   Register BH is ignored for display modes that  support  only
one page.                                                      
              Interrupt 10H (Graphics Monitors)                
                                                               
                                                               
   9.2.4. Int 10H Function 1AH                                 
                                                               
                                                               
Description:                                                   
            Get or Set Display Combination Code [PS/2]         
                                                               
                                                               
   Returns a code describing the installed display  adapter(s),
or updates the ROM BIOS's  variable  describing  the  installed
adapter(s).                                                    
                                                               
  Input                         Output                         
  -------------------------     --------------------------     
  AH=1AH                        If function supported          
  AL=subfunction                AL=1AH                         
     00H=get display            and, if called with AL=00H     
      combination code          BH=inactive display code       
     01H=set display            BL=inactive display code       
      combination code                                         
  BH=inactive display                                          
   code (if AL =01H)                                           
  BL=active display                                            
   code (if AL =01H)                                           
                                                               
   The display codes are interpreted as follows:               
                                                               
    Code(s)     Video Subsystem Type                           
    -------     -----------------------------------            
    00H         no display                                     
    01H         MDA with 5151 monitor                          
    02H         CGA with 5153 or 5154 monitor                  
    03H         reserved                                       
    04H         EGA with 5153 or 5154 monitor                  
    05H         EGA with 5151 monitor                          
    06H         PGA with 5175 monitor                          
    07H         VGA with analog monochrome monitor             
    08H         VGA with analog color monitor                  
    09H         reserved                                       
    0AH         MCGA with digital color monitor                
    0BH         MCGA with analog monochrome monitor            
    0CH         MCGA with analog color monitor                 
    0DH-FEH     reserved                                       
    FFH         unknown                                        
                                                               
                                                               
                                                               
                                                               
   9.2.5. Int 10H Function 1BH                                 
                                                               
                                                               
Description:                                                   
            Get Functionality/State Information [PS/2]         
                                                               
                                                               
   Obtains information about the current display mode, as  well
as a pointer to a  table  describing  the  characteristics  and
capabilities of the video adapter and monitor.                 
                                                               
                                                               
                                                               
              Interrupt 10H (Graphics Monitors)                
Input                               Output                     
----------------------------------- ---------------------------
AH=1BH                              If function supported      
BX=implementation type (always 00H) AL=1BH                     
ES:DI=segment:offset of 64-byte     and information placed in  
       buffer                       caller's buffer (see Notes)
   The caller's buffer  is  filled  in  with  information  that
depends on the current video display mode:                     
Byte(s)                                                        
            Contents                                           
00H-03H                                                        
            pointer  to  functionality  information  (see  next
            Note)                                              
04H                                                            
            current video mode                                 
05H-06H                                                        
            number of character columns                        
07H-08H                                                        
            length of video refresh buffer (bytes)             
09H-0AH                                                        
            starting address in buffer of upper left corner  of
            display                                            
0BH-1AH                                                        
            cursor position for video pages 0-7 as eight 2-byte
            entries; first byte of each pair is  y  coordinate,
            second byte is x coordinate                        
1BH                                                            
            cursor starting line                               
1CH                                                            
            cursor ending line                                 
1DH                                                            
            active display page                                
1EH-1FH                                                        
            adapter base port address  (3BXH  monochrome,  3DXH
            color)                                             
20H                                                            
            current setting of register 3B8H or 3D8H           
21H                                                            
            current setting of register 3B9H or 3D9H           
22H                                                            
            number of character rows                           
23H-24H                                                        
            character height in scan lines                     
25H                                                            
            active display code (see Int 10H Function 1AH)     
26H                                                            
            inactive display code (see Int 10H Function 1AH)   
27H-28H                                                        
            number of displayable colors (0 for monochrome)    
29H                                                            
            number of display pages                            
2AH                                                            
            number of scan lines                               
               00H=200 scan lines                              
               01H=350 scan lines                              
               02H=400 scan lines                              
               03H=480 scan lines                              
               04H-FFH=reserved                                
              Interrupt 10H (Graphics Monitors)                
                                                               
                                                               
2BH                                                            
            primary character block (see Int 10H  Function  11H
            Subfunction 03H)                                   
2CH                                                            
            secondary character block                          
2DH                                                            
            miscellaneous state information                    
                                                               
     Bit(s)          Significance                              
     ------          ------------------------------------------
     0               =1 if all modes on all displays active    
                        (always 0 on MCGA)                     
     1               =1 if gray-scale summing active           
     2               =1 if monochrome display attached         
     3               =1 if mode set default palette            
                        loading disabled                       
     4               =1 if cursor emulation active             
                        (always 0 on=MCGA)                     
     5               =state of I/B toggle (0=intensity, 1=blink
     6-7             =reserved                                 
                                                               
2EH-30H                                                        
            reserved                                           
31H                                                            
            video memory available                             
               00H=64 KB                                       
               01H=128 KB                                      
               02H=192 KB                                      
               03H=256 KB                                      
32H                                                            
            save pointer state information                     
                                                               
      Bit(s)          Significance                             
      ------          ------------------------------------     
      0               =1 if 512-character set active           
      1               =1 if dynamic save area active           
      2               =1 if alpha font override active         
      3               =1 if graphics font override active      
      4               =1 if palette override active            
      5               =1 if display combination code (DCC)     
                         extension active                      
      6-7             =reserved                                
                                                               
33H-3FH                                                        
            reserved                                           
                                                               
                                                               
   Bytes 0-3 of the caller's buffer  contain  a  DWORD  pointer
(offset in lower word, segment in upper word) to the  following
information about the display adapter and monitor:             
                                                               
                                                               
Byte(s)                                                        
            Contents                                           
00H                                                            
            video modes supported                              
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
              Interrupt 10H (Graphics Monitors)                
       Bit(s)          Significance                            
       ------          ------------------------                
       0               =1 if mode 00H supported                
       1               =1 if mode 01H supported                
       2               =1 if mode 02H supported                
       3               =1 if mode 03H supported                
       4               =1 if mode 04H supported                
       5               =1 if mode 05H supported                
       6               =1 if mode 06H supported                
       7               =1 if mode 07H supported                
01H                                                            
            video modes supported                              
       Bit(s)          Significance                            
       ------          ------------------------                
       0               =1 if mode 08H supported                
       1               =1 if mode 09H supported                
       2               =1 if mode 0AH supported                
       3               =1 if mode 0BH supported                
       4               =1 if mode 0CH supported                
       5               =1 if mode 0DH supported                
       6               =1 if mode 0EH supported                
       7               =1 if mode 0FH supported                
02H                                                            
            video modes supported                              
       Bit(s)          Significance                            
       ------          ------------------------                
       0               =1 if mode 10H supported                
       1               =1 if mode 11H supported                
       2               =1 if mode 12H supported                
       3               =1 if mode 13H supported                
       4-7             =reserved                               
03H-06H                                                        
            reserved                                           
07H                                                            
            scan lines available in text modes                 
       Bit(s)          Significance                            
       ------          --------------------                    
       0               =1 if 200 scan lines                    
       1               =1 if 350 scan lines                    
       2               =1 if 400 scan lines                    
       3-7             =reserved                               
08H                                                            
            character blocks available in text modes  (see  Int
            10H Function 11H)                                  
09H                                                            
            maximum number of active character blocks  in  text
            modes                                              
0AH                                                            
            miscellaneous BIOS capabilities                    
              Interrupt 10H (Graphics Monitors)                
                                                               
                                                               
                                                               
       Bit(s)          Significance                            
       ------          --------------------------------------  
       0               =1 if all modes active on all displays  
                          (always 0 for MCGA)                  
       1               =1 if gray-scale summing available      
       2               =1 if character font loading available  
       3               =1 if mode set default palette          
                          loading available                    
       4               =1 if cursor emulation available        
       5               =1 if EGA (64-color) palette available  
       6               =1 if color register loading available  
       7               =1 if color register paging mode        
                          select available                     
                                                               
0BH                                                            
            miscellaneous BIOS capabilities                    
                                                               
       Bit(s)          Significance                            
       ------          ----------------------------------------
       0               =1 if light pen available               
       1               =1 if save/restore video state available
                          (always 0 on MCGA)                   
       2               =1 if background intensity/blinking     
                          control available                    
       3               =1 if get/set display combination       
                          code available                       
       4-7             =reserved                               
                                                               
0CH-0DH                                                        
            reserved                                           
0EH                                                            
            save area capabilities                             
                                                               
       Bit(s)          Significance                            
       ------          --------------------------------------  
       0               =1 if supports 512-character sets       
       1               =1 if dynamic save area available       
       2               =1 if alpha font override available     
       3               =1 if graphics font override available  
       4               =1 if palette override available        
       5               =1 if display combination code          
                          extension available                  
       6-7             =reserved                               
                                                               
0FH                                                            
            reserved                                           
                                                               
                                                               
                                                               
   9.2.6. Int 10H Function 1CH                                 
                                                               
                                                               
Description:                                                   
            Save or Restore Video State [PS/2]                 
                                                               
                                                               
   Saves or  restores  the  digital-to-analog  converter  (DAC)
state and color registers, ROM BIOS video driver data area,  or
video hardware state.                                          
              Interrupt 10H (Graphics Monitors)                
  Input                              Output                    
  -------------------------          --------------------------
  AH=1CH                             If function supported     
  AL=subfunction                     AL=1CH                    
     00H to get state buffer size    and, if called with AL=00H
     01H to save state               BX=buffer block count     
     02H to restore state            (64 bytes per block)      
  CX=requested states                or, if called with AL=01H 
     Bit(s)     Significance         State information placed  
     ------     ------------------   in caller's buffer        
     0          save/restore video   or, if called with AL=02H 
                 hardware state      Requested state restored  
     1          save/restore video   according to contents of  
                 BIOS data area      caller's buffer           
     2          save/restore video                             
                 DAC state and color                           
                 registers                                     
     3-15       reserved                                       
  ES:BX=segment:offset of buffer                               
   Subfunction 00H is used to determine the size of buffer that
will be necessary to contain the specified  state  information.
The caller must supply the buffer.                             
   The current video state  is  altered  during  a  save  state
operation (AL=01H). If the requesting program needs to continue
in the same video state, it can follow the save  state  request
with an immediate call to restore the video state.             
   This function is supported on the VGA only.                 
   9.3. Interrupt 10H, Function 10H (Colors)                   
Interrupt  Fnct  Subfnct    Name                               
10H        10H   00H        Set Palette Register               
10H        10H   01H        Set Border Color                   
10H        10H   02H        Set Palette and Border             
10H        10H   03H        Toggle Blink/Intensity Bit         
10H        10H   07H        Get Palette Register               
10H        10H   08H        Get Border Color                   
10H        10H   09H        Get Palette and Border             
10H        10H   10H        Set Color Register                 
10H        10H   12H        Set Block of Color Registers       
10H        10H   13H        Set Color Page State               
10H        10H   15H        Get Color Register                 
10H        10H   17H        Get Block of Color Registers       
10H        10H   1AH        Get Color Page State               
10H        10H   1BH        Set Gray-Scale Values              
   9.3.1. Int 10H Function 10H Subfunction 00H                 
Description:                                                   
            Set Palette Register [PCjr] [EGA] [MCGA] [VGA]     
             Interrupt 10H, Function 10H (Colors)              
                                                               
                                                               
   Sets  the  correspondence  of  a  palette  register   to   a
displayable color.                                             
                                                               
  Input                                     Output             
  ------------------------------            -------            
  For PCjr, EGA, or VGA                     Nothing            
  AH=10H                                                       
  AL=00H                                                       
  BH=color value                                               
  BL=palette register (00-0FH)                                 
  For MCGA                                                     
  AH=10H                                                       
  AL=00H                                                       
  BX=0712H                                                     
                                                               
   On the MCGA, this function can only be called with BX =0712H
and selects a color register set with eight consistent  colors.
                                                               
                                                               
                                                               
   9.3.2. Int 10H Function 10H Subfunction 01H                 
                                                               
                                                               
Description:                                                   
            Set Border Color [PCjr] [EGA] [VGA]                
                                                               
                                                               
   Controls the color of the screen border (overscan).         
                                                               
  Input                      Output                            
  ---------------            -------                           
  AH=10H                     Nothing                           
  AL=01H                                                       
  BH=color value                                               
                                                               
                                                               
                                                               
                                                               
   9.3.3. Int 10H Function 10H Subfunction 02H                 
                                                               
                                                               
Description:                                                   
            Set Palette and Border [PCjr] [EGA] [VGA]          
                                                               
                                                               
   Sets all palette registers and the border  color  (overscan)
in one operation.                                              
                                                               
  Input                                         Output         
  ----------------------------------            -------        
  AH=10H                                        Nothing        
  AL=02H                                                       
  ES:DX=segment:offset of color list                           
                                                               
   The color list is 17 bytes long. The first 16 bytes are  the
color values to be loaded into palette registers 0-15, and  the
last byte is stored in the border color register.              
   In 16-color graphics modes, the following default palette is
set up:                                                        
                                                               
                                                               
                                                               
             Interrupt 10H, Function 10H (Colors)              
    Pixel value  Color                                         
    -----------  ------------                                  
    01H          blue                                          
    02H          green                                         
    03H          cyan                                          
    04H          red                                           
    05H          magenta                                       
    06H          brown                                         
    07H          white                                         
    08H          gray                                          
    09H          light blue                                    
    0AH          light green                                   
    0BH          light cyan                                    
    0CH          light red                                     
    0DH          light magenta                                 
    0EH          yellow                                        
    0FH          intense white                                 
   9.3.4. Int 10H Function 10H Subfunction 03H                 
Description:                                                   
            Toggle  Blink/Intensity  Bit  [PCjr]  [EGA]  [MCGA]
            [VGA]                                              
   Determines whether the most significant bit of  a  character
attribute will select blinking or intensified display.         
  Input                                Output                  
  -------------------------            -------                 
  AH=10H                               Nothing                 
  AL=03H                                                       
  BL=blink/intensity toggle                                    
     0 =enable intensity                                       
     1 =enable blinking                                        
   9.3.5. Int 10H Function 10H Subfunction 07H                 
Description:                                                   
            Get Palette Register [VGA]                         
   Returns the color  associated  with  the  specified  palette
register.                                                      
  Input                           Output                       
  --------------------            -------------------          
  AH=10H                          BH=color                     
  AL=07H                                                       
  BL=palette register                                          
             Interrupt 10H, Function 10H (Colors)              
                                                               
                                                               
   9.3.6. Int 10H Function 10H Subfunction 08H                 
                                                               
                                                               
Description:                                                   
            Get Border Color [VGA]                             
                                                               
                                                               
   Returns the current border color (overscan).                
                                                               
  Input             Output                                     
  ------            ------------------------------             
  AH=10H            BH=color                                   
  AL=08H                                                       
                                                               
                                                               
                                                               
                                                               
   9.3.7. Int 10H Function 10H Subfunction 09H                 
                                                               
                                                               
Description:                                                   
            Get Palette and Border [VGA]                       
                                                               
                                                               
   Gets the contents of all palette registers  and  the  border
color (overscan) in one operation.                             
                                                               
Input                         Output                           
-------------------------     ------------------------------   
AH=10H                        ES:DX=segment:offset of buffer   
AL=09H                           and buffer contains palette   
ES:DX=segment:offset of          values in bytes 00H-0FH and   
      17-byte  buffer            border color in byte 10H      
                                                               
                                                               
                                                               
                                                               
   9.3.8. Int 10H Function 10H Subfunction 10H                 
                                                               
                                                               
Description:                                                   
            Set Color Register [MCGA] [VGA]                    
                                                               
                                                               
   Programs an individual color register with a  red-green-blue
(RGB) combination.                                             
                                                               
  Input                        Output                          
  -----------------            -------                         
  AH=10H                       Nothing                         
  AL=10H                                                       
  BX=color register                                            
  CH=green value                                               
  CL=blue value                                                
  DH=red value                                                 
                                                               
   If gray-scale summing is enabled,  the  weighted  gray-scale
value is calculated as described under  Int  10H  Function  10H
Subfunction 1BH and is stored into all three components of  the
color register. See also Int 10H Function 12H Subfunction  33H.
                                                               
                                                               
             Interrupt 10H, Function 10H (Colors)              
   9.3.9. Int 10H Function 10H Subfunction 10H                 
Description:                                                   
            Set Color Register [MCGA] [VGA]                    
   Programs an individual color register with a  red-green-blue
(RGB) combination.                                             
  Input                        Output                          
  -----------------            -------                         
  AH=10H                       Nothing                         
  AL=10H                                                       
  BX=color register                                            
  CH=green value                                               
  CL=blue value                                                
  DH=red value                                                 
   If gray-scale summing is enabled,  the  weighted  gray-scale
value is calculated as described under  Int  10H  Function  10H
Subfunction 1BH and is stored into all three components of  the
color register. See also Int 10H Function 12H Subfunction  33H.
   9.3.10. Int 10H Function 10H Subfunction 12H                
Description:                                                   
            Set Block of Color Registers [MCGA] [VGA]          
   Programs a group  of  consecutive  color  registers  in  one
operation.                                                     
  Input                                          Output        
  -----------------------------------            -------       
  AH=10H                                         Nothing       
  AL=12H                                                       
  BX=first color register                                      
  CX=number of color registers                                 
  ES:DX=segment:offset of color table                          
   The table consists of a series of 3-byte entries, one  entry
per color register to be programmed. The bytes of an individual
entry specify the red, green, and blue values (in  that  order)
for the associated color register.                             
   If gray-scale summing is enabled,  the  weighted  gray-scale
value for each register is calculated as  described  under  Int
10H Function 10H Subfunction 1BH and is stored into  all  three
components of the color register. See also Int 10H Function 12H
Subfunction 33H.                                               
   9.3.11. Int 10H Function 10H Subfunction 13H                
Description:                                                   
            Set Color Page State [VGA]                         
             Interrupt 10H, Function 10H (Colors)              
                                                               
                                                               
   Selects the paging mode for the color registers, or  selects
an individual page of color registers.                         
                                                               
  Input                                           Output       
  ------------------------------------            -------      
  To select the paging mode                       Nothing      
  AH=10H                                                       
  AL=13H                                                       
  BH=paging mode                                               
     00H for 4 pages of 64 registers                           
     01H for 16 pages of 16 registers                          
  BL=00H                                                       
  To select a color register page                              
  AH=10H                                                       
  AL=13H                                                       
  BH=page                                                      
  BL=01H                                                       
                                                               
   This function is not valid in mode 13H (320-by-200 256-color
graphics).                                                     
                                                               
                                                               
                                                               
   9.3.12. Int 10H Function 10H Subfunction 15H                
                                                               
                                                               
Description:                                                   
            Get Color Register [MCGA] [VGA]                    
                                                               
                                                               
   Returns the contents of a color register as its red,  green,
and blue components.                                           
                                                               
  Input                        Output                          
  -----------------            --------------                  
  AH=10H                       CH=green value                  
  AL=15H                       CL=blue value                   
  BX=color register            DH=red value                    
                                                               
                                                               
                                                               
                                                               
   9.3.13. Int 10H Function 10H Subfunction 17H                
                                                               
                                                               
Description:                                                   
            Get Block of Color Registers [MCGA] [VGA]          
                                                               
                                                               
   Allows the red, green, and blue components  associated  with
each of a set of color registers to be read in one operation.  
                                                               
Input                            Output                        
------------------------------   ------------------------------
AH=10H                           ES:DX=segment:offset of buffer
AL=17H                           and buffer contains color list
BX=first color register                                        
CX=number of color registers                                   
ES:DX=segment:offset of buffer                                 
   to receive color list                                       
                                                               
   The color list returned in the caller's buffer consists of a
                                                               
             Interrupt 10H, Function 10H (Colors)              
series of 3-byte entries corresponding to the color  registers.
Each 3-byte entry contains the register's red, green, and  blue
components in that order.                                      
   9.3.14. Int 10H Function 10H Subfunction 1AH                
Description:                                                   
            Get Color Page State [VGA]                         
   Returns the color register paging  mode  and  current  color
page.                                                          
  Input             Output                                     
  ------            ----------------------------------         
  AH=10H            BH=color page                              
  AL=1AH            BL=paging mode                             
                       00H if 4 pages of 64 registers          
                       01H if 16 pages of 16 registers         
   See Int 10H  Function  10H  Subfunction  13H,  which  allows
selection of the paging mode or current color page.            
   9.3.15. Int 10H Function 10H Subfunction 1BH                
Transforms the red, green, and blue values of one or more color
registers into the gray-scale equivalents.                     
  Input                                   Output               
  ----------------------------            -------              
  AH=10H                                  Nothing              
  AL=1BH                                                       
  BX=first color register                                      
  CX=number of color registers                                 
   For each color register, the weighted sum of its red, green,
and blue values is calculated (30% red $PL 59%  green  $PL  11%
blue) and written back into all three components of  the  color
register. The original red, green, and blue values are lost.   
   9.4. Interrupt 10H, Function 11H (Fonts)                    
             Interrupt 10H, Function 11H (Fonts)               
                                                               
                                                               
                                                               
Inter-                                                         
rupt  Fnct  Subfnct     Name                                   
10H   11H   00H         Load User Font and                     
10H   11H   10H         Reprogram Controller                   
10H   11H   01H         Load ROM 8-by-14 Font and              
10H   11H   11H         Reprogram Controller                   
10H   11H   02H         Load ROM 8-by-8 Font and               
10H   11H   12H         Reprogram Controller                   
10H   11H   03H         Set Block Specifier                    
10H   11H   04H         Load ROM 8-by-16 Font and              
10H   11H   14H         Reprogram Controller                   
10H   11H   20H         Set Int 1FH Font Pointer               
10H   11H   21H         Set Int 43H for User's Font            
10H   11H   22H         Set Int 43H for ROM 8-by-14 Font       
10H   11H   23H         Set Int 43H for ROM 8-by-8 Font        
10H   11H   24H         Set Int 43H for ROM 8-by-16 Font       
10H   11H   30H         Get Font Information                   
                                                               
                                                               
   9.4.1. Int 10H Function 11H Subfunction 00H/10H             
                                                               
                                                               
Description:                                                   
            Load  User  Font  and  Reprogram  Controller  [EGA]
            [MCGA] [VGA]                                       
                                                               
                                                               
   Loads the user's font (character definition) table into  the
specified block of character generator RAM.                    
                                                               
  Input                                               Output   
  ----------------------------------------            -------  
  AH=11H                                              Nothing  
  AL=00H or 10H (see Notes)                                    
  BH=points (bytes per character)                              
  BL=block                                                     
  CX=number of characters defined by table                     
  DX=first character code in table                             
  ES:BP=segment:offset of font table                           
                                                               
   This function provides font selection in text (alphanumeric)
display    modes.    For    font    selection    in    graphics
(all-points-addressable)  modes,  see  Int  10H  Function   11H
Subfunctions 20H-24H.                                          
   If AL=10H, page 0 must be  active.  The  points  (bytes  per
character),  rows,  and  length  of  the  refresh  buffer   are
recalculated. The controller is reprogrammed with  the  maximum
scan line (points -1), cursor start  (points  -2),  cursor  end
(points -1), vertical display end ((rows  *  points)  -1),  and
underline location (points -1, mode 7 only).                   
   If  Subfunction  10H  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   On the MCGA, a Subfunction 00H call should be followed by  a
Subfunction 03H call so that the ROM BIOS will  load  the  font
into the character generator's internal font pages.            
   Subfunction 10H is reserved on the MCGA. If  it  is  called,
Subfunction 00H is executed.                                   
                                                               
                                                               
                                                               
             Interrupt 10H, Function 11H (Fonts)               
   9.4.2. SetLineMode                                          
;* SetLineMode - Sets line mode for EGA or VGA.                
;*                                                             
;* Shows:   BIOS Interrupt - 10h, Function 11h                 
;*                            (Character Generator Interface)  
;*                           10h, Function 12h                 
;*                            (Video Subsystem Configuration)  
;*          Instruction - cmp                                  
;*                                                             
;* Uses:    vconfig - Video configuration structure,           
;*          declared in the DEMO.INC include file.             
;*          The structure must first be initialized            
;*          by calling the GetVidConfig procedure.             
;*                                                             
;* Params:  line - Requested line mode (25, 43, or 50)         
;*                                                             
;* Return:  Short integer with error code                      
;*          0 if successful                                    
;*          1 if error                                         
SetLineMode PROC \                                             
        line:WORD                                              
        cmp     vconfig.adapter, EGA    ; EGA or VGA?          
        jge     @F                      ; Yes?  Continue       
        jmp     e_exit           ; No?  Exit with error        
@@:     mov     ax, line         ; Check for valid parameter   
        cmp     al, 25                                         
        je      line25                                         
        cmp     al, 43                                         
        je      line43                                         
        cmp     al, 50                                         
        je      line50                                         
        jmp     SHORT e_exit ; If not 25, 43, or 50,           
                             ; exit w/ error                   
line25: mov     al, 11h      ; Set for EGA 25-line mode        
        cmp     vconfig.adapter, EGA    ; EGA?                 
        je      lmode        ; Yes?  Continue                  
        mov     ax, 1202h    ; No?  Function 12h for VGA       
        mov     bl, 30h      ; AL = 2 for 400 scan lines       
        int     10h          ; Reset to 400 scan lines         
        mov     ax, 0003     ; Reset mode (Function 0)         
        int     10h          ;   to mode 3 (80-col text)       
        mov     al, 14h      ; Request 8x16 char matrix        
        jmp     SHORT lmode                                    
line43: mov     al, 12h      ; Set for EGA 43-line mode        
        cmp     vconfig.adapter, EGA    ; EGA?                 
        je      lmode        ; Yes?  Continue                  
        mov     ax, 1201h    ; No?  Function 12h for VGA       
        mov     bl, 30h      ; AL = 1 for 350 scan lines       
        int     10h          ; Reset to 350 scan lines         
        mov     ax, 0003     ; Reset mode (Function 0)         
        int     10h          ;   to mode 3 (80-col text)       
        mov     al, 12h      ; Request 8x8 character matrix    
        jmp     SHORT lmode                                    
line50: cmp     vconfig.adapter, VGA    ; VGA?                 
        jne     e_exit       ; No?  Exit with error            
             Interrupt 10H, Function 11H (Fonts)               
                                                               
                                                               
        mov     ax, 1202h    ; Yes?  Function 12h              
        mov     bl, 30h      ; AL = 2 for 400 scan lines       
        int     10h          ; Reset to 400 scan lines         
        mov     ax, 0003     ; Reset mode (Function 0)         
        int     10h          ;   to mode 3 (80-col text)       
        mov     al, 12h      ; Request 8x8 character matrix    
                                                               
lmode:  sub     bl, bl       ; Use table 0                     
        mov     ah, 11h      ; Request Function 11h            
        int     10h          ; Set new line mode               
                                                               
        mov     ah, 12h      ; Select alternate print          
        mov     bl, 20h      ;    screen for EGA and VGA       
        int     10h                                            
                                                               
        cmp     vconfig.adapter, VGA    ; VGA?                 
        je      exit         ; Yes?  Then exit                 
        cmp     line, 12h    ; If EGA 43-line mode, set        
        je      port         ;   cursor through port to        
                             ;   avoid cursor emulation bug    
        mov     al, 7        ; Else use BIOS to set cursor     
        push    ax           ; Pass bottom scan line           
        mov     al, 6                                          
        push    ax           ; Pass top scan line              
        call    SetCurSize   ; Set normal cursor               
        add     sp, 4        ; Clean stack                     
        jmp     SHORT exit   ; Exit                            
                                                               
port:   mov     dx, 03D4h    ; Video controller address        
        mov     ax, 060Ah    ; Set AH = 06h (cursor start)     
                             ;     AL = 0Ah (register #)       
        out     dx, ax       ; Update port                     
        mov     ax, 000Bh    ; Set AH = 00h (cursor end)       
                             ;     AL = 0Bh (register #)       
        out     dx, ax       ; Update port                     
        jmp     SHORT exit   ; Normal exit                     
                                                               
e_exit: mov     ax, 1        ; Set error code                  
        jmp     SHORT @F                                       
exit:   sub     ax, ax       ; Clear error code                
@@:     ret                                                    
                                                               
SetLineMode ENDP                                               
                                                               
                                                               
                                                               
                                                               
   9.4.3. Int 10H Function 11H Subfunction 01H/11H             
                                                               
                                                               
Description: Load ROM 8-by-14  Font  and  Reprogram  Controller
[EGA] [VGA]                                                    
                                                               
                                                               
   Loads the ROM BIOS  default  8-by-14  font  table  into  the
specified block of character generator RAM.                    
                                                               
                                                               
             Interrupt 10H, Function 11H (Fonts)               
Input                                Output                    
-------------------------            -------                   
AH=11H                               Nothing                   
AL=01H or 11H (see Notes)                                      
BL=block                                                       
   This function provides font selection in text (alphanumeric)
display    modes.    For    font    selection    in    graphics
(all-points-addressable)  modes,  see  Int  10H  Function   11H
Subfunctions 20H-24H.                                          
   If AL=11H, page 0 must be  active.  The  points  (bytes  per
character),  rows,  and  length  of  the  refresh  buffer   are
recalculated. The controller is reprogrammed with  the  maximum
scan line (points -1), cursor start  (points  -2),  cursor  end
(points -1), vertical display end ((rows  *  points)  -1),  and
underline location (points -1, mode 7 only).                   
   If  Subfunction  11H  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   Subfunctions 01H and 11H are reserved on the MCGA. If either
is called, Subfunction 04H is executed.                        
   9.4.4. Int 10H Function 11H Subfunction 02H/12H             
Description: Load ROM  8-by-8  Font  and  Reprogram  Controller
[EGA] [MCGA] [VGA]                                             
   Loads the ROM  BIOS  default  8-by-8  font  table  into  the
specified block of character generator RAM.                    
  Input                                Output                  
  -------------------------            -------                 
  AH=11H                               Nothing                 
  AL=02H or 12H (see Notes)                                    
  BL=block                                                     
   This function provides font selection in text (alphanumeric)
display    modes.    For    font    selection    in    graphics
(all-points-addressable)  modes,  see  Int  10H  Function   11H
Subfunctions 20H-24H.                                          
   If AL =12H, page 0 must be active.  The  points  (bytes  per
character),  rows,  and  length  of  the  refresh  buffer   are
recalculated. The controller is reprogrammed with  the  maximum
scan line (points -1), cursor start  (points  -2),  cursor  end
(points -1), vertical display end ((rows  *  points)  -1),  and
underline location (points -1, mode 7 only).                   
   If  Subfunction  12H  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   On the MCGA, a Subfunction 02H call should be followed by  a
Subfunction 03H call, so that the ROM BIOS will load  the  font
into the character generator's internal font pages.            
   Subfunction 12H is reserved on the MCGA. If  it  is  called,
Subfunction 02H is executed.                                   
             Interrupt 10H, Function 11H (Fonts)               
                                                               
                                                               
   9.4.5. Int 10H Function 11H Subfunction 03H                 
                                                               
                                                               
Description:                                                   
            Set Block Specifier [EGA] [MCGA] [VGA]             
                                                               
                                                               
   Determines  the  character  blocks  selected  by  bit  3  of
character attribute bytes in alphanumeric (text) display modes.
                                                               
  Input                                   Output               
  ----------------------------            -------              
  AH=11H                                  Nothing              
  AL=03H                                                       
  BL=character generator block                                 
   select code (see Notes)                                     
                                                               
   On the EGA and MCGA, the bits of BL are used as follows:    
                                                               
Bits   Significance                                            
----   --------------------------------------------------------
0-1    character block selected by attribute bytes with bit 3=0
2-3    character block selected by attribute bytes with bit 3=1
4-7    not used (should be 0)                                  
                                                               
   On the VGA, the bits of BL are used as follows:             
                                                               
Bits   Significance                                            
----   --------------------------------------------------------
0,1,4  character block selected by attribute bytes with bit 3=0
2,3,5  character block selected by attribute bytes with bit 3=1
6-7    not used (should be 0)                                  
                                                               
   When using a 256-character set, both  fields  of  BL  should
select the same  character  block.  In  such  cases,  character
attribute bit 3 controls the foreground intensity.             
   When using 512-character sets, the fields  of  BL  designate
the blocks holding each half of the character set, and bit 3 of
the character attribute selects the upper or lower half of  the
character set.                                                 
   When using a 512-character set, a call to Int  10H  Function
10H Subfunction 00H with BX =0712H is recommended  to  set  the
color planes to eight consistent colors.                       
                                                               
                                                               
                                                               
   9.4.6. Int 10H Function 11H Subfunction 04H                 
                                                               
                                                               
Description: Load ROM 8-by-16  Font  and  Reprogram  Controller
[MCGA] [VGA]                                                   
                                                               
                                                               
   Loads the ROM BIOS  default  8-by-16  font  table  into  the
specified block of character generator RAM.                    
                                                               
  Input                                Output                  
  -------------------------            -------                 
  AH=11H                               Nothing                 
  AL=04H or 14H (see Notes)                                    
  BL=block                                                     
                                                               
             Interrupt 10H, Function 11H (Fonts)               
   This function provides font selection in text (alphanumeric)
display    mode.    For    font    selection    in     graphics
(all-points-addressable)  modes,  see  Int  10H  Function   11H
Subfunctions 20H-24H.                                          
   If AL =14H, page 0 must be active.  The  points  (bytes  per
character),  rows,  and  length  of  the  refresh  buffer   are
recalculated. The controller is reprogrammed with  the  maximum
scan line (points -1), cursor start  (points  -2),  cursor  end
(points -1), vertical display end rows * points -1 for 350  and
400 line modes, or rows * points * 2 -1 for  200  line  modes),
and underline location (points -1, mode 7 only).               
   If  Subfunction  14H  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   On the MCGA, a Subfunction 04H call should be followed by  a
Subfunction 03H call so that the ROM BIOS will  load  the  font
into the character generator's internal font pages.            
   Subfunction 14H is reserved on the MCGA. If  it  is  called,
Subfunction 04H is executed.                                   
   9.4.7. Int 10H Function 11H Subfunction 14H                 
Description: Load ROM 8-by-16  Font  and  Reprogram  Controller
[MCGA] [VGA]                                                   
   Loads the ROM BIOS  default  8-by-16  font  table  into  the
specified block of character generator RAM.                    
  Input                            Output                      
  -------------------------        -------                     
  AH=11H                           Nothing                     
  AL=04H or 14H (see Notes)                                    
  BL=block                                                     
   This function provides font selection in text (alphanumeric)
display    mode.    For    font    selection    in     graphics
(all-points-addressable)  modes,  see  Int  10H  Function   11H
Subfunctions 20H-24H.                                          
   If AL =14H, page 0 must be active.  The  points  (bytes  per
character),  rows,  and  length  of  the  refresh  buffer   are
recalculated. The controller is reprogrammed with  the  maximum
scan line (points -1), cursor start  (points  -2),  cursor  end
(points -1), vertical display end rows * points -1 for 350  and
400 line modes, or rows * points * 2 -1 for  200  line  modes),
and underline location (points -1, mode 7 only).               
   If  Subfunction  14H  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   On the MCGA, a Subfunction 04H call should be followed by  a
Subfunction 03H call so that the ROM BIOS will  load  the  font
into the character generator's internal font pages.            
   Subfunction 14H is reserved on the MCGA. If  it  is  called,
Subfunction 04H is executed.                                   
             Interrupt 10H, Function 11H (Fonts)               
                                                               
                                                               
   9.4.8. Int 10H Function 11H Subfunction 20H                 
                                                               
                                                               
Description:                                                   
            Set Int 1FH Font Pointer [EGA] [MCGA] [VGA]        
                                                               
                                                               
   Sets the Int 1FH pointer to  the  user's  font  table.  This
table is used for character codes  80H-FFH  in  graphics  modes
04H-06H.                                                       
                                                               
  Input                                         Output         
  ----------------------------------            -------        
  AH=11H                                        Nothing        
  AL=20H                                                       
  ES:BP=segment:offset of font table                           
                                                               
   This  function   provides   font   selection   in   graphics
(all-points-addressable) display modes. For font  selection  in
text  (alphanumeric)  modes,   see   Int   10H   Function   11H
Subfunctions 00H-14H.                                          
   If this  subfunction  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
                                                               
                                                               
                                                               
   9.4.9. Int 10H Function 11H Subfunction 21H                 
                                                               
                                                               
Description:                                                   
            Set Int 43H for User's Font [EGA] [MCGA] [VGA]     
                                                               
                                                               
   Sets the vector for Int 43H to  point  to  the  user's  font
table and updates the video  ROM  BIOS  data  area.  The  video
controller is not reprogrammed.                                
                                                               
  Input                                           Output       
  ------------------------------------------      -------      
  AH=11H                                          Nothing      
  AL=21H                                                       
  BL=character rows specifier                                  
     00H if user specified (see register DL)                   
     01H =14 (0EH) rows                                        
     02H =25 (19H) rows                                        
     03H =43 (2BH) rows                                        
  CX=points (bytes per character)                              
  DL=character rows per screen (if BL =00H)                    
  ES:BP=segment:offset of user font table                      
                                                               
   This  function   provides   font   selection   in   graphics
(all-points-addressable) display modes. For font  selection  in
text  (alphanumeric)  modes,   see   Int   10H   Function   11H
Subfunctions 00H-14H.                                          
   If this  subfunction  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
                                                               
                                                               
                                                               
             Interrupt 10H, Function 11H (Fonts)               
   9.4.10. Int 10H Function 11H Subfunction 22H                
Description:                                                   
            Set Int 43H for ROM 8-by-14 Font [EGA] [MCGA] [VGA]
   Sets the vector for Int 43H to point to the ROM BIOS default
8-by-14 font and updates the video  ROM  BIOS  data  area.  The
video controller is not reprogrammed.                          
  Input                                             Output     
  ------------------------------------------        -------    
  AH=11H                                            Nothing    
  AL=22H                                                       
  BL=character rows specifier                                  
     00H if user specified (see register DL)                   
     01H=14 (0EH) rows                                         
     02H=25 (19H) rows                                         
     03H=43 (2BH) rows                                         
  DL=character rows per screen (if BL=00H)                     
   This  function   provides   font   selection   in   graphics
(all-points-addressable) display modes. For font  selection  in
text  (alphanumeric)  modes,   see   Int   10H   Function   11H
Subfunctions 00H-14H.                                          
   If this  subfunction  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
   When this subfunction is called on the MCGA, Subfunction 24H
is substituted.                                                
   9.4.11. Int 10H Function 11H Subfunction 23H                
Description:                                                   
            Set Int 43H for ROM 8-by-8 Font [EGA] [MCGA]  [VGA]
   Sets the vector for Int 43H to point to the ROM BIOS default
8-by-8 font and updates the video ROM BIOS data area. The video
controller is not reprogrammed.                                
  Input                                             Output     
  ------------------------------------------        -------    
  AH=11H                                            Nothing    
  AL=23H                                                       
  BL=character rows specifier                                  
     00H if user specified (see register DL)                   
     01H=14 (0EH) rows                                         
     02H=25 (19H) rows                                         
     03H=43 (2BH) rows                                         
  DL=character rows per screen (if BL =00H)                    
   This  function   provides   font   selection   in   graphics
(all-points-addressable) display modes. For font  selection  in
text  (alphanumeric)  modes,   see   Int   10H   Function   11H
Subfunctions 00H-14H.                                          
   If this  subfunction  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
             Interrupt 10H, Function 11H (Fonts)               
                                                               
                                                               
   9.4.12. Int 10H Function 11H Subfunction 24H                
                                                               
                                                               
Description:                                                   
            Set Int 43H for ROM 8-by-16 Font [MCGA] [VGA]      
                                                               
                                                               
   Sets the vector for Int 43H to point to the ROM BIOS default
8-by-16 font and updates the video  ROM  BIOS  data  area.  The
video controller is not reprogrammed.                          
                                                               
  Input                                          Output        
  ----------------------------------------       --------      
  AH=11H                                         Nothing       
  AL=24H                                                       
  BL=row specifier                                             
     01H=14 (0EH) rows                                         
     02H=25 (19H) rows                                         
     03H=43 (2BH) rows                                         
  DL=character rows per screen (if BL=00H)                     
                                                               
   This  function   provides   font   selection   in   graphics
(all-points-addressable) display modes. For font  selection  in
text  (alphanumeric)  modes,   see   Int   10H   Function   11H
Subfunctions 00H-14H.                                          
   If this  subfunction  is  called  at  any  time  other  than
immediately after a mode set, the results are unpredictable.   
                                                               
                                                               
                                                               
   9.4.13. Int 10H Function 11H Subfunction 30H                
                                                               
                                                               
Description:                                                   
            Get Font Information [EGA] [MCGA] [VGA]            
                                                               
                                                               
   Returns a pointer to the character definition  table  for  a
font, and the points (bytes per character) and  rows  for  that
font.                                                          
                                                               
Input                        Output                            
---------------------------  ----------------------------------
AH=11H                       CX=points (bytes per character)   
AL=30H                       DL=rows (character rows on screen-
BH=font code                 ES:BP=segment:offset of font table
 00H=current Int 1FH contents                                  
 01H=current Int 43H contents                                  
 02H=ROM 8-by-14 font                                          
     (EGA, VGA only)                                           
 03H=ROM 8-by- 8 font                                          
     (characters 00H-7FH)                                      
 04H=ROM 8-by- 8 font                                          
    (characters 80H-FFH)                                       
 05H=ROM alternate 9-by-14 font                                
     (EGA, VGA only)                                           
 06H=ROM 8-by-16 font                                          
     (MCGA, VGA only)                                          
 07H=ROM alternate 9-by-16 font                                
     (VGA only)                                                
                                                               
                                                               
         Interrupt 10H, Function 12H (Video Config.)           
   9.5.  Interrupt  10H,   Function   12H   (Video             
   Config.)                                                    
Interrupt  Fnct  Subfnct  Name                                 
10H        12H   10H      Get Configuration Information        
10H        12H   20H      Select Alternate PrintScreen         
10H        12H   30H      Set Scan Lines                       
10H        12H   31H      Enable/Disable Default Palette Loadin
10H        12H   32H      Enable/Disable Video                 
10H        12H   33H      Enable/Disable Gray-Scale Summing    
10H        12H   34H      Enable/Disable Cursor Emulation      
10H        12H   35H      Switch Active Display                
10H        12H   36H      Enable/Disable Screen Refresh        
   9.5.1. Int 10H Function 12H Subfunction 10H                 
Description:                                                   
            Get Configuration Information [EGA] [VGA]          
   Obtains  configuration  information  for  the  active  video
subsystem.                                                     
  Input             Output                                     
  ------            --------------------------------           
  AH=12H            BH=display type                            
  BL=10H               0H if color display                     
                       1H if monochrome display                
                    BL=memory installed on EGA board           
                       00H if 64 KB                            
                       01H if 128 KB                           
                       03H if 256 KB                           
                    CH=feature bits (see Notes)                
                    CL=switch setting (see Notes)              
   The feature bits are set from Input  Status  register  0  in
response to an output on the specified Feature Control register
bits:                                                          
      Feature     Feature Control     Input Status             
      Bit(s)      Output Bit          Bit                      
      -------     ---------------     ------------             
      0           0                   5                        
      1           0                   6                        
      2           1                   5                        
      3           1                   6                        
      4-7         not used                                     
   The bits in the switch settings byte indicate the  state  of
the EGA's configuration DIP switch (1 =off, 0 =on).            
         Interrupt 10H, Function 12H (Video Config.)           
                                                               
                                                               
                                                               
      Bit     Significance                                     
      ---     ----------------------                           
      0       configuration switch 1                           
      1       configuration switch 2                           
      2       configuration switch 3                           
      3       configuration switch 4                           
      4-7     not used                                         
                                                               
                                                               
                                                               
                                                               
   9.5.2. Int 10H Function 12H Subfunction 20H                 
                                                               
                                                               
Description:                                                   
            Select Alternate PrintScreen [EGA] [VGA]           
                                                               
                                                               
   Selects an alternate print-screen routine for  the  EGA  and
VGA that works properly if the screen length is not  25  lines.
The ROM BIOS default  print-screen  routine  always  prints  25
lines.                                                         
                                                               
  Input             Output                                     
  ------            -------                                    
  AH=12H            Nothing                                    
  BL=20H                                                       
                                                               
                                                               
                                                               
                                                               
   9.5.3. Int 10H Function 12H Subfunction 30H                 
                                                               
                                                               
Description:                                                   
            Set Scan Lines [VGA]                               
                                                               
                                                               
   Selects the number of scan lines for alphanumeric modes. The
selected value takes effect the next time Int 10H Function  00H
is called to select the display mode.                          
                                                               
  Input                            Output                      
  ---------------------            ------------------------    
  AH=12H                           If the VGA is active        
  AL=scan line code                AL=12H                      
     00H=200 scan lines            If the VGA is not active    
     01H=350 scan lines            AL=00H                      
  BL=30H                                                       
                                                               
                                                               
                                                               
                                                               
   9.5.4. Int 10H Function 12H Subfunction 31H                 
                                                               
                                                               
Description:                                                   
            Enable/Disable Default Palette Loading [MCGA] [VGA]
                                                               
                                                               
   Enables or disables loading of  a  default  palette  when  a
                                                               
         Interrupt 10H, Function 12H (Video Config.)           
video display mode is selected.                                
Input                                     Output               
----------------------------------------  ---------------------
AH=12H                                    If function supported
AL=00H to enable default palette loading    AL=12H             
   01H to disable default palette loading                      
BL=31H                                                         
   9.5.5. Int 10H Function 12H Subfunction 32H                 
Description:                                                   
            Enable/Disable Video [MCGA] [VGA]                  
   Enables or disables CPU access to the  video  adapter's  I/O
ports and video refresh buffer.                                
  Input                               Output                   
  ------------------------            ---------------------    
  AH=12H                              If function supported    
  AL=00H to enable access             AL=12H                   
     01H to disable access                                     
  BL=32H                                                       
   9.5.6. Int 10H Function 12H Subfunction 33H                 
Description:                                                   
            Enable/Disable Gray-Scale Summing [MCGA] [VGA]     
   Enables or disables gray-scale  summing  for  the  currently
active display.                                                
Input                                 Output                   
------------------------------------  ---------------------    
AH=12H                                If function supported    
AL=00H to enable gray-scale summing     AL=12H                 
   01H to disable gray-scale summing                           
BL=33H                                                         
   When enabled, gray-scale summing occurs during display  mode
selection, palette programming, and color register loading.    
   9.5.7. Int 10H Function 12H Subfunction 34H                 
Description:                                                   
            Enable/Disable Cursor Emulation [VGA]              
   Enables or  disables  cursor  emulation  for  the  currently
         Interrupt 10H, Function 12H (Video Config.)           
                                                               
                                                               
active display. When cursor emulation is enabled, the ROM  BIOS
automatically remaps Int 10H Function 01H cursor  starting  and
ending lines for the current character cell dimensions.        
                                                               
  Input                                Output                  
  ----------------------------------   ---------------------   
  AH=12H                               If function supported   
  AL=00H to enable cursor emulation      AL=12H                
     01H to disable cursor emulation                           
  BL=34H                                                       
                                                               
                                                               
                                                               
                                                               
   9.5.8. Int 10H Function 12H Subfunction 35H                 
                                                               
                                                               
Description:                                                   
            Switch Active Display [MCGA] [VGA]                 
                                                               
                                                               
   Allows selection of one of two video adapters in the system,
when memory usage or port addresses conflict  between  the  two
adapters.                                                      
                                                               
Input                         Output                           
----------------------------  -------------------------------  
AH=12H                        If function supported            
AL=switching function           AL=12H                         
  00H to disable initial        and, if called with AL=00H     
      video adapter             or 02H                         
  01H to enable system board    Video adapter state information
      video adapter             saved in caller's buffer       
  02H to disable active         or, if called with AL =03H     
      video adapter             Video adapter state restored   
  03H to enable inactive        from information in caller's   
      video adapter             buffer.                        
BL=35H                                                         
ES:DX=segment:offset of 128-byte buffer                        
    (if AL =00H, 02H, or 03H)                                  
                                                               
   This subfunction cannot be used unless both  video  adapters
have a disable capability (Int  10H  Function  12H  Subfunction
32H).                                                          
   If there is no conflict between the system board  video  and
the adapter board video in memory or  port  usage,  both  video
controllers can be active simultaneously and  this  subfunction
is not required.                                               
                                                               
                                                               
                                                               
   9.5.9. Int 10H Function 12H Subfunction 36H                 
                                                               
                                                               
Description:                                                   
            Enable/Disable Screen Refresh [VGA]                
                                                               
                                                               
   Enables or disables the  video  refresh  for  the  currently
active display.                                                
                                                               
                                                               
                                                               
         Interrupt 10H, Function 12H (Video Config.)           
  Input                               Output                   
  ------------------------            ---------------------    
  AH=12H                              If function supported    
  AL=00H to enable refresh            AL=12H                   
     01H to disable refresh                                    
  BL=36H                                                       
   9.6. Function 13H (Disk I/O)                                
                           Disk I/O                            
Interrupt  Function         Name                               
13H        00H              Reset Disk System                  
13H        01H              Get Disk System Status             
13H        02H              Read Sector                        
13H        03H              Write Sector                       
13H        04H              Verify Sector                      
13H        05H              Format Track                       
13H        06H              Format Bad Track                   
13H        07H              Format Drive                       
13H        08H              Get Drive Parameters               
13H        09H              Initialize Fixed Disk Characteristi
13H        0AH              Read Sector Long                   
13H        0BH              Write Sector Long                  
13H        0CH              Seek                               
13H        0DH              Reset Fixed Disk System            
13H        0EH              Read Sector Buffer                 
13H        0FH              Write Sector Buffer                
                       Disk Diagnostics                        
Interrupt  Function         Name                               
13H        10H              Get Drive Status                   
13H        11H              Recalibrate Drive                  
13H        12H              Controller RAM Diagnostic          
13H        13H              Controller Drive Diagnostic        
13H        14H              Controller Internal Diagnostic     
13H        15H              Get Disk Type                      
13H        16H              Get Disk Change Status             
13H        17H              Set Disk Type                      
13H        18H              Set Media Type for Format          
13H        19H              Park Heads                         
13H        1AH              Format ESDI Drive                  
                   Function 13H (Disk I/O)                     
                                                               
                                                               
   9.6.1. Int 13H Function 00H                                 
                                                               
                                                               
Description:                                                   
            Reset Disk System [PC] [AT] [PS/2]                 
                                                               
                                                               
   Resets the disk controller, recalibrates its attached drives
(the read/ write arm is moved to cylinder 0), and prepares  for
disk I/O.                                                      
                                                               
Input                   Output                                 
---------------------   ------------------------------------   
AH=00H                  If function successful                 
DL=drive                  Carry flag=clear                     
  00H-7FH floppy disk     AH=00H                               
  80H-FFH fixed disk    If function unsuccessful               
                          Carry flag=set                       
                          AH=status (see Int 13H Function 01H) 
                                                               
   This function should be called after a  failed  floppy  disk
Read, Write, Verify, or  Format  request  before  retrying  the
operation.                                                     
   If called with DL >NM =80H (i.e.,  selecting  a  fixed  disk
drive), the floppy disk controller  and  then  the  fixed  disk
controller are reset. See also  Int  13H  Function  0DH,  which
allows the fixed disk controller to be reset without  affecting
the floppy disk controller.                                    
                                                               
                                                               
                                                               
   9.6.2. Int 13H Function 01H                                 
                                                               
                                                               
Description:                                                   
            Get Disk System Status [PC] [AT] [PS/2]            
                                                               
                                                               
   Returns the status of the most recent disk operation.       
                                                               
Input                      Output                              
-----------------------    ------------------------------------
AH=01H                     AH=00H                              
DL=drive                   AL=status of previous disk operation
  00H-7FH  floppy disk       00H no error                      
  80H-FFH  fixed disk        01H invalid command               
                             02H address mark not found        
                             03H disk write-protected (F)      
                             04H sector not found              
                             05H reset failed (H)              
                             06H floppy disk removed (F)       
                             07H bad parameter table (H)       
                             08H DMA overrun (F)               
                             09H DMA crossed 64 KB boundary    
                             0AH bad sector flag (H)           
                             0BH bad track flag (H)            
                             0CH media type not found (F)      
                             0DH invalid number of sectors on  
                                 format   (H)                  
                             0EH control data address mark     
                                 detected   (H)                
                             0FH DMA arbitration level out of  
                   Function 13H (Disk I/O)                     
                                 range   (H)                   
                             10H uncorrectable CRC* or ECC**   
                                 data error                    
                             11H ECC corrected data error (H)  
                             20H controller failed             
                             40H seek failed                   
                             80H disk timedout                 
                                 (failed to respond)           
                             AAH drive not ready (H)           
                             BBH undefined error (H)           
                             CCH write fault (H)               
                             E0H status register error (H)     
                             FFH sense operation failed (H)    
                                 H=fixed disk only             
                                 F=floppy disk only            
*  Cyclic Redundancy Check code                                
** Error Checking and Correcting code                          
   On fixed disks, error code 11H (ECC  data  error)  indicates
that a recoverable error was detected during a  preceding  Read
Sector (Int 13H Function 02H) function.                        
   9.6.3. Int 13H Function 02H                                 
Description:                                                   
            Read Sector [PC] [AT] [PS/2]                       
   Reads one or more sectors from disk into memory.            
Input                              Output                      
--------------------------------   --------------------------- 
AH=02H                             If function successful      
AL=number of sectors transferred     Carry flag=clear          
AL=number of sectors                 AH=00H                    
CH=cylinder                          AL=number of sectors      
CL=sector                               transferred            
DH=head                            If function unsuccessful    
DL=drive                             Carry flag   =set         
  00H-7FH floppy disk                AH=status                 
  80H-FFH fixed disk                 (see Int 13H Function 01H)
ES:BX=segment:offset of buffer                                 
   On fixed disks, the upper 2  bits  of  the  10-bit  cylinder
number are placed in the upper 2 bits of register CL.          
   On fixed disks, error code 11H indicates that a  read  error
occurred that was corrected  by  the  ECC  algorithm;  in  this
event, register AL contains the burst length. The data returned
is probably good, although there is a  small  chance  that  the
data was not corrected properly. If a multisector transfer  was
requested,  the  operation  was  terminated  after  the  sector
containing the read error.                                     
   On floppy disk drives, an error may result  from  the  drive
motor being off at the time of the request. The ROM  BIOS  does
not automatically wait for the drive to come up to speed before
attempting the read operation. The  requesting  program  should
reset the floppy disk system (Int 13H Function 00H)  and  retry
the operation  three  times  before  assuming  that  the  error
results from some other cause.                                 
                   Function 13H (Disk I/O)                     
                                                               
                                                               
   9.6.4. Int 13H Function 03H                                 
                                                               
                                                               
Description:                                                   
            Write Sector [PC] [AT] [PS/2]                      
                                                               
                                                               
   Writes one or more sectors from memory to disk.             
                                                               
Input                            Output                        
------------------------------   ----------------------------- 
AH=03H                           If function successful        
AL=number of sectors               Carry flag=clear            
CH=cylinder                        AH=00H                      
CL=sector                          AL=number of sectors        
DH=head                               transferred              
DL=drive                                                       
  00H-7FH floppy disk            If function unsuccessful      
  80H-FFH fixed disk               Carry flag=set              
ES:BX=segment:offset of buffer     AH=status                   
                                   (see Int 13H Function 01H)  
                                                               
   On fixed disks, the upper 2  bits  of  the  10-bit  cylinder
number are placed in the upper 2 bits of register CL.          
   On floppy disk drives, an error may result  from  the  drive
motor being off at the time of the request. The ROM  BIOS  does
not automatically wait for the drive to come up to speed before
attempting the write operation. The requesting  program  should
reset the floppy disk system (Int 13H Function 00H)  and  retry
the operation  three  times  before  assuming  that  the  error
results from some other cause.                                 
                                                               
                                                               
                                                               
   9.6.5. Int 13H Function 04H                                 
                                                               
                                                               
Description:                                                   
            Verify Sector [PC] [AT] [PS/2]                     
                                                               
                                                               
   Verifies the address fields of one or more sectors. No  data
is transferred to or from memory by this operation.            
                                                               
Input                            Output                        
------------------------------   ----------------------------- 
AH=04H                           If function successful        
AL=number of sectors               Carry flag=clear            
CH=cylinder                        AH=00H                      
CL=sector                          AL=number of sectors verifie
DH=head                          If function unsuccessful      
DL=drive                           Carry flag=set              
  00H-7FH floppy disk              AH=status                   
  80H-FFH fixed disk               (see Int 13H Function 01H)  
ES:BX=segment:offset of buffer                                 
      (see Notes)                                              
                                                               
   On PCs, PC/XTs, and PC/ATs with ROM BIOS dated earlier  than
11/15/85, ES:BX should point to a valid buffer.                
   On fixed disks, the upper 2  bits  of  the  10-bit  cylinder
number are placed in the upper 2 bits of register CL.          
   This function can be used to test whether a  readable  media
                                                               
                   Function 13H (Disk I/O)                     
is in a floppy disk drive. An error may result from  the  drive
motor being off at the time of the  request,  because  the  ROM
BIOS does not automatically wait for the drive to  come  up  to
speed before attempting the verify  operation.  The  requesting
program should reset the floppy disk system (Int  13H  Function
00H) and retry the operation three times before assuming that a
readable floppy disk is not present.                           
   9.6.6. Int 13H Function 05H                                 
Description:                                                   
            Format Track [P] [AT] [PS/2]                       
   Initializes disk sector and  track  address  fields  on  the
specified track.                                               
Input                             Output                       
-------------------------------   ---------------------------- 
AH=05H                            If function successful       
AL=interleave                       Carry flag=clear           
  (PC/XT fixed disks)               AH=00H                     
CH=cylinder                                                    
DH=head                           If function unsuccessful     
DL=drive                            Carry flag=set             
   00H-7FH floppy disk              AH=status                  
   80H-FFH fixed disk               (see Int 13H Function 01H) 
ES:BX=segment:offset of address                                
     field list (except PC/XT)                                 
     fixed disk, see Notes)                                    
   On floppy disks, the address field list consists of a series
of 4-byte entries, one  entry  per  sector,  in  the  following
format:                                                        
Byte     Contents                                              
----     --------------------------------------                
0        cylinder                                              
1        head                                                  
2        sector                                                
3        sector-size code                                      
             00H if 128 bytes per sector                       
             01H if 256 bytes per sector                       
             02H if 512 bytes per sector (standard)            
             03H if 1024 bytes per sector                      
   On floppy disks, the number of sectors per  track  is  taken
from the BIOS floppy disk  parameter  table  whose  address  is
stored in the vector for Int 1EH.                              
   When this function is used for floppy disks on the PC/AT  or
PS/2, it should be preceded by a call to Int 13H  Function  17H
to select the type of medium to be formatted.                  
   On fixed disks, the upper 2  bits  of  the  10-bit  cylinder
number are placed in the upper 2 bits of register CL.          
   On PC/XT-286, PC/AT, and PS/2 fixed disks, ES:BX points to a
512-byte buffer containing byte pairs for  each  physical  disk
sector as follows:                                             
                   Function 13H (Disk I/O)                     
                                                               
                                                               
                                                               
    Byte        Contents                                       
    ---         -------------------                            
    0           00H for good sector                            
                80H for bad sector                             
    1           sector number                                  
   For example, to format  a  track  with  17  sectors  and  an
interleave of two, ES:BX would point to the  following  34-byte
array at the beginning of a 512-byte buffer:                   
                                                               
        db   00h,01h,00h,0ah,00h,02h,00h,0bh,00h,03h,00h,0ch   
        db   00h,04h,00h,0dh,00h,05h,00h,0eh,00h,06h,00h,0fh   
        db   00h,07h,00h,10h,00h,08h,00h,11h,00h,09h           
                                                               
                                                               
                                                               
   9.6.7. Int 13H Function 06H                                 
                                                               
                                                               
Description:                                                   
            Format Bad Track [PC]                              
                                                               
                                                               
   Initializes a track, writing disk address  fields  and  data
sectors and setting bad sector flags.                          
                                                               
Input                    Output                                
----------------------   ------------------------------------  
AH=06H                   If function successful                
AL=interleave              Carry flag=clear                    
CH=cylinder                AH=00H                              
DH=head                  If function unsuccessful              
DL=drive                   Carry flag=set                      
  80H-FFH  fixed disk      AH=status (see Int 13H Function 01H)
                                                               
   This function is defined for PC/XT fixed disk drives only.  
   For additional information, see Notes for Int  13H  Function
05H.                                                           
                                                               
                                                               
                                                               
   9.6.8. Int 13H Function 07H                                 
                                                               
                                                               
Description:                                                   
            Format Drive [PC]                                  
                                                               
                                                               
   Formats the entire drive, writing disk  address  fields  and
data sectors, starting at the specified cylinder.              
                                                               
  Input                             Output                     
  ----------------------            -------------------------- 
  AH=07H                            If function successful     
  AL=interleave                     Carry flag=clear           
  CH=cylinder                       AH=00H                     
  DL=drive                          If function unsuccessful   
     80H-FFH  fixed disk            Carry flag=set             
                                    AH=status (see Int 13H     
                                               Function 01H)   
                                                               
   This function is defined for PC/XT fixed disk drives only.  
                   Function 13H (Disk I/O)                     
   For additional information, see Notes for Int  13H  Function
05H.                                                           
   9.6.9. Int 13H Function 08H                                 
Description:                                                   
            Get Drive Parameters [PC] [AT] [PS/2]              
   Returns various parameters for the specified drive.         
Input                    Output                                
----------------------   ------------------------------------- 
AH=08H                   If function successful                
DL=drive                   Carry flag=clear                    
  00H-7FH floppy disk      BL=drive type                       
  80H-FFH fixed disk         (PC/AT and PS/2 floppy disks)     
                             01H if 360 KB, 40 track, 5.25"    
                             02H if 1.2 MB, 80 track, 5.25"    
                             03H if 720 KB, 80 track, 3.5"     
                             04H if 1.44 MB, 80 track, 3.5"    
                           CH=low 8 bits of maximum            
                              cylinder number                  
                           CL=bits 6-7 high-order 2 bits of    
                                       maximum cylinder number 
                              bits 0-5 maximum sector number   
                           DH=maximum head number              
                           DL=number of drives                 
                           ES:DI=segment:offset of disk drive  
                                         parameter table       
                         If function unsuccessful              
                           Carry flag=set                      
                           AH=status (see Int 13H Function 01H)
   On the PC and PC/XT, this function  is  supported  on  fixed
disks only.                                                    
   The value returned in register DL reflects the  true  number
of physical drives attached to the adapter  for  the  requested
drive.                                                         
   9.6.10. Int 13H Function 09H                                
Description:                                                   
            Initialize Fixed  Disk  Characteristics  [PC]  [AT]
            [PS/2]                                             
   Initializes the fixed disk  controller  for  subsequent  I/O
operations, using  the  values  found  in  the  ROM  BIOS  disk
parameter block(s).                                            
                   Function 13H (Disk I/O)                     
                                                               
                                                               
                                                               
Input                                 Output                   
------------------------------------  -------------------------
AH=09H                                If function successful   
DL=drive                                Carry flag=clear       
   80H-FFH fixed disk                   AH=00H                 
and, on the PC/XT                     If function unsuccessful 
Vector for Int 41H must point           Carry flag=set         
 to disk parameter block                AH=status              
 or, on the PC/AT and PS/2            (see Int 13H Function 01H
Vector for Int 41H must point                                  
 to disk parameter block for drive 0                           
Vector for Int 46H must point                                  
 to disk parameter block for drive 1                           
                                                               
   This function is supported on fixed disks only.             
   For PC and PC/XT fixed disks, the parameter block format  is
as follows:                                                    
                                                               
    Byte(s)      Contents                                      
    -------      ---------------------------------------       
    00H-01H      maximum number of cylinders                   
    02H          maximum number of heads                       
    03H-04H      starting reduced write current cylinder       
    05H-06H      starting write precompensation cylinder       
    07H          maximum ECC burst length                      
    08H          drive options                                 
                 bit 7=1 if disable disk-access retries        
                 bit 6=1 if disable ECC retries                
                 bits 3-5=0                                    
                 bits 0-2=drive option                         
    09H          standard time-out value                       
    0AH          time-out value for format drive               
    0BH          time-out value for check drive                
    0CH-0FH      reserved                                      
                                                               
   For PC/AT and PS/2 fixed disks, the parameter  block  format
is as follows:                                                 
                                                               
    Byte(s)      Contents                                      
    -------      --------------------------------------------- 
    00H-01H      maximum number of cylinders                   
    02H          maximum number of heads                       
    03H-04H      reserved                                      
    05H-06H      starting write precompensation cylinder       
    07H          maximum ECC burst length                      
    08H          drive options                                 
                 bits 6-7=nonzero (10, 01, or 11) if retries di
                 bit 5=1 if manufacturer's defect map present  
                         at maximum cylinder + 1               
                 bit 4=not used                                
                 bit 3=1 if more than 8 heads                  
                 bits 0-2=not used                             
    09H-0BH      reserved                                      
    0CH-0DH      landing zone cylinder                         
    0EH          sectors per track                             
    0FH          reserved                                      
                                                               
                                                               
                                                               
                                                               
                   Function 13H (Disk I/O)                     
   9.6.11. Int 13H Function 0AH                                
Description:                                                   
            Read Sector Long [PC] [AT] [PS/2]                  
   Reads a sector or sectors from disk into memory, along  with
a 4-byte ECC code for each sector.                             
Input                         Output                           
---------------------------   -----------------------------    
AH=0AH                        If function successful           
AL=number of sectors            Carry flag  =clear             
CH=cylinder                     AH=00H                         
CL=sector (see Notes)           AL=number of sectors transferre
DH=head                       If function unsuccessful         
DL=drive                        Carry flag=set                 
  80H-FFH fixed disk            AH=status                      
ES:BX=segment:offset of buffer     (see Int 13H Function 01H)  
   This function is supported on fixed disks only.             
   The upper 2 bits of the 10-bit cylinder number are placed in
the upper 2 bits of register CL.                               
   Unlike the normal Read Sector  function  (Int  13H  Function
02H), ECC errors are not automatically  corrected.  Multisector
transfers are terminated after any sector with a read error.   
   9.6.12. Int 13H Function 0BH                                
Description:                                                   
            Write Sector Long [PC] [AT] [PS/2]                 
   Writes a  sector  or  sectors  from  memory  to  disk.  Each
sector's worth of data must be followed by its 4-byte ECC code.
Input                         Output                           
----------------------------  ------------------------------   
AH=0BH                        If function successful           
AL=number of sectors            Carry flag=clear               
CH=cylinder                     AH=00H                         
CL=sector (see Notes)           AL=number of sectors transferre
DH=head                       If function unsuccessful         
DL=drive                        Carry flag=set                 
  80H-FFH fixed disk            AH=status                      
ES:BX=segment:offset of buffer     (see Int 13H Function 01H)  
   This function is supported on fixed disks only.             
   The upper 2 bits of the 10-bit cylinder number are placed in
the upper 2 bits of register CL.                               
                   Function 13H (Disk I/O)                     
                                                               
                                                               
   9.6.13. Int 13H Function 0CH                                
                                                               
                                                               
Description:                                                   
            Seek [PC] [AT] [PS/2]                              
                                                               
                                                               
   Positions  the  disk  read/write  heads  to  the   specified
cylinder, but does not transfer any data.                      
                                                               
Input                         Output                           
---------------------------   -------------------------------- 
AH=0CH                        If function successful           
CH=lower 8 bits of cylinder     Carry flag=clear               
CL=upper 2 bits of cylinder     AH=00H                         
   in bits 6-7                If function unsuccessful         
DH=head                         Carry flag=set                 
DL=drive                        AH=status (see Int 13H         
   80H-FFH fixed disk                      Function 01H)       
                                                               
   This function is supported on fixed disks only.             
   The upper 2 bits of the 10-bit cylinder number are placed in
the upper 2 bits of register CL.                               
   The Read Sector, Read Sector Long, Write Sector,  and  Write
Sector Long functions include an  implied  seek  operation  and
need not be preceded by an explicit call to this function.     
                                                               
                                                               
                                                               
   9.6.14. Int 13H Function 0DH                                
                                                               
                                                               
Description:                                                   
            Reset Fixed Disk System [PC] [AT] [PS/2]           
                                                               
                                                               
   Resets the  fixed  disk  controller,  recalibrates  attached
drives (moves the read/write arm to cylinder 0),  and  prepares
for subsequent disk I/O.                                       
                                                               
Input                   Output                                 
---------------------   ------------------------------------   
AH=0DH                  If function successful                 
DL=drive                  Carry flag=clear                     
  80H-FFH fixed disk      AH=00H                               
                        If function unsuccessful               
                          Carry flag=set                       
                          AH=status (see Int 13H Function 01H) 
                                                               
   This function is supported on fixed disks only.  It  differs
from Int 13H Function 00H in that the floppy disk controller is
not reset.                                                     
                                                               
                                                               
                                                               
   9.6.15. Int 13H Function 0EH                                
                                                               
                                                               
Description:                                                   
            Read Sector Buffer [PC]                            
                                                               
                                                               
                   Function 13H (Disk I/O)                     
   Transfers the contents of the fixed disk adapter's  internal
sector buffer to system  memory.  No  data  is  read  from  the
physical disk drive.                                           
Input                           Output                         
------------------------------  --------------------------     
AH=0EH                          If function successful         
ES:BX=segment:offset of buffer    Carry flag=clear             
                                If function unsuccessful       
                                  Carry flag=set               
                                  AH=status                    
                                 (see Int 13H Function 01H)    
   This function is supported by the PC/XT's fixed disk adapter
only. It is not defined for fixed disk adapters on the PC/AT or
PS/2.                                                          
   9.6.16. Int 13H Function 0FH                                
Description:                                                   
            Write Sector Buffer [PC]                           
   Transfers  data  from  system  memory  to  the  fixed   disk
adapter's internal sector buffer. No data  is  written  to  the
physical disk drive.                                           
Input                            Output                        
------------------------------   --------------------------    
AH=0FH                           If function successful        
ES:BX=segment:offset of buffer     Carry flag=clear            
                                 If function unsuccessful      
                                   Carry flag=set              
                                   AH=status                   
                                   (see Int 13H Function 01H)  
   This function is supported by the PC/XT's fixed disk adapter
only. It is not defined for fixed disk adapters on the PC/AT or
PS/2.                                                          
   This function should be called to initialize the contents of
the sector buffer before formatting  the  drive  with  Int  13H
Function 05H.                                                  
   9.6.17. Int 13H Function 10H                                
Description:                                                   
            Get Drive Status [PC] [AT] [PS/2]                  
   Tests whether the specified fixed disk drive is  operational
and returns the drive's status.                                
                   Function 13H (Disk I/O)                     
                                                               
                                                               
                                                               
Input                   Output                                 
---------------------   ------------------------------------   
AH=10H                  If function successful                 
DL=drive                  Carry flag=clear                     
  80H-FFH fixed disk      AH=00H                               
                        If function unsuccessful               
                          Carry flag=set                       
                          AH=status (see Int 13H Function 01H) 
                                                               
   This function is supported on fixed disks only.             
                                                               
                                                               
                                                               
   9.6.18. Int 13H Function 11H                                
                                                               
                                                               
Description:                                                   
            Recalibrate Drive [PC] [AT] [PS/2]                 
                                                               
                                                               
   Causes the fixed disk adapter to recalibrate itself for  the
specified drive, positioning the read/arm to  cylinder  0,  and
returns the drive's status.                                    
                                                               
Input                  Output                                  
---------------------  ------------------------------------    
AH=11H                 If function successful                  
DL=drive                 Carry flag=clear                      
  80H-FFH fixed disk     AH=00H                                
                       If function unsuccessful                
                         Carry flag=set                        
                         AH=status (see Int 13H Function 01H)  
                                                               
   This function is supported on fixed disks only.             
                                                               
                                                               
                                                               
   9.6.19. Int 13H Function 12H                                
                                                               
                                                               
Description:                                                   
            Controller RAM Diagnostic [PC]                     
                                                               
                                                               
   Causes the fixed  disk  adapter  to  carry  out  a  built-in
diagnostic test  on  its  internal  sector  buffer,  indicating
whether the test was passed by the returned status.            
                                                               
Input             Output                                       
------            ------------------------------------         
AH=12H            If function successful                       
                    Carry flag=clear                           
                  If function unsuccessful                     
                    Carry flag=set                             
                    AH=status (see Int 13H Function 01H)       
                                                               
   This function is supported on PC/XT fixed disks only.       
                                                               
                                                               
                                                               
                   Function 13H (Disk I/O)                     
   9.6.20. Int 13H Function 13H                                
Description:                                                   
            Controller Drive Diagnostic [PC]                   
   Causes the fixed disk adapter  to  run  internal  diagnostic
tests of the attached drive, indicating whether  the  test  was
passed by the returned status.                                 
  Input             Output                                     
  ------            ------------------------------------       
  AH=13H            If function successful                     
                    Carry flag=clear                           
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status (see Int 13H Function 01H)       
   This function is supported on PC/XT fixed disks only.       
   9.6.21. Int 13H Function 14H                                
Description:                                                   
            Controller Internal Diagnostic [PC] [AT] [PS/2]    
   Causes the fixed  disk  adapter  to  carry  out  a  built-in
diagnostic self-test, indicating whether the test was passed by
the returned status.                                           
  Input             Output                                     
  ------            ------------------------------------       
  AH=14H            If function successful                     
                    Carry flag=clear                           
                    AH=00H                                     
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status (see Int 13H Function 01H)       
   This function is supported on fixed disks only.             
   9.6.22. Int 13H Function 15H                                
Description:                                                   
            Get Disk Type [AT] [PS/2]                          
   Returns a code indicating the type of floppy or  fixed  disk
referenced by the specified drive code.                        
                   Function 13H (Disk I/O)                     
                                                               
                                                               
                                                               
Input                   Output                                 
----------------------  ------------------------------------   
AH=15H                  If function successful                 
DL=drive                  Carry flag=clear                     
  00H-7FH floppy disk     AH=drive type code                   
  80H-FFH fixed disk        00H if no drive present            
                            01H if floppy disk drive           
                                without change-line support    
                            02H if floppy disk drive           
                                with change-line support       
                            03H if fixed disk                  
                                and, if fixed disk (AH=03H)    
                          CX:DX=number of 512-byte sectors     
                        If function unsuccessful               
                          Carry flag=set                       
                          AH=status (see Int 13H Function 01H) 
                                                               
   This function is not supported on the PC or PC/XT.          
                                                               
                                                               
                                                               
   9.6.23. Int 13H Function 16H                                
                                                               
                                                               
Description:                                                   
            Get Disk Change Status [AT] [PS/2]                 
                                                               
                                                               
   Returns the status of the change  line,  indicating  whether
the disk in the drive may have been  replaced  since  the  last
disk access.                                                   
                                                               
Input                    Output                                
----------------------   ------------------------------        
AH=16H                   If change line inactive               
DL=drive                    (disk has not been changed)        
  00H-7FH floppy disk      Carry flag=clear                    
                           AH=00H                              
                         If change line active                 
                            (disk may have been changed)       
                           Carry flag=set                      
                           AH=06H                              
                                                               
   If this function returns with the carry flag set,  the  disk
has not necessarily  been  changed;  the  change  line  can  be
activated by simply unlocking and locking the disk  drive  door
without removing the floppy disk.                              
   This function is not supported for floppy disks on the PC or
PC/XT.                                                         
                                                               
                                                               
                                                               
   9.6.24. Int 13H Function 17H                                
                                                               
                                                               
Description:                                                   
            Set Disk Type [AT] [PS/2]                          
                                                               
                                                               
   Selects a floppy disk type for the specified drive.         
                   Function 13H (Disk I/O)                     
Input                           Output                         
-----------------------------   ----------------------------   
AH=17H                          If function successful         
AL=floppy disk type code          Carry flag=clear             
  00H not used                    AH=00H                       
  01H 320/360 KB floppy disk    If function unsuccessful       
      in 360 KB drive             Carry flag=set               
  02H 320/360 KB floppy disk      AH=status                    
      in 1.2 MB drive             (see Int 13H Function 01H)   
  03H 1.2 MB floppy disk                                       
      in 1.2 MB drive                                          
  04H 720 KB floppy disk                                       
      in 720 KB drive                                          
DL=drive                                                       
   00H-7FH floppy disk                                         
   This function is not supported for floppy disks on the PC or
PC/XT.                                                         
   If the change line is active for the specified drive, it  is
reset. The ROM BIOS then sets the data rate for  the  specified
drive and media type.                                          
   9.6.25. Int 13H Function 18H                                
Description:                                                   
            Set Media Type for Format [AT] [PS/2]              
   Selects media characteristics for the specified drive.      
Input                   Output                                 
----------------------  -------------------------------------  
AH=18H                  If function successful                 
CH=number of cylinders    Carry flag=clear                     
CL=sectors per track      AH=00H                               
DL=drive                  ES:DI=segment:offset of disk         
  00H-7FH floppy disk           parameter table for media type 
                        If function unsuccessful               
                          Carry flag=set                       
                          AH=status (see Int 13H Function 01H) 
   A floppy disk must be present in the drive.                 
   This function should be called prior to  formatting  a  disk
with Int 13H Function 05H so that the  ROM  BIOS  can  set  the
correct data rate for the media.                               
   If the change line is active for the specified drive, it  is
reset.                                                         
   9.6.26. Int 13H Function 19H                                
Description:                                                   
            Park Heads [PS/2]                                  
   Moves the read/write arm to a track that  is  not  used  for
                   Function 13H (Disk I/O)                     
                                                               
                                                               
data storage, so that data will not be damaged when  the  drive
is turned off.                                                 
                                                               
  Input                            Output                      
  ---------------------            --------------------------- 
  AH=19H                           If function successful      
  DL=drive                         Carry flag =clear           
     80H-FFH fixed disk            If function unsuccessful    
                                   Carry flag=set              
                                   AH=status (see Int 13H      
                                      Function 01H)            
                                                               
   This function is defined for PS/2 fixed disks only.         
                                                               
                                                               
                                                               
   9.6.27. Int 13H Function 1AH                                
                                                               
                                                               
Description:                                                   
            Format ESDI Drive [PS/2]                           
                                                               
                                                               
   Initializes disk sector and track address fields on a  drive
attached to the ESDI Fixed Disk Drive Adapter/A.               
                                                               
Input                                  Output                  
------------------------------------   ----------------------- 
AH=1AH                                 If function successful  
AL=relative block address                Carry flag=clear      
   (RBA) defect table count              AH=00H                
  0 if no RBA table                    If function unsuccessful
 >0 if RBA table used                    Carry flag=set        
CL=format modifier bits                  AH=status             
     Bit(s)     Significance (if set)    (see Int 13H          
     ------     ----------------------        Function 01H)    
     0          ignore primary                                 
                defect map                                     
     1          ignore secondary                               
                defect map                                     
     2          update secondary                               
                defect map (see Notes)                         
     3          perform extended                               
                surface analysis                               
     4          generate periodic                              
                interrupt (see Notes)                          
     5-7        reserved (must be 0)                           
  DL=drive                                                     
     80H-FFH fixed disk                                        
  ES:BX=segment:offset of RBA table                            
                                                               
   This operation is sometimes called a "low level format"  and
prepares the disk for physical  read/write  operations  at  the
sector level. The drive must be subsequently  partitioned  with
the FDISK command and then given a "high level format" with the
FORMAT command to install a file system.                       
   If bit 4 of register CL is  set,  Int  15H  is  called  with
AH=0FH and AL=phase code after each cylinder  is  formatted  or
analyzed. The phase code is defined as:                        
                                                               
                                                               
                                                               
                                                               
                   Function 13H (Disk I/O)                     
      0=reserved                                               
      1=surface analysis                                       
      2=formatting                                             
   See also Int 15H Function 0FH.                              
   If bit 2 of register CL is set, the drive's secondary defect
map is updated to reflect errors found during surface analysis.
If both bit 2 and bit 1 are set, the secondary  defect  map  is
replaced.                                                      
   For an extended surface analysis, the disk should  first  be
formatted by calling this function with bit 3 cleared and  then
analyzed by calling this function with bit 3 set.              
   9.7. Interrupt 14H (COM Port)                               
Interrupt  Function   Name                                     
14H        00H        Initialize Communications Port           
14H        01H        Write Character to Communications Port   
14H        02H        Read Character from Communications Port  
14H        03H        Get Communications Port Status           
14H        04H        Extended Initialize Communications Port  
14H        05H        Extended Communications Port Control     
   9.7.1. Int 14H Function 00H                                 
Description:                                                   
            Initialize Communications Port [PC] [AT] [PS/2]    
   Initializes a serial communications port to a  desired  baud
rate, parity, word length, and number of stop bits.            
                   Interrupt 14H (COM Port)                    
                                                               
                                                               
                                                               
Input                          Output                          
-----------------------------  ------------------------------- 
AH=00H                         AH=port status                  
AL=initialization parameter     Bit(s)  Significance (if set)  
   (see Notes)                  ------  ---------------------- 
DX=communications port number   7       timed-out              
  (0=COM1, 1=COM2,   etc.)      6       transmit shift         
                                        register empty         
                                5       transmit holding       
                                        register empty         
                                4       break detected         
                                3       framing error detected 
                                2       parity error detected  
                                1       overrun error detected 
                                0       receive data ready     
                               AL=modem status                 
                                Bit(s)  Significance (if set)  
                                ------  ---------------------- 
                                7       receive line signal    
                                        detect                 
                                6       ring indicator         
                                5       data-set-ready         
                                4       clear-to-send          
                                3       change in receive line 
                                        signal detect          
                                2       trailing edge ring     
                                        indicator              
                                1       change in              
                                        data-set-ready status  
                                0       change in              
                                        clear-to-send status   
                                                               
   The initialization parameter byte is defined as follows:    
                                                               
7 6 5         4 3          2              1 0                  
Baud Rate     Parity       Stop Bits      Word Length          
---------     -------      ---------      -----------          
000=110       X0=none      0=1 bit        10=7 bits            
001=150       01=odd       1=2 bits       11=8 bits            
010=300       11=even                                          
011=600                                                        
100=1200                                                       
101=2400                                                       
110=4800                                                       
111=9600                                                       
                                                               
   To initialize the serial port for data  rates  greater  than
9600 baud on PS/2 machines, see Int 14H Functions 04H and  05H.
                                                               
                                                               
                                                               
   9.7.2. Int 14H Function 01H                                 
                                                               
                                                               
Description:                                                   
            Write Character to Communications  Port  [PC]  [AT]
            [PS/2]                                             
                                                               
                                                               
   Writes a character to the  specified  serial  communications
port, returning the current status of the port.                
                   Interrupt 14H (COM Port)                    
Input                          Output                          
-----------------------------  ----------------------------    
AH=01H                         If function successful          
AL=character                     AH bit 7=0                    
DX=communications port number    AH bits 0-6=port status       
  (0=COM1, 1=COM2,   etc.)        Bit(s)  Significance (if set)
                                     ------  ------------------
                                     6       transmit shift    
                                             register empty    
                                     5       transmit holding  
                                             register empty    
                                     4       break detected    
                                     3       framing error     
                                             detected          
                                     2       parity error detec
                                     1       overrun error     
                                             detected          
                                     0       receive data ready
                                 AL=character (unchanged)      
                               If function unsuccessful (timed-
                                 AH bit 7=1                    
                                 AL=character (unchanged)      
   9.7.3. Int 14H Function 02H                                 
Description:                                                   
            Read Character from Communications Port  [PC]  [AT]
            [PS/2]                                             
   Reads a character from the specified  serial  communications
port, also returning the port's status.                        
Input                          Output                          
-----------------------------  ----------------------------    
AH=02H                         If function successful          
DX=communications port number    AH bit 7=0                    
   (0=COM1, 1=COM2,   etc.)      AH bits 0-6=status            
                                     Bit(s)  Significance (if s
                                     ------  ------------------
                                     4       break detected    
                                     3       framing error dete
                                     2       parity error detec
                                     1       overrun error dete
                                 AL=character                  
                               If function unsuccessful (timed-
                                 AH bit 7=1                    
   9.7.4. Int 14H Function 03H                                 
Description:                                                   
            Get Communications Port Status [PC] [AT] [PS/2]    
                   Interrupt 14H (COM Port)                    
                                                               
                                                               
   Returns the status of the  specified  serial  communications
port.                                                          
                                                               
Input               Output                                     
-----------------   ------------------------------------------ 
AH=03H              AH=port status (see Int 14H Function 00H)  
DX=communications   AL=modem status (see Int 14H Function 00H) 
   port number                                                 
(0=COM1,1=COM2,etc.)                                           
                                                               
                                                               
                                                               
                                                               
   9.7.5. Int 14H Function 04H                                 
                                                               
                                                               
Description:                                                   
            Extended Initialize Communications Port [PS/2]     
                                                               
                                                               
   Initializes a serial communications port to a  desired  baud
rate, parity, word length, and number of stop bits. Provides  a
superset  of  Int  14H  Function  00H  capabilities  for   PS/2
machines.                                                      
                                                               
Input                          Output                          
---------------------------    -----------------------------   
AH=04H                         AH=port status                  
AL=break flag                     (see Int 14H Function 00H)   
  00H no break                 AL=modem status                 
  01H break                       (see Int 14H Function 00H)   
BH=parity                                                      
     00H none                                                  
     01H odd                                                   
     02H even                                                  
     03H stick parity odd                                      
     04H stick parity even                                     
BL=stop bits                                                   
     00H 1 stop bit                                            
     01H 2 stop bits if                                        
         word length=6-8 bits                                  
     01H 1.5 stop bits if                                      
         word length=5 bits                                    
CH=word length                                                 
     00H 5 bits                                                
     01H 6 bits                                                
     02H 7 bits                                                
     03H 8 bits                                                
CL=baud rate                                                   
     00H 110 baud                                              
     01H 150 baud                                              
     02H 300 baud                                              
     03H 600 baud                                              
     04H 1200 baud                                             
     05H 2400 baud                                             
     06H 4800 baud                                             
     07H 9600 baud                                             
     08H 19,200 baud                                           
DX=communications port number                                  
     (0=COM1, 1=COM2,   etc.)                                  
                                                               
                                                               
                   Interrupt 14H (COM Port)                    
   9.7.6. Int 14H Function 05H                                 
Description:                                                   
            Extended Communications Port Control [PS/2]        
   Reads or sets the  modem  control  register  (MCR)  for  the
specified serial communications port.                          
Input                              Output                      
---------------------------------  --------------------------- 
AH=05H                             If called with AL=00H       
AL=subfunction                       BL=modem control register 
     00H to read modem                  contents (see above)   
         control register          If called with AL=01H       
     01H to write modem              AH=port status            
         control register            (see Int 14H Function 00H)
BL=modem control register            AL=modem status           
    contents (if AL=01H)             (see Int 14H Function 00H)
     Bit(s)     Significance                                   
     ------     -------------------                            
     0          data-terminal ready                            
     1          request-to-send                                
     2          Out1                                           
     3          Out2                                           
     4          loop (for testing)                             
     5-7        reserved                                       
  DX=communications port number                                
     (0=COM1, 1=COM2, etc.)                                    
   9.8. Interrupt 15H (I/O Subsystem)                          
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Interrupt  Fnct  Subfnct  Name                                 
15H        00H            Turn On Cassette Motor               
15H        01H            Turn Off Cassette Motor              
15H        02H            Read Cassette                        
15H        03H            Write Cassette                       
15H        0FH            Format ESDI Drive Periodic Interrupt 
15H        21H   00H      Read POST Error Log                  
15H        21H   01H      Write POST Error Log                 
15H        4FH            Keyboard Intercept                   
15H        80H            Device Open                          
15H        81H            Device Close                         
15H        82H            Process Termination                  
15H        83H            Event Wait                           
15H        84H            Read Joystick                        
15H        85H            SysReq Key                           
15H        86H            Delay                                
15H        87H            Move Extended Memory Block           
15H        88H            Get Extended Memory Size             
15H        89H            Enter Protected Mode                 
15H        90H            Device Wait                          
15H        91H            Device Post                          
15H        C0H            Get System Environment               
15H        C1H            Get Address of Extended BIOS Data Are
15H        C2H            Mouse Pointer (summary)              
15H        C3H            Set Watchdog Time-Out                
15H        C4H            Programmable Option Select           
                                                               
                                                               
   9.8.1. Int 15H Function 00H                                 
                                                               
                                                               
Description:                                                   
            Turn On Cassette Motor [PC]                        
                                                               
                                                               
   Turns on the motor of the cassette tape drive.              
                                                               
  Input             Output                                     
  ------            ------------------------------             
  AH=00H            If function successful                     
                    Carry flag=clear                           
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status                                  
                       86H if cassette not present             
                                                               
   This function is available only on the PC and the  PCjr.  It
is not supported on the PC/XT and all subsequent models.       
                                                               
                                                               
                                                               
   9.8.2. Int 15H Function 01H                                 
                                                               
                                                               
Description:                                                   
            Turn Off Cassette Motor [PC]                       
                                                               
                                                               
   Turns off the motor of the cassette tape drive.             
                Interrupt 15H (I/O Subsystem)                  
  Input             Output                                     
  ------            ------------------------------             
  AH=01H            If function successful                     
                    Carry flag=clear                           
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status                                  
                       86H if cassette not present             
   This function is available only on the PC and the  PCjr.  It
is not supported on the PC/XT and all subsequent models.       
   9.8.3. Int 15H Function 02H                                 
Description:                                                   
            Read Cassette [PC]                                 
   Reads one or more 256-byte blocks of data from the  cassette
tape drive to memory.                                          
Input                            Output                        
------------------------------   ----------------------------- 
AH=02H                           If function successful        
CX=number of bytes to read         Carry flag=clear            
ES:BX=segment:offset of buffer     DX=number of bytes          
                                      actually read            
                                   ES:BX=segment:offset + 1 of 
                                         last byte read        
                                 If function unsuccessful      
                                   Carry flag=set              
                                   AH=status                   
                                   01H if CRC error            
                                   02H if bit signals scrambled
                                   04H if no data found        
                                   80H if invalid command      
                                   86H if cassette not present 
   This function is available only on the PC and the  PCjr.  It
is not supported on the PC/XT and all subsequent models.       
   9.8.4. Int 15H Function 03H                                 
Description:                                                   
            Write Cassette [PC]                                
   Writes one or more 256-byte blocks of data  from  memory  to
the cassette tape drive.                                       
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Input                            Output                        
------------------------------   ------------------------------
AH=03H                           If function successful        
CX=number of bytes to write        Carry flag=clear            
ES:BX=segment:offset of buffer     CX=00H                      
                                   ES:BX=segment:offset + 1 of 
                                         last byte written     
                                 If function unsuccessful      
                                   Carry flag=set              
                                   AH=status                   
                                    80H if invalid command     
                                    86H if cassette not present
                                                               
                                                               
                                                               
                                                               
   9.8.5. Int 15H Function 0FH                                 
                                                               
                                                               
Description:                                                   
            Format ESDI Drive Periodic Interrupt [PS/2]        
                                                               
                                                               
   Invoked by the  ROM  BIOS  on  the  ESDI  Fixed  Disk  Drive
Adapter/A during a format or surface analysis  operation  after
each cylinder is completed.                                    
                                                               
Input                   Output                                 
---------------------   ---------------------------------------
AH=0FH                  If formatting or analysis should contin
AL=phase code             Carry flag=clear                     
  0=reserved            If formatting or analysis should       
  1=surface analysis       be terminated                       
  2=formatting            Carry flag=set                       
                                                               
   This function call can be captured by a program so  that  it
will be notified as each cylinder is formatted or analyzed. The
program can count interrupts for each phase  to  determine  the
current cylinder number.                                       
   The ROM BIOS default handler for this function returns  with
the carry flag set.                                            
                                                               
                                                               
                                                               
   9.8.6. Int 15H Function 21H Subfunction 00H                 
                                                               
                                                               
Description:                                                   
            Read POST Error Log [PS/2]                         
                                                               
                                                               
   Returns error information that was  accumulated  during  the
most recent power-on self-test (POST).                         
                                                               
                                                               
                Interrupt 15H (I/O Subsystem)                  
  Input             Output                                     
  ------            --------------------------------------     
  AH=21H            If function successful                     
  AL=00H            Carry flag=clear                           
                    AH=00H                                     
                    BX=number of POST error codes stored       
                    ES:DI=segment:offset of POST error log     
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status                                  
                       80H=invalid command                     
                       86H=function not supported              
   The error log consists of  single-word  entries.  The  first
byte of an entry is the device error code; the  second  is  the
device identifier.                                             
   This function is not available on the PS/2 Models 25 and 30.
   9.8.7. Int 15H Function 21H Subfunction 01H                 
Description:                                                   
            Write POST Error Log [PS/2]                        
   Adds an entry to the power-on self-test (POST) error log.   
Input                  Output                                  
--------------------   -----------------------------           
AH=21H                 If function successful                  
AL=01H                   Carry flag=clear                      
BH=device identifier     AH=00H                                
BL=device error code   If function unsuccessful                
                         Carry flag=set                        
                         AH=status                             
                           01H=error list full                 
                           80H=invalid command                 
                           86H=function not supported          
   This function is not available on the PS/2 Models 25 and 30.
   9.8.8. Int 15H Function 4FH                                 
Description:                                                   
            Keyboard Intercept [PS/2]                          
   Invoked for  each  keystroke  by  the  ROM  BIOS's  Int  09H
keyboard interrupt handler.                                    
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
  Input                   Output                               
  ------------            -----------------------------        
  AH=4FH                  If scan code consumed                
  AL=scan code            Carry flag=clear                     
                          If scan code not consumed            
                          Carry flag=set                       
                          AL=unchanged or new scan code        
                                                               
   An operating system or a resident utility can  capture  this
function to filter  the  raw  keyboard  data  stream.  The  new
handler can substitute a new scan code, return  the  same  scan
code, or return the carry flag clear causing the  keystroke  to
be discarded. The ROM BIOS default routine simply  returns  the
scan code unchanged.                                           
   A program can call Int 15H Function C0H to determine whether
the host machine's ROM BIOS supports this keyboard intercept.  
                                                               
                                                               
                                                               
   9.8.9. Int 15H Function 80H                                 
                                                               
                                                               
Description:                                                   
            Device Open [AT] [PS/2]                            
                                                               
                                                               
   Acquires ownership of a logical device for a process.       
                                                               
  Input                    Output                              
  -------------            ------------------------            
  AH=80H                   If function successful              
  BX=device ID             Carry flag=clear                    
  CX=process ID            AH=00H                              
                           If function unsuccessful            
                           Carry flag=set                      
                           AH=status                           
                                                               
   This function call, along with Int  15H  Functions  81H  and
82H, defines a simple protocol that can be  used  to  arbitrate
usage of devices by multiple processes. A multitasking  program
manager would be expected to capture Int 15H  and  provide  the
appropriate service. The default BIOS routine for this function
simply returns with the carry flag clear and AH=00H.           
                                                               
                                                               
                                                               
   9.8.10. Int 15H Function 81H                                
                                                               
                                                               
Description:                                                   
            Device Close [AT] [PS/2]                           
                                                               
                                                               
   Releases ownership of a logical device for a process.       
                                                               
                                                               
                                                               
                Interrupt 15H (I/O Subsystem)                  
  Input                    Output                              
  -------------            ------------------------            
  AH=81H                   If function successful              
  BX=device ID             Carry flag=clear                    
  CX=process ID            AH=00H                              
                           If function unsuccessful            
                           Carry flag=set                      
                           AH=status                           
   A multitasking program manager would be expected to  capture
Int 15H and provide  the  appropriate  service.  The  ROM  BIOS
default routine for this function simply returns with the carry
flag clear and AH=00H. See also Int 15H Functions 80H and  82H.
   9.8.11. Int 15H Function 82H                                
Description:                                                   
            Process Termination [AT] [PS/2]                    
   Releases ownership of all logical devices for a process that
is about to terminate.                                         
  Input                    Output                              
  -------------            ------------------------            
  AH=82H                   If function successful              
  BX=process ID            Carry flag=clear                    
                           AH=00H                              
                           If function unsuccessful            
                           Carry flag=set                      
                           AH=status                           
   A multitasking program manager would be expected to  capture
Int 15H and provide  the  appropriate  service.  The  ROM  BIOS
default routine for this function simply returns with the carry
flag clear and AH=00H. See also Int 15H Functions 80H and  81H.
   9.8.12. Int 15H Function 83H                                
Description:                                                   
            Event Wait [AT] [PS/2]                             
   Requests setting of a semaphore after a  specified  interval
or cancels a previous request.                                 
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Input                       Output                             
--------------------------  -----------------------------------
If requesting event wait    If called with AL=00H,             
AH=83H                         and function successful         
AL=00H                        Carry flag=clear                 
CX:DX=microseconds          If called with AL=00H, and function
ES:BX=segment:offset of        unsuccessful (Event Wait already
      semaphore byte           active)                         
If canceling event wait       Carry flag=set                   
AH=83H                      If called with AL=01H              
AL=01H                        Nothing                          
                                                               
   The function call returns immediately. If  the  function  is
successful, bit 7  of  the  semaphore  byte  is  set  when  the
specified  interval  has  elapsed.  The  calling   program   is
responsible for clearing the semaphore before  requesting  this
function.                                                      
   The actual duration of an event wait is always  an  integral
multiple  of  976  microseconds.  The  CMOS   date/clock   chip
interrupts are used to implement this function.                
   Use of this function allows programmed, hardware-independent
delays at a finer resolution than can be obtained  through  use
of the MS-DOS Get Time function (Int 21H  Function  2CH,  which
returns time in hundredths of a second).                       
   See also Int 15H Function 86H, which  suspends  the  calling
program for the specified interval in milliseconds.            
   This function is not supported on the PS/2 Models 25 and 30.
                                                               
                                                               
                                                               
   9.8.13. Int 15H Function 84H                                
                                                               
                                                               
Description:                                                   
            Read Joystick [AT] [PS/2]                          
                                                               
                                                               
   Returns  the  joystick  switch  settings  and  potentiometer
values.                                                        
                                                               
Input                            Output                        
-------------------------------  ------------------------------
AH=84H                           If function successful        
DX=subfunction                     Carry flag=clear            
   00H to read switch settings     and, if called with DX=00H  
   01H to read resistive inputs    AL=switch settings (bits 4-7
                                   or, if called with DX=01H   
                                       AX=A(x) value           
                                       BX=A(y) value           
                                       CX=B(x) value           
                                       DX=B( y) value          
                                  If function unsuccessful     
                                    Carry flag=set             
                                                               
   An error condition is returned if  DX  does  not  contain  a
valid subfunction number.                                      
   If no game adapter is installed, AL is returned as  00H  for
Subfunction 00H (i.e., all switches open); AX, BX, CX,  and  DX
are returned containing 00H for Subfunction 01H.               
   Using a 250 KOhm joystick, the potentiometer values  usually
lie within the range 0-416 (0000-01A0H).                       
                Interrupt 15H (I/O Subsystem)                  
   9.8.14. Int 15H Function 85H                                
Description:                                                   
            SysReq Key [AT] [PS/2]                             
   Invoked by the ROM BIOS keyboard driver when the SysReq  key
is detected.                                                   
Input                              Output                      
-------------------------------    ----------------------------
AH=85H                             If function successful      
AL=key status                        Carry flag=clear          
   00H if key make (depression)      AH=00H                    
   01H if key break (release)      If function unsuccessful    
                                     Carry flag=set            
                                     AH=status                 
   The ROM BIOS handler for  this  function  call  is  a  dummy
routine that always returns a success status unless called with
an invalid subfunction number in  AL.  A  multitasking  program
manager would be expected to capture Int 15H so that it can  be
notified when the user strikes the SysReq key.                 
   9.8.15. Int 15H Function 86H                                
Description:                                                   
            Delay [AT] [PS/2]                                  
   Suspends the calling program for  a  specified  interval  in
microseconds.                                                  
Input                         Output                           
--------------------------    --------------------------       
AH=86H                        If function successful           
CX:DX=microseconds to wait       (wait was performed)          
                                Carry flag=clear               
                              If function unsuccessful         
                                 (wait was not performed)      
                                Carry flag=set                 
   The actual duration  of  the  wait  is  always  an  integral
multiple of 976 microseconds.                                  
   Use of this function allows programmed, hardware-independent
delays at a finer resolution than can be obtained  through  use
of the MS-DOS Get Time function (Int 21H  Function  2CH,  which
returns time in hundredths of a second).                       
   See also Int 15H Function 83H, which  triggers  a  semaphore
after a specified interval but does  not  suspend  the  calling
program.                                                       
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
   9.8.16. Int 15H Function 87H                                
                                                               
                                                               
Description:                                                   
            Move Extended Memory Block [AT] [PS/2]             
                                                               
                                                               
   Transfers data  between  conventional  memory  and  extended
memory.                                                        
                                                               
Input                             Output                       
------------------------------    -----------------------------
AH=87H                            If function successful       
CX=number of words to move          Carry flag=clear           
ES:SI=segment:offset of Global      AH=00H                     
      Descriptor Table            If function unsuccessful     
      (see Notes)                   Carry flag=set             
                                    AH=status                  
                                     01H if RAM parity error   
                                     02H if exception interrupt
                                         error                 
                                     03H if gate address line 2
                                         failed                
                                                               
   Conventional memory lies  at  addresses  below  the  640  KB
boundary, and is used for  the  execution  of  MS-DOS  and  its
application programs. Extended memory lies at addresses above 1
MB, and can only be accessed by an 80286 or 80386  CPU  running
in protected mode. As much as 15 MB of extended memory  can  be
installed in a PC/AT or compatible.                            
   The Global Descriptor Table (GDT) used by this function must
be set up as follows:                                          
                                                               
Byte(s)     Contents                                           
-------     -------------------------------------------------  
00H-0FH     reserved (should be 0)                             
10H-11H     segment length in bytes (2 * CX - 1 or greater)    
12H-14H     24-bit source address                              
15H         access rights byte (always 93H)                    
16H-17H     reserved (should be 0)                             
18H-19H     segment length in bytes (2 * CX - 1 or greater)    
1AH-1CH     24-bit destination address                         
1DH         access rights byte (always 93H)                    
1EH-2FH     reserved (should be 0)                             
                                                               
   The table is composed of six 8-byte descriptors to  be  used
by the CPU in protected mode. The four descriptors  in  offsets
00H-0FH and 20H-2FH are filled in by the ROM  BIOS  before  the
CPU mode switch.                                               
   The addresses  used  in  the  descriptor  table  are  linear
(physical) 24-bit addresses in the range 000000H-FFFFFFH -- not
segments and offsets -- with the least significant byte at  the
lowest address and the most significant  byte  at  the  highest
address.                                                       
   The block move is performed with interrupts disabled;  thus,
use of this  function  may  interfere  with  the  operation  of
communications programs, network  drivers,  or  other  software
that relies on prompt servicing of hardware interrupts.        
   Programs and drivers that access extended memory  with  this
function cannot be executed in the Compatibility Environment of
OS/2.                                                          
   This function is not supported on the PS/2 Models 25 and 30.
                                                               
                Interrupt 15H (I/O Subsystem)                  
   9.8.17. Int 15H Function 88H                                
Description:                                                   
            Get Extended Memory Size [AT] [PS/2]               
   Returns the amount  of  extended  memory  installed  in  the
system.                                                        
Input             Output                                       
------            ------------------------------------         
AH=88H            AX=amount of extended memory (in KB)         
   Extended memory is memory at addresses above 1 MB, which can
only be accessed by an 80286 or 80386 CPU running in  protected
mode. Because MS-DOS is a real-mode operating system,  extended
memory can be used for storage of volatile data but  cannot  be
used for execution of programs.                                
   Programs and  drivers  that  use  this  function  cannot  be
executed in the Compatibility Environment of OS/2.             
   This function is not supported on the PS/2 Models 25 and 30.
   9.8.18. Int 15H Function 89H                                
Description:                                                   
            Enter Protected Mode [AT] [PS/2]                   
   Switches the CPU from real mode into protected mode.        
Input                               Output                     
----------------------------------  ---------------------------
AH=89H                              If function successful     
BH=interrupt number for IRQ0,          (CPU is in protected mod
   written to ICW2 of 8259 PIC #1     Carry flag=clear         
   (must be evenly divisible by 8,    AH=00H                   
   determines IRQ0-IRQ7)              CS=user-defined selector 
BL=interrupt number for IRQ8,         DS=user-defined selector 
   written to ICW2 of 8259 PIC #2     ES=user-defined selector 
   (must be evenly divisible by 8,    SS=user-defined selector 
   determines IRQ8-IRQ15)           If function unsuccessful   
ES:SI=segment:offset of Global         (CPU is in real mode)   
      Descriptor Table (GDT)          Carry flag=set           
                                      AH=FFH                   
   The Global Descriptor Table must contain  eight  descriptors
set up as follows:                                             
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Offset            Descriptor usage                             
------            -----------------------------------          
00H               dummy descriptor (initialized to 0)          
08H               Global Descriptor Table (GDT)                
10H               Interrupt Descriptor Table (IDT)             
18H               user's data segment (DS)                     
20H               user's extra segment (ES)                    
28H               user's stack segment (SS)                    
30H               user's code segment (CS)                     
38H               BIOS code segment                            
                                                               
   The user must initialize the first  seven  descriptors;  the
eighth is filled in by the ROM BIOS to  provide  addressability
for its own execution. The calling program may modify  and  use
the eighth descriptor for any purpose after  return  from  this
function call.                                                 
   This function is not supported on the PS/2 Models 25 and 30.
                                                               
                                                               
                                                               
   9.8.19. Int 15H Function 90H                                
                                                               
                                                               
Description:                                                   
            Device Wait [AT] [PS/2]                            
                                                               
                                                               
   Invoked by the ROM BIOS fixed disk,  floppy  disk,  printer,
network, and keyboard drivers prior to performing a  programmed
wait for I/O completion.                                       
                                                               
Input                                      Output              
-------------------------------  ------------------------------
AH=90H                           If no wait (driver must perfor
AL=device type                               its own time-out) 
  00H-7FH serially reusable        Carry flag=clear            
          devices                  AH=00H                      
  80H-BFH reentrant devices      If wait was performed         
  C0H-FFH wait-only calls,         Carry flag=set              
          no corresponding                                     
          Post function                                        
ES:BX=segment:offset of request                                
      block for device                                         
      types   80H-FFH                                          
                                                               
    Predefined device types are:                               
    00H disk (may time-out)                                    
    01H floppy disk (may time-out)                             
    02H keyboard (no time-out)                                 
    03H pointing device (PS/2, may time-out)                   
    80H network (no time-out)                                  
    FCH fixed disk reset (PS/2, may time-out)                  
    FDH floppy disk drive motor start (may time-out)           
    FEH printer (may time-out)                                 
                                                               
   For network adapters, ES:BX  points  to  a  network  control
block (NCB).                                                   
   A multitasking program manager would be expected to  capture
Int 15H Function 90H so that it can dispatch other tasks  while
I/O is in progress. The default BIOS routine for this  function
simply returns with the carry flag clear and AH=00H.           
                Interrupt 15H (I/O Subsystem)                  
   9.8.20. Int 15H Function 91H                                
Description:                                                   
            Device Post [AT] [PS/2]                            
   Invoked by the ROM BIOS fixed disk,  floppy  disk,  network,
and keyboard drivers to signal that I/O is complete and/or  the
device is ready.                                               
Input                                             Output       
--------------------------------------            ------       
AH=91H                                            AH=00H       
AL=device type                                                 
   00H-7FH serially reusable devices                           
   80H-BFH reentrant devices                                   
ES:BX=segment:offset of request block                          
              for device types 80H-BFH                         
    Predefined device types that may use Device Post are:      
    00H  disk (may time-out)                                   
    01H  floppy disk (may time-out)                            
    02H  keyboard (no time-out)                                
    03H  pointing device (PS/2, may time-out)                  
    80H  network (no time-out)                                 
   The ROM BIOS printer routine does not invoke  this  function
because printer output is not interrupt driven.                
   A multitasking program manager would be expected to  capture
Int 15H Function 91H so that it can be  notified  when  I/O  is
completed and awaken the  requesting  task.  The  default  BIOS
routine for this function simply returns with  the  carry  flag
clear and AH=00H.                                              
   9.8.21. Int 15H Function C0H                                
Description:                                                   
            Get System Environment [AT] [PS/2]                 
   Returns a  pointer  to  a  table  containing  a  variety  of
information about the system configuration.                    
Input    Output                                                
------   ------------------------------------------------------
AH=C0H   ES:BX=segment:offset of configuration table (see Notes
   The format of the system configuration table is as  follows:
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Byte(s)            Contents                                    
-------            --------------------------------------------
00H-01H            length of table in bytes                    
02H                system model (see following Note)           
03H                system submodel (see following Note)        
04H                BIOS revision level                         
05H                configuration flags                         
              Bit(s)  Significance (if set)                    
              ------  --------------------------------------   
              7       DMA channel 3 used                       
              6       slave 8259 present (cascaded IRQ2)       
              5       real-time clock available                
              4       keyboard intercept                       
                      (Int 15H Function 4FH) available         
              3       Wait for External Event is available     
              2       extended BIOS data area allocated        
              1       Micro Channel implemented                
              0       reserved                                 
06H-09H            reserved                                    
                                                               
   The system model and type bytes are assigned as follows:    
                                                               
Machine                   Model Byte            Submodel Byte  
-------                   ----------            -------------  
PC                        FFH                                  
PC/XT                     FEH                                  
PC/XT                     FBH                   00H or 01H     
PCjr                      FDH                                  
PC/AT                     FCH                   00H or 01H     
PC/XT-286                 FCH                   02H            
PC Convertible            F9H                                  
PS/2 Model 30             FAH                   00H            
PS/2 Model 50             FCH                   04H            
PS/2 Model 60             FCH                   05H            
PS/2 Model 80             F8H                   00H or 01H     
                                                               
                                                               
                                                               
                                                               
   9.8.22. Int 15H Function C1H                                
                                                               
                                                               
Description:                                                   
            Get Address of Extended BIOS Data Area [PS/2]      
                                                               
                                                               
   Returns the segment address of the base of the extended BIOS
data area.                                                     
                                                               
  Input             Output                                     
  ------            -------------------------------------      
  AH=C1H            If function successful                     
                    Carry flag=clear                           
                    ES=segment of extended BIOS data area      
                    If function unsuccessful                   
                    Carry flag=set                             
                                                               
   The extended BIOS data area is allocated at the high end  of
conventional  memory  during  the   POST   (Power-On-Self-Test)
sequence. The word at 0040:0013H (memory size)  is  updated  to
reflect the reduced amount of memory available for  MS-DOS  and
                                                               
                Interrupt 15H (I/O Subsystem)                  
application programs. The first byte in the extended BIOS  data
area is initialized to its length in KB.                       
   A program can determine whether the extended BIOS data  area
exists with Int 15H Function C0H.                              
   9.8.23. Int 15H Function C3H                                
Description:                                                   
            Set Watchdog Time-Out [PS/2]                       
   Enables or disables a watchdog timer.                       
Input                                  Output                  
-------------------------------------  ------------------------
AH=C3H                                 If function successful  
AL=subfunction                           Carry flag=clear      
  00H to disable watchdog time-out     If function unsuccessful
  01H to enable watchdog time-out        Carry flag=set        
BX=watchdog timer counter (if AL=01H)                          
   The watchdog timer generates an NMI interrupt.              
   This function is not available on the PS/2 Models 25 and 30.
   9.8.24. Int 15H Function C4H                                
Description:                                                   
            Programmable Option Select [PS/2]                  
   Returns  the  base  Programmable  Option   Select   register
address, enables a slot for setup, or enables an adapter.      
Input                               Output                     
--------------------------------    -------------------------  
AH=C4H                              If function successful     
AL=subfunction                        Carry flag=clear         
  00H to return base POS adapter      and, if called with AL=00
      register address                DX=base POS adapter      
  01H to enable slot                  register address         
  02H to enable adapter             If function unsuccessful   
BL=slot number (if AL=01H)            Carry flag=set           
   This function is available only on machines using the  Micro
Channel Architecture (MCA) bus.                                
   After a slot  is  enabled  with  Subfunction  01H,  specific
information can be obtained for the adapter  in  that  slot  by
performing port input operations:                              
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                                               
Port            Function                                       
----            ----------------------------------             
100H            MCA ID (low byte)                              
101H            MCA ID (high byte)                             
102H            Option Select Byte 1                           
                bit 0=1 if enabled,=0 if disabled              
103H            Option Select Byte 2                           
104H            Option Select Byte 3                           
105H            Option Select Byte 4                           
                bits 6-7=channel check indicators              
106H            Subaddress Extension (low byte)                
107H            Subaddress Extension (high byte)               
                                                               
                                                               
                                                               
                                                               
   9.8.25. Interrupt 15H (Mouse Pointer)                       
                                                               
                                                               
                                                               
Interrupt  Fnct  Subfnct    Name                               
15H        C2H   00H        Enable/Disable Pointing Device     
15H        C2H   01H        Reset Pointing Device              
15H        C2H   02H        Set Sample Rate                    
15H        C2H   03H        Set Resolution                     
15H        C2H   04H        Get Pointing Device Type           
15H        C2H   05H        Initialize Pointing Device Interfac
15H        C2H   06H        Set Scaling or Get Status          
15H        C2H   07H        Set Pointing Device Handler Address
                                                               
                                                               
                                                               
                                                               
   9.8.25.1. Int 15H Function C2H Subfunction  00H             
                                                               
                                                               
Description:                                                   
            Enable/Disable Pointing Device [PS/2]              
                                                               
                                                               
   Enables or disables the system's  mouse  or  other  pointing
device.                                                        
                                                               
Input                    Output                                
----------------------   -------------------------------       
AH=C2H                   If function successful                
AL=00H                     Carry flag=clear                    
BH=enable/disable flag     AH=00H                              
  00H=disable            If function unsuccessful              
  01H=enable               Carry flag=set                      
                           AH=status                           
                            01H if invalid function call       
                            02H if invalid input               
                            03H if interface error             
                            04H if resend                      
                            05H if no far call installed       
                                                               
                                                               
                                                               
                                                               
                Interrupt 15H (I/O Subsystem)                  
   9.8.25.2. Int 15H Function C2H Subfunction  01H             
Description:                                                   
            Reset Pointing Device [PS/2]                       
   Resets the system's mouse or other pointing device,  setting
the sample rate, resolution, and other characteristics to their
default values.                                                
Input     Output                                               
------    ---------------------------------------------------- 
AH=C2H    If function successful                               
AL=01H      Carry flag=clear                                   
            AH=00H                                             
            BH=device ID                                       
          If function unsuccessful                             
            Carry flag=set                                     
            AH=status (see Int 15H Function C2H Subfunction 00H
   After a reset operation, the state of the pointing device is
as follows:                                                    
   - disabled;                                                 
   - sample rate at 100 reports per second;                    
   - resolution at 4 counts per millimeter;                    
   - and scaling at 1 to 1.                                    
   The data package size is unchanged by this function.        
   The application can use  the  other  Int  15H  Function  C2H
subfunctions to initialize the pointing device to other  sample
rates, resolution, and scaling, and then enable the device with
Int 15H Function C2H Subfunction 00H.                          
   See  also  Int  15H  Function  C2H  Subfunction  05H,  which
incidentally resets the pointing device in a similar manner.   
   9.8.25.3. Int 15H Function C2H Subfunction  02H             
Description:                                                   
            Set Sample Rate [PS/2]                             
   Sets the sampling  rate  of  the  system's  mouse  or  other
pointing device.                                               
Input                           Output                         
-----------------------------   ---------------------------    
AH=C2H                          If function successful         
AL=02H                            Carry flag=clear             
BH=sample rate value              AH=00H                       
  00H=10 reports per second     If function unsuccessful       
  01H=20 reports per second       Carry flag=set               
  02H=40 reports per second       AH=status (see Int 15H       
  03H=60 reports per second       Function C2H                 
  04H=80 reports per second       Subfunction 00H)             
  05H=100 reports per second                                   
  06H=200 reports per second                                   
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
   The default sample rate is 100 reports per  second  after  a
reset operation (Int 15H Function C2H Subfunction 01H).        
                                                               
                                                               
                                                               
   9.8.25.4. Int 15H Function C2H Subfunction  03H             
                                                               
                                                               
Description:                                                   
            Set Resolution [PS/2]                              
                                                               
                                                               
   Sets the resolution of the system's mouse or other  pointing
device.                                                        
                                                               
Input                            Output                        
------------------------------   ---------------------------   
AH=C2H                           If function successful        
AL=03H                             Carry flag=clear            
BH=resolution value                AH=00H                      
  00H=1 count per millimeter     If function unsuccessful      
  01H=2 counts per millimeter      Carry flag=set              
  02H=4 counts per millimeter      AH=status (see Int 15H      
  03H=8 counts per millimeter         Function C2H             
                                      Subfunction 00H)         
                                                               
   The default resolution is 4 counts per  millimeter  after  a
reset operation (Int 15H Function C2H Subfunction 01H).        
                                                               
                                                               
                                                               
   9.8.25.5. Int 15H Function C2H Subfunction  04H             
                                                               
                                                               
Description:                                                   
            Get Pointing Device Type [PS/2]                    
                                                               
                                                               
   Returns the identification code for the  system's  mouse  or
other pointing device.                                         
                                                               
  Input             Output                                     
  ------            ------------------------------------------ 
  AH=C2H            If function successful                     
  AL=04H            Carry flag=clear                           
                    AH=00H                                     
                    BH=device ID                               
                    If function unsuccessful                   
                    Carry flag=set                             
                    AH=status (see Int 15H Function            
                               C2H Subfunction 00H)            
                                                               
                                                               
                                                               
                                                               
   9.8.25.6. Int 15H Function C2H Subfunction  05H             
                                                               
                                                               
Description:                                                   
            Initialize Pointing Device Interface [PS/2]        
                                                               
                                                               
                Interrupt 15H (I/O Subsystem)                  
   Sets the data package size for the system's mouse  or  other
pointing device, and initializes the resolution, sampling rate,
and scaling to their default values.                           
Input                  Output                                  
--------------------   -----------------------------------     
AH=C2H                 If function successful                  
AL=05H                   Carry flag=clear                      
BH=data package size     AH=00H                                
   in bytes (1-8)      If function unsuccessful                
                         Carry flag=set                        
                         AH=status (see Int 15H Function C2H   
                                    Subfunction 00H)           
   After this operation, the state of the pointing device is as
follows:                                                       
   - disabled;                                                 
   - sample rate at 100 reports per second;                    
   - resolution at 4 counts per millimeter;                    
   - and scaling at 1 to 1.                                    
   9.8.25.7. Int 15H Function C2H Subfunction  06H             
Description:                                                   
            Set Scaling or Get Status [PS/2]                   
   Returns the current status of the system's  mouse  or  other
pointing device or sets the device's scaling factor.           
Input                          Output                          
---------------------------    ------------------------------  
AH=C2H                         If function successful          
AL=06H                           Carry flag=clear              
BH=extended command              AH=00H                        
  00H=return device status       and, if called with BH=00H    
  01H=set scaling at 1:1         BL=status byte                
  02H=set scaling at 2:1           Bit(s)  Significance        
                                   ------  ------------        
                                   0       =1 if right button  
                                              pressed          
                                   1       =reserved           
                                   2       =1 if left button   
                                              pressed          
                                   3       =reserved           
                                   4       =0 if 1:1 scaling   
                                            1 if 2:1 scaling   
                                   5       =0 if device disable
                                            1 if device enabled
                                   6       =0 if stream mode   
                                            1 if remote mode   
                                   7       =reserved           
                                 CL=resolution                 
                                   00H=1 count per millimeter  
                                   01H=2 counts per millimeter 
                                   02H=4 counts per millimeter 
                                   03H=8 counts per millimeter 
                Interrupt 15H (I/O Subsystem)                  
                                                               
                                                               
                                 DL=sample rate                
                                   0AH=10 reports per second   
                                   14H=20 reports per second   
                                   28H=40 reports per second   
                                   3CH=60 reports per second   
                                   50H=80 reports per second   
                                   64H=100 reports per second  
                                   C8H=200 reports per second  
                               If function unsuccessful        
                                 Carry flag=set                
                                 AH=status (see Int 15H        
                                    Function C2H Subfunction 00
                                                               
                                                               
                                                               
                                                               
   9.8.25.8. Int 15H Function C2H Subfunction  07H             
                                                               
                                                               
Description:                                                   
            Set Pointing Device Handler Address [PS/2]         
                                                               
                                                               
   Notifies the ROM BIOS pointing device driver of the  address
for a routine to be called each time pointing  device  data  is
available.                                                     
                                                               
Input                        Output                            
----------------------       ---------------------------       
AH=C2H                       If function successful            
AL=07H                         Carry flag=clear                
ES:BX=segment:offset         If function unsuccessful          
      of user routine          Carry flag=set                  
                               AH=status (see Int 15H          
                                          Function C2H         
                                          Subfunction 00H)     
                                                               
   The user's handler for pointing device data is entered via a
far call with four parameters on the stack:                    
                                                               
      SS:SP+0AH status                                         
      SS:SP+08H x coordinate                                   
      SS:SP+06H y coordinate                                   
      SS:SP+04H z coordinate (always 0)                        
                                                               
The handler must exit via a far  return  without  removing  the
parameters from the stack.                                     
   The  status  parameter  passed  to  the  user's  handler  is
interpreted as follows:                                        
                                                               
    Bit(s)     Significance (if set)                           
    ------     --------------------------                      
    0          left button pressed                             
    1          right button pressed                            
    2-3        reserved                                        
    4          sign of x data is negative                      
    5          sign of y data is negative                      
    6          x data has overflowed                           
    7          y data has overflowed                           
    8-15       reserved                                        
                                                               
                                                               
                   Interrupt 16H (Keyboard)                    
   9.9. Interrupt 16H (Keyboard)                               
Interrupt  Function         Name                               
16H        00H              Read Character from Keyboard       
16H        01H              Get Keyboard Status                
16H        02H              Get Keyboard Flags                 
16H        03H              Set Repeat Rate                    
16H        04H              Set Keyclick                       
16H        05H              Push Character and Scan Code       
16H        10H              Read Character from Enhanced Keyboa
16H        11H              Get Enhanced Keyboard Status       
16H        12H              Get Enhanced Keyboard Flags        
   9.9.1. Int 16H Function 00H                                 
Description:                                                   
            Read Character from Keyboard [PC] [AT] [PS/2]      
   Reads a character from  the  keyboard,  also  returning  the
keyboard scan code.                                            
Input             Output                                       
------            ---------------------                        
AH=00H            AH=keyboard scan code                        
                  AL=ASCII character                           
   9.9.2. GetKeyClock                                          
;* GetKeyClock - Waits for keypress while updating time at     
;* specified location on screen.                               
;*                                                             
;* Shows:   BIOS Interrupt - 16h, Functions 0 and 10h          
;*                           (Read Character)                  
;*                           16h, Functions 1 and 11h          
;*                           (Get Keyboard Status)             
;*          DOS Functions - 2Ah (Get Date)                     
;*                          2Ch (Get Time)                     
;*                                                             
;* Uses:    vconfig - Video configuration structure,           
;*          declared in the DEMO.INC include file.             
;*          The structure must first be                        
;*          initialized by calling the GetVidConfig procedure. 
;*                                                             
;* Params:  row - Screen row for clock display                 
;*          col - Screen column for clock display              
;*                                                             
;* Return:  Short integer with key scan code in high byte      
;*          and ASCII character code in low byte.              
;*          Low byte is 0 for special keys (such as the "F"    
;*          keys) which don't generate characters.             
                   Interrupt 16H (Keyboard)                    
                                                               
                                                               
                                                               
        .DATA                                                  
        PUBLIC datestr                                         
datestr DB      '  -  -     :  :  ', 0  ; Date/time string     
        .CODE                                                  
                                                               
        EXTRN StrWrite:PROC                                    
                                                               
GetKeyClock PROC \                                             
        row:WORD, col:WORD                                     
                                                               
        LOCAL   service:BYTE                                   
                                                               
        call    GetShift     ; Check for extended keyboard     
        mov     service, 11h ; Request for Function 11h        
        cmp     dx, 1        ; Extended keyboard available?    
        je      key1         ; Yes?  Set AH appropriately      
        mov     service, 1   ; No? Set AH for Function 1       
key1:   mov     ah, service                                    
        int     16h          ; Check if Key is Ready           
        jnz     exit         ; Ready?  Exit procedure          
                             ; Not ready?  Check text mode     
        cmp     vconfig.mode, 7  ; Monochrome text mode?       
        je      @F               ; Yes?  Continue              
        cmp     vconfig.mode, 3  ; Color text mode?            
        je      @F               ; Yes?  Continue              
        cmp     vconfig.mode, 2  ; Black/white?                
        jne     key1          ; No?  Skip clock update and     
                              ;   poll keyboard again          
                                                               
; If 80-column text, get date and time from                    
; DOS before again polling keyboard,                           
; and display at upper right corner of screen.                 
                                                               
@@:     mov     ah, 2Ch                 ; Request time         
        int     21h                     ; Get Time             
        mov     dl, dh                                         
        push    dx                      ; Save seconds,        
        push    cx                      ;   minutes,           
        mov     cl, ch                  ;   and                
        push    cx                      ;   hours              
        mov     ah, 2Ah                 ; Request date         
        int     21h                     ; Get Date             
        sub     cx, 1900  ; Subtract century, CL = year        
        push    cx                      ; Save year,           
        push    dx                      ;   day,               
        mov     dl, dh                  ;   and                
        push    dx                      ;   month              
                                                               
        mov     cx, 6                                          
        sub     bx, bx                                         
loop1:  pop     ax        ; Recover all 6 numbers in AL        
        aam               ; Convert to unpacked BCD            
        xchg    al, ah    ; Switch bytes for word move         
        or      ax, '00'  ; Make ASCII numerals                
        mov     WORD PTR datestr[bx], ax; Copy to string       
        add     bx, 3                   ;   at every third byte
        loop    loop1                                          
                                                               
        DispText row, col, <OFFSET datestr>                    
        jmp     key1        ; Loop again for keypress          
                                                               
                                                               
                   Interrupt 16H (Keyboard)                    
exit:   mov     ah, service ; 1 or 11h, depending on keybd     
        dec     ah          ; Set AH to 0 or 10h               
        int     16h         ; Get key to remove it from        
        ret                 ;   keyboard buffer                
GetKeyClock ENDP                                               
   9.9.3. Int 16H Function 01H                                 
Description:                                                   
            Get Keyboard Status [PC] [AT] [PS/2]               
   Determines whether a character is ready for input, returning
a flag and also the character itself, if one is waiting.       
Input             Output                                       
------            --------------------------                   
AH=01H            If key waiting to be input                   
                    Zero flag=clear                            
                    AH=keyboard scan code                      
                    AL=character                               
                  If no key waiting                            
                    Zero flag=set                              
   The character returned by this function when the  zero  flag
is clear is not removed from the type-ahead  buffer.  The  same
character and scan code will be returned by the  next  call  to
Int 16H Function 00H.                                          
   9.9.4. Int 16H Function 02H                                 
Description:                                                   
            Get Keyboard Flags [PC] [AT] [PS/2]                
   Returns the ROM BIOS flags byte that describes the state  of
the various keyboard toggles and shift keys.                   
Input             Output                                       
------            ----------------------------------           
AH=02H            AL=flags                                     
                     Bit(s)  Significance (if set)             
                     ------  -----------------------           
                       7       Insert on                       
                       6       Caps Lock on                    
                       5       Num Lock on                     
                       4       Scroll Lock on                  
                       3       Alt key is down                 
                       2       Ctrl key is down                
                       1       left Shift key is down          
                       0       right Shift key is down         
   The keyboard flags byte is stored in the ROM BIOS data  area
at 0000:0417H.                                                 
                   Interrupt 16H (Keyboard)                    
                                                               
                                                               
   9.9.5. Int 16H Function 03H                                 
                                                               
                                                               
Description:                                                   
            Set Repeat Rate [PC] [AT] [PS/2]                   
                                                               
                                                               
   Sets the ROM BIOS key repeat ("typematic") rate and delay.  
                                                               
Input                                                 Output   
------------------------------------------            -------  
On the PC/AT and PS/2                                 Nothing  
AH=03H                                                         
AL=05H                                                         
BH=repeat delay (see Notes)                                    
BL=repeat rate (see Notes)                                     
On the PCjr                                                    
AH=03H                                                         
AL=subfunction                                                 
     00H to restore default rate and delay                     
     01H to increase initial delay                             
     02H to decrease repeat rate by one-half                   
     03H to increase delay and decrease                        
         repeat rate by one-half                               
     04H to turn off keyboard repeat                           
                                                               
   Subfunctions 00H-04H are available on the PCjr but  are  not
supported by the PC or  PC/XT  ROM  BIOS.  Subfunction  05H  is
available on PC/ATs with ROM BIOS's dated 11/15/85  and  later,
and on the PS/2.                                               
   On the PC/AT and PS/2, the value in BH controls  the  amount
of delay before the first repeat key is  generated,  and  is  a
multiple of 250 milliseconds:                                  
                                                               
    Value            Delay (msec.)                             
    -----            -------------                             
    00H              250                                       
    01H              500                                       
    02H              750                                       
    03H              1000                                      
                                                               
   On the PC/AT and PS/2, the value  for  the  repeat  rate  in
characters per second can be chosen from the following table:  
                                                               
    Value            Repeat rate (characters per second)       
    -----            -----------------------------------       
    00H              30.0                                      
    01H              26.7                                      
    02H              24.0                                      
    03H              21.8                                      
    04H              20.0                                      
    05H              18.5                                      
    06H              17.1                                      
    07H              16.0                                      
    08H              15.0                                      
    09H              13.3                                      
    0AH              12.0                                      
    0BH              10.9                                      
    0CH              10.0                                      
    0DH              9.2                                       
    0EH              8.6                                       
    0FH              8.0                                       
                   Interrupt 16H (Keyboard)                    
    10H              7.5                                       
    11H              6.7                                       
    12H              6.0                                       
    13H              5.5                                       
    14H              5.0                                       
    15H              4.6                                       
    16H              4.3                                       
    17H              4.0                                       
    18H              3.7                                       
    19H              3.3                                       
    1AH              3.0                                       
    1BH              2.7                                       
    1CH              2.5                                       
    1DH              2.3                                       
    1EH              2.1                                       
    1FH              2.0                                       
   9.9.6. Int 16H Function 04H                                 
Description:                                                   
            Set Keyclick [PC]                                  
   Turns the keyboard click on or off.                         
Input                                        Output            
---------------------------------            -------           
AH=04H                                       Nothing           
AL=subfunction                                                 
     00H to turn off keyboard click                            
     01H to turn on keyboard click                             
   This function is supported by the PCjr BIOS only.           
   9.9.7. Int 16H Function 05H                                 
Description:                                                   
            Push Character and Scan Code [AT] [PS/2]           
   Places a character and scan code in the keyboard  type-ahead
buffer.                                                        
  Input                   Output                               
  ------------            -----------------------------        
  AH=05H                  If function successful               
  CH=scan code            Carry flag=clear                     
  CL=character            AL=00H                               
                          If function unsuccessful             
                            (type-ahead buffer is full)        
                          Carry flag=set                       
                          AL=01H                               
   This function can be used by keyboard  enhancers  and  other
utilities to interpolate keys into  the  data  stream  seen  by
                   Interrupt 16H (Keyboard)                    
                                                               
                                                               
application programs.                                          
                                                               
   9.9.8. Int 16H Function 10H                                 
                                                               
                                                               
Description:                                                   
            Read Character from Enhanced Keyboard [AT] [PS/2]  
                                                               
                                                               
   Reads a character and scan code from the keyboard type-ahead
buffer.                                                        
                                                               
  Input             Output                                     
  ------            ---------------------                      
  AH=10H            AH=keyboard scan code                      
                    AL=ASCII character                         
                                                               
   Use this function for the enhanced keyboard instead  of  Int
16H Function 00H. It allows applications  to  obtain  the  scan
codes for the additional F11, F12, and cursor control keys.    
                                                               
                                                               
                                                               
   9.9.9. Int 16H Function 11H                                 
                                                               
                                                               
Description:                                                   
            Get Enhanced Keyboard Status [AT] [PS/2]           
                                                               
                                                               
   Determines whether a character is ready for input, returning
a flag and also the character itself, if one is waiting.       
                                                               
  Input             Output                                     
  ------            --------------------------                 
  AH=11H            If key waiting to be input                 
                    Zero flag=clear                            
                    AH=keyboard scan code                      
                    AL=character                               
                    If no key waiting                          
                    Zero flag=set                              
                                                               
   Use this function for the enhanced keyboard instead  of  Int
16H Function 00H.  It  allows  applications  to  test  for  the
additional F11, F12, and cursor control keys.                  
   The character returned by this function when the  zero  flag
is clear is not removed from the type-ahead  buffer.  The  same
character and scan code will be returned by the  next  call  to
Int 16H Function 10H.                                          
                                                               
                                                               
                                                               
   9.9.10. Int 16H Function 12H                                
                                                               
                                                               
Description:                                                   
            Get Enhanced Keyboard Flags [AT] [PS/2]            
                                                               
                                                               
   Obtains the status of various enhanced keyboard special keys
and keyboard driver states.                                    
                   Interrupt 16H (Keyboard)                    
  Input             Output                                     
  ------            -----------------------------------        
  AH=12H            AX=flags                                   
                       Bit(s)  Significance (if set)           
                       ------  -----------------------         
                       00H     right Shift key is down         
                       01H     left Shift key is down          
                       02H     either Ctrl key is down         
                       03H     either Alt key is down          
                       04H     Scroll Lock toggle is on        
                       05H     Num Lock toggle is on           
                       06H     Caps Lock toggle is on          
                       07H     Insert toggle is on             
                       08H     left Ctrl key is down           
                       09H     left Alt key is down            
                       0AH     right Ctrl key is down          
                       0BH     right Alt key is down           
                       0CH     Scroll key is down              
                       0DH     Num Lock key is down            
                       0EH     Caps Lock key is down           
                       0FH     SysReq key is down              
   Use this function for the enhanced keyboard instead  of  Int
16H Function 02H.                                              
   9.10. Interrupt 17H (Parallel Printer Port)                 
Interrupt  Function         Name                               
17H        00H              Write Character to Printer         
17H        01H              Initialize Printer Port            
17H        02H              Get Printer Status                 
   9.10.1. Int 17H Function 00H                                
Description:                                                   
            Write Character to Printer [PC] [AT]               
   Sends  a  character  to  the  specified   parallel   printer
interface port and returns the current status of the port.     
            Interrupt 17H (Parallel Printer Port)              
                                                               
                                                               
                                                               
Input                         Output                           
---------------------------   -------------------------------  
AH=00H                        AH=status                        
AL=character                  Bit(s)  Significance (if set)    
DX=printer number             ------  ---------------------    
   (0=LPT1, 1=LPT2, 2=LPT3)    7       printer not busy        
                               6       printer acknowledge     
                               5       out of paper            
                               4       printer selected        
                               3       I/O error               
                               2       unused                  
                               1       unused                  
                               0       printer timed-out       
                                                               
                                                               
                                                               
                                                               
   9.10.2. Int 17H Function 01H                                
                                                               
                                                               
Description:                                                   
            Initialize Printer Port [PC] [AT] [PS/2]           
                                                               
                                                               
   Initializes the specified parallel  printer  interface  port
and returns its status.                                        
                                                               
  Input                          Output                        
  ---------------------------    ----------------------------- 
  AH=01H                         AH=status                     
  DX=printer number                 (see Int 17H Function 00H) 
     (0=LPT1, 1=LPT2, 2=LPT3)                                  
                                                               
                                                               
                                                               
                                                               
   9.10.3. Int 17H Function 02H                                
                                                               
                                                               
Description:                                                   
            Get Printer Status [PC] [AT] [PS/2]                
                                                               
                                                               
   Returns the current status of the specified parallel printer
interface port.                                                
                                                               
Input                           Output                         
---------------------------     -----------------------------  
AH=02H                          AH=status                      
DX=printer number                  (see Int 17H Function 00H)  
   (0=LPT1, 1=LPT2, 2=LPT3)                                    
                                                               
                                                               
                                                               
                                                               
   9.10.4. VeriPrint                                           
                                                               
                                                               
            Interrupt 17H (Parallel Printer Port)              
;* VeriPrint - Checks if LPT1 (PRN) is available.              
;*                                                             
;* Shows:   BIOS Interrupt - 17h (Parallel Port Printer Driver)
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Short integer, 1 for yes or 0 for no               
VeriPrint PROC                                                 
        mov     ah, 2         ; Check printer status for       
        sub     dx, dx        ;   parallel printer (port 0)    
        int     17h                                            
        xchg    dx, ax        ; Put 0 (for error) in AX        
        test    dh, 00101001b ; Are any error bits on?         
        jne     exit          ; Yes?  Leave 0                  
        test    dh, 10010000b ; Are both operation bits on?    
        jz      exit          ; No?  Leave 0                   
        inc     ax            ; Yes?  Return 1                 
exit:   ret                                                    
VeriPrint ENDP                                                 
   9.11. Interrupt 1AH (Clock)                                 
Interrupt  Function         Name                               
1AH        00H              Get Tick Count                     
1AH        01H              Set Tick Count                     
1AH        02H              Get Time                           
1AH        03H              Set Time                           
1AH        04H              Get Date                           
1AH        05H              Set Date                           
1AH        06H              Set Alarm                          
1AH        07H              Reset Alarm                        
1AH        0AH              Get Day Count                      
1AH        0BH              Set Day Count                      
1AH        80H              Set Sound Source                   
   9.11.1. Int 1AH Function 00H                                
Description:                                                   
            Get Tick Count [AT] [PS/2]                         
   Returns the contents of the clock tick counter.             
                    Interrupt 1AH (Clock)                      
                                                               
                                                               
                                                               
Input             Output                                       
------            -------                                      
AH=00H            AL=rolled-over flag                          
                    00H if midnight not passed since last read 
                    <>00H if midnight was passed since last rea
                  CX:DX=tick count (high 16 bits in CX)        
                                                               
   This function is supported by the PC/XT and PCjr  ROM  BIOS,
but is not present in the ROM BIOS for the original PC.        
   The returned value is the cumulative number of  clock  ticks
since midnight. There are 18.2 clock ticks per second. When the
counter reaches 1,573,040, it  is  cleared  to  zero,  and  the
rolled-over flag is set.                                       
   The rolled-over flag is cleared by this  function  call,  so
the flag will only be returned nonzero once per day.           
   Int 1AH Function 01H can be  used  to  set  the  clock  tick
counter to an arbitrary 32-bit value.                          
                                                               
                                                               
                                                               
   9.11.2. Pause                                               
                                                               
                                                               
                                                               
;* Pause - Waits for specified number of clocks                
;* to elapse, then returns.                                    
;*                                                             
;* Shows:   BIOS Interrupt - 1Ah, Function 0                   
;*          (Real-Time Clock Driver)                           
;*          Operators - LOCAL     []                           
;*                                                             
;* Params:  duration - Desired duration in clocks, where       
;*                     18 clocks = approx 1 second             
;*                                                             
;* Return:  None                                               
                                                               
Pause   PROC \                                                 
        duration:WORD                                          
                                                               
        LOCAL time:DWORD                                       
                                                               
        sub     ah, ah                                         
        int     1Ah           ; Get Clock Count in CX:DX       
        add     dx, duration  ; Add pause time to it           
        adc     cx, 0                                          
        mov     WORD PTR time[0], dx ; Result is target time;  
        mov     WORD PTR time[2], cx ;   keep in local variable
loop1:  int     1AH                  ; Now repeatedly poll cloc
        cmp     dx, WORD PTR time[0] ;   count until the target
        jb      loop1                ;   time is reached       
        cmp     cx, WORD PTR time[2]                           
        jb      loop1                                          
        ret                                                    
                                                               
Pause   ENDP                                                   
                                                               
                                                               
                                                               
                                                               
                    Interrupt 1AH (Clock)                      
   9.11.3. Int 1AH Function 01H                                
Description:                                                   
            Set Tick Count [AT] [PS/2]                         
   Stores a 32-bit value in the clock tick counter.            
  Input                                            Output      
  -------------------------------------            -------     
  AH=01H                                           Nothing     
  CX:DX=tick count (high 16-bits in CX)                        
   This function is supported by the PC/XT and PCjr  ROM  BIOS,
but is not present in the ROM BIOS for the original PC.        
   Int 1AH Function 00H is used to read the value of the  clock
tick counter.                                                  
   The rolled-over flag is cleared by this function call.      
   9.11.4. Int 1AH Function 02H                                
Description:                                                   
            Get Time [AT] [PS/2]                               
   Reads the current time from the CMOS time/date chip.        
  Input             Output                                     
  ------            --------------------------------------     
  AH=02H            CH=hours in binary coded decimal (BCD)     
                    CL=minutes in BCD                          
                    DH=seconds in BCD                          
                    DL=daylight-saving-time code               
                       00H if standard time                    
                       01H if daylight saving time             
                    and, if clock running                      
                    Carry flag=clear                           
                    or, if clock stopped                       
                    Carry flag=set                             
   9.11.5. Int 1AH Function 03H                                
Description:                                                   
            Set Time [AT] [PS/2]                               
   Sets the time in the CMOS time/date chip.                   
                    Interrupt 1AH (Clock)                      
                                                               
                                                               
                                                               
  Input                                             Output     
  --------------------------------------            -------    
  AHM=03H                                           Nothing    
  CH=hours in binary coded decimal (BCD)                       
  CL=minutes in BCD                                            
  DH=seconds in BCD                                            
  DL=daylight-saving-time code                                 
     00H if standard time                                      
     01H if daylight saving time                               
                                                               
                                                               
                                                               
                                                               
   9.11.6. Int 1AH Function 04H                                
                                                               
                                                               
Description:                                                   
            Get Date [AT] [PS/2]                               
                                                               
                                                               
   Reads the current date from the CMOS time/date chip.        
                                                               
  Input     Output                                             
  ------    ---------------------------------------------------
  AH=04H    CH=century (19 or 20) in binary coded decimal (BCD)
            CL=year in BCD                                     
            DH=month in BCD                                    
            DL=day in BCD                                      
            and, if clock running                              
            Carry flag=clear                                   
            or, if clock stopped                               
            Carry flag=set                                     
                                                               
                                                               
                                                               
                                                               
   9.11.7. Int 1AH Function 05H                                
                                                               
                                                               
Description:                                                   
            Set Date [AT] [PS/2]                               
                                                               
                                                               
   Sets the date in the CMOS time/date chip.                   
                                                               
Input                                                Output    
---------------------------------------------------  -------   
AH=05H                                               Nothing   
CH=century (19 or 20) in binary coded decimal (BCD)            
CL=year in BCD                                                 
DH=month in BCD                                                
DL=day in BCD                                                  
                                                               
                                                               
                                                               
                                                               
                    Interrupt 1AH (Clock)                      
   9.11.8. Int 1AH Function 06H                                
Description:                                                   
            Set Alarm [AT] [PS/2]                              
   Sets an alarm in the CMOS date/time chip.                   
Input                                   Output                 
--------------------------------------  -----------------------
AH=06H                                  If function successful 
CH=hours in binary coded decimal (BCD)    Carry flag=clear     
CL=minutes in BCD                       If function unsuccessfu
DH=seconds in BCD                         (alarm already set,  
                                           or clock stopped)   
                                          Carry flag=set       
   A side effect of this function  is  that  the  clock  chip's
interrupt level (IRQ8) is enabled.                             
   Only one alarm may be active at any given  time.  The  alarm
occurs every 24 hours at the specified time until it  is  reset
with Int 1AH Function 07H.                                     
   The program using this function must place  the  address  of
its interrupt handler for the alarm in the vector for Int  4AH.
   9.11.9. Int 1AH Function 07H                                
Description:                                                   
            Reset Alarm [AT] [PS/2]                            
   Cancels any pending alarm  request  on  the  CMOS  date/time
chip.                                                          
  Input             Output                                     
  ------            -------                                    
  AH=07H            Nothing                                    
   This function does not disable the  clock  chip's  interrupt
level (IRQ8).                                                  
   9.11.10. Int 1AH Function 0AH                               
Description:                                                   
            Get Day Count [PS/2]                               
   Returns the contents of the system's day counter.           
                    Interrupt 1AH (Clock)                      
                                                               
                                                               
                                                               
  Input             Output                                     
  ------            ------------------------------             
  AH=0AH            If function successful                     
                    Carry flag=clear                           
                    CX=count of days since 1-1-1980            
                    If function unsuccessful                   
                    Carry flag=set                             
                                                               
                                                               
                                                               
                                                               
   9.11.11. Int 1AH Function 0BH                               
                                                               
                                                               
Description:                                                   
            Set Day Count [PS/2]                               
                                                               
                                                               
   Stores an arbitrary value in the system's day counter.      
                                                               
  Input                             Output                     
  ----------------------            -------------------------- 
  AH=0BH                            If function successful     
  CX=count of days since            Carry flag=clear           
     January 1, 1980                If function unsuccessful   
                                    Carry flag=set             
                                                               
                                                               
                                                               
                                                               
   9.11.12. Int 1AH Function 80H                               
                                                               
                                                               
Description:                                                   
            Set Sound Source [PC]                              
                                                               
                                                               
   Sets up the source for tones that will appear on the  PCjr's
"Audio Out" or RF modulator.                                   
                                                               
  Input                                          Output        
  --------------------------------------------   -------       
  AH=80H                                         Nothing       
  AL=sound source                                              
     00H if 8253 programmable timer, channel 2                 
     01H if cassette input                                     
     02H if "Audio In" line on I/O channel                     
     03H if sound generator chip                               
                                                               
   This function is supported on the PCjr only.                
                                                               
                                                               
                                                               
   9.12. Int 11H                                               
                                                               
                                                               
Description:                                                   
            Get Equipment Configuration [PC] [AT] [PS/2]       
                                                               
                                                               
   Obtains the equipment list code word from the ROM BIOS.     
                      Miscellaneous BIOS                       
Input     Output                                               
-------   -----------------------------------------------------
Nothing   AX=equipment list code word                          
          Bit(s)          Significance                         
          ------          -------------------------------------
          14-15           number of printers installed         
          13              =1 if internal modem installed       
                             (PC and XT only)                  
                          =1 if serial printer attached (PCjr) 
          12              =1 if game adapter installed         
          9-11            number of RS-232 ports installed     
          8               reserved                             
          6-7             number of floppy disk drives         
                          (if bit 0 =1)                        
                                   00=1                        
                                   01=2                        
                                   10=3                        
                                   11=4                        
          4-5             initial video mode                   
                                     00  reserved              
                                     01  40-by-25 color text   
                                     10  80-by-25 color text   
                                     11  80-by-25 monochrome   
          2-3             system board RAM size (PC, see Note) 
                                     00=16 KB                  
                                     01=32 KB                  
                                     10=48 KB                  
                                     11=64 KB                  
          2               =1 if pointing device installed (PS/2
          1               =1 if math coprocessor installed     
          0               =1 if floppy disk drive(s) installed 
   Bits 2-3 of the returned value are used only in the ROM BIOS
for the original IBM PC with the 64 KB system board and on  the
PCjr.                                                          
   9.13. VeriCop                                               
;* VeriCop - Checks for coprocessor.                           
;*                                                             
;* Shows:   BIOS Interrupt - 11h (Get Equipment Information)   
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Short integer, 1 for yes or 0 for no               
VeriCop PROC                                                   
        int     11h        ; Check peripherals                 
        test    al, 10b    ; Coprocessor?                      
        mov     ax, 0      ; Assume no, don't alter flags      
        jz      exit       ; No?  Done                         
        inc     ax         ; Yes?  Set to 1                    
exit:   ret                                                    
VeriCop ENDP                                                   
                      Miscellaneous BIOS                       
                                                               
                                                               
   9.14. Int 12H                                               
                                                               
                                                               
Description:                                                   
            Get Conventional Memory Size [PC] [AT] [PS/2]      
                                                               
                                                               
   Returns the amount of conventional memory available for  use
by MS-DOS and application programs.                            
                                                               
  Input              Output                                    
  -------            ----------------------                    
  Nothing            AX=memory size (in KB)                    
                                                               
   On some early PC models, the amount of  memory  returned  by
this function is controlled by the settings of the dip switches
on the system board and may not reflect all the memory that  is
physically present.                                            
   On the PC/AT, the value returned is the amount of functional
memory found during the power-on self-test, regardless  of  the
memory size configuration information stored in CMOS RAM.      
   The value returned does  not  reflect  any  extended  memory
(above the 1 MB boundary) that may be  installed  on  80286  or
80386 machines such as the PC/AT or PS/2 (Models 50 and above).
                                                               
                                                               
                                                               
   9.15. GetMem                                                
                                                               
                                                               
                                                               
;* GetMem - Gets total size of memory and determines the       
;* largest amount of unallocated memory available.             
;* GetMem invokes DOS Function 48h (Allocate Memory)           
;* to request an impossibly large memory block. DOS denies the 
;* request, but returns instead the size of the largest block  
;* available. This is the amount that GetMem returns to the    
;* calling program. See the WinOpen procedure for an example   
;* of calling Function 48h to allocate unused memory.          
;*                                                             
;* Shows:   BIOS Interrupt - 12h (Get Conventional Memory Size)
;*                                                             
;* Params:  None                                               
;*                                                             
;* Return:  Long integer, high word = total memory             
;*                         in kilobytes (KB)                   
;*                        low word  = largest block            
;*                         of available memory (KB)            
                                                               
GetMem  PROC                                                   
                                                               
        int     12h        ; Get total memory in K             
        push    ax         ; Save size of memory               
        mov     ah, 48h    ; Request memory allocation         
        mov     bx, 0FFFFh ; Ensure request is denied for      
                           ;   impossibly large block          
        int     21h        ; Get largest available block in BX 
        mov     ax, bx     ; Copy to AX                        
        mov     cl, 6      ; Convert paragraphs to kilobytes by
        shr     ax, cl     ;   dividing by 64                  
        pop     dx         ; Recover total in DX               
        ret                ; Return long integer DX:AX         
                      Miscellaneous BIOS                       
GetMem  ENDP                                                   
   9.16. Int 18H                                               
Description:                                                   
            ROM BASIC [PC] [AT] [PS/2]                         
   Transfers control to ROM BASIC.                             
  Input              Output                                    
  -------            -------                                   
  Nothing            Nothing                                   
   This function is invoked when the system  is  turned  on  or
restarted if attempts to read a boot sector from the fixed disk
or floppy disk drives are unsuccessful.                        
   9.17. Int 19H                                               
Description:                                                   
            Reboot System [PC] [AT] [PS/2]                     
   Reboots the operating system from the floppy disk  or  fixed
disk drive.                                                    
  Input              Output                                    
  -------            -------                                   
  Nothing            Nothing                                   
   The bootstrap routine reads Sector 1, Track 0 into memory at
location 0000:7C00H and transfers control to the same  address.
If attempts to read a boot sector from the floppy disk or fixed
disk are unsuccessful, control is transferred to ROM  BASIC  by
execution of an Int 18H.                                       
   If location 0000:0472H does not contain the value  1234H,  a
memory test will be performed before reading the boot sector.  
                           MASM 5.1                            
                                                               
                                                               
                          I n d e x                            
                                                               
                                                               
                                                               
@code  . . . . . . . . . . . . . . . . . . 143                 
@CodeSize  . . . . . . . . . . . . . . . . 145                 
@Cpu   . . . . . . . . . . . . . . . . . . 146                 
@CurSeg  . . . . . . . . . . . . . . . . . 144                 
@data  . . . . . . . . . . . . . . . . . . 145                 
@DataSize  . . . . . . . . . . . . . . . . 146                 
@FileName  . . . . . . . . . . . . . . . . 144                 
@Model   . . . . . . . . . . . . . . . . . 145                 
@Version   . . . . . . . . . . . . . . . . 146                 
@WordSize  . . . . . . . . . . . . . . . . 145                 
                                                               
% (Expression Operator)  . . . . . . . . . 128                 
%OUT Directive   . . . . . . . . . . . . . 107                 
                                                               
! (Literal Character Operator)   . . . . . 127                 
                                                               
& (Substitute Operator)  . . . . . . . . . 128                 
                                                               
* (Multiplication)   . . . . . . . . . . . 125                 
                                                               
+ (Plus, Binary)   . . . . . . . . . . . . 123                 
+ (Plus, Unary)  . . . . . . . . . . . . . 124                 
                                                               
- (Minus, Binary)  . . . . . . . . . . . . 124                 
- (Minus, Unary)   . . . . . . . . . . . . 124                 
                                                               
. (Structure-Field Reference)  . . . . . . 126                 
.186   . . . . . . . . . . . . . . . . . . 111                 
.286   . . . . . . . . . . . . . . . . . . 111                 
.287   . . . . . . . . . . . . . . . . . . 111                 
.8086  . . . . . . . . . . . . . . . . . . 111                 
.8087  . . . . . . . . . . . . . . . . . . 112                 
.ALPHA   . . . . . . . . . . . . . . . . . 116                 
.CODE  . . . . . . . . . . . . . . . . . . 118                 
.CONST   . . . . . . . . . . . . . . . . . 120                 
.DATA  . . . . . . . . . . . . . . . . . . 119                 
.DATA?   . . . . . . . . . . . . . . . . . 120                 
.ERR   . . . . . . . . . . . . . . . . . . 91                  
.ERR1/.ERR2  . . . . . . . . . . . . . . . 91                  
.ERRB/.ERRNB   . . . . . . . . . . . . . . 92                  
.ERRDEF/.ERRNDEF   . . . . . . . . . . . . 92                  
.ERRDIF/.ERRIDN  . . . . . . . . . . . . . 92                  
.ERRE/.ERRNZ   . . . . . . . . . . . . . . 91                  
.FARDATA   . . . . . . . . . . . . . . . . 120                 
.FARDATA?  . . . . . . . . . . . . . . . . 121                 
.LALL  . . . . . . . . . . . . . . . . . . 101                 
.LFCOND  . . . . . . . . . . . . . . . . . 100                 
.LIST  . . . . . . . . . . . . . . . . . . 100                 
.MODEL   . . . . . . . . . . . . . . . . . 117                 
.RADIX   . . . . . . . . . . . . . . . . . 108                 
.SALL  . . . . . . . . . . . . . . . . . . 101                 
.SEQ   . . . . . . . . . . . . . . . . . . 116                 
.SFCOND  . . . . . . . . . . . . . . . . . 100                 
.STACK   . . . . . . . . . . . . . . . . . 119                 
.STARTUP   . . . . . . . . . . . . . . . . 118                 
.TFCOND  . . . . . . . . . . . . . . . . . 101                 
.TYPE  . . . . . . . . . . . . . . . . . . 137                 
.XALL  . . . . . . . . . . . . . . . . . . 101                 
                           MASM 5.1                            
.XLIST   . . . . . . . . . . . . . . . . . 100                 
/ (Division)   . . . . . . . . . . . . . . 125                 
; (Comment Delimeter)  . . . . . . . . . . 141                 
;; (Macro Comment Delimeter)   . . . . . . 127                 
<> (Literal Text Operator)   . . . . . . . 127                 
? (Uninitialized Value)  . . . . . . . . . 142                 
AAA  . . . . . . . . . . . . . . . . . . . 20                  
AAD  . . . . . . . . . . . . . . . . . . . 22                  
AAM  . . . . . . . . . . . . . . . . . . . 21                  
AAS  . . . . . . . . . . . . . . . . . . . 21                  
AddLong  . . . . . . . . . . . . . . . . . 12                  
ADC  . . . . . . . . . . . . . . . . . . . 13                  
ADD  . . . . . . . . . . . . . . . . . . . 12                  
ALIGN  . . . . . . . . . . . . . . . . . . 95                  
AND  . . . . . . . . . . . . . . . . . . . 65, 129             
ASSUME   . . . . . . . . . . . . . . . . . 114                 
CALL   . . . . . . . . . . . . . . . . . . 38                  
CBW  . . . . . . . . . . . . . . . . . . . 84                  
CLC  . . . . . . . . . . . . . . . . . . . 55                  
CLD  . . . . . . . . . . . . . . . . . . . 57                  
CLI  . . . . . . . . . . . . . . . . . . . 58                  
CMC  . . . . . . . . . . . . . . . . . . . 59                  
CMP  . . . . . . . . . . . . . . . . . . . 26                  
CMPS   . . . . . . . . . . . . . . . . . . 29, 81              
CMPSB  . . . . . . . . . . . . . . . . . . 29, 81              
CMPSW  . . . . . . . . . . . . . . . . . . 29, 81              
COMM   . . . . . . . . . . . . . . . . . . 109                 
COMMENT  . . . . . . . . . . . . . . . . . 106                 
CWD  . . . . . . . . . . . . . . . . . . . 85                  
DAA  . . . . . . . . . . . . . . . . . . . 22                  
DAS  . . . . . . . . . . . . . . . . . . . 23                  
DB   . . . . . . . . . . . . . . . . . . . 96                  
DD   . . . . . . . . . . . . . . . . . . . 98                  
DEC  . . . . . . . . . . . . . . . . . . . 16                  
DIV  . . . . . . . . . . . . . . . . . . . 19                  
DisableCGA   . . . . . . . . . . . . . . . 59                  
DOSSEG   . . . . . . . . . . . . . . . . . 115                 
DQ   . . . . . . . . . . . . . . . . . . . 98                  
DT   . . . . . . . . . . . . . . . . . . . 99                  
DUP  . . . . . . . . . . . . . . . . . . . 142                 
DW   . . . . . . . . . . . . . . . . . . . 98                  
END  . . . . . . . . . . . . . . . . . . . 107                 
ENDM   . . . . . . . . . . . . . . . . . . 103                 
ENDP   . . . . . . . . . . . . . . . . . . 94                  
ENDS   . . . . . . . . . . . . . . . . . . 114, 122            
ENTER  . . . . . . . . . . . . . . . . . . 43                  
EQ   . . . . . . . . . . . . . . . . . . . 139                 
ESC  . . . . . . . . . . . . . . . . . . . 73                  
EVEN   . . . . . . . . . . . . . . . . . . 95                  
EXIT   . . . . . . . . . . . . . . . . . . 118                 
EXITM  . . . . . . . . . . . . . . . . . . 104                 
EXTRN  . . . . . . . . . . . . . . . . . . 109                 
FindNext   . . . . . . . . . . . . . . . . 177                 
                           MASM 5.1                            
                                                               
                                                               
Flags  . . . . . . . . . . . . . . . . . . 149                 
                                                               
GetMem   . . . . . . . . . . . . . . . . . 331                 
GE   . . . . . . . . . . . . . . . . . . . 140                 
GetVidConfig   . . . . . . . . . . . . . . 237                 
GROUP  . . . . . . . . . . . . . . . . . . 114                 
GT   . . . . . . . . . . . . . . . . . . . 140                 
                                                               
HELLOM.ASM   . . . . . . . . . . . . . . . 39                  
HIGH   . . . . . . . . . . . . . . . . . . 134                 
HLT  . . . . . . . . . . . . . . . . . . . 75                  
                                                               
IDIV   . . . . . . . . . . . . . . . . . . 19                  
IF   . . . . . . . . . . . . . . . . . . . 88                  
IF1  . . . . . . . . . . . . . . . . . . . 88                  
IFB  . . . . . . . . . . . . . . . . . . . 89                  
IFDEF  . . . . . . . . . . . . . . . . . . 89                  
IFDIF  . . . . . . . . . . . . . . . . . . 90                  
IMUL   . . . . . . . . . . . . . . . . . . 17                  
Int 10H Function 00H   . . . . . . . . . . 236                 
Int 10H Function 01H   . . . . . . . . . . 239                 
Int 10H Function 02H   . . . . . . . . . . 240                 
Int 10H Function 03H   . . . . . . . . . . 242                 
Int 10H Function 04H   . . . . . . . . . . 242                 
Int 10H Function 05H   . . . . . . . . . . 243                 
Int 10H Function 06H   . . . . . . . . . . 243                 
Int 10H Function 07H   . . . . . . . . . . 244                 
Int 10H Function 08H   . . . . . . . . . . 244                 
Int 10H Function 09H   . . . . . . . . . . 245                 
Int 10H Function 0AH   . . . . . . . . . . 246                 
Int 10H Function 0BH   . . . . . . . . . . 249                 
Int 10H Function 0CH   . . . . . . . . . . 250                 
Int 10H Function 0DH   . . . . . . . . . . 250                 
Int 10H Function 0EH   . . . . . . . . . . 247                 
Int 10H Function 0FH   . . . . . . . . . . 247                 
Int 10H Function 10H Subfunction 00H   . . 256                 
Int 10H Function 10H Subfunction 01H   . . 257                 
Int 10H Function 10H Subfunction 02H   . . 257                 
Int 10H Function 10H Subfunction 03H   . . 258                 
Int 10H Function 10H Subfunction 07H   . . 258                 
Int 10H Function 10H Subfunction 08H   . . 259                 
Int 10H Function 10H Subfunction 09H   . . 259                 
Int 10H Function 10H Subfunction 10H   . . 259, 260            
Int 10H Function 10H Subfunction 12H   . . 260                 
Int 10H Function 10H Subfunction 13H   . . 260                 
Int 10H Function 10H Subfunction 15H   . . 261                 
Int 10H Function 10H Subfunction 17H   . . 261                 
Int 10H Function 10H Subfunction 1AH   . . 262                 
Int 10H Function 10H Subfunction 1BH   . . 262                 
Int 10H Function 11H Subfunction 00H/10H   263                 
Int 10H Function 11H Subfunction 01H/11H   265                 
Int 10H Function 11H Subfunction 02H/12H   266                 
Int 10H Function 11H Subfunction 03H   . . 267                 
Int 10H Function 11H Subfunction 04H   . . 267                 
Int 10H Function 11H Subfunction 14H   . . 268                 
Int 10H Function 11H Subfunction 20H   . . 269                 
Int 10H Function 11H Subfunction 21H   . . 269                 
Int 10H Function 11H Subfunction 22H   . . 270                 
Int 10H Function 11H Subfunction 23H   . . 270                 
Int 10H Function 11H Subfunction 24H   . . 271                 
Int 10H Function 11H Subfunction 30H   . . 271                 
Int 10H Function 12H Subfunction 10H   . . 272                 
                           MASM 5.1                            
Int 10H Function 12H Subfunction 20H   . . 273                 
Int 10H Function 12H Subfunction 30H   . . 273                 
Int 10H Function 12H Subfunction 31H   . . 273                 
Int 10H Function 12H Subfunction 32H   . . 274                 
Int 10H Function 12H Subfunction 33H   . . 274                 
Int 10H Function 12H Subfunction 34H   . . 274                 
Int 10H Function 12H Subfunction 35H   . . 275                 
Int 10H Function 12H Subfunction 36H   . . 275                 
Int 10H Function 13H   . . . . . . . . . . 248                 
Int 10H Function 1AH   . . . . . . . . . . 251                 
Int 10H Function 1BH   . . . . . . . . . . 251                 
Int 10H Function 1CH   . . . . . . . . . . 255                 
Int 11H  . . . . . . . . . . . . . . . . . 329                 
Int 12H  . . . . . . . . . . . . . . . . . 331                 
Int 13H Function 00H   . . . . . . . . . . 277                 
Int 13H Function 01H   . . . . . . . . . . 277                 
Int 13H Function 02H   . . . . . . . . . . 278                 
Int 13H Function 03H   . . . . . . . . . . 279                 
Int 13H Function 04H   . . . . . . . . . . 279                 
Int 13H Function 05H   . . . . . . . . . . 280                 
Int 13H Function 06H   . . . . . . . . . . 281                 
Int 13H Function 07H   . . . . . . . . . . 281                 
Int 13H Function 08H   . . . . . . . . . . 282                 
Int 13H Function 09H   . . . . . . . . . . 282                 
Int 13H Function 0AH   . . . . . . . . . . 284                 
Int 13H Function 0BH   . . . . . . . . . . 284                 
Int 13H Function 0CH   . . . . . . . . . . 285                 
Int 13H Function 0DH   . . . . . . . . . . 285                 
Int 13H Function 0EH   . . . . . . . . . . 285                 
Int 13H Function 0FH   . . . . . . . . . . 286                 
Int 13H Function 10H   . . . . . . . . . . 286                 
Int 13H Function 11H   . . . . . . . . . . 287                 
Int 13H Function 12H   . . . . . . . . . . 287                 
Int 13H Function 13H   . . . . . . . . . . 288                 
Int 13H Function 14H   . . . . . . . . . . 288                 
Int 13H Function 15H   . . . . . . . . . . 288                 
Int 13H Function 16H   . . . . . . . . . . 289                 
Int 13H Function 17H   . . . . . . . . . . 289                 
Int 13H Function 18H   . . . . . . . . . . 290                 
Int 13H Function 19H   . . . . . . . . . . 290                 
Int 13H Function 1AH   . . . . . . . . . . 291                 
Int 14H Function 00H   . . . . . . . . . . 292                 
Int 14H Function 01H   . . . . . . . . . . 293                 
Int 14H Function 02H   . . . . . . . . . . 294                 
Int 14H Function 03H   . . . . . . . . . . 294                 
Int 14H Function 04H   . . . . . . . . . . 295                 
Int 14H Function 05H   . . . . . . . . . . 296                 
Int 15H Function 00H   . . . . . . . . . . 297                 
Int 15H Function 01H   . . . . . . . . . . 297                 
Int 15H Function 02H   . . . . . . . . . . 298                 
Int 15H Function 03H   . . . . . . . . . . 298                 
Int 15H Function 0FH   . . . . . . . . . . 299                 
Int 15H Function 21H Subfunction 00H   . . 299                 
Int 15H Function 21H Subfunction 01H   . . 300                 
Int 15H Function 4FH   . . . . . . . . . . 300                 
Int 15H Function 80H   . . . . . . . . . . 301                 
Int 15H Function 81H   . . . . . . . . . . 301                 
Int 15H Function 82H   . . . . . . . . . . 302                 
Int 15H Function 83H   . . . . . . . . . . 302                 
Int 15H Function 84H   . . . . . . . . . . 303                 
Int 15H Function 85H   . . . . . . . . . . 304                 
Int 15H Function 86H   . . . . . . . . . . 304                 
                           MASM 5.1                            
                                                               
                                                               
Int 15H Function 87H   . . . . . . . . . . 305                 
Int 15H Function 88H   . . . . . . . . . . 306                 
Int 15H Function 89H   . . . . . . . . . . 306                 
Int 15H Function 90H   . . . . . . . . . . 307                 
Int 15H Function 91H   . . . . . . . . . . 308                 
Int 15H Function C0H   . . . . . . . . . . 308                 
Int 15H Function C1H   . . . . . . . . . . 309                 
Int 15H Function C2H Subfunction 00H   . . 311                 
Int 15H Function C2H Subfunction 01H   . . 312                 
Int 15H Function C2H Subfunction 02H   . . 312                 
Int 15H Function C2H Subfunction 03H   . . 313                 
Int 15H Function C2H Subfunction 04H   . . 313                 
Int 15H Function C2H Subfunction 05H   . . 313                 
Int 15H Function C2H Subfunction 06H   . . 314                 
Int 15H Function C2H Subfunction 07H   . . 315                 
Int 15H Function C3H   . . . . . . . . . . 310                 
Int 15H Function C4H   . . . . . . . . . . 310                 
Int 16H Function 00H   . . . . . . . . . . 316                 
Int 16H Function 01H   . . . . . . . . . . 318                 
Int 16H Function 02H   . . . . . . . . . . 318                 
Int 16H Function 03H   . . . . . . . . . . 319                 
Int 16H Function 04H   . . . . . . . . . . 320                 
Int 16H Function 05H   . . . . . . . . . . 320                 
Int 16H Function 10H   . . . . . . . . . . 321                 
Int 16H Function 11H   . . . . . . . . . . 321                 
IN   . . . . . . . . . . . . . . . . . . . 70                  
Int 16H Function 12H   . . . . . . . . . . 321                 
Int 17H Function 00H   . . . . . . . . . . 322                 
Int 17H Function 01H   . . . . . . . . . . 323                 
Int 17H Function 02H   . . . . . . . . . . 323                 
INC  . . . . . . . . . . . . . . . . . . . 14                  
INCLUDE  . . . . . . . . . . . . . . . . . 107                 
INCLUDELIB   . . . . . . . . . . . . . . . 107, 110            
INS  . . . . . . . . . . . . . . . . . . . 71                  
Int 18H  . . . . . . . . . . . . . . . . . 332                 
Int 19H  . . . . . . . . . . . . . . . . . 332                 
Int 1AH Function 00H   . . . . . . . . . . 324                 
Int 1AH Function 01H   . . . . . . . . . . 326                 
Int 1AH Function 02H   . . . . . . . . . . 326                 
Int 1AH Function 03H   . . . . . . . . . . 326                 
Int 1AH Function 04H   . . . . . . . . . . 327                 
Int 1AH Function 05H   . . . . . . . . . . 327                 
Int 1AH Function 06H   . . . . . . . . . . 328                 
Int 1AH Function 07H   . . . . . . . . . . 328                 
Int 1AH Function 0AH   . . . . . . . . . . 328                 
Int 1AH Function 0BH   . . . . . . . . . . 329                 
Int 1AH Function 80H   . . . . . . . . . . 329                 
Int 21H Function 00H   . . . . . . . . . . 209                 
Int 21H Function 01H   . . . . . . . . . . 153                 
Int 21H Function 02H   . . . . . . . . . . 154                 
Int 21H Function 03H   . . . . . . . . . . 156                 
Int 21H Function 04H   . . . . . . . . . . 156                 
Int 21H Function 05H   . . . . . . . . . . 157                 
Int 21H Function 06H   . . . . . . . . . . 157                 
Int 21H Function 07H   . . . . . . . . . . 158                 
Int 21H Function 08H   . . . . . . . . . . 159                 
Int 21H Function 09H   . . . . . . . . . . 159                 
Int 21H Function 0AH   . . . . . . . . . . 160                 
Int 21H Function 0BH   . . . . . . . . . . 161                 
Int 21H Function 0CH   . . . . . . . . . . 161                 
Int 21H Function 0DH   . . . . . . . . . . 165                 
Int 21H Function 0EH   . . . . . . . . . . 165                 
                           MASM 5.1                            
Int 21H Function 0FH   . . . . . . . . . . 183                 
Int 21H Function 10H   . . . . . . . . . . 183                 
Int 21H Function 11H   . . . . . . . . . . 184                 
Int 21H Function 12H   . . . . . . . . . . 185                 
Int 21H Function 13H   . . . . . . . . . . 185                 
Int 21H Function 14H   . . . . . . . . . . 222                 
Int 21H Function 15H   . . . . . . . . . . 223                 
Int 21H Function 16H   . . . . . . . . . . 186                 
Int 21H Function 17H   . . . . . . . . . . 187                 
Int 21H Function 19H   . . . . . . . . . . 166                 
Int 21H Function 1AH   . . . . . . . . . . 215                 
Int 21H Function 1BH   . . . . . . . . . . 166                 
Int 21H Function 1CH   . . . . . . . . . . 167                 
Int 21H Function 21H   . . . . . . . . . . 224                 
Int 21H Function 22H   . . . . . . . . . . 224                 
Int 21H Function 23H   . . . . . . . . . . 187                 
Int 21H Function 24H   . . . . . . . . . . 225, 226            
Int 21H Function 25H   . . . . . . . . . . 192                 
Int 21H Function 26H   . . . . . . . . . . 210                 
Int 21H Function 27H   . . . . . . . . . . 226                 
Int 21H Function 28H   . . . . . . . . . . 227                 
Int 21H Function 29H   . . . . . . . . . . 188                 
Int 21H Function 2AH   . . . . . . . . . . 228                 
Int 21H Function 2BH   . . . . . . . . . . 229                 
Int 21H Function 2CH   . . . . . . . . . . 229                 
Int 21H Function 2DH   . . . . . . . . . . 229                 
Int 21H Function 2EH   . . . . . . . . . . 168                 
Int 21H Function 2FH   . . . . . . . . . . 216                 
Int 21H Function 30H   . . . . . . . . . . 195                 
Int 21H Function 31H   . . . . . . . . . . 210                 
Int 21H Function 33H   . . . . . . . . . . 195                 
Int 21H Function 35H   . . . . . . . . . . 196                 
Int 21H Function 36H   . . . . . . . . . . 168                 
Int 21H Function 38H   . . . . . . . . . . 196                 
Int 21H Function 39H   . . . . . . . . . . 162                 
Int 21H Function 3AH   . . . . . . . . . . 163                 
Int 21H Function 3BH   . . . . . . . . . . 163                 
Int 21H Function 3CH   . . . . . . . . . . 170                 
Int 21H Function 3DH   . . . . . . . . . . 171                 
Int 21H Function 3EH   . . . . . . . . . . 171                 
Int 21H Function 3FH   . . . . . . . . . . 217                 
Int 21H Function 40H   . . . . . . . . . . 218                 
Int 21H Function 41H   . . . . . . . . . . 172                 
Int 21H Function 42H   . . . . . . . . . . 219                 
Int 21H Function 43H   . . . . . . . . . . 173                 
Int 21H Function 44H   . . . . . . . . . . 198                 
Int 21H Function 45H   . . . . . . . . . . 173, 174            
Int 21H Function 46H   . . . . . . . . . . 174                 
Int 21H Function 47H   . . . . . . . . . . 164                 
Int 21H Function 48H   . . . . . . . . . . 190                 
Int 21H Function 49H   . . . . . . . . . . 190                 
Int 21H Function 4AH   . . . . . . . . . . 191                 
Int 21H Function 4BH   . . . . . . . . . . 212                 
Int 21H Function 4CH   . . . . . . . . . . 213                 
Int 21H Function 4DH   . . . . . . . . . . 214                 
Int 21H Function 4EH   . . . . . . . . . . 175                 
Int 21H Function 4FH   . . . . . . . . . . 176                 
Int 21H Function 54H   . . . . . . . . . . 169                 
Int 21H Function 56H   . . . . . . . . . . 178                 
Int 21H Function 57H   . . . . . . . . . . 179                 
Int 21H Function 58H   . . . . . . . . . . 191                 
Int 21H Function 59H   . . . . . . . . . . 199                 
                           MASM 5.1                            
                                                               
                                                               
Int 21H Function 5AH   . . . . . . . . . . 179                 
Int 21H Function 5BH   . . . . . . . . . . 180                 
Int 21H Function 5CH   . . . . . . . . . . 219, 220            
Int 21H Function 5EH Subfunction 00H   . . 201                 
Int 21H Function 5EH Subfunction 02H   . . 201                 
Int 21H Function 5EH Subfunction 03H   . . 202                 
Int 21H Function 5FH Subfunction 02H   . . 203                 
Int 21H Function 5FH Subfunction 03H   . . 204                 
Int 21H Function 5FH Subfunction 04H   . . 204                 
Int 21H Function 62H   . . . . . . . . . . 215                 
Int 21H Function 63H   . . . . . . . . . . 205                 
INSB   . . . . . . . . . . . . . . . . . . 71                  
Int 21H Function 65H   . . . . . . . . . . 206                 
INSW   . . . . . . . . . . . . . . . . . . 71                  
Int 21H Function 66H   . . . . . . . . . . 208                 
Int 21H Function 67H   . . . . . . . . . . 182                 
Int 21H Function 68H   . . . . . . . . . . 221                 
Interrupt 15H (Mouse Pointer)  . . . . . . 311                 
Interrupt 20H  . . . . . . . . . . . . . . 231                 
Interrupt 21H, Function 5EH                                    
(Machine/Printer)  . . . . . . . . . . . . 201                 
INT  . . . . . . . . . . . . . . . . . . . 41                  
Interrupt 21H, Function 5FH (Device                            
Redirection)   . . . . . . . . . . . . . . 203                 
Interrupt 25H  . . . . . . . . . . . . . . 232                 
Interrupt 26H  . . . . . . . . . . . . . . 233                 
Interrupt 27H  . . . . . . . . . . . . . . 234                 
Interrupt 2FH  . . . . . . . . . . . . . . 235                 
IntToAsc   . . . . . . . . . . . . . . . . 21                  
IRET   . . . . . . . . . . . . . . . . . . 42                  
IRP  . . . . . . . . . . . . . . . . . . . 105                 
IRPC   . . . . . . . . . . . . . . . . . . 105                 
                                                               
JA   . . . . . . . . . . . . . . . . . . . 34                  
JAE  . . . . . . . . . . . . . . . . . . . 34                  
JB   . . . . . . . . . . . . . . . . . . . 34                  
JBE  . . . . . . . . . . . . . . . . . . . 34                  
JC   . . . . . . . . . . . . . . . . . . . 34                  
JCXZ/JECXZ   . . . . . . . . . . . . . . . 34                  
JE   . . . . . . . . . . . . . . . . . . . 34                  
JG   . . . . . . . . . . . . . . . . . . . 34                  
JGE  . . . . . . . . . . . . . . . . . . . 34                  
JL   . . . . . . . . . . . . . . . . . . . 34                  
JLE  . . . . . . . . . . . . . . . . . . . 34                  
JMP  . . . . . . . . . . . . . . . . . . . 32                  
JNA  . . . . . . . . . . . . . . . . . . . 34                  
JNAE   . . . . . . . . . . . . . . . . . . 34                  
JNB  . . . . . . . . . . . . . . . . . . . 34                  
JNBE   . . . . . . . . . . . . . . . . . . 34                  
JNC  . . . . . . . . . . . . . . . . . . . 34                  
JNE  . . . . . . . . . . . . . . . . . . . 34                  
JNG  . . . . . . . . . . . . . . . . . . . 34                  
JNGE   . . . . . . . . . . . . . . . . . . 34                  
JNL  . . . . . . . . . . . . . . . . . . . 34                  
JNLE   . . . . . . . . . . . . . . . . . . 34                  
JNO  . . . . . . . . . . . . . . . . . . . 34                  
JNP  . . . . . . . . . . . . . . . . . . . 34                  
JNS  . . . . . . . . . . . . . . . . . . . 34                  
JNZ  . . . . . . . . . . . . . . . . . . . 34                  
JO   . . . . . . . . . . . . . . . . . . . 34                  
JP   . . . . . . . . . . . . . . . . . . . 34                  
JPE  . . . . . . . . . . . . . . . . . . . 34                  
                           MASM 5.1                            
JPO  . . . . . . . . . . . . . . . . . . . 34                  
JS   . . . . . . . . . . . . . . . . . . . 34                  
JZ   . . . . . . . . . . . . . . . . . . . 34                  
Keyboard Scan Codes  . . . . . . . . . . . 150                 
LABEL  . . . . . . . . . . . . . . . . . . 95                  
LAHF   . . . . . . . . . . . . . . . . . . 62                  
LDS  . . . . . . . . . . . . . . . . . . . 52                  
LE   . . . . . . . . . . . . . . . . . . . 141                 
LEA  . . . . . . . . . . . . . . . . . . . 51                  
LEAVE  . . . . . . . . . . . . . . . . . . 43                  
LES  . . . . . . . . . . . . . . . . . . . 52                  
LoadPtr  . . . . . . . . . . . . . . . . . 52                  
LOCAL (in macros)  . . . . . . . . . . . . 104                 
LOCK   . . . . . . . . . . . . . . . . . . 74                  
LODS   . . . . . . . . . . . . . . . . . . 49, 80              
LODSB  . . . . . . . . . . . . . . . . . . 49, 80              
LODSW  . . . . . . . . . . . . . . . . . . 49, 80              
LOOP   . . . . . . . . . . . . . . . . . . 37                  
LOOPE  . . . . . . . . . . . . . . . . . . 38                  
LOOPNE   . . . . . . . . . . . . . . . . . 38                  
LOW  . . . . . . . . . . . . . . . . . . . 135                 
LT   . . . . . . . . . . . . . . . . . . . 140                 
MACRO  . . . . . . . . . . . . . . . . . . 103                 
MASK   . . . . . . . . . . . . . . . . . . 133                 
MOD  . . . . . . . . . . . . . . . . . . . 125                 
MOV  . . . . . . . . . . . . . . . . . . . 44                  
MOVS   . . . . . . . . . . . . . . . . . . 45, 79              
MOVSB  . . . . . . . . . . . . . . . . . . 45, 79              
MOVSW  . . . . . . . . . . . . . . . . . . 45, 79              
MUL  . . . . . . . . . . . . . . . . . . . 18                  
NE   . . . . . . . . . . . . . . . . . . . 139                 
NEG  . . . . . . . . . . . . . . . . . . . 17                  
NOP  . . . . . . . . . . . . . . . . . . . 73                  
NOT  . . . . . . . . . . . . . . . . . . . 69, 131             
OFFSET   . . . . . . . . . . . . . . . . . 138                 
OR   . . . . . . . . . . . . . . . . . . . 67, 129             
ORG  . . . . . . . . . . . . . . . . . . . 96                  
OUT  . . . . . . . . . . . . . . . . . . . 72                  
OUTS   . . . . . . . . . . . . . . . . . . 72                  
OUTSB  . . . . . . . . . . . . . . . . . . 72                  
OUTSW  . . . . . . . . . . . . . . . . . . 72                  
PAGE   . . . . . . . . . . . . . . . . . . 102                 
PopAll   . . . . . . . . . . . . . . . . . 78                  
POP  . . . . . . . . . . . . . . . . . . . 77                  
POPA   . . . . . . . . . . . . . . . . . . 78                  
POPF   . . . . . . . . . . . . . . . . . . 61                  
PROC   . . . . . . . . . . . . . . . . . . 93                  
PSP  . . . . . . . . . . . . . . . . . . . 151                 
PTR  . . . . . . . . . . . . . . . . . . . 135                 
PUBLIC   . . . . . . . . . . . . . . . . . 109                 
PURGE  . . . . . . . . . . . . . . . . . . 104                 
PUSH   . . . . . . . . . . . . . . . . . . 75                  
PUSHA  . . . . . . . . . . . . . . . . . . 77                  
PUSHF  . . . . . . . . . . . . . . . . . . 61                  
RCL  . . . . . . . . . . . . . . . . . . . 24                  
                           MASM 5.1                            
                                                               
                                                               
RCR  . . . . . . . . . . . . . . . . . . . 24                  
RECORD   . . . . . . . . . . . . . . . . . 121                 
REP  . . . . . . . . . . . . . . . . . . . 82                  
REPE   . . . . . . . . . . . . . . . . . . 83                  
REPNE  . . . . . . . . . . . . . . . . . . 83                  
REPT   . . . . . . . . . . . . . . . . . . 105                 
RET  . . . . . . . . . . . . . . . . . . . 40                  
ReadCharAttr   . . . . . . . . . . . . . . 245                 
Register   . . . . . . . . . . . . . . . . 149                 
RETF   . . . . . . . . . . . . . . . . . . 40                  
RETN   . . . . . . . . . . . . . . . . . . 40                  
Register Setup   . . . . . . . . . . . . . 150                 
ROL  . . . . . . . . . . . . . . . . . . . 24                  
ROR  . . . . . . . . . . . . . . . . . . . 24                  
                                                               
SAHF   . . . . . . . . . . . . . . . . . . 63                  
SAL  . . . . . . . . . . . . . . . . . . . 25                  
SAL/SAR/SHL/SHR  . . . . . . . . . . . . . 131                 
SAR  . . . . . . . . . . . . . . . . . . . 25                  
SBB  . . . . . . . . . . . . . . . . . . . 15                  
SCAS   . . . . . . . . . . . . . . . . . . 81                  
SCASB  . . . . . . . . . . . . . . . . . . 81                  
SCASW  . . . . . . . . . . . . . . . . . . 81                  
SEG  . . . . . . . . . . . . . . . . . . . 138                 
SetCurPos  . . . . . . . . . . . . . . . . 241                 
SetCurSize   . . . . . . . . . . . . . . . 240                 
SEGMENT  . . . . . . . . . . . . . . . . . 112                 
SHL  . . . . . . . . . . . . . . . . . . . 25                  
SHORT  . . . . . . . . . . . . . . . . . . 135                 
SHR  . . . . . . . . . . . . . . . . . . . 25                  
SIZE   . . . . . . . . . . . . . . . . . . 136                 
Sound  . . . . . . . . . . . . . . . . . . 70                  
String Operations  . . . . . . . . . . . . 78                  
STC  . . . . . . . . . . . . . . . . . . . 60                  
STD  . . . . . . . . . . . . . . . . . . . 60                  
STI  . . . . . . . . . . . . . . . . . . . 60                  
STOS   . . . . . . . . . . . . . . . . . . 50, 80              
STOSB  . . . . . . . . . . . . . . . . . . 50, 80              
STOSW  . . . . . . . . . . . . . . . . . . 50, 80              
STRUC  . . . . . . . . . . . . . . . . . . 122                 
SUB  . . . . . . . . . . . . . . . . . . . 14                  
SUBTTL   . . . . . . . . . . . . . . . . . 102                 
SubLong  . . . . . . . . . . . . . . . . . 16                  
                                                               
TEST   . . . . . . . . . . . . . . . . . . 30                  
THIS   . . . . . . . . . . . . . . . . . . 136                 
TITLE  . . . . . . . . . . . . . . . . . . 102                 
Type Operator Summary  . . . . . . . . . . 134                 
TYPE   . . . . . . . . . . . . . . . . . . 137                 
                                                               
VeriAnsi   . . . . . . . . . . . . . . . . 51                  
VeriCop  . . . . . . . . . . . . . . . . . 330                 
                                                               
WAIT   . . . . . . . . . . . . . . . . . . 74                  
WinOpen  . . . . . . . . . . . . . . . . . 46                  
WIDTH  . . . . . . . . . . . . . . . . . . 134                 
                                                               
XCHG   . . . . . . . . . . . . . . . . . . 48                  
XLAT   . . . . . . . . . . . . . . . . . . 53                  
XLATB  . . . . . . . . . . . . . . . . . . 53                  
XOR  . . . . . . . . . . . . . . . . . . . 68, 130             
                                                               
                           MASM 5.1                            
[] (Index Operator)  . . . . . . . . . . . 126                 
\ (Line Continutation)   . . . . . . . . . 142                 
                                                               
                                                               
                                                               
                                                               
                                                               
                                                               
