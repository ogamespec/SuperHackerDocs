                                   Оглавление                                  
       Windows 3.0/Ref/7#7                                        = 1 =

       Глава 12. УПРАВЛЯЮЩИЕ ПОСЛЕДОВАТЕЛЬНОСТИ ДЛЯ ПРИНТЕРА..........4
       ABORTDOC.......................................................5
       BANDINFO.......................................................6
       BEGIN_PATH.....................................................9
       CLIP_TO_PATH..................................................11
       DEVICEDATA....................................................13
       DRAFTMODE.....................................................13
       DRAWPATTERNRECT...............................................14
       ENABLEDUPLEX..................................................16
       ENABLEPAIRKERNING.............................................17
       ENABLERELATIVEWIDTHS..........................................18
       ENDDOC........................................................19
       END_PATH......................................................19
       ENUMPAPERBINS.................................................22
       ENUMPAPERMETRICS..............................................23
       EPSPRINTING...................................................24
       EXT_DEVICE_CAPS...............................................24
       EXTTEXTOUT....................................................26
       FLUSHOUTPUT...................................................29
       GETCOLORTABLE.................................................30
       GETEXTENDEDTEXTMETRICS........................................30
       GETEXTENTTABLE................................................34
       GETFACENAME...................................................36
       GETPAIRKERNTABLE..............................................36
       GETPHYSPAGESIZE...............................................38
       GETPRINTINGOFFSET.............................................38
       GETSCALINGFACTOR..............................................39
       GETSETPAPERBINS...............................................39
       GETSETPAPERMETRICS............................................41
       GETSETPAPERORIENT.............................................42
       GETSETSCREENPARAMS............................................43
       GETTECHNOLOGY.................................................45
       GETTRACKKERNTABLE.............................................45
       GETVECTORBRUSHSIZE............................................47
       GETVECTORPENSIZE..............................................47
       MFCOMMENT.....................................................49
       NEWFRAME......................................................50
       NEXTBAND......................................................51
       PASSTROUGH....................................................53
       QUERYESCSUPPORT...............................................54
       RESTORE_CTM...................................................55
       SAVE_CTM......................................................56
       SELECTPAPERSOURCE.............................................56
       SETALLJUSTVALUES..............................................58
       SET_ARC_DIRECTION.............................................60
       SET_BACKGROUND_COLOR..........................................60
       SET_BOUNDS....................................................61
       SETCOLORTABLE.................................................62
       SETCOPYCOUNT..................................................64
       SETKERNTRACK..................................................65
       SETLINECAP....................................................66
       SETLINEJOIN...................................................67
       SETMITERLIMIT.................................................68

       Windows 3.0/Ref/7#7                                        = 2 =

       SET_POLY_MODE.................................................69
       SET_SCREEN_ANGLE..............................................72
       SET_SPREAD....................................................73
       STARTDOC......................................................73
       TRANSFORM_CTM.................................................76
       Глава 13. ОБЗОР МАКРОКОМАНД ЯЗЫКА АССЕМБЛЕРА..................77
       13.1 Советы  по  созданию прикладных программ  для Windows
            на языке ассемблера......................................78
       13.1.1 Выбор модели памяти....................................78
       13.1.2 Соглашения по вызову...................................79
       13.1.3 Параметр  разрешения   инициализации/завершения   в....80
       13.1.4 Включение файла CMACROS.INC............................81
       13.1.5 Создание точки входа в прикладную программу............81
       13.1.6 Объявление Функций многократного вызова................81
       13.1.7 Компановка с библиотеками..............................82
       13.1.8 Контроль стека.........................................82
       13.2 Группа макрокоманд C.....................................83
       13.2.1 Макрокоманды работы с сегментами.......................83
       13.2.2 Макрокоманды распределения памяти......................84
       13.2.3 Макрокоманды работы с функциями........................85
       13.2.4 Макрокоманды вызова....................................85
       13.2.5 Специальные макрокоманды определения...................86
       13.2.6 Макрокоманды обработки ошибок..........................87
       13.3 Использование Cmacros....................................88
       13.3.1 Замена типов...........................................88
       13.3.2 Переопределение символов...............................88
       13.3.3 Cmacros: пример функции................................89
       13.4 Заключение...............................................91
       Глава 14. СПИСОК МАКРОКОМАНД ЯЗЫКА АССЕМБЛЕРА.................92
       Arg...........................................................92
       assumes.......................................................92
       cBegin........................................................93
       cCall.........................................................93
       cEnd..........................................................94
       codeOFFSET....................................................95
       cProc.........................................................95
       createSeg.....................................................96
       dataOFFSET....................................................97
       DefX..........................................................97
       errn$.........................................................98
       errnz.........................................................99
       externX......................................................100
       FarPtr.......................................................100
       globalX......................................................101
       labelX.......................................................102
       localX.......................................................103
       parmX........................................................104
       Save.........................................................105
       sBegin.......................................................105
       segNameOFFSET................................................106
       sEnd.........................................................106
       staticX......................................................107
       Глава 15. ОПРЕДЕЛЕНИЕ  ПРОТОКОЛА  ДИНАМИЧЕСКОГО  ОБМЕНА

       Windows 3.0/Ref/7#7                                        = 3 =

        ДАННЫМИ (DDE)...............................................108
       15.1 Использование набора сообщений DDE......................109
       15.2 Синхронизация диалога DDE...............................111
       15.3 Использование атомов....................................112
       15.4 Использование объектов разделяемой памяти...............113
       15.5 Использование форматов системного буфера................114
       15.6 Использование системного предмета.......................115
       15.7 Список сообщений DDE....................................116
       WM_DDE_ACK...................................................116
       WM_DDE_DATA..................................................120
       WM_DDE_EXECUTE...............................................123
       WM_DDE_INITIATE..............................................124
       WM_DDE_POKE..................................................126
       WM_DDE_REQUEST...............................................128
       WM_DDE_TERMINATE.............................................129
       WM_DDE_UNADVISE..............................................129
       ПРИЛОЖЕНИЯ...................................................131
       Приложение A. Коды виртуальных клавиш........................132
       Приложение B. Диагностические сообщения компилятора      ресурсов.136
       Приложение C. Отладочные сообщения Windows...................148
       Приложение D. Таблицы символов...............................161
       Приложение Е. Динамически-подсоединяемая библиотека
                     Windows для управления 32-битовой памятью......162
       E.1 Сегментная и плоская модели памяти.......................164
       E.2 Использование библиотеки WINMEM32.DLL....................166
       E.3 Некоторые особенности использования 32-ух битовой памяти.168
       E.3.1 Плоская модель под Windows.............................169
       E.3.2 Стек прикладной программы..............................169
       E.3.3 Код обработки прерывания...............................170
       E.3.4 Языки программирования.................................171
       Е.4 Использование 32-ух битовой памяти в прикладных
           программах Windows.......................................172
       Е.4.1 Использование 32-ух битовых объектов данных............172
       E.4.2 Использование 32-ух битового кода и данных в
             библиотечной...........................................172
       E.4.3 Использование 32-ух битового кода и данных в
             основной...............................................173
       E.5 Список функций...........................................174
       GetWinMem32Version                                   [3.0]...174
       Global16PointerAlloc                                 [3.0]...175
       Global16PointerFree                                  [3.0]...176
       Global32Alloc                                        [3.0]...177
       Global32CodeAlias                                    [3.0]...178
       Global32CodeAliasFree                                [3.0]...179
       Global32Free                                         [3.0]...180
       Global32Realloc                                      [3.0]...181
       ПРИМЕР. ПРОСТАЯ программа для WINMEM32 DLL ..................183

       Windows 3.0/Ref/7#7                                        = 4 =

                                                                               
            Глава 12. УПРАВЛЯЮЩИЕ ПОСЛЕДОВАТЕЛЬНОСТИ ДЛЯ ПРИНТЕРА
       ----------------------------------------------------------------

             Эта глава  содержит список управляющих последовательностей
        принтера для  Microsoft  Windows,  расположенных  в  алфавитном
        порядке.    Управляющие    последовательности    для   принтера
        предоставляют  прикладным   программам   возможность   удобного
        доступа  к  устройствам  вывода,  которые  не доступны напрямую
        через средства GDI (интерфейс  графических  устройств).  Вызовы
        управляющих     последовательностей     делаются    прикладными
        программами, воспринимаются системой Windows и затем посылаются
        драйверу принтера.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                        = 5 =

                                         ABORTDOC                              

             Синтаксис    short Escape(hDC, ABORTDOC, NULL, NULL, NULL)

             Эта управляющая  последовательность  прекращает выполнение
        текущей задачи,  стирает все прикладные программы записанные  в
        устройство с   момента   последнего  использования  управляющей
        последовательности ENDDOC.

             Управляющая последовательность   ABORTDOC   должна    быть
        использована для прерывания следующих действий:

             - Операция   печати,   которая   не   определена  функцией
        прерывания, используя       управляющую       последовательость
        SETABORTPROC

             - Операция печати,  для которой еще не было первого вызова
        управляющей последовательности NEWFRAME или NEXTBAND.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Она  будет  положительна,  если выполнение
        последовательности прошло  успешно,  и  отрицательна  во   всех
        остальных случаях.

             Комментарий:

             Если прикладная  программа  сталкивается  с  ошибкой   при
        печати  или  прерывает операцию печати,  она не должна пытаться
        прервать операцию  печати,  используя  функцию  Escape  либо  с
        управляющей  последовательностью  ENDDOC, либо  ABORTDOC.   GDI
        автоматически   прерывает  работу  перед  возвращеним  значения
        ошибки.

             Если прикладная программа отображает  панель  диалога  для
        предоставления пользователю  возможности  аннулировать операцию
        печати, она  должна  послать   управляющую   последовательность
        ABORTDOC перед разрушением панели диалога.

             В любом   случае   прикладная   программа  должна  послать
        управляющую  последовательность  ABORTDOC  перед  освобождением
        адреса экземпляра процедуры функции прерывания.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                        = 6 =

                                         BANDINFO                              

             Синтаксис    short Escape(hDC, BANDINFO,
                                             sizeof(BANDINFOSTRUCT),
                                                    lpInData,lpOutData)

             Эта управляющая последовательность копирует информацию  об
        устройстве  с  поддержкой фрагментации в структуру,  на которую
        указывает параметр  lpOutData.  Это  реализовано   только   для
        устройств, использующих фрагментацию.

             Фрагментация -  это  свойство  устройство вывода,  которое
        позволяет страницу вывода  хранить  в  метафайле  и  делить  на
        фрагменты, каждый из которых посылается на устройство для того,
        чтобы  создать  полную  страницу.

             Информация копируемая  в  структуру,  указанную  lpOutData
        включает:

             - Величину, которая показывает имеет ли следующий фрагмент
               графики

             - Величину, которая показывает есть ли текст на странице

             - Структуру  данных  RECT,  которая  содержит  разбитый на
               фрагменты прямоугольник     для    всего    графического
               изображения на странице

             Если данные   для  возвращения  отсутствуют,  то  параметр
        lpOutData устанавлмвается в NULL.

             Параметр lpOutData   определяет   информацию,   посылаемую
        прикладной   программой  драйверу  устройства.  Эта  информация
        читается  драйвером  устройства  только   при   первом   вызове
        управляющей последовательности BANDINFO для страницы.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства.

             lpInData     BANDINFOSTRUCT FAR*    Указывает на структуру
                          данных BANDINFOSTRUCT,    которая    содержит
                          информацию ,   которая  должна  быть передана
                          драйверу.  Для  дополнительной  информации  о
                          структуре   данных   BANDINFOSTRUCT  смотрите
                          нижеследующий раздел "Комментарий".

             lpOutData    BANDINFOSTRUCT FAR*    Указывает на структуру
                          данных BANDINFOSTRUCT,    которая    содержит
                          информацию , возвращаемую  драйвером.     Для
                          дополнительной информации  о структуре данных
                          BANDINFOSTRUCT смотрите нижеследующий  раздел

       Windows 3.0/Ref/7#7                                        = 7 =

                          "Комментарий".


             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Она будет равна 1 , если выполнение прошло
        успешно,  и равна нулю  если  произошел  сбой  или  функция  не
        ваполнена драйвером.

             Комментарий:

             Структура данный  BANDINFOSTRUCT  содержит  информацию   о
        содержимом страницы,   а   также    разбитый    на    фрагменты
        прямоугольник для  графического  изображения на странице.  Ниже
        приведен формат структуры данных BANDINFOSTRUCT:

             typedef struct {
                   BOOL   fGraphicsFlag;
                   BOOL   fTextFlag;
                   RECT   GraphicsRect;
             } BANDINFOSTRUCT;

             Поля структуры BANDINFOSDTRUCT имеют следующее значение:
             ────────────────────────────────────────────────────────

             Поле         Описание
             ────         ────────
             fGraphicsFlag Равно TRUE  если  есть  графики на странице;
                           во   всех остальных случаях FALSE.

             fTextFlag    Равно TRUE если есть текст на странице; во
                          всех остальных случаях FALSE.

             GraphicsRect Содержит  структуру  данных   RECT,   которая
                          содержит разбитый на полосы прямоугольник для
                          всего графического изображения на странице.

             Таблица 12.1 показывает значения этих полей,  зависящие от
        каждого параметра содержащегося в этой структуре.


        Таблица 12.1             Значения полей структуры BANDIFOSTRUCT
        ───────────────────────────────────────────────────────────────
        Поле           В lpInData               В lpOutData
        ───────────────────────────────────────────────────────────────
        fGraphicsGlag  TRUE  если  прикладная   TRUE     если   драйвер
                       программа     сообщает   сообщает     прикладной
                       драйверу,    что    на   программе,  что  он
                       странице есть графики.   ожидает графики в  этом
                                                фрагменте.

        fTextFlag      TRUE  если  прикладная   TRUE     если   драйвер

       Windows 3.0/Ref/7#7                                        = 8 =

                       программа     сообщает   сообщает     прикладной
                       драйверу,    что    на   программе,     что   он
                       странице есть текст.     ожидает    текст в этом
                                                фрагменте.

        GraphicsRect   Содержит  разбитый  на   Нет возвращаемых данных.
                       полосы   прямоугольник
                       для всего графического
                       изображения на странице.

        ───────────────────────────────────────────────────────────────

             Прикладная программа  должна  вызывать   эту   управляющую
        последовательность непосредственно    после    каждого   вызова
        управляющей последовательности  NEXTBAND.  Она   ссылается   на
        на фрагмент,   возвращаемый   драйвером   в   эту   управляющую
        последовательность.

             Прикладная программа должна использовать  эту  управляющую
        последовательность следующим образом:

             На первом фрагменте,  драйвер   может   давать  прикладной
        программе полно-страничный фрагмент и запрашивает только  текст
        (флаг fGraphicsFlag  устанавливается  в  FALSE и флаг ftextFlag
        устанавливается в TRUE). Прикладная программа посылает драйверу
        только текст.

             Если прикладная  программа сообщает,  что на первой полосе
        есть графики ( флаг fGraphicsFlag устанавливается в TRUE),  или
        если драйвер встретил векторный шрифт, тогда последовательность
        NEXTBAND  вернет  пустой   прямоугольник,   показывающий,   что
        прикладная программа должна перейти на следующую страницу.

             Если графики  есть, но  нет  векторных шрифтов (прикладная
        программа устанавливает флаг fGraphicsFlag в TRUE,  но не  было
        графиков  на первой полно-страничной текстовой полосе),  то для
        последующих  фрагментов  драйвер   может   выборочно   вырезать
        фрагменты  в  прямоугольнике,  посланном  прикладной программе.
        Этот  прямоугольник  разбивает  на  фрагменты  все  графики  на
        странице. Если  обнаружены  векторные шрифты,  то драйвер будет
        разбивать на фрагменты во всю ширину и высоту страницы с флагом
        fTextFlag установленным в единицу. Он будет также устанавливать
        флаг fGraphicsFlag в TRUE если прикладная программа установила
        его.

             Драйвер предполагает,  что прикладная программа  используя
        управляющую последовательность BANDINFO будет  посылать  только
        текст на первый полно-страничный фрагмент текста. Поэтому, если
        драйвер встречает в полосе  векторный  шрифт  или  графики,  он
        предполагает, что они были образованны текстовыми примитивами и
        устанавливает флаг  fTextFlag  в  TRUE  для  всех   последующих
        графических  фрагментов  так,  что  они могут быть выведены как
        графики.  Если  прикладная  программа  не  удовлетворяет  этому

       Windows 3.0/Ref/7#7                                        = 9 =

        требованию, образ будет оставаться сгенерированным как следует,
        но драйвер  будет  тратить  время  посылая  неверные  текстовые
        примитивы в графические фрагменты.

             Старые драйверы       написанные       до      управляющей
        последовательности   BANDINFO   были   разработаны    используя
        полно-страничное   разбиение  на  фрагменты  для  текста.  Если
        драйвер   не   поддерживает   управляющей    последовательности
        BANDINFO,  но  устанавливает  RC_BANDING,  прикладная программа
        может определить полно-страничное разбиение  на  фрагменты  для
        текста  путем  определения того,  покрывает ли первая полоса на
        странице всю страницу.

        ───────────────────────────────────────────────────────────────
                                        BEGIN_PATH                             

             Синтаксис    short Escape(hDC,BEGIN_PATH,NULL,NULL,NULL)

             Эта управляющая   последовательность   открывает   "путь".
        "Путь" - это связанная последовательность  примитивов  рисуемых
        последовательно  для  формирования  одной  ломанной  линии  или
        многоугольника. "Пути" дают  возможность  прикладной  программе
        рисовать  сложные  границы,  заполненные  формы,  и  вырезаемые
        области  снабжая  ее   набором   других   примитивов,   которые
        определяют нужную форму.

             Управляющие последовательности   принтера   поддерживающие
        "пути" дают возможность прикладной программе  оказывать  помощь
        образам   на   высокоинтелектуальных   устройствах,  таких  как
        принтеры   Post   Script   (R)   без   генерирования    больших
        многоугольников для моделирования образов.

             Для рисования  "пути"  прикладная программа сначала выдает
        управляющую последовательность  BEGIN_PATH.  Затем  она  рисует
        примитивы,  определяющие  границу  желаемой  области  и  выдает
        управляющую последовательность       END_PATH.      Управляющая
        последовательность END_PATH включает параметр определяющий  как
        "путь" должен быть воспроизведен.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства.


             Возвращаемая величина:

             Возвращаемая величина   определяется   текущем    уровенем
        "пути".  Если управляющая последовательность выполнена успешно,
        то возвращаемая  величина  -  это  число  вызовов   управляющей
        последовательности   BEGIN_PATH   без   соответсвующего  вызова
        управляющей последовательности  END_PATH.  В  противном  случае
        возвращаемое значение равно нулю.

       Windows 3.0/Ref/7#7                                       = 10 =


             Комментарий:

             Прикладная программа может начать "подпуть" внутри другого
        "пути". Если  "подпуть"  закрыт,  то  он  трактуется  также как
        многоугольник. Если он открыт,  то он трактуется  как  ломанная
        линия.

             Прикладная программа    может   использовать   управляющую
        последовательность CLIP_TO_PATH  для   определения   вырезаемой
        области соответствующей   внутреннему   или  внешнему  текущему
        открытоиу "пути".

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 11 =

                                       CLIP_TO_PATH                            

             Синтаксис    short Escape(hDC,CLIP_TO_PATH,sizeof(int),
                                                       lpClipMode,NULL)

             Эта управляющая последовательность  определяет  вырезаемую
        область, ограниченную  текущем   открытым   путем.   Это   дает
        возможность прикладной  программе сохранять или восстанавливать
        текущую  вырезаемую  область   и   открывать   включаемую   или
        исключаемую  вырезаемую область,  ограниченную текущим открытым
        "путем".   Если   "путь"   определяет   включаемую   вырезаемую
        область,то  части  примитивов  не  попадающие  внутрь  области,
        ограниченной  "путем"  отрезаются.   Если   "путь"   определяет
        исключаемую вырезаемую область,  то части примитивов попадающие
        внутрь области вырезаются.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpClipMode   LPINT Указывает     на     короткое    целое,
                          определяющее режим вырезания.  Это может быть
                          одна из следующих величин:

                          Величина     Значение
                          ────────     ────────

                          CLIP_SAVE(0) Сохраняет текущую     вырезаемую
                                       область.

                          CLIP_RESTORE(1) Востанавливает        текущую
                                       вырезаемую область.

                          CLIP_INCLUSIVE(2) Устанавливает    включаемую
                                       вырезаемую область.

                          CLIP_EXCLUSIVE(3) Устанавливает   исключаемую
                                       вырезаемую область.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Это    не    ноль    если    управляющая
        последовательность была выполнена успешно.  В противном  случае
        она равна нулю.

             Комментарий:

             Для "вырезки"   набора  примитивов  на  "пути"  прикладная
        программа должна выполнить следующие шаги:

             1. Сохранить   текущую   вырезаемую   область,   используя

       Windows 3.0/Ref/7#7                                       = 12 =

        управляющую последовательность CLIP_TO_PATH.

             2. Начать "путь", используя управляющую последовательность
        BEGIN_PATH.

             3. Нарисовать    примитивы,    ограничивающие   вырезаемую
        область.

             4. Установить  вырезаемую  область  используя  управляющую
        последовательность BEGIN_TO_PATH.

             5. Закрыть       "путь",       используя       управляющую
        последовательность END_PATH.

             6. Нарисовать примитивы, которые должны быть вырезаны.

             7. Восстановить начальную  вырезаемую  область,  используя
        управляющую последовательность CLIP_TO_PATH.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 13 =

                                                                               
            DEVICEDATA

             Синтаксис    short  Escape(hDC,DEVICEDATA,nCount,lpInData,
                                                             lpOutData)

             Эта управляющая  последовательность  идентична управляющей
        последовательности PASSTROUGH.  Смотрите  описание  управляющей
        последовательности PASSTROUGH    для    получения    дальнейшей
        информации.

        ───────────────────────────────────────────────────────────────
                                         DRAFTMODE                             

             Синтаксис    short Escape(hDC,DRAFTMODE,sizeof(int),
                                                      lpDraftMode,NULL)

             Эта управляющая последовательность включает или  выключает
        "черновой" режим принтера.  Включая "черновой"  режим  драйверу
        устройства  сообщается,  что  печатать  надо быстрее и с низким
        качеством печати (если необходимо).  "Черново" режим может быть
        изменен только на границе страницы,  например после управляюшей
        последовательности NEWFRAME, указывающей драйверу на переход на
        новую страницу.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpDraftMode  LPINT     Указывает    на    короткое  целое,
                          определяющее "черновой" режим. Это может быть
                          одна из следующих величин:

                          Величина     Значение
                          ────────     ────────

                              0        Определяет  "черновой"     режим
                                       выключенным.

                              1        Определяет  "черновой"     режим
                                       включенным.


             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это  положительное  число если управляющая
        последовательность выполнена успешно.  В противном  случае  оно
        отрицательно.

             Комментарий:

             По умолчанию "черновой" режим выключен.
        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 14 =

                                      DRAWPATTERNRECT                          

             Синтаксис    short Escape(hDC,DRAWPATTERNRECT,
                                     sizeof(PRECTSTRUCT),lpInData,NULL)

             Эта управляющая   последовательность    создает    шаблон,
        градацию серого или прямоугольник, заполненный черным используя
        шаблоны  и  правила  языка  управления  страницами   (PCL)   на
        принтерах Hewlett-Packard     (R)     LaserJet     (R)      или
        LaserJet-совместимых   принтерах.  Градация  серого  это  серый
        шаблон,  который содержит определенную  смесь  черных  и  белых
        пикселей.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     PRECT_STRUCT FAR *   Указывает  на  структуру
                          данных PRECT_STRUCT,    которая     описывает
                          прямоугольник. Смотрите        "Комментарий",
                          следующий ниже, для получения более детальной
                          информации по структуре данных PRECT_STRUCT.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это  1 если управляющая последовательность
        выполнена успешно. В противном случае это ноль.

             Комментарий:

             Параметр lpInData    указывает    на    структуру   данных
        PRECT_STRUCT, которая определяет прямоугольник,  который  будет
        создан. Структура PRECT_STRUCT имеет следующий формат:

             typedef struct {
                     POINT   prPosition;
                     POINT   prSize;
                     WORD    prStyle;
                     WORD    prPattern;
             } PRECT_STRUCT;

             Эта структура имеет следующие поля:

             Поле         Описание
             ────         ────────

             prPosition   Определяет верхний левый угол прямоугольника.

             prSize       Определяет нижний правый угол прямоугольника.

       Windows 3.0/Ref/7#7                                       = 15 =


             prStyle      Определяет тип шаблона. Это одна из следующих
                          величин:

                          Величина     Значение
                          ────────     ────────

                             0         Черное правило.

                             1         Белое правило,которое    очищает
                                       данные   растровой  карты  перед
                                       записью на эту же область.  Этот
                                       шаблон    имеется    только    у
                                       принтеров HP LaserJet IIP.

                             2         Серая градация.

                             3         Определенный HP.

             prPattern    Определяет шаблон.  Это поле игнорируется для
                          черного   правила.   Оно  определяет  процент
                          серого  для  шаблона  градации  серого.   Оно
                          представляет    один    из   шести   шаблонов
                          определенных Hewlett-Packard.

             Прикладная программа   должна   использовать   управляющую
        последовательность QUERYESCSUPPORT для определения, способно ли
        устройство рисовать  шаблон  и  правила,  перед  использованием
        управляющей последовательности DRAWPATTERNRECT. Если прикладная
        программа использует управляющую  последовательность  BANDINFO,
        то все  шаблоны  и  прямоугольники  посылаемые с использованием
        управляющей последовательности  DRAWPATTERNRECT   должны   быть
        представлены как текст и посланны в качестве полосы текста.

             Не пробуйте   стирать   шаблоны   и   правила    созданные
        управляющей    последовательностью    DRAWPATTERNREC,   помещая
        непрозрачные объекты поверх них.  Для стирания таких шаблонов и
        правил используйте вызовы функций, обеспечиваемых GDI.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 16 =

                                       ENABLEDUPLEX                            

             Синтаксис    short Escape(hDC,ENABLEDUPLEX,sizeof(WORD),
                                                         lpInData,NULL)

             Эта управляющая   последовательность   дает    возможность
        печатать принтеру   с  двух  сторон  листа(дуплексная  печать).
        Устройства,  обладающие способностью дуплексной  печати,  могут
        печатать на обоих сторонах выходного листа.


             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     WORD FAR *    Указывает на беззнаковое 16-ти
                          битовое целое,       которое       определяет
                          используется  ли  печать  с  одной  или  двух
                          сторон листа(симплексная или дуплексная). Это
                          может быть одна из следующих величин:

                          Величина     Значение
                          ────────      ────────

                             0          Симплексная

                             1          Дуплексная    с    вертикальным
                                        связыванием  страниц.

                             2          Дуплексная    с  горизонтальным
                                        связыванием страниц.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это 1 если управляющая  последовательность
        выполнена успешно. В противном случае это ноль.

             Комментарий:

             Прикладная программа   должна   использовать   управляющую
        последовательность QUERYESCSUPPORT    для   определения,   того
        способно ли выходное устройство осуществлять дуплексную печать.
        Если последовательность  QUERYESCSUPPORT  возвращает не нулевую
        величину, прикладная  программа  должна   послать   управляющую
        последовательность ENABLEDUPLEX  даже  если  нужна  симплексная
        печать. Это гарантирует замещение любой величины, установленной
        в   панели   диалога   драйвера  конкретного  устройства.  Если
        дуплексная печать возможна и есть  неравное  число  управляющих
        последовательностей    NEXTFRAME,    посылаемых   драйверу   до
        управляющей   последовательности    ENDDOC,    драйвер    будет
        "выбрасывать" дополнительную страницу перед завершением печати.
        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 17 =

                                     ENABLEPAIRKERNING                         

             Синтаксис    short Escape(hDC,ENABLEPAIRKERNING,
                                           sizeof(int),lpNewKernFlag,
                                                         lpOldKernFlag)

             Эта управляющая последовательность разрешает или запрещает
        драйверу автоматическую разрядку символьных пар. Разрядка - это
        процесс увеличения или уменьшения расстояния между символами  в
        текстовой    строке.

             Если разрядка   разрешена,   драйвер  автоматически  будет
        устанавливать разрядку  пар  символов,  приведенных  в  таблице
        разрядки  символьных  пар шрифта.  Драйвер будет отображать эту
        разрядку,  как  при  печати,   так   и   при   вызове   функции
        GetTextExtent.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpNewKernFlag LPINT    Указывает на     короткое     целое
                          значение, определяющее   разрешена   (1)  или
                          запрещена (0) автоматическая разрядка пар.

             lpOldKernFlag LPINT    Указывает на     короткое     целое
                          значение, которое  будет содержать предыдущее
                          значение автоматической разрядки пар.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она     равна     1     если    управляющая
        последовательность выполнена успешно,  и равна  0,  если  имела
        место ошибка или функция не реализована в данной версии.

             Комментарий:

             Значение режима по умолчанию для  этой  функции  равно  0,
        или автоматическая разрядка пары символов запрещена.

             Драйвер не  имеет поддержки управляющей последовательности
        ENABLEPAIRKERNING только  потому,  что  он   передает   таблицу
        разрядки пары     символов     прикладной    программе    через
        управляющую последовательность GETPAIRKERNTABLE.  В том  случае
        когда управляющая      последовательноcть      GETPAIRKERNTABLE
        поддерживается, а  последовательность  ENABLEPAIRKERNING   нет,
        прикладная программа   должна   обеспечивать   нужную  разрядку
        символов на выходном устройстве, используя функцию ExtOutText.

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 18 =

                                   ENABLERELATIVEWIDTHS                        

             Синтаксис    short Escape(hDC,ENABLERELATIVEWIDTHS,
                                          sizeof(int),lpNewWidthFlag,
                                                         lpOldWidthFlag)

             Эта управляющая последовательность разрешает или запрещает
        относительную ширину (протяженность) символа.  При запрете  (по
        умолчанию)  протяженность  каждого  символа может быть выражена
        целым числом в единицах устройства.  Это гарантирует, что длина
        строки будет равна сумме протяженностей символов в строке.  Это
        позволяет прикладным программам строить таблицу протяженностей,
        используя вызов функции GetTextExtent для каждого символа.

             Если относительная протяженность  символов  разрешена,  то
        длина   строки   может  не  равняться  суммарной  протяженности
        символов. Предполагается, что прикладные программы, применяющие
        эту возможность,  восстанавливают таблицу протяженностей шрифта
        и вычисляют длину строки соответственно масштабу.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpNewWidthFlag LPINT   Указывает на     короткое    целое,
                          определяющее, что    относительная     ширина
                          символа разрешена (1) или запрещена (0).

             lpOldWidthFlag LPINT   Указывает на     короткое     целое
                          значение, которое    будет    соответствовать
                          предыдущему  относительному  значению  ширины
                          символа.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это 1 если управляющая  последовательность
        выполнена  успешно,  и  равна  0,  если  имела место ошибка или
        функция не реализована в данной версии.

             Комментарий:

             Режим этой  управляющей  последовательности  по  умолчанию
        равен 0; относительная ширина символа запрещена.

             Значения, которые принимаются и возвращаются  управляющими
        последовательностями, описанными  в  этой  главе определяются и
        возвращаются в относительных единицах  шрифта,  если  разрешена
        управляющая последовательность ENABLERELATIVEWIDTHS.

              Предполагается, что  только  устройства,   осуществляющие

       Windows 3.0/Ref/7#7                                       = 19 =

        линейное   масштабирование,   будут  работать  в  относительном
        режиме.  Для  устройств  с  нелинейным   масштабированием   эта
        управляющая последовательность не должна выполняться.

        ───────────────────────────────────────────────────────────────
                                          ENDDOC                               

             Синтаксис    short Escape(hDC,ENDDOC,NULL,NULL,NULL)


             Эта управляющая   последовательность  заканчивает  печать,
        начатую STARTDOC.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Она    положительна   если   управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательна.

             Комментарий:

             При ошибке печати или отмене печати,  не следует  пытаться
        прекратить операцию  печати,  используя  функцию  Escape либо c
        управляющей   последовательностью   ENDDOC, либо с  управляющей
        последовательностью ABORTDOC.   GDI   автоматически   прерывает
        операцию печати, предварительно возвращая значение ошибки.

             Когда прикладная программа отображает панель  диалога  для
        предоставления пользователю  отмены операции печати,  то должна
        быть послана последовательность ENDDOC перед разрушением панели
        диалога.

             В любом   случае   прикладная   программа  должна  послать
        управляющую  последовательность  ENDDOC   перед   освобождением
        адреса экземпляра процедуры функции завершения.

        ───────────────────────────────────────────────────────────────
                                         END_PATH                              

             Синтаксис    short Escape(hDC,END_PATH,sizeof(PATH_INFO),
                                                         lpInData,NULL)

             Эта управляющая   последовательность  заканчивает  "путь".
        "Путь" - это связанная последовательность  примитивов  рисуемых
        последовательно  для  формирования  одной  ломанной  линии  или
        многоугльника.  "Пути" дают  возможность  прикладной  программе
        рисовать  сложные  границы,  заполненные  формы,  и  вырезаемые

       Windows 3.0/Ref/7#7                                       = 20 =

        области  снабжая  ее   набором   других   примитивов,   которые
        определяют нужную форму.

             Управляющие последовательности   принтера   поддерживающие
        "пути" дают возможность прикладной программе  оказывать  помощь
        образам   на   высокоинтелектуальных   устройствах,  таких  как
        принтеры  PostScript   (R)    без     генерирования     больших
        многоугольников для моделирования образов.

             Для рисования  "пути"  прикладная программа сначала выдает
        управляющую последовательность  BEGIN_PATH.  Затем  она  рисует
        примитивы,  определяющие  границу  желаемой  области  и  выдает
        управляющую последовательность       END_PATH.

             Управляющая последовательность   END_PATH   получает   как
        параметр указатель на структуру,  определяющую способ,  которым
        "путь" должен  быть  воспроизведен.  Эта  структура  определяет
        должен ли быть "путь" нарисован или нет,  и закрыт  ли  он  или
        нет.  Открытый  "путь"  определяет  ломаную  линию,  а закрытый
        "путь" определяет многоугольник.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     PATH_INFO FAR * Указывает на структуру данных
                          PATH_INFO, которая   определяет   как  "путь"
                          должен быть исполнен. Смотрите следующий ниже
                          пункт     "Комментарий"     для     получения
                          дополнительной информации об этой структуре.


             Возвращаемая величина:

             Возвращаемая величина   определяется   текущим    уровнем
        "пути".  Если управляющая последовательность выполнена успешно,
        то  возвращаемая  величина  это   число   вызовов   управляющей
        последовательности   BEGIN_PATH   без   соответсвующего  вызова
        управляющей последовательности  END_PATH.  В  противном  случае
        возвращаемое значение равно нулю.

             Комментарий:

             Прикладная программа может начать "подпуть" внутри другого
        "пути". Если  "подпуть"  закрыт,  то  он  трактуется  также как
        многоугольник. Если он открыт,  то он трактуется  как  ломанная
        линия.

             Прикладная программа    может   использовать   управляющую
        последовательность CLIP_TO_PATH  для   определения   вырезаемой
        области соответствующей   внутреннему   или  внешнему  текущему
        открытоиу "пути".

       Windows 3.0/Ref/7#7                                       = 21 =


             Параметр lpInData указывает на структуру данных PATH_INFO,
        определяюшую как выполнить "путь".  Эта структура данных  имеет
        следующую форму:

             typedef struct {
                     short     RenderMode;
                     BYTE      FillMode;
                     BYTE      BkMode;
                     LOGPEN    Pen;
                     LOGBRUSH  Brush;
                     DWORD     BkColor;
              } PATH_INFO;

             Структура PATH_INFO имеет следующие поля:

             Поле         Описание
             ────         ────────

             RenederMode  Определяет     как    "путь"    должен   быть
                          воспроизведен. Это   может   быть   одна   из
                          следующих величин:

                          Величина     Значение
                          ────────     ────────

                          NO_DISPLAY(0) "Путь" не рисуется.

                          OPEN(1)      "Путь"   рисуется  как  открытый
                                       многоугольник.

                          CLOSED(2)    "Путь"   рисуется  как  закрытый
                                       многоугольник.

              FillMode    Определяет как  "путь" должен  быть заполнен.
                          Это может быть одна из следующих величин:

                          Величина     Значение
                          ────────     ────────

                          ALTERNATE(1) Заполнение        (закрашивание)
                                       выполняется,           используя
                                       альтернативный          алгоритм
                                       заполнения.

                          WINDING(2)   Заполнение          выполняется,
                                       используя алгоритм "намотки".

             BkMode       Определяет режим фона для  заполнения "пути".
                          Это может быть одна из следующих величин:


       Windows 3.0/Ref/7#7                                       = 22 =

                          Величина     Значение
                          ────────     ────────
                          OPAQUE       Фон заполнен с цветом фона перед
                                       рисованием кистью.

                          TRANSPARENT  Фон не меняется.

             Pen          Определяет перо, которым "путь"  должен  быть
                          нарисован. Когда поле RenderMode  установлено
                          в NO_DISPLAY перо игнорируется.

             Brush        Определяет кисть, которой "путь"  должен  быть
                          нарисован. Когда поле RenderMode  установлено
                          в NO_DISPLAY кисть игнорируется.

             BkColor      Определяет цвет,  которым "путь" заполняется,
                          если поле BkMode установлено в OPAQUE.

        ───────────────────────────────────────────────────────────────
                                       ENUMPAPERBINS                           

             Синтаксис    short Escape(hDC,ENUMPAPERBINS,sizeof(int),
                                                   lpNumBins,lpOutData)

             Эта управляющая последовательность возвращает себе атрибут
        информации об определенном числе кассет для бумаги. Управляющая
        последовательность GETSETPAPERBINS возвращает себе число кассет
        имеющихся в распоряжении принтера.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpNumBins    LPINT     Указывает на  целое,   определяющее
                          число кассет,  для которых информация  должна
                          быть получена.

             lpOutData    LPSTR     Указывает на  структуру  данных,  в
                          которую копируется информация о кассетах  для
                          бумаги.  Размер  структуры  зависит  от числа
                          кассет,   для   которых    информация    была
                          запрошена.   Смотрите   нижеследующий   пункт
                          "Комментарий"  для  получения  описания  этой
                          структуре данных.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это  1 если управляющая последовательность
        выполнена успешно.  Это ноль если последовательность  выполнена
        неуспешно или не представлена в данной версии.

             Комментарий:

       Windows 3.0/Ref/7#7                                       = 23 =


             Структура данных на которую указывает lpOutData состоит из
        двух массивов.  Первый массив  коротких  целых  содержит  числа
        идентифицирующие кассеты для бумаг в следующем формате:

             short  BinList[cBinMax]

             Число целых  в  массиве (cBinMax) равно величине указанной
        параметром lpNumBins.

             Второй массив в структуре  данных,  на  которую  указывает
        lpOutData - это массив символов в следующем формате:

             char   PaperNames[cBinMax][cchBinName]

             Величина cBinMax   равна   величине  указанной  параметром
        lpNumBins; величина  cchBinName  -  это  длина  каждой   строки
        (текущая 24).

        ───────────────────────────────────────────────────────────────
                                     ENUMPAPERMETRICS                          

             Синтаксис    short Escape(hDC,ENUMPAPERMETRICS,
                                          sizeof(int),lpMode,lpOutData)

             Эта управляющая  последовательность выполняет одну из двух
        функций согласно режиму:

             - Определяет   число   типов   поддерживаемой   бумаги   и
        возвращает эту величину,  которая затем может быть использована
        для размещения в массиве структуры данных RECT.

             - Возвращает  одну  или  больше  структур   данных   RECT,
        определяющих область на странице, которая может получать образ.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpMode       LPINT     Указывает на   целое,  определяющее
                          режим для управляющей последовательности. Это
                          может быть одна из следующих величин:

                          Величина     Значение
                          ────────     ────────

                             0         Возвращаемая величина показывает
                                       сколько структур   данных   RECT
                                       требуется     для     содержания
                                       информации   о  возможных  типах
                                       бумаги.


       Windows 3.0/Ref/7#7                                       = 24 =

                             1         Массив   структуры   RECT,    на
                                       которую   указывает    lpOutData
                                       содержит информацию.

             lpOutData    LPRECT    Указывает    на    массив структуры
                          данных RECT,    определяющей   все   области,
                          которые могут получить образ.

             Возвращаемая величина:

             Возвращаемая величина   положительна,   если   управляющая
        последовательность     выполнена     успешно,     ноль     если
        последовательность  не   представлена   в   данной   версии   и
        отрицательна в случае возникновения ошибки.

        ───────────────────────────────────────────────────────────────
                                        EPSPRINTING                            

             Синтаксис    short Escape(hDC,EPSPRINTING,sizeof(BOOL),
                                                           lpBool,NULL)

             Эта управляющая    последовательность    запрещает   вывод
        заголовка управляющей секции Windows PostScript,  который имеет
        размер около  7К.  Если  прикладная  программа  использует  эту
        управляющую последовательность, то не возможны вызовы GDI.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpBool       BOOL FAR * Указывает  на  Булевскую величину,
                          показывающую что  загрузка  разрешена  (TRUE)
                          или запрещена (FALSE).

             Возвращаемая величина:

             Возвращаемая величина   положительна,   если   управляющая
        последовательность     выполнена     успешно,     ноль     если
        последовательность  не   представлена   в   данной   версии   и
        отрицательна в случае возникновения ошибки.

        ───────────────────────────────────────────────────────────────
                                      EXT_DEVICE_CAPS                          

             Синтаксис    short Ecape(hDC,EXT_DEVICE_CAPS,sizeof(int),
                                                        lpIndex,lpCaps)

             Эта управляющая последовательность получает информацию  об
        аппаратно-определяемых характеристиках.    Она     поставляется
        функцией GetDeviceCaps.


       Windows 3.0/Ref/7#7                                       = 25 =

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpIndex      LPINT     Указывает   на   короткое    целое,
                          определяющее индекс характеристики,   который
                          должен  быть получен.  Это может быть одна из
                          следующих величин:

                          Величина     Значение
                          ────────     ────────

                          R2_CAPS(1)   Параметр lpCaps показывает какую
                                       из    16    двоичных   растровых
                                       операций  поддерживает   драйвер
                                       устройства. Бит будет установлен
                                       для    каждой     поддерживаемой
                                       растровой      операции.     Для
                                       дальнейшей  информации  смотрите
                                       описание функции SetROP2 в Главе
                                       4,"Список функций",  Справочного
                                       Руководства, Том 1.


                          PATTERN_CAPS(2) Параметр   lpCaps  возвращает
                                       максимальные размеры   растровой
                                       карты   шаблона  кисти.  Младшее
                                       слово возможного        значения
                                       содержит   максимальную   ширину
                                       растровой карты шаблона кисти, а
                                       старшее      слово      содержит
                                       максимальную высоту.

                          PATH_CAPS(3) Параметр     lpCaps   показывает
                                       способно ли устройство создавать
                                       "пути", используя альтернативную
                                       и     "намотанную"    внутреннюю
                                       область,  и может ли  устройство
                                       осуществлять    включающую   или
                                       исключающую вырезку    внутреней
                                       области "пути". Возможные "пути"
                                       получают,  используя  логическую
                                       операцию    OR   для   следующих
                                       величинах:

                                       PATH_ALTERNATE(1)
                                       PATH_WINDING(2)
                                       PATH_INCLUSIVE(4)
                                       PATH_EXCLUSIVE(8)

                          POLYGON_CAPS(4) Параметр   lpCaps  возвращает
                                       максимальное число         точек
                                       многоугольника,   поддерживаемых

       Windows 3.0/Ref/7#7                                       = 26 =

                                       устройством.  Возможное значение
                                       -   это   беззнаковая  величина,
                                       определяющая максимальное  число
                                       точек.

                          PATTERN_COLOR_CAPS(5)   Параметр       lpCaps
                                       показывает способно           ли
                                       устройство        конвертировать
                                       монохромный  шаблон  в  цветной.
                                       Возможная величина равна 1, если
                                       устройство  может   осуществлять
                                       цветовое  преобразование шаблона
                                       растровой карты, и нулю, если не
                                       может.

                          R2_TEXT_CAPS(6)  Параметр  lpCaps  показывает
                                       способно ли устройство выполнять
                                       двоичные растровые операции  над
                                       текстом.      Младшее      слово
                                       возможного значения  определяет,
                                       какая     растровая     операция
                                       поддерживается для  текста.  Бит
                                       устанавливается    для    каждой
                                       растровой  операции,  как  и   в
                                       последовательности      R2_CAPS.
                                       Старшее  слово  определяет   тип
                                       текста  для которого применяется
                                       растровая операция. Это получают
                                       применением  логической операции
                                       OR для следующих величин:

                                       RASTER_TEXT(1)
                                       DEVICE_TEXT(2)
                                       VECTOR_TEXT(4)

             lpCaps       DWORD FAR * Указывает на 32-ух битовое целое,
                          в которое будут скопированы характкристики.

             Возвращаемая величина:

             Возвращаемая величина   не   ноль,    если    определенная
        расширенная характеристика поддерживается, и ноль если нет.

        ───────────────────────────────────────────────────────────────
                                        EXTTEXTOUT                             

             Синтаксис    short Escape(hDC,EXTTEXTOUT,
                                               sizeof(EXTTEXT_STRUCT),
                                                         lpInData,NULL)

             Эта управляющая   последовательность   обеспечивает    для
        прикладных программ более эффективный способ вызова функции GDI
        TextOut  при включении  выравнивания,   изменения   межбуквенных

       Windows 3.0/Ref/7#7                                       = 27 =

        промежутков и/или разрядки.

             Эта функция   обеспечивается   только   для  совместимости
        сверху-вниз. Новые  прикладные  программы  должны  использовать
        ее вместо функции GDI ExtTextOut.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     EXTTEXT_STRUCTFAR  *  Указывает на структуру
                          данных EXTTEXT_STRUCT,   которая   определяет
                          начальную  позицию,  символы,  и   символьную
                          ширину    строки.    Смотрите   нижеследующий
                          "Комментарий"  для  получения  информации   о
                          структуре данных EXTTEXT_STRUCT.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Это 1 если управляющая  последовательность
        выполнена  успешно.  Это ноль если последовательность выполнена
        неуспешно или не представлена в данной версии.

             Комментарий:

             Структура данных EXTTEXT_STRUCT имеет следующий формат:

             typedef  struct {
                      WORD     X;
                      WORD     Y;
                      WORD FAR *lpText;
                      WORD FAR *lpWidths;
             } EXTTEXT_STRUCT;

             Эта структура имеет следующие поля:

             Поле         Описание
             ────         ────────

             X            Определяет координату  x верхнего левого угла
                          точки начала строки.

             Y            Определяет координату  y верхнего левого угла
                          точки начала строки.

             lpText       Указывает  на массив кодов символов  cch, где
                          cch -  это  число  байтов в строке (cch - это
                          также число слов в массиве протяженностей).

             lpWidths     Указывает на  массив  протяженностей символов
                          (cch), который   используется   при    печати

       Windows 3.0/Ref/7#7                                       = 28 =

                          строки. Первый символ имеет координаты (Х,У),
                          второй  (Х  +  lpWidths[0],У),  третий  (Х  +
                          lpWidths[0] + lpWidths[1],У) и так далее. Эти
                          протяженности   символов    определяются    в
                          единицах   текущего   шрифта   (протяженность
                          символа всегда будет  измеряться  в  единицах
                          устройства,   пока  прикладная  программа  не
                          разрешит относительную протяженность).

                          Элементы, содержащиеся       в        массиве
                          протяженностей,   определяются   в   единицах
                          шрифта устройства.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 29 =

                                                                               
            FLUSHOUTPUT

             Синтаксис    short Escape(hDC,FLUSHOUTPUT,NULL,NULL,NULL)

             Эта управляющая  последовательность  очищает  все выходные
        данные из буфера устройства.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Положительна,        если       управляющая
        последовательность выполнилась  успешно,  в  противном   случае
        отрицательна.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 30 =

                                       GETCOLORTABLE                           

             Синтаксис    short Escape(hDC,GETCOLORTABLE,sizeof(int),
                                                       lpIndex,lpColor)

             Эта управляющая  последовательность  считывает значение из
        цветовой таблицы RGB и  копирует  его  в  ячейку,  определяемую
        параметром lpColor.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpIndex      LPINT   Указывает на короткое целое значение,
                          определяющее индекс     элемента     цветовой
                          таблицы.  Индекс  цветовой таблицы равен нулю
                          для первого элемента таблицы.

             lpColor      DWORD FAR * Указывает   на    длинное   целое
                          значение, которое    будет    соответствовать
                          цветовому значению RGB для данного элемента.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Положительна,        если       управляющая
        последовательность выполнилась  успешно,  в  противном   случае
        отрицательно.

        ───────────────────────────────────────────────────────────────
                                  GETEXTENDEDTEXTMETRICS                       

             Синтаксис    short Escape(hDC,GETEXTENDEDTEXTMETRICS,
                                                sizeof(WORD),lpInData,
                                                             lpOutData)

             Эта управляющая   последовательность   заполняет    буфер,
        указанный   параметром   lpOutData,   расширенными   текстовыми
        параметрами для текущего выбранного шрифта.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     WORD FAR *   Указывает   на       беззнаковое
                          16-ти битовое целое,  определяющее количество
                          байт,    на    которые   указывает   параметр
                          lpOutData.

             lpOutData    EXTTEXTMETRIC FAR *  Указывает  на  структуру
                          данных EXTTEXTMETRIC.  Смотрите нижеследующий

       Windows 3.0/Ref/7#7                                       = 31 =

                          "Комментарий"  для  получения  описания  этой
                          структуры.

             Возвращаемая величина:

             Возвращаемая величина определяет число байтов,  копируемых
        в буфер,  указанный параметром lpOutData.  Это значение никогда
        не   превышает   значения   поля  nSize,  указанное  параметром
        lpInData.  Возвращаемая величина равна нулю,  если  управляющая
        последовательность не завершена успешно или не реализована.


             Комментарий:

             Параметр lpOutData    указывает    на   структуру   данных
        EXTTEXTMETRIC, имеющую следующий формат:

             typedef struct {
                     short  etmSize;
                     short  etmPointSize;
                     short  etmOrientation;
                     short  etmMasterHeight;
                     short  etmMinScale;
                     short  etmMaxScale;
                     short  etmMasterUnits;
                     short  etmCapHeight;
                     short  etmXHeight;
                     short  etmLowerCaseAscent;
                     short  etmLowerCaseDescent;
                     short  etmSlant;
                     short  etmSuperScript;
                     short  etmSubScript;
                     short  etmSuperScriptSize;
                     short  etmSubScriptSize;
                     short  etmUnderlineOffset;
                     short  etmUnderlineWidth;
                     short  etmDoubleUpperUnderlineOffset;
                     short  etmDoubleLowerUnderlineOffset;
                     short  etmDoubleUpperUnderlineWidth;
                     short  etmDoubleLowerUnderlineWidth;
                     short  etmStrikeOutOffset;
                     short  etmStrikeOutWidth;
                     WORD   etmKernPairs;
                     WORD   etmKernTracks;
             } EXTTEXTMETRIC;

             Структура данных EXTTEXTMETRIC имеет следующие поля:

             Поле         Описание
             ────         ────────

             etmSize      Определяет размер структуры в байтах.


       Windows 3.0/Ref/7#7                                       = 32 =

             etmPointSize Определяет номинальный размер точки в твипсах
                          (Двадцатая часть точки,  или  1/1440  дюйма).
                          Это  предполагаемый  размер шрифта;  реальный
                          размер может слегка отличаться в  зависимости
                          от разрешающей способности устройства.

             etmOrientation Определяет   ориентацию  шрифта.  Это  поле
                          может быть одной из следующих величин:

                          Величина     Значение
                          ────────     ────────

                             0         Любая ориентация

                             1         "Портретная"

                             2         "Пейзажная"

                          Эта величина указывает на способность данного
                          шрифта быть размещенным на странице  заданной
                          ориентации.   "Портретная"   страница   имеет
                          высоту большую,  чем ее  ширину.  "Пейзажная"
                          страница имеет ширину большую, чем высоту.

             etmMasterHeight Определяет  размер  устройства  в единицах
                          устройства, для которого  величины   в   этой
                          шрифтовой таблице точны.

             etmMinScale  Определяет минимальный допустимый  размер для
                          данного шрифта.      Следующее      равенство
                          показывает как вычисляется минимальный размер
                          точки.
                                                    etmMinScale * 72
                          Наименьший размер точки = ─────────────────
                                                        dfVertRes

                          Число 72  определяет  число  точек  на  дюйм.
                          Величина dfVertRes - это число точек принтера
                          на дюйм.

             etmMaxScale  Определяет  максимальный   допустимый  размер
                          для данного   шрифта.   Следующее   равенство
                          показывает как    вычисляется    максимальный
                          размер точки.
                                                     etmMaxScale * 72
                          Наименьший размер точки = ─────────────────
                                                         dfVertRes

                          Число 72  определяет  число  точек  на  дюйм.
                          Величина dfVertRes - это число точек принтера
                          на дюйм.

             etmMasterUnits Определяет целое число единиц на em, где em

       Windows 3.0/Ref/7#7                                       = 33 =

                          равно etmMasterHeight.     Таким      образом
                          etmMasterUnits      есть      emtMasterHeight
                          выраженное в единицах шрифта,  что лучше  чем
                          единицы устройства.

             etmCapHeight Определяет высоту символов верхнего  регистра
                          шрифта в единицах шрифта.  Обычно это  высота
                          заглавной буквы H.

             etmXHeight   Определяет высоту символов нижнего   регистра
                          шрифта в единицах шрифта.  Обычно это  высота
                          прописной буквы x.

             etmLowerCaseAscent Определяет растояние в единицах шрифта,
                          на которое  возвышаются  надстрочные элементы
                          букв  нижнего регистра  над  базовой  линией.
                          Обычно это высота прописной буквы d.

             etmLowerCaseDescent Определяет    растояние   в   единицах
                          шрифта, на   которое   опущены    подстрочные
                          элементы  букв  нижнего  регистра под базовой
                          линией.   Обычно    это    определенно    для
                          подстрочной части прописной буквы p.

             etmSlant     Определяет   для   курсивного  или наклонного
                          шрифта угол  наклона,  измеряемый  в  десятых
                          долях градуса,  отмеряемый по часовой стрелке
                          от верхнего правого угла шрифта.

             etmSuperScript Определяет      в      единицах      шрифта
                          рекомендованное  число  для смещения символов
                          верхних индексов от базовой линии. Обычно это
                          отрицательная величина.

             etmSubScript Определяет  в единицах шрифта рекомендованное
                          число для смещения символов  нижних  индексов
                          от  базовой  линии.  Обычно это положительная
                          величина.

             etmSuperScriptSize Определяет    в     единицах     шрифта
                          рекомендованный размер  верхних  индексов для
                          данного  шрифта.

             etmSubScriptSize Определяет     в     единицах      шрифта
                          рекомендованный  размер нижних   индексов для
                          данного шрифта.

             etmUnderlineOffset Определяет в единицах  шрифта  смещение
                          вниз от  базовой линии,  где должна появиться
                          верхушка символа подчеркивания.

             etmUnderlineWidth Определяет  в  единицах  шрифта  толщину
                          символа подчеркивания.

       Windows 3.0/Ref/7#7                                       = 34 =


             etmDoubleUpperUnderlineOffsett  Определяет   в    единицах
                          шрифта смещение вниз от  базовой  линии,  где
                          должна появиться  верхушка  верхнего  символа
                          двойного подчеркивания.

             etmDoubleLowerUnderlineOffset   Определяет   в    единицах
                          шрифта смещение вниз от  базовой  линии,  где
                          должна появиться  верхушка  нижнего   символа
                          двойного подчеркивания.

             etmDoubleUpperUnderlineWidth Определяет  в единицах шрифта
                          толщину верхнего символа подчеркивания.

             etmDoubleLowerUnderlineWidth Определяет  в единицах шрифта
                          толщину нижнего символа подчеркивания.

             etmStrikeOutOffset Определяет  в  единицах шрифта вверх от
                          базовой линии,  где должна появиться верхушка
                          символа ударения.

             etmStrikeOutWidth Определяет  в  единицах  шрифта  толщину
                          символа ударения.

             etmKernPairs Определяет  число   межсимвольной   разрядки,
                          определенной  для данного шрифта.  Прикладная
                          программа может использовать эту величину для
                          вычисления размера таблицы разрядки символов,
                          возвращаемой управляющей  последовательностью
                          GETPAIRKERNTABLE.  Это значение не может быть
                          больше 512.

             etmKernTracks Определяет число разрядок,определенной   для
                          данного шрифта.  Прикладная  программа  может
                          использовать   эту  величину  для  вычисления
                          размера таблицы         разрядок,возвращаемой
                          управляющей               последовательностью
                          GETTRACKKERNTABLE. Это значение не может быть
                          больше чем 16 разрядок.

             Значения возвращаемые     многими     полями     структуры
        EXTTEXTMETRIC  зависят  от того была ли разрешена или запрещена
        относительная ширина  символов.  Для  получения  дополнительной
        информации,  смотрите  описание  управляющей последовательности
        ENABLERELATIVEWIDTHS, приведенное раннее в этой главе.

        ───────────────────────────────────────────────────────────────
                                      GETEXTENTTABLE                           

             Синтаксис    short Escape(hDC,GETEXTENTTABLE,
                                           sizeof(CHAR_RANGE_STRUCT),
                                                    lpInData,lpOutData)


       Windows 3.0/Ref/7#7                                       = 35 =

             Эта управляющая   последовательность   возвращает   ширину
        (протяженность)  каждого  символа  из  группы  последовательных
        символов в выбранном символьном наборе шрифта.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     LPSTR    Указывает   на   структуру    данных
                          CHAR_RANGE_STRUCT,     которая     определяет
                          диапазон символов  для  которых  должна  быть
                          получена   ширина.   Смотрите   нижеследующий
                          "Комментарий"  для  получения  информации   о
                          структуре данных CHAR_RANGE_STRUCT.

             lpOutData    LPINT  Указывает   на   массив  целых  чисел,
                          который получает   ширину   символов.  Размер
                          массива   должен   быть   по   крайней   мере
                          (chLast-chFirst+1).

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Равна    1,    если   последовательность
        выполнилась  успешно.  Возвращаемая  величина  равна  0,   если
        последовательность   не   завершена   успешно  или  управляющая
        последовательность не реализована.

             Комментарий:

             Параметр lpInData   указывает    на    структуру    данных
        CHAR_RANGE_STRUCT, определяющую     диапазон    символов    для
        которых должна     быть     получена     ширина.      Структура
        CHAR_RANGE_STRUCT имеет следующий формат:

             typedef struct {
                     BYTE   chFirst;
                     BYTE   chLast;
             } CHAR_RANGE_STRUCT;

             Эта структура имеет следующие поля:

             Поле         Описание
             ────         ────────

             chFirst      Определяет  символьный  код  первого символа,
                          для которого будет получена ширина.

             chLast       Определяет символьный код последнего символа,
                          для которого будет получена ширина.



       Windows 3.0/Ref/7#7                                       = 36 =

             Возвращаемые значения зависят от того  была  ли  разрешена
        или  запрещена  относительная  ширина  символов.  Для получения
        дополнительной  информации,   смотрите   описание   управляющей
        последовательности  ENABLERELATIVEWIDTHS,  приведенное раннее в
        этой главе.

        ───────────────────────────────────────────────────────────────
                                        GETFACENAME                            

             Синтаксис     short Escape(hDC,GETFACENAME,NULL,NULL,
                                                            lpFaceName)

             Эта управляющая   последовательность   получает   название
        текущего физического шрифта.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpFaceName LPSTR Указывает на буфер символов для получения
                        названия. Этот  буфер  должен  быть  длиной  по
                        крайней мере 60 байт.

             Возвращаемая величина:

             Возвращаемая величина   положительна,   если   управляющая
        последовательность была  завершена  успешно,  равна нулю,  если
        последовательность не реализована,  и отрицательна,  если имела
        место ошибка.

        ───────────────────────────────────────────────────────────────
                                     GETPAIRKERNTABLE                          

             Синтаксис    short Escape(hDC,GETPAIRKERNTABLE,NULL,NULL,
                                                             lpOutData)

             Эта управляющая    последовательность   заполняет   буфер,
        указанный параметром lpOutData значениями из  таблицы  разрядок
        пар символов для выбранного шрифта.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpOutData    KERNPAIR FAR * Указывает на  массив структуры
                          данных KERNPAIR.   Этот  массив  должен  быть
                          достаточно  большим,  чтобы  разместить   всю
                          таблицу разрядок символьных пар шрифта. Число
                          пар  символ-разрядка  в  шрифте  может   быть
                          получено из    структуры    GETEXTTEXTMETRIC,
                          возвращаемой       управляющей       функцией

       Windows 3.0/Ref/7#7                                       = 37 =

                          GETEXTENDEDTEXTMETRICS.              Смотрите
                          нижеследующий  "Комментарий"  для   получения
                          описания структуры KERNPAIR.

             Возвращаемая величина:

             Возвращаемая величина    представляет   собой   количество
        структур KERNPAIR,  копируемых в буфер.  Это значение равно   0,
        если в шрифте не определены пары разрядок, функция не завершена
        успешно или не реализована.

             Комментарий:

             Структура данных KERNPAIR имеет следующий формат:

             typedef struct {
                union {
                          BYTE each   [2];  /*  ОБЪЕДИНЕНИЕ:  'each'  и
                                            'both' разделяют одну и  ту
                                             же память */
                          WORD  both;
                      } kpPair;
                short kpKernAmount;
             } KERNPAIR;

             Структура KERNPAIR имеет следующие поля:

             Поле         Описание
             ────         ────────

             kpPair.each[0] Определяет  символьный  код   для   первого
                          символа в разрядной паре.

             kpPair.each[1] Определяет  символьный  код   для   второго
                          символа в разрядной паре.

             kpPair.both  Определяет слово,  в котором в  младшем байте
                          содержится первый символ разрядной пары,  а в
                          старшем байте второй символ.

             kpKernAmount Определяет знаковое число на  которое  данная
                          пара символов   будет   разрежена,  если  они
                          появляются рядом,  и они  одного  и  того  же
                          шрифта   и   размера.   Это  значение  обычно
                          отрицательно,  так как парная разрядка обычно
                          осуществляется    между    двумя    символами
                          установленными более тесно, чем обычно.

             Массив структуры KERNPAIR хранится в  порядке  возрастания
        поля kpPair.both.

             Возвращаемые значения в структуре KERNPAIR зависят от того
        была  ли разрешена или запрещена относительная ширина символов.

       Windows 3.0/Ref/7#7                                       = 38 =

        Для  получения  дополнительной  информации,  смотрите  описание
        управляющей       последовательности      ENABLERELATIVEWIDTHS,
        приведенное раннее в этой главе.

        ───────────────────────────────────────────────────────────────
                                      GETPHYSPAGESIZE                          

             Синтаксис    short Escape(hDC,GETPHYSPAGESIZE,NULL,NULL,
                                                          lpDimensions)

             Эта управляющая   последовательность  получает  физический
        размер страницы и копирует его в ячейку,  на которую  указывает
        параметр lpDimensions.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpDimensions LPPOINT  Указывает на структуру данных POINT,
                          которая будет получать размер страницы.  Поле
                          x  структуры  POINT  получает  горизонтальный
                          размер в  единицах устройства,поле y получает
                          вертикальный размер в единицах устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательна.

        ───────────────────────────────────────────────────────────────
                                     GETPRINTINGOFFSET                         

             Синтаксис    short Escape(hDC,GETPRINTINGOFFSET,NULL,NULL,
                                                              lpOffset)

             Эта управляющая  последовательность  получает  смещение от
        верхнего левого угла физической страницы до точки, где начнется
        реальная     печать     или    рисование.    Эта    управляющая
        последовательность  обычно  не  используется   для   устройств,
        позволяющих пользователю вручную установить начало печати.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpOffset     LPPOINT  Указывает на структуру данных POINT,
                          которая будет   получать   координату   точки
                          смещения печати.  Поле  x   структуры   POINT
                          получает горизонтальную координату в единицах

       Windows 3.0/Ref/7#7                                       = 39 =

                          устройства,поле y    получает    вертикальную
                          координату  точки  смещения печати в единицах
                          устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательна.

        ───────────────────────────────────────────────────────────────
                                     GETSCALINGFACTOR                          

             Синтаксис    short Escape(hDC,GETSCALINGFACTOR,NULL,NULL,
                                                             lpFactors)

             Эта управляющая последовательность  получает  коэффициенты
        масштабирования  по  осям х и у устройства печати.  Для каждого
        коэффициента масштабирования   управляющая   последовательность
        копирует показатель степени числа  два  в  ячейку,  на  которую
        указывает параметр lpFactors. Например, значение 3 копируется в
        lpFactors, если коэффициент масштабирования равен 8.

             Коэффициенты масштабирования    применяются    печатающими
        устройствами, поддерживающими графику меньшего разрешения,  чем
        текст.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpFactors    LPPOINT  Указывает на структуру данных POINT,
                          которая будет      получать       коэффициент
                          масштабирования.   Поле   x  структуры  POINT
                          получает коэффициент масштабирования  по  оси
                          x, поле      y      получает      коэффициент
                          масштабирования по оси y.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательна.

        ───────────────────────────────────────────────────────────────
                                      GETSETPAPERBINS                          

             Синтаксис short Escape(hDC,GETSETPAPERBINS,nCount,
                                                    lpInData,lpOutData)


       Windows 3.0/Ref/7#7                                       = 40 =

             Эта управляющая  последовательность  получает число кассет
        для бумаги,  возможное  на  данном  принтере  и   устанавливает
        текущую кассету.   Смотрите   нижеследующий  "Комментарий"  для
        дополнительной информации   по   реальному   применению    этой
        последовательности.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             nCount       int    Определяет количество  байт, указанных
                          параметром lpInData.

             lpInData     BinInfo  FAR  *    Указывает   на   структуру
                          данных BinInfo,  определяющую  новую  кассету
                          бумаги. Может быть установлено в NULL.

             lpOutData    BinInfo  FAR  *    Указывает   на   структуру
                          данных BinInfo,   содержащую   информацию   о
                          текущей   или   предыдущей  кассете  и  числе
                          возможных кассет.

             Комментарий:

             Есть три   возможных   действия   для   этой   управляющей
        последовательности, зависящих    от   значений,  переданных   в
        параметрах lpInData и  lpOutData:

        ───────────────────────────────────────────────────────────────
             lpInData     lpOutData    Действие
        ───────────────────────────────────────────────────────────────
             NULL         BinInfo      Получает  число  кассет  и номер
                                       текущей кассеты.

             BinInfo      BinInfo      Устанавливает  номер     текущей
                                       кассеты, определеный   в    поле
                                       BinNumber структуры   данных  на
                                       которую  указывает  lpInData   и
                                       получает     номер    предыдущей
                                       кассеты.

             BinInfo      NULL         Устанавливает  номер     текущей
                                       кассеты, определеный   в    поле
                                       BinNumber структуры   данных  на
                                       которую  указывает  lpInData.
        ───────────────────────────────────────────────────────────────

             Структура данных BinInfo имеет следующий формат:

             typedef struct {
                     DWORD  BinNumber;
                     DWORD  NbrofBins;

       Windows 3.0/Ref/7#7                                       = 41 =

                     DWORD      Reserved;
                     DWORD      Reserved;
                     DWORD      Reserved;
                     DWORD      Reserved;
             } BinInfo;

             Структура BinInfo имеет следующие поля:

             Поле         Описание
             ────         ────────

             BinNumber    Идентифицирует текущую или предыдущую кассету
                          бумаги.

             NbrofBins    Определяет число возможных кассет бумаги.

             При установке новой кассеты, это не будет иметь эффекта до
        тех пор  пока  не  будет  создан   контекст   устройства(   без
        инициализации данных).   Установка   будет   иметь  немедленный
        эффект, если старший бит в  номере  кассеты  установлен,  таким
        образом следующая  страница для печати будет поступать из новой
        кассеты. Например,  0x8001 использует вторую кассету немедленно
        даже если 0x0001 устанавливает ту же самую кассету по умолчанию
        для последующей печати.

             В общем случае,  только форма немедленной  выборки  должна
        использоваться прикладными  программами.  Установленный бит для
        будующей печати поддерживается для совместимости  "снизу-вверх"
        в ранних  формах  этой управляющей последовательности,  которая
        появлялась в некоторых версиях HP Языка  Управления  Страницами
        (PCL) и PostScript.

        ───────────────────────────────────────────────────────────────
                                    GETSETPAPERMETRICS                         

             Синтаксис short Escape(hDc,GETSETPAPERMETRICS,
                                              sizeof(RECT),lpNewPaper,
                                                           lpPrevPaper)

             Эта управляющая   последовательность   устанавливает   тип
        бумаги согласно данной информации о характеристиках бумаги. Она
        также получает текущую информацию о характкристиках  печатаемой
        бумаги.

             Эта управляющая   последовательность   ожидает   структуру
        данных RECT, представляющую область образов физической страницы
        и предполагает ее начало в верхнем левом углу.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства


       Windows 3.0/Ref/7#7                                       = 42 =

             lpNewPaper   LPRECT   Указывает на структуру данных RECT,
                          определяющую новую область образов.

             lpPrevPaper  LPRECT   Указывает на структуру данных RECT,
                          получающую предыдущую область образов.

             Возвращаемая величина:

             Возвращаемая величина   положительна,   если   управляющая
        последовательность была  завершена  успешно,  равна нулю,  если
        последовательность не реализована,  и отрицательна,  если имела
        место ошибка.

             Комментарий:

             Эта управляющая  последовательность  обеспечивается только
        для совместимости  "сверху-вниз".  Новые  прикладные  программы
        должны использовать вместо нее функции GDI DeviceCapabilities и
        ExtDeviceMode.

        ───────────────────────────────────────────────────────────────
                                     GETSETPAPERORIENT                         

             Синтаксис    short Escape(hDC,GETSETPAPERORIENT,nCount,
                                                         lpInData,NULL)

             Эта управляющая    последовательность    возвращает    лил
        устанавливает текущую ориентацию страницы.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             nCount       int     Определяет  число  байтов   указанных
                          параметром lpInData.

             lpInData     ORIENT  FAR  *    Указывает    на   структуру
                          данных, определяющую     новую     ориентацию
                          страницы.        Смотрите       нижеследующий
                          "Комментарий"  для  получения  описания  этой
                          структуры данных.  Этот  параметр  может быть
                          установлен в     NULL,    в    этом    случае
                          управляющая                последовательность
                          GETSETPAPERORIENT      возвращает     текущую
                          ориентацию страницы.

             Возвращаемая величина:

             Возвращаемая величина  определяется  текущей  ориентацией,
        если lpInData   NULL;   в   противном   случае  это  предыдущая
        ориентация. Возвращаемое  значение  -   1,   если   управляющая
        последовательность не выполнена успешно.

       Windows 3.0/Ref/7#7                                       = 43 =


             Комментарий:

             Эта управляющая  последовательность  обеспечивается только
        для совместимости  "сверху-вниз".  Новые  прикладные  программы
        должны использовать вместо нее функции GDI DeviceCapabilities и
        ExtDeviceMode.

             Структура данных ORIENT имеет следующий формат:

             typedef struct {
                     DWORD  Orientation;
                     DWORD      Reserved;
                     DWORD      Reserved;
                     DWORD      Reserved;
                     DWORD      Reserved;
             } ORIENT;

             Поле Orientation может быть одной из следующих величин:

             Величина     Значение
             ────────     ────────

                1         Новая ориентация является "портретной".

                2         Новая ориентация является "пейзажной".

             Эта управляющая   последовательность  известна  также  как
        GETSETPAPERORIENTATION.

        ───────────────────────────────────────────────────────────────
                                    GETSETSCREENPARAMS                         

             Синтаксис    short Escape(hDC,GETSETSCREENPARAMS,
                                       sizeof(SCREENPARAMS),lpInData,
                                                             lpOutData)

             Эта управляющая     последовательность     получает    или
        устанавливает текущую  информацию  об  экране   для   поддержки
        полутонов.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     SCREENPARAMS FAR *   Указывает  на  структуру
                          данных SCREENPARAMS,  содержащую информацию о
                          новом экране. Этот параметр может быть NULL.

             lpOutData    SCREENPARAMS FAR *   Указывает  на  структуру
                          данных SCREENPARAMS,     которая     получает
                          предыдущую информацию об экране.Этот параметр

       Windows 3.0/Ref/7#7                                       = 44 =

                          может быть NULL.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательно.

             Комментарий:

             Эта управляющая    последовательность    действует     как
        поддерживаемые  аппаратно-независимые  растровые карты (DIBs) и
        заполненные цветовые объекты.

             Структура данных SCREENPARAMS имеет следующий формат:

             typedef struct {
                     int   angle;
                     int   frequency;
                     DWORD types;
             } SCREENPARAMS;

             Структура SCREENPARAMS имеет следующие поля:

             Поле         Описание
             ────         ────────

             angle        Определяет в градусах угол полутона экрана.

             frequency    Определяет  в точках принтера на дюйм частоту
                          экрана.

             types        Это маска  содержащая биты,  показывающие тип
                          элементов экрана.   Когда  указатель  на  эту
                          структуру посылается как  параметр  lpInData,
                          только  один бит может быть установлен.  Если
                          параметр lpOutData содержит указатель на  эту
                          структуру,          когда         управляющая
                          последовательность возвращает результат, поле
                          types   будет  иметь  бит  установленный  для
                          каждого,  поддерживаемого драйвера  принтера.
                          Приемлемы следующие величины битов:

                          - DIAMOND

                          - DOT

                          - ELLIPSE

                          - LINE

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 45 =

                                       GETTECHNOLOGY                           

             Синтаксис    short Escape(hDc,GETTEHNOLOGY,NULL,NULL,
                                                          lpTechnology)

             Эта управляющая    последовательность    получает    общий
        технологический тип для принтера, тем самым позволяя прикладной
        программе выполнять специальные технологические действия.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpTechnology LPSTR   Указывает на буфер в который  драйвер
                          копирует, заканчивающуюся    нулем    строку,
                          содержащую   технологический   тип  принтера,
                          такую как "PostScript".

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Это 1,  если управляющая последовательность
        выполнилась   успешно,  и  это  ноль,  если  последовательность
        закончена неудачно или не реализована.

        ───────────────────────────────────────────────────────────────
                                     GETTRACKKERNTABLE                         

             Синтаксис    short Escape(hDC,GETTRACKKERNTABLE,NULL,NULL,
                                                             lpOutData)

             Эта управляющая   последовательность   заполняет    буфер,
        указанный параметром lpOutData значениями из  таблицы  разрядок
        пар символов текущего выбранного шрифта.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpOutData    KERNTRACK FAR *  Указывает на массив структур
                          KERNTRACK. Этот массив должен быть достаточно
                          большим,  чтобы   разместить   все   значения
                          разрядок  шрифта.  Число  разрядок  в  шрифте
                          может    быть    получено    из     структуры
                          EXTTEXTMETRIC,    возвращаемой    управляющей
                          последовательностью   GETEXTENDEDTEXTMETRICS.
                          Смотрите   нижеследующий   "Комментарий"  для
                          получения описания структуры KERNTRACK.

             Возвращаемая величина:


       Windows 3.0/Ref/7#7                                       = 46 =

             Возвращаемая величина   представляет   собой    количество
        структур KERNTRACK,  копируемых в буфер.  Это значение равно 0,
        если в шрифте не содержится определения разрядок пар  символов,
        или функция не завершена успешно или не реализована.

             Комментарий:

             Структура данных KERNTRACK имеет следующий формат:

             typedef struct {
                     short  ktDegree;
                     short  ktMinSize;
                     short  ktMinAmount;
                     short  ktMaxSize;
                     short  ktMaxAmount;
             } KERNTRACK;

             Структура KERNTRACK имеет следующие поля:

             Поле         Описание
             ────         ────────

             ktDegree     Определяет  количество   разрядок.    Большие
                          отрицательные числа    представляют    тесную
                          разрядку.   Большие    положительные    числа
                          представляют свободную разрядку.

             ktMinSize    Определяет в единицах устройства  минимальный
                          размер шрифта   для   которого    применяется
                          линейная разрядка.

             ktMinAmount  Определяет  в   единицах   шрифта  количество
                          разрядок для  применения  в  шрифте,  размеры
                          которого   меньше    или    равны,    размеру
                          определенному в поле ktMinSize.

             ktMaxSize    Определяет в единицах устройства максимальный
                          размер шрифта   для   которого    применяется
                          линейная разрядка.

             ktMaxAmount  Определяет  в   единицах   шрифта  количество
                          разрядок для  применения  в  шрифте,  размеры
                          которого    больше    или    равны,   размеру
                          определенному в поле ktMaxSize.

             Между размерами  шрифта  ktMinSize  и ktMaxSize,  разрядка
        это линейная функция от ktMinAmount до ktMaxAmount.Возвращаемые
        значения  в  структуре  KERNTRACK  зависят  от  того  была   ли
        разрешена  или  запрещена  относительная  ширина символов.  Для
        получения   дополнительной   информации,   смотрите    описание
        управляющей       последовательности      ENABLERELATIVEWIDTHS,
        приведенное раннее в этой главе.

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 47 =

                                    GETVECTORBRUSHSIZE                         

             Синтаксис    short Escape(hDC,GETVECTORBRUSHSIZE,
                                            sizeof(LOGBRUSH),lpInData,
                                                             lpOutData)

             Эта управляющая   последовательность   получает в единицах
        устройства размер  перьевого  графопостроителя  для  заполнения
        замкнутых фигур.    GDI    использует    эту   информацию   для
        предотвращения рисования  перьевым   графопостроителем   поверх
        границ фигуры при заполнении замкнутых фигур.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     LOGBRUSH FAR *  Указывает на структуру данных
                          LOGBRUSH, определяющую   кисть   для  которой
                          должны быть возвращены данные.

             lpOutData    LPPOINT  Указывает на структуру данных POINT,
                          содержащую в  ее  втором  слове ширину пера в
                          единицах устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Это 1,  если управляющая последовательность
        выполнилась   успешно,  и  это  ноль,  если  последовательность
        закончена неудачно или не реализована.

        ───────────────────────────────────────────────────────────────
                                     GETVECTORPENSIZE                          

             Синтаксис    short Escape(hDC,GETVECTORPENSIZE,
                                              sizeof(LOGPRN),lpInData,
                                                             lpOutData)

             Эта управляющая   последовательность   получает в единицах
        устройства размер перьевого  графопостроителя.  GDI  использует
        эту информацию для предотвращения затирания шаблонами штриховой
        кисти границ  замкнутых фигур.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC       Идентифицирует контекст устройства

             lpInData     LOGPEN FAR *  Указывает на структуру данных
                          LOGPEN, определяющую  перо   для  которого
                          должна быть возвращена ширина.

       Windows 3.0/Ref/7#7                                       = 48 =


             lpOutData    LPPOINT  Указывает на структуру данных POINT,
                          содержащую в  ее  втором  слове ширину пера в
                          единицах устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Это 1,  если управляющая последовательность
        выполнилась   успешно,  и  это  ноль,  если  последовательность
        закончена неудачно или не реализована.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 49 =

                                         MFCOMMENT                             

             Синтаксис    BOOL Escape(hDC,MFCOMMENT,nCount,lpComment,
                                                                  NULL)

             Эта управляющая последовательность добавляет комментарий в
        метафайл.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC Идентифицирует контекст устройства для
                          устройства на котором расположен метафайл.

             nCount       short   Определяет   количество  символов   в
                          строке, на   которую    указывает    параметр
                          lpComment.

             lpComment    LPSTR    Указывает  на  завершающуюся   нулем
                          строку, содержащую комментарий, который будет
                          помещен в метафайл.

             Возвращаемая величина:

             Возвращаемая величина положительна, если функция завершена
        успешно,  и равна  -1,  если  имеет  место  ошибка  такая,  как
        нехватка памяти или некорректная спецификация порта.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 50 =

                                         NEWFRAME                              

             Синтаксис    short Escape(hDC,NEWFRAME,NULL,NULL,NULL)

             Эта управляющая  последовательность  сообщает  устройству,
        что   прикладная   программа   закончила  вывод  страницы.  Эта
        управляющая последовательность обычно используется с печатающим
        устройством  для  указания  драйверу  устройства  о переходе на
        новую страницу.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        это одна из следующих величин:

             Величина     Значение
             ────────     ────────

             SP_APPABORT  Процесс  был  прерван  и  завершен,  так  как
                          функция прерывания   прикладной    программмы
                          возвратила  0.

             SP_ERROR     Общая ошибка.

             SP_OUTOFDISK В   настоящее   время   нет   доступного  для
                          буферизации   дискового   пространства    или
                          другого доступного пространства.

             SP_OUTOFMEMORY  Для буферизации недостаточно памяти.

             SP_USERABORT Пользователь    прервал   процесс  с  помощью
                          программы PrintMahager.

             Комментарий:

             Не используйте управляющую последовательность  NEXTBAND  с
        последовательностью NEWFRAME. Для печати порциями, GDI передает
        метафайл  на    принтер,     моделируя     непрерывный      ряд
        последовательностей NEXTBAND.

             Управляющая последовательность NEWFRAME восстанавливает по
        умолчанию значения контекста устройства.  Поэтому, когда выбран
        шрифт, отличающийся от шрифта,  выбираемого  по  умолчанию,  во
        время вызова прикладной программой последовательности NEWFRAME,
        прикладная  программа  должна   выбрать   шрифт   снова   после
        последовательности NEWFRAME.
        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 51 =

                                         NEXTBAND                              

             Синтаксис    short Escape(hDC,NEXTBAND,NULL,NULL,
                                                            lpBandRect)

             Эта управляющая   последовательность   сообщает   драйверу
        устройства, что прикладная программа закончила вывод фрагмента,
        заставляя драйвер устройства послать фрагмент в программу Print
        Manager  и  возвратить  координаты  следующего  фрагмента.  Эта
        управляющая   последовательность    используется    прикладными
        программами, самостоятельно обрабатывающими фрагменты.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpBandRect   LPRECT Указывает на  структуру  данных  RECT,
                          которая будет  получать координаты следующего
                          фрагмента.Драйвер     устройства     копирует
                          координаты   следующего   фрагмента   в   эту
                          структуру.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        это одна из следующих величин:

             Величина     Значение
             ────────     ────────

             SP_APPABORT  Процесс  был  прерван  и  завершен,  так  как
                          функция прерывания   прикладной    программмы
                          возвратила  0.

             SP_ERROR     Общая ошибка.

             SP_OUTOFDISK В   настоящее   время   нет   доступного  для
                          буферизации   дискового   пространства    или
                          другого доступного пространства.

             SP_OUTOFMEMORY  Для буферизации недостаточно памяти.

             SP_USERABORT Пользователь  прервал    процесс   с  помощью
                          PrintMahager.

             Комментарий:

             Последовательность NEXTBAND   устанавливает  прямоугольник

       Windows 3.0/Ref/7#7                                       = 52 =

        следующего фрагмента  в  пустой  прямоугольник,  когда   печать
        достигла конца страницы.

             Не используйте управляющую последовательность  NEWFRAME  с
        последовательностью NEXTBAND.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 53 =

                                        PASSTROUGH                             

             Синтаксис    short Escape(hDC,PASSTROUGH,nCount,lpInData,
                                                                  NULL)

             Эта управляющая  последовательность  позволяет  прикладной
        программе посылать данные прямо на принтер,  обходя стандартный
        код драйвера принтера.

             Примечание:

             Для использования  этой  управляющей   последовательности,
        прикладная программа  должна  иметь полную информацию о том как
        работает принтер в особом режиме.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             nCount       short    Определяет  число  байт на  которые,
                          указывает параметр lpInData.

             lpInData     LPSTR  Указывает  на  структуру, первое слово
                          (16 бит)  которой содержит число байт входных
                          данных. Остальные   байты   этой    структуры
                          содержат сами данные.

             Возвращаемая величина:

             Возвращаемая величина    определяется   количеством   байт
        переданных на  принтер,   если   последовательность   завершена
        успешно. Она  меньше нуля,  если управляющая последовательность
        не реализована,    и    меньше    или    равна    нулю,    если
        последовательность не завершена успешно.

             Комментарий:

             Могут быть ограничения в типах данных устройства,  которые
        прикладная программа может послать устройству без помехи работе
        драйвера. В  общем  случае прикладные программы должны избегать
        "сброса" принтера или принуждения печати страницы.

             Мы настоятельно рекомендуем, чтобы прикладная программы не
        выполняли функций, которым требуются память принтера, такие как
        загрузка шрифта или макроопределений.

             Прикладная программа может избежать порчи ее потока данных
        если используется  многократные,  последовательные  управляющие
        последовательности PASSTROUGH,  когда нет  доступа  к  принтеру
        лябыми другими путями в течении выполнения последовательности.

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 54 =

                                      QUERYESCSUPPORT                          

             Синтаксис    short Escape(hDC,QUERYESCSUPPORT,sizeof(int),
                                                         lpEscNum,NULL)

             Эта управляющая последовательность проверяет,  выполняется
        ли указанная управляющая функция драйвером устройства.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpEscNum     LPINT  Указывает на короткое целое  значение,
                          которое определяет  проверяемую   управляющую
                          последовательность.

             Возвращаемая величина:

             Возвращаемая величина   определяется   наличием  указанной
        управляющей последовательности.  Не равна 0  для  реализованной
        управляющей     последовательности;    в    противном    случае
        отрицательна.

             Когда параметр lpEscNum установлен в DRAWPATTERNRECT, то
        возвращаемая величина одна из следующих величин:

             Величина     Значение
             ────────     ────────

                0         DRAWPATTERNRECT не реализована.

                1         DRAWPATTERNRECT   реализована,   но  не   для
                          принтера HP   LaserJet   IIP;   этот  принтер
                          поддерживает белые правила.

                2         DRAWPATTERNRECT   реализована   для  принтера
                          HP   LaserJet   IIP.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 55 =

                                        RESTORE_CTM                            

             Синтаксис    short Escape(hDC,RESTORE_CTM,NULL,NULL,NULL)

             Эта управляющая     последовательность     восстанавливает
        сохраненную перед этим текущую матрицу преобразования.

             Текущая матрица преобразования контролирует способ которым
        координаты переводятся, вращаются и масштабируются устройством.
        Используя  матрицы прикладная программа может комбинировать эти
        операции в любом порядке для создания желаемого отображения для
        отдельной картинки.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.


             Возвращаемая величина:

             Возвращаемая величина    определяется    числом    вызовов
        управляющей последовательности  SAVE_CTM  без  соответствующего
        вызова последовательности RESTORE_CTM.  Если последовательность
        завершена не успешно, то возвращаемая величина -1.

             Комментарий:

             Прикладные программы   не   должны   принимать   на   себя
        инициализацию содержимого текущей матрицы преобразования.

             Эта управляющая  последовательность использует определение
        матрицы, базирующееся  на  модели   программного   графического
        интерфейса (GPI)  Microsoft OS/2 Presentation Manager,  которая
        является системой  целых   координат,   моделирующих   систему,
        которую использует GDI.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 56 =

                                         SAVE_CTM                              

             Синтаксис    short Escape(hDC,SAVE_CTM,NULL,NULL,NULL)

             Эта управляющая   последовательность   сохраняет   текущую
        матрицу преобразования.

             Текущая матрица преобразования контролирует способ которым
        координаты переводятся, вращаются и масштабируются устройством.
        Используя матрицы  прикладная программа может комбинировать эти
        операции в любом порядке для создания желаемого отображения для
        отдельной картинки.

             Прикладная программа может восстановить матрицу, используя
        управляющую последовательность RESTORE_CTM.

             Обычно прикладная  программа  сохраняет  текущую   матрицу
        преобразования перед  ее  изменением.  Это позволяет прикладной
        программе восстанавливать предыдущее состояние  при  завершении
        отдельной операции.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.


             Возвращаемая величина:

             Возвращаемая величина    определяется    числом    вызовов
        управляющей последовательности  SAVE_CTM  без  соответствующего
        вызова последовательности RESTORE_CTM.  Если последовательность
        завершена не успешно, то возвращаемая величина ноль.

             Комментарий:

             Прикладные программы   не   должны   принимать   на   себя
        инициализацию содержимого текущей матрицы преобразования.

             Эта управляющая  последовательность использует определение
        матрицы, базирующееся  на  модели   программного   графического
        интерфейса (GPI)  Microsoft OS/2 Presentation Manager,  которая
        является системой  целых   координат,   моделирующих   систему,
        которую использует GDI.

        ───────────────────────────────────────────────────────────────
                                     SELECTPAPERSOURCE                         

             Эта управляющая последовательность заменяется  управляющей
        последовательностью GETSETPAPERBINS и обеспечивается только для
        совместимости "сверху-вниз".  Новые прикладные программы должны
        использовать вместо нее последовательность GETSETPAPERBINS.


       Windows 3.0/Ref/7#7                                       = 57 =

        ──────────────────────────────────────────────────────────────
             SETABORTPROC

             Синтаксис    short Escape(hDC,SETABORTPROC,NULL,
                                                      lpAbortFunc,NULL)

             Эта управляющая  последовательность  устанавливает функцию
        прерывания при выводе  на  печать.

             Если прикладная   программа   хочет   иметь    возможность
        прерывать процесс печати при буферизации, она должна установить
        функцию прерывания перед процессом печати,  который запускается
        управляющей функцией STARTDOC. Программа Print Manager вызывает
        функцию   прерывания   при   буферизации,  позволяя  прикладной
        программе  отменить  процесс  печати  или  обработать   условие
        нехватки  дискового  пространства.  Если  функция прерывания не
        установлена,  то,  в том случае,  если  дискового  пространства
        недостаточно для буферизации,  процесс печати может завершиться
        неудано.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpAbortFunc  FARPROC   Указывает  на  функцию  прерывания,
                          предоставляемую прикладной        программой.
                          Смотрите нижеследующий          "Комментарий"
                          для получения детальной информации.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности. Она    положительна,    если    управляющая
        последовательность  выполнилась  успешно,  в  противном  случае
        отрицательна.

             Комментарий:

             Адрес функции,   передаваемый  как  параметр  lpAbortFunc,
        должен быть создан с помощью функции MakeProcInstance.

             Функция многократного    вызова    должна     использовать
        соглашения  по вызову языка Паскаль и должна быть объявлена как
        FAR. Функция прерывания должна иметь следующий вид:

             short FAR PASCAL AbortFunc(hPr,code)
             HDC hPr;
             short code;

             AbortFunc это   место   хранения   для    имени    функции
        поставляемого прикладной  программой.  Реальное имя должно быть
        экспортировано включением  его  в  оператор  EXPORTS  в   файле

       Windows 3.0/Ref/7#7                                       = 58 =

        определения модуля прикладной программы.

             Параметр     Описание
             ────────     ────────

             hPr          Идентифицирует контекст устройства.

             code         Определяет, не произошла ли  ошибка. Параметр
                          равен 0,   если   имеется   ошибка,  и  равен
                          SP_OUTOFDISK, если Print Manager  не  хватает
                          дискового пространства.  Прикладная программа
                          должна перейти в режим ожидания для получения
                          требуемого дискового пространства.

                          Если code   равен   SP_OUTOFDISK,  прикладная
                          программа не имеет функции прерывания печати.
                          Если это   так,   то  это  должно  выполнятся
                          программой Print Manager  посредством  вызова
                          функций PeekMesage или GetMessage.

             Возвращаемая величина:

             Возвращаемая величина  не  равна  0,  если операция печати
        продолжается, и равна 0, если она отменена.

        ───────────────────────────────────────────────────────────────
                                     SETALLJUSTVALUES                          

             Синтаксис    short Escape(hDC,SETALLJUSTVALUES,
                                           sizeof(JUST_VALUE_STRUCT),
                                                         lpInData,NULL)

             Эта управляющая   последовательность   устанавливает   все
        значения выравнивания текста, используемые для его вывода.

             Выравнивание текста - это процесс  вставки  дополнительных
        пикселей  между разделяющими символами в строке текста.  Символ
        пробела обычно используется как разделяющий символ.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpInData     JUST_VALUE_STRUCT FAR *    Указывает       на
                          структуру данных  JUST_VALUE_STRUCT,  которая
                          определяет  значения для выравнивания текста.
                          Смотрите  нижеследующий   "Комментарий"   для
                          получения дополнительной     информации     о
                          структуре JUST_VALUE_STRUCT.

             Возвращаемая величина:


       Windows 3.0/Ref/7#7                                       = 59 =

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Она    равна    1,    если   управляющая
        последовательность выполнилась успешно,  в противном случае это
        ноль.

             Комментарий:

             Параметр lpInData   указывает    на    структуру    данных
        JUST_VALUE_STRUCT, которая определяет значения для выравнивания
        текст, используемые    при     выводе     текста.     Структура
        JUST_VALUE_STRUCT имеет следующий формат:

             typedef struct {
                     short  nCharExtra;
                     WORD   nCharCount;
                     short  nBreakExtra;
                     WORD   nBreakCount;
             } JUST_VALUE_STRUCT;

             Эта структура имеет следуюшие поля:

             Поле         Описание
             ────         ────────

             nCharExtra   Определяет  общее  количество дополнительного
                          пространства (в  единицах  шрифта),   которое
                          должно  быть  распределено  сверх  количества
                          символов nCharCount.

             nCharCount   Определяет   число   символов,   к    которым
                          добавляется nCharExtra.

             nBreakExtra  Определяет  общее  количество дополнительного
                          пространства (в  единицах  шрифта),   которое
                          распределено    сверх   количества   символов
                          nBreakCount.

             nBreakCount  Определяет  число   разделяющих   символов, к
                          которым добавляется nBreakExtra.

             Единицы, используемые  для  nCharExtra и nBreakExtra,  это
        единицы шрифта  устройства  и  зависят  от  того  разрешена  ли
        относительная  ширина  символов управляющей последовательностью
        ENABLERELATIVEWIDTHS.

             Значения, устанавливаемые         этой         управляющей
        последовательностью,  применяются  в  последовательных  вызовах
        функции  TextOut.  Драйвер  прекращает  отводить дополнительное
        пространство,  определенное в поле nCharExtra, когда он выводит
        количество  символов,  определеное в поле nCharCount.  Он также
        прекращает отводить дополнительное пространство, определенное в
        поле   nBreakExtra,  когда  он  выводит  количество  симвовлов,
        определенное в поле nBreakCount.  Вызов  функции  GetTextExtent

       Windows 3.0/Ref/7#7                                       = 60 =

        для  этой же строки осуществляется непосредственно после вызова
        функции  TextOut,  которая  будет  обработана  тем   же   самым
        способом.

             Для того  чтобы  переопределить  параметры  выравнивания с
        помощью         функций         SetTextJustification          и
        SetTextCharacterExtra,прикладная   программа   должна   вызвать
        управляющую  функцию   SETALLJUSTVALUES   и   установить   поля
        nCharExtra и nBreakExtra равными нулю.

        ───────────────────────────────────────────────────────────────
                                     SET_ARC_DIRECTION                         

             Синтаксис    short Escape(hDC,SET_ARC_DIRECTION,
                                          sizeof(int),lpDirection,NULL)

             Эта управляющая  последовательность определяет направление
        в котором рисуются эллиптические дуги,  используя  функцию  GDI
        Arc.

             По общему  согласию эллиптические дуги рисуются GDI против
        часовой стрелки.  Эта последовательность  позволяет  прикладной
        программе рисовать линии, состоящие из дуг по часовой стрелке.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpDirection  LPINT   Указывает    на    короткое    целое,
                          определяющее напрвление дуги.  Это может быть
                          одна из следующих величин:

                          - COUNTERCLOCKWISE(0)

                          - CLOCKWISE(1)

             Возвращаемая величина:

             Возвращаемая величина это предыдущее значение  направления
        дуги.

             Комментарий:

             Эта управляющая   последовательность   создает  карту  для
        элементов языка  PostScript  и  предназначена   для   устройств
        направления PostScript.

        ───────────────────────────────────────────────────────────────
                                   SET_BACKGROUND_COLOR                        

             Синтаксис    short Escape(hDC,SET_BACKGROUND_COLOR,nCount,
                                                 lpNewColor,lpOldColor)

       Windows 3.0/Ref/7#7                                       = 61 =


             Эта управляющая    последовательность    устанавливает   и
        получает текущий цвет фона для устройства.

             Цвет фона  это  цвет  поверхности  дисплея  перед  началом
        рисования прикладной  программой  чего-либо на устройстве.  Эта
        последовательность особенно используется для цветных  принтеров
        и видеомагнитофонов.

             Эта управляющая  последовательность  должна  быть  послана
        перед тем как прикладная программа начнет рисовать  на  текущей
        странице.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             nCount       int   Определяет  количество  байт, указанных
                          параметром lpNewColor.

             lpNewColor   DWORD FAR * Указывает на 32-ух битовое целое,
                          определяющее желаемый   цвет    фона.    Этот
                          параметр может  быть  NULL,  если  прикладная
                          программа просто получает текущий цвет фона.

             lpOldColor   DWORD FAR * Указывает на 32-ух битовое целое,
                          определяющее предыдущий   цвет   фона.   Этот
                          параметр может  быть  NULL,  если  прикладная
                          программа не использует предыдущий цвет фона.

             Возвращаемая величина:

             Возвращаемая величина    TRUE,   если   последовательность
        была завершена успешно, и FALSE, если не успешно.

             Комментарий:

             По умолчанию цвет фона белый.

             Цвет фона сбрасывается на цвет  фона  по  умолчанию,  если
        драйвер   устройства   получил   последовательности   ENDDOC  и
        ABORTDOC.

        ───────────────────────────────────────────────────────────────
                                        SET_BOUNDS                             

             Синтаксис    short Escape(hDC,SET_BOUNDS,sizeof(RECT),
                                                         lpInData,NULL)

             Эта управляющая      последовательность      устанавливает
        ограничение прямоугольника для картинки, нарисованной драйвером
        устройства, поддерживающим  данный  контекст  устройства.   Она

       Windows 3.0/Ref/7#7                                       = 62 =

        используется при  создании  образов в файле такого формата, как
        Encapsulated PostScript(EPS)    и    Hewlett-Packard    Graphics
        Language(HPGL) для    которых    используется    этот   драйвер
        устройства.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpInData     LPRECT   Указывает на  структуру данных RECT,
                          определяющую в     координатах     устройства
                          прямоугольник,  ограничивающий образ, который
                          должен быть выведен.

             Возвращаемая величина:

             Возвращаемая величина    TRUE,   если   последовательность
        была завершена успешно, и FALSE, если не успешно.

             Комментарий:

             Прикладная программа   должна   выдавать  эту  управляющую
        последовательность перед  каждой  страницей   в   образе.   Для
        одностраничных образов,   эта  последовательность  должна  быть
        выдана  непосредственно перед последовательностью STARTDOC.

             Если прикладная  программа  использует  последовательности
        преобразующие координаты,    то   драйвер   может   некорректно
        вычислить  ограничительную  рамку.  Если  прикладная  программа
        использует  последовательность  SET_BOUNDS,  драйвер  не должен
        вычислять размеры ограничения.

             Прикладные программы  всегда  используют  эту  управляющую
        последовательность для    обеспечения    поддержки   печатающих
        возможностей Encapsulated   PostScript(EPS),   которые    будут
        встроены в будущие драйверы PostScript.

        ───────────────────────────────────────────────────────────────
                                       SETCOLORTABLE                           

             Синтаксис    short Escape(hDC,SETCOLORTABLE,
                                            sizeof(COLORTABLE_STRUCT),
                                                      lpInData,lpColor)

             Эта управляющая последовательность устанавливает элемент в
        цветовую таблицу RGB. Если устройство не поддерживает требуемый
        цвет,  функция устанавливает  ближайшее  существующее  цветовое
        значение.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

       Windows 3.0/Ref/7#7                                       = 63 =


             lpInData     COLORTABLE_STRUCT FAR *    Указывает       на
                          структуру данных  COLORTABLE_STRUCT,  которая
                          содержит  индекс  и  значение  RGB   элемента
                          цветовой таблицы.    Смотрите   нижеследующий
                          "Комментарий" для  получения   информации   о
                          структуре COLORTABLE_STRUCT.

             lpColor      DWORD FAR *   Указывает   на    длинное целое
                          значение,которое используется  для  получения
                          цветового значения RGB,  выбранного драйвером
                          устройства   для   представления   требуемого
                          цветового значения.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Она  положительна,    если   управляющая
        последовательность выполнилась успешно,  в противном случае она
        отрицательна.

             Комментарий:

             Структура данных COLORTABLE_STRUCT имеет следующий формат:

             typedef  struct {
                      WORD   Index;
                      DWORD  rgb;
             } COLORTSBLE_STRUCT;

             Эта структура имеет следующие поля:

             Поле         Описание
             ────         ────────

             Index        Определяет   индекс    цветовой      таблицы.
                          Значение индекса   равно   нулю  для  первого
                          элемента таблицы.

             rgb          Определяет требуемое цветовое значение RGB.


             Цветовая таблица устройства является разделяемым ресурсом;
        изменение цвета системного дисплея для одного окна  приводит  к
        изменению его  для  всех  окон.  Только  прикладные  программы,
        имеющие полную   информацию   о   драйвере    дисплея    должны
        использоваит эту управляющую последовательность.

             Управляющая последовательность SETCOLORTABLE не работает с
        устройствами, имеющими фиксированную цветовую таблицу.

             Эта управляющая   последовательность   предназначена   для

       Windows 3.0/Ref/7#7                                       = 64 =

        использования драйверами  как принтера,  так и дисплея.  Однако
        цветовые драйверы EGA и VGA не поддерживают ее.

             Эта управляющая   последовательность   изменяет   палитру,
        используемую  драйвером  дисплея.  Однако,  так  как  алгоритмы
        цветовых преобразований  драйверов  вероятно  больше  не  будут
        работать с различными палитрами, в эту последовательность будут
        добавлены расширения.

             Если цветовой индекс,  указанный параметром lpInData равен
        0xFFFF, драйвер должен разрешить все действия по преобразованию
        цветов в вызванной прикладной программе.  Прикладная  программа
        должна использовать      надлежащий      алгоритм     цветового
        преобразования и взять  на  себя  отвественность  за  передачу,
        правильно преобразованного  физического цвета драйверу ( вместо
        логического цвета RGB) в такие функции драйвера устройства, как
        RealizeObject и ColorInfo.

             Например, если   устройство   поддерживает  256  цветов  с
        индексами палитры от 0  до  255,  прикладная  программа  должна
        определить, какой индекс содержит нужный для использования цвет
        в определенной кисти.  Затем она должна передать этот индекс  в
        младший  байт  DWORD  логического  цвета,  переданного  функции
        драйвера  устройства  RealizeObject.   Драйвер   должен   затем
        использовать  это цвет,  как переданный,  вместо выполнения его
        обычного  алгоритма  преобразования  цветов.  Если   прикладная
        программа желает  заново активизировать алгоритм преобразования
        цветов драйвера (что нужно, когда она восстанавливает начальную
        палитру,  при  переключении  ее  контекста  окна),  то цветовой
        индекс указанный параметром lpInData должен быть равен 0xFFFE.

        ───────────────────────────────────────────────────────────────
                                       SETCOPYCOUNT                            

             Синтаксис    short Escape(hDC,SETCOPYCOUNT,sizeof(int),
                                            lpNumCopies,lpActualCopies)

             Эта управляющая последовательность определяет число  копий
        каждой страницы, которые печатает устройство печати.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpNumCopies  LPINT   Указывает на короткое целое значение,
                          содержащее число  копий,  которые должны быть
                          отпечатаны.

             lpActualCopies LPINT Указывает на короткое целое значение,
                          определяещее число  отпечатанных  копий.  Оно
                          может   быть   меньше,   чем    запрашиваемое
                          количество,  если  требуемое  число превышает

       Windows 3.0/Ref/7#7                                       = 65 =

                          максимально  допустимое   число   копий   для
                          устройства.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Она    равна    1,    если   управляющая
        последовательность выполнилась успешно,  равна  0,  если  имела
        место ошибка или функция не реализована в данной версии.

        ───────────────────────────────────────────────────────────────
                                       SETKERNTRACK                            

             Синтаксис    short Escape(hDC,SETKERNTRACK,sizeof(int),
                                                 lpNewTrack,lpOldTrack)

             Эта управляющая   последовательность   определяет,   какое
        значение    разрядки    будет     использоваться     драйвером,
        поддерживающим   автоматическую   разрядку.   Нулевое  значение
        запрещает автоматическую  разрядку.

             Если разрядка  разрешена,  драйвер   будет   автоматически
        выполнять  разрядку  всех  символов согласно специфицированному
        значению и будет придерживаться этой разрядки и при  печати,  и
        при вызовах функции GetTextExtent.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpNewTrack   LPINT   Указывает на короткое целое значение,
                          определяющее значение  используемой разрядки.
                          Нулевое значение запрещает разрядку. Значения
                          в диапазоне  от  1  до nKernTraсks (структура
                          EXTTEXTMETRIC  )  соответствуют  позициям   в
                          таблице  значений  разрядки  (1 соответствует
                          первму элементу  в  таблице).  Для  получения
                          дополнительной информации,  смотрите описание
                          структуры    EXTTEXTMETRIC,   приведенное   в
                          описании    управляющей    последовательности
                          GETEXTENDEDMETRICS.

             lpOldTrack   LPINT   Указывает  на короткое целое значение,
                          которое определяет     предыдущее    значение
                          разрядки.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.    Она    равна    1,    если   управляющая
        последовательность выполнилась успешно,  равна  0,  если  имела
        место ошибка или функция не реализована в данной версии.

       Windows 3.0/Ref/7#7                                       = 66 =


             Комментарий:

             По умолчанию автоматическая разрядка запрещена.

             Драйвер не    поддерживает   непосредственно   управляющую
        последовательность ENABLEPAIRKERNING, поскольку он обеспечивает
        прикладную  программу  таблицей  значений  разрядок  с  помощью
        последовательности    GETTRACKKERNTABLE.    В   случае,   когда
        GETTRACKKERNTABLE поддерживается, а функция SETKERNTRACK - нет,
        прикладная  программа  ответственна за корректное распределение
        символов на устройстве вывода.

        ───────────────────────────────────────────────────────────────
                                        SETLINECAP                             

             Синтаксис    short Escape(hDC,SETLINECAP,sizeof(int),
                                                     lpNewCap,lpOldCap)

             Эта управляющая  последовательность  устанавливает признак
        конца строки.

             Признак конца - это  та  часть  сегмента  строки,  которая
        появляется в конце каждого сегмента.  Признак может быть в виде
        небольшого квадрата или полукруга;  он  может  размещаться  вне
        пределов  специфицированных  концов  сегмента  или оставаться в
        пределах сегмента.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpNewCap     LPINT  Указывает на короткое целое  значение,
                          которое определяет   тип   признака    конца.
                          Возможные  величины  и  их значения приведены
                          ниже:

                          Величина     Значение
                          ────────     ────────

                            -1         Сегменты  строки  отображаются с
                                       признаком конца,    используемым
                                       GDI по умолчанию.


                             0         Сегменты  строки  отображаются с
                                       признаком конца в виде квадрата,
                                       который не выходит за  указанную
                                       длину сегмента.


                             1         Сегменты  строки  отображаются с

       Windows 3.0/Ref/7#7                                       = 67 =

                                       признаком конца  в  виде  круга;
                                       диаметр   этой   дуги   в   виде
                                       полукруга равен ширине строки.

                             2         Сегменты  строки  отображаются с
                                       признаком конца в виде квадрата,
                                       который   выходит   за   пределы
                                       указанной  длины   сегмента   на
                                       половину ширины строки.

             lpOldCap     LPINT  Указывает  на короткое целое значение,
                          которое соответствует          предшествующей
                          установке признака конца строки.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.   Она   положительна,   если    управляющая
        последовательность выполнилась успешно,  в противном случае она
        отрицательна.

             Комментарий:

             Интерпретация этой  управляющей  функции  изменяется   при
        использовании языка    описания    страницы   (PDL).   Смотрите
        документацию PDL для получения точного ее описания.

             Эта управляющая последовательность известна как SETENDCAP.

        ───────────────────────────────────────────────────────────────
                                        SETLINEJOIN                            

             Синтаксис    short Escape(hDC,SETLINEJOIN,sizeof(int)
                                                   lpNewJoin,lpOldJoin)

             Эта управляющая последовательность определяет, как драйвер
        устройства будет объединять два  сегмента  строки.  Пересечение
        сегментов может иметь округленную, прямую или скошенную форму.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpNewJoin    LPINT  Указывает на короткое целое  значение,
                          которое определяет тип пересечения. Возможные
                          величины и их значения приведены ниже:

                          Величина     Значение
                          ────────     ────────

                            -1         Сегменты   строки  объединяются,
                                       используя установку  в  GDI   по

       Windows 3.0/Ref/7#7                                       = 68 =

                                       умолчанию.

                             0         Сегменты строки объединяются под
                                       скошенным углом;  наружные  края
                                       строк  сближаются  до  тех  пор,
                                       пока они не встретят  скос.  Это
                                       так называемое   объединение  со
                                       скосом.

                             1         Сегменты строки объединяются под
                                       скругленным углом;  дуга в  виде
                                       полукруга,    имеющая   диаметр,
                                       равный      ширине       строки,
                                       отображается около  точки,   где
                                       строки   встречаются.   Это  так
                                       называемое    объединение     со
                                       скруглением.

                             2         Сегменты строки объединяются под
                                       прямым   углом;   наружные  края
                                       строк не   сближаются.  Это  так
                                       называемое     объединение     с
                                       обрезом.

             lpOldJoin    LPINT   Указывает на короткое целое значение,
                          которое соответствует          предшествующей
                          установке значения объединения строки.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.   Она   положительна,   если    управляющая
        последовательность выполнилась успешно,  в противном случае она
        отрицательна.

             Комментарий:

             Интерпретация этой  управляющей  функции  изменяется   при
        использовании языка    описания    страницы   (PDL).   Смотрите
        документацию PDL для получения точного ее описания.

             Если прикладная  программа  устанавливает  объединение  со
        скосом,  а  угол  пересечения  слишком мал,  драйвер устройства
        игнорирует эту установку и использует вместо нее объединение  с
        обрезом.

        ───────────────────────────────────────────────────────────────
                                       SETMITERLIMIT                           

             Синтаксис    short Escape(hDC,SETMITERLIMIT,nCount,
                                                 lpNewMiter,lpOldMiter)

             Эта управляющая      последовательность      устанавливает

       Windows 3.0/Ref/7#7                                       = 69 =

        минимальный скос для устройства.  Минимальный  скос  определяет
        угол,   начиная   с   которого   драйвер   устройства  заменяет
        объединение со скосом на объединение с обрезом.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             nCount       short  Определяет количество байт, на которые
                          указывает параметр lpNewMiter.

             lpNewMiter   LPINT   Указывает на короткое целое значение,
                          которое определяет      минимальный     скос.
                          Корректными являются  значения,  большие  или
                          равные  -1.  Если  это значение равно -1,  то
                          драйвер будет использовать минимальный  скос,
                          установленный в GDI по умолчанию.

             lpOldMiter   LPINT   Указывает на короткое целое значение,
                          которое соответствует          предшествующей
                          установке минимального скоса.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.   Она   положительна,   если    управляющая
        последовательность выполнилась успешно,  в противном случае она
        отрицательна.

             Комментарий:

             Минимальный скос определяется следующим образом:

                 длина скоса         1
                ─────────────   = ───────
                ширина строки     sin(X/2)

             X равен углу объединения строк в радианах.

             Интерпретация этой  управляющей  функции  изменяется   при
        использовании языка    описания    страницы   (PDL).   Смотрите
        документацию PDL для получения точного ее описания.

        ───────────────────────────────────────────────────────────────
                                       SET_POLY_MODE                           

             Синтаксис    short Escape(hDC,SET_POLY_MODE,sizeof(int),
                                                           lpMode,NULL)

             Эта управляющая      последовательность      устанавливает
        множественный режим   для  драйвера  устройства.  Множественный
        режим   -   это   состояние    переменой    показывающей    как

       Windows 3.0/Ref/7#7                                       = 70 =

        интерпретируются вызовы функций Polygon и Polyline.

             Последовательность SET_POLY_MODE     разрешает    драйверу
        устройства  рисовать  очертания  (такие  как  дуги  Безье),  не
        поддерживаемые   напрямую   GDI.   Это   позволяет   прикладным
        программам,  рисующим сложные кривые,  посылать описание кривой
        прямо  на  устройство  без имитации кривой как многоугольника с
        большим количеством точек.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpMode       LPINT      Указывает   на  короткое    целое,
                          определяющее   множественный           режим.
                          Множественный режим - это состояние переменой
                          показывающей как должны быть интерпретированы
                          вызовы функций   Polygon   и   Polyline.  Все
                          драйверы устройств не требуют поддержки  всех
                          возможных    режимов.    Драйвер   устройства
                          возвращает  ноль,  если  он  не  поддерживает
                          определенный режим.  Этот параметр может быть
                          одной из следующих величин:

                          Величина     Значение
                          ────────     ────────

                          PM_POLYLINE(1) Точки определяют обусловленные
                                       многоугольник или ломанную.

                          PM_BEZIER(2)       Точки           определяют
                                       последовательность 4-ех точечных
                                       кривых   Безье.   Первая    дуга
                                       проходит   через  первые  четыре
                                       точки,  с  конечными  первой   и
                                       четвертой       точками,       и
                                       контрольными  второй  и  третьей
                                       точками.                  Каждая
                                       подпоследовательность   дуги   в
                                       последовательности         имеет
                                       конечную точку предыдущей  дуги,
                                       как  свою  начальную,  следующие
                                       две  точки  -   контрольные,   и
                                       третью - конечнаую.

                                       Последней         дуге         в
                                       последовательности   разрешается
                                       иметь меньше четырех точек. Если
                                       дуга имеет  только  одну  точку,
                                       она  считается точкой.  Если она
                                       имеет две точки, то это отрезок.
                                       Если  дуга  имеет три точки,  то

       Windows 3.0/Ref/7#7                                       = 71 =

                                       это    парабола,    определенная
                                       рисуемой  дугой Безье с первой и
                                       третьей  конечной   точками,   и
                                       двумя    контрольными    точками
                                       равными второй точке.

                          PM_POLYLINE-
                          SEGMENT(3)   Точки    определяют     перечень
                                       координатных пар.  Отрезок линии
                                       рисуется    соединением   каждой
                                       последовательной пары точек.

             Возвращаемая величина:

             Возвращаемая величина  -  это   предыдущий   множественный
        режим. Если  возвращаемая величина ноль,  то драйвер устройства
        не поддерживает запрос данного режима.

             Комментарий:

             Прикладная программа    должна    выдавать     управляющую
        последовательность SET_POLY_MODE   перед   рисованием   сложной
        кривой. Затем она должна вызвать функцию Polygon или Polyline с
        желаемыми точками   управления,   определяющими  кривую.  После
        отображения кривой,  прикладная  программа  должна   "сбросить"
        драйвер в его предыдущее состояние используя последовательность
        SET_POLY_MODE.

             Вызовы Polyline рисуют используя текущее выбранное перо.

             Вызовы Polygon рисуют используя текущие перо и кисть. Если
        начальная и   конечная   точки  не  равны,  линия  рисуется  от
        начальной точки     до     конечной      перед      заполнением
        многоугольника(или дуги).

             GDI обращается   к   вызовам   Polygon,   используя  режим
        PM_POLYLINESEGMENT точно так же как к вызовам Polyline.

             Четыре точки определят кривую Безье.  GDI создает  кривую,
        соединяя первую и вторую, вторую и третью, и третью и четвертую
        точки. Затем GDI соединяет средние точки этих  последовательных
        отрезков. И   наконец   GDI   соединяет  средние  точки  линий,
        соединяющих средние точки, и так далее.

             Отрезки линий  нарисованные  таким  образом   сходятся   к
        кривой, определенной  следующими  параметрическими уравнениями,
        выраженными как функция независимой переменой t.

             X(t) = ...............................

             Y(t) = ..............................

             Точки ( ,  ),( ,  ),( ,  ) и ( , ) - это контрольные точки

       Windows 3.0/Ref/7#7                                       = 72 =

        определяющие кривую.  Независимая  переменная t изменяется от 0
        до 1.

             Более простые типы,  чем  PM_BEZIER  и  PM_POLYLINESEGMRNT
        могут быть   добавлены  в  эту  последовательность  в  будущем.
        Прикладные программы  должны  проверять  возвращаемое  значение
        этой   управляющей   последовательности  для  определения  того
        поддерживает ли  драйвер  или  нет  определенный  множественный
        режим.

        ───────────────────────────────────────────────────────────────
                                     SET_SCREEN_ANGLE                          

             Синтаксис    short(hDC,SET_SCREEN_ANGLE,sizeof(int),
                                                          lpAngle,NULL)

             Эта управляющая  последовательность  устанавливает текущий
        угол экрана в желаемое значение  угла  и  разрешает  прикладной
        программе   имитировать   вращение  фотографической  маски  при
        создании  цветового  разделения  для  определенного   основного
        цвета.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpAngle      LPINT   Указывает на короткое целое значение,
                          определяющее нужный  угол  экрана  в  десятых
                          долях градуса.   Угол   отмеривается   против
                          часовой стрелки.

             Возвращаемая величина:

             Возвращаемая величина   -   это  предыдущий  угол  наклона
        зкрана.

             Комментарий:

             Четырех-цветовой процесс   разделения   -   это   процесс,
        разделяющий  цвета,  заключающие изображение в четыре первичных
        компоненты:  голубой,  сиреневый,  желтый и черный. Изображение
        затем   заново   отображается  перепечатывая  каждую  первичную
        компоненту.

             В обычном  процессе  четырех-цветовой   печати,   полутона
        изображений для   каждой   из   четырех   первичных   компонент
        отображаются против  вращения  маски  на   определенный   угол.
        Вращение маски  при  этом  способе  минимизирует  нежелательные
        муаровые шаблоны,  заставляющие перепечатывать  два  или  более
        цветов.

             Драйвер устройства определяет угол экрана по умолчанию.
        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 73 =

                                        SET_SPREAD                             

             Синтаксис    short Escape(hDC,SET_SPREAD,suzeof(int),
                                                         lpSpread,NULL)

             Эта управляющая последовательность устанавливает число, на
        которое "непробельные"  примитивы   расширяются   для   данного
        устройства, для  обеспечения  незначительного  перекрытия между
        примитивами,   для   компенсации   недостатков    в    процессе
        воспроизведения.

             Разделения цвета  на  области  -  это  процесс  разделения
        изображения  на  каждый  отчетливый   цвет   использованный   в
        изображении.   Изображение   воспроизводится   перепечатыванием
        каждого цвета в изображении по порядку.

             Когда воспроизводится изображение разделенное на  области,
        печатающее  оборудование  должно  быть градуировано для точного
        выравнивания  каждой  страницы  на   каждый   проход.   Однако,
        изменение температуры,  влажности и так далее,  между проходами
        часто бывают причиной для выравнивания недостатков  изображения
        в последующих  проходах.  По этой причине,  линии в разделенных
        областях часто   слегка   расширяются   (развертываются)    для
        компенсации недостатков   в   регистрируемых   последовательных
        проходах через  принтер.  Это   процесс   называется   трапинг.
        Управляющая последовательность    SET_SPREAD   реализует   этот
        процесс.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpSpread     LPINT   Указывает на короткое целое значение,
                          определяющее число,  в пикселях,  на  которое
                          все   "непробельные"  примитивы  должны  быть
                          расширенны.

             Возвращаемая величина:

             Возвращаемая величина - это предыдущее значение расширения.

             Комментарий:

             По умолчанию расширение примитивов равно нулю.

             Текущее расширение  применяется   для   всех   обрамляющих
        примитивов (несмотря на то, видима ли или нет рамка) и текста.

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 74 =

                                         STARTDOC                              

             Синтаксис    short Escape(hDC,STARTDOC,nCount,lpDocName,
                                                                  NULL)

             Эта управляющая   последовательность   сообщает   драйверу
        устройства,  что начался новый процесс вывода на печать,  и что
        все последующие вызовы NEWFRAME должны буферизироваться под тем
        же самым процессом до тех пор, пока не встретится вызов ENDDOC.
        Это дает уверенность в том,  что вывод документа размером более
        одной страницы не будет пересекаться с другими процессами.

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             nCount       short  Определяет количество байт, на которые
                          указывает параметр lpDocName.

             lpDocName    LPINT    Указывает  на  оканчивающуюся  нулем
                          строку, содержащую   имя    документа.    Имя
                          документа    выводится   в   окне   программы
                          PrintManager. Максимальная длина этой  строки
                          31    символ    плюс   заканчивающий   строку
                          нуль-символ.

             Возвращаемая величина:

             Возвращаемая величина определяется результатом управляющей
        последовательности.  Равна -1, если произошла такая ошибка, как
        переполнение памяти  или  некорректная  спецификация  порта;  в
        противном случае положительна.

             Комментарий:

             Правильная последовательность событий при операции  вывода
        на печать:

             1. Создать контекст устройства.

             2. Установить  функцию  прерывания,  чтобы  не   допустить
             сброса операции  печати  при  ошибках  выхода  за  пределы
             дискового пространства.

             Процедура прерывания,  которая  обрабатывает  эти  ошибки,
             должна быть    установлена    с    помощью     управляющей
             последовательности SETABORTPROC.

             3. Начать операцию печати последовательностью STARTDOC.

             4. Начинать каждую новую страницу с NEWFRAME или каждый
             новый фрагмент с NEXTBAND.


       Windows 3.0/Ref/7#7                                       = 75 =

             5. Окончить операцию печати  последовательностью ENDDOC.

             6. Разрушить панель диалога отмены, в любом случае.

             7. Освободить   адрес   процедуры   инициализации  функции
             прерывания.


             Когда прикладная  программа неожиданно обнаруживает ошибку
        печати или отменяет операцию печати,  то она не должна пытаться
        прервать  операцию  печати,  используя  функцию  Escape  либо с
        управляющей последовательностью ENDDOC,  либо с  ABORTDOC.  GDI
        автоматически  прерывает  операцию  перед возвращением значения
        ошибки.

        ───────────────────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 76 =

                                       TRANSFORM_CTM                           

             Синтаксис    short Escape(hDC,TRANSFORM_CTM,36,lpMatrix,
                                                                  NULL)

             Эта управляющая    последовательность   изменяет   текущую
        матрицу преобразования.    Текущая    матрица    преобразования
        контролирует способ которым координаты переводятся, вращаются и
        масштабируются устройством.  Используя   матрицы,   вы   можете
        комбинировать   эти  операции  в  любом  порядке  для  создания
        желаемого отображения для отдельной картинки.

             Новая текущая матрица преобразования (CTM) будет содержать
        результирующую матрицу  (M),  указанную  параметром  lpMatrix и
        предыдущую текущую матрицу преобразования ( CTM = M * CTM ).

             Параметр     Тип / Описание
             ────────     ──────────────

             hDC          HDC     Идентифицирует  контекст устройства.

             lpMatrix    LPSTR  Указывает на массив  3 * 3   32-битовых
                         величин, определяющих      новую       матрицу
                         преобразования.     Элементы     в     матрице
                         масштабированы  для  представления   чисел   с
                         фиксированной  точкой.  Каждый элемент матрицы
                         не  больше  65,536.  Старшее  слово   элемента
                         содержит  целую  часть числа,  а младшее слово
                         содержит дробную часть.

             Возвращаемая величина:

             Возвращаемая величина равна TRUE,  если последовательность
        была завершена успешно, и равна FALSE, если не успешно.

             Комментарий:

             Прикладные программы   не   должны   принимать   на   себя
        инициализацию содержимого текущей матрицы преобразования.

             Эта управляющая  последовательность использует определение
        матрицы, базирующееся  на  модели   программного   графического
        интерфейса (GPI)  Microsoft OS/2 Presentation Manager,  которая
        является системой  целых   координат,   моделирующих   систему,
        которую использует GDI.

         ──────────────────────────────────────────────────────────────




       Windows 3.0/Ref/7#7                                       = 77 =

                       Глава 13. ОБЗОР МАКРОКОМАНД ЯЗЫКА АССЕМБЛЕРА            
       ----------------------------------------------------------------

             Язык ассемблера  для  программ  работающих  под  Microsoft
        Wimdows это   высоко-структурированные   программы   на   языке
        ассемблера, которые используют высоко-уровневые  соглашения  по
        вызовам, а также соглашения по функциям Windows, типам данных и
        программированию. Если вы создаете ассемблерную  программу  для
        Windows с  использованием Макро Ассемблера фирмы Microsoft,  то
        результатом работы будет являться  объектный  код,  аналогичный
        объектному коду, созданному  C  компилятором.  Эта  глава  дает
        некоторые советы,  которые могут  помочь  вам  достичь  нужного
        результата при создании прикладной программы.

             Инструментарий разработчика     (SDK)     включает    файл
        CMACROS.INC. Этот файл содержит макроопределения языка высокого
        уровня, которые   определяют   сегменты,   программные  модули,
        интерфейсы функций  и  типы  данных, необходимые  для  создания
        прикладной   программы.   Макрокоманды  C  содержат  параметры,
        необходимые во время выполнения трансляции,  которые определяют
        модель памяти и соглашения по вызову,  используемые прикладными
        программами .  Параметры должны быть выбраны до того, как будет
        использована директива INCLUDE для включения файла CMACROS.INC.

             В этом  разделе описываются макрокоманды C и дается важная
        информация по созданию прикладных программ для Windows на языке
        ассемблера. Глава включает в себя следующие разделы:

             - Как  создавать прикладные программы для Windows на языке
               ассемблера

             - Обзор макрокоманд C

             - Как использовать макрокоманды C в прикладных  программах
               на языке ассемблера



       Windows 3.0/Ref/7#7                                       = 78 =

             13.1 Советы  по  созданию прикладных программ  для Windows        
            на языке ассемблера
       ----------------------------------------------------------------
             При  создании  прикладной  программы  для Windows на языке
        ассемблера, для использования макрокоманд C вы должны  добавить
        к исходному файлу вашей прикладной программы  следующие пункты:

             1. Определить модель  памяти  путем  установки  одного  из
        параметров: memS, memM, memC или memL в единицу.

             2. Определить соглашения по вызову Паскаля путем установки
        параметра  ?PLM  в  единицу.  Это  необходимо  для   прикладных
        программ, которые будут вызваны Windows.

             3. Разрешить  использование  инициализации  и   завершения
        путем установки параметра ?WIN в единицу.

             4. Включить файл CMACROS.INC в  исходный  файл  прикладной
        программы.
             Оператор, который включает  CMACROS.INC, должен находиться
        после операторов описанных в предыдущих пунктах.

             5. Создать  точку  входа  в прикладную программу,  функцию
        WinMain, и убедиться, что она объявлена как общая (public).

             6. Объявить функции многократного вызова,  как это описано
        в разделе 13.1.6, "Объявление функций многократного вызова".

             7. После ассемблирования исходного файла, скомпонуйте файл
             с вашим объектным кодом  с  соответствующими  библиотеками
        языка C для Windows.

             Следующие разделы описывают эти шаги более детально.

                                13.1.1 Выбор модели памяти                     
       ----------------------------------------------------------------

             Параметры модели  памяти  специфицируют   модель   памяти,
        используемую  прикладной  программой.  Модель памяти определяет
        количество кодовых сегментов и сегментов данных,  принадлежащих
        прикладной программе. Существуют следующие модели памяти:

             Модель       Описание
             ──────       ────────
             Малая        Один кодовый сегмент и один сегмент данных.

             Средняя      Несколько  кодовых  сегментов и один  сегмент
                          данных.

             Компактная   Один кодовый  сегмент и   несколько сегментов
                          данных.


       Windows 3.0/Ref/7#7                                       = 79 =

             Большая      Несколько   кодовых  сегментов   и  сегментов
                          данных.

             Максимальная Несколько   кодовых   сегментов  и  сегментов
                          данных, причем  размер одного  или нескольких
                          из них превышает 64 Кбайта.

             Параметр памяти  выбирается  посредством   определения   в
        начале  исходного файла на языке ассемблера одного из следующих
        имен параметров, перечисленных в таблице 13.1:


        Таблица 13.1                                   Параметры памяти
        ───────────┬──────────────┬──────────────┬─────────────────────
           Имя     │ Модель       │   Размер     │     Размер
        параметра  │ памяти       │  кодового    │    сегмента
                   │              │  сегмента    │     данных
        ───────────┼──────────────┼──────────────┼─────────────────────
           memS    │ малая        │   малый      │      малый
           memM    │ средняя      │   большой    │      малый
           memL    │ большая      │   большой    │      большой
           memC    │ компактная   │   малый      │      большой
           memH    │ максимальная │   большой    │      большой
        ───────────┴──────────────┴──────────────┴─────────────────────

             Имя может  быть   определено   посредством   использования
        директивы EQU. Определение имеет форму:

             memM     EQU    1

             Если никакой   параметр   не   выбран,   то  по  умолчанию
        используется имя "memS", т.е. малая модель.

             Выбор параметра  модели  памяти  завершается  определением
        двух   символов,  значения  которых  представляют  собой  коды,
        зависящие от модели памяти:

             SizeC        0 = малый размер  кодового  сегмента
                          1 = большой размер кодового сегмента

             SizeD        0 = малый размер сегмента данных
                          1 = большой размер сегмента данных
                          2 = максимальный размер сегмента данных

                                13.1.2 Соглашения по вызову                    
       ----------------------------------------------------------------

             Параметр соглашения  по  вызову  определяет  соглашение по
        вызову  языка   высокого   уровня,   используемого   прикладной
        программой.   Соглашение   по   вызову  выбирается  посредством
        определения значения символа ?PLM.  В приведенной ниже  таблице
        13.2 перечислены эти значения и соответствующие соглашения.

       Windows 3.0/Ref/7#7                                       = 80 =


        Таблица 13.2                               Соглашения по вызову
        ──────────┬──────────────┬─────────────────────────────────────
         Значение │  Соглашение  │           Описание
          ?PLM    │              │
        ──────────┼──────────────┼─────────────────────────────────────
            0     │  Стандарт C  │  При вызове  крайний правый аргумент
                  │              │  заносится в  стек  первым,  крайний
                  │              │  левый    -   последним.   Аргументы
                  │              │  выбираются из стека после  возврата
                  │              │  управления.
                  │              │
            1     │  Pascal      │  При вызове  крайний  левый аргумент
                  │              │  записывается в стек  первым,  самый
                  │              │  правый   -   последним.   Вызванная
                  │              │  функция   выбирает   аргументы   из
                  │              │  стека.
        ──────────┴──────────────┴─────────────────────────────────────

             Значение символа  ?PLM  может  устанавливаться посредством
        использования директивы =. Оператор имеет форму:

             ?PLM = 1

             По умолчанию устанавливается соглашение языка Паскаль. Оно
        обязательно для функций, которые вызываются Windows.

             13.1.3 Параметр  разрешения   инициализации/завершения   в        
             операционной среде Windows.
       ----------------------------------------------------------------

             Параметр инициализации/завершения    операционной    среды
        Windows определяет,  должен ли использоваться с каждой функцией
        специальный код инициализации/завершения.  Этот специальный код
        определяет  текущий  сегмент  данных  для  данной   функции   и
        необходим для прикладной программы в среде Windows.

             Этот параметр  выбирается посредством определения значения
        символа ?WIN. В приведенной таблице 13.3 перечислены значения и
        соглашения:

        Таблица 13.3            Параметры кода инициализации/завершения
        ─────────────┬─────────────────────────────────────────────────
         Значение    │              Назначение
           ?WIN      │
        ─────────────┼─────────────────────────────────────────────────
             0       │   Разрешение специального кода инициализации/
                     │   завершения
             1       │   Запрещение специального кода инициализации/
                     │   завершения
        ─────────────┴─────────────────────────────────────────────────


       Windows 3.0/Ref/7#7                                       = 81 =

             Значение символа ?WIN  может  устанавливаться  посредством
        использования директивы =. Оператор имеет форму:

             ?WIN = 1

             По  умолчанию  разрешается режим инициализации/завершения.

                                                                               
            13.1.4 Включение файла CMACROS.INC
       ----------------------------------------------------------------

             Файл CMACROS.INC содержит определения на языке  Ассемблера
        всех макрокоманд C. Этот файл должен быть включен в начало
        транслируемого  исходного   файла   посредством   использования
        директивы INCLUDE. Эта строка имеет вид:

             INCLUDE cmacros.inc

             Полный маршрут должен быть указан в том случае,  если файл
        макрокоманд находится не в текущем  рабочем  каталоге  и  не  в
        каталоге, специфицированном в командной строке.

             Для полного  описания каждой макрокоманды,  смотрите Главу
        14, "Список макрокоманд языка ассемблера".

                    13.1.5 Создание точки входа в прикладную программу         
       ----------------------------------------------------------------

             Создайте точку  входа  в  прикладную программу WinMain,  и
        убедитесь, что она объявлена как  общая  (public).  Это  должно
        выглядеть следующим образом:

             cProc WinMain, <PUBLIC>, <si, di>
                   parmW    hInstance
                   parmW    hPrevInstance
                   paramD   lpCmdLine
                   paramW   nCmdShow
             cBegin WinMain
                   .
                   .
                   .
             cEnd WinMain

             sEnd

             Функция WinMain должна быть определена внутри стандартного
        кодового сегмента CODE.



       Windows 3.0/Ref/7#7                                       = 82 =

                                                                               
            13.1.6 Объявление Функций многократного вызова
       ----------------------------------------------------------------
             Убедитесь, что   каждая   функция   многократного   вызова
        определена следующим образом:

             cProc TestWndProc, <FAR, PUBLIC>, <si, di>
                   parmW        hWnd
                   parmW        message
                   parmW        wParam
                   parmD        lParam
             cBegin TestWndProc
                   .
                   .
                   .
             cEnd TestWndProc

             Функции многократного вызова должны быть определены внутри
        кодового сегмента.
                                                                               
            13.1.7 Компановка с библиотеками
       ----------------------------------------------------------------
             После ассемблирования  исходного  файла  вашей  прикладной
        программы, вы   должны   скомпановать   объектные    файлы    с
        соответствующими библиотеками языка C.

             Если часть   прикладной   программы   написана   на  языке
        ассемблера, для  правильной  компановки  вам  будет  необходимо
        добавить внешнее определение для абсолютного символа __acrtused
        в исходном файле вашей прикладной программы.


                                                                               
            13.1.8 Контроль стека
       ----------------------------------------------------------------
             Контроль стека может быть разрешен посредством определения
        символа  ?CHKSTK.  Если  контроль  разрешен,  то для размещения
        локальных     переменных     код     инициализации     вызывает
        внешнеопределенную подпрограмму CHKSTK.

             Значение символа     ?CHKSTK     должно    устанавливаться
        посредством использования директивы =. Оператор имеет форму:

             ?CHKSTK = 1

             Если символ CHKSTK определен,  то контроль стека  разрешен
        для   всего   файла.

             По умолчанию  (когда  символ  CHKSTK не определен) стек не
        контролируется.




       Windows 3.0/Ref/7#7                                       = 83 =

                                 13.2 Группа макрокоманд C                     
       ----------------------------------------------------------------

             В глава   14,   "Список   макрокоманд   языка  ассемблера"
        представлен список и описание макрокоманд C, являющийся набором
        макрокоманд  языка  ассемблера,  который может быть использован
        совместно с  макроассемблером  MASM  для  создания   прикладных
        программ   Windows   на   языке   ассемблера.   Макрокоманды  C
        обеспечивают простой интерфейс соглашений по вызову  функций  и
        работы с сегментами языков высокого уровня, таких как Cи.

             Cmacros делится на следующие группы:

             - макрокоманды работы с сегментами

             - макрокоманды распределения памяти

             - макрокоманды работы с функциями

             - макрокоманды вызова

             - специальные макрокоманды определения

             - макрокоманды обработки ошибок

             В последующих пунктах подробно описываются каждая груп-
        па макрокоманд.

                          13.2.1 Макрокоманды работы с сегментами              
       ----------------------------------------------------------------

             Макрокоманды работы с сегментами  дают  доступ  к  кодовым
        сегментам   и   сегментам  данных,  используемым  в  прикладной
        программе.  Эти сегменты должны иметь имена, атрибуты, классы и
        группы, требуемые операционной средой Windows.

             Cmacros  имеет два предопределенных сегмента, именуемых
        CODE и DATA, которые без специальных определений  может  ис-
        пользовать  любая прикладная программа.

             Имя макрокоманды          Описание
             ────────────────          ────────

             createSeg                 Эта макрокоманда  создает  новый
                                       сегмент, имеющий указанное имя и
                                       атрибуты.


             sBegin                    Эта макрокоманда       открывает
                                       сегмент.  Она подобна  директиве
                                       Ассемблера SEGMENT.


       Windows 3.0/Ref/7#7                                       = 84 =

             sEnd segName              Эта макрокоманда       закрывает
                                       сегмент.  Она подобна  директиве
                                       Ассемблера ENDS.

             assumes                   Эта макрокоманда   делает    все
                                       ссылки   на   данные  и  коды  в
                                       сегменте segName,   относительно
                                       сегментного регистра segReg. Она
                                       подобна   директиве   Ассемблера
                                       ASSUME.

             dataOFFSET arg            Эта макрокоманда      генерирует
                                       смещение   относительно   начала
                                       группы,   к   которой  относится
                                       сегмент   DATA.   Она    подобна
                                       оператору Ассемблера OFFSET, но,
                                       в отличие от него, автоматически
                                       задает имя группы.  Поэтому, эта
                                       макрокоманда              должна
                                       использоваться  вместо оператора
                                       OFFSET.

             codeOFFSET arg            Эта макрокоманда      генерирует
                                       смещение   относительно   начала
                                       группы,  к  которой  принадлежит
                                       сегмент    CODE.   Она   подобна
                                       оператору Ассемблера OFFSET, но,
                                       в отличие от него, автоматически
                                       задает имя группы.  Поэтому, эта
                                       макрокоманда              должна
                                       использоваться вместо  оператора
                                       OFFSET.

             segNameOFFSET arg         Эта макрокоманда      генерирует
                                       смещение   относительно   начала
                                       группы,  к  которой  принадлежит
                                       сегмент  segName,   определенный
                                       пользователем.    Она    подобна
                                       оператору Ассемблера OFFSET, но,
                                       в отличие от него, автоматически
                                       задает имя группы.  Поэтому, эта
                                       макрокоманда              должна
                                       использоваться вместо  оператора
                                       OFFSET.

                         13.2.2 Макрокоманды распределения памяти              
       ----------------------------------------------------------------

             Эти макрокоманды    распределяют    статическую     память
        (собственную/закрытую или общую),  описывает внешнеопределенную
        память и процедуры и дают определение общих меток.


       Windows 3.0/Ref/7#7                                       = 85 =

             Имя макрокоманды          Описание
             ────────────────          ────────

             staticX                   Эта макрокоманда    распределяет
                                       частную/закрытую     статическую
                                       память.

             globalX                   Эта макрокоманда    распределяет
                                       общую статическую память.

             externX                   Эта макрокоманда  определят одно
                                       или более  имен,  которые  будут
                                       метками  внешних  переменных или
                                       функций.

             labelX                    Эта макрокоманда определят  одно
                                       или   несколько   имен,  которые
                                       будут метками внешних переменных
                                       или функций.

                          13.2.3 Макрокоманды работы с функциями               
       ----------------------------------------------------------------

             Макрокоманды работы   с   функциями   определяют    имена,
        атрибуты, параметры и локальные переменные функций.

             Имя макрокоманды          Описание
             ────────────────          ────────

             cProc                     Эта макрокоманда  определяет имя
                                       и атрибуты функции.

             parmX                     Эта макрокоманда определяет один
                                       или     несколько     параметров
                                       функции.  Параметры обеспечивают
                                       доступ       к       аргументам,
                                       передаваемым функции.

             localX                    Эта макрокоманда определяет одну
                                       или      несколько     групповых
                                       переменных  для   функции.

             cBegin                    Эта макрокоманда      определяет
                                       фактическую  точку   входа   для
                                       функции  procName.

             cEnd                      Эта макрокоманда      определяет
                                       точку выхода  для   определенной
                                       функции.



       Windows 3.0/Ref/7#7                                       = 86 =

                                13.2.4 Макрокоманды вызова                     
       ----------------------------------------------------------------

             Макрокоманды вызова  могут   использоваться   для   вызова
        функций  cProc  и  функций  на  языке программирования высокого
        уровня.  Эти макрокоманды передают аргументы в  соответствии  с
        соглашениями  по  вызову,  определенными  при  помощи параметра
        ?PLM.

             Имя макрокоманды          Описание
             ────────────────          ────────


             cCall                     Эта макрокоманда  заносит в стек
                                       определенные          аргументы,
                                       сохраняет  регистры  (если   это
                                       необходимо)      и      вызывает
                                       определенную функцию.

             Save                      Эта макрокоманда    предписывает
                                       следующей  за  ней  макрокоманде
                                       cCall  перед   вызовом   функции
                                       сохранить  указанные  регистры в
                                       стеке и  восстановить  их  после
                                       выполнения функции. Макрокоманда
                                       Save может быть использована для
                                       сохранения   регистров,  которые
                                       разрушаются вызванной функцией.

             Arg                       Эта макрокоманда  определяет  те
                                       аргументы,     которые     будут
                                       переданы   функции   посредством
                                       следующей макрокоманды cCall.

                                                                               
            13.2.5 Специальные макрокоманды определения
       ----------------------------------------------------------------

             Специальные макрокоманды определения информируют Cmacros о
        переменных,     определяемых    пользователем, об использовании
        функционального регистра и об указателях регистра.


             Имя макрокоманды          Описание
             ────────────────          ────────

             Def                       Эта макрокоманда    регистрирует
                                       имя   переменной,   определенной
                                       пользователем с помощью Cmacros.

             FarPtr                    Эта макрокоманда      определяет
                                       значение  32-битового указателя,
                                       передаваемого как один  аргумент
                                       макрокоманде cCall.

       Windows 3.0/Ref/7#7                                       = 87 =


                           13.2.6 Макрокоманды обработки ошибок                
       ----------------------------------------------------------------

             Макрокоманды обработки  ошибок  выдают сообщение об ошибке
        на системный дисплей и на печать.  Как  текст,  который  вызвал
        ошибку, так и результат его оценки находят отражение в выданном
        сообщении об ошибке.

             Макрокоманды обработки    ошибок    позволяют    вставлять
        операторы контроля  в  транслируемую  исходную  программу.  Они
        допускают    использование    оптимальных   последовательностей
        инструкций для некоторых операций,  основанных на распределении
        переменных или битовой позиции флага в слове.


             Имя макрокоманды          Описание
             ────────────────          ────────


             errnz                     Эта макрокоманда       вычисляет
                                       заданное     выражение.     Если
                                       результат   не  равен  нулю,  то
                                       индицируется ошибка.

             errn$                     Эта макрокоманда        вычитает
                                       смещение   label   из   величины
                                       смещения   счетчика   адреса   и
                                       прибавляет  величину   аргумента
                                       bias  к  полученному результату.
                                       Если результат  не  равен  нулю,
                                       индицируется ошибка.




       Windows 3.0/Ref/7#7                                       = 88 =

                                                                               
            13.3 Использование Cmacros
       ----------------------------------------------------------------

             В этом  подразделе  объясняются  действия операторов языка
        Ассемблера,  генерируемых  некоторыми   функциями   Cmacros   и
        иллюстрируется  их  использование  на  примере функции Cmacros,
        называемой BITBLT.

                                    13.3.1 Замена типов                        
       ----------------------------------------------------------------

             Параметры и     локальные    переменные,    созданные    с
        использованием   макрокоманд   parmX   и   localX    фактически
        преобразуются в выражения вида:

             LocalB x     ==>     x equ byte ptr [bp+nn]

             ParmB y      ==>     x equ byte ptr [bp+nn],

        где nn - смещение относительно текущего значения регистра BP.

             Эти выражения   допускают  употребление  имен  без  явного
        указания типа в операторах  "type  ptr"  и  "[BP]+offset".  Это
        означает,  что  на  "x"  и  на  "y"  можно  ссылаться следующим
        образом:

             mov       al,x

             mov       al,y

             Проблема возникает  при  замене  типов.  Ассемблер  выдает
        сообщение об ошибке в том случае, если встретится строка

             mov       ax,word ptr x.

             Эта ситуация  разрешается  посредством  заключения имени в
        скобки:

             mov       ax,word ptr (x).

             Исключением из   вышеизложенного   является   макрокоманда
        LocalV.  Выражение, созданное посредством этой макрокоманды, не
        имеет связанного с ним типа.  Поэтому,  оно может заменяться  и
        без скобок. Например:

             LocalV    horse,10     ==>     horse equ [bp+nn].


                                                                               
            13.3.2 Переопределение символов
       ----------------------------------------------------------------

             Любой символ,  определенный посредством макрокоманды parmX
        в одной функции,  может быть переопределен как параметр в любой

       Windows 3.0/Ref/7#7                                       = 89 =

        другой  функции.  Это позволяет различным функциям ссылаться на
        тот же самый параметр с тем же самым именем,  не взирая на  его
        расположение в стеке.

                              13.3.3 Cmacros: пример функции                   
       ----------------------------------------------------------------

             Следующий пример определяет функцию ассемблера BITBLT. Эта
        функция имеет   тип   FAR  и  PUBLIC.Когда  вызывается  BITBLT,
        регистры SI и DI автоматически сохраняются,  а после выхода  из
        нее - автоматически восстанавливаются.  Отметим, что регистр BP
        сохраняется в любом случае.

             Функция BITBLT записывает в стек семь длинных  указателей.
        Пространство  в  стеке  распределяется между восемью фреймовыми
        переменными (одна структура, пять байтов и два слова).

             Макрокоманда cBegin   определяет    начало    фактического
        кодового  сегмента.  Загружается  параметр  pExt,  а  некоторые
        значения записываются в регистры.  Регистры DS и SI сохраняются
        в следующей макрокоманде cCall.

             Другая функция  языка  C,  THERE,  вызывается  посредством
        макрокоманды cCall.  Этой функции передаются четыре  аргумента:
        pDestBitmap,  32-битовый  указатель в DI:SI,  регистры AX и BX.
        Макрокоманда записывает  аргументы  в  стек  в  соответствующем
        порядке.

             Когда функция   THERE  возвращает  управление,  аргументы,
        записанные в стек,  автоматически удаляются и регистры DS и  SI
        восстанавливаются.

             Когда выполняется макрокоманда cEnd,  фреймовые переменные
        уничтожаются,   все    автоматически    сохраняемые    регистры
        восстанавливаются     и     происходит    возврат    управления
        соответствующего типа (ближнего или дальнего).

             Следующий пример показывает как определена функция BITBLT:

             cProc BITBLT, <FAR,PUBLIC>,<si,di>

             ParmD     pDestBitmap     ;--> дескриптор растра
                                       ;                  приемника
             ParmD     pDestOrg        ;--> начальный адрес
                                       ;                  приемника
             ParmD     pSrcBitmap      ;--> дескриптор растра
                                       ;                  источника
             ParmD     pSrcOrg         ;--> начальный адрес
                                       ;                  источника
             ParmD     pExt            ;--> протяженность прямоу-

       Windows 3.0/Ref/7#7                                       = 90 =

                                       ;                   гольника
             ParmD     pRop            ;--> дескриптор  растровых
                                       ;                   оперций
             ParmD     pBrush          ;--> физическая кисть
             LocalV    nOps,4          ;# использующегося каждым
                                       ;                 операндом
             LocalB    phaseH          ;горизонтальная фаза (счет-
                                       :чик циклического сдвига)
             LocalB    PatRow          ;текущая строка для образцов
                                       ;[0...7]
             LocalB    direction       ;флаг увеличения/уменьшения
             LocalW    startMask       ;маска первого байта
                                       ;                  приемника
             LocalW    lastMask        ;маска последнего байта
                                       ;                  приемника
             LocalB    firstFetch      ;число необходимых первых
                                       ;                    выборок
             LocalB    stepDirection   ;направление движения (влево,
                                       ;                     вправо)
             cBegin

             lds       si,pExt
             mov       ax,extentX[si]
             mov       bx,extentY[si]

             RegPtr    dest,ds,si
             Save      <ds,si>

             cCall     THERE,<pDestBitmap,dest,ax,bx>

             mov       ax,extentX[si],cx
             mov       bx,extentY[si],dx

             \.
             \.
             \.
             cEnd




       Windows 3.0/Ref/7#7                                       = 91 =

                                      13.4 Заключение                          
       ----------------------------------------------------------------

             Файл CMACROS.INC определяет сегменты,  программные модули,
        функции и  типы  данных,  необходимые  для  создания прикладных
        программ Windows.   Cmacros   предоставляет   данные   процесса
        ассемблирования, которые  определяют модель памяти и соглашения
        по вызову, которые прикладная программа будет использовать. Для
        получения дополнительной   информации  по  темам,  связанным  с
        Cmacros смотрите следующие  разделы:


             Тема                      Раздел
             ────                      ──────

             Описания Cmacros          Справочное   руководство, Том 2:
                                       Глава 14,   "Список  макрокоманд
                                       языка ассемблера"

             Использование             Tools:   Глава 2,       "Linking
             компоновщика              Aplications:The Linker"

             Использование             Microsoft Macro Assembler
             макроассесблера           Programmer's Guide





       Windows 3.0/Ref/7#7                                       = 92 =

                                                                               
            Глава 14. СПИСОК МАКРОКОМАНД ЯЗЫКА АССЕМБЛЕРА
       ----------------------------------------------------------------

             Эта глава  описывает  макрокоманды  C Cmacros,  являющиеся
        набором  макрокоманд  языка  ассемблера,  который  может   быть
        использован  совместно  с  макроассемблером  MASM  для создания
        прикладных программ Windows на языке ассемблера. Макрокоманды C
        обеспечивают  простой  интерфейс соглашений по вызову функций и
        работы с сегментами языков высокого уровня, таких как Cи.

             В этой главе  макрокоманды  C  представлены  в  алфавитном
        порядке и каждая макрокоманда детально описана.

        ───────────────────────────────────────────────────────────────
                                            Arg                                

             Синтаксис    Arg nameList

             Эта макрокоманда определяет те  аргументы,  которые  будут
        переданы  функции  посредством  следующей  макрокоманды  cCall.
        Аргументы заносятся в стек в  заданном  порядке.  Этот  порядок
        должен соответствовать порядку параметров функции.

             Перед каждой  макрокомандой  cCall может быть задано более
        одной макрокоманды Arg.  Множество макрокоманд Arg дают тот  же
        эффект, что и одна макрокоманда.


             Параметр nameList - список имен  аргументов,  передаваемых
        функции.  Все имена должны быть предварительно определены.

             Примечания:

             Параметры типа   байт   передаются   как  слова,  т.е.  не
        производится  расширение  знаковым   разрядом   или   обнуление
        старшего байта.

             Непосредственно передаваемые аргументы не поддерживаются.

             Примеры:

             Arg     var1
             Arg     var2
             Arg     var3
             Arg     <var1,var2,var3>
        ───────────────────────────────────────────────────────────────
                                                                               
            assumes

             Синтаксис    assumes segReg, segName

             Эта макрокоманда  все  ссылки  на данные и коды в сегменте
        segName делает относительно сегментного  регистра  segReg.  Она
        подобна директиве Ассемблера ASSUME.

       Windows 3.0/Ref/7#7                                       = 93 =


             Параметр segReg определяет имя сегментного регистра.

             Параметр segName определяет имя предопределенного сегмента
        (CODE или DATA) или сегмента, определенного пользователем.

             Примеры:

             assumes CS, CODE
             assumes DS, CODE
        ───────────────────────────────────────────────────────────────
                                                                               
            cBegin

             Синтаксис    cBegin procName

             Эта макрокоманда  определяет  фактическую  точку входа для
        функции   procName.   Она   создает   сегмент   кода,   который
        устанавливает фрейм и сохраняет регистры.

             procName -  необязательный аргумент,  представляющий собой
        имя функции.  Если он задан, то должен быть тем же самым, что и
        в  макрокоманде  cProc,  которая  непосредственно  предшествует
        макрокоманде cBegin.

        ───────────────────────────────────────────────────────────────
                                           cCall                               

             Синтаксис    cCall procName,[<argList>],[underscores]

             Эта макрокоманда   заносит   в   стек  аргументы  argList,
        сохраняет регистры (если это  необходимо)  и  вызывает  функцию
        procName.

             Параметр procName определяет имя вызываемой функции.

             Параметр argList  - необязательный список имен аргументов,
        передаваемых функции.  Этот список  не  требуется,  если  перед
        макрокомандой   cCall   используется   макрокоманда  Arg.

             Параметр underscores  -  необязательный аргумент,  который
        специфицирует,  должен  ли   предшествовать   procName   символ
        подчеркивания. Если  аргумент  пуст и соглашения по вызову есть
        соглашения по вызову C, то подчеркивание включается.

             Примечания:

             Аргументы макрокоманды  Arg  заносятся в стек раньше,  чем
        любые аргументы из списка argList макрокоманды cCall.

             Параметры типа  байт  передаются  как   слова,   т.е.   не
        производится   расширение   знаковым   разрядом  или  обнуление
        старшего байта.


       Windows 3.0/Ref/7#7                                       = 94 =

             Непосредственно передаваемые аргументы не поддерживаются.

             Примеры:

             cCall    there,<pExt,ax,bx,pResult>
             Arg      pExt
             Arg      ax
             cCall    there,<bx,pResult>
        ───────────────────────────────────────────────────────────────
                                           cEnd                                

             Синтаксис    cEnd procName

             Эта макрокоманда   определяет  точку  выхода  для  функции
        procName.  Эта  макрокоманда  создает  код,  который  разрушает
        фрейм,   восстанавливает   содержимое  регистров  и  возвращает
        управление вызвавшему блоку.

             Параметр procName     -      необязательный      аргумент,
        представляющий собой имя функции. Если он задан, то должен быть
        тем  же  самым,  что   и   в   макрокоманде   cBegin,   которая
        непосредственно предшествует макрокоманде cBegin.

             Если функция  определяется  при помощи макрокоманды cProc,
        то  все  ее  формальные   параметры   должны   быть   объявлены
        макрокомандой parmX, а все локальные переменные - макрокомандой
        localX.  Макрокоманды cBegin и cEnd должны  использоваться  для
        описания кода функции. Ниже приведен пример полного определения
        функции:

             cProc   strcpy,<PUBLIC>,<si,di>
                 parmW   dst
                 parmW   src
                 localW  cnt

             cBegin
                 cld
                 mov     si,src
                 mov     di,dest
                 push    ds
                 pop     es
                 xor     cx,cx
                 mov     cnt,cx
             loop:
                 lodsb
                 stosd
                 inc     cnt
                 cmp     al,0
                 jnz     loop
                 mov     ax,cnt
             cEnd

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                       = 95 =

                                                                               
            codeOFFSET

             Синтаксис    codeOFFSET arg

             Эта макрокоманда  генерирует  смещение относительно начала
        группы,  к  которой  принадлежит  сегмент  CODE.  Она   подобна
        оператору   Ассемблера   OFFSET,   но,   в   отличие  от  него,
        автоматически задает  имя  группы.  Поэтому,  эта  макрокоманда
        должна использоваться вместо оператора OFFSET.

             Параметр arg определяет имя метки или величину смещения.

             Пример:

             mv ax,codeOFFSET lable
        ───────────────────────────────────────────────────────────────
                                           cProc                               

             Синтаксис    cProc procName, <attributes>, <autoSave>

             Эта макрокоманда определяет имя и атрибуты функции.

             Параметр procName определяет имя функции.

             Параметр attributes    специфицирует   тип   функции.   Он
        представляет собой комбинацию следуюших типов:

             Тип                       Описание
             ───                       ────────

             NEAR                      Ближняя функция.  Она может быть
                                       вызвана только из того сегмента,
                                       в котором определена.

             FAR                       Дальняя функция.  Она может быть
                                       вызвана из любого сегмента.

             PUBLIC                    Общая функция.  Она  может  быть
                                       объявлена  как  внешняя в других
                                       исходных файлах.

             Атрибутами по     умолчанию      являются      NEAR      и
        собственная/закрытая  (т.е.  функция,  которая  не  может  быть
        объявлена как внешняя в других исходных файлах).  Атрибуты NEAR
        и  FAR  не  могут использоваться вместе.  Если выбирается более
        одного аргумента attribute,  то необходимо использовать угловые
        скобки.

             Параметр autoSave определяет список регистров,  содержимое
        которых  должно   быть   сохранено   при   вызове   функции   и
        восстановлено   при  возврате.  Могут  быть  указаны  любые  из
        регистров микропроцессора 8086.


       Windows 3.0/Ref/7#7                                       = 96 =

             Примечания:

             Соглашение по вызову языка  C  требует,  чтобы  содержимое
        регистров SI и DI сохранялось при изменении.

             Содержимое регистра   BP   сохраняется   в  любом  случае,
        независимо от того, был ли он представлен в списке autoSave.

             Примеры:

             cProc proc1, <FAR>, <ds,es>
             cProc proc2, <NEAR,PUBLIC>
             cProc proc3,,ds
        ───────────────────────────────────────────────────────────────
                                         createSeg                             

             Синтаксис    createSeg segName, logName, align, combine,
                                                                  class

             Эта макрокоманда создает новый сегмент,  имеющий указанное
        имя и атрибуты.  Она автоматически создает для нового  сегмента
        макрокоманду assumes и оператор OFFSET для вычисления смещения.
        Она предназначена для использования со средней  моделью  памяти
        Windows для  определения  нерезидентных  сегментов в прикладной
        программе.

             Параметр segName  -  фактическое  имя  сегмента.  Это  имя
        передается компоновщику.

             Параметр logName   -  логическое  имя  сегмента.  Это  имя
        используется во всех последующих макрокомандах sBegin,  sEnd  и
        assumes, ссылающихся на зтот сегмент.

             Параметр align - тип выравнивания.  Он может быть одним из
        следующих:

                          BYTE
                          WORD
                          PARA
                          PAGE

             Параметр combine - комбинированный тип сегмента.  Он может
        быть одним из следующих:

                          PUBLIC
                          STACK
                          MEMORY
                          COMMON

             Если не  задан  комбинированный  тип,  то  подразумевается
        собственный/закрытый сегмент.

             Параметр class  -  имя   класса   сегмента.   Имя   класса

       Windows 3.0/Ref/7#7                                       = 97 =

        определяет,  какой  сегмент  должен  загружаться  в непрерывную
        память.

             Пример:

             createSeg   _INIT,INITCODE,BYTE,PUBLIC,CODE

             sBegin  INITCODE
             assumes CS:INITCODE

                    mov ax,initcodeOFFSET  sample

             sEnd    INITCODE

             Примечание:

             Выравнивание, комбинированный тип и  имя  класса  подробно
        описаны в документации по Макроассемблеру MASM.

             Cmacros имеет  два  предопределенных  сегмента,  именуемых
        CODE   и   DATA,  которые  без  специальных  определений  может
        использовать любая прикладная программа.  Прикладные  программы
        средней, большой  и максимальной модели памяти могут определять
        дополнительные сегменты, используя макрокоманду createSeg.

        ───────────────────────────────────────────────────────────────
                                                                               
            dataOFFSET

             Синтаксис    dataOFFSET arg

             Эта макрокоманда  генерирует  смещение относительно начала
        группы, к которой относится сегмент DATA. Она подобна оператору
        Ассемблера OFFSET,  но, в отличие от него, автоматически задает
        имя группы.  Поэтому,  эта макрокоманда  должна  использоваться
        вместо оператора OFFSET.

             Параметр arg определяет имя метки или величину смещения.

             Пример:

             mv ax,dataOFFSET lable
        ───────────────────────────────────────────────────────────────
                                           DefX                                

             Синтаксис    DefX <nameList>

             Эта макрокоманда регистрирует имя переменной, определенной
        пользователем с помощью Cmacros. На переменные, которые не были
        определены  с  помощью макрокоманд staticX,  globalX,  externX,
        parmX или localX, нельзя ссылаться в других макрокомандах, если
        имя  не было зарегистрировано или переменная не была определена
        с помощью директивы Ассемблера DW.


       Windows 3.0/Ref/7#7                                       = 98 =

             Параметр X   специфицирует   размер   памяти,   занимаемой
        переменной. Он может принимать одно из следующих значений:

             Тип                       Описание
             ───                       ────────
             B                         байт

             W                         слово

             D                         двойное слово

             Q                         учетверенное слово

             T                         слово, состоящее из десяти  байт

             CP                        указатель кода ( одно  слово для
                                       маленькой и компактной модели)

             DP                       указатель данных ( одно слово для
                                      маленькой  и компактной модели)


             Параметр namelist - список определяемых имен переменных.

             Пример:

             maxSize db     132
                     DefB   maxSize
             dest    equ        wordptr   es:[di]
                     DefW        dest

        ───────────────────────────────────────────────────────────────
                                           errn$                               

             Синтаксис    errn$ label,bias

             Эта макрокоманда  вычитает  смещение  label  из   величины
        смещения счетчика адреса и прибавляет величину аргумента bias к
        полученному  результату.  Если   результат   не   равен   нулю,
        индицируется ошибка.

             Параметр label  -  соответствующая  ячейка памяти.

             Параметр bias - знак смещения. Требуется знак "+" или "-".

             Пример:

             ;             конец предыдущего кодового сегмента
                           errn$     function1
             function1:

             Если функция, первоначально размещенная сразу после другой
        части кодового сегмента,  изменила местоположение, макрокоманда

       Windows 3.0/Ref/7#7                                       = 99 =

        errn$ выдает сообщение об ошибке.


        ───────────────────────────────────────────────────────────────
                                           errnz                               

             Синтаксис    errnz <expression>

             Эта  макрокоманда  вычисляет  заданное   выражение.   Если
        результат не равен нулю, то индицируется ошибка.

             Параметр  expression - выражение, значение которого должно
        быть вычислено. Если  в  выражении  присутствуют  пробелы,  оно
        должно быть заключено в угловые скобки.

             Примеры

             x     db     ?
             y     db     ?

             mov   ax, word ptr x
             errnz <(OFFSET y) - (OFFSET x) - 1>

             Если во  время трансляции  x и y получают  что-либо, кроме
        последовательных  адресов  памяти,  макрокоманда  errnz  выдает
        сообщение об ошибке.

             table1                       struc
                                          .
                                          .
                                          .
             table1len                    equ             $-table1
             table1                       ends

             table2                       struc
                                          .
                                          .
             table2len                    equ             $-table2
             table2                       ends
             errnz    table1Len-table2Len

             Если  во  время  трансляции  длина  двух  таблиц  не будет
        одинаковой, макрокоманда errnz выдаст сообщение об ошибке.

             Макрокоманды   обработки   ошибок   позволяют    вставлять
        операторы  контроля  в  транслируемую  исходную  программу. Они
        допускают   использование    оптимальных    последовательностей
        инструкций  для некоторых операций, основанных на распределении
        переменных или битовой позиции флага в слове.

             Макрокоманды  обработки  ошибок выдают сообщение об ошибке
        на системный дисплей и на печать.  Как  текст,  который  вызвал
        ошибку, так и результат его оценки находят отражение в выданном

       Windows 3.0/Ref/7#7                                      = 100 =

        сообщении об ошибке.


        ───────────────────────────────────────────────────────────────
                                          externX                              

             Синтаксис    externX <namelist>

             Эта макрокоманда определят одно или  более  имен,  которые
        будут метками внешних переменных или функций.

             Параметр  X  определяет  размер памяти или тип функции. Он
        может быть одним из следующих:

             Тип          Описание
             ───          ────────

             A            Константа, определенная директивами EQU или =
                          в разделяемом файле

             B            Байт

             W            Слово

             D            Двойное слово

             Q            Учетверенное слово

             T            Десять байт

             CP           Указатель  кода  (одно слово   для   малой  и
                          компактной моделей памяти)

             DP           Указатель данных  (одно  слово  для  малой  и
                          средней моделей памяти)

             NP           Ближняя функция

             FP           Дальняя функция

             P            Ближняя   для   малой  и  компактной  моделей
                          памяти, дальняя для других моделей

             Параметр namelist определяет список  имен  переменных  или
        функций.

             Примеры:

             externB <DataBase>
             externFP <SampleRead>

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                      = 101 =

                                                                               
            FarPtr

             Синтаксис    FarPtr name, segment, offset

             Эта макрокоманда  определяет   значение   32-ух   битового
        указателя,  передаваемого как один аргумент макрокоманде cCall.
        В макрокоманде FarPtr значения аргументов segment и  offset  не
        должны находиться в регистрах.

             Параметр name определяет имя создаваемого указателя.

             Параметр  segment  это текст, определяющий часть "segment"
        указателя.

             Парамтр offset  это  текст,  определяющий  часть  "offset"
        указателя.

             Пример:

             FarPtr    destPtr,es,<wordptr 3[si]>
             cCall     proc,<destPtr,ax>


        ───────────────────────────────────────────────────────────────
                                          globalX                              

             Синтаксис    globalX name, [initialValue] [replication]

             Эта макрокоманда распределяет общую статическую память.

             Параметр  X  определяет  размер  распределяемой памяти. Он
        может быть любым из следующих:

             Тип          Описание
             ───          ────────

             B            Байт

             W            Слово

             D            Двойное слово

             Q            Учетверенное слово

             T            Десять байт

             CP           Указатель  кода  (одно  слово  для   малой  и
                          компактной моделей памяти)

             DP           Указатель  данных (одно  слово  для  малой  и
                          средней моделей памяти)

             Параметр name  определяет  имя  ссылки  на  распределяемую
        память.

       Windows 3.0/Ref/7#7                                      = 102 =


             Необязательный параметр initialValue определяет  начальную
        величину памяти. По умолчанию эта величина равна нулю.

             Необязательный  параметр  replication  определяет  счетчик
        числа  повторений  распределения.   Этот   аргумент   порождает
        оператор Ассемблера DUP.

             Примеры:

             globalW flag,1
             globalB string,0, 30

        ───────────────────────────────────────────────────────────────
                                          labelX                               

             Синтаксис    labelX <namelist>

             Эта   макрокоманда  определяет одно  или  несколько  имен,
        которые будут метками общих переменных или функций.

             Параметр X  определяет размер памяти или тип  функции.  Он
        может быть одним из следующих:

             Тип          Описание
             ───          ────────

             B            Байт

             W            Слово

             D            Двойное слово

             Q            Учетверенное слово

             T            Десять байт

             CP           Указатель  кода  (одно  слово   для  малой  и
                          компактной моделей памяти)

             DP           Указатель  данных (одно  слово  для  малой  и
                          средней моделей памяти)

             NP           Ближняя функция

             FP           Дальняя функция

             P            Ближняя   для   малой  и  компактной  моделей
                          памяти, дальняя для других моделей

             Параметр   namelist   определяет   список   имен   внешних
        переменных или функций.


       Windows 3.0/Ref/7#7                                      = 103 =

             Примеры:

             labelB <DataBase>
             labelFP <SampleRead>

        ───────────────────────────────────────────────────────────────
                                          localX                               

             Синтаксис    localX <namelist>,size

             Эта макрокоманда определяет одну или  несколько  фреймовых
        переменных  для  функции. Для поддержки выравнивания на слово в
        стеке, должна быть уверенность в том, что размещенное свободное
        пространство памяти  располагается   в   четном   числе   байт.

             Параметр  X  определяет  размер памяти. Он может принимать
        одно из следующих значений:

             Тип          Описание
             ───          ────────

             B            Байт (размещает в стеке один байт памяти)

             W            Слово (выравнено на границу слова)

             D            Двойное слово (выравнено на границу слова)

             V            Переменный размер(выравнено на границу слова)

             Q            Учетверенное  слово  (выравнено  на   границу
                          слова)

             T            Слово,  состоящее из десяти байт   (выравнено
                          на  границу слова)

             CP           Указатель кода (используется так же, как и  в
                          других случаях)

             DP           Указатель  данных (используется так же, как и
                          в других случаях)

             Параметр  namelist  определяет   список   имен   фреймовых
        переменных  функции.

             Параметр  size определяет размер переменной. Этот аргумент
        используется только в макрокоманде localV.

             Комментарий:

             Переменные типа B не обязательно  выравнивать  на  границу
        слова.

             Макрокоманда    localD    создает    два    дополнительных

       Windows 3.0/Ref/7#7                                      = 104 =

        идентификатора:  OFF_name  и   SEG_name.   OFF_name   -   часть
        "смещение" в параметре; SEG_name - часть "сегмент".

             Когда  происходит  ссылка  на соответствующий аргумент, то
        требуется только имя параметра.

             Верно:

             mov     al,var1

             Неверно:

             mov     al,byte ptr var1[bp]

             Примеры:

             LocalB <L1,L2,L3>
             LocalW L4
             LocalD <L5>
             LocalV L6,%(size struc)

        ───────────────────────────────────────────────────────────────
                                           parmX                               

             Синтаксис    parmX <namelist>

             Эта макрокоманда определяет один или несколько  параметров
        функции.    Параметры   обеспечивают   доступ   к   аргументам,
        передаваемым функции. Параметры должны быть расположены  в  том
        же порядке, что и аргументы в строке вызова функции.

             Параметр X определяет размер памяти. Он может быть одним из
        следующих:

             Тип          Описание
             ───          ────────

             B            Байт (размещает в стеке один байт памяти)

             W            Слово (выравнено на границу слова)

             D            Двойное слово (выравнено на границу слова)

             Q            Учетверенное  слово  (выравнено  на   границу
                          слова)

             T            Слово,  состоящее из десяти  байт  (выравнено
                          на границу слова)

             CP           Указатель кода (используется так же, как и  в
                          других случаях)

             DP           Указатель  данных (используется так же, как и

       Windows 3.0/Ref/7#7                                      = 105 =

                          в других случаях)

             Параметр namelist определяет список имен параметров.

             Комментарий:

             Макрокоманда     parmD    создает    два    дополнительных
        идентификатора:  OFF_name  и   SEG_name.   OFF_name   -   часть
        "смещение" в параметре; SEG_name - часть "сегмент".

             Когда  происходит  ссылка  на соответствующий аргумент, то
        требуется только имя параметра.

             Верно:

             mov     al,var1

             Неверно:

             mov     al,byte ptr var1[bp]

             Примеры:

             ParmW var1
             ParmB <var2,var3,var4>
             ParmD <var5>

        ───────────────────────────────────────────────────────────────
                                           Save                                

             Синтаксис    Save <regList>

             Эта    макрокоманда    предписывает   следующей   за   ней
        макрокоманде cCall,  перед вызовом функции, сохранить указанные
        регистры  в  стеке  и восстановить их после выполнения функции.
        Макрокоманда  Save  может  быть  использована  для   сохранения
        регистров, которые разрушаются вызванной функцией.

             Save  работает  только с одной макрокомандой cCall; каждая
        новая   макрокоманда   cCall   должна   иметь   соответствующую
        макрокоманду   Save.   Если   перед   cCall   расположены   две
        макрокоманды Save, то только вторая признается действительной.

             Параметр  regList  определяет  список  регистров,  которые
        будут  сохраняться.

             Примеры:

             Save    <cl,bh,si>
             Save    <ax>

        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                      = 106 =

                                                                               
            sBegin

             Синтаксис    sBegin segName

             Эта  макрокоманда открывает сегмент. Она подобна директиве
        Ассемблера SEGMENT.

             Параметр segName определяет имя открываемого сегмента. Это
        либо имя одного из предопределяемых сегментов (CODE или  DATA),
        либо имя сегмента, определенного пользователем.

             Примеры:

             sBegin DATA
             sBegin CODE


        ───────────────────────────────────────────────────────────────
                                                                               
            segNameOFFSET

             Синтаксис    segNameOFFSET arg

             Эта  макрокоманда  генерирует смещение относительно начала
        группы, к которой  принадлежит  сегмент  segName,  определенный
        пользователем.  Она  подобна оператору ассемблера OFFSET, но, в
        отличии от него, автоматически задает имя группы. Поэтому,  эта
        макрокоманда должна использоваться вместо оператора OFFSET.

             Параметр  arg  определяет имя метки или величину смещения.

             Пример:

             mv ax,initcodeOFFSET label

        ───────────────────────────────────────────────────────────────
                                                                               
            sEnd

             Синтаксис    sEnd [segName]

             Эта макрокоманда закрывает сегмент. Она подобна  директиве
        Ассемблера ENDS.

             Необязательный    параметр    segName    определяет   имя,
        используемое для удобства чтения программы. Если оно задано, то
        должно быть тем же самым, что и в соответствующей  макрокоманде
        sBegin.

             Примеры:

             sEnd
             sEnd DATA


        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                      = 107 =

                                          staticX                              

             Синтаксис    staticX name, [initialValue], [replication]

             Эта макрокоманда распределяет частную/закрытую статическую
        память.

             Параметр  X  определяет  размер  распределяемой памяти. Он
        может быть любым из следующих:

             Тип          Описание
             ───          ────────

             B            Байт

             W            Слово

             D            Двойное слово

             Q            Учетверенное слово

             T            Десять байт

             CP           Указатель  кода  (одно  слово  для   малой  и
                          компактной моделей памяти)

             DP           Указатель данных (одно  слово  для  малой   и
                          средней моделей памяти)


             Параметр  name  определяет  имя  ссылки  на распределенную
        память.   Необязательный   параметр   initialValue   определяет
        начальное значение памяти. По умолчанию она равна нулю.

             Необязательный  аргумент  replication  определяет  счетчик
        числа  повторений  распределения.   Этот   аргумент   порождает
        оператор Ассемблера DUP.

             Примеры:

             staticW flag,1
             staticB string, , 30





       Windows 3.0/Ref/7#7                                      = 108 =

               Глава 15. ОПРЕДЕЛЕНИЕ  ПРОТОКОЛА  ДИНАМИЧЕСКОГО  ОБМЕНА         
                 ДАННЫМИ (DDE)
       ----------------------------------------------------------------

             Протокол динамического   обмена  данными  (DDE)  Microsoft
        Windows определяет   метод   взаимосвязи   между    прикладными
        программами. Эта  взаимосвязь имеет место как только прикладные
        программы посылают  сообщения  друг  другу  для   инициализации
        диалога, для  запроса  и  разделения данных,  и для прекращения
        диалога. Эта глава описывает эти сообщения и правила  связанные
        с их  использованием.  Здесь  также  кратко  описаны  несколько
        форматов системного буфера,  которые прикладная  программа  DDE
        может регистрировать для использования в диалоге DDE.

             Руководство программиста     предоставляет     обзор    по
        программированию DDE,    включающий    такие    понятия     как
        клиент, сервер,  приложение,  предмет  и  элемент.  В нем также
        представляются режимы взаимосвязи DDE, включая постоянную связь
        по данным,  одноразовую передачу, запуск удаленной программы, и
        объясняется поток сообщений DDE.


             Соглашения, используемые в этой главе
             ─────────────────────────────────────

             Префиксы имен  аргументов,  в  зависимости  от   сообщения
        определяют их тип, следующим образом:

             Префикс      Описание
             ───────      ────────
             а            Атом длиной в слово (16 бит);например, aName.

             cf           Номер   зарегистрированного   формата  буфера
                          (длиной в слово); например, cfFormat.

             f            Флаговый бит; например, fName.

             h            Дескриптор  ( длиной  в  слово)  для  объекта
                          глобальной памяти; например,hName.

             w            Любой     другой  аргумент  длинной в  слово;
                          например, wName.




       Windows 3.0/Ref/7#7                                      = 109 =

                          15.1 Использование набора сообщений DDE              
       ----------------------------------------------------------------

             Каждое сообщение DDE имеет два параметра. Первый параметр,
        wParam (длиной в слово),  передает дескриптор посылающего окна;
        этот параметр одинаков во всех  случаях,  и  он  не  показан  в
        таблице 15.1.  Второй параметр, lParam (длиное слово, 32 бита),
        состоит из  младшего  слова  и  старшего  слова,  содержащих, в
        зависимости от сообщений, аргументы следующим образом:

             Таблица 15.1      Сообщения DDE
        ───────────────────────────────────────────────────────────────
                                        Аргументы в lParam

         Сообщение               Младшее слово     Старшее слово
        ───────────────────────────────────────────────────────────────

         WM_DDE_ACK

          В ответе на  INITIATE  aApplication      aTopic

          В ответе на  EXECUTE   wStatus           hCommands

          Все другие сообщения   wStatus           aItem

         WM_DDE_ADVISE           hOptions          aItem

         WM_DDE_DATA             hData             aItem

         WM_DDE_EXECUTE          (Зарезервировано) hCommands

         WM_DDE_INITIATE         aApplication      aTopic

         WM_DDE_POKE             hData             aItem

         WM_DDE_REQUEST          cfFormat          aItem

         WM_DDE_TERMINATE        (Зарезервировано) (Зарезервировано)

         WM_DDE_UNADVISE         (Зарезервировано) aItem

        ───────────────────────────────────────────────────────────────

          Прикладная программа вызывает функцию SendMessage для посылки
        сообщения WM_DDE_INITIATE или сообщения WM_DDE_ACK,  посылаемых
        в ответ на WM_DDE_INITIATE.  Все другие  сообщения  посылаются,
        используя функцию   PostMessage.  Дескриптор  получающего  окна
        появляется как первый параметр этих  вызовов.  Второй  параметр
        содержит сообщение для передачи, третий параметр идентифицирует
        посылающее окно,  и  четвертый  параметр   содержит   аргумент,
        зависящий от сообщения. Например:

             PostMessage(hwndRecipient,WM_DDE_MESSAGE,hwndSender,

       Windows 3.0/Ref/7#7                                      = 110 =

                                         MAKELONG(low_word, high_word))

             Макрос MAKELONG объединяет младшее слово и старшее слово в
        длиное слово.




       Windows 3.0/Ref/7#7                                      = 111 =

                              15.2 Синхронизация диалога DDE                   
       ----------------------------------------------------------------

             Окно прикладной  программы,  которое  обрабатывает запросы
        DDE от другого окна-партнера DDE,  должно обработать их точно в
        том   порядке,  в  котором  запросы  поступили.  Однако,  когда
        получаются сообщения от множества партнеров DDE,окну не следует
        применять  правило  "первым  пришел  -  первым вышел".  Другими
        словами,  только сами диалоги должны быть синхронны; окно может
        переходить от одного диалога к другому асинхронно.

        Например, пусть окно имеет следующие сообщения в очереди окна:

                            Сообщение от окна    X
                            Сообщение от окна    Y
                            Сообщение от окна    X

             Окно должно обрабатывать  1  сообщение  перед  3,  но  нет
        необходимости  обрабатывать  2 сообщение перед 3.  Если Y имеет
        более низкий приоритет партнера диалога DDE,  чем X, окно может
        отложть  обработку  сообщения  от  окна  Y,  пока не закончится
        работа с   сообщениями,   посланными  окном  X.  Ниже  показаны
        приемлемые порядки обработки для этих сообщений и относительный
        приоритет предпологаемый для каждого порядка:

             Порядок      Относительный приоритет
             ───────      ───────────────────────
             1  2  3      Окно X = окну Y

             1  3  2      Окно X > окна Y

             2  1  3      Окно X < окна Y


             Если прикладная  программа  не  в   состоянии   обработать
        поступивший   запрос,   поскольку  он  сам  ожидает  результата
        внешнего процесса DDE,  она должна послать сообщение WM_DDE_ACK
        c  флагом fBusy,  становленным в 1,  чтобы предотвратить тупик.
        Сообщение  WM_DDE_ACK  "занято"  может   быть   также   послано
        прикладной программой,  если по любой другой причине прикладная
        программа не в  состоянии  обрабатывать  поступивший  запрос  в
        приемлемый отрезок времени.

             Прикладная программа  должна  быть  способна  работать   в
        ситуации,   при  которой  партнер  DDE  не  может  ответить  на
        сообщение за   определенный   промежуток   времени.   Так   как
        длительность  этого  интервала  может меняться в зависимости от
        характера прикладной программы и конфигурации  пользовательской
        системы    (включая    сеть),   прикладная   программа   должна
        обеспечивать способ    определения   для   пользователя   этого
        промежутка времени.



       Windows 3.0/Ref/7#7                                      = 112 =

                                                                               
            15.3 Использование атомов
       ----------------------------------------------------------------

             Определенные аргументы  сообщений  DDE  (aItem,  aTopic  и
        aApplication)  -  это  глобальные  атомы.  Для  удаления старых
        атомов  из  списка  атомов,  они  должны  быть   явно   удалены
        использующими   их  прикладными  программами.  В  разделе  15.7
        "Список  сообщений  DDE",  описываются  правила  размещения   и
        удаления атомов, используемые каждым сообщением.

             В любом  случае,  программа,  посылающая  сообщение должна
        удалять любой атом, который предназначался программе получающей
        сообщение, но   не   был  получен  в  результате  возникновения
        состояния ошибки, такой как сбой функции PostMessage.




       Windows 3.0/Ref/7#7                                      = 113 =

                      15.4 Использование объектов разделяемой памяти           
       ----------------------------------------------------------------

             DDE использует объекты разделяемой памяти для трех целей:

             - Для  поддержки  обмениваемого   элемента   данных.   Это
        элемент, на  который  ссылается  аргумент  hData  в  сообщениях
        WM_DDE_DATA и WM_DDE_POKE.

             - Для поддержки указаний  в  сообщении.  Это  элемент,  на
        который ссылается аргумент hOptions в сообщении WM_DDE_ADVISE.

             - Для поддержки выполнения командной строки.  Это элемент,
        на   который   ссылается   аргумент   hCommands   в   сообщении
        WM_DDE_EXECUTE и передается сообщением WM_DDE_ACK.

             Прикладная программа, получающая объект разделяемой памяти
        DDE должна обращаться к нему только для чтения.  Это  запрещает
        их  использование  в  качестве общих областей чтения/записи для
        свободного обмена информацией.

             Как и атомы DDE, объекты разделяемой памяти должны вовремя
        освобождаться   для   того,   чтобы   управление  памятью  было
        эффективным.  Объекты  разделяемой  памяти   также   необходимо
        соответствующим образом блокировать и разблокировать. В разделе
        15.7 "Список сообщений DDE",  описываются правила размещения  и
        удаления объектов   разделяемой   памяти,  используемые  каждым
        сообщением.

             В любом  случае,  программа,  посылающая  сообщение должна
        удалять любой     объект     разделяемой     памяти,    который
        предназначался программе  получающей  сообщение,  но   не   был
        получен в результате возникновения состояния ошибки,  такой как
        сбой функции PostMessage.




       Windows 3.0/Ref/7#7                                      = 114 =

                                                                               
            15.5 Использование форматов системного буфера
       ----------------------------------------------------------------

             Вы можете  передавать   данные   посредством   любого   из
        стандартных форматов    системного   буфера   или   посредством
        зарегистрированных форматов   системного    буфера.    Смотрите
        описание  функции  SetClipboardData в Главе 4 "Список функций",
        Руководства Программиста,  том 1 для  получения  дополнительной
        информации  по  стандартным  системным  буферам.  Для получения
        информации по   форматам   регистрируемых   системных   буферов
        смотрите описание фцнкции RegisterClipboardFormat.

             Специальный, зарегистрированный   формат,  названный  Link
        используется  для  определения  элемента  в  диалоге  DDE.  Для
        получения   дополнительной   информации   смотрите  Руководство
        Пользователя.




       Windows 3.0/Ref/7#7                                      = 115 =

                          15.6 Использование системного предмета               
       ----------------------------------------------------------------

             Прикладные программы  всегда   поощряются   за   поддержку
        специального   предмета   с   именем   System.   Этот   предмет
        обеспечивает для элементов информации контекст,  который  может
        представлять для прикладных программ общий интерес.

             Следующий список   содержит   предлагаемые   элементы  для
        предмета System. Этот список не совсем точен. Значения элемента
        данных должны  быть  представлены  в  формате CF_TEXT.Отдельные
        части значения элемента предмета System должны быть  ограничены
        знаками табуляции.

             Элемент      Описание
             ───────      ────────

             SysItems     Перечень    элементов     предмета     System
                          поддерживаемых прикладной пргораммой.

             Topics       Перечень    предметов,         поддерживаемых
                          прикладной программой   в   текущий    момент
                          времени;  он  может  меняться  от  момента  к
                          моменту.

             ReturnMessage Поддерживаемый   элемент   для   большинства
                          недавно выданных     сообщений    WM_DDE_ACK.
                          Полезен,  когда   требуется   код   возврата,
                          специфический для прикладных программ - более
                          8 битов.

             Status       Индикация   текущего   состояния   прикладной
                          программы. Когда  сервер  получает  сообщение
                          WM_DDE_REQUEST   для   элемента    системного
                          предмета,  он  должен  ответить  отправлением
                          сообщения WM_DDE_DATA с  подходящей  строкой,
                          содержащей либо "Занят", либо "Готов".


             Formats      Этот   элемент  содержит   перечень   номеров
                          форматов системного      буфера,      которые
                          прикладная программа может преобразовывать.





       Windows 3.0/Ref/7#7                                      = 116 =

                                                                               
            15.7 Список сообщений DDE
       ----------------------------------------------------------------

             Этот раздел  описывает  девять  сообщений  DDE.  В  каждом
        описании приводятся  список   аргументов,  в   зависимости   от
        сообщения и   правил   для   отправления  и  получения  каждого
        сообщения.  SDK  содержит   файл   заголовка   DDE.H,   который
        определяет  сообщения DDE и структуры данных,  описанные в этом
        разделе.

        ───────────────────────────────────────────────────────────────
                                        WM_DDE_ACK                             

             Это сообщение уведомляет прикладную программу о  приеме  и
        обработке     сообщений:    WM_DDE_INITIATE,    WM_DDE_EXECUTE,
        WM_DDE_DATA,  WM_DDE_ADVISE, WM_DDE_UNADVISE или WM_DDE_POKE и,
        в некоторых случаях, сообщения WM_DDE_REQUEST.


             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Значения старшего и  младшего  слова  зависят
                          от сообщения,  на  которое отвечает сообщение
                          WM_DDE_ACK.

                          При ответе на WM_DDE_INITIATE:

                          Аргумент     Описание
                          ────────     ────────

                          Application  Младшее  слово   lParam.   Атом,
                                       который содержит  имя отвечающей
                                       программы.

                          aTopic       Старшее   слово   lParam.  Атом,
                                       который содержит   предмет,    с
                                       которым  отвечающее окно сервера
                                       соединено.

                          При ответе на WM_DDE_EXECUTE:

                          Аргумент     Описание
                          ────────     ────────

                          wStatus      Младшее     слово        lParam.
                                       Последовательность       флагов,
                                       показывающих статус ответа.

                          hCommands    Старшее слово lParam. Дескриптор
                                       который определяет       элемент

       Windows 3.0/Ref/7#7                                      = 117 =

                                       данных,   содержащий   командную
                                       строку.

                          При ответе на все другие сообщения:

                          Аргумент     Описание
                          ────────     ────────

                          wStatus      Младшее     слово        lParam.
                                       Последовательность       флагов,
                                       показывающих статус ответа.

                          aItem        Старшее слово lParam. Атом,
                                       определяющий элемент данных, для
                                       которого посылается ответ.


             Комментарий:

             Слово WStatus   состоит   из   структуры   данных  DDEACK,
        содержащей следующую информацию:


             Бит          Имя          Значение
             ───          ───          ────────

              15          fAck         1 = Запрос доступен.

                                       0 = Запрос не доступен.

              14          fBusy        1 = Занято. Прикладная программа
                                       ожидает установку   fBusy,  если
                                       невозможно ответить на запрос во
                                       время его получения.  Влаг fBusy
                                       определен  только   когда   fAck
                                       равен нулю.


                                       0 = Не занято.

              13-8                     Резервируется для испоьзования
                                       фирмой Microsoft.

              7-0                      Резервируется для кодов возврата,
                                       специфичных прикладных программ.

             Отправление:

             За исключением  ответа   на   сообщение   WM_DDE_INITIATE,
        послание сообщения  WM_DDE_ACK  осуществляется  вызовом функции
        PostMessage, а не функции SendMessage.  При ответе на сообщение
        WM_DDE_INITIATE, сообщение   WM_DDE_ACK   посылается   функцией
        SendMessage.

       Windows 3.0/Ref/7#7                                      = 118 =


             При подтверждении приема любого сообщения в  сопровождении
        атома   aItem,   прикладная   программа,  посылающая  сообщение
        WM_DDE_ACK  может  использовать  вновь  атом   aItem,   который
        сопровождает первоначальное сообщение,  или может удалить его и
        создать новый.

             При подтверждении   приема    сообщения    WM_DDE_EXECUTE,
        прикладная программа,     посылающая    сообщение    WM_DDE_ACK
        использует вновь   объект   hCommands,  который    сопровождает
        первоначальное сообщение WM_DDE_EXECUTE.

             Когда прикладная   программа   инициализирует  прекращение
        диалога  посланием  сообщения  WM_DDE_TERMINATE   и   не   ждет
        подтверждения приема,  ожидающая прикладная программа не должна
        подтверждать  прием  (положительно  или   отрицательно)   любой
        последовательности   сообщений,   посланных  другой  прикладной
        программой. Ожидающая прикладная программа должна удалить любые
        атомы   или  объекты  разделяемой  памяти,  полученные  в  этих
        сообщениях.


             Получение:

             Прикладная программа,    которая    получает     сообщение
        WM_DDE_ACK должна удалить все атомы, сопровождающие сообщения.

             Если прикладная  программа получает сообщение WM_DDE_ACK в
        ответ на сообщение, сопровождающееся объектом hData, прикладная
        программа должна удалить объект hData.

             Если прикладная программа получает отрицательное сообщение
        WM_DDE_ACK, посланное   в  ответ  на  сообщение  WM_DDE_ADVISE,
        прикладная программа должна удалить объект hOptions, переданный
        с первоначальным сообщением WM_DDE_ADVISE.

             Когда прикладная    программа    получает    отрицательное
        сообщение   WM_DDE_ACK,   посланное   в   ответ   на  сообщение
        WM_DDE_EXECUTE,  прикладная  программа  должна  удалить  объект
        hCommands, переданный      с      первоначальным     сообщением
        WM_DDE_EXECUTE.

        ──────────────────────────────────────────────────────────────
             WM_DDE_ADVISE

             Это сообщение,  посылаемое  прикладной  программой клиент,
        запрашивает   принимающую   прикладную    программу    (сервер)
        произвести  корректировку элемента данных каждый раз,  когда он
        изменяется.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

       Windows 3.0/Ref/7#7                                      = 119 =


             lParam       Идентифицирует     запрашиваемые   данные   и
                          определяет как данные должны быть посланны.

                          Аргумент     Описание
                          ────────     ────────

                          hOptions     Младшее     слово        lParam.
                                       Дескриптор,              который
                                       идентифицирует объект глобальной
                                       памяти,  который определяет  как
                                       данные должны быть посланны.

                          aItem        Старшее  слово   lParam.   Атом,
                                       который определяет запрашиваемый
                                       элемент данных.

             Комментарий:

             Объект глобальной   памяти,  идентифицированный  hOptions,
        состоит из  структуры  данных   DDEADVISE,   которая   содержит
        следующую информацию:

             Слово        Имя          Содержимое
             ─────        ───          ──────────

               1          fAckReq      Если  15-й  бит  равен   1,   то
                                       запрашивается        принимающая
                                       прикладная  программа   (сервер)
                                       для    посылки    ею   сообщения
                                       WM_DDE_DATA   с    установленным
                                       битом   fAckReq.  Такая  техника
                                       управления    потоком     данных
                                       позволит   прикладной  программе
                                       клиент избежать  перегрузки   от
                                       поступающих сообщений DATA.

                          fDeferUpd    Если    14-й    бит    равен  1,
                                       запрашивается сервер для посылки
                                       им   сообщений   WM_DDE_DATA   с
                                       нулевым дескриптором hData.  Эти
                                       сообщения - сигнал клиенту,  что
                                       исходные данные  изменились.  По
                                       получении    одного    из   этих
                                       сигналов  клиент  может  выбрать
                                       самую  последнюю  версию данных,
                                       выбрав сообщение WM_DDE_REQUEST,
                                       или    проигнорировать    сигнал
                                       вообще, когда для преобразования
                                       и/или ассимиляции         данных
                                       необходимы          значительные
                                       временные ресурсы.

       Windows 3.0/Ref/7#7                                      = 120 =


                          Зарезервировано      Биты 13-0 резервируются.

               2          cfFormat     Тип   данных,     предпочитаемый
                                       клиентом. Должен            быть
                                       зарегистрированным       номером
                                       формата    данных     системного
                                       буфера.

             Если прикладная   программа   поддерживает  больше  одного
        формата системного буфера для отдельного предмета  и  элемента,
        то  может  посылаться  множество  сообщений  WM_DDE_ADVISE  для
        предмета и элемента,  определяющих различный формат  системного
        буфера с каждым сообщением.

             Отправление:

             Сообщение WM_DDE_ADVISE    посылается    вызовом   функции
        PostMessage, а не SendMessage.

             Размещение hOptions    производится    вызовом     функции
        GlobalAlloc с опцией GEMEM_DDE_SHARE.

             Размещение aItem      производится     вызовом     функции
        GlobalAddAtom.

             Если получающая  прикладная  программа  (сервер)  отвечает
        отрицательным   сообщением  WM_DDE_ACK,  посылающая  прикладная
        программа (клиент) должна удалить объект hOptions.


             Получение:

             Сообщение WM_DDE_ACK посылается в ответ либо положительно,
        либо  отрицательно.  При   посылке   WM_DDE_ACK,   атом   aItem
        используется  вновь  или  он удаляется и создается новый.  Если
        сообщение WM_DDE_ACK положительно, удаляется объект hOptions; в
        противном случае объект не удаляется.

        ───────────────────────────────────────────────────────────────
                                        WM_DDE_DATA                            

             Это сообщение,  посылаемое  сервером,  передает   величину
        элемента данных получающей прикладной программе (клиенту),  или
        уведомляет клиента о доступности данных.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Идентифицирует    доступность    данных     и
                          определяет как они переданы.

       Windows 3.0/Ref/7#7                                      = 121 =


                          Аргумент     Описание
                          ────────     ────────

                          hData        Младшее слово lParam.Дескриптор,
                                       определяющий  объект  глобальной
                                       памяти,  содержащий   данные   и
                                       дополнительную       информацию.
                                       Дескриптор      должен      быть
                                       установлен  в NULL,  если сервер
                                       не   уведомляет    клиента    об
                                       изменении    значения   элемента
                                       данных во  время  "теплой" связи
                                       по  данным.  Теплая  связь   это
                                       установленная  клиентом передача
                                       сообщения    WM_DDE_ADVISE     с
                                       установленным битом fDeferUpd.

                          aItem        Старшее   слово   lParam.  Атом,
                                       который идентифицирует   элемент
                                       данных   для  которого  посланно
                                       уведомление.

             Комментарий:

             Объект глобальной памяти, идентифицированный hData,состоит
        из структуры   данных   DDEDATA,   которая  содержит  следующую
        информацию:

             Слово        Имя          Содержимое
             ─────        ───          ──────────

              1           fAckReq      Если     15-й   бит   равен   1,
                                       ожидается, что  клиент  посылает
                                       сообщение    WM_DDE_ACK    после
                                       обработки сообщения WM_DDE_DATA.
                                       Если    15-й    бит   равен   0,
                                       прикладная программа  клиент  не
                                       должна     посылать    сообщение
                                       WM_DDE_ACK.

                          Зарезервировано       14-й бит резервируется.

                          fRelease     Если     13-й   бит   равен   1,
                                       ожидается, что        прикладная
                                       программа клиент       освободит
                                       объект    памяти    после    его
                                       обработки.  Если 13-й бит  равен
                                       0,  прикладная  программа клиент
                                       не  должна  освобождать  объект.
                                       Смотрите разделы "Отправление" и
                                       "Получение" для особых случаев.


       Windows 3.0/Ref/7#7                                      = 122 =

                          fRequested   Если    12-й бит   равен 1,  эти
                                       данные предлагаются  в  ответ на
                                       сообщение  WM_DDE_REQUEST.  Если
                                       12-й  бит  равен  0,  эти данные
                                       предлагаются    в    ответ    на
                                       сообщение WM_DDE_ADVISE.

                          Зарезервировано    Биты 11-0 зарезервированы.

             2            cfFormat     Определяет    зарегистрированный
                                       формат в котором данные  посланы
                                       или     предложены    прикладной
                                       программе  клиенту.  Это  должен
                                       быть       стандартный       или
                                       зарегистрированный        формат
                                       системного буфера.

             3-n          Data         Это   данные.  Они   в   формате
                                       определенном cfFormat.

             Отправление:

             Сообщение WM_DDE_DATA    посылается    вызовом     функции
        PostMessage, а не SendMessage.

             Размещение hData  производится вызовом функции GlobalAlloc
        с опцией GEMEM_DDE_SHARE.

             Размещение aItem      производится     вызовом     функции
        GlobalAddAtom.

             Если получающая  прикладная  программа  (клиент)  отвечает
        отрицательным сообщением   WM_DDE_ACK,   посылающая   программа
        (сервер) должна удалить объект hData.

             Если посылающая      прикладная     программа     (сервер)
        устанавливает флаг  fRelease  в  ноль,то  посылающая  программа
        ответственена за    удаление    hData    в   полученном,   либо
        отрицательном, либо положительном подтверждении.

             Не устанавливайте оба флага fAckReq  и  fRelease  в  ноль.
        Когда оба флага равны нулю,  возникают трудности для посылающей
        программы (сервера) при прекращении, когда удаляется hData.


             Получение:

             Если fAckReq равен 1,  то в ответ посылается положительное
        или отрицательное сообщение WM_DDE_ACK. При посылке WM_DDE_ACK,
        атом  aItem  используется  вновь  или  он удаляется и создается
        новый.

             Если fAckReq ноль, атом aItem удаляется.

       Windows 3.0/Ref/7#7                                      = 123 =


             Если посылающая прикладная программа  (сервер)  определила
        hData как NULL,  получающая прикладная программа (клиент) может
        запросить сервер послать  реальные  данные,  посылая  сообщение
        WM_DDE_REQUEST.

             После обработки сообщения WM_DDE_DATA,  в котором hData не
        NULL, hData удаляется до тех пор пока  не  произойдет  одно  из
        следующих действий:

             - Флаг fRelease равен нулю.

             - Флаг fRelease равен 1,  но получающая программа (клиент)
        отвечает отрицательным сообщением WM_DDE_ACK.

        ───────────────────────────────────────────────────────────────
                                      WM_DDE_EXECUTE                           

             Это сообщение,   посланное   программой  клиент,  посылает
        серверу   строку,   которая   должна   быть   обработана    как
        последовательность  команд.Ожидается,  что  в  ответ прикладная
        программа  сервер пошлет сообщение WM_DDE_ACK.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Определяет команды для выполнения.

                          Аргумент     Описание
                          ────────     ────────

                          Зарезервировано    Младшее    слово    lParam
                                       зарезервировано.

                          hCommands    Старшее       слово      lParam.
                                       Дескриптор,              который
                                       идентифицирует объект глобальной
                                       памяти,   содержащий    команды,
                                       которые должны быть выполнены.


             Комментарий:

             Командная строка  оканчивается  нулем.  Командная   строка
        должна придерживаться     синтаксиса,     показанного     ниже.
        Необязательные элементы   заключены   в   двойные    квадратные
        скобки ([[   ]]);  одинарные  квадратные  скобки  это  элементы
        синтаксиса.

             [opcodestring] [[ [opcodestring] ]] ...


       Windows 3.0/Ref/7#7                                      = 124 =

             opcodestring использует следующий синтаксис:

             opcode [[ (parameter [[,parameter]] ...) ]]

             opcode -  это  любая, определенная  прикладной  программой
        единичная лексема.  Она  не  может  включать пробелы,  запятые,
        круглые скобки или кавычки.

             parameter -  любая,  определенная  прикладной   программой
        величина. Несколько параметров разделяются запятыми, и элементы
        списка параметров заключаются в  круглые  скобки.  Параметр  не
        может включать запятые или круглые скобки, исключая те, которые
        находятся внутри той строки,  на  которую  он  ссылается.  Если
        квадратные  или круглые скобки появляются в строке,  на которую
        ссылаются, они могут быть двойными: ((.

             Нижеследующие примеры  показывает   допустимые   командные
        строки:

             [connect][download(query1,results.txt)][disconnect]
             [query("sales per employee for eash district")]
             [open("sample.xlm")][run("rlcl")]

             Отправление:

             Сообщение WM_DDE_EXECUTE    посылается   вызовом   функции
        PostMessage, а не SendMessage.

             Размещение hCommands    производится    вызовом    функции
        GlobalAlloc с опцией GEMEM_DDE_SHARE.

             Когда WM_DDE_ACK  посылается  в  ответ  на WM_DDE_EXECUTE,
        программа, посылающая первоначальное  сообщение  WM_DDE_EXECUTE
        должна удалить объект hCommands,  посланный обратно в сообщении
        WM_DDE_ACK.


             Получение:

             В ответ   посылается   положительное   или   отрицательное
        сообщение  WM_DDE_ACK, используя заново объект hCommands.

        ───────────────────────────────────────────────────────────────
                                      WM_DDE_INITIATE                          

             Это сообщение,   посылаемое   либо  прикладной  программой
        клиент  либо  сервером,  инициализирует  диалог  с  прикладными
        программами  отвечающими на определенные прикладные программы и
        имена предметов.

             По получении этого сообщения все  прикладные  программы  с
        именами,  совпадающими  с aApplication и поддерживающие предмет
        aTopic, ожидают подтверждения ( смотрите сообщение WM_DDE_ACK).

       Windows 3.0/Ref/7#7                                      = 125 =


             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Определяет целевую  прикладную  программу   и
                          предмет.

                          Аргумент     Описание
                          ────────     ────────

                          aApplication Младшее слово  lParam  .    Атом,
                                       который специфицирует        имя
                                       прикладной     программы     для
                                       обслуживания    запроса.     Имя
                                       прикладной  программы  не  может
                                       содержать   косую   черту    или
                                       обратную    косую   черту.   Эти
                                       символы   зарезервированы    для
                                       будущего     использования     в
                                       реализации   сетей.   Если   имя
                                       прикладной  программы  NULL,  то
                                       требуется   диалог   со    всеми
                                       прикладными программами.

                          aTopic       Старшее   слово   lParam.  Атом,
                                       который определяет  предмет  для
                                       которого требуется диалог.  Если
                                       предмет   NULL,   то   требуется
                                       диалог    для   всех   возможных
                                       предметов.

             Комментарий:

             Если параметр  aApplication  равен  NULL,  ответить  может
        любая прикладная  программа.  Если  параметр aTopic равен NULL,
        допускается любой предмет.  Ожидается, что по получении запроса
        WM_DDE_INITIATE   с   нулевым  предметом  прикладная  программа
        посылает сообщение WM_DDE_ACK для каждого предмета, который она
        поддерживает.

             Отправление:

             Сообщение WM_DDE_INITIATE   посылается   вызовом   функции
        SendMessage, а не PostMessage.  Передача сообщения  всем  окнам
        осуществляется установкой  первого  параметра SendMessage в -1,
        как показано ниже:

             SendMessage(-1,WM_DDE_INITIATE,hwndClient,
                                                MAKELONG(aApp,aTopic));

             Если прикладная  программа  уже  получила  дескриптор окна

       Windows 3.0/Ref/7#7                                      = 126 =

        желаемого сервера, она может послать WM_DDE_INITIATE прямо окну
        сервера, через  дескриптор  окна  сервера  как  первый параметр
        SendMessage.

             Размещение aApplication  и  aTopic  производится   вызовом
        функции GlobalAddAtom.

             Когда SendMessage     возвращает     управление,     атомы
        aApplication и aTopic удаляются.


             Получение:

             Для завершения  инициализации диалога,  отвечают одним или
        несколькими сообщениями  WM_DDE_ACK,   каждое   сообщения   для
        отдельного  предмета.  Когда  посылается  сообщение WM_DDE_ACK,
        создаются новые атомы aApplication  и  aTopic;  не  используйте
        вновь атомы посланные с сообщением WM_DDE_INITIATE.

        ───────────────────────────────────────────────────────────────
                                        WM_DDE_POKE                            

             Это сообщение,  посылаемое прикладной  программой  клиент,
        запрашивает у получающей прикладной программы (сервер) доступ к
        невостребованному значению элемента данных.

             Ожидается, что принимающая  прикладная  программа  ответит
        положительным  сообщением WM_DDE_ACK,  если она получает данные
        или отрицательным сообщением WM_DDE_ACK, если нет.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Определяет  данные и идентифицирует  как  они
                          посланы.

                          Аргумент     Описание
                          ────────     ────────

                          hData        Младшее слово            lParam.
                                       Дескриптор,              который
                                       специфицирует объект  глобальной
                                       памяти,   содержащий   данные  и
                                       другую информацию.

                          aItem        Старшее слово lParam. Атом,
                                       который идентифицирует   элемент
                                       данных предложеных серверу.

             Комментарий:


       Windows 3.0/Ref/7#7                                      = 127 =

             Объект глобальной    памяти,   идентифицированный   hData,
        состоит из  структуры  данных  DDEPOKE,  содержащей   следующую
        информацию:

             Слово        Имя          Содержимое
             ─────        ───          ──────────

               1          Зарезервировано   Биты 15-14 зарезервированы.

                          fRelease     Если 13-й     бит    равен    1,
                                       ожидается,    что    принимающая
                                       прикладная   программа  (сервер)
                                       освободит  объект  памяти  после
                                       его  обработки.  Если  13-й  бит
                                       равен 0,  принимающая прикладная
                                       программа  не должна освобождать
                                       объект.  Смотрите  нижеследующие
                                       разделы      "Отправление"     и
                                       "Получение" для особых случаев.

                          Зарезервировано    Биты 12-0 зарезервированы.

             2            cfFormat     Определяет        предпочитаемый
                                       клиентом тип данных.  Это  может
                                       быть    зарегистрированный   или
                                       стандартный  формат   системного
                                       буфера.

             3            Value[]      Это   данные.   Они   в  формате
                                       определенном cfFormat.

             Отправление:

             Сообщение WM_DDE_POKE    посылается    вызовом     функции
        PostMessage, а не SendMessage.

             Размещение hData  производится вызовом функции GlobalAlloc
        с опцией GEMEM_DDE_SHARE.

             Размещение aItem     производится     вызовом      функции
        GlobalAddAtom.


             Если получающая  прикладная  программа  (сервер)  отвечает
        отрицательным   сообщением   WM_DDE_ACK,  посылающая  программа
        (клиент) должна удалить объект hData.

             Если посылающая      прикладная     программа     (клиент)
        устанавливает флаг  fRelease  в  ноль,то  посылающая прикладная
        программа ответствененна за удаление hData в  полученном,  либо
        отрицательном либо, положительном сообщении WM_DDE_ACK.



       Windows 3.0/Ref/7#7                                      = 128 =

             Получение:

             В ответ   посылается   положительное   или   отрицательное
        сообщение WM_DDE_ACK.   При   посылке  WM_DDE_ACK,  атом  aItem
        используется вновь или он удаляется и создается новый.

             После обработки сообщения WM_DDE_DATA,  в котором hData не
        NULL, hData удаляется до тех пор пока  не  произойдет  одно  из
        следующих действий:

             - Флаг fRelease равен нулю.

             - Флаг fRelease равен 1,  но получающая программа (сервер)
        отвечает отрицательным сообщением WM_DDE_ACK.

        ───────────────────────────────────────────────────────────────
                                      WM_DDE_REQUEST                           

             Это сообщение,  посылаемое прикладной  программой  клиент,
        запрашивает получающую прикладную программу (сервер) обеспечить
        значение элемента данных.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Определяет   запрашиваемые  данные  и   номер
                          формата системного буфера для данных.

                          Аргумент     Описание
                          ────────     ────────

                          cfFormat     Младшее  слово  lParam.    Номер
                                       зарегистрированного          или
                                       стандартного  формата системного
                                       буфера.

                          aItem        Старшее  слово   lParam.   Атом,
                                       определяющий, какой      элемент
                                       данных был запрошен у сервера.

             Отправление:

             Сообщение WM_DDE_REQUEST   посылается   вызовом    функции
        PostMessage, а не SendMessage.

             Размещение aItem     производится     вызовом      функции
        GlobalAddAtom.

             Получение:

             Если получающая  прикладная   программа   (сервер)   может

       Windows 3.0/Ref/7#7                                      = 129 =

        удовлетворить запрос,  то  она отвечает сообщением WM_DDE_DATA,
        содержащим  запрашиваемые  данные.  В  противном  случае,   она
        отвечает отрицательным сообщением WM_DDE_ACK.

             Если ответ    производится   сообщением   WM_DDE_ACK   или
        WM_DDE_DATA, атом aItem используется вновь или он  удаляется  и
        создается новый.

        ───────────────────────────────────────────────────────────────
                                     WM_DDE_TERMINATE                          

             Это сообщение,  посылаемое либо  сервером  либо  клиентом,
        прекращает диалог.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.

             lParam       Зарезервировано.

             Отправление:

             Сообщение WM_DDE_TERMINATE  посылается   вызовом   функции
        PostMessage, а не SendMessage.

             Пока ожидается     подтверждение    прерывания    диалога,
        посылающая прикладная программа не  должна  подтверждать  прием
        любых   других   сообщений,   посланных  получающей  прикладной
        программой. Когда  посылающая  прикладная  программа   получает
        сообщения (  кроме  WM_DDE_TERMINATE ) от получающей прикладной
        программы, она  должна  удалить   любые   атомы   или   объекты
        разделяемой памяти, сопровождающие эти сообщения.


             Получение:

             В ответ посылается сообщение WM_DDE_TERMINATE.

        ───────────────────────────────────────────────────────────────
                                      WM_DDE_UNADVISE                          

             Это сообщение,  посылаемое  прикладной  программой клиент,
        информирует прикладную  программу  сервер,   что   определенный
        элемент, или   формат   системного   буфера  не  должны  больше
        корректироваться. Оно прерывает "теплую"  или  "горячую"  связь
        для определенного элемента.

             Параметр     Описание
             ────────     ────────

             wParam       Идентифицирует посылающее окно.


       Windows 3.0/Ref/7#7                                      = 130 =

             lParam       Определяет   элемент,  запрашиваемых  данных,
                          который будет отменен.

                          Аргумент     Описание
                          ────────     ────────

                          aItem        Старшее   слово   lParam.  Атом,
                                       который определяет, какой запрос
                                       на корректировку данных отменен.
                                       Если  aItem NULL,  то отменяются
                                       все       активные       диалоги
                                       WM_DDE_ADVISE,    связанные    с
                                       клиентом.

                          cfFormat     Младшее   слово   lParam. Формат
                                       системного буфера      элемента,
                                       который    определяет     формат
                                       системного буфера,  для которого
                                       запрос на корректировку отменен.
                                       Если   cfFormat   NULL,  то  все
                                       диалоги    WM_DDE_ADVISE     для
                                       элементов отменяются.


             Отправление:

             Сообщение WM_DDE_UNADVISE   посылается   вызовом   функции
        PostMessage, а не SendMessage.

             Размещение aItem     производится     вызовом      функции
        GlobalAddAtom.

             Получение:

             В ответ   посылается   положительное   или   отрицательное
        сообщение WM_DDE_ACK.   При   посылке  WM_DDE_ACK,  атом  aItem
        используется вновь или он удаляется и создается новый.

        ───────────────────────────────────────────────────────────────








       Windows 3.0/Ref/7#7                                      = 131 =

                                                                               
            ПРИЛОЖЕНИЯ
       ----------------------------------------------------------------

             A            Коды виртуальных клавиш

             B            Диагностические     сообщения     компилятора
                          ресурсов

             C            Отладочные сообщения Windows

             D            Символьные таблицы

             E            Windows DLL управления 32-разрядной памятью


        ───────────────────────────────────────────────────────────────




       Windows 3.0/Ref/7#7                                      = 132 =

                           Приложение A. Коды виртуальных клавиш               
       ----------------------------------------------------------------

             Список приведенный   ниже   показывет   имена   символьных
        констант, шестнадцатеричные значения и краткую  информацию  для
        кодов  виртуальных  клавиш Microsoft Windows.  Коды приведены в
        порядке возрастания.

        ───────────────────────────────────────────────────────────────
        Имя               Значение     Описание
        ───────────────────────────────────────────────────────────────

        VK_LBUTTON        01H          Левая кнопка мыши
        VK_RBUTTON        02H          Правая кнопка мыши
        VK_CANEL          03H          Произошло прерывание процесса
        VK_MBUTTON        04H          Средняя  кнопка  мыши  (для  3-х
                                       кнопочных мышей)
                          05H-07H      Неопределено
        VK_BACK           08H          Клавиша BACKSPACE
        VK_TAB            09H          Клавиша TAB
                          0AH-0BH      Неопределено
        VK_CLEAR          0CH          Клавиша CLEAR
        VK_RETURN         0DH          Клавиша RETURN
        VK_SHIFT          10H          Клавиша SHIFT
        VK_CONTROL        11H          Клавиша CONTROL
        VK_MENU           12H          Клавиша MENU
        VK_PAUSE          13H          Клавиша PAUSE
        VK_CAPITAL        14H          Клавиша CAPITAL
                          15H-19H      Зарезервированно для Kanji
                                       систем
                          1AH          Неопределено
        VK_ESCAPEL        1BH          Клавиша ESCAPE
                          1CH-1FH      Зарезервированно для Kanji
                                       систем
        VK_SPACE          20H          Клавиша SPACEBAR
        VK_PRIOR          21H          Клавиша PAGE UP
        VK_NEXT           22H          Клавиша PAGE DOWN
        VK_END            23H          Клавиша END
        VK_HOME           24H          Клавиша HOME
        VK_LEFT           25H          Клавиша LEFT ARROW
        VK_UP             26H          Клавиша UP ARROW
        VK_RIGHT          27H          Клавиша RIGHT ARROW
        VK_DOWN           28H          Клавиша DOWN ARROW
        VK_SELECT         29H          Клавиша SELECT
                          2AH          Зависит от OEM кода
        VK_EXECUTE        2BH          Клавиша EXECUTE
        VK_SNAPSHOT       2CH          Клавиша PRINTSCREEN  для Windows
                                       3.0 и более поздних версий.
        VK_INSERT         2DH          Клавиша INSERT
        VK_DELETE         2EH          Клавиша DELETE
        VK_HELP           2FH          Клавиша HELP
        VK_0              30H          Клавиша 0
        VK_1              31H          Клавиша 1

       Windows 3.0/Ref/7#7                                      = 133 =

        VK_2              32H          Клавиша 2
        VK_3              33H          Клавиша 3
        VK_4              34H          Клавиша 4
        VK_5              35H          Клавиша 5
        VK_6              36H          Клавиша 6
        VK_7              37H          Клавиша 7
        VK_8              38H          Клавиша 8
        VK_9              39H          Клавиша 9
                          3AH-40H      Неопределено
        VK_A              41H          Клавиша A
        VK_B              42H          Клавиша B
        VK_C              43H          Клавиша C
        VK_D              44H          Клавиша D
        VK_E              45H          Клавиша E
        VK_F              46H          Клавиша F
        VK_G              47H          Клавиша G
        VK_H              48H          Клавиша H
        VK_I              49H          Клавиша I
        VK_J              4AH          Клавиша J
        VK_K              4BH          Клавиша K
        VK_L              4CH          Клавиша L
        VK_M              4DH          Клавиша M
        VK_N              4EH          Клавиша N
        VK_O              4FH          Клавиша O
        VK_P              50H          Клавиша P
        VK_Q              51H          Клавиша Q
        VK_R              52H          Клавиша R
        VK_S              53H          Клавиша S
        VK_T              54H          Клавиша T
        VK_U              45H          Клавиша U
        VK_V              56H          Клавиша V
        VK_W              57H          Клавиша W
        VK_X              58H          Клавиша X
        VK_Y              59H          Клавиша Y
        VK_Z              5AH          Клавиша Z
                          5FH-5FH      Неопределено
        VK_NUMPAD0        60H          Цифровая клавиша 0
        VK_NUMPAD1        61H          Цифровая клавиша 1
        VK_NUMPAD2        62H          Цифровая клавиша 2
        VK_NUMPAD3        63H          Цифровая клавиша 3
        VK_NUMPAD4        64H          Цифровая клавиша 4
        VK_NUMPAD5        65H          Цифровая клавиша 5
        VK_NUMPAD6        66H          Цифровая клавиша 6
        VK_NUMPAD7        67H          Цифровая клавиша 7
        VK_NUMPAD8        68H          Цифровая клавиша 8
        VK_NUMPAD9        69H          Цифровая клавиша 9
        VK_MULTIPLY       6AH          Клавиша умножения
        VK_ADD            6BH          Клавиша сложения
        VK_SEPARATER      6CH          Клавиша разделения
        VK_SUBSTRACT      6DH          Клавиша вычитания
        VK_DECIMAL        6EH          Клавиша десятичной точки
        VK_DIVIDE         6FH          Клавиша деления
        VK_F1             70H          Клавиша F1

       Windows 3.0/Ref/7#7                                      = 134 =

        VK_F2             71H          Клавиша F2
        VK_F3             72H          Клавиша F3
        VK_F4             73H          Клавиша F4
        VK_F5             74H          Клавиша F5
        VK_F6             75H          Клавиша F6
        VK_F7             76H          Клавиша F7
        VK_F8             77H          Клавиша F8
        VK_F9             78H          Клавиша F9
        VK_F10            79H          Клавиша F10
        VK_F11            7AH          Клавиша F11
        VK_F12            7BH          Клавиша F12
        VK_F13            7CH          Клавиша F13
        VK_F14            7DH          Клавиша F14
        VK_F15            7EH          Клавиша F15
        VK_F16            7FH          Клавиша F16
                          80H-87H      Зависит от OEM кода
                          88H-8FH      Не назначено
        VK_NUMLOCK        90H          Клавиша NUM LOCK
        VK_OEM_SCROLL     91H          Клавиша SCROLL LOCK
                          92H-B9H      Не назначено
        VK_OEM_1          BAH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_PLUS       BBH          Клавиша плюс    (+)
        VK_OEM_COMMA      BCH          Клавиша запятая (,)
        VK_OEM_MINUS      BDH          Клавиша минус   (-)
        VK_OEM_PERIOD     BEH          Клавиша период  (.)
        VK_OEM_2          BFH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_3          BFH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_4          C0H          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
                          C1H-DAH      Не назначено
        VK_OEM_5          DBH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_6          DDH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_7          DEH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
        VK_OEM_8          DFH          Специфичная  клавиша  пунктуации
                                       (присутствует    не    на   всех
                                       клавиатурах)
                          E0H-E1H      Зависит от OEM кода
        VK_OEM_102        E2H          <>   или   \|  на расширенных не
                                       американских   102-х   клавишных
                                       IBM совместимых клавиатурах

       Windows 3.0/Ref/7#7                                      = 135 =

                          E3H-E4H      Зависит от OEM кода
                          E5           Не назначено
                          E6           Зависит от OEM кода
                          E7H-E8H      Не назначено
                          E9H-F5H      Зависит от OEM кода
                          F6H-FEH      Не назначено
        ───────────────────────────────────────────────────────────────





       Windows 3.0/Ref/7#7                                      = 136 =

              Приложение B. Диагностические сообщения компилятора ресурсов     
       ----------------------------------------------------------------

             Это приложение содержит описания диагностических сообщений
        выдаваемых компилитором ресурсов (RC). Многие из этих сообщений
        появляются  когда  RC  не  может  откомпилировать ваши ресурсы.
        Описания  в  этом  приложеннии  могут  помочь  вам  решить  эти
        проблемы.

             Символ  (V)  в  начале  описания сообщения показывает, что
        сообщения показывается только если RC выполняется с  параметром
        V  (многословный). Эти сообщения в основном информационные и не
        обязательны для показа ошибок.

             Смотрите  главу  8,  "Опрераторы  описания  ресурса",  для
        получения информации по ключевым словам и полям, определенным в
        этом приложении.

             Сообщения приведены в алфавитном порядке.


             Accelerator Type required (ASCII or VIRTKEY)

             Поле  type  опрератора   ACCELERATORS   должно   содержать
        либо ASCII, либо VIRTKEY величину.


             BEGIN expected in Accelepator Table

             Ключевое  слово  BEGIN должно следовать непосредственно за
        ключевым словом ACCELERATORS.


             BEGIN expected in Dialog

             Ключевое  слово  BEGIN должно следовать непосредственно за
        ключевым словом DIALOG.


             BEGIN expected in menu

             Ключевое  слово  BEGIN должно следовать непосредственно за
        ключевым словом MENU.


             BEGIN expected in RCData

             Ключевое  слово  BEGIN должно следовать непосредственно за
        ключевым словом RCDATA.


             BEGIN keyword expected in String or Error Table


       Windows 3.0/Ref/7#7                                      = 137 =

             Ключевое  слово  BEGIN должно следовать непосредственно за
        ключевым словом STRINGTABLE или ключевым словом ERRTABLE.


             Cannot Reuse String Constants

             Вы используете одно и тоже значение  дважды  в  опрераторе
        STRINGTABLE  или  ERRTABLE.  Убедитесь,  что  вы  не смешиваете
        десятичные и шестнадцатеричные значения.


             Control Character out of range [^A - ^Z]

             Управляюший  символ  в  операторе  ACCELERATORS   неверен.
        Символ  стоящий  после  (^)  должен  находится  между  A  и  Z,
        включительно.


             copy of temp-file-2 to exe-file failed

             Не было  возможности создать из временого файла новый .EXE
        файл. Убедитесь,  что переменная окружения  TEMP  указывает  на
        устройство, которое не защищено от записи.


             Copying segment id(size bytes)

             (V) RC копирует определенный сегмент в .EXE файл.


             Could not find  RCPP.EXE

             RCPP.ERR должен  находиться  в  текущем  каталоге  или   в
        каталоге, указанном в PATH.


             Could  not  open  in-file-name

             RC не может открыть определенный файл. Убедитесь, что файл
        существует и что набранное вами имя правильно.


             Couldn't open resource-name

             RC не может открыть определенный файл. Убедитесь, что файл
        существует и что набранное вами имя правильно.


             Couldn't write executable

             Фал с  расширением  .EXE  не  может  быть  скопирован   во
        временный   файл.  Убедитесь,  что  переменная  окружения  TEMP
        указывает на устройство,  которое не закрыто от копирования  и,

       Windows 3.0/Ref/7#7                                      = 138 =

        что .EXE файл скомпанован верено. Вы можете проверить .EXE файл
        с помощью программы EXENDR.


             Creating recource-name

             (V) RC создает новый .RES файл.


             Empty menus not allowed

             Ключевое слово  END  появляется  перед  любыми  элементами
        меню,  определенными  в  операторе   MENU.   Пустые   меню   не
        пропускаются компилятором ресурса. Убедитесь,  что  у  вас  нет
        открытых кавычек внутри оператора MENU.


             END expected in Dialog

             Ключевое слово END должно  находиться  в  конце  оператора
        DIALOG. Убедитесь, что нет открытых кавычек  слева  от  данного
        оператора.


             END expected in menu

             Ключевое слово END должно  находиться  в  конце  оператора
        MENU. Убедитесь, что нет открытых кавычек  или  соответствующих
        пар операторов BEGIN и END.


             Error:Bitmap file resourse-file is not in 3.00 format.

             Используйте SDKPaint  для  преобразования  файлов  ресурса
        версии 2.x в формат версии 3.0.


             Error Creating resource-name

             Невозможно создать определенный .RES файл. Убедитесь,  что
        он не  создается  на  устройстве,  предназначенном  только  для
        чтения. Используйте  параметр  -  V  для  указания:  искать  ли
        создаваемый файл.


             Error:I/O error reading file.

             Чтение невозможно. Задано не конкретное имя.


             Error:I/O error seeking in file.

             Поиск в файле невозможен.

       Windows 3.0/Ref/7#7                                      = 139 =



             Error:I/O error writing file.

             Запись невозможна. Задано не конкретное имя.


             Error:Old DIB in resource-name. Pass it through SDKRAINT.

             Определенный файл  ресурса  не  совместим с Windows версии
        3.0.  Убедитесь,  что  вы  читаете  и  записываете  этот   файл
        используя самую позднюю версию SDKPaint.


             Error:Out of memory.Try not using  resources  with  string
        identifiers.

             Не хватает памяти для размещения таблиц строковых имен. Вы
        можете просмотреть  эти  имена,  если  вы  будете  использовать
        параметр   V.  Попытайтесь  поменять  имена  строк  на  номера.
        Например, вы можете заменить:


             MYICON ICON myicon.ico

             на

             1 ICON myicon .ico


             или введите следующий оператор в файл заголовка

             #define MYICON 1


             Error:Resource file resource-name is not in 3.00 format.

             Убедитесь,  что  ваши   иконы   и   курсоры   читались   и
        записывались при помощи самой поздней версии SDKPaint.


             Errors in .EXE file

             LINK работает  с ошибкой.  Смотрите руководство "CcodeView
        and Utilities" в документации  к  Microsoft  C  5.1  Optimizing
        Compiler для дополнительной информации.


             .EXE file too large; relink with higher/ALIGN value

             Файл с расширением .EXE файл слишком большой.  Скомпонуйте
        .EXE  файл  заново  с большим /ALIGN значением.  Если .EXE файл
        больше 800 К, вы должны использовать значение /ALIGN:32 в вашей

       Windows 3.0/Ref/7#7                                      = 140 =

        командной строке для LINK.


             .EXE not created by LINK

             Вы должны создать .EXE файл с помощью LINK  из  C  version
        5.1 или более поздней.


             Expected Comma in Accelerator Table

             RC  требует  запятую  между  полями  event  и  idvalue   в
        операторе ACCELERATORS.


             Expected control class name

             Поле class оператора CONTROL  в  операторе  DIALOG  должно
        быть   одного  из  следующих  типов:  BUTTON,  COMBOBOX,  EDIT,
        LISTBOX,  SCROLLBAR,  STATIC  или  определенное  пользователем.
        убедитесь, что класс описан правильно.


             Еxpected font face name

             Поле typeface параметра FONT  в  операторе  DIALOG  должно
        быть строкой ASCII символов, заключенной в двойные кавычки. Это
        поле определяет имя шрифта.


             Expected ID value for Menuitem

             Оператор  MENU  должен  содержать  поле  menuID,   которое
        определяет имя или число, идентифицирующее ресурс меню.


             Expected Menu String

             Каждый оператор MENUITEM и  POPUP  должен  содержать  поле
        text, которое заключено в двойные  кавычки,  и  определяет  имя
        элемента  меню  или  накладываемого  меню.  Оператор   MENUITEM
        SEPARATOR не требует строки.


             Expected numeric command value

             RC ожидал число в поле idvalue в  операторе  ACCELERATORS.
        Убедитесь, что вы использовали #define для определения значения
        константы, и что константа описана правильно.


             Expected numeric constant in string table


       Windows 3.0/Ref/7#7                                      = 141 =

             Числовая  константа,  определенная  в  операторе  #define,
        должна следовать непосредственно за  ключевым  словом  BEGIN  в
        операторе STRINGTABLE или ERRTABLE.


             Expected numeric point size

             Поле pointsize параметра FONT в  операторе  DIALOG  должно
        быть целым значением размера точки.


             Expected Numerical Dialog constant

             Оператор DIALOG требует целых значений  для  полей  x,  y,
        width и height. Убедитесь, что  эти  значения  вставлены  после
        ключевого слова DIALOG, и что они не отрицательны.


             Expected String in STRINGTABLE/ERRTABLE

             Ожидается  строка  после  каждого  значения   stringid   в
        операторе STRINGTABLE или ERRTABLE.


             Expected String or Constant Accelerator command

             RC не смог определить какой тип клавиши  нужно  установить
        для ускорения. Поле event в операторе ACCELERATORS  может  быть
        неправильным.


             Expecting number for ID

             Ожидается  числовое  значение  для  поля  id  управляющего
        оператора  в  операторе  DIALOG.  Убедитесь,  что  в  операторе
        #define ID сопоставлено число.


             Expecting quoted string in dialog class

             Поле class параметра CLASS в операторе DIALOG должно  быть
        целым значением или строкой, заключенной в двойные кавычки.


             Expecting quoted string in dialog title

             Поле captiontext  параметра  CAPTION  в  операторе  DIALOG
        должно быть  строкой  ASCII  символов,  заключенной  в  двойные
        кавычки.


             File not found: filename


       Windows 3.0/Ref/7#7                                      = 142 =

             Файл,  указанный  в  командной  строке   RC   не   найден.
        Проверьте, не находится ли файл в другом каталоге  и  правильно
        ли набрано имя файла или путь.


             Font names must be ordinals

             Поле  pointsize  в  операторе  FONT  должно   быть   целым
        значением, а не строкой.


             Gangload area is [size] bytes at offset 0x[address]

             (V) Это размер (в байтах) всех  сегментов,  которые  имеют
        один из следующих атрибутов:

             - PRELOAD

             - DISCARDABLE

             - Кодовые сегменты, которые содержат точку входа WinMain

             - Сегменты данных (которые не могут быть сброшены)

             Сегменты размещены в непрерывной области в .EXE файле  для
        быстрой загрузки. Значение  смещения  отсчитывается  от  начала
        файла. Для запрещения групповой загрузки используйте ключ -k.


             Insufficient memory to spawn RCPP.EXE

             Не  хватает  памяти  для  работы   препроцессора   (RCPP).
        Попробуйте  не  выполнять  какой-либо  резидентной   программы,
        которая  может  занимать  слишком  много  оперативной   памяти.
        Используйте  программу  CHKDSK  для  проверки  всей   имеющейся
        памяти.


             Invalid Accelerator

             Поле event в операторе ACCELERATORS не было воспринято или
        же имело длину более двух символов.

             Invalid Accelerator Type (ASCII or VIRTKEY)

             Поле type  в  операторе ACCELERATORS должно содержать либо
        ASCII, либо VIRTKEY значение.


             Invalid control charcter

             Управляющий символ  в  операторе  ACCELERATORS  не  верен.
        Правильный управляющий  символ  должен  содержать  только  одну

       Windows 3.0/Ref/7#7                                      = 143 =

        букву, следующую за символом (^).


             Invalid Control type

             Каждый оператор управления в операторе DIALOG должен  быть
        одним  из  следующих:  CHECKBOX,  COMBOBOX,   CONTROL,   CTEXT,
        DEFPUSHBUTTON,  EDITTEXT,  GROUPBOX,  ICON,   LISTBOX,   LTEXT,
        PUSHBUTTON, RADIOBUTTON, RTEXT, SCROLLBAR.

             Убедитесь, что операторы управления набраны правильно.


             Invalid .EXE file

             Файл расширением .EXE не верен. Убедитесь, что компановщик
        создал его правильно и что файл существует. Вы можете проверить
        .EXE файл с помощью программы EXEHDR.


             Invalid switch, option

             Вы использовали неверный параметр. Используйте RC  -?  для
        получения списка параметров командной строки.


             Invalid type

             Тип ресурса  отличается  от  типа  определенного  в  файле
        WINDOWS.H.


             Invalid usage. Use rs -? for Help

             Убедитесь, что обрабатывается по крайней мере  один  файл.
        Используйте RC -? для  получения  списка  параметров  командной
        строки.


             No executable filename specified.

             Был  использован  параметр  -FE,  но  имя  .EXE  файла  не
        определено.


             No resource binary filename specified.


             Был  использован  параметр  -FO,  но  имя  .RES  файла  не
        определено.


             Not a Microsoft Windows format .EXE file

       Windows 3.0/Ref/7#7                                      = 144 =


             Убедитесь, что компановщик создал .EXE  файл  правильно  и
        что файл существует. Вы можете проверить .EXE  файл  с  помощью
        программы EXEHDR.


             Out of far heap memory

             Не хватает памяти .  Попробуйте  не  выполнять  какой-либо
        резидентной программы, которая  может  занимать  слишком  много
        оперативной памяти. Используйте программу CHKDSK  для  проверки
        всей имеющейся памяти.


             Out of memory, needed n bytes

             RC не смог разместить определенное количество памяти.


             RC: Invalid swap area size: -S string

             Размер области для обмена  не  верен.  Проверте  синтаксис
        параметра  -S  в  командной  строке  RC.   Возможны   следующие
        командные строки:

             RC S123
             RC S123K ;где K это килобайты
             RC S123p ;где p это параграфы


             RC: Invalid switch: option

             Вы использовали неверный параметр. Используйте RC  -?  для
        получения списка параметров командной строки.


             RC: RCPP preprocessor-command-string

             (V) RC прошел строку предназначенную для препроцессора.


             RC: RCPP.ERR not found

             Файл RCPP.ERR должен находиться в текущем каталоге  или  в
        каталоге, указаном в PATH.


             RC terminated by user

             Была  нажата  комбинация  клавиш  CONTROL+C,   работа   RC
        прервана.



       Windows 3.0/Ref/7#7                                      = 145 =

             RC terminating after preprocessor errors

             Смотрите  документацию  к  Microsoft  C   5.1   Optimizing
        Compiler для получения информации об ошибках препроцессора.


             RCPP.EXE command line greater than 128 bytes

             Командная строка имеет слишком большую длину.


             RCPP.EXE is not a valid executable

             Файл RCPP.EXE не верен.  Файл мог быть изменен. Попробуйте
        скопировать файл с SDK дисков.


             Reading resource-name

             (V) RC читает .RES файл.


             Resources will be aligned on number byte boundaries

             (V)  Выравнивание  определено  параметром  ALIGN:number  в
         LINK строке.


             Sorting  preload  segments  and  resources  into  gangload
        section

             (V) RC сортирует предварительно загружаемые сегменты таким
        образом, что бы они могли быть быстро загружены.


             Text string or ordinal expected in Control

             Поле text операторa CONTROL в операторе DIALOG должно быть
        или  текстовой  строкой  или  порядковым  указателем   на   тип
        ожидаемого  блока  управления.  Если  используется   порядковый
        указатель, убедитесь, что у вас есть оператор #define для блока
        управления.


             The EXETYPE of this prgram is not Windows

             В .DEF  файле  нет  оператора  EXETYPE  WINDOWS.  Так  как
        компановщик мог произвести оптимизацию для OS/2  (по  умолчанию
        EXETYPE),  что  не  приемлимо  для  Windows,  поэтому  оператор
        EXETYPE WINDOWS должен быть определен.


             Unable to create destination

       Windows 3.0/Ref/7#7                                      = 146 =


             RC не смог создать  файл  назначения.  Убедитесь,  что  на
        диске достаточно свободного места.


             Unable to open exe-file

             RC  не  может  открыть  этот  .EXE  файл.  Убедитесь,  что
        компановщик создал его правильно и что файл существует.


             Unbalanced Parenthesis

             Убедитесь, что вы закрыли все открытые  круглые  скобки  в
        операторе DIALOG.

             Unexpected value in RCData

             Значения raw-data в операторе RCDATA  должны  быть  целыми
        или строками, и каждое из них отделено запятой. Убедитесь,  что
        вы не  пропустили  запятых,  и  не  пропустили  кавычек  вокруг
        строки.


             Unknown DIB header format

             Заголовок   растровой   карты   не   является   структурой
        BITMAPCOREHEADER или структурой BITMAPINFOHEADER.


             Unknown error spawning RCPP.EXE

             По неизвестной причине RCPP не  был  запущен.  Попытайтесь
        скопировать файл с SDK дисков, и используйте  программу  CHKDSK
        для проверки всей имеющейся памяти.


             Unknown Menu SubType

             Поле item-definition оператора MENU может содержать только
        операторы MENUITEM и POPUP.


             Warning: ASCII character not  equivalent  to  virtual  key
        code

             В операторе ACCELERATORS неверный код виртуальной клавиши.
        Значение ASCII для некоторых символов  (таких как *, ^, &,)  не
        равно коду виртуальной  клавиши  для  передаваемых  клавиш.  (В
        случае звездочки  (*),  код  виртуальной  клавиши  равен  ASCII
        значению  для  8,  цифровому  символу  на   той   же   клавише.
        Следовательно оператор:


       Windows 3.0/Ref/7#7                                      = 147 =

             VIRTKEY '*'

        не  верен. Смотрите приложение A, "Коды виртуальных клавиш",  и
        приложение D, "Таблицы символов", для этих значений.


             Warning:  Discardable  segment  id  (hex-size  bytes)   is
                                                      exesssively large.

             Размер  сегмента  больше  чем  27FFh.   RC   выведет   это
        предупреждение потому, что очень большие сегменты могут вызвать
        нежелательный эффект в памяти. Проверте ваш файл для  уточнения
        размеров ваших сегментов.


             Warning: SHIET or CONTROL used without VIRTKEY

             Необязательные параметры  ALT,  SHIFT  и CONTROL применимы
        только к   виртуальным   клавишам    оператора    ACCELERATORS.
        Убедитесь, что  вы  используете  опцию  VIRTKEY с одним из этих
        параметров.


             Writing resource resource-name or ordinal-id
                                          resource type (resource size)

             (V) RC записывает имя источника или номер ID,  за  которым
        следует точка, тип ресурса и размер ( в байтах).


             Warning: string segmen number set to PRELOAD

             RC отображает это сообщение  когда  он  копирует  сегмент,
        который должен  быть  предварительно  загружен,  но  который не
        помечен компоновщиком в .DEF файле как PRELOAD.

             Все несбрасываемые  сегменты  должны  быть  предварительно
        загружены, включая      сегменты     автоматических     данных,
        фиксированные сегменты и точку входа в программу (WinMain).

             Атрибуты ваших  кодовых  сегментов  устанавливаются   .DEF
        файлом. Проверьте  содержимое  вашего  MAP  файла для получения
        дополнительной информации.





       Windows 3.0/Ref/7#7                                      = 148 =

                        Приложение C. Отладочные сообщения Windows             
       ----------------------------------------------------------------

             Отладочная версия   Windows   генерирует   диагностические
        сообщения всегда когда  она  встречает  ошибки,  которые  могут
        повредить систему.   Каждое   диагностическое  сообщение  имеет
        уникальное число или строку, определяющую причину возникновения
        сообщения и потенциальный неудачный исход.  Это приложение дает
        перечень большинства   имен   диагностических   сообщений,   их
        передаваемых шестнадцетеричных   значений,  объясняет  значения
        каждого сообщения, и в некоторых случаях предлагаются возможные
        решения.

             Все сообщения    разделены    на    три   части,   которые
        соответствуют  трем  модулям  Windows:  User,  GDI  и   Kernel.
        Сообщения   в   каждой   части   создаются  функциями,  которые
        содержатся в соответствующих модулях. Это разделение необходимо
        только потому, что  некоторые  сообщения  в  модулях User и GDI
        имеет одинаковые коды ошибок.


             Коды ошибок User
             ────────────────

             Коды ошибок в этом  разделе  созданы  функциями  в  модуле
        Windows User.  Некоторые  из этих сообщений используют такие же
        коды как и сообщения GDI.  Проверяйте контекст кода ошибки  для
        определения того, с каким модулем он связан. Смотрите следующий
        раздел "Коды   ошибок   GDI"   для   получения   дополнительной
        информации для отличия этих сообщений.

             Код   Значение
             ───   ────────

             1     Не достаточное  количество  памяти было доступно для
                   запрошенного  размещения.  Выдается  при   маленьком
                   количестве    памяти.    Запустите    HEAPWALK   для
                   определения  количества  свободной  памяти.   Будьте
                   уверены  в  том,  что  вы  не  создали фиксированных
                   объектов, фрагментирующих память.

             2     Не достаточное количество памяти было  доступно  для
                   запрошенного   перемещения.   Не  пытайтесь  вызвать
                   функцию LocalRealloc для увеличения  размера  вашего
                   сегмента сверх 64K. Избегайте создания фиксированных
                   объектов, которые фрагментируют память.

             4     Блок памяти   не   может   быть  блокирован.  Будьте
                   уверены,  что возвращаемая  величина  функции  вашей
                   прикладной   программы   -   допустимый  дескриптор.
                   Запустите  HEAPWALK   для   определения   количества
                   свободной  памяти.  Будьте уверены в том,  что вы не
                   создали  фиксированных   объектов,   фрагментирующих

       Windows 3.0/Ref/7#7                                      = 149 =

                   память.

             5     Блок памяти  не  может  быть  разблокирован.  Будьте
                   уверены. что блок был блокирован.

             6     Недопустимый дескриптор был послан функции GDI.  Это
                   может  произойти  для любого объекта GDI.  Проверьте
                   величину,   которую   вы   получили    от    объекта
                   создания/получения   GDI   для   того,   чтобы  быть
                   уверенным что возвращается допустимое значение.

             7     Дескриптор окна,  посланный вами в  функцию  был  не
                   допустим.  Используйте функцию IsWindow для проверки
                   допустимости дескриптора и того,  что окно  не  было
                   разрушено.

             8     Использовано пять     предварительно     загружаемых
                   контекстов отображения (DCs).  Будьте  уверены,  что
                   ваша прикладная программа вызывает функцию ReleaseDC
                   для  освобождения  DC,  когда  прикладная  программа
                   работает  с ним.  Если функция ReleaseDC не вызвана,
                   DC  будет  не  доступен  для   системы   или   любой
                   прикладной программы.

             9     Не найдена  функция DefWindowProc в вашей прикладной
                   программе.  Разместите функцию DefWindowProc в вашей
                   прикладной  программе  и убедитесь,  что вы передали
                   корректные параметры.

             A     Некоторые прикладные  программы  могут   откладывать
                   открытие   системного   буфера.   Выждите   паузу  и
                   проверьте через  несколько  секунд.  Убедитесь,  что
                   ваша    прикладная    программа    вызвала   функцию
                   CloseClipboard так быстро, как только возможно.

             B     Ваша прикладная программа  пыталась  разрушить  окно,
                   в то    время    как    оно    использует   контекст
                   отображения(DC). Будьте уверены, что ваша прикладная
                   программа    вызывает    функцию    ReleaseDC    для
                   освобождения DC, когда прикладная программа работает
                   с ним.  Если функция ReleaseDC не вызвана,  DC будет
                   не  доступен  для  системы  или   любой   прикладной
                   программы.

             C     Неправильно инициализирован    драйвер   клавиатуры.
                   Перезапустите Setup.

             D     Неправильно инициализирован     драйвер      "мыши".
                   Запустите    вновь   Setup,   или   убедитесь,   что
                   оборудование  "мыши"  не  отсоединено,  и  что   она
                   работает вне Windows.

             E     Неправильно инициализирован     драйвер     дисплея.

       Windows 3.0/Ref/7#7                                      = 150 =

                   Перезапустите Setup.

             F     Была попытка разблокировать сегмент данных,  а он не
                   был  заблокирован.  Убедитесь,  что  сегмент  данных
                   заблокирован перед попыткой его разблокировать.

             16    Счетчик  для  окон  определенного  класса   превысил
                   ограничение 32767.  Каждый  раз когда создается окно
                   определенного класса,  Windows  увеличивает  счетчик
                   класса.  Каждый  раз  когда окно класса разрушается,
                   счетчик уменьшается.  Это сообщение  имеет  место  в
                   функциях CreateWindow и CreateWindowEx.

             17    Счетчик  для   окон   определенного   класса    стал
                   отрицательным числом. Смотрите предыдущее сообщение,
                   для получения информации о  деталях.  Это  сообщение
                   имеет место в функции DestroyWindow.

             18    Счетчик для окон определенного класса не стал нулем,
                   когда класс был разрушен. Когда прикладная программа
                   или библиотека прекращает работу,  Windows разрушает
                   все   окна   и  классы,  созданные  этой  прикладной
                   программой или библиотекой.  Эта ошибка имеет место,
                   когда   после  того, как  класс  разрушен,  все  еще
                   существует окно,  созданное  различными  прикладными
                   программами  или библиотеками,  которые использовали
                   разрушенный класс.


             Коды ошибок GDI
             ───────────────

             Ошибки GDI   возникают,   когда   недопустимый  дескриптор
        посылается определенной  функции  GDI.  Эти  ошибки  могут быть
        определены   существованием    функции    ValidateHandle    при
        тестировании.  ValidateHandle - это внутренняя функция Windows,
        которая сообщает,  что дескриптор допустим.  Убедитесь,  что вы
        проверяете  эту  функцию для отличия ошибок GDI от ошибок User,
        имеющих такой же номер кода.  (Ошибки User описаны в предыдущем
        разделе).


             Код   Значение
             ───   ────────

             0     Функция GDI получила NULL дескриптор объекта.

             1-A   Допустимый дескриптор,  ссылается на объект, который
                   не  является  объектом  GDI,  или  это  объект   GDI
                   неправильного  типа.  Эта  ошибка часто встречается,
                   когда объект удален и дескриптор используется вновь,
                   для каких-то других целей в других операциях GDI.


       Windows 3.0/Ref/7#7                                      = 151 =

                   Значение кода   ошибки   зависит  от  типа  объекта,
                   ожидаемого   функцией   GDI,   которая    генерирует
                   сообщение   об   ошибке.  Каждый  объект  GDI  имеет
                   идентификатор  типа.  Каждая  функция  GDI,  которой
                   доступен  объект,  как  параметр,  определяет  какой
                   объект или объекты доступны.  Для сообщения,  что ею
                   получен  допустимый  дескриптор,  каждая функция GDI
                   вызывает  функцию  ValidateHandle  и   передает   ей
                   дескриптор   и  диапазон  доступных  идентификаторов
                   типа.   Если   дескриптор   ссылается   на   объект,
                   идентификатор  типа которого не попадает в доступный
                   диапазон,  ValidateHandle  генерирует  код   ошибки,
                   представляющий собой наименьшую величину диапазона.

                   Например, функция   SelectObject   ожидает,  что  ее
                   первый параметр должен быть DC,  DC метафайла, или/и
                   DC разделенного на части метафайла. Она посылает это
                   значение,  вместе с диапазоном (от 7H до AH) функции
                   ValidatHandle.  Если  идентификатор типа дескриптора
                   не попадает    внутрь    этого     диапазона,     то
                   ValidateHandle создает код ошибки со значением 7H.

                   Нижеследующий перечень   показывает   идентификаторы
                   типов различных объектов:


                   ID Типа             Объект
                   ───────             ──────

                   1                   Перо

                   2                   Кисть

                   3                   Шрифт

                   4                   Палитра

                   5                   Растровая карта

                   6                   Область

                   7                   Контекст устройства

                   8                   Разрушенный контекст устройства

                   9                   Контекст устройства метафайла

                   A                   Контекст устройства разделенного
                                       на части метафайла


             B     Окно разрушено,   не    освободив   DC,   полученное
                   с использованием функции GetDC.

       Windows 3.0/Ref/7#7                                      = 152 =



             Коды ошибок Kernel
             ──────────────────

             Диагностические сообщения   в   этом   разделе  связаны  с
        функциями, содержащимися в модуле Windows Kernel. Эти сообщения
        представлены  в  порядке  возрастания номеров кодов.  Некоторые
        номера  представляют  несколько  сообщений.   Версия   Windows,
        поступающая в продажу,  отображает как число кода,  так и текст
        сообщения.  Отладочная версия Windows отображает  только  число
        кода.

             Код   Сообщение
             ───   ─────────

             FF    gnotify - can`t discard segment

                   Эта ошибка обычно имеет место в реальном режиме  при
                   дальнем   вызове,  когда  регистр  DS  указывает  на
                   фиксированный объект.  Windows  не  сможет  сбросить
                   кодовый сегмент, который сделал этот вызов.

                   Эта ошибка  может быть создана следующими функциями:
                   GlobalReAlloc,  GlobalAlloc  (  параметр  wFlags  не
                   содержит    GMEM_NOCOMPACT    или   GMEM_NODISCARD),
                   GlobalCompact, GlobalDiscard, GlobalWire.


             FF    Cannot GetProcAddress a task

                   Вы не  можете  использовать вызов GetProcAddress для
                   библиотеки или вызывающей задачи.

             FF    Make ProcInstance only for current instance

                   Это сообщение  отображается,  если  вы   используете
                   MakeProcInstance  для  вызова точки вхождения другой
                   задачи.

             FF    MyOpenFile not reentrant

                   Внутренняя ошибка Windows.

             FF    gadd_free: Seg add not range

                   Невозможно добавить сегмент в  свободный  глобальный
                   перечень.   Ваша  прикладная  программа  выходит  за
                   границу памяти Windows.

             FF    FREE MEMEORY OVERWRITE AT

                   Память, перечисленная,  как свободная не содержит CC

       Windows 3.0/Ref/7#7                                      = 153 =

                   в  каждом  байте,  как  ожидалось.  Поставьте  точку
                   останова на  определенный   адрес   для   нахождения
                   решения проблемы.

             FF    free_list: prev bad

                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью;  указатель предыдущего элемента
                   в списке, не указывает на текущий.

             FF    free_list: next bad

                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью; указатель следующего элемента в
                   списке, не указывает обратно на текущий элемент.

             FF    free_list: count bad

                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью;  последний элемент в списке, не
                   соответствует ожидаемому последнему элементу.

             FF    Heap frozen in INT 33

                   Внутренняя ошибка Windows.

             FF    LOCAL FREE MEMORY OVERWRITE AT

                   Память, перечисленная,  как свободная не содержит CC,
                   как  ожидалось, в  каждом  байте.

             FF    Automatic Data Segment larger than 64K

                   STACK + HEAP + STATICS образуют больше 64К. Измените
                   фйал определения модуля (.DEF).

             FF    PatchCodeHandle, CORE DUMP FOLLOWS:

                   Внутренняя ошибка Windows.

             FF    lru: prev bad

                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью;  указатель предыдущего элемента
                   в списке, не указывает на текущий.

             FF    lru: next bad

                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью; указатель следующего элемента в
                   списке, не указывает обратно на текущий элемент.

             FF    lru: count bad

       Windows 3.0/Ref/7#7                                      = 154 =


                   Область свободной  глобальной  памяти была испорчена
                   посторонней записью;  последний элемент в списке, не
                   соответствует ожидаемому последнему элементу.

             100   LocalAlloc: Invalid local heap

                   Посторонняя запись   испортила   область  локальной
                   динамической памяти.

             100   Ifreeadd: Invalid local heap

                   Невозможно добавить сегмент в  свободный  глобальный
                   перечень.    Ваша    прикладная    программа   имеет
                   перекрытую локальную область динамической памяти.

             100   function_name: Invalid local heap

                   Приводит список функций,  которые выполняют проверку
                   (LocalAlloc,  LocalLock и т.д.  ) и показывает общее
                   перекрытие локальной динамической памяти.

             103   Invalid local heap

                   Либо посторонняя  запись  имела место,  либо функция
                   LocalInit  была  неправильно   выполнена.   Оставьте
                   немного   памяти   для   Windows,   когда  вызываете
                   LocalInit.

             140   Local heap is busy

                   Два редактируемых блока управления  в  одной  панели
                   диалога с одинаковым значением ID. Убедитесь, что вы
                   не перепутали десятичные и шестнадцетиричные числа.

             140   EnterCrit: local heap is busy

                   Внутрення ошибка Windows. Попытка повторного входа в
                   системную  область  системы,  управляющей  локальной
                   памятью.

             140   LeaveCrit: local heap is busy

                   Внутрення ошибка   Windows.   Попытка   выхода    из
                   системной  области  системы,  управляющей  локальной
                   памятью, когда ее уже нет в системной области.

             143   Invalid local heap

             14B   Invalid local heap

             15B   Invalid local heap


       Windows 3.0/Ref/7#7                                      = 155 =

             180   LDREF: Invalid local handle

                   Недопустимый локальный   дескриптор  (создаваемый  в
                   вызовах функций LocalReAlloc, LocaLock и т.д. ).

             1C0   LocalLock: Object usage count overflow

                   Память LMEM_MOVEABLE   или   LMEM_DISCARDABLE   была
                   заблокирована больше чем 255 раз.

             1F0   LocalFree: freeing locked object

                   Локальная память была разблокирована перед тем,  как
                   была вызвана функция LocaFree.

             1F0   LocalUnlock: Object usage count underflow

                   Локальная память была разблокирована больше раз, чем
                   блокирована.

             200   gmove_stack usage error

                   Внутренняя ошибка  Windows  использования  временого
                   стека.

             200   Leave_eems_stack error

                   Внутренняя ошибка    Windows    при    использовании
                   временого стека.

             200   function_name: Invalid  global heap,
                                            offender_para_reader_header

                   Приводит список функций,  которые выполняют проверку
                   (&n=LocalAlloc,  LocalLock  и  т.д.  )  и показывает
                   общее перекрытие локальной динамической памяти.

             200   function_name: Invalid  global heap,
                                            offender_para_reader_header

                   Приводит список  функций,   где   проверка   выявила
                   нарушения    и   показывает   перекрытие   локальной
                   динамической памяти.

                   Если DX не ноль, DX = началу нарушенной области:

                   Код    Значение
                   ───    ────────

                   201    Недопустимая ссылка вперед

                   202    Недопустимая ссылка назад


       Windows 3.0/Ref/7#7                                      = 156 =

                   204    ga_handle указывает на свободный дескриптор

                   208    Область указывает не дескриптор

                   280    Плохой ga_sig

                   Если DX равен нулю:

                   Код    Значение
                   ───    ────────

                   210    Размещенный  дескриптор    не    совпадает  с
                          используемыми дескрипторами

                   220    Общее число дескрипторов неверно

                   240    Неверно общее число свободных дескрипторов


             240   Critical section problems

             280   gdfer: invalid handle

                   Недопустимый глобальный  дескриптор  (  созданный  в
                   вызовах функций GlobalReAlloc,  GlobalLock и  т.д.).
                   Убедитесь, что:

                   - Для окна имеется функция окна.

                   - Для    функции   окна   делается   вызов   функции
                     MakeProcInstance.

                   - Экспортируется ваша функция окна.

             2C0   GlobalLock: Object usage count overflow

                   Память GMEM_MOVEABLE   или   GMEM_DISCARDABLE   была
                   заблокирована больше 255 раз.

             2F0   EMS_GlobalFree: freeing locked object

                   Глобальная память была разблокирована перед тем, как
                   была вызвана функция GlobalFree.

             2F0   GlobalFree: freeing locked object

                   Глобальная память была разблокирована перед тем, как
                   была вызвана функция GlobalFree.

             2F0   GlobalFree: freeing locked object

                   Глобальная память была разблокирована перед тем, как
                   была вызвана функция GlobalFree.

       Windows 3.0/Ref/7#7                                      = 157 =


             2F0   GlobalUnlock: Object usage count underflow

                   Глобальная память была  разблокирована  больше  раз,
                   чем блокирована.

             2F0   GlobalUnWire: Object usage count underflow

                   Связывание глобальной  памяти  было отключено больше
                   раз, чем она была связана.

             303   PatchStack - invalid BP chain

                   Цепочка фреймов  стека  неверна,   из   за   наличия
                   посторонней записи.

             303   SearchStack - invalid BP chain

                   Цепочка фреймов  стека  неверна,   из   за   наличия
                   посторонней записи.

             401   BOOT: unable to load application

                   Функция LoadModule   неправильно    выполнена    для
                   прикладной программы оболочки.

             401   BOOT: Unable to find file pathname

                   Файл не найден.

             401   BOOT: Invalid .EXE file pathname

                   Недопустимый формат файла .EXE.

             401   BOOT: Unable to load pathname

                   Функция LoadModule    неправильно    выполнена   для
                   библиотеки, загруженной во время начальной загрузки.
                   Передан дальний указатель на имя модуля,  который не
                   может быть загружен.

             403   Invalid ordinal reference

                   Вы компонуете функцию,  не имеющую точки вхождения в
                   версии Windows,  которую вы запустили на выполнение.
                   Проверьте ваш .DEF файл,  для того чтобы  убедиться,
                   что вы используете правильную ссылку.

             404   Call to undefined dynlink entry point at entry-point

                   Поврежденная таблица  импорта или посторонняя запись
                   появляется       поверх       сегмента       таблицы
                   перераспределений. Это сообщение отображается, когда

       Windows 3.0/Ref/7#7                                      = 158 =

                   ваша прикладная программа вызывает  точку  вхождения
                   для  драйвера,  который больше не содержит эту точку
                   вхождения.

             405   Invalid ctart procedure

                   Неправильный заголовок .EXE.

             406   Invalid module handle

                   Невозможно получить заголовок EXE для  определенного
                   дескриптора модуля.

             407   Invalid relocation record in es,bx

                   Посторонняя запись         разрушила          запись
                   перераспределения.

             408   Error saving forward reference

             409   Out of memory loading segment from hModule of
                                                      segment  location

                   Недостаточно памяти   имелось   в  распоряжении  для
                   загрузки сегментов.

             409   I/O error reading segment contens from hModule of
                                                      segment  location

                   Невозможно прочитать   сегмент   вследствии   ошибки
                   открытия, чтения или поиска файла.

             409   Segment contents invalid

                   Значение контрольной суммы не совпадает с содержимым
                   сегмента при загрузке сегмента.

             409   Segment contents trashed

                   В определенном   сегменте  имела  место  посторонняя
                   запись.

                   Ошибка 409  появляется  когда  кодовый  сегмент  был
                   изменен после его загрузки;  это происходит обычно в
                   результате появления посторонних записей.

                   Работающая в защищенном  режиме  Windows  будет  для
                   кода,   порождающего   ошибку,  гененрировать  общую
                   ошибку нарушения защиты.

                   Убедитесь, что ваши  буфера  достаточно  велики  для
                   работы.  Также запустите Shaker для просмотра,  если
                   эта ошибка появляется слишком часто.

       Windows 3.0/Ref/7#7                                      = 159 =


             410   Error reading relocation records from

                   Функция 3F  прерывания  21  невозможна  для   чтения
                   диска,   или   чтения   информации   совместимой   с
                   запрашиваемой информацией.

             411   Insert disk for specified file

             412   Unable to load non-resident table

                   При попытке загрузить  таблицу  нерезидентных  имен,
                   возможно   появление   одной  из  следующих  четырех
                   ошибок:

                   - Неправильно выполнена функция OpenFile.

                   - Функция 42 ( поиск) прерывания 21 дает ошибку.

                   - Функция 3F (загрузка сегмента) прерывания 21  дает
                     ошибку.

                   - Размер таблицы не совпадает с содержимым.

             4FF   INT 3F nahdler unable to load segment

                   Функция LoadSegment дает сбой. Вы получите сообщение
                   "Out of  memory  loading  segment"  перед  тем,  как
                   получите это сообщение.

             501   Missing resource table

             502   Bad resourcetype

             503   Bad resource name

             504   Bad resource file

             505   Unable to read resource from segment

                   Функция 3F  прерывания  21  невозможна  для   чтения
                   диска,   или   чтения   информации   совместимой   с
                   запрашиваемой информацией.

             505   Error loading from resource file filename

                   Эта ошибка возможна в одном из следующих случаев:

                   - Параметр hResInfo функции LoadResoyrce есть NULL.

                   - Посторонняя запись разрушила заголовок модуля.

                   - Посторонняя запись разрушила таблицу EXE.

       Windows 3.0/Ref/7#7                                      = 160 =


                   - Файл ресурсов не содержит требуемый ресурс.

             600   Atom Manager errors

                   Имела место посторонняя запись.

             700   Input/Output package errors




       Windows 3.0/Ref/7#7                                      = 161 =

                              Приложение D. Таблицы символов                   
       ----------------------------------------------------------------

             Расширенный набор символов IBM PC





             Рис. 1



               Показывает, что этот символ не поддерживается Windows.


             Таблица ANSI








             Рис 2.

               Показывает, что этот символ не поддерживается Windows.




       Windows 3.0/Ref/7#7                                      = 162 =

           Приложение Е. Динамически-подсоединяемая библиотека Windows для     
                      управления 32-битовой памятью.
       ----------------------------------------------------------------

             Одна  из  важнейших  возможностей  микропроцессоров  Intel
        80386 и  80486 это наличие 32-ух битовых регистров для работы с
        кодами  и   данными.   Прикладные   программы,   написанные   с
        использованием  этих регистров могут избежать сегментной модели
        памяти,  применяющуюся на ранних микропроцессорах,  а  в  место
        этого  использовать  "плоскую" модель памяти,  в которой память
        рассматривается как единый, непрерывный блок.

             Хотя   Microsoft   Windows  версии  3.0  продолжает  линию
        сегментой модели памяти, Windows предоставляет  набор  функций,
        которые позволяют прикладной программе возможность использовать
        32-битовые  возможности  микропроцессоров  80386  и  80486. Эти
        фкнкции      доступны      прикладной      программе      через
        динамически-подсоединяемую  библиотеку  (DLL), имеющую название
        WINMEN32.DLL.  Эта DLL, поставлется как часть SDK и не является
        частью продаваемой версии  Windows.  Следовательно,  если  ваша
        прикладная прграмма вызывает функции из WINMEM32.DLL, вы должны
        включить  WINMEM32.DLL  в  вашу  прикладную  программу когда вы
        поставите ее конечному пользователю.

             В  этом  приложении  обсуждаются  функции  содержащиеся  в
        WINMEM32.DLL   и   показано  как  использовать  эти  функции  в
        контексте прикладной программы Windows. Темы  приведенной  ниже
        информации:

             -  Краткий  обзор  некоторых  различий  между   сегментной
        моделью памяти и плоской моделью памяти

             - Использование  WINMEM32.DLL  для  получения  преимуществ
        32-ух битовых возможностей микропрцессоров 80386 и 80486

             -  Особенности  программирования  при  использовании  этих
        возможностей в прикладных программах для Windows

             - Общие подходы в  использования  32-ух  битовой памяти  в
        прикладных программах для Windows

             Список функций предоставляемых WINMEM32.DLL приведен после
        этой  информации.  В  приложение  включено  несколько  примеров
        ассемблерных  программ,   демонстрирующих,   как   использовать
        функции DLL.

             ВАЖНО: Это приложение предполагает, что вы хорошо  знакомы
        с архитектурой и  возможностями  управления  кодами  и  памятью
        микропроцессоров  80386/80486.  Это  приложение   не   пытается
        объяснить эти возможности и  предполагает,  что  вы  знакомы  с
        терминологией и принципами общения с такой архитектурой.

             Только опытный разработчик  программного  обеспечения  для

       Windows 3.0/Ref/7#7                                      = 163 =

        Windows с большим опытом написания ассемблерных программ должен
        пытаться использовать эти функции в прикладных программах.




       Windows 3.0/Ref/7#7                                      = 164 =

                          E.1 Сегментная и плоская модели памяти               
       ----------------------------------------------------------------

             Микропроцессоры  семейства 80x86  поддерживают  сегментную
        модель памяти, в которой системная память разделена на сегменты
        по 64 килобайта. В собственном  режиме  этих  микропроцессоров,
        адрес любого  байта  состоит  из  двух  16-ти битовых значений:
        адрес сегмента и смещение.  В режиме протекции микропроцессоров
        80286,  80386 и 80486 адрес сегмента перемещается в зависимости
        от значения селектора,  который микропроцессор  использует  для
        доступа к 64-ех килобайтным сегментам. В обоих режимах, объекты
        памяти больше 64К будут занимать  полностью  или  часть  разных
        сегментов. Так как объекты состоят из целых непрерывных блоков,
        они не могут быть доступны  прикладным  программам  посредством
        простого  увеличения указателя на ячейку памяти.  Вместо этого,
        прикладные программы могут увеличивать только смещение  адреса,
        не заботясь о превышении 64-ех килобайтной границы сегмента.

             В микропроцессор  80386  введены  32-ух  битовые регистры,
        которые параллельно являются 16-ти битовыми  регистрами  как  в
        старых   представителях  семейства  80x86.  Эти  регистры  дают
        возможность для первичного доступа к памяти в сегментах больших
        чем  64  килобайта.  Так как размер сегмента потенциально велик
        (2^32),  то плоская модель использует уже сейчас единый  сегмет
        памяти.  В  этой  модели  код прикладной программы и/или данные
        занимают   общий   сегмент.    Прикладная    программа    может
        манипулировать 32-ух  битовой  частью смещения памяти также как
        это  было  в  простом  указателе.  Прикладная  программа  может
        увеличивать  или  уменьшать  указатель/смещение  до любой точки
        адресного пространства не имея дела с границами сегмента.

             В  определенной  степении,  плоская  модель  памяти  имеет
        наибольшое сходство с минимальной моделью памяти, в  которой  и
        код и данные занимают единый сегмент; конечно,  за  исключением
        того, что сегмент намного больше чем 64-х  килобайтный  предел,
        налагаемый на сегментную модель памяти.  Как  и  в  минимальной
        модели   памяти,   начало   сегмента   плоской   модели   может
        располагаться в любом месте памяти. Другими словами, сегментная
        часть адреса может  указывать  виртуально  на  любую  ячейку  в
        памяти. В то время  пока  прикладная  программа  выполняется  в
        памяти,  указатель  сегмента  не  изменяется.  Только  смещение
        увеличивается или уменьшается  для  того,  чтобы  указывать  на
        различные ячейки памяти.

             Также, в этом приложении будет  отмечено,  что  невозможно
        выполнять прикладные программы для  Windows,  используя  только
        плоскую модель памяти. Сама среда Windows  опирается  на  16-ти
        битовую  сегментную  модель  памяти  и  таким  образом,   любая
        прикладная  программа,  взаимодействующая  с  Windows,   должна
        выполняться  не  более  чем  в  одном  16-ти  битовом   кодовом
        сегменте.  Однако,  несмотря  на  это   ограничение,   у   зтих
        прикладных программ есть возможность  находиться  в  одном  или
        более 32-ух  битовых  кодовых  сегментах  и  использовать 32-ух

       Windows 3.0/Ref/7#7                                      = 165 =

        битовые  сегменты  данных.  Библиотека  WINMEM32.DLL  дает  эту
        возможность  в  том  случае,  если  прикладная  программа будет
        полностью взаимодействовать с Windows и  иметь  с  ней  сходную
        основу.




       Windows 3.0/Ref/7#7                                      = 166 =

                         E.2 Использование библиотеки WINMEM32.DLL             
       ----------------------------------------------------------------

             Хотя  вы  можете  напрямую   выполнять   вашу   прикладную
        программу с кодом плоской модели, это сделает ee  обособленной.
        В результате, ваша программа не сможет выполняться  с  будущими
        версиями Windows или с другими совместимыми средами.

             Библиотека WINMEM32.DLL  предоставляет  стандартный  метод
        для выполнения плоских моделей,  что гарантирует взаимодействие
        с будущими версиями Windows или с другими совместимыми средами.
        Это  дает  вашей  прикладной  программе  доступ  к  сервису для
        размещения, перемещения и освобождения 32-ух  битовых  объектов
        памяти;  для  перевода 32-ух битовых указателей в 16-ти битовые
        указатели,  которые могут быть использованы функциями Windows и
        DOS; и для объеденения сегмента данных с кодовым сегментом так,
        что вы сможете  выполнять  код,  загружаемый  в  32-ух  битовый
        сегмент.

             Ваша прикладная   программа   может  загружать  библиотеку
        WINMEM32.DLL, когда Windows выполняется в реальном, стандартном
        или в 386-ом улучшенном режиме.  Однако,  так как 32-ух битовые
        регистры микропоцессоров  80386/80486  разрешены  только  когда
        Windows находится в 386-ом улучшенном режиме, то и WINMEM32.DLL
        допустима только в этом режиме.  Если ваша прикладная программа
        может выполняться в реальном или стандартном режиме,  вы должны
        разработать ее так, чтобы в этих режимах она могла иметь доступ
        к 16-ти  битовой памяти вместо 32-ух битовой памяти.  Вы можете
        определить режим в котором находится Windows с  помощью  вызова
        функции GetWinFlags.

             Библиотека WINMEM32.DLL  содержит восемь функций,  которые
        дают вашей прикладной программе доступ к 32-ух битовым объектам
        памяти. Ниже приведен список этих функций:

             Функция                   Описание
             ───────                   ────────

             Global32Alloc             Размещает  блок   32-ух  битовой
                                       памяти.

             Global32Realloc           Изменяет  размер  32-ух битового
                                       объекта памяти.

             Global32Free              Освобождает 32-ух битовый объект
                                       памяти.

             Global16PointerAlloc      Переводит 32-ух битовый указатель
                                       в 16-ти битовый указатель.

             Global16PointerFree       Освобождает            указатель
                                       псевдонима,            созданный
                                       Global16PointerAlloc.

       Windows 3.0/Ref/7#7                                      = 167 =


             Global32CodeAlias         Создает псевдоним кода для 32-ух
                                       битового     объекта     памяти,
                                       позволяющий коду в объекте  быть
                                       выполняемым.

             Global32CodeAliasFree     Освобождает   псевдоним    кода,
                                       созданный               функцией
                                       Global32CodeAlias.

             GetWinMem32Verwsion       Возвращает     номер      версии
                                       WINMEM32.DLL API.



             Список этих функций находится в конце данного приложения.

             Библиотека WINMEM32.DLL это  стандартная  DLL,  и  поэтому
        ваша  прикладная  программа  загружает ее так как бы она делала
        это с любой другой DLL.  В добавлении к DLL,  SDK предоставляет
        для   C-программ  включаемый  файл  WINMEM32.H  для  объявления
        функций  в  вашей   прикладной   программе   и   импортирования
        библиотеки  WINMEM32.LIB  для того,  чтобы ваша программа могла
        импортировать функции DLL при компановке программы.

             Соглашения по вызову функций WINMEM32.DLL такие же  как  и
        для других функций Windows.  Точки  входа  в  DLL  это  внешние
        процедуры FAR PASCAL. Они сохраняют SS,  BP,  DS,  SI  и  DI  и
        возвращают значения в AX или в DX:AX.




       Windows 3.0/Ref/7#7                                      = 168 =

             E.3 Некоторые особенности использования 32-ух битовой памяти      
       ----------------------------------------------------------------

             Как отмечалось      ранее,      Windows     придерживается
        сегментированной модели памяти.  То есть, все дальние указатели
        выражаются  в  форме 16:16,  состоящей из 16-ти битового адреса
        сегмента (в  реальном  режиме)  или  селектора  (в   защищенном
        режиме),  скомбинированного  с  16-ти  битовым смещением внутри
        сегмента. Прикладная  программа,  использующая  32-ух   битовые
        регистры микропроцессора 80386/80486 не может напрямую вызывать
        функции Windows потому,  что ее дальние  указатели  выражены  в
        форме 16:32 и Windows не может работать с лишними 16-ю битами в
        части адреса, отвечающей за смещение.

             Из-за  этого  несоответствия,  прикладная  программа   для
        Windows не  может  находиться только в 32-ух битовых сегментах.
        Она должна содержать хотя бы один кодовый  сегмент  "помощник",
        через  который  она  взаимодействовала  бы  с  Windows (включая
        WINMEM32.DLL).  Другими словами,  все  вызовы  функциЙ  Windows
        должны  быть  сделаны  из  вспомогательного  кодового сегмента.
        Вспомогательный кодовый сегмент содержит код, который переводит
        указатели 16:32  для 32-ух битовых сегментов в указатели 16:16,
        используемые функциями Windows. Этот сегмент также выполняет те
        же  задачи  для  прикладной программы,  когда она вызывает DOS,
        другие библиотеки  DLL  и  любые  другие   программы,   которые
        используют указатели 16:16.

             Существует  одно   важное   ограничение,   налагаемое   на
        вспомогательный сегмент, которое состоит в том, что он не может
        быть сброшен.  Если  же  сегмент  был  сброшен  и 32-ух битовый
        сегмент попытался обратиться к сегменту для  косвенного  вызова
        модуля   ядра   Windows,   то   в   результате,  сегмент  будет
        перезагружен.  Так как источником этого косвенного вызова может
        не быть 16-ти битовый сегмент, система может разрушиться.

             Другая  важная  особенность  состоит  в  том,   что   ваша
        прикладная программа не должна  назначать  что-либо  состояниям
        32-ух битовых  регистров  на время вызова API 16:16.  Например,
        вызов Windows API сохранит SI и DI,  но не обязательно сохранит
        ESI и  EDI.  Если  прикладная  программа  хочет сохранить 32-ух
        битовые  регистры  на  время  вызова  API  16:16,  она   должна
        самостоятельно  положить и взять из стека значения регистров до
        и после вызова.  Если 32-ух битовый  кодовый  сегмент,  который
        вызывает   функции   Windows  (через  вспомогательный  сегмент)
        сообщает, что регистры ESI и EDI должны быть сохранены на время
        вызова    функции,    то    вспомогательный    сегмент   должен
        самостоятельно сохранить регистры до вызова  функции.  А  после
        выполнения  функции вспомагательный сегмент должен восстановить
        значения регистров.

             Это правило применимо так же  для  возвращаемых  значений,
        когда  32-ух битовый сегмент косвено вызывает функцию Windows и
        ожидает 32-ух битовое  возвращаемое  значение.  Вспомогательный

       Windows 3.0/Ref/7#7                                      = 169 =

        сегмент   должен   самостоятельно  установить  старшие  16  бит
        возвращаемой величины,  когда он размещает ее в  регистре  EAX,
        что и показано на следующих примерах:

             MOVZX      EAX,AX      ; Беззнаковое возвращаемое значение

             MOVSX      EAX,AX      ; Знаковое возвращаемое значение

             Все эти особенности относятся так  же  к  вызовам  Windows
        DLL, DOS и других 16-ти битовых API.

                                                                               
            E.3.1 Плоская модель под Windows
       ----------------------------------------------------------------

             В среде Windows, системная память это разделяемый  ресурс,
        которым Windows управляет в интересах всех прикладных программ.
        Поэтому, правильная  работа  плоской  модели  памяти  в   среде
        Windows не возможна. Когда прикладная программа размещает 32-ух
        битовый объект ,то память, которую дает Windows программе может
        быть  размещена  в  любом месте физической памяти.  Память,  на
        которую указывает селектор уникальна для прикладной программы и
        не  включает  область ячеек системной памяти.  Другими словами,
        селектор,  который получает прикладная программа,  не указывает
        на вектор прерывания 0.  Это означает,  например,  что смещение
        400h для селектора не указывает на область данных DOS ROM BIOS.

                              E.3.2 Стек прикладной программы                  
       ----------------------------------------------------------------

             Windows имеет проблемы с работой в среде  смешанных  типов
        сегментов (сегменты 16:16 м 16:32).  И  как  результат,  размер
        селектора стека должен совпадать  с  размером  селектора  кода.
        Другими словами, когда процессор выполняет программу в  кодовом
        сегменте 16:32 (USE32), селектор SS регистра также должен  быть
        16:32. А когда выполняется программа в сегменте 16:16  (USE16),
        SS регистр должен содержать селектор 16:16.

             Когда микропроцессор 80386/80486 находится в режиме USE16,
        он использует младшие 16 бит регистра ESP как регистр  SP.  Так
        как в режиме процессора USE16 используются  только  младшие  16
        битов, процессор не следит за состоянием  старших  16-ти  битов
        регистра ESP. В результате  старшие  16  битов  устанавливаются
        случайным образом. Когда прикладная программа  переключается  в
        режим  сегмента  стека  USE32,  регистр  ESP  будет   содержать
        испорченный указатель,  если  только  старшие  16  бит  ESP  не
        установлены верно.

             Например,  прикладная  пррограмма  Windows  имеет  кодовый
        сегмент USE16:32  и  вспомогательный  сегмент  USE16,  но  стек
        только USE32. Когда прикладная программа  делает  вызов  из  ее
        кода USE32 в сегмент USE16, она остается в стеке USE32. Кодовый

       Windows 3.0/Ref/7#7                                      = 170 =

        сегмент  USE16  вызывает  функцию  Windows,  которая   изменяет
        селектор регистра SS на селектор USE16.  Так  как  теперь  стек
        находится  в  режиме  USE16,  старшие  16  битов  регистра  ESP
        устанавливаются случайным образом. Код,  который  первоначально
        переключил стек, затем восстановил старый  селектор  SS  и,  не
        зная , что он указывал на стек USE32, восстановит 16-ти битовый
        регистр SP вместо полных 32-ти битов регистра ESP. В результате
        стек будет иметь неверное значение указателя в регистре ESP.

             Существует несколько путей для борьбы  с  этой  проблемой.
        Во-первых,  прикладная   программа   может   организовать   два
        различных стека, один USE16 и другой USE32.  Обслуживание  этих
        разделенных стеков требует от вас  включить  лишние  команды  -
        например, вы должны скопировать параметры для  стека,  учитывая
        соглашения по  вызову,  таких  как  C.  Другим  решением  может
        служить организация одного стека, но с двумя селекторами стека,
        один USE16 и другой USE32. Оба селектора  должны  указывать  на
        одну и ту же память USE32. Это будет требовать от  стека  USE32
        ограничение значения в ESP величиной меньшей либо равной FFFFh.

             В любом случае, кодовый сегмент USE16 должен переключиться
        на  стек  USE32  непосредственно  перед  вызовом  программы   в
        сегменте USE32. Когда управление будет возвращено  из  кодового
        сегмента USE32 в кодовый сегмент USE16, тогда последний  должен
        сразу же переключиться обратно в стек USE16  до  того,  как  он
        сделает что-нибудь еще. Так как проблема с переключением  стека
        связана с разрушением старших 16-ти битов  ESP,  то  прикладная
        программа с кодом 16:32 должна убедиться,  что  она  установила
        старшие 16 битов ESP, когда она переключалась на селектор стека
        USE32. Она устанавливает эти биты путем размещения селектора  в
        SS, как показано на следующем примере:

             MOV     SS,   word  prt  [ Use32StackSel ]
             MOV     ESP, dword  prt  [ Use32StackOffset ]

             MOV     SS,   word  prt  [ Use32StackSel ]
             MOVZX   ESP, dword  prt  [ Use32StackOffset ]

             MOV     SS,   word  prt  [ Use32StackSel ]
             MOVZX   ESP, SP

                                                                               
            E.3.3   Код обработки прерывания
       ----------------------------------------------------------------

             Так как Windows это 16-ти битовая среда, то Windows  имеет
        проблемы, связанные со смешением типов,  и значит 32-ух битовый
        кодовый  сегмент не должен содержать кода,  который выполняется
        во время прерывания.  Так же она не должна содержать данные,  к
        которым  идет  обращение  во время обработки прерывания.  Любой
        код,  обрабатывающий прерывания,  должен находиться  в  кодовом
        сегменте USE16 со стеком USE16.  Данные,  используемые во время
        обработки прерывания,  должны находиться в сегменте данных кода

       Windows 3.0/Ref/7#7                                      = 171 =

        USE16.  Это правило так же применимо к исключительным ситуациям
        в  микропроцессоре  (таким  как   исключительные   ситуации   в
        сопроцессоре),   так  как  они  обрабатываются  так  же  как  и
        прерывания. Заметим,  однако,  что  это  приемлимо  для   32-ух
        битового  кодового  сегмента  для  доступа  к данным в сегменте
        данных USE16.

                                                                               
            E.3.4   Языки программирования
       ----------------------------------------------------------------

             Как уже ясно,  вспомогательный  сегмент  выполняет  задачи
        очень низкого уровня по управлению переключений  между  стеками
        USE16 и USE32, и между кодом USE16 и  USE32.  По  это  причине,
        трудно использовать высокоуровневый  язык,  такой  как  C,  для
        написания вспомогательного  кодового  сегмента.  Даже  если  вы
        написали вспомогательный сегмент на C, вы должны добавить часть
        на языке аасемблера для более трудных задач.  В  общем  случае,
        проще и более еффективно писать весь вспомогательный сегмент на
        языке ассемблера.




       Windows 3.0/Ref/7#7                                      = 172 =

                                                                               
       Е.4 Использование 32-ух битовой памяти в прикладных программах
            Windows
       ----------------------------------------------------------------

             Существует три  основных   способа   использования   32-ух
        битовой памяти для прикладных программ Windows. Они приведены в
        порядке возрастания сложности:

             - Использование  32-ух битовых  объектов  данных  в  16-ти
               битовом коде.

             - Использование   32-ух   битового   кода   и   данных   в
               библиотечной подпрограмме.

             - Использование 32-ух битового кода и  данных  в  основной
               программе.

             Следующие  разделы  кратко  обсуждают   каждый   из   этих
        подходов.

                                                                               
            Е.4.1 Использование 32-ух битовых объектов данных
       ----------------------------------------------------------------

             Простейший случай использования 32-х  битовой  памяти  это
        сохранение   данных,   которые   используются   только  кодовым
        сегментом USE16.  В этом случае,  прикладная программа содержит
        кодовый   сегмент   не   USE32  и,  таким  образом,  не  требут
        промежуточного вспомогательного сегмента.  Вместо этого,  любые
        (или  все)  ее кодовые сегменты выполняют необходимые задачи по
        размещению, переразмещению и освобождению 32-ух битовой памяти.
        Если данные из 32-ух битовой памяти передаются функциям Windows
        или  другим  16-ти  битовым  функциям,  кодовый  сегмент  USE16
        прикладной  программы  так  же  выполняет  переназначение  32-х
        битовых указателей, используя функцию Global16PointerAlloc.

           E.4.2 Использование 32-ух битового кода и данных в библиотечной     
             подпрограмме
       ----------------------------------------------------------------

             Использование 32-ух битовой памяти для кода и данных может
        упростить присоединение  прикладной  программы на 32-ух битовой
        платформе к среде Windows,  когда  часть  прикладной  программы
        может  быть  изолирована  как  библиотечная  подпрограмма.  Эта
        сервисная   библиотечная    подпрограмма    используется    как
        низкоуровневое  средство,  но  не  вызывающее функций Windows и
        DOS.

             Таким образом,  когда 32-ух  битовая  память  используется
        только   для   хранения,   кодовый   сегмент  USE16  удерживает
        управление программой.  Обычно, кодовый сегмент USE16 размещает
        32-ух битовую память, создавая один или более объектов для кода

       Windows 3.0/Ref/7#7                                      = 173 =

        и данных. В добавление к задачам управления данными, описанными
        в  предыдущем  разделе,  сегмент  USE16  так  же  загружает код
        подпрограммы в  один  из  32-ух  битовых  сегментов,  фиксирует
        требуемые   указатели   на   код,   и  создает  кодо-сегментное
        переназначение,  чтобы сделать код выполняемым. Кодовый сегмент
        USE16  -  это  тип сегментов,  управляющих процессом выполнения
        программы,  использующий  кодовый  сегмент  USE32,  когда   ему
        требуется сервис низкоуровневой библиотечной подпрограммы.

              E.4.3 Использование 32-ух битового кода и данных в основной      
               программе
       ----------------------------------------------------------------

             Наиболее сложно   использовать   32-ух   битовую   память,
        включающую в  себя  первичное  управление  программой  в  32-ух
        битовом  кодовом  сегменте.  В  этом  типе  прикладных программ
        сегмент USE16 уменьшен до размеров  вспомогательного  кода.  Во
        время инициализации,  сегмент  USE16  размещает  32-ух  битовую
        память для кода и данных,загружает код в сегмент USE32, создает
        кодо-сегментный псевдоним для сегмента USE32,  и затем вызывает
        основную точку входа в сегменте USE32.

             В  этой   точке   сегмент   USE32   принимает   управление
        программой, вызывая вспомогательный сегмент USE16 только  когда
        прикладная программа нуждается в  вызове  функций  Windows  или
        DOS. Сегмент USE32 продолжает управлять входом программы до тех
        пор, пока прикладная программа не будет  готова  к  завершению.
        Только затем он вернет управление к  сегменту  USE16,  так  как
        последний может освободить 32-ух  битовую  память  и  выполнить
        сбор "мусора" перед выходом из прикладной программы.




       Windows 3.0/Ref/7#7                                      = 174 =

                                    E.5 Список функций                         
       ----------------------------------------------------------------

             В этом  разделе  описаны  функции библиотеки WINMEM32.DLL.
        Большинство из  этих  функций  возвращают  ноль  для  индикации
        успешного завершения  или  не  нулевое значение кода ошибки для
        индикации сбоя. Ниже описаны эти коды ошибок:

             Величина     Значение
             ────────     ────────

               1          Недопустимая функция.  Текущий режим  Windows
                          не   поддерживает   данную  функцию.  Windows
                          поддерживает  функции  32-ух  битовой  памяти
                          только в расширенном 386 режиме.

               2          Недопустимый флаг.  Параметр  wFlags содержит
                          недопустимую установку битов. Параметр wFlags
                          в настоящее время не  используется  и  должен
                          быть установлен в ноль.

               3          Недопустимый параметр.  Один  из   параметров
                          недопустим.  Например, параметр размера вышел
                          за границы.

               4          Селектор  не  предоставлен в распоряжение. Не
                          хватает пространства в  таблице  дескрипторов
                          для   размещения  требуемых  селекторов.  Это
                          может быть   причиной,   для    того    чтобы
                          посоветовать   пользователю   закрыть  другую
                          прикладную программу Windows.

               5          Недостаточно памяти.  Не хватает  памяти  для
                          удовлетворения   требуемого   размещения  или
                          настройки.

        ───────────────────────────────────────────────────────────────
                                                                               
            GetWinMem32Version                                   [3.0]

             Синтаксис    WORD GetWinMem32Version( )

             Эта функция возвращает версию API, представляемую DLL. Это
        не номер версии самой DLL.

             Эта функция не имеет параметров.

             Возвращаемая величина:

             Возвращаемая величина определяется версией  32-ух  битовой
        памяти API,  представленной библиотекой WINMEM32.DLL. Старшие 8
        бит содержат главный номер версии,  и младшие  8  бит  содержат
        вспомогательный  номер  версии.  Данный  номер версии API - это
        1.00 (100h): главный номер -1, и вспомогательный номер - 0.
        ───────────────────────────────────────────────────────────────

       Windows 3.0/Ref/7#7                                      = 175 =

                Global16PointerAlloc                                 [3.0]     

             Синтаксис    WORD Global16PointerAlloc(wSelecotor,
                                       dwOffset,lpBuffer,dwSize,wFlags)

             Эта функция  преобразует 16:32 указатель в 16:16 указатель
        псевдонима, который  прикладная  программа  может  передать   в
        функцию Windows или другим 16:16 функциям.

             Параметр     Тип/Описание
             ────────     ────────────

             wSelector    WORD Определяет селектор объекта для которого
                          должен быть создан псевдоним. Это должен быть
                          селектор,  возвращаемый  предыдущим   вызовом
                          функции Global32Alloc.

             dwOffset     DWORD Определяет   смещение   первого   байта
                          каждого   псевдонима,   который  должен  быть
                          создан.  Смещение от первого байта до объекта
                          определяется параметром wSelector.  Заметьте,
                          что wSelector:dwOffset формирует 16:32  адрес
                          первого байта области для которой должен быть
                          создан псевдоним.

             lpBuffer     LPDWORD  Указывает на 4-ех байтовую   область
                          памяти,   которая  получает  16:16  указатель
                          псевдонима для определенной области.

             dwSize       DWORD Определяет в байтах возможно адресуемый
                          размер области,  для  которой   должен   быть
                          создан псевдоним.  Это значение должно быть в
                          диапазоне от 1 до 10000h.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.


             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

             Комментарий:

             Когда эта функция  заканчивается  успешно,  часть  памяти,
        указанная  параметром  lpBuffer  содержит  16:16  указатель  на
        первый байт  области.  Это  тот  же  самый  байт,  на   который
        указывает wSelector:dwOffset.


       Windows 3.0/Ref/7#7                                      = 176 =

             Возвращаемый селектор  - это    изменяемый,    раширяемый,
        маленький ( бит B очищен  )  дескриптор  данных.  В  дискретной
        системе   существуют   дескриптор   DPL   и  установка  степени
        детализации ( бит G ),  и таким образом прикладная программа не
        должна  принимать  на  себя  их  установку.  Дескриптор  DPL  и
        селектор RPL подходят для прикладных программ Windows.

             Замечание:

             Прикладная программа  не  должна  изменять установку любых
        полей в дескрипторе селектора RPL.  Не соблюдение  этого  может
        привести   к  разрушению  системы  и  будет  мешать  прикладной
        программе выполнятся на совместимых системах.

             Вследствии того,    что    схемы    управления     окнами,
        представленные  некоторыми системами,  не требуют,  чтобы часть
        смещения возвращаемого указателя 16:16 была ноль.

             Прикладная программа не должна брать на  себя  ограничения
        размеров возвращаемого   селектора.   Взамен  этого  прикладная
        программа должна позаботиться о  том,  чтобы  по  крайней  мере
        dwSize байт  могло  быть адресовано начиная от 16:16 указателя,
        созданного этой функцией.

        ───────────────────────────────────────────────────────────────
                Global16PointerFree                                  [3.0]     

             Синтаксис    WORD Global16PointerFree(wSelector,dwAlias,
                                                                wFlags)

             Эта функция  освобождает   16:16   указатель   псевдонима,
        предварительно созданного вызовом функции Global16PointerAlloc.

             Параметр     Тип/Описание
             ────────     ────────────

             wSelector    WORD Определяет селектор объекта для которого
                          должен быть освобожден псевдоним.  Это должен
                          быть   селектор,   возвращаемый    предыдущим
                          вызовом функции Global32Alloc.

             dwAlias      DWORD Определяет 16:16  указатель псевдонима,
                          который должен быть  освобожден.  Это  должен
                          быть    псевдоним    (   включающий   обычное
                          смещение),  возвращаемый  предыдущим  вызовом
                          функции Global16PointerAlloc.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.


             Возвращаемая величина:


       Windows 3.0/Ref/7#7                                      = 177 =

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

             Комментарий:

             Прикладная программа  должна  освободить  16:16  указатель
        псевдонима сразу,  как только он более не нужен.  Освобожденный
        псевдоним  освобождает  пространство  в  таблице  дескрипторов,
        ограниченном системном ресурсе.

        ───────────────────────────────────────────────────────────────
                Global32Alloc                                        [3.0]     

             Синтаксис    WORD Global32Alloc(dwSize,lpSelector,
                                                      dwMaxSize,wFlags)

             Эта функция размещает блок  памяти,  который  должен  быть
        использован как  кодовый  сегмент  или  сегмент  данных USE32 и
        получает часть селектора 16:32 адреса блока памяти. Первый байт
        объекта - это смещение 0 от начала селектора.

             Параметр     Тип/Описание
             ────────     ────────────

             dwSize       DWORD   Определяет  в  байтах  размер  блока,
                          который должен быть  размещен.  Это  значение
                          должно  быть в диапазоне от 1 до 400 000h( 64
                          Мбайт).

             lpSelector   LPDWORD  Указывает на 2-ух  байтовую  область
                          памяти, которая   получает   часть  селектора
                          16:32 адреса размещенного объекта.

             dwMaxSize    DWORD Определяет    в   байтах   максимальный
                          размер, которого   достигнет  объект  при  его
                          перераспределении  в  памяти,  под  действием
                          функции Global32Realloc.  Это значение должно
                          быть в диапазоне от 1 до 400 000h( 64 Мбайт).
                          Если  прикладная  программа  никогда не будет
                          перемещать  этот  блок  памяти,  то  параметр
                          dwMaxSize  должен  быть  установлен  в  то же
                          значение, что и параметр wSize.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.


             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

       Windows 3.0/Ref/7#7                                      = 178 =


             Комментарий:

             Если функция  Global32Alloc  завершена   с   ошибкой,   то
        величина на  которую  указывает параметр lpSelector равна нулю.
        Если функция завершена  успешно,  то  lpSelector  указывает  на
        селектор объекта.  Допустимый  диапазон  смещений  для объекта,
        указанного этим селектором находится в диапазоне от нуля до (но
        не включая) dwSize.

             Возвращаемый селектор  - это    изменяемый,    раширяемый,
        маленький ( бит B очищен  )  дескриптор  данных.  В  дискретной
        системе   существуют   дескриптор   DPL   и  установка  степени
        детализации ( бит G ),  и таким образом прикладная программа не
        должна принимать   на   себя  их  установку.  Так  как  система
        устанавливает степень детализации,  реальный размер объекта(  и
        ограничение размера селектора) может быть больше, чем требуемый
        размер на величину от 1 байта до 4K.  Дескриптор DPL и селектор
        RPL подходят для прикладных программ Windows.

             Замечание:

             Прикладная программа  не  должна  изменять установку любых
        полей в дескрипторе селектора RPL.  Не соблюдение  этого  может
        привести   к  разрушению  системы  и  будет  мешать  прикладной
        программе выполнятся на совместимых системах.

             Размещенные объекты не могут  быть  ни  перемещаемыми,  ни
        сбрасываемыми, но могут быть странично организованными. Так как
        страница блокирует объект,  то это полезно если объект содержит
        код или данные, которые используются во время прерывания, и так
        как 32-ух  битовая  память  не может быть использована во время
        прерывания,   прикладная   программа   не   должна    странично
        блокировать объект 32-ух битовой памяти.

        ───────────────────────────────────────────────────────────────
                Global32CodeAlias                                    [3.0]     

             Синтаксис    WORD Global32CodeAlias(wSelector,lpAlias,
                                                                wFlags)

             Эта функция создает 16:32(USE32) код псевдонима  селектора
        для объекта  32-ух  битовой  памяти,  предварительно созданного
        функцией Global32Alloc.  Это   позволяет  прикладной  программе
        исполнять код, содержащийся в объекте памяти.

             Параметр     Тип/Описание
             ────────     ────────────

             wSelector    WORD Определяет селектор объекта для которого
                          должен быть создан псевдоним. Это должен быть
                          селектор,  возвращаемый  предыдущим   вызовом
                          функции Global32Alloc.

       Windows 3.0/Ref/7#7                                      = 179 =


             lpAlias      LPWORD Указывает  на  2-ух байтовую   область
                          памяти,   которая  получает  16:32  псевдоним
                          селектора кодового сегмента для определенного
                          объекта.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.


             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

             Комментарий:

             Если функция завершена с ошибкой,  то величина на  которую
        указывает  параметр lpAlias равна нулю.  Если функция завершена
        успешно, то  lpAlias  указывает  на псевдоним кодового сегмента
        USE32 для объекта определенного  параметром  wSelector.  Первый
        байт объекта - это смещение 0 от начала сегмента, возвращаемого
        lpAlias. Допустимые смещения, определяемые размером объекта как
        набор   наиболее   новых   вызовов  функций  Global32Alloc  или
        Global32Realloc.

             Возвращаемый селектор     -    это    читаемо/выполняемый,
        неизменяемый,  USE32( бит D установлен) кодовый  дескриптор.  В
        дискретной   системе  существуют  дескриптор  DPL  и  установка
        степени детализации ( бит  G  ),  и  таким  образом  прикладная
        программа  не  должна  принимать на себя их установку.  Степень
        детализации будет согласованна с текущим селектором данных  для
        объекта. Дескриптор DPL и селектор RPL подходят для  прикладных
        программ Windows.

             Замечание:

             Прикладная программа  не  должна  изменять установку любых
        полей в дескрипторе селектора RPL.  Не соблюдение  этого  может
        привести   к  разрушению  системы  и  будет  мешать  прикладной
        программе выполнятся на совместимых системах.

             Прикладная программа   не   должна  вызывать  эту  функцию
        больше,  чем один раз для объекта.  В зависимости  от  системы,
        функция   может   давать   ошибку,  если  прикладная  программа
        вызываает   ее   второй   раз   для   данного   объекта,    без
        первоначального   вызова   функции   Global32CodeAliasFree для
        объекта.

        ───────────────────────────────────────────────────────────────
                Global32CodeAliasFree                                [3.0]     

             Синтаксис    WORD  Global32CodeAliasFree(wSelector,wAlias
                                                                wFlags)

       Windows 3.0/Ref/7#7                                      = 180 =


             Эта функция   освобождает   псевдоним  кодового  селектора
        USE32,     предварительно     созданный     вызовом     функции
        Global32CodeAlias.

             Параметр     Тип/Описание
             ────────     ────────────

             wSelector    WORD Определяет селектор объекта для которого
                          должен быть освобожден псевдоним.  Это должен
                          быть    селектор,   возвращаемый   предыдущим
                          вызовом функции Global32Alloc.

             wAlias       WORD Определяет псевдоним  кодового  сегмента
                          USE32, который должен  быть  освобожден.  Это
                          должен     быть    псевдоним,    возвращаемый
                          предыдущим вызовом функции Global32Alloc.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.

             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

        ───────────────────────────────────────────────────────────────
                Global32Free                                         [3.0]     

             Синтаксис    WORD Global32Free(wSelector,wFlags)

             Эта функция освобождает объект, предварительно размещенный
        функцией Global32Alloc.

             Параметр     Тип/Описание
             ────────     ────────────

             wSelector    WORD   Определяет  селектор  объекта, который
                          должен быть   освобожден.   Это  должен  быть
                          селектор,  возвращаемый  предыдущим   вызовом
                          Global32Alloc.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.

             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

       Windows 3.0/Ref/7#7                                      = 181 =


             Комментарий:

             Эта функция   освобождает   сам   объект,  также  как  все
        псевдонимы, созданные для объекта с помощью API  32-ух  битовой
        памяти.

             Замечание:

             Перед прекращением   работы  прикладная  программа  должна
        вызвать эту   функцию   для   освобождения   каждого   объекта,
        размещенного функцией  Global32Alloc  для  гарантирования того,
        что все псевдонимы, созданные для объекта освобождены.

        ───────────────────────────────────────────────────────────────
                Global32Realloc                                      [3.0]     

             Синтаксис WORD Global32Realloc(wSelector,dwNewSize,wFlags)

             Эта функция изменяет размер объекта 32-ух битовой  памяти,
        предварительно размещенный функцией Global32Alloc.

             Параметр     Тип/Описание
             ────────     ────────────

             wASelector   WORD  Определяет   селектор  объекта, который
                          должен быть   изменен.   Это   должен    быть
                          селектор,   возвращаемый  предыдущим  вызовом
                          Global32Alloc.

             dwNewSize    DWORD   Определяет   в   байтах  новый размер
                          объекта. Это   значение  должно  быть  больше
                          нуля,   и   меньше    или    равно    размеру
                          определенному  параметром  dwMaxSize  функции
                          Global32Alloc,  вызов  которой  создал   этот
                          объект.

             wFlags       WORD   Зарезервировано    и    должно    быть
                          установлено в ноль.

             Возвращаемая величина:

             Возвращаемая величина  равна  нулю,  если   функция   была
        завершена успешно. В противном случае это один из кодов ошибки,
        описанных в начале этого раздела.

             Комментарий:

             Если функция завершена с ошибкой,  то предыдущее состояние
        объекта не  изменяется.  Если  функция  завершена  успешно,  то
        изменяется состояние объекта и состояние всех  псевдонимов  для
        объекта, созданного API 32-ух битовой памяти.  По этой причине,
        прикладная   программа   должна  вызывать  Global32Realloc  для

       Windows 3.0/Ref/7#7                                      = 182 =

        изменения  размеров  объекта.  Использование   других   функций
        Windows  для  манипулирования  объектами приведет к повреждению
        псевдонимов.

             Эта функция не изменяет селектор,  определенный параметром
        wSelector. Если эта функция завершена успешно, новый допустимый
        диапазон смещений  для  селектора есть от 0 до ( но не включая)
        wdNewSize.

             Система определяет    подходящую    степень    детализации
        объектов. В результате реальный размер объекта ( и ограничения
        размера селектора) может быть больше,  чем требуемый размер  на
        величину от 1 байта до 4K.

        ───────────────────────────────────────────────────────────────



       Windows 3.0/Ref/7#7                                      = 183 =

                        ПРИМЕР. ПРОСТАЯ программа для WINMEM32 DLL             
       ----------------------------------------------------------------

        ;--------------------------------------------------------------
        ;
        ; ПРОСТАЯ программа для WINMEM32 DLL
        ;
        ;--------------------------------------------------------------
        .386p

        memS    equ       1

                .xlist

                include   cmacros.inc

        ;
        ; ЗАМЕТИМ,   что  мы  НЕ  МОЖЕМ  использовать  обычные  CMACROS
        ; C-макроопределения сегмента:
        ;
        ;       CreateSeg
        ;       sBegin
        ;       sEnd
        ;
        ; так как  мы  находимся  в  .386p  тип  сегмента  USE32.  Наши
        ; сегменты  должны  быть  USE16  так,  что  мы  объявляем  наши
        ; сегменты как обычно, и включаем атрибуты сегмента USE 16.
        ;
                include   windows.inc

                .list

        ;
        ; Эти  присвоения  должны  быть в определенном включаемом файле
        ; прикладной программы
        ;
        error_bad_file   EQU    08001h
        error_wrong_mode EQU    08002h

        ;--------------------------------------------------------------
        ;
        ; Внешние процедуры WINMEM32
        ;
        externFP          GetWinMem32Version
        externFP          Global32Alloc
        externFP          Global32Realloc
        externFP          Global32Free
        externFP          Global16PointerAlloc
        externFP          Global16PointerFree
        externFP          Global32CodeAlias
        externFP          Global32CodeAliasFree

        ;--------------------------------------------------------------

       Windows 3.0/Ref/7#7                                      = 184 =

        ;
        ; Внешние процедуры Windows
        ;
        externFP          OpenFile
        externFP          GetWinFlag
        externFP          _llseek
        externFP          _lread
        externFP          _lclose
        externFP          OemToAnsi

        ;
        ; ОПИСАНИЕ ВЕРСИИ: createseg _HELPERCODE,hcode,word,public,CODE
        ;
        ; ЗАМЕТИМ, что этот сегмент должен быть НЕСБРАСЫВАЕМ, он должен
        ; быть фиксирован.  Это потому,  что сегмент вызывается из кода
        ; USE32
        ;
        _HELPERCODE       segment word public 'CODE' use16
        _HELPERCODE       ends


        ;
        ; ОПИСАНИЕ ВЕРСИИ объявления автоматического сегмента данных
        ;
        _DATA segment word public 'DATA' use16
        _DATA ends

        _DATA segment use16

        globalD           AddrOEMtoANSI,0        ;Адрес вспомогательной
                                                 ; функции OEMtoANSI
        globalD           AddrDOSGetFreeSpase,0  ;Адрес вспомогательной
                                                 ; функции DOS Get disk
                                                 ; Free spase
        globalD           U32RetVal,0            ;Код   возврата     из
                                                 ; вызова USE32

        globalD           U32StackAlias,0        ;Псевдоним для стека

        globalD           EntryStackSave,0       ;сохранение  указателя
                                                 ; стека

        ;
        ; Это FWORD формирует точку входа для кода USE32
        ;
        U32EntryPt        LABEL FWORD
        globalD           U32EntOff,0001 000h    ; Вход проедпологается
                                                 ; по смещению 64K

        globalW           U32CodeSel,0           ; Псевдоним  CODE  для
                                                 ; объекта BIG

        globalW           U32DataSel,0           ; Селектор   DATA  для

       Windows 3.0/Ref/7#7                                      = 185 =

                                                 ; объекта BIG
        _DATA ends

        _HELPERCODE segment use16
               assume cs:_HELPERCODE

        ;**************************************************************
        ;
        ; SetupCallUSE32
        ;
        ;      SetupCallUSE32(fName)
        ;
        ;      Установка и вызов в коде USE32
        ;
        ; ПРИСВОЕНИЯ:
        ;    Образ USE32 - это 32 - битовый образ, НЕ имеющий ЗАГОЛОВКА
        ;    с началом(ORGed) в 0.
        ;    Первые 64K     образа     (смещение     00000000-0000FFFH)
        ;       зарезервированы для стека.  Мы помещаем стек здесь, так
        ;       как требуемый стек переключающий (USE32 <->  USE16)  то
        ;       же самое, что и изменение SS.
        ;
        ;    Предпологается, что  точка  входа  кода  USE32 будет сразу
        ;       после стека, по смещению 0000100H в образе. Мы входим с
        ;       DS,  FS, GS и SS, установленных на сегмент данных FLAT,
        ;       и CS  установленном  на  плоский  сегмент  данных.  Это
        ;       гарантирует,  что  точка  входа  USE32 установлена ES и
        ;       ЗАЩИЩАЕТ ЕЕ ОТ НАС.
        ;
        ;    Когда эта программа пожелает  вызвать  две  обеспечиваемые
        ;       USE32 вспомогательные функции,  она посмотрит на адреса
        ;       вызовов     в      переменных      AddrOEMtoANSI      и
        ;       AddrDOSGetFreeSpace  сегменте  _DATA.  Этот "загрузчик"
        ;       кода реально нужен для передачи селектора для  сегмента
        ;        _DATA коду USE32, так как доступ к сегменту данных, или
        ;       для копирования адресов вызова в  сегменте  кода/данных
        ;       USE32.   Эта   деталь  реализации  НЕ  включена  в  эту
        ;       программу.
        ;
        ; ВХОД:
        ;
        ;       FName - указатель DWORD на имя файла образа  USE32  для
        ;                                                      загрузки
        ;
        ; ВЫХОД:
        ;
        ;    AX != 0  Если имела место ошибка
        ;      AX = код ошибки
        ;    Иначе
        ;      AX = 0 и USE32 содержит код возврата из программы USE32.
        ;
        ; ИСПОЛЬЗУЕТ:
        ;

       Windows 3.0/Ref/7#7                                      = 186 =

        ;     Стандартный C
        ;
        ;**************************************************************

        cProc    StartupCallUSE32,<FAR,PUBLIC>,<si,di>

                 ParmD   fName

                 LocalD fSize                    ; Размер файла
                 LocalD U16rdAlias               ; Псевдоним для чтения
                                                 ;  образа

                 LocalD FileOff                  ; Текущее     смещение
                                                 ;  файла для чтения

                 LocalW fHand                    ; Дескриптор файла
                 LocalV OpnBuf,<SIZE OPENSTRUC>  ; Открытая   структура
                                                 ;  файла   для  вызова
                                                 ;  открытия файла


        cBegin
             assume  ds:_DATA
             assume  es:nothing
             assume  ss:_DATA
             ;
             ; Первая проверка, если мы запустили в расширенном режиме
             ;
             ; ЗАМЕТЬТЕ, ПОСКОЛЬКУ МЫ НЕ ЗНАЕМ В КАКОМ РЕЖИМЕ МЫ
             ; НАХОДИМСЯ, ТО    МЫ   ДОЛЖНЫ   ИСКЛЮЧИТЬ   ИСПОЛЬЗОВАНИЕ
             ; СПЕЦИАЛЬНЫХ КОМАНД 386 ПРОЦЕССОРА
             ;

                cCall    GetWinFlags

                and      ax,WF_PMODE + WF_ENHANCED
                cmp      ax,WF_PMODE + WF_ENHANCED
                je       short OKtoLoad          ; ДОЛЖНО БЫТЬ КОРОТКИМ
                mov      ax,error_wrong_mode
                jmp      Donel

             ;
             ; Теперь мы знаем надлежащий режим  и  можем  использовать
             ; команды 386 процессора.
             ;
        OKtoLoad:
             ;
             ; Установка    адресов   для   кода   USE32   для   вызова
             ; вспомогательных функций
             ;
            mov ax,cs
            mov word ptr [AddrOEMToANSI+2],ax
            mov word ptr [AddrOEMToANSI],offset_HELPERCODE:U32OEMtoANSI

       Windows 3.0/Ref/7#7                                      = 187 =

            mov word ptr [AddrDOSGetFreeSpace+2],ax
            mov word ptr [AddrDOSGetFreeSpace],offset
                                               _HELPERCODE:U32GetDskFree

             ;
             ; Открытие файла
             ;
             lea     bx,OpnBuf
             regptr  ssbx,ss,bx
             cCall   OpenFile,<fName,ssbx,OF_READ>
             cmp     ax,-1                         ; Найден ли файл?
             je      DonelFlErr                    ; Нет, ошибка файла
             mov     fHand,ax                      ; Сохранение
                                                     дескриптора файла
             ;
             ; Получить размер файла
             ;
             cCall   _llseek,<fHand,0,0,2>
             shl     edx,16
             mov     dx,ax
             inc     edx
             jz      DonelFlErr                    ; Неудачный поиск,
                                                   ; ошибка файла
             dec     edx
             mov     fSize,edx
             cmp     edx,10000h          ; Образ по крайней мере 64K?
             jbe     DonelFlErr          ; Нет, размер слишком мал,
                                         ; ошибка файла
             ;
             ; Перемещение указателя файла на начало файла, для чтения
             ;
             cCall   _llseek,<fHand,0,0,0>
             ;
             ; Размещение большого объекта USE32
             ;
             mov     si,dataOffset U32DataSel
             regptr  Selpt,di,si
             cCall   Global32Alloc,<fSize,Selpt,fSize,0>
             or      ax,bx               ; Работает?
             jnz     FcloserEr           ; Нет, возврат кода ошибки
                                         ; WINMEM32

             ;
             ; Размещение псевдонима стека кода  USE16  для  первых
             ; 64K объекта
             ;
             mov     si,dataOffset U16StackAlias
             regptr  Alipt,di,si
             mov     ecx,00010000h
             cCall   Global16PoinerAlloc,<[U32DataSel],0,0,Alipt,ecx,0>
             or      ax,bx               ; Работает?
             jnz     AliasErrF2          ; Нет, возврат кода ошибки
                                         ; WINMEM32

       Windows 3.0/Ref/7#7                                      = 188 =


             ;
             ; Размещение псевдонима кода USE32
             ;
             mov     si,dataOffset U32CodeSel
             regptr  Alipt,di,si
             cCall   Global32CodeAlias,<[U32DataSel],Alipt,0>
             or      ax,bx               ; Работает?
             jnz     AliasErr2           ; Нет, возврат кода ошибки
                                         ; WINMEM32
             ;
             ; Теперь читаем в образ. Мы будем делать это 32K частями
             ;
             mov     FileOff,0           ; Начальное смещение файла 0
        ReadLp:
             mov     ecx,00008000h       ; 32K
             cmp     ecx,Fsize
             jbe     short Read32K
             mov     ecx,fSize
        Read32K:
             ;
             ; Создание псевдонима USE32 для этой области объекта
             ;
             push    ecx
             lea     si,U16RAlias
             regptr  Alipt,ss,si
          cCall Global16PointerAlloc,<[U32DataSel],FileOff,Alipt,ecx,0>
             pop     ecx
             or      ax,ax
             jnz     short AliasErrF1
             push    ecx
             cCall   _lread,<fHand,U16Alias,cx>
             push    ax
             cCall   Global16PointerFree,<[U32DataSel],U16RdAlias,0>
             pop     ax
             pop     ecx
             inc     ax
             jz      short F1RdErr
             dec     ax
             cmp     ax,cx
             jne     short F1RdErr
             add     FileOff,ecx
             sub     fSize,ecx
             ja      short ReadLp
             ;
             ; Сейчас мы готовы к установке и вызову в коде USE32
             ;
             ; Сохраняем текущий стек для того,  чтобы переключиться на
             ; стек USE32
             ;
             ; ЗАМЕЧАНИЕ БУДЬТЕ ОСТОРОЖНЫ,  ТАК  КАК  ЭТО  СДЕЛАЕТ  ЭТУ
             ; ПОДПРОГРАММУ  НЕ РЕЕНТЕРАБЕЛЬНОЙ,  ТАК КАК ОНА СОХРАНЯЕТ
             ; ТЕКУЩИЙ SS:SP В СТАТИЧЕСКОЙ ЯЧЕЙКЕ ПАМЯТИ

       Windows 3.0/Ref/7#7                                      = 189 =

             ;
             mov     word ptr [EntryStackSave],sp
             mov     word ptr [EntryStackSave+2],ss
             mov     ax,[U32DataSel]
             push    ds
             pop     es
        assume  es:_DATA
             ;
             ; Установка всех сегментов и вызовов в USE32
             ;
             ; ЗАМЕТИМ,   что   мы  оставляем  файл  открытым  на  всем
             ; протяжении вызова
             ;
             mov     ds,ax
        assume  ds:nothing
             mov     fs,ax
             mov     gs,ax
             mov     ss,ax
        assume  ss:nothing
             mov     esp,0000FFFCh
             call    [U32EntryPt]
             ;
             ; Устанавливаем DS и стек
             ;
             mov     bx,es
             mov     ds,bx
        assume  ds:_DATA
             mov     ss,word ptr [EntryStackSave+2]
        assume  ss:_DATA
             mov     ss,word ptr [EntryStackSave]
             ;
             ; Очистка и возврат кода успешного завершения
             ;
             mov     [U32RetVal],eax
             xor     ax,ax               ; Возврат кода успеха
             jmp     short AliasErrF1

        F1RdErr:
             mov     ax,error_bad_file
        AliasErrF1:
             ;
             ; Освобождение псевдонима кода USE32
             ;
             push    ax                  ; Сохранение кода ошибки
             cCall  Global32CodeAliasFree,<[U32DataSel],[U32CodeSel],0>
             pop     ax
        AliasErrF2:
             ;
             ; Освобождение псевдонима стека USE16
             ;
             push    ax                  ; Сохранение кода ошибки
             cCall  Global16PointerFree,<[U32DataSel],[U16StackAlias],0>
             pop     ax

       Windows 3.0/Ref/7#7                                      = 190 =

        AliasErrF3:
             ;
             ; Освобождение объекта
             ;
             push    ax                  ; Сохранение кода ошибки
             cCall  Global32Free,<[U32DataSel],0>
             pop     ax
        FcloseEr:
             ;
             ;  Закрытие файла
             ;
             push    ax                  ; Сохранение кода ошибки
             cCall   _lclose,<fHand>
             pop     ax
             jmp     short Donel

        DonelF1Err:
             mov     ax,error_bad_file
        Donel:
        cEnd


        ;**************************************************************
        ;
        ; U32OEMtoANSI - Вызов OemToANSI из сегмента USE32
        ;
        ;    Предпологаются соглашения по вызову паскаль
        ;
        ; ВХОД:
        ;    U32OENToANSI(lpOemStr,lpAnsiStr)
        ;
        ;    ЗАМЕТИМ, что  этот  аргументы казателя НЕ реальные LPSTRs.
        ;    Они являются ближними указателями в объекте данных USE32 (
        ;    используемый сегмент это U32DataSel)
        ;
        ; ВЫХОД:
        ;    EAX - код возврата
        ;
        ; ИСПОЛЬЗУЕТ:
        ;    32 - биттовый стандарт C
        ;
        ;**************************************************************
        PUBLIC  U32OEWMtoAnsi
        U32OEMtoANSI proc far
        assume  ds:nothing
        assume  es:nothing
        assume  ss:nothing
             ;
             ; Первое переключение стека USE16
             ;
             mov cx,ds                   ;  Сохранение входа DS в cx
                                         ;  пока мы      не     получим
                                         ;  переключения стека

       Windows 3.0/Ref/7#7                                      = 191 =

             mov  ax,SEG _DATA
             mov  ds,ax
        assume  ds:_DATA
             mov  ss,word ptr [U16StackAlias+2]
             push ecx
             pusn ebp
             mov  bp,sp
             ;
             ; Фрейм сейчас выглядит таким образом:
             ;
             ; dword ptr [bp+20]  -->   Первый  аргумент для OEMtoAnsi
        lpOemStr (реально 32 - битовый ближний указатель)
             ; dword ptr [bp+16]  -->   Второй  аргумент  для  OEMtoAnsi
        lpAnsiStr (реально 32 - битовый ближний указатель)
             ; dword ptr [bp+12] -->    Возврат CS
             ; dword ptr [bp+8] -->     ВозвратEIP
             ; dword ptr [bp+4] --> Вход DS положенный в стек как DWORD
             ; dword ptr [bp+0] --> Вход EBP
             ;
             lpOemStr    equ      dword ptr [bp+20]
             lpAnsiStr   equ      dword ptr [bp+16]

             sub sp,8          ; Необходимы 2 LPSTRs для псевдонима

             AlsOemStr   equ      dword ptr [bp-4] ; Псевдоним для
                                                   ; lpOemStr
             AlsAnsiStr  equ      dword ptr [bp-8] ; Псевдоним для
                                                   ; lpAnsiStr

             push  esi
             push  edi
             push  ebx
             push  es          ; Предохраняем  ES,FS,GS
             push  fs
             push  gc
             ;
             ; Это  a?,  какого  размера lpOemStr?  Нужно знать это для
             ; установки  размера  псевдонима(ов).   Мы   устанавливаем
             ; размер  64K(  или  размер  до  конца  объекта  USE32,  в
             ; зависимости  от  того,  что   меньше).   ЗАМЕТЬТЕ,   это
             ; предпологает,  что  строка  меньше  или  равна 64K,  что
             ; является  разумным  допущением  так  как  мы  не   можем
             ; выделить любым путем ничего большего размера.
             ;
             lsl eax,dword  ptr  [U32DataSel]  ;  Получаем  ограничение
                                               ;  объекта USE32
             inc eax                           ;  Ограничение -> размер
             mov edx,eax
             sub eax,lpOemStr  ; Количество байт до конца объекта USE32
             jc  SkipCall      ; Плохой строковый указатель
             sub eax,lpAnsiStr ; Количество байт до конца объекта USE32
             jc  short SkipCall; Плохой строковый указатель
             cmp eax,eax

       Windows 3.0/Ref/7#7                                      = 192 =

             jbe short UseSrcLim
             mov eax,edx       ;
        UseSrcLim:
             mov ecx,00010000h ; 64K
             cmp ecx,eax
             jbe short Use64k
             mov ecx,eax       ; Ограничение размера до конца объекта
        Use64k:
             ;
             ; Создание псевдонима для lpOemStr
             ;
             push ecx
             lea  bx,AlsOemStr
             regptr AlsPt,ss,bx

        cCall  Global16PointerAlloc,<[U32DataSel],lpOemStr,AlsPt,ecx,0>

             pop  ecx
             or   ax.ax
             jnz  short SkipCall

             ;
             ; Создание псевдонима для lpOemStr
             ;

             lea  bx,AlsOemStr

        cCall  Global16PointerAlloc,<[U32DataSel],lpAnsiStr,AlsPt,ecx,0>

             or   ax.ax
             jnz  short freeOemAls
             ;
             ;  Вызов OemToAnsi
             ;

             cCall  OemToAnsi,<AlsOemStr,AlsAnsiStr>

             ;
             ; Освобождение псевдонимов
             ;
             push ax           ; Сохранение RET кода

             cCall  Global16PointerFree,<[U32DataSel],AlsAnsiStr,0>

             pop  ax           ; Восстановление RET кода
        FreeOemAls:
             push ax           ; Сохранение RET кода

             cCall  Global16PointerFree,<[U32DataSel],AlsOemStr,0>

             pop  ax           ; Восстановление RET кода

        SkipCall:

       Windows 3.0/Ref/7#7                                      = 193 =

             pop gs
             pop fs
             pop es
             pop ebx
             pop edi
             pop esi
             add sp,8
             pop ebp
             pop ecx           ; Вход DS в CX
             ;
             ; Возвращаемому значению расширяется знак,  что делает его
             ; 32 -битовым
             ;
             movsx  eax,ax
             ;
             ; Переключение  обратно  в  стек  USE32 УБЕДИТЕСЬ,  ЧТО ВЫ
             ; УСТАНОВИЛИ СТАРШИЕ 16 БИТ ESP.
             ;
             mov    ss,[U32DataSel]
             movzx  esp,sp
             mov    ds,cx
        assume ds:nothing
             db    66h ; USE32 override on far ret so it returns to EIP
             ret   (2 * 4)

        U32OEMtoAnsi  endp


        ;**************************************************************
        ;
        ; U32GetDskFree - выдает  вызов  DOS  для  получения свободного
        ;                 дискового пространства
        ;
        ; Предпологаются соглашения по вызову паскаль
        ;
        ; ВХОД:
        ;     U32GetDiskFree(drvnum)
        ;
        ; ВЫХОД:
        ;     EAX = Свободное дисковое пространство в байтах
        ;     EAX == 0FFFFFFFFh в случае ошибки
        ;
        ; ИСПОЛЬЗУЕТ:
        ;     32-ух битовый стандарт C
        ;
        ;
        ;**************************************************************

        PUBLIC U32GetDiskFree

        U32FetDiskFree proc far
             assume ds:hothing
             assume es:hothing

       Windows 3.0/Ref/7#7                                      = 194 =

             assume ss:hothing
             ;
             ; Первое переключение стека USE16
             ;

             mov cx,ds                   ;  Сохранение входа DS в cx
                                         ;  пока мы      не     получим
                                         ;  переключения стека
             mov  ax,SEG _DATA
             mov  ds,ax
        assume  ds:_DATA
             mov  ss,word ptr [U16StackAlias+2]
             push ecx          ;  Вход DS, как DWORD для сохранения
                               ;  выравнивания стека
             pusn ebp
             mov  bp,sp
             ;
             ; Фрейм сейчас выглядит таким образом:
             ;
             ; dword ptr [bp+16]  --> Дисковод # ( 0= по умолчанию,
                                      А = 1, .......)
             ; dword ptr [bp+12] -->    Возврат CS
             ; dword ptr [bp+8] -->     ВозвратEIP
             ; dword ptr [bp+4] --> Вход DS положенный в стек как DWORD
             ; dword ptr [bp+0] --> Вход EBP
             ;
        ArgDrv                 equ dword ptr[bp+16]

             push  esi
             push  edi
             push  ebx
             push  es          ; Предохраняем  ES,FS,GS
             push  fs
             push  gc

             mov   edx,ArgDrv  ; # дисковода в DL
             mov   ah,36h
             int   21h         ; Делаем вызов DOS

             movsx eax,ax      ;
             cmp   ax,0FFFFh   ;
             je    short BadDrv          ;
             movzx eax,ax                ;
             movzx ebx,bx                ;
             movzx ecx,cx                ;
             mul   ecx                   ;

             mul   ebx

        BadDrv:
             pop gs
             pop fs
             pop es

       Windows 3.0/Ref/7#7                                      = 195 =

             pop ebx
             pop edi
             pop esi
             pop ebp
             pop ecx           ; Вход DS в CX
             ;
             ; Переключаем  обратно  на  стек  USE32   УБЕДИТЕСЬ,   ЧТО
             ; УСТАНОВЛЕНЫ СТАРШИЕ 16 БИТ ESP
             ;
             mov   ss,[U32DataSel]
             movzx esp,sp
             mov   ds,cx
        assume ds:nothing

             db    66h ; USE32 override on far ret so it returns to EIP
             ret   (2 * 4)

        U32GetDskFree  endp

        _HELPERCODE ends

             end

