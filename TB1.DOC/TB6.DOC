.R: 
.L:72
.N:119
.H:
.H:...-$$$-...
.S:6
.X:10
                Опертатор COLOR (графический тип)
-----------------------------------------------------------------
Назначение  Опертатор COLOR графического  типа устанавливает цвет 
            при выполнении графическитх операций.

Синтаксис   Для SCREEN 1:  COLOR [background] [,[palette]]
                ЭКРАНа     ЦВЕТ  [фоновый]      [набор]

         Для SCREENs 7,8,9,10: COLOR [foreground] [,[background]]
             ЭКРАНов 7,8,9,10  ЦВЕТ  [основной]     [фоновый]

Комментарий    background это целое выражение в диапазоне от 0 до 
                          63,  определяющее цвет фона на  котором 
                          высвечиваются символы и строятся графи-
                          ческие объекты;  

               palette    это целое выражение в диапазоне от 0 до
                          1, которое выбирает один из двух цвето-
                          вых наборов;



               foreground это целое выражение в диапазоне от 1 до 
                          15, которое определяет основной цвет, 
                          т.е. цвет, которым высвечиваются симво-
                          лы и графические объекты. 

                      ..
                        ..
                          ..
                            ..
                              ..
                                ..
                                  ..
                                    ..
                                      ..
                                        ..
                                          ..
                                            ..
                                              ..
                                                ..
                                                  ..
                                                    ..



           -----------------------------------------
            ЦВЕТ      Набор 0        Набор 1
           -----------------------------------------
             1        зеленый      зелено-голубой  
             2        красный      пурпурно-красный
             3        коричневый   белый
           -----------------------------------------

                   ЭКРАН 7 и 8

               Только EGA. Цвета зависят от текущего набора. 
               Основной цвет 1 -15.  Выбранный цвет  используется 
            при написании символов и построении графиков.
               Фонофый цвет 0 -15. Выбирает цвет фона на котором 
            пишутся символы и строятся графики.

                   ЭКРАН 9

               Основной цвет 1 -15.  Выбранный цвет  используется 
            при написании  текста  и построении графиков. Если в
            вашем EGA только 64К памяти для установки цвета поль-
            зуйтесь значениями из диапазона 1- 3.
               Фонофый цвет 0 -63. Выбирает цвет фона на котором 
            пишутся символы и строятся графики.

                   ЭКРАН 10

               Основной  цвет 1 - 3.  Выбранный цвет используется 
            при написании текста и построении графиков.  
               1 = черный,  2 = слабый,  3 = интенсивный.
               Использование 0 для  основного  цвета  приводит  к 
            ошибке  "Illegal  Function Call" ("Неправильный вызов 
            функции").  
               Для изменения атрибутов по умолчанию используйте 
            оператор PALETTE.
               Фонофый цвет 0 -63. Выбирает цвет фона.
               Примечание: 0 является фоновыфм цветом для любого 
            набора цветов, определенного в данном операторе, ос-
            новной цвет по умолчанию устанавливается с максималь-
            ным значением.

Ограничения    В режиме ЭКРАНа 2 оператор COLOR приводит к ошибке 
            выполнения 5 "Illegal Function  Call"  ("Неправильный 
            вызов функции").  

Пример         'Данная  программа  демонстрирует работу оператора 
            COLOR в графическом режиме.

               'Переключить экран в графический режим со средней
            'разрешающей спрособностью и установить цветовой на- 
            'бор 0
                  SCREEN 1
                  COLOR ,0
            FOR Radius% = 1 to 20  'увеличить размер круга
            Color% =  Radius% MOD 4 'вычислить цвет дисплея
            CIRCLE (160,100), Radius%, Color%  'показать на экране
            NEXT Radius%       'круг с центром в точке 250.150

            delay 2
                   COLOR  ,1   'изменить набор цветов

            delay 2

                   'установить набор цветов и фоновый цвет,
                   'очистить экран

                   COLOR 6,1:CLS

                  'построить красный кртуг в середине экрана

            CIRCLE (160,100), 50, 2

            delay 2
                    END

                Опертатор COLOR (текстовый тип)
-----------------------------------------------------------------
Назначение  Опертатор COLOR устанавливает текстовый цвет.

Синтаксис   COLOR [foreground] [,[background] [,[border]]
            ЦВЕТ  [основной]     [фоновый]      [граница]  

Комментарий    foreground  это  целочисленное выражение  от 0 до 
                           31, определяющее цвет символов;

               background  это  целочисленное выражение  от 0 до 
                           7, определяющее цвет фона;

               border      это  целочисленное выражение  от 0 до 
                           15, определяющее цвет на границе ос- 
                           новного и фонового цветов.

               Если какой-либо из названных параметров выйдет за 
            пределы указанных диапазонов произойдет ошибка вы-
            полнения 5 "Illegal Function  Call"  ("Неправильный 
            вызов функции").

               Для стандартных видеодек типа C/G (Цвет/Графика) 
            ваш выбор основных цветов должен быть следующим:

            0 - черный               8 - серый
            1 - синий                9 - голубой
            2 - зеленый             10 - светлозеленый
            3 - зелено-голубой      11 - светлозелено-голубой
            4 - красный             12 - светлокрасный
            5 - пурпурно-красный    13 - светлопурпурно-красный
            6 - коричневый          14 - желтый
            7 - белый               15 - интенсивно белый

               Символы могут мигать на экране, для этого необхо- 
            димо установить параметр основного цвета увеличенным 
            на 16. Например, если установим  foreground = 22, то
            получим мигающие коричневые символы  (22 = 6 + 16).

               В случае монохромных адаптеров,  которые  не  дают 
            цветного  изображения,  соответствующие  значения для 
            установки основного цвета интерпретируются  следуюшим 
            образом: 

            0 -     черный
            1 -     подчеркивание
            2-7 -   белый
            8 -     черный
            9 -     интенсивное подчеркивание
           10-15 -  интенсивный
           16 -     черный
           17 -     подчеркивание черным цветом
           18-23 -  мигание
           24 -     черный
           25 -     высокая интенсивность подчеркивания, мигание
           26-31 -  высокая интенсивность, мигание

               Значения фонового цвета от 0 до 6 при монохромном 
            адаптере дают черный фон, 7 - белый.
               Усовершенствованные  графические  адаптеры (EGA) и 
            Видео-графические адваптеры (VGA) с усовершенствован-
            ными мониторами позволяют использовать 16  цветов  из 
            набора в 64 цвета (см. PALETTE).  

Ограничения    Пограничный параметр не дает эффекта в случае  EGA 
            или VGA с усовершенствованным монитором.

Пример      'Данная прграмма демонстрирует оператор COLOR  как  в
            'текстовом, так и в графическом режиме.

                    'показать на экране таблицу атрибутов
            FOR Back% = 0 to 7
               FOR Fore% = 0 to 15
                    COLOR Fore%, Back%
                  PRINT USING " ### ";Back%*16+Fore%;
               NEXT Fore%
                  PRINT
            NEXT Back%

                  PRINT

            FOR Back% = 0 to 7      'показать на экране таблицу
                                    'всех атрибутов c миганием
               FOR Fore% = 16 TO 31 
                    COLOR Fore%, Back%   'установить цвет экрана
                  PRINT USING " ### ";Back%*16+Fore%-16;
               NEXT Fore%
                  PRINT
            NEXT Back%

            END

                         Оператор  COM(n)
-----------------------------------------------------------------

Назначение  Оператор   COM(n)   управляет  срабатыванием  ловушки 
            серийных портов.  

Синтаксис   COM(n){ON/OFF/STOP}

Комментарий      n - есть номер коммуникационного  адаптера,  где 
            применяется ловушка (1 или  2).  Оператор  COM(n)  ON 
            позволяет  применять  ловушку  при  помощи программы, 
            описанной в операторе ON COM(n).  После COM(n)  ON  , 
            Турбо  Бейсик  проверяет выполнение каждого оператора 
            для  выяснения  поступления   знаков   на   указанный 
            серийный порт Если выясняется, что такое срабатывание 
            произошло,  он  вызывает  описанную  в  операторе  ON 
            COM(n) подпрограмму.  
               Если COM(n) находится в OFF, активность в серийном 
            порте  игнорируется.  Прерывание  связи  прекращается 
            после оператора COM(n) STOP; однако, любая активность 
            запоминается, в случае выполнения оператора COM(n) ON 
            происходит   незамедлительное  срабатывание  ловушки.  
            Для увеличения  или  уменьшения  размера  буфера  COM 
            используйте метаоператор $COM .  

См.также    ON COM(n)

Пример
            'Демонстрируется оператор  COM(n). Примечание.
            'Данная программа ничего не покажет, если ваш
            'port COM1  не получит ввода
            'установите программу для обработки ввода COM ON COM(1)
                   GOSUB GetCominput
            'назначить  массив в 5к для сохранения ввода 
                   DIM ComPortinput (5 * 1024)
            'назначить   указатель   (поинтер)  в  следующее  доступное
             пространство буфера
                   HeadPtr%=0
            'включить включатель  COM
                   COM(1) ON
            'установить буфер ввода в 1К
                   $COM1 1024
            'открыть переменную файла COM1
                   OPEN "com1" AS # 1
             PRINT "Press any key to terminate the program..."
            'пока не нажата клавиша
                     WHILE NOT INSTANT
            'если буфер не пустой
                   IF TailPtr% <> HeatPtr% THEN
            'показать ввод.
            
            PRINT "COM Port input: ";ComPortInput (TailPtr%)
            'перейти к следующей ячейке буфера
                  TailPtr% = TailPtr% + 1
             END IF
             LOCATE 2,1
             PRINT TIME$
            WEND
          END       'конец программы
             
                GetComInput:  'обработать прерывание порта  COM
            'считать ввод с буфера порта  COM
                INPUT# 1,ComPortInput (HeadPtr%)
            'указать следующее пространство буфера
                HeadPtr% = HeadPtr% + 1
            RETURN
                  END of input    'конец ввода порта  COM
                PRINT "Reached the end of input..."
          END       'закончить программу

                         функция COMMAND$  
-----------------------------------------------------------------
Назначение  функция COMMAND$ возвращает командную строку, исполь- 
            зуемую для запуска прграммы с DOS.

Синтаксис   s$ = COMMAND$

Комментарий    функция COMMAND$ возвращает все,  что было введено
            на подсказке DOS в процессе вызова прграммы,  за  ис-
            ключением  самого  имени программы (иногда этот текст 
            называют "трейлером" <"trailer">).  
               Используйте  функцию COMMAND$ для сбора аргументов 
            выполнения программы таких,  как имена файлов  и  фа-
            культативные  (подгружаемые)  программы.   Нрапример, 
            рассмотрим введенную в ответ на подсказку  DOS  такую 
            команду: 

               FASTSORT cust.dta cust.new 

            где  FASTSORT представляет собой прграммный файл .EXE 
            типа,  созданный средствами ТУРБО БЕЙСИКа.  Когда уп- 
            равление  будет передано программе FASTSORT,  то фун-
            кция COMMAND$ будет удерживать все что  было  введено 
            по подсказке DOS после самого имени программы,  в на-
            шем случае это строка: "cust.dta cust.new". Определе-
            ние FASTSORT решает,  что делать с этой строкой (воз- 
            можно  функция  COMMAND$ будет прервана в файле,  имя 
            которого стоит первым, и в файле,  имя которого стоит 
            вторым; и содержимое первого файла будет в отсортиро-
            ванном виде передано второму файлу).  
               Для проверки при помощи ТУРБО БЕЙСИКа <from within 
            TURBO BASIC> правильности работы программы <to test a 
            program>, в которой применена функция COMMAND$, сле-
            дует использовать вариант <option> строки Параметра 
            меню Варианты <Options> для установки строки возвра-
            щаемой функцией COMMAND$.

Ограничения    Максимальная  длина строки команд DOS составляет 
            127 символов.

Пример        'Данная программа демонстрирует функцию COMMAND$.

  PRINT "The command line parameteres passed to this program are"
              PRINT COMMAND$

               Скомпилируйте эту программу в память и дважды про- 
            гоните ее,  меняя каждый раз статью параметров в меню 
            Options.  

                         Оператор COMMON
-----------------------------------------------------------------
Назначение  Оператор COMMON обявляет одну или несколько перемен-
            ных, которые должны перейти в цепочную программу.

Синтаксис   COMMON variable [,variable]...

Комментарий    variable это  переменная массива или скалярная пе-
            ренменная,  которая должна  быть  доступна  следующей 
            соединяемой  в  цепочку <CHAINed> программе.  Массивы 
            описываются включением параметров размера  в  скобках 
            после имени переменной массива.  
               Операторы  COMMON  могут  появляться в любой части 
            программы, их может быть несколько,  а конкретная пе- 
            ременная может появиться только один раз.  
               В программе,  которая соединяется в цепочку должен 
            появиться соответствующий оператор COMMON.  Имена пе-
            ременных,  используемых в операторе COMMON,  не имеют 
            значения  -  важны  их число и тип.  Если переменная, 
            объявленная общей в вызывающей программе, не соответ-
            ствует типу и количеству переменных, обявленных общи-
            ми в принимающей  программе,  -  генерируется  ошибка 
            выполненния.

Различия       ТУРБО БЕЙСИК не поддерживает параметр CHAIN ALL, 
            обеспечиваемый Интерпретатором БЕЙСИК. Вам необходимо 
            в явном виде определить каждую общую переменную в це-
            почной программе.
               При описании массива как общей переменной в ТУПРБО 
            БУЙСИКе вы должны описать параметроы размера массива.
               Интерператор БЕЙСИК не троебует соответствия 
            соответствия операторов COMMON, потому что COMMON 
            троебуется только только оператору CHAIN "из", а  
            CHAIN "в" этого не требует. ТУРБО БЕЙСИК, наоборот, 
            требует, чтобы переменные в каждом общем операторе 
            были правильно расположены (в одинаковом порядке). 
            Иначе говоря,  имена переменных в основной и присое-
            диняемой (цепочной) программах могут быть разными, но 
            типы переменных должны совпадать. Ниже приведен при-
            мер правильного оператора COMMON.

               'Основная программа

            COMMON I%, Array(1), J$

               'Присоединяемая (цупочная) программа

            COMMON Int%, RealArray(1), DblPrt$

Ограничения    ТУРБО БЕЙСИК не поддерживает режим замены  
            CHAIN ALL COMMON Интерпретатора БЕЙСИК.

Пример      'Данная прграмма демонстрирует оператор COMMON
            'для ее выполнения необходимо:
            '1) скомпилировать первую программу в файл  .EXE
            '2) скомпилировать вторую программу в файл  .TBC
            '3) выполнить первую программу на подсказке DOS
            
            'Программа MASTER. Скомпелируйте ее в файл .EXE
            
               DIM OldArray$(1) 'объявлен массив из двух строк
                
                'присвоить значения строкам массива OldArray$
                   OldArray$(0) = "это первая строка массива"
                   OldArray$(1) = "это вторая строка массива"
                          
            'присвоить значения другим переменным
            OldInteger% = 12345
            OldLongInt& = 123450000
            OldSinglePre! = 12345.54321
            OldDoublePre# = 1.0E+300
            

            'Описать переменные общие для главной и 
            'присоединяемой программ
             COMMON OldArray$(), OldInteger%, OldLongInt&,- 
                    OldSinglePre!, OldDoublePre#

       CHAIN "SLAVE.TBS"  'Цепочка для присоединения программы
            END           'конец главной программы

            'Программа SLAVE (присоединяемая). 
            'Скомпелируйте ее в файл .TBC

             COMMON NewArray$(), NewInteger%, NewLongInt&,_ 
                    NewSinglePre!, NewDoublePre#

                PRINT  NewArray$(0) 
                PRINT  NewArray$(1) 
                PRINT  NewInteger%, NewLongInt&, NewSinglePre!,_ 
                       NewDoublePre#

                           Функция COS
-----------------------------------------------------------------
Назначение  Функция  COS  возвращает тригонометрический косинус.

Синтаксис   y = COS (numeric expression)

Коментарий     numeric expression -  угол, выраженный в радианах. 

               Для того,  чтобы перевести радианы в углы, необхо-
            димо  произвести  умножение  180/П.  Чтобы  перевести 
            градусы  в  радианы,  произведите умножение на П/180.  
            (См. о радианах в описании функции ATN).  
               Функция   COS   возвращает   значение    удвоенной 
            точности.  

См. также   ATN   SIN   TAN
                              
Пример      'Данная программа демонстрирует функцию  COS
            PI# = ATN(1) * 4
            FOR I% = 0 TO 360 STEP 45
              PRINT USING "The Cosine of ### degrees = ##;_
                           I%,COS(PI#/180 * I%)
            NEXT I%
            END

                          Функция  CSNG
-----------------------------------------------------------------
Назначение  Функция  CSNG  преобразует  численное выражение в его
            эквивалент с одинарной точностью.
            
Синтаксис   Y = CSNG(numeric expression)

Комментарий    Функция CSNG  преобразует численную переменную или 
            выражение в форму с одинарной точностью  с  плавающей 
            запятой   Функция   CSNG   обычно   используется  для 
            профилактики    промежуточного    переполнения    при 
            обработке целочисленных операнд.  

См. также   CDBL    CINT   CLNG

Пример      PRINT CSNG(&HFFF),CSNG(13241.1324),CSNG(&HF000)

                         Функция  CSRLIN
-----------------------------------------------------------------
Назначение     Функция  CSRLIN  возвращает  текущее  вертикальное 
            положение курсора (номер строки).  

Синтаксис   Y = CRLIN

Комментарий    Функция CSRLIN возвращает целое число от 1 до 255, 
            представляя  текущее  вертикальное  положение  (номер 
            строки)  курсора.   Для  считывания   горизонтального 
            положения курсора (номер колонки) используйте функцию 
            POS.  
               Оператор LOCATE перемещает курсор в специальную 
            строку и колонку.  

См. также   LOCATE   POS

Пример      Col = POS    'записать строку курсора
            Row = CRLIN  'записать колонку курсора
            CLS
            LOCATE Row,Col 'восстановить позицию курсора.

                    Функции   CVI,CVL,CVS,CVD
-----------------------------------------------------------------
Назначение  Функции    CVI,CVL,CVS,CVD   преобразуют   символьные 
            данные,   считываемые   с   файлов   с   произвольной 
            организацией, в численные данные.  

Синтаксис   Y% = CVI (2 - bite string)
            Y% = CVL (4 - bite string)
            Y% = CVS (4 - bite string)
            Y% = CVD (8 - bite string)

Комментарий    CVI  преобразует строку в 2 байта в целое  число.  
               CVL  преобразует строку в 4 байта  в длинное целое 
                     число.  
               CVS  преобразует строку в 4  байта  в  значение  с 
                    одинарной  точностью.  
               CVD  преобразует строку в 8  байтов  в  значение с 
                     двойной точностью.  

            Из-за  специфики  работы  Турбо  Бейсика  с файлами с 
            произвольной организацией,  численные значения должны 
            транслироваться  в символьные до того,  как они будут 
            записаны на диске,  а при считывании файла они  будут 
            транслироваться  обратно  в  числа.  Не  путайте  эти 
            функции (которые предназначены строго  для  обработки 
            файлов  с  произвольной организацией) с функцией VAL, 
            которая берет строку типа "3.7" и  преобразует  ее  в 
            численный вид.  

См. также   MKD$    MKI$   MKL$   MKS$

Пример      'Данная прграмма создает файл с произвольной выборкой 
            'данных и записывает на него определенную информацию.  
            'Затем   она   считывает   только   что    записанную 
            'информацию,  преобразуя  ее  в  употребимую  форму с 
            'использованием предыдущих функций.  

            'открыть файл с произвольной выборкой
            OPEN "R",#1,"CVISLD.DATA",18
            FIELD #1, 2 AS Integer$, 4 AS LongInt$,_
                      4 AS SinglePre$, AS DoublePres
            MaxInt% = 32767

        'записать данные в файл, преобразовать их, присвоить
        'ему буфер до записи его в файл данного
            FOR I% = 1 TO 5
              LSET Integer$ = MKI$ (1%)
              LSET LongInt$ = MKL$ [1% + CLNG (MaxInt%)]
          LSET Singlepre$ = MKS$ [CSNG(1% * CSNG (MaxInt%))]
              LSET Doublepre$ = MKD$ (MaxInt-1%)
              PUT #1,I%
            NEXT 1%
            FOR I% = 1 TO 5   'считать данные с файла
              GET #1,I%     'показать их на экране
              PRINT CVI (Integer$), CVL (LongInt$),_
                    CVS (Singlepre$), CVD (Doublepre$)
            NEXT I%            
            CLOSE #1   'закрыть файл            
            END

                        Функции CVMD, CVMS
-----------------------------------------------------------------
Назначение  Функции   CVMD   и   CVMS   преобразуют    символьные 
            переменные,   считываемые  с  файлов  с  произвольной 
            организацией с формата Micvosoft, в численный вид.  

Синтаксис   y! = CVMS (4 - byte string)
            y# = CVMD (8 - byte string)

Комментарий    CVMS (строка с одинарной точностью  ConVert Micro-
            soft)  преобразует  строку в 4 байта,  представляющую 
            значение с одинарной точностью в формате Micvosoft, в 
            значение с одинарной точностью в формате  IEEE  ТУРБО
            БЕЙСИКа.  
               CVMD (строка с удвоенной точностью ConVert Micro-
            soft) преобразует строку в 8 байтов,  представляющую 
            значение с удвоенной точностью в формате Microsoft, в 
            значение  с  удвоенной точностью в формате IEEE ТУРБО 
            БЕЙСИКа.   Эти  функции  обеспечиваются  только   для 
            совместимости  с существующими файлами с произвольной 
            организацией Интерпретатора БЕЙСИК.  

Пример      'открыть файл с произвольной выборкой
            OPEN "CVMD.DTA" AS #1 LEN = 12
            FIELT #1, 4 AS Single$, 8 AS Double$

            FOR I = 1 TO 5   'записать некоторые данные в файл
              `преобразовать данные и назначить файл данных
              LSET Single$ = MKMS$ (I)
              LSET Double$ = MKMD$ (I^I)
              PUT #1,I
            NEXT I
                   FOR I = 1 TO 5   'считать данные файла
              GET #1,I       'показать данные на экране
              PRINT CVMS (Single$), CVMD (Double$)
            NEXT I
            PRINT CVS (x$), CVMS (x$)
            CLOSE #1         'закрыть файл
            END

                          Оператор DATA
-----------------------------------------------------------------   
Назначение  Оператор DATA объявляет константы для операторов 
            READ.

Синтаксис   DATA constant [,constant]...

Комментарий    constant - это численная и символьная постоянная.  
            Численные  константы  могут быть целыми числами или с 
            плавающей запятой и могут факультативно быть  выраже- 
            ны  в  шестнадцатеричных  или восьмеричных значениях.  
            Символьные константы не берутся в кавычки,  если  они 
            не  содержат огранчителей (запятых или двоеточий) или 
            значимых пробелов, и их можно легко спутать с числен- 
            ными константами. Например: 
            
         DATA Taco,.79,Chicken Supreme,2.29,"Dr.Pepper,large",.89 

            Программа может содержать много операторов DATA и они 
            не должны распологаться в  последовательных  строках. 
            каждая может включать столько констант, сколько может 
            поместиься в строке.  
               Во время выполнения программы операторы  READ  об- 
            ращаются  к  константам DATA слева направо и сверху в 
            вниз  в  порядке  появления  их в исходной программе.  
            Наиболее частой ошибкой, связанной с операторами DATA 
            и READ ,  является выход из синхронизатора и  попытка 
            загрузить  символьные  данные в численную переменную, 
            это генерирует синтаксическую ошибку  (ошибка  выпол- 
            нения 2).  К сожалению, вам не удастся перевести чис- 
            ленные  константы,  загружающие ошибку,  в символьные 
            переменные, даже, если это и не то, что вы ожидали.  
               Команда  RESTORE  позволит  вам  повторно  считать 
            константы из первого оператора или любого  описанного 
            оператора DATA .  
               Если  вы  попытаетесь  использовать  READ  большее 
            количество раз, чем количество констант, содержащихся 
            в вашей программе,  произойдет ошибка  выполнения  4, 
            Out of data (вне данных).  

Ограничения    Нельзя использовать знаки,  подчеркивающие  непре-    
            рывность, в операторах DATA. Не используйте запятую в 
            верхней  части   строки   (')   для   комментирования 
            оператора DATA, потому что Турбо Бейсик подумает, что 
            последняя  статья  и  ваш комментарий являются частью 
            одной, длинной символьной константы.  
              Например: 

              DATA cats,dogs,tigs   'приводит названия животных
            интерпритируется  как   содержащая   три   символьных 
            константы:   "cats",   "dogs"   and  "pigs  'приводит 
            названия животных "; 

               Вы можете,  однако, совершенно безопасно использо-
            вать для этой цели: REM: 

               DATA  cats,dogs,pigs :REM list the animals
            
См. также   READ    RESTORE

Пример      'Данная  программа  демонстрирует  использование  
            'оператора DATA.

            SUB Process Results (StudentName$, StudentAverage%)
            LOCAL Total%, Value%, %
            Total% = 0            
            READ StudentName$
            FOR I% = 1 TO 10
            READ Value%
            Total% = Total% + Value%
            NEXT I%
            StudentAverage% = Total%\10
            END SUB
            FOR Student% = 1 TO 3
            CALL Process Results (Name$, Average%)
            PRINT USING  "&,average is ###"; SName$, Average%
            NEXT Student%
            END   'закончить программу
            DATA w. Perry,  78,65,35,79,86,93,79,85,99,96
            DATA P. Watson, 98,94,70,88,99,100,75,96,100,95
            DATA M. Ciccone, 65,59,75,82,56,79,82,76,69,89

                   Системная переменная  DATE$
-----------------------------------------------------------------
Назначение  DATE$  устанавливает и отыскивает системные данные

Синтаксис   DATE$ = s$ (set date according to information in s$)
                   `установить дату в соответствии с информацией

            s$ = DATE$ (s$ now contains date informetion)
                       `теперь содержит информацию о дате

Комментарий    Назначение  строго  форматированного   символьного 
            значения  системной   переменной   DATE$   символьной 
            переменной   делает   системную  дату  доступной  для 
            обработки.  DATE$  возвращает  10-знаковую  строку  в 
            виде  mm-dd-yyyy,  где mm - представляет месяц,  dd - 
            день, а yyyy - год.  
               Для    изменения   даты,    ваша   строка   должна 
            форматировать дату одним из следующих  способов:  

               mm-dd-yy 
               mm/dd/yy 
               mm-dd-yyyy 
               mm/dd/yyyy 

            Например    DATE$ = "10-25-86"
            устанавливает системную дату 05 октября 1986 года.

Ограничения    Год,  назначаемый системной переменной DATE$, дол-
            жен находиться в приделах диапазона 1980 - 2099.  

См. также   TIME$

Пример      `Покажите текущую системеую дату на экране
            PRINT "The current system date is" DATE$
     INPUT  "Please  enter  then new date in then form MM-DD-YY"; 
            NewDate$ DATE$ = NewDate$ PRINT "The system  date  is 
            now set to" DATES 
            END  `закончить программу

                          Оператор  DECR
-----------------------------------------------------------------
Назначение   Оператор   DECR   дает    отрицательное   приращение 
             переменной 

Синтаксис   DECR  variable [,size]

Комментарий    variable - это численная переменная,  а size - это 
            необязательное числовое выражение,  которое указывает 
            на   значение,   которое   должно   быть  вычтено  из 
            variable.Если size опускается, используется 1.  
               DECR - удобный  способ  отрицательного  приращения 
            переменной.  Для  приращения  переменной  используйте 
            оператор INCR.  

См. также   INCR

Пример      I% = 15    `инициализировать счетчик переменных
            J% = 500
            WHILE  I% > 0
            PRINT  I%,J%    `показать значение
            DECR   I%   `уменьшить значение на одну единицу
            DECR   J%, 5    `уменьшить значение на  5
            WEND
            END         `закончить программу

                    Оператор   DEF FN/END DEF
-----------------------------------------------------------------
Назначение  DEF FN/END DEF  определяет функцию.

Синтаксис   Из одной строки
            DEF FNidentifier[(argument list)] = expression

            Из нескольких строк
            DEF FNidentifier [(argument list)]
              [LOCAL variable list]
              [STATIC variable list]
              [SHARED variable list]
                .
                .
                .   statements
                .
                [EXIT DEF]
                [FNidentifier = expression]
              END DEF

Комментарий    identifier   есть  уникальное имя,  которое должно 
            ассоциироваться с функцией,  и должно соответствовать 
            условиям  присвоение  имени меткам и переменным (т.е. 
            буква за которой следует любое колличество букв и/или 
            цифр).  argument list есть необязательная, отделенная 
            запятыми  последовательность  формальных  параметров. 
            Параметры  в  списке  аргументов  служат  только  для 
            определения функции:  они не имеют никакого отношения 
            к другим переменным в программе с таким же названием.  
               DEF  FN и END DEF берут в скобки и присваивают имя 
            группе    подпрограммных    операторов,    называемых 
            функцией.  Функции  могут быть факультативно переданы 
            один  или  более  аргументов  по  значению.   Функции 
            возвращают   значение  (тип  которого  контролируется 
            именем функции,  как будто это переменная) и могут по 
            этому  вызываться из любого оператора, который прини-
            мает значение соответствующего типа.

                      Определение функции и ход программы.
               Положение определений функции нематериально.  Фун-
            кция может быть определена в 1 строке или 1000 строке 
            программы без учета места ее использования;  и вам не 
            надо  направлять  ход программы через функцию как шаг 
            инициализации  (как  это  требуется  в   однострочных 
            функциях  в Интерпритаторе Бейсик).  Компилятор видит 
            ваши определения, где бы они не находились.  Выполне-
            ние программы также не может случайно (и в отличие от 
            подпрограмм) "распадаться"  на функции.  Что касается 
            маршрута выполнения программы,  определения функций и 
            процедур являются не видимыми.  

              Например:

            t = FNPrintStuff
            DEF fnprintStuff
                PRINT "Printed from within FNPrintStuff"
            END DEF

               Когда  выполняется  эта четырехстрочная программа, 
            сообщение появляется только однажды, т.к.  PrintStuff 
            вызывается в первой строчке.  
               Определения  функции  следует  рассматривать   как 
            изолированные островки кода; не запрыгивайте на них и 
            не  выпрыгиваете  обратно при помощи операторов GOTO, 
            GOSUB или RETURN. В рамках определений, однако, такие 
            операторы допустимы.  
               Заметьте,  что определения функции и процедуры  не 
            могут  вкладываться  друг в друга,  т.е.  недопустимо 
  
            определять процедуру или функцию в  рамках  процедуры 
            или  функции  (хотя определение процедуры или функции 
            может содержать вызовы других процедур или функций).  

                      Объявление локальных переменных 
                       (только многострочные функции).   
               Для   объявления  локальных  переменных  в  рамках 
            функции  используйте  оператор  LOKAL   перед   любым 
            выполняемым оператором в дефиниции. 
               Например: 
            
                LOCAL a%,b#,bigArray%()

            создает  три  локальные  переменные:  a%  и b# (целое 
            число и число с двойной точностью  соответственно)  и 
            целочисленный  массив  bigArray.  Массив  должен быть 
            соответствующих размеров: 

            DIM DYNAMIC bigArray%(1000)

                    Статические и разделенные переменные.
               По умолчанию, переменные, которые появляются в ра-
            мках определений функции имеют аттрибут SHARED,  т.е.  
            они  являются  глобальными  по  отношению к остальной 
            части программы.  Так как по умолчанию подвержено из-
            менениям,  вы  должны сделать попытку объявить каждую 
            переменную, используемую в функции.  
               Объявляйте  переменные  с  атрибутом STATIC,  если 
            важно,  чтобы переменная не теряла  свое  значение  с 
            каждым  вызовом,  а  изменена она может быть только в 
            пределах функции.  
               Определение функции из нескольких  строк  включает 
            обычно  назначение  идентификатору  функции  и должно 
            быть прекращено при помощи END DEF. Если вы решили не 
            включать  назначение  идентификатору  функции,  тогда 
            значения,   возвращенное  функцией,   бюудет  неопре- 
            деленным.  Используйте оператор EXIT DEF для возврата 
            из функции, которая находится не в конце ее.  

См. также   LOCAL   SHARED   STATIC

Пример      $STASK &H7FFF
            Total = 1
            DEF FNFactorfal%(I%)
            'данная функция вычисляет факториал параметра I%
            Total = Total = I%
            IF I% > 1 THEN
            Subb% = FNFactorfaI%(I%-1)
            END IF
            FNFactoraI% = Total
            END DEF  'закончить факториал функции
            PRINT "Input the number you wish to calculate the";
            INPUT "factorial of: ",J%
            PRINT FNFactorial%(J%)
            END   'закончить программу

        Операторы  DEFINT, DEFLNG, DEFSNG, DEFDBL, DEFSTR
-----------------------------------------------------------------
Назначение  Операторы  DEFINT, DEFLNG, DEFSNG,  DEFDBL  и  DEFSTR
            объявляют тип идентификаторов переменных по умолчанию

Синтаксис   DEFtype letter range [, letter range]....

Комментарий    type  представляет  один  из пяти типов переменных 
            ТУРБО БЕЙСИКа: INT, LNG, SNG, DBL и STR.  
               letter  range это либо одиночный алфавитный символ 
            (от A до Z), либо диапазон букв (две буквы отделенные 
            друг от друга тире, например: A-M). 
               Оператор  типа  DEF сообщает компилятору что пере-
            менные и определенные пользователем функции,  начиная 
            с конкретной буквы или набора букв  будут  определен- 
            ного типа.  Это дает возможность использовать в  про- 
            грамме  без включения идентификаторов типа (например, 
            %,  #) переменные не только с одинарной  точностью  и 
            плавающей запятой.  
               По умолчанию,  когда компилятиор находит имя пере- 
            менной без идентификатора типа, он допускает, что пе- 
            ременная с плавающей запятой и с одинарной точностью.  
               Например:  в  данном  операторе  как  n  так  и  m 
            являются переменными с одинарной точностью: 
 
                 n = m + 16

               Однако если, этому оператору предшевствуют  

                 DEFINT n,m

            тогда n и m обе будут целочисленными переменными, как 
            и любая другая переменная, чье имя начинается с n или 
            m в верхнем или нижнем регистре.  
               Выполнение DEFtype в ТУРБО БЕЙСИКе немного отлича- 
            ется от Интерпритатора БЕЙСИК. Интерпритатор оценива- 
            ет  печатание  в  соответсвии  с  тем,  где  оператор 
            DEFtype  появляется  при  выполнеии программы.  ТУРБО 
            БЕЙСИК в качестве компилятора рассматривает положение 
            DEFtype в исходном файле.  
               Например,  при выполнении данной программы 

               10 GOTO 30 
               20 DEFINT A-M 
               30 j = 45.3 : PRINT j 

            Интерпритатор  БЕЙСИК  никогда  не   видит   оператор 
            печатания  в  строке  20 когда он встретит j в строке 
            30, j станет переменной с одинарной точностью и будет 
            напечатано 45.3.  ТУРБО БЕЙСИК,  наоборот,  принимает 
            решения  о  введении  переменных во время компиляции, 
            без учета маршрута выполнения  (о  котором  во  время 
            компиляции он ничего не знает).  Он заботится только, 
            чтобы оператор DEFINT появился физически  до  первого 
            появления  переменной  j.  Таким образом j становится 
            целым числом и печатается 45 .  

Ограничения    Оператор DEFtype переопределит тип любой  соответ-
            ствующей переменной уже использованной в программе. 
               Программа примера демонстрирует этот тонкий момент.  

Пример      'назначить значение числу с одинарной точностью
                 I = 35567.999
                       PRINT "Single Precision number".I
            'показать значение на экране
            'экплизитно объявить переменную с таким же именем
            'и такого же типа
                 DEFSNG I
                      PRINT  "Single Precision number".I

            'эксплизитно объявить переменную с таким же именем
            'но другого типа
                  DEFINT I
            'напечатать значение новой переменной
                      PRINT  "Integer number".I

            'все идентификаторы, начиная с буквы от A  до  C
            'будут с двойной точностью до 
            'следующего оператора DEF 
            DEFDBL A-C

            'все идентификаторы,  начиная с буквы от J до Z будут 
            'целочисленного типа до очередного оператора DEF 
            DEFLNG J-Z

            'присвоить значение переменной с удвоенной точностью
            A = 32767.1

            'присвоить значение длинному целому числу
            Z = -1

            'присвоить значение ранее определенной   
            'целочисленной переменной 
            I = &H8FFF
                  PRINT  "The different types:",A,Z,I
             END    'закончить программу
