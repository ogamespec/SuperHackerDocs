.R:
.L:72
.N:67
.H:...$$$...
.H:
.H:
.X:10
.S:6
                              Файлы.
                              ------                              
     После создания программы или подборки данных,  к которым вам 
нужно будет возвращаться, следующий логический шаг- сохранить ее. 
Сохраняя данные, вы создаете файл, который можно использовать для 
ввода и вывода информации. Можно создавать файлы трех типов: пос- 
ледовательные, прямого доступа и двоичные. Ниже мы рассмотрим ка- 
ждый из этих типов, но сперва давайте рассмотрим как назвать фай- 
лы и/или каталоги (содержащие несколько файлов или подкаталогов).  
     Будучи "гражданами" мира MS-DOS файлы, которые Вы создаете и 
с которыми работаете используя ТБ,  должны именоваться в соответ- 
ствии с нормами DOS.  Имена файлов состоят из двух частей, разде- 
ляемых точкой: 
                    filename.ext (имя файла.расширение) 

     Имя файла может включать от 1 до 8 знаков, а соответствующее 
расширение - до трех знаков.  Если в имени файла больше 8 знаков, 
ТБ автоматически усекает имя и добавляет точку в конце. Например, 
если ввести: 

     TESTINGDATA          оно превратится в     TESTINGD. 

     Если строка содержит точку, разделяющую имя файла и расшире-
ние, но имя файла содержит больше 8 знаков, ТБ сокращает имя до 8
знаков, а затем добавляет расширение, как, например: 

    VERYLONGFILENAME.TBS    становится         VERYLONG.TBS 

     Если  использовать  расширение,  в котором больше трех букв, 
лишние буквы буддут отсечены, например: 

     TESTING.DATA           станет      TESTING.DAT 

     Имена файлов и расширения могут содержать следующие символы: 

     A-Z 0-9 () {} @ # $ % ^ ! - _ ' / ~ 

     Заметьте, что символ пробела нельзя использовать, а строчные 
буквы автоматически трансформируются в прописные.  Ниже приведены 
примеры павильных имен файлов: 

     MYFIRST.TBS 
     MY1ST.TBS 
     MY_ABCS.(1) 
     10-25-51.@@@ 

     Кроме  операторов для создания,  считывания и записи файлов, 
ТБ имеет средства  для  осуществления  определенных  DOS-подобных 
сервисных программ внутри программы. Оператор NAME переименовыва-
ет файлы, KILL - стирает файлы, MKDIR - создает каталоги, CHDIR - 
меняет текущий каталог, RMDIR - уничтожает каталоги.  Нет команды 
COPY (копировать);  вместо  нее используйте метод двоичных файлов 
(или используйте SHELL для вызова COMMAND.COM).  
     Имена файлов,  используемые в операторах ТБ (например,  KILL 
или OPEN) должны быть в символьной форме, например: 

     KILL "myfile.bak" 
или 
     a$ = "myfile.bak" : KILL a$ 
но не 
     KILL myfile.bak 

     Более подробно о файлах и каталогах расказано в Приложении G 
"Основы DOS" и в Вашем справочнике по DOS.  

     Имена каталогов и маршрутов.
     ---------------------------- 
     В  MS-DOS 2.0 и выше (ТБ и создаваемые им программы не будут 
работать в более ранних версиях) форматирование гибкого или жест-

кого диска создает каталог фиксированного размера,  известный под 
именем  корневого.  Элементами  корневого каталога могут быть как 
файлы, так и дополнительные каталоги (называемые подкаталогами).  
     Как обычные файлы,  подкаталоги имеют  имена  и  расширения, 
могут разрастаться по мере необходимости.  Подкаталоги сами могут 
включать свои подкаталоги,  организованные  в  систему  файлов  и 
каталогов, напоминающую перевернутое дерево (см. Рисунок 4-1).  

               Корневой каталог (Root direktory)
         ___________________________________________________
         I                       I                         I
         I                       I                         I
         BIN                  TURBOBNAS                  WORDSTAR
         I                       I
   ______I______                 I
   I           I                 I
   I           I                 I
 CHKDSK     FORMAT               I
                                 I
         ________________________I__________________________
         I                       I                         I
         I                       I                         I
     EXAMPLES                MIVIRST.BAS               MIVIRST.EXE
         I
  _______I______
  I            I
  I            I
 EX1.BAS    EX2.BAS
                    
               Рис. 4-1  Иерархия файловой системы

     На вершине дерева файловой системы - корневой  каталог,  имя 
которого предопределено: обратная черта дроби (\). Файлы в дереве 
определяются указанием каталожной цепочки или пути доступа, веду-
щего к ним.  
     Пути доступа образуют перечислением подкаталогов,  ведущих к 
файлу,  разделенных обратной чертой дроби (\).  Другими  словами, 
полное описание файла CHESS.BAS в каталоге TURBO\BASIC\GAMES выг-
лядит так: 

     буквенный индекс дисковода и двоеточие 

I 
C:\TURBO\BASIC\GAMES\CHESS.BAS 
  I_________________II___II__I 
           I           I    I 
     путь допуска     имя  расширение 
        каталога     файла 

     Первая  обратная  черта  дроби  (\)  указывает,  что маршрут 
начина-ется из корневого каталога. DOS трассирует текущий каталог 
(назы-ваемый также активным или по умолчанию), тот, в котором она 
будет разыскивать файлы, если Вы укажите маршрут.  Если имя марш-
рута начинается не с "\", то оно описывает маршрут, принадлежащий 
текущему каталогу.  Например, если текущий каталог- \TURBO\BASIC, 
то оба следующих имени точно описывают положение CHESS.BAS: 

     GAMES\CHESS.BAS 
                                      или 
     \TURBO\BASIC\GAMES\CHESS.BAS 

     В любом подкаталоге,  список файлов каталога из DOS  или  ТБ 
(используя  FILES)  обязательно включает два особых файла:  "." и 
"..".   Имя файла "." указывает каталог,  числящийся как подката-
лог,  а имя ".." относится к родителю каталога.  Например,  чтобы 
сменить текущий каталог на "родительский",  воспользуйтесь опера-
тором CHDIR с особым именем ".." 

     CHDIR ".." 

                    Методы сохранения файлов.
                    ------------------------- 
     ТБ  предлагает  три  различных  способа сохранения и востре- 
бования информации с лиска:  последовательный,  прямой и двоичный 
ввод/вывод файла.  У каждого есть свои преимущества и недостатки; 
какой из них будет лучшим для вас зависит от применения.  

     Спрямление курса при управлении базой данных.
     ----------------------------------------------
     Традиционная   номенклатура   программирования  подразделяет 
файлы данных на отдельные записи,  каждая из которых  состоит  из 
одного  или  более полей.  Например,  в программе "список адресов 
выпускников"  каждая   запись   в   файле   данных   представляет 
определенного человека. Напимер, штат и почтовый индекс - это два 
поля,  которые  можно найти в файле "список адресов выпускников". 
     При распечатке строки представляют записи, а колонки - поля: 

----------------------------------------------------------------- 
Имя          Адрес           Город        Штат Индекс Класс Вклад 
----------------------------------------------------------------- 
Кати Хервей  1010 В.Редвуд   Сайокс Сити  ИНД  51103   73    0.00 
Эндрю Рич    37Андерсон Роуд Хьюстон      ТЕХ  77018   58  500.00 
Лэрри Ирвинг 32110 Мэйн      Линдсбург    КАНЗ 67456   81    0.00 

----------------------------------------------------------------- 

     Этот файл содержит три записи,  в каждой по семь  полей.  По 
причинам,  на которых мы бегло остановимся,  разграничение обычно 
производится между  численными  и  строковыми  полями.  В  данном 
примере, последние три поля численные, а остальные - символьные.   

     Последовательные файлы.
     -----------------------
     Метод  последовательных файлов - это способ прямого чтения и 
записи файлов.  Команды последовательных файлов в  Турбо  Бейсике 
создают  текстовые файлы:  файлы ASCII-символов с парами "возврат 
каретки/перевод строки", разделяющими записи.  
     Вероятно   одной   из    основных    причин    использования 
последовательных  файлов  является  степень  их "переносимости" в 
другие программы,  языки программирования и компьютеры.  По  этой 
причине  последовательные  файлы  часто  можно  рассматривать как 
общий знаменатель  обработки  данных.  Они  читаются  программами 
подготовки  текстов  и  редакторами  (такими как в Турбо Бейсик), 
принимаются другими прикладными  пограммами  MS-DOS,  такими  как 
управление базой данных,  и могут посылаться через серийные порты 
на другие компьютеры.  
     В основе последовательных файлов лежит сама простота: пишите 
в них так, словно они - экран, и читайте с них так,  словно они -
клавиатура.  

     Создайте последовательный файл используя следующие шаги: 

     1. ОТКРЫТЬ файл в режиме последовательного ВВОДА. Для созда-
        ния  файла в Турбо Бейсике необходимо использовать опера-
        тор OPEN.
        В последовательных файлах есть два пути подготовки  файла 
        к выводу: 

        OUTPUT (ВЫВОД):  Если файл не существует- создается новый
        файл.  Если файл уже существует, его содержание уничтожа-
        ется, а сам файл рассматривается как новый. 

        APPEND (ДОБАВИТЬ В КОНЕЦ):  Если файл не существует- соз- 
        дается новый файл.  Если файл уже существует,  ТБ дописы- 
        вает любые данные в конец этого файла.  
  
     2. Ввод  данных  в  файл.  Используйте  WRITE#   PRINT#  или
        PRINT#USING для записи данных в последовательный файл. 

     3. ЗАКРОЙТЕ файл. Оператор CLOSE закрывает файловую перемен-
        ную  после  завершения всех операций ввода/вывода. 

     Для чтения последовательного файла 

     1. ОТКРЫТЬ файл в режиме последовательного  ВВОДА.  Подгото-
        вить файл для считывания. 

     2. Считывать данные с файла.  Использовать операторы INPUT#,
        INPUT$, или LINE INPUT# Турбо Бейсика. 

     3. ЗАКРЫТЬ файл.  Оператор CLOSE закрывает файловую перемен-
        ную после выполненитя всех  операций ввода/вывода. 

     В Главе 5, "Опорный каталог Турбо Бейсика", дана более подроб-
ная информация по упомянутым операциям с файлами. 

     Недостаток  последовательных  файлов  в  том,  что  возможен 
только последовательный доступ к данным:  за  один  шаг  доступна 
только  одна  запись,  начиная с первой.  Это значит,  что,  если 
необходимо  добраться  до  последней  записи  в  последовательном 
файле,  состоящем  из  23000  записей,  придется пройти через все 
предыдущие 22999 записей.  
     Поэтому последовательные файлы лучше всего использовать там, 
где нужна последовательная обработка  данных  (например,  подсчет 
слов, проверка правописания, распечатка почтовых ярлыков в поряд-
ке следования файлов),  или где данные могут одновременно удержи-
ваться  в  памяти.  Это позволяет Вам считывать весь файл за один 
быстрый прогон с начала файла, и вновь записывать его в конце. По 
ходу прогона доступ к данным осуществляется через  временные  на-
чальные позиции прямого доступа численных и символьных массивов.  
     Последовательные  файлы очень удобны в таких ситуациях с ба-
зой данных,  когда записи имеют  меняющуюся  длину.  Предположим, 
например, что список адресов выпускников имеет поле "примечания".  
У  некоторых  адресатов примечания могут занимать до 100 байт или 
более;  у других,  скорее даже у большинства,  их не будет вовсе.  
Последовательные  файлы легко справляются с этой задачей не тратя 
впустую пространство диска.  
     Используя Турбо Бейсик можно создавать последовательные фай-
лы двух типов:  1- последовательные файлы с разделенными  полями, 
где  все поля на каждой строке файла разделяются (ограничиваются) 
особыми  символами,  и  2-  неразделенные последовательные файлы, 
когда каждый файл выглядит абсолютно одинаково и на экране,  и на 
распечатке.  Эти два типа файлов создаются с  помощью  операторов 
WRITE# и PRINT#.  соответственно. Используйте INPUT#, INPUT$, или 
LINE INPUT# для обратного считывания информации с  последователь-
ного файла любого типа.  

     Последовательные файлы с разделенными полями.
     ---------------------------------------------
     Если рассмотреть последовательный файл, созданный Турбо Бей-
сиком,  вы  увидите,  что данные в файле разделены (разграничены) 
запятыми,  а строки заключены в кавычки - это  форма,  в  которой 
оператор  INPUT#  находит данные.  (Кавычки,  в которые заключены 
строки,  исключают путаницу  с  встроенными  запятыми.  Цифры  не 
заключаются в кавычки, так как записываются без запятых.) 
   Рассмотрите и выполните следующую программу: 

'Эта программа открывает последовательный файл для вывода. Она 
'записывает  пару  строк данных разного типа в файл, используя 
'оператор WRITE #. 

OPEN "SEQUENTI.BAS" FOR OUTPUT AS #1         'назначить файловую 
                                             'переменную #1 
StringVariable$ = "This is a string of text" 'определить несколь-
Integer% = 1000                              'ко переменных и 
FloatingPoint! = 30000.1234                  'инициализировать их 

'теперь запишите строку текста в последовательный файл 

WRITE# 1, StringVariable$, Integer%, FloatingPoint! 

StringVariable$ = "Another String" 
Integer% = -32767 
FloatingPoint! = 12345.54321 

'напишите еще одну строку текста 

WRITE# 1, Integer%, StringVariable$, FloatingPoint! 

CLOSE #1                                   'закрыть файловую 
                                           'переменную 

END                                        'закончить программу 


     Содержание файла SEQUENTI.BAS выглядит так: 

"This is a string of text", 1000,30000.123046875 
-32767, "Another String", 12345.54296875 

     Здесь важно отметить, что оператор WRITE# выводит информацию 
в последовательный файл в точно такой форме, в какой рассчитывает 
найти ее оператор INPUT#.  
     Следующая программа считывает последовательный файл, создан-
ный программой из последнего примера: 

'Данная программа открывает последовательный файл для ввода. Она 
'считывает пару строк данных разного типа из файла, используя 
'оператор INPUT#. 

OPEN "SEQUENTI,BAS" FOR INPUT AS #1       'назначить файловую 
                                          'переменную #1 

StringVariable$ = ""                      'определить несколько
Integer% = 0                              'переменных и 
FloatingPoint! = 0                        'инициализировать их 

'теперь считайте строку текста из последовательного файла 
INPUT # 1, StringVariable$, Integer%, FloatingPoint! 

PRINT StringVariable$, Integer%, FloatingPoint! 

StringVariable$ = "" 
Integer% = 0 
FloatingPoint! = 0 

'считайте еще одну строку текста 
INPUT # 1, StringVariable$, Integer%, FloatingPoint! 

PRINT StringVariable$, Integer%, FloatingPoint! 

CLOSE #1                                     'закрыть файловую 
                                             'переменную 
END                                          'закончить программу 

     Важно помнить, что программы, показанные в предыдущих приме-
рах  не будут правильно работать,  если для создания файла данных 
вы используете оператор PRINT#. Для создания файла, который будет 
читаться оператором INPUT#,  используйте не  оператор  PRINT#,  a 
оператор WRITE#.  

     Неразделенные последовательные файлы.
     -------------------------------------
     В неразделенных последовательных файлах данные выглядят оди- 
наково и при выводе на экран оператором PRINT и при распечатке на 

принтере с помощью оператора LPRINT. Можно применить произвольный  
параметр  USING  для  обеспечения вывода в последовательный файл, 
точно также, как Вы бы сделали для вывода на экран или принтер.  

     Рассмотрите и выполните следующую программу: 

'Эта программа открывает последовательный файл для ввода. Она 
'записывает пару строк данных разного типа в файл используя 
'операторы PRINT # и PRINT# USING 

OPEN "SEQUENTI.BAS" FOR OUTPUT AS #1          'назначить файловую 
                                              'переменную #1 

StringVariable$ = "This is a string of text" 'определить несколь-
Integer% = 1000                              'ко переменных и 
FloatingPoint! = 30000.1234                  'инициализировать их 

'теперь запишите строку текста в последовательный файл 
PRINT# 1, StringVariable$, Integer%, FloatingPoint! 

StringVariable$ = "Another String" 
Integer% = -32767 
FloatingPoint! = 12345.54321 

'напишите еще одну строку текста, но форматируйте ее с помощью
'USING 
 
PRINT# 1, USING "+##### & ##.##^^^^; Integer%, StringVariable$, 
FloatingPoint! 

CLOSE #1                                     'закрыть файловую 
                                             'переменную 

END                                          'закончить программу 

           Содержание файла SEQUENTI.BAS выглядит так: 

"This is a string of text"        1000        30000.123046875 
-32767, "Another String", 12.35E+03 

     Как  и в файлах с разделенными полями,  здесь важно отметить 
формат данных и каким  образом  их  можно  отсчитывать.  Если  Вы 
попытаетесь  использовать  тот же оператор INPUT#,  как во втором 
примере программы,  Турбо бейсик выдаст "ошибку при  выполнении", 
поскольку  прочитает  слово "This" в первой строке как символьную 
переменную и попытается прочитать следующие  два  слова  как  две 
численные переменные. Поэтому нужно использовать операторы INPUT$ 
или LINE INPUT# для чтения этой информации.  
     Следующая программа считывает последовательный файл, создан-
ный программой из последнего примера: 

'Данная программа открывает последовательный файл для ввода. Она 
'считывает пару строк данных разного типа из файла, используя 
'операторы LINE INPUT# или INPUT$. 

OPEN "SEQUENTI.BAS" FOR OUTPUT AS #1          'назначить файловую 
                                              'переменную #1 
StringVariable$ = "" 

'теперь считайте 80-знаковую строку текста из последнего файла 
StringVariable$ = INPUT$(80,1)  
PRINT StringVariable$ 

'введите всю строку ввода независимо от ее длины 
LINE INPUT# 1, StringVariable$  
PRINT StringVariable$ 
CLOSE #1               'закрыть файловую переменную 
END                    'закончить программу 

     Ниже приведены операторы и функции Турбо  Бейсика,  управля- 
ющие вводом/выводом последовательных файлов: 

----------------------------------------------------------------- 
Оператор/Функция           Операция 
----------------------------------------------------------------- 
 
CLOSE                      Прекращает работу с файлами 
EOF                        Дает сигнал по достижении конца файла 
INPUT#                     Считывает запись (строку текста) в
                           указанную(ые) переменную(ые) 
INPUT$                     Считывает n знаков в символьную перем. 
LINE INPUT#                Считывает всю строку в одну символьную
                           переменную 
OPEN                       Открывает файл для режимов INPUT,
                           OUTPUT, или APPEND, и присваивает ему
                           номер 
PRINT#, PRINT # USING      Пишет в файл как на принтер или экран 
WRITE                      Пишет разделенные запятыми данные в
                           файл 

----------------------------------------------------------------- 

     Файлы прямого доступа.
     ----------------------
     Файлы  прямого доступа состоят из записей,  доступ к которым 
возможен в любой последовательности.  Это  означает,  что  данные 
хранятся в том виде,  в каком они поступают в память,  тем  самым 
экономится время на обработку поскольку не нужна трансляция,  как 
при записи, так и при чтении файла. 
     Вообще,  файл прямого доступа более удобен для решения  раз- 
личных проблем базы данных,  чем последовательный файл, хотя и он 
не свободен от недостатков.  Во-первых,  файл прямого доступа  не 
очень хорошо "переносим".  Нельзя заглянуть внутрь такого файла с 
помощью  редактора  или  показать  его в читаемом виде на экране.  
Фактически, для перевода файла прямого доступа в другой компьютер  
или  на другой язык,  вероятно,  потребуется написать специальную 
программу-транслятор для считывания файла прямого доступа и выво- 
да текстового (последовательного) файла. Один из примеров пробле- 
мы "переносимости" наиболее впечатляющ.  Поскольку  Интерпритатор 
БЕЙСИК использует нестандартный формат фирмы Microsoft для значе- 
ний с плавающей запятой,  а в Турбо Бейсике для этой цели исполь- 
зуются  символы  по  стандарту IEEE (IEEE - Институт инженеров по 
электротехнике и радиоэлектронике), невозможно читать поля с пла- 
вающей запятой файлов прямого доступа,  созданных Интерпретатором 
БЕЙСИКа,  с  помощью  программ  Турбо  Бейсика,  и наоборот,  без 
дополнительной проработки.  
     Мы  предлагаем  четыре специальных функции для решения этого 
ребуса:  CVMS  и  CVMD  для превращения численных полей Microft -
форматов в обычне переменные Турбо Бейсика с одинарной и  двойной 
точностью;  а  также  MKMS$  и MKMD$ для превращения переменных с 
одинарной  и  двойной  точностью  с  строки   Microsoft-форматов, 
которые можно затем записать в файл.  
     Основное  преимущество  файлов  прямого  доступа  ясно из их 
названия: любая запись файла доступна в любой момент. Например, в 
базе данных о 23000 выпускников программа может  прямо  выйти  на 
запись 22709 или 11663 без чтения других записей.  Такое свойство 
делает эти программы наиболее  пригодными  при  создании  больших 
файлов,  и  предпочтительными  при  создании  малых,  особенно  с 
довольно длинными записями.  
     Файлы прямого  доступа  занимают  довольно  много  места  на 
диске,  поскольку  каждой записи выделяется место для максимально 
возможного размера поля.  Например,  включение 100-байтового поля 
примечаний  вызывает  увеличение каждой записи на 100 байт,  даже 
если оно использовано в одной записи из тысячи.  
     Но с другой стороны, если записи довольно велики и состоят в 
основном из чисел,  фйлы прямого доступа занимают меньше места по 
сравнению  с  последовательными.  В  файле прямого доступа каждое 

число одного типа (целое, длинное целое, с одинарной точностью, с 
двойной точностью) занимает  на  диске  одинаковое  пространство. 
Например,   каждое   следующее  значение  с  одинарной  точностью 
занимает 4 байта (такое же пространство они занимают в памяти): 

0 
1.660565E-27 
15000.1 
641 
623000000 

     В последовательных файлах,  напротив, числа занимают столько 
байт,  сколько в них ASCII символов  при  печати  плюс  один  для 
разделительной запятой, например: 

WRITE #1, 0;0 
занимает 3 байта, 

PRINT #1, 0;0 
занимает 6 байт, а 

PRINT #1.660565E-27 
занимает 13 байт. 

     Та  незначительная  "плата"  за  преимущество файлов прямого 
доступа заключается  в  небольшом  увеличении  объема  обработки, 
необходимой для ввода/вывода строк и чисел в/из формы,  в которой 
ими может оперировать программа файлов прямого доступа.  
     Вы можете создавать,  записывать и считывать  файлы  прямого 
доступа следующим образом: 

   1. ОТКРЫТЬ файлы и определить величину каждой записи. 

      OPEN filespec AS [#]fillenum LEN = record.size 

      Параметр LEN показывает Турбо Бейсику, что этот файл прямо- 
      го доступа.  В отличии от последовательного файла здесь  не 
      нужно указывать для чего открывается файл  - ввода или 
      вывода - так как можно одновременно  читать/писать  в  файл 
      прямого доступа.  

   2. Выполнить оператор FIELD для определения соответствия между 
      сериями символьных переменных (после этой операции они ста-  
    новятся "переменными полями") и "буфером файла".  

      FIELD filenum, width AS string-var [width AS string-var]...

      Этот буфер является загрузочным доком данных, которые будут 
      считаны или записаны именно в  этот  файл.  Оператор  FIELD 
      хотя  бы  один  раз  должен быть выполнен для данного файла 
      прямого доступа.  
 
   3. При  записи в файл используйте LSET  и  RSET  для  загрузки 
      переменных  поля  данными  для  записи.  Числа  должны быть 
      превращены  в  строковую  форму  соответствующей  фаункцией 
      "make"(например,  MKS$  для величины с одинарной точностью) 
      прежде чем использовать LSET и RSET. И наконец, используйте  
      PUT для выполнения записи в файл в указанном месте.  

   4. При  считывании записи с файла используйте оператор GET для 
      считывания нужной записи.  Затем загрузите строковые и чис-
      ленные переменные Вашей программы из соответствующих буфер-
      ных  переменных.   Прежде  чем   Вы   сможете   оперировать 
      численными  данными их нужно превратить из символьной формы 
      с помощью одной из функций "превращения" (например, CVS для 
      величин с одинарной точностью).  

   5. После завершения работы ЗАКРЫТЬ файл. 

     Ниже  перечислены  операторы  и   функции   Турбо   Бейсика, 
управляющие считыванием и записью в файле прямого доступа.  

-----------------------------------------------------------------
Оператор/Функция            Операция 
-----------------------------------------------------------------

CLOSE                     Закрыть файл 
CVI, CVL, CVS, CVD        Превращает переменную поля в соответ-
                          ствующий численный тип 
FIELD                     Определяет переменные поля 
GET                       Считывает запись 
LOC                       Определяет # последней читаемой записи
LSET, RSET                Назначается переменной поля 
MKI$, MKL$, MKS$, MKD$    Превращает определенные типы численных
                          величин в форму, которая может быть
                          назначена переменной поля 
MKMS$, MKMD$, CVMS, CVMD  Функции-трансляторы форматов Microsoft
OPEN                      Отрывает файл для прямого доступа 
PUT                       Осуществляет запись 
----------------------------------------------------------------- 

     А вот образец программы, изпользующий файлы прямого доступа: 

'программа для чтения базы данных "список рассылки" 
'пользователь вводит номер записи; программа показывает 
'все поля данной записи. 
'эта программа не может читать выше описанные последовательные 
'файлы. 
OPEN "ADDRESS.DTA" AS #1 LEN = 81    '"LEN = 81" показывает- это
                                     'файлы прямого доступа 

'определите расположение записей файла #1 
'отметьте использование символа длительности 
FIELD #1, 25 AS FileName$, 25 AS address$,_ 
          15 AS city$, 2 AS state$,_ 
           4 AS zip$, 2 AS class$, 8 AS contrib$ 

'zip$ длинное целое число, class$ целое число, contrib$ дей-
'ствительное двойной точности, 
'все они существуют в файле как строки. До считывания этих 
'численных полей необходимо превратить их обратно в числа. 

INPUT "Which record do you want to see:", recnamber 
GET #1, recnamber   'данные теперь в буфере файла 
PRINT "Data for record" recnamber 
PRINT "Name:" FileName$ 
PRINT "Address: " address$ 
PRINT "City/State/Zip: " city$, state$,CVL(zip$) 
PRINT "Class: " CVI(class$) 
PRINT "Most recent contrib:" CVL(contrib$) 

     ВНИМАНИЕ:  Никогда не присваивайте переменной поля; т.е.  не 
используйте переменную поля в левой части  оператора  присвоения.  
Присвоение  переменной  поля  отрывает переменную от назначенного 
буфера. Например, после 

zip$ = a$ 

переменная поля zip$ уже не относится к буферу, которому она была 
присвоена в операторе FIELD.  Использование LSET и RSET не вернет 
ее.  

     Двоичные файлы.
     ---------------
     Метод  двоичных файлов в Турбо Бейсике - это усовершнствова-
ние Интерпретируемого БЕЙСИКа,  позволяющие  относится  к  любому 
файлу как к нумерованной последовательности байтов, независимо от 

ASCII  символов,  противопоставления  численный-строковый,  длины 
записи,  символов "возврат каретки",  и  т.п.  При  использовании 
метода  двоичных  файлов  считывание и запись в файл производится 
простым указанием какие байты записать,  и где расположить  их  в 
файле.  Это  очень похоже на системные вызовы DOC (используемые в 
языке ассемблера) для чтения и записи файлов.  
     Но,  за гибкость всегда приходится платить.  ДВОИЧНЫЙ  режим 
работы с файлами предпологает,  что Вы сами принимаете решения по 
расположению  данных.  Это вероятно наиболее подходящий режим для 
работы с "чужими" файлами,  использующими не ASCII формат, напри- 
мер,  dBASE или Lotus 1-2-3 файлы.  Разумеется,  необходимо точно 
знать структура файла, прежде чем начать разбивать его на числа и 
строки, подходящие для Турбо Бейсика.  
     Любой файл, открываемый в ДВОЙЧНОМ режиме, содержит соответ- 
ствующий указатель позиции,  показывающий в файле место,  которое 
будет считываться или записываться следующим. Используется опера- 
тор SEEK для установки положения указателя,  а  функция  LOC  для 
чтения.  
     Доступ в двоичный файл осуществляется следующим образом: 

   1. ОТКРЫТЬ файл в ДВОИЧНОМ режиме. Не нужно указывать считыва- 
      ете Вы или записываете - можно делать и то,  и другое одно- 
      временно.  

   2. При  чтении  файла используйте SEEK для установки файлового 
      указателя на желаемый байт.  Затем с помощью  GET  считайте 
      определенное количество знаков (от 1 до 32767) и символьную  
      переменную.  

   3. При записи в файл загрузите символьную переменную информа-   
      цией, которую хотите записать. Затем с помощью PUT$ укажите   
      строковые данные и место в файле, куда она должна быть за-   
      писана. 

   4. Окончив работу ЗАКРЫТЬ файл. 

     Ниже перечисленны операторы и функции Тубро Бейсика, управ-   
     ляющие считыванием и записью двойчныех файлов.  

----------------------------------------------------------------- 
Оператор/Функция            Операция 
----------------------------------------------------------------- 
CLOSE                       Закрывает файл 
GET$                        Считывает определенное количество 
                            знаков начиная от указателя 
LOC                         Опредегяет положение указателя в  
                            файле 
LOF                         Показывает длину файла 
OPEN                        Открывает файл и определяет его как 
                            двоичный 
PUT$                        Записывает определенное количество 
                            байт, начиная от указателя 
SEEK                        Перемещает указатель 

----------------------------------------------------------------- 

     Устройства ввода/вывода.
     -----------------------
     Турбо  Бейсик  обеспечивает  так называемые файлы устройств; 
т.е.  рассматривает аппаратные средства -  такие  как клавиатура, 
дисплей и принтер - как последовательные файлы. Каждое обеспечи-   
ваемое устройство имеет резервированное файловое имя, оканчиваю-   
щееся двоеточием: 

----------------------------------------------------------------- 
Имя                Функция 
----------------------------------------------------------------- 
KYBD:              Клавиатура может быть открыта для ввода. Счи- 
                   тывание файла "KYBD:" сходно с использованием 
                   INKEY$. 
SCRN:              Экран может быть открыт для ввода. Запись в  
                   файл устройства "SCRN:" сходно с использова-    
                   нием PRINT. 

LPT1-3             Линейные принтеры от 1 до 3. 

COM1-2             Комуникационные порты от 1 до 2. 
----------------------------------------------------------------- 

   Например: 

OPEN "SCRN:" FOR OUTPUT AS #1, "Hello"  

производит тот же эффект, что и    

        PRINT "Hello", 
а 
       OPEN "KUBD:" FOR INPUT AS #1, a$, b$ 

то же, что 

       INPUT a$, b$ 

                             Графика.
                             --------                            
     Когда дело доходит до отображения информации на  экране  ге- 
нерируемая  Турбо Бейсиком программа должна работать в рамках ап-
паратного обеспечения имеющихся дисплеев.  Турбо Бейсик обеспечи-
вает  подобные типы видео-интерфейсов на персональных компьютерах 
и  совместимые:  Монохромный дисплейный адаптер,  воспроизводящий 
только один цвет; Цветной графический адаптер и Усовершенствован- 
ный графический адаптер,  способные воспроизводить графику и тек- 
сты как цветные, так и черно-белые; Многоцветный графический ада- 
птер массивов,  работающий на  ИБМовской  Персональной  системе/2 
Модель 30;  и Графический видео-адаптер,  работающий на ИБМовской 
Персональной Системе/2 Модели 30,50,60, и 80 (Таблица 4-5).  
     Соответственно  уровню  этих  видео-устройств  Турбо  Бейсик 
может выбрать любой текстовый или  графический  режим  с  помощью 
операторов SCREEN и/или WIDTH.  

Таблица 4-5     Характеристики графических адаптеров 
-----------------------------------------------------------------
Адаптер  Режим экрана     Формат текста         Примечания 
-----------------------------------------------------------------
Монохром 0                80 знаков      80*225 знаков, с 4 атри- 
                                         бутами (нормальный, под- 
                                         светкка, мигающий и под- 
                                         черкивание.) 

ЦГА      0,1,2            40/80 знаков   До 16 цветов ( только в
                                         текстовом режиме);до 4 -
                                         в графическом.Разрешение
                                         экрана: 640*200). 

УГА      0,1,2,7,8,9,10   40/80 знаков   Разрешение экран: 640 *
                                         350. До 16 цветов из 64-
                                         цветной палитры (в зави-
                                         симости от памяти). 

МГАМ     0,1,2,11         40/80 знаков   АЦГ с разрешением экрана
                                         640*480; черно-белый в
                                         режиме 11. 
-----------------------------------------------------------------

Таблица 4-5     Характеристики графических адаптеров (продлжение)
-----------------------------------------------------------------
Адаптер  Режим экрана     Формат текста         Примечания 
-----------------------------------------------------------------
ГВА      0,1,2,7,8,9,10   40/80 знаков   УГА и МГАМ с разрешением
         11,12                           экрана 640*480; до 16
                                         цветов в режиме 12. 

ЦГА  (CGA)      = Цветной графический адаптер 
УГА  (EGA)      = Усовершенствованный графический адаптер 
МГАМ (MCGA)     = Многоцветный графический адаптер массивов 
ГВА  (VGA)      = Графический видео-адаптер 
-----------------------------------------------------------------

                         Текстовые режимы.
                         -----------------
     В  80-знаковом  текстовом  режиме  (единственно  возможном в 
Монохромном дисплейном адаптере),  экран состоит из 25 строк,  по 
80 знаков в каждой, пронумерованных от 1 до 25 (сверху вниз) и от 
1  до  80  (слева  направо).  В  40-знаковом  текстовом режиме (в 
адаптерах ЦГА/УГА) экран  состоит  из  25  строк  по  40  знаков. 
Знаковая позиция в каждой строке может быть занята любым символом 
из списка, приведенного в примечании F.  
     В  общем,  знаки помещаются на экран передвижением курсора в 
желаемое  место  с  помощью  оператора  LOCATE,  a  затем  PRINT.  
Экзотические  символы,  которые трудно генерировать с клавиатуры, 
можно сделать с помощью функции SHR$ (См. Приложение F).  
     25-я  (нижняя)  строка экрана заслуживает особого рассмотре- 
ния:  оператор KEY загружает ее описанием клавишей функций,  т.н.  
програмируемых  клавишей.  Для защиты этих описаний,  25-я строка 
никогда не "прокручивается" и  в  нее  ничего  не  пишется,  если 
только не выключить "дисплей клавишей функций" с помощью KEY OFF.  
     В  монохромных адаптерах,  оператор COLOR можно использовать 
для   создания   спецэффектов,    например,    негативного    или 
"приглушенного" изображения,  подчеркивания и/или мигания текста. 
В  адаптерах  ЦГА/УГА  оператор  COLOR  используется  для  выбора 
текущего цвета отображаемых данных, выводимвх оператором PRINT.  
     В  текстовом  режиме  адаптеры  ЦГА/УГА отображают до восьми 
дисплейных "страниц";  обрабатываемая и/или отображаемая страница 
задается оператором SCREEN.  

                        Графические режимы.
                        -------------------
     Турбо  Бейсик  содержит  полный  набор команд для построения 
цветных точечных и линейных  графиков,  графических  символов  на 
экране.  Но, если у Вас нет соответствующего аппаратного дисплей- 
ного обеспечения,  такого как ЦГА-УГА или аналогичного,  все  эти 
команды не будут функционировать правильно.  Попытка использовать 
графические команды на "только текстовом"  оборудовании  вызывает 
появление сообщения об ошибке "Неверный Вызов Функции".
     В графических режимах  экран  рассматривается  как  матрица, 
состоящая из маленьких точек,  или растровых элементов, каждый из 
которых может быть включен (белый или иной  цвет),  или  выключен 
(цвет  фона,  обычно черный).  Точки определяются по их положению 
(x,y) в матрице;  исходное положение по умолчанию - левый верхний 
угол экрана. Значение x представляют расстояние по горизонтальной 
оси  от  левого  края  экрана,  а  y - расстояние по вертикали от 
верхней  границы  экрана.   Заметьте,   что  данное   обозначение 
отличается   от   обычных  декартовых  координат,   гда  значение 
уменьшается по оси сверху вниз.  
     В  зависимости  от  избранного  режима (и вероятно от объема 
"видео"-памяти), разрешение по горизонтали может быть 320 или 640 
точек,  а по вертикали - 200 или 350.  Эта комбинация  определяет 
также и максимальное число возможных цыетов (2/4/16), равно как и 
максимальное  число  видео-"страниц" (1/2/4/8).  Отсчет растровых 
точек начинается с нуля,  в отличие от счета текстовых строк  или 
знаков (колонок), который начинается с единицы.  
     Каждая   растровая   точка  имеет  соответствующее  цветовое 

значение (или атрибут), от 0 до максимального для данного режима.  
Результирующий цвет для каждого значения управляется  операторами 
SOLOR и PALETTE.  

     Последнее указание точки.
     -------------------------
     После    большинства   графических   операций   воображаемая 
карандашная точка привязывается к x,y координате на  экране.  Это 
положение  "карандаша" называется Последней Опорной  Точкой (Last 
Point Referenced) или ПОТ (LPR).  При первом вызове  графического 
режима оператором SCREEN, ПОТ устанавливается в центре экрана.  
     Некоторые  графические команды способны воспринимать ПОТ как 
координатный аргумент.  Например,  если  оператором  LINE  задана 
только  одна  точка  назначения,  то линия проводится между ПОТ и 
указанной  точкой.   В  дальнейшем  ПОТ  будет  являться   точкой 
назначения.  

     Абсолютные и относительные координаты.
     --------------------------------------
     Большинство  графопостроительных  операторов  Турбо  Бейсика 
могут давать координаты как в относительной,  так и в  абсолютной 
форме.  
     В абсолютной форме координатная пара (x,y) точно определяет, 
где произвести операцию; например, PSET(50,75) включает растровую 
точку  на  расстоянии  50  точек от левого края экрана и 75 точек 
сверху.  
     В относительной форме координата  определяется  относительно 
ПОТ, и представляет собой величину горизонтального или вертикаль- 
ного смещения относительно ПОТ.  В этой форме использовано ключе- 
вое слово STEP для того,  чтобы отличить ее от стандартных  абсо-
лютных координат. Например, если ПОТ (60,75): 

PSET(10,20) 

определяет точку (10,20), то 

PSET STEP (10,20) 

определяет точку  (70,95),  на  10  правее  и  на  20  ниже  ПОТ.  
Отрицательное  относительное значение координаты определяет точку 
выше и левее ПОТ.  

     Смена координат экрана.
     -----------------------
     Если  Вас  устраивает  такая система адресации,  используйте 
оператор WINDOW для смены управления соответствием  между  парами 
(x,y)  данными  в  графопостроительных  операторах  и  точками на 
экране.  Например: 

WINDOW (-1,1)-(1-1) 

меняет координаты экрана,  приближая их  к  декартовой  плоскости 
аналитической   геометрии,   с   начальным  адресом  посредине  и 
возрастанием значения у  вверх  по  оси.  После  этого  оператора 
WINDOW,PSET(0,0)  включает  физическую растровую точку (100,160), 
PSET(-1,-1)  -  крайнюю  левую   точку   в   нижней   строке,   а 
PSET(0.5,0.5)  -  физическую  растровую  точку  (220,50) в центре 
правого верхнего квадрата.  
     Оператор VIEW позворляет Вам  создавать  активную  (текущую) 
облать,   или  "окно",   на  графическом  дисплее,  и  по  выбору 
определять координаты, соответствующие верхнему левому углу окна.  
Оперировать точками вне окна невозможно.  

      Г        Л        А        В        А               5 
----------------------------------------------------------------- 

                 Справочный каталог ТУРБО БЕЙСИКа.
                 --------------------------------- 

     200 с лишним команд ТУРБО БЕЙСИКа  по  обоим  синтаксическим 
признакам делятся на функции,  операторы,  системные переменные и 
метаоператоры.  
     Функции (предопределенные, в отличии от определяемых пользо- 
вателем) возвращают значение и поэтому  должны  использоваться  в 
рамках   выражений.   Большинство  их  требует  одного  или  двух 
аргументов, например: 

t = COS(3.1)         'числовая функция w/ 1 числовой аргумент  

ts = LEFTS("Cat",2)  'символьная  функция  w/ 1 символьный и 1 
                     'числовой аргумет 

     Операторы  представляют  собой неделимые строительные блоки, 
которые  составляют  программы.  Операторы  появляются  в  строке 
самостоятельно или с ограничительными двоеточиями между соседними 
операторами; например: 

SIRCLE (160,000), 50 ' начертить круг CALL 

MySub  (x,y,z)  ' вызвать процедуру а = а + 1 ' выполнить задание 
                                                (см.оператор LET) 

     Системные  переменные являются предопределенными идентифика- 
торами доступа и управления определенной  системной  информацией, 
например: 

aS = DATES ' читать системные данные 

TIMES = "00:00"  ' установить системное время 

     Метаоператоры   представляют  собой  директивы  компилятора. 
Строго говоря,  они не являются  частью  языка,  а  оперируют  на 
другом уровне, управляя действиями компилятора, например: 

SINCLUDE "module1.tbs"   ' загрузить и обрабатывать файл 

SSTACK &H1000            ' установить об'ем стека 

     Метаоператоры,    как   и   переключатели   субменю   Optios 
компилятора,  скорее управляют компилятором во время  компиляции, 
чем   компилятором   во   время   выполнения   программы.   Перед 
метаоператорами ставится знак доллара ($),  чтобы отличить их  от 
обычных операторов. В строке может быть только один метаоператор, 
и, в отличии от некоторых других компилированных БЕЙСИКов, они не 
помещаются внутри комментариев (REM).  


                         ФОРМАТ КАТАЛОГА.
                         ----------------
     Каждая статья в каталоге содержит описание, синтаксис, общие 
замечания   и   пример   использования  оператора,   функции  или 
процедуры.  В случае  необходимости  для  связанных  между  собой 
статей  дается  перекрестная  ссылка,  определяются ограничения в 
использовании,  отличаются различия в использовании  элементов  в 
ТУРБО БЕЙСИКе и Интерпретаторе БЕЙСИК.  

     Ниже  приводятся  условные  обозначения описания синтаксиса, 
используемые в алфавитном командном справочнике.  

численное выражение 

     Численная  константа,   численная  функция   или   численная 
переменная,  или  их  сочетание  с использованием апифметических, 
логических  и  реляционных  операторов.   В   некоторых   случаях 
описывается тип численного выражения,  например,  целое выражение
(integer expression). 
     Пример:

16 
х 
16 * х 
SIN(3.14159) 
SIN(x /(16 * x)) 

символьное выражение 

     Символьная константа,  символьная переменная или  символьная 
функция,  или  их сочетание с факультативным включением оператора 
конкатенации, значка "плюс" (+). 
     Например: 

"Cat" 
aS + "Cat" 
LEFTS(aS + "Cat",4) 

filesrec (спецификация файла) 

     Символьное выражение,  описывающее имя файла MS-DOS  (восемь 
знаков с необязательным трехзначным добавлением с  предшествующей 
точкой,  регистр  любой),  возможно  включая  описание накопителя 
и/или ветви программы.  Имена файлов  должны  быть  выражены  как 
символьные  переменные  или  заключены в кавычки,  за исключением 
случаев, о которых уже говорилось, например: 

"MYFIRST.BAS" 
"turbobas\myfirst.bas" 
"a:\tyrbobas\myfirst.bas" 

ветвь 

     Символьное выражение, описывающее действительный подсправоч-
ник на зарегистрированном накопителе. Например: 

"\TURBOBAS" 
"GAMES" 

LPR (ПОТ) 

     "Последняя  опорная  точка"  используется  как   имплицитная 
координатная  величина  в  некоторых  операциях  вычеркивания,  и 
устанавливается большинством графических операторов.  

метка 

     Метка представляет собой либо буквенно-цифолвуё метку,  либо 
номер  строки  идентифицирующий строку программы.  Номера строк и 
метки более или менее взаимозаменяемы в синтаксисе ТУРБО БЕЙСИКа, 
за  исключением  того,  что  метки  должны  появляться  в  строке 
самостоятельно.   

                              ШРИФТ. 
                              ------
     Обычный шрифт указывает зоны в пределах команд, которые дол- 
жны быть заполнены специальной информацией прикладного характера, 
например: 

REG  регистр, величина 

     Текст  с прописными буквами обозначает часть команды которая 
должна быть передана дословно, например: 

RESUME NEXT 

     Скобки ([ ]) означает,  что  заключенная  в  них  информация 
необязательна, например: 

OPEN  спецификация файла AS [ ] номер файла 

означает, что  вы можете вставить номерной знак (#) перед номером
файла  в  операторе  OPEN,  а  можете и опустить его. Поэтому оба
следующих варианта допустимы: 

OPEN "cust.dta" AS 1 
OPEN "cust.dta" AS #1 

     Фигурные скобки ({ }) указывают  на  выбор  двух  или  более 
вариантов,  один  из  которых  должен быть использован.  Варианты 
отделяются друг от друга косой чертой (/). Например: 

KEY {ON/OFF} 

означает,  что  и  KEY  ON  и  KEY  OFF  являются действительными 
операторами, а KEY, взятый отдельно, не является таковым.  

     Многоточие (...) указывает на то,  что часть  команды  может 
быть  повторена  необходимое  количество  раз.   Например:   

READ переменная [,переменная]...  

означает, что множественные переменные,  отделенные друг от друга 
запятыми, могут быть обработаны одним оператором READ: 

READ aS 
READ aS, bS, a, b, s 

     Три  вертикально  расположенные  точки указывают на опущение 
одной или более строк текста программы, например: 

FOR n = 1 to 10 
    . 
    . 
    . 
NEXT n 

                        МЕТАОПЕРАТОР  $COM 
-----------------------------------------------------------------
Назначение        $COM определяет место для буфера порта с после-
                  довательным приёмом данных 

Синтаксис         #COMn size 

Комментарий       n указывает на коммуникационный адптер (1или2),
                  а size представляет собой  целочисленную  конс-
                  танту, определяющую  ёмкость буфера этого адап-
                  тера (0 до 32, 767), 256 по умолчанию. Значение
                  по умолчанию  может быть установлено и записано
                  в меню Options.  Значения  по  умолчанию  могут
                  быть заменены метаоператорами в коде. 
              
Ограничения       Емкость буфера, описанная в метаоператоре  #COM
                  должна  быть в пределах от 0 до 32, 767. Интер-
                  претатор БЕЙСИК  предоставит  буфер  такого  же
                  размера для обоих коммуникативных  портов, если
                  они существуют. В  ТУРБО БЕЙСИКе  размеры  этих
                  двух буферов устанавливаются независимо. 
Различия          Эта функциональность возможна  только через ко-
                  мандно-строчные параметры в случае  интерпрета-
                  тора БЕЙСИК. 
              
Пример            'метаоператор $COM используется  для  изменения
                  'пространства по умолчанию, определенного буфе-
                  'рам портов с последовательным примом данных
                  'устаносить программу обработки ввода COM

                  $COM 1024  ' установить буфер ввода 1К          
        ON COM(1) GOSUB GetComInput 
                  COM(1) ON  ' включить обработку ввода COM 
         OPEN "COM1:" AS #1  ' открыть переменную файла как COM1 

  PRINT  "Нажмите  любую  клавишу  для  окончания программы..." 

                                     'пока клавиша еще не нажата 
                   WHILE NOT INSTANT 
                      LOCATE 2,1 
                      PRINT TIME       'вывести время на экран 
                   WEND 
                   END                 ' закончить программу 
              GetComInput: ' обработать прерывание порта COM
                           'очистить ввод с буфера порта COM 
                      INPUT# 1,ComPortInput$ 
                      RETURN 

                      Метаоператор $DYNAMIC 
-----------------------------------------------------------------
Назначение        $DYNAMIC об'являет определение массива по умол-
                  чанию динамическим. 

Синтаксис         $DYNAMIC 

Комментарий       Метаоператор $DYNAMIC не принимает никаких ар-
                  гументов и об'являет тип  определения  массива
                  по умолчанию динамичным. 
                  Пространство для динамичных массивов выделяет-
                  ся во время прогона. Для освобождения  массива
                  можно использовать оператор  ERESE. Динамичные
                  массивы обеспечивают более эффективное исполь-
                  зование памяти. 
                  Массивы можно также об'явить динамичными,  ис-
                  пользуя дескриптор DYNAMIC или аргументы выра-
                  жения в операторе DIM. Массивы с изменяющимися
                  размерами, которые об'являются  общими или ло-
                  кальными к процедуре  или функции всегда дина-
                  мичны. 

См.также          DIM   ERASE  FRE   $STATIC 

Пример             $DYNAMIC 
                   ' установить программу обработки ошибок 
                   ON ERROR GOTO ErrorHandler 

                   ' индицировать память в массиве 
                   PRINT FRE(-1) 

                   DIM BigArray(10000) ' об'явить динамичный мас-
                                         сив 
                   BigArray(6666) = 66 ' присвоить данные 
                   ' индицировать память в массиве 
                   PRINT FRE(-1) 

                  ' ошибка прогона возвращается, если прогон осу-
                  ' ществляется с контролем границ 
                  PRINT BigArray(6666) 

                  END           ' закончить программу 

                   ErrorHandler:
                      PRINT "Ошибка типа" ERR; 
                      PRINT "произошла по адресу" ERADR 
                      END 

                       Метаоператор $EVENT 
-----------------------------------------------------------------
Назначение        $EVENT управляет генерацией кода со срабатыва-
                  нием ловушки. 

Синтаксис         $EVENT{ON OFF} 

Примечание        Если ваша  программа включает любое  срабатыва-
                  ние  ловушек  (например,  ON KEY,  ON COM),  то
                  $EVENT срабатывает по умолчанию на ON, а компи-
                  лятор генерирует  код с контролем  результата в
                  промежутках между каждым оператором вашей прог-
                  раммы. Если ваша программа не организует  лову-
                  шек, тогда метаоператор $EVENT  находится в по-
                  ложении OFF и не генерирует код с контролем ре-
                  рультата. 
                  Метаоператор $EVENT дает вам возможность управ-
                  лять тем, какие  части  вашей  программы  будут
                  контролировать результат. Если существует зона,
                  где максимальная скорость более важна чем быст-
                  рое ответное действие, тогда  вначале  и  конце
                  поместите метаоператоры $EVENT OFF и $EVENT ON.

Примеры           'EVENT пример 
                  ON TIMER (1) GOSUB WasteTime 
                  TIMER ON 

                  PRINT "Медленная цепь" 
                  x = timer
               FOR i = 1 TO 10000 
                     i = i + i - i 
              NEXT i 
                   y = timer 
                   PRINT "время цепи -" y-x 

                   $EVENT OFF 

                   PRINT "выстрая цепь" 
                   x = timer 
             FOR i = 1 TO 10000 
                   i = i + i - i 
             NEXT i 
                   y = timer 
                   PRINT "время цепи -" y-x 

                   END 
                   WasteTime: 

            FOR j = 1 TO 10000 : j = j + j - j : NEXT j : PRINT
           
                    RETURN 






