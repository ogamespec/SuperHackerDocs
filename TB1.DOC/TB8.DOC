                         Функция ENVIRON$
-----------------------------------------------------------------
Назначение  Функция ENVIRON$ отыскивает параметры таблицы среды.  
 
Синтаксис   s$ = ENVIRON$ (parameter string)
            s$ = ENVIRON$ (n)
 
Комментарий    parameter string - это символьное  выражение,  со-
            держащее отыскиваемые параметры;
               n - это целочисленное выражение в диапазоне  от  1  
            до  255.  
               Функция   ENVIRON$   и   соответствующий  оператор 
            ENVIRON используются для конфигурации среды,  которая 
            переходит к программам,  выполняемым  через  оператор 
            SHELL  (подробнее  см.  статью  об  операторе SHELL в 
            настоящем руководстве и о команде SET  в  справочнике 
            DOS).  
               Если  используется  символьный  аргумент,  функция 
            ENVIRON$ возвращает текст, следующий за строкой пара- 
            метра в таблице среды. Заметьте, что функция ENVIRON$ 
            различает прописные и строчные буквы. Если строка па- 
            раметра отсутствует или после знака равенства нет ни- 
            какого текста, возвращается нулевая строка.  
               Если используеться численный вид, функция ENVIRON$ 
            возвращает строку, содержащую n-ный параметр с начала 
            таблицы.  Если n-го параметра нет, возвращается нуле- 
            вая строка.  

Пример      См. пример в статье ENVIRON
 
                           Функция  EOF
-----------------------------------------------------------------
Назначение  Функция EOF возвращает статус "конец файла".  
 
Синтаксис   Y = EOF (filenum)
 
Комментарий    filenum - это значение, описанное при открытии 
            файла (OPEN).  
               EOF  возвращает TRUE (-1),  если в указанном файле 
            достигнут "конец файла";  в противном случае, возвра- 
            щается FALSE (0).  Фуекция EOF  действительна  только 
            для  дисковых файлов,  открытых для последовательного 
            ввода и для коммуникационных файлов. Возврат EOF -1 в 
            случае коммуникационного файла  означает,  что  буфер 
            пустой.  

Пример      Следующий пример считывает информацию с TEXT.DTA пос- 
            ледовательного  файла  до  тех  пор,  пока  не  будет 
            достигнут конец файла: 

              OPEN "TEXT DTA" FOR INPUT AS #1
            top:
                 IF EOF (1) THEN
              PRINT c "records (lines) in file TEXT.DTA"
                 END IF
              INPUT #1, dummy$
              c = c + 1
            GOTO top
   
           или более элегантно:

            OPEN "TEXT.DTA" FOR INPUT AS #1
            WHILE NOT EOF (1)
              INPUT #1, dummy$
              INCR c
            WEND
            PRINT c "records (lines) in file TEXT.DTA" : END
 
                          Функция ERADR
-----------------------------------------------------------------
Назначение  ERADR возвращает адрес самой последней ошибки.
 
Синтаксис   Y = ERADR
  
Комментарий    Функция  ERADR  возвращает  длинное  целочисленное 
            значение,  представляющее  местонахождение самой пос-
            ледней  ошибки.  ERADR  -  это  то  же самое значение 
            счетчика программы, которое было бы напечатано в слу- 
            чае,  если бы не была выполнена  ловушка  ошибок  (то 
            есть, может быть использовано выбором ошибки выполне- 
            ние  меню  Options  для нахождения положения исходной 
            программы оператора, генерирующего ошибку).  
               ERADR используется в качестве последнего обращения 
            в программах с ошибками из-за  неправильного  обраще- 
            ния. Если программа с ошибкой не имеет плана обработ- 
            ки  конкретной ошибки,  можно по крайней мере вывести 
            код ошибки (ERR) и ERADR  на  экран  и  дать  команду 
            сообщать пользователю о ее наличии.  

См.также    ERL     ERR     ERROR    ON ERROR

Пример      ON ERROR GOTO Trap 'установите обработку ошибки 
                               'выполнения
            DIM X%(10)
            FOR I% = 1 TO 10
              READ X%(I%)    'считайте X 10 раз
              PRINT X%(I%)   'только с семью данными
            NEXT I%          'возвращает ошибку вне данных

            'недостаточное количество доступных элементов данных

            DATA 1,2,3,4,5,6,7
            END              'закончить программу

              Следующая программа обработки ошибок печатает номер 
            ошибки (ERR) и адрес (ADD).

          ON ERROR COTO Trap  'при ошибке обратиться к процедуре
                              'Trap -  обработка ошибки 
 
            Trap:
              LOCATE 10,15
            'напечатать сообщение в середине экрана
      PRINT  "An error of type " ERR " has occurred at address"
            ERADR
            LOCATE 11,15
          PRINT "Please note these values and check your manual"
            END              'закончить программу
 
                          Оператор ERASE
-----------------------------------------------------------------
Назначение  Оператор ERASE стирает динамические массивы и восста-
            навливает статические массивы.

Синтаксис   ERASE array name [,array name]...
 
Комментарий    array name -  это имя массива, который  вы  хотите 
            восстановить или переместить.  Заметьте, что с именем 
            массива не должны использоваться пустые скобки.  
              Если имя массива динамическое,  его пространство  в 
            памяти  освобождается  и  имя  массива затем задается 
            вновь с помощью нового оператора DIM.  
              Если  имя  массива  статическое,  стирание  (ERASE) 
            просто  очищает  его  элементы  до  0 (или до нулевой 
            строки для символьных массивов).  

Ограничения    Невозможно стереть (ERASE)  несуществующий  массив 
            или  в  случае динамических массивов массив,  который 
            уже был стерт.  
 
Различия       В ТУРБО БЕЙСИКе статические массивы обрабатываются 
            быстрее динамических массивов.  Интерпретатор  БЕЙСИК 
            работает только с динамическими массивами.  

См.также    CLEAR   DIM  $DYNAMIC   FRE   $STATIC
 
Пример      ON ERROR GOTO ErrorHandler 'установить программу
            PRINT FRE(-1)      'показать доступное простран-
                               'ство массива
                               'обьявить динамический массив,
                               'присвоить ему данные и показать 
                               'доступное пространство массива
            DIM DYNAMIC BigArray(1000)
            BigArray(6666) = 66
            PRINT FRE(-1)
            ERASE BigArray  'переместить динамический массив
            PRINT FRE(-1)   'показать доступное пространство массива
                     'Данный оператор возвратит ошибку выполнения,
                     'если программа вывполняется с проверкой границ.
            PRINT BigArray(6666)
            END             'закончить программу
            ErrorHandler:
            PRINT "An error of type" ERR
            PRINT "has occurred at address" ERADR
            END
 
                       Функции ERDEV, ERDEV$
-----------------------------------------------------------------
Назначение     Функции ERDEV и ERDEV$ возвращают информацию зада-
               ющего  устройства (драйвера).

Синтаксис      Y = ERDEV
               Y$= ERDEV$
 
Комментарий    Когда происходит ошибка в устройстве, целочислен-
            ная  функция ERDEV возвращает инфоромацию об ошибке в 
            наименее значимый байт. Этот байт представляет ошибку 
            кода  INT  24   Наиболее   значимый   байт   включает 
            15,14,13,3,2,1 и 0 биты аттрибута слова устройства.  
              Функция ERDEV  содержит  имя  3  байтов  устройств, 
            предназначенных  для  знаковых  устройств  и  2 - для 
            блочных устройств  (Более  подробно  см.  Техническое 
            руководство- справочник IBM DOS) 

Пример                        'установить обработку ошибок
            ON ERROR GOTO ErrorHandler
            PRINT "Open the door to drive A and press any key..."
            WHILE NOT INSTAT : WEND   'подождать клавишу
                'попытайтесь получить каталог
            FILES "A:\*.*"
                     END           'закончить программу

       ErrorHandle      'программа обработки критических ошибок
                        'показать сообщение об ошибке с указанием
                        'проблемы и источника
            PRINT USING "Critical error ## occurred with &";
                         ERDEV,ERDEV$
            RESUME NEXT
 
                         Функции ERL,ERR
-----------------------------------------------------------------
Назначение     Функции ERL и ERR возврвщают строку  и  код  самой
               последней ошибки.

Синтаксис      Y = ERL      Y = ERR

Комментарий    ERL возвращает номер строки последней ошибки. Если
            ошибка происходит в операторе без номера строки,  ERL 
            возвращает номер ближайшей строки с номером, оперируя 
            в обратном порядке по направлению к началу программы.  
            Если  между  местом  ошибки  и  началом программы нет 
            пронумерованных строк, ERL возвращает 0.  
               Функция  ERR возвращает  номер  последней   ошибки 
            выполнения.  Проверьте ее в программах ловушки ошибок 
            для выполнения кода, соответствующего типу ошибки.  

Примечание     Операторы  ERL,  RESOME  и  RESUME  NEXT  вызывают
            генерирование  компилятором  4-байтового пойнтера для 
            каждого оператора в программе.  
               Это должны  учитывать  программисты,  для  которых 
            важен  размер их генерированного кода.  Использование 
            оператора RESUME  [строка  #]  генерирует  инструкцию 
            одной   операции   перехода.   Обычно,   функция  ERL 
            используется при отладке программ.  
 
Различия       Правила,  касающиеся того на какой стороне реляци-
            онного  оператора  должен  находиться  номер  строки, 
            сопоставляемой  с  функцией  ERL,  неприемлемы.   Это 
            происходит потому, что в Турбо Бейсике нет инcтрукции 
            RENUM.  В Турбо Бейсике также не  применим  результат 
            функции  ERL  интерпритатора Бейсик, когда происходит 
            ошибка во время  выполнения  оператора  DIRECT  MODE.  

См. также   ERARD   ERROR    ON ERROR
 
Пример     'установить обработку ошибки выполнения

            ON ERROR GOTO Trap
            
            DIM X% (10)

            FOR I% = 1 TO 10
            40 READ X% (I%)  'считать X 10 раз
               PRINT X% (I%) 'только с данными Y
            NEXT I%          'возвращает ошибку вне данных
            'недостаточное количество элементов данных
            70 DATA 1,2,3,4,5,6,7
            80 END 'закончить программу
            90 Trap:
          IF  ERL=40 THEN
            RESTORE
            RESUME
          ELSE
                 PRINT "Unknown Error" : END
                       "Неизвестная ошибка"
            END IF

                          Оператор ERROR
-----------------------------------------------------------------
Назначение  Оператор ERROR формирует ошибку выполнения

Синтаксис   ERROR errcode

Комментарий     errcode есть целочисленное выражение от 0 до 255.
            Если  errcode  является предопределенным кодом ошибки 
            выполнения (см.  приложение Е),  тогда оператор ERROR 
            вызывает  такое  поведение  вашей  программы,  как  в 
            случае появления  ошибки.  Это  способствует  отладке 
            программ,  ловушке  ошибок.   Для  определения  ваших 
            кодов ошибок используйте значения errcode, которые не 
            используются Турбо Бейсиком.  Если вы  не  определите 
            процедуру  обработки  ошибок этих новых кодов ошибок, 
            Турбо Бейсик выдаст сообщение:  Error n  at  pgm-ctr: 
            address, где n - это код ошибки, а address - значения 
            в  счетчике  программы  процессора во время появления 
            ошибки.  
Пример
            'Форсировать ошибку неправильного вызова
            'функции из-за плохого ввода
            
            DEF FN func%= (X%)
            IF X% > 65 THEN
         ERROR 5     'вызвать ошибку неправильного вызова функции
            ELSE
              FNfunc%= X%*1000
              END IF
            END DEF

         PRINT FN func(66)  'вызвать ошибку неправильного вызова
                            'функции

                          Оператор EXIT
-----------------------------------------------------------------
Назначение  Оператор EXIT преждевременно оставляет структуру.

Синтаксис   EXIT {SELECT/DEF/FOR/IF/LOOP/SUB}

Комментарий    Оператор EXIT дает вам возможность выйти из cтрук- 
            турного оператора,  процедуры или  определения  функ- 
            ции, не выполнив их до конца.  Тип структуры, к кото- 
            рой  применен оператор EXIT,  должен быть включен как 
            часть оператора EXIT, в соответствии со следующим: 

-----------------------------------------------------------------
       Вариант EXIT           Выходная структура
-----------------------------------------------------------------
       SELECT                 оператор SELECT
       DEF                    определение функции
       FOR                    петля FOR/NEXT
       IF                     блок IF
       LOOP                   петля DO/LOOP или WHILE/WEND
       SUB                    определение процедуры
--------------------------------------------------------------------------

            Использование   EXIT   может   спасти   беспорядочные 
            операторы GOTO.  

Ограничения    Используя оператор EXIT для выхода из функции,  вы 
            должны назначить этой функции результат до выполнения 
            оператора EXIT.  

Пример      'Данная программа демонстрирует все операторы EXIT.
            'Для терминирования выполнения используется как процедура
            'так и функция. Подпрограммы также демонстрируют различные
            'доступные операторы EXIT, используя конструкции LOOP
            'на ряду с SELECT CASE и IF THEN ELSE.

            SUB Controls(Se I%, Dummy %)

            'Операторы EXIT могут использоваться для терминирования
            'конструкции SELECT CASE и IF THEN ELSE.
            'EXIT также терминирует выполнение процедуры

            SELECT CASE Se I%
         CASE 1
            'Используйте выбирающий оператор для передачи пользователю
            'информации о введенном числе
            SELECT CASE Dummy%
            CASE < 0
            PRINT "Number is less the zero"
            'вывести оператор выбора
            EXIT SELECT
            CASE > 0
            PRINT "Number is greater then zero"
            'вывести оператор выбора
            EXIT SELECT
            CASE ELSE
            PRINT "Number is 0"
            END SELECT
            EXIT SUB    'вывести процедуру
         CASE 2
            'исползуйте IF THEN ELSE для выполнения того, что
            'делает SELECT CASE
         IF Dummy % < 0 THEN
            PRINT "Number is less then zero"
         EXIT IF
            ELSE IF Dummy % > 0 THEN
            PRINT  "Number is greated then zero"

         EXIT IF   'вывести если, тогда
            ELSE
            PRINT "NUMBER IS 0"
            END IF
            END SELECT
            PRINT "You selected number 2"
            END SUB
            DEF FN Loops (Set%)
      'Параметр, переходящий к функции указывает, какой EXIT
      'будет выполнен. Каждая структура петли делает то же самое
      'чтобы продемонстрировать как оператор EXIT может быть
      'использован для завершения выполнения петли.
      'Мы также демонстрируем как EXIT может использоваться для
      'вывода функции. EXIT DEF используется для выполнения EXIT
      'из двух первых отборов. Это предотвращает от выполнения
      'оператора печатания.

      'Присвоить значение результату функции
            FN Loops = -1
            SELECT CASE Se I%
                        
                    CASE 1
      'используйте оператор EXIT для выхода из петли вместо того,
      'чтобы закончить ее в норме.
            FOR I% = 1 TO 32767
              PRINT RND (Dummy %)
            EXIT FOR        'вывести петлю для ...
            NEXT I%
            EXIT DEF        'вывести всю функцию
  
                    CASE 2
            'используйте EXIT для выхода из этой петли
            'вместо того, чтобы закончить ее в норме
            DO
            PRINT RND (Dummy %)
            EXIT Loop       'вывести петлю
            Loop
            EXIT DEF        'вывести всю функцию

                    CASE 3
            'используйте EXIT для вывода из этой петли
            'вместо окончания ее в норме
            WHILE 1
            PRINT RND (Dummy %)
            'это то же самое, что и вывод
            EXIT Loop
            WEND       'петля DO
            END SELECT
            PRINT "Yoy executed selection 3"
            END DEF    'закончить определение функции
            'начать главную программу
     'произвести три вызова Loops, выбирая каждую доступную петлю
            PRINT FN Loops (1)
            PRINT FN Loops (2)
            PRINT FN Loops (3)
         INPUT "Enter a number":" Dummy %  'получите ввод пользо-
                                           'вателя
           'выполните Controls, выбирая каждую структуру контроля
        FOR Count % = 1 TO 2
            CALL Controls (Count %, Dummy %)
            CALL Controls (Count %, Dummy %)
        NEXT Count %
            END     'закончить программу

                     Функции EXP,EXP2, EXP10
-----------------------------------------------------------------
Назначение  EXP       возвращает e; 
            EXP10     возвращает 10; 
            EXP2      возвращает 2.,

Синтаксис   EXP:           EXP2:            EXP10:
            Y = EXP (X)    Y = EXP2 (X)     Y = EXP10 (X)

Комментарий    EXP возвращает е в степени х, где х есть численное 
            выражение,  а  е - основание натуральных  логарифмов,   
            приблизительно e=2.718282. Такой же результат вы  по-
            лучите  с  оператором  е  х.  Что вы можете сделать с 
            функцией EXP, так это вычислить само е: е = EXP (1) 
               EXP2 (X) возвращает 2 в  степени  х,  где  х  есть 
            численное  выражение или численная переменная.  Такой 
            же результат вы получите в выражении 2^х.  
               EXP10 (X) возвращает 10 в степени х,  где  х  есть 
            численная переменная или выражение. Такой  же резуль-
            тат вы получите в выражении 10^Х.  
               EXP,   EXP2  и  EXP10  возвращают   результаты   с 
            удвоенной точностью.  
Пример
            FOR I% = 1 TO 10
            PRINT USING "EXP OF ## = #### "; I%,EXP(I%)
            NEXT I%
            END

                          Оператор FIELD
-----------------------------------------------------------------
Назначение     Оператор  FIELD определяет переменные поля с буфе-
            ром файла с произвольной организацией.

Синтаксис   FIELD [#] filenum, width AS string-var
                  [,width AS string-var]...

Комментарий    filenum есть номер открытия файла;  
               width (ширина)  есть количество байтов, выделенных 
            переменной поля, а 
               string-var - это сама переменная поля.  
            
               Оператор FIELD  определяет  преобразование  данных 
            между  символьными  переменными и буфером I/O файла с 
            произвольной выборкой. Будучи однажды использованными 
            в операторе FIELD, эти символьные переменные получают 
            специальный статус "переменные поля". Они присваивают-
            ся  только  используя  RSET  и  LSET при подготовке к 
            записи в указанном файле с произвольной выборкой.  

Ограничения    Идентификатор оператора  FIELD  никогда  не должен 
            использоваться  с левой стороны оператора назначения. 
            Если это произойдет, то идентификатор больше не будет 
            идентифицироваться   с  определениями  поля  файла  с 
            произвольной выборкой.  

См. также   LSET    RSET

Пример      'открыть файл с произвольной выборкой
            OPEN "R", #1, "SYISLD.DTA" ,18
                  'OPEN "FIELD.DTA" FOR OUTPUT AS #1 LEN = 18
            'сделать два определения поля для каждого поля
            FIELD #1, 2 AS Integer $, 4 AS LongInt$,_
                      4 AS SinglePre$, 8 AS DoublePre$
            FIELD #1, 2 AS A$, 4 AS B$, 8  AS D$
            MaxInt% = 32767
                               'записать данные в файл
         FOR I% = 1 TO 5
                    'преобразовать данные и назначить их буферу
                     'до записи его в файл данных
            LSET Integer$  = MKIS(I%)
            LSET LongInt$ = MKL$(I% + CLNG(MaxInt%))
            LSET Singlepre$ = MKS$(CSNG(I% * CSNG(MaxInt%))
            LSET DoublePre$ = MKD$(MaxInt% I%)
            PUT #1,I%
            NEXT I%
                               'считать данные с файла
            FOR I% = 1 TO 5
                                'и показать их на экране
            GET #1, I%
            PRINT CVI(A$), CVL(B$), CVD(D$)
            NEXT I%
            CLOSE #1  'закрыть файл
            END       'закончить программу

                          Оператор FILES
-----------------------------------------------------------------
Назначение  Оператор FILES показывает содержимое каталога (аналог
            команды DIR DOS).

Синтаксис   FILTS [filespec]

Комментарий    filespec  есть символьное выражение, следующее ус-
            ловным  обозначениям  DOS,  оно  может  факультативно 
            включать в себя спецификатор накопителя и  информацию 
            о маршруте.  Если filespec опущен, будут показаны все 
            файлы в текущем каталоге 

               filespec,  как и команда DIR DOS,  может содержать 
            знаки ? и * , например: 

            FILES **.**   -перечисляет все файлы в данном текущем 
                           каталоге; 
    
            FILES **.BAS"- перечисляет  только  исходные  файлы 
                           Турбо Бейсика. 
             
               В конце списка файлов (FILES) ТУРБО БЕЙСИК показы-
            вает  количество свободных байтов на устройстве,  со-
            держащем  текущий  каталог.  Файлы подкаталога указы- 
            ваются суффиксом DIR.  
 
Ограничения    Описание несуществующего накопителя или каталога в 
            операторе FILES вызовет ошибку выполнения.

Пример
    
    INPUT "Enter the drive and directory you would like tolist";_
           Dir$
                            'показать описанный каталог
            FILES Dir$
            END             'закончить программу

                           Функция FIX
-----------------------------------------------------------------
Назначение  Функция FIX усекается до целого числа.

Синтаксис   Y + FIX (numeric expression)
                    (численное выражение)

Комментарий    Функция FIX отбрасывает дробную часть  аргумента и
            возвращает  целочисленную часть  (в отличие от CINT и 
            INT, которые производят округление).  

См. также   CEIL    CINT    INT

Пример      FOR I = 50 TO 52 STEP RND
           PRINT USING "The integer part of ##.## is ##";I,FIX(I)
            NEXT I
            END   'закончить программу

                        Оператор FOR/NEXT
-----------------------------------------------------------------
Назначение  Операторы FOR  и  NEXT  определяют    автоматически
            приращающийся цикл (или отрицательно приращающийся)

Синтаксис  FOR variable = x TO y [step z]
            .
            . statements
            .
            NEXT [variable]...]

Комментарий    variable есть численная переменная, служащая счет-
            чиком цикла, а x, y и z являются численными выражени-
            ями,  определяющими начальные и конечные условия цик-
            ла,  x - начальное значение,  а y - конечное значение 
            счетчика,  z - необязательное значение шага  прираще- 
            ния. 
               Выполнение операторов между FOR и NEXT повторяется.
               С каждым прохождением через цикл значение перемен-
            ной увеличивается на величину шага приращения z. Если 
            z опускается,  пошаговое приращение по умолчанию ста-
            новится равным 1.  Цикл завершается, когда переменная 
            счетчика будет больше или равна y (или,  для  отрица-
            тельного x, меньше или равна y).  
               Циклы  FOR/NEXT  выполняются быстрее всего с цело-
            численными переменными в качестве переменной счетчика 
            и константами x,y и z.  
               Тело цикла полностью пропускается,  если начальное 
            значение  x  больше  y  или,  если  z - отрицательное 
            значение, а x меньше y.  
               Циклы FOR/NEXT  могут  быть  помещены  в  пределах 
            других  циклов  FOR/NEXT (вложение циклов). При вло-
            жениях циклов необходимо следить, чтобы у каждого 
            цикла была своя переменная счетчика и чтобы внутрен-
            ний цикл завершался оператрором NEXT до появления  
            NEXT, завершающего внешний цикл.  
               Пример неправильной организации вложенного цикла:

            FOR n = 1 TO 10     'внешний цикл по n
            FOR m = 1 TO 20     ' внутренний цикл по m
             .
             .
             .
       NEXT n  'ОШИБКА внешний цикл завершен раньше внутреннего
       NEXT m
               Поскольку коды циклов пересекаются, данный цикл не 
            будет компилироваться.  

               Если множественные  циклы  заканчиваются  в  одной 
            точке,  единственный оператор NEXT, содержащий каждую 
            переменную счетчика, будет достаточным: 

            FOR n = 1 TO 10
            FOR m = 1 TO 20
              .
              .
              .
            NEXT m,n

               В  операторе  NEXT   переменная   счетчика   может 
            опускаться,  но  если  вы включите ее,  то это должна 
            быть единственно верная переменная. Например: 

            FOR n = 1 TO 10
              .
              .
              .
            NEXT   'NEXT n будет тоже работать, но не NEXT m

               Несмотря на то, что компилятору все это безразлич-
            но,  расположите операторы между FOR и NEXT двумя или 
            тремя пространствами для структурирования цикла.  
               Для выхода из цикла FOR/NEXT до его завершения ис-
            пользуйте оператор EXIT FOR.  
               Если NEXT появился без предшевствовавшего ему FOR,
            происходит  ошибка  выполнения 1,  NEXT  Without  FOR 
            (NEXT без FOR).

Пример
            FOR I% = 1 TO 10
              PRINT "For loop iteration " I%  'показать интерации
            NEXT I%

            PRINT "Press any key..."    'пауза
            WHILE NOT INSTAT
            WEND
            
      'используйте STEP для отрицательного приращения цикла 
            FOR I% = 50 to 1 STEP -5
                  PRINT "For loop iteration" 45-I%)\ 5
             'обратите внимание на отсутствие параметра next
            NEXT
            END

                           Функция FRE
-----------------------------------------------------------------
Назначение     Функция  FRE  возвращает доступное вашей программе 
            количество свободной памяти.

Синтаксис   Y = FRE( string expression/-1/-2 )

Комментарий    Функция  FRE с  символьным  аргументом  возвращает 
            длинное целое число, представляющее количество свобо-
            дных байтов оперативной  памяти.  FRE(-1)  возвращает 
            число свободных байтов оперативной памяти, отведенных 
            под   массивы  вашей  программы.   FRE(-2)  сообщает, 
            сколько места осталось на стеке.  

Различия       Функция FRE  ТУКБО БЕЙСИКА обеспечивает больше ин-
            формации, чем функция Интерпретатора БЕЙСИК. Оператор 
            FRE  в   интерпретаторе   БЕЙСИК   возвращает   обьем 
            доступной  памяти  в  сегмент  данных БЕЙСИКа:  таким 
            образом вызов FRE(s$) и FRE(0)  возвращают  такое  же 
            количество.  
               Однако,  учитывая,что  ТУРБО  БЕЙСИК  обеспечивает 
            больший обьем памяти для  работы,  его  оператор  FRE 
            имеет  больше  функций.  ТУРБО БЕЙСИК имеет отдельный 
            символьный   сегмент;    таким   образоми,    FRE(S$) 
            возвращает  доступное символьное пространство.  Турбо 
            Бейсик имеет большое  (>64К)  пространство  массивов, 
            поэтому FRE(-1) возвращает доступную память массивов. 
            Турбо Бейсик обеспечивает также процедуру и рекурсию, 
            поэтому FRE(-2) возвращает доступный обьем стека.  
Пример
            ON ERROR GOTO Erroandler 'установить обработку ошибок
            'показать память, доступную в сегментах строки,
            'данных и стека
            PRINT FRE("String Space"),FRE(-1),FRE(-2)

        DIM DINAVIC BigArray(10000) 'обьявить динамический массив
            BigArray(6666) = 66   'назначить ему данные
            'показать память, доступную в сегментах строки,
            'данных и стека
            S$="abc..z"
            PRINT FRE("String Spase"),FRE(-1),FRE(-2)

            ERASE BigArray   'перераспределить динамический массив
            'показать память, доступную в сегментах строки,
            'данных и стека
            S$=""
            PRINT FRE("String Spase"),FRE(-1),FRE(-2)
            'Данный оператор возвращает ошибку выполнения, если
            'программа прогоняется с контролем границ
            PRINT BigFrray(6666)
            END       'закончить программу

            ErrorHandler:
       PRINT "An error of type " ERR " has occurred at address"
               ERADR
            END

                      Оператор  GET (файлы)
-----------------------------------------------------------------
Назначение  Оператор  GET считывает запись с файла c произвольной
            организацией.

Синтаксис   GET [#]filenum[,recnum]

Комментарий    filenum - номер открытия файла; 
               recnum - запись, которую надо считать,  от 1  до  
               16 777 215*(2^24-1).

               Если recnum опускается,  то считывается  следующая 
            запись  (следом за записью, указанной самым последним 
            GET или PUT).  

Пример      'открыть файл с произвольной выборкой
            OPEN "GET.DTA" AS #1 LEN = 18

         'сделать два определения поля для каждого элемента поля
            FIELD #1, 2 AS Integer$, 4 AS LongInt$,-
                      4 AS SinglePre$, 8 AS DoublePre$
            FIELD #1, 2 AS A$, 4 AS B$, 4 AS C$, 8 AS D$

            MaxInt% = 32767

            FOR I% = 1 TO 5   'записать данные в файл
            'преобразовать данные и назначить буфер перед
            'записью в файл данных
            LSET Integer$ = MKI$(I%)
            LSET Integer$ = MKL$(I% + CLNG(MaxInt%))
            LSET Integer$ = MKS$(CSNG(I% * CSNG(MaxInt%)))
            LSET Integer$ = MKD$(MaxInt%-I%)
            PUT #1,I%
            NEXT I%

            FOR I% = 1 TO 5  'считать данные с файла
            GET #1, I%       'показать их на экране
              PRINT CVI(A$), CYL(B$), CVD(D$)
            NEXT I%

            CLOSE #1         'закрыть файл
            END              'закончить программу

                   Оператор  GET (графический)
-----------------------------------------------------------------
Назначение  Оператор  GET  считывает  весь или часть графического 
            экрана в массив.

Синтаксис   GET (x1,y1)-(x2,y2),array

Комментарий    (x1,y1) и (x2,y2) описывают соответственно верхнюю 
            левую и нижнюю правую  границы  зоны  на  графическом 
            экране оператора GET. 
               array - это численный массив.  

               Оператор  GET  и соответствующий ему оператор  PUT 
            используются для считывания, а затем для записи  гра-
            фических образов на экране.  Единственное ограничение 
            в отношении  численного  массива,  используемого  для 
            удерживания данных, считываемых с экрана, это то, что 
            он  должен  быть  достаточно большим для того,  чтобы 
            удержать их.  Используйте для вычисления размера мас- 
            сива,  необходимого  для  удержания данного диапазона 
            экрана, следующую формулу: 

            ByteNecessary = 4 + INT((X * bitsPerPixel + 7)/8) * Y  

            где X и Y представляют собой соответсвенно размеры по 
            горизонтали   и   вертикали    захватываемой    зоны, 
            bitsPerPixel   является  константой,   относящейся  к 
            графическому режиму:  2 для среднего разрешения  и  1 
            для высокого разрешения.  

            -----------------------------------------------------
              Экран                  Биты на растровый элемент
            -----------------------------------------------------
                1                                2
                2                                1
                7                                4
                8                                4
                9                                4
               10                                2
            -----------------------------------------------------

               Например, для сохранения образа среднего  разреше-
            ния 35 растровых элементов  на  45,  вам  потребуется 
            массив в  4 + INT((35 * 2 + 7)/8) * 45 байтов или 409 
            байтов. 
               409 байтов представляют  целочисленный  массив  из 
            205 элементов, таким образом массив, объявленный опе-
            раторром DIM :

                  DIM buffer%(204) 

            будет достаточным.   Помните, что по умолчанию каждый 
            массив содержит нулевой элемент,  так массив  buffer% 
            имеет 205 двухбайтных элементов,  от 0 до 204,  всего 
            410 байтов.  
               ТУКБО  БЕЙСИК  сохраняет  графические   данные   в 
            массиве буфера в следующем формате: 

               buffer%(0):    Количество байт по-горизонтали
               buffer%(1):    Количество байт по-вертикали
               buffer%(2):   }
               .             } Собственно
               .             } графическая 
               .             } информация
               buffer%(204): }

               В результате организации памяти дисплея, оживление 
            основанное на GET и PUT,  происходит быстрее, если вы 

            выберете участки экрана,  примыкающие к границам бай-
            тов.  Для средней разрешающей способности используйте 
            значения X кратные 4; для высокого разрешения - крат-
            ные 8.  
               Основная стратегия использования  GET  и  PUT  для 
            оживления объекта от точки A до точки B заключается в 
            следующем: 

            Draw the object
            GET the object into an array
            position = old location = point A
            DO UNTIL position = point B
          PUT XOR the object at old location  'стереть/построить
               position = position + increment
          PUT XOR the object at position
               Delay if necessary
               old location = position
            LOOP

Пример      'выделить буфер для хранения графических образов

            DIM Buffer%(143)

            'перейти в графический режим средней
            'разрешающей способности

            SCREEN 1
            CIRCLE (16,16),8,2    'нарисовать круг
         GET (0,0)-(31,31),Buffer%  'получить круг
                                    'копировать его 
                                    'по всему экрану
             FOR I% = 0 TO 9
         PUT (I% * 32,100),Buffer%
            NEXT I%
            END         'закончить программу

                          Функция  GET$
-----------------------------------------------------------------
Назначение  Функция  GET$  считывает строку  с  файла открытого в 
            режиме   BINARY.

Синтаксис   GET$ [#] filenum, count, string variable

Комментарий  count  есть целочисленное выражение в диапазоне от 0 
             до  32,767.

               GET считывает счетные байты начиная с текущего по-
            ложения  файла  (которое  может  быть  установлено  с 
            помощью SEEK), с номера файла filenum и назначает его 
            символьной переменной.  Filenum файла должно быть от-
            крыто в режиме BINARY.  После функции  GET$,  текущее 
            положение  файла  будет  продвинуто с помощью счетных 
            байтов.  
               GET$, PUT$ и SEEK обеспечивают альтернативу низко-
            го уровня технике обработки последовательных файлов и 
            файлов с произвольной организацией, которая позволяет 
            вам иметь дело с файлами  на  основе  байт/байт.  

См. также   OPEN      PUT$    SEEK

Пример      SUB Create File   'процедура создания файла
            'GET$  открывает файл и записывает в него 256 знаков 

            LOCAL I%

            'открыть файл для BINARY  I/O

            OPEN  "GETS.DATA" FOR BINARY AS #1

            'записать в него данные

            FOR I% = 0 TO 255
                 PUT$ #1, I%, CHRS(I%)
            NEXT  I%
            END SUB  'закончить процедуру создания файла

        DEF FNReagIt$(Styart%,Size%)  'функция считывания данных
            `GET$ считывает указанное количество данных из файла

            LOCAL TempStr$, Char$, I%

            'поиск для коррекции положения в файле
            SEEK 1, Start%

            'считать байты Size%
            GET$ #$1, Size% TempStr$

            FNReadIt$ = TempStr$
        END DEF     'закончить функцию ReadIt

            CALL CreateFile   'создать файл данных
                              'получить ввод пользователя
          PRINT "Enter the starting point[0...255] and how many"
          PRINT "bytes of data[0...255] yon wish to"
          INPUT "read from the file: ",St%, Sz%

            PRINT FNReadit$(St%, Sz%)  'считать данные

            END  'закончить программу

                         Оператор  GOSUB
-----------------------------------------------------------------
Назначение  Оператор  GOSUB  вызывает подпрограмму.

Синтаксис   GOSUB label

Комментарий    Оперратор GOSUB заставляет ТУРБО БЕЙСИК перескаки-
            вать на оператор с предшествующей меткой,  после пер-
            вой записи его текущего адреса на  стеке.  Выполнение 
            RETURN возвращает управление на оператор, следующий в
            программе непосредственно за GOSUB .  
               Процедуры и функции ТУРБО БУЙСИКА могут  выполнять 
            работу   подпрограммы  с  извлечением  дополнительных 
            пиреимуществ  от  рекурсии,  прохождения  параметров, 
            локальных и статических переменных.  

См. также  DEF FN     SUB     RETURN

Пример      PI# = ATN(1) * 4 'вычисление значения Pi
            Radius! = 55   'объявить переменную с 
                           'одинарной точностью
            GOSUB CalcArea 'переход на подпрограмму

            END            'закончить программу

            'вычислить и показать на экране площадь круга
            СalcArea:
                Area = PI# * Radius^2  'вычислить площадь
                PRINT Area             'показать результат
                RETURN                 'выход из подпрограммы

                          Оператор  GOTO
-----------------------------------------------------------------
Назначение  GOTO посылает выполнение программы к оператору с мет-
            кой.

Синтаксис   GOTO label

Комментарий    Оператор  GOTO  перемещает выполнение программы к 
            коду с меткой.
               GOTO - быстрое и эффективное  программное  устрой-
            ство,  если пользоваться им умеренно.  Если же приме-
            нять  COTO  беспечно,  они  могут "удушить" программу 
            своими кодами,  которые практически невозможно  отга-
            дать  (особенно  по прошествии месяцев или нескольких 
            лет). Современное использование операторов GOTO мини-
            мизировано в практике программирования  подпрограмма-
            ми,  процедурами, функциями и структурными оператора-
            ми,  такими как:   FOR/NEXT,   WHILE/WEND,   DO/LOOP, 
            IF BLOCK и SELECT Оператор  EXIT  тоже  может  помочь 
            сократиь использование GOTO. 

См. также   EXIT 

Пример      X = 0

            Start:     'определите метку
              X = X + 1  'приращение  X
              IF X < 20 THEN  'если X<20, то перейти к PrintOut
                 GOTO  PrintOut
              END IF
            END

            PrintOut:      'показать значение  X
              PRINT "Variable X = "X
              GOTO Start  'вернуться на Start(начало)

                          Функция  HEX$
-----------------------------------------------------------------
Назначение  Функция  HEX$ преобразует число в его шестнадцатирич-
            ный символьный эквивалент.

Синтаксис   s$ = HEX$(numeric expression)
                     (чисоленное выражение)

Комментарий    численное выражение может принимать  значения   от 
            -32,768 до 65,535. Любая дробная часть численного вы- 
            ражения округляется до создания строки. Если аргумент 
            HEX$ отрицательный,  HEX$ возвращает  двузначный  вид 
            числа.  

См. такжке BIN$    OCT$

Пример      PRINT HEX$(65535)
            PRINT HEX$(-1)

                           Оператор  IF
-----------------------------------------------------------------
Назначение  Оператор IF тестирует условия и меняет ход выполнения
            программы в соответствии с заданными условиям.

Синтаксис  

  IF integer expression [,] THEN statement(s) [ELSE statement(s)]
     целочисленное выражение     оператор(ы)       оператор(ы)

Комментарий    Если  целочисленное выражение есть  TRUE (не равно 
            нулю), т.е. соблюдены заданные условия, то выполняет-
            ся оператор(ы),  следующий за THEN и  перед  необяза-
            тельным ELSE.  Если выражение является FALSE (нулевой 
            результат),  т.е.  заданные условия  не  соблюдаются, 
            тогда выполняется оператор,  следующий за ELSE.  Если 
            необязательный ELSE опускается, продолжается выполне-
            ние следующей строки программы.  
               Обычно,     целочисленное    выражение    является 
            результатом,   возвращенным  реляционным  оператором, 
            хотя и не всегда, как видно из примера: 

            IF printerOn THEN LPRINT answer$

               Здесь  оператор LPRINT выполняется в случае,  если 
            "флаговая" переменная printerOn(вкл.) имеет  значение 
            не равное нулю.  
               Перед клавишей ELSE не должно быть двоеточия, нап-
            ример, следующий оператор не будет компилироваться: 

            IF a < b THEN c = d  :ELSE e = f

               Оператор  IF и родственные операторы,  включая те, 
            что идут после ELSE, должны появляться на одной и той 
            же логической строке. Поэтому следующая запись ошибо-
            чна: 

            IF a < b THEN t = 15 : u = 16 : v = 17
                ELSE t = 17 : u = 16 : v = 15

            потому  что  компилятор  рассматривает вторую строку, 
            как новый вид оператора,  не связанный с  предыдущим.  
            Если у вас операторв больше,  чем может вместить одна 
            строка,  вы можете воспользоваться знаком продолжения 
            строки  (низкая  черта) и распростронить единую логи-
            ческую  строку   на   несколько   физических   строк.  
               Например, нижеследующая запись верна: 
  
            IF a < b THEN t = 15 : u = 16 : v = 17_ 
              ELSE t = 17 : u = 16 : v = 15

               Однако   альтернативой  может  быть  использование 
            блочного оператора  IF.  Блочный  оператор  IF  можно 
            также  использовать  для  формирования  многострочных 
            серий операторов IF.  
                                               
Различия       ТУРБО БЕЙСИК  расширил оператор  IF THEN ELSE  для
            олбеспечения многострочных  кодов  в  конструкции  IF 
            THEN ELSE.  ТУРБО БЕЙСИК также обеспечивает операторы 
            ELSEIF и ENDIF для блочного оператора IF.  

См.также    блочный оператор IF     SELECT

Пример      'одна строка IF
            INPUT "Enter a number", X
            IF X > 100 THEN PRINT "Bignumber" ELSE_ 
                            PRINT "SmallNumber"
            END

                       Блочный оператор IF
-----------------------------------------------------------------
Назначение  Блок  IF создает серию операторов  IF.

Синтаксис   IF integer expression[,] THEN
            .
            .  statement(s)
            .
            [ELSEIF integer expression [,] THEN
            .
            . statement(s)]
            .
            .
            [ELSE
            .
            . statement(s)]
            .
            END IF

Комментарий    Блок IF  представляет собой расширение Интерприта-
            тора БЕЙСИК,  он позволяет многократные тесты  многих 
            строк.  
               При выполнении блока операторов IF,  сперва прове-
            ряется  истинность  выражения  в  оператора IF.  Если 
            FALSE(нулевой результат),  каждый из последующих опе- 
            раторов ELSEIF проверется по порядку (операторов ELSE 
            может  быть сколько угодно).  Как только ТУРБО БУЙСИК 
            подтверждает истинность одного из операторов,  он вы- 
            полняет этот оператор, следуя за связанным с ним THEN 
            и перескакивает на этот оператор сразу же по заверше- 
            нии END IF без дальнейших тестов. Этот оператор после 
            необязательного  ELSE  выполняется,  если  ни один из 
            предшествующих тестов не удается.  
               Заметьте,  что после ключевого слова THEN в первой 
            строке блока IF не может быть больше ничего; по этому 
            признаку  компилятор  может  отличить  блок   IF   от 
            обычного оператора IF.  Также помните, что после ELSE 
            ничего нет.  
               Операторы блока IF допускают вложения, т.е.  любой 
            оператор после любого THEN может содержать блоки IF.  
               Операторы блока IF должны  заканчиваться  END  IF.  
            Обратите внимание,  что END IF имеет пространство,  а 
            ELSEIF не имеет.  

 См. также  SELECT

Пример        RANDOMIZE TIMER
              bankroll = 100 : bet = 5 : delayVal = .5
              WHILE NOT INSTAT   'для завершения нажать клавишу
                roll = INT(RND(1) * 6) + INT(RND(1) * 6) + 2
                PRINT STRING$(30,"-")
                PRINT "Сумма наличности =" bancroll
                PRINT roll : DELAY delayVal
                IF roll = 2 OR roll = 3 OR roll = 12 THEN
                  PRINT "Вы проиграли"
                  bancroll = bancroll + bet
                ELSEIF roll = 7 OR roll = 11 THEN
                  PRINT "Вы выиграли !"
                  bancroll = bancroll - bet
                ELSE
                  PRINT "Ваши очки" roll
                  noPoint = -1
                  WHILE noPoint
                    nextRoll : DELAY delayVal
                    IF roll = nextRoll THEN   'вложенный блок IF
                      PRINT "Вы выиграли !"
                      bancroll = bancroll + bet
                      noPoint = 0
                    ELSE IF nextRoll = 7 THEN
                      PRINT "Вы проиграли"
                      bancroll = bancroll - bet
                      noPoint = 0
                    ENDIF
                  WEND              'завершает цикл WHILE noPoint
                ENDIF               'завершает первый блок IF
              WEND                  'конец цикла WHILE NOT INSTAT









