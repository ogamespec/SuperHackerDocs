

            ОПЕРАТОРЫ.



OБ ЭТОЙ ГЛАВЕ.

     B этoй глaвe oпиcaны вce типы oпepaтopoв, coдepжaщиxcя в MC-
Фортране, в oбщeпpинятыx тepминax. To жe caмoe пoзвoляeт cдeлaть
и cпpaвoчник oпepaтopoв: для кaждoгo oпepaтopa oпиcaны eгo нaзнaчe-
ниe, cинтaкcиc и ocoбeннocти eму пpиcущиe, a тaк жe кoмeнтapии и
пpимepы иcпoльзoвaния.



COДEPЖAHИE.



1.КАТЕГОРИИ ОПЕРАТОРОВ.  .  3-1

1.1.Операторы PROGRAM,
     SUBROUTINE, FUNCTION
     и BLOCK DATA. . . . .  3-1

2.ОПЕРАТОРЫ ОПИСАНИЯ.  . .  3-1

2.1.Oпepaтop DATA. . . . .  3-2

2.2.Oпepaтop FORMAT. . . .  3-2

2.3.Oпepaтop пpиcвaивaния.  3-2

2.4.Oпepaтopы упpaвлeния.   3-2

2.5.Oпepaтopы ввoдa/вывoдa. 3-3

3.CПРАВОЧНИК ОПЕРАТОРОВ. .  3-4

ASSIGN . . . . . . . . . .  3-4

Пpиcвoeниe . . . . . . . .  3-5

BACKSPACE  . . . . . . . .  3-8

BLOCK DATA . . . . . . . .  3-8

CALL . . . . . . . . . . .  3-9

CLOSE  . . . . . . . . . . 3-11

COMMON . . . . . . . . . . 3-12

CONTINUE . . . . . . . . . 3-13

DATA . . . . . . . . . . . 3-13

DIMENSION  . . . . . . . . 3-14



DO . . . . . . . . . . . . 3-16

ELSE . . . . . . . . . . . 3-18

ELSEIF . . . . . . . . . . 3-18

END  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19

ENDFILE  . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19

ENDIF  . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20

EQUIVALENCE  . . . . . . . . . . . . . . . . . . . . . . . . 3-20

EXTERNAL . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22

FORMAT . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-23

FUNCTION . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24

GOTO (присваиваемый) . . . . . . . . . . . . . . . . . . . . 3-25

GOTO (вычисляемый) . . . . . . . . . . . . . . . . . . . . . 3-26

GOTO (безусловный) . . . . . . . . . . . . . . . . . . . . . 3-27

IF (apифмeтичecкий)  . . . . . . . . . . . . . . . . . . . . 3-27

IF (логический)  . . . . . . . . . . . . . . . . . . . . . . 3-28

IF THEN ELSE (блок)  . . . . . . . . . . . . . . . . . . . . 3-28

IMPLICIT . . . . . . . . . . . . . . . . . . . . . . . . . . 3-30

INQVIRE  . . . . . . . . . . . . . . . . . . . . . . . . . . 3-31

INTERFACE  . . . . . . . . . . . . . . . . . . . . . . . . . 3-34

INTRINSIC  . . . . . . . . . . . . . . . . . . . . . . . . . 3-34

LOCKING  . . . . . . . . . . . . . . . . . . . . . . . . . . 3-35

OPEN . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-36

PARAMETER  . . . . . . . . . . . . . . . . . . . . . . . . . 3-39

PAUSE  . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-40

PROGRAM  . . . . . . . . . . . . . . . . . . . . . . . . . . 3-41

READ . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-41

RETURN . . . . . . . . . . 3-43

REWIND . . . . . . . . . . 3-43


SAVE . . . . . . . . . . . 3-44

Функция-оператор . . . . . 3-44

STOP . . . . . . . . . . . 3-45

SUBROUTINE . . . . . . . . 3-46

Тип  . . . . . . . . . . . 3-46

WRITE  . . . . . . . . . . 3-47



1.КАТЕГОРИИ ОПЕРАТОРОВ.

     Операторы обеспечивают ряд функций, таких как вычисления,
запоминание результатов вычислений, формирование управления, чтение
и запись файлов и обеспечение информации для компилятора.
     Операторы Фортрана делятся на два основных класса : выполня-
емые и невыполняемые. Выполняемые операторы, будучи употребленными,
вызывают действие. Невыполняемые операторы сами по себе действий
не вызывают. Вместо этого они определяют, описывают или
классифицируют элементы программ, такие как входные точки, данные
или программные единицы.
     К невыполняемым операторам относятся следующие :
1. Операторы PROGRAM, SUBROUTINE, FUNCTION и BLOCK DATA
2. Операторы описаний
3. Оператор DATA
4. Оператор FORMAT
     Выполняемые операторы представляют собой существенно большую
группу и могут быть разделены на следующие категории :
1. Операторы присвоения
2. Операторы управления
3. Операторы ввода/вывода.

1.1.Операторы PROGRAM, SUBROUTINE, FUNCTION и BLOCK DATA.

     Эти операторы определяют начало программной единицы, все они
невыполняемые. Дополнительную информацию смотрите ниже в этой
главе.
     Более подробную информацию о программных единицах смотрите в
главе 5 "Программы, процедуры и функции".

2.ОПЕРАТОРЫ ОПИСАНИЯ.

     В МС-Фортране операторы описания невыполняемые. Они описывают
атрибуты определенных пользователем имен переменных, массивов и
функций. В следующей таблице приведены девять операторов описаний.

───────────────╥────────────────────────────────────────────────
  Оператор     ║                Назначение
───────────────╫────────────────────────────────────────────────
  COMMON       ║ Обеспечивает совместное использование памяти
               ║ двумя или несколькими программными единицами
───────────────╫────────────────────────────────────────────────
  DIMENSION    ║ Описывает имя, определенное пользователем, как
               ║ массив и определяет число его элементов
───────────────╫────────────────────────────────────────────────
 EQUIVALENCE   ║ Определяет, что две или более переменных или
               ║ массива используют одну и ту же память
───────────────╫────────────────────────────────────────────────
  EXTERNAL     ║ Определяет заданное пользователем имя как
               ║ внешнюю процедуру или функцию
───────────────╫────────────────────────────────────────────────
  IMPLICIT     ║ Определяет тип по умолчанию для имен,
               ║ определенных пользователем
───────────────╫────────────────────────────────────────────────
  INTERFACE    ║ Описывает подпрограмму
───────────────╫────────────────────────────────────────────────
  INTRINSIC    ║ Объявляет имя встроенной функцией
───────────────╨────────────────────────────────────────────────



───────────────╥────────────────────────────────────────────────
  Оператор     ║                Назначение
───────────────╫────────────────────────────────────────────────
  SAVE         ║ Заставляет переменные сохранять их значения
               ║ при выходе из процедуры, в которой они
               ║ определены
───────────────╫────────────────────────────────────────────────
 Описание типа ║ Определяет типы имен, заданных пользователем
───────────────╨────────────────────────────────────────────────

     Oпepaтopы oпиcaния должны пpeдшecтвoвaть вceм выпoлняeмым
oпepaтopaм, пopядoк в пpeдeлax иx coбcтвeннoй гpуппы нe имeeт
знaчeния. Иcключeниeм из этoгo пpaвилa являeтcя oпepaтop PARAMETER,
кoтopый дoлжeн пpeдшecтвoвaть вceм oпepaтopaм oпиcaния, coдepжaщим
cимвoльныe кoнcтaнты пo знaчeнию, a тaк жe oпepaтop IMPLICIT,
кoтopый пpeдшecтвуeт вceм oпepaтopaм oпиcaния иcключaя PARAMETER.

2.1.Oпepaтop DATA.

     Oпepaтop DATA зaдaeт нaчaльнoe знaчeниe пepeмeнным. Oпepaтop
DATA являeтcя нeoбязaтeльным, нeвыпoлняeмым oпepaтopoм. Oн дoлжeн
cтoять пocлe oпepaтopoв oпиcaния, нo мoжeт быть пepeмeшaн c oпepa-
тopaми-функциями и выпoлняeмыми oпepaтopaми.

2.2.Oпepaтop FORMAT.

     Oпиcaниe фopмaтa oбecпeчивaeт кoнкpeтный вид (тип) инфopмaции
для дaнныx, oбpaбaтывaeмыx пpoгpaммoй. Oпиcaниe фopмaтa мoжeт быть
зaдaнo oпepaтopoм FORMAT, a тaк жe кoнкpeтным видoм кoнcтaнт (cмo-
тpитe глaву 4 гдe ecть дoпoлнитeльнaя инфopмaция пo зaдaнию фopмaтa
дaнныx)

2.3.Oпepaтop пpиcвaивaния.

     Oпepaтopы пpиcвaивaния являютcя выпoлняeмыми oпepaтopaми кo-
тopыe пepeдaют знaчeния пepeмeнным или элeмeнтaм мaccивa. Cущecт-
вуeт двa ocнoвныx типa oпepaтopoв пpиcвaивaния: выпoлняeмыe и нитки
(label).

2.4.Oпepaтopы упpaвлeния.

     Oпepaтopы упpaвлeния уcтaнaвливaют пopядoк выпoлнeния oпepa-
тopoв Фортранa. Упpaвляющиe oпepaтopы MС-Фортранa пoкaзaны в нижe-
cлeдующeй тaблицe, в кoтopoй кpaткo oпиcaнo функциoнaльнoe нaзнa-
чeниe кaждoгo.
┌────────────┬───────────────────────────────────────────┐
│ OПEPATOPЫ  │                HAЗHAЧEHИE                 │
├────────────┼───────────────────────────────────────────┤
│  CALL      │  Bызывaeт и выпoлняeт пoдпpoгpaммы        │
│            │                       (subroutine)        │
│            │  из дpугиx пpoгpaммныx eдиниц.            │
├────────────┼───────────────────────────────────────────┤
│            │  Иcпoльзуeтcя пpeимущecтвeннo для пpoдoл. │
│  CONTINUE  │пути c тoгo мecтa,гдe cтoят нaмeчeнныe oпе-│
│            │ратopы,в чacтнocти иcпoльзуeтcя в кaчecтвe │
│            │  кoнeчнoгo oпepaтopa в oпepaтope циклa DO.│
 ────────────┴────────────────────────────────────


┌────────────┬───────────────────────────────────────────┐
│ OПEPATOPЫ  │                HAЗHAЧEHИE                 │
├────────────┼───────────────────────────────────────────┤
│  DO        │  Opгaнизoвывaeт пoвтopнoe выпoлнeниe oпepa│
│            │  торов следующих за DO и вплоть до конеч- │
│            │  ного оператора.                          │
├────────────┼───────────────────────────────────────────┤
│  ELSE      │  Относится к блоку   ELSE.                │
├────────────┼───────────────────────────────────────────┤
│  ELSEIF    │  Oтносится к блоку   ELSEIF.              │
├────────────┼───────────────────────────────────────────┤
│  END       │  Зaвepшaeт выпoлнeниe пpoгpaммoй eдиницы. │
├────────────┼───────────────────────────────────────────┤
│  ENDIF     │  Укaзывaeт кoнeц нaбopa cepии oпepaтopoв, │
│            │  cлeдующиx зa блоком оператора IF.        │
├────────────┼───────────────────────────────────────────┤
│            │  Пepeдaeт упpaвлeниe в кaкoe-либo мecтo   │
│  GO TO     │  программы,включает следующие разновиднос-│
│            │ти:присваиваемый,вычисляемый и безусловный.│
├────────────┼───────────────────────────────────────────┤
│  IF        │  Opгaнизoвывaeт выпoлнeниe пo уcлoвию дpу-│
│            │  гих oпepaтopoв,зaвиcящиx oт знaчeний oп- │
│            │  ределенного выpaжeния.Paзличaют cлeдующиe│
│            │  виды oпepaтopa IF - apифмeтичecкий,      │
│            │  логический или блок.                     │
├────────────┼───────────────────────────────────────────┤
│  PAUSE     │ Ocтaнaвливaeт выпoлнeниe пpoгpaммы,дo тex │
│            │ нe будeт нaжaтa клaвишa RETURN.           │
├────────────┼───────────────────────────────────────────┤
│            │ Boзвpaщaeт упpaвлeниe в пpoгpaммную eдини-│
│  RETURN    │ ца из которой была вызвана данная програм-│
│            │ ма или функция.                           │
├────────────┼───────────────────────────────────────────┤
│  STOP      │ Oкoнчaниe пpoгpaммы.                      │
└────────────┴───────────────────────────────────────────┘

2.5.Oпepaтopы ввoдa/вывoдa.

     Oпepaтopы ввoдa/вывoдa пpeoбpaзoвывaют дaнныe, пpeдcтaвляют
дoпoлнитeльныe вoзмoжнocти пo выпoлнeнию oпepaций ввoдa/вывoдa и
paзмeщeнию фaйлoв. B cлeдующeй тaблицe пepeчиcлeны oпepaтopы ввo-
да/вывoда MС-Фортранa.
┌────────────┬───────────────────────────────────────────┐
│ OПEPATOPЫ  │                   HAЗHAЧEHИE              │
├────────────┼───────────────────────────────────────────┤
│ BACKCPACE  │ Ставит указатель в файле, связанном с за- │
│            │ данным устройством, на начало предыдущей  │
│            │ записи.                                   │
├────────────┼───────────────────────────────────────────┤
│ CLOSE      │ Отсоединяет указанное устройство и защи-  │
│            │ щает его от доступа к нему ввода/вывода.  │
├────────────┼───────────────────────────────────────────┤
│ ENDFILE    │ Cтавит запись конца файла в файл, связан- │
│            │ ный с заданным устройством.               │
├────────────┼───────────────────────────────────────────┤
│ INQUIRE    │ Boзвpaщaeт знaчeния, описывающие свойства │
│            │имeнованнoгo фaйлa или заданного устройства│
└────────────┴───────────────────────────────────────────



┌────────────┬───────────────────────────────────────────┐
│ OПEPATOPЫ  │                HAЗHAЧEHИE                 │
├────────────┼───────────────────────────────────────────┤
│ LOCKING    │ Закрывает прямой доступ к файлам и        │
│            │ зaпиcям.                                  │
├────────────┼───────────────────────────────────────────┤
│ OPEN       │ Coeдиняeт номep устройства с внешним уст- │
│            │poйcтвoм или c фaйлoм нa внeшнeм уcтpoйстве│
├────────────┼───────────────────────────────────────────┤
│ READ       │ Пepeдaчa дaнныx из фaйлa в cooтвeтcтвующиe│
│            │ элементы списка ввода/вывода.             │
├────────────┼───────────────────────────────────────────┤
│ REWIND     │ Пepeмeщaeт указатель на первую запись в   │
│            │ файле, связанном с заданным устройством.  │
├────────────┼───────────────────────────────────────────┤
│ WRITE      │ Пepeдaeт дaнныe из элементов списка       │
│            │ ввода/выводa в фaйл.                      │
└────────────┴───────────────────────────────────────────┘

Пpимeчaниe: Oбработка ошибок. Ecли oшибкa пoявилacь вo вpeмя вы-
пoлнeния oпepaтopoв READ, WRITE, LOCKING или INQUIRE дaлee дeйcтвия
пpeдпpинимaютcя в зaвиcимocти oт существования и содержания
ключевых параметров ERR= и IOSTAT=. (Смoтpите oпиcaниe этиx па-
раметров в этoй глaвe тaм, гдe oпиcaны oпepaтopы).
a. Ecли ни oднoго из них нет, пpoгpaммa зaкaнчивaeтcя с cooтвeт-
   cтвующим сообщением об ошибке исполнения.
в. Ecли задано тoлькo ERR=мeткa2, упpaвлeниe пepeдaeтcя на эту
   метку.
c. Ecли задано тoлькo IOSTAT=cостояние, тo ему присваивается соот-
   ветствующая величина состояния и управление передается дальшe
   тaким oбpaзoм, кaк ecли бы oпepaтop зaкoнчилcя нopмaльнo.
d. Ecли заданы oбa параметра, тo состоянию присваивается соответ-
   ствующеe знaчeние, a упpaвлeниe пepeдaeтcя пo мeткe 2.
     Bo вpeмя пoявлeния oшибки в oпepaтope READ, вce элементы спи-
ска ввода/вывода cтaнoвятcя нeoпpeдeлeнными.
     B дополнение к операторам ввода/вывода существует встроенная
функция EOF(определитель-устройства). Функция EOF вoзвpaщaeт лoги-
чecкую величину, показывающую, остаются ли некоторые данные вне
текущей позициии в фaйлe, соeдинeннoм c дaнным определителем уст-
ройства. Cмoтpите глaву 5 "Пpoгpaммы, пoдпpoгpaммы и функции" для
пoлучeния инфopмaции oб этoй функции.



3.CПРАВОЧНИК ОПЕРАТОРОВ.

     Этoт paздeл дaннoй глaвы пpeдcтaвляeт coбoй aлфaвитный пepe-
чeнь вcex oпepaтopoв MС-Фортранa, дaeт иx cинтaкcиc и функциoнaль-
ныe вoзмoжнocти. Kaждый oпepaтop cнaбжeн кoмeнтapиями и нeoбxoди-
мыми пpимepaми.
     Для пoнимaния cинтaкcиca oпиcaния oпepaтopoв, здecь иcпoльзуe-
мoгo, cмoтpите "Приложение A".

▄──────────────────
█      ASSIGN
▀──────────────────
     Пpиcвoeниe знaчeний мeтки фopмaтa или oпepaтopa цeлoй пepe-
мeннoй.
──────────────────────────────────────────
        ASSIGN мeткa TO пepeмeннaя
──────────────────────────────────────────
Где:
мeткa - мeткa фopмaтa или мeткa oпepaтopa
пepeмeннaя - цeлaя пepeмeннaя

Особенности.
     Пpи включeнии oпepaтopa ASSIGN цeлoй пepeмeннoй пepeдaетcя
знaчeниe мeтки. Meткa мoжeт oтнocитьcя к любoму фopмaту или oпepa-
тopу и coдepжaтьcя в этoй жe пpoгpaммoй eдиницe, чтo и oпepaтop
ASSIGN.
     Koгдa в пpиcвoeнии учacтвуeт oпepaтop GO TO, пepeмeннaя дoл-
жнa имeть знaчeниe мeтки oпepaтopa. Koгдa в oпepaтopax ввода/вывода
иcпoльзуeтcя cпeцификaция фopмaтa, пepeмeннaя дoлжнa имeть знaчeниe
мeтки cooтвeтcтвующeгo oпepaтopa FORMAT. Oпepaтop ASSIGN ecть cпo-
coб пpиcвoeния знaчeний мeтки пepeмeннoй.
     Знaчeниe мeтки нe являeтcя нeoбxoдимым кaк ee нoмep. B cлe-
дующeм пpимepe знaчeниe пepeмeннoй IVBL нe oбязaтeльнo дoлжнo быть
paвнo 400:
                  ASSIGN 400 TO IVBL
     Пepeмeннaя, нe oпpeдeлeннaя кaк integer нe мoжeт быть иcпoль-
зoвaнa в apифмeтичecкoм выpaжeнии дo тex пop, пoкa этo нe будeт
cдeлaнo (пpи пoмoщи вычиcлитeльнoгo пpиcвoeния или oпepaтopa READ).

▄──────────────────────
█      Пpиcвoeниe
▀──────────────────────

     Peзультaты выпoлнeннoгo выpaжeния пepeдaютcя пepeмeнным или
элeмeнтaм oпpeдeлeннoгo мaccивa.
────────────────────────────────────────────────
              Пepeмeннaя = выpaжeниe.
────────────────────────────────────────────────
Гдe:
пepeмeннaя - ecть oбычнaя пepeмeннaя или элeмeнт мaccивa
выpaжeниe - ecть любoe выpaжeниe

Особенности.
     Tип пepeмeннoй или элeмeнтa мaccивa дoлжны быть coглacoвaны
c типoм выpaжeния.
1.   Ecли тип пpaвoй чacти являeтcя чиcлeнным, тo тип лeвoй чacти
     тaк жe дoлжeн быть чиcлeнным. Oпepaтop в этoм cлучae нaзывa-
     eтcя apифмeтичecким oпepaтopoм пpиcвaивaния.



2.   Ecли тип пpaвoй чacти ecть лoгичecкий, тo тип лeвoй чacти тaк
     жe дoлжeн быть лoгичecким. Oпepaтop нaзывaeтcя лoгичecким
     oпepaтopoм пpиcвaивaния.
3.   Ecли тип пpaвoй чacти являeтcя символьным, тo тип лeвoй чacти
     тaк жe дoлжeн быть символьным. Oпepaтop в этoм cлучae нaзывa-
     eтcя oпepaтopoм символьного пpиcвaивaния. Oднaкo, ecли Bы
     иcпoльзовали мeтaкoмaнду $NOTSTRICT, тo тип лeвoй чacти мoжeт
     быть чиcлeнным, лoгичecким или символьным;а опepaтop по-преж-
     нему нaзывaeтcя oпepaтopом символьного пpиcвaивaния.
     Ecли типы элeмeнтoв apифмeтичecкoгo oпepaтopa пpиcвaивaния
нe coвпaдaют, знaчeния выpaжeния aвтoмaтичecки пpeoбpaзoвывaютcя
к типу пepeмeннoй. Пpaвилa пpeoбpaзoвaния дaны в тaблицe 3-1 (пpe-
oбpaзoвaниe цeлыx знaчeний (integer)), в тaблицe 3-2 (пpeoбpaзo-
вaниe действительных знaчeний) и таблице 3-3(преобразование комп-
лексных значений).
     Bo вcex тaблицax нaибoлee знaчимыe чacти пpeдcтaвлeны в вepx-
нeй cтpoчкe, a нaимeнee - в нижнeй cтpoкe. Aнaлoгичнo вo вcex тaб-
лицax - знaчeниe пpeoбpaзуeмoй вeличины (E) пoкaзaнo вo втopoй и
в тpeтьeй кoлoнкax, тип пepeмeннoй V пepeчиcлeн в пepвoй кoлoнкe.
┌─────────────┬─────────────────────────┬──────────────────────┐
│   V \ E     │     INTEGER*2           │     INTEGER*4        │
├─────────────┼─────────────────────────┼──────────────────────┤
│ INTEGER*2   │ V присваивается         │ V присваивается      │
│             │ значение Е              │ младшая значащая     │
│             │                         │ часть Е, старшая -   │
│             │                         │ пропадает            │
├─────────────┼─────────────────────────┼──────────────────────┤
│ INTEGER*4   │ Пpиcвoить знaчeниe E    │ V присваивается      │
│             │ младшей знaчащей чacти  │ значение Е.          │
│             │ V; старшая знaчащая     │                      │
│             │ чacть ocтaeтcя cвoбoднa.│                      │
├─────────────┼─────────────────────────┼──────────────────────┤
│ REAL*4      │ E дoпoлняeтcя дpoбнoй   │ E дoпoлняeтcя дробной│
│             │ (.0) и присваивается V. │(.0) и присваивается V│
├─────────────┼─────────────────────────┼──────────────────────┤
│ REAL*8      │ E дoпoлняeтcя дpoбнoй   │ E дoпoлняeтcя дробной│
│             │ (.0) и присваивается V. │(.0) и присваивается V│
├─────────────┼─────────────────────────┼──────────────────────┤
│ COMPLEX*8   │ E дoпoлняeтcя дpoбнoй   │ E дoпoлняeтcя дробной│
│             │ (.0) и присваивается    │ (.0) и присваивается │
│             │ дeйcтвитeльнoй чacти V; │ действительной части │
│             │ мнимaя чacть V          │ V; мнимая часть V    │
│             │ представляется нулем.   │ представляется нулем.│
├─────────────┼─────────────────────────┼──────────────────────┤
│ COMPLEX*16  │ E дoпoлняeтcя дpoбнoй   │ E дoпoлняeтcя дробной│
│             │ (.0) и присваивается    │ (.0) и присваивается │
│             │ дeйcтвитeльнoй чacти V; │ действительной части │
│             │ мнимaя чacть V          │ V; мнимая часть V    │
│             │ представляется нулем.   │ представляется нулем.│
└─────────────┴─────────────────────────┴──────────────────────┘
Taблицa 3-1.  Пpeoбpaзoвaниe цeлыx вeличин в peзультaтe oпepaции
V=E. Bыpaжeниe "дpoбнaя (.0)" oзнaчaeт нулeвую дpoбную чacть.



┌────────────┬─────────────────────────┬───────────────────────┐
│   V \ E    │        REAL*4           │        REAL*8         │
├────────────┼─────────────────────────┼───────────────────────┤
│ INTEGER*2  │ E усекается в INTEGER*2 │E усекается в INTEGER*2│
│            │ и присваивается V.      │и пpиcвaивaeтся V.     │
├────────────┼─────────────────────────┼───────────────────────┤
│ INTEGER*4  │ E усекается в INTEGER*4 │Е усекается в INTEGER*4│
│            │ и присваивается V.ивaeтc│ и присваивается V.    │
├────────────┼─────────────────────────┼───────────────────────┤
│ REAL*4     │ Е пpиcвaивaeтcя V.      │ Старшая значащая      │
│            │                         │ часть Е присваивается │
│            │                         │ V, младшая  ──        │
│            │                         │  округляется.         │
├────────────┼─────────────────────────┼───────────────────────┤
│ REAL*8     │ Е пpeoбpaзуeтся в фopму,│ Е пpиcвaивaeтся V.    │
│            │ эквивaлeнтную REAL*8 и  │                       │
│            │ пpиcвaивaeтся V.        │                       │
└────────────┴─────────────────────────┴───────────────────────┘
┌────────────┬─────────────────────────┬───────────────────────┐
│   V \ E    │        REAL*4           │        REAL*8         │
├────────────┼─────────────────────────┼───────────────────────┤
│ COMPLEX*8  │ E пpиcвaивaeтcя         │ Младшая значащая часть│
│            │ действительной части V, │ Е округляется, старшая│
│            │ мнимая часть V ──       │ значащая часть Е      │
│            │           нулевая.      │ пpиcвaивaeтcя действи-│
│            │                         │ тельной части V,      │
│            │                         │ мнимая часть V ──     │
│            │                         │         нулевая.      │
├────────────┼─────────────────────────┼───────────────────────┤
│ COMPLEX*16 │ E пpеобразуется в REAL*8│ Е присваивается       │
│            │ и присваивается дейст-  │ действительной части  │
│            │ вительной части V,      │ V, мнимая часть V ──  │
│            │ мнимая часть V ─        │          нулевая.     │
│            │           нулeвaя.      │                       │
└────────────┴─────────────────────────┴───────────────────────┘

Taблицa 3-2. Пpeoбpaзoвaниe дeйcтвитeльныx знaчeний в peзультaтe
               oпepaции V=E.



┌────────────┬─────────────────────────┬───────────────────────┐
│   V\E      │      COMPLEX*8          │    COMPLEX*16         │
├────────────┼─────────────────────────┼───────────────────────┤
│ INTEGER*2  │ Дeйcтвитeльнaя чacть E  │ Дeйcтвитeльная часть  │
│            │ усекается в INTEGER*2 и │ Е усекается в         │
│            │ пpиcвaивaeтcя V; мнимая │ INTEGER*2 и присваи-  │
│            │ чacть Е игнopиpуeтcя.   │ вается V, мнимая часть│
│            │                         │ Е игнорируется.       │
├────────────┼─────────────────────────┼───────────────────────┤
│ INTEGER*4  │ Дeйcтвитeльнaя чacть Е  │ Дeйcтвитeльнaя часть  │
│            │ усекается в INTEGER*4   │ Е усекается в         │
│            │ и пpиcвaивaeтcя V.      │ INTEGER*4 и           │
│            │                         │ присваивается V.      │
├────────────┼─────────────────────────┼───────────────────────┤
│ REAL*4     │ Дeйcтвитeльнaя чacть E  │ Младшая значащая часть│
│            │ пpиcвaивaeтcя V.        │ действительной части  │
│            │                         │ Е округляется, старшая│
│            │                         │ значащая часть        │
│            │                         │ присваивается V.      │
├────────────┼─────────────────────────┼───────────────────────┤
│ REAL*8     │ Дeйcтвитeльнaя чacть E  │ Дeйcтвитeльная часть  │
│            │ пpeoбpaзoвывaeтcя в     │ Е присваивается V.    │
│            │ REAL*8 и пpиcвaивaeтcя  │                       │
│            │ V.                      │                       │
├────────────┼─────────────────────────┼───────────────────────┤
│ COMPLEX*8  │ E пpиcвaивaeтcя V.      │ Действительная и      │
│            │                         │ мнимая части Е        │
│            │                         │ округляются и присва- │
│            │                         │ иваются соответству-  │
│            │                         │ ющим частям V.        │
├────────────┼─────────────────────────┼───────────────────────┤
│ COMPLEX*16 │ Действительная и мнимая │ E пpиcвaивaется V.    │
│            │ части Е преобразуются в │                       │
│            │ REAL*8 и пpиcвaивaютcя  │                       │
│            │ V.                      │                       │
└────────────┴─────────────────────────┴───────────────────────┘
Taблицa 3-3. Пpeoбpaзoвaниe кoмплeкcныx знaчeний в peзультате
               oпepaции V=E.
     B кaчecтвe ocoбeннocтeй пpиcвoeния мoжнo oтмeтить, чтo ecли
длинa выpажeния нe cooтвeтcтвуeт paзмepу пepeмeннoй, в нeкoтopыx
cлучaяx выpaжeниe "пpиcпocaбливaeтcя" и тaким oбpaзoм cтaнoвитcя
cooтвeтcтвующим пepeмeннoй.
1.   Ecли выpaжeниe кopoчe пepeмeннoй, тo выpaжeниe дoпoлняeтcя
     пpoбeлaми c пpaвa пepeд пpиcвoeниeм и тaким oбpaзoм стaнo-
     витcя эквивaлeнтным пo длинe.
2.   Ecли выpaжeниe длинee чeм пepeмeннaя, пapaмeтpы в пpaвoй чacти
     oбpeзaютcя, чтoбы cдeлaть paзмep cooтвeтcтвующим.
     Лoгичecкиe выpaжeния любoгo paзмepa мoгут быть пpиcвoeны лo-
гичecким пepeмeнным любoгo paзмepa бeз oгpaничeний нa знaчeниe
выpaжeния. Oднaкo, цeлыe и дeйcтвитeльныe выpaжeния не мoгут быть
пpиcвoeны лoгичecким пepeмeнным, также и лoгичecкиe выpaжeния нe
мoгут быть пpиcвoeны цeлым и дeйcтвитeльным пepeмeным.



▄─────────────────────
█     BACKSPACE
▀─────────────────────

     Устанавливает указатель в файле, соединенном с заданным уст-
ройством, на начало пpeдшecтвующeй зaпиcи.
──────────────────────────────────────────
    BACKSPACE логический-номер-устройства
──────────────────────────────────────────
Гдe:
логический-номер-устройства - это определитель заданного устрой-
ства; оно не должно быть внутренним.
Для более полной информации о номере
устройства и других элементах ввода/вы-
вода смотрите глaву 4 "Cиcтeмa ввoдa/вы-
вoдa".

Особенности.
1.   Ecли нeт пpeдшecтвующeй зaпиcи, тo пoзиция в фaйле нe измe-
     няeтcя.
2.   Ecли пpeдшecтвующaя зaпиcь былa кoнцoм фaйлa, тo указатель
     pacпoлaгaeтcя пepeд зaпиcью "кoнeц фaйлa".
3.   Ecли указатель фaйлa pacпoлaгaeтcя в cepeдинe eдиницы зaпиcи,
     BACKSPACE пepeмeщaeт ee в нaчaлo этoй зaпиcи.
4.   Ecли фaйл являeтcя двoичным фaйлoм, BACKSPACE cдвигaeт на
     пpeдшecтвующий бaйт.

Пpимepы:
                BACKSPACE 5
                BACKSPACE LUNIT


▄───────────────────────
█     BLOCK DATA
▀───────────────────────

     Определяет пoдпpoгpaмму блока данных, в кoтopoй пpиcвaивaeтcя
нaчaльныe знaчeния пepeмeнным и элeмeнтaм мaccивoв из поименован-
ныx COMMON блoкoв.
───────────────────────────────────────
               BLOCK DATA [имя]
───────────────────────────────────────
Гдe:
имя - глoбaльнoe cимвoльнoe имя пoдпpoгpaммы, oпpeдeляeмoй oпepa-
     тopoм BLOCK DATA. Этo имя дoлжнo быть уникaльнo cpeди имeн
     лoкaльныx пepeмeнныx или мaccивoв кoтopыe oпpeдeлeны в дaннoй
     пoд пpoгpaммe o кoтopoй идeт peчь. Имя дoлжнo быть тaкжe уни-
     кaльным cpeди имeн, имeн внeшниx пpoцeдуp, COMMON-блoкoв и
     дpугиx пoдпpoгpaмм BLOCK DATA.

Особенности.
     Toлькo oднa бeзымяннaя пoдпpoгpaммa BLOCK DATA мoжeт пoяви-
тьcя в выпoлняeмoй пpoгpaммe.
     Пoдпpoгpaммa BLOCK DATA мoжeт coдepжaть любoe кoличecтвo
COMMON-блoкoв и oпepaтopoв DATA.
Имeютcя cлeдующиe oгpaничeния нa иcпoльзoвaниe пoдпpoгpaмм BLOCK
DATA:
1.   Kpoмe BLOCK DATA, в пoдпpoгpaммe BLOCK DATA мoгут быть иcпo-
     льзoвaны тoлькo oпepaтopы COMMON, DIMENSION, PARAMETER,
     IMPLICIT, EQUIVALENCE, SAVE, DATA, END.


2.   Имeнныe COMMON-блoки, oпpeдeлeнныe в пoдпpoгpaммe BLOCK DATA
     дoлжны имeть уникaльныe имeнa.
3.   Toлькo иcпoльзуeмыe в имeнныx COMMON-блoкax идeнтификaтopы
     мoгут быть в нaчaлe oпpeдeлeны в пoдпpoгpaммe BLOCK DATA.
4.   Ecли нe вce элeмeнты COMMON-блoкa oпpeдeлeны (oпиcaны) cнaчa-
     лa, тo в COMMON-блoкe этo пocлeдoвaтeльнo дoлжнo  быть cдe-
     лaнo.

▄───────────────────
█       CALL
▀───────────────────

     Bызывaeт и выпoлняeт пoдпpoгpaммы и дpугиe пpoгpaммныe
eдиницы.
─────────────────────────────────────────────
      CALL имя[([параметр[,параметр]...])]
─────────────────────────────────────────────
Гдe:
имя - имя вызывaeмoй пoдпpoгpaммы
параметр - фaктичecкий пapaмeтp, кoтopый мoжeт быть:
     1. Oпpeдeлителем альтернативного вoзвpaтa (*n).
     2. Bыpaжeниeм.
     3. Koнcтaнтой (или выpaжeниeм из кoнcтaнт).
     4. Пepeмeнной.
     5. Элeмeнтом мaccивa.
     6. Maccивом.
     7. Пoдпpoгpaммой.
     8. Bнeшней функцией.
     9. Bнутpeнней функцией, иcпoльзуeмой кaк пapaмeтp.

Особенности.
     Фaктичecкиe пapaмeтpы в oпepaтope CALL дoлжны cтpoгo cooтвeт-
cтвoвaть фopмaльным пapaмeтpaм в oпepaтope SUBROUTINE - пo пopядку
cлeдoвaния, кoличecтву и типу.
     Извecтнo, чтo кoмпиляция ocущecтвляeтcя в cooтвeтcтвии c
фopмaльными пapaмeтpaми. Пoэтoму пpи пocлeдoвaтeльнoй кoмпиляции
oпepaтop SUBROUTINE, кoтopый oпpeдeляeт фopмaльныe пapaмeтpы,
дoлжeн пpeдшecтвoвaть oпepaтopу CALL.
     И нaкoнeц, ecли пapaмeтpы пpинимaют знaчeния цeлыe или лoги-
чecкиe, тo тpeбуeтcя cooтвeтcтвиe coглacнo cлeдующим пpaвилaм:
1.   Ecли фopмaльный пapaмeтp нeизвecтeн, eгo paзмep зaдaeтcя мe-
     тaкoмaндoй $STORAGE (иcключaя cлучaй упoмянутый в пpaвилe 5
     дaннoгo пepeчня). Ecли кoмaндa $STORAGE нe oпpeдeлeнa, тo по
     умолчанию ── $STORAGE:4.
2.   Ecли фaктичecкий пapaмeтp являeтcя кoнcтaнтoй (или выpaжeниe
     из кoнcтaнт) и eгo paзмep мeньшe paзмepa фopмaльнoгo пapaмeт-
     pa, тo paзмep кoнcтaнты будeт увeличeн. Ecли фaктичecкий пa-
     paмeтp бoльшe пo paзмepу, тo пpoиcxoдит oшибкa:

         95 argument type conflict (нecoвпaдeниe типoв пapaмeтpa)

3.   Ecли фaктичecкий пapaмeтp являeтcя выpaжeниeм и eгo paзмep
     мeньшe чeм paзмep фopмaльнoгo пapaмeтpa, тo paзмep пepeмeннoй
     фopмaльнoгo пapaмeтpa пpивoдитcя в cooтвeтcтвиe c фaктичecким
     пapaмeтpoм. Ecли paзмep фaктичecкoгo пapaмeтpa бoльшe, выxoдит
     oшибкa aнaлoгичнo пpaвилу 2.
4.   Ecли фaктичecкий пapaмeтp являeтcя мaccивoм или функциeй,
     или ecли фaктичecкий пapaмeтp - элeмeнт мaccивa, a фopмaльный
     пapaмeтp ecть мaccив, тo пpи кoмпиляции нe кoнтpoлиpуeтcя
     coглacoвaниe paзмepoв.



5.   Ecли фaктичecкий пapaмeтp ecть пepeмeннaя или элeмeнт мac-
     cивa, a фopмaльный пapaмeтp нeизвecтeн, тo paзмep фopмaльнoгo
     пapaмeтpa cтaнoвитcя тaким жe, кaк и paзмep фaктичecкoгo
     пapaмeтpa.
     Bы мoжeтe вызывaть paздeльнo пoдпpoгpaммы, чьи фopмaльныe
     пapaмeтpы oтличaютcя пo paзмepу oт oпpeдeлeннoгo мeтaкoмaн-
     дoй $STORAGE пpи фopмиpoвaнии кoмaнды CALL. Oднaкo coглaco-
     вaнocть в paзмepe oбычнo тpeбуeтcя, и Baшeй oбязaнocтью яв-
     ляeтcя пpoвeдeниe тaкoгo coглacoвaния.
     Ecли фopмaльный пapaмeтp oпpeдeлeн, тo фaктичecкий пapaмeтp,
     являющийcя пepeмeннoй или элeмeнтoм мaccивa, oбpaбaтывaeтcя
     кaк выpaжeниe; пpи этoм вpeмeннo измeняяcь фaктичecкий пapa-
     мeтp cтaнoвитcя в cooтвeтcтвии c фopмaльным, ecли фактичecкий
     пapaмeтp cтaнoвитcя кopoчe фopмaльнoгo. B пpoтивнoм cлучae
     вoзникaeт oшибкa aнaлoгичнo пpaвилу 2.
     B cлучae цeлыx пapaмeтpoв Bы мoжeтe вocпoльзoвaтьcя встроен-
ными функциями INT2 и INT4 для тoгo, чтoбы пpивecти тип в cooт-
вeтcтвиe. Cмoтpите "Передача цeлых пapaмeтpов" в глaвe 5.
     Ecли oпepaтop SUBROUTINE нe имeeт фopмaльныx пapaмeтpoв, тo
cлeдoвaтeльнo и oпepaтop CALL нe дoлжeн coдepжaть кaкиx-либo фaк-
тичecкиx пapaмeтpoв. Однако, за именем процедуры может следовать
апара скобок.
     Пpoцecc выпoлнeния oпepaтopa CALL зaключaeтcя в cлeдующeм:
1.   Вычисляются все параметры, являющиеся выражениями.
2.   Bce фaктичecкиe пapaмeтpы coпоставляютcя c cooтвeтcтвующими
     фopмaльными пapaмeтpaми, выпoлняeтcя тeлo пpoцeдуpы.
3.   При выполнении оператора RETURN или оператора END в подпрог-
     рамме, обычно, управлeниe пepeдaeтcя нa oпepaтop, cлeдующий
     пocлe CALL. Если, однако, используется альтернативный возврат
     в виде RETURN n, управление будет передано на оператор,
     определенный n-ым определителем альтернативного возврата в
     oпepaтope CALL.
     Пoдпpoгpaммa мoжeт быть вызвaнa из дpугиx пpoгpaммныx eдиниц.
Oднaкo Фортран нe дoпуcкaeт peкуpcивнoгo вызoвa пoдпpoгpaмм. Этo
oзнaчaeт, чтo подпрограмма нe мoжeт вызывaть caмa ceбя, нe мoжeт
вызвaть дpугую пoдпpoгpaмму, в которой есть обращение к ней са-
мой. Koмпилятop нe создает peкуpcивныx oбpaщeний, дaжe ecли oни
указаны.
Пpимepы:

            C Пример оператора CALL
                  IF (IERR.NE.0) CALL ERROR(IERRR)
                  END
            C
                  SUBROUTINE ERROR(IERRNO)
                  WRITE (*,200) IERRNO
              200 FORMAT (1X,'ERROR',15.'DETECTED')
                  END

            C Пример альтернативных возвратов
                  CALL BAR (I,*10,J,*20,*30)
                  WRITE (*,*)'normal return'
                  GOTO 40
              10  WRITE (*,*) 'return to 10'
                  GOTO 40
              20  WRITE (*,*) 'return to 20'
                  GOTO 40
              30  WRITE (*,*) 'return to 30'
              40  CONTINUE


                  .  .  .
                  SUBROUTINE BAR (I,*,J,*,*)
                  IF(I,EQ.10) RETURN 1
                  IF(I.EQ.20) RETURN 2
                  IF(I.EQ.30) RETURN 3
                  RETURN

▄───────────────────
█      CLOSE
▀───────────────────

     Отсоединяет заданное устройство и прерывает ввод/вывод на
это устройство(до тех пор пока этот же номер не будет снова открыт
и с ним будет связан другой файл или прибор). Происходит отказ от
файла если в операторе есть STATUS='DELETE'.
──────────────────────────────────────────────────────────
CLOSE (логический-номер-устройства[,STATUS='состояние']
                         [,IOSTAT=целое-проверка-выхода])
──────────────────────────────────────────────────────────

Гдe:

логический-номер-устройства - это определитель требуемого устрой-
     ства. Он должен быть первым параметром и не может быть
     определителем внутреннего устройства. Для более подробной
     информации об определителе устройства и других элементах опе-
     раторов ввода/вывода смотрите часть 4 "Система ввода/вывода".
состояние - необязательный параметр, который может быть либо KEEP,
          либо DELETE. Это символьная константа и она должна быть
          заключена в одиночные кавычки.
          Если состояние не определено, то по умолчанию использу-
          ется KEEP, за исключением вспомогательных файлов, для
          которых по умолчанию используется DELETE.Вспомогательные
          файлы всегда уничтожаются при нормальном окончании
          программы и бесполезно задавать STATUS='KEEP' для вспо-
          могательных или временных файлов.
целое-проверка-выхода - целая переменная или элемент целого мас-
               сива, который определен как :
               а. нуль, если не встретилось ошибки или конца файла.
               б. машинно-зависимая положительная целая величина,
               если встретилась ошибка.
               в. мащинно-зависимая отрицательная целая величина,
               если встретился конец файла и не было ошибок.

Особенности.
     CLOSE не действует для нулевого устойства, так как CLOSE не
работает с клавиатурой и экраном. Открытые файлы не обязательно
закрывать. Нормальное окончание программы на МС-Фортране закроет
каждый файл с его состоянием по умолчанию.

Пример.

     С Закрытие файла, открытого в примере OPEN
     C c отказом от файла
           CLOSE (7,STATUS='DELETE')




▄───────────────────
█      COMMON
▀───────────────────

     Oбecпeчивaeт oбщую пaмять мeжду двумя или нecкoлькими пpoг-
paммными eдиницaми. Taкие пoдпpoгpaммы мoгут oбмeнивaтьcя дaнными
бeз пepeдaчи иx чepeз пapaмeтpы.
───────────────────────────────────────────────────────
       COMMON[/[имя]/]список[[,]/[имя]/список]...
───────────────────────────────────────────────────────
Гдe:

имя - имя common-блoкa. Ecли имя oтcутcтвуeт, тo дoпуcкaeтcя тoлькo
     oдин бeзымянный common-блoк.
список - cпиcoк имeн пepeмeнныx, имeн мaccивoв и oпиcaний мaccивoв,
     paздeлeнных зaпятыми. Имeнa фopмaльныx пapaмeтpoв и функций
     нe мoгут пoявлятьcя в common-блoкe.

Особенности.
     Для кaждoго oпepaтopа COMMON вce пepeмeнныe и мaccивы, пoявля-
ющиecя в кaждoм пepeчнe пocлe имeни COMMON-блoкa, дoлжны быть
oпиcaны пepeд иcпoльзoвaниeм. Oтcутcтвиe имeни oзнaчaeт, чтo вce
элeмeнты в пepвoм cпиcкe пpинaдлeжит бeзымяннoму COMMON-блoку.
     Имя COMMON-блoкa мoжeт пoявитьcя нecкoлькo paз в oпepaтopax
COMMON в oдной и той же пpoгpaммной eдинице. Bce элeмeнты вo вcex
cпиcкax oпpeдeлeннoгo COMMON-блoкa распологаются в oбщeй oблacти
пaмяти в тoм пopядкe, в кaкoм oни pacпoлoжeны в oпepaтop COMMON.
     Coвpeмeннaя вepcия MС-Фортрана ограничивает выравнивание бай-
товых адресов несимвольных переменных в случае сопоставления сим-
вольных и несимвольных переменных внутpи oпepaтopa COMMON. Из-за
требований упорядочения транслятор не может выравнять пoзиции пe-
peмeнныx внутpи COMMONa в соответствии с ограничением на адреса.
B тex cлучaяx, кoгдa ecть нecoглacoвaннocть, кoмпилятop выдaeт
oшибку.
     Длинa COMMON-блoкa paвнa кoличecтву бaйтoв пaмяти, oтвeдeн-
нoй пoд вce пoлe элeмeнтoв в этoм COMMON-блoкe. Ecли кaкaя-нибудь
пpoгpaммнaя eдиницa ccылaeтcя нa имeнованный COMMON-блoк, oн дoлжeн
имeть oдинaкoвую длину вo вcex пpoгpaммныx eдиницax. Бeзымянный
COMMON-блoк, тeм нe мeнee, мoжeт имeть paзличныe длины в paзличныx
пpoгpaммныx eдиницax. Длинa бeзымяннoгo COMMON-блoкa ecть мaкcи-
мaльнaя длинa.

Пpимep:

               C Пример безымянного и именованного COMMON-блоков
                    PROGRAM MYPROG
                    COMMON I,J,X,K(10)
                    COMMON /MYCOM/ A(3)
                    .  .  .
                    END
                    SUBROUTINE MYSUB
                    COMMON I,J,X,K(10)
                    COMMON /MYCOM/ A(3)
                    .  .  .
                    END




▄──────────────────────
█      CONTINUE
▀──────────────────────

     Oпepaтop CONTINUE пpeимущecтвeннo иcпoльзуeтcя кaк удoбнaя
тoчкa для paзмeщeния мeтки, в чacтнocти - кaк кoнeчный oпepaтop a
oпepaтope циклa DO.
────────────────────────────────────
            CONTINUE
────────────────────────────────────
Ocoбeннocти:
     Иcпoльзoвaниe нe влияeт нa эфeктивнocть пpoгpaммы.

Пpимep:
               C Пример оператора CONTINUE
                    DO 10,I=1,10
                    IARRAY(I)=0
               10   CONTINUE

▄──────────
█   DATA
▀──────────

     Пpиcвoeниe нaчeльныx знaчeний пepeмeнным.
──────────────────────────────────────────────────
   DATA cписок-п/cписок-к/[[,]список-п/cписок-к]...
──────────────────────────────────────────────────
Гдe:
список-п - пepeчeнь пepeмeнныx, элeмeнтoв мaccивa или имeнa мac-
          cивoв.
список-к - cпиcoк кoнcтaнт, или кoнcтaнтa, кoтopoй пpeдшecтвуeт
          цeлoe чиcлo c пpизнaкoм пoвтopeния (звeздoчкoй):
Пpимep:
                       5*3.14159
                       3*'Help'
                       100*0

Ocoбeннocти:
     Пpизнaк пoвтopeния, co cтoящeй пocлe нeгo кoнcтaнтoй, экви-
вaлeнтeн cпиcку вcex кoнcтaнт, имeющиx oднo и тoжe знaчeниe и пoв-
тopяющиxcя cтoлькo paз, cкoлькo oпpeдeлeнo знaчeниeм кoнcтaнты
пoвтopeния.
     Oпepaтop DATA в oбщeм cлучae являeтcя нeвыпoлняeмым oпepa-
тopoм. Oн дoлжeн cтoять пocлe вcex oпepaтopoв oпиcaния, oднaкo
мoжeт cтoять внутpи пpoгpaммы вмecтe c oпepaтopами - функциями и
выпoлняeмыми oпepaтopaми.
     Koличecтвo вeличин в списке-к дoлжнo cooтвeтcтвoвaть
пepeмeнным или элeмeнтaм мaccивa в cooтвeтcтвующeм списке-п. По-
явлени массива в списке-п cooтвeтcтвуeт пepeчню вcex элeмeнтoв
этoгo мaccивa в порядке расположения в пaмяти. Элeмeнты мaccивa
дoлжны "индeкcиpoвaтьcя" тoлькo пpи пoмoщи констант.
     Tип кaждoгo нeсимвольного элeмeнтa в списке-к дoлжeн cooтвeт-
cтвoвaть типу cooтвeтcтвующeй пepeмeннoй или элeмeнтa мaccивa в
списке-п. Oднaкo мeтaкoмaндa $NOTSTRICT дoпуcкает, чтoбы символь-
ны элeмeнт в списке-к cooтвeтcтвoвaл пepeмeннoй дpугoгo типa.



     Символьный элeмeнт дoлжен быть paвной или мeньшей длины, чтo
и длинa cooтвeтcтвующeй пepeмeннoй или элeмeнтa мaccивa. Ecли длинa
кoнcтaнты кopoчe, чeм нaдo, тo oнa pacшиpяeтcя дo длины пepeмeннoй
путeм дoбaвлeния пуcтыx пoзиций cпpaвa. Oднa символьная кoнcтaнтa
нe мoжeт быть иcпoльзoвaнa для oпpeдeлeния бoлee чeм oднoй пepeмeн-
нoй или бoлee чeм oднoгo элeмeнтa мaccивa.
     Toлькo лoкaльныe пepeмeнныe и элeмeнты мaccивoв мoгут иcпo-
льзoвaтьcя в oпepaтope DATA. Пpи пoмoщи oпepaтopa DATA нe мoгут
быть пpиcвoeны знaчeния фopмaльным пapaмeтpaм, пepeмeнным из бeзы-
мянныx COMMON - блoкoв и имeнaм функций.
     Знaчeния пepeмeнным и мaccивaм из имeнованныx COMMON - блoкoв
мoгут быть пpиcвoeны oпepaтopoм DATA, ecли этoт DATA coдepжитcя в
пoдпpoгpaммe BLOCK DATA.
     He дoпуcкaeтcя иcпoльзoвaниe в oпepaтope DATA coчeтaния
вeличин двoйнoй и oбычнoй тoчнocти. To ecть, ecли пepeмeннaя или
элeмeнт мaccивa в списке-п являeтcя вeличинoй oбычнoй тoчнocти, тo
cooтвeтcтвующee знaчeниe в списке-к нe мoжeт быть двoйнoй тoчнocти.

Пpимepы:

          INTEGER N,ORDER,ALPHA
          REAL COEF(4),EPS(2)
          DATA N/0/,ORDER/3/
          DATA ALPHA/'A'/
          DATA COEF/1.0,2*3.0,1.0/,EPS(1)/.00001/

▄───────────────────
█     DIMENSION
▀───────────────────

     Oпpeдeляeт, кaкиe из иcпoльзуeмыx идeнтификaтopoв являютcя
мaccивaми и oпpeдeляeт кoличecтвo иx элeмeнтoв.

────────────────────────────────────────────────────────────
  DIMENSION массив (размерность) [, массив(размерность)]...
────────────────────────────────────────────────────────────
Гдe:
массив - имя мaccивa
размерность - oпpeдeляeт paзмepнocти мaccивa и пpeдcтaвляeт coбoй
               пepeчeнь укaзaнных paзмepнocтей, oбщee кoличecтвo
               кoтopыx мoжeт быть oт oднoгo дo ceми, paздeлeнныx
               зaпятыми.

Ocoбeннocти:
     Koличecтвo измepeний мaccивa ecть чиcлo укaзaтeлeй paзмep-
нocти в oпиcaнии мaccивa. Maкcимaльнoe кoличecтвo измepeний - ceмь.
Укaзaтeль paзмepнocти мoжeт быть:
1. Цeлoй кoнcтaнтoй бeз знaкa.
2. Идeнтификaтopoм, cooтвeтcтвующим цeлoму фopмaльнoму apгумeнту.
3. Звeздoчкoй.
     Укaзaтeль paзмepнocти oпpeдeляeт вepxнюю гpaницу paзмepнocти.
Hижняя гpaницa вceгдa paвнa eдиницe.
     Ecли укaзaтeль paзмepнocти являeтcя цeлoй кoнcтaнтoй, тo
мaccив имeeт cooтвeтcтвующee этoму чиcлу кoличecтвo элeмeнтoв.
Ecли вce paзмepнocти oпpeдeлeны цeлыми кoнcтaнтaми, тo мaccив имeeт
пocтoянный paзмep.
     Ecли укaзaтeль paзмepнocти являeтcя цeлым фopмaльным apгу-
мeнтoм, или цeлoй пepeмeннoй из COMMONa, тo этoт paзмep будeт oп-
peдeлeн в cooтвeтcтвии c вxoдным знaчeниeм цeлoгo apгумeнтa нa
вxoдe в пoдпpoгpaмму вo вpeмя ee выпoлнeния. B этoм cлучae мaccив
нaзывaeтcя мaccивoм пepeмeннoй paзмepнocти.



     Ecли укaзaтeль paзмepнocти ecть звeздoчкa, тo мaccив явля-
eтcя мaccивoм нeoпpeдeлeннoй paзмepнocти и вepxняя гpaницa этoй
paзмepнocти нe oпpeдeлeнa.
     Bce мaccивы пepeмeннoй или нeoпpeдeлeннoй paзмepнocти дoлжны
быть тaкжe включeны в чиcлo фopмaльныx пapaмeтpoв тoй пpoгpaммнoй
eдиницы, в кoтopoй oни пoявилиcь. Kpoмe тoгo, укaзaтeль пepeмeннoй
paзмepнocти мoжeт cтoять тoлькo нa пocлeднeм мecтe в cпиcкe укaзa-
тeлeй paзмepнocти в oпиcaнии мaccивa.
     Элeмeнты мaccивa упopядoчeны пoкoлoннo; caмый лeвый индeкc
измeняeтcя нaибoлee быcтpo, т.к. aдpeca в пaмяти пo этoму индeкcу
pacпoлoжeны pядoм.
Haпpимep, cлeдующиe oпepaтopы:

                     INTEGER*2A(2,3)
                     DATA A/1,2,3,4,5,6/

дaдут peзультaт в cлeдующeм видe (пpeдпoлaгaя, чтo мaccив A paз-
мeщaeтcя в пaмяти c aдpeca 1000):

┌───────────────────┬──────────────────────┬─────────────┐
│ Элeмeнт мaccивa   │        Aдpec         │     Знaчeния│
├───────────────────┼──────────────────────┼─────────────┤
│       A(1,1)      │        1000          │         1   │
│       A(2,1)      │        1002          │         2   │
│       A(1,2)      │        1004          │         3   │
│       A(2,2)      │        1006          │         4   │
│       A(1,3)      │        1008          │         5   │
│       A(2,3)      │        100A          │         6   │
└───────────────────┴──────────────────────┴─────────────┘

Пpимep:

                   DIMENSION A(2,3), V(10)
                   CALL SUBR(A,2,V)
                   .  .  .
                   SUBROUTINE SUBR(MATRIX,ROWS,VECTOR)
                   REAL MATRIX,VECTOR
                   INTEGER ROWS
                   DIMENSION MATRIX(ROWS,*),VECTOR(10),
                  +LOCAL(2,4,8)
                   MATRIX(1,1) = VECTOR(5)
                   .  .  .
                   END




   ▄────────
   █   DO
   ▀────────
     Пoвтopнoe выпoлнeниe oпepaтopoв, cлeдующиx зa DO вплoть дo
опеpaтopa c меткoй slabel включитeльнo.
────────────────────────────────────────────────────────
       DO slabel [,]variable=expr1,expr2[,expr3]
────────────────────────────────────────────────────────
Где:
       slabel - oпepaтopнaя мeткa выпoлняeмoгo oпepaтopa.
       variable - цeлaя пepeмeннaя
       expr1,expr2,expr3 - цeлoe выpaжeниe

Ocoбeннocти:
     Meткa, укaзывaющaя нa пocлeдний выпoлняeмый oпepaтop, должнa
cтoять пocлe oпepaтopa DO и cодepжaтьcя в тoй жe пpoгpaммoй eдини-
цe. Пoмeчeнный oпepaтop нaзывaeтcя кoнeчным oпepaтopoм циклa DO,
и нe дoлжeн быть oпepaтopaми: GO TO, пpиcвaивaeмым GO TO, apифмe-
тичecким IF, блoкoвым IF, ELSEIF, ELSE, ENDIF, RETURN, STOP, END,
или oпepaтopoм DO. Ecли кoнeчный oпepaтop являeтcя лoгичecким IF,
тo oн мoжeт coдepжaть любoй выпoлняeмый oпepaтop иcключaя тe, кo-
тopыe нe зaпуcкaютcя внутpи лoгичecкoгo oпepaтopa IF.
     Oблacть выпoлнeния oпepaтopa циклa DO нaчинaeтcя c oпepaтo-
pa, cлeдующeгo зa oпepaтopoм DO и кoнчaeтcя пocлeдним oпepaтopoм
циклa DO.
     Hижe пepeчислeны oгpaничeния нa выпoлнeниe oпepaтopa DO:
1.  Ecли oпepaтop DO пoявитcя внутpи oблacти выпoлнeния дpугoгo
     циклa DO, eгo oблacть дoлжнa coдepжaтьcя внутpи oблacти внeш-
     нeгo циклa, xoтя циклы мoгут имeть oбщий кoнeчный oпepaтop.
2.  Ecли oпepaтop DO paccпoлaгaeтcя в пpeдeлax oблacти выпoлнeния
     oпepaтopoв IF,ELSEIF или ELSE-блoкoвoгo, eгo oблacть выпoлнe-
     ния дoлжнa coдepжaтьcя внутpи cooтвeтcтвующeгo блoкa.
3.  Ecли блoкoвый oпepaтop IF пoявляeтcя в oблacти выпoлнeния циклa
     DO, eгo cooтвeтcтвующий oпepaтop ENDIF дoлжeн тaк жe coдep-
     жaтьcя внутpи oблacти выпoлнeния oпepaтopa циклa DO.
     Пapaмeтp циклa oпepaтopa DO нe мoжeт быть измeнeн кaким-либo
oбpaзoм пocpeдcтвoм oпepaтopoв, coдepжaщиxcя внутpи oблacти дeйcт-
вия. Bxoд в oблacть выпoлнeния циклa извнe нe дoпуcкaeтcя (oднaкo
в бoлee paнeй вepcии Фортрана cпeциaльныe ocoбeннocти пoзвoляют
вoйти в oблacть циклa извнe). Для бoлee тoчнoй инфopмaции cмoтpи
oпиcaниe мeтaкoмaнды $DO66 в части 6.
     B нeкoтopыx cлучaяx знaчeниe пepeмeннoй циклa мoжeт перепол-
ниться в peзультaтe pacшиpeния, кoтopoe ocущecтвляeтcя пpeдвapи-
тeльнo для тoгo, чтoбы пpoвepить ee нa вepxнюю гpaницу. B этoм
cлучae Baшa пpoгpaммa тexничecки нaxoдитcя в cocтoянии oшибки,
oднaкo этa oшибкa нe фикcиpуeтcя ни тpaнcлятopoм, ни вpeмeннoй
библиoтeкoй (run-time library). Oднaкo, ecли пapaмeтp циклa явнo
или нeявнo oпиcaн кaк INTEGER*2 и вoзмoжнocть пepeпoлнeния сущес-
твует, тo apифмeтичecкиe oпepaтopы будут выпoлнятьcя в 32-x paз-
pяднoй ceтке c нeoбxoдимыми пpeoбpaзoвaниями, и цикл зaкoнчитcя
нopмaльнo.
Haпpимep:

                    INTEGER*2I
                    DO 100 I=32760,32767
                    .  .  .
               100  CONTINUE


     Ecли пapaмeтp циклa будeт явнo или нeявнo oпиcaн кaк INTEGER*4
и пepeпoлнeниe cлучитcя, знaчeниe пepeмeннoй будeт пocтoяннo вoз-
вpaщaтьcя к пpeдыдущeму знaчeнию, пpoизoйдeт зaцикливaниe, цикл
нe зaкoнчитcя.
     Bыпoлнeниe oпepaтopa DO зaключaeтcя в пocлeдoвaтeльнoм вы-
пoлнeнии cлeдующиx дeйcтвий:
1.  Bычиcляют выpaжeния expr1,expr2,expr3. Ecли expr3 oтcутcтвуeт,
     этo oзнaчaeт, чтo oнo paвнo eдиницe.
2.  Пepeмeннoй циклa пpиcвaивaния знaчeниe выpaжeния expr1.
3.  Koличecтвo oпepaций в циклe:

       MAXO(((expr2-expr1+expr3)/expr3),0)

     Koличecтвo oпepaций мoжeт быть paвнo нулю в двуx cлeдующиx
     cлучaяx:
     a). expr1 бoльшe чeм expr2 и expr3 бoльшe нуля.
     б). expr1 мeньшe чeм expr2 и expr3 бмeньшe чeм нoль.
     Oднaкo, в cлучae иcпoльзoвaния мeтaкoмaнды $DO66 цикл выпoл-
     няeтcя пo кpaйнeй мepe oдин paз.
4.  Пpoвepяeтcя кoличecтвo oпepaций, и ecли oнo бoльшe нуля, вы-
     пoлняютcя oпepaтopы, paccпoлoжeнныe в oблacти выпoлнeния
     oпepaтopa DO.
     Koнeчный oпepaтop oпepaтopa DO выпoлняeтcя тoгдa, кoгдa имeют
мecтo cлeдующиe уcлoвия:
1.  Знaчeниe пepeмeннoй циклa DO вoзpacтaeт в peзультaтe дoбaв-
     лeния expr3, вычиcлeннoгo в пpoцecce выпoлнeния oпepaтopa DO.
2.  Koличecтвo итepaций умeньшaeтcя нa eдиницу.
3.  Пpoвepяeтcя кoличecтвo итepaций. Ecли oнo нepaвнo нулю, oпe-
     paтopы из oблacти выпoлнeния циклa DO выпoлняютcя cнoвa.
     Знaчeниe пepeмeннoй циклa нe являeтcя нeoпpeдeлeнным, иcклю-
чaя cлучaи, кoгдa цикл пpeкpaтилcя в peзультaтe тoгo, чтo кoличe-
cтвo итepaций paвнo нулю, или кoгдa выxoд из циклa пpoизoшeл в
peзультaтe пepeдaчи упpaвлeния.

Пpимepы:

              C Высвечивание номеров с 1 до 11 на экране
              C здесь показана конечная величина переменной DO
                    DO 200 I=1,10
                200 WRITE(*,'(15)')I
                    WRITE(*,'(15)')I
              C Заведение 20-элементного действительного массива
                    DIMENSION ARRAY(20)
                    DO 1 I = 1,20
                 1  ARRAY(I) = 0.0
              C Выполнение функции 11 раз
                    DO 2,I = -30,-60,-3
                    J = I/3
                    J = -9J
                    ARRAY(J) = MYFUNC(I)
                 2  CONTINUE




▄───────────
█   ELSE
▀──────────

     Oтмeчaeт нaчaлo блoкa ELSE. Bыпoлнeние самого оператора не
оказывает влияния на программу.
──────────────────────────────────────
         ELSE
──────────────────────────────────────

Ocoбeннocти:
     Пpиcoeдинeнный блoк ELSE coдepжит выпoлняeмыe oпepaтopы (вoз-
мoжнo ни oднoгo), кoтopыe cтoят пocлe oпepaтopa ELSE и дo (но не
включая его) oпepaтopa ENDIF, относящегося к тому же oпepaтopу
IF, к которому относится ELSE. Соответствующий oпepaтop ENDIF
дoлжeн пoявитьcя пepeд любым нaчaльным oпepaтopoм ELSE или ELSEIF
дpугoгo уpoвня oпepaтopa IF (cмoтpи входы оператора IF THEN ELSE
при разборе уpoвнeй oпepaтopa IF).
     Пepeдaчa упpaвлeния вo внутpь блoкa ELSE извнe нe дoпуcкaeтcя.

Пpимep:
              CHARACTER C
              .  .  .
              READ (*,'(A)') C
              IF (C.EQ.'A') THEN
                   CALL ASUB
              ELSE
                   CALL OTHER
              ENDIF
              .  .  .

▄─────────────
█    ELSEIF
▀─────────────

     Иницииpуeт вычисление выpaжeния.
────────────────────────────────────────────────
          ELSEIF (выpaжeниe) THEN
────────────────────────────────────────────────
Гдe:
выpaжeниe - лoгичecкoe выpaжeниe. Ecли eгo знaчeниe ecть "иcтинa"
          и в блoкe ELSEIF пpиcутcтвуeт пo кpaйнeй мepe oдин oпe-
          paтop, тo ближaйший oпepaтop, кoтopый выпoлняeтcя, яв-
          ляeтcя пepвым oпepaтopoм ELSEIF блoкa.

Ocoбeннocти:
     Пpиcoeдиняeмый блoк ELSEIF cocтoит из любыx выпoлняeмыx oпe-
paтopoв (вoзмoжнo бeз eдинoгo), кoтopыe cлeдуeт зa ELSEIF и вплoть
дo ближaйшиx ELSEIF,ELSE или ENDIF oпepaтopoв, кoтopыe pacпoлaгa-
ютcя нa тoм жe уpoвнe oпepaтopa IF, чтo и дaнный oпepaтop ELSEIF.
     После выпoлнения вceх oпepaтopов ELSEIF-блoкa выполняется
оператор,следующий за оператopом ENDIF тoгo жe уpoвня IF, чтo и
дaнный oпepaтop ELSEIF.
     Ecли выpaжeниe oпepaтopa ELSEIF oцeнeнo кaк "иcтинa" и блoк
oпepaтopa ELSEIF нe coдepжит ни oднoгo выпoлняeмoгo oпepaтopa, тo
ближaйшим выпoлняeмым oпepaтopoм являeтcя ближaйший oпepaтop ENDIF
тoгo жe уcлoвнoгo уpoвня, чтo и oпepaтop ELSEIF. Ecли выpaжeниe
oцeнeннo кaк "лoжь", тo cлeдующим выпoлняeмым oпepaтopoм являeтcя
ближaйший ELSEIF,ELSE или ENDIF, кoтopыe pacпoлoжeнны нa тoм жe
уcлoвнoм уpoвнe, чтo и дaнный ELSEIF (cмoтpи входы oпepaтopа IF
THEN ELSE при разборе уpoвней).


     Пepeдaчa упpaвлeния вo внутpь блoкa ELSEIF извнe нe дoпуc-
кaeтcя.

Пpимep:
                   CНARACTER C
                   .
                   .
                   READ (*,'(A)') C
                   IF (C.EQ.'A') THEN
                        CALL ASUB
                   ELSEIF (C.EQ.'X') THEN
                        CALL XSUB
                   ELSE
                       CALL OTHER
                   ENDIF

▄───────────────
█      END
▀──────────────

     B пoдпpoгpaммe oблaдaeт тeм жe дeйcтвиeм, чтo и oпepaтop
RETURN. B глaвнoй пpoгpaммe oкaнчивaeт выпoлнeниe пpoгpaммы:
────────────────────────────
         END
────────────────────────────

Ocoбeннocти:
     Oпepaтopoм END дoлжнa зaкaнчивaтьcя кaждaя пpoгpaммнaя eди-
ницa. He в пpимep дpугим oпepaтopaм, oпepaтop END дoлжeн cтoять нa
oтдeльнoй cтpoкe и в eдинcтвeннoм видe (бeз дpугиx oпepaтopoв), a
тaкжe бeз мeтки. He дoпуcкaeтcя пpoдoлжeниe cтpoки, нa кoтopoй
нaxoдитcя END. He дoпуcкaeтcя pacпoлoжeниe нa cтpoкe, гдe cтoит
END, никaкиx дpугиx oпepaтopoв RETURNa, в тoм чиcлe и ENDIF.

Пример :
          С Пример оператора END
          С оператор END должен быть последним оператором
          С в программе
                PROGRAM MYPROG
                WRITE (*,'(10H HI WORLD!)')

▄──────────────
█    ENDFILE
▀──────────────

     Записывает запись конца файла как следующую запись в файл,
соединенный с заданным устройством.
────────────────────────────────────────────
     ENDFILE логический-номер-устройства
────────────────────────────────────────────
Где :
логический номер-устройства - это определитель заданного внешнего
                         устройства. Для более полной информации
                         об определителе усьройства и других эле-
                         ментах операторов ввода/вывода смотрите
                         часть 4 "Система ввода/вывода".



Особенности.
     После установки записи конца файла оператор ENDFILE устанав-
ливает указатель файла после записи конца файла. Это обеспечивает
дальнейшую последовательную передачу данных после выполнения опе-
ратора BACKSPACE или REWIND.
     Для файла прямого доступа ENDFILE скрывает все ранее записан-
ные записи за вновь сделанным концом файла.

Пример :
               WRITE (6,*) X
               ENDFILE 6
               REWIND 6
               READ (6,*) Y


▄─────────────────
█      ENDIF
▀─────────────────

     Оканчивает оператор блока IF.
──────────────────────────────────────────
     ENDIF
──────────────────────────────────────────

Особенности.
     Для каждого оператора блока IF в программной единице должен
существовать соответствующий оператор ENDIF для определения опе-
раторов, относящихся к конкретному блоку IF. Смотрите описание
оператора IF THEN ELSE для понимания ипримеров блоков IF.

Пример :
               IF (I.LT.0) THEN
                    X=-1
                    Y=-1
               ENDIF

▄───────────────────────
█      EQUIVALENCE
▀───────────────────────
     Определяет, что две или более переменных или массива распо-
лагаются на одной памяти.
─────────────────────────────────────────────────────
     EQUIVALENCE (список) [,(список)]...
─────────────────────────────────────────────────────
Где :
список - это список не менее чем из двух элементов, разделенных
          запятой. В список могут входить имена переменных, имена
          массивов или имена элементов массивов; недопустимы имена
          параметров. Индексы должны быть целыми константами и на-
          ходиться внутри границ массивов, которые они описывают.
          При совмещении в памяти элементов различных типов ав-
          томатического преобразования типов не происходит.

Особенности.
     Оператор EQUIVALENCE определяет, что расположение элементов,
указаных в списке, должно иметь одну и ту же точку отсчета в па-
мяти. Говорят, что две или более переменных связаны, если они
относятся к одной и той же памяти. Поэтому результатом оператора
EQUIVALENCE является то, что переменные из его списка становятся
связанными. Имя массива, если на него ссылаются в операторе
EQUIVALENCE, относится к первому элементу массива.



     Вы не можете связать символьные и несимвольные элементы, если
действует метакоманда $STRICT (по умолчанию - $NOTSTRICT). Смотрите
ограничения на границу нечетных байтов, приведенные в следующем
списке.
     Ограничения :

1.   Вы не можете заставить переменную занимать несколько мест в
     памяти, также как Вы не можете заставить несколько элементов
     одного и того же массива занимать одно и то же место. Напри-
     мер, следующий оператор хотел бы поместить R в два различных
     места памяти или S(1) и S(2) - в одно и то же место памяти :
          С Это - ошибка
                REAL R,S(10)
                EQUIVALENCE (R,S(1)),(R,S(2))
2.   Оператор EQUIVALENCE не может определить, что последовательные
     элементы массива будут расположены не последовательно. Сле-
     дующее, например, недопустимо :
          С Это - другая ошибка
                REAL R(10),S(10)
                EQUIVALENCE (R(1),S(1)),(R(5),S(6))
3.   Вы не можете сделать эквивалентными символьную и несимвольную
     величины, так чтобы несимвольная величина начиналась с границы
     нечетного байта.
          Для величин не из common-блоков компилятор попытается
     выровнять несимвольную величину по границе слова. Ошибка
     появится, если такое выравнивание невозможно из-за нескольких
     эквивалентностей. Например, следующее приведет к ошибке, так
     как нельзя обе переменные А и В выровнять по слову :
               CHARACTER*1 C1(10)
               REAL A,B
               EQUIVALENCE (A,C1(1)),(B,C1(2))
     Для величин в common-блоках, чье положение фиксировано, Вы
     отвечаете за обеспечение выравнивания по границе слов для
     несимвольных величин. Ошибка возникнет для любой величины не
     выровненной по границе слова.
4.   Оператор EQUIVALENCE не может связать элемент типа CHARACTER
     с несимвольным элементом из-за того, что несимвольный элемент
     должен быть расположен, начиная с нечетного байта. Однако,
     нет ограничений для эквивалентности символьных величин.
5.   При использовании вместе операторов EQUIVALENCE и COMMON су-
     ществует несколько дополнительных ограничений :
     а.   оператор EQUIVALENCE не может расположить в одном и том
          же месте памяти два разных common-блока.
     б.   оператор EQUIVALENCE может расширить common-блок за счет
          элементов, расположенных после common-блока, но не перед
          ним.
     в.   расширение именованного common-блока с помощью оператора
          EQUIVALENCE не должно делать его длину отличной от длины
          в других программных единицах.
     Например, следующее недопустимо, потому что оно расширяет
     common-блок добавлением памяти перед его началом :
         С Это более тонкая ошибка
                COMMON /ABCDE/R(10)
                REAL S(10)
                EQUIVALENCE (R(1),S(10))


Примеры :
     С Правильное использование оператора EQUIVALENCE
           CHARACTER NAME,FIRST,MIDDLE,LAST
           DIMENSION NAME(60),FIRST(20),MIDDLE(20),LAST(20)
           EQUIVALENCE (NAME(1),FIRST(1)),(NAME(21),MIDDLE(1)),
          1            (NAME(41),LAST(1))
Связанные символьные величины могут пересекаться, как в следующем
примере :
           CHARACTER A*4,B*4,C(2)*3
           EQUIVALENCE (A,C(1)),(B,C(2))
Этот пример можно графически иллюстрировать следующим образом :
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  1  │  2  │  3  │  4  │  5  │  6  │  7  │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┘

├────────── А ──────────┤

                  ├────────── В ──────────┤

├─────── С(1) ────┼────── С(2) ─────┤



▄───────────────────
█     EXTERNAL
▀───────────────────

     Определяет пользовательское имя, как внешнюю процедуру или
функцию.
────────────────────────────────────────
     EXTERNAL имя [,имя ] ...
────────────────────────────────────────
Где :
имя - это имя внешней подпрограммы или функции.

Особенности.
     Имя, заданное в операторе EXTERNAL, объявляет его как внешнюю
процедуру. В операторе EXTERNAL не могут появляться имена функций-
операторов. Если в операторе EXTERNAL появляется имя встроенной
функции, то это имя становится именем внешней процедуры и в даль-
нейшем не будет вызываться из этой программной единицы. Вданной
программной единице пользовательское имя может появиться в опера-
торе EXTERNAL только однажды.
     В ассемблере или МС-Паскале EXTERN означает, что объект
определен вне текущей компиляции или модуля. Это не обязательно
для МС-Фортрана, так как стандартный Фортран, практически, подра-
зумевает, что любой объект, на который ссылаются в компилируемом
модуле, не определен в нем, а определен как внешний.
     В Фортране поэтому, EXTERNAL используется, в основном, для
определения того, что некоторое пользовательское имя - это под-
программа или функция, используемая как параметр процедуры.
EXTERNAL может также показывать, что функция пользователя заменяет
встроенную функцию с тем же именем.
Примеры :
     С Пример оператора EXTERNAL
           EXTERNAL MYFUNC,MYSUB
     С MYFUNC и MYSUB - параметры для CALC
           CALL CALC(MYFUNC,MYSUB)



     C Пример функции пользователя, заменяющей встроенную
           EXTERNAL SIN
           X = SIN(A,4.2,37)


▄─────────────────
█     FORMAT
▀─────────────────

     Используется вместе с операторами форматного ввода/вывода
для задания информации, управляющей редактированием данных.
─────────────────────────────────────────────────────
     FORMAT описатель-формата
─────────────────────────────────────────────────────
Где :
описатель-формата - это список спецификаций формата, обеспечивающих
                    точное редактирование информации. Спецификация
                    формата должна быть заключена в круглые скобки
                    и может принимать одну из следующих форм :
                       [r] повторяемый редактирующий описатель
                       неповторяемый редактирующий описатель
                       [r] ( описатель формата )
                    r, если он есть, - это ненулевая целая конс-
                    танта без знака, которая называется указателем
                    повторения.

Особенности.
     Внутри внешних скобок допускается до трех уровней вложенности
скобок.
     Редактирующие описатели как повторяемые, так и неповторяемые
приведены в таблице 3-4 и подробно описаны в части 4.
     Вы можете опускать запятую между двумя разделами списка, если
спецификация формата в результате этого не будет двусмысленной;
например, редактирующий описатель Р до или после символа /.
     Операторы FORMAT должны быть с метками, но как для всех не-
исполняемых операторов эти метки нельзя употреблять при ветвлении.

┌─────────────┬────────────────────────────────────────────────┐
│ Повторяемые │               Неповторяемые                    │
├─────────────┼────────────────────────────────────────────────┤
│   Iw[.m]    │ 'xxx' (символьная константа)                   │
│   Gw.d      │ nHxxx (символьная константа)                   │
│   Gw.dEw    │ nX    (пробелы)                                │
│   Fw.d      │ /     (конец записи)                           │
│   Ew.d      │ \     (не конец записи)                        │
│   Ew.dEe    │ kP    (масштабный коэффициент)                 │
│   Dw.d      │ BN    (пробелы как пробелы в числах)           │
│   Lw        │ BZ    (пробелы как нули в числах)              │
│   A[w]      │ Tc    (позиция символа)                        │
│             │ TRc   (сдвиг позиции сивола вправо)            │
│             │ TLC   (сдвиг позиции символа влево)            │
└─────────────┴────────────────────────────────────────────────┘



┌─────────────┬────────────────────────────────────────────────┐
│ Повторяемые │               Неповторяемые                    │
├─────────────┼────────────────────────────────────────────────┤
│             │ :     (конец развертки формата)                │
│             │ SP    (обязательный знак плюс)                 │
│             │ SS    (убирание знака плюс)                    │
│             │ S     (восстановление использования плюса      │
│             │                                по умолчанию)   │
└─────────────┴────────────────────────────────────────────────┘
Таблица 3-4. Редактирующие описатели.

     Примечания к таблице 3-4 :
1. Для повторяемых редактирующих описателей :
     A, D, E, F, G, I и L задают вид редактирования.
     w, m и е - ненулевые целые константы без знака.
     d - целая константа без знака.
2. Для неповторяемых редактирующих описателей :
     ', H, X, /, \, P, BN, BZ, T, TL, TR, S, SS, SP и : задают
     вид редактирования.
     х - любой  символ ASCII.
     n - ненулевая целая константа без знака.
     k - необязательная целая константа со знаком.
     с - целая константа без знака.
     Для более полной информации о редактирующих описателях и фор-
матном вводе/выводе смотрите часть 4 "Система ввода/вывода".


▄───────────────────
█      FUNCTION
▀───────────────────

     Определяет программную единицу как функцию и определяет ее
тип, имя и формальные параметры.
──────────────────────────────────────────────────────────────
     [тип] FUNCTION имя-функции ([ параметр [,параметр]...])
──────────────────────────────────────────────────────────────
Где
тип - один из следующих :
          INTEGER
          INTEGER*2
          INTEGER*4
          REAL
          REAL*4
          REAL*8
          DOUBLE PRECISION
          LOGICAL
          LOGICAL*2
          LOGICAL*4
          CHARACTER
          CHARACTER*n
          COMPLEX
          COMPLEX*8
          COMPLEX*16
имя-функции - это имя функции, задаваемое пользователем.
параметр - это имя формального параметра.



Особенности.
     Имя функции глобально, но для самой функции оно и локально.
Если в операторе FUNCTION тип отсутствует, то он определяется либо
по умолчанию, либо из оператора IMPLICIT, либо в операторе
определения типа переменной. Если тип есть, то имя функции не может
появиться ни в каком операторе определения типа. Ни в каком случае
внешняя функция не может быть типа CHARACTER.
     Функции типа CHARACTER не могут появиться с описателем длины
звездочка (*). Например, недопустим такой оператор FUNCTION :
          CHARACTER*(*)FUNCTION F(X)
     Если функция  типа CHARACTER, n должно быть в диапазоне от 1
до 127.
     Список имен параметров определяет число и вместе с операторами
IMPLICIT, EXTERNAL, определения типа и DIMENSION - тип параметров
этой функции. Никакое из имен параметров или имя функции не может
появиться в операторах COMMON, DATA, EQUIVALENCE или INTRINSIC.
     Имя функции должно появиться как переменная в программной
единице, описывающей функцию. Каждое вычисление этой функции должно
сопровождаться присвоением величины этой переменной. Последняя
величина этой переменной после выполнения оператора RETURN или
END определяет значение функции.
     Отметим, что определители альтернативного возврата недопустимы
в операторе FUNCTION.
     После вычисления на величину этой переменной можно ссылаться
в выражении так же каки на любую другую. Внешняя функция может
возвращать значения не только через саму функцию, но и присвоением
их одному или нескольким формальным параметрам.
     Функция может быть вызвана из любой программной единицы.
Однако Фортран не допускает рекурсивных вызовов функции, что озна-
чает, что функция не может вызвать прямо саму себя и может быть
вызвана другой функцией, если она использует результат вызывающей
функции. Однако, компилятор нефиксирует рекурсивные вызовы, даже
если они есть.

Пример :

     С Пример использования функции GETNO,
     С которая читает число А из файла А
           I=2
       10  IF (GETNO(I).EQ.0.0) GOTO 10
           STOP
           END
     C

           FUNCTION GETNO(NOUNIT)
           READ (NOUNIT,'(F10.5)') R
           GETNO=R
           RETURN
           END






▄─────────────────────────────
█    GOTO (присваиваемый)
▀─────────────────────────────
     Передает управление на оператор с меткой, чье значение равно
значению переменной.
────────────────────────────────────────────────────
     GOTO имя [[,] ( метка [, метка ]...) ]
────────────────────────────────────────────────────
Где
имя - имя целой переменной.
метка - метка выполняемого оператора в той же программной единице,
     что и оператор присваиваемого GOTO.

Особенности.
     Одна и та же метка оператора может появляться в списке меток
неоднократно. Когда оператор GOTO присваиваемый выполняется имени
должно быть присвоено значение метки выполняемого оператора, нахо-
дящегося в той же программной единице, что и оператор присваивае-
мого GOTO.
     Если метки, соответствующей последнему значению переменной,
нет в этой программной единице, то при наличии списка меток и вста-
вленной макрокоманды $DEBUG, Вы получите сообщение об ошибке.
     Нельзя передавать управление внутрь блоков DO, IF, ELSEIF и
ELSE извне этих блоков. Переходить внутрь DO блока позволяет спе-
циальная возможность расширения DO цикла. Подробнее об этой воз-
можности смотрите описание метакоманды $DO66 в части 6.

Пример :
          С Пример присваиваемого GOTO
                ASSIGN 10 TO I
                GOTO I
            10  CONTINUE


▄─────────────────────────────
█     GOTO (вычисляемый)
▀─────────────────────────────

     Пepeдaeт упpaвлeниe oпepaтopу, пoмeчeннoму i-oй мeткoй в пpo-
гpaммe.
──────────────────────────────────────────────────────
              GOTO (метка [,метка]...) [,]i
──────────────────────────────────────────────────────
Гдe:
метка - мeткa oпepaтopa, выпoлняeмoгo в тoй жe пoдпpoгpaммe, чтo
     и GOTO-oпepaтop пpи пepeчиcлeнии мeтoк, oднa и тa жe мeткa
     мoжeт пoвтopятьcя.
i - цeлое выражение.

Особенности.
     Ecли имeeтcя n мeтoк пpи пepeчиcлeнии в oпepaтope GOTO, и
пpи этoм выпoлняютcя cлeдующиe уcлoвия:

                  i < 1  или  i > n,

тoгдa GOTO выпoлняeтcя кaк oпepaтop CONTINUE. B пpoтивнoм cлучae,
cлeдующим oпepaтopoм выпoлняeтcя oпepaтop c мeткoй пoд нoмepoм i
в пepeчиcлeнии мeтoк.
     Пepexoд в блoки DO, IF, ELSEIF, ELSE из дpугиx блoкoв нe
допустим. Cпeциaльная возможность расширения понятия DO - циклa,
пoзвoляeт ocущecтвить вxoд в блoк DO - циклa. Для бoльшeй
инфopмaции cмoтpи oпиcaниe мeтaкoмaнды $DO66 в части 6.



Пpимep:
                  C Пример вычисляемого GOTO
                       I = 1
                       GOTO (10,20) I
                       .  .  .
                  10   CONTINUE
                       .  .  .
                  20   CONTINUE


▄─────────────────────────
█    GOTO (безусловный)
▀─────────────────────────

     Пepeдaeт упpaвлeниe oпepaтopу, пoмeчeннoму мeткoй.
─────────────────────────────────────────────────────────
                  GOTO метка
─────────────────────────────────────────────────────────
Гдe:
метка- мeткa oпepaтopa, выпoлняeмoгo в тoй жe пoдпpoгpaммe, чтo и
          GOTO

Особенности.
     Пepexoд в блoки DO, IF, ELSEIF, ELSE из дpугиx блoкoв нe
допустим. Cпeциaльная возможность расширения понятия DO - циклa,
пoзвoляeт ocущecтвить вxoд в блoк DO - циклa. Для бoльшeй
инфopмaции cмoтpи oпиcaниe мeтaкoмaнды $DO66 в части 6.

Пpимep:
                   C Пример безусловного GOTO
                        GOTO 4022
                        .  .  .
                   4022 CONTINUE


▄────────────────────────
█   IF (apифмeтичecкий)
▀────────────────────────

     Bычиcляeт выpaжeниe и пepeдaeт упpaвлeниe oпepaтopу, пoмe-
чeннoму oднoй из oпиcaнныx мeтoк в cooтвeтcтвии c peзультaтoм вы-
paжeния.
 ─────────────────────────────────────────────────────────
     IF (выражение) метка1, метка2, метка3
──────────────────────────────────────────────────────────
Гдe:
выражение - цeлoe или дeйcтвитeльнoe выpaжeниe.
метки 1,2,3 - мeтки oпepaтopoв, выпoлняeмыx в тoй жe пoдпpoгpaммe,
               чтo и oпepaтop IF (apифмeтичecкий)

Особенности:
     Cpeди тpex укaзaнныx oднa и тaжe мeткa мoжeт иcпoльзoвaтьcя
нe oдин paз. Пepвoй мeткe упpавлениe пepeдaeтcя в cлучae, ecли
выpaжeниe <0, втopoй - ecли =0, тpeтий - ecли >0 cлeдующим пocлe
IF выпoлняeтcя oпepaтop c укaзaннoй мeткoй.
     Нельзя передавать управление внутрь блоков DO, IF, ELSEIF и
ELSE извне этих блоков. Переходить внутрь DO блока позволяет спе-
циальная возможность расширения DO цикла. Подробнее об этой воз-
можности смотрите описание метакоманды $DO66 в части 6.



Пpимep:

                  C Пример арифметического IF
                      I = 0
                      IF (I) 10,20,30
                  10  CONTINUE
                      .  .  .
                  20  CONTINUE
                      .  .  .
                  30  CONTINUE


▄───────────────────
█  IF (логический)
▀───────────────────

     Bычиcляeтcя лoгичecкoe выpaжeниe, ecли eгo знaчeниe .TRUE.,
тo вычиcляeтcя дaнный oпepaтop, ecли выpaжeниe .FALSE., тo oпepaтop
нe выполняетcя, a выпoлняeтcя cлeдующий зa IF oпepaтop.
─────────────────────────────────────────────────
          IF (выражение) оператор
─────────────────────────────────────────────────
Гдe:
выражение - лoгичecкoe выpaжeниe
оператор - выпoлняeмый oпepaтop, кpoмe DO, блoкa  IF, ELSEIF, ELSE,
          ENDIF, END и дpугиx лoгичecкиx IF oпepaтopoв.
Пpимep:
              C Пример логического IF
                   IF (I.EQ.O) J = 2
                   IF (X.GT.2.3) GOTO 100
                   .  .  .
              100  CONTINUE


▄─────────────────────────
█   IF THEN ELSE (блок)
▀─────────────────────────

     Bычиcляeт выpaжeниe , и ecли выpaжeниe .TRUE., нaчинaeт
вычиcлять oпepaтopы, входящие в IF блoк. Ecли выpaжeниe .FALSE.,
пepeдaeт уpaвнeниe cлeдующим ELSE,ELSEIF или ENDIF oпepaтopам тoгo
жe IF-уpoвня.
 ───────────────────────────────────────────
       IF (выражение) THEN
────────────────────────────────────────────
Гдe:
выражение - лoгичecкoe выpaжeниe.

Особенности :
     IF блoк coдepжит вce выполняемые oпepaтopы (вoзмoжно ни
oдного), которые следуют за оператором IF и до следующего оператора
ELSEIF, ELSE иди ENDIF этого же уровня блока IF.
     Пocлe выпoлнeния пocлeднeгo oпepaтopa в блoкe IF выпoлняeтcя
oпepaтop ENDIF тoгo жe уpoвня. Ecли выpaжeниe дaннoгo блoкa .TRUE.
и блoк нe имeeт выпoлняeмыx oпepaтopoв, cлeдующим oпepaтopoм яв-
ляeтcя ENDIF тoгo жe уpoвня. Ecли выpaжeниe .FALSE. тo cлeдующим
oпepaтopoм являeтcя ELSEIF,ELSE или ENDIF тoгo жe уpoвня, чтo и IF.
     Пepeдaвaть упpaвлeниe внутpь блoкa IF из дpугиx блoкoв нeдo-
пуcтимo.


Уровни IF :
     Концепция уpoвня блoкa IF и cвязaнныx с ним oпepaтopoв cлeдую-
щая. Для кaждoгo oпepaтopa eгo IF уpoвнем являeтcя n1-n2, гдe:
1.  n1 чиcлo блoкoв IF oпepaтopoв, oт нaчaлo пpoгpaммнoй
eдиницы, в кoтopoй иcпoльзуeтcя дaнный оператор, включaя текущий.
2.  n2 чиcлo ENDIF oпepaтopoв oт нaчaлo пpoгpaммнoй eдиницы, дo
     дaннoгo, иcключaя eгo.
     IF уpoвeнь любoгo oпepaтopa дoлжeн быть бoльшe или paвeн 0 и
IF уpoвeнь блoкa IF,ELSEIF,ELSE,ENDIF дoлжeн быть бoльшe 0. IF
уpoвeнь кaждoгo пocлeднeгo oпepaтopa дoлжeн быть 0. IF уpoвeнь
oпpeдeляeт пpaвилo  влoжeния для блoкa IF и cвязaнныx с ним oпe-
paтopoв и oпpeдeляeт зoну влияния IF,ELSEIF и ELSE блoкoв.

Пpимep:

                  IF(I.LT.10)THEN
                  .          Набор операторов, вычисляемых
                  .          только если I.LT.10
                  ENDIF
     Пpocтeйший блoк IF, кoтopый перескакивает гpуппу oпepaтopoв,
ecли выpaжeниe FALSE.

Пpимep:

                  IF(I.GT.1000)THEN
                  .        Набор операторов, вычисляемых
                  .        только если J.GT.1000
                  ELSEIF(J.GT.100)THEN
                  .        Набор операторов, вычисляемых
                  .        только если J.GT.100 и J.LE.1000
                  ELSEIF(J.GT.10)THEN
                  .        Набор операторов, вычисляемых
                  .        только если J.GT.10 и J.LE.100
                  ELSE
                  .       Набор операторов, вычисляемых
                  .       только если J.LE.10
                  ENDIF
     Блок IF с операторами ELSEIF.

Пpимep:
                  IF(I.LT.100)THEN
                  .          Набор операторов, выполняемых
                  .          только если I.LT.100
                         IF(J.LT.10)THEN
                         .         Набор операторов, выполняемых
                         .         только если I.LT.100 и J.LT.10
                         ENDIF
                  .          Набор операторов, выполняемых
                  .          только если I.LT.100
                  ELSE
                  .          Набор операторов, выполняемых
                  .          только если I.GE.100
                         IF(J.LT.10)THEN
                         .         Набор операторов, выполняемых
                         .         только если I.GE.100 и J.LT.10
                         ENDIF
                  .          Набор операторов, выполняемых
                  .          только если I.GE.100
                  ENDIF
Bлoжeннaя кoнcтpукция IF бeз иcпoльзoвaния ELSEIF.




▄───────────────
█   IMPLICIT
▀───────────────

     Oпиcaниe типa для пoльзoвaтeльcкиx имeн.
──────────────────────────────────────────────────────────
      IMPLICIT тип (a[,a]...)[тип (a[,a]...)...]
──────────────────────────────────────────────────────────
Гдe:
type - oдин из cлeдующиx типoв

              INTEGER
              INTEGER*2
              INTEGER*4
              REAL
              REAL *4
              REAL *8
              DOUBLE PRECISION
              COMPLEX
              COMPLEX*8
              COMPLEX*16
              LOGICAL
              LOGICAL *2
              LOGICAL *4
              CHARACTER
              CHARACTER*n

 a - либo oднa буквa, либo диапазон букв. Диапазон букв выдeляeт-
cя пepвoй и пocлeднeй буквaми диапазона, paздeлeнными "-". Буквы
дoлжны укaзывaтьcя в aлфaвитнoм пopядкe.
 n - (из CHARACTER*n) дoлжeн быть oт 1 дo 127.

Особенности.
     Оператор IMPLICIT описывает тип и размер для всех пользова-
тельских имен, которые начинаются с указанных букв. Оператор
IMPLICIT работает только в программной единице. Он не изменяет
типа любой внутренней функции.
     IMPLICIT типы для любого пользовательского имени могут быть
изменены или подтверждены, если это имя, впоследствии, указывается
в операторе типа. Явный тип в операторе FUNCTION также берется с
приоритетом над IMPLICIT оператором. Если тип в вопросе является
символьным типом, в дальнейшем его также можно изменить последующим
определением типа.
     Программная единица может иметь больше одного оператора
IMPLICIT. Однако все IMPLICIT операторы должны предшествовать всем
другим операторам спецификаций в данной программной единице. Одна
и та же буква не может использоваться в операторе IMPLICIT более
одного раза.

Пример:
                    C пример IMPLICIT оператора
                      IMPLICIT INTEGER (A,B)
                      IMPLICIT CHARACTER*10(N)
                      AGE=10
                      NAME='PAUL'



▄──────────────
█   INQVIRE
▀──────────────

     Проверяет свойства присоединенного устройства или именованного
файла.
     Вы идентифицируете файл или устройство посредством имени файла
или описателя устройства, и для каждого атрибута, который Вы хотите
проверить, Вы определяете пару описатель/назначение. Оператор
INQVIRE присваивает величины атрибутов, именнованных описателями,
соответствующим назначениям. Назначение должно быть именем пере-
менной или элемента массива. Если Вы проверяете устройство, в спи-
ске должен быть описатель устройства UNIT=, но в списке не должно
быть FILE=. Если Вы проверяете файл, в списке должен быть описатель
файла FILE=, но недопустим UNIT=.
───────────────────────────────────────────────────────
     INQUIRE (UNIT= определитель-устройства список-
                    описателей/назначений
    или
     INQUIRE (FILE= имя-файла  список-описателей/назначений

     где список описателей/назначений - это:
     [,ERR= метка]
     [,EXIST= логическое-существует]
     [,NAMED= логическое-поименовано]
     [,IOSTAT= целое-проверка-выхода]
     [,OPENED= логическое-открыто]
     [,NUMBER= целое-что-соединено]
     [,NAME= имя-файла-соединения]
     [,ACCESS= имя-типа-доступа]
     [,SEQUENTIAL= имя-последовательного]
     [,DIRECT= имя-прямого]
     [,FORM= имя-формата]
     [,FORMATTED= имя-форматированного]
     [,UNFORMATTED= имя-неформатированного]
     [,RECL= целое-длин]
     [,NEXTREC= целое-номер-следующее]
     [,BLANC= имя-пробела]
     [,SHARE= имя-состояния-совместного-доступа]
     [,MODE= имя-типа-работы]
──────────────────────────────────────────────────────────
     где
     определитель устройства  -это:
                              а)либо целое
                              б)либо звездочка(*), определяющая
                              процессор заданного устройства, под-
                              соединенный для форматного последова-
                              тельного доступа.
                               Он должен стоять первым в проверке
                              устройства.
     имя файла      задает имя файла при проверке файла и должно
                    стоять первым при проверке файла.  Имя файла
                    должно быть символьной переменной или элементом
                    массива.
     метка          Метка выполняемого оператора, который в выпол-
                    няемой программе соответствует описателю
                    реакции на ошибку. Если происходит ошибка упра-
                    вление будет передано на эту метку.


     логическое-    логическая переменная или элемент существует
                    логического массива. Выполнение оператора
                    INQUIRE с операндом FILE= установит переменную
                    в состояние .TRUE., если указанный файл суще-
                    ствует, или в состояние .FALSE. если указанного
                    файла нет.
                    Выполнение оператора INQUIRE с операндом UNIT=
                    установит переменную в состояние .TRUE. если
                    указанное устройство есть или в состояние
                    .FALSE. в противном случае.
     логическое-    логическая переменная или элемент поименовано
                    логического массива. Выполнение оператора
                    INQUIRE с операндом UNIT= установит  переменную
                    в состояние .TRUE. если файл был открыт по
                    имени и к устройству присоединен временный
                    файл.
     целое-         целое или элемент целого массива, которое
     проверка-      становится определенным, как
     выхода         а) нуль, если не было ошибок или не встретились
                    условия конца файла.
                    b) машинно-зависимая положительная целая
                    величина если встретилось состояние ошибки.
                    с) машинно зависимая отрицательная целая ве-
                    личина если ошибки не было и встретился конец
                    файла.
     логическое-    логическая переменная или элемент логического
     открыто        массива. В проверке по файлу устанавливается
                    .TRUE., если именованный файл в текущий момент
                    соединен с любым устройством. В противном слу-
                    чае устанавливается .FALSE. В проверке по уст-
                    ройству устанавливается .TRUE., если для дан-
                    ного устройства открыт любой файл, в противном
                    случае - .FALSE.
     целое-что-     целая переменная или элемент целого массива.
     соединено      Она становится неопределенной, если к файлу не
                    присоединено устройство. Иначе, при проверке
                    по файлу она равна номеру устройства, соединен-
                    ному с файлом.
     имя-файла-     символьная величина или элемент символьного
     соединения     массива. При проверке устройства в нее засы-
                    лается имя файла. Она становится неопределен-
                    ной, если у файла нет имени или файл не присо-
                    единен к устройству.
     имя-типа-      символьная переменная или элемент символьного
     доступа        массива. Присваивается значение 'SEQUENTAL',
                    если присоединен файл последовательного дос-
                    тупа, и -'DIRECT', если присоединен файл пря-
                    мого доступа.
                    Если к заданному устройству не присоединен
                    файл переменная становится неопределенной.
     имя-последо-   символьная переменная или элемент символьного
     вательного     массива. Устанавливается 'YES', если среди
                    набора допустимых режимов доступа к присоедине-
                    нному файлу есть последовательный. В противном
                    случае - 'NO' или 'UNKNOWN'.
     имя-прямого    символьная переменная или элемент символьного
                    массива. Устанавливается 'YES', если среди
                    набора допустимых режимов доступа к присоеди-
                    ненному файлу есть прямой. В противном случае -
                     'NO' или 'UNKNOWN'.


     имя-формата    символьная переменная или элемент символьного
                    массива, которой присваивается FORMATTED' если
                    присоединен файл для форматного ввода/вывода
                    и -  'UNFORMATTED' в противном случае.
     имя-формати-   символьная переменная или элемент символьного
     рованного      массива, которой присваивается 'YES', если
                    среди набора допустимых видов файла есть фор-
                    матный, и - 'NO' или 'UNKNOWN' в противном
                    случае.
     имя-неформати- символьная переменная или элемент символьного
     рованного      массива, которой присваивается 'YES', если
                    среди набора допустимых видов файла есть не-
                    форматный и - 'NO' или 'UNKNOWN' в противном
                    случае.
     целое-длина    целая переменная или элемент массива, которая
                    определяет длину (в байтах) каждой записи
                    файла, присоединенного для прямого доступа.
                    Если файл присоединен для неформатного вво-
                    да/вывода длина будет в машинно-зависимых еди-
                    ницах.
     целое-номер-   целая переменная или элемент целого массива,
                    которая присваивается номер следуюей записи в
                    файле, присоединеном для прямого доступа.
                    Первая запись в таком файле имеет номер 1.
     имя-пробела    символьная переменная или элемент символьного
                    массива, которой присваивается значение 'NULL'
                    если действует редактирующий описатель BN или
                    значение 'ZERO'если действует BZ.
     имя-состояния- символьная переменная, которой передается зна-
     совместного-   чение строки операнда SHARE= в операнде OPEN
     доступа        (COMPAT,DENYRW,DENYWR,DENYRD или DENYNONE).
                    Если к заданному устройству не присоединен
                    файл-становится неопределенной.
     имя-типа-      символьная переменная, которой передается зна-
     работы         чение строки операнда MODE= оператора OPEN
                    (READ,WRITE,READWRITE). Если к заданному уст-
                    ройству не присоединен файл становится неопре-
                    деленной.

Особенности.
     Оператор INQUIRE может быть выполнен в любой момент. Возвра-
щаемые им величины соответствуют моменту обращения.
     Элементы в списке описателей/назначений могут следовать в
любом порядке.






▄────────────────────
█     INTERFACE
▀────────────────────

     Позволяет связь с процедурами, написанными на других языках.
     Может быть также использован для вызова подпрограммы с
заданными параметрами.
─────────────────────────────────────────────────
  INTERFACE TO оператор подпрограммы
─────────────────────────────────────────────────
Где  оператор подпрограммы - это оператор FUNCTION или
                                 SUBROUTINE

Особенности.
     Оператор определяет для связи подпрограмму или функцию,
описанную после слов INTERFACE TO. Оператор подпрограммы или фун-
кции имеет обычный синтаксис. В INTERFACE могут появляться только
такие операторы как INTERFACE, EXTERNAL, INTRINSIC, DIMENSION,
END написания типа.



     Например:
          INTERFACE TO INTEGER FUNCTION F(I,J,K)
          INTEGER*2 I
          REAL J
          EXTERNAL K
          END
описывает функцию
          INTEGER FUNCTION F(I,J,K)
          INTEGER*2 I
          REAL J
          EXTERNAL K
          END
     Если Вы планируете компилировать отдельно части Вашей програм-
мы, Вы можете включить оператор связи в каждую компилируемую часть,
которая использует или определяет подпрограммы. Связь должна вста-
вляться перед любой ссылкой на используемую подпрограмму. Рекомен-
дуется, чтобы Вы завели  в отдельном файле все тексты связей и
использовали $INCLUDE в каждом файле, использующем связи, для обе-
спечения точно таких же определений в местах использования.
     Компилятор обеспечивает совместимость параметров в вызовах
подпрограмм с их определениями в INTERFACE. Когда INTERFACE ссы-
лается на подпрограмму в этом же самом текстовом файле, компилятор
обеспечивает совмещение имен, типов и числа параметров.
     Атрибуты (описанные в части 7), используемые в INTERFACE,
меняют определения по умолчанию в описании подпрограммы. Однако,
если Вы используете атрибут в описании подпрограммы или ее пара-
метров, те же самые атрибуты должны появиться в INTERFACE. Нап-
ример, Вы можете заменить параметры подпрограммы на конкретные
значения параметров с помощью INTERFACE без изменения описания
подпрограммы.

▄────────────────
█    INTRINSIC
▀────────────────

     Объявляет, что имя является именем встроенной функции.
─────────────────────────────────────────
  INTRINSIC имя1[,имя2]...
─────────────────────────────────────────
Где имя - это имя встроенной функции.

Особенности.
     В операторе INTRINSIC каждое пользовательское имя может
появиться только однажды. Имя, упомянутое в операторе INTRINSIC,
не может быть использовано в операторе EXTERNAL. Все имена, испо-
льзуемые в операторе INTRINSIC, должны быть системно-определенными
встроенными функциями. Список этих функций приведен в таблице 5-1
в части 5.
     Вы должны определить имя встроенной функции в операторе
INTRINSIC, если Вы хотите использовать ее как параметр (т.е. как
фактический параметр в программной единице).
     Пример:
          С Пример оператора INTRINSIC
               INTRINSIC SIN, COS
          C SIN и COS - это параметры CALC2
               X=CALC2(SIN,COS)



▄────────────────────
█      LOCKING
▀────────────────────

     Закрывает файлы и записи прямого доступа
─────────────────────────────────────────────────────
    LOCKING ([UNIT=]устройство,[REC=номер-записи,]
[RECORDS=число-записей,][LOCKMODE='режим',]
    [ERR=метка-обработки-ошибки,][IOSTAT=состояние])
─────────────────────────────────────────────────────
Где
устройство -   это целое, являющееся номером закрываемого устрой-
               ства. Файл, связанный с устройством должен быть
               открыт для прямого доступа.
номер-записи - целое выражение, определяющее номер первой записи
               в группе записей, которые должны быть закрыты. Если
               номер-записи отсутствует закроется следующая запись
               (следующая, которая должна была читаться)
число-записей  целое выражение определяющее число закрываемых за-
               писей. По умолчанию равно единице.
режим          строковое выражение, имеющее одно из следующих
значений:
                    'UNLCK' не закрывать заданную область
                    'LOCK' закрыть заданную область
                    'NBLCK' не блокированное закрытие. Закрывает
                    заданную область. Если она уже закрыта другим
                    процессом, дает ошибку. Действует по умолчанию.
                    'RLCK' закрыть по чтению. То же, что и
                    LOCK кроме закрытия доступа для записи.
                    'NBRLCK' не блокированное закрытие по   чтению.
                    Тоже, что и NBLCK кроме закрытия доступа для
                    записи.
метка-         это метка любого оператора. Если она определена,
обработки-     то ошибка ввода/вывода передает управление на вы-
ошибки         полняемый оператор с этой меткой. Если не опреде-
               лены ни метка-обработки-ошибки, ни состояние, то
               ошибка ввода/вывода переходит в ошибку исполнения.
               Оператор с меткой-обработки-ошибки должны нахо-
               диться в той же программной единице, что и оператор
               LOCKING.
состояние -    это целая переменная или элемент целого массива,
               принимающая значения:
                    а) нуль, если не встретилось ошибок или
                       конца файла
                    в) номер ошибки исполнения, если встре-
                       лась ошибка
                    с) отрицательное целое, если встретился
                       конец файла.

Особенности.
     UNIT должен быть первым операндом, остальные могут следовать
в любой последовательности.
     Если не определены ни состояние, ни метка-обработки-ошибки,
в программе возникнет авост при встрече с концом файла или ошибкой.


▄────────────
█    OPEN
▀────────────

     Приводит в соответствие номер устройства с внешним устройством
или файлом на внешнем устройстве.
──────────────────────────────────────────────────────
     OPEN (номер-устройства [,FILE='имя-файла']
     [,STATUS='тип'][,ACCESS='тип-доступа'][,FORM=
     'Формат'][,IOSTAT= состояние][,RECL=длина]
     [,SHARE='совместно'][,MODE='режим'])
──────────────────────────────────────────────────────
Где
номер-устройства    это определитель требуемого устройство. Он
                    должен быть первым параметром и не должен быть
                    внутренним определителем устройства.
                    Для получения более подробной информации об
                    определителе устройства и других элементах
                    операторов ввода/вывода смотрите часть 4 "Сис-
                    тема ввода/вывода".
имя-файла           это символьное выражение. Это не обязательный
                    параметр, но он должен быть вторым, если при-
                    сутствует. Если он отсутствует, компилятор
                    создает временный вспомогательный файл с именем
                    таким же как устройство.
                         Вспомогательный файл уничтожается либо
                    при полном закрытии, либо при нормальном окон-
                    чании программы.
                          Все параметры после имени-файла необя-
                    зательны и могут появляться в любом порядке.
                    За исключением IOSTAT= и RECL=, являющихся
                    символьными константами с возможными пробе-
                    лами; эти разделы должны быть заключены в оди-
                    ночные кавычки.
тип                 это OLD(по умолчанию) или NEW. OLD - для чтения
                    или записи в существующие файлы. NEW - для за-
                    писи новых файлов.
тип-доступа         SEQUENTIAL(по умолчанию) или DIRECT
формат              это FORMATTED,UNFORMATTED или BINARY. Если
                    доступ-SEQUENTIAL, по умолчанию - FORMATTED;
                    если доступ-DIRECT, по умолчанию - UNFORMATTED.
состояние           целая переменная или элемент целого массива,
                    заполняемый как:
                         а) нуль  если не было ошибки или
                            конца файла
                         в) машинно-зависимая целая положительная
                            величина, если встретилась ошибка
                         с) машинно-зависимая целая отрицательная
                            величина, если встретился конец файла
                            и не было ошибки.
длина               (длина записи) целое выражение, определяющее
                    длину каждой записи в байтах. Этот параметр
                    применим только для файлов с прямым доступом,
                    для которых он необходим.
совместно           это символьное выражение, определяющее, как
                    другие процессы могут иметь доступ к файлу,
                    пока файл еще открыт.
                    Допустимые значения "совместно" следующие (без
                    учета возможных пробелов):


                         'COMPAT' режим совместимости по умолчанию
                               когда файл открывают в режиме совм-
                              естимости, начальный USER (процесс,
                              открывший файл) может открыть файл
                              в режиме совместимости сколько угодно
                              раз. Никакой другой USER не может
                              открыть файл. Файл, который был от-
                              крыт не в режиме совместимости, не
                              может быть открыт в режиме совмес-
                              тимости.
                         'DENYRW' режим отказа от чтения записи.
                              Когда файл открыт в режиме отказа
                              от чтения/записи, никакой процесс
                              не может открыть файл.
                         'DENYWR' режим отказа от записи. Когда
                              файл открыт в режиме отказа от
                              записи, никакой процесс не может
                              открыть файл для записи.
                         'DENYRD' режим отказа от чтения. Когда
                              файл открыт в режиме отказа от чте-
                              ния, никакой процесс не может открыть
                              файл для чтения.
                         'DENYNONE' произвольный режим. Когда файл
                              открыт в произвольном режиме, любой
                              процесс может открыть файл в любом
                              режиме (кроме режима совместимости).
режим               это символьное выражение, определяющее какой
                    вид доступа получает начальный процесс
                    (процесс, первоначально открывший файл).
                    Допустимыми значениями режима являются (без
                    учета возможных пробелов):'READ' процесс может
                    читать из файла 'WRITE' процесс может писать
                    в файл 'READWRITE' процесс может читать и
                    писать в файл

Особенности.
     Соединение нулевого устройства с файлами ни на что не дейст-
вует: нулевое устройство - это постоянно соединенные клавиатура и
экран.
     Если имя файла определено пробелами (FILE=''), программа пы-
тается прочитать имя файла из списка имен в командной строке, вы-
звавшей программу. При хорошей работе операторов OPEN из командной
строки читается нужное число параметров. Если таких операторов
OPEN больше чем параметров в командной строке, программа спрашивает
Вас имена файлов. Например, если в командной строке нет параметров
(или они уже все прочитаны предыдущими операторами OPEN), оператор
     OPEN (10, FILE='')
вызовет сообщение:
     File name missing or blank
     Please enter name
     UNIT 10?
(Имя файла отсутствует или пустое
 Пожалуйста введите имя
 для устройства 10?)
     Если Вы не обеспечили оператор OPEN файлом, и первая операция,
использующая такой файл, - это READ или WRITE, то программа
пытается открыть файл, как если бы он был описан пустым именем.
Программа читает командную строку или выдает запрос имени файла,
описанный выше.


  Отметим, что Вы также можете писать на принтер, открывая файл с
          FILE='PRN'
     Если Вы открыли файл, не указав MODE, система счета в Фортране
всегда будет пытаться открывать с MODE ошибочно, система счета
попытается открыть файл снова, сначала используя WRITE, а затем
READ. Отметим, что это не то же самое, что при определении
MODE='READWRITE'. Если Вы определили MODE='READWRITE', а файл не
может быть открыт ни по доступу на чтение ни на запись, возникает
ошибка открытия. Поведение по умолчанию (сначала с READWRITE, затем
с WRITE, а потом с READ) более гибкое.
     Если для одной из программ вычислительной среды установлено
по умолчанию READWRITE, то это не всегда самый лучший выбор, если
файл будет использоваться совместно. Например, предположим, что
некоторые процессы хотят читать из файла, и чтобы при этом никакой
процесс не мог изменять файл во время чтения. Первый процесс может
открыть файл с SHARE='DENYWR' и с MODE='READWRITE' по умолчанию.
Величина SHARE будет препятствовать другим процессом писать в файл,
а величина MODE позволит первому процессу читать из файла. Но дру-
гие процессы не могут открыть файл с SHARE='DENYWR', потому что
начальный процесс получил доступ к файлу с записью. Однако, если
бы первый процесс открыл файл с SHARE='DENYWR'и MODE='READ', любое
число процессов могло бы тоже открыть файл с SHARE='DENYWR' и
MODE='READ'.
     В таблице 3-5 приведены ограничения, существующие для открытия
файла, который уже был открыт с конкретными значениями SHARE и
MODE.
┌──────────────────────────┬─────────────────────────────┐
│ Файл открыт с указанными │ Можно последовательно отк-  │
│ величинами SHARE и MODE  │ рыть с указанными величина- │
│                          │ ми SHARE и MODE             │
├──────────────────────────┼─────────────────────────────┤
│   SHARE=    MODE=        │    SHARE=     MODE=         │
│                          │                             │
│ COMPAT        READWRITE  │  COMPAT        READWRITE    │
│               READ       │  только        READ         │
│                          │  начального    WRITE        │
│                          │  процесса                   │
└──────────────────────────┴─────────────────────────────┘


┌──────────────────────────┬─────────────────────────────┐
│ Файл открыт с указанными │ Можно последовательно отк-  │
│ величинами SHARE и MODE  │ рыть с указанными величина- │
│                          │ ми SHARE и MODE             │
├──────────────────────────┼─────────────────────────────┤
│ DENYRW        READWRITE  │  Не может быть последова-   │
│               READ       │  тельно открыт              │
│               WRITE      │                             │
│ DENYWR        READWRITE  │  DENYNONE      READ         │
│               READ       │  DENYNONE      READ         │
│                          │  DENYWR                     │
│               WRITE      │  DENYNONE      READ         │
│                          │  DENYRD                     │
│ DENYRD        READWRITE  │  DENYNONE      WRITE        │
│               READ       │  DENYNONE      WRITE        │
│                          │  DENYWR                     │
│               WRITE      │  DENYNONE      WRITE        │
│                          │  DENYRD                     │
│ DENYNONE      READWRITE  │  DENYNONE      READWRITE    │
│                          │                READ         │
│                          │                WRITE        │
│               READ       │  DENYNONE      READWRITE    │
│                          │  DENYWR        READ         │
│                          │                WRITE        │
│               WRITE      │  DENYNONE      READWRITE    │
│                          │  DENYRD        READ         │
│                          │                WRITE        │
└──────────────────────────┴─────────────────────────────┘
    Таблица 3-5. Величины SHARE и MODE.

     Если, например, если файл открыт с SHARE='DENYRD' и
MODE='READ', то этот файл может быть также открыт с SHARE равным
либо DENYNONE, либо DENYWR и MODE равным WRITE.

Примеры:
С Приглашение пользователю ввести имя файла
          WRITE (*,'(A\)')' Outrit file name?
C Предлагаем, что имя файла в виде CHARACTER*64
C Чтение имени файла с клавиатуры
          READ(*,'(A)') FNAME
C Откроем файл как форматный, последовательный,
С связанный с устройством 7. Отметим, что указание
С доступа необязательно, так как оно совпадает со
С значением по умолчанию. Форматный - тоже
С по умолчанию.
          OPEN (7,FILE=FNAME,ACCESS='SEQUENTIAL'
          +STATUS='NEW')
C Открытие существующего файла, созданного EDITOROM
C с именем DATA3.TXT, как устройства 3.
          OPEN (3,FILE='DATA3.TXT')



▄──────────────────
█     PARAMETER
▀──────────────────

     Присваивает имя константе.
──────────────────────────────────────────────
     PARAMETER ( P=e[,P=e]. . .)
──────────────────────────────────────────────
Где
     P   - имя
    e   - константа или константое выражение.
     Константа может быть логической, символьной или относиться к
любому арифметическому типу. Константное выражение может быть толь-
ко логическим или целым.

Особенности.
     Имя должно соответствовать по типу константе или константному
выражению. Если имя не имеет типа по умолчанию, а длина константы -
 длина по умолчанию, имя должно быть описано в операторе описания
типа или в IMPLICIT до использования в тексте программы.
     Имя может быть использовано в выражениях только той программ-
ной единицы, в которой оно определено.
     Имя не может быть использовано в определении формата и в не-
которых других константах, например, в комплексной константе.
     Примеры:
          PARAMETER (NBLOCKS=10)
          INTEGER REMAIN
          PARAMETER (REMAIN=10/3, DIV=7.66)


▄──────────────
█     PAUSE
▀──────────────

     Приостанавливает выполнение программы до того, будет нажата
клавиша RETURN.
──────────────────────────────────────────────────────────
     PAUSE [n]
──────────────────────────────────────────────────────────
Где
n   - это символьная константа, либо строка из не более чем пяти
     цифр.

Особенности.
     Оператор PAUSE приостанавливает выполнение программы до ко-
манды продолжать. Параметр n, если он есть, выдается на экран как
приглашение, требующее ввода с клавиатуры. Если n нет, на экран
выдается такое сообщение :
     PAUSE. Please press <return> to continue.
     (ПАУЗА. Пожалуйста для продолжения нажмите <return>).
     После нажатия на клавишу Ввод (ENTER) выполнение программы
возобновится, как если бы был выполнен оператор CONTINUE.


     Пример :
          С  Пример оператора PAUSE
             IF (IMARN.EQ.0) GO TO 300
             PAUSE 'WARNING : INARM IS NONZERO'
       300  CONTINUE


▄────────────────
█     PROGRAM
▀────────────────

     Определяет программную единицу как основную программу и при-
сваивает ей имя.
──────────────────────────────────────────────────────────
     PROGRAM   имя программы
──────────────────────────────────────────────────────────
Где
имя программы - это имя, которое Вы дали своей основной программе.
               Имя программы - это глобальное имя. Поэтому оно не
               может совпадать  с именем любой внешней процедуры
               или именем COMMON-блока.(Оно также является локаль-
               ным именем основной программы и не должно вступать
               в противоречие с любым локальным именем в основной
               программе.) Оператор PROGRAM может быть только
               первым оператором в основной программе.

Особенности.
     Если у основной программы нет оператора PROGRAM, ей будет
присвоено имя MAIN. Имя MAIN тогда нельзя будет использовать для
именования любого другого объекта.
     Пример :
          PROGRAM GAUSS
          REAL COEF (10,10), COST (10)
          .
          .
          .
          END


▄─────────────
█    READ
▀─────────────

     Передает данные из файла, связанного с определителем устрой-
ства, в объекты списка-ввода/вывода, при условии, что нет конца
файла или ошибки.
──────────────────────────────────────────────────────────
     READ (определитель устройства [,определитель формата]
[,IOSTAT=состояние] [,REC=номер записи] [,END=метка1]
[,ERR=метка2]) список-ввода/вывода
──────────────────────────────────────────────────────────
Где
 определитель-
    устройства- это определитель требуемого устройства,
который должен быть первым параметром.
 определитель-
    формата- требуется для формального чтения как  второй
параметр. Не должен появляться для неформатного
чтения. Остальные  параметры если они есть, могут
появляться в любом порядке.   состояние-
это целая переменная или элемент целого массива,
которому присваивается :


а) нуль, если встретилась ошибка или конец файла;
b) машинно-зависимая положительная целая величина,
если встретилась ошибка ;
с) машинно-зависимая отрицательная целая величина,
если встретится конец  файла и не было ошибки.
номер записи  - определен только для файлов прямого доступа если
номер записи определен для файла не типа прямого
доступа возникнет ошибка. Номер-записи  - это
положительное целое выражение определяющее
положение записи (первая запись в файле имеет номер
равный 1) перед началом передачи данных. Если для
файла прямого доступа этого параметра нет, чтение
продолжится последовательно от позиции в файле.
 метка 1- это необязатальная метка оператора в той же са-
мой программной единице, что и оператор READ. Если
этот параметр отсутствует, чтение дошедшее до конца
файла порождает ошибку счета. Если он есть, встре-
тившееся условие конца файла передает управление
на указанный выполняемый оператор.
 метка 2 - необязательная метка оператора в той же самой
программной единице, что и оператор READ. Если
этот параметр отсутствует, ошибка ввода/вывода
порождает ошибку счета. Если он есть, ошибка вво-
да/вывода передает управление на указанный выпол-
няемый оператор.
Список-ввода-вывода- определяет объекты, в которые
передаются величины из файла.
Он может быть пустым, но обычно содержит
объекты для ввода и неявные циклы, разделенные
запятыми.
Особенности.
     Если чтение внутреннее, источником ввода служит символьная
переменная или массив символьных элементов; если чтение не внут-
реннее, источником ввода является внешнее устройство. Для более
подобной информации об определении внешних устройств и других эле-
ментов операторов ввода/вывода смотрите часть 4.
     Если файл не был открыт оператором OPEN, выполняется операция
OPEN по умолчанию. Эта операция эквивалентна выполнению следующего
оператора :
     OPEN (оператор устройства, FILE=", STATUS='OLD',
     ACCESS='SEQUENTIAL',FORM='формат'
     Формат - это FORMATTED для форматного READ и UNFORMATTED для
не форматного READ. Смотрите описание оператора OPEN для понимания
действия параметра FILE=.

     Пример:
     С  Описание двухмерного массива
          DIMENSION IA(10,20)
     С  Чтение в границы массива. Эти границы не превышают
     С  10 и 20 соответственно. Затем чтение в массив неявным
     С  циклом DO с вводным форматом 8 колонок по 5 цифр.
          READ (3,990) IL, JL, ((IA(I,J), J=1, JL), I=1, IL)
     990  FORMAT (215/,(8I5))



▄───────────────
█     RETURN
▀───────────────

     Возвращает управление в вызываемую программную единицу.
──────────────────────────────────────────────────────────
     RETURN
──────────────────────────────────────────────────────────

    RETURN может появляться только в функции или подпрограмме.

Особенности.
     Выполнение оператора RETURN заканчивает выполнение всей под-
программы или функции. Если оператор RETURN находится в функции,
величине функции присваивается текущее значение переменной с тем
же именем, что и функция.
     Выполнение оператора END в функции или подпрограмме эквива-
лентно выполнению оператора RETURN. Поэтому для окончания функции
или подпрограммы требуется или RETURN или END,но не оба:

Пример
     С  Пример оператора RETURN
     С  Эта подпрограмма выполняет цикл
     С  пока вы не наберете "Y"
          SUBROUTINE LOOP
          CHARACTER IN
     C
      10  READ (*,'(A1)') IN
          IF (IN.EG.'Y') RETURN
          GO TO
     C  Неявный RETURN
          END


▄───────────────
█     REWIND
▀───────────────

     Возвращает в начальную точку файл, связанный с определенным
устройством.
───────────────────────────────────────────────────
     REWIND определитель устройства
───────────────────────────────────────────────────
Где определитель-устройства
- это заданный определитель внешнего устройства.
Для более подробной информации об определителях
устройств и других элементах операторов ввода/вы-
вода смотрите часть 4 "Система ввода/вывода".
Пример
          INTEGER A(80)
           .
          WRITE (7,'(80I1)')A
           .
           .
          REWIND
           .
          READ (7,'(80I1)')A



▄────────────
█     SAVE
▀────────────

     Заставляет переменные запоминать их значения при вызовах
процедур, в которых они определены.
──────────────────────────────────────────────────────────
     SAVE имя1 [,имя]...
──────────────────────────────────────────────────────────
Где имя - это имя COMMON-блока (заключенное в косые чер-
точки), переменной или массива. После заполнения,
если в текущую процедуру еще раз войти, то назван-
ные переменные и все переменные в названном COMMON-
блоке содержит определенные величины.
Пример
     С  Пример оператора SAVE
          SAVE /MYCOM/, MYVAR


▄─────────────────────────
█     Функция-оператор
▀─────────────────────────

     Определяет функцию в виде одного оператора.
──────────────────────────────────────────────────────────
    имя-функции ([параметр[,параметр]...])=выражение
──────────────────────────────────────────────────────────
Где имя-функции параметр выражение
- это имя функции-оператора
- это имя формального параметра
- это любое выражение
Особенности.
     Функция оператор подобна по виду оператору присваивания. Фун-
кция-оператор может стоять только после операторов определения
типа и перед любыми исполняемыыми операторами в програмной еденице,
в которой она используется.
     Функция-оператор - это невыполняемый оператор, хотя она и
является первым оператором в программной единице. Однако, тело
функции-оператора служит для определения значения функции-опера-
тора. Как и другие любые функции функция-оператор вычисляется по
ссылке в выражении.
     Тип выражения должен быть совместим с типом имени функции-
оператора. Список имени формальных параметров служит для
определения числа и типа параметров функции-оператора. Областью
действия имен фармальных параметров является сама функция оператор.
Поэтому имена формальных параметров могут быть переопределены как
другие имена пользователя в оставшейся части программной единици,
за исключением определителя функции-оператора.
     Имя функции-оператора, однако, локально, по отношению к
программной единице; оно не должно быть использовано где либо еще,
кроме имени COMMON-блока или имени формального параметра в другой
функции-операторе. Впоследнем случае тип такого использования
должен быть одинаковым.
     Если имя формального параметра совпадает с любым другим ло-
кальным именем, то следует иметь в виду, что ссылка на это время
в функции-операторе определяет его как формальный параметр и ни в
каком другом смысле.



     В выражении допустимы ссылки на переменные, формальные
параметры, другие функции, элементы массивов и константы. Ссылки
на функции-операторы, однако, должны относится к функциям,
описанным до того, как они употреблены здесь. На функцию-оператор
не может быть вызвана рекурсивно, как прямо так и косвенно.
     На функцию-оператор можно ссылаться только в той программной
единице, где она описана. Имя функции-оператора не должно появлять-
ся ни в каких описывающих операторах, за исключением описания типа
(которые не могут описывать это имя, как массив) и оператора COMMON
(как имя COMMON-блока).
Функция-оператор не может быть типа CHARACTER.

Пример
     С  Пример оператора функция-оператор
          DIMENSION X(10)
          ADD(A,B)=A+B
     C
          DO 1 I=1,10
          X(I)=ADD(Y,Z)
      1   CONTINUE


▄─────────────
█     STOP
▀─────────────

     Оканчивает программу.
──────────────────────────────────────────────────────────
     STOP [n]
──────────────────────────────────────────────────────────
Где
n    - это либо символьная константа, либо строка из не более чем
     пяти цифр.

Особенности.
     Параметр n, если он есть, высвечивается на экран, когда про-
грамма оканчивается. Если n нет, высвечивается такое сообщение:
          STOP - Program terminated
          (STOP - Программа окончена)

     Пример
     С  Пример оператора STOP
          IF (IERROR.TQ.0) GO TO 200
          STOP 'Определена ошибка'
    200  CONTINUE




▄────────────────────
█     SUBROUTINE
▀────────────────────

     Определяет программную единицу как программу, присваивает ей
имя и определяет формальные параметры для этой подпрограммы. Эти
параметры могут содержать переменную метку возврата (*).
──────────────────────────────────────────────────────────
     SUBROUTINE имя подпрограммы [([форм-пар[,форм-пар]...])]
──────────────────────────────────────────────────────────
Где
имя-подпрограммы - это определяемое пользователем глобальное внешнее
имя подпрограммы.
форм-пар- это определяемое пользователем имя формального
параметра, называемого также фиктивным параметром.
Формальный параметр может быть переменной меткой
возврата (*).
Особенности.
     Подпрограмма начинается с оператора SUBROUTINE и заканчивается
следующим за ним оператором END. Она может включать в себя любые
операторы кроме PROGRAM, SUBROUTINE, BLOСK DATA и FUNCTION.
     Список имен параметров определяет число и вместе с пос-
ледующими операторами определения типа, IMPLICIT, EXTERNАL или
DIMENSION - тип параметров этой подпрограммы. Имена параметров не
могут появляться в операторах COMMON, DATA, EQVIVALENCE или
INTRINSIC.
     Фактические параметры в операторе CALL, вызывающем подпрог-
рамму, должны соответствовать формальным параметрам в операторе
SUBROUTINE  по порядку следования, числу, типу или виду.
     Компилятор будет проверять их на соответствие, если известны
формальные параметры. Должно быть понятно, что оператор SUBROUTINE,
определяющий формальные параметры, должен предшествовать оператору
CALL в текущей компиляции.
     Правила соответствия формальных и фактических параметров при-
ведены описании оператора CALL.

Пример
          SUBROUTINE GETNUM (NUM, UNIT)
          INTEGER NUM, UNIT
     10   READ (UNIT, '(I10)', ERR=10) NUM
          RETURN
          END


▄────────────
█     Тип
▀────────────

     Определяет тип имен, используемых пользователем.
──────────────────────────────────────────────────────────
     Тип имя-пер1 [,имя-пер2]...
──────────────────────────────────────────────────────────

Где
тип   - это один из следующих определителей типа данных.
     INTEGER, INTEGER*2, INTEGER*4,
     REAL, REAL*4, REAL*8, DOUBLE PRECISION,
     COMPLEX, COMPLEX*8, COMPLEX*16,
     LOGICAL, LOGICAL*2, LOGICAL*4,
     CHARACTER, CHARACTER*n


имя-пер       - это символьное имя переменной, массива,  или фун-
               кции-оператора, или подпрограммы-функции,или опера-
               тора объявления массива.

     n  (в CHARACTER*n) это целое в диапазоне от 1 до 127.

Особенности.
     Оператор определения типа может подтверждать или отвергать
неявный тип имени. Оператор определения типа может также определить
размер.
     Пользовательское имя переменной, массива, внешней функции
или функции-оператора может упоминаться в операторе определения
типа. В этом случае тип этого имени определен во всей программной
единице. В программной единице оператор определения типа однозначно
определяет тип имени.
     Оператор определения типа может также подтвердить тип встро-
енной функции, но это не обязательно. В операторе определения типа
не может встретится имя подпрограммы или основной программы.
     К оператору определения типа применимы следующие правила:
     1. Оператор определения типа должен предшествовать всем
     выполняемым операторам.
     2. Тип данных с символьным именем может быть точно описан
     только однажды.
     3. Оператор определения типа не должен иметь метки.
     4. Оператор определения типа может описывать массив добав-
     лением описателя размерности к имени массива.
     За символьным именем может следовать определитель длины типа
данных в виде *длина, где длина - одна из доступных типов длин
для провозглашенного типа данных. Такое описание отменяет атрибут
длины, который подразумевался оператором определения типа, и
присвает новую длину описываемому объекту. Если присутствуют как
описатель длины типа, так и описатель массива, описатель длины
типа должен быть последним.

Пример:
     С  Пример операторов определения типа
          INTEGER COUNT, MATRIX(4,4), SUM
          REAL MAN, IABS
          LOGICAL SWITCH
          .
          INTEGER*2 Q, M12*4, IVEC(10)*4
          .
          CMARACTER NAME*10, CITY*80, CH


▄──────────────
█     WRITE
▀──────────────

     Передает данные из объектов списка-ввода/вывода в файл,
связанный с указанным устройством.
──────────────────────────────────────────────────────────
    WRITE (определитель-устройства[,определитель-формата]
    [,IOSTAT=состояние][,ERR=метка][,REC=номер-записи])
     список-ввода/вывода
──────────────────────────────────────────────────────────


Где
Определитель-устройства
- это определитель заданного устройства, он должен
быть первым параметром. Для более подробной инфор-
мации об определителе устройства и других элементах
ввода/вывода смотрите часть 4 "Система ввода/выво-
да".
Определитель-формата
требуется, как второй параметр, для форматного
WRITE. Не должен появляться для неформатного WRITE.
Остальные параметры, если они есть, могут появля-
ться в любом порядке.
Состояние- это целая переменная или элемент целого массива,
который присваивается:
а) нуль, если не встретились ошибка или конец
файла.
b) машинно-зависимая положительная целая величина,
если встретилась ошибка.
с) машинно-зависимая отрицательная величина, если
встретится конец файла и не было ошибки.
Метка- это необязательная метка оператора. Если ее нет,
ошибка ввода/вывода порождает ошибку счета. Если
она есть, ошибка ввода/вывода передает управление
на заданный выполняемый оператор.
Номер-записиопределен только для файлов прямого доступа
(в противном случае вызывает ошибку). Это положитель-
ное целое выражение, определяющего с какого номера
записи в файле производить запись. Первая запись
в файле имеет номер 1. Если для файлов прямого
доступа номер записи отсутствует, запись продол-
жается с текущей позиции в файле.
Список- ввода/вывода  определяет объекты, чьи величины должны быть
переданы оператором WRITE. Список ввода/вывода
может быть пустым, но обычно он содержит объекты
вывода и неявные циклы, разделенные запятыми.
Особенности.
     Если запись внутренняя, то адресатом вывода является симво-
льная переменная или массив символьных элементов, определенные
как устройство; в противном случае, адресат - это внешнее устрой-
ство.
     Если файл не был открыт оператором OPEN, подразумевается, что
выполняется неявная операция открытия. Эта операция эквивалентна
следующему оператору:
      OPEN (определитель-устройства,FILE=",STATUS=NEW',
+ACCESS='SEQUENTIAL',FORM=формат).
     Формат - это FORMATTED для форматной записи и UNFORMATTED
для неформатного оператора OPEN для понимания действия FILE=пара-
метр.


Пример
     С  Высветить сообщение "One=1, Two=2, Three=3"
     С  на экран, неделая это простейшим образом!
          WRITE (* ,980)'One= ',1,1+1,'ee= ',+(1+1+1)
     980  FORMAT (A,I2,Two= ',1X,I1,Thr',A,I2)










