
                        ТЕРМИНЫ И КОНЦЕПЦИИ.



     ОБ ЭТОЙ ЧАСТИ
     Эта часть описывает основные возможности языка МС-Фортран.


СОДЕРЖАНИЕ.



1. ЗАПИСЬ ПРОГРАММ.  . . . . . . . . . . . . . . . . . . . .  2-1

1.1. Буквенноцифровые символы. . . . . . . . . . . . . . . .  2-1

1.2. Пробелы.  . . . . . . . . . . . . . . . . . . . . . . .  2-1

1.3. Табуляторы. . . . . . . . . . . . . . . . . . . . . . .  2-1

1.4. Позиции.  . . . . . . . . . . . . . . . . . . . . . . .  2-1

2. СТРОКИ И ОПЕРАТОРЫ. . . . . . . . . . . . . . . . . . . .  2-1

2.1. Начальные строки. . . . . . . . . . . . . . . . . . . .  2-2

2.2. Строки продолжения. . . . . . . . . . . . . . . . . . .  2-2

2.3. Строки коментария.  . . . . . . . . . . . . . . . . . .  2-2

2.4. Операторы описания данных и порядок следования опера-
     торов.  . . . . . . . . . . . . . . . . . . . . . . . .  2-2

3. ТИПЫ ДАННЫХ.  . . . . . . . . . . . . . . . . . . . . . .  2-4

3.1. Целые типы данных.  . . . . . . . . . . . . . . . . . .  2-5

3.2. Тип действительных данных обычной точности IEEE.  . . .  2-6

3.3. Действительный тип данных IEEE двойной точности.  . . .  2-6

3.4. Формат десятичных чисел с плавающей точкой
       обычной и двойной точности. . . . . . . . . . . . . .  2-7

3.5. Комплексные типы данных.  . . . . . . . . . . . . . . .  2-7

3.6. Логические типы данных. . . . . . . . . . . . . . . . .  2-8

3.7. Символьный тип данных.  . . . . . . . . . . . . . . . .  2-8

3.7.1. Символьные подстроки. . . . . . . . . . . . . . . . .  2-9

4. ИМЕНА.  . . . . . . . . . . . . . . . . . . . . . . . . . 2-10

4.1. Область действия имен Фортрана. . . . . . . . . . . . . 2-10

4.2. Имена Фортрана по умолчанию.  . . . . . . . . . . . . . 2-11


5. ВЫРАЖЕНИЯ.  . . . . . . . . . . . . . . . . . . . . . . . 2-12

5.1. Арифметические выражения. . . . . . . . . . . . . . . . 2-12

5.2. Деление целых.  . . . . . . . . . . . . . . . . . . . . 2-13

5.3. Преобразования типов арифметических операндов.  . . . . 2-13

5.4. Символьные выражения. . . . . . . . . . . . . . . . . . 2-13

5.5. Выражения отношения.  . . . . . . . . . . . . . . . . . 2-14

5.6. Логические выражения.   . . . . . . . . . . . . . . . . 2-14

5.7. Приоритеты операторов.  . . . . . . . . . . . . . . . . 2-15

5.8. Правила вычисления выражений. . . . . . . . . . . . . . 2-15

5.9. Ссылки на элемент массива.  . . . . . . . . . . . . . . 2-16


     1. ЗАПИСЬ ПРОГРАММ.

     Текст программы на Фортране - это последовательность символов
ASCII. К символам ASCII относятся:
1.   52 прописных и заглавных английских буквы (от А до Z и от а
     до z).
2.   10 цифр (0,1,2,3,4,5,6,7,8,9)
3.   Специальные символы (все остальные печатаемые символы таблицы
     кодов ASCII - в том числе и русские буквы).

1.1. Буквенноцифровые символы.

     Английские  буквы  и цифры, рассматриваемые как одна группа,
называются буквенноцифровыми символами.  МС-Фортран  воспринимает
прописные  буквы  как  заглавные в любом контексты, исключая сим-
вольные константы и холлеритовские поля. Поэтому следующие имена,
определенные пользователем, эквивалентны в МС-Фортране:
   ABCDE      abcde      AbCdE      aBcDe
     Последовательность сортировки для набора символов МС-Фортра-
на - это последовательность ASCII (Полную таблицу символов  ASCII
смотрите в приложении С "Коды символов ASCII").

1.2. Пробелы.

     За  исключением  ниже приведенного списка символов пробел не
является значащим в тексте программы на МС-Фортране и поэтому мо-
жет использоваться для улучшения внешнего вида программы.  Исклю-
чения  следующие:
1. Пробелы внутри строковых констант являются значащими.
2. Пробелы  внутри  холлеритовских  полей являются значащими.
3. Пробел или нуль в шестов позиции отличает начальную строку  от
   строки продолжения.

1.3. Табуляторы.

     Символ  ТАВ  имеет  следующее значение в тексте программы на
МС-Фортране:
1. Если ТАВ появляется в позициях с 1-ой по 5-ю, то считается,
   что следующий символ находится в 7-ой позиции.
2. ТАВ в позициях с 6-ой по 72-ю рассматривается как пробел, даже
   если он содержит внутри строки или холлеритового поля.

1.4. Позиции.

     Символы  в каждой строке расположены по позициям, первый - в
первой позиции, второй - во второй и т.д.
     Позиция, в которой находится символ, имеет существенное зна-
чение  в Фортране. Позиция 1 используется для указания коментария
и метакоманды. Позиции с 1-ой по 5-ю  зарезервированы  для  меток
операторов, а 6-я позиция для указания продолжения.



2. СТРОКИ И ОПЕРАТОРЫ.

     Вы можете также считать, что текст программы на  Фортране  -
это  последовательность строк. Для компилятора значащими являются
только первые 72 символа в  строке,  остальные  им  игнорируются.
Строки,  длиной  меньше,  чем  72 символа, считаются заполненными
пробелами до 72-ой позиции (для иллюстрации этого смотрите ниже в
этой части в описании символьных констант).

2.1. Начальные строки.

     Начальной  строкой  называется строка, не являющаяся строкой
коментария или метакоманды и содержащая пробел или нуль в  шестой
позиции.  В  первых  пяти позициях строки должны быть пробелы или
должна стоять метка. За исключением оператора, следующим за логи-
ческим IF, операторы Фортрана должны начинаться с начальной стро-
ки.
     Метка оператора - это последовательность от  одной  до  пяти
цифр,  хотя  бы  одна из которых должна быть не нуль. Метка может
находится в любом месте в позициях с  1-ой  по  5-ю  в  начальной
строке. Пробелы и предшествующие нули являются незначащими.

2.2. Строки продолжения.

     Строка продолжения - это любая строка, не  являющая  строкой
коментария  или метакоманды и содержащая в позиции 6 любой символ
отличный от пробела или нуля. Первые пять символов строки продол-
жения позволяет существенно увеличить длину оператора. Если он не
помещается в одну начальную строку,  его  можно  продлить  на  19
строк продолжения.

2.3. Строки коментария.

     Строка  считается  строкой коментария, если выполняется одно
из следующих условий:
1. В позиции 1 стоит "С" (или"с").
2. В позиции 1 стоит звездочка (*).
3. Строка состоит из одних пробелов.
     Строки комментария не оказывают никакого воздействия на  вы-
полнение  программы  на  Фортране. После строки коментария должна
идти начальная строка или другая строка коментария.  Строка  про-
должения не может следовать за строкой коментария.

2.4. Операторы описания данных и порядок следования операторов.

     Оператор  Фортрана  содержит  начальную  строку и от 0 до 19
строк продолжения. Оператор может содержать до  1320  символов  в
позициях  с  7-ой по 72-ю начальной строки и с 7-ой по 72-ю строк
продолжения. Оператор END должен быть записан в позициях  с  7-ой
по  72-ю  начальной  строки  и в его строке не может быть никаких
других операторов (в дальнейшем на отдельные операторы  мы  будем
ссылаться  просто  по их именам; смотрите часть 3 "Операторы" для
определения различных операторов и их свойств).
     Язык Фортран требует определенного порядка следования опера-
торов и строк, составляющих программную единицу  Фортрана.  Кроме
того  МС-Фортран накладывает дополнительные требования на порядок
строк и операторов в транслируемом тексте МС-Фортрана.



     В  основном, транслируемый текст содержит одну или несколько
программных единиц (для  более  полной  информации  о  трансляции
программных  единиц  и  подпрограмм  смотрите часть 5 "Программы,
подпрограммы и функции"). Различные правила по порядку следования
операторов проиллюстрированы на рис.2-1 и описаны в следующих па-
раграфах.

┌────────────────────────────────────────────────────┬─────────┐
│  метакоманды $DO66,$STORAGE,$DECMATH               │         │
├────────────────────────────────────────┬───────────┤         │
│ операторы PROGRAM,FUNCTION,            │           │         │
│ BLOCK DATА,SUBROUTINE                  │           │         │
├───────────────────┬──────────┬─────────┤  другие   │         │
│оператор IMPLICIT  │операторы │         │  мета-    │ строки  │
├───────────────────┤          │         │  команды  │         │
│другие операторы   │PARAMETER │операторы│           │ комен-  │
│определения данных │          │         │           │ тариев  │
├───────────────────┼──────────┤ FORMAT  │           │         │
│функции-операторы  │операторы │         │           │         │
├───────────────────┤          │         │           │         │
│  выполняемые      │   DATA   │         │           │         │
│   операторы       │          │         │           │         │
├───────────────────┴──────────┴─────────┴───────────┤         │
│   оператор   END                                   │         │
└────────────────────────────────────────────────────┴─────────┘

Рис.2-1  Порядок операторов в программых единицах и транслируемых
          текстах.

     Для рисунка 2-1 существуют следующие соглашения:
1.   Классы строк или операторов, расположенные выше или ниже
     других классов, должны следовать в заданном порядке.
2.   Классы строк или операторов могут быть перемешаны с другими
     классами, находящимися с боку от них.
3.   Метакоманды $LARGE и $NOTLARGE не могут находиться в разделе
     выполняемых операторов.
4.   Подпрограммы BLOCK DATA не могут содержать функции-операторы,
     операторы FORMAT или выполняемые операторы.
     Подпрограмма начинается с оператора  либо  SUBROUTINE,  либо
FUNCTION,  либо BLOCK DATA и заканчивается оператором END. Основ-
ная программа начинается с оператора PROGRAM или  любого  другого
оператора, отличного от операторов SUBROUTINE, FUNCTION или BLOCK
DATA,  и  заканчивается  оператором  END. Подпрограмма и основная
программа являются программными единицами.
     В программной единице операторы должны следовать в порядке,
соответствующем таким правилам:
1.   Оператор PROGRAM, если он есть или оператор SUBROUTINE,
     FUNCTION, BLOCK DATA должны быть первым оператором программ-
     ной единицы.
2.   Оператор FORMAT может встретиться в любом месте после операто-
     ра  SUBROUTINE,  FUNCTION,BLOCK  DATA  или  PROGRAM, если он
     есть.
3.   Все операторы определения типов должны предшествовать опера-
     торам DATA, операторам-функциям и выполняемым операторам.
4.   Все операторы DATA должны стоять после операторов определения
     типов. Операторы DATA могут быть перемешаны с операторами-
     функциями и выполняемыми операторами.



5.   Обычно оператор PARAMETER предшествует всем другим операторам
     определения типов. Однако, когда некоторый оператор определяет
     тип константы, используемой в операторе PARAMETER, оператор
     PARAMETER должен следовать за этим оператором определения
     типа.
6.   В операторах определения типа оператор IMPLICIT должен пред-
     шествовать всем другим операторам, за исключением оператора
     PARAMETER.
7.   Все операторы-функции должны предшествовать всем выполняемым
     операторам.
8.   Метакоманды $DO66, $DECMATH и $STORAGE должны предшествовать
     любым другим операторам. Другие места команды могут находиться
     где угодно в программной единице.

3. ТИПЫ ДАННЫХ.

     В МС-Фортране существует шесть основных типов данных:
1.   Целый (INTEGER*2  INTEGER*4)
2.   Действительный (REAL*4 или REAL)
3.   Двойной точности (REAL*8 или DOUBLE PRECISION)
4.   Комплексный (COMPLEX*8 и COMPLEX*16)
5.   Логический (LOGICAL*2 и LOGICAL*4)
6.   Символьный.
     Свойства, состав и форма представления констант каждого типа
описаны на следующих страницах; требования по памяти приведены в
таблице 2-2.
┌──────────────────────┬─────────────────────┬───────────┐
│        Тип           │   Число байтов      │Примечание │
├──────────────────────┼─────────────────────┼───────────┤
│  LOGICAL             │     2 или 4         │     1     │
│  LOGICAL*2           │        2            │           │
│  LOGICAL*4           │        4            │           │
│  INTEGER             │     2 или 4         │     1     │
│  INTEGER*2           │        2            │           │
│  INTEGER*4           │        4            │           │
│  SHARACTER           │        1            │     2     │
│  SHARACTER*n         │        n            │     3     │
│  REAL                │        4            │     4     │
│  REAL*4              │        4            │           │
│  REAL*8              │        8            │     5     │
│  DOUBLE PRECISION    │        8            │           │
│  COMPLEX             │        8            │     6     │
│  COMPLEX*8           │        8            │           │
│  COMPLEX*16          │        16           │           │
└──────────────────────┴─────────────────────┴───────────┘

Таб.2-2. Требования по памяти.

Примечание к таблице 2-2:
1.   Может использоваться 2 или 4 байта. По умолчанию - 4, но мета-
     командой $STORAGE может быть установлено 2 или 4.
2.   CHARACTER и CHARACTER*1 - синонимы.
3.   Максимальное n равно 127.
4.   REAL и REAL*4 - синонимы.
5.   REAL*8 и DOUBLE PRECISION - синонимы.
6.   COMPLEX и COMPLEX*8 - синонимы.



Замечания.
     На многих микропроцессорах команды, необходимые для выполне-
ния 16-битовой арифметики, значительно быстрее и короче соответс-
твующих команд для выполнения 32-битовой арифметики. Поэтому, по-
ка Вы не используете метакоманду МС-Фортрана $STORAGE, устанавли-
вающую 2, в программе по умолчанию будет 32-битовая арифметика  и
она  будет  выполняться  существенно  медленней,  чем  ожидается.
(Смотрите описание метакоманды $STORAGE в части 6).  Установка  2
метакомандой  $STORAGE  ускорит выполнение программы и сделает ее
короче.
     Вы можете использовать внутреннюю функцию INT2 для  указанию
компилятору использовать в выраженных 16-битовую арифметику.

3.1. Целые типы данных.

     Целый тип данных состоит из подмножества целых чисел.  Целая
величина  - это точное представление соответствующего целого. Це-
лая величина занимает 2 или 4 байта, в зависимости  от  установки
метакоманды  $STORAGE.  2-байтовое целое, INTEGER*2, может содер-
жать величину в диапазоне от -32767 до 32767.  4-байтовое  целое,
INTEGER*4, может содержать величину в диапазоне от -2147483647 до
2147463647.
     Целые константы содержат последовательность одной или  более
десятичных  цифр  или  определитель системы счисления, за которым
следует строка цифр в диапазоне от 0...(основание системы счисле-
ния - 1), где величины от 10 до 35 представлены буквами от А до Z
соответственно. Указатель системы счисления содержит символ  "#",
которому обычно предшествует строка десятичных цифр, представляю-
щая  величину основания системы счисления. Если строка отсутству-
ет, подразумевается, что основание равно 16. Если указатель  сис-
темы  счисления отсутствует, подразумевается, что основание равно
10.
     Любому  формату  может предшествовать произвольный арифмети-
ческий знак плюс (+) или минус (-). Целые константы не должны вы-
ходить из диапазона. Десятичная точка недопустима в целой конста-
не.
     Замечание: диапазон величин как для 16-битовых так и для 32-
битовых целых не включает наиболее отрицательное  число,  которое
может  быть представлено в двоичном дополнительном коде этим чис-
лом битов. Эти числа, 16#8000 и  16#80000000  обрабатываются  как
"неопределенные" для сигнализации об ошибке.
     Хотя максимальная величина 32-битового целого определена как
2**31-1, при компиляции и счете будут считываться и большие вели-
чины,  которые  выходят  за диапазон 2**32. Но эти величины будут
только считываться без ошибки, если  их  основание  счисления  не
равно 10. Они будут интегрироваться как отрицательные числа с со-
ответствующим  внутренним  представлением.  Например, 16#FFFFFFFF
приведет к тому что все биты 32-битового числа будут единицы, что
соответствует арифметической величине -1.
     Примеры целых констант:
                   123           +123               0
              00000123          32767          -32767
                -#AB05       2#010111       -36#ABZ07
     В МС-Фортране точность целых определяется следующим образом:
     *Константы.
     Точность устанавливает метакоманда $STORAGE.
     *Результат выражения.
     Точность  результата  определяется  точностью  максимального
операнда и величиной установленной метакомандой $STORAGE.



     *Формальные параметры.
     Если точность неизвестна, предлагается, что она такая же как
у  фактического параметра. Если тип известен, он должен точно со-
ответствовать фактическому параметру (до тех пор пока параметр не
передается величиной, использующей  атрибут  VALUE,  описанный  в
части 7).
     *Целые переменные и функции.
     Точность задана для каждой переменной или функции (по умолча-
нию установлена метакомандой $STORAGE).

3.2. Тип действительных данных обычной точности IEEE.

     Тип действительных данных (REAL или REAL*4) содержит подмно-
жество  действительных чисел обычной точности. Действительная ве-
личина обычной точности - это приближение требуемого действитель-
ного числа, занимающее 4 байта  памяти.  Диапазон  действительных
чисел обычной точности приблизительно следующий:
     от 8.43Е-37 до 3.37Е+38 (положительные числа)
     от -3.37Е+38 до -8.43Е-37(отрицательные числа)
               0                (нуль)
     Точность - больше шести десятичных цифр и меньше семи.
Основная действительная константа содержит:
1.   Необязательный знак.
2.   Целую часть.
3.   Десятичную точку.
4.   Дробную часть.
5.   Необязательный показатель экспоненты.
     Целая  и дробная части содержат по одной или больше десятич-
ных цифр, а точка является разделителем (.). Как целая часть, так
и дробная могут отсутствовать, но не обе. Некоторые простые целые
константы:
         -123.456              +123.456           123.456
  -123.                 +123.              123.
         -.456                 +.456              .456
     Экспоненциальная часть содержит букву "Е", за которой следу-
ет  (необязательно)  целая  константа со знаком из одной или двух
цифр.
     Экспонента показывает, что предшествующую величину нужно ум-
ножить на десять в степени целая константа. Некоторые простые эк-
споненциальные части:
          Е12          Е-12             Е+12      Е0
     Действительная константа - это либо основная  действительная
константа,  либо  основная действительная константа с экспоненци-
альной частью, либо целая константа  с  экспоненциальной  частью.
Например:
           +1.000Е-2         1.Е-2          1Е-2
           +0.01           100.0Е-4        0.0001Е+2
Все это - одно и то же число, одна сотая.

3.3. Действительный тип данных IEEE двойной точности.

     Действительный  тип  данных  двойной  точности  (REAL*8  или
DOUBLE  PRECISION)  содержит  подмножество  действительных  чисел
двойной точности. Это подмножество больше, чем подмножество  типа
данных REAL(REAL*4).



     Действительная величина двойной точности - это, обычно приб-
лижение требуемого действительного числа. Действительная величина
двойной точности может быть положительной, отрицательной или  ну-
лем  и занимает восемь байтов памяти. Диапазон действительных ве-
личин двойной точности приблизительно следующий:
     от 4.19D-307  до 1.67D+308  (положительные числа)
     от -1.67D+308 до -4.19D-307 (отрицательные числа)
                          0      (нуль)
     Точность больше чем 15 десятичных цифр. Константа двойной
точности содержит:
1.   Необязательный знак.
2.   Целую часть.
3.   Десятичную точку.
4.   Дробную часть.
5.   Обязательную экспоненциальную часть.
     В экспоненте используется "D" а не "Е" для отличия от  обыч-
ной точности. Целая и дробная части содержат одну или более деся-
тичных  цифр,  а  десятичная  точка  является разделителем. Целая
часть или дробная, но не обе, могут отсутствовать.
     Константа  двойной точности - это либо основная действитель-
ная константа, за которой следует  экспоненциальная  часть,  либо
целая  константа, за которой следует экспоненциальная часть. Нап-
ример:
     +1.123456789D-2         1.D-2           1D-2
     +0.000000001D0       100.0000005D-4   .00012345D+2
     Экспоненциальная часть содержит букву "D", за которой следу-
ет целая константа. Целая константа  может  иметь  необязательный
знак. Экспонента показывает, что предшествующее число должно быть
умножено на десять в степени целый показатель экспоненты. Некото-
рые простые экспоненты:
              D12    /D-12      D+12      /D0

3.4. Формат десятичных чисел с плавающей точкой
     обычной и двойной точности.

     Десятичные  числа  с  плавающей точкой содержат байт с битом
знака и семибитовой экспонентой в 64-ричной системе счисления, за
которым следует мантисса из 6 (для обычной точности)  или  из  14
(для  двойной точности) двоично-десятичных цифр, упакованных по 2
в байт (если байт экспоненты нулей - число  равно  нулю).  Запись
десятичных констант с плавающей точкой производится в том же фор-
мате,  что  и  для  стандартных  действительных констант Фортрана
обычной и двойной точности.  Допустимый  диапазон  чисел  обычной
точности следующий:
       от +1.0Е-64 до +9.99Е+62 (положительные числа)
       от -9.99+62 до -1.0Е-64  (отрицательные числа)
             0                  (нуль)
Точность равна точно 6 цифрам.
Допустимый диапазон чисел двойной точности следующий:
       от +1.0D-64  до +9.999D+62 (положительные числа)
       от -9.99D+62 до -1.0D-64   (отрицательные числа)
              0                   (нуль)
Точность равна точно 14 цифрам.
     Метакоманда $DECMATH вызывает представление констант тексто-
вого файла в виде с плавающей запятой.



3.5. Комплексные типы данных.

     Тип данных COMPLEX*8 задает пару действительных чисел  обыч-
ной  точности, второе из которых представляет мнимую часть. Число
COMPLEX*8 занимает 8 байтов памяти.
     Комплексная  константа состоит из необязательного знака, ле-
вой скобки, двух целых или действительный чисел, разделенных  за-
пятой, и правой скобки. Элемент данных COMPLEX*16 содержит упоря-
доченную пару действительных чисел двойной точности. Элемент дан-
ных COMPLEX*16 занимает 16 байтов памяти. Каждая компонента (дей-
ствительная  и  мнимая) COMPLEX*8 - это REAL*4. Каждая компонента
COMPLEX*16 - это REAL*8.


3.6. Логические типы данных.

     Логический  тип  данных  содержит  две  логических  величины
.TRUE. и .FALSE. Логическая переменная занимает  два  или  четыре
байта  памяти в зависимости от установки метакоманды $STORAGE. По
умолчанию это 4 байта. Значение логической  переменной  независит
от  метакоманды  $STORAGE, которая соответствует требованию ANSI,
чтобы логические, целые и действительные переменные обычной  точ-
ности  занимали одинаковое место в памяти. Величины LOGICAL*2 за-
нимают  два  байта.  Младший  значащий  (первый)  байт   -   либо
0(.FALSE.), либо 1(.TRUE.); старший значащий байт не определен.
     Переменные LOGICAL*4 занимают два  слова,  младшее  значащее
(первое) из которых содержит величину LOGICAL*2. Старшее значащее
слово не определено.

3.7. Символьный тип данных.

     Символьный тип данных содержит  последовательность  символов
ASCII.  Длина символьной величины равно числу символов в последо-
вательности. Длина заданной константы или переменой фиксирована и
должна составлять от 1 до 127 символов. Символьная переменная за-
нимает один байт памяти для каждого символа в последовательности.
Предполагается, что символьная переменная занимает цепочку байтов
без учета границ слов. Однако компилятор предполагает, что несим-
вольные переменные, следующие за символьными, начинаются с грани-
цы слова.
     Символьная константа содержит последовательность  из  одного
или  более символов, заключенных в пару одиночных кавычек. В сим-
вольной константе символы пробелов допустимы и значимы.  Регистры
буквенных  символов значимы. Одиночная кавычка в символьной конс-
танте представляется двумя одиночными кавычками без пробелов меж-
ду ними.
     Длина символьной константы равна числу символов  между  оди-
ночными  кавычками.  Пара одиночных кавычек означает один символ.
Несколько примеров символьных констант:
                   'A'
                   ' '
                   'Help!'
                   'A very long CHARACTER constant'
                   'O''Brien'
                   ''''
     Последний  пример - это символьная константа содержащая один
апостроф (одиночную кавычку).



     Символьной переменной может быть присвоена несимвольная  ве-
личина, если присвоение не включено в выражение. Допустимо следу-
ющее:
                     REAL R
                     CHARACTER*5 C
                     C=R,
но следующее недопустимо
                     REAL R
                     CHARACTER*5 C
                     C=R+1.0
     Фортран допускает строки исходного текста длиной до 72 пози-
ций.  Короткие  строки дополняются пробелами до 72 позиции. Когда
символьная константа переходит через границу строки, ее  величина
такова,  как если бы часть строки продолжения, начиная с 7-ой по-
зиции, добавить к 72-й позиции начальной строки. Поэтому  следую-
щий текст Фортрана
                 200  СН='ABC
                    X DEF'
Эквивалентен:
                 200  CH='ABC(58 пробелов)...DEF'
     С  58-ю  пробелами  между С и Д, равными пространству от С в
15-й позиции до 72-й позиции плюс одному пробелу в  7-ой  позиции
строки  продолжения.  Таким образом могут быть представлены очень
длинные символьные константы.

3.7.1. Символьные подстроки.

     МС-Фортран поддерживает подстроки так же, как они определены
в полном языке Фортран 77. Подстроки относятся к типу CHARACTER и
используются для доступа к слитным частям символьной  переменной.
Они имеют следующий синтаксис:
───────────────────────────────────────────────
  переменная ([первый №]:[последний №])
───────────────────────────────────────────────
                     или
──────────────────────────────────────────────────────────
  массив (индекс1 [,индекс2])([первый №]:[последний №])
──────────────────────────────────────────────────────────
где
переменная                    это символьная переменная
массив (индекс1[,индекс2])    это элемент символьного массива
первый № и                    это целые выражения, определяющие
последний №                   первый (самый левый) и последний
                              (самый правый) символ в подстроке
                              Как первый №, так и последний № не-
                              обязательны. По умолчанию первый №
                              равен единице, так что подстрока
                              начинается с первого символа стро-
                              ки. По умолчанию последний № -это
                              длина строки, так что подстрока
                              кончается на последнем символе стро-
                              ки.
     Отметим  что  переменная(:)  эквивалентна  переменная. Длина
подстроки равна последний №-первый №+1. Взятая длина должна  быть
длиной  символьной  переменной  и  при этом должны удовлетворятся
следующие отношения:
1. первый №єпоследний №
2. 1єпервый  №єдлина
3. 1єпоследний №єдлина



     Транслятор не проверяет эти соотношения. Если они не сообщены
Вы получите неопределенный результат.
Подстроки не могут быть представлены величиной. Если Вы попытаетесь
это сделать, то получите ошибку 97.
Вы можете использовать подстроки для конкатенации строк, например,
                   CHARACTER A*12, B*20, C*32
                   A='Now is the t'
                   B='ime for all gooel men'
                   C(1:12)=A
                   C(13:12+20)=B
                   WRITE(*,*)'C=',C
                   END
В результате на выходе будет
                   C=Now is the time for all gooel men

4. ИМЕНА.

     Имя в МС-Фортране или идентификатор содержат последователь-
ность буквенноцифровых символов (максимум по 66 символов в строке,
умноженных на 20 строк). Начальный символ должен быть буквенным,
следующие символы должны быть буквенноцифровыми. Пробелы игнори-
руются. Только первые шесть буквенноцифровых символов являются
значащими, остальные игнорируются.
     Имя означают определенную пользователем или системой
переменную, массив или программную единицу. Любая значащая после-
довательность символов может быть использована для любого имени
Фортрана. Здесь нет зарезервированных имен, как в других языках.
Последовательности буквенных символов, используемые как ключевые
слова компилятора МС-Фортрана не смешиваются с именами, определя-
емыми пользователем. Компилятор отличает ключевые слова по их
контексту и на использование имен, определяемых пользователем,
нет ограничений.
     Поэтому в программе могут быть массивы с именами, например,
IF, READ или GO TO и при этом не будет ошибок (пока они будут ис-
пользоваться по правилам, которым должны подчиняться). Однако,
использование ключевых слов для имен пользователя часто мешает
читабельности программы и, практически, этого следует избегать.

4.1. Область действия имен Фортрана.

     Область действия имени - Это диапазон операторов, где это
имя известно, или на него можно ссылаться в программе на Фортране.
     В основном, область действия имени либо глобальна, либо
локальна, хотя и существуют некоторые исключения. Имя может быть
использовано лишь в соответствии с единственным определением в
его области действия. Однако, одно и тоже имя может иметь разные
определения в разных областях действия.
     Имя с глобальной областью действия может быть использовано в
более чем одной программной единице (подпрограмме, функции,
основной программе) и на него можно ссылаться в них. Фактически,
имена с глобальной областью действия используются обычным после-
довательным образом в одной и той же программе. Все имена процедур,
функций, подпрограмм, COMMON-блоков так же как и имена программ
имеют глобальную область действия. Поэтому не может быть подпрог-
раммы-функции с тем же именем, что и подпрограмма или COMMON-блок.
Также в одной программе две процедуры-функции не могут иметь одно
и то же имя.



     Имя с локальной областью действия доступно только внутри одной
программной единицы. Имя с локальной областью действия может быть
использовано в другой программной единице по другому назначению
или подобно, но нельзя требовать чтобы оно имело одинаковое зна-
чение в разных областях действия. Локальную область действия имеют
имена переменных, массивы, формальные параметры и функций-опера-
торы.
     Единственным исключением в правилах областей действия является
имя, присваиваемое данным в COMMON-блоке. Можно ссылаться на
глобально действующее имя COMMON-блока в программной единице, в
которой определено такое же локально действующее имя. Это возможно
благодаря тому, что имя COMMON-блока всегда заключено в косые чер-
точки, например, /FROG/ и поэтому всегда отличимо от таких же, но
обычных имен.
     Другое исключение из правил областей действия сделано для
параметров функции-оператора. Область действия параметров функции-
оператора ограничена единственным оператором, входящим в эту функ-
цию. Любое другое использование этих имен в функции-операторе не-
допустимо, пока они могут быть задействованы и вне ее.

4.2. Имена Фортрана по умолчанию.

     При проходе по выполняемым операторам программа компилятор
заводит имена, встречающиеся ему впервые ( т.е. те, которые не
определены точно ), в соответствии с контекстом.
     Если имя используется как переменная, его тип определяется
по первой букве имени ; I, J, K, L, M или N по умолчанию
принимаются целыми, а остальные буквы - действительными числами.
Вы можете использовать оператор IMPLICIT для замены соответствия
типа и начальной буквы (подробнее, смотрите часть 3 "Операторы").
Это же правило используется при использовании имени в функции для
определения типа возвратной величины.
     Когда имя используется как указатель в операторе CALL, под-
разумевается что это имя подрограммы. Точно так же подразумевается,
что имя, используемое в ссылке на функцию, - это имя функции. Если
подпрограмма или функция является частью этой же компилируемой
единицы ( т.е. находятся в этом же текстовом файле ) и это опре-
деление приведено до оператора CALL или ссылки на функцию, то ком-
пилятор проверит, чтобы тип фактических параметров и их число в
операторе CALLили ссылке на функцию соответствовали определениям
в операторе SUBROUTINE или FUNCTION.
5. ВЫРАЖЕНИЯ.

     Выражение - это формула для вычисления величины. Она содержит
последовательность операндов и операторов. Операнды могут содержать
вызовы функций, переменные, константы, или другие выражения.
Операторы определяют действия, которые необходимо произвести над
операндами.
     В Фортране существует четыре класса выражений :
     1. Арифметические.
     2. Символьные.
     3. Отношения.
     4. Логические.



5.1. Арифметические выражения.

     Результатом арифметических выражений являются величины типов
INTEGER, REAL, DOUBLE PRECISION или COMPLEX. Простейшие виды ариф-
метических выражений - это :
     1. Константы.
     2. Использование переменных.
     3. Использование элементов массивов.
     4. Использование функций.
Используемые величины переменных или элементов массивов должны
быть определены до того, как они появятся в арифметическом выра-
жении. Также, величины целых переменных должны быть арифметичес-
кими, а не величинами меток операторов, установленными оператором
ASSIGN.
     Другие арифметические выражения создаются из простейших форм,
приведенных выше в списке, с использованием скобок и арифметических
операторов указанных в таблице 2-3.
┌────────────────────┬──────────────────────┬────────────┐
│ Оператор           │     Операция         │  Приоритет │
├────────────────────┼──────────────────────┼────────────┤
│     * *            │ Возведение в степень │  Высший    │
│      /             │ Деление              │  Средний   │
│      *             │ Умножение            │  Средний   │
│      -             │ Вычитание или отриц. │  Низший    │
│      +             │ Сложение или         │  Низший    │
│                    │          идентичность│            │
└────────────────────┴──────────────────────┴────────────┘
     Таблица 2-3. Арифметические операторы.
     Все операторы могут быть использованы как бинарные, т.е. сто-
ящие между двумя операндами арифметического выражения. Плюс (+) и
минус (-) могут быть также унарными и предшествовать какому-либо
одиночному оператору.
     Операции равного приоритета, за исключением возведения в
степень выполняются слева направо. Возведение в степень выполняется
справа налево. Поэтому каждое из следующих выражений слева экви-
валентно выражению справа :
     A/B * C                (A/B) * C
     A * * B * * C          A * * (B * * C)
     Арифметические выражения могут быть получены обычным матема-
тическим образом, как в большенстве языках программирования. Однако
Фортран заприщает ставить два оператора подряд. Например, нельзя:
     A * * - B
но можно
     A * * (- B)
Унарный минус имеет наименьший приоритет. Поэтому выражение -А**В
понимается как - (А ** В).
     Вы можете использовать скобки для группирования оераций и
задания порядка, в котором операции должны выполняться.

5.2. Деление целых.

     Результатом деления двух целых чисел является величина, равная
математическому частному двух этих величин, округленного до целого
в сторону нуля. Поэтому 7/3 превращается в 2, а (-7)/3 превращается
в -2. Как 9/10, так и 9/(-10) равны нулю.



5.3. Преобразования типов арифметических операндов.

     Когда в арифметическом выражении все операнды одного типа,
то величина, являющаяся результатом этого выражения, этого же типа.
Когда операнды разного типа, типом результата выражения является
тип операнда максимального ранга.
     Ранг операнда зависит от его типа данных соответсвенно сле-
дующему списку :
     1. INTEGER * 2 (низший ранг)
     2. INTEGER * 4
     3. REAL * 4
     4. REAL * 8
     5. COMPLEX * 8
     6. COMPLEX * 16 (высший ранг)
Например, результатом операции над элементами INTEGER*2 и REAL*4
будет величина, относящаяся к типу данных REAL*4.
     Специальный случай : операция над операндами типов REAL*8 и
COMPLEX*8 породит COMPLEX*16, а не COMPLEX*8.
     Тип данных всего выражения - это тип данных результата
последней операции, выполненной при вычислении всего выражения.
     Типы данных операций могут быть INTEGER*2, INTEGER*4, REAL*4,
REAL*8, COMPLEX*8 или COMPLEX*16.
     Целые операции выполняются только над целыми операндами.
Дробный результат от деления в целой арифметике превращается в
целое, а не округляется. Поэтому следующие выражение равно нулю,
а не единице :
     1/4 + 1/4 + 1/4 + 1/4
Распределение памяти для типа INTEGER без указания длины *2 или
*4 в определении типа зависит от использования метакоманды $STORAGE
(для подробностей смотрите раньше в этой части и части 6 "Мета-
команды МС-Фортрана").
     Действительные операции выполняются только над действительными
операндами или комбинацией действительного и целого операндов.
Целые операнды сначала преобразуются в действительные прибавлением
к каждому дробной части равной нулю. Затем для вычисления выражения
используется действительная арифметика. Но в следующем операторе
сначало осуществляется целое деление I на J, а потом действительное
 умножение результата на X :
     Y = (I/J) * X

5.4. Символьные выражения.

     Результатом символьных выражений является тип CHARACTER. Формы
символьных выражений следующие :
     1. Символьные константы.
     2. Ссылки на символьные переменные.
     3. Ссылки на элементы символьных массивов.
     4. Любые символьные выражения, заключенные в скобки.
     5. Ссылки на символьные функции.
     В символьных выражениях нет операторов.

5.5. Выражения отношения.

     Выражения отношения сравнивают величины двух арифметических
или двух символьных выражений. Арифметическое выражение нельзя
сравнивать с символьным, пока не определена метакоманда $NOTSTRICT.
В этом случае арифметические выражения сравнимы с символьными.
Результатом выражения отношения является тип LOGICAL. Для сравнеия
величин в выражениях отношения можно использовать любой оператор,
указанный в таблице 2-4.



┌───────────────────────────┬────────────────────────────┐
│        Оператор           │             Операция       │
├───────────────────────────┼────────────────────────────┤
│        .LT.               │   Меньше чем               │
│        .LE.               │   Меньше или равно         │
│        .EQ.               │   Равно                    │
│        .NE.               │   Не равно                 │
│        .GT.               │   Больше чем               │
│        .GE.               │   Больше или равно         │
└───────────────────────────┴────────────────────────────┘
     Таблица 2-4. Операторы отношения.

     Все операторы отношения бинарные и появляются между двумя
операндами. Среди операторов отношения нет относительного стар-
шинства или сочетательности и поэтому выражение следующего вида
нарушает правила типов для операндов :
     A .LT. B .NE. C
Выражения отношения могут появляться только в логических выраже-
ниях.
     Выражения отношения с арифметическими операндами могут иметь
один операнд типа INTEGER и один операнд типа REAL. В этом случае
перед вычислением выражения отношения целый операнд будет преоб-
разован в тип REAL.
     Выражения отношения символьных операндов сравнивают положение
этих операндов в упорядоченной последовательности ASCII. Операнд
является меньше чем другой, если он появляется раньше в упорядо-
ченной последовательности. Если сравниваются операнды разной длины,
то более короткий рассматривается как доплненный справа пробелами
до такой же длины как и длинный.

5.6. Логические выражения.

     Результатом логического выражения является величина типа
LOGICAL. Простейшие формы логических выражений следующие :
     1. Логические константы.
     2. Ссылки на логические переменные.
     3. Ссылки на элементы логических массивов.
     4. Ссылки на логические функции.
     5. Выражения отношения.
Другие логические выражения состоят из простейших логических форм,
приведенных выше, с использованием скобок и логических операторов,
указанных в таблице 2-5.



┌───────────┬─────────────────────────────┬──────────────┐
│  Оператор │           Операция          │     Приоритет│
├───────────┼─────────────────────────────┼──────────────┤
│  .NOT.    │  Отрицание                  │  Наивысший   │
│  .AND.    │  Конъюнкция                 │  Средний     │
│  .OR.     │  Включающая дизъюнкция      │  Средний     │
│  .EQV.    │  Эквивалентность            │  Низший      │
│  .NEQV.   │  Неэквивалентность          │  Низший      │
└───────────┴─────────────────────────────┴──────────────┘
     Таблица 2-5. Логические операторы.



     Операторы .AND., .OR., .EQV., .NEQV. не являются бинарными и
появляются между двумя операндами логических выражений. Оператор
.NOT. - унарный и предшествует своему операнду.
     Операции равного приоритета выполняются слева направо, поэ-
тому, например,
     A .AND. B .AND. C
Эквивалентно :
     (A .AND. B) .AND. C
Пример правила приоритета :
     .NOT. A .OR. B .AND. C
выполняется как :
     (.NOT. A) .OR. (B .AND. C)
Два .NOT. не могут соседствовать с друг другом, хотя
     A .AND. .NOT. B
- это пример допустимого выражения с двумя операторами подряд.
     Другой пример правила приоритетов и использования
     .EQV. и .NEQV. :
     .NOT. A . EQV. B .OR. C .NEQV. D .AND. E
может быть выполнено как
     ((.NOT. A) .EQV. (B .OR. C)) .NEQV. (D .AND. E)
Логические операторы имеют тоже самое значение, что и в стандартной
математической симантике с неразделительным .OR.. Например:
     .TRVE. .OR. .TRVE.
даст величину
     .TRVE.

5.7. Приоритеты операторов.

     Когда в одном выражении встречаются арифметические, логические
операторы и операторы отношения, они выполняются со следующими
приоритетами :
     1. Логические (низший).
     2. Отношения (средний).
     3. Арифметические (высший).

5.8. Правила вычисления выражений.

     Любая переменная, массив, элемент или функция, на которые
ссылаются в выражении, должны быть определены до момента ссылки.
Целые переменные должны быть определены арифметической величиной,
не величиной метки оператора, устанавливаемой оператором ASSIGN.
     Определенные арифметические операции, также как деление на
нуль, математически неопределенные, запрещены. К другим запрещенным
операциям относятся возведение нулевого операнда в нулевую или
отрицательную степень и возведение отрицательного операнда в
степень типа REAL.




5.9. Ссылки на элемент массива.

     Ссылка на элемент массива определяет один элемент массива.
Ее синтаксис следующий :
─────────────────────────────────────────────────────────
     массив ( индекс [, индекс ] . . . )
─────────────────────────────────────────────────────────
Где
массив    это имя массива
индекс    это индексное выражение, являющиеся целым выражением
          для выбора заданного элемента массива. Число индексных
          выражений должно соответствовать числу размерностей в
          описании массива. Величина индексного выражения должна
          находится между единицей и верхней границей для соответ-
          ствующей ей размерности включительно.

С Пример операторов размерности
     DIMENSION A(3,2), B(3,4), C(4,5), D(5,6), V(10)
     EQVIVALENCE (X, V(1)), (Y, V(2))
     D(i,j) = D(i,j)/PIVOT
     C(i,j) = C(I,J) + A(i,k) * B(k,j)
     READ (*,*) (V(N), N = 1, 10)


