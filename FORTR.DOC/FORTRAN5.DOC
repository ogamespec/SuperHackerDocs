




              ПРОГРАММЫ, ПОДПРОГРАММЫ И ФУНКЦИИ.








     ОБ ЭТОЙ ЧАСТИ.

     Эта часть расширяет описание операторов PROGRAM, SUBROUTINE,
FUNCTION и функции-оператора, приведенное в части 3. В ней приво-
дится информация о типах функций и взаимодействии формальных и
фактических параметров при вызове функции или подпрограммы.



     Содержание.



1.ОСНОВНАЯ ПРОГРАММА.  . . . . . . . . . . . . . . . . . . .  5-1

2.ПОДПРОГРАММЫ.  . . . . . . . . . . . . . . . . . . . . . .  5-1

3.ФУНКЦИИ. . . . . . . . . . . . . . . . . . . . . . . . . .  5-1

3.1.Внешние функции. . . . . . . . . . . . . . . . . . . . .  5-2

3.2.Встроенные функции.  . . . . . . . . . . . . . . . . . .  5-2

3.3.Функции-операторы. . . . . . . . . . . . . . . . . . . .  5-8

4.ПАРАМЕТРЫ. . . . . . . . . . . . . . . . . . . . . . . . .  5-8

5.ПЕРЕДАЧА ЦЕЛЫХ ПАРАМЕТРОВ. . . . . . . . . . . . . . . . .  5-9



 1.ОСНОВНАЯ ПРОГРАММА.

     Основная программа - это любая программная единица, у которой
первый оператор - это не FUNCTION,SUBROUTINE или BLOCK DATA. Первым
оператором основной программы может быть оператор PROGRAM. Если у
основной программы нет оператора PROGRAM, ей будет присвоено имя
MAIN. Имя MAIN тогда не может быть использовано как имя любого
другого глобального объекта.
     Выполнение программы всегда начинается с первого выполняемого
оператора основной программы. Соответственно, в каждой выполняемой
программе должна быть только одна основная программа.
     Для дополнительной информации о программах и операторе PROGRAM
смотрите часть 3 "Операторы".


2.ПОДПРОГРАММЫ.

     Подпрограмма - это программная единица, которая может быть
вызвана из другой программной единицы c помощью оператора CALL.
Будучи вызванной, подпрограмма производит набор действий,
определенных ее выполняемыми операторами, и затем возвращает управ-
ление на оператор, следующий непосредственно за вызвавшим ее
оператором, или на оператор, определенный как переменный возврат
(смотрите оператор CALL в части 3).
     Подпрограмма не возвращает величину прямо, хотя величины могут
быть возвращены в вызывающую программную единицу через параметры
и COMMON-блоки.
     Для более подробной информации о подпрограммах смотрите часть
3 "Операторы".

3.ФУНКЦИИ.

     На функцию ссылаются в выражении, и она возвращает величину,
которая используется при вычислении этого выражения. Существует
три вида функций:
          1. Внешние функции
          2. Встроенные функции
          3. Функции-операторы.
     Каждый из них описан более подробно в дальнейших параграфах.
     Ссылка на функцию может появиться в арифметическом или логи-
ческом выражении. Когда выполняется ссылка на функцию, функция
вызывается, а величина результата используется как операнд в вы-
ражении, которое содержит ссылку на функцию. Форма ссылки на фун-
кцию следующая:
────────────────────────────────────────────────
 имя-функции ([пар[,пар]...])
────────────────────────────────────────────────
     имя-функции - это определенное пользователем имя внешней или
                   встроеной функции или функции-оператора.
         пар     - это фактический параметр.
     Правила для параметров функций аналогичны правилам для под-
программ (за исключением переменного возврата, который недопустим)
и приведены в описании оператора CALL в части 3. Некоторые допол-
нительные ограничения, применимые для функций-операторов и встро-
еных функций, описаны ниже в этой части.




3.1.Внешние функции.

     Внешняя функция определена программной единицей функции. Она
начинается оператором FUNCTION и заканчивается оператором END.
Она может содержать любые виды операторов, кроме PROGRAM, FUNCTION,
SUBROUTINE или BLOCK DATA.

3.2.Встроенные функции.

     Встроенные функции определены в языке МС-Фортран и доступны
для использования в программе на МС-Фортране. В таблице 5-1 при-
ведены имена, назначения, типы параметров и типы функций для всех
встроенных функций, допустимых в МС-Фортране, с дополнительными
примечаниями после таблицы.
     Оператор IMPLICIT не может изменять тип встроенной функции.
Для этих встроенных функций, которые допускают различные типы па-
раметров, при одном обращении все параметры должны быть одного и
того же типа.
     Имя встроенной функции может появиться в операторе INTRINSIC.
Имя встроенной функции может также появиться в операторе описания
типа, но только если тип тот же самый, что и стандартный тип этой
встроенной функции.
     Параметры некоторых встроенных функций ограничены назначением
этих функций. Например, логарифм отрицательного числа математически
не определен и поэтому недопустим.
     Многие встроенные функции имеют общие имена, что позволяет
ссылаться на функцию без уточнения типа параметров при ссылке.
Когда ссылаются на общее имя компилятор выбирает соответствующую
относительно специфическую функцию в зависимости от типа парамет-
ра(ов) в ссылке на функцию.
     Например, функция INT - это общее имя шести чуть отличающихся
функций: одна с собственным именем, совпадающим с основным, три с
особыми именами (IFIX,IDINT,ICHAR) и две - безымянных (для типов
данных COMPLEX*8 и COMPLEX*16).
     Все углы в таблице 5-1 выражены в радианах. Все параметры в
ссылке на встроенную функцию должны быть того же типа. Х и У -
действительные, Z - комплексное, I и J - целые, а С,С1 и С2 - сим-
вольные величины. Числа в квадратных скобках в колонке 1 ссылаются
на примечания после таблицы.
     В дальнейшем REAL эквивалентно REAL*4, DOUBLE PRECISION -
REAL*8, a COMPLEX - COMPLEX*8. Если в указанном типе параметра -
INTEGER, то тип может быть INTEGER*2 или INTEGER*4. Если указанный
тип функции - INTEGER, тип будет целый по умолчанию определенный
метакомандой $STORAGE. (Для более полной информации смотрите часть 6).


╔════════════╦═══════════════════════╦══════════╦═════════╗
║    ИМЯ     ║       НАЗНАЧЕНИЕ      ║ТИП ПАРАМ.║ТИП Ф    ║
╠════════════╩═══════════════════════╩══════════╩═════════╣
║ Преобразование типов                                    ║
║ INT(общее) ║ преобразует в INTEGER ║   любой  ║INTEGER  ║
║ INT2(X)    ║ преобразует в INTEGER*║   любой  ║INTEGER* ║
║ INT4(X)    ║ преобразует в INTEGER*║   любой  ║INTEGER* ║
║ INT(X) [1] ║ преобразует в INTEGER ║   REAL*4 ║INTEGER  ║
║ IFIX(X)    ║ преобразует в INTEGER ║   REAL*4 ║INTEGER  ║
║ IDINT(X)   ║ преобразует в INTEGER ║   REAL*8 ║INTEGER  ║
║ ICHAR(C)[S]║ преобразует в INTEGER ║ CHARACTER║INTEGER  ║
║ REAL(общее)║ преобразует в REAL*4  ║   любой  ║REAL*4   ║
║ REAL(X) [2]║ преобразует в REAL*4  ║  INTEGER ║REAL*4   ║
║            ║                       ║   REAL*4 ║REAL*4   ║
║ DREAL(Z)   ║ преобразует COMPLEX*16║COMPLEX*16║  REAL*8 ║
║            ║ в REAL*8              ║          ║         ║
║ FLOAT(I)   ║ преобразует в REAL*4  ║  INTEGER ║  REAL*4 ║
║ CHAR(X)    ║ преобразует в символ. ║  INTEGER ║CHARACTER║
║ SNGL(X)    ║ преобразует в REAL*4  ║   REAL*8 ║  REAL*4 ║
║ DBLE(общее)║ преобразует в REAL*8  ║    любой ║  REAL*8 ║
║ CMPLX(Z[,Y]║ преобразует в COMPLEX*║    любой ║COMPLEX*8║
║         [4]║                       ║          ║         ║
║ DCMPLX(Z[,Y║ преобразует в COMPLEX*║    любой ║COMPLEX*1║
║                                                         ║
║ Взятие целой части                                      ║
║ AINT(общее)║ целая часть от REAL   ║   REAL*4 ║  REAL*4 ║
║ AINT(X)    ║ целая часть от REAL*4 ║   REAL*8 ║  REAL*8 ║
║            ║                       ║   REAL*4 ║  REAL*4 ║
║ DINT(X)    ║ целая часть от REAL*8 ║   REAL*8 ║  REAL*8 ║
║                                                         ║
║ Округление                                              ║
║ ANINT(общее║ округление REAL       ║   REAL*4 ║  REAL*8 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║ ANINT(X)   ║ округление REAL*4     ║   REAL*4 ║  REAL*4 ║
║ DNINT(X)   ║ округление REAL*8     ║   REAL*8 ║  REAL*8 ║
║                                                         ║
║ Округление в целое                                      ║
║ NINT(общее)║ округление с переводом║   REAL*4 ║ INTEGER ║
║            ║ в целое               ║   REAL*8 ║ INTEGER ║
║ NINT(X)    ║ округление с переводом║   REAL*4 ║ INTEGER ║
║            ║ в целое               ║          ║         ║
║ IDNINT(X)  ║ округление с переводом║   REAL*8 ║ INTEGER ║
║            ║ в целое               ║          ║         ║
║                                                         ║
║ Абсолютная величина                                     ║
║ ABS(общее) ║ абсолютная величина   ║    любой ║   любой ║
║ IABS(I)    ║ абсолютное целое      ║  INTEGER ║ INTEGER ║
║ ABS (X)    ║ абсолютное REAL*4     ║   REAL*4 ║ REAL*4  ║
║ DABS(X)    ║ абсолютное REAL*8     ║   REAL*8 ║ REAL*8  ║
║ CABS(Z)    ║ абсолютное COMPLEX    ║ COMPLEX*8║ REAL*4  ║
║            ║                       ║ COMPLEX*1║ REAL*8  ║
║ CDABC(Z)   ║ абсолютное COMPLEX*16 ║ COMPLEX*1║ REAL*8  ║
║                                                         ║
║ Взятие остатка                                          ║
║ MOD(общее) ║ остаток               ║  INTEGER ║INTEGER  ║
║            ║                       ║   REAL*4 ║ REAL*4  ║
║ MOD(I,Y)   ║ целый остаток         ║  INTEGER ║ INTEGER ║
║ AMOD(X,Y)  ║ остаток REAL*4        ║   REAL*4 ║ REAL*4  ║
║ DMOD(X,Y)  ║ остаток REAL*8        ║   REAL*8 ║ REAL*8  ║
-----------------------------------------------------------

___________________________________________________________
║                                                         ║
║ Передача знака                                          ║
║ SIGN(общее)║ передача знака        ║  INTEGER ║ INTEGER ║
║            ║                       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ ISIGN(I,Y) ║ передача знака целого ║  INTEGER ║ INTEGER ║
║ SIGN(X,Y)  ║ передача знака REAL*4 ║   REAL*4 ║ REAL*4  ║
║ DSIGN(X,Y) ║ передача знака REAL*8 ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Положительная разность [6]                              ║
║ DIM(общее) ║ положительная разность║  INTEGER ║ INTEGER ║
║            ║                       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ IDIM(I,Y)  ║ разность целых        ║  INTEGER ║ INTEGER ║
║ DIM(X,Y)   ║ разность REAL*4       ║   REAL*4 ║ REAL*4  ║
║ DDIM(X,Y)  ║ разность REAL*8       ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Поиск наибольшей величины                               ║
║ MAX(общее) ║ максимум              ║  INTEGER ║ INTEGER ║
║            ║                       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ MAX0(I,Y..)║ целый максимум        ║  INTEGER ║ INTEGER ║
║ AMAX1(X,Y.)║ максимум REAL*4       ║   REAL*4 ║ REAL*4  ║
║ AMAX0(I,Y.)║ максимум REAL*4       ║  INTEGER ║ REAL*4  ║
║ MAX1(X,Y..)║ целый максимум        ║   REAL*4 ║ INTEGER ║
║ DMAX1(X,Y.)║ максимум REAL*8       ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Поиск наименьшей величины                               ║
║ MIN(общее) ║ минимум               ║  INTEGER ║ INTEGER ║
║            ║                       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ MIN0(I,Y..)║ целый минимум         ║  INTEGER ║ INTEGER ║
║ AMIN1(X,Y.)║ минимум REAL*4        ║   REAL*4 ║ REAL*4  ║
║ AMIN0(I,Y.)║ минимум REAL*4        ║  INTEGER ║ REAL*4  ║
║ MIN1(X,Y..)║ целый минимум         ║   REAL*4 ║ INTEGER ║
║ DMIN1(X,Y.)║ минимум REAL*8        ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Перевод в REAL*8                                        ║
║ DPROD(X,Y) ║ перевод в REAL*8      ║   REAL*4 ║ REAL*4  ║
║                                                         ║
║ Мнимая часть комплексного числа                         ║
║ AIMAG(Z)   ║ выделяет мнимую часть ║ COMPLEX*8║ REAL*4  ║
║            ║ заданной пары в REAL*4║          ║         ║
║ DIMAG(Z)   ║ выделяет мнимую часть ║COMPLEX*16║ REAL*8  ║
║            ║ заданной пары в REAL*8║          ║         ║
║                                                         ║
║ Сопряжение комплексного числа                           ║
║ CONYG(Z)   ║ сопряжение COMPLEX*8  ║COMPLEX*8 ║COMPLEX*8║
║ DCONYG(Z)  ║ сопряжение COMPLEX*16 ║COMPLEX*16║COMPLEX*1║
-----------------------------------------------------------



___________________________________________________________
║ Квадратный корень                                       ║
║ SQRT(общее)║ квадратный корень     ║   REAL*4 ║  REAL*4 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║            ║                       ║COMPLEX*8 ║COMPLEX*8║
║            ║                       ║COMPLEX*16║COMPLEX*1║
║ SQRT(X)    ║ квадратный корень REAL║   REAL*4 ║  REAL*4 ║
║ DSQRT(X)   ║ квадратный корень REAL║   REAL*8 ║  REAL*8 ║
║ CSQRT(Z)   ║ квадратный корень     ║ COMPLEX*8║COMPLEX*8║
║            ║ COMPLEX*8             ║          ║         ║
║ CDSQRT(Z)  ║ квадратный корень     ║COMPLEX*16║COMPLEX*1║
║            ║ COMPLEX*16            ║          ║         ║
╚════════════╩═══════════════════════╩══════════╩═════════╝
╔════════════╦═══════════════════════╦══════════╦═════════╗
║    ИМЯ     ║       НАЗНАЧЕНИЕ      ║ТИП ПАРАМ.║ТИП Ф    ║
╠════════════╩═══════════════════════╩══════════╩═════════╣
║ Экспонента                                              ║
║ EXP(общее) ║ экспонента            ║   REAL*4 ║  REAL*4 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║            ║                       ║ COMPLEX*8║COMPLEX*8║
║            ║                       ║COMPLEX*16║COMPLEX*1║
║ EXP(X)     ║ REAL*4 e в степени    ║   REAL*4 ║  REAL*4 ║
║ DEXP(X)    ║ REAL*8 e в степени    ║   REAL*8 ║  REAL*8 ║
║ CEXP(Z)    ║ COMPLEX*8 e в степени ║ COMPLEX*8║COMPLEX*8║
║ CDEXP(Z)   ║ COMPLEX*16 e в степени║COMPLEX*16║COMPLEX*1║
║                                                         ║
║ Натуральный логарифм                                    ║
║ LOG(общее) ║ натуральный логарифм  ║   REAL*4 ║  REAL*4 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║            ║                       ║ COMPLEX*8║COMPLEX*8║
║            ║                       ║ COMPLEX*1║COMPLEX*1║
║ ALOG(X)    ║ нат. логарифм REAL*4  ║   REAL*4 ║  REAL*4 ║
║ DLOG(X)    ║ нат. логарифм REAL*8  ║   REAL*8 ║  REAL*8 ║
║ CLOG(Z)    ║ нат. логарифм COMPLEX*║ COMPLEX*8║COMPLEX*8║
║ DLOG(Z)    ║ нат. логарифм COMPLEX*║COMPLEX*16║COMPLEX*1║
║                                                         ║
║ Десятичный логарифм                                     ║
║LOG10(общее)║ десятичный логарифм   ║   REAL*4 ║  REAL*4 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║ ALOG10(X)  ║ дес. логарифм REAL*4  ║   REAL*4 ║  REAL*4 ║
║ DLOG10(X)  ║ дес. логарифм REAL*8  ║   REAL*8 ║  REAL*8 ║
║                                                         ║
║ Синус                                                   ║
║ SIN(общее) ║ функция синус         ║   REAL*4 ║  REAL*4 ║
║            ║                       ║   REAL*8 ║  REAL*8 ║
║            ║                       ║ COMPLEX*8║COMPLEX*8║
║            ║                       ║COMPLEX*16║COMPLEX*1║
║ SIN(X)     ║ REAL*4 синус          ║   REAL*4 ║  REAL*4 ║
║ DSIN(X)    ║ REAL*8 синус          ║   REAL*8 ║  REAL*8 ║
║ CSIN(Z)    ║ COMPLEX*8 синус       ║ COMPLEX*8║COMPLEX*8║
║ CDSIN(Z)   ║ COMPLEX*16 синус      ║COMPLEX*16║COMPLEX*1║
-----------------------------------------------------------


___________________________________________________________
║ Косинус                                                 ║
║ COS(общее) ║ функция косинус       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║            ║                       ║ COMPLEX*8║COMPLEX*8║
║            ║                       ║COMPLEX*16║COMPLEX*1║
║ COS(X)     ║ REAL*4 косинус        ║   REAL*4 ║ REAL*4  ║
║ DCOS(X)    ║ REAL*8 косинус        ║   REAL*8 ║ REAL*8  ║
║ CCOS(Z)    ║ COMPLEX*8 косинус     ║ COMPLEX*8║COMPLEX*8║
║ CDCOS(Z)   ║ COMPLEX*16 косинус    ║COMPLEX*16║COMPLEX*1║
║                                                         ║
║ Тангенс                                                 ║
║ TAN(общее) ║ функция тангенс       ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ TAW(X)     ║ REAL*4 тангенс        ║   REAL*4 ║ REAL*4  ║
║ DTAN(X)    ║ REAL*8 тангенс        ║   REAL*8 ║ REAL*8  ║
╚════════════╩═══════════════════════╩══════════╩═════════╝



╔════════════╦═══════════════════════╦══════════╦═════════╗
║    ИМЯ     ║       НАЗНАЧЕНИЕ      ║ТИП ПАРАМ.║ТИП Ф    ║
╠════════════╩═══════════════════════╩══════════╩═════════╣
║ Арксинус                                                ║
║ ASIN(общее)║ функция арксинус      ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ ASIN(X)    ║ REAL*4 арксинус       ║   REAL*4 ║ REAL*4  ║
║ DASIN(X)   ║ REAL*8 арксинус       ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Арккосинус                                              ║
║ ACOS(общее)║ функция арккосинус    ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ ACOS(X)    ║ REAL*4 арккосинус     ║   REAL*4 ║ REAL*4  ║
║ DACOS(X)   ║ REAL*8 арккосинус     ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Арктангенс                                              ║
║ ATAN(общее)║ функция арктангенс    ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ ATAN(X)    ║ REAL*4 арктангенс     ║   REAL*4 ║ REAL*4  ║
║ DATAW(X)   ║ REAL*8 арктангенс     ║   REAL*8 ║ REAL*8  ║
║ ATAN2(X,Y) ║ REAL*4 арктангенс х/y ║   REAL*4 ║ REAL*4  ║
║ DATAN2(X,Y)║ REAL*8 арктангенс x/y ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Гиперболический синус                                   ║
║ SINH(общее)║ гиперболический синус ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ SINH(X)    ║ REAL*4 гиперб. синус  ║   REAL*4 ║ REAL*4  ║
║ DSINH(X)   ║ REAL*8 гиперб. синус  ║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Гиперболический косинус                                 ║
║ COSH(общее)║ гиперболич. косинус   ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ COSH(X)    ║ REAL*4 гиперб. косинус║   REAL*4 ║ REAL*4  ║
║ DCOSH(X)   ║ REAL*8 гиперб. косинус║   REAL*8 ║ REAL*8  ║
-----------------------------------------------------------


___________________________________________________________
║ Гиперболический тангенс                                 ║
║ TANH(общее)║ гиперболич. тангенс   ║   REAL*4 ║ REAL*4  ║
║            ║                       ║   REAL*8 ║ REAL*8  ║
║ TANH(X)    ║ REAL*4 гиперб. тангенс║   REAL*4 ║ REAL*4  ║
║ DTANH(X)   ║ REAL*8 гиперб. тангенс║   REAL*8 ║ REAL*8  ║
║                                                         ║
║ Лексически больше или равно [7]                         ║
║ LGE(C1,C2) ║ первый параметр больше║ CHARACTER║ LOGICAL ║
║            ║ или равен второму     ║          ║         ║
║                                                         ║
║ Лексически больше [7]                                   ║
║ LGT(C1,C2) ║ первый параметр больше║ CHARACTER║ LOGICAL ║
║            ║ второго               ║          ║         ║
║                                                         ║
║ Лексически меньше или равно [7]                         ║
║ LLT(C1,C2) ║ первый параметр меньше║ CHARACTER║ LOGICAL ║
║            ║ или равен второму     ║          ║         ║
║                                                         ║
║ Лексически меньше [7]                                   ║
║ LLT(C1,C2) ║ первый параметр меньше║ CHARACTER║ LOGICAL ║
║            ║ второго               ║          ║         ║
╚════════════╩═══════════════════════╩══════════╩═════════╝

╔════════════╦═══════════════════════╦══════════╦═════════╗
║    ИМЯ     ║       НАЗНАЧЕНИЕ      ║ТИП ПАРАМ.║ТИП Ф    ║
╠════════════╩═══════════════════════╩══════════╩═════════╣
║ Конец файла [8]                                         ║
║ EOF(I)     ║ целый конец файла     ║  INTEGER ║ LOGICAL ║
╚════════════╩═══════════════════════╩══════════╩═════════╝
    Таблица 5-1. Встроенные функции.

     Примечания к таблице 5-1:
1.    Для Х типа INTEGER INT(X)=X. Для Х типа REAL или REAL*8, если
     Х - неотрицательно, то INT(X) - наибольшее целое, не превы-
     шающее Х; а если Х - отрицательно, то INT(X) - наибольшее
     отрицательное  целое не меньшее чем Х. Для Х типа REAL IFIX(X)
     то же самое, что INT(X).
2.   Для Х типа REAL REAL*(X)=X. Для Х типа INTEGER или  REAL*8
     REAL(X) это значащая часть наибольшей точности Х, которую
     может содержать данный тип REAL. Для Х типа INTEGER FLOAT(X) -
      то же самое, что REAL(X).
3.   Для Х типа REAL*8 DBLE(X)=X. Для Х типа INTEGER или REAL
     DBLE(X) - это значащая часть наибольшей точности Х, которую
     может содержать тип данных двойной точности.
4.   COMPLEX и DCMPLX могут иметь один или два параметра.  Если ис-
     пользован один параметр, он может быть типа
     INTEGER, REAL, DOUBLE PRECISION, COMPLEX или DOUBLE PRECISION
     COMPLEX. Если использованы два параметра, то они должны быть
     одного и того же типа и при этом допустимы типы INTEGER, REAL
     или DOUBLE PRECISION.
     При Z=COMPLEX*8, COMPLEX(Z)=Z. Для Z=INTEGER, REAL и REAL*8
     COMPLEX(Z)=комплексной величине, действительная часть которой
     REAL(Z), а мнимая часть равна нулю.
     COMPLEX(X,Y)= комплексной величине, действительная часть ко-
     торой - REAL(X), а мнимая - REAL(Y).



     При Z=COMPLEX*16, DCMPLX(Z)=Z. Для Z=INTEGER, REAL и REAL*8
     DCMPL(Z)=комплексной величине, у которой действительная часть
     - REAL*8, а мнимая равна нулю. Для Z=COMPLEX*8 DCMPLX(Z) имеет
     действительную часть равной DBLE(Z), а мнимую равной
     DBLE(AIMAG(Z)).
     DCMPLX(X,Y)=комплексной величине, у которой действительная
     часть - REAL*8(X), а мнимая - REAL*8(Y).
5.   ICHAR преобразует символьную величину в целую. Целая величина
     символа - это внутреннее представление символа в коде ASCII,
     лежащее в диапазоне от 0 до 255.
     Для любых двух символов С1 и С2 (С1.LE.C2) будет .TRUE. тогда
     и только тогда если (ICHAR(C1).LE.ICHAR(C2)) есть .TRUE.
     Функция CHAR(I) возвращает 1-й символ таблиц ASCII. Это ве-
     личина типа CHARACTER длиной один символ, при этом I должно
     быть целым выражением, величина которого принадлежит диапазону
     0єiє255.
     ICHAR(CHAR(I))=I для 0єIє255
     CHAR(ICHAR(C))=C для любого С из набора ASCII
6.   DIM(X,Y) - это Х-Y, если X>Y, или нуль в противном случае.
7.   LGE(X,Y) возвращает .TRUE. если Х=Y или если Х следует за Y
     в таблице кодов ASCII; иначе возвращается .FALSE.
     LGT(X,Y) возвращает .TRUE. если Х следует за Y в таблице кодов
     ASCII; иначе возвращается .FALSE.
     LLE(X,Y) возвращает .TRUE. если X=Y или если Х предшевствует
     Y в таблице ASCII; иначе возвращается .FALSE.
     LLT(X,Y) возвращает .TRUE. если Х предшевствует Y в таблице
     ASCII; иначе возвращается .FALSE.
     Если у операндов неравная длина, то более короткий дополняется
     справа пробелами.
8.   EOF(X) возвращает .TRUE. если устройство, определенное этим
     параметром находится на или после записи конец-файла; иначе
     возвращается .FALSE. Величина Х должна соответствовать откры-
     тому файлу или нулю, что соответствует экрану или клавиатуре.

3.3.Функции-операторы.

     Функция-оператор определена единственным оператором и по виду
подобна оператору присваивания. Функция-оператор может появиться
только после операторов описания и перед любыми выполняемыми опера-
торами в программной единице.
     Функция-оператор не является выполняемым оператором, так как
она не выполняется, как стоящая первой в конкретной программной
единице. Однако, тело функции-оператора используется для определе-
ния значения функции-оператора. Она выполняется, как и любая другая
функция при вычислении ссылки на функцию в выражении.
     Для информации о синтаксисе и использовании функции-оператора
смотрите часть 3 "Операторы".



4.ПАРАМЕТРЫ.

     Формальный параметр - это имя, с помощью которого параметр
передается функции или подпрограмме; фактический параметр - это
указанная переменная, выражение, массив и т.д., передаваемый
процедуре при конкретном ее вызове. Взаимодействие между формаль-
ными и фактическими параметрами в функции или подпрограмме детально
раскрывается ниже.
     Параметры передают величины и берут их из процедуры ссылочным
образом. Число действительных параметров должно совпадать с числом
формальных параметров и при этом их типы должны быть согласованы.
     На входе в подпрограмму или функцию фактические параметры
связываются с формальными, во многом подобно тому как оператор
EQUIVALENCE связывает два или более массива или переменные, а
оператор COMMON в двух или нескольких программных единицах связы-
вает списки переменных. Эта связь действует, пока не закончилось
выполнение подпрограммы или функции. Поэтому присвоение величины
формальному параметру во время выполнения подпрограммы или функции
может изменить величину соответствующего фактического параметра.
     Если фактический параметр - константа, ссылка на функцию или
выражение, а не простая переменная, то присвоение величины соот-
ветствующему формальному параметру недопустимо и может вызвать
непредсказуемые последствия. В частности, присвоение величины фор-
мальному параметру типа CHARACTER, когда фактический параметр -
литерал, может вызвать ненормальное поведение.
     Если фактический параметр - выражение, то оно вычисляется
немедленно, еще до установления связи формальных и фактических
параметров. Если фактический параметр - элемент массива, его ин-
дексные выражения вычисляются тоже до установления связи и остаются
постоянными во время выполнения процедуры, даже если они содержат
переменные, которые переопределяются во время выполнения процедуры.
     Формальный параметр, описанный как переменная, может быть
связан с фактическим параметром - переменной, элементом массива,
выражением. Формальный параметр, описанный как переменный возврат
(*) может быть связан с определителем переменного возврата (*n) в
операторе CALL и является повторяемым.
     Формальный параметр, описанный как массив, может быть связан
с фактическим параметром, являющимся массивом или элементом мас-
сива. Число и размер размерностей формального параметра могут быть
отличны от этих характеристик фактического параметра, но любая
ссылка на формальный массив должна быть в пределах памяти, отве-
денной под фактический массив. Когда ссылка на элемент выходит за
границы, это не фиксируется как ошибка при исполнение программы
на МС-Фортране и результат непредсказуем.
     Формальный параметр может быть также связан с внешней подпрог-
рвммой, функцией или встроенной функцией, если он используется в
теле процедуры как ссылка на подпрограмму или функцию или он по-
является в операторе EXTERNAL.
     Соответствующий фактический параметр должен быть внешней под-
программой или функцией, объявленной в операторе EXTERNAL или
встроенной функцией, которую допускается связывать с формальным
параметром процедуры. Встроенные функции должны быть объявлены в
операторе INTRISIC в программной единице, где они используются как
фактические параметры.
     Все встроенные функции, за исключением нижеуказанных, могут
быть связаны с формальными параметрами процедуры:
          INT   SNGL     CHAR    MAX0    MIN0
          INT2  REAL     LGE     AMAX1   AMIN1
          INT4  DBLE     LGT     DMAX1   DMIN1
          IFIX  COMPLX   LLE     AMAX0   AMIN0
          IDINT DCMPLX   LLT     MAX1    MIN1
          FLOAT ICHAR    MAX     MIN



5.ПЕРЕДАЧА ЦЕЛЫХ ПАРАМЕТРОВ.

     Переменная INTEGER*2 не может быть передана формальному
параметру INTEGER*4, а переменная INTEGER*4 не может быть передана
формальному параметру INTEGER*2. Передача неверного типа переменной
порождает ошибку компиляции. Вы должны использовать встроенные
функции INT4 и INT2. Также при действии $STORAGE:4 по умолчанию
выражения с параметрами INTEGER*2 будут иметь результат типа
INTEGER*4. Следующая программа:
               SUBROUTINE S(I)
               INTEGER*2 I
               .  .  .
               END
               INTEGER*2 J,K
               CALL S(J+K)
дает ошибку, поэтому J+K - INTEGER*4. Вы должны написать вызов
подпрограммы так
               CALL S(INT2(J+K))
     Компилятор при оптимизации понижает степень точности арифме-
тики, если это не влияет на результат и не установлено $DEBUG.
Например, если не установлено $DEBUG, арифметика в
               INTEGER2 I,J,K
               I=J+K
 - 16-ти разрядная арифметика, даже если определено $STORAGE:4.
Использование $STORAGE:4 не действует на выражения INTEGER*2 при
использовании в нем только операторов +, - или *, поэтому что ре-
зультат их одинаковый как в 16-разрядной, так и в 32-разрядной
арифметике.
     Целые параметры, которые передаются величинами (смотрите
"Атрибуты" в части 7 для определения атрибутов, которые позволяют
передавать параметры величинами), не являются объектами таких же
ограничений. Параметр обрабатывается, как если бы ему была присво-
ена временно переменная соответствующего типа, и временная пере-
менная затем передается как параметр. Правила присвоения для
величин параметров те же самые, что и при присваивании. Вы можете,
например, передать действительную величину целому параметру.


