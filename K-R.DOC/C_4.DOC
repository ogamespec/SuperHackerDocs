                           - 73 -
     
     4. Функции и структура программ.
 
     Функции разбивают большие вычислительные задачи на ма-
 ленькие подзадачи и позволяют использовать в работе то, что
 уже сделано другими, а не начинать каждый раз с пустого мес-
 та. Соответствующие функции часто могут скрывать в себе де-
 тали проводимых в разных частях программы операций, знать
 которые нет необходимости, проясняя тем самым всю программу,
 как целое, и облегчая мучения при внесении изменений.
     Язык "C" разрабатывался со стремлением сделать функции
 эффективными и удобными для использования; "C"-программы
 обычно состоят из большого числа маленьких функций, а не из
 нескольких больших. Программа может размещаться в одном или
 нескольких исходных файлах любым удобным образом; исходные
 файлы могут компилироваться отдельно и загружаться вместе
 наряду со скомпилированными ранее функциями из библиотек. Мы
 здесь не будем вдаваться в детали этого процесса, поскольку
 они зависят от используемой системы.
     Большинство программистов хорошо знакомы с "библиотечны-
 ми" функциями для ввода и вывода /GETCHAR , PUTCHAR/ и для
 численных расчетов /SIN, COS, SQRT/. В этой главе мы сообщим
 больше о написании новых функций.
 
      4.1. Основные сведения.
 
     Для начала давайте разработаем и составим программу пе-
 чати каждой строки ввода, которая содержит определенную ком-
 бинацию символов. /Это - специальный случай утилиты GREP
 системы "UNIX"/. Например, при поиске комбинации "THE" в на-
 боре строк
                                                      
     NOW IS THE TIME
     FOR ALL GOOD
     MEN TO COME TO THE AID
     OF THEIR PARTY
 в качестве выхода получим
 
     NOW IS THE TIME
     MEN TO COME TO THE AID
     OF THEIR PARTY
 
 
 основная схема выполнения задания четко разделяется на три
 части:
 
    WHILE (имеется еще строка)
    IF (строка содержит нужную комбинацию)
          вывод этой строки
           

                           - 74 -
 
     Конечно, возможно запрограммировать все действия в виде
 одной основной процедуры, но лучше использовать естественную
 структуру задачи и представить каждую часть в виде отдельной
 функции. С тремя маленькими кусками легче иметь дело, чем с
 одним большим, потому что отдельные не относящиеся к сущест-
 ву дела детали можно включить в функции и уменьшить возмож-
 ность нежелательных взаимодействий. Кроме того, эти куски
 могут оказаться полезными сами по себе.
 
     "Пока имеется еще строка" - это GETLINE, функция, кото-
 рую мы запрограммировали в главе 1, а "вывод этой строки" -
 это функция PRINTF, которую уже кто-то подготовил для нас.
 Это значит, что нам осталось только написать процедуру для
 определения, содержит ли строка данную комбинацию символов
 или нет. Мы можем решить эту проблему, позаимствовав разра-
 ботку из PL/1: функция INDEX(S,т) возвращает позицию, или
 индекс, строки S, где начинается строка T, и -1, если S не
 содержит т . В качестве начальной позиции мы используем 0, а
 не 1, потому что в языке "C" массивы начинаются с позиции
 нуль. Когда нам в дальнейшем понадобится проверять на совпа-
 дение более сложные конструкции, нам придется заменить толь-
 ко функцию INDEX; остальная часть программы останется той же
 самой.
     После того, как мы потратили столько усилий на разработ-
 ку, написание программы в деталях не представляет затрудне-
 ний. ниже приводится целиком вся программа, так что вы може-
 те видеть, как соединяются вместе отдельные части. Комбина-
 ция символов, по которой производится поиск, выступает пока
 в качестве символьной строки в аргументе функции INDEX, что
 не является самым общим механизмом. Мы скоро вернемся к об-
 суждению вопроса об инициализации символьных массивов и в
 главе 5 покажем, как сделать комбинацию символов параметром,
 которому присваивается значение в ходе выполнения программы.
 Программа также содержит новый вариант функции GETLINE; вам
 может оказаться полезным сравнить его с вариантом из главы
 1.
 
 #DEFINE  MAXLINE  1000
 MAIN()  /* FIND ALL LINES MATCHING A PATTERN */
 {
      CHAR LINE[MAXLINE];
 
      WHILE (GETLINE(LINE, MAXLINE) > 0)
    IF (INDEX(LINE, "THE") >= 0)
       PRINTF("%S", LINE);
  }
      
                           - 75 -
     
     
 GETLINE(S, LIM) /* GET LINE INTO S, RETURN LENGTH *
  CHAR S[];
  INT LIM;
  {
  INT C, I;
 
  I = 0;
 WHILE(--LIM>0 && (C=GETCHAR()) != EOF && C != '\N')
  S[I++] = C;
  IF (C == '\N')
  S[I++] = C;
  S[I] = '\0';
  RETURN(I);
  }
 
  INDEX(S,T) /* RETURN INDEX OF T IN S,-1 IF NONE */
  CHAR S[], T[];
  {
      INT I, J, K;
 
    FOR (I = 0; S[I] != '\0'; I++) {
      FOR(J=I, K=0; T[K] !='\0' && S[J] == T[K]; J++; K++)
     ;
     IF (T[K] == '\0')
       RETURN(I);
      }
      RETURN(-1);
  }
     
 Каждая функция имеет вид имя (список аргументов, если они
 имеются) описания аргументов, если они имеются
 
  {
      описания и операторы , если они имеются
  }
 
 
       Как и указывается, некоторые части могут отсутство-
 вать; минимальной функцией является
 
 
     DUMMY ()  { }
 
 которая не совершает никаких действий.
 
       /Такая ничего не делающая функция иногда оказывается
 удобной для сохранения места для дальнейшего развития прог-
 раммы/. если функция возвращает что-либо отличное от целого
 значения, то перед ее именем может стоять указатель типа;
 этот вопрос обсуждается в следующем разделе.
     
                           - 76 -
     
       Программой является просто набор определений отдельных
 функций. Связь между функциями осуществляется через аргумен-
 ты и возвращаемые функциями значения /в этом случае/; ее
 можно также осуществлять через внешние переменные. Функции
 могут располагаться в исходном файле в любом порядке, а сама
 исходная программа может размещаться на нескольких файлах,
 но так, чтобы ни одна функция не расщеплялась.
       Оператор RETURN служит механизмом для возвращения зна-
 чения из вызванной функции в функцию, которая к ней обрати-
 лась. За RETURN может следовать любое выражение:
 
    RETURN (выражение)
 
       Вызывающая функция может игнорировать возвращаемое
 значение, если она этого пожелает. Более того, после RETURN
 может не быть вообще никакого выражения; в этом случае в вы-
 зывающую программу не передается никакого значения. Управле-
 ние также возвращется в вызывающую программу без передачи
 какого-либо значения и в том случае, когда при выполнении мы
 "проваливаемся" на конец функции, достигая закрывающейся
 правой фигурной скобки. EСли функция возвращает значение из
 одного места и не возвращает никакого значения из другого
 места, это не является незаконным, но может быть признаком
 каких-то неприятностей. В любом случае "значением" функции,
 которая не возвращает значения, несомненно будет мусор. От-
 ладочная программа LINT проверяет такие ошибки.
       Механика компиляции и загрузки "C"-программ, располо-
 женных в нескольких исходных файлах, меняется от системы к
 системе. В системе "UNIX", например, эту работу выполняет
 команда 'CC', упомянутая в главе 1. Предположим, что три
 функции находятся в трех различных файлах с именами MAIN.с,
 GETLINE.C и INDEX.с . Тогда команда
       
    CC MAIN.C GETLINE.C INDEX.C
 
 компилирует эти три файла, помещает полученный настраиваемый
 объектный код в файлы MAIN.O, GETLINE.O и INDEX.O и загружа-
 ет их всех в выполняемый файл, называемый A.OUT .
     Если имеется какая-то ошибка, скажем в MAIN.C, то этот
 файл можно перекомпилировать отдельно и загрузить вместе с
 предыдущими объектными файлами по команде
 
    CC MAIN.C GETLIN.O INDEX.O
 
     Команда 'CC' использует соглашение о наименовании с ".с"
 и ".о" для того, чтобы отличить исходные файлы от объектных.
     Упражнение  4-1.
     ----------------
     Составьте программу для функции RINDEX(S,T), которая
 возвращает позицию самого правого вхождения т в S и -1, если
 S не содержит T.
     
                           - 77 -
 
      4.2. Функции, возвращающие нецелые значения.
 
     До сих пор ни одна из наших программ не содержала како-
 го-либо описания типа функции. Дело в том, что по умолчанию
 функция неявно описывается своим появлением в выражении или
 операторе, как, например, в
 
  WHILE (GETLINE(LINE, MAXLINE) > 0)
 
     Если некоторое имя, которое не было описано ранее, появ-
 ляется в выражении и за ним следует левая круглая скобка, то
 оно по контексту считается именем некоторой функции. Кроме
 того, по умолчанию предполагается, что эта функция возвраща-
 ет значение типа INT. Так как в выражениях CHAR преобразует-
 ся в INT, то нет необходимости описывать функции, возвращаю-
 щие CHAR. Эти предположения покрывают большинство случаев,
 включая все приведенные до сих пор примеры.
     Но что происходит, если функция должна возвратить значе-
 ние какого-то другого типа ? Многие численные функции, такие
 как SQRT, SIN и COS возвращают DOUBLE; другие специальные
 функции возвращают значения других типов. Чтобы показать,
 как поступать в этом случае, давайте напишем и используем
 функцию ATоF(S), которая преобразует строку S в эквивалент-
 ное ей плавающее число двойной точности. Функция ATоF явля-
 ется расширением атоI, варианты которой мы написали в главах
 2 и 3; она обрабатывает необязательно знак и десятичную точ-
 ку, а также целую и дробную часть, каждая из которых может
 как присутствовать, так и отсутствовать./эта процедура пре-
 образования ввода не очень высокого качества; иначе она бы
 заняла больше места, чем нам хотелось бы/.
     Во-первых, сама ATоF должна описывать тип возвращаемого
 ею значения, поскольку он отличен от INT. Так как в выраже-
 ниях тип FLOAT преобразуется в DOUBLE, то нет никакого смыс-
 ла в том, чтобы ATOF возвращала FLOAT; мы можем с равным ус-
 пехом воспользоваться дополнительной точностью, так что мы
 полагаем, что возвращаемое значение типа DOUBLE. Имя типа
 должно стоять перед именем функции, как показывается ниже:
 
 DOUBLE ATOF(S) /* CONVERT STRING S TO DOUBLE */
 CHAR S[];
 {
   DOUBLE VAL, POWER;
   INT  I, SIGN;
           
                           - 78 -
     
 FOR(I=0; S[I]==' ' \!\! S[I]=='\N' \!\! S[I]=='\T'; I++)
    ;       /* SKIP WHITE SPACE */
   SIGN = 1;
   IF (S[I] == '+' \!\! S[I] == '-')   /* SIGN */
      SIGN = (S[I++] == '+') ? 1 : -1;
   FOR (VAL = 0; S[I] >= '0' && S[I] <= '9'; I++)
      VAL = 10 * VAL + S[I] - '0';
   IF (S[I] == '.')
      I++;
 FOR (POWER = 1; S[I] >= '0' && S[I] <= '9'; I++) {
      VAL = 10 * VAL + S[I] - '0';
      POWER *= 10;
    }
    RETURN(SIGN * VAL / POWER);
 }
     
     Вторым, но столь же важным, является то, что вызывающая
 функция должна объявить о том, что ATOF возвращает значение,
 отличное от INT типа. Такое объявление демонстрируется на
 примере следующего примитивного настольного калькулятора
 /едва пригодного для подведения баланса в чековой книжке/,
 который считывает по одному числу на строку, причем это чис-
 ло может иметь знак, и складывает все числа, печатая сумму
 после каждого ввода.
 
 #DEFINE   MAXLINE   100
 MAIN()  /* RUDIMENTARY DESK CALKULATOR */
 {
      DOUBLE SUM, ATOF();
      CHAR LINE[MAXLINE];
 
      SUM = 0;
      WHILE (GETLINE(LINE, MAXLINE) > 0)
    PRINTF("\T%.2F\N",SUM+=ATOF(LINE));
 
 
  Оисание
 
      DOUBLE  SUM, ATOF();
 
 
 говорит, что SUM является переменной типа DOUBLE , и что
 ATOF является функцией, возвращающей значение типа DOUBLE .
 Эта мнемоника означает, что значениями как SUM, так и
 ATOF(...) являются плавающие числа двойной точности.
     
                           - 79 -
     
     Если функция ATOF не будет описана явно в обоих местах,
 то в "C" предполагается, что она возвращает целое значение,
 и вы получите бессмысленный ответ. Если сама ATOF и обраще-
 ние к ней в MAIN имеют несовместимые типы и находятся в од-
 ном и том же файле, то это будет обнаружено компилятором. Но
 если ATOF была скомпилирована отдельно /что более вероятно/,
 то это несоответствие не будет зафиксировано, так что ATOF
 будет возвращать значения типа DOUBLE, с которым MAIN будет
 обращаться, как с INT , что приведет к бессмысленным резуль-
 татам. /Программа LINT вылавливает эту ошибку/.
     Имея ATOF, мы, в принципе, могли бы с ее помощью напи-
 сать ATOI (преобразование строки в INT):
 
  ATOI(S)   /* CONVERT STRING S TO INTEGER */
  CHAR S[];
  {
     DOUBLE ATOF();
 
     RETURN(ATOF(S));
  }
 
 
 Обратите внимание на структуру описаний и оператор RETURN.
 Значение выражения в
 
     RETURN (выражение)
 
 всегда преобразуется к типу функции перед выполнением самого
 возвращения. Поэтому при появлении в операторе RETURN значе-
 ние функции атоF, имеющее тип DOUBLE, автоматически преобра-
 зуется в INT, поскольку функция ATOI возвращает INT. (Как
 обсуждалось в главе 2, преобразование значения с плавающей
 точкой к типу INT осуществляется посредством отбрасывания
 дробной части).
     Упражнение  4-2.
     ----------------
     Расширьте ATOF таким образом, чтобы она могла работать с
 числами вида
 
     123.45е-6
 
 где за числом с плавающей точкой может следовать 'E' и пока-
 затель экспоненты, возможно со знаком.
 
     4.3. Еще об аргументах функций.
 
     В главе 1 мы уже обсуждали тот факт , что аргументы фун-
 кций передаются по значению, т.е. вызванная функция получает
 свою временную копию каждого аргумента, а не его адрес. это
 означает, что вызванная функция не может воздействовать на
 исходный аргумент в вызывающей функции. Внутри функции каж-
 дый аргумент по существу является локальной переменной, ко-
 торая инициализируется тем значением, с которым к этой функ-
 ции обратились.
     
                           - 80 -
     
     Если в качестве аргумента функции выступает имя массива,
 то передается адрес начала этого массива; сами элементы не
 копируются. Функция может изменять элементы массива, исполь-
 зуя индексацию и адрес начала. Таким образом, массив переда-
 ется по ссылке. В главе 5 мы обсудим, как использование ука-
 зателей позволяет функциям воздействовать на отличные от
 массивов переменные в вызывающих функциях.
     Между прочим, несуществует полностью удовлетворительного
 способа написания переносимой функции с переменным числом
 аргументов. Дело в том, что нет переносимого способа, с по-
 мощью которого вызванная функция могла бы определить, сколь-
 ко аргументов было фактически передано ей в данном обраще-
 нии. Таким образом, вы, например, не можете написать дейст-
 вительно переносимую функцию, которая будет вычислять макси-
 мум от произвольного числа аргументов, как делают встроенные
 функции MAX в фортране и PL/1.
     Обычно со случаем переменного числа аргументов безопасно
 иметь дело, если вызванная функция не использует аргументов,
 которые ей на самом деле не были переданы, и если типы сог-
 ласуются. Самая распространенная в языке "C" функция с пере-
 менным числом - PRINTF . Она получает из первого аргумента
 информацию, позволяющую определить количество остальных ар-
 гументов и их типы. Функция PRINTF работает совершенно неп-
 равильно, если вызывающая функция передает ей недостаточное
 количество аргументов, или если их типы не согласуются с ти-
 пами, указанными в первом аргументе. Эта функция не является
 переносимой и должна модифицироваться при использовании в
 различных условиях.
     Если же типы аргументов известны, то конец списка аргу-
 ментов можно отметить, используя какое-то соглашение; напри-
 мер, считая, что некоторое специальное значение аргумента
 (часто нуль) является признаком конца аргументов.
 
      4.4. Внешние переменные.
 
     Программа на языке "C" состоит из набора внешних объек-
 тов, которые являются либо переменными, либо функциями. Тер-
 мин "внешний" используется главным образом в противопостав-
 ление термину "внутренний", которым описываются аргументы и
 автоматические переменные, определенные внурти функций.
 Внешние переменные определены вне какой-либо функции и, та-
 ким образом, потенциально доступны для многих функций. Сами
 функции всегда являются внешними, потому что правила языка
 "C" не разрешают определять одни функции внутри других. По
 умолчанию внешние переменные являются также и "глобальными",
 так что все ссылки на такую переменную, использующие одно и
 то же имя (даже из функций, скомпилированных независимо),
 будут ссылками на одно и то же. В этом смысле внешние пере-
 менные аналогичны переменным COмMON в фортране и EXTERNAL в
 PL/1. Позднее мы покажем, как определить внешние переменные
 и функции таким образом, чтобы они были доступны не глобаль-
 но, а только в пределах одного исходного файла.
     
                           - 81 -
     
     В силу своей глобальной доступности внешние переменные
 предоставляют другую, отличную от аргументов и возвращаемых
 значений, возможность для обмена данными между функциями.
 Если имя внешней переменной каким-либо образом описано, то
 любая функция имеет доступ к этой переменной, ссылаясь к ней
 по этому имени.
     В случаях, когда связь между функциями осуществляется с
 помощью большого числа переменных, внешние переменные оказы-
 ваются более удобными и эффективными, чем использование
 длинных списков аргументов. Как, однако, отмечалось в главе
 1, это соображение следует использовать с определенной осто-
 рожностью, так как оно может плохо отразиться на структуре
 программ и приводить к программам с большим числом связей по
 данным между функциями.
     Вторая причина использования внешних переменных связана
 с инициализацией. В частности, внешние массивы могут быть
 инициализированы а автоматические нет. Мы рассмотрим вопрос
 об инициализации в конце этой главы.
     Третья причина использования внешних переменных обуслов-
 лена их областью действия и временем существования. Автома-
 тические переменные являются внутренними по отношению к фун-
 кциям; они возникают при входе в функцию и исчезают при вы-
 ходе из нее. Внешние переменные, напротив, существуют посто-
 янно. Они не появляютя и не исчезают, так что могут сохра-
 нять свои значения в период от одного обращения к функции до
 другого. В силу этого, если две функции используют некоторые
 общие данные, причем ни одна из них не обращается к другой ,
 то часто наиболее удобным оказывается хранить эти общие дан-
 ные в виде внешних переменных, а не передавать их в функцию
 и обратно с помощью аргументов.
     Давайте продолжим обсуждение этого вопроса на большом
 примере. Задача будет состоять в написании другой программы
 для калькулятора, лучшей,чем предыдущая. Здесь допускаются
 операции +,-,*,/ и знак = (для выдачи ответа).вместо инфикс-
 ного представления калькулятор будет использовать обратную
 польскую нотацию,поскольку ее несколько легче реализовать.в
 обратной польской нотации знак следует за операндами; инфик-
 сное выражение типа
 
    (1-2)*(4+5)=
     
   записывается в виде
    12-45+*=
   круглые скобки при этом не нужны
           
                           - 82 -
     
     Реализация оказывается весьма простой.каждый операнд по-
 мещается в стек; когда поступает знак операции,нужное число
 операндов (два для бинарных операций) вынимается,к ним при-
 меняется операция и результат направляется обратно в
 стек.так в приведенном выше примере 1 и 2 помещаются в стек
 и затем заменяются их разностью, -1.после этого 4 и 5 вво-
 дятся в стек и затем заменяются своей суммой,9.далее числа
 -1 и 9 заменяются в стеке на их произведение,равное -9.опе-
 рация = печатает верхний элемент стека, не удаляя его (так
 что промежуточные вычисления могут быть проверены).
     Сами операции помещения чисел в стек и их извлечения
 очень просты,но, в связи с включением в настоящую программу
 обнаружения ошибок и восстановления,они оказываются доста-
 точно длинными. Поэтому лучше оформить их в виде отдельных
 функций,чем повторять соответствующий текст повсюду в прог-
 рамме. Кроме того, нужна отдельная функция для выборки из
 ввода следующей операции или операнда. Таким образом, струк-
 тура программы имеет вид:
 
 WHILE( поступает операция или операнд, а не конец
    IF ( число )
         поместить его в стек
    еLSE IF ( операция )
         вынуть операнды из стека
         выполнить операцию
         поместить результат в стек
    ELSE
         ошибка
 
     Основной вопрос, который еще не был обсужден, заключает-
 ся в том,где поместить стек, т. Е. Какие процедуры смогут
 обращаться к нему непосредственно. Одна из таких возможнос-
 тей состоит в помещении стека в MAIN и передачи самого стека
 и текущей позиции в стеке функциям, работающим со стеком. Но
 функции MAIN нет необходимости иметь дело с переменными, уп-
 равляющими стеком; ей естественно рассуждать в терминах по-
 мещения чисел в стек и извлечения их оттуда. В силу этого мы
 решили сделать стек и связанную с ним информацию внешними
 переменными , доступными функциям PUSH (помещение в стек) и
 POP (извлечение из стека), но не MAIN.
     Перевод этой схемы в программу достаточно прост. Ведущая
 программа является по существу большим переключателем по ти-
 пу операции или операнду; это, по-видимому, более характер-
 ное применеие переключателя, чем то, которое было продемонс-
 трировано в главе 3.
     
    #DEFINE MAXOP   20  /* MAX SIZE OF OPERAND, OPERАTOR *
    #DEFINE NUMBER '0'  /* SIGNAL THAT NUMBER FOUND */
    #DEFINE TOOBIG '9'  /* SIGNAL THAT STRING IS TOO BIG *
           
                           - 83 -
     
    MAIN()  /* REVERSE POLISH DESK CALCULATOR */
    /(
     INT TUPE;
     CHAR S[MAXOP];
     DOUBLE OP2,ATOF(),POP(),PUSH();
 
     WHILE ((TUPE=GETOP(S,MAXOP)) !=EOF);
       SWITCH(TUPE) /(
       CASE NUMBER:
            PUSH(ATOF(S));
            BREAK;
       CASE '+':
            PUSH(POP()+POP());
            BREAK;
       CASE '*':
            PUSH(POP()*POP());
            BREAK;
       CASE '-':
            OP2=POP();
            PUSH(POP()-OP2);
            BREAK;
       CASE '/':
            OP2=POP();
            IF (OP2 != 0.0)
    PUSH(POP()/OP2);
            ELSE
               PRINTF("ZERO DIVISOR POPPED\N");
            BREAK;
       CASE '=':
            PRINTF("\T%F\N",PUSH(POP()));
            BREAK;
       CASE 'C':
            CLEAR();
            BREAK;
       CASE TOOBIG:
            PRINTF("%.20S ... IS TOO LONG\N",S)
            BREAK;
       /)
    /)
    #DEFINE MAXVAL 100 /* MAXIMUM DEPTH OF VAL STACK */
           
                           - 84 -
     
    INT SP = 0;        /* STACK POINTER */
    DOUBLE VAL[MAXVAL]; /*VALUE STACK */
    DOUBLE PUSH(F)    /* PUSH F ONTO VALUE STACK */
    DOUBLE F;
    /(
     IF (SP < MAXVAL)
             RETURN(VAL[SP++] =F);
     ELSE    /(
             PRINTF("ERROR: STACK FULL\N");
             CLEAR();
             RETURN(0);
     /)
    /)
 
    DOUBLE POP()   /* POP TOP VALUE FROM STEACK */
    /(
     IF (SP > 0)
             RETURN(VAL[--SP]);
     ELSE    /(
             PRINTF("ERROR: STACK EMPTY\N");
             CLEAR();
             RETURN(0);
     /)
    /)
 
    CLEAR()       /* CLEAR STACK */
    /(
      SP=0;
    /)
 
     Команда C очищает стек с помощью функции CLEAR, которая
 также используется в случае ошибки функциями PUSH и POP. к
 функции GETOP мы очень скоро вернемся.
     Как уже говорилось в главе 1, переменная является внеш-
 ней, если она определена вне тела какой бы то ни было функ-
 ции. Поэтому стек и указатель стека, которые должны исполь-
 зоваться функциями PUSH, POP и CLEAR, определены вне этих
 трех функций. Но сама функция MAIN не ссылается ни к стеку,
 ни к указателю стека - их участие тщательно замаскировано. В
 силу этого часть программы, соответствующая операции = , ис-
 пользует конструкцию
  
    PUSH(POP());
 
 
 для того, чтобы проанализировать верхний элемент стека, не
 изменяя его.
     Отметим также, что так как операции + и * коммутативны,
 порядок, в котором объединяются извлеченные операнды, несу-
 щественен, но в случае операций - и / необходимо различать
 левый и правый операнды.
     
                           - 85 -
     
     Упражнение 4-3.
     ---------------
     Приведенная основная схема допускает непосредственное
 расширение возможностей калькулятора. Включите операцию де-
 ления по модулю /%/ и унарный минус. Включите команду "сте-
 реть", которая удаляет верхний элемент стека. Введите коман-
 ды для работы с переменными. /Это просто, если имена пере-
 менных будут состоять из одной буквы из имеющихся двадцати
 шести букв/.
 
      4.5. Правила, определяющие область действия.
 
     Функции и внешние переменные, входящие в состав
 "C"-программы, не обязаны компилироваться одновременно;
 программа на исходном языке может располагаться в нескольких
 файлах, и ранее скомпилированные процедуры могут загружаться
 из библиотек. Два вопроса представляют интерес:
     Как следует составлять описания, чтобы переменные пра-
 вильно воспринимались во время компиляции ?
     Как следует составлять описания, чтобы обеспечить пра-
 вильную связь частей программы при загрузке ?
 
     4.5.1. Область действия.
 
     Областью действия имени является та часть программы, в
 которой это имя определено. Для автоматической переменной,
 описанной в начале функции, областью действия является та
 функция, в которой описано имя этой переменной, а переменные
 из разных функций, имеющие одинаковое имя, считаются не от-
 носящимися друг к другу. Это же справедливо и для аргументов
 функций.
     Область действия внешней переменной простирается от точ-
 ки, в которой она объявлена в исходном файле, до конца этого
 файла. Например, если VAL, SP, PUSH, POP и CLEAR определены
 в одном файле в порядке, указанном выше, а именно:
 
      INT  SP = 0;
      DOUBLE  VAL[MAXVAL];
 
      DOUBLE  PUSH(F) {...}
 
      DOUBLE  POP()  {...}
 
      CLEAR()  {...}
 
 то переменные VAL и SP можно использовать в PUSH, POP и
 CLEAR прямо по имени; никакие дополнительные описания не
 нужны.
     С другой стороны, если нужно сослаться на внешнюю пере-
 менную до ее определения, или если такая переменная опреде-
 лена в файле, отличном от того, в котором она используется,
 то необходимо описание EXTERN.
     
                           - 86 -
     
     Важно различать описание внешней переменной и ее опреде-
 ление. описание указывает свойства переменной /ее тип, раз-
 мер и т.д./; определение же вызывает еще и отведение памяти.
 Если вне какой бы то ни было функции появляются строчки
 
    INT  SP;
    DOUBLE  VAL[MAXVAL];
 
 то они определяют внешние переменные SP и VAL, вызывают от-
 ведение памяти для них и служат в качестве описания для ос-
 тальной части этого исходного файла. В то же время строчки
 
    EXTERN  INT  SP;
    EXTERN  DOUBLE  VAL[];
 
 описывают в остальной части этого исходного файла переменную
 SP как INT, а VAL как массив типа DOUBLE /размер которого
 указан в другом месте/, но не создают переменных и не отво-
 дят им места в памяти.
     Во всех файлах, составляющих исходную программу, должно
 содержаться только одно определение внешней переменной; дру-
 гие файлы могут содержать описания EXTERN для доступа к ней.
 /Описание EXTERN может иметься и в том файле, где находится
 определение/. Любая инициализация внешней переменной прово-
 дится только в определении. В определении должны указываться
 размеры массивов, а в описании EXTERN этого можно не делать.
     Хотя подобная организация приведенной выше программы и
 маловероятна, но VAL и SP могли бы быть определены и инициа-
 лизированы в одном файле, а функция PUSH, POP и CLEAR опре-
 делены в другом. В этом случае для связи были бы необходимы
 следующие определения и описания:
 
 в файле 1:
 ----------
 
    INT SP = 0;  /* STACK POINTER */
    DOUBLE VAL[MAXVAL]; /* VALUE STACK */
 
  в файле 2:
  ----------
 
     EXTERN INT SP;
     EXTERN DOUBLE VAL[];
 
     DOUBLE PUSH(F)  {...}
 
     DOUBLE POP()   {...}
 
     CLEAR()   {...}
 
 
 так как описания EXTERN 'в файле 1' находятся выше и вне
 трех указанных функций, они относятся ко всем ним; одного
 набора описаний достаточно для всего 'файла 2'.
     
                           - 87 -
     
     Для программ большого размера обсуждаемая позже в этой
 главе возможность включения файлов, #INCLUDE, позволяет
 иметь во всей программе только одну копию описаний EXTERN и
 вставлять ее в каждый исходный файл во время его компиляции.
     Обратимся теперь к функции GETOP, выбирающей из файла
 ввода следующую операцию или операнд. Основная задача прос-
 та: пропустить пробелы, знаки табуляции и новые строки. Если
 следующий символ отличен от цифры и десятичной точки, то
 возвратить его. В противном случае собрать строку цифр /она
 может включать десятичную точку/ и возвратить NUMBER как
 сигнал о том, что выбрано число.
     Процедура существенно усложняется, если стремиться пра-
 вильно обрабатывать ситуацию, когда вводимое число оказыва-
 ется слишком длинным. Функция GETOP считывает цифры подряд
 /возможно с десятичной точкой/ и запоминает их, пока после-
 довательность не прерывается. Если при этом не происходит
 переполнения, то функция возвращает NUMBER и строку цифр.
 Если же число оказывается слишком длинным, то GETOP отбрасы-
 вает остальную часть строки из файла ввода, так что пользо-
 ватель может просто перепечатать эту строку с места ошибки;
 функция возвращает TOOBIG как сигнал о переполнении.
 
  GETOP(S, LIM) /* GET NEXT OPRERATOR OR OPERAND */
  CHAR S[];
  INT LIM;
  {
    INT I, C;
 
      WHILE((C=GETCH())==' '\!\! C=='\T' \!\! C=='\N')
     ;
    IF (C != '.' && (C < '0' \!\! C > '9'))
     RETURN(C);
    S[0] = C;
    FOR(I=1; (C=GETCHAR()) >='0' && C <= '9'; I++)
     IF (I < LIM)
     
        S[I] = C;
   IF (C == '.') {   /* COLLECT FRACTION */
    IF (I < LIM)
       S[I] = C;
   FOR(I++;(C=GETCHAR()) >='0' && C<='9';I++)
       IF (I < LIM)
           S[I] =C;
   }
   IF (I < LIM)  { /* NUMBER IS OK */
   UNGETCH(C);
   S[I] = '\0';
   RETURN (NUMBER);
 
  } ELSE { /* IT'S TOO BIG; SKIP REST OF LINE */
    WHILE (C != '\N' && C != EOF)
           C = GETCHAR();
    S[LIM-1] = '\0';
    RETURN (TOOBIG);
   }
      }    
                           - 88 -
 
     Что же представляют из себя функции 'GETCH' и 'UNGETCH'?
 Часто так бывает, что программа, считывающая входные данные,
 не может определить, что она прочла уже достаточно, пока она
 не прочтет слишком много. Одним из примеров является выбор
 символов, составляющих число: пока не появится символ, от-
 личный от цифры, число не закончено. Но при этом программа
 считывает один лишний символ, символ, для которого она еще
 не подготовлена.
     Эта проблема была бы решена, если бы было бы возможно
 "прочесть обратно" нежелательный символ. Тогда каждый раз,
 прочитав лишний символ, программа могла бы поместить его об-
 ратно в файл ввода таким образом, что остальная часть прог-
 раммы могла бы вести себя так, словно этот символ никогда не
 считывался. к счастью, такое неполучение символа легко имми-
 тировать, написав пару действующих совместно функций. Функ-
 ция GETCH доставляет следующий символ ввода, подлежащий рас-
 смотрению; функция UNGETCH помещает символ назад во ввод,
 так что при следующем обращении к GETCH он будет возвращен.
     То, как эти функции совместно работают, весьма просто.
 Функция UNGETCH помещает возвращаемые назад символы в сов-
 местно используемый буфер, являющийся символьным массивом.
 Функция GETCH читает из этого буфера, если в нем что-либо
 имеется; если же буфер пуст, она обращается к GETCHAR. При
 этом также нужна индексирующая переменная, которая будет
 фиксировать позицию текущего символа в буфере.
     Так как буфер и его индекс совместно используются функ-
 циями GETCH и UNGETCH и должны сохранять свои значения в пе-
 риод между обращениями, они должны быть внешними для обеих
 функций. Таким образом, мы можем написать GETCH, UNGETCH и
 эти переменные как:
 
  #DEFINE  BUFSIZE  100
  CHAR BUF[BUFSIZE]; /* BUFFER FOR UNGETCH */
  INT BUFP = 0; /* NEXT FREE POSITION IN BUF */
 
      GETCH() /* GET A (POSSIBLY PUSHED BACK) CHARACTER */
  {
    RETURN((BUFP > 0) ? BUF[--BUFP] : GETCHAR());
  }
 
      UNGETCH(C)  /* PUSH CHARACTER BACK ON INPUT */
  INT C;
  {
     IF (BUFP > BUFSIZE)
   PRINTF("UNGETCH: TOO MANY CHARACTERS\N");
     ELSE
   BUF [BUFP++] = C;
  }
 
 Мы использовали для хранения возвращаемых символов массив, а
 не отдельный символ, потому что такая общность может приго-
 диться в дальнейшем.
     
                           - 89 -
     
     
     Упражнение  4-4.
     ----------------
 Напишите функцию UNGETS(S) , которая будет возвращать во
 ввод целую строку. Должна ли UNGETS иметь дело с BUF и BUFP
 или она может просто использовать UNGETCH ?
     Упражнение  4-5.
     ----------------
 Предположите, что может возвращаться только один символ. Из-
 мените GETCH и UNGETCH соответствующим образом.
     Упражнение  4-6.
     ----------------
 Наши функции GETCH и UNGETCH не обеспечивают обработку возв-
 ращенного символа EOF переносимым образом. Решите, каким
 свойством должны обладать эти функции, если возвращается
 EOF, и реализуйте ваши выводы.
 
      4.6. Статические переменные.
 
     Статические переменные представляют собой третий класс
 памяти, в дополнении к автоматическим переменным и EXTERN, с
 которыми мы уже встречались.
     Статические переменные могут быть либо внутренними, либо
 внешними. Внутренние статические переменные точно так же,
 как и автоматические, являются локальными для некоторой фун-
 кции, но, в отличие от автоматических, они остаются сущест-
 вовать, а не появляются и исчезают вместе с обращением к
 этой функции. это означает, что внутренние статические пере-
 менные обеспечивают постоянное, недоступное извне хранение
 внутри функции. Символьные строки, появляющиеся внутри функ-
 ции, как, например, аргументы PRINTF , являются внутренними
 статическими.
     Внешние статические переменные определены в остальной
 части того исходного файла, в котором они описаны, но не в
 каком-либо другом файле. Таким образом, они дают способ
 скрывать имена, подобные BUF и BUFP в комбинации
 GETCH-UNGETCH, которые в силу их совместного использования
 должны быть внешними, но все же не доступными для пользова-
 телей GETCH и UNGETCH , чтобы исключалась возможность конф-
 ликта. Если эти две функции и две переменные объеденить в
 одном файле следующим образом
 
 STATIC CHAR BUF[BUFSIZE]; /* BUFFER FOR UNGETCH */
 STATIC INT BUFP=0; /*NEXT FREE POSITION IN BUF */
 
 GETCH()  {...}
 
 UNGETCH()  {...}
 
 то никакая другая функция не будет в состоянии обратиться к
 BUF и BUFP; фактически, они не будут вступать в конфликт с
 такими же именами из других файлов той же самой программы.
     Статическая память, как внутренняя, так и внешняя, спе-
 цифицируется словом STATIC , стоящим перед обычным описани-
 ем. Переменная является внешней, если она описана вне какой
 бы то ни было функции, и внутренней, если она описана внутри
 некоторой функции.
     
                           - 90 -
     
     Нормально функции являются внешними объектами; их имена
 известны глобально. возможно, однако, объявить функцию как
 STATIC ; тогда ее имя становится неизвестным вне файла, в
 котором оно описано.
     В языке "C" "STATIC" отражает не только постоянство, но
 и степень того, что можно назвать "приватностью". Внутренние
 статические объекты определены только внутри одной функции;
 внешние статические объекты /переменные или функции/ опреде-
 лены только внутри того исходного файла, где они появляются,
 и их имена не вступают в конфликт с такими же именами пере-
 менных и функций из других файлов.
     Внешние статические переменные и функции предоставляют
 способ организовывать данные и работающие с ними внутренние
 процедуры таким образом, что другие процедуры и данные не
 могут прийти с ними в конфликт даже по недоразумению. Напри-
 мер, функции GETCH и UNGETCH образуют "модуль" для ввода и
 возвращения символов; BUF и BUFP должны быть статическими,
 чтобы они не были доступны извне. Точно так же функции PUSH,
 POP и CLEAR формируют модуль обработки стека; VAR и SP тоже
 должны быть внешними статическими.
 
      4.7. Регистровые переменные.
 
     Четвертый и последний класс памяти называется регистро-
 вым. Описание REGISTER указывает компилятору, что данная пе-
 ременная будет часто использоваться. Когда это возможно, пе-
 ременные, описанные как REGISTER, располагаются в машинных
 регистрах, что может привести к меньшим по размеру и более
 быстрым программам. Описание REGISTER выглядит как
 
  REGISTER INT X;
  REGISTER CHAR C;
 
 и т.д.; часть INT может быть опущена. Описание REGISTER мож-
 но использовать только для автоматических переменных и фор-
 мальных параметров функций. В этом последнем случае описания
 выглядят следующим образом:
 
  F(C,N)
  REGISTER INT C,N;
  {
     REGISTER INT I;
     ...
  }
           
                           - 91 -
 
     На практике возникают некоторые ограничения на регистро-
 вые переменные, отражающие реальные возможности имеющихся
 аппаратных средств. В регистры можно поместить только нес-
 колько переменных в каждой функции, причем только определен-
 ных типов. В случае превышения возможного числа или исполь-
 зования неразрешенных типов слово REGISTER игнорируется.
 Кроме того невозможно извлечь адрес регистровой переменной
 (этот вопрос обсуждается в главе 5). Эти специфические огра-
 ничения варьируются от машины к машине. Так, например, на
 PDP-11 эффективными являются только первые три описания
 REGISTER в функции, а в качестве типов допускаются INT, CHAR
 или указатель.
 
      4.8. Блочная структура.
 
     Язык "C" не является языком с блочной структурой в смыс-
 ле PL/1 или алгола; в нем нельзя описывать одни функции
 внутри других.
     Переменные же, с другой стороны, могут определяться по
 методу блочного структурирования. Описания переменных (вклю-
 чая инициализацию) могут следовать за левой фигурной скоб-
 кой,открывающей любой оператор, а не только за той, с кото-
 рой начинается тело функции. Переменные, описанные таким об-
 разом, вытесняют любые переменные из внешних блоков, имеющие
 такие же имена, и остаются определенными до соответствующей
 правой фигурной скобки. Например в
 
 IF (N > 0)  {
    INT I;  /* DECLARE A NEW I */
    FOR (I = 0; I < N; I++)
            ...
 }
 
     Областью действия переменной I является "истинная" ветвь
 IF; это I никак не связано ни с какими другими I в програм-
 ме.
     Блочная структура влияет и на область действия внешних
 переменных. Если даны описания
 
 INT X;
 
 F()
 {
    DOUBLE X;
    ...
 }
 
 То появление X внутри функции F относится к внутренней пере-
 менной типа DOUBLE, а вне F - к внешней целой переменной.
 это же справедливо в отношении имен формальных параметров:
 
 INT X;
 F(X)
 DOUBLE X;
 {
    ...
 }
 
 Внутри функции F имя X относится к формальному параметру, а
 не к внешней переменной.
 
      4.9. Инициализация.
 
     Мы до сих пор уже много раз упоминали инициализацию, но
 всегда мимоходом , среди других вопросов. Теперь, после того
 как мы обсудили различные классы памяти, мы в этом разделе
 просуммируем некоторые правила, относящиеся к инициализации.
     Если явная инициализация отсутствует, то внешним и ста-
 тическим переменным присваивается значение нуль; автомати-
 ческие и регистровые переменные имеют в этом случае неопре-
 деленные значения (мусор).
     
                           - 92 -
     
     Простые переменные (не массивы или структуры) можно ини-
 циализировать при их описании, добавляя вслед за именем знак
 равенства и константное выражение:
 
  INT X = 1;
  CHAR SQUOTE = '\'';
  LONG DAY = 60 * 24;    /* MINUTES IN A DAY */
 
 Для внешних и статических переменных инициализация выполня-
 ется только один раз, на этапе компиляции. Автоматические и
 регистровые переменные инициализируются каждый раз при входе
 в функцию или блок.
 В случае автоматических и регистровых переменных инициализа-
 тор не обязан быть константой: на самом деле он может быть
 любым значимым выражением, которое может включать определен-
 ные ранее величины и даже обращения к функциям. Например,
 инициализация в программе бинарного поиска из главы 3 могла
 бы быть записана в виде
 
 
  BINARY(X, V, N)
  INT X, V[], N;
  {
     INT LOW = 0;
     INT HIGH = N - 1;
     INT MID;
     ...
  }
 
 вместо
 
  BINARY(X, V, N)
  INT X, V[], N;
  {
     INT LOW, HIGH, MID;
 
     LOW = 0;
    HIGH = N - 1;
    ...
 }
 
 По своему результату, инициализации автоматических перемен-
 ных являются сокращенной записью операторов присваивания.
 Какую форму предпочесть - в основном дело вкуса. мы обычно
 используем явные присваивания, потому что инициализация в
 описаниях менее заметна.
 Автоматические массивы не могут быть инициализированы. Внеш-
 ние и статические массивы можно инициализировать, помещая
 вслед за описанием заключенный в фигурные скобки список на-
 чальных значений, разделенных запятыми. Например программа
 подсчета символов из главы 1, которая начиналась с
           
                           - 93 -
     
     
 MAIN()     /* COUNT DIGITS, WHITE SPACE, OTHERS */
  (
   INT C, I, NWHITE, NOTHER;
   INT NDIGIT[10];
   
   NWHITE = NOTHER = 0;
   FOR (I = 0; I < 10; I++)
      NDIGIT[I] = 0;
   ...
  )
 
 Ожет быть переписана в виде
 
  INT NWHITE = 0;
  INT NOTHER = 0;
  INT NDIGIT[10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
    
  MAIN()     /* COUNT DIGITS, WHITE SPACE, OTHERS */
   (
    INT C, I;
    ...
   )
 
 Эти инициализации фактически не нужны, так как все присваи-
 ваемые значения равны нулю, но хороший стиль - сделать их
 явными. Если количество начальных значений меньше, чем ука-
 занный размер массива, то остальные элементы заполняются ну-
 лями. Перечисление слишком большого числа начальных значений
 является ошибкой. К сожалению, не предусмотрена возможность
 указания, что некоторое начальное значение повторяется, и
 нельзя инициализировать элемент в середине массива без пере-
 числения всех предыдущих.
     Для символьных массивов существует специальный способ
 инициализации; вместо фигурных скобок и запятых можно ис-
 пользовать строку:
 
  CHAR PATTERN[] = "THE";
 
 Это сокращение более длинной, но эквивалентной записи:
 
  CHAR PATTERN[] = { 'T', 'H', 'E', '\0' };
 
 Если размер массива любого типа опущен, то компилятор опре-
 деляет его длину, подсчитывая число начальных значений. В
 этом конкретном случае размер равен четырем (три символа
 плюс конечное \0).
     
                           - 94 -
     
      4.10. Рекурсия.
 
     В языке "C" функции могут использоваться рекурсивно; это
 означает, что функция может прямо или косвенно обращаться к
 себе самой. Традиционным примером является печать числа в
 виде строки символов. как мы уже ранее отмечали, цифры гене-
 рируются не в том порядке: цифры младших разрядов появляются
 раньше цифр из старших разрядов, но печататься они должны в
 обратном порядке.
     Эту проблему можно решить двумя способами. Первый спо-
 соб, которым мы воспользовались в главе 3 в функции ITOA,
 заключается в запоминании цифр в некотором массиве по мере
 их поступления и последующем их печатании в обратном поряд-
 ке. Первый вариант функции PRINTD следует этой схеме.
 
   PRINTD(N)    /* PRINT N IN DECIMAL */
   INT N;
   {
     CHAR S[10];
     INT I;
    
     IF (N < 0) {
        PUTCHAR('-');
        N = -N;
     }
     I = 0;
     DO {
        S[I++] = N % 10 + '0'; /* GET NEXT CHAR */
     } WHILE ((N /= 10) > 0); /* DISCARD IT */
     WHILE (--I >= 0)
        PUTCHAR(S[I]);
   }
    
 
     Альтернативой этому способу является рекурсивное реше-
 ние, когда при каждом вызове функция PRINTD сначала снова
 обращается к себе, чтобы скопировать лидирующие цифры, а за-
 тем печатает последнюю цифру.
 
  PRINTD(N)   /* PRINT N IN DECIMAL (RECURSIVE)*/
  INT N;
   (
    INT I;
    
    IF (N < 0) {
       PUTCHAR('-');
       N = -N;
    }
    IF ((I = N/10) != 0)
       PRINTD(I);
    PUTCHAR(N % 10 + '0');
   )       
                           - 95 -
 
     Когда функция вызывает себя рекурсивно, при каждом обра-
 щении образуется новый набор всех автоматических переменных,
 совершенно не зависящий от предыдущего набора. Таким обра-
 зом, в PRINTD(123) первая функция PRINTD имеет N = 123. Она
 передает 12 второй PRINTD, а когда та возвращает управление
 ей, печатает 3. Точно так же вторая PRINTD передает 1
 третьей (которая эту единицу печатает), а затем печатает 2.
     Рекурсия обычно не дает никакой экономиии памяти, пос-
 кольку приходится где-то создавать стек для обрабатываемых
 значений. Не приводит она и к созданию более быстрых прог-
 рамм. Но рекурсивные программы более компактны, и они зачас-
 тую становятся более легкими для понимания и написания. Ре-
 курсия особенно удобна при работе с рекурсивно определяемыми
 структурами данных, например, с деревьями; хороший пример
 будет приведен в главе 6.
     Упражнение 4-7.
     --------------
     Приспособьте идеи, использованные в PRINTD для рекурсив-
 ного  написания ITOA; т.е. Преобразуйте целое в строку с по-
 мощью рекурсивной процедуры.
 
     Упражнение 4-8.
     --------------
     Напишите рекурсивный вариант функции REVERSE(S), которая
 располагает в обратном порядке строку S.
 
      4.11. Препроцессор языка "C".
 
     В языке "с" предусмотрены определенные расширения языка
 с помощью простого макропредпроцессора. одним из самых расп-
 ространенных таких расширений, которое мы уже использовали,
 является конструкция #DEFINE; другим расширением является
 возможность включать во время компиляции содержимое других
 файлов.
 
      4.11.1. Включение файлов
 
     Для облегчения работы с наборами конструкций #DEFINE и
 описаний (среди прочих средств) в языке "с" предусмотрена
 возможность включения файлов. Любая строка вида
 
  #INCLUDE "FILENAME"
 
 заменяется содержимым файла с именем FILENAME. (Кавычки обя-
 зательны). Часто одна или две строки такого вида появляются
 в начале каждого исходного файла, для того чтобы включить
 общие конструкции #DEFINE и описания EXTERN для глобальных
 переменных. Допускается вложенность конструкций #INCLUDE.
     Конструкция #INCLUDE является предпочтительным способом
 связи описаний в больших программах. Этот способ гарантиру-
 ет, что все исходные файлы будут снабжены одинаковыми опре-
 делениями и описаниями переменных, и, следовательно, исклю-
 чает особенно неприятный сорт ошибок. Естественно, когда ка-
 кой-TO включаемый файл изменяется, все зависящие от него
 файлы должны быть перекомпилированы.
           
                           - 96 -
     
     4.11.2. Макроподстановка
 
     Определение вида
 
  #DEFINE TES     1
 
 приводит к макроподстановке самого простого вида - замене
 имени на строку символов. Имена в #DEFINE имеют ту же самую
 форму, что и идентификаторы в "с"; заменяющий текст совер-
 шенно произволен. Нормально заменяющим текстом является ос-
 тальная часть строки; длинное определение можно продолжить,
 поместив \ в конец продолжаемой строки. "Область действия"
 имени, определенного в #DEFINE, простирается от точки опре-
 деления до конца исходного файла. имена могут быть переопре-
 делены, и определения могут использовать определения, сде-
 ланные ранее. Внутри заключенных в кавычки строк подстановки
 не производятся, так что если, например, YES - определенное
 имя, то в PRINTF("YES") не будет сделано никакой подстанов-
 ки.
     Так как реализация #DEFINE является частью работы
 маKропредпроцессора, а не собственно компилятора, имеется
 очень мало грамматических ограничений на то, что может быть
 определено. Так, например, любители алгола могут объявить
 
 #DEFINE THEN
 #DEFINE BEGIN {
 #DEFINE END   ;}
 
 и затем написать
 
 IF (I > 0) THEN
    BEGIN
            A = 1;
            B = 2
    END
 
     Имеется также возможность определения макроса с аргумен-
 тами, так что заменяющий текст будет зависеть от вида обра-
 щения к макросу. Определим, например, макрос с именем MAX
 следующим образом:
 
 #DEFINE MAX(A, B)  ((A) > (B) ? (A) : (B))
 
 когда строка
 
 X = MAX(P+Q, R+S);
 
 будет заменена строкой
 
 X = ((P+Q) > (R+S) ? (P+Q) : (R+S));
 
 Такая возможность обеспечивает "функцию максимума", которая
 расширяется в последовательный код, а не в обращение к функ-
 ции. При правильном обращении с аргументами такой макрос бу-
 дет работать с любыми типами данных; здесь нет необходимости
 в различных видах MAX для данных разных типов, как это было
 бы с функциями.
     
                           - 97 -
     
     Конечно, если вы тщательно рассмотрите приведенное выше
 расширение MAX, вы заметите определенные недостатки. Выраже-
 ния вычисляются дважды; это плохо, если они влекут за собой
 побочные эффекты, вызванные, например, обращениями к функци-
 ям или использованием операций увеличения. Нужно позаботить-
 ся о правильном использовании круглых скобок, чтобы гаранти-
 ровать сохранение требуемого порядка вычислений. (Рассмотри-
 те макрос
 
   #DEFINE SQUARE(X)  X * X
 
 при обращении к ней, как SQUARE(Z+1)). Здесь возникают даже
 некоторые чисто лексические проблемы: между именем макро и
 левой круглой скобкой, открывающей список ее аргументов, не
 должно быть никаких пробелов.
     Тем не менее аппарат макросов является весьма ценным.
 Один практический пример дает описываемая в главе 7 стандар-
 тная библиотека ввода-вывода, в которой GETCHAR и PUTCHAR
 определены как макросы (очевидно PUTCHAR должна иметь аргу-
 мент), что позволяет избежать затрат на обращение к функции
 при обработке каждого символа.
     Другие возможности макропроцессора описаны в приложении
 А.
     Упражнение 4-9.
     ---------------
     Определите макрос SWAP(X, Y), который обменивает значе-
 ниями два своих аргумента типа INT. (В этом случае поможет
 блочная структура).
