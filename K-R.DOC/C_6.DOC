                           - 128 -
     
     6. Структуры.
     Структура - это набор из одной или более переменных,
 возможно различных типов, сгруппированных под одним именем
 для удобства обработки. (В некоторых языках, самый известный
 из которых паскаль, структуры называются "записями").
     Традиционным примером структуры является учетная карточ-
 ка работающего: "служащий" описывается набором атрибутов та-
 ких, как фамилия, имя, отчество (ф.и.о.), адрес, код соци-
 ального обеспечения, зарплата и т.д. Некоторые из этих атри-
 бутов сами могут оказаться структурами: ф.и.о. Имеет нес-
 колько компонент, как и адрес, и даже зарплата.
     Структуры оказываются полезными при организации сложных
 данных особенно в больших программах, поскольку во многих
 ситуациях они позволяют сгруппировать связанные данные таким
 образом, что с ними можно обращаться, как с одним целым, а
 не как с отдельными объектами. В этой главе мы постараемся
 продемонстрировать то, как используются структуры. Програм-
 мы, которые мы для этого будем использовать, больше, чем
 многие другие в этой книге, но все же достаточно умеренных
 размеров.
 
 6.1. Основные сведения.
     Давайте снова обратимся к процедурам преобразования даты
 из главы 5. Дата состоит из нескольких частей таких, как
 день, месяц, и год, и, возможно, день года и имя месяца. Эти
 пять переменных можно объеденить в одну структуру вида:
 
  STRUCT DATE \(
  INT  DAY;
  INT  MONTH;
  INT  YEAR;
  INT  YEARDAY;
  CHAR MON_NAME[4];
  \);
 
     Описание структуры, состоящее из заключенного в фигурные
 скобки списка описаний, начинается с ключевого слова STRUCT.
 За словом STRUCT может следовать необязательное имя, называ-
 емое ярлыком структуры (здесь это DATе). Такой ярлык именует
 структуры этого вида и может использоваться в дальнейшем как
 сокращенная запись подробного описания.
     Элементы или переменные, упомянутые в структуре, называ-
 ются членами. Ярлыки и члены структур могут иметь такие же
 имена, что и обычные переменные (т.е. Не являющиеся членами
 структур), поскольку их имена всегда можно различить по кон-
 тексту. Конечно, обычно одинаковые имена присваивают только
 тесно связанным объектам.
     
                           - 129 -
     
     Точно так же, как в случае любого другого базисного ти-
 па, за правой фигурной скобкой, закрывающей список членов,
 может следовать список переменных.
 Оператор
 
    STRUCT   \( ...\) X,Y,Z;
 
 синтаксически аналогичен
 
    INT X,Y,Z;
 
 в том смысле, что каждый из операторов описывает X , Y и Z в
 качестве переменных соотвествующих типов и приводит к выде-
 лению для них памяти.
     Описание структуры, за которым не следует списка пере-
 менных, не приводит к выделению какой-либо памяти; оно толь-
 ко определяет шаблон или форму структуры. Однако, если такое
 описание снабжено ярлыком, то этот ярлык может быть исполь-
 зован позднее при определении фактических экземпляров струк-
 тур. Например, если дано приведенное выше описание DATE, то
 
    STRUCT  DATE D;
 
 определяет переменную D в качестве структуры типа DATE.
 Внешнюю или статическую структуру можно инициализировать,
 поместив вслед за ее определением список инициализаторов для
 ее компонент:
 
  STRUCT DATE D=\( 4, 7, 1776, 186, "JUL"\);
 
     Член определенной структуры может быть указан в выраже-
 нии с помощью конструкции вида
 
   имя структуры . Член
   --------------------
 Операция указания члена структуры "." связывает имя структу-
 ры и имя члена. В качестве примера определим LEAP (признак
 високосности года) на основе даты, находящейся в структуре
 D,
 
 LEAP = D.YEAR % 4 == 0 && D.YEAR % 100 != 0
    \!\! D.YEAR % 400 == 0;
 
 или проверим имя месяца
 
  IF (STRCMP(D.MON_NAME, "AUG") == 0) ...
 
 Или преобразуем первый символ имени месяца так, чтобы оно
 начиналось со строчной буквы
 
  D.MON_NAME[0] = LOWER(D.MON_NAME[0]);
            
                           - 130 -
     
     Структуры могут быть вложенными; учетная карточка служа-
 щего может фактически выглядеть так:
 
  STRUCT  PERSON  \(
     CHAR NAME[NAMESIZE];
     CHAR ADDRESS[ADRSIZE];
     LONG ZIPCODE;   /* почтовый индекс */
     LONG SS_NUMBER; /* код соц. Обеспечения */
     DOUBLE SALARY;  /* зарплата */
     STRUCT DATE BIRTHDATE; /* дата рождения */
     STRUCT DATE HIREDATE; /* дата поступления
      на работу */
  \);
 
 
 Структура PERSON содержит две структуры типа DATE . Если мы
 определим EMP как
 
  STRUCT PERSON EMP;
 
 то
 
  EMP.BIRTHDATE.MONTH
 
 будет ссылаться на месяц рождения. Операция указания члена
 структуры "." ассоциируется слева направо.
 
 6.2. Структуры и функции.
     В языке "C" существует ряд ограничений на использование
 структур. Обязательные правила заключаются в том, что единс-
 твенные операции, которые вы можете проводить со структура-
 ми, состоят в определении ее адреса с помощью операции & и
 доступе к одному из ее членов. Это влечет за собой то, что
 структуры нельзя присваивать или копировать как целое, и что
 они не могут быть переданы функциям или возвращены ими. (В
 последующих версиях эти ограничения будут сняты). На указа-
 тели структур эти ограничения однако не накладываются, так
 что структуры и функции все же могут с удобством работать
 совместно. И наконец, автоматические структуры, как и авто-
 матические массивы, не могут быть инициализированы; инициа-
 лизация возможна только в случае внешних или статических
 структур.
     Давайте разберем некоторые из этих вопросов, переписав с
 этой целью функции перобразования даты из предыдущей главы
 так, чтобы они использовали структуры. Так как правила зап-
 рещают непосредственную передачу структуры функции, то мы
 должны либо передавать отдельно компоненты, либо передать
 указатель всей структуры. Первая возможность демонстрируется
 на примере функции DAY_OF_YEAR, как мы ее написали в главе
 5:
     
  D.YEARDAY = DAY_OF_YEAR(D.YEAR, D.MONTH, D.DAY);
            
                           - 131 -
     
 другой способ состоит в передаче указателя. если мы опишем
 HIREDATE как
 
  STRUCT  DATE HIREDATE;
 
 и перепишем DAY_OF_YEAR нужным образом, мы сможем тогда на-
 писать
 
  HIREDATE YEARDAY = DAY_OF_YEAR(&HIREDATE);
 
 передавая указатель на HIREDATE функции DAY_OF_YEAR . Функ-
 ция должна быть модифицирована, потому что ее аргумент те-
 перь является указателем, а не списком переменных.
 
    DAY_OF_YEAR(PD) /* SET DAY OF YEAR FROM MONTH, DAY */
    STRUCT DATE *PD;
    \(
 INT I, DAY, LEAP;
 
 DAY = PD->DAY;
 LEAP = PD->YEAR % 4 == 0 && PD->YEAR % 100 != 0
    \!\! PD->YEAR % 400 == 0;
 FOR (I =1;  I < PD->MONTH; I++)
    DAY += DAY_TAB[LEAP][I];
 RETURN(DAY);
     \)
 
 
 Описание
 
 STRUCT DATE *PD;
 
 говорит, что PD является указателем структуры типа DATE.
 Запись, показанная на примере
 
 PD->YEAR
 
 является новой. Если P - указатель на структуру, то
                P-> член структуры
                ------------------
 обращается к конкретному члену. (Операция -> - это знак ми-
 нус, за которым следует знак ">".)
     Так как PD указывает на структуру, то к члену YEAR можно
 обратиться и следующим образом
 
  (*PD).YEAR
 
 но указатели структур используются настолько часто, что за-
 пись -> оказывается удобным сокращением. Круглые скобки в
 (*PD).YEAR необходимы, потому что операция указания члена
     
                           - 132 -
     
 стуктуры старше , чем * . Обе операции, "->" и ".", ассоции-
 руются слева направо, так что конструкции слева и справа
 зквивалентны
 
  P->Q->MEMB    (P->Q)->MEMB
  EMP.BIRTHDATE.MONTH    (EMP.BIRTHDATE).MONTH
 
 Для полноты ниже приводится другая функция, MONTH_DAY, пере-
 писанная с использованием структур.
 
    MONTH_DAY(PD) /* SET MONTH AND DAY FROM DAY OF YEAR */
    STRUCT DATE *PD;
    \(
  INT I, LEAP;
 
  LEAP = PD->YEAR % 4 == 0 && PD->YEAR % 100 != 0
     \!\! PD->YEAR % 400 == 0;
  PD->DAY = PD->YEARDAY;
  FOR (I = 1; PD->DAY > DAY_TAB[LEAP][I]; I++)
     PD->DAY -= DAY_TAB[LEAP][I];
  PD->MONTH = I;
     \)
 
     Операции работы со структурами "->" и "." наряду со ()
 для списка аргументов и [] для индексов находятся на самом
 верху иерархии страшинства операций и, следовательно, связы-
 ваются очень крепко. Если, например, имеется описание
 
  STRUCT \(
     INT X;
     INT *Y;
  \) *P;
 
 то выражение
 
  ++P->X
     
 увеличивает х, а не р, так как оно эквивалентно выражению
 ++(P->х). Для изменения порядка выполнения операций можно
 использовать круглые скобки: (++P)->х увеличивает P до дос-
 тупа к х, а (P++)->X увеличивает P после. (круглые скобки в
 последнем случае необязательны. Почему ?)
     Совершенно аналогично *P->Y извлекает то, на что указы-
 вает Y; *P->Y++ увеличивает Y после обработки того, на что
 он указывает (точно так же, как и *S++); (*P->Y)++ увеличи-
 вает то, на что указывает Y; *P++->Y увеличивает P после вы-
 борки того, на что указывает Y.
            
                           - 133 -
     
      6.3. Массивы сруктур.
     Структуры особенно подходят для управления массивами
 связанных переменных. Рассмотрим, например, программу подс-
 чета числа вхождений каждого ключевого слова языка "C". Нам
 нужен массив символьных строк для хранения имен и массив це-
 лых для подсчета. одна из возможностей состоит в использова-
 нии двух параллельных массивов KEYWORD и KEYCOUNT:
 
 CHAR *KEYWORD [NKEYS];
 INT  KEYCOUNT [NKEYS];
 
 Но сам факт, что массивы параллельны, указывает на возмож-
 ность другой организации. Каждое ключевое слово здесь по су-
 ществу является парой:
 
 CHAR *KEYWORD;
 INT  KEYCOUNT;
 
 и, следовательно, имеется массив пар. Описание структуры
 
 STRUCT KEY  \(
    CHAR *KEYWORD;
    INT  KEYCOUNT;
 \) KEYTAB [NKEYS];
 
 оперделяет массив KEYTAB структур такого типа и отводит для
 них память. Каждый элемент массива является структурой. Это
 можно было бы записать и так:
 
 STRUCT KEY  \(
    CHAR *KEYWORD;
    INT  KEYCOUNT;
 \);
 STRUCT KEY KEYTAB [NKEYS];
 
     Так как структура KEYTAB фактически содержит постоянный
 набор имен, то легче всего инициализировать ее один раз и
 для всех членов при определении. Инициализация структур
 вполне аналогична предыдущим инициализациям - за определени-
 ем следует заключенный в фигурные скобки список инициализа-
 торов:
 
  STRUCT KEY  \(
     CHAR *KEYWORD;
     INT  KEYCOUNT;
  \) KEYTAB[] =\(
     "BREAK", 0,
     "CASE", 0,
     "CHAR", 0,
     "CONTINUE", 0,
     "DEFAULT", 0,
     /* ... */
     "UNSIGNED", 0,
     "WHILE", 0
  \);
 
 Инициализаторы перечисляются парами соответственно членам
 структуры. Было бы более точно заключать в фигурные скобки
 инициализаторы для каждой "строки" или структуры следующим
 образом:
 
  \( "BREAK", 0 \),
  \( "CASE", 0 \),
  . . .
            
                           - 134 -
     
 Но когда инициализаторы являются простыми переменными или
 символьными строками и все они присутствуют, то во внутрен-
 них фигурных скобках нет необходимости. Как обычно, компиля-
 тор сам вычислит число элементов массива KEYTAB, если иници-
 ализаторы присутствуют, а скобки [] оставлены пустыми.
     Программа подсчета ключевых слов начинается с определе-
 ния массива KEYTAB. ведущая программа читает свой файл вво-
 да, последовательно обращаясь к функции GETWORD, которая из-
 влекает из ввода по одному слову за обращение. Каждое слово
 ищется в массиве KEYTAB с помощью варианта функции бинарного
 поиска, написанной нами в главе 3. (Конечно, чтобы эта функ-
 ция работала, список ключевых слов должен быть расположен в
 порядке возрастания).
 
  #DEFINE    MAXWORD   20
 
  MAIN()   /* COUNT "C" KEYWORDS */
  \(
  INT  N, T;
  CHAR WORD[MAXWORD];
 
  WHILE ((T = GETWORD(WORD,MAXWORD)) != EOF)
     IF (T == LETTER)
       IF((N = BINARY(WORD,KEYTAB,NKEYS)) >= 0)
          KEYTAB[N].KEYCOUNT++;
  FOR (N =0; N < NKEYS; N++)
     IF (KEYTAB[N].KEYCOUNT > 0)
      PRINTF("%4D %S\N",
        KEYTAB[N].KEYCOUNT, KEYTAB[N].KEYWORD);
  \)
  BINARY(WORD, TAB, N) /* FIND WORD IN TAB[0]...TAB[N-1] */
  CHAR *WORD;
  STRUCT KEY TAB[];
  INT N;
  \(
   INT LOW, HIGH, MID, COND;
   
   LOW = 0;
   HIGH = N - 1;
   WHILE (LOW <= HIGH) \(
     MID = (LOW+HIGH) / 2;
     IF((COND = STRCMP(WORD, TAB[MID].KEYWORD)) < 0)
      HIGH = MID - 1;
     ELSE IF (COND > 0)
      LOW = MID + 1;
     ELSE
      RETURN (MID);
   \)
   RETURN(-1);
  \)
 Мы вскоре приведем функцию GETWORD; пока достаточно сказать,
 что она возвращает LETTER каждый раз, как она находит слово,
 и копирует это слово в свой первый аргумент.
     
                           - 135 -
     
     Величина NKEYS - это количество ключевых слов в массиве
 KEYTAB . Хотя мы можем сосчитать это число вручную, гораздо
 легче и надежнее поручить это машине, особенно в том случае,
 если список ключевых слов подвержен изменениям. Одной из
 возможностей было бы закончить список инициализаторов указа-
 нием на нуль и затем пройти в цикле сквозь массив KEYTAB,
 пока не найдется конец.
     Но, поскольку размер этого массива полностью определен к
 моменту компиляции, здесь имеется более простая возможность.
 Число элементов просто есть
 
 SIZE OF KEYTAB / SIZE OF STRUCT KEY
 
 дело в том, что в языке "C" предусмотрена унарная операция
 SIZEOF, выполняемая во время компиляции, которая позволяет
 вычислить размер любого объекта. Выражение
 
 SIZEOF(OBJECT)
 
 выдает целое, равное размеру указанного объекта. (Размер оп-
 ределяется в неспецифицированных единицах, называемых "бай-
 тами", которые имеют тот же размер, что и переменные типа
 CHAR). Объект может быть фактической переменной, массивом и
 структурой, или именем основного типа, как INT или DOUBLE,
 или именем производного типа, как структура. В нашем случае
 число ключевых слов равно размеру массива, деленному на раз-
 мер одного элемента массива. Это вычисление используется в
 утверждении #DEFINE для установления значения NKEYS:
 
 #DEFINE NKEYS (SIZEOF(KEYTAB) / SIZEOF(STRUCT KEY))
 
     Теперь перейдем к функции GETWORD. Мы фактически написа-
 ли более общий вариант функции GETWORD, чем необходимо для
 этой программы, но он не на много более сложен. Функция
 GETWORD возвращает следующее "слово" из ввода, где словом
 считается либо строка букв и цифр, начинающихся с буквы, ли-
 бо отдельный символ. Тип объекта возвращается в качетве зна-
 чения функции; это - LETTER, если найдено слово, EOF для
 конца файла и сам символ, если он не буквенный.
 
  GETWORD(W, LIM)   /* GET NEXT WORD FROM INPUT */
  CHAR *W;
  INT LIM;
  \(
   INT C, T;
   IF (TYPE(C=*W++=GETCH()) !=LETTER) \(
        *W='\0';
        RETURN(C);
   \)
     
                           - 136 -
     
  WHILE (--LIM > 0)  \(
   T = TYPE(C = *W++ = GETCH());
   IF (T ! = LETTER && T ! = DIGIT) \(
        UNGETCH(C);
        BREAK;
   \)
  \)
  *(W-1) - '\0';
  RETURN(LETTER);
  \)
 
 Функция GETWORD использует функции GETCH и UNGETCH, которые
 мы написали в главе 4: когда набор алфавитных символов пре-
 рывается, функция GETWORD получает один лишний символ. В ре-
 зультате вызова UNGETCH этот символ помещается назад во ввод
 для следующего обращения.
     Функция GETWORD обращается к функции TYPE для определе-
 ния типа каждого отдельного символа из файла ввода. Вот ва-
 риант, справедливый только для алфавита ASCII.
 
   TYPE(C)  /* RETURN TYPE OF ASCII CHARACTER */
   INT C;
    \(
   IF (C>= 'A' && C<= 'Z' \!\! C>= 'A' && C<= 'Z')
        RETURN(LETTER);
   ELSE IF (C>= '0' && C<= '9')
        RETURN(DIGIT);
   ELSE
        RETURN(C);
   \)
 
 
 Символические константы LETTER и DIGIT могут иметь любые
 значения, лишь бы они не вступали в конфликт с символами,
 отличными от буквенно-цифровых, и с EOF; очевидно возможен
 следующий выбор
 
      #DEFINE   LETTER   'A'
      #DEFINE   DIGIT   '0'
 
 функция GETWORD могла бы работать быстрее, если бы обращения
 к функции TYPE были заменены обращениями к соответствующему
 массиву TYPE[ ]. В стандартной библиотеке языка "C" предус-
 мотрены макросы ISALPHA и ISDIGIT, действующие необходимым
 образом.
     Упражнение 6-1.
     --------------
     Сделайте такую модификацию функции GETWORD и оцените,
 как изменится скорость работы программы.
     Упражнение 6-2.
     --------------
     Напишите вариант функции TYPE, не зависящий от конкрет-
 ного наборасимволов.
     
                           - 137 -
     
     Упражнение 6-3.
     --------------
     Напишите вариант программы подсчета ключевых слов, кото-
 рый бы не учитывал появления этих слов в заключенных в ка-
 вычки строках.
     
     6.4. Указатели на структуры.
     Чтобы проиллюстрировать некоторые соображения, связанные
 с использованием указателей и массивов структур, давайте
 снова составим программу подсчета ключевых строк, используя
 на этот раз указатели, а не индексы массивов.
     Внешнее описание массива KEYTAB не нужно изменять, но
 функции MAIN и BINARY требуют модификации.
 
     MAIN()   /* COUNT C KEYWORD; POINTER VERSION */
     \(
    INT  T;
    CHAR WORD[MAXWORD];
    STRUCT KEY *BINARY(), *P;
    WHILE ((T = GETWORD(WORD, MAXWORD;) !=EOF)
      IF (T==LETTER)
      IF ((P=BINARY(WORD,KEYTAB,NKEYS)) !=NULL)
              P->KEYCOUNT++;
    FOR (P=KEYTAB; P>KEYTAB + NKEYS; P++)
      IF (P->KEYCOUNT > 0)
   PRINTF("%4D %S/N", P->KEYCOUNT, P->KEYWORD);
     \)
      STRUCT KEY *BINARY(WORD, TAB, N) /* FIND WORD */
     CHAR *WORD   /* IN TAB[0]...TAB[N-1] */
     STRUCT KEY TAB [];
     INT N;
     \(
    INT  COND;
    STRUCT KEY *LOW = &TAB[0];
    STRUCT KEY *HIGH = &TAB[N-1];
    STRUCT KEY *MID;
    WHILE (LOW <= HIGH) \(
   MID = LOW + (HIGH-LOW) / 2;
   IF ((COND = STRCMP(WORD, MID->KEYWORD)) < 0)
         HIGH = MID - 1;
   ELSE IF (COND > 0)
         LOW = MID + 1;
   ELSE
         RETURN(MID);
    \)
    RETURN(NULL);
     \)
 
     Здесь имеется несколько моментов, которые стоит отме-
 тить. Во-первых, описание функции BINARI должно указывать,
 что она возвращает указатель на структуру типа KEY, а не на
 целое; это объявляется как в функции MAIN, так и в BINARY.
 Если функция BINARI находит слово, то она возвращает указа-
 тель на него; если же нет, она возвращает NULL.
     
                           - 138 -
     
     Во-вторых, все обращения к элементам массива KEYTAB осу-
 ществляются через указатели. Это влечет за собой одно сущес-
 твенное изменение в функции BINARY: средний элемент больше
 нельзя вычислять просто по формуле
 
   MID = (LOW + HIGH) / 2
 
 потому что сложение двух указателей не дает какого-нибудь
 полезного результата (даже после деления на 2) и в действи-
 тельности является незаконным. эту формулу надо заменить на
 
   MID = LOW + (HIGH-LOW) / 2
 
 в результате которой MID становится указателем на элемент,
 расположенный посередине между LOW и HIGH.
     Вам также следует разобраться в инициализации LOW и
 HIGH. указатель можно инициализировать адресом ранее опреде-
 ленного объекта; именно как мы здесь и поступили.
     В функции MAIN мы написали
 
   FOR (P=KEYTAB; P < KEYTAB + NKEYS; P++)
 
 Если P является указателем структуры, то любая арифметика с
 P учитывает фактический размер данной структуры, так что P++
 увеличивает P на нужную величину, в результате чего P указы-
 вает на следующий элемент массива структур. Но не считайте,
 что размер структуры равен сумме размеров ее членов, - из-за
 требований выравнивания для различных объектов в структуре
 могут возникать "дыры".
     И, наконец, несколько второстепенный вопрос о форме за-
 писи программы. Если возвращаемая функцией величина имеет
 тип, как, например, в
 
      STRUCT KEY *BINARY(WORD, TAB, N)
 
 Tо может оказаться, что имя функции трудно выделить среди
 текста. В связи с этим иногда используется другой стиль за-
 писи:
 
           STRUCT KEY *
       BINARY(WORD, TAB, N)
 
 Это главным образом дело вкуса; выберите ту форму, которая
 вам нравится, и придерживайтесь ее.
 
     6.5. Структуры, ссылающиеся на себя.
     Предположим, что нам надо справиться с более общей зада-
 чей, состоящей в подсчете числа появлений всех слов в неко-
 тором файле ввода. Так как список слов заранее не известен,
 мы не можем их упорядочить удобным образом и использовать
 бинарный поиск. Мы даже не можем осуществлять последователь-
 ный просмотр при поступлении каждого слова, с тем чтобы ус-
 тановить, не встречалось ли оно ранее; такая программа будет
 работать вечно. (Более точно, ожидаемое время работы растет
 как квадрат числа вводимых слов). Как же нам организовать
 программу, чтобы справиться со списком произвольных слов?
     
                           - 139 -
     
     Одно из решений состоит в том, чтобы все время хранить
 массив поступающих до сих пор слов в упорядоченном виде, по-
 мещая каждое слово в нужное место по мере их поступления.
 OДнако это не следует делать, перемещая слова в линейном
 массиве, - это также потребует слишком много времени. Вместо
 этого мы используем структуру данных, называемую доичным де-
 ревом.
     Каждому новому слову соответствует один "узел" дерева;
 каждый узел содержит:
 указатель текста слова
 ----------------------
 счетчик числа появлений
 -----------------------
 указатель узла левого потомка
 -----------------------------
 указатель узла правого потомка
 ------------------------------
 Никакой узел не может иметь более двух детей; возможно от-
 сутсвие детей или наличие только одного потомка.
     Узлы создаются таким образом, что левое поддерево каждо-
 го узла содержит только те слова, которые меньше слова в
 этом узле, а правое поддерево только те слова, которые боль-
 ше. Чтобы определить, находится ли новое слово уже в дереве,
 начинают с корня и сравнивают новое слово со словом, храня-
 щимся в этом узле. Если слова совпадают, то вопрос решается
 утвердительно. Если новое слово меньше слова в дереве, то
 переходят к рассмотрению левого потомка; в противном случае
 исследуется правый потомок. Если в нужном направлении пото-
 мок отсутствует, то значит новое слово не находится в дереве
 и место этого недостающего потомка как раз и является мес-
 том, куда следует поместить новое слово. Поскольку поиск из
 любого узла приводит к поиску одного из его потомков, то сам
 процесс поиска по существу является рекурсивным. В соответс-
 твии с этим наиболее естественно использовать рекурсивные
 процедуры ввода и вывода.
     Возвращаясь назад к описанию узла, ясно, что это будет
 структура с четырьмя компонентами:
 
 STRUCT TNODE \( /* THE BASIC NODE */
    CHAR *WORD; /* POINTS TO THE TEXT */
    INT   COUNT; /* NUMBER OF OCCURRENCES */
    STRUCT TNODE *LEFT; /* LEFT CHILD */
    STRUCT TNODE *RIGHT; /* RIGHT CHILD */
 \);
 
 Это "рекурсивное" описание узла может показаться рискован-
 ным, но на самом деле оно вполне корректно. Структура не
 имеет права содержать ссылку на саму себя, но
 
 STRUCT TNODE *LEFT;
 
 описывает LEFT как указатель на узел, а не как сам узел.
            
                           - 140 -
     
     Текст самой программы оказывается удивительно маленьким,
 если, конечно, иметь в распоряжении набор написанных нами
 ранее процедур, обеспечивающих нужные действия. Мы имеем в
 виду функцию GETWORD для извлечения каждого слова из файла
 ввода и функцию ALLOC для выделения места для хранения слов.
     Ведущая программа просто считывает слова с помощью функ-
 ции GETWORD и помещает их в дерево, используя функцию TREE.
 
 #DEFINE   MAXWORD   20
 MAIN()    /* WORD FREGUENCY COUNT */
 \(
     STRUCT TNODE *ROOT, *TREE();
     CHAR WORD[MAXWORD];
     INT   T;
     ROOT = NULL;
     WHILE ((T = GETWORD(WORD, MAXWORD)) \! = EOF)
        IF (T == LETTER)
             ROOT = TREE(ROOT, WORD);
     TREEPRINT(ROOT);
 \)
 
     Функция TREE сама по себе проста. Слово передается функ-
 цией MAIN к верхнему уровню (корню) дерева. На каждом этапе
 это слово сравнивается со словом, уже хранящимся в этом уз-
 ле, и с помощью рекурсивного обращения к TREE просачивается
 вниз либо к левому, либо к правому поддереву. В конце концов
 это слово либо совпадает с каким-то словом, уже находящимся
 в дереве (в этом случае счетчик увеличивается на единицу),
 либо программа натолкнется на нулевой указатель, свидетель-
 ствующий о необходимости создания и добавления к дереву но-
 вого узла. В случае создания нового узла функция TREE возв-
 ращает указатель этого узла, который помещается в родитель-
 ский узел.
 
  STRUCT TNODE *TREE(P, W)
         /* INSTALL W AT OR BELOW P */
  STRUCT TNODE *P;
  CHAR *W;
  \(
     STRUCT TNODE *TALLOC();
     CHAR *STRSAVE();
     INT COND;
     IF (P == NULL) \( /* A NEW WORD
        HAS ARRIVED */
          P == TALLOC(); /* MAKE A NEW NODE */
          P->WORD = STRSAVE(W);
          P->COUNT = 1;
          P->LEFT = P->RIGHT = NULL;
  \) ELSE IF ((COND = STRCMP(W, P->WORD)) == 0)
          P->COUNT++;     /* REPEATED WORD */
      ELSE IF (COND < 0)/* LOWER GOES INTO LEFT SUBTREE */
          P->LEFT = TREE(P->LEFT, W);
  ELSE            /* GREATER INTO RIGHT SUBTREE */
          P->RIGHT = TREE(P->RIGHT, W);
  RETURN(P);
  \)        
                           - 141 -
 
     Память для нового узла выделяется функцией TALLOC, явля-
 ющейся адаптацией для данного случая функции ALLOC, написан-
 ной нами ранее. Она возвращает указатель свободного прост-
 ранства, пригодного для хранения нового узла дерева. (Мы
 вскоре обсудим это подробнее). Новое слово копируется функ-
 цией STRSAVE в скрытое место, счетчик инициализируется еди-
 ницей, и указатели обоих потомков полагаются равными нулю.
 Эта часть программы выполняется только при добавлении нового
 узла к ребру дерева. Мы здесь опустили проверку на ошибки
 возвращаемых функций STRSAVE и TALLOC значений (что неразум-
 но для практически работающей программы).
     Функция TREEPRINT печатает дерево, начиная с левого под-
 дерева; в каждом узле сначала печатается левое поддерево
 (все слова, которые младше этого слова), затем само слово, а
 затем правое поддерево (все слова, которые старше). Если вы
 неуверенно оперируете с рекурсией, нарисуйте дерево сами и
 напечатайте его с помощью функции TREEPRINT ; это одна из
 наиболее ясных рекурсивных процедур, которую можно найти.
 
  TREEPRINT (P) /* PRINT TREE  P  RECURSIVELY */
  STRUCT TNODE *P;
  \(
     IF (P != NULL)    \(
        TREEPRINT (P->LEFT);
        PRINTF("%4D %S\N", P->COUNT, P->WORD);
        TREEPRINT (P->RIGHT);
     \)
 \)
 
     Практическое замечание: если дерево становится "несба-
 лансированным" из-за того, что слова поступают не в случай-
 ном порядке, то время работы программы может расти слишком
 быстро. В худшем случае, когда поступающие слова уже упоря-
 дочены, настоящая программа осуществляет дорогостоящую ими-
 тацию линейного поиска. Существуют различные обобщения дво-
 ичного дерева, особенно 2-3 деревья и AVL деревья, которые
 не ведут себя так "в худших случаях", но мы не будем здесь
 на них останавливаться.
     Прежде чем расстаться с этим примером, уместно сделать
 небольшое отступление в связи с вопросом о распределении па-
 мяти. Ясно, что в программе желательно иметь только один
 распределитель памяти, даже если ему приходится размещать
 различные виды объектов. Но если мы хотим использовать один
 распределитель памяти для обработки запросов на выделение
 памяти для указателей на переменные типа CHAR и для указате-
 лей на STRUCT TNODE, то при этом возникают два вопроса. Пер-
 вый: как выполнить то существующее на большинстве реальных
 машин ограничение, что объекты определенных типов должны
 удовлетворять требованиям выравнивания (например, часто це-
 лые должны размещаться в четных адресах)? Второй: как орга-
 низовать описания, чтобы справиться с тем, что функция ALLOC
 должна возвращать различные виды указателей ?
     
                           - 142 -
     
     
     Вообще говоря, требования выравнивания легко выполнить
 за счет выделения некоторого лишнего пространства, просто
 обеспечив то, чтобы распределитель памяти всегда возвращал
 указатель, удовлетворяющий всем ограничениям выравнивания.
 Например, на PDP-11 достаточно, чтобы функция ALLOC всегда
 возвращала четный указатель, поскольку в четный адрес можно
 поместить любой тип объекта. единственный расход при этом -
 лишний символ при запросе на нечетную длину. Аналогичные
 действия предпринимаются на других машинах. Таким образом,
 реализация ALLOC может не оказаться переносимой, но ее ис-
 пользование будет переносимым. Функция ALLOC из главы 5 не
 предусматривает никакого определенного выравнивания; в главе
 8 мы продемонстрируем, как правильно выполнить эту задачу.
     Вопрос описания типа функции ALLOC является мучительным
 для любого языка, который серьезно относится к проверке ти-
 пов. Лучший способ в языке "C" - объявить, что ALLOC возвра-
 щает указатель на переменную типа CHAR, а затем явно преоб-
 разовать этот указатель к желаемому типу с помощью операции
 перевода типов. Таким образом, если описать P в виде
 
     CHAR *P;
 то
     (STRUCT TNODE *) P
 
 преобразует его в выражениях в указатель на структуру типа
 TNODE . Следовательно, функцию TALLOC можно записать в виде:
 
 STRUCT TNODE *TALLOC()
 \(
    CHAR *ALLOC();
 
    RETURN ((STRUCT TNODE *) ALLOC(SIZEOF(STRUCT TNODE)));
 \)
 
 
 это более чем достаточно для работающих в настоящее время
 компиляторов, но это и самый безопасный путь с учетом будую-
 щего.
     Упражнение 6-4.
     ----------------
     Напишите программу, которая читает "C"-программу и печа-
 тает в алфавитном порядке каждую группу имен переменных, ко-
 торые совпадают в первых семи символах, но отличаются где-то
 дальше. (Сделайте так, чтобы 7 было параметром).
     Упражнение 6-5.
     ----------------
     Напишите программу выдачи перекрестных ссылок, т.е.
 Программу, которая печатает список всех слов документа и для
 каждого из этих слов печатает список номеров строк, в кото-
 рые это слово входит.
     Упражнение 6-6.
     ----------------
     Напишите программу, которая печатает слова из своего
 файла ввода, расположенные в порядке убывания частоты их по-
 явления. Перед каждым словом напечатайте число его появле-
 ний.       
                           - 143 -
     
      6.6. Поиск в таблице.
     Для иллюстрации дальнейших аспектов использования струк-
 тур в этом разделе мы напишем программу, представляющую со-
 бой содержимое пакета поиска в таблице. Эта программа явля-
 ется типичным представителем подпрограмм управления символь-
 ными таблицами макропроцессора или компилятора. Рассмотрим,
 например, оператор #DEFINE языка "C". Когда встречается
 строка вида
 
 #DEFINE YES    1
 
 то имя YES и заменяющий текст 1 помещаются в таблицу. Позд-
 нее, когда имя YES появляется в операторе вида
 
 INWORD = YES;
 
 Oно должно быть замещено на 1.
     Имеются две основные процедуры, которые управляют имена-
 ми и заменяющими их текстами. Функция INSTALL(S,T) записыва-
 ет имя S и заменяющий текст T в таблицу; здесь S и T просто
 символьные строки. Функция LOOKUP(S) ищет имя S в таблице и
 возвращает либо указатель того места, где это имя найдено,
 либо NULL, если этого имени в таблице не оказалось.
     При этом используется поиск по алгоритму хеширования -
 поступающее имя преобразуется в маленькое положительное чис-
 ло, которое затем используется для индексации массива указа-
 телей. Элемент массива указывает на начало цепочных блоков,
 описывающих имена, которые имеют это значение хеширования.
 Если никакие имена при хешировании не получают этого значе-
 ния, то элементом массива будет NULL.
     Блоком цепи является структура, содержащая указатели на
 соответствующее имя, на заменяющий текст и на следующий блок
 в цепи. Нулевой указатель следующего блока служит признаком
 конца данной цепи.
 
 STRUCT NLIST  \(  /* BASIC TABLE ENTRY */
      CHAR *NAME;
      CHAR *DEF;
      STRUCT NLIST *NEXT; /* NEXT ENTRY IN CHAIN */
 \);
 
 Массив указателей это просто
 
  DEFINE    HASHSIZE     100
  TATIC STRUCT NLIST *HASHTAB[HASHSIZE] /* POINTER TABLE */
 
     Значение функции хеширования, используемой обеими функ-
 циями LOOKUP и INSTALL , получается просто как остаток от
 деления суммы символьных значений строки на размер массива.
 (Это не самый лучший возможный алгоритм, но его достоинство
 состоит в исключительной простоте).
            
                           - 144 -
     
  HASH(S)   /* FORM HASH VALUE FOR STRING */
  CHAR *S;
  \(
   INT HASHVAL;
 
   FOR (HASHVAL = 0; *S != '\0'; )
       HASHVAL += *S++;
   RETURN(HASHVAL % HASHSIZE);
  \)
 
     В результате процесса хеширования выдается начальный ин-
 декс в массиве HASHTAB ; если данная строка может быть
 где-то найдена, то именно в цепи блоков, начало которой ука-
 зано там. Поиск осуществляется функцией LOOKUP. Если функция
 LOOKUP находит, что данный элемент уже присутствует, то она
 возвращает указатель на него; если нет, то она возвращает
 NULL.
 
 STRUCT NLIST *LOOKUP(S) /* LOOK FOR S IN HASHTAB */
 CHAR *S;
 \(
 STRUCT NLIST *NP;
 
 FOR (NP = HASHTAB[HASH(S)]; NP != NULL;NP=NP->NEXT)
     IF (STRCMP(S, NP->NAME) == 0)
   RETURN(NP);  /* FOUND IT */
 RETURN(NULL);    /* NOT FOUND */
 
 
     Функция INSTALL использует функцию LOOKUP для определе-
 ния, не присутствует ли уже вводимое в данный момент имя;
 если это так, то новое определение должно вытеснить старое.
 В противном случае создается совершенно новый элемент. Если
 по какой-либо причине для нового элемента больше нет места,
 то функция INSTALL возвращает NULL.
 
    STRUCT NLIST *INSTALL(NAME, DEF) /* PUT (NAME, DEF) */
    CHAR *NAME, *DEF;
    \(
  STRUCT NLIST *NP, *LOOKUP();
  CHAR *STRSAVE(), *ALLOC();
  INT HASHVAL;
 
  IF((NP = LOOKUP(NAME)) == NULL) \( /* NOT FOUND */
   NP = (STRUCT NLIST *) ALLOC(SIZEOF(*NP));
   IF (NP == NULL)
      RETURN(NULL);
   IF ((NP->NAME = STRSAVE(NAME)) == NULL)
      RETURN(NULL);
   HASHVAL = HASH(NP->NAME);
   NP->NEXT = HASHTAB[HASHVAL];
   HASHTAB[HASHVAL] = NP;
  \) ELSE        /* ALREADY THERE */
       FREE((NP->DEF);/* FREE PREVIOUS DEFINITION */
  IF ((NP->DEF = STRSAVE(DEF)) == NULL)
       RETURN (NULL);
  RETURN(NP);
    \)      
     
                           - 145 -
 
     Функция STRSAVE просто копирует строку, указанную в ка-
 честве аргумента, в место хранения, полученное в результате
 обращения к функции ALLOC. Мы уже привели эту функцию в гла-
 ве 5. Так как обращение к функции ALLOC и FREE могут проис-
 ходить в любом порядке и в связи с проблемой выравнивания,
 простой вариант функции ALLOC из главы 5 нам больше не под-
 ходит; смотрите главы 7 и 8.
     Упражнение 6-7.
     ---------------
     Напишите процедуру, которая будет удалять имя и опреде-
 ление из таблицы, управляемой функциями LOOKUP и INSTALL.
     Упражнение 6-8.
     ---------------
     Разработайте простую, основанную на функциях этого раз-
 дела, версию процессора для обработки конструкций #DEFINE ,
 пригодную для использования с "C"-программами. Вам могут
 также оказаться полезными функции GETCHAR и UNGETCH.
 
      6.7. Поля.
     Когда вопрос экономии памяти становится очень существен-
 ным, то может оказаться необходимым помещать в одно машинное
 слово несколько различных объектов; одно из особенно расп-
 росраненных употреблений - набор однобитовых признаков в
 применениях, подобных символьным таблицам компилятора. внеш-
 не обусловленные форматы данных, такие как интерфейсы аппа-
 ратных средств также зачастую предполагают возможность полу-
 чения слова по частям.
     Представьте себе фрагмент компилятора, который работает
 с символьной таблицей. С каждым идентификатором программы
 связана определенная информация, например, является он или
 нет ключевым словом, является ли он или нет внешним и/или
 статическим и т.д. Самый компактный способ закодировать та-
 кую информацию - поместить набор однобитовых признаков в от-
 дельную переменную типа CHAR или INT.
     Обычный способ, которым это делается, состоит в опреде-
 лении набора "масок", отвечающих соответствущим битовым по-
 зициям, как в
 
   #DEFINE   KEYWORD   01
   #DEFINE   EXTERNAL  02
   #DEFINE   STATIC    04
 
 (числа должны быть степенями двойки). Тогда обработка битов
 сведется к "жонглированию битами" с помощью операций сдвига,
 маскирования и дополнения, описанных нами в главе 2.
     Некоторые часто встречающиеся идиомы:
 
   FLAGS \!= EXTERNAL  \! STATIC;
 
 включает биты EXTERNAL и STATIC в FLAGS, в то время как
 
   FLAGS &= \^(еXTERNAL \! STATIC);
            
                           - 146 -
     
 их выключает, а
 
   IF ((FLAGS & (EXTERNAL \! STATIC)) == 0) ...
 
 истинно, если оба бита выключены.
     Хотя этими идиомами легко овладеть, язык "C" в качестве
 альтернативы предлагает возможность определения и обработки
 полей внутри слова непосредственно, а не посредством побито-
 вых логических операций. Поле - это набор смежных битов
 внутри одной переменной типа INT. Синтаксис определения и
 обработки полей основывается на структурах. Например, сим-
 вольную таблицу конструкций #DEFINE, приведенную выше, можно
 бы было заменить определением трех полей:
 
     STRUCT  \(
   UNSIGNED IS_KEYWORD : 1;
   UNSIGNED IS_EXTERN  : 1;
   UNSIGNED IS_STATIC  : 1;
     \)    FLAGS;
 
 Здесь определяется переменная с именем FLAGS, которая содер-
 жит три 1-битовых поля. Следующее за двоеточием число задает
 ширину поля в битах. Поля описаны как UNSIGNED, чтобы под-
 черкнуть, что они действительно будут величинами без знака.
     На отдельные поля можно ссылаться, как FLAGS.IS_STATIE,
 FLAGS. IS_EXTERN, FLAGS.IS_KEYWORD И т.д., то есть точно так
 же, как на другие члены структуры. Поля ведут себя подобно
 небольшим целым без знака и могут участвовать в арифметичес-
 ких выражениях точно так же, как и другие целые. Таким обра-
 зом, предыдущие примеры более естественно переписать так:
 
     FLAGS.IS_EXTERN = FLAGS.IS_STATIC = 1;
 
 для включения битов;
 
     FLAGS.IS_EXTERN = FLAGS.IS_STATIC = 0;
 
 для выключения битов;
 
   IF (FLAGS.IS_EXTERN == 0 &&FLAGS.IS_STATIC == 0)...
 
 для их проверки.
     Поле не может перекрывать границу INT; если указанная
 ширина такова, что это должно случиться, то поле выравнива-
 ется по границе следующего INT. Полям можно не присваивать
 имена; неименованные поля (только двоеточие и ширина) ис-
 пользуются для заполнения свободного места. Чтобы вынудить
 выравнивание на границу следующего INT, можно использовать
 специальную ширину 0.
     
                           - 147 -
     
     При работе с полями имеется ряд моментов, на которые
 следует обратить внимание. По-видимому наиболее существенным
 является то, что отражая природу различных аппаратных сред-
 ств, распределение полей на некоторых машинах осуществляется
 слева направо, а на некоторых справа налево. Это означает,
 что хотя поля очень полезны для работы с внутренне опреде-
 ленными структурами данных, при разделении внешне определяе-
 мых данных следует тщательно рассматривать вопрос о том, ка-
 кой конец поступает первым.
     Другие ограничения, которые следует иметь в виду: поля
 не имеют знака; они могут храниться только в переменных типа
 INT (или, что эквивалентно, типа UNSIGNED); они не являются
 массивами; они не имеют адресов, так что к ним не применима
 операция &.
 
      6.8. Объединения.
     Oбъединения - это переменная, которая в различные момен-
 ты времени может содержать объекты разных типов и размеров,
 причем компилятор берет на себя отслеживание размера и тре-
 бований выравнивания. Объединения представляют возможность
 работать с различными видами данных в одной области памяти,
 не вводя в программу никакой машинно-зависимой информации.
     В качестве примера, снова из символьной таблицы компиля-
 тора, предположим, что константы могут быть типа INT , FLOAT
 или быть указателями на символы. значение каждой конкретной
 константы должно храниться в переменной соотвествующего ти-
 па, но все же для управления таблицей самым удобным было бы,
 если это значение занимало бы один и тот же объем памяти и
 хранилось в том же самом месте независимо от его типа. это и
 является назначением объединения - выделить отдельную пере-
 менную, в которой можно законно хранить любую одну из пере-
 менных нескольких типов. Как и в случае полей, синтаксис ос-
 новывается на структурах.
 
   UNION U_TAG \(
   INT IVAL;
   FLOAT FVAL;
   CHAR *PVAL;
   \) UVAL;
 
 Переменная UVAL будет иметь достаточно большой размер,чтобы
 хранить наибольший из трех типов, независимо от машины, на
 которой осуществляется компиляция, - программа не будет за-
 висить от характеристик аппаратных средств. Любой из этих
 трех типов может быть присвоен UVAR и затем использован в
 выражениях, пока такое использование совместимо: извлекаемый
 тип должен совпадать с последним помещенным типом. Дело
 программиста - следить за тем, какой тип хранится в объеди-
 нении в данный момент; если что-либо хранится как один тип,
 а извлекается как другой, то результаты будут зависеть от
 используемой машины.
     
                           - 149 -
     
     Синтаксически доступ к членам объединения осуществляется
 следующим образом:
 
   имя объединения.член
   --------------------
 или
   указатель объединения ->член
   ----------------------------
 
 то есть точно так же, как и в случае структур. если для отс-
 леживания типа, хранимого в данный момент в UVAL, использу-
 ется переменная UTYPE, то можно встретить такой участок
 программы:
 
   IF (UTYPE == INT)
   PRINTF("%D\N", UVAL.IVAL);
   ELSE IF (UTYPE == FLOAT)
   PRINTF("%F\N", UVAL.FVAL);
   ELSE IF (UTYPE == STRING)
   PRINTF("%S\N", UVAL.PVAL);
   ELSE
   PRINTF("BAD TYPE %D IN UTYPE\N", UTYPE);
 
     Объединения могут появляться внутри структур и массивов
 и наоборот. Запись для обращения к члену объединения в
 структуре (или наоборот) совершенно идентична той, которая
 используется во вложенных структурах. например, в массиве
 структур, определенным следующим образом
 
  STRUCT \(
  CHAR *NAME;
  INT FLAGS;
  INT UTYPE;
  UNION \(
  INT IVAL;
  FLOAT FVAL;
  CHAR *PVAL;
  \) UVAL;
   \) SYMTAB[NSYM];
 
 на переменную IVAL можно сослаться как
 
   SYMTAB[I].UVAL.IVAL
 
 а на первый символ строки PVAL как
 
   *SYMTAB[I].UVAL.PVAL
 
    В сущности объединение является структурой, в которой все
 члены имеют нулевое смещение. Сама структура достаточно ве-
 лика, чтобы хранить "самый широкий" член, и выравнивание
 пригодно для всех типов, входящих в объединение. Как и в
 случае структур, единственными операциями, которые в настоя-
 щее время можно проводить с объединениями, являются доступ к
     
                           - 150 -
     
 члену и извлечение адреса; объединения не могут быть присво-
 ены, переданы функциям или возвращены ими. указатели объеди-
 нений можно использовать в точно такой же манере, как и ука-
 затели структур.
    Программа распределения памяти, приводимая в главе 8 ,
 показывает, как можно использовать объединение, чтобы сде-
 лать некоторую переменную выровненной по определенному виду
 границы памяти.
 
    6.9. Определение типа
    В языке "C" предусмотрена возможность, называемая TYPEDEF
 для введения новых имен для типов данных. Например, описание
 
 TYPEDEF INT LENGTH;
 
 делает имя LENGTH синонимом для INT. "Тип" LENGTH может быть
 использован в описаниях, переводов типов и т.д. Точно таким
 же образом, как и тип INT:
 
    LENGTH   LEN, MAXLEN;
    LENGTH   *LENGTHS[];
 
 Аналогично описанию
 
     TYPEDEF CHAR *STRING;
 
 делает STRING синонимом для CHAR*, то есть для указателя на
 символы, что затем можно использовать в описаниях вида
 
     STRING P, LINEPTR[LINES], ALLOC();
 
     Обратите внимание, что объявляемый в конструкции TYPEDEF
 тип появляется в позиции имени переменной, а не сразу за
 словом TYPEDEF. Синтаксически конструкция TYPEDEF подобна
 описаниям класса памяти EXTERN, STATIC и т. Д. мы также ис-
 пользовали прописные буквы, чтобы яснее выделить имена.
     В качестве более сложного примера мы используем конст-
 рукцию TYPEDEF для описания узлов дерева, рассмотренных ра-
 нее в этой главе:
 
  TYPEDEF STRUCT TNODE \(     /* THE BASIC NODE */
  CHAR *WORD; /* POINTS TO THE TEXT */
  INT COUNT; /* NUMBER OF OCCURRENCES */
  STRUCT TNODE *LEFT;     /* LEFT CHILD */
  STRUCT TNODE *RIGHT;    /* RIGHT CHILD */
  \) TREENODE, *TREEPTR;
 
 В результате получаем два новых ключевых слова: TREENODE
 (структура) и TREEPTR (указатель на структуру). Тогда функ-
 цию TALLOC можно записать в виде
            
                           - 151 -
  TREEPTR TALLOC()
  \(
     CHAR *ALLOC();
     RETURN((TREEPTR) ALLOC(SIZEOF(TREENODE)));
  \)
 
     Необходимо подчеркнуть, что описание TYPEDEF не приводит
 к созданию нового в каком-либо смысле типа; оно только до-
 бавляет новое имя для некоторого существующего типа. при
 этом не возникает и никакой новой семантики: описанные таким
 способом переменные обладают точно теми же свойствами, что и
 переменные, описанные явным образом. По существу конструкция
 TYPEDEF сходна с #DEFINE за исключением того, что она интер-
 претируется компилятором и потому может осуществлять подста-
 новки текста, которые выходят за пределы возможностей мак-
 ропроцессора языка "C". Например,
 
  TYPEDEF INT (*PFI) ();
 
 создает тип PFI для "указателя функции, возвращающей значе-
 ние типа INT", который затем можно было бы использовать в
 программе сортировки из главы 5 в контексте вида
 
 PFI STRCMP, NUMCMP, SWAP;
 
 
     Имеются две основные причины применения описаний
 TYPEDEF. Первая причина связана с параметризацией программы,
 чтобы облегчить решение проблемы переносимости. Если для ти-
 пов данных, которые могут быть машинно-зависимыми, использо-
 вать описание TYPEDEF, то при переносе программы на другую
 машину придется изменить только эти описания. Одна из типич-
 ных ситуаций состоит в использовании определяемых с помощью
 TYPEDEF имен для различных целых величин и в последующем
 подходящем выборе типов SHORT, INT и LONG для каждой имею-
 щейся машины.
 Второе назначение TYPEDEF состоит в обеспечении лучшей доку-
 ментации для программы - тип с именем TREEPTR может оказать-
 ся более удобным для восприятия, чем тип, который описан
 только как указатель сложной структуры.
 И наконец, всегда существует вероятность, что в будущем ком-
 пилятор или некоторая другая программа, такая как LINT, смо-
 жет использовать содержащуюся в описаниях TYPEDEF информацию
 для проведения некоторой дополнительной проверки программы.
