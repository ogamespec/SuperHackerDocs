                           - 185 -
     
     9. Приложение А: справочное руководство по языку 'C'
 
     9.1. Введение
 
 
 
     Это руководство описывает язык 'с' для компьютеров DEC
 PDP-11, HONEYWELL 6000, IBM система/370 и INTERDATA 8/32.
 там, где есть расхождения, мы сосредотачиваемся на версии
 для PDP-11, стремясь в то же время указать детали, которые
 зависят от реализации. За малым исключением, эти расхождения
 непосредственно обусловлены основными свойствами используе-
 мого аппаратного оборудования; различные компиляторы обычно
 вполне совместимы.
 
    10. Лексические соглашения
     Имеется шесть классов лексем: идентификаторы, ключевые
 слова, константы, строки, операции и другие разделители.
 Пробелы, табуляции , новые строки и комментарии (совместно,
 "пустые промежутки"), как описано ниже, игнорируются, за ис-
 ключением тех случаев, когда они служат разделителями лек-
 сем. Необходим какой-то пустой промежуток для разделения
 идентификаторов, ключевых слов и констант, которые в против-
 ном случае сольются.
     Если сделан разбор входного потока на лексемы вплоть до
 данного символа, то в качестве следующей лексемы берется са-
 мая длинная строка символов, которая еще может представлять
 собой лексему.
     10.1. Комментарии
     Комментарий открывается символами /* и заканчивается
 символами /*. Комментарии не вкладываются друг в друга.
 
     10.2. Идентификаторы (имена)
     Идентификатор - это последовательность букв и цифр; пер-
 вый символ должен быть буквой. Подчеркивание _ считается
 буквой. Буквы нижнего и верхнего регистров различаются. зна-
 чащими являются не более, чем первые восемь символов, хотя
 можно использовать и больше. На внешние идентификаторы, ко-
 торые используются различными ассемблерами и загрузчиками,
 накладыватся более жесткие ограничения:
 
     DEC PDP-11             7 символов, 2 регистра
     HONEYWELL 6000         6 символов, 1 регистр
     IBM 360/370            7 символов, 1 регистр
     INTERDATA 8/32         8 символов, 2 регистра
            
                           - 186 -
     
      10.3. Ключевые слова
 
     Следующие идентификаторы зарезервированы для использова-
 ния в качестве ключевых слов и не могут использоваться иным
 образом:
 
      INT      EXTERN      ELSE
      CHAR      REGISTER      FOR
      FLOAT      TYPEDEF      DO
      DOUBLE      STATIC      WHILE
      STRUCT      GOTO      SWITCH
      UNION      RETURN      CASE
      LONG      SIZEOF      DEFAULT
      SHORT      BREAK      ENTRY
      UNSIGNED    CONTINUE
     *AUTO      IF
 
 Ключевое слово ENTRY в настоящее время не используется ка-
 ким-либо компилятором; оно зарезервировано для использования
 в будущем. В некоторых реализациях резервируется также слова
 FORTRAN и ASM
      10.4. Константы
 Имеется несколько видов констант, которые перечислены ниже.
 В пункте 10.6 резюмируются характеристики аппаратных сред-
 ств, которые влияют на размеры.
     10.4.1. Целые константы
 
 
 
     Целая константа, состоящая из последовательности цифр,
 считается восьмеричной, если она начинается с 0 (цифра
 нуль), и десятичной в противном случае. Цифры 8 и 9 имеют
 восьмеричные значения 10 и 11 соответственно. Последователь-
 ность цифр, которой предшествуют символы 0х (нуль, х-малень-
 кое) или 0х (нуль х-большое), рассматривается как шестнадца-
 тиричное целое. Шестнадцатиричные цифры включают буквы от а
 (маленькое) или а (большое) до F (маленькое) или F (большое)
 со значениями от 10 до 15. Десятичная константа, величина
 которой превышает наибольшее машинное целое со знаком, счи-
 тается длинной; восмеричная или шестнадцатиричная константа,
 которое превышает наибольшее машинное целое без знака, также
 считается длинной.
     10.4.2. Явные длинные константы
     Десятичная, восмеричная или шестнадцатиричная константа,
 за которой непосредственно следует L (эль-маленькое) или L
 (эль-большое), является длинной константой. Как обсуждается
 ниже, на некоторых машинах целые и длинные значения могут
 рассматриваться как идентичные.
     10.4.3. Символьные константы
     Символьная константа - это символ, заключенный в одиноч-
 ные кавычки, как, например, 'X'. Значением символьной конс-
 танты является численное значение этого символа в машинном
 представлении набора символов.
     
                           - 187 -
     
     Некоторые неграфические символы, одиночная кавычка ' и
 обратная косая черта \ могут быть представлены в соответст-
 вии со следующей таблицей условных последовательностей:
 
   новая строка                      NL/LF/    \N
   горизонтальная табуляция          HT        \T
   символ возврата на одну позицию   BS        \B
   возврат каретки                   CR        \R
   переход на новую страницу         FF        \F
   обратная косая черта              \         \\
   одиночная кавычка                 '         \'
   комбинация битов                  DDD       \DDD
 
     Условная последовательность \DDD состоит из обратной ко-
 сой черты, за которой следуют 1,2 или 3 восмеричных цифры,
 которые рассмативаются как задающие значение желаемого сим-
 вола. Специальным случаем этой конструкции является последо-
 вательность \0 (за нулем не следует цифра), которая опреде-
 ляет символ NUL. если следующий за обратной косой чертой
 символ не совпадает с одним из указанных, то обратная косая
 черта игнорируется.
     10.4.4. Плавающие константы
     Плавающая константа состоит из целой части, десятичной
 точки, дробной части, буквы E (маленькая) или E (большая) и
 целой экспоненты с необязательным знаком. Как целая, так и
 дробная часть являются последовательностью цифр. Либо целая,
 либо дробная часть (но не обе) может отсутствовать; либо де-
 сятичная точка, либо е (маленькая) и экспонента (но не то и
 другое одновременно) может отсутствовать. Каждая плавающая
 константа считается имеющей двойную точность.
     10.5. Строки
     Строка - это последовательность символов, заключенная в
 двойные кавычки, как, наприимер,"...". Строка имеет тип
 "массив массивов" и класс памяти STATIC (см. Пункт 4 ниже).
 Строка инициализирована указанными в ней символами. Все
 строки, даже идентично записанные, считаются различными.
 Компилятор помещает в конец каждой строки нулевой байт \0, с
 тем чтобы просматривающая строку программа могла определить
 ее конец. Перед стоящим внутри строки символом двойной ка-
 вычки " должен быть поставлен символ обратной косой черты \;
 кроме того, могут использоваться те же условия последова-
 тельности, что и в символьных константах. И последнее, об-
 ратная косая черта \, за которой непосредственно следует
 символ новой строки, игнорируется.
     
                           - 188 -
     
     10.6. Характеристики аппаратных средств
     Следующая ниже таблица суммирует некоторые свойства ап-
 паратного оборудования, которые меняются от машины к машине.
 Хотя они и влияют на переносимость программ, на практике они
 представляют маленькую проблему, чем это может казаться за-
 ранее.
           Таблица 1
  -------------------------------------------------------
    DEC PDP-11   HONEYWELL      IBM 370    INTERDATA 8/32
    ASCII        ASCII          EBCDIC     ASCII
  CHAR   8 BITS  9 BITS         8 BITS     8 BITS
  INT    16      36             32         32
  SHORT  16      36             16         16
  LONG   32      36             32         32
  FLOAT  32      36             32         32
  DOUBLE 64      72             64         64
  RANGE -38/+38 -38/+38         -76/+76    -76/+76
 --------------------------------------------------------
     11. Синтаксическая нотация
 
     В используемой в этом руководстве синтаксической нотации
 синтаксические категории выделяются курсивом (прим. перев.:
 в настоящее время синтексические категории вместо курсивом
 выделяются подчеркиванием), а литерные слова и символы -
 жирным шрифтом. Альтернативные категории перечисляются на
 отдельных строчках. Необязательный символ, терминальный или
 нетерминальный, указывается индексом "необ", так что
 
    \( выражение
     --------- необ \)
     
 указывает на необязательное выражение, заключенное в фигур-
 ных скобках. Синтаксис суммируется в пункте 18.
 
    12. Что в имене тебе моем?
     Язык "C" основывает интерпретацию идентификатора на двух
 признаках идентификатора: его классе памяти и его типе.
 Класс памяти определяет место и время хранения памяти, свя-
 занной с идентификатором; тип определяет смысл величин, на-
 ходящихся в памяти, определенной под идентификатором.
     Имеются четыре класса памяти: автоматическая, статичес-
 кая, внешняя и регистровая. Автоматические переменные явля-
 ются локальными для каждого вызова блока и исчезают при вы-
 ходе из этого блока. Статические переменные являются локаль-
 ными, но сохраняют свои значения для следующего входа в блок
 даже после того, как управление передается за пределы блока.
 Внешние переменные существуют и сохраняют свои значения в
 течение выполнения всей программы и могут использоваться для
 связи между функциями, в том числе и между независимо ском-
 пилированными функциями. Регистровые переменные хранятся
 (ели это возможно) в быстрых регистрах машины; подобно авто-
 матическим переменным они являются локальными для каждого
 блока и исчезают при выходе из этого блока.
     
                           - 189 -
     
     В языке "C" предусмотрено несколько основных типов
 объектов:
     объекты, написанные как символы (CHAR), достаточно вели-
 ки, чтобы хранить любой член из соответствующего данной реа-
 лизации внутреннего набора символов, и если действительный
 символ из этого набора символов хранится в символьной пере-
 менной, то ее значение эквивалентно целому коду этого симво-
 ла. В символьных переменных можно хранить и другие величины,
 но реализация будет машинно-зависимой.
     Можно использовать до трех размеров целых, описываемых
 как SHORT INT, INT и LONG INT. Длинные целые занимают не
 меньше памяти, чем короткие, но в конкретной реализации мо-
 жет оказаться, что либо короткие целые, либо длинные целые,
 либо те и другие будут эквивалентны простым целым. "Простые"
 целые имеют естественный размер, предусматриваемый архиитек-
 турой используемой машины; другие размеры вводятся для удво-
 летворения специальных потребностей.
     Целые без знака, описываемые как UNSIGNED, подчиняются
 законам арифметики по модулю 2**N, где N - число битов в их
 представлении. (На PDP-11 длинные величины без знака не пре-
 дусмотрены).
     Плавающие одинарной точности (FLOAT) и плавающие двойной
 точности (DOUBLE) в некоторых реализациях могут быть синони-
 мами.
     Поскольку объекты упомянутых выше типов могут быть ра-
 зумно интерпретированы как числа, эти типы будут называться
 арифметическими. типы CHAR и INT всех размеров совместно бу-
 дут называться целочисленными. Типы FLOAT и DOUBLE совместно
 будут называться плавающими типами.
     Кроме основных арифметических типов существует концепту-
 ально бесконечный класс производных типов, которые образуют-
 ся из основных типов следующим образом:
      массивы объектов большинства типов;
      функции, которые возвращают объекты заданного типа;
      указатели на объекты данного типа;
      структуры, содержащие последовательность объектов
      различных типов;
      объединения, способные содержать один из нескольких
        объектов различных типов.
     Вообще говоря, эти методы построения объектов могут при-
 меняться рекурсивно.
 
     13. Объекты и L-значения
     Объект является доступным обработке участком памяти;
 L-значение - это выражение, ссылающееся на объект. Очевидным
 примером выражения L-значения является идентификатор. Сущес-
 твуют операции, результатом которых являются L-значения; ес-
 ли, например, E - выражение указанного типа, то *E является
 выражением L-значения, ссылающимся на объект E. Название
 "L-значение" происходит от выражения присваивания E1=E2, в
 котором левая часть должна быть выражением L-значения. При
 последующем обсуждении каждой операции будет указываться,
 ожидает ли она операндов L-значения и выдает ли она L-значе-
 ние.       
                           - 190 -
 
     14. Преобразования
 
     Ряд операций может в зависимости от своих операндов вы-
 зывать преобразование значение операнда из одного типа в
 другой. В этом разделе объясняются результаты, которые сле-
 дует ожидать от таких преобразований. В п. 14.6 Подводятся
 итоги преобразований, требуемые большинством обычных опера-
 ций; эти сведения дополняются необходимым образом при обсуж-
 дении каждой операции.
 
     14.1. Символы и целые
     Символ или короткое целое можно использовать всюду, где
 можно использовать целое. Во всех случаях значение преобра-
 зуется к целому. Преобразование более короткого целого к бо-
 лее длинному всегда сопровождается знаковым расширением; це-
 лые являются величинами со знаком. Осуществляется или нет
 знаковое расширение для символов, зависит от используемой
 машины, но гарантируется, что член стандартного набора сим-
 волов неотрицателен. из всех машин, рассматриваемых в этом
 руководстве, только PDP-11 осуществляет знаковое расширение.
 область значений символьных переменных на PDP-11 меняется от
 -128 до 127; символы из набора ASC11 имеют положительные
 значения. Символьная константа, заданная с помощью восьме-
 ричной условной последовательности, подвергается знаковому
 расширению и может оказаться отрицательной; например, '\377'
 имеет значение -1.
     Когда более длинное целое преобразуется в более короткое
 или в CHAR, оно обрезается слева; лишние биты просто отбра-
 сываются.
 
     14.2. Типы FLOAT и DOUBLE
     Вся плавающая арифметика в "C" выполняется с двойной
 точностью каждый раз, когда объект типа FLOAT появляется в
 выражении, он удлиняется до DOUBLE посредством добавления
 нулей в его дробную часть. когда объект типа DOUBLE должен
 быть преобразован к типу FLOAT, например, при присваивании,
 перед усечением DOUBLE округляется до длины FLOAT.
     14.3. Плавающие и целочисленные величины
     Преобразование плавающих значений к целочисленному типу
 имеет тенденцию быть до некоторой степени машинно-зависимым;
 в частности направление усечения отрицательных чисел меняет-
 ся от машине к машине. Результат не определен, если значение
 не помещается в предоставляемое пространство.
     Преобразование целочисленных значений в плавающие выпол-
 няется без осложнений. Может произойти некоторая потеря точ-
 ности, если для результата не содержится достаточного коли-
 чества битов.
     14.4. Указатели и целые
     Целое или длинное целое может быть прибавлено к указате-
 лю или вычтено из него; в этом случае первая величина преоб-
 разуется так, как указывается в разделе описания операции
 сложения.
     
                           - 191 -
     
     Два указателя на объекты одинакового типа могут быть
 вычтены; в этом случае результат преобразуется к целому, как
 указывается в разделе описания операции вычитания.
     14.5. Целое без знака
     Всякий раз, когда целое без знака объединяется с простым
 целым, простое целое преобразуется в целое без знака и ре-
 зультат оказывается целым без знака. Значением является наи-
 меньшее целое без знака, соответствующее целому со знаком
 (по модулю 2**размер слова). В двоичном дополнительном пред-
 ставлении это преобразование является чисто умозрительным и
 не изменяет фактическую комбинацию битов.
     Когда целое без знака преобразуется к типу LONG, значе-
 ние результата совпадает со значением целого без знака. Та-
 ким образом, это преобразование сводится к добавлению нулей
 слева.
     14.6. Арифметические преобразования
     Подавляющее большинство операций вызывает преобразование
 и определяет типы результата аналогичным образом. Приводимая
 ниже схема в дальнейшем будет называться "обычными арифмети-
 ческими преобразованиями".
 Сначала любые операнды типа CHAR или SHORT преобразуются в
   INT, а любые операнды типа FLOAT преобразуются в DOUBLE.
 Затем, если какой-либо операнд имеет тип DOUBLE, то другой
   преобразуется к типу DOUBLE, и это будет типом результата.
 В противном случае, если какой-либо операнд имеет тип LONG,
   то другой операнд преобразуется к типу LONG, и это и будет
   типом результата.
 В противном случае, если какой-либо операнд имеет тип
   UNSIGNED, то другой операнд преобразуется к типу UNSIGNED,
   и это будет типом результата.
 В противном случае оба операнда будут иметь тип INT, и это
   будет типом результата.
 
     15. Выражения
     Старшинство операций в выражениях совпадает с порядком
 следования основных подразделов настоящего раздела, начиная
 с самого высокого уровня старшинства. Так, например, выраже-
 ниями, указываемыми в качестве операндов операции +
 (п.15.4), Являются выражения, определенные в п.п.15.1-15.3.
 Внутри каждого подраздела операции имеет одинаковое старшин-
 ство. В каждом подразделе для описываемых там операций ука-
 зывается их ассоциативность слева или справа. Старшинство и
 ассоциативность всех операций в выражениях резюмируются в
 грамматической сводке в п.18.
     В противном случае порядок вычислений выражений не опре-
 делен. В частности, компилятор считает себя в праве вычис-
 лять подвыражения в том порядке, который он находит наиболее
 эффективным, даже если эти подвыражения приводят к побочным
 эффектам. Порядок, в котором происходят побочные эффекты, не
 специфицируется. Выражения, включающие коммутативные и ассо-
 циативные операции ( *,+,&,!,^ ), могут быть переупорядочены
 произвольным образом даже при наличии круглых скобок; чтобы
 вынудить определенный порядок вычислений, в этом случае не-
 обходимо использовать явные промежуточные переменные.
     
                           - 192 -
     
     При вычислении выражений обработка переполнения и про-
 верка при делении являются машинно-зависимыми. Все существу-
 ющие реализации языка "C" игнорируют переполнение целых; об-
 работка ситуаций при делении на 0 и при всех особых случаях
 с плавающими числами меняется от машины к машине и обычно
 выполняется с помощью библиотечной функции.
     15.1. Первичные выражения
     Первичные выражения, включающие ., ->, индексацию и об-
 ращения к функциям, группируются слева направо.
 
   Первичное выражение:
   идентификатор
   константа
   строка
   (выражение)
   первичное-выражение  [выражение]
   первичное-выражение  (список-выражений   нео
   первичное-L-значение . Идентификатор
   первичное-выражение -> идентификатор
   список-выражений:
   выражение
   список-выражений, выражение
      
 Идентификатор является первичным выражением при условии, что
 он описан подходящим образом, как это обсуждается ниже. тип
 идентификатора определяется его описанием. Если, однако, ти-
 пом идентификатора является "массив ...", то значением выра-
 жения, состоящего из этого идентификатора , является указа-
 тель на первый объект в этом массиве, а типом выражения бу-
 дет "указатель на ...". Более того, идентификатор массива не
 является выражением L-значения. подобным образом идентифика-
 тор, который описан как "функция, возвращающая ...", за иск-
 лючением того случая, когда он используется в позиции имени
 функции при обращении, преобразуется в "указатель на функ-
 цию, которая возвращает ...".
     Константа является первичным выражением. В зависимости
 от ее формы типом константы может быть INT, LONG или DOUBLE.
     Строка является первичным выражением. Исходным ее типом
 является "массив символов"; но следуя тем же самым правилам,
 которые приведены выше для идентификаторов, он модифицирует-
 ся в "указатель на символы", и результатом является указа-
 тель на первый символ строки. (имеется исключение в некото-
 рых инициализаторах; см. П. 16.6.)
     Выражение в круглых скобках является первичным выражени-
 ем, тип и значение которого идентичны типу и значению этого
 выражения без скобок. Наличие круглых скобок не влияет на
 то, является ли выражение L-значением или нет.
     
                           - 193 -
     
     Первичное выражение, за которым следует выражение в
 квадратных скобках, является первичным выражением. Интуитив-
 но ясно, что это выражение с индексом. Обычно первичное вы-
 ражение имеет тип "указатель на ...", индексное выражение
 имеет тип INT, а типом результата является "...". Выражение
 E1[E2] по определению идентично выражению * ((E1) + (E2)).
 Все, что необходимо для понимания этой записи, содержится в
 этом разделе; вопросы, связанные с понятием идентификаторов
 и операций * и + рассматриваются в п.п. 15.1, 15.2 И 15.4
 соответственно; выводы суммируются ниже в п. 22.3.
     Обращение к функции является первичным выражением, за
 которым следует заключенный в круглые скобки возможно пустой
 список выражений, разделенных запятыми, которые и представ-
 ляют собой фактические аргументы функции. Первичное выраже-
 ние должно быть типа "функция, возвращающая ...", а резуль-
 тат обращения к функции имеет тип "...". Как указывается ни-
 же, ранее не встречавщийся идентификатор, за которым непос-
 редственно следует левая круглая скобка, считается описанным
 по контексту, как представляющий функцию, возвращающую це-
 лое; следовательно чаще всего встречающийся случай функции,
 возвращающей целое значение, не нуждается в описании.
     Перед обращением любые фактические аргументы типа FLOAT
 преобразуются к типу DOUBLE, любые аргументы типа CHAR или
 SHORT преобразуются к типу INT, и, как обычно, имена масси-
 вов преобразуются в указатели. Никакие другие преобразования
 не выполняются автоматически; в частности, не сравнивает ти-
 пы фактических аргументов с типами формальных аргументов.
 Если преобразование необходимо, используйте явный перевод
 типа (CAST); см. П.п. 15.2, 16.7.
     При подготовке к вызову функции делается копия каждого
 фактического параметра; таким образом, все передачи аргумен-
 тов в языке "C" осуществляются строго по значению. функция
 может изменять значения своих формальных параметров, но эти
 изменения не влияют на значения фактических параметров. С
 другой строны имеется возможность передавать указатель при
 таком условии, что функция может изменять значение объекта,
 на который этот указатель указывает. Порядок вычисления ар-
 гументов в языке не определен; обратите внимание на то, что
 различные компиляторы вычисляют по разному.
     Допускаются рекурсивные обращения к любой функции.
     Первичное выражение, за которым следует точка и иденти-
 фикатор, является выражением. Первое выражение должно быть
 L-значением, именующим структуру или объединение, а иденти-
 фикатор должен быть именем члена структуры или объединения.
 Результатом является L-значение, ссылающееся на поименован-
 ный член структуры или объединения.
     Первичное выражение, за которым следует стрелка (состав-
 ленная из знаков - и >) и идентификатор, является выражени-
 ем. первое выражение должно быть указателем на структуру или
 объединение, а идентификатор должен именовать член этой
 структуры или объединения. Результатом является L-значение,
 ссылающееся на поименованный член структуры или объединения,
 на который указывает указательное выражение.
     Следовательно, выражение E1->MOS является тем же самым,
 что и выражение (*E1).MOS. Структуры и объединения рассмат-
 риваются в п. 16.5. Приведенные здесь правила использования
 структур и объединений не навязываются строго, для того что-
 бы иметь возможность обойти механизм типов. См. П. 22.1.
     
                           - 194 -
     
     15.2. Унарные операции
     Выражение с унарными операциями группируется справо на-
 лево.
  Унарное-выражение:
       *  выражение
       &  L-значение
       -  выражение
       !  Выражение
       \^ выражение
       ++ L-значение
       -- L-значение
       L-значение ++
       L-значение --
       (имя-типа) выражение
       SIZEOF выражение
       SIZEOF имя-типа
 
     Унарная операция * означает косвенную адресацию: выраже-
 ние должно быть указателем, а результатом является L-значе-
 ние, ссылающееся на тот объект, на который указывает выраже-
 ние. Если типом выражения является "указатель на...", то ти-
 пом результата будет "...".
     Результатом унарной операции & является указатель на
 объект, к которому ссылается L-значение. Если L-значение
 имеет тип "...", то типом результата будет "указатель на
 ...".
     Результатом унарной операции - (минус) является ее опе-
 ранд, взятый с противоположным знаком. Для величины типа
 UNSIGNED результат получается вычитанием ее значения из 2**N
 (два в степени N), где N-число битов в INT. Унарной операции
 + (плюс) не существует.
     Результатом операции логического отрицания ! Является 1,
 если значение ее операнда равно 0, и 0, если значение ее
 операнда отлично от нуля. Результат имеет тип INT. Эта опе-
 рация применима к любому арифметическому типу или указате-
 лям.
     Операция \^ дает обратный код, или дополнение до едини-
 цы, своего операнда. Выполняются обычные арифметические пре-
 образования. Операнд должен быть целочисленного типа.
     Объект, на который ссылается операнд L-значения префикс-
 ной операции ++, увеличивается. значением является новое
 значение операнда, но это не L-значение. Выражение ++х экви-
 валентно х+=1. Информацию о преобразованиях смотри в разборе
 операции сложения (п. 15.4) и операции присваивания (п.
 15.14).
     Префиксная операция -- аналогична префиксной операции
 ++, но приводит к уменьшению своего операнда L-значения.
     При применении постфиксной операции ++ к L-значению ре-
 зультатом является значение объекта, на который ссылается
 L-значение. После того, как результат принят к сведению,
 объект увеличивается точно таким же образом, как и в случае
 префиксной операции ++. Результат имеет тот же тип, что и
 выражение L-значения.
     
                           - 195 -
     
     При применении постфиксной операции -- к L-значению ре-
 зультатом является значение объекта, на который ссылается
 L-значение. После того, как результат принят к сведению,
 объект уменьшается точно таким же образом, как и в случае
 префиксной операции --. Результат имеет тот же тип, что и
 выражение L-значения.
     Заключенное в круглые скобки имя типа данных,стоящее пе-
 ред выражением , вызывает преобразование значения этого вы-
 ражения к указанному типу. Эта конструкция называется пере-
 вод (CAST). Имена типов описываются в п. 16.7.
     Операция SIZEOF выдает размер своего операнда в байтах.
 (Понятие байт в языке не определено, разве только как значе-
 ние операции SIZEOF. Однако во всех существующих реализациях
 байтом является пространство, необходимое для хранения
 объекта типа CHAR). При применении к массиву результатом яв-
 ляется полное число байтов в массиве. Размер определяется из
 описаний объектов в выражении. Это выражение семантически
 является целой константой и может быть использовано в любом
 месте, где требуется константа. Основное применение эта опе-
 рация находит при связях с процедурами, подобным распредели-
 телям памяти, и в системах ввода- вывода.
     Операция SIZEOF может быть также применена и к заключен-
 ному в круглые скобки имени типа. В этом случае она выдает
 размер в байтах объекта указанного типа.
     Конструкция SIZEOF (тип) рассматривается как целое, так
 что выражение SIZEOF (тип) - 2 эквивалентно выражению
 (SIZEOF (тип)9 - 2.
     15.3. Мультипликативные операции
     Мультипликативные операции *, /, и % группируются слева
 направо. Выполняются обычные арифметические преобразования.
   Мультипликативное-выражение:
   выражение * выражение
   выражение / выражение
   выражение % выражение
     Бинарная операция * означает умножение. Операция * ассо-
 циативна, и выражения с несколькими умножениями на одном и
 том же уровне могут быть перегруппированы компилятором.
     Бинарная операция / означает деление. При делении поло-
 жительных целых осуществляется усечение по направлению к ну-
 лю, но если один из операндов отрицателен, то форма усечения
 зависит от используемой машины. На всех машинах, охватывае-
 мых настоящим руководством, остаток имеет тот же знак , что
 и делимое. Всегда справедливо, что (A/B)*B+A%B равно A (если
 B не равно 0).
     Бинарная операция % выдает остаток от деления первого
 выражения на второе. Выполняются обычные арифметические пре-
 образования. Операнды не должны быть типа FLOAT.
     15.4. Аддитивные операции
     Аддитивные операции + и - группируются слева направо.
 выполняются обычные арифметические преобразования. Для каж-
 дой операции имеются некоторые дополнительные возможности,
 связанные с типами операндов.
     
                           - 196 -
     
  Аддитивное-выражение:
  выражение + выражение
  выражение - выражение
 
 Результатом операции + является сумма операндов. Можно скла-
 дывать указатель на объект в массиве и значение любого цело-
 численного типа. во всех случаях последнее преобразуется в
 адресное смещение посредством умножения его на длину объек-
 та, на который указывает этот указатель. Результатом являет-
 ся указатель того же самого типа, что и исходный указатель,
 который указывает на другой объект в том же массиве, смещен-
 ный соответствующим образом относительно первоначального
 объекта. Таким образом, если P является указателем объекта в
 массиве, то выражение P+1 является указателем на следующий
 объект в этом массиве.
     Никакие другие комбинации типов для указателей не разре-
 шаются.
     Операция + ассоциативна, и выражение с несколькими сло-
 жениями на том же самом уровне могут быть переупорядочены
 компилятором.
     Результатом операции - является разность операндов. Вы-
 полняются обычные арифметические преобразования. Кроме того,
 из указателя может быть вычтено значение любого целочислен-
 ного типа, причем, проводятся те же самые преобразования,
 что и при операции сложения.
     Если вычитаются два указателя на объекты одинакового ти-
 па, то результат преобразуется (делением на длину объекта) к
 типу INT, представляя собой число объектов, разделяющих ука-
 зываемые объекты. Если эти указатели не на объекты из одного
 и того же массива, то такое преобразование, вообще говоря,
 даст неожиданные результаты, потому что даже указатели на
 объекты одинакового типа не обязаны отличаться на величину,
 кратную длине объекта.
     15.5. Операции сдвига
     Операции сдвига << и >> группируются слева направо. Для
 обеих операций проводятся обычные арифметические преобразо-
 вания их операндов, каждый из которых должен быть целочис-
 ленного типа. Затем правый операнд преобразуется к типу INT;
 результат имеет тип левого операнда. Результат не определен,
 если правый операнд отрицателен или больше или равен, чем
 длина объекта в битах.
   Выражение-сдвига:
   выражение << выражение
   выражение >> выражение
 
 Значением выражения E1<<E2 является E1 (интерпретируемое как
 комбинация битов), сдвинутое влево на E2 битов; освобождаю-
 щиеся биты заполняются нулем. значением выражения E1>>E2 яв-
 ляется E1, сдвинутое вправо на E2 битовых позиций. Если E1
 имеет тип UNSIGNE, то сдвиг вправо гарантированно будет ло-
 гическим (заполнение нулем); в противном случае сдвиг может
 быть (и так и есть на PDP-11) арифметическим (освобождающие-
 ся биты заполняются копией знакового бита).
     
                           - 197 -
     
     15.6. Операции отношения
     Операции отношения группируются слева направо, но этот
 факт не очень полезен; выражение A<B<C не означает того, что
 оно казалось бы должно означать.
   Выражение-отношения:
   выражение < выражение
   выражение > выражение
   выражение <= выражение
   выражение >= выражение
 
 Операции < (меньше), > (больше), <= (меньше или равно) и >=
 (больше или равно) все дают 0, если указанное отношение лож-
 но, и 1, если оно истинно. Результат имеет тип ITN. Выполня-
 ются обычные арифметические преобразования. Могут сравни-
 ваться два указателя; результат зависит от относительного
 расположения указываемых объектов в адресном пространстве.
 Сравнение указателей переносимо только в том случае, если
 указатели указывают на объекты из одного и того же массива.
     15.7. Операции равенства
     Выражение-равенства:
  выражение == выражение
  выражение != выражение
 
 Операции == (равно) и != (не равно) в точности аналогичны
 операциям отношения, за исключением того, что они имеют бо-
 лее низкий уровень старшинства. (Поэтому значение выражения
 A<B==C<D равно 1 всякий раз, когда выражение A<B и C<D имеют
 одинаковое значение истинности).
     Указатель можно сравнивать с целым, но результат будет
 машинно- независимым только в том случае, если целым являет-
 ся константа 0. Гарантируется, что указатель, которому прис-
 воено значение 0, не указывает ни на какой объект и на самом
 деле оказывается равным 0; общепринято считать такой указа-
 тель нулем.
     15.8. Побитовая операция 'и'
     Выражение-и:
  выражение & выражение
 
 Операция & является ассоциативной, и включающие & выражения
 могут быть переупорядочены. Выполняются обычные арифметичес-
 кие преобразования; результатом является побитовая функция
 'и' операндов. Эта операция применима только к операндам це-
 лочисленного типа.
     15.9. Побитовая операция исключающего 'или'
     Выражение-исключающего-или:
   выражение ^ выражение
 
 Операция ^ является ассоциативной, и включающие ^ выражения
 могут быть переупорядочены. выполняются обычные арифметичес-
 кие преобразования; результатом является побитовая функция
 исключающего 'или' операндов. Операция применима только к
 операндам целочисленного типа.
     
                           - 198 -
     
     15.10. Побитовая операция включающего 'или'
     Выражение-включающего-или:
   выражение \! Выражение
 
 Операция \! Является ассоциативной, и содержащие \! Выраже-
 ния могут быть переупорядочены. выполняются обычные арифме-
 тические преобразования; результатом является побитовая фун-
 кция включающего 'или' операндов. Операция применима только
 к операндам целочисленного типа.
     15.11. Логическая операция 'и'
     Выражение-логического-и:
   выражение && выражение
 
 Операция && группируется слева направо. Она возвращает 1,
 если оба ее операнда отличны от нуля, и 0 в противном слу-
 чае. В отличие от & операция && гарантирует вычисление слева
 направо; более того, если первый операнд равен 0, то значе-
 ние второго операнда вообще не вычисляется.
     Операнды не обязаны быть одинакового типа, но каждый из
 них должен быть либо одного из основных типов, либо указате-
 лем. результат всегда имеет тип ITN.
     15.12. Операция логического 'или'
     Выражение-логического-или:
  выражение \!\! выражение
 
 Операция \!\! Группируется слева направо. Она возвращает 1,
 если один из операндов отличен от нуля, и 0 в противном слу-
 чае. В отличие от операции \! Операция \!\! Гарантирует вы-
 числение слева направо; более того, если первый операнд от-
 личен от нуля, то значение второго операнда вообще не вычис-
 ляется.
     Операнды не обязаны быть одинакового типа, но каждый из
 них должен быть либо одного из основных типов, либо указате-
 лем. Результат всегда имеет тип INT.
     15.13. Условная операция
     Условное-выражение:
  выражение ? выражение : выражение
 
 Условные выражения группируются слево направо. Вычисляется
 значение первого выражения, и если оно отлично от нуля, то
 результатом будет значение второго выражения; в противном
 случае результатом будет значение третьего выражения. Если
 это возможно, проводятся обычные арифметические преобразова-
 ния, с тем, чтобы привести второе и третье выражения к обще-
 му типу; в противном случае, если оба выражения являются
 указателями одинакового типа, то результат имеет тот же тип;
 в противном случае одно выражение должно быть указателем, а
 другое - константой 0, и результат будет иметь тип указате-
 ля. Вычисляется только одно из второго и третьего выражений.
     
                           - 199 -
     
     15.14. Операция присваивания
     Имеется ряд операций присваивания, каждая из которых
 группируется слева направо. Все операции требуют в качестве
 своего левого операнда L-значение, а типом выражения присва-
 ивания является тип его левого операнда. Значением выражения
 присваивания является значение, хранимое в левом операнде
 после того, как присваивание уже будет произведено. Две час-
 ти составной операции присваивания являются отдельными лек-
 семами.
     Выражение-присваивания:
   L-значение = выражение
   L-значение += выражение
   L-значение -= выражение
   L-значение *= выражение
   L-значение /= выражение
   L-значение %= выражение
   L-значение >>= выражение
   L-значение <<= выражение
   L-значение &= выражение
   L-значение ^= выражение
   L-значение \!= выражение
 
     Когда производится простое присваивание C'=', значение
 выражения заменяет значение объекта, на которое ссылается
 L-значение. Если оба операнда имеют арифметический тип, то
 перед присваиванием правый операнд преобразуется к типу ле-
 вого операнда.
     О свойствах выражения вида E1 оп = E2, где Oп - одна из
 перечисленных выше операций, можно сделать вывод, если
 учесть, что оно эквивалентно выражению E1 = E1 оп (E2); од-
 нако выражение E1 вычисляется только один раз. В случае опе-
 раций += и -= левый операнд может быть указателем, причем
 при этом (целочисленный) правый операнд преобразуется таким
 образом, как объяснено в п. 15.4; все правые операнды и все
 отличные от указателей левые операнды должны иметь арифмети-
 ческий тип.
     Используемые в настоящее время компиляторы допускают
 присваивание указателя целому, целого указателю и указателя
 указателю другого типа. такое присваивание является чистым
 копированием без каких-либо преобразований. Такое употребле-
 ние операций присваивания является непереносимым и может
 приводить к указателям, которые при использовании вызывают
 ошибки адресации. Тем не менее гарантируется, что присваива-
 ние указателю константы 0 дает нулевой указатель, который
 можно отличать от указателя на любой объект.
     15.15. Операция запятая
     Выражение-с-запятой:
   выражение , выражение
            
                           - 200 -
     
 Пара выражений, разделенных запятой, вычисляется слева нап-
 раво и значение левого выражения отбрасывается. Типом и зна-
 чением результата является тип и значение правого операнда.
 Эта операция группируется слева направо. В контексте, где
 запятая имеет специальное значение, как, например, в списке
 фактических аргументов функций (п. 15.1) Или в списках ини-
 циализаторов (п. 16.6), Операция запятая, описываемая в этом
 разделе, может появляться только в круглых скобках; напри-
 мер, функция
 
   F(A,(T=3,T+2),C)
 
 имеет три аргумента, второй из которых имеет значение 5.
     16. Описания
     Описания используются для указания интерпретации, кото-
 рую язык "C" будет давать каждому идентификатору; они не
 обязательно резервируют память, соответствующую идентифика-
 тору. Описания имеют форму
  Описание:
  спецификаторы-описания список-описателей
             необ;
 
 Описатели в списке описателей содержат описываемые идентифи-
 каторы. Спецификаторы описания представляют собой последова-
 тельность спецификаторов типа и спецификаторов класса памя-
 ти.
 
 Спецификаторы-описания:
   спецификатор-типа спецификаторы-описания
        необ
   спецификатор-класса-памяти спецификатор-описания
       необ
 
 список должен быть самосогласованным в смысле, описываемом
 ниже.
     16.1. Спецификаторы класса памяти
     Ниже перечисляются спецификаторы класса памяти:
  Спецификатор-класса-памяти:
       AUTO
       STATIC
       EXTERN
       REGISTER
       TYPEDEF
 
     Спецификатор TYPEDEF не реализует памяти и называется
 "спецификатором класса памяти" только по синтаксическим со-
 ображениям; это обсуждается в п. 16.8. Смысл различных клас-
 сов памяти был обсужден в п. 12.
     Описания AUTO, STATIC и REGISTER служат также в качестве
 определений в том смысле, что они вызывают резервирование
 нужного количества памяти. В случае EXTERN должно присутст-
 вовать внешнее определение (п. 18) Указываемых идентификато-
 ров где-то вне функции, в которой они описаны.
     
                           - 201 -
     
     Описание REGISTER лучше всего представлять себе как опи-
 сание AUTO вместе с намеком компилятору, что описанные таким
 образом переменные будут часто использоваться. Эффективны
 только несколько первых таких описаний. Кроме того, в регис-
 трах могут храниться только переменные определенных типов;
 на PDP-11 это INT, CHAR или указатель. Существует и другое
 ограничение на использование регистровых переменных: к ним
 нельзя применять операцию взятия адреса &. При разумном ис-
 пользовании регистровых описаний можно ожидать получения
 меньших по размеру и более быстрых программ, но улучшение в
 будущем генерирования кодов может сделать их ненужными.
     Описание может содержать не более одного спецификатора
 класса памяти. Если описание не содержит спецификатора клас-
 са памяти, то считается, что он имеет значение AUTO, если
 описание находится внутри некоторой функции, и EXTERN в про-
 тивном случае. исключение: функции никогда не бывает автома-
 тическими.
     16.2. Спецификаторы типа
     Ниже перечисляются спецификаторы типа.
 
   Спецификатор-типа:
   CHAR
   SHORT
   INT
   LONG
   UNSIGNED
   FLOAT
   DOUBLE
   спецификатор-структуры-или-объединения
   определяющее-тип-имя
 
     Слова LONG, SHORT и USIGNED можно рассматривать как при-
 лагательные; допустимы следующие комбинации:
 
   SHORT INT
   LONG INT
   USIGNED INT
   LONG FLOAT
 
 Последняя комбинация означает то же, что и DOUBLE. В осталь-
 ном описание может содержать не более одного спецификатора
 типа. Если описание не содержит спецификатора типа, то счи-
 тается, что он имеет значение INT.
     Спецификаторы структур и объединений обсуждаются в п.
 16.5; Описания с определяющими тип именами TYPEDEF обсужда-
 ются в п. 16.8.
     
                           - 202 -
     
     16.3. Описатели
     Входящий в описание список описателей представляет собой
 последовательность разделенных запятыми описателей, каждый
 из которых может иметь инициализатор.
   Список-описателей:
  инициализируемый-описатель
  инициализируемый-описатель, список-описателей
   инициализируемый-описатель:
  описатель-инициализатор
     необ
 
 Инициализаторы описываются в п. 16.6. Спецификаторы и описа-
 ния указывают тип и класс памяти объектов, на которые ссыла-
 ются описатели. Описатели имеют следующий синтаксис:
 
  описатель:
  идентификатор
  ( описатель )
  * описатель
  описатель ()
  описатель [константное-выражение
          необ]
 
 Группирование такое же как и в выражениях.
     16.4. Смысл описателей
     Каждый описатель рассматривается как утверждение того,
 что когда конструкция той же самой формы, что и описатель,
 появляется в выражении, то она выдает объект указанного типа
 и указанного класса памяти. Каждый описатель содержит ровно
 один идентификатор; это именно тот идентификатор, который и
 описывается.
     Если в качестве описателя появляется просто идентифика-
 тор, то он имеет тип, указываемый в специфицирующем заголов-
 ке описания.
     Описатель в круглых скобках идентичен описателю без
 круглых скобок, но круглые скобки могут изменять связи в
 составных описателях. Примеры смотри ниже.
     Представим себе описание
 
    T     DI
 
 где T - спецификатор типа (подобный INT и т.д.), а DI - опи-
 сатель. Предположим, что это описание приводит к тому, что
 соответствующий идентификатор имеет тип "...T", где "..."
 пусто, если DI просто отдельный идентификатор (так что тип X
 в "INT X" просто INT). Тогда , если DI имеет форму
 
     *D
 
 то содержащийся идентификатор будет иметь тип "... Указатель
 на T".
     
                           - 203 -
     
     Если DI имеет форму
 
     D()
 
 то содержащийся идентификатор имеет тип "... Функция, возв-
 ращающая T".
     Если DI имеет форму
 
  D[константное-выражение]
 
 или
 
  D[ ]
 
 то содержащийся идентификатор имеет тип "...массив T". В
 первом случае константным выражением является выражение,
 значение которого можно определить во время компиляции и ко-
 торое имеет тип INT. (Точное определение константного выра-
 жения дано в п. 23). Когда несколько спецификаций вида "мас-
 сив из" оказываются примыкающими, то создается многомерный
 массив; константное выражение, задающее границы массивов,
 может отсутствовать только у первого члена этой последова-
 тельности. Такое опускание полезно, когда массив является
 внешним и его фактическое определение, которое выделяет па-
 мять, приводится в другом месте. Первое константное выраже-
 ние может быть опущено также тогда, когда за описателем сле-
 дует инициализация. В этом случае размер определяется по
 числу приведенных инициализируемых элементов.
     Массив может быть образован из элементов одного из ос-
 новных типов, из указателей, из структур или объединений или
 из других массивов (чтобы образовать многомерный массив).
     Не все возможности, которые разрешены с точки зрения
 указанного выше синтаксиса, фактически допустимы. Имеются
 следующие ограничения: функции не могут возвращать массивы,
 структуры, объединения или функции, хотя они могут возвра-
 щать указатели на такие вещи; не существует массивов функ-
 ций, хотя могут быть массивы указателей на функции. Анало-
 гично, структуры или объединения не могут содержать функцию,
 но они могут содержать указатель на функцию.
     В качестве примера рассмотрим описание
 
  INT I, *IP, F(), *FIP(), (*PFI)();
 
 в котором описывается целое I, указатель IP на целое, функ-
 ция F, возвращающая целое, функция FIP, возвращающая указа-
 тель на целое, и указатель PFI на функцию, которая возвраща-
 ет целое. Особенно полезно сравнить два последних описателя.
 Связь в *FIP() можно представить в виде *(FIP()), так что
 описанием предполагается, а такой же конструкцией в выраже-
 нии требуется обращение к функции FIP и последующее исполь-
 зование косвенной адресации для выдачи с помощью полученного
 результата (указателя) целого. В описателе (*PFI)() дополни-
     
                           - 204 -
     
 тельные скобки необходимы, поскольку они точно так же, как и
 в выражении, указывают, что косвенная адресация через указа-
 тель на функцию выдает функцию, которая затем вызывается;
 эта вызванная функция возвращает целое.
     В качестве другого примера приведем описание
 
    FLOAT FA[17], *AFP[17];
 
 в котором описывается массив чисел типа FLOAT и массив ука-
 зателей на числа типа FLOAT. Наконец,
 
   STATIC INT X3D[3][5][7];
 
 описывает статический трехмерный массив целых размером
 3*5*7. более подробно, X3D является массивом из трех элемен-
 тов; каждый элемент является массивом пяти массивов; каждый
 последний массив является массивом из семи целых. Каждое из
 выражений X3D, X3D[I], X3D[I][J] и X3D[I][J][K] может разум-
 ным образом появляться в выражениях. Первые три имеют тип
 "массив", последнее имеет тип INT.
     16.5. Описание структур и объединений
     Структура - это объект, состоящий из последовательности
 именованных членов. каждый член может быть произвольного ти-
 па. Объединение - это объект, который в данный момент может
 содержать любой из нескольких членов. Спецификаторы и
 объединения имеют одинаковую форму.
 Спецификатор-структуры-или-объединения
 
 структура-или-объединение \( список-описаний-структуры\)
 
 идентификатор    структуры-или-объединения
 \(список-описаний-структуры\)
 идентификатор структуры-или-объединения
 
 Структура-или-объединение:
 
    STRUCT
    UNION
 
 Список-описаний-структуры является последовательностью опи-
 саний членов структуры или объединения:
 
  Список-описаний-структуры:
 описание-структуры
 описание-структуры список-описаний-структуры
  описание-структуры:
 спецификатор-типа список-описателей-структуры
  список-описателей-структуры:
 описатель-структуры
 описатель-структуры, список-описателей-структуры
 
 В обычном случае описатель структуры является просто описа-
 телем члена структуры или объединения. Член структуры может
 также состоять из специфицированного числа битов. Такой член
 называется также полем; его длина отделяется от имени поля
 двоеточием.
     
                           - 205 -
 
   Описатель-структуры:
   описатель
   описатель: константное выражение
   : константное выражение
 
 Внутри структуры описанные в ней объекты имеют адреса, кото-
 рые увеличиваются в соответствии с чтением их описаний слева
 направо. Каждый член структуры, который не является полем,
 начинается с адресной границы, соответствующей его типу;
 следовательно в структуре могут оказаться неименованные ды-
 ры. Члены, являющиеся полями, помещаются в машинные целые;
 они не перекрывают границы слова. Поле, которое не умещается
 в оставшемся в данном слове пространстве, помещается в сле-
 дующее слово. Поля выделяются справа налево на PDP-11 и сле-
 ва направо на других машинах.
     Описатель структуры, который не содержит описателя, а
 только двоеточие и ширину, указывает неименованное поле, по-
 лезное для заполнения свободного пространства с целью соот-
 ветствия задаваемых извне схемам. Специальный случай неиме-
 нованного поля с шириной 0 используется для указания о вы-
 равнивании следующего поля на границу слова. При этом пред-
 полагается, что "следующее поле" действиетльно является по-
 лем, а не обычным членом структуры, поскольку в последнем
 случае выравнивание осуществляется автоматически.
     Сам язык не накладывает ограничений на типы объектов,
 описанных как поля, но от реализаций не требуется обеспечи-
 вать что-либо отличное от целых полей. Более того, даже поля
 типа INT могут рассматриваться как неимеющие знака. На
 PDP-11 поля не имеют знака и могут принимать только целые
 значения. Во всех реализациях отсутствуют массивы полей и к
 полям не применима операция взятия адреса &, так что не су-
 ществует и указателей на поля.
     Объединение можно представить себе как структуру, все
 члены которой начинаются со смещения 0 и размер которой дос-
 таточен, чтобы содержать любой из ее членов. В каждый момент
 объединение может содержать не более одного из своих членов.
     Спецификатор структуры или объединения во второй форме,
 т.е. Один из
 
 STRUCT идентификатор \(список-описаний-структуры\)
 
 UNION идентификатор \(список-описаний-структуры\)
 
 описывает идентификатор в качестве ярлыка структуры (или яр-
 лыка объединения) структуры, специфицированной этим списком.
 Последующее описание может затем использовать третью форму
 спецификатора, один из
 
 STRUCT идентификатор
 
 UNION идентификатор
                                          
     
                           - 206 -
     
 Ярлыки структур дают возможность определения структур, кото-
 рые ссылаются на самих себя; они также позволяют неоднократ-
 но использовать приведенную только один раз длинную часть
 описания. Запрещается описывать структуру или объединение,
 которые содержат образец самого себя, но структура или
 объединение могут содержать указатель на структуру или
 объединение такого же вида, как они сами.
     Имена членов и ярлыков могут совпадать с именами обычных
 переменных. Однако имена ярлыков и членов должны быть взаим-
 но различными.
     Две структуры могут иметь общую начальную последователь-
 ность членов; это означает, что тот же самый член может поя-
 виться в двух различных структурах, если он имеет одинаковый
 тип в обеих структурах и если все предыдущие члены обеих
 структур одинаковы. (Фактически компилятор только проверяет,
 что имя в двух различных структурах имеет одинаковый тип и
 одинаковое смещение, но если предшествующие члены отличают-
 ся, то конструкция оказывается непереносимой).
     Вот простой пример описания структуры:
 
  STRUCT TNODE \(
  CHAR TWORD[20];
  INT COUNT;
  STRUCT TNODE *LEFT;
  STRUCT TNODE *RIGHT;
  \);
 Такая структура содержит массив из 20 символов, целое и два
 указателя на подобные структуры. Как только приведено такое
 описание, описание
 
    STRUCT TNODE S, *SP;
 
 говорит о том, что S является структурой указанного вида, а
 SP является указателем на структуру указанного вида. При на-
 личии этих описаний выражение
 
   SP->COUNT
 
 ссылается к полю COUNT структуры, на которую указывает SP;
 выражение
 
   S.LEFT
 
 ссылается на указатель левого поддерева в структуре S, а вы-
 ражение
 
   S.RIGHT->TWORD[0]
 
 ссылается на первый символ члена TWORD правого поддерева из
 S.
     
                           - 207 -
      16.6. Инициализация
     Описатель может указывать начальное значение описываемо-
 го идентификатора. Инициализатор состоит из выражения или
 заключенного в фигурные скобки списка значений, перед кото-
 рыми ставится знак =.
 
   Инициализатор:
   = выражение
   = \(список-инициализатора\)
   = \(список-инициализатора,\)
   список-инициализатора:
   выражение
   список-инициализатора,список-инициализатора
   \(список-инициализатора\)
 
     Все выражения, входящие в инициализатор статической или
 внешней переменной, должны быть либо константными выражения-
 ми, описываемыми в п. 23, Либо выражениями, которые сводятся
 к адресу ранее описанной переменной, возможно смещенному на
 константное выражение. Автоматические и регистровые перемен-
 ные могут быть инициализированы произвольными выражениями,
 включающими константы и ранее описанные переменные и функ-
 ции.
     Гарантируется, что неинициализированные статические и
 внешние переменные получают в качестве начальных значений
 0;неинициализированные автоматические и регистровые перемен-
 ные в качестве начальных значений содержат мусор.
     Когда инициализатор применяется к скаляру (указателю или
 объекту арифметического типа), то он состоит из одного выра-
 жения, возможно заключенного в фигурные скобки. Начальное
 значение объекта находится из выражения; выполняются те же
 самые преобразования, что и при присваивании.
     Когда описываемая переменная является агрегатом (струк-
 турой или массивом ), то инициализатор состоит из заключен-
 ного в фигурные скобки и разделенного запятыми списка иници-
 ализаторов для членов агрегата. Этот список составляется в
 порядке возрастания индекса или в соответствии с порядком
 членов. Если агрегат содержит подагрегаты, то это правило
 применяется рекурсивно к членам агрегата. Если количество
 инициализаторов в списке оказывается меньше числа членов аг-
 регата, то оставшиеся члены агрегата заполняются нулями.
 Запрещается инициализировать объединения или автоматические
 агрегаты.
     Фигурные скобки могут быть опущены следующим образом.
 Если инициализатор начинается с левой фигурной скобки, то
 последующий разделенный запятыми список инициализаторов ини-
 циализирует члены агрегата; будет ошибкой, если в списке
 окажется больше инициализаторов, чем членов агрегата. Если
 однако инициализатор не начинается с левой фигурной скобки,
 то из списка берется только нужное для членов данного агре-
 гата число элементов; оставшиеся элементы используются для
 инициализации следующего члена агрегата, частью которого яв-
 ляется настоящий агрегат.
     
                           - 208 -
     
     Последнее сокращение допускает возможность инициализации
 массива типа CHAR с помощью строки. В этом случае члены мас-
 сива последовательно инициализируются символами строки.
     Например,
 
     INT X[] = \(1,3,5\);
 
 описывает и инициализирует X как одномерный массив; посколь-
 ку размер массива не специфицирован, а список инициализитора
 содержит три элемента, считается, что массив состоит из трех
 членов.
     Вот пример инициализации с полным использованием фигур-
 ных скобок:
 
     FLOAT *Y[4][3] = \(
      ( 1, 3, 5 ),
      ( 2, 4, 6 ),
      ( 3, 5, 7 ),
     \);
 
 Здесь 1, 3 и 5 инициализируют первую строку массива Y[0], а
 именно Y[0][0], Y[0][1] и Y[0][2]. Аналогичным образом сле-
 дующие две строчки инициализируют Y[1] и Y[2]. Инициализатор
 заканчивается преждевременно, и, следовательно массив Y[3]
 инициализируется нулями. В точности такого же эффекта можно
 было бы достичь, написав
 
      FLOAT Y[4][3] = \(
       1, 3, 5, 2, 4, 6, 3, 5, 7
      \);
 
 Инициализатор для Y начинается с левой фигурной скобки, но
 инициализатора для Y[0] нет. Поэтому используется 3 элемента
 из списка. Аналогично следующие три элемента используются
 последовательно для Y[1] и Y[2]. следующее описание
 
      FLOAT Y[4][3] = \(
       (1), (2), (3), (4)
      \);
 
 инициализирует первый столбец Y (если его рассматривать как
 двумерный массив), а остальные элементы заполняются нулями.
     И наконец, описание
 
     CHAR MSG[] = "SYNTAX ERROR ON LINE %S\N";
 
 демонстрирует инициализацию элементов символьного массива с
 помощью строки.
     16.7. Имена типов
     В двух случаях (для явного указания типа преобразования
 в конструкции перевода и для аргументов операции SIZEOF) же-
 лательно иметь возможность задавать имя типа данных. Это
 осуществляется с помощью "имени типа", которое по существу
 является описанием объекта такого типа , в котором опущено
 имя самого объекта.
     
                           - 209 -
     
    Имя типа:
  спецификатор-типа абстрактный-описатель
    абстрактный-описатель:
  пусто
  (абстрактный-описатель)
  * абстрактный описатель
  абстрактный-описатель ()
  абстрактный-описатель [константное выражение
        необ]
 
 Во избежании двусмысленности в конструкции
 
      (абстрактный описатель)
 
 требуется, чтобы абстрактный-описатель был непуст. При этом
 ограничении возможно однозначено определить то место в абст-
 рактном-описателе, где бы появился идентификатор, если бы
 эта конструкция была описателем в описании. Именованный тип
 совпадает тогда с типом гипотетического идентификатора. Нап-
 ример, имена типов
 
  INT
  INT *
  INT *[3]
  INT (*)[3]
  INT *()
  INT (*)()
 
 именуют соответственно типы "целый", "указатель на целое",
 "массив из трех указателей на целое", "указатель на массив
 из трех целых", " функция, возвращающая указатель на целое"
 и "указатель на функцию, возвращающую целое".
     16.8. TYPEDEF
     Описания, в которых "класс памяти"специфицирован как
 TYPEDEF, не вызывают выделения памяти. вместо этого они оп-
 ределяют идентификаторы ,которые позднее можно использовать
 так, словно они являются ключевыми словами, имеющими основ-
 ные или производные типы.
  Определяющее-тип-имя
  идентификатор
 
 В пределах области действия описания со спецификатором
 TYPEDEF каждый идентификатор, являющийся частью любого опи-
 сателя в этом описании, становится синтаксически эквивалент-
 ным ключевому слову, имеющему тот тип , который ассоциирует
 с идентификатором в описанном в п. 16.4 Смысле. Например,
 после описаний
 
  TYPEDEF INT MILES, >KLICKSP;
  TYPEDEF STRUCT ( DOUBLE RE, IM; ) COMPLEX;
 
 конструкции
 
  MILES DISTANCE;
  EXTERN KLICKSP METRICP;
  COMPLEX Z, *ZP;
            
                           - 210 -
     
 становятся законными описаниями; при этом типом DISTANCE яв-
 ляется INT, типом METRICP - "указатель на INT", типом Z -
 специфицированная структура и типом ZP - указатель на такую
 структуру.
     Спецификатор TYPEDEF не вводит каких-либо совершенно но-
 вых типов, а только определяет синонимы для типов, которые
 можно было бы специфицировать и другим способом. Так в при-
 веденном выше примере переменная DISTANCE считается имеющей
 точно такой же тип, что и любой другой объект, описанный в
 INT.
     17. Операторы
     За исключением особо оговариваемых случаев, операторы
 выполняются последовательно.
     17.1. Операторное выражение
     Большинство операторов являются операторными выражения-
 ми, которые имеют форму
 
      выражение;
 
 обычно операторные выражения являются присваиваниями или об-
 ращениями к функциям.
     17.2. Составной оператор (или блок)
     С тем чтобы допустить возможность использования несколь-
 ких операторов там, где ожидается присутствие только одного,
 предусматривается составной оператор (который также и экви-
 валентно называют "блоком"):
 
     составной оператор:
    \(список-описаний    список-операторов
                необ  необ\)
     список-описаний:
    описание
    описание список-описаний
     список-операторов:
    оператор
    оператор список-операторов
 
 Если какой-либо идентификатор из списка-описаний был описан
 ранее, то во время выполнения блока внешнее описание подав-
 ляется и снова вступает в силу после выхода из блока.
     Любая инициализация автоматических и регистрационных пе-
 ременных проводится при каждом входе в блок через его нача-
 ло. В настоящее время разрешается (но это плохая практика)
 передавать управление внутрь блока; в таком случае эти ини-
 циализации не выполняются. Инициализации статических пере-
 менных проводятся только один раз, когда начинается выполне-
 ние программы.
     Находящиеся  внутри  блока   внешние   описания   не
резервируют памяти,  так   что   их инициализация   не
разрешается.
     
                           - 211 -
     
     17.3. Условные операторы
     Имеются две формы условных операторов:
 
    IF (выражение) оператор
    IF (выражение) оператор ELSE оператор
 
 В обоих случаях вычасляется выражение и, если оно отлично от
 нуля, то выполняется первый подоператор. Во втором случае,
 если выражение равно нулю, выпалняется второй подоператор.
 Как обычно, двусмысленность "ELSE" разрешается связываением
 ELSE с последним встречающимся IF, у которого нет ELSE.
     17.4. Оператор WHILE
     Оператор WHILE имеет форму
 
      WHILE (выражение) оператор
 
 Подоператор выполняется повторно до тех пор, пока значение
 выражения остается отличным от нуля. проверка производится
 перед каждым выполнением оператора.
     17.5. Оператор DO
     Оператор DO имеет форму
 
 DO оператор WHILE (выражения)
 
     Оператор выполняется повторно до тех пор, пока значение
 выражения не станет равным нулю. Проверка производится после
 каждого выполнения оператора.
     17.6. Оператор FOR
     Оператор FOR имеет форму
 
 (выражение-1  ; выражение-2 ; выражение-3  )оператор
      необ          необ          необ
 
     Оператор FOR эквивалентен следующему
 
  выражение-1;
     WHILE   (выражение-2) \(
        оператор
        выражение-3
  \)
 
 Таким образом, первое выражение определяет инициализацию
 цикла; второе специфиуирует проверку, выполняемую перед каж-
 дой итерацией, так что выход из цикла происходит тогда, ког-
 да значение выражения становится нулем; третье выражение
 часто задает приращение параметра, которое проводится после
 каждой итерации.
     Любое выражение или даже все они могут быть опущены. Ес-
 ли отсутствует второе выражение, то предложение с WHILE счи-
 тается эквивалентным WHILE(1); другие отсутствующие выраже-
 ния просто опускаются из приведенного выше расширения.
     
                           - 212 -
     
     17.7. Оператор SWITCH
     Оператор SWITCH (переключатель), вызывает передачу уп-
 равления к одному из нескольких операторов, в зависимости от
 значения выражения. Оператор имеет форму
 
  SWITCH (выражение) оператор
 
 В выражении проводятся обычные арифметические преобразова-
 ния, но результат должен иметь тип INT. Оператор обычно яв-
 ляется составным. Любой оператор внутри этого оператора мо-
 жет быть помечен одним или более вариантным префиксом CASE,
 имеющим форму:
 
  CASE констанстное выражение:
 
 где константное выражение должно иметь тип INT. Никакие две
 вариантные константы в одном и том же переключателе не могут
 иметь одинаковое значение. точное определение константного
 выражения приводится в п. 23.
     Кроме того, может присутствовать самое большее один опе-
 раторный префикс вида
     
  DEFAULT:
 
     При выполнении оператора SWITCH вычисляется входящее в
 него выражение и сравнивается с каждой вариантной констан-
 той. Если одна из вариантных констант оказывается равной
 значению этого выражения, то управление передается операто-
 ру, который следует за совпадающим вариантным префиксом. Ес-
 ли ни одна из вариантных констант не совпадает со значением
 выражения и если при этом присутствует префикс DEFAULT, то
 управление передается оператору, помеченному этим префиксом.
 если ни один из вариантов не подходит и префикс DEFAULT от-
 сутствует, то ни один из операторов в переключателе не вы-
 полняется.
     Сами по себе префиксы CASE и DEFAULT не изменяют поток
 управления, которое беспрепятсвенно проходит через такие
 префиксы. Для выхода из переключателя смотрите оператор
 BREAK, п. 17.8.
     Обычно оператор, который входит в переключатель, являет-
 ся составным. Описания могут появляться в начале этого опе-
 ратора, но инициализации автоматических и регистровых пере-
 менных будут неэффективными.
     17.8. Оператор BREAK
     Оператор
 
 BREAK;
 
 вызывает завершение выполнения наименьшего охватывающего
 этот оператор оператора WHILE, DO, FOR или SWITCH; управле-
 ние передается оператору, следующему за завершенным операто-
 ром.
     
                           - 213 -
     
     17.9. Оператор CONTINUE
 
 
 
     Оператор
 
  CONTINUE;
 
 приводит к передаче управления на продолжающую цикл часть
 наименьшего охватывающего этот оператор оператора WHILE, DO
 или FOR; то есть на конец цикла. Более точно, в каждом из
 операторов
 
   WHILE(...) \(       DO \(      FOR(...) \(
      ...            ...         ...
   CONTIN: ;           CONTIN: ;     CONTIN: ;
   \)            \) WHILE(...);     \)
 
 Оператор CONTINUE эквивалентен оператору GOTO CONTIN. (За
 CONTIN: следует пустой оператор; см. П. 17.13.).
     17.10. Оператор возврата
     Возвращение из функции в вызывающую программу осуществ-
 ляется с помощью оператора RETURN, который имеет одну из
 следующих форм
 
   RETURN;
    RETURN выражение;
 
 В первом случае возвращаемое значение неопределено. Во вто-
 ром случае в вызывающую функцию возвращается значение выра-
 жения. Если требуется, выражение преобразуется к типу функ-
 ции, в которой оно появляется, как в случае присваивания.
 Попадание на конец функции эквивалентно возврату без возвра-
 щаемого значения.
     17.11. Оператор GOTO
     Управление можно передавать безусловно с помощью опера-
 тора
 
     GOTO идентификатор1
 
 идентификатор должен быть меткой (п. 9.12), Локализованной в
 данной функции.
     17.12. Помеченный оператор
     Перед любым оператором может стоять помеченный префикс
 вида
     идентификатор:
 
 который служит для описания идентификатора в качестве метки.
 Метки используются только для указания места, куда передает-
 ся управление оператором GOTO. Областью действия метки явля-
 ется данная функция, за исключением любых подблоков, в кото-
 рых тот же идентификатор описан снова. Смотри п. 19.
     
                           - 214 -
     
     17.13. Пустой оператор
     Пустой оператор имеет форму:
     
   ;
 
 Пустой оператор оказывается полезным, так как он позволяет
 поставить метку перед закрывающей скобкой \) составного опе-
 ратора или указать пустое тело в операторах цикла, таких как
 WHILE.
     18. Внешние определения
     C-программа представляет собой последовательность внеш-
 них определений. Внешнее определение описывает идентификатор
 как имеющий класс памяти EXTERN (по умолчанию), или возможно
 STATIC, и специфицированный тип. Спецификатор типа (п. 16.2)
 Также может быть пустым; в этом случае считается, что тип
 является типом INT. Область действия внешних определений
 распространяется до конца файла, в котором они приведены,
 точно так же , как влияние описаний простирается до конца
 блока. Синтаксис внешних определений не отличается от син-
 таксиса описаний, за исключением того, что только на этом
 уровне можно приводить текст функций.
     18.1. Внешнее определение функции
     Определение функции имеет форму
 
     определение-функции:
 
     спецификаторы-описания   описатель-функции
 тело-функции
          необ
 
 Единственными спецификаторами класса памяти, допускаемыми в
 качестве спецификаторов-описания, являются EXTERN или
 STATIC; о различии между ними смотри п. 19.2. Описатель фун-
 кции подобен описателю для "функции, возвращающей...", за
 исключением того, что он перечисляет формальные параметры
 определяемой функции.
 
   Оисатель-функции:
  описатель (список-параметров
          необ)
   список параметров:
   идентификатор
   идентификатор, список-параметров
 
 тело-функции имеет форму
 
    тело-функции:
   список-описаний составной-оператор
            
                           - 215 -
     
     Идентификаторы из списка параметров и только они могут
 быть описаны в списке описаний. Любой идентификатор, тип ко-
 торого не указан, считается имеющим тип INT. Единственным
 допустимым здесь спецификатором класса памяти является
 REGISTER; если такой класс памяти специфицирован, то в нача-
 ле выполнения функции соответствующий фактический параметр
 копируется, если это возможно, в регистр.
     Вот простой пример полного определения функции:
 
   INT MAX(A, B, C)
   INT A, B, C;
   \(
  INT M;
  M = (A>B) ? A:B;
  RETURN((M>C) ? M:C);
   \)
 
 Здесь INT - спецификатор-типа, MAX(A,B,C) - описатель-функ-
 ции, INT A,B,C; - список-описаний формальных параметров, \(
 ... \) - Блок, содержащий текст оператора.
     В языке "C" все фактические параметры типа FLOAT преоб-
 разуются к типу DOUBLE, так что описания формальных парамет-
 ров, объявленных как FLOAT, приспособлены прочесть параметры
 типа DOUBLE. Аналогично, поскольку ссылка на массив в любом
 контексте (в частности в фактическом параметре) рассматрива-
 ется как указатель на первый элемент массива, описания фор-
 мальных параметров вила "массив ..." приспособлены прочесть
 : "указатель на ...". И наконец, поскольку структуры,
 объединения и функции не могут быть переданы функции, бесс-
 мысленно описывать формальный параметр как структуру,
 объединение или функцию (указатели на такие объекты, конеч-
 но, допускаются).
     18.2. Внешние определения данных
 
     Внешнее определение данных имеет форму
 
  определение-данных:
    описание
 
 Классом памяти таких данных может быть EXTERN (в частности,
 по умолчанию) или STATIC, но не AUTO или REGISTER.
     19. Правила, определяющие область действия
     Вся C-программа необязательно компилируется одновремен-
 но; исходный текст программы может храниться в нескольких
 файлах и ранее скомпилированные процедуры могут загружаться
 из библиотек. Связь между функциями может осуществляться как
 через явные обращения, так и в результате манипулирования с
 внешними данными.
     Поэтому следует рассмотреть два вида областей действия:
 во-первых, ту, которая может быть названа лексической об-
 ластью действия идентификатора и которая по существу являет-
 ся той областью в программе, где этот идентификатор можно
 использовать, не вызывая диагностического сообщения "неопре-
 деленный идентификатор"; и во-вторых, область действия, ко-
 торая связана с внешними идентификаторами и которая характе-
 ризуется правилом, что ссылки на один и тот же внешний иден-
 тификатор являются ссылками на один и тот же объект.
     
                           - 216 -
     
     19.1. Лексическая область действия
     Лексическая область действия идентификаторов, описанных
 во внешних определениях, простирается от определения до кон-
 ца исходного файла, в котором он находится. Лексическая об-
 ласть действия идентификаторов, являющихся формальными пара-
 метрами, распространяется на ту функцию, к которой они отно-
 сятся. Лексическая область действия идентификаторов, описан-
 ных в начале блока, простирается до конца этого блока. Лек-
 сической областью действия меток является та функция, в ко-
 торой они находятся.
     Поскольку все обращения на один и тот же внешний иденти-
 фикатор обращаются к одному и тому же объекту (см. П. 19.2),
 Компилятор проверяет все описания одного и того же внешнего
 идентификатора на совместимость; в действительности их об-
 ласть действия распространяется на весь файл, в котором они
 находятся.
     Во всех случаях, однако, есть некоторый идентификатор,
 явным образом описан в начале блока, включая и блок, который
 образует функцию, то действие любого описания этого иденти-
 фикатора вне блока приостанавливается до конца этого блока.
     Напомним также (п. 16.5), Что идентификаторы, соответст-
 вующие обычным переменным, с одной стороны, и идентификато-
 ры, соответствующие членам и ярлыкам структур и объединений,
 с другой стороны, формируют два непересекающихся класса, ко-
 торые не вступают в противоречие. Члены и ярлыки подчиняются
 тем же самым правилам определения областей действия, как и
 другие идентификаторы. Имена, специфицируемые с помощью
 TYPEDEF, входят в тот же класс, что и обычные идентификато-
 ры. Они могут быть переопределены во внутренних блоках, но
 во внутреннем описании тип должен быть указан явно:
 
  TYPEDEF FLOAT DISTANCE;
  ...
  \(
     AUTO INT DISTANCE;
     ...
 
 Во втором описании спецификатор типа INT должен присутство-
 вать, так как в противном случае это описание будет принято
 за описание без описателей с типом DISTANCE (прим. Автора:
 согласитесь, что лед здесь тонок.).
     19.2. Область действия внешних идентификаторов
     Если функция ссылается на идентификатор, описанный как
 EXTERN, то где-то среди файлов или библиотек, образующих
 полную программу, должно содержаться внешнее определение
 этого идентификатора. Все функции данной программы, которые
 ссылаются на один и тот же внешний идентификатор, ссылаются
 на один и тот же объект, так что следует позаботиться, чтобы
 специфицированные в этом определении тип и размер были сов-
 местимы с типом и размером, указываемыми в каждой функции,
 которая ссылается на эти данные.
     
                           - 217 -
     
     Появление ключевого слова EBTERN во внешнем определении
 указывает на то, что память для описанных в нем идентифика-
 торов будет выделена в другом файле. Следовательно, в состо-
 ящей из многих файлов программе внешнее определение иденти-
 фикатора, не содержащее спецификатора EXTERN, должно появ-
 ляться ровно в одном из этих файлов. любые другие файлы, ко-
 торые желают дать внешнее определение этого идентификатора,
 должны включать в это определение слово EXTERN. Идентифика-
 тор может быть инициализирован только в том описании, кото-
 рое приводит к выделению памяти.
     Идентификаторы, внешнее определение которых начинается
 со слова STATIC, недоступны из других файлов. Функции могут
 быть описаны как STATIC.
     20. Строки управления компилятором
     Компилятор языка "C" содержит препроцессор, который поз-
 воляет осуществлять макроподстановки, условную компиляцию и
 включение именованных файлов. Строки, начинающиеся с #, об-
 щаются с этим препроцессором. Синтаксис этих строк не связан
 с остальным языком; они могут появляться в любом месте и их
 влияние распространяется (независимо от области действия) до
 конца исходного программного файла.
     20.1. Замена лексем
     Управляющая компилятором строка вида
 
 #DEFINE идентификатор строка-лексем
 
     (Обратите внимание на отсутствие в конце точки с запя-
 той) приводит к тому, что препроцессор заменяет последующие
 вхождения этого идентификатора на указанную строку лексем.
 Строка вида
 
 #DEFINE        идентификатор
 (идентификатор,...,идентификатор)строка лексем
 
 где между первым идентификатором и открывающейся скобкой (
 нет пробела, представляет собой макроопределение с аргумен-
 тами. Последующее вхождение первого идентификатора, за кото-
 рым следует открывающая скобка '(', последовательность раз-
 деленных запятыми лексем и закрывающая скобка ')', заменяют-
 ся строкой лексем из определения. каждое вхождение идентифи-
 катора, упомянутого в списке формальных параметров в опреде-
 лении , заменяется соответствующей строкой лексем из обраще-
 ния. Фактическими аргументами в обращении являются строки
 лексем, разделенные запятыми; однако запятые, входящие в за-
 кавыченные строки или заключенные в круглые скобки, не раз-
 деляют аргументов. Количество формальных и фактических пара-
 метров должно совпадать. Текст внутри строки или символьной
 константы не подлежит замене.
     В обоих случаях замененная строка просматривается снова
 с целью обнаружения других определенных идентификаторов. В
 обоих случаях слишком длинная строка определения может быть
 продолжена на другой строке, если поместить в конце продол-
 жаемой строки обратную косую черту \ .
     
                           - 218 -
     
     Описываемая возможность особенно полезна для определения
 "объявляемых констант", как, например,
 
  #DEFINE TABSIZE 100
  INT TABLE[TABSIZE];
 
 Управляющая строка вида
 
  #UNDEF идентификатор
 
 приводит к отмене препроцессорного определения данного иден-
 тификатора.
     20.2. Включение файлов
     Строка управления компилятором вида
 
  #INCLUDE "FILENAME"
 
 приводит к замене этой строки на все содержимое файла с име-
 нем FILENAME. Файл с этим именем сначала ищется в справочни-
 ке начального исходного файла, а затем в последовательности
 стандартных мест. В отличие от этого управляющая строка вида
 
  #INCLUDE <FILENAME>
 
 ищет файл только в стандартных местах и не просматривает
 справочник исходного файла.
     Строки #INCLUDE могут быть вложенными.
     20.3. Условная компиляция
     Строка управления компилятором вида
 
 #IF константное выражение
 
 проверяет, отлично ли от нуля значение константного выраже-
 ния (см. П. 15). Управляющая строка вида
 
 #IF DEF идентификатор
 
 проверяет, определен ли этот идентификатор в настоящий мо-
 мент в препроцессоре, т.е. Определен ли этот идентификатор с
 помощью управляющей строки #DEFINE.
     21. Неявные описания
     Не всегда является необходимым специфицировать и класс
 памяти и тип идентификатора в описании. Во внешних определе-
 ниях и описаниях формальных параметров и членов структур
 класс памяти определяется по контексту. Если в находящемся
 внутри функции описании не указан тип, а только класс памя-
 ти, то предполагается, что идентификатор имеет тип INT; если
 не указан класс памяти, а только тип, то идентификатор пред-
 полагается описанным как AUTO. Исключение из последнего пра-
 вила дается для функций, потому что спецификатор AUTO для
 функций является бессмысленным (язык "C" не в состоянии ком-
 пилировать программу в стек); если идентификатор имеет тип
 "функция, возвращающая ...", то он предполагается неявно
 описанным как EXTERN.
     
                           - 219 -
     
     Входящий в выражение и неописанный ранее идентификатор,
 за которым следует скобка ( , считается описанным по контек-
 сту как "функция, возвращающая INT".
     22. Снова о типах
     В этом разделе обобщаются сведения об операциях, которые
 можно применять только к объектам определенных типов.
     22.1. Структуры и объединения
     Только две вещи можно сделать со структурой или объеди-
 нением: назвать один из их членов (с помощью операции) или
 извлечь их адрес ( с помощью унарной операции &). Другие
 операции, такие как присваивание им или из них и передача их
 в качестве параметров, приводят к сообщению об ошибке. В бу-
 дущем ожидается, что эти операции, но не обязательно ка-
 кие-либо другие, будут разрешены.
     В п. 15.1 Говорится, что при прямой или косвенной ссылке
 на структуру (с помощью . Или ->) имя справа должно быть
 членом структуры, названной или указанной выражением слева.
 Это ограничение не навязывается строго компилятором, чтобы
 дать возможность обойти правила типов. В действительности
 перед '.' допускается любое L-значение и затем предполагает-
 ся, что это L-значение имеет форму структуры, для которой
 стоящее справа имя является членом. Таким же образом, от вы-
 ражения, стоящего перед '->', требуется только быть указате-
 лем или целым. В случае указателя предполагается, что он
 указывает на структуру, для которой стоящее справа имя явля-
 ется членом. В случае целого оно рассматривается как абсо-
 лютный адрес соответствующей структуры, заданный в единицах
 машинной памяти.
     Такие структуры не являются переносимыми.
     22.2. Функции
     Только две вещи можно сделать с функцией: вызвать ее или
 извлечь ее адрес. Если имя функции входит в выражение не в
 позиции имени функции, соответствующей обращению к ней, то
 генерируется указатель на эту функцию. Следовательно, чтобы
 передать одну функцию другой, можно написать
 
  INT F();
  ...
  G(F);
 
 Тогда определение функции G могло бы выглядеть так:
 
 G(FUNCP)
 INT(*FUNCP)();
 \(
    ...
    (*FUNCP)();
    ...
 \)
 
 Обратите внимание, что в вызывающей процедуре функция F дол-
 жна быть описана явно, потому что за ее появлением в G(F) не
 следует скобка ( .
     
                           - 220 -
     
     22.3. Массивы, указатели и индексация
     Каждый раз, когда идентификатор, имеющий тип массива,
 появляется в выражении, он преобразуется в указатель на пер-
 вый член этого массива. Из-за этого преобразования массивы
 не являются L-значениями. По определению операция индексация
 [] интерпретируется таким образом, что E1[E2] считается
 идентичным выражению *((е1)+(е2)). Согласно правилам преоб-
 разований, применяемым при операции +, если E1 - массив, а
 е2 - целое, то е1[е2] ссылается на е2-й член массива е1. По-
 этому несмотря на несимметричный вид операция индексации яв-
 ляется коммутативной.
     В случае многомерных массивов применяется последователь-
 ное правило. Если е является N-мерным массивом размера
 I*J*...*K, то при появлении в выражении е преобразуется в
 указатель на (N-1)-мерный массив размера J*...*K. Если опе-
 рация * либо явно, либо неявно, как результат индексации,
 применяется к этому указателю, то результатом операции будет
 указанный (N-1)-мерный массив, который сам немедленно преоб-
 разуется в указатель.
     Рассмотрим, например, описание
 
 INT X[3][5];
 
 Здесь X массив целых размера 3*5. При появлении в выражении
 X преобразуется в указатель на первый из трех массивов из 5
 целых. В выражении X[I], которое эквивалентно *(X+I), снача-
 ла X преобразуется в указатель так, как описано выше; затем
 I преобразуется к типу X, что вызывает умножение I на длину
 объекта, на который указывает указатель, а именно на 5 целых
 объектов. Результаты складываются, и применение косвенной
 адресации дает массив (из 5 целых), который в свою очередь
 преобразуется в указатель на первое из этих целых. Если в
 выражение входит и другой индекс, то таже самая аргументация
 применяется снова; результатом на этот раз будет целое.
     Из всего этого следует, что массивы в языке "C" хранятся
 построчно ( последний индекс изменяется быстрее всего) и что
 первый индекс в описании помогает определить общее количест-
 во памяти, требуемое для хранения массива, но не играет ни-
 какой другой роли в вычислениях, связанных с индексацией.
     22.4. Явные преобразования указателей
     Разрешаются определенные преобразования, с использовани-
 ем указателей , но они имеют некоторые зависящие от конкрет-
 ной реализации аспекты. Все эти преобразования задаются с
 помощью операции явного преобразования типа; см. П. 15.2 и
 16.7.
     Указатель может быть преобразован в любой из целочислен-
 ных типов, достаточно большой для его хранения. Требуется ли
 при этом INT или LONG, зависит от конкретной машины. Преоб-
 разующая функция также является машинно-зависимой, но она
 будет вполне естественной для тех, кто знает структуру адре-
 сации в машине. Детали для некоторых конкретных машин приво-
 дятся ниже.
     Объект целочисленного типа может быть явным образом пре-
 образован в указатель. такое преобразование всегда переводит
 преобразованное из указателя целое в тот же самый указатель,
 но в других случаях оно будет машинно-зависимым.
     
                           - 221 -
     
     Указатель на один тип может быть преобразован в указа-
 тель на другой тип. Если преобразуемый указатель не указыва-
 ет на объекты, которые подходящим образом выравнены в памя-
 ти, то результирующий указатель может при использовании вы-
 зывать ошибки адресации. Гарантируется, что указатель на
 объект заданного размера может быть преобразован в указатель
 на объект меньшего размера и снова обратно, не претерпев при
 этом изменения.
     Например, процедура распределения памяти могла бы прини-
 мать запрос на размер выделяемого объекта в байтах, а возв-
 ращать указатель на символы; это можно было бы использовать
 следующим образом.
 
  EXTERN CHAR *ALLOC();
  DOUBLE *DP;
  DP=(DOUBLE*) ALLOC(SIZEOF(DOUBLE));
  *DP=22.0/7.0;
 
 Функция ALLOC должна обеспечивать (машинно-зависимым спосо-
 бом), что возвращаемое ею значение будет подходящим для пре-
 образования в указатель на DOUBLE; в таком случае использо-
 вание этой функции будет переносимым.
     Представление указателя на PDP-11 соответствует 16-бито-
 вому целому и измеряется в байтах. Объекты типа CHAR не име-
 ют никаких ограничений на выравнивание; все остальные объек-
 ты должны иметь четные адреса.
     На HONEYWELL 6000 указатель соответствует 36-битовому
 целому; слову соответствует 18 левых битов и два непосредст-
 венно примыкающих к ним справа бита, которые выделяют символ
 в слове. Таким образом, указатели на символы измеряются в
 единицах 2 в степени 16 байтов; все остальное измеряется в
 единицах 2 в степени 18 машинных слов. Величины типа DOUBLE
 и содержащие их агрегаты должны выравниваться по четным ад-
 ресам слов (0 по модулю 2 в степени 19). Эвм IBM 370 и
 INTERDATA 8/32 сходны между собой. На обеих машинах адреса
 измеряются в байтах; элементарные объекты должны быть выров-
 нены по границе, равной их длине, так что указатели на SHORT
 должны быть кратны двум, на INT и FLOAT - четырем и на
 DOUBLE - восьми. Агрегаты выравниваются по самой строгой
 границе, требуемой каким-либо из их элементов.
     23. Константные выражения
     В нескольких местах в языке "C" требуются выражения, ко-
 торые после вычисления становятся константами: после вариан-
 тного префикса CASE, в качестве границ массивов и в инициа-
 лизаторах. В первых двух случаях выражение может содержать
 только целые константы, символьные константы и выражения
 SIZEOF, возможно связанные либо бинарными операциями
 
  + - * / . % & \! Ч << >> == 1= <> <= >=
 
 либо унарными операциями
 
 - \^
 
 либо тернарной операцией ?:
            
                           - 222 -
     
 Круглые скобки могут использоваться для группировки, но не
 для обращения к функциям.
 
     В случае инициализаторов допускается большая (ударение
 на букву о) свобода; кроме перечисленных выше константных
 выражений можно также применять унарную операцию & к внешним
 или статическим объектам и к внешним или статическим масси-
 вам, имеющим в качестве индексов константное выражение.
 Унарная операция & может быть также применена неявно, в ре-
 зультате появления неиндексированных массивов и функций. Ос-
 новное правило заключается в том, что после вычисления ини-
 циализатор должен становится либо константой, либо адресом
 ранее описанного внешнего или статического объекта плюс или
 минус константа.
     24. Соображения о переносимости
     Некоторые части языка "C" по своей сути машинно-зависи-
 мы. Следующие ниже перечисление потенциальных трудностей хо-
 тя и не являются всеобъемлющими, но выделяет основные из
 них.
     Как показала практика, вопросы, целиком связанные с ап-
 паратным оборудованием, такие как размер слова, свойства
 плавающей арифметики и целого деления, не представляют осо-
 бенных затруднений. Другие аспекты аппаратных средств нахо-
 дят свое отражение в различных реализациях. Некоторые из
 них, в частности, знаковое расширение (преобразующее отрица-
 тельный символ в отрицательное целое) и порядок, в котором
 помещаются байты в слове, представляют собой неприятность,
 которая должна тщательно отслеживаться. Большинство из ос-
 тальных проблем этого типа не вызывает сколько-нибудь значи-
 тельных затруднений.
     Число переменных типа REGISTER, которое фактически может
 быть помещено в регистры, меняется от машины к машине, также
 как и набор допустимых для них типов. Тем не менее все ком-
 пиляторы на своих машинах работают надлежащим образом; лиш-
 ние или недопустимые регистровые описания игнорируются.
     Некоторые трудности возникают только при использовании
 сомнительной практики программирования. Писать программы,
 которые зависят от каких- либо этих свойств, является чрез-
 вычайно неразумным.
     Языком не указывается порядок вычисления аргументов фун-
 кций; они вычисляются справа налево на PDP-11 и VAX-11 и
 слева направо на остальных машинах. порядок, в котором про-
 исходят побочные эффекты, также не специфицируется.
     Так как символьные константы в действительности являются
 объектами типа INT, допускается использование символьных
 констант, состоящих из нескольких символов. Однако, посколь-
 ку порядок, в котором символы приписываются к слову, меняет-
 ся от машины к машине, конкретная реализация оказывается
 весьма машинно-зависимой.
     Присваивание полей к словам и символов к целым осуществ-
 ляется справо налево на PDP-11 и VAX-11 и слева направо на
 других машинах. эти различия незаметны для изолированных
 программ, в которых не разрешено смешивать типы (преобразуя,
 например, указатель на INT в указатель на CHAR и затем про-
 веряя указываемую память), но должны учитываться при согла-
 совании с накладываемыми извне схемами памяти.
     
                          - 223 -
     
     Язык, принятый на различных компиляторах, отличается
 только незначительными деталями. Самое заметное отличие сос-
 тоит в том, что используемый в настоящее время компилятор на
 PDP-11 не инициализирует структуры, которые содержат поля
 битов, и не допускает некоторые операции присваивания в оп-
 ределенных контекстах, связанных с использованием значения
 присваивания.
     25. Анахронизмы
     Так как язык "C" является развивающимся языком, в старых
 программах можно встретить некоторые устаревшие конструкции.
 Хотя большинство версий компилятора поддерживает такие анах-
 ронизмы, они в конце концов исчезнут, оставив за собой толь-
 ко проблемы переносимости.
     В ранних версиях "C" для проблем присваивания использо-
 валась форма =ON, а не ON=, приводя к двусмысленностям, ти-
 пичным примером которых является
     
 X = -1
 
 где X фактически уменьшается, поскольку операции = и - при-
 мыкают друг к другу, но что вполне могло рассматриваться и
 как присваивание -1 к X.
     Синтаксис инициализаторов изменился: раньше знак равенс-
 тва, с которого начинается инициализатор, отсутствовал, так
 что вместо
 
 INT X = 1;
 
 использовалось
 
 INT X 1;
 
 изменение было внесено из-за инициализации
 
 INT F (1+2)
 
 которая достаточно сильно напоминает определение функции,
 чтобы смутить компиляторы.
     26. Сводка синтаксических правил
     Эта сводка синтаксиса языка "C" предназначена скорее для
 облегчения понимания и не является точной формулировкой язы-
 ка.
     26.1. Выражения
     Основными выражениями являются следующие:
 
    выражение:
     первичное-выражение
   * выражение
   & выражение
   - выражение
   ! Выражение
  \^ выражение
  ++ L-значение
  -- L-значение
   L-значение ++
   L-значение --
     
                           - 224 -
     
   SIZEOF выражение
   (имя типа) выражение
   выражение бинарная-операция выражение
   выражение ? Выражение : выражение
   L-значение операция-присваивания выражение
   выражение , выражение
    первичное выражение:
   идентификатор
   константа
   строка
   (выражение)
   первичное-выражение (список выражений
           необ)
   первичное-выражение [выражение]
   L-значение . Идентификатор
   первичное выражение -> идентификатор
    L-значение:
   идентификатор
   первичное-выражение [выражение]
   L-значение . Идентификатор
   первичное-выражение -> идентификатор
   * выражение
   (L-значение)
 
 Операции первичных выражений
 
   () []  .  ->
 
 имеют  самый  высокий  приоритет  и  группируются   слева
 направо. Унарные операции
     
   *  &  -  !  \^  ++  --  SIZEOF(Имя типа)
 
 имеют более низкий приоритет, чем операции первичных выраже-
 ний, но более высокий, чем приоритет любой бинарной опера-
 ции. Эти операции группируются справа налево. Все бинарные
 операции и условная операция (прим. Перевод.: условная опе-
 рация группируется справа налево; это изменение внесено в
 язык в 1978 г.) группируются слева направо и их приоритет
 убывает в следующем порядке:
 
   Бинарные операции:
       *   /   %
       +   -
       >>  <<
       <   >  <=   >=
       ==  !=
       &
       \^
       \!
       &&
     \!\!
       ?:
            
                           - 225 -
     
 Все операции присваивания имеют одинаковый приоритет и груп-
 пируются справа налево.
 Операции присваивания:
   =  +=  -=  *=  ?=  %=  >>=  <<=  &=  \^=  \!=
 
 Операция запятая имеет самый низкий приоритет и группируется
 слева направо.
     26.2. Описания
 Описание:
 спецификаторы-описания список-инициализируемых-описателей
         необ;
---------------------------------------------------------
 
 спецификаторы-описания:
 
   спецификатор-типа спецификаторы-описания
        необ
   спецификатор-класса-памяти спецификаторы-описания
        необ
 спецификатор-класса-памяти:
  AUTO
  STATIC
  EXTERN
  REGISTER
  TYPEDEF
 спецификатор-типа:
   CHAR
   SHORT
   INT
   LONG
   UNSIGNED
   FLOAT
   DOUBLE
    спецификатор-структуры-или-объединения
    определяющее-тип-имя
 список-инициализируемых-описателей:
    инициализируемый-описатель
    инициализируемый-описатель,
    список-инициализируемых-описателей
 инициализируемый-описатель
   описатель-инициализатор
     необ
 описатель:
    идентификатор
    (описатель)
    * описатель
    описатель ()
    описатель [константное выражение
          необ]
     
                           - 226 -
     
 спецификатор-структуры-или-объединения:
    STRUCT список-описателей-структуры
    STRUCT идентификатор \(список-описаний-структуры\)
    STRUCT идентификатор
    UNION \(список-описаний-структуры\)
    UNION идентификатор \(список-описаний-структуры\)
    UNION идентификатор
 список-описаний-структцры:
    описание-структуры
    описание-структуры список-описаний-структуры
 описание структуры:
    спецификатор-типа список-описателей-структуры:
 список-описателей-структуры
    описатель-структуры
    описатель-структуры,список-описателей-структуры
 описатель-структуры:
    описатель
    описатель: константное выражение
    :константное-выражение
 инициализатор:
    = выражение
    = \(список-инициализатора\)
    = \(список-инициализатора\)
 список инициализатора:
    выражение
    список-инициализатора,список-инициализатора
    \(список-инициализатора\)
 имя-типа:
    спецификатор-типа абстрактный-описатель
 абстрактный-описатель:
    пусто
    \(абстрактный-описатель\)
    * абстрактный-описатель
    абстрактный-описатель ()
    абстрактный-описатель [константное-выражение
             необ]
 определяющее-тип-имя:
   идентификатор
     26.3. Операторы
 составной-оператор:
   \(список-описаний      список-операторов
         необ      необ\)
 список-описаний:
   описание
   описание список-описаний
 список-операторов:
   оператор
   оператор список-операторов
 оператор:
   составной оператор
   выражение;
     
                           - 227 -
     
   IF (выражение) оператор
   IF (выражение) оператор ELSE оператор
   WHILE (выражение) оператор
   DO оператор WHILE (выражение);
   FOR(выражение-1    ;выражение-2    ;выражение-3    )
       необ      необ   необ
  оператор
   SWITCH (выражение) оператор
   CASE константное-выражение : оператор
   DEFAULT: оператор
   BREAK;
   CONTINUE;
   RETURN;
   RETURN выражение;
   GOTO идентификатор;
   идентификатор : оператор
   ;
     26.4. Внешние определения
 Программа:
   внешнее-определение
   внешнее-определение программа
 внешнее-определение:
   определение-функции
   определение-данных
 определение-функции:
   спецификатор-типа     описатель-функции тело-функции
         необ
 описатель-функции:
   описатель (список-параметров    )
     необ
 список-параметров:
    идетификатор
    идентификатор , список-параметров
 тело-функции:
    список-описаний-типа оператор-функции
 оператор-функции:
    \(список описаний     список-операторов\)
          необ
 определение данных:
    EXTERN  спецификатор типа    список
    необ   необ
   инициализируемых описателей    ;
      необ
    STATIC  спецификатор типа     список
    необ   необ
   инициализируемых описателей
      необ;
     26.5. Препроцессор
 #DEFINE идентификатор строка-лексем
 #DEFINE
     
                           - 229 -
     
 #DEFINE идентификатор(идентификатор,...,идентификатор)стр
 #UNDEF идентификатор
 #INCLUDE "имя-файла"
 #INCLUDE <имя-файла>
 #IF константное-выражение
 #IFDEF идентификатор
 #IFNDEF идентификатор
 #ELSE
 #ENDIF
 #LINE константа идентификатор
 
      Последние изменения языка "C" (15 ноября 1978 г.)
 
     27. Присваивание структуры
     Структуры могут быть присвоены, переданы функциям в ка-
 честве аргументов и возвращены функциям. Типы участвующих
 операндов должны оставаться теми же самыми. Другие правдопо-
 добные операторы, такие как сравнение на равенство, не были
 реализованы.
     В реализации возвращения структур функциями на PDP-11
 имеется коварный дефект: если во время возврата происходит
 прерывание и та же самая функция пеентерабельно вызывается
 во время этого прерывания, то значение возвращаемое из пер-
 вого вызова, может быть испорчено. Эта трудность может воз-
 никнуть только при наличии истинного прерывания, как из опе-
 рационной системы, так и из программы пользователя, прерыва-
 ния, которое существенно для использования сигналов; обычные
 рекурсивные вызовы совершенно безопасны.
     28. Тип перечисления
     Введен новый тип данных,аналогичный скалярным типам язы-
 ка паскаль. К спецификатору-типа в его синтаксическом описа-
 нии в разделе 8.2. Приложения а следует добавить
 
  спецификатор-перечисления
  -------------------------
 
 с синтаксисом
 
 
 пецификатор-перечисления:
 -------------------------
 ENUM список-перечисления
      -------------------
 ENUM идентификатор  список-перечисления
      -------------  -------------------
 ENUM идентификатор
      -------------
            
                           - 230 -
 
 cписок-перечисления:
 -------------------
 перечисляемое
 -------------
 список-перечисления, перечисляемое
 -------------------  -------------
 перечисляемое:
 --------------
   идентификатор
  -------------
  идентификатор = константное выражение
  -------------   ---------------------
 
     Роль идентификатора в спецификаторе-перечисления пол-
 ностью аналогична роли ярлыка структуры в спецификато-
 ре-структуры; идентификатор обозначает определенное перечис-
 ление. Например, описание
 
  ENUM COLOR \(RED, WHITE, BLACK, BLUE \);
  . . .
  ENUM COLOR *CP, COL;
 
 
 Объявляет идентификатор COLOR ярлыком перечисления типа,
 описывающего различные цвета и затем объявляет CP указателем
 на объект этого типа, а COL - объектом этого типа.
     Идентификаторы в списке-перечисления описываются как
 константы и могут появиться там, где требуются (по контекс-
 ту) константы. Если не используется вторая форма перечисляе-
 мого (с равеством =), то величины констант начинаются с 0 и
 возрастают на 1 в соответствии с прочтением их описания сле-
 ва на право. Перечисляемое с присвоением = придает соответс-
 твующему идентификатору указанную величину; последующие
 идентификаторы продолжают прогрессию от приписанной величи-
 ны.
     Все ярлыки перечисления и константы могут быть различны-
 ми и непохожими на ярлыки и члены структур даже при условии
 использования одного и того же множества идентификаторов.
     Объекты данного типа перечисления рассматриваются как
 объекты, имеющие тип, отличный от любых типов и контролирую-
 щая программа LINT сообщает об ошибках несоответствия типов.
 В реализации на PDP-11 со всеми перечисляемыми переменными
 оперируют так, как если бы они имели тип INT.
     29. Таблица изображений непечатных символов языка "C".
     В данной таблице приведены изображения некоторых симво-
 лов (фигурные скобки и т.д.) языка "C", которых может не
 оказаться в знаковом наборе дисплея или печатающего устройс-
 тва.
     
                           - 231 -
     
 -------------------------------------------------
 !    Значение          !   Изображение   **     !
 !                      !    В тексте            !
 -------------------------------------------------
 !  Фигурная открывающаяся  !                    !
 !    Скобка                !        \(          !
 !                          !                    !
 -------------------------------------------------
 !  Фигурная закрывающаяся  !                    !
 !    Скобка                !        \)          !
 !                          !                    !
 -------------------------------------------------
 ! Вертикальная             !                    !
 !    Черта                 !        \!          !
 !                          !                    !
 -------------------------------------------------
 !                          !                    !
 !   Апостороф              !        \'          !
 !                          !                    !
 -------------------------------------------------
 !    Волнистая             !                    !
 !      Черта               !        \^          !
 !                          !                    !
 -------------------------------------------------
  
     ** П_р_и_м_е_ч_а_н_и_е:
     Изображения приведены для операционой системы UNIX. При
 работе компилятора "C" под управлением любой другой операци-
 онной системы, необходимо воспользоваться соответствующим
 руководством для данной системы.
