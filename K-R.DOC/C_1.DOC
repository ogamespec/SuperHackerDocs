                     
     
     
     
     
     
     
     
     
     
     
                            
                            ЯЗЫК С
     
     
                        Б.В. Керниган,
                          Д.М. Ричи.
     
                             - 1 -
     Аннотация
     Язык "C"(произносится "си") - это универсальный язык
программирования, для которого характерны экономичность выра-
жения, современный поток управления и структуры данных, бога-
тый набор операторов. Язык "C" не является ни языком "очень
высокого уровня", ни "большим" языком, и не предназначается
для некоторой специальной области применения. но отсутствие
ограничений и общность языка делают его более удобным и эф-
фективным для многих задач, чем языки, предположительно более
мощные.
      Язык "C", первоначально предназначавшийся для написания
 операционной системы "UNIX" на ЭВМ DEC PDP-11, был разрабо-
 тан и реализован на этой системе Деннисом Ричи. Операционная
 система, компилятор с языка "C" и по существу все прикладные
 программы системы "UNIX" (включая все программное обеспече-
 ние, использованное при подготовке этой книги) написаны на
 "C". Коммерческие компиляторы с языка "C" существуют также
 на некоторых других ЭВМ, включая IBM SYSTEM/370, HONEYWELL
 6000, INTERDATA 8/32. Язык "C", однако, не связан с каки-
 ми-либо определенными аппаратными средствами или системами,
 и на нем легко писать программы, которые можно пропускать
 без изменений на любой ЭВМ, имеющей "C"-компилятор.
      Эта книга предназначена для того, чтобы помочь читателю
 научиться программировать на языке "C". Она содержит учебное
 введение, цель которого - позволить новым пользователям на-
 чать программировать как можно быстрее, отдельные главы по
 всем основным особенностям языка и справочное руководство.
 Обучение построено в основном на чтении, написании и разборе
 примеров, а не голой формулировке правил. Примеры, приводи-
 мые в книге, по большей части являются законченными реальны-
 ми программами, а не отдельными фрагментами. Все примеры бы-
 ли проверены непосредственно с текста книги, где они напеча-
 таны в виде, пригодном для ввода в машину. Кроме указаний о
 том, как сделать использование языка более эффективным, мы
 также пытались, где это возможно, проиллюстрировать полезные
 алгоритмы и принципы хорошего стиля и разумной разработки.
      Настоящая книга не является вводным курсом в программи-
 рование; она предполагает определенное знакомство с основны-
 ми понятиями программирования такими как переменные, опера-
 торы присваивания, циклы, функции. Тем не менее и новичок в
 программировании должен оказаться в состоянии читать подряд
 и освоиться с языком, хотя при этом была бы полезной помощь
 более опытного коллеги.
      По нашему опыту , "C" показал себя приятным, вырази-
 тельным и разносторонним языком на широком множестве разно-
 образных программ. Его легко выучить , и он не теряет своих
 качеств с ростом опыта программиста. Мы надеемся , что эта
 книга поможет вам хорошо его использовать.
     
                           - 2 -
     
      Вдумчивая критика и предложения многих наших друзей и
 коллег очень много добавили как для самой книги, так и для
 нашего удовольствия при ее написании. В частности, Майк Би-
 апси, Джим Блю, Стью Фельдман, Доуг Мак-Илрой, Билл Рум, Боб
 Розин и Ларри Рослер тщательно прочитали множество вариан-
 тов. Мы также обязаны Элю Ахо, Стиву Борну, Дэву Двораку,
 Чаку Хэлею, Дебби Хэлей, Мариону Харрису, Рику Холту, Стиву
 Джонсону, Джону Машею, Бобу Митцу, Ральфу Мьюа, Питеру Нель-
 сону, Эллиоту Пинсону, Биллу Плагеру, Джерри Спиваку, Кену
 Томпсону и Питеру Вейнбергеру за полезные замечания на раз-
 личных этапах и Майку Лоску и Джо Осанна за неоценимую по-
 мощь при печатании книги.
         Брайен В. Керниган
            Деннис М. Ричи
      
     
                           - 3 -
     
                      Содержание
 
       Aннотация ........................................1
 0.1.  Введение   .......................................7
 1.    Учебное введение..................................
 1.1.     Hачинаем.......................................
 1.2.     Переменные и арифметика........................
 1.3.     Оператор FOR...................................
 1.4.     Символические константы........................
 1.5.     Набор полезных программ........................
 1.5.1.     Ввод и вывод символов........................
 1.5.2.     Копирование файла............................
 1.5.3.     Подсчет символов.............................
 1.5.4.     Подсчет строк................................
 1.5.5.     Подсчет слов.................................
 1.6.     Массивы........................................
 1.7.     Функции........................................
 1.8.     Аргументы - вызов по значению..................
 1.9.     Массивы символов...............................
 1.10.    Область действия: внешние переменные...........
 1.11.    Резюме.........................................
 2.    Типы, операции и выражения........................
 2.1.     Имена переменных...............................
 2.2.     Типы и размеры данных..........................
 2.3.     Константы......................................
 2.3.1.     Символьная константа.........................
 2.3.2.     Константное выражение........................
 2.3.3.     Строчная константа...........................
 2.4.     Описания.......................................
 2.5.     Арифметические операции........................
 2.6.     Операции отношения и логические операции.......
 2.7.     Преобразование типов...........................
 2.8.     Операции увеличения и уменьшения...............
 2.9.     Побитовые логические операции..................
 2.10.    Операции и выражения присваивания..............
 2.11.    Условные выражения.............................
 2.12.    Старшинство и порядок вычисления...............
 3.    Поток управления..................................
 3.1.     Операторы и блоки..............................
 3.2.     IF - ELSE......................................
 3.3.     ELSE - IF......................................
 3.4.     Переключатель..................................
 3.5.     Циклы - WHILE и FOR............................
 3.6.     Цикл DO - WHILE................................
 3.7.     Оператор BREAK.................................
 3.8.     Оператор CONTINUE..............................
 3.9.     Оператор GOTO и метки..........................
 4.    Функции и структура программ......................
 4.1.     Основные сведения..............................
 4.2.     Функции, возвращающие нецелые значения.........
 4.3.     Еще об аргументах функций......................
 4.4.     Внешние переменные.............................
 4.5.     Правила, определяющие область действия.........
 4.5.1.     Область действия.............................
 4.6.     Статические переменные.........................
 4.7.     Регистровые переменные.........................
 4.8.     Блочная структура..............................
 4.9.     Инициализация..................................
     
                             - 4 -
     
 4.10.    Рекурсия.......................................
 4.11.    Препроцессор языка "C".........................
 4.11.1.    Включение файлов.............................
 4.11.2.    Mакроподстановка.............................
 5.       Указатели и массивы............................
 5.1.     Указатели и адреса.............................
 5.2.     Указатели и аргументы функций..................
 5.3.     указатели и массивы............................
 5.4.     Адресная арифметика............................
 5.5.     указатели символов и функции...................
 5.6.     Указатели - не целые...........................
 5.7.     Многомерные массивы............................
 5.8.     Массивы указателей; указатели указателей.......
 5.9.     Инициализация массивов указателей..............
 5.10.    Указатели и многомерные массивы................
 5.11.    Командная строка аргументов....................
 5.12.    Указатели на функции...........................
 6.    Структуры.........................................
 6.1.     Основные сведения..............................
 6.2.     Структуры и функции............................
 6.3.     Массивы сруктур................................
 6.4.     Указатели на структуры.........................
 6.5.     Структуры, ссылающиеся на себя.................
 6.6.     Поиск в таблице................................
 6.7.     Поля...........................................
 6.8.     Объединения....................................
 6.9.     Определение типа...............................
 7.    Ввод и вывод......................................
 7.1.     Обращение к стандартной библиотеке.............
 7.2.     Стандартный ввод и вывод - функции  GETCHAR
          и PUTCHAR......................................
 7.3.     Форматный вывод - функция PRINTF...............
 7.4.     Форматный ввод - функция SCANF.................
 7.5.     Форматное преобразование в памяти..............
 7.6.     Доступ к файлам................................
 7.7.     Обработка ошибок - STDERR и EXIT...............
 7.8.     Ввод и вывод строк.............................
 7.9.     Несколько разнообразных функций................
 7.9.1.     Проверка вида символов и преобразования......
 7.9.2.     Функция UNGETC...............................
 7.9.3.     Обращение к системе..........................
 7.9.4.     Управление памятью...........................
 8.    Интерфейс системы UNIX............................
 8.1.     Дескрипторы файлов.............................
 8.2.     Низкоуровневый ввод/вывод - операторы  READ
          и WRITE........................................
 8.3.     Открытие, создание, закрытие и  расцепление
          (UNLINK).......................................
 8.4.     Произвольный доступ - SEEK и LSEEK.............
 8.5.     Пример - реализация функций FOPEN и GETC.......
 8.6.     Пример - распечатка справочников...............
 8.7.     Пример - распределитель памяти.................
     
                             - 5 -
       Приложение а: справочное руководство по языку 'C'.
 9.1.     Введение.......................................
 10.   Лексические соглашения............................
 10.1.    Комментарии....................................
 10.2.    Идентификаторы (имена).........................
 10.3.    Ключевые слова.................................
 10.4.    Константы......................................
 10.4.1.    Целые константы..............................
 10.4.2.    Явные длинные константы......................
 10.4.3.    Символьные константы.........................
 10.4.4.    Плавающие константы..........................
 10.5.    Строки.........................................
 10.6.    Характеристики аппаратных средств..............
 11.   Синтаксическая нотация............................
 12.   Что в имене тебе моем?............................
 13.   Объекты и L-значения..............................
 14.   Преобразования....................................
 14.1.    Символы и целые................................
 14.2.    Типы FLOAT и DOUBLE............................
 14.3.    Плавающие и целочисленные величины.............
 14.4.    Указатели и целые..............................
 14.5.    Целое без знака................................
 14.6.    Арифметические преобразования..................
 15.   Выражения.........................................
 15.1.    Первичные выражения............................
 15.2.    Унарные операции...............................
 15.3.    Мультипликативные операции.....................
 15.4.    Аддитивные операции............................
 15.5.    Операции сдвига................................
 15.6.    Операции отношения.............................
 15.7.    Операции равенства.............................
 15.8.    Побитовая операция 'и'.........................
 15.9.    Побитовая операция исключающего 'или'..........
 15.10.   Побитовая операция включающего 'или'...........
 15.11.   Логическая операция 'и'........................
 15.12.   Операция логического 'или'.....................
 15.13.   Условная операция..............................
 15.14.   Операция присваивания..........................
 15.15.   Операция запятая...............................
 16.   Описания..........................................
 16.1.    Спецификаторы класса памяти....................
 16.2.    Спецификаторы типа.............................
 16.3.    Описатели......................................
 16.4.    Смысл описателей...............................
 16.5.    Описание структур и объединений................
 16.6.    Инициализация..................................
 16.7.    Имена типов....................................
 16.8.    TYPEDEF........................................
 17.   Операторы.........................................
 17.1.    Пператорное выражение..........................
 17.2.    Составной оператор (или блок)..................
 17.3.    Условные операторы.............................
 17.4.    Оператор WHILE.................................
 17.5.    Оператор DO....................................
     
                             - 6 -
 17.6.    Оператор FOR...................................
 17.7.    Оператор SWITCH................................
 17.8.    Оператор BREAK.................................
 17.9.    Оператор CONTINUE..............................
 17.10.   Оператор возврата..............................
 17.11.   Оператор GOTO..................................
 17.12.   Оомеченный оператор............................
 17.13.   Оустой оператор................................
 18.   Внешние определения...............................
 18.1.    Внешнее определение функции....................
 18.2.    Внешние определения данных.....................
 19.   Правила, определяющие область действия............
 19.1.    Лексическая область действия...................
 19.2.    Область действия внешних идентификаторов.......
 20.   Строки управления компилятором....................
 20.1.    Замена лексем..................................
 20.2.    Включение файлов...............................
 20.3.    Условная компиляция............................
 21.   Неявные описания..................................
 22.   Снова о типах.....................................
 22.1.    Структуры и объединения........................
 22.2.    Функции........................................
 22.3.    Массивы, указатели и индексация................
 22.4.    Явные преобразования указателей................
 23.   Константные выражения.............................
 24.   Соображения о переносимости.......................
 25.   Анахронизмы.......................................
 26.   Сводка синтаксических правил......................
 26.1.    Выражения......................................
 26.2.    Описания.......................................
 26.3.    Операторы......................................
 26.4.    Внешние определения............................
 26.5.    Препроцессор...................................
 27.   Присваивание структуры............................
 28.   Тип перечисления..................................
 29.   Таблица изображений непечатных символов языка "C".
          
                             - 7 -
 0.1. Введение.
      Язык "C" является универсальным языком программирова-
 ния. Он тесно связан с операционной системой "UNIX" , так
 как был развит на этой системе и так как "UNIX" и ее прог-
 раммное обеспечение написано на "C". Сам язык , однако, не
 связан с какой-либо одной операционной системой или машиной;
 и хотя его называют языком системного программирования, так
 как он удобен для написания операционных систем, он с равным
 успехом использовался при написании больших вычислительных
 программ, программ для обработки текстов и баз данных.
      Язык "C" - это язык относительно "низкого уровня". В
 такой характеристике нет ничего оскорбительного; это просто
 означает, что "C" имеет дело с объектами того же вида, что и
 большинство ЭВМ, а именно, с символами, числами и адресами.
 Они могут объединяться и пересылаться посредством обычных
 арифметических и логических операций, осуществляемых реаль-
 ными ЭВМ.
      В языке "C" отсутствуют операции, имеющие дело непос-
 редственно с составными объектами, такими как строки симво-
 лов, множества, списки или с массивами, рассматриваемыми как
 целое. Здесь, например, нет никакого аналога операциям PL/1,
 оперирующим с целыми массивами и строками. Язык не предос-
 тавляет никаких других возможностей распределения памяти,
 кроме статического определения и механизма стеков, обеспечи-
 ваемого локальными переменных функций; здесь нет ни
 "куч"(HEAP), ни "сборки мусора", как это предусматривается в
 АЛГОЛЕ-68. Наконец, сам по себе "C" не обеспечивает никаких
 возможностей ввода-вывода: здесь нет операторов READ или
 WRITE и никаких встроенных методов доступа к файлам. Все эти
 механизмы высокого уровня должны обеспечиваться явно вызыва-
 емыми функциями.
      Аналогично, язык "C" предлагает только простые, после-
 довательные конструкции потоков управления: проверки, циклы,
 группирование и подпрограммы, но не мультипрограммирование,
 параллельные операции, синхронизацию или сопрограммы.
      Хотя отсутствие некоторых из этих средств может выгля-
 деть как удручающая неполноценность ("выходит, что я должен
 обращаться к функции, чтобы сравнить две строки символов
 ?!"), но удержание языка в скромных размерах дает реальные
 преимущества. Так как "C" относительно мал, он не требует
 много места для своего описания и может быть быстро выучен.
 Компилятор с "C" может быть простым и компактным. Кроме то-
 го, компиляторы легко пишутся; при использовании современной
 технологии можно ожидать написания компилятора для новой ЭВМ
 за пару месяцев и при этом окажется, что 80 процентов прог-
 раммы нового компилятора будет общей с программой для уже
 существующих компиляторов. Это обеспечивает высокую степень
 мобильности языка. Поскольку типы данных и стуктуры управле-
 ния, имеющиеся в "C", непосредственно поддерживаются боль-
 шинством существующих ЭВМ, библиотека, необходимая во время
 прогона изолированных программ, оказывается очень маленькой.
 На PDP -11, например, она содержит только программы для
 32-битового умножения и деления и для выполнения программ
 ввода и вывода последовательностей. Конечно, каждая реализа-
 ция обеспечивает исчерпывающую, совместимую библиотеку функ-
 ций для выполнения операций ввода-вывода, обработки строк и
 распределения памяти, но так как обращение к ним осуществля-
 ется только явно, можно , если необходимо, избежать их вызо-
 ва; эти функции могут быть компактно написаны на самом "C".
     
                             - 8 -
     
      Опять же из-за того , что язык "C" отражает возможности
 современных компьютеров, программы на "C" оказываются доста-
 точно эффективными, так что не возникает побуждения писать
 вместо этого программы на языке ассемблера. Наиболее убеди-
 тельным примером этого является сама операционная система
 "UNIX", которая почти полностью написана на "C". Из 13000
 строк программы системы только около 800 строк самого низко-
 го уровня написаны на ассемблере. Кроме того, по существу
 все прикладное программное обеспечение системы "UNIX" напи-
 сано на "C"; подавляющее большинство пользователей системы
 "UNIX"(включая одного из авторов этой книги) даже не знает
 языка ассемблера PDP-11.
      Хотя "C" соответствует возможностям многих ЭВМ, он не
 зависит от какой-либо конкретной архитектуры машины и в силу
 этого без особых усилий позволяет писать "переносимые" прог-
 раммы, т.е. программы, которые можно пропускать без измене-
 ний на различных аппаратных средствах. В наших кругах стал
 уже традицией перенос программного обеспечения, разработан-
 ного на системе "UNIX", на системы ЭВМ: HONEYWELL, IBM и
 INTERDATA. Фактически компиляторы с "C" и программное обес-
 печение во время прогона программ на этих четырех системах,
 по-видимому, гораздо более совместимы, чем стандартные вер-
 сии фортрана американского национального института стандар-
 тов (ANSI). Сама операционная система "UNIX" теперь работает
 как на PDP-11, так и на INTERDATA 8/32. За исключением прог-
 рамм, которые неизбежно оказываются в некоторой степени ма-
 шинно-зависимыми, таких как компилятор, ассемблер и отлад-
 чик. Написанное на языке "C" программное обеспечение иден-
 тично на обеих машинах. Внутри самой операционной системы
 7000 строк программы, исключая математическое обеспечение
 языка ассемблера ЭВМ и управления операциями ввода-вывода,
 совпадают на 95 процентов.
      Программистам, знакомым с другими языками, для сравне-
 ния и противопоставления может оказаться полезным упоминание
 нескольких исторических, технических и философских аспектов
 "C".
      Многие из наиболее важных идей "C" происходят от гораз-
 до более старого, но все еще вполне жизненного языка BCPL ,
 разработанного Мартином Ричардсом. Косвенно язык BCPL оказал
 влияние на "C" через язык "B", написанный Кеном Томпсоном в
 1970 году для первой операционной системы "UNIX" на ЭВМ
 PDP-7.
      Хотя язык "C" имеет несколько общих с BCPL характерных
 особенностей, он никоим образом не является диалектом пос-
 леднего. И BCPL и "B" - "безтипные" языки; единственным ви-
 дом данных для них являются машинное слово, а доступ к дру-
 гим объектам реализуется специальными операторами или обра-
 щением к функциям. В языке "C" объектами основных типов дан-
 ных являются символы, целые числа нескольких размеров и чис-
 ла с плавающей точкой. Кроме того, имеется иерархия произ-
 водных типов данных, создаваемых указателями, массивами,
 структурами, объединениями и функциями.
      
                             - 9 -
     
      Язык "C" включает основные конструкции потока управле-
 ния, требуемые для хорошо структуированных программ: группи-
 рование операторов, принятие решений (IF), циклы с проверкой
 завершения в начале (WHILE, FOR) или в конце (DO) и выбор
 одного из множества возможных вариантов (SWITCH). (Все эти
 возможности обеспечивались и в BCPL, хотя и при несколько
 отличном синтаксисе; этот язык предчувствовал наступившую
 через несколько лет моду на структурное программирование).
      В языке "C" имеются указатели и возможность адресной
 арифметики. Аргументы передаются функциям посредством копи-
 рования значения аргумента , и вызванная функция не может
 изменить фактический аргумент в вызывающей программе. Если
 желательно добиться "вызова по ссылке", можно неявно пере-
 дать указатель, и функция сможет изменить объект, на который
 этот указатель указывает. Имена массивов передаются указани-
 ем начала массивов, так что аргументы типа массивов эффек-
 тивно вызываются по ссылке.
      К любой функции можно обращаться рекурсивно, и ее ло-
 кальные переменные обычно "автоматические", т.е. Создаются
 заново при каждом обращении. Описание одной функции не может
 содержаться внутри другой, но переменные могут описываться в
 соответствии с обычной блочной структурой. Функции в "C" -
 программе могут транслироваться отдельно. переменные по от-
 ношению к функции могут быть внутренними, внешними, но из-
 вестными только в пределах одного исходного файла, или пол-
 ностью глобальными. Внутренние переменные могут быть автома-
 тическими или статическими. Автоматические переменные для
 большей эффективности можно помещать в регистры, но объявле-
 ние регистра является только указанием для компилятора и ни-
 как не связано с конкретными машинными регистрами.
      Язык "C" не является языком со строгими типами в смысле
 паскаля или алгола 68. Он сравнительно снисходителен к пре-
 образованию данных, хотя и не будет автоматически преобразо-
 вывать типы данных с буйной непринужденностью языка PL/1.
 Существующие компиляторы не предусматривают никакой проверки
 во время выполнения программы индексов массивов, типов аргу-
 ментов и т.д.
      В тех ситуациях, когда желательна строгая проверка ти-
 пов, используется специальная версия компилятора. Эта прог-
 рамма называется LINT очевидно потому, она выбирает кусочки
 пуха из вашей программы. Программа LINT не генерирует машин-
 ного кода, а делает очень строгую проверку всех тех сторон
 программы, которые можно проконтролировать во время компиля-
 ции и загрузки. Она определяет несоответствие типов, несов-
 местимость аргументов, неиспользованные или очевидным обра-
 зом неинициализированные переменные, потенциальные трудности
 переносимости и т.д. Для программ,которые благополучно про-
 ходят через LINT, гарантируется отсутствие ошибок типа при-
 мерно с той же полнотой, как и для программ, написанных,
 например, на АЛГОЛЕ-68. Другие возможности программы LINT
 будут отмечены, когда представится соответствующий случай.
     
                            - 10 -
     
      Наконец, язык "C", подобно любому другому языку, имеет
 свои недостатки. Некоторые операции имеют неудачное старшин-
 ство; некоторые разделы синтаксиса могли бы быть лучше; су-
 шествует несколько версий языка, отличающихся небольшими де-
 талями. Тем не менее язык "C" зарекомендовал себя как исклю-
 чительно эффективный и выразительный язык для широкого раз-
 нообразия применений программирования.
      Содержание книги организовано следующим образом. Глава
 1 является учебным введением в центральную часть языка "C".
 Цель - позволить читателю стартовать так быстро,как только
 возможно, так как мы твердо убеждены, что единственный спо-
 соб изучить новый язык - писать на нем программы. При этом ,
 однако, предполагается рабочее владение основными элементами
 программирования; здесь не объясняется, что такое ЭВМ или
 компилятор, не поясняется смысл выражений типа N=N+1. Хотя
 мы и пытались, где это возможно, продемонстрировать полезную
 технику программирования. Эта книга не предназначается быть
 справочным руководством по структурам данных и алгоритмам;
 там, где мы вынуждены были сделать выбор, мы концентрирова-
 лись на языке.
      В главах со 2-й по 6-ю различные аспекты "C" излагаются
 более детально и несколько более формально, чем в главе 1,
 хотя ударение по-прежнему делается на разборе примеров за-
 конченных, полезных программ, а не на отдельных фрагментах.
      В главе 2 обсуждаются основные типы данных, операторы и
 выражения. В главе 3 рассматриваются управляющие операторы:
 IF-ELSE ,WHILE ,FOR и т.д. Глава 4 охватывает функции и
 структуру программы - внешние переменные, правила определен-
 ных областей действия описания и т.д. В главе 5 обсуждаются
 указатели и адресная арифметика. Глава 6 содержит подробное
 описание структур и объединений.
      В главе 7 описывается стандартная библиотека ввода-вы-
 вода языка "C", которая обеспечивает стандартный интерфейс с
 операционной системой. Эта библиотека ввода-вывода поддержи-
 вается на всех машинах, на которых реализован "C", так что
 программы, использующие ее для ввода, вывода и других сис-
 темных функций, могут переноситься с одной системы на другую
 по существу без изменений.
      В главе 8 описывается интерфейс между "C" - программами
 и операционной системой "UNIX". Упор делается на ввод-вывод,
 систему файлов и переносимость. Хотя некоторые части этой
 главы специфичны для операционной системы "UNIX", програм-
 мисты, не использующие "UNIX", все же должны найти здесь по-
 лезный материал, в том числе некоторое представление о том,
 как реализована одна версия стандартной библиотеки и предло-
 жения для достижения переносимости программы.
      Приложение A содержит справочное руководство по языку
 "C". Оно является "официальным" изложением синтаксиса и се-
 мантики "C" и (исключая чей-либо собственный компилятор)
 окончательным арбитром для всех двусмысленностей и упущений
 в предыдущих главах.
     
                            - 11 -
     
      Так как "C" является развивающимся языком, реализован-
 ным на множестве систем, часть материла настоящей книги мо-
 жет не соответствовать текущему состоянию разработки на ка-
 кой-то конкретной системе. Мы старались избегать таких проб-
 лем и предостерегать о возможных трудностях. В сомнительных
 случаях, однако, мы обычно предпочитали описывать ситуацию
 для системы "UNIX" PDP-11 , так как она является средой для
 большинства программирующих на языке "C". В приложении а
 также описаны расхождения в реализациях языка "C" на основ-
 ных системах.
      1. Учебное введение.
      Давайте начнем с быстрого введения в язык "C". Наша
 цель - продемонстрировать существенные элементы языка на ре-
 альных программах, не увязая при этом в деталях, формальных
 правилах и исключениях. В этой главе мы не пытаемся изложить
 язык полностью или хотя бы строго (разумеется, приводимые
 примеры будут корректными). Мы хотим как можно скорее довес-
 ти вас до такого уровня, на котором вы были бы в состоянии
 писать полезные программы, и чтобы добиться этого, мы сосре-
 дотачиваемся на основном: переменных и константах, арифмети-
 ке, операторах передачи управления, функциях и элементарных
 сведениях о вводе и выводе. Мы совершенно намеренно оставля-
 ем за пределами этой главы многие элементы языка "C", кото-
 рые имеют первостепенное значение при написании больших
 программ, в том числе указатели, сртуктуры, большую часть из
 богатого набора операторов языка "C", несколько операторов
 передачи управления и несметное количество деталей.
      Такой подход имеет, конечно, свои недостатки. Самым су-
 щественным является то, что полное описание любого конкрет-
 ного элемента языка не излагается в одном месте, а поясне-
 ния, в силу краткости, могут привести к неправильному истол-
 кованию. Кроме того, из-за невозможности использовать всю
 мощь языка, примеры оказываются не столь краткими и элегант-
 ными, как они могли бы быть. И хотя мы старались свести эти
 недостатки к минимуму, все же имейте их ввиду.
      Другой недостаток состоит в том, что последующие главы
 будут неизбежно повторять некоторые части этой главы. Мы на-
 деемся, что такое повторение будет скорее помогать, чем раз-
 дражать.
      Во всяком случае, опытные программисты должны оказаться
 в состоянии проэкстраполировать материал данной главы на
 свои собственные программистские нужды. Начинающие же должны
 в дополнение писать аналогичные маленькие самостоятельные
 программы. И те, и другие могут использовать эту главу как
 каркас, на который будут навешиваться более подробные описа-
 ния, начинающиеся с главы 2.
      1.1. Hачинаем. Единственный способ освоить новый язык
 программирования - писать на нем программы. Первая програм-
 ма, которая должна быть написана, - одна для всех языков:
 напечатать слова : HELLO, WORLD.
      Это - самый существенный барьер; чтобы преодолеть его,
 вы должны суметь завести где-то текст программы, успешно его
 скомпилировать, загрузить, прогнать и найти, где оказалась
 ваша выдача. Если вы научились справляться с этими техничес-
 кими деталями, все остальное сравнительно просто.
     
                            - 12 -
     
      Программа печати "HELLO, WORLD" на языке "C" имеет вид:
      
    MAIN ()
    {
            PRINTF("HELLO, WORLD\N");
    }
      Как пропустить эту программу - зависит от используемой
 вами системы. В частности, на операционной системе "UNIX" вы
 должны завести исходную программу в файле, имя которого
 оканчивается на ".C" , например, HELLO.C , и затем скомпили-
 ровать ее по команде
      
            CC HELLO.C
      
      Если вы не допустили какой-либо небрежности , такой как
 пропуск символа или неправильное написание, компиляция прой-
 дет без сообщений и будет создан исполняемый файл с именем
 а.OUT . Прогон его по команде
      
               A.OUT
      
 приведет к выводу
      
           HELLO, WORLD
      
      На других системах эти правила будут иными; проконсуль-
 тируйтесь с местным авторитетом.
      Упражнение 1-1.
      ---------------
      Пропустите эту программу на вашей системе. Попробуйте
 не включать различные части программы и посмотрите какие со-
 общения об ошибках вы при этом получите.
      Теперь некоторые пояснения к самой программе. Любая
 "C"-программа, каков бы ни был ее размер, состоит из одной
 или более "функций", указывающих фактические операции
 компьютера, которые должны быть выполнены. Функции в языке
 "C" подобны функциям и подпрограммам фортрана и процедурам
 PL/1, паскаля и т.д. В нашем примере такой функцией является
 MAIN. Обычно вы можете давать функциям любые имена по вашему
 усмотрению, но MAIN - это особое имя; выполнение вашей прог-
 раммы начинается сначала с функции MAIN. Это означает, что
 каждая программа должна в каком-то месте содержать функцию с
 именем MAIN. Для выполнения определенных действий функция
 MAIN обычно обращается к другим функциям, часть из которых
 находится в той же самой программе, а часть - в библиотеках,
 содержащих ранее написанные функции.
     
                            - 13 -
     
      Одним способом обмена данными между функциями является
 передача посредством аргументов. Круглые скобки, следующие
 за именем функции, заключают в себе список аргументов; здесь
 маIN - функция без аргументов, что указывается как (). Опе-
 раторы, составляющие функцию, заключаются в фигурные скобки
 { и }, которые аналогичны DO-END в PL/1 или BEGIN-END в ал-
 голе, паскале и т.д. Обращение к функции осуществляется ука-
 занием ее имени, за которым следует заключенный в круглые
 скобки список аргументов. здесь нет никаких операторов CALL,
 как в фортране или PL/1. Круглые скобки должны присутство-
 вать и в том случае, когда функция не имеет аргументов.
 Строка
      
      PRINTF("HELLO, WORLD\N");
      
 является обращением к функции, которое вызывает функцию
 с именем PRINTF и аргуметом "HELLO, WORLD\N". Функция PRINTF
 является библиотечной функцией, которая выдает выходные дан-
 ные на терминал (если только не указано какое-то другое мес-
 то назначения). В данном случае печатается строка символов,
 являющаяся аргументом функции.
      Последовательность из любого количества символов, зак-
 люченных в удвоенные кавычки "...", называется 'символьной
 строкой' или 'строчной константой'. Пока мы будем использо-
 вать символьные строки только в качестве аргументов для
 PRINTF и других функций.
      Последовательность \N в приведенной строке является
 обозначением на языке "C" для 'символа новой строки', кото-
 рый служит указанием для перехода на терминале к левому краю
 следующей строки. Если вы не включите \N (полезный экспери-
 мент), то обнаружите, что ваша выдача не закончится перехо-
 дом терминала на новую строку. Использование последователь-
 ности \N - единственный способ введения символа новой строки
 в аргумент функции PRINTF; если вы попробуете что-нибудь
 вроде
      
          PRINTF("HELLO, WORLD
          ");
      
 то "C"-компилятор  будет печатать злорадные диагностические
 сообщения о недостающих кавычках.
      Функция PRINTF не обеспечивает автоматического перехода
 на новую строку, так что многократное обращение к ней можно
 использовать для поэтапной сборки выходной строки. Наша пер-
 вая программа, печатающая идентичную выдачу, с точно таким
 же успехом могла бы быть написана в виде
      
     MAIN()
     {
             PRINTF("HELLO, ");
             PRINTF("WORLD");
             PRINTF("\N");
     }
     
     
                            - 14 -
      
      Подчеркнем, что \N представляет только один символ. Ус-
 ловные 'последовательности', подобные \N , дают общий и до-
 пускающий расширение механизм для представления трудных для
 печати или невидимых символов. Среди прочих символов в языке
 "C" предусмотрены следующие: \т - для табуляции, \B - для
 возврата на одну позицию, \" - для двойной кавычки и \\ для
 самой обратной косой черты.
      Упражнение 1-2.
      ---------------
      Проведите эксперименты для того, чтобы узнать что прои-
 зойдет, если в строке, являющейся аргументом функции PRINTF
 будет содержаться \X, где X - некоторый символ, не входящий
 в вышеприведенный список.
     1.2. Переменные и арифметика.
      Следующая программа печатает приведенную ниже таблицу
 температур по Фаренгейту и их эквивалентов по стоградусной
 шкале Цельсия, используя для перевода формулу
      
          C = (5/9)*(F-32).
     0       -17.8
    20        -6.7
    40         4.4
    60        15.6
   ...         ...
   260       126.7
   280       137.8
   300       140.9
      
       Теперь сама программа:
      
    /* PRINT FAHRENHEIT-CELSIUS TABLE
    FOR F = 0, 20, ..., 300 */
    MAIN()
    {
    INT LOWER, UPPER, STEP;
    FLOAT FAHR, CELSIUS;
    LOWER = 0;  /* LOWER LIMIT OF TEMPERATURE
    TABLE */
    UPPER =300; /* UPPER LIMIT */
    STEP  = 20; /* STEP SIZE */
    FAHR = LOWER;
    WHILE (FAHR <= UPPER) {
      CELSIUS = (5.0/9.0) * (FAHR -32.0);
      PRINTF("%4.0F %6.1F\N", FAHR, CELSIUS);
      FAHR = FAHR + STEP;
    }
    }
     
                            - 15 -
 
 Первые две строки
      
      /* PRINT FAHRENHEIT-CELSIUS TABLE
         FOR  F = 0, 20, ..., 300 */
      
 являются комментарием, который в данном случае кратко пояс-
 няет, что делает программа. Любые символы между /* и */ иг-
 норируются компилятором; можно свободно пользоваться коммен-
 тариями для облегчения понимания программы. Комментарии мо-
 гут появляться в любом месте, где возможен пробел или пере-
 ход на новую строку.
     В языке "C" все переменные должны быть описаны до их ис-
 пользования, обычно это делается в начале функции до первого
 выполняемого оператора. Если вы забудете вставить описание,
 то получите диагностическое сообщение от компилятора. Описа-
 ние состоит из типа и списка переменных, имеющих этот тип,
 как в
     
     INT LOWER, UPPER, STEP;
     FLOAT FAHR, CELSIUS;
     
     Тип INT означает, что все переменные списка целые; тип
 FLOAT предназначен для чисел с плавающей точкой, т.е. для
 чисел, которые могут иметь дробную часть. Точность как INT ,
 TAK и FLOAT зависит от конкретной машины, на которой вы ра-
 ботаете. На PDP-11, например, тип INT соответствует 16-бито-
 вому числу со знаком, т.е. числу, лежащему между -32768 и
 +32767. Число типа FLOAT - это 32-битовое число, имеющее
 около семи значащих цифр и лежащее в диапазоне от 10е-38 до
 10е+38. В главе 2 приводится список размеров для других ма-
 шин.
     В языке "C" предусмотрено несколько других основных ти-
 пов данных, кроме INT и FLOAT:
 CHAR    символ - один байт
 SHORT   короткое целое
 LONG    длинное целое
 DOUBLE  плавающее с двойной точностью
     Размеры этих объектов тоже машинно-независимы; детали
 приведены в главе 2. Имеются также массивы, структуры и об-
 ъединения этих основных типов, указатели на них и функ-
 ции,которые их возвращают; со всеми ними мы встретимся в
 свое время.
     Фактически вычисления в программе перевода температур
 начинаются с операторов присваивания
 LOWER = 0;
 UPPER =300;
 STEP = 20;
 FAHR =LOWER;
 которые придают переменным их начальные значения. каждый от-
 дельный оператор заканчивается точкой с запятой.
     Каждая строка таблицы вычисляется одинаковым образом,
 так что мы используем цикл, повторяющийся один раз на стро-
 ку. В этом назначение оператора WHILE:
     
 WHILE (FAHR <= UPPER) {
 ....
 }         
                            - 16 -
     
 проверяется условие в круглых скобках. Если оно истинно
 (FAHR меньше или равно UPPER), то выполняется тело цикла
 (все операторы, заключенные в фигурные скобки { и } ). Затем
 вновь проверяется это условие и, если оно истинно, опять вы-
 полняется тело цикла. Если же условие не выполняется ( FAHR
 превосходит UPPER ), цикл заканчивается и происходит переход
 к выполнению оператора, следующего за оператором цикла. Так
 как в настоящей программе нет никаких последующих операто-
 ров, то выполнение программы завершается.
     Тело оператора WHILE может состоять из одного или более
 операторов, заключенных в фигурные скобки, как в программе
 перевода температур, или из одного оператора без скобок,
 как, например, в
     
     WHILE (I < J)
           I = 2 * I;
     
     В обоих случаях операторы, управляемые оператором WHILE,
 сдвинуты на одну табуляцию, чтобы вы могли с первого взгляда
 видеть, какие операторы находятся внутри цикла. Такой сдвиг
 подчеркивает логическую структуру программы. Хотя в языке
 "C" допускается совершенно произвольное расположение опера-
 торов в строке, подходящий сдвиг и использование пробелов
 значительно облегчают чтение программ. Мы рекомендуем писать
 только один оператор на строке и (обычно) оставлять пробелы
 вокруг операторов. Расположение фигурных скобок менее сущес-
 твенно; мы выбрали один из нескольких популярных стилей. Вы-
 берите подходящий для вас стиль и затем используйте его пос-
 ледовательно.
     Основная часть работы выполняется в теле цикла. Темпера-
 тура по Цельсию вычисляется и присваивается переменной
 CELAIUS оператором
     
      CELSIUS = (5.0/9.0) * (FAHR-32.0);
     
 причина использования выражения 5.0/9.0 вместо выглядящего
 проще 5/9 заключается в том, что в языке "C", как и во мно-
 гих других языках, при делении целых происходит усечение,
 состоящее в отбрасывании дробной части результата. Таким об-
 разом, результат операции 5/9 равен нулю, и, конечно, в этом
 случае все температуры оказались бы равными нулю. Десятичная
 точка в константе указывает, что она имеет тип с плавающей
 точкой, так что, как мы и хотели, 5.0/9.0 равно 0.5555... .
     Мы также писали 32.0 вместо 32 , несмотря на то, что так
 как переменная FAHR имеет тип FLOAT , целое 32 автоматически
 бы преобразовалось к типу FLOAT ( в 32.0) перед вычитанием.
 С точки зрения стиля разумно писать плавающие константы с
 явной десятичной точкой даже тогда, когда они имеют целые
 значения; это подчеркивает их плавающую природу для просмат-
 ривающего программу и обеспечивает то, что компилятор будет
 смотреть на вещи так же, как и Вы.
     
                            - 17 -
     
     Подробные правила о том, в каком случае целые преобразу-
 ются к типу с плаваюшей точкой, приведены в главе 2. Сейчас
 же отметим, что присваивание
     
            FAHR = LOWER;
     
 проверка
     
            WHILE (FAHR <= UPPER)
     
 работают, как ожидается, - перед выполнением операций целые
 преобразуются в плавающую форму.
     Этот же пример сообщает чуть больше о том, как работает
 PRINTF. Функция PRINTF фактически является универсальной
 функцией форматных преобразований, которая будет полностью
 описана в главе 7. Ее первым аргументом является строка сим-
 волов, которая должна быть напечатана, причем каждый знак %
 указывает, куда должен подставляться каждый из остальных ар-
 гументов /второй, третий, .../ и в какой форме он должен пе-
 чататься. Например, в операторе
     
   PRINTF("%4.0F %6.1F\N", FAHR, CELSIUS);
     
 спецификация преобразования %4.0F говорит, что число с пла-
 вающей точкой должно быть напечатано в поле шириной по край-
 ней мере в четыре символа без цифр после десятичной точки.
 спецификация %6.1F описывает другое число, которое должно
 занимать по крайней мере шесть позиций с одной цифрой после
 десятичной точки, аналогично спецификациям F6.1 в фортране
 или F(6,1) в PL/1. Различные части спецификации могут быть
 опущены: спецификация %6F говорит, что число будет шириной
 по крайней мере в шесть символов; спецификация %2 требует
 двух позиций после десятичной точки, но ширина при этом не
 ограничивается; спецификация %F говорит только о том, что
 нужно напечатать число с плавающей точкой. Функция PRINTF
 также распознает следующие спецификации: %D - для десятично-
 го целого, %о - для восьмеричного числа, %х - для шестнадца-
 тиричного, %с - для символа, %S - для символьной строки и %%
 - для самого символа %.
     Каждая конструкция с символом % в первом аргументе функ-
 ции PRINTF сочетается с соответствующим вторым, третьим, и
 т.д. Аргументами; они должны согласовываться по числу и ти-
 пу; в противном случае вы получите бессмысленные результаты.
     Между прочим, функция PRINTF не является частью языка
 "C"; в самом языке "C" не определены операции ввода-вывода.
 Нет ничего таинственного и в функции PRINTF ; это - просто
 полезная функция, являющаяся частью стандартной библиотеки
 подпрограмм, которая обычно доступна "C"-программам. Чтобы
 сосредоточиться на самом языке, мы не будем подробно оста-
 навливаться на операциях ввода-вывода до главы 7. В частнос-
 ти, мы до тех пор отложим форматный ввод. Если вам надо
 ввести числа - прочитайте описание функции SCANF в главе 7,
 раздел 7.4. Функция SCANF во многом сходна с PRINTF , но она
 считывает входные данные, а не печатает выходные.
     
                            - 18 -
     
      Упражнение  1-3.
      ----------------
     Преобразуйте программу перевода температур таким обра-
 зом, чтобы она печатала заголовок к таблице.
      Упражнение  1-4.
      ----------------
     Напишите программы печати соответствующей таблицы пере-
 хода от градусов цельсия к градусам фаренгейта.
     
     1.3. Оператор FOR.
     Как и можно было ожидать, имеется множество различных
 способов написания каждой программы. Давайте рассмотрим та-
 кой вариант программы перевода температур:
     
 MAIN()  /* FAHRENHEIT-CELSIUS TABLE */
 {
    INT FAHR;
    FOR (FAHR = 0; FAHR <= 300; FAHR = FAHR + 20)
  PRINTF("%4D %6.1F\N", FAHR, (5.0/9.0)*(FAHR-32.0));
 }
     
     Эта программа выдает те же самые результаты, но выглядит
 безусловно по-другому. Главное изменение - исключение боль-
 шинства переменных; осталась только переменная FAHR , причем
 типа INT (это сделано для того, чтобы продемонстрировать
 преобразование %D в функции PRINTF). Нижняя и верхняя грани-
 цы и размер щага появляются только как константы в операторе
 FOR , который сам является новой конструкцией, а выражение,
 вычисляющее температуру по цельсию, входит теперь в виде
 третьего аргумента функции PRINTF , а не в виде отдельного
 оператора присваивания.
     Последнее изменение является примером вполне общего пра-
 вила языка "C" - в любом контексте, в котором допускается
 использование значения переменной некоторого типа, вы можете
 использовать выражение этого типа. Так как третий аргумент
 функции PRINTF должен иметь значение с плавающей точкой,
 чтобы соответствовать спецификации %6.1F, то в этом месте
 может встретиться любое выражение плавающего типа.
     Сам оператор FOR - это оператор цикла, обобщающий опера-
 тор WHILE. Его функционирование должно стать ясным, если вы
 сравните его с ранее описанным оператором WHILE . Оператор
 FOR содержит три части, разделяемые точкой с запятой. Первая
 часть
 
 FAHR = 0
 
 выполняется один раз перед входом в сам цикл. Вторая часть -
 проверка, или условие, которое управляет циклом:
 
 FAHR <= 300
 
 это условие проверяется и, если оно истинно, то выполняется
 тело цикла (в данном случае только функция PRINTF ). Затем
 выполняется шаг реинициализации
     
                            - 19 -
     
 
 FAHR =FAHR + 20
 
 и условие проверяется снова. цикл завершается, когда это ус-
 ловие становится ложным. Так же, как и в случае оператора
 WHILE , тело цикла может состоять из одного оператора или из
 группы операторов, заключенных в фигурные скобки. Инициали-
 зирующая и реинициализирующая части могут быть любыми от-
 дельными выражениями.
     Выбор между операторами WHILE и FOR произволен и основы-
 вается на том , что выглядит яснее. Оператор FOR обычно удо-
 бен для циклов, в которых инициализация и реинициализация
 логически связаны и каждая задается одним оператором, так
 как в этом случае запись более компактна, чем при использо-
 вании оператора WHILE , а операторы управления циклом сосре-
 дотачиваются вместе в одном месте.
     Упражнение  1-5.
     ---------------
     Модифицируйте программу перевода температур таким обра-
 зом, чтобы она печатала таблицу в обратном порядке, т.е. От
 300 градусов до 0.
     1.4. Символические константы.
     Последнее замечание, прежде чем мы навсегда оставим
 программу перевода температур. Прятать "магические числа",
 такие как 300 и 20, внутрь программы - это неудачная практи-
 ка; они дают мало информации тем, кто, возможно, должен бу-
 дет разбираться в этой программе позднее, и их трудно изме-
 нять систематическим образом. К счастью в языке "C" предус-
 мотрен способ, позволяющий избежать таких "магических чи-
 сел". Используя конструкцию #DEFINE , вы можете в начале
 программы определить символическое имя или символическую
 константу, которая будет конкретной строкой символов. Впос-
 ледствии компилятор заменит все не заключенные в кавычки по-
 явления этого имени на соответствующую строку. Фактически
 это имя может быть заменено абсолютно произвольным текстом,
 не обязательно цифрами
 
  #DEFINE  LOWER 0/* LOWER LIMIT OF TABLE */
  #DEFINE  UPPER 300  /* UPPER LIMIT */
  #DEFINE  STEP  20  /* STEP SIZE */
  MAIN () /* FAHRENHEIT-CELSIUS TABLE */
  {
  INT FAHR;
 FOR (FAHR =LOWER; FAHR <= UPPER; FAHR =FAHR + STEP)
   PRINTF("%4D %6.1F\N", FAHR, (5.0/9.0)*(FAHR-32));
  }
 
 
     величины LOWER, UPPER и STEP являются константами и поэ-
 тому они не указываются в описаниях. Символические имена
 обычно пишут прописными буквами, чтобы их было легко отли-
 чить от написанных строчными буквами имен переменных. отме-
 тим, что в конце определения не ставится точка с запятой.
 Так как подставляется вся строка, следующая за определенным
 именем, то это привело бы к слишком большому числу точек с
 запятой в операторе FOR .
 
                            - 20 -
     
     1.5. Набор полезных программ.
     
     Теперь мы собираемся рассмотреть семейство родственных
 программ, предназначенных для выполнения простых операций
 над символьными данными. В дальнейшем вы обнаружите, что
 многие программы являются просто расширенными версиями тех
 прототипов, которые мы здесь обсуждаем.
     
     1.5.1. Ввод и вывод символов.
     
     Стандартная библиотека включает функции для чтения и за-
 писи по одному символу за один раз. функция GETCHAR() извле-
 кает следующий вводимый символ каждый раз, как к ней обраща-
 ются, и возвращает этот символ в качестве своего значения.
 Это значит, что после
 
         C = GETCHAR()
 
 переменная 'C' содержит следующий символ из входных данных.
 Символы обычно поступают с терминала, но это не должно нас
 касаться до главы 7.
     Функция PUTCHAR(C) является дополнением к GETCHAR : в
 результате обращения
 
         PUTCHAR (C)
 
 содержимое переменной 'C' выдается на некоторый выходной но-
 ситель, обычно опять на терминал. Обращение к функциям
 PUTCHAR и PRINTF могут перемежаться; выдача будет появляться
 в том порядке, в котором происходят обращения.
     Как и функция PRINTF , функции GETCHAR и PUTCHAR не со-
 держат ничего экстраординарного. Они не входят в состав язы-
 ка "C", но к ним всегда можно обратиться.
 
     1.5.2. Копирование файла.
 
     Имея в своем распоряжении только функции GETCHAR и
 PUTCHAR вы можете, не зная ничего более об операциях вво-
 да-вывода, написать удивительное количество полезных прог-
 рамм. Простейшим примером может служить программа посимволь-
 ного копирования вводного файла в выводной. Общая схема име-
 ет вид:
 ввести символ
 WHILE (символ не является признаком конца файла)
   вывести только что прочитанный символ
   ввести новый символ
 
 программа, написанная на языке "C", выглядит следующим обра-
 зом:
 
  MAIN()  /* COPY INPUT TO OUTPUT; 1ST VERSION */
  {
     INT C;
 
     C = GETCHAR();
     WHILE (C != EOF) {
            PUTCHAR (C);
            C = GETCHAR();
     }
  }
 
                            - 21 -
     
 оператор отношения != означает "не равно".
      Основная проблема заключается в том, чтобы зафиксиро-
 вать конец файла ввода. Обычно, когда функция GETCHAR натал-
 кивается на конец файла ввода, она возвращает значение , не
 являющееся действительным символом; таким образом, программа
 может установить, что файл ввода исчерпан. Единственное ос-
 ложнение, являющееся значительным неудобством, заключается в
 существовании двух общеупотребительных соглашений о том, ка-
 кое значение фактически является признаком конца файла. Мы
 отсрочим решение этого вопроса, использовав символическое
 имя EOF для этого значения, каким бы оно ни было. На практи-
 ке EOF будет либо -1, либо 0, так что для правильной работы
 перед программой должно стоять собственно либо
 
  #DEFINE  EOF  -1
 
 либо
 
  #DEFINE  EOF   0
 
      Использовав символическую константу EOF для представле-
 ния значения, возвращаемого функцией GETCHAR при выходе на
 конец файла, мы обеспечили, что только одна величина в прог-
 рамме зависит от конкретного численного значения.
      Мы также описали переменную 'C' как INT , а не CHAR , с
 тем чтобы она могла хранить значение, возвращаемое GETCHAR .
 как мы увидим в главе 2, эта величина действительно INT, так
 как она должна быть в состоянии в дополнение ко всем возмож-
 ным символам представлять и EOF.
      Программистом, имеющим опыт работы на "C", программа
 копирования была бы написана более сжато. В языке "C" любое
 присваивание, такое как
 
  C = GETCHAR()
 
 может быть использовано в выражении; его значение - просто
 значение, присваиваемое левой части. Если присваивание сим-
 вола переменной 'C' поместить внутрь проверочной части опе-
 ратора WHILE , то программа копирования файла запишется в
 виде:
 
 MAIN()  /* COPY INPUT TO OUTPUT; 2ND VERSION */
 {
 INT C;
 
 WHILE ((C = GETCHAR()) != EOF)
 PUTCHAR(C);
 }
 
      Программа извлекает символ , присваивает его переменной
 'C' и затем проверяет, не является ли этот символ признаком
 конца файла. Если нет - выполняется тело оператора WHILE,
 выводящее этот символ. Затем цикл WHILE повторяется. когда,
 наконец, будет достигнут конец файла ввода, оператор WHILE
 завершается, а вместе с ним заканчивается выполнение и функ-
 ции MAIN .
     
                            - 22 -
     
      В этой версии централизуется ввод - в программе только
 одно обращение к функции GETCHAR - и ужимается программа.
 Вложение присваивания в проверяемое условие - это одно из
 тех мест языка "C", которое приводит к значительному сокра-
 щению программ. Однако, на этом пути можно увлечься и начать
 писать недоступные для понимания программы. Эту тенденцию мы
 будем пытаться сдерживать.
      Важно понять , что круглые скобки вокруг присваивания в
 условном выражении действительно необходимы. Старшинство
 операции != выше, чем операции присваивания =, а это означа-
 ет, что в отсутствие круглых скобок проверка условия != бу-
 дет выполнена до присваивания =. Таким образом, оператор
 
 C = GETCHAR()  != EOF
 
 эквивалентен оператору
 
 C = (GETCHAR() != EOF)
 
      Это, вопреки нашему желанию, приведет к тому, что 'C'
 будет принимать значение 0 или 1 в зависимости от того, на-
 толкнется или нет GETCHAR на признак конца файла. Подробнее
 об этом будет сказано в главе 2/.
 
     1.5.3. Подсчет символов.
 
      Следующая программа подсчитывает число символов; она
 представляет собой небольшое развитие программы копирования.
 
  MAIN()  /* COUNT CHARACTERS IN INPUT */
  {
      LONG NC;
 
      NC = 0;
      WHILE (GETCHAR() != EOF )
     ++NC;
      PRINTF("%1D\N", NC);
  }
 
  Оператор
 
     ++NC;
 
 демонстрирует новую операцию, ++, которая означает увеличе-
 ние на единицу. Вы могли бы написать NC = NC + 1 , но ++NC
 более кратко и зачастую более эффективно. Имеется соответст-
 вующая операция -- уменьшение на единицу. Операции ++ и --
 могут быть либо префиксными (++NC), либо постфиксными
 (NC++); эти две формы, как будет показано в главе 2, имеют в
 выражениях различные значения, но как ++NC, так и NC++ уве-
 личивают NC. Пока мы будем придерживаться префиксных опера-
 ций.
     
                            - 23 -
     
      Программа подсчета символов накапливает их количество в
 переменной типа LONG, а не INT . На PDP-11 максимальное зна-
 чение равно 32767, и если описать счетчик как INT , то он
 будет переполняться даже при сравнительно малом файле ввода;
 на языке "C" для HONEYWELL и IBM типы LONG и INT являются
 синонимами и имеют значительно больший размер. Спецификация
 преобразования %1D указывает PRINTF , что соответствующий
 аргумент является целым типа LONG .
      Чтобы справиться с еще большими числами, вы можете ис-
 пользовать тип DOUBLE / FLOAT двойной длины/. мы также ис-
 пользуем оператор FOR вместо WHILE с тем, чтобы проиллюстри-
 ровать другой способ записи цикла.
 
  MAIN()  /* COUNT CHARACTERS IN INPUT */
  {
      DOUBLE  NC;
 
      FOR (NC = 0; GETCHAR() != EOF; ++NC)
     ;
      PRINTF("%.0F\N", NC);
  }
 
      Функция PRINTF использует спецификацию %F как для FLOAT
 , так и для DOUBLE ; спецификация %.0F подавляет печать не-
 существующей дробной части.
      Тело оператора цикла FOR здесь пусто, так как вся рабо-
 та выполняется в проверочной и реинициализационной частях.
 Но грамматические правила языка "C" требуют, чтобы оператор
 FOR имел тело. Изолированная точка с запятой, соответствую-
 шая пустому оператору, появляется здесь, чтобы удовлетворить
 этому требованию. Мы выделили ее на отдельную строку, чтобы
 сделать ее более заметной.
      Прежде чем мы распростимся с программой подсчета симво-
 лов, отметим, что если файл ввода не содержит никаких симво-
 лов, то условие в WHILE или FOR не выполнится при самом пер-
 вом обращении к GETCHAR , и, следовательно , программа вы-
 даст нуль, т.е. Правильный ответ. это важное замечание. од-
 ним из приятных свойств операторов WHILE и FOR является то,
 что они проверяют условие в начале цикла, т.е. До выполнения
 тела. Если делать ничего не надо, то ничего не будет сдела-
 но, даже если это означает, что тело цикла никогда не будет
 выполняться. программы должны действовать разумно, когда они
 обращаются с файлами типа "никаких символов". Операторы
 WHILE и FOR помогают обеспечить правильное поведение прог-
 рамм при граничных значениях проверяемых условий.
 
    1.5.4. Подсчет строк.
 
      Следующая программа подсчитывает количество строк в
 файле ввода. Предполагается, что строки ввода заканчиваются
 символом новой строки \N, скрупулезно добавленным к каждой
 выписанной строке.
           
     
                            - 24 -
     
 MAIN()  /* COUNT LINES IN INPUT */
 {
     INT C,NL;
 
     NL = 0;
     WHILE ((C = GETCHAR()) != EOF)
    IF (C =='\N')
        ++NL;
     PRINTF("%D\N", NL);
 }
 
      Тело WHILE теперь содержит оператор IF , который в свою
 очередь управляет оператором увеличения ++NL. Оператор IF
 проверяет заключенное в круглые скобки условие и, если оно
 истинно, выполняет следующий за ним оператор /или группу
 операторов, заключенных в фигурные скобки/. Мы опять исполь-
 зовали сдвиг вправо, чтобы показать, что чем управляет.
      Удвоенный знак равенства == является обозначением в
 языке "C" для "равно" /аналогично .EQ. В фортране/. Этот
 символ введен для того, чтобы отличать проверку на равенство
 от одиночного =, используемого при присваивании. Поскольку в
 типичных "C" - программах знак присваивания встречается при-
 мерно в два раза чаще, чем проверка на равенство, то естест-
 венно, чтобы знак оператора был вполовину короче.
      Любой отдельный символ может быть записан внутри оди-
 ночных кавычек, и при этом ему соответствует значение, рав-
 ное численному значению этого символа в машинном наборе сим-
 волов; это называется символьной константой. Так, например,
 'A' - символьная константа; ее значение в наборе символов
 ASCII /американский стандартный код для обмена информацией/
 равно 65, внутреннему представлению символа а. Конечно, 'A'
 предпочтительнее, чем 65: его смысл очевиден и он не зависит
 от конкретного машинного набора символов.
      Условные последовательности, используемые в символьных
 строках, также занимают законное место среди символьных кон-
 стант. Так в проверках и арифметических выражениях '\N'
 представляет значение символа новой строки. Вы должны твердо
 уяснить, что '\N' - отдельный символ, который в выражениях
 эквивалентен одиночному целому; с другой стороны "\N" - это
 символьная строка, которая содержит только один символ. Воп-
 рос о сопоставлении строк и символов обсуждается в главе 2.
     Упражнение  1-6.
     ----------------
      Напишите программу для подсчета пробелов, табуляций и
 новых строк.
     Упражнение  1-7.
     ----------------
      Напишите программу, которая копирует ввод на вывод, за-
 меняя при этом каждую последовательность из одного или более
 пробелов на один пробел.
 
      1.5.5. Подсчет слов.
 
      Четвертая программа из нашей серии полезных программ
 подсчитывает количество строк, слов и символов, используя
 при этом весьма широкое определение, что словом является лю-
 бая последовательность символов, не содержащая пробелов, та-
 буляций или новых строк. /Это - упрощенная версия утилиты
 'WC' системы 'UNIX'/
     
                            - 25 -
     
 #DEFINE    YES  1
 #DEFINE    NO   0
 
 MAIN()  /* COUNT LINES, WORDS, CHARS IN INPUT */
 {
    INT C, NL, NW, INWORD;
 
    INWORD = NO;
    NL = NW = NC = 0;
    WHILE((C = GETCHAR()) != EOF)  {
        ++NC;
        IF (C == '\N')
             ++NL;
        IF (C==' ' \!\! C=='\N' \!\! C=='\T')
             INWORD = NO;
        ELSE IF (INWORD == NO)  {
             INWORD = YES;
             ++NW;
        }
    }
    PRINTF("%D %D %D\N", NL, NW, NC);
 }
 
      Каждый раз, когда программа встречает первый символ
 слова, она увеличивает счетчик числа слов на единицу. Пере-
 менная INWORD следит за тем, находится ли программа в насто-
 ящий момент внутри слова или нет; сначала этой переменной
 присваивается " не в слове", чему соответствует значение NO.
 Мы предпочитаем символические константы YES и NO литерным
 значениям 1 и 0, потому что они делают программу более удоб-
 ной для чтения. Конечно, в такой крошечной программе, как
 эта, это не приводит к заметной разнице, но в больших прог-
 раммах увеличение ясности вполне стоит тех скромных дополни-
 тельных усилий, которых требует следование этому принципу с
 самого начала. Вы также обнаружите, что существенные измене-
 ния гораздо легче вносить в те программы, где числа фигури-
 руют только в качестве символьных констант.
     Строка
 
       NL = NW = NC = 0;
 
 полагает все три переменные  равными  нулю.  Это  не
 особый случай, а следствие того обстоятельства, что операто-
 ру присваивания соответствует некоторое значение и присваи-
 вания проводятся последовательно справа налево. Таким обра-
 зом, дело обстоит так, как если бы мы написали
 
        NC = (NL = (NW = 0));
 
 операция \!\! Означает   OR  , так что строка
 
        IF( C==' ' \!\! C=='\N' \!\! C=='\T')
 
 говорит "если с - пробел, или с - символ новой строки, или с
 -табуляция ..."./условная последовательность \T является
 изображением символа табуляции/.
     
                            - 26 -
     
    Имеется соответствующая операция && для AND. Выражения,
  связанные операциями && или \!\! , Рассматриваются слева на
   право, и при этом гарантируется, что оценивание выражений
   будет прекращено, как только станет ясно, является ли все
   выражение истинным или ложным. Так, если 'C' оказывается
  пробелом, то нет никакой необходимости проверять, является
 ли 'C' символом новой строки или табуляции, и такие проверки
    действительно не делаются. В данном случае это не имеет
  принципиального значения, но, как мы скоро увидим, в более
  сложных ситуациях эта особенность языка весьма существенна.
   Этот пример также демонстрирует оператор ELSE языка "C",
  который указывает то действие, которое должно выполняться,
  если условие, содержащееся в операторе IF, окажется ложным.
                      Общая форма такова:
 
  IF (выражение)
  оператор-1
  ELSE оператор-2
 
     Выполняется один и только один из двух операторов, свя-
 занных с конструкцией IF-ELSE. Если выражение истинно, вы-
 полняется оператор-1; если нет - выполняется оператор-2.
 Фактически каждый оператор может быть довольно сложным. В
 программе подсчета слов оператор, следующий за ELSE , явля-
 ется опертором IF , который управляет двумя операторами в
 фигурных скобках.
     Упражнение  1-9.
     ----------------
     Как бы вы стали проверять программу подсчета слов ?
 Kакие имеются ограничения ?
     Упражнение  1-10.
     -----------------
     Напишите программу, которая будет печатать слова из фай-
 ла ввода, причем по одному на строку.
     Упражнение  1-11.
     ----------------
     Переделайте программу подсчета слов, используя лучшее
 пределение "слова"; считайте, например словом последователь-
 ность букв, цифр и апострофов, рачинающуюся с буквы.
 
      1.6. Массивы.
 
     Давайте напишем программу подсчета числа появлений каж-
 дой цифры, символов пустых промежутков/пробел, табуляции,
 новая строка/ и всех остальных символов. Конечно, такая за-
 дача несколько искусственна, но она позволит нам проиллюст-
 рировать в одной программе сразу несколько аспектов языка
 "C".
     Мы разбили вводимые символы на двенадцать категорий, и
 нам удобнее использовать массив для хранения числа появлений
 каждой цифры, а не десять отдельных переменных. Вот один из
 вариантов программы:
           
     
                            - 27 -
     
 MAIN()  /* COUNT DIGITS, WHITE SPACE, OTHERS */
 {
     INT  C, I, NWHITE, NOTHER;
     INT  NDIGIT[10];
 
     NWHITE = NOTHER = 0;
     FOR (I = 0; I < 10; ++I)
  NDIGIT[I] = 0;
 
     WHILE ((C = GETCHAR()) != EOF)
  IF (C >= '0' && C <= '9')
      ++NDIGIT[C-'0'];
  ELSE IF(C== ' ' \!\! C== '\N' \!\! C== '\T')
      ++NWHITE;
  ELSE
      ++NOTHER;
 
     PRINTF("DIGITS =");
     FOR (I = 0; I < 10; ++I)
     PRINTF(" %D", NDIGIT[I]);
     PRINTF("\NWHITE SPACE = %D, OTHER = %D\N",
      NWHITE, NOTHER);
 }
 
 Описание
 
    INT  NDIGIT[10];
 
 объявляет, что NDIGIT является массивом из десяти целых. в
 языке "C" индексы массива всегда начинаются с нуля /а не с
 1, как в фортране или PL/1/, так что элементами массива яв-
 ляются NDIGIT[0], NDIGIT[1],..., NDIGIT[9]. эта особенность
 отражена в циклах FOR , которые инициализируют и печатают
 массив.
      Индекс может быть любым целым выражением, которое, ко-
 нечно, может включать целые переменные, такие как I , и це-
 лые константы.
      Эта конкретная программа сильно опирается на свойства
 символьного представления цифр. Так, например, в программе
 проверка
 
    IF( C >= '0' && C <= '9')...
 
 определяет, является ли символ в 'C' цифрой, и если это так,
 то численное значение этой цифры определяется по формуле / C
 - '0'/. Такой способ работает только в том случае, если зна-
 чения символьных констант '0', '1' и т.д. Положительны, рас-
 положены в порядке возрастания и нет ничего, кроме цифр,
 между константами '0' и '9'. К счастью, это верно для всех
 общепринятых наборов символов.
     
                            - 28 -
     
     По определению перед проведением арифметических опера-
 ций, вовлекающих переменные типа CHAR и INT, все они преоб-
 разуются к типу INT, TAK что в арифметических выражениях пе-
 ременные типа CHAR по существу идентичны переменным типа
 INT. Это вполне естественно и удобно; например, C -'0'- это
 целое выражение со значением между 0 и 9 в соответствии с
 тем, какой символ от '0' до '9' хранится в 'C', и, следова-
 тельно, оно является подходящим индексом для массива NDIGIT.
     Выяснение вопроса, является ли данный символ цифрой,
 символом пустого промежутка или чем-либо еще, осуществляется
 последовательностью операторов
 
  IF (C >= '0' && C <= '9')
  ++NDIGIT[C-'0'];
  ELSE IF(C == ' ' \!\! C == '\N' \!\! C == '\T')
  ++NWHITE;
  ELSE
  ++NOTHER;
 
 Конструкция
     IF  (условие)
             оператор
     ELSE IF  (условие)
             оператор
     ELSE
             оператор
      
 часто встречаются в программах как средство выражения ситуа-
 ций, в которых осуществляется выбор одного из нескольких
 возможных решений.
     Программа просто движется сверху вниз до тех пор, пока
 не удовлетворится какое-нибудь условие; тогда выполняется
 соответствующий 'оператор', и вся конструкция завершается.
 /Конечно, 'оператор' может состоять из нескольких операто-
 ров, заключенных в фигурные скобки/. Если ни одно из условий
 не удовлетворяется, то выполняется 'оператор', стоящий после
 заключительного ELSE, если оно присутствует. Если последнеE
 ELSE и соответствующий 'оператор' опущены (как в программе
 подсчета слов), то никаких действий не производится. Между
 начальным IF и конечным ELSE может помещаться произвольное
 количество групп
 
 ELSE IF (условие)
    оператор
 
     С точки зрения стиля целесообразно записывать эту конст-
 рукцию так, как мы показали, с тем чтобы длинные выражения
 не залезали за правый край страницы.
     Оператор SWITCH (переключатель), который рассматривается
 в главе 3, представляет другую возможность для записи раз-
 ветвления на несколько вариантов. этот оператор особенно
 удобен, когда проверяемое выражение является либо просто не-
 которым целым, либо символьным выражением, совпадающим с од-
 ной из некоторого набора констант. Версия этой программы,
 использующая оператор SWITCH, будет для сравнения приведена
 в главе 3.
     
                            - 29 -
 
     Упражнение  1-12.
     ----------------
 
     Напишите программу, печатающую гистограмму длин слов из
 файла ввода. Самое легкое - начертить гистограмму горизон-
 тально; вертикальная ориентация требует больших усилий.
 
      1.7. Функции.
 
     В языке "C" функции эквивалентны подпрограммам или функ-
 циям в фортране или процедурам в PL/1, паскале и т.д. Функ-
 ции дают удобный способ заключения некоторой части вычисле-
 ний в черный ящик, который в дальнейшем можно использовать,
 не интересуясь его внутренним содержанием. Использование
 функций является фактически единственным способом справиться
 с потенциальной сложностью больших программ. Если функции
 организованы должным образом, то можно игнорировать то, как
 делается работа; достаточно знание того, что делается. Язык
 "C" разработан таким образом, чтобы сделать использование
 функций легким, удобным и эффективным. Вам будут часто вст-
 речаться функции длиной всего в несколько строчек, вызывае-
 мые только один раз, и они используются только потому, что
 это проясняет некоторую часть программы.
     До сих пор мы использовали только предоставленные нам
 функции типа PRINTF, GETCHAR и PUTCHAR; теперь пора написать
 несколько наших собственных. так как в "C" нет операции воз-
 ведения в степень, подобной операции ** в фортране или PL/1,
 давайте проиллюстрируем механику определения функции на при-
 мере функции POWER(M,N), возводящей целое м в целую положи-
 тельную степень N. Так значение POWER(2,5) равно 32. Конеч-
 но, эта функция не выполняет всей работы операции **, пос-
 кольку она действует только с положительными степенями не-
 больших чисел, но лучше не создавать дополнительных затруд-
 нений, смешивая несколько различных вопросов.
     Ниже приводится функция POWER и использующая ее основная
 программа, так что вы можете видеть целиком всю структуру.
 
  MAIN()  /* TEST POWER FUNCTION */
  {
     INT I;
 
     FOR(I = 0; I < 10; ++I)
      PRINTF("%D %D %D\N",I,POWER(2,I),POWER(-3,I));
  }
 
  POWER(X,N)  /* RAISE  X  N-TH POWER; N > 0  */
  INT X,N;
  {
     INT I, P;
     P = 1;
     FOR (I =1; I <= N; ++I)
     P = P * X;
     RETURN (P);
  }
     
     
                            - 30 -
 
     Все функции имеют одинаковый вид:
  имя (список аргументов, если они имеются)
  описание аргументов, если они имеются
  {
  описания
     операторы
  }
 
 
     Эти функции могут быть записаны в любом порядке и нахо-
 диться в одном или двух исходных файлах. Конечно, если ис-
 ходная программа размещается в двух файлах, вам придется
 дать больше указаний при компиляции и загрузке, чем если бы
 она находилась в одном, но это дело операционной системы, а
 не атрибут языка. В данный момент, для того чтобы все полу-
 ченные сведения о прогоне "C"- программ, не изменились в
 дальнейшем, мы будем предполагать, что обе функции находятся
 в одном и том же файле.
     Функция POWER вызывается дважды в строке
 
 PRINTF("%D %D %D\N",I,POWER(2,I),POWER(-3,I));
 
 при каждом обращении функция POWER, получив два аргумента,
 вазвращает целое значение, которое печатается в заданном
 формате. В выражениях POWER(2,I) является точно таким же це-
 лым, как 2 и I. /Не все функции выдают целое значение; мы
 займемся этим вопросом в главе 4/.
     Аргументы функции POWER должны быть описаны соответству-
 ющим образом, так как их типы известны. Это сделано в строке
 
 INT X,N;
 
 которая следует за именем функции.
     Описания аргументов помещаются между списком аргументов
 и открывающейся левой фигурной скобкой; каждое описание за-
 канчивается точкой с запятой. Имена, использованные для ар-
 гументов функции POWER, являются чисто локальными и недос-
 тупны никаким другим функциям: другие процедуры могут ис-
 пользовать те же самые имена без возникновения конфликта.
 Это верно и для переменных I и P; I в функции POWER никак не
 связано с I в функции MAIN.
     Значение, вычисленное функцией POWER, передаются в MAIN
 с помощью оператора RETURN, точно такого же, как в PL/1.
 внутри круглых скобок можно написать любое выражение. Функ-
 ция не обязана возвращать какое-либо значение; оператор
 RETURN, не содержащий никакого выражения, приводит к такой
 же передаче управления, как "сваливание на конец" функции
 при достижении конечной правой фигурной скобки, но при этом
 в вызывающую функцию не возвращается никакого полезного зна-
 чения.
     Упражнение  1-13.
     ----------------
     Апишите программу преобразования прописных букв из айла
 ввода в строчные, используя при этом функцию OWER(C), кото-
 рая возвращает значение 'C', если C'- не буква, и значение
 соответствующей строчной уквы, если 'C'-буква.
           
                            - 31 -
     
     1.8. Аргументы - вызов по значению.
 
     Один аспект в "C" может оказаться непривычным для прог-
 раммистов, которые использовали другие языки, в частности,
 фортран и PL/1. в языке "C" все аргументы функций передаются
 "по значению". это означает, что вызванная функция получает
 значения своих аргументов с помощью временных переменных
 /фактически через стек/, а не их адреса. Это приводит к не-
 которым особенностям, отличным от тех, с которыми мы сталки-
 вались в языках типа фортрана и PL/1, использующих "вызов по
 ссылке ", где вызванная процедура работает с адресом аргу-
 мента, а не с его значением.
     Главное отличие состоит в том, что в "C" вызванная функ-
 ция не может изменить переменную из вызывающей функции; она
 может менять только свою собственную временную копию.
     Вызов по значению, однако, не помеха, а весьма ценное
 качество. Оно обычно приводит к более компактным программам,
 содержащим меньше не относящихся к делу переменных, потому
 что с аргументами можно обращаться как с удобно инициализи-
 рованными локальными перемнными вызванной процедуры. Вот,
 например, вариант функции POWER использующей это обстоятель-
 ство
 
  POWER(X,N)  /* RAISE  X  N-TH POWER; N > 0;
            VERSION 2 */
  INT X,N;
  {
  INT P;
 
  FOR (P = 1; N > 0; --N)
       P = P * X;
  RETURN (P);
  }
 
 
     Аргумент N используется как временная переменная; из не-
 го вычитается единица до тех пор, пока он не станет нулем.
 Переменная I здесь больше не нужна. чтобы ни происходило с N
 внутри POWER это никак не влияет на аргумент, с которым пер-
 воначально обратились к функции POWER.
     При необходимости все же можно добиться, чтобы функция
 изменила переменную из вызывающей программы. Эта программа
 должна обеспечить установление адреса переменной /техничес-
 ки, через указатель на переменную/, а в вызываемой функции
 надо описать соответствующий аргумент как указатель и ссы-
 латься к фактической переменной косвенно через него. Мы рас-
 смотрим это подробно в главе 5.
     Когда в качестве аргумента выступает имя массива, то
 фактическим значением, передаваемым функции, является адрес
 начала массива. /Здесь нет никакого копирования элементов
 массива/. С помощью индексации и адреса начала функция может
 найти и изменить любой элемент массива. Это - тема следующе-
 го раздела.
     
                            - 32 -
 
      1.9. Массивы символов.
 
     По-видимому самым общим типом массива в "C" является
 массив символов. Чтобы проиллюстрировать использование мас-
 сивов символов и обрабатывающих их функций, давайте напишем
 программу, которая читает набор строк и печатает самую длин-
 ную из них. Основная схема программы достаточно проста:
 
 WHILE (имеется еще строка)
   IF (эта строка длиннее самой длинной из
   предыдущих)
      запомнить эту строку и ее длину
 напечатать самую длинную строку
     По этой схеме ясно, что программа естественным образом
 распадается на несколько частей. Одна часть читает новую
 строку, другая проверяет ее, третья запоминает, а остальные
 части программы управляют этим процессом.
     Поскольку все так прекрасно делится, было бы хорошо и
 написать программу соответсвующим образом. Давайте сначала
 напишем отдельную функцию GETLINE, которая будет извлекать
 следующую строку из файла ввода; это - обобщение функции
 GETCHAR. мы попытаемся сделать эту функцию по возможности
 более гибкой, чтобы она была полезной и в других ситуациях.
 Как минимум GETLINE должна передавать сигнал о возможном по-
 явлении конца файла; более общий полезный вариант мог бы пе-
 редавать длину строки или нуль, если встретится конец файла.
 нуль не может быть длиной строки, так как каждая строка со-
 держит по крайней мере один символ; даже строка, содержащая
 только символ новой строки, имеет длину 1.
     Когда мы находим строку, которая длиннее самой длинной
 из предыдущих, то ее надо где-то запомнить. Это наводит на
 мысль о другой функции, COPY , которая будет копировать но-
 вую строку в место хранения.
     Наконец, нам нужна основная программа для управления
 функциями GETLINE и COPY . Вот результат :
 
 #DEFINE  MAXLINE  1000 /* MAXIMUM INPUT
        LINE SIZE */
  MAIN()  /* FIND LONGEST LINE */
  {
  INT LEN; /* CURRENT LINE LENGTH */
  INT MAX; /* MAXIMUM LENGTH SEEN SO FAR */
  CHAR LINE[MAXLINE]; /* CURRENT INPUT LINE */
  CHAR SAVE[MAXLINE]; /* LONGEST LINE, SAVED */
 
  MAX = 0;
  WHILE ((LEN = GETLINE(LINE, MAXLINE)) > 0)
      IF (LEN > MAX) {
     MAX = LEN;
     COPY(LINE, SAVE);
      }
      IF (MAX > 0)   /* THERE WAS A LINE */
     PRINTF("%S", SAVE);
  }
     
     
                            - 33 -
     
  GETLINE(S,LIM) /* GET LINE INTO S,RETURN LENGTH */
  CHAR S[];
  INT LIM;
  {
     INT C, I;
 
     FOR(I=0;I<LIM-1 && (C=GETCHAR())!=EOF && C!='\N';++I)
     S[I] = C;
     IF (C == '\N')  {
   S[I] = C;
   ++I;
     }
     S[I] = '\0';
     RETURN(I);
  }
 
  COPY(S1, S2)    /* COPY S1 TO S2;
                ASSUME S2 BIG ENOUGH */
  CHAR S1[], S2[];
  {
  INT I;
 
  I = 0;
  WHILE ((S2[I] = S1[I] != '\0')
     ++I;
  }
     
     Функция MAIN и GETLINE общаются как через пару аргумен-
 тов, так и через возвращаемое значение. аргументы GETLINE
 описаны в строках
 
     CHAR S[];
     INT LIM;
 
 которые указывают, что первый аргумент является массивом, а
 второй - целым.
     Длина массива S не указана, так как она определена в
 MAIN . функция GETLINE использует оператор RETURN для пере-
 дачи значения назад в вызывающую программу точно так же, как
 это делала функция POWER. Одни функции возвращают некоторое
 нужное значение; другие, подобно COPY, используются из-за их
 действия и не возвращают никакого значения.
     Чтобы пометить конец строки символов, функция GETLINE
 помещает в конец создаваемого ей массива символ \0 /нулевой
 символ, значение которого равно нулю/. Это соглашение ис-
 пользуется также компилятором с языка "C": когда в "C" -
 программе встречается строчная константа типа
 
    "HELLO\N"
           
                            - 34 -
 
 то компилятор создает массив символов, содержащий символы
 этой строки, и заканчивает его символом \0, с тем чтобы фун-
 кции, подобные PRINTF, могли зафиксировать конец массива:
 
 -------------------------------------------
 !  H !  E  !  L  !  L  !  O  ! \N  ! \0 !
 -------------------------------------------
 
 Спецификация формата %S указывает, что PRINTF ожидает стро-
 ку, представленную в такой форме. Проанализировав функцию
 COPY, вы обнаружите, что и она опирается на тот факт, что ее
 входной аргумент оканчивается символом \0, и копирует этот
 символ в выходной аргумент S2. /Все это подразумевает, что
 символ \0 не является частью нормального текста/.
     Между прочим, стоит отметить, что даже в такой маленькой
 программе, как эта, возникает несколько неприятных организа-
 ционных проблем. Например, что должна делать MAIN, если она
 встретит строку, превышающую ее максимально возможный раз-
 мер? Функция GETLINE поступает разумно: при заполнении мас-
 сива она прекращает дальнейшее извлечение символов, даже ес-
 ли не встречает символа новой строки. Проверив полученную
 длину и последний символ, функция MAIN может установить, не
 была ли эта строка слишком длинной, и поступить затем, как
 она сочтет нужным. Ради краткости мы опустили эту проблему.
     Пользователь функции GETLINE никак не может заранее уз-
 нать, насколько длинной окажется вводимая строка. Поэтому в
 GETLINE включен контроль переполнения. в то же время пользо-
 ватель функции COPY уже знает /или может узнать/, каков раз-
 мер строк, так что мы предпочли не включать в эту функцию
 дополнительный контроль.
     Упражнение  1-14.
     -----------------
     Переделайте ведущую часть программы поиска самой длинной
 строки таким образом, чтобы она правильно печатала длины
 сколь угодно длинных вводимых строк и возможно больший
 текст.
     Упржнение   1-15.
     -----------------
     Напишите программу печати всех строк длиннее 80 симво-
 лов.
     Упражнение  1-16.
     -----------------
     Напишите программу, которая будет удалять из каждой
 строки стоящие в конце пробелы и табуляции, а также строки,
 целиком состоящие из пробелов.
     Упражнение  1-17.
     -----------------
     Напишите функцию REVERSE(S), которая распологает сим-
 вольную строку S в обратном порядке. С ее помощью напишите
 программу, которая обратит каждую строку из файла ввода.
           
                            - 35 -
     
      1.10. Область действия: внешние переменные.
 
     Переменные в MAIN(LINE, SAVE и т.д.) являются внутренни-
 ми или локальными по отношению к функции MAIN, потому что
 они описаны внутри MAIN и никакая другая функция не имеет к
 ним прямого доступа. Это же верно и относительно переменных
 в других функциях; например, переменная I в функции GETLINE
 никак не связана с I в COPY. Каждая локальная переменная су-
 ществует только тогда, когда произошло обращение к соответс-
 твующей функции, и исчезает, как только закончится выполне-
 ние этой функции. По этой причине такие переменные, следуя
 терминологии других языков, обычно называют автоматическими.
 Мы впредь будем использовать термин автоматические при ссыл-
 ке на эти динамические локальные переменные. /в главе 4 об-
 суждается класс статической памяти, когда локальные перемен-
 ные все же оказываются в состоянии сохранить свои значения
 между обращениями к функциям/.
     Поскольку автоматические переменные появляются и исчеза-
 ют вместе с обращением к функции, они не сохраняют своих
 значений в промежутке от одного вызова до другого, в силу
 чего им при каждом входе нужно явно присваивать значения.
 Если этого не сделать, то они будут содержать мусор.
     В качестве альтернативы к автоматическим переменным мож-
 но определить переменные, которые будут внешними для всех
 функций, т.е. Глобальными переменными, к которым может обра-
 титься по имени любая функция, которая пожелает это сделать.
 (этот механизм весьма сходен с "COMMON" в фортране и
 "EXTERNAL" в PL/1). Так как внешние переменные доступны всю-
 ду, их можно использовать вместо списка аргументов для пере-
 дачи данных между функциями. Кроме того, поскольку внешние
 переменные существуют постоянно, а не появляются и исчезают
 вместе с вызываемыми функциями, они сохраняют свои значения
 и после того, как функции, присвоившие им эти значения, за-
 вершат свою работу.
     Внешняя переменная должна быть определена вне всех функ-
 ций; при этом ей выделяется фактическое место в памяти. Та-
 кая переменная должна быть также описана в каждой функции,
 которая собирается ее использовать; это можно сделать либо
 явным описанием EXTERN, либо неявным по контексту. Чтобы
 сделать обсуждение более конкретным, давайте перепишем прог-
 рамму поиска самой длинной строки, сделав LINE, SAVE и MAX
 внешними переменными. Это потребует изменения описаний и тел
 всех трех функций, а также обращений к ним.
 
 #DEFINE MAXLINE 1000   /* MAX. INPUT LINE SIZE*/
 
 CHAR   LINE[MAXLINE];  /* INPUT LINE */
 CHAR   SAVE[MAXLINE];/* LONGEST LINE SAVED HERE*/
 INT   MAX;/*LENGTH OF LONGEST LINE SEEN SO FAR*/
           
     
                            - 36 -
     
 MAIN()  /*FIND LONGEST LINE; SPECIALIZED VERSION*/
 {
    INT     LEN;
    EXTERN  INT   MAX;
    EXTERN  CHAR   SAVE[];
    MAX = 0;
 
 WHILE ( (LEN = GETLINE()) > 0 )
    IF ( LEN > MAX )  {
            MAX = LEN;
            COPY();
    }
 IF ( MAX > 0 )  /* THERE WAS A LINE */
    PRINTF( "%S", SAVE );
 }
 
 GETLINE()       /* SPECIALIZED VERSION */
 {
    INT C, I;
    EXTERN CHAR LINE[];
 
    FOR (I = 0; I < MAXLINE-1
 
     
        && (C=GETCHAR()) !=EOF && C!='\N'; ++I)
             LINE[I] = C;
             ++I;
     }
     LINE[I] = '\0'
     RETURN(I)
  }
  COPY()  /* SPECIALIZED VERSION */
  {
     INT I;
     EXTERN CHAR LINE[], SAVE[];
 
     I = 0;
     WHILE ((SAVE[I] = LINE[I]) !='\0')
             ++I;
  }
     
     Внешние переменные для функций MAIN, GETLINE и COPY оп-
 ределены в первых строчках приведенного выше примера, кото-
 рыми указывается их тип и вызывается отведение для них памя-
 ти. синтаксически внешние описания точно такие же, как опи-
 сания, которые мы использовали ранее, но так как они распо-
 ложены вне функций, соответствующие переменные являются
 внешними. Чтобы функция могла использовать внешнюю переме-
 ную, ей надо сообщить ее имя. Один способ сделать это -
 включить в функцию описание EXTERN; это описание отличается
 от предыдущих только добавлением ключевого слова EXTERN.
     
                            - 37 -
     
     В определенных ситуациях описание EXTERN может быть опу-
 щено: если внешнее определение переменной находится в том же
 исходном файле, раньше ее использования в некоторой конкрет-
 ной функции, то не обязательно включать описание EXTERN для
 этой переменной в саму функцию. Описания EXTERN в функциях
 MAIN, GETLINE и COPY являются, таким образом, излишними.
 Фактически, обычная практика заключается в помещении опреде-
 лений всех внешних переменных в начале исходного файла и
 последующем опускании всех описаний EXTERN.
     Если программа находится в нескольких исходных файлах, и
 некоторая переменная определена, скажем в файле 1, а исполь-
 зуется в файле 2, то чтобы связать эти два вхождения пере-
 менной, необходимо в файле 2 использовать описание EXTERN.
 Этот вопрос подробно обсуждается в главе 4.
     Вы должно быть заметили, что мы в этом разделе при ссыл-
 ке на внешние переменные очень аккуратно используем слова
 описание и определение. "Определение" относится к тому мес-
 ту, где переменная фактически заводится и ей выделяется па-
 мять; "описание" относится к тем местам, где указывается
 природа переменной, но никакой памяти не отводится.
     Между прочим, существует тенденция объявлять все, что ни
 попадется, внешними переменными, поскольку кажется, что это
 упрощает связи, - списки аргументов становятся короче и пе-
 ременные всегда присутствуют, когда бы вам они ни понадоби-
 лись. Но внешние переменные присутствуют и тогда, когда вы в
 них не нуждаетесь. Такой стиль программирования чреват опас-
 ностью, так как он приводит к программам, связи данных внут-
 ри которых не вполне очевидны. Переменные при этом могут из-
 меняться неожиданным и даже неумышленным образом, а програм-
 мы становится трудно модифицировать, когда возникает такая
 необходимость. Вторая версия программы поиска самой длинной
 строки уступает первой отчасти по этим причинам, а отчасти
 потому, что она лишила универсальности две весьма полезные
 функции, введя в них имена переменных, с которыми они будут
 манипулировать.
     Упражнение 1-18.
     ---------------
     Проверка в операторе FOR функции GETLINE довольно неук-
 люжа. Перепишите программу таким образом, чтобы сделать эту
 проверку более ясной, но сохраните при этом то же самое по-
 ведение в конце файла и при переполнении буфера. Является ли
 это поведение самым разумным?
 
     1.11. Резюме
 
     На данном этапе мы обсудили то, что можно бы назвать
 традиционным ядром языка "C". Имея эту горсть строительных
 блоков, можно писать полезные программы весьма значительного
 размера, и было бы вероятно неплохой идеей, если бы вы за-
 держались здесь на какое-то время и поступили таким образом:
 следующие ниже упражнения предлагают вам ряд программ нес-
 колько большей сложности, чем те, которые были приведены в
 этой главе.
     
                            - 38 -
     
     После того как вы овладеете этой частью "C", приступайте
 к чтению следующих нескольких глав. Усилия, которые вы при
 этом затратите, полностью окупятся, потому что в этих главах
 обсуждаются именно те стороны "C", где мощь и выразитель-
 ность языка начинает становиться очевидной.
    Упражнение 1-19.
    ---------------
     Напишите программу DETAB, которая заменяет табуляции во
 вводе на нужное число пробелов так, чтобы промежуток дости-
 гал следующей табуляционной остановки. Предположите фиксиро-
 ванный набор табуляционных остановок, например, через каждые
 N позиций.
     Упражнение 1-20.
     ----------------
     Напишите программу ENTAB, которая заменяет строки пробе-
 лов минимальным числом табуляций и пробелов, достигая при
 этом тех же самых промежутков. Используйте те же табуляцион-
 ные остановки, как и в DETAB.
     Упражнение 1-21.
     ----------------
     Напишите программу для "сгибания" длинных вводимых строк
 после последнего отличного от пробела символа, стоящего до
 столбца N ввода, где N - параметр. убедитесь, что ваша прог-
 рамма делает что-то разумное с очень длинными строками и в
 случае, когда перед указанным столбцом нет ни табуляций, ни
 пробелов.
     Упражнение 1-22.
     ----------------
     Напишите программу удаления из "C"-программы всех ком-
 ментариев. Не забывайте аккуратно обращаться с "закавыченны-
 ми" строками и символьными константами.
     Упражнение 1-23.
     ----------------
     Напишите программу проверки "C"-программы на элементар-
 ные синтаксические ошибки, такие как несоответствие круглых,
 квадратных и фигурных скобок. Не забудьте о кавычках, как
 одиночных, так и двойных, и о комментариях. (Эта программа
 весьма сложна, если вы будете писать ее для самого общего
 случая).
           
