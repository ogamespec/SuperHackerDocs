
                           - 59 -
     
      3. Поток управления
          
      Управляющие операторы языка определяют порядок вычисле-
 ний. В приведенных ранее примерах мы уже встречались с наи-
 более употребительными управляющими конструкциями языка "C";
 здесь мы опишем остальные операторы управления и уточним
 действия операторов, обсуждавшихся ранее.
 
      3.1. Операторы и блоки
      
      Такие выражения, как X=0, или I++, или PRINTF(...),
 становятся операторами, если за ними следует точка с запя-
 той, как, например,
 
     X = 0;
     I++;
     PRINTF(...);
 
 В языке "C" точка с запятой является признаком конца опера-
 тора, а не разделителем операторов, как в языках типа алго-
 ла.
     Фигурные скобки /( и /) используются для объединения
 описаний и операторов в составной оператор или блок, так что
 они оказываются синтаксически эквивалентны одному оператору.
 Один явный пример такого типа дают фигурные скобки, в кото-
 рые заключаются операторы, составляющие функцию, другой -
 фигурные скобки вокруг группы операторов в конструкциях IF,
 ELSE, WHILE и FOR.(на самом деле переменные могут быть опи-
 саны внутри любого блока; мы поговорим об этом в главе 4).
 Точка с запятой никогда не ставится после первой фигурной
 скобки, которая завершает блок.
 
      3.2. IF - ELSE
 
     Оператор IF - ELSE используется при необходимости сде-
 лать выбор. Формально синтаксис имеет вид
 
     IF  (выражение)
             оператор-1
     ELSE
             оператор-2,
 
     Где часть ELSE является необязательной. Сначала вычисля-
 ется выражение; если оно "истинно" /т.е. значение выражения
 отлично от нуля/, то выполняется оператор-1. Если оно ложно
 /значение выражения равно нулю/, и если есть часть с ELSE,
 то вместо оператора-1 выполняется оператор-2.
     
                           - 60 -
     
     Так как IF просто проверяет численное значение выраже-
 ния, то возможно некоторое сокращение записи. Самой очевид-
 ной возможностью является запись
 
    IF  (выражение)
 вместо
    IF  (выражение !=0)
 
 иногда такая запись является ясной и естественной, но време-
 нами она становится загадочной.
     То, что часть ELSE в конструкции IF - ELSE является нео-
 бязательной, приводит к двусмысленности в случае, когда ELSE
 опускается во вложенной последовательности операторов IF.
 Эта неоднозначность разрешается обычным образом - ELSE свя-
 зывается с ближайшим предыдущим IF, не содержащим ELSE.
 Например, в
 
 IF ( N > 0 )
    IF( A > B )
            Z = A;
    ELSE
            Z = B;
 
 конструкция ELSE относится к внутреннему IF, как мы и пока-
 зали, сдвинув ELSE под соответствующий IF. Если это не то,
 что вы хотите, то для получения нужного соответствия необхо-
 димо использовать фигурные скобки:
 
 IF (N > 0)      {
    IF (A > B)
            Z = A;
 }
 ELSE
    Z = B;
 
 
     Tакая двусмысленность особенно пагубна в ситуациях типа
 
 IF (N > 0)
    FOR (I = 0; I < N; I++)
            IF (S[I] > 0) {
     PRINTF("...");
     RETURN(I);
            }
 ELSE   /* WRONG */
    PRINTF("ERROR - N IS ZERO\N");
           
                           - 61 -
     
 Запись ELSE под IF ясно показывает, чего вы хотите, но ком-
 пилятор не получит соответствующего указания и свяжет ELSE с
 внутренним IF. Ошибки такого рода очень трудно обнаруживают-
 ся.
      Между прочим, обратите внимание, что в
 
  IF (A > B)
     Z = A;
  ELSE
     Z = B;
 
 после Z=A стоит точка с запятой. Дело в том, что согласно
 грамматическим правилам за IF должен следовать оператор, а
 выражение типа Z=A, являющееся оператором, всегда заканчива-
 ется точкой с запятой.
 
      3.3. ELSE - IF
      
      Конструкция
 
  IF (выражение)
     оператор
  ELSE    IF (выражение)
             оператор
  ELSE    IF (выражение)
             оператор
  ELSE
     оператор
 
 встречается настолько часто, что заслуживает отдельного
 краткого рассмотрения. Такая последовательность операторов
 IF является наиболее распространенным способом программиро-
 вания выбора из нескольких возможных вариантов. выражения
 просматриваются последовательно; если какое-то выражение
 оказывается истинным,то выполняется относящийся к нему опе-
 ратор, и этим вся цепочка заканчивается. Каждый оператор мо-
 жет быть либо отдельным оператором, либо группой операторов
 в фигурных скобках.
     Последняя часть с ELSE имеет дело со случаем, когда ни
 одно из проверяемых условий не выполняется. Иногда при этом
 не надо предпринимать никаких явных действий; в этом случае
 хвост
 
  ELSE
     оператор
 
 может быть опущен, или его можно использовать для контроля,
 чтобы засечь "невозможное" условие.
     
                           - 62 -
     
     Для иллюстрации выбора из трех возможных вариантов при-
 ведем программу функции, которая методом половинного деления
 определяет, находится ли данное значение х в отсортированном
 массиве V. Элементы массива V должны быть расположены в по-
 рядке возрастания. Функция возвращает номер позиции (число
 между 0 и N-1), в которой значение х находится в V, и -1,
 если х не содержится в V.
 
 BINARY(X, V, N) /* FIND X IN V[0]...V[N-1] */
 INT X, V[], N;
 {
    INT LOW, HIGH, MID;
 
    LOW = 0;
    HIGH = N - 1;
    WHILE (LOW <= HIGH) {
            MID = (LOW + HIGH) / 2;
            IF (X < V[MID])
     HIGH = MID - 1;
            ELSE IF (X > V[MID])
     LOW = MID + 1;
            ELSE   /* FOUND MATCH */
     RETURN(MID);
    }
    RETURN(-1);
 }
 
     Основной частью каждого шага алгоритма является провер-
 ка, будет ли х меньше, больше или равен среднему элементу
 V[MID]; использование конструкции ELSE - IF здесь вполне ес-
 тественно.
     
      3.4. Переключатель
 
     Оператор SWITCH дает специальный способ выбора одного из
 многих вариантов, который заключается в проверке совпадения
 значения данного выражения с одной из заданных констант и
 соответствующем ветвлении. В главе 1 мы привели программу
 подсчета числа вхождений каждой цифры, символов пустых про-
 межутков и всех остальных символов, использующую последова-
 тельность IF...ELSE IF...ELSE. Вот та же самая программа с
 переключателем.
           
                           - 63 -
     
 MAIN() /* COUNT DIGITS,WHITE SPACE, OTHERS */
 {
    INT C, I, NWHITE, NOTHER, NDIGIT[10];
 
    NWHITE = NOTHER = 0;
    FOR (I = 0; I < 10; I++)
            NDIGIT[I] = 0;
 
    WHILE ((C = GETCHAR()) != EOF)
             SWITCH (C) {
             CASE '0':
             CASE '1':
             CASE '2':
             CASE '3':
             CASE '4':
             CASE '5':
             CASE '6':
             CASE '7':
             CASE '8':
             CASE '9':
      NDIGIT[C-'0']++;
      BREAK;
             CASE ' ':
             CASE '\N':
             CASE '\T':
      NWHITE++;
      BREAK;
             DEFAULT :
      NOTHER++;
      BREAK;
             }
     PRINTF("DIGITS =");
     FOR (I = 0; I < 10; I++)
             PRINTF(" %D", NDIGIT[I]);
     PRINTF("\NWHITE SPACE = %D, OTHER = %D\N",
             NWHITE, NOTHER);
 
 
     Переключатель вычисляет целое выражение в круглых скоб-
 ках (в данной программе - значение символа с) и сравнивает
 его значение со всеми случаями (CASE). Каждый случай должен
 быть помечен либо целым, либо символьной константой, либо
 константным выражением. Если значение константного выраже-
 ния, стоящего после вариантного префикса CASE, совпадает со
 значением целого выражения, то выполнение начинается с этого
 случая. Если ни один из случаев не подходит, то выполняется
 оператор после префикса DEFAULT. Префикс DEFAULT является
 необязательным ,если его нет, и ни один из случаев не подхо-
 дит, то вообще никакие действия не выполняются. Случаи и вы-
 бор по умолчанию могут располагаться в любом порядке. Все
 случаи должны быть различными.
     
                           - 64 -
     
     Оператор BREAK приводит к немедленному выходу из перек-
 лючателя. Поскольку случаи служат только в качестве меток,
 то если вы не предпримите явных действий после выполнения
 операторов, соответствующих одному случаю, вы провалитесь на
 следующий случай. Операторы BREAK и RETURN являются самым
 обычным способом выхода из переключателя. Как мы обсудим
 позже в этой главе, оператор BREAк можно использовать и для
 немедленного выхода из операторов цикла WHILE, FOR и DO.
     Проваливание сквозь случаи имеет как свои достоинства,
 так и недостатки. К положительным качествам можно отнести
 то, что оно позволяет связать несколько случаев с одним дей-
 ствием, как было с пробелом, табуляцией и новой строкой в
 нашем примере. Но в то же время оно обычно приводит к необ-
 ходимости заканчивать каждый случай оператором BREAK, чтобы
 избежать перехода к следующему случаю. Проваливание с одного
 случая на другой обычно бывает неустойчивым, так как оно
 склонно к расщеплению при модификации программы. За исключе-
 нием, когда одному вычислению соответствуют несколько меток,
 проваливание следует использовать умеренно.
     Заведите привычку ставить оператор BREAK после последне-
 го случая (в данном примере после DEFAULT), даже если это не
 является логически необходимым. В один прекрасный день, ког-
 да вы добавите в конец еще один случай, эта маленькая мера
 предосторожности избавит вас от неприятностей.
     Упражнение 3-1.
     --------------
     Напишите программу для функции EXPAND(S, T), которая ко-
 пирует строку S в т, заменяя при этом символы табуляции и
 новой строки на видимые условные последовательности, как \N
 и \т. используйте переключатель.
 
      3.5. Циклы - WHILE и FOR
 
     Мы уже сталкивались с операторами цикла WHILE и FOR. В
 конструкции
 
 WHILE (выражение)
    оператор
 
 вычисляется выражение. Если его значение отлично от нуля, то
 выполняется оператор и выражение вычисляется снова. Этот
 цикл продолжается до тех пор, пока значение выражения не
 станет нулем, после чего выполнение программы продолжается с
 места после оператора.
 
    Оператор
 
 FOR (выражение 1; выражение 2; выражение 3)
    оператор
           
                           - 65 -
     
 эквивалентен последовательности
 
 выражение 1;
 WHILE (выражение 2) {
    оператор
    выражение 3;
 }
 
 Грамматически все три компонента в FOR являются выражениями.
 наиболее распространенным является случай, когда выражение 1
 и выражение 3 являются присваиваниями или обращениями к фун-
 кциям, а выражение 2 - условным выражением. любая из трех
 частей может быть опущена, хотя точки с запятой при этом
 должны оставаться. Если отсутствует выражение 1 или выраже-
 ние 3, то оно просто выпадает из расширения. Если же отсутс-
 твует проверка, выражение 2, то считается, как будто оно
 всегда истинно, так что
 
  FOR (;;)        {
     ...
  }
 
 является бесконечным циклом, о котором предполагается, что
 он будет прерван другими средствами (такими как BREAK или
 RETURN).
      Использовать ли WHILE или FOR - это, в основном дело
 вкуса. Например в
 
 WHILE ((C = GETCHAR())
    == ' ' \!\! C == '\N' \!\! C == '\T')
  ;    /* SKIP WHITE SPACE CHARACTERS */
 
 нет ни инициализации, ни реинициализации, так что цикл WHILе
 выглядит самым естественным.
     Цикл FOR, очевидно, предпочтительнее там, где имеется
 простая инициализация и реинициализация, поскольку при этом
 управляющие циклом операторы наглядным образом оказываются
 вместе в начале цикла. Это наиболее очевидно в конструкции
 
  FOR (I = 0; I < N; I++)
 
 которая является идиомой языка "C" для обработки первых N
 элементов массива, аналогичной оператору цикла DO в фортране
 и PL/1. Аналогия, однако, не полная, так как границы цикла
 могут быть изменены внутри цикла, а управляющая переменная
 сохраняет свое значение после выхода из цикла, какова бы ни
 была причина этого выхода. Поскольку компонентами FOR могут
 быть произвольные выражения, они не ограничиваются только
 арифметическими прогрессиями. Тем не менее является плохим
 стилем включать в FOR вычисления, которые не относятся к уп-
 равлению циклом, лучше поместить их в управляемые циклом
 операторы.
     
                           - 66 -
     
     В качестве большего по размеру примера приведем другой
 вариант функции ATOI, преобразующей строку в ее численный
 эквивалент. Этот вариант является более общим; он допускает
 присутствие в начале символов пустых промежутков и знака +
 или -. (В главе 4 приведена функция ATOF, которая выполняет
 то же самое преобразование для чисел с плавающей точкой).
     Общая схема программы отражает форму поступающих данных:
 
  - пропустить пустой промежуток, если он имеется
  - извлечь знак, если он имеется
 
  - извлечь целую часть и преобразовать ее
 
 Каждый шаг выполняет свою часть работы и оставляет все в
 подготовленном состоянии для следующей части. Весь процесс
 заканчивается на первом символе, который не может быть
 частью числа.
 
 ATOI(S)   /* CONVERT S TO INTEGER */
 CHAR S[];
 {
 INT I, N, SIGN;
 FOR(I=0;S[I]==' ' \!\!
          S[I]=='\N' \!\! S[I]=='\T';I++)
    ; /* SKIP WHITE SPACE */
 SIGN = 1;
 IF(S[I] == '+' \!\! S[I] == '-')  /* SIGN */
    SIGN = (S[I++]=='+') ? 1 : - 1;
 FOR( N = 0; S[I] >= '0' && S[I] <= '9'; I++)
    N = 10 * N + S[I] - '0';
 RETURN(SIGN * N);
 }
 
     Преимущества централизации управления циклом становятся
 еще более очевидными, когда имеется несколько вложенных цик-
 лов. Следующая функция сортирует массив целых чисел по мето-
 ду шелла. основная идея сортировки по шеллу заключается в
 том, что сначала сравниваются удаленные элементы, а не смеж-
 ные, как в обычном методе сортировки. Это приводит к быстро-
 му устранению большой части неупорядоченности и сокращает
 последующую работу. Интервал между элементами постепенно
 сокращается до единицы, когда сортировка фактически превра-
 щается в метод перестановки соседних элементов.
                               
     
                           - 67 -
     
 SHELL(V, N)   /* SORT V[0]...V[N-1]
                INTO INCREASING ORDER */
 INT V[], N;
 {
   INT GAP, I, J, TEMP;
 
   FOR (GAP = N/2; GAP > 0; GAP /= 2)
      FOR (I = GAP; I < N; I++)
   FOR (J=I-GAP; J>=0 && V[J]>V[J+GAP]; J-=GAP) {
    TEMP = V[J];
    V[J] = V[J+GAP];
    V[J+GAP] = TEMP;
   }
 }
          
 Здесь имеются три вложенных цикла. Самый внешний цикл управ-
 ляет интервалом между сравниваемыми элементами, уменьшая его
 от N/2 вдвое при каждом проходе, пока он не станет равным
 нулю. Средний цикл сравнивает каждую пару элементов, разде-
 ленных на величину интервала; самый внутренний цикл перес-
 тавляет любую неупорядоченную пару. Так как интервал в конце
 концов сводится к единице, все элементы в результате упоря-
 дочиваются правильно. Отметим, что в силу общности конструк-
 ции FOR внешний цикл укладывается в ту же самую форму, что и
 остальные, хотя он и не является арифметической прогрессией.
     Последней операцией языка "C" является запятая ",", ко-
 торая чаще всего используется в операторе FOR. Два выраже-
 ния, разделенные запятой, вычисляются слева направо, причем
 типом и значением результата являются тип и значение правого
 операнда. Таким образом, в различные части оператора FOR
 можно включить несколько выражений, например, для параллель-
 ного изменения двух индексов. Это иллюстрируется функцией
 REVERSE(S), которая располагает строку S в обратном порядке
 на том же месте.
 
  REVERSE(S)    /* REVERSE STRING S IN PLACE */
  CHAR S[];
  {
  INT C, I, J;
 
  FOR(I = 0, J = STRLEN(S) - 1; I < J; I++, J--)  {
     C = S[I];
     S[I] = S[J];
     S[J] = C;
  }
  }
 
 Запятые, которые разделяют аргументы функций, переменные в
 описаниях и т.д., не имеют отношения к операции запятая и не
 обеспечивают вычислений слева направо.
           
     
                           - 68 -
     
     Упражнение 3-2.
     ---------------
     Составьте программу для функции EXPAND(S1,S2), которая
 расширяет сокращенные обозначения вида а-Z из строки S1 в
 эквивалентный полный список авс...XYZ в S2. Допускаются сок-
 ращения для строчных и прописных букв и цифр. Будьте готовы
 иметь дело со случаями типа а-в-с, а-Z0-9 и -а-Z. (Полезное
 соглашение состоит в том, что символ -, стоящий в начале или
 конце, воспринимается буквально).
 
      3.6. Цикл DO - WHILE
 
     Как уже отмечалось в главе 1, циклы WHILE и FOR обладают
 тем приятным свойством, что в них проверка окончания осущес-
 твляется в начале, а не в конце цикла. Третий оператор цикла
 языка "C", DO-WHILE, проверяет условие окончания в конце,
 после каждого прохода через тело цикла; тело цикла всегда
 выполняется по крайней мере один раз. Синтаксис этого опера-
 тора имеет вид:
 
 DO
    оператор
 WHILE (выражение)
 
 Сначала выполняется оператор, затем вычисляется выражение.
 Если оно истинно, то оператор выполняется снова и т.д. Если
 выражение становится ложным, цикл заканчивается.
 
     Как и можно было ожидать, цикл DO-WHILE используется
 значительно реже, чем WHILE и FOR, составляя примерно пять
 процентов от всех циклов. Тем не менее, иногда он оказывает-
 ся полезным, как, например, в следующей функции ITOA, кото-
 рая преобразует число в символьную строку (обратная функции
 ATOI). Эта задача оказывается несколько более сложной, чем
 может показаться сначала. Дело в том, что простые методы вы-
 деления цифр генерируют их в неправильном порядке. Мы пред-
 почли получить строку в обратном порядке, а затем обратить
 ее.
           
                           - 69 -
     
     
 ITOA(N,S)   /*CONVERT N TO CHARACTERS IN S */
 CHAR S[];
 INT N;
 {
 INT I, SIGN;
 
 IF ((SIGN = N) < 0)   /* RECORD SIGN */
    N = -N;     /* MAKE N POSITIVE */
 I = 0;
 DO {    /* GENERATE DIGITS IN REVERSE ORDER */
    S[I++] = N % 10 + '0';/* GET NEXT DIGIT */
 }   WHILE ((N /=10) > 0); /* DELETE IT */
 IF (SIGN < 0)
    S[I++] = '-'
 S[I] = '\0';
 REVERSE(S);
 }
 
 Цикл DO-WHILE здесь необходим, или по крайней мере удобен,
 поскольку, каково бы ни было значение N, массив S должен со-
 держать хотя бы один символ. Мы заключили в фигурные скобки
 один оператор, составляющий тело DO-WHILе, хотя это и не
 обязательно, для того, чтобы торопливый читатель не принял
 часть WHILE за начало оператора цикла WHILE.
     Упражнение 3-3.
     --------------
     При представлении чисел в двоичном дополнительном коде
 наш вариант ITOA не справляется с наибольшим отрицательным
 числом, т.е. Со значением N рAвным -2 в степени м-1, где м -
 размер слова. объясните почему. Измените программу так, что-
 бы она правильно печатала это значение на любой машине.
 
     Упражнение 3-4.
     --------------
     Напишите аналогичную функцию ITOB(N,S), которая преобра-
 зует целое без знака N в его двоичное символьное представле-
 ние в S. Запрограммируйте функцию ITOH, которая преобразует
 целое в шестнадцатеричное представление.
    Упражнение 3-5.
    ---------------
     Напишите вариант Iтоа, который имеет три, а не два аргу-
 мента. Третий аргумент - минимальная ширина поля; преобразо-
 ванное число должно, если это необходимо, дополняться слева
 пробелами, так чтобы оно имело достаточную ширину.
            
                           - 70 -
     
     
 3.7. Оператор BREAK
 
     Иногда бывает удобным иметь возможность управлять выхо-
 дом из цикла иначе, чем проверкой условия в начале или в
 конце. Оператор BRеак позволяет выйти из операторов FOR,
 WHILE и DO до окончания цикла точно так же, как и из перек-
 лючателя. Оператор BRеак приводит к немедленному выходу из
 самого внутреннего охватывающего его цикла (или переключате-
 ля).
     Следующая программа удаляет хвостовые пробелы и табуля-
 ции из конца каждой строки файла ввода. Она использует опе-
 ратор BRеак для выхода из цикла, когда найден крайний правый
 отличный от пробела и табуляции символ.
 
  #DEFINE MAXLINE 1000
  MAIN()    /* REMOVE TRAILING BLANKS AND TABS */
  {
  INT N;
  CHAR LINE[MAXLINE];
 
  WHILE ((N = GETLINE(LINE,MAXLINE)) > 0) {
   WHILE (--N >= 0)
         IF (LINE[N] != ' ' && LINE[N] != '\T'
         && LINE[N] != '\N')
               BREAK;
   LINE[N+1] = '\0';
   PRINTF("%S\N",LINE);
  }
  }
 
     Функция GETLINE возвращает длину строки. Внутренний цикл
 начинается с последнего символа LINE (напомним, что --N
 уменьшает N до использования его значения) и движется в об-
 ратном направлении в поиске первого символа , который отли-
 чен от пробела, табуляции или новой строки. Цикл прерывает-
 ся, когда либо найден такой символ, либо N становится отри-
 цательным (т.е., когда просмотрена вся строка). Советуем вам
 убедиться, что такое поведение правильно и в том случае,
 когда строка состоит только из символов пустых промежутков.
     В качестве альтернативы к BRеак можно ввести проверку в
 сам цикл:
 
 WHILE ((N = GETLINE(LINE,MAXLINE)) > 0) {
  WHILE (--N >= 0
      && (LINE[N] == ' ' \!\! LINE[N] == '\T'
      \!\! LINE[N] == '\N'))
            ;
    ...
 }
     
                           - 71 -
 
 Это уступает предыдущему варианту, так как проверка стано-
 вится труднее для понимания. Проверок, которые требуют пе-
 реплетения &&, \!\!, ! И круглых скобок, по возможности сле-
 дует избегать.
 
      3.8. Оператор CONTINUE
 
     Оператор CONTINUE родственен оператору BRеак, но исполь-
 зуется реже; он приводит к началу следующей итерации охваты-
 вающего цикла (FOR, WHILE, DO ). В циклах WHILE и DO это оз-
 начает непосредственный переход к выполнению проверочной
 части; в цикле FOR управление передается на шаг реинициали-
 зации. (Оператор CONTINUE применяется только в циклах, но не
 в переключателях. Оператор CONTINUE внутри переключателя
 внутри цикла вызывает выполнение следующей итерации цикла).
     В качестве примера приведем фрагмент, который обрабаты-
 вает только положительные элементы массива а; отрицательные
 значения пропускаются.
 
 FOR (I = 0; I < N; I++) {
  IF (A[I] < 0) /* SKIP NEGATIVE ELEMENTS */
        CONTINUE;
      ...  /* DO POSITIVE ELEMENTS */
 }
 
 Оператор CONTINUE часто используется, когда последующая
 часть цикла оказывается слишком сложной, так что рассмотре-
 ние условия, обратного проверяемому, приводит к слишком глу-
 бокому уровню вложенности программы.
 
Упражнение 3-6.
--------------
 
     Напишите программу копирования ввода на вывод, с тем ис-
 ключением, что из каждой группы последовательных одинаковых
 строк выводится только одна. (Это простой вариант утилиты
 UNIQ систем UNIX).
     
     3.9. Оператор GOTO и метки
 
     В языке "C" предусмотрен и оператор GOTO, которым беско-
 нечно злоупотребляют, и метки для ветвления. С формальной
 точки зрения оператор GOTO никогда не является необходимым,
 и на практике почти всегда можно обойтись без него. Мы не
 использовали GOTO в этой книге.
     Тем не менее, мы укажем несколько ситуаций, где оператор
 GOTO может найти свое место. Наиболее характерным является
 его использование тогда, когда нужно прервать выполнение в
 некоторой глубоко вложенной структуре, например, выйти сразу
 из двух циклов. Здесь нельзя непосредственно использовать
 оператор BRеак, так как он прерывает только самый внутренний
 цикл. Поэтому:
           
                           - 72 -
     
   FOR ( ... )
      FOR ( ... )    {
              ...
              IF (DISASTER)
       GOTO ERROR;
      }
   ...
 
 ERROR:
    CLEAN UP THE MESS
     
 Если программа обработки ошибок нетривиальна и ошибки могут
 возникать в нескольких местах, то такая организация оказыва-
 ется удобной. Метка имеет такую же форму, что и имя перемен-
 ной, и за ней всегда следует двоеточие. Метка может быть
 приписана к любому оператору той же функции, в которой нахо-
 дится оператор GOTO.
     В качестве другого примера рассмотрим задачу нахождения
 первого отрицательного элемента в двумерном массиве. (Много-
 мерные массивы рассматриваются в главе 5). Вот одна из воз-
 можностей:
 
   FOR (I = 0; I < N; I++)
      FOR (J = 0; J < M; J++)
              IF (V[I][J] < 0)
       GOTO FOUND;
      /* DIDN'T FIND */
   ...
 FOUND:
   /* FOUND ONE AT POSITION I, J */
   ...
 
     Программа, использующая оператор GOTO, всегда может быть
 написана без него, хотя, возможно, за счет повторения неко-
 торых проверок и введения дополнительных переменных. Напри-
 мер, программа поиска в массиве примет вид:
 
 FOUND = 0;
 FOR (I = 0; I < N && !FOUND; I++)
    FOR (J = 0; J < M && !FOUND; J++)
            FOUND = V[I][J] < 0;
 IF (FOUND)
    /* IT WAS AT I-1, J-1 */
    ...
 ELSE
    /* NOT FOUND */
    ...
     Хотя мы не являемся в этом вопросе догматиками, нам все
 же кажется, что если и нужно использовать оператор GOTO, то
 весьма умеренно.
