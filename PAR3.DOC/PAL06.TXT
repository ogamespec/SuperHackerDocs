                                                          ГЛАВА 6
-----------------------------------------------------------------
     
                            ПРОЦЕДУРЫ
     
-----------------------------------------------------------------
     
     С  помощью процедур и библиотек процедур вы можете дополнить 
набор команд и функций PAL и  усовершенствовать  ваши  прикладные 
системы. В настоящей главе описано: 
     
  -  что такое процедура;
     
  -  как определять и удалять из памяти процедуры;
     
  -  как обращаться к процедурам;
     
  -  как создавать библиотеки процедур.
     
     
     
                      ЧТО ТАКОЕ ПРОЦЕДУРА?
-----------------------------------------------------------------

     Процедурой  называется  программный модуль, состоящий из ко-
манд PAL и созданный для  выполнения  определенной  задачи.  Если
процедура определена (т. е. считана в память ), то ее можно расс-
матривать  как пользовательскую команду или  функцию,  работающую
аналогично  встроенным  командам и функциям PAL.То есть процедуру
можно вызывать, включая ее имя в скрипт и передавать ей один  или
более  параметров,  необходимых  для ее работы. После обращения к
процедуре, она выполняет свою задачу (т.е. набор команд,  состав-
ляющих ее) и может возвратить вызывающему ее скрипту определенный
набор величин.
     Процедуры похожы на скрипты - они тоже связывают  последова-
тельность команд в один пакет. В отличие  от  скриптов,  процеду-
ры  могут  обмениваться переменными с вызывающими модулями. Можно
объявить некоторые переменные, используемые  процедурой,  ограни-
ченными в этой процедуре. Таким образом процедуры работают анало-
гично подпрограммам. Их можно использовать для  разделения  вашей
программы  на  функциональные  модули, которые легко отлаживать и
тестировать.
     Для структурирования вашей программы и обеспечения автомати-
ческого  распределения  памяти  в прикладных системах применяются
скрытые процедуры. При завершении работы скрытой  процедуры  весь
объем  оперативной памяти, используемый ее переменными, массивами
и вызываемыми ею процедурами, освобождается.
     Если процедура определена, она загружается в оперативную па-
мять. Напротив, скрипты все время содержатся в файлах и интерпре-
тируются системой Paradox  покомандно. В результате этого обраще-
ние  к процедуре требует меньше времени, чем обращение к скрипту,
содержащему те же самые команды. PAL позволяет вам объявить неог-
раниченное количество процедур. 
     Библиотекой процедур называется группа предопределенных про-
цедур, сохраняемая в файле на диске так, что процедуры из нее мо-
гут  быть  быстро загружены в оперативную память и немедленно вы-
полнены. Включение часто используемых процедур в библиотеки  зна-
чительно  усовершенствует  действие  больших  прикладных систем и
уменьшает количество файлов в соответствующих программных пакетах.
     Кроме того, если процедуры заключены в  библиотеки,  то  PAL
может  автоматически  вводить и удалять их из оперативной памяти.
Библиотечные процедуры могут также использовать расширение  памя-
ти, если на вашем компьютере установлены платы EMS или EEMS.  Оп-
тимальной  конфигурацией  большинства  прикладных систем является
небольшой ведущий скрипт, группа таблиц и форм, а также библиоте-
ка процедур.
     
     
     
                      ОПРЕДЕЛЕНИЕ ПРОЦЕДУР
-----------------------------------------------------------------
     
     Процедуры  определяются  командой PROC. Первая строка каждой
процедуры, или заголовок, состоит из:
     
  -  ключевого слова PROC;
     
  -  необязательного ключевого слова CLOSED;
     
  -  имени процедуры;
     
  -  заключенного в скобки списка параметров, разделенных запяты-
     ми. 
     
     Скобки,  в  которых  заключен список параметров, обязательно
должны быть в заголовке, даже если список параметров пуст. 
     Команды между заголовком процедуры и ключевым словом ENDPROC
составляет  тело  процедуры.  Команды,  составляющие тело, должны
быть командами PAL или обращениями к функциям и  другим  процеду-
рам. 
     При  исполнении команды PROC PAL обрабатывает тело процедуры
и помещает его в оперативную память. Начиная с этого момента про-
цедура  считается  определенной и содержится в оперативной памяти
до тех пор, пока не будет выполнено одно из условий:
     
  -  закончится выполнение всех скриптов;
     
  -  с помощью команды RELEASE PROCS процедура будет  удалена  из
     памяти; 
     
  -  закончится выполнение скрытой процедуры, внутри которой  оп-
     ределена данная процедура;
     
  -  если  данная процедура - скрытая, то по окончанию ее выпоне-
     ния.
     
     Перед обращением к процедуре ее обязательно надо определить.
Процедуры могут содержать определения других процедур, но опреде-
ленные  в  них  процедуры загружаются в оперативную память только
при обращении к объемлющей процедуре.
     Пример на рис.6-1 определяет процедуру  DelLast,  предназна-
ченную  для удаления последней записи из таблицы, имя которой яв-
ляется параметром процедуры. Процедура возвращает число оставших-
ся записей. 
     
     
     PROC  DelLast(tblname)    ; заголовок процедуры
       EDIT tblname            ; вход в режим редактирования
       END                     ; переход к последней записи
       DEL                     ; удаление ее
       DO_IT!                  ; завершение редактирования
       RETURN [#]              ; возврат числа оставшихся записей
     ENDPROC                   ; конец процедуры
     
                 Рис.6-1. Определение процедуры.
     
     Для  того,  чтобы  переопределить процедуру, следует сначала
удалить уже определенную процедуру с тем же именем. Иначе PAL иг-
норирует новые определения процедуры. Следует соблюдать осторож-
ность, включая определения процедур в циклы и другие структуры. 
     
     
               Обмен и удаление процедур из памяти
-----------------------------------------------------------------
     
     Так как определения процедур  занимают  опетативную  память,
одновременно может быть определено лишь ограниченное число проце-
дур. Существует три способа освобождения памяти, занятой процеду-
рами:
     
  -  Можно использовать команду RELEASE PROCS для удаления проце- 
     дур, определенных ранее.Команда RELEASE PROCS позволяет рас- 
     пределять ресурсы памяти, избирательно удаляя процедуры пос- 
     ле их использования. Дополнительная информация содержится  в 
     главе  15.  С помощью команды RELEASE PROCS можно также уда- 
     лять процедуры  перед  их  повторным  определением.  Команду 
     RELEASE  PROCS,  требующую  удаления определенной процедуры, 
     нельзя включать в тело этой процедуры. 
      
  -  Если определение процедуры было прочитано из библиотеки, PAL
     автоматически  удалит  (обменяет)  эту процедуру, как только
     потребуется память для другой процедуры или каких-либо  иных
     целей.  В большинстве случаев могут удаляться любые процеду-
     ры, даже процедура, вызвавшая текущую процедуру. Когда вновь
     потребуется  обратиться к удаленной процедуре, то ее опреде-
     ление будет вновь автоматически внесено  в  оперативную  па-
     мять.  PAL в последнюю очередь удаляет из оперативной памяти
     те процедуры, обращение к которым произошло  позднее  всего.
     Подробности смотри в главе 15.
      
     Если установлены платы EMS или EEMS, процедуры, автоматичес-
     ки удаленные из оперативной памяти, загружаются в  расширен-
     ную  память.  Это значительно увеличивает скорость повторной
     загрузки удаленных процедур. Если платы  расширенной  памяти
     отсутствуют, то удаленные процедуры считываются из библиоте-
     ки на диске. 
     
  -  Если процедура определена как скрытая, то все ресурсы, кото-
     рыми она пользовалась, автоматически освобождаются после ее
     завершения. 
   
     
     
                     ОБРАЩЕНИЕ К ПРОЦЕДУРАМ
-----------------------------------------------------------------
     
     Существует два способа обращения к процедурам:
                 
  -  можно включить ее имя в скрипт:
     
     DelLast ("orders")      ; удаляет последнюю запись в таблице
                             ; orders4
     
  -  Если процедура возвращает величину, ее можно включить  в вы-
     ражение. При этом во время обработки выражения имя процедуры
     заменяется  на  возвращаемую  величину. Кроме того, значение
     возвращаемой  величины  присваивается  системной  переменной
     retval.
     
     Таким образом, обращение к процедуре:
     
     MESSAGE "There are ", DelLast("orders"), "records in ORDERS"
     
     действует также как:
     
     DelLast("orders")             ; уничтожение последней записи
     MESSAGE "There are ", retval, "records in ORDERS"
     
     Обратиться к процедуре можно еще несколькими способами:
     
     fdate  =  pdate  +  Tdate(today())  ; присваивает переменной
                                         ; fdate  сумму  pdate  и
                                         ; значения функции Tdate 
     IF  Bigord(csum(),"orders")>100     ; процедура Bigord вызы-
         THEN ...                        ; вается в условном  вы-
     ENDIF                               ; ражении
     
     Во  всех этих случаях обращение к процедуре состоит из имени 
процедуры, за которым следует заключенный в скобки  список  аргу- 
ментов, разделенных запятыми. Число аргументов, передаваемых про- 
цедуре при обращении к ней, должно совпадать с числом  формальных 
параметров  процедуры. Даже если процедура не требует параметров, 
скобки после ее имени необходимы. 
     
     
                         Возврат величин
-----------------------------------------------------------------
     
     Для возврата величин скрипту из процедуры можно использовать
команду  RETURN.  Выполнением этой команды завершается процедура,
при этом скрипту передается  значение  выражения, следующего  за
RETURN.  Процедура  может  возвратить только одну величину любого
типа.
     Например, процедура, приведенная на рис.6-1, возвращает  те-
кущее число записей. В примере на рис.6-2 процедура GetBirth воз-
вращает значение переменной BDay. 
     Побочный эффект завершения процедуры заключается в том,  что
возвращаемая величина присваивается системной переменной retval.
     Рассмотрим  процедуру  GetBirth,  возвращающую дату рождения
рабочего, имя которого присвоено переменной name.
     В процедуру введен условный оператор IF для проверки, запол-
нено ли поле дня рождения работника в таблице "empdata".
     
     
     PROC GetBirth(empname)
         VIEW "empdata"      MOVETO [Name]
         LOCATE empname
         BDay = [Birthday]
         CLEARIMAGE
         RETURN BDay
     ENDPROC
     
     ...
     
     Birth Day = GetBirth(name)
     IF ISBLANK (BirthDay)       ; определен ли день рождения?
         THEN MESSAGE name, "еще не сообщил мне день рождения"
         ELSE MESSAGE name, "родился:", BirthDay
     ENDIF
     
                 Рис.6-2.  Возврат  величины.  
     
                                             
     
                  Передача аргументов процедуре
-----------------------------------------------------------------
                                                                 
     При  обращении  к процедуре значения аргументов присваивают-
ся формальным  параметрам,  определенным  в  описании  процедуры.
Этот  метод  называется  передачей  аргументов  по  значению. При
этом исключается зависимость значений аргументов  от  порядка  их
передачи  процедуре.  
     Массивы  нельзя  использовать  в  качестве аргументов проце-
дур, можно передавать им лишь значения элементов  массивов  (нап-
ример, b[3]).
     Пример на рис.6-3 определяет процедуру Future, имеющую в ка- 
честве  аргументов  дату  и число недель, и возвращающую дату, на
это число  недель  отстоящую  от  первоначальной.  Когда  функция
Future  используется в команде MESSAGE, PAL вычисляет значения ее
аргументов TODAY () и X и присваивает их величины соответствующим
формальным параметрам. Затем выполняется тело процедуры. При этом
присваивание формальному параметру W нового значения внутри  тела
процедуры  не  влияет на значение входного фактического параметра
X, используемого при обращении к процедуре. 
     
     PROC Future(d,w)       ; возвращаемая дата на w недель позже
                            ; чем d
         w = w * 7          ; перевод w в дни
         RETURN (d+w)        
     ENDPROC
     x = 4
     MESSAGE  "Future date is", Future (TODAY(), x)
     
                 Рис.6-3. Аргументы в процедуре.
     
     
     
              Ограниченные и глобальные переменные
-----------------------------------------------------------------
     
     Так  как  d  и  w являются формальными параметрами процедуры 
Future (рис.6-3), то они определены только  во  время  выполнения 
процедуры.  После  завершения процедуры величины формальных пара- 
метров теряются. Такие параметры называют ограниченными в  проце- 
дуре  Future. Для того, чтобы переменную явно объявить ограничен- 
ной, используется ключевое слово PRIVATE. 
     Предположим, в примере на рис.6-3 мы присвоили значения гло-
бальным переменным w и y перед обращением к процедуре Future:
     
     w = 3
     x = 4
     y = 5
     MESSAGE  Future (TODAY(), x)
     MESSAGE  "w is", w          ; сохраняет величину 3
                                                       
     Внутри тела процедуры Future при всех действиях с переменной
w имеется ввиду величина формального параметра (в  нашем  примере
она равна 4, так как ей присвоена величина фактического параметра
x). Глобальная переменная w, равная 3, скрыта от процедуры Future.
     Однако глобальные переменные x и y не являются  скрытыми  от
Future, так как она не имеет формальных параметров с этими имена-
ми. При любом обращении к этим переменным в теле процедуры Future
PAL будет считать , что произошло обращение к глобальным перемен-
ным.
     Предположим теперь, что Future обращается к некоторой другой
процедуре с именем Past. Если переменная w не является ограничен-
ной в процедуре Past, любое ее упоминание в теле  этой  процедуры
будет  рассматриваться  как  обращение  к  переменной w процедуры
Future. Если переменная x не является  ограниченной  в  процедуре
Past,  любое ее упоминание в теле этой процедуры будет рассматри-
ваться  как  обращение  к глобальной переменной x. 
     В общем, если переменная v является ограниченной в процедуре
P,  то любое обращение к ней внутри P (как присваивание ей значе-
ния, так и использование ее в выражении) считается  обращением  к
ограниченной  переменной.  Иначе  переменная  v рассматривается в
контексте процедуры, вызывающей P. При этом сформулированное выше
правило  следует применить снова. Эта схема называется динамичес-
ким контекстом (dynamic scoping) переменных. 
     Если это кажется вам сложным, мы рекомендуем избегать  пута-
ницы,  используя  только ограниченные переменные (путем включения
их в список формальных параметров или используя команду PRIVATE),
если  отсутствуе  необходимость  присвоить  новое значение внутри
процедуры именно глобальной переменной.  Чем  более  сложна  ваша
прикладная система, тем более важно использовать эту рекомендацию.
     
     
                     Ключевое слово PRIVATE
-----------------------------------------------------------------
     
     Так как формальные параметры процедуры являются ограниченны-
ми, вы можете присваивать им новые значения, не опасаясь за судь-
бу других переменных с этим же именем, используемых в других час-
тях программы.
     Для защиты других переменных, используемых внутри  процедуры
надо объявить их ограниченными, используя ключевое слово PRIVATE.
Это ключевое слово должно быть первой командой тела процедуры.  В
примере  на рис.6-4 описана процедура, использующая теорему Пифа-
гора для вычисления длины гипотенузы треугольника. С помощью  ко-
манды  PRIVATE  переменные  w  и z объявлены ограниченными в этой
процедуре. Есмли бы не было этой команды, то величина  глобальных
переменных  с этими же именами менялась бы при каждом обращении к
процедуре.
     
     
     PROC Hipotenuse(x,y)
         PRIVATE w,z        ; объявляет w и z ограниченными 
         w = x  *  x        ; использует эти переменные в вычи-
                            ; слениях 
         z = y * y
         RETURN (SQRT(z+w))
     ENDPROC
     
     x = 4
     y = 5
     ? Hypotenuse (x,y)     ; печатает длину гипотенузы 
     ? x,y                  ; сохраняют первоначальные значения 
                            ; 4 и 5
     
                                  
          Рис. 6-4. Объявление ограниченных переменных.
          
     
     В разделе " Скрытые процедуры" содержится описание использо-
вания переменных и массивов в скрытых процедурах.
     Массивы тоже можно объявить ограниченными. При  этом  доста-
точно  написать только имя массива после команды PRIVATE, а затем
объявить его размер с помощью команды ARRAY:

     PROC Foo(x)
         PRIVATE a
     ...
     ARRAY a[20]
     ...
     ENDPROC
     
     
     
                       БИБЛИОТЕКИ ПРОЦЕДУР
-----------------------------------------------------------------
     
     Библиотекой  процедур  является  специальный файл , содержа-
щий определения процедур, обработанные специальным образом,  поз-
воляющим  быстро  загружать  процедуры  в  оперативную  память  и
выполнять их. Внесения процедур в  библиотеку  позволяет  пользо-
ваться  преимуществами компилятора при разработке и запуске прик-
ладных систем:
     
  -  Процедуры, содержащиеся  в  библиотеках,  загружаются  быст-
     рее,  чем  процедуры, описанные в виде скриптов.
     
  -  PAL  имеет возможность автоматически обменивать библиотечные
     процедуры, надобность в которых отпала,  на  процедуры,  ко-
     торые  будут  необходимы. 
     
  -  Вы  можете  объединять различные скрипты, содержащие большую 
     прикладную систему в одну библиотеку  процедур  и  маленький 
     скрипт - драйвер.
     
  -  Библиотеки  процедур  являются прекрасным средством для опи-
     сания макрокоманд, загружаемых  и  выполняемых  по  требова-
     нию.
     
     Библиотеки  процедур  впервые  введены  в версии 1.1 системы
Paradox  и  усовершенствованы  в  версии  2.0.  Ваши   прикладные
системы  не  смогут пользоваться библиотечными  процедурами, если
запускать их под  управлением  систем Paradox версии 1.0.
     В настоящем разделе описаны команды,  необходимые  для  соз-
дания  и  использования  библиотек процедур. В главе 15 содержит-
ся дополнительная информация об использовании библиотек  процедур
и  предложения  по  использованию  их в различных версиях системы
Paradox.  Роль  библиотек  процедур  в   структурировании   ваших
прикладных  систем  проиллюстрирована  на  примерах,  описанных в
главах 22 и  23.
     
     
     
                  Создание библиотеки процедур
-----------------------------------------------------------------
     
     Для  создания  библиотеки  процедур   используется   команда
CREATELIB.  Перед  тем,  как  загрузить  процедуру  в   библиоте-
ку,  ее  нужно  явно  создать  с помощью этой команды. Параметром
команды  CREATELIB  является  строковое  выражение,  обозначающее
имя  библиотеки.  PAL  дает  библиотечным файлам расширение .LIB,
таким  образом, 
     
     CREATELIB "myprocs"
     
создает файл с именем  MYPROCS.LIB.
     Приведенный   на   рис.6-5   скрипт    создает    библиотеку
ordprocs,  определяет  процедуры  DelLast  и Future, и записывает
их в  эту библиотеку.  
     
     CREATELIB  "ordprocs"
     
     PROC  DelLast(tblname)    ; заголовок процедуры
       EDIT tblname            ; вход в режим редактирования
       END                     ; переход к последней записи
       DEL                     ; удаление ее
       DO_IT!                  ; завершение редактирования
       RETURN [#]              ; возврат числа оставшихся записей
     ENDPROC                   ; конец процедуры
     
     
     PROC Future(d,w)       ; возвращаемая дата на w недель позже
                            ; чем d
         w = w * 7          ; перевод w в дни
         RETURN (d+w)        
     ENDPROC

     WRITELIB  "ordprocs" DelLast,  Future
     
     
             Рис.6-5. Создание библиотеки процедур.
     
     
     
                 Внесение процедуры в библиотеку
-----------------------------------------------------------------
     
     Если вы создали библиотеку с помощью команды  CREATELIB,  то
для   внесения   процедур   в  нее  можно  пользоваться  командой
WRITELIB. В  одной  библиотеке  можно  хранить  до  трехсот  про-
цедур.  Аргументами  команды  WRITELIB  являются имя библиотеки и
список процедур, вносимых в нее. Процедуры, вносимые в  библиоте-
ку,  должны  содержаться  в оперативной памяти, т.е. быть опреде-
лены.
     Команду  WRITELIB  можно  использовать  несколько  раз   для
внесения  в библиотеку дополнительных процедур. Запись новой про-
цедуры, имя которой совпадает с именем  процедуры,  уже  имеющей-
ся в библиотеке, вызывает потерю внесенной ранее процедуры.
     
     
               Использование библиотечных процедур
-----------------------------------------------------------------
     
     Процедуры,  записанные  в  библиотеку,  могут быть использо-
ваны в скрипте. При этом их можно загружать  явно  или  автомати-
чески  с  помощью  PAL. Загрузка процедуры из библиотеки приводит
к результатам,  аналогичным  определению  ее  с  помощью  команды
PROC,  но  выполняется гораздо  быстрее. 
     
     
                Автоматическая загрузка процедур
                --------------------------------
     
     Средства  автоматической загрузки процедур PAL можно исполь-
зовать для  автоматического  считывания  процедур  в  оперативную
память. При обращении к процедуре, которая не была определена
явно,  PAL  обращается  к  библиотеке  с именем PARADOX в текущем
каталоге. Если эта библиотека существует, PAL  ищет  в  ней  тре-
буемую  процедуру,  и  ,  если  нашел,  то считывает ее в память.
Если библиотеки нет или процедура в ней не  найдена,  то  появля-
ется   сообщение  об  ошибке  скрипта,  указывающее  на  то,  что
процедура  не была  определена.  
     Вы можете  определить  в  качестве  библиотеки  автозагрузки
любую  другую  библиотеку,  присвоив  ее  имя системной перемен-
ной autolib. Например,
     
     autolib  =  "sam"
     
сообщает PAL, что  надо  искать  SAM.LIB  вместо PARADOX.LIB.
     В набор бибилиотек автозапуска можно  включить  любое  коли-
чество библиотек. Например,  команда:
     
     autoload  "sam,joe,mylib"
     
сообщает  системе  Paradox,  что  процедуры следует искать в трех
библиотеках: SAM.LIB, JOE.LIB и MYLIB.LIB.  Таким  образом,  мож-
но  установить  неограниченное  количество  библиотек. Порядок, в
котором  библиотеки  упоминаются  в  команде  autoload,  является
порядком предпочтения  при поиске процедуры.  
     Так  как  PAL  обладает возможностью автоматической загрузки
процедур из библиотек и автоматического обмена их  в  случае  не-
достатка  памяти,  вам нет необходимости заботиться о распределе-
нии ресурсов. С помощью команды SETSWAP, описанной  в  главах  15
и  20,  можно  установить  минимальный  объем  свободной  памяти,
который необходимо поддерживать. Если объем свободной оперативной
памяти  будет  меньше  этого минимума, то PAL начнет обмен проце-
дур.
     
     
                     Явная загрузка процедур
                     -----------------------
     
     Команда READLIB используется  для  явной  загрузки  процедур
из  библиотеки  в оперативную память. READLIB указывает библиоте-
ку процедур, из которой осуществляется  чтение  и  список  загру-
жаемых  процедур.  С  помощью  команды  READLIB  можно  загрузить
любое  требуемое  количество  процедур.  Скрипт,  приведенный  на
рис.6-6,  загружает  процедуру  DelLast  из  библиотеки ordprocs,
а  затем  обращается  к ней.  
     
     READLIB  "ordprocs" DelLast
     MESSAGE "There  are", DelLast("orders"),
               "records left in  ORDERS"
     
    Рис.6-6. Чтение  и использование  библиотечных процедур.
     
     
     
                 Просмотр содержания библиотеки
-----------------------------------------------------------------
     
     С помощью команды INFOLIB можно создать временную таблицу
list, содержащую имена процедур, записанных  в  библиотеку.  Таб-
лица  содержит приблизительный объем оперативной памяти, занимае-
мый  каждой процедурой.  Например,  
     
     INFOLIB "ordprocs"
     
высвечивает таблицу  содержащую  оглавление  процедур  библиотеки
"ordprocs".
     
     
                    Дополнительная информация
-----------------------------------------------------------------
     
     Использование библиотек процедур имеет несколько тонких осо-
бенностей, о  которых  не  говорилось  в  нашем  описании.  Глава
15 содержит  дополнительную информацию о:
     
     автозагрузке  процедур  и обмене  их;
     
  -  использовании расширеной памяти процедурами;
     
  -  отладки библиотечных процедур;
     
  -  управлении   использованием  оперативной  памяти  с  помощью
     процедур;
     
  -  различии  между процедурами разных версий системы Paradox.
   
     
     
                       СКРЫТЫЕ  ПРОЦЕДУРЫ
-----------------------------------------------------------------
     
     Скрытыми  процедурами  называется  специальный тип процедур, 
позволяющий создавать модули прикладных систем, являющиеся  почти 
полностью  автономными.  С  помощью них облегчается использование 
средств автоматического распределения памяти  PAL  и  уменьшается 
потребность  в  явном  распределении  памяти для ваших прикладных 
систем. Эти две особенности делают их весьма полезными при разра- 
ботке  больших  прикладных  систем.  Для таких систем очень важно 
разграничить модули верхнего и нижнего уровня. Подробности смотри 
в главе 15. 
     Основное различие между скрытыми процедурами  и  процедурами 
других типов заключается в том, что скрытые процедуры представля- 
ют собой автономные модули. При  использовании  скрытых  процедур 
следует иметь в виду: 
     
  -  Скрытую  процедуру   можно  вызывать  только  из библиотеки.
     Предпочтительнее  вызывать скрытые  процедуры  из  библиоте-
     ки  автовызова, а  не  использовать  команду  READLIB.
     
  -  При входе в скрытую  процедуру все предыдущие активные пере-
     менные  и  процедуры считаются утерянными.
     
  -  Все процедуры, вызываемые  скрытой процедурой, должны содер-
     жаться  и вызываться из библиотеки процедур (допускается оп-
     ределение других процедур  в  теле   скрытой  процедуры,  но
     это  не  желательно).  Вызываемая  процедура  должна  содер-
     жаться в библиотеке  автовызова  или  может  быть  загружена
     с помощью  команды  READLIB.  
     
  -  Скрытая    процедура  не  имеет  доступа  к  глобальным пере-
     менным, определенным вне ее,  кроме  тех,  что  переданы  ей
     с помощью  команды  USEVARS.
     
  -  Все  правила,  касающиеся  областей  определения  переменных
     PAL, работают внутри каждой   скрытой процедуры.
     
  -  При завершении  скрытой процедуры все  ресурсы  памяти,  ис-
     пользуемые  ею,  освобождаются.  Таким  образом, вся память,
     используемая для определения переменных, массивов  и  других
     процедур  в  теле   скрытой  процедуры, возвращается в цент-
     ральный пул памяти.  Следовательно,  нет  необходимости  ис-
     пользовать команды  RELEASE  PROCS  и RELEASE VARS.
     
  -  После  завершения   скрытой  процедуры  состояние, в котором
     находились переменные и процедуры вашей системы перед  нача-
     лом  работы   скрытой процедуры, восстанавливается. Если ве-
     личины глобальных переменных, переданных   скрытой  процеду-
     ре  с  помощью  команды USEVARS, были изменены внутри закры-
     той процедуры, то новые их  величины  сохраняются  после  ее
     завершения.
     
  -  Допускается шесть уровней вложения   скрытых процедур.  
                 
     Для определения скрытой процедуры следует добавить в заголо- 
вок процедуры ключевое слово CLOSED. Например, 
     
     PROC  CLOSED  Foo()
         USEVARS x,y,z          ; глобальные  переменные x,y и z
                                ; передаются процедуре
         Myvar = ( x +  y)/ z   ; вводится  новая переменная  ог-
                                ; раниченная внутри процедуры,
                                ; после  завершения процедуры 
                                ; будет  утеряна
         IF  Myvar  > 100
             THEN  RETURN True
             ELSE  RETURN False
         ENDIF
     ENDPROC

     Скрытые  процедуры  впервые  введены  в системе Paradox вер-
сии 3.0.  Прикладные  системы,  использующие  скрытые  процедуры,
не  будут  работать  под  управлением  предыдущих  версий системы
Paradox.
     Дополнительная информация об использовании скрытых процедур
для построения больших и  эффективных  прикладных  систем  содер-
жится в  главе 15.
