
       Дополнительные средства для ввода данных.

      Построение  программ для входного контроля данных явля-
 ется сложной задачей. Т.к. ввод данных часто  встречается  в
 приложениях, был разработан набор процедур, который ускоряет
 и  упрощает  этот  процесс. Этот набор называется Data Entry
 Toolkit.
 Сюда входят (в главу):
      1.Введение и демонстрация использования.
      2.Описание запуска.
      3.Пошаговое описание использования в построении прило-
 жений.
      4.Список  процедур,  которые можно использовать в этом
 пакете.

      Примечание. Информация, присутствующая в  этом  разделе
 большей  частью является технической и обзорной. Поэтому пе-
 ред тем как использовать Data Entry Toolkit Вы должны  полу-
 чить представление об:
      -использовании процедур;
      -использовании необходимых переменных;
      -пересылке и редактировании внутри и между таблицами;
      -использовании окон PAL`а внутри рабочего пространства
 ПАРАДОКСа;
      -использовании команды Wait для ввода данных.
      Если Вы попытаетесь использовать  Data  Entry  Toolkit
 без этих знаний основных понятий, Вы потерпите неудачу. Эта
 часть является заключительной в руководстве пользователя по
 следующей   причине: Вам  необходимо  изучить  вышеописанную
 часть руководства для эффективного использования Data Entry
 Toolkit.


      Что такое Toolkit?

      До сих пор основной возможностью, предоставляемой поль-
 зователю для  редактирования таблиц, являлась команда Wait.
 Эта команда предоставляет 4 возможности для управления  вво-
 дом:
      -ограничение того, ч т о  пользователь может редактиро-
 вать (поле, запись, вся таблица);
      -воспринимать  одно  или  несколько нажатий на клавиши,
 которые завершают взаимодействие;
      -выдавать сообщение из двух строк;
      -выдавать начальные сообщения пользователю.

      Как только скрипт запустит процедуру Wait, Вы потеряете
 управление  над  рабочим  полем  до тех пор, пока не нажмете
 определенной клавиши. Даже потом потеряется управление  тем,
 что  пользователь  может делать в рабочем поле. Например, Вы
 не можете потребовать, чтобы одно поле было  введено  раньше
 другого,  и  в  зависимости  от  содержания первого. Команда
 PAL'а Wait не позволяет Вам осуществлять такой вид  управле-
 ния процедурой ввода данных пользователя.
      Data Entry Toolkit является набором PAL-процедур, кото-
 рые будучи добавленными к Вашим скриптам  позволят  наиболее
 полно  осуществлять управление процессами ввода и редактиро-
 вания данных в таблицах. Единственной процедурой, используе-
 мой в Data Entry Toolkit является DoWait. Она является более
 общей, чем Wait и позволяет управлять событиями системы  при
 вводе данных.
      С помощью DoWait Вы можете определить действия, которые
 будут  выполнены при входе в поле, выходе из поля и во время
 нахождения внутри поля (когда нажата соответствующая  клави-
 ша).  Кроме того, независимо от того, в каком поле находится
 пользователь специальная клавиша вызывает  процедуры,  пред-
 назначенные  для  того, чтобы выполняться в любой момент при
 желании  пользователя.  Несколько  дополнительных  процедур,
 включенных в Toolkit поддерживают процедуру DoWait или обес-
 печивают дополнительные функции, которые удобны в приложени-
 ях, требующих большого объема вводимых данных.
     - ArriveField - сообщает DoWait, что курсор вышел в но-
 вое  поле, и что должна быть вызвана соответствующая проце-
 дура.
      - EditMenu - выводит на дисплей простое меню редактиро-
 вания, содержащее услуги: Undo, Do-It!, Help, Cancel,  кото-
 рые  могут быть использованы во время ввода данных с исполь-
 зованием DoWait. Это является примером  типа  действия,  что
 может быть выполнено во время специальной процедуры.
      - GetFaile - выводит на экран меню из файлов. Для  оп-
 ределения файлов, которые должны быть высвечены в меню, ис-
 пользуются маски.
      - GetPassword - вводит строку от пользователя, но  не
 отображает символы на экране дисплея.
      -  InitWait - устанавливает исходные значения проце-
 дур, переменных, массивов необходимых для процедуры DoWait.
      - LookupSelect - показывает таблицу  помощи  Lookup  и
 позволяет пользователю сделать выбор из нее.
      - NewField - сообщает DoWait, что курсор попал в новое
 поле (но необязательно помещает его туда,таким образом, что
 процедура доставки в это поле не вызывается).
      -  Popup - выводит на дисплей вертикальное меню произ-
 вольной длины, из которого пользователь может  сделать  вы-
 бор.  Пользователь  просто  перемещается по вертикали и для
 выбора значения нажимает [Enter].
      -  RecurseWait - специальная версия DoWait, используе-
 мая для организации вложенности.  Эта  процедура  допускает
 многочисленные уровни рекурсии и предоставляет пользователю
 возможность  переходить  от  ввода  данных в одну таблицу к
 вводу даннных в другую.
      - SetKeycodes - определяет специальные переменные, ко-
 торые могут быть использованы в  приложениях,  использующих
 DoWait.
      - SetPopup - определяет меню для команды Popup.

      GetFile, GetPassword, LookupSelect, Popup и SetPopup не
 обязательно могут использоваться процедурой DoWait. Они  вы-
 зываются по желанию пользователя.
      Дополнительно,  некоторые  утилиты Toolkit'а, или под-
 системы, предоставлены чтобы помочь Вам построить Вашу сис-
 тему ввода данных и формы. Вы не видите процедур,  содержа-
 щих этих утилит, т.к. они доступны через специальный скрипт
 носящий имя toolkit.
      Когда Вы запустите toolkit Вы увидите меню со следующи-
 ми услугами :

 *Demonstration* FildDefine KeyDefine HelpForm PrepareFinal
 Quit
 Demonstration of the capabilities of the toolkit.
 (демонстрация возможностей toolkit'а)

      - Demonstration - запускает пример приложения, которое
 использует Toolkit для демонстрации его возможностей.
      - FildDefine - обеспечивает поддержку оператора DoWait.
 Он определяет имена процедур и действия, используемые  про-
 цедурой DoWait.
      -  HelpForm  - поддерживает создание форм. Он позволит
 Вам интерактивно рисовать линии в формах,  используя  алго-
 ритм, позволяющий пересекать и соединять границы. Такой ас-
 пект создания форм невозможен в режиме нормальной разработ-
 ки форм в ПАРАДОКСе.
      -  KeyDefine - поддерживает оператор DoWait. Он позво-
 ляет Вам переопределить значения всех клавиш, пока работает
 процедура DoWait.
      - PrepareFinal -удаляет процедуры  TKDebug  из  вашего
 приложения  и подставляет значения вместо имен переменных с
 целью сократить требования памяти.
      Позднее в этом разделе мы рассмотрим  каждую  из  этих
 процедур и подсистем более детально. Сначала, Вам необходи-
 мо изучить, что представляет из себя Toolkit и как Вы може-
 те его использовать.
      Применение  Toolkit проиллюстрировано при помощи прог-
 рамм, написанных на языке PAL, которые входят в  подсистему
 Demonstration  (полный  текст  этой  программы находится на
 диске Simple Application/ Data Entry Toolkit  в  скрипте  с
 именем makedemo.


      Преимущества DoWait.

      DoWAit  предоставляет  два  основных  преимущества  для
 пользователей програмирующих на PAL'е. Первое, и
 наиболее очевидное - то, что процедура DoWait  предоставляет
 новые возможности внутри ПАРАДОКСа. Вы получаете возможность
 всестороннего управления вводом данных. Не так очевидно дру-
 гое  преимущество  DoWait, когда форма ввода данных, которую
 Вы создаете интерактивно в ПАРАДОКСе управляет  вводом  дан-
 ных.  DoWAit представляет собой программу, чьи функции "над
 формой". Перемещение от поля к полю управляется (контролиру-
 ется) скорее посредством формы, чем программированием.Приба-
 вим то, что проверки правильности данных, табличные преобра-
 зования, вычисление поля, просмотр поля, Help и все  обычные
 функции автоматически поддерживаются посредством формы. Про-
 верка правильности данных, для примера, производится всегда,
 не считаясь с тем, выполняется ли одна или не одна ваша про-
 цедура ввода данных.
      Явной выгодой от использования формы управления вводом
 является то, что Вы можете программировать на очень высоком
 уровне;  дополнительные  процедуры, в которых Вы нуждаетесь
 малы, просты и ориентированы на обработку  только  исключе-
 ний. Это уменьшает время и размер необходимых программ и по-
 могает преодолеть сложности при вводе данных.

      Концептуальная разница между Wait и DoWait.

      DoWait  представляет собой тщательно сделанное расши-
 рение команды Wait, но это не определяет основные концепту-
 альные различия между ними. Одно из различий состоит в том,
 как используется DoWait.  Для  примера,  при  использовании
 DoWait  полный  цикл ввода данных завершается нормально при
 единственном вызове процедуры. В  противоположность  этому,
 ввод данных, использующий Wait, часто требует неоднократного
 выполнения  команды  Wait.  Например, если Вы хотите "разре-
 шить" исползование специальных клавиш  (Menu  key)  в  вашем
 приложении, используя Wait, это может выглядеть так:

              retwal = "F10"
              WHILE retwal = "F10"
                  WAIT TABLE UNTIL "F2","F10","Esc"
                  IF retwal = "F10"
                      THEN Play "Menu"
                  ENDWHILE

      В приведенном фрагменте, всякий раз нажатие объявленной
 клавиши (Меню), завершается выполнением команды Wait и обра-
 батывается меню, а затем опять выполняется команда Wait. При
 использовании  DoWait  необходимость в таком цикле отпадает.
 Если "F10" определена как "special" (при помощи упоминавшей-
 ся выше подсистемы KeyDefine в toolkit'е), всякий раз, когда
 пользователь нажимает "F10", DoWait  автоматически  вызывает
 специальную управляющую процедуру, указанную Вами. Если "F2"
 и  "Esc"  определены,  как  "Exit" клавиши (опять при помощи
 KeyDefine), цикл ввода данных завершается, когда бы  пользо-
 ватель не нажал ту или иную клавишу. Основное различие между
 Wait  и  DoWait состоит в том, что вся специальная обработка
 совершается автоматически внутри DoWait.  Нет  необходимости
 покидать  DoWait, как это было бы необходимо при специальной
 обработке, используя Wait. Обычно, DoWait вызывается  только
 один раз в цикле ввода данных, в то время как Wait часто ис-
 пользуется повторно в цикле в течении ввода данных.
      Если Вы хотите прекратить ввод данных в одну таблицу и
 начать ввод в другую, Вы должны выполнить второй DoWait для
 новой таблицы.
      Toolkit содержит специальную версию DoWait, называемую
 RecurseWait, для  использования  в  подобных  случаях  (см.
 "Procedure Reference"). RecurseWait спасает переменные, ис-
 пользуемые текущим DoWait и хранит их отдельно от  подобных,
 используемых  для нового цикла ввода данных, контролируемого
 RecurseWait. Использование DoWait и  RecurseWait  при  вводе
 данных  в семейство таблиц,в действительности гораздо проще,
 чем  использование  Wait.  RecurseWait   вызываемый   внутри
 DoWait,  управляет вводом даннных для второй таблицы; DoWait
 управляет вводом данных для первой таблицы. Каждый может ис-
 пользовать различный набор специальных клавиш и процедур.  В
 случае команды Wait, Вы, возможно, имели бы такую структуру:
 SWITCH  внутри  WHILE, который внутри SWITCH, который внутри
 WHILE, и при этом Вы не смогли бы явно управлять специальны-
 ми клавишами вне Wait.


      Инстолирование (установка) Toolkit.

      Data Entry Toolkit может быть запущена либо с жесткого
 диска на автономном компьютере либо  с  сетевого  файлового
 процессора (сервера).
      Установка  Toolkit в сети - есть часть стандартной се-
 тевой процедуры установки  ПАРАДОКСа.  Завершающие  команды
 для  установки ПАРАДОКСа в сети содержатся в книге "Network
 Administrator's Guide". При сетевой установке, дол-
 жна  существовать   поддиректория   \paradox2\detool,
 содержащая  файлы  Toolkit.  Обратитесь  к  книге  "Network
 Administrator's Guide" в том случае, если Вы не  уверены  в
 том, как разместить эту поддиректорию.


      Установка Toolkit на автономной системе с жестким дис-
 ком.

      1.  Войдите в директорию содержащую файлы ПАРАДОКСа. На
 Винчестере   это    обычно:    C:\paradox2.    Наберите:
 C>cd\paradox2.
      2.  Запустите  командный файл dinstall, для того, чтобы
 создать новую поддиректорию для Toolkit.

      После   того,   как   Вы    вставили    диск:    Sumple
 Application/Data  Командный файл создаст новую поддиректорию
 \paradox2\detool и скопирует в нее все файлы Toolkit.


      Использование Toolkit.

      Toolkit содержит два первичных основных компонента:
      -  Скрипт toolkit с пятью подсистемами, выбираемыми из
 его основного меню.
      - Библиотека процедур Toolkit,  содержащая  процедуры,
 управляющие  вводом  данных,  когда  Вы пользуетесь Toolkit
 (см."Toolkit Reference" в конце параграфа).


      Запуск Toolkit Skript.

      1. Запустите ПАРАДОКС.
      2. Выберите    из    основного  Меню  ПАРАДОКСа  услугу
 Tools/Move/Directory и наберите: C:\paradox2\detool.
      3.  Выберите  из  Основного   Меню   ПАРАДОКСа   услугу
 Scripts/Play и наберите Toolkit.
      Когда  Вы запустите скрипт Toolkit, создадутся две биб-
 лиотеки процедур:
      - DemoApp  -  Библиотека,  содержащая  демонстрационные
 процедуры.
      - Toolkit - основная библиотека процедур.

      После компиляции библиотек, Вы увидите на экране Основ-
 ное Меню Toolkitа:

 *Demonstration* FildDefine KeyDefine HelpForm PrepareFinal
 Quit
 Demonstration of the capabilities of the toolkit.
 (демонстрация возможностей toolkit'а)


      Приложение ввода данных.

      Первая подсистема Toolkit это демонстрация его исполь-
 зования.  Демонстрация содержит фрагмент ввода данных боль-
 шого приложения.  Этот  фрагмент  иллюстрирует  достоинства
 системы Toolkit.


      Запуск демонстрации Toolkit.

      1.Сначала  выберите услугу Tools/More/Directory и вве-
 дите C:\paradox2\detool. Это поместит Вас в директорию, ко-
 торая содержит файлы Toolkit'а, которые Вы будете использо-
 вать.
      2.Теперь выберите услугу  Scripts/Play  и  напечатайте
 toolkit. После идентификации, скрипт изобразит основное ме-
 ню Toolkit.
      3.Выберите  услугу  Demonstration.  В ответ, компьютер
 загрузит и запустит процедуры из библиотеки  demoapp  (лис-
 тинг есть в скрипте makdemo.sc).
      Эти процедуры заключают в себе код, управляющий демон-
 страцией простого ввода данных.
      4.После нескольких заставок, экран очистится и Вы уви-
 дите демонстрацию формы ввода данных. Это типичное приложе-
 ние,  для  которого  Data Entry Toolkit наилучшая оболочка.
 Сама форма нарисована с использованием Help  Form,  которая
 будет описана ниже.
      5.Введите  какие-либо  данные. Курсор находится в поле
 Invoice#. Напечатайте 122.
      6.Курсор переместится на поле ShipVia. Желаете ли  Вы
 знать какой выбор загрузки возможен? Нажмите клавишу помощи
 "F1".  Ваш экран сейчас отображает меню, показывающее выбор
 загрузки. заметим, что курсор в поле ShipVia стал  малень-
 кого    размера   на   время   просмотра   меню.   [Стрелка
 вверх],[стрелка вниз],[PgUp],[PgDn],[Home] и [End]  переме-
 щают рамку повышенной яркости по услугам меню.
      7.Переместите  рамку повышенной яркости на ParcelPost
 и нажмите [Enter]. Меню исчезнет и ParcelPost  появится  в
 поле ShipVia.
      Этот  пример показывает, что DoWait может делать в те-
 чении Wait. Процедура KeyDefine на данном этапе  переопре-
 деляет  что  делает  клавиша  [F1] (Help). Затем, процедуры
 Setpopup и Popup определят и выполнят  меню  ShipVia.  Вы
 изучите   как   работают  эти  функции  несколько  позднее.
 Сейчас  же, только заметим, что они очень эффективны и пре-
 доставляют пользователю большие возможности для входа в по-
 ле.
 Кстати, если Вы попытаетесь ввести неверную запись  в  поле
 ShipVia, Вы получите сообщение.
      8.После того, как Вы выберите курьера для доставки за-
 каза Вы обнаружите кое что интересное. Когда курсор  выйдет
 из  поля ShipVia, он переместится в поле Date, которое ав-
 томатически заполнится. Потом курсор переместится в  следу-
 ющёё поле.
      Программисты,  достигшие  совершенства  на  языке PAL,
 сразу отметят простоту и мощность этого действия. Если бы Вы
 использовали  Wait, то этого просто невозможно было бы восп-
 роизвести. В данном же случае, DoWait  был  использован  для
 автоматического вызова процедуры перед входом в поле. DoWait
 рассказал, как реагировать на ввод незаполненного поля Date:
 Взять дату сегодняшнего дня, заполнить ее и перейти к следу-
 ющему поолю.
      9.Для того, чтобы  узнать  больше  о  том,  что  может
 Toolkit, вводите идентификатор заказчика: ID 1386.
      После   короткой  паузы  заполняется  поле  "Имя","Ад-
 рес","Город","Штат","Индекс","Телефон" и "Скидка", и курсор
 переместится в поле Quantaty ("Количество").
      10.Если Вы введете номер заказчика (ID), которого  нет
 в  главном  файле, Вы получите задание либо повторить ввод,
 добавляя новую информацию о заказчике в основной файл, либо
 обратиться за помощью.
      11.Услуга Help (Помощь). Программа позволит Вам  прос-
 мотреть таблицу Customer для того, чтобы найти интересующий
 (правильный) номер заказчика ID.
      Это  иллюстрации DoWait, GoodDepart и BadDepart про-
 цедур. В этом случае, т.к. номера заказчика введенного Вами
 не было в таблице,  DoWait  вызвал  процедуру  BadDepart.
 Обычно  пользователь не может выйти из поля, пока не произ-
 ведет корректный ввод (исходная процедура может  не  прини-
 мать  во  внимание эти требования, позволяющие пользователю
 отказаться даже если введенные данные не действительны).
      12.Если вы введете допустимый номер заказчика  (ID)  и
 потом  переведете  курсор  обратно к полю Cust ID и нажмете
 клавишу [Enter] без изменения содержимого поля  ID,  курсор
 переместится  на поле Discount ("Скидка"), предоставляя Вам
 возможность ввести специальную скидку. Т.к. данные о заказ-
 чике не изменились, нет необходимости в перекодировании.
      13.Перейдем  к  полю  Quantaty  (количество).  Нажмите
 [F10]. Появится меню редактирования.
      14.Перейдите  к  полю  Part. Нажмите Help [F1]. Курсор
 будет переведен к таблице Stock, к полю Part, где Вы мо-
 жете выбрать подходящий номер части (Part) и, затем, нажми-
 те Do-It [F2] для того, чтобы ввести информацию в форму.
      Поля Subtotal, Discount,Tax и Total изменяться автома-
 тически при вводе вашего заказа. Все это  опять  происходит
 за  счет  возможностей DoWait выполнять процедуру, пока су-
 ществует поле ( в этом случае поля Quantaty,  Discount  или
 Part,  каждое из которых может влиять на другие). Использо-
 вание просмотра таблиц не имеют никакого  действия  в  этом
 примере, пока номер части влияет на общую стоимость заказа.
      Используя  Toolkit,  чтобы создать процедуру возврата,
 Вы управляете просмотром, заполнением и вычислениями  всего
 лишь  единственным  вызовом  процедуры.  Поскольку все поля
 Quantaty, Discount и Part влияют на конечный  общий  заказ,
 Вы можете записать один раз процедуру вычисления и вызывать
 ее  из внутренних процедур возврата, используемых для этого
 поля.
      Вы также можете использовать  переменную  Toolkit'а  с
 именем TKChanged в этой процедуре для того, чтобы видеть -
 есть   ли   необходимость   производить   вычисления  (если
 TKChanged = True, то Вам необходимы вычисления,  если  нет,
 то Вы можете двигаться дальше).
      15.Наберите  1 в поле Quantaty и нажмите [Enter]. Кур-
 сор переместится к полю Part#.
      16.Для того, чтобы выбирать номер  части  из  таблицы,
 нажмите Help [F1]. Переместите курсор к самой правой записи
 и нажмите Do-It![F2]. ([Esc] прекратит просмотр).
      17.Выберите  (или  введите) 76848, Compag Portable 286
 компьютер. Помимо заполнения  в  Part  (часть)  информации,
 процедура  возврата  вычисляет  следующие  поля:  Subtotal,
 Discount, Tax и Total.
      18.Для того , чтобы покинуть демонстрацию  ввода  дан-
 ных,  нажмите  Do-It! [F2], точно так, как будто Вы находи-
 тесь в регулярных приложениях ввода данных.
      Из Demo программа приводит Вас в Toolkit Меню,  вместо
 того,  чтобы сохранять информацию в таблицах. Поскольку эта
 демонстрация не является завершенным приложением,  введение
 Ваших  данных  не  записывается в базовые таблицы. Скрипт с
 именем Post на диске содержит пример того,  как  информация
 может быть сохранена.
      Демонстрация  использует несколько особенностей форма-
 тирования ПАРАДОКСа, для того, чтобы управлять вводом  дан-
 ных  в форму. Эти особенности не являются частью Date Entry
 Toolkit, а стандартным контролем правильности, применимым к
 любым приложениям ПАРАДОКСа. Например, если Вы вводите  но-
 вую информацию о заказчике, Вы обнаружите, что в поле "Имя"
 и в поле "Адрес" первые символы становятся заглавными авто-
 матически,  посредством использования маски Valcheck (огра-
 ничение целостности)

      * {  ,.}!* {{  ,.} * {  ,.}!,@}

      Поле "Телефон#" также использует контроль  правильнос-
 ти, усовершенствованный процедурами FillPhone и NormalPhone
 в MakeDemo, для того, чтобы иметь возможность вводить номер
 телефона в любом из трех имеющихся форматов.

    Маска вида ###-#### не позволит Вам покинуть поле
 автоматически  ,  пока  не будет введено поле кода и первые
 четыре цифры, как в ###-###-#.

    Введение ###-###-#### или (###)###-#### приведет к авто-
 матическому выводу из поля.

      Проверте код PAL в скрите makedemo и, также, разработ-
 ку и структуру формы Tkentry, если Вы захотите  посмотреть,
 как  дополнительные  особенности Toolkit'а были соединены в
 единое целое с базовыми возможностями ПАРАДОКСа.
      Сейчас, когда у Вас появился "вкус" к тому,  как  Data
 Entry  Toolkit  может помочь Вам, давайте покопаем во внут-
 ренностях частей его компонентов и посмотрим,  как  Вы  ис-
 пользуете их для построения приложений с особенностями, ко-
 торые Вы узрели во время нашей демонстрации.


      Создание демонстрационного скрипта.

      Процедуры Date Entry Toolkit, пригодные для Вашего ис-
 пользования,  хранятся в библиотеке с именем toolkit. Неко-
 торые дополнительные процедуры (не для прямого  использова-
 ния  в  Ваших  приложениях)  хранятся в библиотеке с именем
 toolkit2. Для того, чтобы использовать любую из этих проце-
 дур в скрипте, вы должны пройти через бит готовности. Здесь
 перечислены шаги, необходимые для создания демонстрационно-
 го скрипта:

      - создать таблицы;
      - создать процедуры для выполнения в рамках DoWait;
      - определить процедуры, используя FieldDefine;
      - присвоить значенния клавишам, используя KeyDefine;
      - собрать элементы в скрипт.


      Создание таблиц.

      Первым шагом было создание таблиц, используемых в при-
 ложении. Это были таблицы Cust, Orders  и  Stock,  а  также
 таблицу  -  источник для мультиввода Tkentry. Наименее ясна
 необходимость создания некоторых специальных таблиц. Напри-
 мер, мы создали таблицу  с  именем  Carriers  (используемую
 подсистемой  "вертикального"  меню), где SetPopup запоминает
 имена "shippers" для поля Ship Via. Как часть  этого  шага,
 мы также создали форму ввода данных, которую хотели исполь-
 зовать.


      Создание процедур.

      Процедуры  были  потом созданы для каждой из фкнкций,
 которые мы хотели использовать в рамках процедуры DoWait.
 Например,  когда  пользователь   пытается   покинуть   поле
 Invoice#,  мы  проверяем, ввел ли он номер invoice (наклад-
 ной). Осуществляет такой контроль процедура Reqd:

 PROC Reqd()
     IF ISBLANK([]) AND TKChar<>TKUndo
             AND TKChar<>TKUndo
             AND TKChar<>TKCancel
         THEN TKAccept = False
          ; ignore movement key that was pressed (stay here)
          TKMessage="An invoice number must be provided."
     ENDIF
 ENDPROG

      Для каждой задачи, выполняемой  DoWait,  мы  создавали
 процедуру (см. скрипт makedemo на диске Toolkit).


      Назначение (присваивание) процедур.

      Затем  мы  "проиграли"  скрипт  toolkit и выбрали Fild
 Define. FildDefine используется для того,  чтобы  "расска-
 зать"  DoWait о процедурах, определенных выше: какие проце-
 дуры работают для какого поля и когда необходимо их  выпол-
 нить  (перед  входом в поле, перед попыткой покинуть поле и
 т.д.). Четыре типа процедур могут быть назначены для каждо-
 го поля:

      - Arrive (прибытие): Выполняется в тот  момент,  когда
 курсор подводится к полю.
      -  GoodDepart (нормальный выход): Выполняется, когда
 пользователь пытается покинуть поле и данные  удовлетворяют
 всем условиям проверки правильности.
      -  BadDepart (плохое завершение): Выполняется, когда
 пользователь пытается выйти из поля и  данные,  которые  он
 ввел, не корректны.
      -  Keystroke (нажатие клавиши): Выполняется после каж-
 дого нажатия клавиши (нажатия клавиш подразделяются на  ка-
 тегории, используемые процедурой KeyDefine).

      В  приведенном ниже приложении мы определили процедуру
 с именем FillDate (заполнение  даты),  которая  выполняется
 при попадании курсора в поле Date (дата):

 PROC FillDate()
   IF ISBLANK([])
     THEN
      IF (TLChar=TKReverseTab) OR (TKChar=TKLeft)
                     ; Did we arrive from next field?
       THEN LEFT     ; Yes, so continue along backwards
                                      through field?
       ELSE RIGHT    ; No, so move to next field
      ENDIF          ; Date filled in by ValCheck
      ArriveField()  ; Tell DoWait we've left the field
                                it thinks we're in
   ENDIF
 ENDPROC

      Эта  процедура  заполняет дату (используя по умолчанию
 дату сегодняшнего дня) и покидает поле.  Если  пользователь
 позднее возвратится в это поле, то процедура не окажет
 никакого эффекта, поскольку  в  поле  находится  информация
 (поле не пусто). Мы также проверяем, вводит ли пользователь
 [ReverseTab] или [Left] для того, чтобы попасть в это поле.


      Присваивание клавишам определенных действий.

      Следующей выполняемой подсистемой  Toolkit'а  является
 KeyDefine.  KeyDefine  используется для того, чтобы опреде-
 лить принадлежность клавиши к одному из  четырех  возможных
 типов.

      -  Regular: Клавиши воспринимаются в соответствии с их
 регулярным значением (обычно А-z, О-9, клавиши  перемещения
 курсора и тому подобные).
      -  Illegal  (неразрешенный): Указывает, что клавиша не
 может  быть принята и при этом подается звуковой сигнал. Вы,
 например, можете сделать клавишу [F9] запрещенной и  она  не
 будет выполнять свои функции (редактирование).
      -  Exit (выход): Клавиша, которая выводит из процедуры
 DoWait (аналогично нажатию клавиши [UNTIL] в команде Wait).
      -  Special:  Эта клавиша вызывает назначенные процедуры
 всякий раз, когда ее нажимают.

      В нашем примере клавиша Меню  [F10]  определяется  как
 специальная, которая вызывает меню редактирования вне зави-
 симости от поля, в котором находится курсор:

      PROC SpecialKey()
        SWITCH
          CASE TKChar=TKHelp:  ; пользователь нажал [F1]

          CASE TKChar=TKMenu:  ; пользователь нажал [F10]
            EditMenu()         ; показ меню Toolkit's Edit
        ENDSWITH
      ENDPROC


     Запуск скрипта.

      Окончательно, мы берем процедуры, определенные ранее и
 строим из них конечный продукт (скрипт). Первая процедура в
 нашем приложении (поскольку скрипт toolkit управляет иници-
 ализацией) состоит из следующих операторов:

 READLIB "toolkit" InitWait, SetKeykodes,SetPopup ; загрузка
    процедуры инициализации в память
 InitWait("FldSpec","KeySpec) ; сообщение DoWait'у, где  ис-
    кать определение ключа и поля
 SetKeycodes()              ; установка кодов клавиш
 SetPopup("Carriers")       ; привести/ в готовность ShipVia
 RELEASE  PROCS InitWait, SetKeycodes, SetPopup ; больше нет
    необходимости в процедуре инициализации
 AreaCode="(415)"
 TaxRate=.0725

 Замечание.  Предложенный  фрагмент  не  является  закончен-
 ным приложением, а только лишь демонстрацией. Эти программы
 начальной установки должны быть выполнены в начале приложе-
 ния, а не в начале блока ввода данных Вашего приложения.
      Следующей инициализацией мы начинаем устанавливать не-
 обходимые нам таблицы в рабочее пространство:

    PROC DataEntry()
      SETSWAP 12000
      READLIB "DemoApp" Reqd,FillDate,DateLeave,CustLeave,
 ResetSpecs,ChangeDisk,SpecialKey,FindPart,ChangeQuan,DoTotal,
 FillSubtotal,BadID,BadCarrier,GetCust,NoUp,NoUpLeft,
 NoDownRight,NormalPhone,FillPhone,LookupSelect
      READLIB TKLibName EditMenu
      CLEARALL
      VIEW "cust"
      COEDIT "TKEntry"
      PICKFORM "F"
      PROMPT "Entering invoice information.",
             "Press [F1] for help, [F10] for menu."
      DoWait("")
      PROMPT
      RELEASE PROCS Reqd,FillDate,DateLeave,CustLeave,
 ResetSpecs,ChangeDisc,SpecialKey,FindPart,ChangeQuan,DoTotal,
 FillSubtotal,BadID,BadCarrier,GetCust,NoUp,NoUpLeft,
 NoDownRight,NormalPhone,FillPhone,LookupSelect,EditMenu
      ENDPROC

      READLIB "DemoApp" DataEntry
      DataEntry()

      Если бы это было завершенное приложение, нам необходи-
 мо  было  бы добавить что-нибудь похожее на конец процедуры
 DoWait:

      IF retval=TKcancel
          THEN RESET
          ELSE
            DO_IT!
      ENDIF

      Скрипт post содержит информацию, которая  поможет  Вам
 послать  информацию  ввода данных в соответствующую таблицу
 данных.
      Аналогично, программы инициализации будут  выполняться
 в  начале Вашего приложения, а не в начале цикла ввода дан-
 ных.
      Как  Вы  можете  видеть, несмотря на то, что Вы должны
 провести некоторую подготовительную работу, для того, чтобы
 вставить оператор DoWait в Ваш скрипт, полученные результа-
 ты окупят Ваши затраты. Кроме того, выбор услуг  KeyDefine,
 FieldDefine  и HelpForm из меню Toolkit будет будет автома-
 тизировать большую часть работ. Ваша основная за дача  сос-
 тоит  в  создании  процедур, которые будут использоваться в
 процессе ввода данных и, затем ввести имена этих процедур в
 соответствующую таблицу, используемую для спецификации  по-
 лей.


      Использование FieldDefine.

 Demonstration *FieldDefine KeyDefine  HelpForm PrepareFinal
 Quit

 Определение процедур, вызываемых DoWait

      Подсистема FieldDefine создает скрипт на языке PAL  по
 умолчанию  называемый  fldspec, который устанавливает пере-
 менные, используемые процедурой DoWait, которая при  помощи
 них  управляет  процедурами,  выполняемыми при определенных
 условиях для каждого поля в Вашей таблице ввода данных.
      Когда Вы выберете услугу FieldDefine из меню  Toolkit,
 система попросит у Вас имя скрипта, в котором Вы хотите за-
 помнить переменные:

      Script: FldSpec
      Enter the name of the script in which to store
                               field specifications.

      Если  скрипт уже существует, система попросит Вас либо
 прекратить, либо модифицировать существующие определения.
      Если скрипт не существует,  Вас  попросят  ввести  имя
 таблицы, содержащей поля ввода данных для того, чтобы опре-
 делить процедуры:

      Table: TKEntry
      Enter the name of the underlying data entry table.

      Затем Вы увидите таблицу спецификации полей, состоящую
 из пяти полей, одно из которых содержит имена полей для Ва-
 шей  таблицы ввода данных, и одному полю для каждого из че-
 тырех типов процедур:

      -  FieldName:  Информационное  поле, содержащее список
 имен всех полей в Вашей форме ввода данных.
      - Arrive: Процедура, вызываемая когда пользователь пе-
 ремещает курсор в указанное поле.
      -  GoodDepart:  процедура,  вызываемая в тот момент,
 когда пользователь пытается завершить ввод в указанное  по-
 ле,  и введенные данные прошли все процедуры контроля, пре-
 дусмотренные для поля; процедура выполняется до  того,  как
 поле будет покинуто.
      - BadDepart: Процедура вызывается в тот момент, когда
 пользователь  пытается  завершить  ввод  в указанное поле и
 введенные данные не прошли входного контроля; процедура вы-
 полняется до того как поле  будет  покинуто.  Прцедуры  Bad
 Depart  и  Keystroke могут быть вызваны в том случае, когда
 содержимое поля не корректно.
      Незавершенные или неправильные данные, трактуемые  как
 правильные, могут позднее явиться причиной ошибки скрипта в
 Вашем приложении (например,при использовании команды MOVETO).
      -  Keystroke  (нажатие  клавиши): процедура вызывается
 после каждого "регулярного" нажатия клавиши (см.  использо-
 вание KeyDefine).
      Для того, чтобы задать процедуру для поля, введите со-
 ответствующее  имя  процедуры  в  колонку. После заполнения
 таблицы, нажмите Do_It![F2], для того, чтобы сохранить  ее
 имя, выберите [Cancel] из меню, чтобы подтвердить все изме-
 нения.
      Если  Вы  изменили  структуру Таблицы ввода данных, Вы
 должны изменить скрипт спецификации полей при помощи проце-
 дуры FieldDefine.
      Для зтого выберите услугу FieldDefine/Modify. Процеду-
 ра  FieldDefine  автоматически  сохранит  как  спецификацию
 старших  (не измененных) полей, если это возможно, или соз-
 дастновую таблицу с именем fldspec для  будущих  изменений.
 Эта таблица позже транслируется в скрипт и не будет сущест-
 вовать после завершения процедуры FieldDefine. Но не пытай-
 тесь изменить скрипт fldspec. Также, из-за того, что проце-
 дура  DoWait  чувствительна как к структуре соответствующей
 таблицы, так и к относительной позиции ее полей, Вы не  мо-
 жете использовать функцию "вращения" ([Ctrl][R]) или услугу
 Image/Move  внутри  Вашего приложения для того, чтобы изме-
 нить вид таблиц в которые вводятся данные.
      Вы должны использовать FieldDefine и Вы должны созда-
 вать  процедуры  и  определять  в таблице их создание перед
 тем, как использовать DoWAit. Не имеет значения до или после
 использования FieldDefine Вы определили процедуры.


      Скрипт Borrow.

      Подсистема FieldDefine создает для себя второй скрипт
 с именем borrow. Всякий раз, как FieldDefine читает скрипт
 спецификации поля, она использует скрипт borrow  для  того,
 чтобы определить, когда структура таблицы должна быть изме-
 нена.
      FieldDefine  создает и сохраняет последующие скрипты
 borrow (borrow 0 - borrow  n)  для  соответствующих  файлов
 спецификации полей. Скрипт borrow используется исключитель-
 но процедурой FieldDefine и его нет необходимости включать
 в Ваше приложение.


      Использование KeyDefine.

      Услуга  KeyDefine создает скрипт на языке PAL, который
 по умолчанию называется Keyspec, и содержит переменные, ис-
 пользуемые процедурой DoWait.
      Когда Вы выбираете услугу KeyDefine из  меню  Toolkit,
 система  попросит  Вас ввести имя скрипта, который содержит
 определения клавиш:

 Script:KeySpec
 Enter the name of the script to store key specifications.

      Если такой скрипт уже существует, система попросит Вас
 либо  подтвердить  уже имеющиеся определения, либо изменить
 скрипт. Скрипт спецификации клавиш  не  является  таблицей,
 поэтому  система не будет просить Вас ввести имя соответст-
 вующей таблицы ввода данных. Сделав хотя бы раз этот выбор,
 Вы увидите, что таблица спецификации  клавиш  содержит  три
 поля:
      - AsciiCode: Содержит код Ascii для каждой клавиши,
 возможной в Вашем приложении.
      - Function: Содержит функции каждой клавиши.
      - Effect (действие):  Содержит  величины,  присвоенные
 специальным клавишам.
      Поля Ascii и Function являются информационными. В поле
 Effect может появиться одна из следующих величин:
      -  Regular:  Заставляет клавиши работать нормально, не
 выполняя специальных функций - нажатие клавиши просто  про-
 ходит  через  PARADOX.  Используется  эта величина для всех
 клавиш, за исключением тех, которые выполняют  специальное
 действие.
      - Illegal: Определенные таким образом клавиши отверга-
 ются  процедурой DoWait. DoWait сигналом сообщает пользова-
 телю, когда нажимается неразрешенная клавиша.
      - Exit: Нажатие такой клавиши  приводит  к  выходу  из
 процедуры DoWait (аналогично действию ключевого слова UNTIL
 в процедуре Wait).
      -  Special: Нажатие клавиши приводит к выполнению про-
 цедуры, которую Вы определяете.
      Для того, чтобы изменять действие, вызываемое нажатием
 клавиши, введите правильную категорию в поле Effect для та-
 кой клавиши. После завершения  изменеения  функций  клавиш,
 нажмите  Do_It![F2], для того, чтобы сохранить новые изме-
 нения, или выберите услугу Cancel, для подтверждения  изме-
 нений.   Если   Вы  захотите  сохранить  изменения,  услуга
 KeyDefine попросит Вас ввести имена процедур, которые вызы-
 ваются при нажатии заново обозначенных специальных  клавиш.
 Введите  имя  процедуры,  которая  используется при нажатии
 каждой специальной клавиши. См. далее  раздел  "Специальные
 функции", где приведены инструкции по созданию процедур.
      Процедура  KeyDefine  просматривает определения клавиш
 и, через некоторое время сохраняет скрипт определения  кла-
 виш, затем возвращается в основное Toolkit меню.
      Не  пытайтесь  изменить  скрипт,  созданный процедурой
 KeyDefine (обычно скрипт keyspec), вместо этого воспользуй-
 тесь услугой Modify (изменить) в KeyDefine. Дело в том, что
 таблица, используемая во время услуги KeyDefine, фактически
 транслируется в скрипт и, после того, как KeyDefine  завер-
 шит работу, ее таблицы просто не будет существовать.
      Вы  должны  воспользоваться услугой KeyDefine до того,
 как Вы использовали DoWait в вашем приложении. Если Вы  оп-
 ределили  некоторые клавиши, как специальные, Вы должны также
 создать процедуру специальных клавиш для управления их  на-
 жатием.


      TKKEYTYPE.

      Переменная с именем TKKeyType используется в процедуре
 DoWait  и применима в Ваших процедурах в различных контекс-
 тах (см. "Arrival, Departure, Special и KeyStroke процедуры).
      TKKeyType может принимать одно из шести значений:
      - R: регулярная, неперемещающая;
      - I: запрещенная;
      - E: выход;
      - S: специальная, неперемещающая;
      - M: регулярная, перемещающая (Movement);
      - D: специальная, перемещающая (DepartSpecial).
      M и D автоматически  присваиваются  услугой  KeyDefine
 Регулярным  и Специальным клавишам, которые заставляют кур-
 сор выходить из поля. М -  присваивается,  когда  KeyDefine
 определяет,  что регулярная клавиша будет заставлять курсор
 покидать текущее поле. D - присваивается,  когда  KeyDefine
 определяет, что специальная клавиша будет заставлять курсор
 покидать  текущее поле. Из-за того, что это присвоение про-
 исходит автоматически, типы "Movement" и  "Departspecial"
 нельзя  специфицировать  непосредственно  используя  услугу
 KeyDefine.
      В заключение заметим,  что  процедуры  нажатия  клавиш
 (как  назначенные  услугой  FieldDefine) вызываются всякий
 раз, как происходит нажатие регулярных неперемещающих  кла-
 виш. Клавиши перемещения включают [стрелка влево], [стрелка
 вправо],  [PgUp]  и  тому  подобные  клавиши,  но не [Esc],
 [Backspace] или другие клавиши, которые  перемещают  курсор
 внутри поля.


      Использование HelpForm.

 Demonstration  FieldDefine  KeyDefine _   .*HelpForm*

      PrepareFinal  Quit

 Редактирование  или  определение формы, позволяющее пересе-
 кать границы.

      При создании формы в ПАРАДОКСе, размещение новых  гра-
 ниц поверх уже существующих, приводит к пересечению границ,
 которое  определяется  только  текущей границей. Обычно для
 того, чтобы определить пересечение двух границ,  Вы  должны
 переместить  курсор  к  месту пересечения и воспользоваться
 клавишей [Alt], совместно с вспомогательной цифровой клавиа-
 турой для того,  чтобы  напечатать  подходящий  графический
 символ IBM.
      Разработка форм с использованием услуги HelpForm зави-
 сит от различных условий. Когда Вы располагаете границы по-
 верх  других границ, HelpForm заполняет символы пересечения
 автоматически. Существует только одно исключение: пересече-
 ние угла рамки, состоящей из двух линий с углом рамки, сос-
 тоящей из одной линии, для такой ситуации просто не сущест-
 вует  подходящего  символа.  В  подобных  случаях,   услуга
 HelpForm  работает  также, как  и генератор форм ПАРАДОКСа -
 новая граница будет удалять предыдущие символы, находящиеся
 в этой позиции.
 Вы еще можете изменить интерактивно пересечение,  используя
 особенности, приведенные ниже.
      Когда Вы нажимаете [Alt][F1], услуга HelpForm выводит
 список всех графических символов на дисплей. После этого Вы
 можете выбрать курсором символ для текущей позиции в Форме.
 Нажмите  [Enter] для того, чтобы поместить высвеченный сим-
 вол на место курсора, и нажмите клавишу [?], в том  случае,
 если  Вам необходимо увидеть ASCII код символа, помеченного
 в  таблице  повышенной  яркостью. Если Вы захотите покинуть
 режим "Форма", нажмите клавиши [F2][Do_It!]  или  выберите
 услугу Cancel из меню HelpForm, HelpForm автоматически воз-
 вратится в Toolkit.


      Использование PrepareFinal.

      Выбор  услуги  PrepareFinal из меню Toolkit'а позволит
 Вам выполнить две функции, которые  повысят  быстродействие
 Вашего приложения:
      -  Удалить все процедуры TKDebug (отладка), вызываемые
 из приложения.
      - Удалить все специальные переменные Toolkit'а (TKDel,
 TKDo_It! и т.п.) с действительными величинами.
      Вторая функция, несмотря на сокращение обьема  памяти,
 используемое Вашим приложением, также уменьшает удобочитае-
 мость скриптов. Например, если скрипт содержит строку:
      IF ISBLANC ([]) And TKChar<>TKDel,
      то услуга PrepareFinal изменит ее на:
      IF ISBLANC ([]) AND TKChar<>-83

      Когда Вы выберите услугу PrepareFinal, то сначала сис-
 тема  попросит  Вас ввести имя скрипта, с которым Вы хотите
 работать.Введите имя скрипта (или  выберите  его),  как  Вы
 обычно  делали это в ПАРАДОКСе. Затем PrepareFinal спросит
 Вас новое имя скрипта.Введите имя, под которым  Вы  желаете
 сохранить   конечный  скрипт.  В  заключение,  PrepareFinal
 спросит Вас:
      Желаете   ли   Вы   извлечь    (K)    Keycodes,    (D)
 DebugProcedures или обе одновременно.
      Введите   K,   D  или  В,  как  Вам  больше  подходит.
 PrepareFinal завершит операцию и вернется  в  главное  меню
 Toolkit'а.
      Хотя услуга PrepareFinal удаляет KeyCode переменные из
 Вашего  скрипта,  она не удалит вызов процедуры SetKeycodes
 или  вызов  библиотеки  ReadLib,  где  читаются  переменные
 SetKeycodes. Эти вызовы должны быть удалены вручную.


      Создание процедур Custom (заказ).

      Toolkit содержит только процедуры, написанные на языке
 PAL.  Некоторые  из  этих  процедур Вы можете использовать.
 Другие предназначены только для внутреннего  использования.
 Содержат  процедуры  два  библиотечных файла: Toolkit.lib и
 Toolkit2.lib. Настоящий раздел рассматривает, каким образом
 процедуры, написанные Вами, могут взаимодействовать с  про-
 цедурами Toolkit'а.
      Вы  используете Toolkit для присвоения процедурам, ко-
 торые Вы написали, различных функций. Наиболее важные функ-
 ции следующие:
      - Нажатие клавиши пользователем.
      - Прибытие в поле.
      - Попытка покинуть поле.
      Внутри Ваших процедур  Вы  можете  вызывать  процедуры
 Toolkit'a.  Дополнительно Вы можете использовать переменные
 поддерживаемые основной процедурой Toolkit'a - DoWait.


      Переменные, используемые процедурой Toolkit'a.

      Для того, чтобы понять, как писать процедуры,  взаимо-
 действующие  с  Toolkit'ом, необходимо сначала разобраться,
 как Toolkit использует переменные. Большинство из  процедур
 Toolkit'a  определяют  свои переменные, как закрытые (част-
 ные) и они не представляют  большого  интереса.  Переменные
 Toolkit'a начинаются с букв TK, например TKDel. Вы не долж-
 ны  начинать  имена  своих переменных с букв TK, если Вы не
 пользовались  сознательно  хотя  бы  одной  из   переменных
 Toolkit'a,  приведенных  ниже. Все переменные, используемые
 процедурой DoWait, обьявлены частными к ней.
      Очень важно понять, что процедуры, которые Вы предназ-
 начаете для полей и действий клавиш, являются  подчиненными
 по  отношению  к  процедуре DoWait (то есть DoWait вызывает
 Ваши процедуры). Это значит, что  переменные,  обьявленные
 как частные к процедуре DoWait, могут быть использованы Ва-
 шими  процедурами.  Кроме  того, Вы можете установить конк-
 ретные величины этих переменных, для того, чтобы  управлять
 действием процедуры DoWait.
      Вам,  возможно, потребуется использовать следующие пе-
 ременные процедуры DoWait:
      - TKChanged: Логическая величина (Истина/Ложь),  пока-
 зывающая, изменилась ли величина в текущем поле. Переменная
 определена только в процедуре GoodDepart.
      - TKChar: Содержит расширенный код Ascii последней на-
 жатой  пользователем  клавиши.  Эта величина принимается из
 DoWait (см. выше), но может быть также задана, как отличная
 от принимаемой по умолчанию.
      - TKFieldVal: Величина, содержащаяся в поле,  когда  в
 него  входили,  она  используется  для установки переменной
 TKCanged.
      - TKHoldCanvas: Если переменная имеет  значение  TRUE,
 то  DoWait  знает,  что не следует удалять канву ПАЛа, пока
 пользователь не нажмет клавишу.
      - TKKeyType: Содержит символ, обозначающий текущий тип
 клавиши (R,I,E,M,S,D).
      -TKMessage: Когда установлена не пустая строка, DoWait
 высвечивает строку в окне сообщения ПАРАДОКСа, до следующе-
 го нажатия клавиши.
      Использование переменных Toolkit'a  рассмотрено  более
 детально в следующем параграфе.


      Процедуры.

      Для  того,  чтобы использовать Toolkit эффективно, Вам
 необходимо только создавать процедуры для специальных дей-
 ствий или ситуаций. Запомните, что форма ввода данных,  ко-
 торую  Вы создаете интерактивно в ПАРАДОКСе, управляет шаб-
 лонными ситуациями. Процедуры, которые Вы создаете,  должны
 обрабатывать исключения, которые могут произойти в процессе
 ввода  данных  (неразрешенная величина, специальные нажатия
 клавиш для помощи или  других  действий  и  т.п.).  Обычно,
 большую часть Вашей работы будет занимать создание процедур
 следующих четырех типов:
      - Arrival (прибытие);
      - Departure (покинуть):GoodDeparture и Bad;
      - Keystroke (нажатие клавиш);
      - Special (специальные).
      Этот  параграф  приводит детальное описание каждого из
 этих типов процедур с упором на использование  и  установку
 переменных  Toolkit'a.  Вы  создаете  эти процедуры точно
 также, как Вы это делали с процедурами на ПАЛе. Вы назнача-
 ете эти процедуры, используя FieldDefine (см.  "Использова-
 ние FieldDefine выше).


      Процедуры прибытия.

      Процедуры прибытия вызываются всякий раз, когда курсор
 входит в поле. Вы можете назначить различные процедуры при-
 бытия  к каждому полю, или назначить одну процедуру по мно-
 гим полям.
      Процедура DoWait вызывает процедуры прибытия автомати-
 чески, когда пользователь перемещает курсор во внутрь поля,
 для которого определена эта процедура прибытия. Такие дейс-
 твия возможны для курсора, который входит в поле по команде
 (такой, как MOVETO или RIGHT) в Вашем приложении. Когда  Вы
 переводите  курсор во внутрь поля при помощи команды, необ-
 ходимо известить процедуру DoWait о том, что Вы вошли в поле
 без использования клавиш передвижения курсора  или  клавиши
 DepartSpecial  (специальный вход). Это очень важно для пра-
 вильной работы Toolkit'a.
      Вы можете сообщить процедуре DoWait о том,  что вход  в
 поле произошел без использования клавиш передвижения курсо-
 ра,  посредством  вызова  процедуры ArriveField (прибытие в
 поле)  сразу  после  перехода  в  новое   поле.   Процедура
 ArriveField устанавливает в начальное значение все перемен-
 ные зависимые от поля, которые использует DoWait, и вызыва-
 ет процедуру прибытия для поля (если таковая существует).
      Если  Вы хотите перейти к новому полю без вызова про-
 цедуры прибытия, используйте вместо процедуры  ArriveField,
 процедуру  NewField  (новое  поле).  Она  сообщит процедуре
 DoWait, что вход в новое поле произошел без вызова процеду-
 ры прибытия.
      Следующие переменные Toolkit'a имеют специальное  зна-
 чение для процедуры прибытия:
      - TKHoldCanvas: Когда переменная имеет значение "Исти-
 на", установленное Вашей процедурой, она запрещает процеду-
 ре  DoWait использовать режим ECHO NORMAL вместе с процеду-
 рой прибытия, пока пользователь не нажмет следующую  клави-
 шу.  Переменная  TKHoldCanvas  работает только тогда, когда
 режим ECHO выключен. Значение  переменной  по  умолчанию  -
 "Ложь".
      - TKFieldVal: Содержит величину, находящуюся в текущем
 поле, когда происходил вход. Как процедура ArriveField, так
 и  NewField сбрасывает эту переменную. TKFieldWal использу-
 ется для вычисления переменной  TKChanged  (см.  "Процедуры
 выхода" ниже).
      - TKMessage: Когда устанавливается не пустая строковая
 величина  процедурой  прибытия,  эта переменная высвечивает
 эту строку, как "Сообщение" до  нажатия  следующей  клавиши
 пользователем.  TKMessage  логически  связана  с переменной
 TKHoldCanves, как показано в таблице:

      Эхо     TKHoldCanvas             TKMessage
      -------------------------------------------
      Normal  Истина или Ложь       Показывается,
                                   как в рабочем
                                    пространстве
      OF          Ложь             Показывается,
                                   как в рабочем
                                   пространстве
                                  (после удаления
                                   канвы ПАЛа)
      ON        Истина             Показывается в
                                   текущей канве
                                       ПАЛа.

      -  TKChar: Возвращает код клавиши, который вводит курсор
 в поле.
      - TKChanged, TKKeyType, TKUserKey и TKAccept не  имеют
 отношения к процедурам прибытия.
      Вы назначаете процедуры прибытия в поле, используя ус-
 лугу FieldDefine из скрипта "toolkit".


      Процедуры выхода.

      Процедура выхода вызывается всякий раз, когда пользова-
 тель нажимает  клавишу,  которая  перемещает курсор из поля,
 для которого определена такая процедура. Вызов процедуры вы-
 хода происходит перед тем, как команда пройдет через  ПАРА-
 ДОКС и поле будет действительно покинуто.
      В  том  случае, когда поле покидается при помощи таких
 команд, как MOVETO или RIGHT, которые Вы  включили  в  Ваше
 приложение, DoWait не не вызывает процедуру выхода. Однако,
 Вы  непосредственно  можете вызвать процедуру выхода также,
 как Вы вызываете процедуру в Ваших приложениях.
      Процедуры выхода вызываются  автоматически  процедурой
 DoWait по следующим двум причинам:
      -  Пользователь  нажал  клавишу выхода из поля, такую,
 как [стрелка вверх], спращивал процедуру DoWait "Могу ли  я
 покинуть  это  поле?" Ваша процедура выхода выберет - должен
 ли курсор остаться внутри поля  (возможно,  пока  не  будет
 введена правильная величина) или покинуть его.
      -  Пользователь  нажал  клавишу  выхода  из  процедуры
 DoWait. Но для того, чтобы выйти из процедуры DoWait, теку-
 щее поле должно содержжать корректное значение, и Ваша про-
 цедура выхода произведет необходимые  проверки  перед  тем,
 как позволить пользователю выйти из DoWait.
      Существует  два типа процедур выхода: Корректный выход
 (GoodDepart) и Плохой выход (BadDepart).  Процедура  Good
 Depart  вызывается  во  время  попытки выйти из поля, когда
 данные прошли  все  необходимые  проверки.  Процедура  Good
 Depart  не  должна  помещать неправильные или частично пра-
 вильные  данные  в  поле,  потому,  что   процедура   DoWait
 предпологает, что корректность данных в поле остается нена-
 рушенной после работы процедуры Good Depart.
      Процедуры  BadDepart  вызываются  процедурой DoWait,
 когда пользователь пытается выйти из поля и при зтом данные
 в этом поле не прошли все необходимые проверки.  Процедуры
 типа  BadDepart должны быть написаны очень тщательно, пос-
 кольку они вызываются в тот  момент,  когда  поле  содержит
 неправильные данные. Попытки покинуть поле с неправилььными
 данными могут привести к ошибке скрипта.
      Процедуры GoodDepart и BadDepart назначаются к полям
 посредством услуги FieldDefine.


      Переменные в процедуре GoodDepart.

      Процедура  GoodDepart использует те же самые перемен-
 ные, что были рассмотрены выше, за следующим исключением:
      - TKAccept: Если установить эту переменную в  значение
 "Ложно",  то  процедура  DoWait знает, что нельзя принимать
 символ, который был введен и отменяет выход из поля.
      - TKChanged: Устанавливается в состояние "Истина"  или
 "Ложь"  процедурой  DoWait  в зависимости от того, менялась
 или нет величина в поле после входа в него.
      - TKChar: Содержит величину последнего введенного сим-
 вола. В отличии от процедуры arrival  (прибытия),  действие
 клавиш  может быть отложено (не обрабатывается ПАРАДОКСом),
 и даже может быть отменено самой процедурой.  Сброс  TKChar
 приводит  к  тому,  что процедура DoWait игнорирует нажатие
 клавиши и реагирует на новое  значение  величины.  Поэтому,
 сброс  переменной  TKChar  по отношению к еще одной клавише
 перемещения заставляет DoWAit перезапускать процедуру выхо-
 да. Если Вы не хотите, чтобы процедура перезапускалась, ис-
 пользуйте KEYPRESS для того, чтобы ввести символ и  вызвать
 процедуру ArriveField.
      - TKKeyType: Содержит тип отложенной клавиши. Для про-
 цедур   выхода   приемлимыми  типами  являются  (M)ovement,
 (D)epart и (E)xit.
      Если Вы хотите выйти из процедуры  DoWait  при  помощи
 Вашей  процедуры выхода, причем без ее перезапуска, устано-
 вите переменную TKKeyType в "E". Когда  процедура  завершит
 работу, процедура DoWait, будет покинута автоматически.


      Переменные в процедуре BadDepart.

      Процедуры BadDepart имеют побочные действия, которые
 должны быть рассмотрены. Если Ваша процедура BadDepart ис-
 правляет данные в текущем поле, то после выхода из процеду-
 ры, DoWait реагирует так, как если бы процедура GoodDepart
 была  вызвана вместо процедуры BadDepart. В противном слу-
 чае, процедура DoWait не позволит покинуть поле.
      Три клавиши: [Del], Undo[Ctrl][U] и  [Ctrl][Break]
 могут  влиять на процедуры BadDepart следующим неожиданным
 образом:
      -  Нажатие  любой  из этих клавиш, несмотря на то, что
 поле содержит неправильные данные,  приведет  к  тому,  что
 данные будут теоретически исправлены.
      -  Если  какая-нибудь  из  этих клавиш определена, как
 клавиша выхода, пользователь не может выйти, даже если  на-
 жатие  клавиши  было принято процедурой BadDepart. И, пос-
 кольку данные в поле еще не были изменены при помощи клавиш
 [Del], Undo[Ctrl][Break], неправильные  данные  остаются,
 заставляя  процедуру  DoWait вызывать, перед тем, как выйти
 из поля, процедуру BadDepart. DoWait не позволит выйти из
 поля, пока данные в нем не будут правильными.
     - Когда  клавиши  [Del],  Undo[Ctrl][U] и [Ctrl][Break]
 определены,  как  Регулярные  или Специальные, они
 запрещают любые сообщения, определенные пользователем в пе-
 ременной TKMessage. Вот почему принято, что набор сообщений
 процедуры BadDepart относится к тому, что  поле  не  может
 быть покинуто. И поскольку эти клавиши приводят к выходу из
 поля, несмотря на его текущее содержание, любые такие сооб-
 щения неподходящи.
      Переменные,  используемые в процедуре BadDepart точно
 так, как и в процедуре GoodDepart за следующим исключением:
      - TKAccept: Когда переменная  установлена  в  значение
 "Истина",  она позволяет передавать код клавиши через ПАРА-
 ДОКС и вызывает появление на экране окна с сообщением. Выс-
 вечиваемые сообщения будут аналогичны тем, которые высвечи-
 ваются в интерактивном режиме при попытке покинуть  поле  с
 неправильным  содержанием;  Если же процедура Bad Depart не
 определена, это случится автоматически. По умолчанию  пере-
 менная устанавливается в значение "Истина".
      Если Вы установили TKAccept в значение "Ложно", то код
 клавиши,  с  помощью которого пользователь попытается поки-
 нуть поле, не передается через ПАРАДОКС и окно с сообщением
 не будет высвечено.
      Замечание:  Если   установлено   значение   переменной
 TKMessage, то  переменная TKAccept игнорируется, и символ не
 принимается. это ликвидирует возможность появления на экра-
 не одновременно двух сообщений.
      - TKMessage: Когда переменная TKMessage устанавливает-
 ся, то она высвечивается на экране  раньше,  чем  сообщение
 ПАРАДОКСа.  Исключение  составляет случай, когда TKChar со-
 держит коды клавиш: [Del],Undo[Ctrl][U],или [Ctrl][Break],
 которые запрещают сообщение.
      - TKChanged: Эта переменная не определена для процедур
 BadDepart. Очевидно, что если данные неправильные, то они
 должны  быть изменены до выхода из поля.


      Процедуры нажатия клавиш.

      Процедуры  нажатия  клавиш  вызываются всякий раз, как
 происходит нажатие регулярных, не перемещающих курсор  кла-
 виш  и  курсор,  находящийся в поле с определенной для него
 процедурой нажатия клавиши. Единственным исключением  явля-
 ется  случай, когда рабочее пространство находится в режиме
 Помощи или в режиме Просмотра поля. В этом случае процедуры
 нажатия клавиш не вызываются процедурой DoWait.
      Процедуры нажатия клавиш вызываются перед  тем,  когда
 код  нажатой  клавиши  передастся в ПАРАДОКС для обработки.
 Это позволяет Вам осуществлять общий контроль над  входными
 данными  (то есть Вы можете проверять и реагировать на каж-
 дое нажатие клавиши, если Вы хотите).
      Переменные, используемые в процедуре  нажатия  клавиши
 следующие:
      - TKAccept: Если Ваша процедура установит эту перемен-
 ную  в значение "Ложь", то любая нажатая пользователем кла-
 виша будет игнорироваться процедурой DoWait и не пройдет  в
 ПАРАДОКС.  По умолчанию она устанавливается в значение "Ис-
 тина".
      - TKCanged: Не имеет значения в данном контексте.
      - TKKeyType: В процедурах нажатия клавиш, все  клавиши
 являются  регулярными. Специальные клавиши управляются спе-
 циальными процедурами. Клавиши  Exit,  Movement,  Departure
 управляются  с помощью процедуры выхода. Неразрешенные кла-
 виши просто не принимаются процедурой DoWait. Значение  пе-
 ременной по умолчанию равно "R" для регулярных неперемещаю-
 щих курсор клавиш.
      -  TKChar:  Содержит  код  клавиши ожидания. Вы можете
 проверить эту величину или изменить  ее  при  помощи  Вашей
 процедуры. Изменение переменной приведет к тому, что проце-
 дура  DoWait будет игнорировать вводимые символы и работать
 так, как если бы пользователь только что нажал новую клави-
 шу. Если Вы не хотите, чтобы процедура перезапускалась, ис-
 полььзуйте KEYPRESS для ввода символа и установите перемен-
 ную TKAssept в состояние "Ложь".
       Переменные  TKFieldVal,  TKHoldCanvas,  TKMessage  и
 TKFieldNum используются точно также, как это было описано в
 главе "Процедуры прибытия".
      Процедуры  нажатия клавиш могут приводить к выходу из
 поля. В этом случае Вы должны вызвать  любую  из  процедур:
 ArriveField  или  NewField для того, чтобы информировать
 DoWait о том, что  Вы  перешли  в  другое  поле.  Процедуры
 ArriveField рассмотрены в главе "Процедуры прибытия" выше,
 а также в конце данного параграфа.
      Вы  должны заметить одно различие в использовании этих
 двух процедур: любые задержки нажатия клавиш будут  аннули-
 рованы  процедурой ArriveField (по определению не сущест-
 вует нажатий клавиш, которые могли  бы  быть  задержаны  во
 время прибытия в поле).
      Процедура  NewField,  с  другой стороны, не является
 причиной прибытия в поле и это происходит не отменяя задер-
 жанный ввод. Как и в случае с процедурой BadDepart, данные
 могут быть как правильными, так и неправильными при  вызове
 процедуры нажатия клавиш, так,что необходимо быть уверенным
 в  контроле  правильности поля перед попыткой его покинуть.
 Процедуры нажатия  клавиш  назначаются  при  помощи  услуги
 FieldDefine.


      Специальныые процедуры.

      Специальные  процедуры  вызываются  всякий  раз, когда
 происходит нажатие специальной  клавиши.  Если  специальная
 клавиша  может вывести пользователя из поля, то она называ-
 ется DepartSpecialKey. Процедуре DoWait  известно,  какие
 специальные клавиши могут осуществлять выход из поля.
      В  отличии  от всех других процедур определяемых Вами,
 специальные процедуры не зависят от поля, в  котором  нахо-
 дится курсор. Когда происходит нажатие специальной клавиши,
 то  процедура, присвоенная ее услугой KeyDefine, вызывается
 автоматически, независимо от поля, в котором работает пользо-
 ватель.
      Переменные,  используемые  специальными   процедурами,
 различаются  своим  представлением для прибытия и выхода из
 поля следующим образом:
      - TKKeyType: Содержит значение либо "S" либо  "D".  Вы
 можете проверить эту переменную для того, чтобы определить,
 относится ли клавиша к типу Special или DepartSpecial. Ес-
 ли клавиша относится к типу DepartSpecial и Вы хотите вый-
 ти из процедуры DoWait после выполнения процедуры выхода из
 поля, установите переменную TKKeyType в значение "E" (Exit).
      Процедура выхода (которая будет выполняться после спе-
 циальной  процедуры) может также отменить требование выхода
 (см. "Процедуры выхода").
      - TKChar: Содержит код клавиши.  Вы  можете  проверить
 эту  величину  или  изменить ее своей процедурой. Изменение
 значения этой переменной приведет  к  тому,  что  процедура
 DoWait  будет игнорировать вводимые с клавиатуры символы, и
 работать, как если бы  пользователь  нажимал  только  новую
 клавишу.
      В заключение отметим, что процедуры ArriveField и New
 Field  должны  вызываться только при определенных условиях,
 как рассмотрено в главе "Процедуры нажатия клавиш".  Специ-
 альные процедуры присваиваются при помощи услуги KeyDefine.

      Сборка программы.

      До  сих  пор материал был представлен отдельными фраг-
 ментами. В этом параграфе обобщены  все  шаги,  которые  Вы
 должны  сделать  при создании приложений, используя систему
 Toolkit.
      1.Создать (интерактивно в ПАРАДОКСе)  таблицы,  формы,
 контроль целостности и другие объекты ПАРАДОКСа, используе-
 мые во время ввода данных.
      2.Определить  исключения  к  нормальному вводу данных,
 которые Вы хотите обрабатывать в Ваших приложениях. Под ис-
 ключениями понимаются автоматически проводимые  вычисления,
 специальная обработка особенных данных и т.п.
      3.Для  каждого  исключения, упомянутого в шаге 2, соз-
 дать процедуру  обработки,  используя  традиционные  методы
 программирования на ПАЛе.
      4.Для  каждой  процедуры,  созданной  на третьем шаге,
 представьте себе, когда она будет работать, и, затем,  наз-
 начте эти процедуры к соответствующим полям. Для того, что-
 бы  сделать  такое  назначение,  запустите  скрипт с именем
 toolkit, выберите услугу FieldDefine, и назначьте процедуры
 к полям, заполняя поля спецификации таблицы. Например,  ав-
 томатический  ввод данных является процедурой Arrival (при-
 бытие), поэтому Вы вводите имя своей процедуры в таблицу в
 колонку с именем Arrival.
      5.Выберите услугу KeyDefine и присвойте значения  всем
 возможным клавишам.
      6.Занесите Ваши процедуры в библиотеку (или библиотеки).
      7.Добавьте  в начало Вашего скрипта процедуру инициа-
 лизации Toolkit'a, например InitWait.
      8.В заключение, когда  Вы  захотите  осуществить  ввод
 данных в Ваше приложение, вызовите процедуру DoWait. Вы мо-
 жете  проверить  переменную  Retval  поля  вызова процедуры
 DoWait, поскольку переменная Retval  скажет  Вам,  нажатие
 каких клавиш приведет к завершению процедуры DoWait.
      Несмотря  на очевидную сложность информации, представ-
 ленной в этом параграфе, использование Toolkit'a  есть суть
 приведенных  нескольких  простых шагов. Вам совсем не нужно
 использовать все процедуры и переменные Toolkit'a в  каждом
 приложении.  Мы представили систему Toolkit в деталях, так,
 что когда Вы будете нуждаться в одной из ее функций, Вы бу-
 дете знать, как ее использовать.


      Использование Toolkit'a  вместе  с  уже  существующими
 приложениями.

      Обычно  это  несложная  задача  -  внедрить  процедуру
 DoWait в существующие приложения. Вы можете быть  заинтере-
 сованы в зтом по двум причинам:
      -  Процедура  DoWait  выполняется намного быстрей, чем
 похожая команда Wait, выполнение которой всякий раз  завер-
 шается  и  вознобновляется, так как имеет место специальная
 обработка.
      - DoWait обладает дополнительными возможностями, кото-
 рые улучшат ваши приложения.

      Если Ваша программа ввода данных включает  специальную
 обработку, то она, возможно, похожа на следующий фрагмент:

 retval = ""
 WHILE retval <> "F2" AND retwal <> "Esc"
      WAIT TABLE UNTIL "F2","Esc","Help","Menu","Left","Right"
      SWITCH
          CASE retval = "Help":HelpMe()
          CASE retval = "Menu":DoMenu()

      ; дополнительные операторы CASE

      ; здесь могло бы быть новое поле
      ; сначала, мы проконтролируем, где мы находимся,
      ; затем, куда мы идем, затем применим оператор
      ; SWITCH для выполнения нового фрагмента программы

          ENDSWITCH
      ENDWHILE
      IF retval = "F2"
          THEN Do_It!        ; обработка всех данных
          ELSE CANCELEDIT    ; отмена ввода данных
      ENDIF

      Для того, чтобы адаптировать этот фрагмент под исполь-
 зование процедуры DoWait необходимо:
      1.Обьявить клавиши Do_It![F2], [Esc] клавишами выхода
 из процедуры, а HELP [F1] и Menu [F10] специальными.
      2.Сделать  фрагмент  программы  после  каждого оператора
 CASE отдельными процедурами.
      3.Поместить фрагменты кода, которые обрабатывают  вход
 или  выход из поля, в небольшие, обрабатывающие поля проце-
 дуры.
      4.Присвоить процедуры, созданные на шаге 3, к соответ-
 ствующим полям при помощи услуги FieldDefine.
      5.Добавить в начало своего приложения оператор READLIB
 для библиотеки Toolkit. Также убедитесь, что Ваше  приложе-
 ние начинает свою работу с процедурой InitWait.
      6.Видоизменить  все фрагменты скрипта, где осуществля-
 ется ввод данных, следующим образом:

      DoWait("")
      IF retval = TKDo_It!
          THEN...  ; процесс ввода данных
          ELSE...  ; отменить процесс ввода данных
      ENDIF



      Разнообразные темы.

      Запуск из различных директорий.

      Библиотека файлов, которая заключает  в  себе  систему
 Toolkit  должна  находиться в той же директории, что и Ваше
 приложение. Вы можете изменить это положение путем записи в
 переменную Toolkit'a с именем  TKLibName  полного  пути  и
 имени файла библиотеки, содержащей Toolkit перед выполнени-
 ем процедуры InitWait в Вашем приложении. Например, если Вы
 переименовали  библиотеку  ansatk и записали ее в новую ди-
 ректорию с именем Tools, то Вы должны  выполнить  следующий
 оператор перед входом в процедуру InitWait в Вашем приложе-
 нии:
      TKLibName = "\\tools\\ansatk"

      Вам   нет   необходимости   устанавливать   переменную
 TKLibName, если библиотечный файл находится в  текущей  ди-
 ректории скрипта, или не переименовался.


      Использование Эхо в скриптах.

      Когда  процедура DoWait осуществляет управление Вашими
 процедурами, Эхо установлено в значение "NORMAL"  (пока  Вы
 не  выключите его в своих процедурах). Одна из причин изме-
 нения режима - то, что Эхо требует дополнительного времени.
 Если Ваши процедуры не взаимодействуют с рабочим пространс-
 твом, то нет причины изменять режим Эхо. Если же Ваши  про-
 цедуры проводят некоторые манипуляции над рабочим простран-
 ством,  и  Вы  не  хотите,  чтобы пользователь их видел, то
 вставьте команду ECHO OFF в Вашу процедуру.

      Важное замечание для пользователей RunTime:
      Из-за того, что Toolkit всегда вызывает Ваши процедуры
 с режимом ECHO, установленного в "NORMAL", Вы можете не ис-
 пользовать команду ECHO NORMAL. Процедура DoWait  установит
 статус ECHO для Вас автоматически. Если Вы вставили команду
 ECHO  OF в Вашу процедуру, команда DoWait переключит статус
 ON, когда она опять возьмет управление (Если, конечно,  пе-
 ременная TKHoldCanvas установлена в обычное значение "Ложь").
      ПАРАДОКС  RunTime  конфигурации  не распознает команду
 ECHO NORMAL в Ваших приложениях (однако она распознает  ко-
 манду   ECHO  OFF).  Любая  специальная  версия  библиотеки
 Toolkit'a, в которой разрешена команда ECHO  NORMAL,  чтобы
 работать  внутри Toolkit'a (и только внутри Toolkit'a), за-
 пускает свои приложения из системы RunTime.


      Отладка.

      Возможны ситуации, когда процедура DoWait работать  не
 может,  или работает неправильно. Например, если поле поки-
 нуто, но ни процедура ArriveField ни  NewField  не  была
 вызвана  в  приложении,  а  DoWait  не знает, что находится
 внутри поля и, следовательно,  может  вызвать  неподходящую
 процедуру.
      Для того, чтобы быть уверенными в том, что Ваше прило-
 жение  не  содержит подобных ошибок, Вы можете использовать
 процедуру TKDebug. В процессе создания Вашей системы  ввода
 данных,  разместите оператор TKDebug() в начале каждой про-
 цедуры, которая вызывается процедурой DoWait (TKDebug долж-
 на быть первой строкой в Вашей процедуре).  Если  процедура
 DoWait  считает,  что она находится в неверном поле, то она
 инициирует выполнение процедуры TKDebug и Вам будет  выдано
 сообщение  о неисправности. Затем процедура DoWait входит в
 режим отладки (Debug).
      Для того, чтобы извлечь все операторы TKDebug из Ваше-
 го завершенного и протестированного приложения,  можно  ис-
 пользовать  подсистему Toolkit'a PrepareFinal (окончатель-
 ная подготовка). (См. PrepareFinal выше).
      Другим источником проблем в  Ваших  приложениях  может
 явиться взаимодействие между клавишами [Del],Undo[Ctrl][U]
 или [Ctrl][Break] и неправильными  полями.  Во  многих
 случаях  должно осуществляться специальное управление этими
 клавишами в процессе ввода данных. Для  того,  чтобы  прове-
 рить, необходимо ли Вам дополнить процедуру Bad Depart спе-
 циальной  функцией  для,  чтобы управлять клавишами [Del] и
 [Undo], рассмотрим по шагам приведенный ниже пример.

      Проверка правильности работы процедуры BadDepart.

      1.Запустите Ваше приложение.
      2.Введите заведомо неправильные данные в поле.
      3.Нажмите клавишу [Del] и оцените результаты.
      Если Ваше приложение отреагирует, как и ожидалось,  то
 закончите  проверку.  Если нет, то Вы должны дополнить Вашу
 процедуру BadDepart специальным фрагментом  кода,  который
 устранит неисправность.
      Повторите шаги 2 и 3 для каждого поля, в которое можно
 ввести неправильные данные.


      Список процедур (Справочник).

      Эта  глава является кратким описанием предназначения и
 использования каждой процедуры.  Тринадцать  процедур,  ис-
 пользуемых  системой Toolkit, могут пригодиться Вам для Ва-
 ших приложений.

      Toolkit.lib. Процедуры в приложениях:

      - ArriveField(): Информирует процедуру DoWait, что Вы
 переместились к новому полю,  и  что  необходимо  запустить
 процедуру прибытия.
      -  DoWait  (String): Основная процедура Toolkit'a, уп-
 равляющая вводом данных.
      - EditMenu(): Представляет пользователю Меню редактора.
      - GetFile (Mask, Promt, Message, FileName, Required):
      Получает имя файла от пользователя.
      - GetPassword (MaxLength, DisplayKeys): Получает  па-
 роль от пользователя.
      - InitWait (FldSpecFile, KeySpecFile): Устанавливает
 начальное   значение  переменных,  используемых  процедурой
 DoWait.
      - LookupSelect(): Высвечивание справочной таблицы.
      - NewField(): Информирует DoWait, что Вы переместились
 к новому полю, но не вызвали процедуру прибытия.
      - Popup (Row, Column,  Number,  Length):  Представляет
 вертикальное, "прокручивающееся" меню пользователю.
      -  RecurseWait (Message, ProcedureName): Версия про-
 цедуры DoWait, которая может быть вызвана внутри DoWait.
      - SetKeycodes(): Присваивает величины  ключевым  пере-
 менным, таким как TKDel.
      -  SetPopup (TableNameList): Подготавливает меню, выс-
 вечиваемое процедурой Popup.
      - TKDebug(): Проверяет, знает ли процедура  DoWait, ка-
 кое поле в настоящий момент является текущим.

      Другие  процедуры (не упомянутые в этой главе) исполь-
 зуются исключительно Toolkit'ом. Только одна  библиотека  с
 именем toolkit должна быть включена вместе с Вашим приложе-
 нием;  вторая  библиотека  с  именем toolkit2, используется
 только для того, чтобы создать приложения и не  нужна,  при
 их запуске.
      Восемь процедур в библиотеке toolokit.lib предназначе-
 ны специально для управления вводом данных:

      - ArriveField             - NewField
      - DoWait                  - RecurseWait
      - EditMenu                - SetKeyCodes
      - InitWait                - TKDebug

      Из  них  Вы  обязательно должны использовать процедуру
 InitWait  для  установки  началььных  значений   переменных
 Toolkit'a, если, конечно же Вы используете процедуру DoWait
 для  управления  вводом данных. Другие шесть процедур могут
 использоваться, а могут и не использоваться в Ваших  прило-
 жениях,  в зависимости от Ваших запросов. Пять дополнитель-
 ных процедур в библиотеке toolkit.lib  считаются  вспомога-
 тельными  и  могут быть использованы в Вашем приложении вне
 зависимости от того, используете ли Вы процедуру DoWait или
 нет.
      - GetFile                 - Popup
      - GetPassword             - Setpopup
      - LookupSelect
      Используйте эти процедуры только там, где они полезны.

      ARRIVEFIELD процедура сообщает DoWait или RecurseWait,
 что вход в новое поле произошел и должна быть запущена про-
 цедура прибытия (если она определена для этого поля).

      Синтаксис: ArriveField ()
      Процедура не имеет аргументов и не возвращает значений.

      Описание: Хотя результаты процедуры не видны, она (или
 NewField) должна быть вызвана, когда работа одной из  Ваших
 процедур  повлечет выход из поля. Процедура ArriveField от-
 меняет любые задержанные клавиши,  устанавливает  начальные
 значения  переменных  TKFieldVal и других, значения которых
 зависят от поля, затем вызывает процедуру прибытия для  но-
 вого поля (если она определена).

      Пример: Этот фрагмент скрипта makedemo использует про-
 цедуру,  которая  автоматически  заполняет  дату и вызывает
 процедуру ArriveField после выхода курсора из поля Даты:

      PROC Filldate()
        IF ISBLANK([]) ;есть ли дата в поле
          THEN
             IF (TKChar=TKReversetab) OR TKChar=Left
                 THEN LEFT     ; прошел ли пользователь
                 ELSE RIGHT    ; обратно через поле?
                               ; если да - продолжите
                               ; движение назад, если нет -
                               ; двигайтесь вперед к
                               ; следующему полю
             ENDIF             ; дата  заполняется через
                               ; ValCheck
             FrriveField()     ; мы покинули поле даты,
                               ; о чем информировали DoWait
        ENDIF
      ENDPROC

      Смотри также процедуру NewField;
      - Описание процедур ArriveField и NewField выше.


      DOWAIT().
      Эта  процедура управляет процессом ввода данных, вызы-
 вая  и  управляя  специальными  процедурами,   назначенными
 FieldDefine и KeyDefine услугами меню Toolkit'а.

      Синтаксис: DoWait (String),
      где  String - строковое выражение (высвечиваемое в ка-
 честве сообщения в правом нижнем углу экрана во время входа
 в процедуру). Возвращает величину в коде  Ascii  последнего
 введенного  символа.  Также  устанавливает набор переменных
 retval.

      Описание: Процедура выполняет функции  Wait-типа.  Она
 может  выполнять управление процессом ввода в поле, процес-
 сом выхода из поля,  содержание  которого  прошло  контроль
 правильности, процессом выхода из поля, содержимое которого
 не  корректно,  а  также  процессом  нажатия каждой клавиши
 пользователем. В ведении процедуры DoWait находятся следую-
 щие вопросы:
      - Какая процедура должна выполняться?
      - Когда необходимо начать выполнение?
      - Какие ответы дать на  нажатия  клавиш,  определенных
 услугами Toolkit'a  FieldDefine и KeyDefine.

      Перед  вызовом процедуры DoWait в Вашем приложении, Вы
 должны выполнить процедуру InitWait, обеспечив  ее  именами
 полей  и  файлов  спецификации  клавиш (созданными услугами
 Toolkit'a FieldDefine и KeyDefine).

      Использование: DoWait почти всегда используется в виде
 оператора:
              DoWait ("")
      Процедура устанавливает значение глобальной переменной
 retval так, что Вы можете определить, что пользователь сде-
 лал. В нашем демонстрационном приложении значение  перемен-
 ной равное нулю означает, что пользователь отменил редакти-
 рование.  В  то  время, как значение -60 (Do_It!) означает,
 что пользователь сделал изменения в соответствующей таблице.
 Это  в  свою  очередь  означает, что Вы должны были сделать
 что-либо для того, чтобы сохранить эти изменения. Вы можете
 свободно устанавливать свои собственные соглашения, но  ру-
 ководствуясь  правилом:  "Присваивайте  одному из последних
 нажатий клавиши действие "отмена редактирования", так,  что
 Ваши  приложения могут проверить переменную retval (возвра-
 щенное значение), чобы определить,  решил  ли  пользователь
 завершить цикл ввода данных.
      Процедура  DoWait  существует так долго, пока клавиша,
 назначенная услугой KeyDefine в качестве клавиши выхода  не
 будет принята (но перед тем, как действие клавиши будет вы-
 полнено). Если переменная TKAccept установлена в "Ложь", то
 DoWait не прекратит свою работу. Если TKAccept имеет значе-
 ние  "Истина", то DoWait будет покинута перед тем, как кла-
 виша будет принята; клавиша обрабатывается  ПАРАДОКСом  или
 скриптом, который вызвал процедуру DoWait.
      Наиболее важные переменные, которые использует проце-
 дура DoWait включают:
      - TKCanged: Имеет значение "Истина", если текущая ве-
 личина в поле не изменилась во время входа в поле; в обрат-
 ном случае - "Ложь".
      - TKCanged: Используется только процедурой GoodDepart.
      - TKChar: Содержит код последней нажатой пользователем
 клавиши. Обычно передается DoWait, но может быть уста-
 новлена  и  самим  программистом. В процедурах прибытия нет
 задержанных клавиш и они не могут быть установлены.
      - TKAccept: Установлено в "Ложь", если Вы  не  хотите,
 чтобы  символы  в процедуре DoWait проходили через ПАРАДОКС
 (нет соответствуюших процедур прибытия).  Переменная  уста-
 навливается программистом.
      - TKHoldCanvas: Принимает значение "Истина", если ка-
 нва  ПАЛа высвечивалась до нажатия следующей клавиши. Уста-
 навливается процедурой DoWait.
      - TKMessage: Содержит строку, которая выдается пользо-
 вателю в качестве сообщения. Устанавливается программистом.

      Переменные TKCanged, TKChar, и TKAccept имеют  большое
 значение  и Вы должны понимать, какие результаты Вы получите
 используя их в Toolkit'e. Для получения более  под-
 робной информации, см. выше: "Использование переменных про-
 цедурами Toolkit'a".

      Этот  пример  показывает, что Вы должны делать в Вашем
 скрипте перед вызовом DoWait:

      ; следующие действия могут иногда  иметь  место  перед
 применением процедуры DoWait

      READLIB  "toolkit" initwait
                ; 1) вызов процедур из памяти
      initwait("fldspec","keyspec")
                ; 2) определение полей и клавишных процедур

      EDIT "tkentry"
                ; 3) установка режима редактирования для таб-
                ; лиц, находящихся в рабочем пространстве
      PICKFORM "1"

                ; сейчас DoWait перезапускает сама себя
      DoWait("Starting DoWait Entry")
                ; 4) вызов DoWait, если retval=0
      THEN RESET
                ; пользователь отменяет режим редактирования
      ELSE DO_IT!
                ; пользователь нажимает Do_It!
      ENDIF

      Смотрите также:

      - InitWait: Вы должны применять процедуру InitWait пе-
 ред вызовом DoWait.
      -   RecurseWait:   Вы   должны   применять   процедуру
 RecurseWait вместо DoWait, если DoWait уже выполняется.


      EDITMENU.

      Процедура представляет простое меню редактора в стиле
 ПАРАДОКСа.

      Синтаксис: EditMenu()

      Процедура EditMenu не имеет аргументов и не возвращает
 значений,  но  устанавливает  (или  сбрасывает)  переменную
 TKChar.

      Описание: Процедура создает и  высвечивает  на  экране
 меню со следующими услугами:

      Undo  Help  Do_It!  Cancel

      Undo the last edit (отменить последние изменения).

      Оно  содержит  наиболее общие услуги для пользователя,
 которые ему будут необходимы во время цикла  редактирования
 с использованием процедуры DoWait.

      Использование:  Для того, чтобы использовать процедуру
 EditMenu, Вы должны сначала использовать  услугу  KeyDefine
 из  скрипта "toolkit" для определения клавиши [F10] "Menu",
 как специальной.  Таким  образом,  процедура  DoWait  будет
 знать,  что  Вы  хотите запустить EditMenu, всякий раз, как
 нажмете клавишу [F10] "Menu" в процессе ввода данных.
      Все специальные клавиши вызывают одну и ту же процеду-
 ру. Поэтому, если Вы определили  более  одной  специальной
 клавиши, то процедура должна определять, какая клавиша была
 нажата. По умолчанию, имя этой процедуры - SpecialKey.
      Смотрите также "Использование процедуры KeyDefine" для
 того,чтобы узнать каким образом сделать клавишу специальной.

      GETFILE процедура высвечивает на экране файловое меню,
 использующее  маски для определения, какой файл будет выве-
 ден на экран.
      Синтаксис: GetFile (Mask,  Prompt,  Meesage,  Default,
 Required), где:
      Mask  -  строковое  выражение,  используемое для того,
 чтобы выбрать необходимый файл.
      Prompt - строковое  выражение,  содержащее  сообщение,
 которое будет высвечено в верхней строке экрана.
      Message  - строковое выражение, содержащее обьяснение,
 высвечивающееся во второй строке экрана.
      Default - строковое выражение, содержащее  имя  файла,
 выбирается по умолчанию из строки сообщения.
      Required  - логическое выражение, показывающее, должен
 или нет существовать файл перед тем, как он будет выбран.

      Описание: Процедура GetFile высвечивает меню,  показы-
 вающее   имена  файлов,  если  пользователь  нажал  клавишу
 [Enter]. Это похоже на подсказки ПАРАДОКСа для  скриптов  и
 имен таблиц. Процедура написана с использованием команд
 ПАЛа SHOWFILES и SHOWTABLES.
       Mask позволяет Вам определить, какие файлы будут выс-
 вечены  на экране, после того, как пользователь нажмет кла-
 вишу [Enter]. Mask - строка, в которой можно использовать
 знак (*),  определяющая,  какие  файлы  должны быть выбраны
 (как в командах DOS обозначаются любые символы), например:
      *.sc         ; показывает имена всех скриптов
      X*.sc ; показывает имена всех скриптов, первая буква
 которых X.

      C:\\paradox\\myapp\\*.sc  ;  показывает  все скрипты в
 директории \paradox\myapp.

      Процедура GetFile возвращает имя выбранного файла  или
 пусто, если файл не был выбран.
      Примеры:    Этот   оператор   присваивает   переменной
 ScriptName имя выбранного пользователем скрипта.
      Script Name  =  GetFile("*.sc","Script",  введите  имя
 скрипта, который Вы хотите использовать", "" , True).

      Смотри также команды ПАЛа SHOWFILES и SHOWTABLES.

      GETPASSWORD процедура принимает строку от пользователя.
      Синтаксис: GetPassword (Length, Display), где
     Length  -  числовая величина, обозначающая максимальную
 длину введенной строки.
     Display - строка, которая высвечивается всякий раз, как
 нажимается клавиша (это может быть пустая строка, "").
      Описание: Процедура работает также, как команда ACCEPT
 не высвечивая символов, которые вводятся. При вводе пользо-
 вателем каждого символа, при помощи процедуры  GetPassword,
 строка, содержащаяся в параметре Display - высвечивается на
 экране.  Клавиша  [BackSpace]  удаляет  последний введенный
 символ и  одновременное  нажатие  клавиш  [Ctrl][Backspace]
 удаляет всю строку символов введенную до настоящего момента.

      Пример:     "Введите ключевое слово длиной 8 бит"

      UserPassword = GetPassword (8,"x")
      IF UPPER (UserPassword) = "PASSWORD"
      THEN PLAY "App"
      ELSE EXIT
      ENDIF

      INITWAIT  процедура  устанавливает все переменные, ис-
 пользуемые процедурой DoWait, в начальное значение.

      Синтаксис: InitWait (Script1, Script2),
      где Script1 - скрипт спецификации поля, созданный  ус-
 лугой FieldDefine из скрипта с именем toolkit.
          Script2  -  скрипт  спецификации клавиш, созданный
 услугой KeyDefine из скрипта toolkit.

      Описание: InitWait устанавливает  переменные,  которые
 содержат имена процедур и спецификации клавиш, используемые
 процедурой DoWait и процедурами, которые вызываются DoWait.
      Для  того, чтобы создать скрипт, который содержит спе-
 цификации полей и клавиш, запустите скрипт toolkit и  выбе-
 рите услуги FieldDefine и KeyDefine.
      Использование:  Вы  должны  вызвать процедуру InitWait
 перед тем, как использовать процедуру DoWait. Вы можете  ис-
 пользовать  InitWait  более одного раза в скрипте для того,
 чтобы изменить определения ключей и процедур для  процедуры
 DoWait.

      Пример:    fp = "fldprocs"
                 kp = "keyprocs"
                 INITWAIT(fp,kp)

      Смотрите также "Использование "FieldDefine" и "Использо-
 вание  KeyDefine""  для создания скрипта, содержащего аргу-
 менты для процедуры DoWait.


      LOOKUPSELECT - процедура показывает справочную таблицу
 и позволяет пользователю сделать выбор из нее.
      Синтаксис: LookupSelect()
      Процедура не имеет аргументов.  Она  возвращает  Ascii
 код  клавиши, которая была нажата для того, чтобы закончить
 ожидание (либо [Esc], либо Do_It![F2]).

      Описание: Из-за того, что Вы не можете  выполнить  ко-
 манду  WAITTABLE  из  режима  помощи,  вводится  процедура
 LookupSelect. Она позволяет пользователю выбирать из спра-
 вочной таблицы услуги, и работает точно так же, как  и  ко-
 манда WAITTABLE.
      Вместе  с  командой Wait, процедура LookupSelect будет
 возвращать управление пользователю  перед  тем,  как  будет
 принят код нажатой клавиши. Таким образом система будет на-
 ходиться в режиме помощи.

      Пример: Этот пример показывает, что программист должен
 делать для того, чтобы обеспечивать специальной помощью ис-
 пользование  команды Wait, если он хочет, чтобы появилась
 справочная таблица.

      WHILE True
          WAIT TABLE UNTIL "F1", "F2", "Esc"
          IF Retval = "F1"
              THEN SWITCH
                     Case FIELD() = "Cust ID":
                       LookupSelect()
                       IF Retval = TKDo_It!
                         THEN DO_IT!
                         ELSE ESC
                       ENDIF
                     Case FIELD() = "Shipper":
                       ShipperHelp()
                   ENDSWITCH
              ELSE QUITLOOP
          ENDIF
      ENDWHILE

      Смотрите также описание команды Wait.


      NEWFIELD   сигнализирует    процедуре    DoWait    или
 RecurseWait,  о том, что произошел вход в новое поле. В от-
 личие от процедуры ArriveField, NEWFIELD не приводит к  вы-
 зову процедуры прибытия для нового поля.

      Синтаксис: NewField()
      Процедура не имеет аргументов и не возвращает значений.

      Описание:  Когда одна из Ваших процедур приводит к то-
 му, что поле должно быть  покинуто,  некоторые  переменные,
 используемые процедурой DoWait должны быть сброшены.
      Процедура  ArriveField  (см. выше) делает это, отменяя
 все задержанные клавиши и вызывает процедуру  прибытия  для
 нового  поля.  Процедура  NewField, напротив, сигнализирует
 DoWait о том, что поле изменилось  без  отмены  задержанных
 клавиш  или вызова процедуры прибытия для нового поля. Про-
 цедура NewField используется в таких ситуациях, когда  при-
 менение  процедуры  ArriveField после изменения поля невоз-
 можно.
      Пример: Этот пример предполагает, что в текушей таблице
 имеются поля: "Method of Payment" и "Credit Card Namber".

      PROC LeavePayType()
      ; вызов процедуры GoodDepart для выхода из поля "Метод
      платежа"

        IF TKChanged
      ; было ли изменено поле "Метод платежа" при предыдущем
      входе

          THEN IF []="cash" OR []="check"
      ; нуждаемся ли мы в поле "Номер кредитной карточки"

              THEN RIGHT
                  NewField()
      ;  нет,  поэтому говорим DoWait, что мы изменили поля,
         но не отменили задержанные клавиши

                  []="N/A"
      ; заполнение поля

               ENDIF
          TKChar=TKRight
      ; мы хотим перейти к следующему полю
      ; вспомним, что процедура NewField не отменяет нажатых
        пользователем клавиш
        ENDIF
      ENDPROC

      Смотрите также процедуру ArriveField.

      POPUP процедура высвечивает на экране вертикальное ме-
 ню, созданное при помощи SetPopup.
      Синтаксис: Popup (Row, Column,  Number,  Lenght),  где
 Row  и  Column - числовые величины, определяющие позицию на
 экране верхнего левого угла меню.
      Number - числовая величина, показывающая, сколько меню
 Вы хотите высветить.
      Length - числовая величина, показывающая число  услуг,
 высвечиваемых за один раз (меню "прокручивается", если име-
 ется  больше  услуг,  чем  позволяет параметр Length). Если
 Length больше, чем число предоставляемых услуг, меню  будет
 занимать больше места, чем необходимо для перечня услуг.

      Описание: Процедура высвечивает меню, созданное проце-
 дурой SetPopup. Вы должны ввести координаты левого верхнего
 угла меню (горизонтальные координаты 0-79, вертикальные ко-
 ординаты 0-24). Вы также должны определить параметр Length,
 который определяет максимальное число пунктов, изображаемое
 одновременно  во всем блоке меню.
     Процедура  возвращает пункт меню, выбранный пользовате-
 лем. Если пользователь не произвел выбор, то она возвращает
 пустую величину.

      Пример: Этот пример высвечивает "меню"  пассажиров  на
 морской  рейс, пока пользователь не нажал клавишу [Esc] или
 не сделал нужного выбора.

      PROC ShipViaMenu()
      ; предположим, что мы находимся в поле "ShipVia"

        Popup(2,37,1,4))
      ; показ меню (4 выбора одновременно)

        IF NOT ISBLANK(retval)
           THEN []=retval
      ; присвоить выбор к полю

            TKChar=TKRight
            TKAccept=True
      ; нажмите клавишу перемещений для того, чтобы  пользо-
        ватель покинул поле и убедитесь в том, что процедура
        DoWait получит код зтой клавиши

        ENDIF
      ENDPROC

      Смотрите также процедуру SetPopup.

      RECURSEWAIT - версия процедуры DoWait, которая  должна
 использоваться, когда процедура DoWait уже активна.
      Синтаксис:  RecurseWait  (String,  ProcedureName), где
 String  -  сообщение,  высвечивающееся,   когда   процедура
 RecurseWait берет управление вводом данных.
      ProcedureName  - строка, содержащая имя процедуры, ко-
 торая загружает соответствующие величины для скриптов  спе-
 цификации полей и клавиш.
      RecueseWait  - присваивает системной переменной retval
 код последней нажатой пользователем клавиши, еслли  пользо-
 ватель вводил данные в таблицу в течении DoWait.

      Описание:  Процедура  RecurseWait  - упрощенная версия
 процедуры Dowait и используется, когда процедура DoWait уже
 активна. Она работает также, как и процедура DoWait.
      В процедуре RecurseWait нет необходимости использовать
 те же таблицы, формы, объекты или спецификации клавиш и по-
 лей, которые вызвала DoWait. Это позволяет  вводить  данные
 во  многие таблицы, как в случае, если пользователь, запол-
 няющий таблицу "Orders" (заказы), решает заполнить информа-
 цию о заказчике, находящуюся в таблице "Cust".

      Пример:

      PROC PlaySpecs()
          Play "fildspec2"
      ; загрузить новую спецификацию полей

          PLAY "keyspec2"
      ; загрузить новую спецификацию клавиш

      ENDPROC
      ; сохранить изменения?

      RecurseWait("",PlaySpecs)
      IF retval <> TKDo_It!
          THEN DO_IT!
      ; да, сохранить изменения в таблице

          ELSE QUITLOOP
      ; возврат

      ENDIF

      Смотрите также процедуру DoWait.

      SETKEYCODES - устанавливает  переменные,  используемые
 совместно с DoWait.

      Синтаксис: SetKeyCodes ()
      Процедура не имеет аргументов и не возвращает значения
 (хотя устанавливает переменные).

      Описание:  Процедура устанавливает переменные, которые
 Вы можете использовать  для  доступа  к  расширенным  кодам
 Ascii.  Все переменные, устанавливаемые этой процедурой на-
 чинаются с букв TK, за которыми следует  ключевое  имя  от-
 дельных клавиш (такие, как TKDel, TKPgUp и т.д.).
      Программисту  нет необходимости запоминать целый набор
 расширенных Ascii кодов, для создания программ ввода данных.
      Переменные делают программы удобочитаемыми и  удобопо-
 нимаемыми.

      Использование: Вы должны вызвать процедуру SetKeycodes
 перед  тем, как обратитесь к любой из переменных. Процедура
 может быть вызвана всего один раз в начале Вашего  приложе-
 ния, а не в конце цикла ввода данных.

      Пример:

      Proc InitApp()
          Readlib "Toolkit" SetKeycodes
          SetKeycodes
          Release Procs SetKeycodes

      ; другие коды инициализации

      ENDPROC

      Смотри также "Использование процедуры "Prepare Final".

      SETPOPUP  процедура  выбирает данные из одной или нес-
 кольких таблиц и подготавливает их для использования в вер-
 тикальном меню.

      Синтаксис: SetPopup (TableNameList),
      где TableNameList - список таблиц, каждая  из  которых
 содержит данные, которые войдут в меню.
      Процедура SetPopup не возвращает значения.

      Описание:  Для каждой таблицы из списка TableNameList,
 процедура SetPopup преобразует величины, находящиеся в пер-
 вом столбце, в меню, используемое процедурой Popup.  Данные
 в первом поле таблицы могут быть в любом виде и любого раз-
 мера; Процедура SetPopup автоматически вычислит размер, не-
 обходимый для меню. Каждому меню присваивается номер, соот-
 ветствующий номеру таблицы в списке TableNameList.

      Примеры: Если первое поле таблицы parts содержит запи-
 си Bolt, Nut и Lockwasher, следующая команда готовит верти-
 кальное  меню  с  тремя пунктами и шириной 10 (максимальная
 длина записи Lockwasher):

      SetPopup("parts")
      ; для того,чтобы высветить меню в верхнем левом углу
      ; экрана, используем процедуру:Popup(0,0,1)

      Смотрите также процедуру Popup.

      TKDEBUG сообшает Вам о любых обстоятельствах, в  кото-
 рых процедура DoWait не знает, какое поле является текущим.

      Синтаксис: TKDebug()
      Процедура не имеет аргументов и не возвращает значений.

      Описание:  Когда  процедуру  TKDebug поместят на место
 первой  команды  в  любую  процедуру,  вызываемую   DoWait,
 TKDebug высвечивает на экране сообщение, в том случае, ког-
 да  DoWait  не  знает, в каком поле находится курсор, когда
 вызывается процедура. Это может случиться, если поле  поки-
 нуто  и ни процедура ArriveField ни NewField не была вызва-
 на. в любом другом случае TKDebug не действует.

      Использование:
      TKDebug предназначена для использования в приложениях,
 находящихся на стадии  разработки.  Все  операторы  TKDebug
 должны  быть  удалены после отладки, т.к. эта процедура за-
 медляет работу Ваших приложений. TKDebug может быть  удален
 автоматически при помощи подсистемы PrepareFinal.
      Пример: Процедура BadDepart удалила последний символ:

      PROC BDForgetKey()
            TKDebug()
          TKAccept = False
      ENDPROC

      Смотрите также использование подсистемы PrepareFinal.

