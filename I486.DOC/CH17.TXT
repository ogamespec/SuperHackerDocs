
Глава 17. Операции с плавающей точкой
----------------------------------------------------------------

Команды с плавающей точкой процессора i486(TM) можно
сгруппировать в шесть функциональных классов:

- Команды передачи данных

- Нетрансцендентные команды

- Команды сравнения

- Трансцендентные команды

- Команды с константами

- Управляющие команды

В этой главе все классы команд описаны как набор средств,
доступных для программиста, работающего на ассемблере
ASM386/486. Для детального ознакомления с форматами,
кодированием и временем выполнения команд обратитесь к описанию
набора команд в Главе 26.

Математический сопроцессор 387(TM) и модуль обработки операций с
плавающей точкой процессора i486 поддерживают большее число
команд, чем математические сопроцессоры 8087 и 80287. Некоторые
системы на основе процессора 386 DX используют математический
сопроцессор 80287. Для того, чтобы узнать, представлены ли в
системе математические сопроцессоры 8087 и 80287 и возможно ли
использование новых команд, обратитесь к примеру на Рисунке 16-
4.

17.1 Операнды источника и назначения
----------------------------------------------------------------

Обычно команда с плавающей точкой имеет один или два операнда,
которые выбираются из регистрового стека модуля обработки
операций с плавающей точкой или из памяти. Многие команды, такие
как FSIN, автоматически работают с элементом в вершине
регистрового стека модуля обработки операций с плавающей точкой.
Другие команды позволяют или требуют, чтобы программист явно
закодировал операнд или операнды в соответствии с мнемоникой
операции. Еще одна разновидность команд принимает один явный
операнд и один неявный операнд (обычно элемент в вершине стека
модуля обработки операций с плавающей точкой).

Не зависимо от того, определены ли операнды программистом или
подразумеваются по умолчанию, операнды команд с плавающей точкой
делятся на два основных типа: операнд-источник и операнд
назначения (приемник). Операнд-источник представляет для
команды входную информацию и не меняется после выполнения.
Даже когда команда переводит операнд-источник из одного формата
в другой (например, вещественное в целое), команда работает во
внутренней области для того, чтобы предотвратить изменение
исходного операнда. Операнд назначения также может предоставлять
команде некоторую входную информацию, но при выполнении, однако,
команда выдает результат в операнд назначения, меняя его
предыдущее содержание.

Многие команды позволяют кодировать операнды различными путями.
Например, команда FADD (вещественное сложение) может быть
записана либо без операндов, либо только с операндом-источником,
либо с исходным и принимающим операндами. Когда указаны оба
операнда, и операнд-приемник и операнд назначения, то
операнд назначения должен предшествовать операнду-источнику в
командной строке и оба должны быть взяты из стека модуля
обработки операций с плавающей точкой.

Операнды из памяти могут быть закодированы любым способом
адресации, предоставляемым байтом ModR/M. Для того, чтобы
ознакомиться с этими методами (БАЗА = (ИНДЕКС x МАСШТАБ) +
СМЕЩЕНИЕ), обратитесь к Главе 2. Команды с плавающей точкой с
операндами из памяти либо читают из памяти, либо пишут в память.
Ни одна команда с плавающей точкой не делает то и другое
одновременно. Для детального ознакомления с каждой командой,
включая способы возможных кодирований, обратитесь к справочной
информации в Главе 26.

17.2 Команды передачи данных
----------------------------------------------------------------

Эти команды (представленные в Таблице 17-1) занимаются передачей
данных между регистрами стека и между вершиной стека и памятью.
Любой из семи типов данных может быть переведен в расширенный
вещественный формат и загружен в стек с помощью простой
команды. Таким же образом можно сохранить их в памяти. Команды
передачи данных автоматически обновляют слово признака
модуля обработки операций с плавающей точкой для того, чтобы
отразить информацию о том, пуст или полон регистр после
очередной команды.

             Таблица 17-1. Команды Передачи Данных

┌────────────────────┬──────────────────┬───────────────────────┐
│    Вещественный    │       Целый      │Упакованный Десятичный │
├────────────────────┼──────────────────┼───────────────────────┤
│ FLD  Загрузить     │ FILD  Загрузить  │ FBLD  Загрузить Упако-│
│      Вещественное  │       Целое      │       ванное Десятич- │
│                    │                  │       ное             │
│ FST  Сохранить     │ FIST  Сохранить  │                       │
│      Вещественное  │       Целое      │                       │
│ FSTP Сохранить Ве- │ FISTP Сохранить  │ FBSTP Загрузить Упако-│
│      щественное и  │       Целое и    │       ванное Десятич- │
│      Взять из Стека│       Взять из   │       ное и Взять из  │
│                    │       Стека      │       Стека           │
│ FXCH Заменить      │                  │                       │
│      Регистры      │                  │                       │
└────────────────────┴──────────────────┴───────────────────────┘

17.3 Нетрансцендентные команды
----------------------------------------------------------------

Набор нетрансцендентных команд предоставляет изобилие вариаций
сложения, вычитания, умножения и деления, а также некоторые
другие полезные функции. Диапазон этих команд изменяется от
простой команды взятия абсолютного значения до команд, которые
проводят точное деление по модулю, округление вещественных чисел
до целых и масштабируют величины степенью двух. На Таблице 17-2
показаны нетрансцендентные команды, помимо основной арифметики.

Основные арифметические команды (сложение, вычитание, умножение
и деление) разработаны для того, чтобы разрабатывать эффективные
алгоритмы. Практически, они позволяют программисту обращаться к
памяти также легко, как и к регистровому стеку модуля обработки
операций с плавающей точкой. На Таблице 17-3 приведены
возможные формы команды/операнда для основной арифметики. В
добавок к основным четырем командам существуют "обратное"
вычитание и деление, которые устраняют необходимость постоянных
обменов между ST(0) и ST(1). Разнообразность форм команд и
операндов дает программисту необычайную гибкость:

- Операнды могут располагаться в регистрах или в памяти.

- Результаты могут быть выданы в выбранные регистры.

- Операнды могут быть данными различных типов: расширенное
  вещественное, двойное вещественное, простое вещественное,
  короткое целое или целое слово. При этом модулем обработки
  операций с плавающей точкой производится автоматический
  перевод в расширенный вещественный формат.

            Таблица 17-2. Нетрансцендентные Команды
                (Кроме Основных Арифметических)

┌───────────┬───────────────────────────────────────────────────┐
│ Мнемоника │                     Операция                      │
├───────────┼───────────────────────────────────────────────────┤
│           │                                                   │
│ FSQRT     │         Извлечение Квадратного Корня              │
│           │                                                   │
│ FSCALE    │         Масштабирование                           │
│           │                                                   │
│ FXTRACT   │         Выделение Порядка и Мантиссы              │
│           │                                                   │
│ FPREM     │         Частичный Остаток                         │
│           │                                                   │
│ FPREM1 *  │         Стандарт IEEE Частичный Остаток           │
│           │                                                   │
│ FRNDINT   │         Округление до Целого                      │
│           │                                                   │
│ FABS      │         Абсолютное Значение                       │
│           │                                                   │
│ FCHS      │         Смена Знака                               │
│           │                                                   │
└───────────┴───────────────────────────────────────────────────┘

 * Недоступно для математического сопроцессора 80287/8087.


    Таблица 17-3. Основные Арифметические Команды и Операнды

┌───────────────────────────┬──────────┬────────────────────────┐
│      Вид Команды          │   Форма  │    Формы Операндов:    │
│                           │ Мнемоники│   Приемник, Источник   │
├───────────────────────────┼──────────┼────────────────────────┤
│                           │          │                        │
│ Классический Стек         │    Fop   │{ST(1),ST}              │
│                           │          │                        │
│ Классический Стек, допол- │          │                        │
│ нительная команда POP     │    FopP  │{ST(1),ST}              │
│                           │          │                        │
│ Регистр                   │    Fop   │ST(i),ST или ST,ST(i)   │
│                           │          │                        │
│ Регистр, Выборка из Стека │    FopP  │ST(i),ST                │
│                           │          │                        │
│ Память для вещественных   │    Fop   │{ST} обычное веществен- │
│                           │          │     ное/двойное вещес- │
│                           │          │     твенное            │
│                           │          │                        │
│ Память для целых          │    FIop  │{ST} целое слово/корот- │
│                           │          │     кое целое          │
│                           │          │                        │
└───────────────────────────┴──────────┴────────────────────────┘

ОБРАТИТЕ ВНИМАНИЕ:
В скобках ({ }) содержатся неявные операнды; они не закодированы,
но поддерживаются ассемблером.

op = ADD   DEST ── DEST + SRC
     SUB   DEST ── ST - Другой Операнд
     SUBR  DEST ── Другой Операнд - ST
     MUL   DEST ── DEST x SRC
     DIV   DEST ── ST / Другой Операнд
     DIVR  DEST ── Другой Операнд / ST

Пять основных видов команд могут быть использованы со всеми
шестью командами, как показано в Таблице 17-3. Форма
классического стека может быть использована для того, чтобы
сделать модуль обработки операций с плавающей точкой подобно
машине с классическим стеком. Никакие операнды не нужны для этой
формы, только мнемоника команды. Модуль обработки операций с
плавающей точкой берет исходный операнд из вершины стека (ST), а
принимающий из следующего элемента стека (ST(1)). После
выполнения вычислений, результат возвращается в ST(1), а затем
выталкивается из стека ST, перемещая при этом результат на свое
место.

Регистровая форма является усовершенствованной формой
классического стека. При этом программист определяет вершину
стека как один операнд и любой регистр как другой операнд.
Кодирование вершины стека как операнда назначения предоставляет
удобный способ для доступа к константам из вершины стека, если
они находятся где-либо в стеке. Операнд назначения не должен
быть всегда ST. Основные двухоперандные команды позволяют
использовать другой регистр в качестве приемника. Использование
ST как исходного операнда позволяет, например, прибавлять
вершину стека к регистру, используемому как счетчик цикла.

Часто операнд в вершине стека необходим для одной команды и в
дальнейшем не используется для последующих вычислений. Форма
выталкивания регистра может быть использована для того, чтобы
взять вершину стека как исходный операнд и затем отбросить его,
вытолкнув из стека. При кодировании операндов ST(1) и ST вместе
с мнемоникой выталкивания регистра эквивалентно классическому
стеку: вершина выталкивается, а результат остается в новой
вершине стека.

Две формы памяти повышают гибкость нетрансцендентных команд.
Они разрешают непосредственно использовать как операнд-источник
двоичные целые или вещественные числа из памяти. Это полезно в
ситуациях, когда операнды используются не так часто и нет смысла
держать их все время в регистрах. Обратите внимание, что любой
метод адресации памяти может быть использован для того, чтобы
определить эти операнды так, чтобы они были бы элементами
массивов, структур или других типов организации данных также,
как и простыми скалярными величинами.

17.4 Команды сравнения
----------------------------------------------------------------

Команды этого класса позволяют сравнивать числа всех
поддерживаемых вещественных и целых типов данных. Каждая из этих
команд (Таблица 17-4) анализирует элемент в вершине стека, часто
по отношению к другому операнду, и в результате выдает код
условия в слово состояния (флаги C0, C2 и C3).

Основными командами являются сравнение, тестирование (сравнение
с нулем) и проверка (на тип, знак и нормализацию). Особые формы
команды сравнения предназначены для оптимизации алгоритмов,
разрешая прямое сравнение с двоичными целыми и вещественными
числами в памяти также, как и выталкивание из стека после
сравнения.

                Таблица 17-4. Операции Сравнения

┌───────────┬───────────────────────────────────────────────────┐
│ Мнемоника │                     Операция                      │
├───────────┼───────────────────────────────────────────────────┤
│           │                                                   │
│ FCOM      │ Сравнить Вещественные                             │
│           │                                                   │
│ FCOMP     │ Сравнить Вещественные и Взять из Стека            │
│           │                                                   │
│ FCOMPP    │ Сравнить Вещественные и Дважды Взять из Стека     │
│           │                                                   │
│ FICOM     │ Сравнить Целые                                    │
│           │                                                   │
│ FICOMP    │ Сравнить Целые и Взять из Стека                   │
│           │                                                   │
│ FTST      │ Тестирование                                      │
│           │                                                   │
│ FUCOM*    │ Сравнение Неупорядоченных Вещественных            │
│           │                                                   │
│ FUCOMP*   │ Сравнить Неупорядоченные Вещественные и Взять из  │
│           │ Стека                                             │
│           │                                                   │
│ FUCOMPP*  │ Сравнить Неупорядоченные Вещественные и Взять из  │
│           │ Стека Дважды                                      │
│           │                                                   │
│ FXAM      │ Проверка                                          │
│           │                                                   │
└───────────┴───────────────────────────────────────────────────┘

 * Недоступно для математического сопроцессора 80287/8087.

Команда FSTSW AX (сохранить слово состояния) может быть
использована после сравнения для того, чтобы передать код
условия в регистр AX для просмотра. Команда TEST рекомендуется
для использования флагов модуля обработки операций с плавающей
точкой для управления условным ветвлением. Сначала проверяется,
получилось ли в результате сравнения, что числа неупорядочены.
Это может случится, если один операнд является NaN. Сравните
содержимое регистра AX с константой 0400H; флаг ZF будет очищен
(флаг нуля регистра EFLAGS), если сравнение дало
неупорядоченность, и установлен в противном случае. Теперь можно
использовать команду JNZ для того, чтобы передать управление
(при необходимости) программе, которая обрабатывает случай
неупорядоченных операндов. Отфильтровав случай неупорядоченных
операндов, снова сравните содержимое регистра AX с
соответствующей константой из Таблицы 17-5, а затем используйте
соответствующую условную ветвь.

Нет необходимости все время отфильтровывать случай
неупорядоченности при использовании этого алгоритма для условных
переходов. Если программное обеспечение было тщательно
оттестировано и включает периодические проверки результата на
QNaN (как рекомендовано в Главе 16), то совершенно не
обязательно проверять случай неупорядоченности всякий раз после
сравнения.

Кроме представленых в группе операций сравнения, некоторые
другие команды могут обновлять код условия. Для того, чтобы
быть уверенным, что слово состояния не было случайно изменено,
сохраняйте его сразу же после команды сравнения.

17.5 Трансцендентные команды
----------------------------------------------------------------

Команды этого класса (Таблица 17-6) производят занимающие
большое количество времени вычисления для всех обычных
тригонометрических, обратных тригонометрических,
гиперболических, обратных гиперболических, логарифмических и
степенных функций. Трансцендентные команды работают с верхними
одним или двумя элементами стека и возвращают результат обратно
в стек. Тригонометрические команды предполагают, что их
аргументы выражены в радианах. Логарифмические и степенные
функции работают по основанию 2.

Результаты трансцендентных команд очень точны. Абсолютное
значение относительной ошибки вычисления трансцендентной функции
гарантированно меньше чем 2**(-62). (Относительная ошибка - это
отношение между абсолютной ошибкой и точным значением.)

   Таблица 17-5. Константы Сравнения для Условного Ветвления

┌────────────────────┬────────────────────┬─────────────────────┐
│      Порядок       │     Константа      │      Переход        │
├────────────────────┼────────────────────┼─────────────────────┤
│                    │                    │                     │
│    ST > Операнд    │       4500H        │         JZ          │
│                    │                    │                     │
│    ST < Операнд    │       0100H        │        JNZ          │
│                    │                    │                     │
│    ST = Операнд    │       4000H        │        JNZ          │
│                    │                    │                     │
│    Неупорядочено   │       0400H        │        JNZ          │
│                    │                    │                     │
└────────────────────┴────────────────────┴─────────────────────┘

Некоторые тригонометрические функции принимают практически
неограниченный диапазон значений, в то время как другие
трансцендентные команды требуют, чтобы аргументы были более
сжаты в диапазоне. Команды FPREM или FPREM1 можно использовать
для того, чтобы преобразовать допустимый операнд периодической
функции к требуемому диапазону. Программные продукты, имеющие
начальные и конечные приготовления, могут быть использованы для
сокращения аргументов до ожидаемого диапазона и, если
необходимо, для отладки результата, чтобы он соответствовал
начальным аргументам. Описание команд в справочной части Главы
26 дано вместе с разрешенным диапазоном операндов для каждой
команды.

             Таблица 17-6. Трансцендентные Команды
┌───────────┬───────────────────────────────────────────────────┐
│ Мнемоника │                    Команды                        │
├───────────┼───────────────────────────────────────────────────┤
│           │                                                   │
│  FSIN*    │    Синус                                          │
│           │                                                   │
│  FCOS*    │    Косинус                                        │
│           │                                                   │
│  FSINCOS* │    Синус и Косинус                                │
│           │                                                   │
│  FPTAN**  │    Тангенс                                        │
│           │                                                   │
│  FPATAN   │    Арктангенс от ST(1) / ST                       │
│           │                                                   │
│           │     x                                             │
│  F2XM1**  │    2 - 1; X находится в ST                        │
│           │                                                   │
│  FYL3X    │    Y x log X; Y находится ST, X - в ST            │
│           │           2                                       │
│           │                                                   │
│  FYL2XP1  │    Y x log (X+1); Y находится ST, X - в ST        │
│           │           2                                       │
└───────────┴───────────────────────────────────────────────────┘

 *  Недоступно для математического сопроцессора 80287/8087.

 ** Операнды из расширенного диапазона математического сопроцес-
    сора 80287/8087

Когда аргумент тригонометрической функции попадает в диапазон
допустимых значений, он автоматически сокращается
соответствующим делением на 2Пи (при точности в 66 битов),
используя для этого точно такой же механизм как и команды
FPREM и FPREM1. Значение числа Пи, используемое в автоматическом
сокращении, выбирается так, чтобы гарантировать, что не будет
потери значимости операнда, представленного в определенном
диапазоне. Внутреннее значение числа Пи:

4 * 0.C90FDAA2 2168C234 C H

Программа может использовать явное значение для числа Пи в
вычислениях, результат которых будет использоваться как аргумент
для дальнейших тригонометрических функций. В таких случаях
(например, результат явного сокращения тригонометрического
операнда выходит за рамки определенного диапазона) значение,
используемое для Пи, должно быть такое же как полное встроенное
66-ти битовое Пи. Это застрахует от того, что результаты будут
последовательно сокращаться при обращении к следующей
тригонометрической функции. Число Пи в 66 битов не может быть
представлено как расширенное вещественное значение, так как оно
должно кодироваться как два или более чисел. Обычное решение -
представить число Пи как сумму верхнего Пи, которое содержит 33
высшие значащие бита, и нижнего Пи, которое содержит 33 низшие
значащие бита. При использовании этого двухчастного Пи, все
вычисления следут выполнять над каждой частью отдельно и
результаты складывать только в конце.

Трудностей установления последовательных значений Пи для
сокрашаемого аргумента можно избежать либо применением
тригонометрических функций только к аргументам из диапазона
механизма автоматического сокращения, либо выполнением всех
сокращений аргумента (до значения меньшего чем Пи/4)
непосредственно в программном обеспечении.

17.6 Операции с константами
----------------------------------------------------------------

Каждая из этих команд (Таблица 17-7) заносит общеиспользуемые
константы в стек. (ST(7) должен быть пуст для того, чтобы
избежать исключения.) Значения имеют полную
расширенную точность (64 бита) и достигают примерно 19-ти
десятичных цифр. Так как расширенная вещественная константа
занимает 10 байт памяти, то команды с константами, которые
имеют длину только 2 байта, сохраняют информацию и повышают скорость
выполнения, упрощая вдобавок программирование.

              Таблица 17-7. Команды с Константами

┌───────────────────────────────┬───────────────────────────────┐
│           Мнемоника           │          Команды              │
├───────────────────────────────┼───────────────────────────────┤
│                               │                               │
│            FLDZ               │      Загрузить + 0.0          │
│                               │                               │
│            FLD1               │      Загрузить + 1.0          │
│                               │                               │
│            FLDPI              │      Загрузить Пи             │
│                               │                               │
│            FLDL27             │      Загрузить log 10         │
│                               │                   2           │
│            FLDL2E             │      Загрузить log e          │
│                               │                   2           │
│            FLDLG2             │      Загрузить log  2         │
│                               │                   10          │
│            FLDLN2             │      Загрузить log 2          │
│                               │                   e           │
└───────────────────────────────┴───────────────────────────────┘

Константы, используемые этими командами, во внутреннем
представлении сохраняются в более точном формате, чем
расширенный вещественный. При загрузке констант модуль обработки
операций с плавающей точкой округляет более точные внутренние
константы в соотвестствии с битом RC (управление округлением)
слова состояния. Однако несмотря на это округление, исключения
точности не генерируется (для поддержки совместимости). Когда
устанослено округление до ближайшего, модуль обработки операций
с плавающей точкой выдает точно такие же константы, какие
выдавались бы арифметическими сопроцессорами 8087 и 80287.

17.7 Управляющие команды
----------------------------------------------------------------

Управляющие команды модуля обработки операций с плавающей
точкой показаны в Таблице 17-8. Команда FSTSW обычно
используется для условного ветвления. Остальные команды как
правило не используются в вычислениях, они управляют действиями
модуля обработки операций с плавающей точкой на системном
уровне. Эти действия включают в себя инициализацию модуля
обработки операций с плавающей точкой, обработку численных
исключений и переключение задач.

              Таблица 17-8. Управляющие Инструкции

┌─────────────────────┬─────────────────────────────────────────┐
│      Мнемоника      │              Операция                   │
├─────────────────────┼─────────────────────────────────────────┤
│                     │                                         │
│ FINIT/FNINIT        │ Инициализация FPU                       │
│                     │                                         │
│ FLDCW               │ Загрузка Управляющего Слова             │
│                     │                                         │
│ FSTCW/FNSTCW        │ Сохранить Управляющее Слово             │
│                     │                                         │
│ FSTSW/FNSTSW        │ Сохранить Слово Состояния               │
│                     │                                         │
│ FSTSW AX/FNSTSW AX* │ Сохранить Слово Состояния в Регистре AX │
│                     │                                         │
│ FCLEX/FNCLEX        │ Сброс Исключения                        │
│                     │                                         │
│ FSTENV/FNSTENV      │ Сохранить Окружение                     │
│                     │                                         │
│ FLDENV              │ Загрузить Окружение                     │
│                     │                                         │
│ FSAVE/FNSAVE        │ Сохранить Состояние                     │
│                     │                                         │
│ FRSTOR              │ Восстановить Состояние                  │
│                     │                                         │
│ FINCSTP             │ Увеличить Указатель Вершины Стека       │
│                     │                                         │
│ FDECSTP             │ Уменьшить Указатель Вершины Стека       │
│                     │                                         │
│ FFREE               │ Очистить Регистры                       │
│                     │                                         │
│ FNOP                │ Нет Операция                            │
│                     │                                         │
│ FWAIT               │ Отчет об ошибках FPU                    │
│                     │                                         │
└─────────────────────┴─────────────────────────────────────────┘

* Недоступно для математического сопроцессора 8087.

Как показано в Таблице 17-8, конкретные команды имеют
альтернативную мнемонику. Команды, которые инициализируют
модуль обработки операций с плавающей точкой, снимают
исключения или сохраняют (полностью или частично) операционную
среду модуля обработки операций с плавающей точкой, можно
представить в двух видах:

- Ожидать - эта мнемоника начинается с одного F, например FSTSW.
  Этот вид проверяет на немаскируемые численные исключения.

- Не ожидать - эта мнемоника начинается с FN, например FNSTSW.
  Этот вид игнорирует немаскируемые численные исключения.

Когда управляющие команды кодируются с использованием мнемоники
"не ожидать", ассемблер ASM386/486 не выполняет ESC-команду
перед команду WAIT (ожидать), а процессор не тестирует условие
возникновения ошибки при команде с плавающей точкой перед
выполнением управляющей команды.

В Таблице 17-8 показаны не только команды вида "не ожидать".
Все остальные команды с плавающей точкой автоматически
синхронизируются процессором. Все операнды передаются перед тем,
как следующая команда начнет выполняться. Из-за этой
автоматической синхронизации перед неуправляющими командами с
плавающей точкой не надо выполнять команду WAIT для того, чтобы
все было корректно.

Синхронизация исключений возложена на команду WAIT. Так как
модуль обработки операций с плавающей точкой и модуль обработки
целочисленных операций работают параллельно, то в случае
исключения с плавающей точкой возможно, что процессор будет
использовать информацию, необходимую для исправления этой
ситуацией, перед тем, как вызвать обработчик этого исключения.
Применение команды WAIT или FWAIT в надлежащем месте может
предотвратить это. Смотрите Главу 18 для дальнейших пояснений.

Следует также обратить внимание на то, что команды FENI и
FDISI сопроцессора 8087 и команда FSETPM сопроцессора 80287
не реализуют никаких функций в процессоре i486. Если эти коды
операций обнаруживаются в потоке команд, то процессор i486 не
выполняет каких-либо специальных действий и не меняет никаких
внутренних состояний. В Главе 25 приведено более полное описание
различий между командами с плавающей точкой процессора i486 и
арифметических сопроцессоров 8087, 80287 и 387 DX.

