
Глава 16. Особые вычислительные ситуации
----------------------------------------------------------------

Кроме представления положительных и отрицательных чисел, форматы
числовых данных можно использовать и для описания некоторых
особых значений. Эти специальные значения дают дополнительную
гибкость, но большинству пользователей нет необходимости
понимать их, чтобы успешно пользоваться вычислительными
возможностями процессора i486. В этом разделе описаны особые
значения, которые могут всплыть в конкретных ситуациях, и
показано назначение каждого из них. Числовые исключения описаны
специально для тех, кто пишет обработчики исключений и кому
интересно исследовать пределы вычислительных возможностей
процессора i486.

Материал, изложенный в этом разделе, будет в основном интересен
программистам, занимающимся созданием обработчиков исключений.
Остальные читатели могут бегло пролистать этот раздел.

При обсуждении особых вычислительных ситуаций полезно различать
арифметические команды и неарифметические команды.
Неарифметические команды это те, которые не имеют операндов или
передают операнды без особых изменений. Арифметические
команды это те, которые производят значимые изменения своих
операндов. В Таблице 16-1 приведены определения этих двух
классов команд.

16.1 Особые числовые значения
----------------------------------------------------------------

Форматы числовых данных процессора i486 позволяют кодировать
множество особых значений в добавок к обыкновенным целочисленным
и вещественным данным, которые являются результатами нормальных
вычислений. Эти особые значения имеют некоторую значимость и
могут нести какую-либо информацию о вычислениях или операндах,
которые производят это значение. Ниже приведен список типов
особых значений:

- Денормальные вещественные числа

- Нули

- Положительная и отрицательная бесконечность

- NaN (не-число)

- Неопределенность

- Неподдерживаемые форматы

В следующем разделе объясняется происхождение и значимость
каждого из этих особых значений. На иллюстрациях от Таблицы 16-6
до Таблицы 16-9 в конце этого раздела показано, как каждое из
этих особых значений кодируется для каждого типа числовых
данных.

16.1.1 Денормальные вещественные числа
----------------------------------------------------------------

Обычно процессор i486 хранит ненулевые вещественные числа в
нормализованной форме с плавающей точкой. То есть, бит
(начальный) целой части мантиссы всегда есть единица. (Смотрите
Главу 15 о форматах операнда.) Этот бит явно хранится в
расширенном формате и неявно предполагается единицей (1) в
простом и двойном форматах. Так как начальные нули подавляются,
то нормализованный вид позволяет хранить максимальное число
значащих цифр в мантиссе данной ширины.

    Таблица 16-1. Арифметические и Неарифметические Команды
┌───────────────────────────────┬───────────────────────────────┐
│  Неарифметические Команды     │   Арифметические Команды      │
├───────────────────────────────┼───────────────────────────────┤
│                               │                               │
│    FABS                       │   F2XM1                       │
│    FCHS                       │   FADD (P)                    │
│    FCLEX                      │   FBLD                        │
│    FDECSTP                    │   FBSTP                       │
│    FFREE                      │   FCOMP(P)(P)                 │
│    FINCSTP                    │   FCOS                        │
│    FINIT                      │   FDIV(R)(P)                  │
│    FLD   (регистр-в-регистр)  │   FIADD                       │
│    FLD   (расширенный формат  │   FICOM(P)                    │
│           из памяти)          │   FIDIV(R)                    │
│    FLD   константа            │   FILD                        │
│    FLDCW                      │   FIMUL                       │
│    FLDENV                     │   FIST(P)                     │
│    FNOP                       │   FISUB(R)                    │
│    FRSTOR                     │   FLD     (перевод форматов)  │
│    FSAVE                      │   FMUL(P)                     │
│    FST(P) (регистр-в-регистр) │   FPATAN                      │
│    FSTP   (расширенный формат │   FPREM                       │
│            в память)          │   FPREM1                      │
│    FSTCW                      │   FPTAN                       │
│    FSTENV                     │   FRNDINT                     │
│    FSTSW                      │   FSCALE                      │
│    FWAIT                      │   FSIN                        │
│    FXAM                       │   FSINCOS                     │
│    FXCH                       │   FSQRT                       │
│                               │   FST(P)  (перевод форматов)  │
│                               │   FSUB(R)(P)                  │
│                               │   FTST                        │
│                               │   FUCOM(P)(P)                 │
│                               │   FXTRACT                     │
│                               │   FYL2X                       │
│                               │   FYL2XP1                     │
│                               │                               │
└───────────────────────────────┴───────────────────────────────┘

Когда величина числа становится близкой к нулю, то уже нельзя
использовать нормализованный вид с плавающей точкой для того,
чтобы выразить это значение точно. Термин "маленькое" будет
использоваться в дальнейшем для того, чтобы точно определить
значения, требующие особой обработки. Говорят, что число R
является маленьким, если -2**(Emin) < R < 0 или 0 < R <
+2**(Emin). (Как определено в Главе 15, Emin равно -126 для
простого формата, -1022 для двойного формата и -16382 для
расширенного формата.) Другими словами, ненулевое значение
является маленьким, если его порядок имеет слишком большую
отрицательную величину для того, чтобы быть сохраненным в
принимающем формате.

Для того, чтобы выходить из таких ситуаций, процессор i486 может
хранить и оперировать денормализованными вещественными числами,
то есть числами, мантиссы которых содержат один или более
начальных нулей. Денормальные числа как правило возникают, когда
в результате вычислений получается значение, являющееся
маленьким.

Денормальные значения имеют следующие свойства:

- Несмещенный порядок с плавающей точкой хранится в его
  наименьшем значении (ноль)

- Целый бит мантиссы (явный или неявный) является нулем

Начальные нули денормального значения позволяют представлять
меньшие числа с некоторой приемлемой потерей точности (число
значащих разрядов сокращается из-за начальных нулей). В
стандартных алгоритмах такие маленькие значения в большинстве
случаев генерируются как промежуточные, а не конечные
результаты. Использование расширенного вещественного формата для
хранения промежуточных значений гарантирует, что можно
представить такие маленькие числа как ё3.37 x 10**(-4932). Это
делает случай с денормальными числами особым феноменом в
вычислительных приложениях процессора i486. При этом процессор
i486 может также загружать, хранить денормализованные
вещественные числа и оперировать ими при появлении таких чисел.

Процессор i486 предпринимает некоторые действия, связанные с
денормальными числами:

- Процессор i486 избегает создания денормальных чисел всегда,
  когда это возможно. Другими словами, он всегда нормализует
  вещественное число, за исключением ситуации с маленькими
  числами.

- Процессор i486 выдает немаскируемую исключение отрицательного
  переполнения для того, чтобы позволить программисту обнаружить
  случаи создания денормальных чисел.

- Процессор i486 выдает исключение денормального числа для того,
  чтобы позволить пррограммисту обнаружить случаи, когда
  денормальные числа переходят в дальнейшие вычисления.

Денормализация означает увеличение порядка истинного результата
и добавление соответствующих начальных нулей в мантиссу, сдвигая
остаток мантиссы на одну позицию вправо. Денормальные значения
могут всплывать в любом из форматов - простом, двойном или
расширенном. В Таблице 16-2 показан диапазон денормализованных
значений для каждого формата.

Денормализация производит либо денормальное значение, либо ноль.
Денормальные числа легко определяются своими показателями,
которые всегда минимальны для своих форматов. В форме со
смещенным показателем это всегда битовая строка: 00...00. Такое
же значение порядка приписывается нулям, но денормальные числа
имеют ненулевую мантиссу. Денормальное число в регистре
помечается как особое. В Таблицах 16-8 и 16-9 этой главы
показано, как денормальные числа кодируются в каждом из
вещественных форматов данных.

            Таблица 16-2. Денормализованные Значения
┌──────────┬────────────────────┬───────────────────────────────┐
│          │ Наименьш.Величина  │     Наибольшая Величина       │
│  Формат  ├─────────┬──────────┼─────────────────┬─────────────┤
│          │(Точная) │(Приблиз.)│    (Точная)     │  (Приблиз.) │
├──────────┼─────────┼──────────┼─────────────────┼─────────────┤
│ Простая  │  -150   │   -46    │  -126    -150   │   -38       │
│ точность │ 2       │ 10       │ 2     - 2       │ 10          │
│ Двойная  │  -1075  │   -324   │  -1022   -1075  │   -308      │
│ точность │ 2       │ 10       │ 2     - 2       │ 10          │
│ Расши-   │  -16461 │   -4956  │  -16382  -16462 │   -4932     │
│ ренный   │ 2       │ 10       │ 2     - 2       │ 10          │
└──────────┴─────────┴──────────┴─────────────────┴─────────────┘

Процесс денормализации является причиной потери значимости, если
низшие по порядку биты сдвигаются в мантиссе направо. В худшем
случае все биты мантиссы истинного результата сдвигаются и
заменяются начальными нулями. В этом случае результатом
денормализации является истинный ноль и, если значение находится
в регистре, то оно помечается как ноль.

Денормальные значения часто встречаются в большинстве
приложений. Типичные отладочные алгоритмы генерируют
экстремально малые результаты в процессе оценки промежуточных
подвыражений. Конечный результат, как правило, является
приемлемой величиной для простого или двойного формата на
выходе. Если промежуточные результаты содержатся во временном
вещественном виде, как рекомендовано, то диапазон этого формата
не очень часто дает отрицательное переполнение. Денормальные
числа часто всплывают только тогда, когда программа генерирует
слишком много промежуточных результатов, так много, что они не
могут храниться в регистровом стеке или в переменных памяти
расширенного формата. Если ограничения хранения заставляют
использовать простой или двойной формат для промежуточных
вещественных чисел и при этом производится маленькое значение,
то может произойти отрицательное переполнение. При этом, если
оно маскированное, то может быть выдано денормальное число.

Когда денормальное число простого или двойного формата
используется как исходный операнд и маскируется исключительная
ситуация с денормальными числами, то устройство обработки
операций с плавающей точкой процессора i486 автоматически
нормализует число при его переводе в расширенный формат.

16.1.1.1 Денормальные числа и последовательное отрицательное
         переполнение
----------------------------------------------------------------

Арифметика с плавающей точкой не может выполнять все операции
точно для всех операндов. Когда результат не представим как
переменная с плавающей точкой, неизбежна аппроксимация. Для
того, чтобы оставить аппроксимацию математически управляемой,
аппаратная часть подчиняется стандартам точности, которые могут
моделироваться конкретными неравенствами вместо уравнений.
Давайте предположим, что

X <- Y @ Z    (где @ - некоторая операция)

представляет типичную операцию. При изначальном режиме
округления (округление до ближайшего), каждая операция
выполняется с абсолютной ошибкой не более чем половина разности
между двумя числами с плавающей точкой ближайшими к точным
результатам. Пусть x является значением, хранимым в переменной с
именем X в программе, y - переменной Y и z - переменной Z.
Обычно y и z будут отличаться суммарной ошибкой от желаемого
результата и от того, что было бы получено при отсутствии
ошибок. Для вычисления x мы предполагаем, что y и z яляются
наилучшей аппроксимацией и что мы будем вычислять x настолько,
насколько это возможно. Если выражение y@z представимо точно, то
мы ожидаем, что x=y@z, и это то, что мы получили для каждой
алгебраической операции на устройстве обработки операций с
плавающей точкой процессора i486 (то есть, когда выражение y@z
является одним из y+z, y-z, y*z, y/z, sqrt z). Но если выражение
y@z должно быть аппроксимировано, как обычно, то x должен
отличаться от y@z не более чем на половину разности между двумя
представимыми числами, которые покрывают выражение y@z. Эта
разность зависит от двух факторов:

1.  Как определена точность, с которой проводятся вычисления,
    либо битами управления точностью, либо форматом,
    используемым в памяти. На процессоре i486 точность бывает
    простая (24 значащие бита), двойная (53 значащих бита) и
    расширенная (64 значащих бита).

2.  Как близко значение выражения y@z к нулю. В этом отношении
    существование денормальных чисел на процессоре i486
    предоставляет определенное преимущество над системами,
    которые не допускают денормальные числа.

В любых системах чисел с плавающей точкой плотность представимых
чисел больше ближе к нулю, чем ближе к наибольшим представимым
величинам. Однако, машины, которые не используют денормальные
числа, страдают от огромной дыры между нулем и его ближайшими
соседями. На Рисунках 16-1 и 16-2 показано, что случается около
нуля в двух различных системах чисел с плавающей точкой.

На Рисунке 16-1 показана система чисел с плавающей точкой,
которая (подобно процессору i486) допускает денормальные числа.
Для упрощения показаны только неотрицательные числа и рисунок
иллюстрирует систему чисел, которая несет только четыре значащие
разряда вместо 24-х, 53-х или 64-х значащих разряда, которые
предлагает процессор i486.

Каждый плюс обозначает представимое четырьмя значащими битами
число, а длинная вертикальная черта обозначает степень 2. Минусы
обозначают числа, не представимые с этой точностью. Денормальные
числа лежат между 0 и ближайшей нормальной степенью 2. Они не
менее плотны чем оставшиеся ненулевые числа.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│ 0+++++++│+++++++│-+-+-+-+-+-+-+-│---+---+---+---+---+---+.... │
│                                                             │
│ └───────┘ - - - - - - Нормальные числа - - - - - ->           │
│ Денормальные                                                  │
│    числа                                                      │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

Рисунок 16-1. Система Чисел с Плавающей Точкой с Денормальными
              Значениями

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│ 0       │+++++++│-+-+-+-+-+-+-+-│---+---+---+---+---+---+.... │
│                                                              │
│         └ - - - - - - Нормальные числа - - - - - ->           │
│                                                               │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘
Рисунок 16-2. Система Чисел с Плавающей Точкой без Денормальных
              Значений

На Рисунке 16-2 показана система чисел с плавающей точкой,
которая (в отличие от модуля обработки операций с плавающей
точкой процессора i486 или сопроцессора 387) не допускает
денормальные числа. Существует две большие дырки: одна на
положительной стороне от нуля (как показано), а другая на
отрицательной стороне от нуля (не показано). Пространство между
нулем и ближайшим соседом нуля отличается от пространства между
этим соседом и следующим большим числом с коэффициентом примерно
8.4 x 10**(6) для простого формата, 4.5 x 10**(15) для двойного
формата и 9.2 x 10**(18) для расширенного формата. Эти дырки
усложняют анализ ошибок.

Преимущество денормальных чисел бесспорно, при рассмотрении
того, что происходит в случае, когда маскируется исключение
отрицательного переполнения и значение выражения y@z попадает в
пространство между нулем и наименьшим нормальным значением.
Процессор i486 выдает ближайшее денормальное число. Этот процесс
может быть назван "последовательное отрицательное переполнение".
Действие не отличается от округления, которое может случиться,
когда значение выражения y@z попадает в нормальный диапазон.

С другой стороны, система, которая не имеет денормальных чисел,
возвращает как результат ноль - процесс, который может быть
намного более неточен, чем округление. Это действие может быть
названо "резкое переполнение". Модуль обработки операций с
плавающей точкой процессора i486 и математический сопроцессор
387 обрабатывают денормальные значения по другому, иначе, чем
математические сопроцессоры 8087/80287. Для детального
знакомства обратитесь к разделу 16.2.4.

16.1.2 Нули
----------------------------------------------------------------

Значение нуль в десятичном вещественном или целочисленном
формате может быть со знаком плюс или минус, тогда как знак
двоичного целого нуля всегда положительный. При вычислениях
значение нуля всегда ведет себя одинаково, несмотря на знак, и
обычно то, что ноль может быть со знаком, является очевидным для
программиста. При необходимости можно использовать команду FXAM
для того, чтобы определить знак нуля.

Либо программист может закодировать ноль, или он может быть
создан модулем обработки операций с плавающей точкой как
маскируемый ответ на исключение отрицательного переполнения.
Если ноль загружен или сгенерирован в регистре, то этот регистр
помечается как ноль. В Таблице 16-3 приведены результаты
команд, выполненных с нулевыми операндами, а также показано, как
может получиться ноль из ненулевых операндов.

          Таблица 16-3. Нулевые Операнды и Результаты
┌──────────────────┬────────────────────┬───────────────────────┐
│    Команда       │      Операнды      │       Результат       │
├──────────────────┼────────────────────┼───────────────────────┤
│ FLD,FBLD         │ ё0                 │ *0                    │
│ FILD             │ +0                 │ +0                    │
│ FST,FSTP,FRNDINT │ ё0                 │ *0                    │
│                  │ +X                 │ +0(1)                 │
│                  │ -X                 │ -0(1)                 │
│ FBSTP            │ ё0                 │ *0                    │
│ FIST,FISTP       │ ё0                 │ *0                    │
│                  │ +X                 │ +0(3)                 │
│                  │ -X                 │ -0(4)                 │
│ FCHS             │ +0                 │ -0                    │
│                  │ -0                 │ +0                    │
│ FABS             │ ё0                 │ +0                    │
│ Сложение         │ +0 плюс +0         │ +0                    │
│                  │ -0 плюс -0         │ -0                    │
│                  │ +0плюс-0, -0плюс+0 │ ё0(2)                 │
│                  │ -Xплюс+X, +Xплюс-X │ ё0(2)                 │
│                  │ ё0плюсёX, ёXплюсё0 │ #X                    │
│                  │                    │                       │
│ Вычитание        │ +0 минус -0        │ +0                    │
│                  │ -0 минус +0        │ -0                    │
│                  │ +0 минус+0,-0 минус│ ё0(2)                 │
│                  │ -0                 │ ё0(2)                 │
│                  │ +X минус+X,-X минус│ -#X                   │
│                  │ -X                 │ #X                    │
│                  │ ё0 минус ёX        │                       │
│                  │ ёX минус ё0        │                       │
│ Умножение        │ ё0 x ё0            │ (+)0                  │
│                  │ ё0 x ёX, ёX x ё0   │ (+)0                  │
│                  │ +X x +Y, -X x -Y   │ +0(1)                 │
│                  │ +X x -Y, -X x +Y   │ -0(1)                 │
│ Деление          │ ё0 / ё0            │ Недопустимая Операция │
│                  │ ёX / ё0            │ (+)oo (Деление на 0)  │
│                  │ ёX / ёoo           │ (+)0                  │
│                  │ +0 / +X, -0 / -X   │ +0                    │
│                  │ +0 / -X, -0 / +X   │ -0                    │
│                  │ -X / -Y, +X / +Y   │ +0(1)                 │
│                  │ -X / +Y, +X / -Y   │ -0(1)                 │
│ FPREM, FPREM1    │ ё0 rem ё0          │ Недопустимая Операция │
│                  │ ёX rem ё0          │ Недопустимая Операция │
│                  │ +0 rem ёX          │ +0                    │
│                  │ -0 rem ёX          │ -0                    │
│                  │ +X rem ёY          │ +0 Y точно делит X    │
│                  │ -X rem ёY          │ -0 Y точно делит X    │
│ FSQRT            │ ё0                 │ *0                    │
│ Сравнение        │ ё0 : +X            │ ё0 < +X               │
│                  │ ё0 : ё0            │ ё0 = ё0               │
│                  │ ё0 : -X            │ ё0 > -X               │
│ FTST             │ ё0                 │ ё0 = 0                │
│ FXAM             │ +0                 │ C3=1;  C2=C1=C0=0     │
│                  │ -0                 │ C3=C1=1;  C2=C0=0     │
│ FSCALE           │ ё0 масштабир. -oo  │ *0                    │
│                  │ ё0 масштабир. +oo  │ Недопустимая Операция │
│                  │ ё0 масштабир. X    │ *0                    │
│ FXTRACT          │ +0                 │ ST=+0, ST(1)=-oo      │
│                  │ -0                 │ Деление на ноль       │
│                  │                    │ ST=-0, ST(1)=-oo      │
│                  │                    │ Деление на ноль       │
│ FPTAN            │ ё0                 │ *0                    │
│ FSIN (или резулт.│ ё0                 │ *0                    │
│  SIN из FSINCOS) │                    │                       │
│ FCOS (или резулт.│ ё0                 │ +1                    │
│  COS из FSINCOS) │                    │                       │
│                  │                    │                       │
│ FPATAN           │ ё0 / +X            │ *0                    │
│                  │ +0 / -X            │ *Пи                   │
│                  │ ёX / ё0            │ #Пи/2                 │
│                  │ ё0 / +0            │ *0                    │
│                  │ ё0 / -0            │ *Пи                   │
│                  │ +oo / ё0           │ +Пи/2                 │
│                  │ -oo / ё0           │ -Пи/2                 │
│                  │ ё0 / +oo           │ *0                    │
│                  │ ё0 / -oo           │ *Пи                   │
│ F2XM1            │ +0                 │ +0                    │
│                  │ -0                 │ -0                    │
│ FYL2X            │ ёY x log(ё0)       │ Деление на ноль       │
│                  │ ё0 x log(ё0)       │ Недопустимая Операция │
│ FYL2XP1          │ +Y x log(ё0+1)     │ *0                    │
│                  │ -Y x log(ё0+1)     │ -*0                   │
│                  │                    │                       │
└──────────────────┴────────────────────┴───────────────────────┘

X и Y         ненулевые положительные операнды.

1             когда отрицательное переполнение денормализует
              результат до нуля.

2             знак, опрежделяемый режимом округления: + для
              округления до ближайшего, округления вверх или
              отсечения, - для округления вниз.

3             при 0 < X < 1 и если не установлен режим
              округления вверх.

4             при -1 < X < 0 и если не установлен режим
              округления вниз.

*             знак изначального нулевого операнда.

#             знак изначального операнда X.

-#            дополнение знака изначального операнда X.

(+)           исключающее ИЛИ знаков операндов


16.1.3 Бесконечность
----------------------------------------------------------------

Вещественные форматы поддерживают представление бесконечности со
знаком. Эти значения кодируются со смещенным порядком из всех
единиц и с мантиссой 100..00. Если бесконечность попадает в
регистр, то он помечается как особый.

Или программист может закодировать бесконечность, или она может
быть создана модулем обработки операций с плавающей точкой как
маскируемый ответ на исключение переполнения или деления на
ноль. Обратите внимание, что в зависимости от режима округления,
маскируемый ответ может повлечь за собой наибольшее допустимое
значение, представимое в принимающем формате, а не
бесконечность.

К бесконечностям можно приписывать знак, поэтому возможно
сравнение с бесконечностью. Бесконечность всегда
интерпретируется в афинном смысле, то есть -oo < (любое конечное
число) < +oo. Арифметические операции с бесконечностью всегда
точны и не дают исключительных ситуаций, за исключением
недопустимых операций, указанных в Таблице 16-4.

         Таблица 16-4. Бесконечные Операнды и Результат

┌──────────────────┬────────────────────┬───────────────────────┐
│    Операция      │      Операнды      │       Результат       │
├──────────────────┼────────────────────┼───────────────────────┤
│ FLD,FBLD         │ ёoo                │ *oo                   │
│ FST,FSTP,FRNDINT │ ёoo                │ *oo                   │
│ FCHS             │ +oo                │ -oo                   │
│                  │ -oo                │ +oo                   │
│ FABS             │ ёoo                │ +oo                   │
│ Сложение         │ +oo плюс +oo       │ +oo                   │
│                  │ -oo плюс -oo       │ -oo                   │
│                  │ +oo плюс -oo       │ Недопустимая Операция │
│                  │ -oo плюс +oo       │ Недопустимая Операция │
│                  │ ёoo плюс ёX        │ *oo                   │
│                  │ ёX плюс ёoo        │ *oo                   │
│ Вычитание        │ +oo минус -oo      │ +oo                   │
│                  │ -oo минус +oo      │ -oo                   │
│                  │ +oo минус +oo      │ Недопустимая Операция │
│                  │ -oo минус -oo      │ Недопустимая Операция │
│                  │ ёoo минус ёX       │ *oo                   │
│                  │ ёX минус ёoo       │ -*oo                  │
│ Умножение        │ ёoo x ёoo          │ (+)oo                 │
│                  │ ёoo x ёY, ёY x ёoo │ (+)oo                 │
│                  │ +0 x ёoo, ёoo x ё0 │ Недопустимая Операция │
│ Деление          │ ёoo / ёoo          │ Недопустимая Операция │
│                  │ ёoo / ёX           │ (+)oo                 │
│                  │ ёX / ёoo           │ (+)0                  │
│                  │ ёoo / ё0           │ (+)oo                 │
│ FPREM, FPREM1    │ ёoo rem ёoo        │ Недопустимая Операция │
│                  │ ёoo rem ёX         │ Недопустимая Операция │
│                  │ ёX rem ёoo         │ $X, Q = 0             │
│ FSQRT            │ -oo                │ Недопустимая Операция │
│                  │ +oo                │ +oo                   │
│ Сравнение        │ +oo : +oo          │ +oo = +oo             │
│                  │ -oo : -oo          │ -oo = -oo             │
│                  │ +oo : -oo          │ +oo > -oo             │
│                  │ -oo : +oo          │ -oo < +oo             │
│                  │ +oo : ёX           │ +oo > X               │
│                  │ -oo : ёX           │ -oo < X               │
│                  │ ёX  : +oo          │ X   < +oo             │
│                  │ ёX  : -oo          │ X   > -oo             │
│                  │ +oo                │ +oo > 0               │
│ FTST             │ -oo                │ -oo < 0               │
│ FSCALE           │ ёoo масштабир. -oo │ Недопустимая Операция │
│                  │ ёoo масштабир. +oo │ *oo                   │
│                  │ ёoo масштабир. ёX  │ *oo                   │
│                  │ ё0  масштабир. -oo │ ё0(1)                 │
│                  │ ё0  масштабир. oo  │ Недопустимая Операция │
│                  │ ёY  масштабир. +oo │ #oo                   │
│                  │ ёY  масштабир. -oo │ #0                    │
│ FXTRACT          │ ёoo                │ ST=*oo, ST(1)=+oo     │
│ FXAM             │ +oo                │ C0=C2=1;  C1=C3=0     │
│                  │ -oo                │ C0=C1=C2=1;  C3=0     │
│                  │                    │                       │
│ FPATAN           │ ёoo / ёX           │ *Пи/2                 │
│                  │ ёY  / +oo          │ #0                    │
│                  │ ёY / -oo           │ #Пи                   │
│                  │ ёoo / +oo          │ *Пи/4                 │
│                  │ ёoo / -oo          │ *3Пи/4                │
│                  │ ёoo / ё0           │ *Пи/2                 │
│                  │ +0  / +oo          │ +0                    │
│                  │ +0  / -oo          │ +Пи                   │
│                  │ -0  / +oo          │ -0                    │
│                  │ -0  / -oo          │ -Пи                   │
│ F2XM1            │ +oo                │ +oo                   │
│                  │ -oo                │ -1                    │
│ FYL2X            │ ёoo x log(1)       │ Недопустимая Операция │
│                  │ ёoo x log(X>1)     │ *oo                   │
│                  │ ёoo x log(0<X<1)   │ -*oo                  │
│                  │ ёY  x log(+oo)     │ #oo                   │
│                  │ ё0  x log(+oo)     │ Недопустимая Операция │
│                  │ ёY  x log(-oo)     │ Недопустимая Операция │
│ FYL2XP1          │ ёoo x log(1)       │ Недопустимая Операция │
│                  │ ёoo x log(X>0)     │ *oo                   │
│                  │ ёoo x log(-1<X<0)  │ -*oo                  │
│                  │ ёY  x log(+oo)     │ #oo                   │
│                  │ ё0  x log(+oo)     │ Недопустимая Операция │
│                  │ ёY x log(-oo)      │ Недопустимая Операция │
│                  │                    │                       │
└──────────────────┴────────────────────┴───────────────────────┘

X             нулевой или ненулевой положительный операнд.

Y             ненулевой положительный операнд.

*             знак изначального бесконечного операнда.

-*            дополнение знака изначального бесконечного операнда.

$             знак изначального операнда.

(+)           исключительное ИЛИ знаков операндов.

#             знак изначального операнда Y.

1             знак изначального нулевого операнда.


16.1.4 NaN (не-число)
----------------------------------------------------------------

NaN (Not-a-Number) - не-число принадлежит к классу особых
значений, которые существуют только в вещественных форматах. NaN
имеет порядок 11..11B, может иметь любой знак и любую мантиссу,
за исключением 100..00B, которая предназначается для
бесконечности. Если NaN попадает в регистр, то он помечается как
особый.

Существует два класса NaN: сигнальный (SNaN) и безответный
(QNaN). Среди безответных QNaN особый интерес представляет
вещественная неопределенность.

16.1.4.1 Сигнальные NaN
----------------------------------------------------------------

Сигнальные NaN - это те, которые имеют в самом значащем разряде
своей мантиссы ноль. Остальная мантисса может иметь любое
значение. Модуль обработки операций с плавающей точкой никогда
не выдает сигнальные NaN как результат, однако он распознает
сигнальные NaN при их появлении в качестве операндов.
Арифметические операции (как определено в начале этой главы) над
сигнальными NaN вызывают исключение недопустимой операции (за
исключением операций загрузки из стека FXCH, FCHS и FABS).

Немаскируя исключение недопустимой операции, программист может
использовать сигнальные NaN для того, чтобы вызвать обработчик
исключений. Этот подход и большие величины значений допустимых
NaN дают в руки талантливому программисту инструмент, который
может быть применен в широком диапазоне исключений.

Например, компилятор мог бы использовать сигнальные NaN как
ссылки на неинициализованные элементы (вещественного) массива.
Компилятор мог бы изначально проинициализировать каждый элемент
массива сигнальными NaN, мантиссы которых содержали бы индекс
(относительную позицию) элемента. Если прикладная программа
попытается обратиться к элементу, которые не инициализован, то
она получит NaN, помещенное туда компилятором. Если
исключение недопустимой операции не было маскировано,
произойдет прерывание и будет вызван обработчик исключений.
Обработчик исключений смог бы определить, к какому элементу был
обращен запрос, так как поля адреса операнда указателей
исключения показывали бы на NaN, которое содержит
числовой индекс элемента массива.

16.1.4.2 Безответные NaN
----------------------------------------------------------------

Безответные NaN - это те, которые имеют в самом значащем разряде
своей мантиссы единицу. Процессор i486 выдает вещественную
неопределенность (определяемую ниже) - один из видов QNaN - как
ответ по умолчанию на конкретные условия возникновения
исключения. Процессор i486 может также получать другие виды QNaN
преобразованием SNaN. Процессор i486 переводит SNaN в QNaN,
устанавливая в самом значащем разряде мантиссы единицу.
Остальные биты мантиссы остаются неизменными, поэтому
диагностическая информация, которая могла храниться в этих битах
SNaN переходит в QNaN.

Процессор i486 будет также генерировать особое QNaN,
вещественную неопределенность, как маскированный ответ на
исключение недопустимой операции. Это NaN имеет отрицательный
знак, его мантисса кодируется как 1100..00. Все другие NaN
представляют из себя значения, созданные программистом или
полученные из значений, созданных программистом.

Как сигнальные, так и безответные NaN поддерживаются во всех
операциях. QNaN генерируется как маскированный ответ на
исключение недопустимой операции или как результат операции, в
которой хотя бы один операнд является QNaN. При генерации QNaN
процессор i486 придерживается правил, показанных в Таблице 16-5.

            Таблица 16-5. Правила Генерирования QNaN

┌───────────────────────────────┬───────────────────────────────┐
│          Операция             │          Действие             │
├───────────────────────────────┼───────────────────────────────┤
│                               │                               │
│ Вещественная над SNaN и QNaN. │ Передает операнд типа QNaN.   │
│                               │                               │
│ Вещественная над двумя SNaN.  │ Передает QNaN, получаемое     │
│                               │ переводом SNaN, которое имеет │
│                               │ большую мантиссу.             │
│                               │                               │
│ Вещественная над двумя QNaN.  │ Передает QNaN, которое имеет  │
│                               │ большую мантиссу.             │
│                               │                               │
│ Вещественная над SNaN и       │ Передает QNaN, получаемое     │
│ другим числом.                │ переводом SNaN.               │
│                               │                               │
│ Вещественная над QNaN и       │ Передает QNaN.                │
│ другим числом.                │                               │
│                               │                               │
│ Недопустимая, не включающая   │ Передает вещественную         │
│ типа NaN.                     │ неопределенность типа QNaN.   │
│                               │                               │
└───────────────────────────────┴───────────────────────────────┘

Обратите внимание, что обработка операнда QNaN имеет больший
приоритет, чем все исключительные ситуации, за исключением
конкретных исключительных ситуаций, связанных с недопустимыми
операциями (смотрите раздел "Приоритетность исключительных
ситуаций" в этой главе).

Безответные NaN можно было бы использовать, например, для того,
чтобы ускорить отладку. В начальной фазе тестирования программа
часто содержит многочисленные ошибки. Млжно было бы написать
обработчик исключений для того, чтобы сохранять диагностическую
информацию в памяти всегда, когда вызывается этот обработчик.
После сохранения диагностической информации он мог бы выдавать
QNaN как результат ошибочной команды, а это QNaN могло бы
указывать на область памяти, где собраны диагностики. Затем
программа могла бы продолжиться, создавая различные NaN для
каждой ошибки. После завершения программы результирующие NaN
могли бы быть использованы для доступа к диагностическим данным,
сохраненным в момент прохождения ошибки. Таким образом можно
было бы диагностировать и исправлять сразу много ошибок за один
проход тестирования.

В тех приложениях, которые используют полученные результаты в
дальнейших вычислениях, необнаруженное QNaN может загубить все
последующие результаты. Такие приложения следует периодически
проверять на QNaN и предоставлять механизм восстановления, если
был обнаружет QNaN результат.

16.1.5 Неопределенность
----------------------------------------------------------------

Для каждого типа числовых данных отведен один уникальный код для
представления особого значения - неопределенности. Процессор
i486 производит этот код как ответ на маскированное исключение
недопустимой операции.

В случае вещественных чисел значение неопределенности является
QNaN числом, как уже было отмечено в предыдущем разделе.

Упакованная десятичная неопределенность может быть сохранена с
помощью команды FBSTR, однако, попытка использовать этот код в
команде FBLD приведет к неизвестному результату. Таким образом,
неопределеность не может быть загружена из упакованного
десятичного целого.

Для двоичных чисел такой же код может представлять либо
неопределенность, либо наибольшее отрицательное число,
поддерживаемое форматом (-2**(15), -2**(31) или -2**(63)).
Процессор i486 будет выдавать этот код как маскированный ответ
на недопустимую операцию, либо когда значение в исходном
регистре представляется или округляется до наибольшего
отрицательного целого числа, представимого принимающим форматом.
В случаях, когда его изначальное содержание может быть неясно,
то может быть проверен флаг исключения недопустимой операции для
того, чтобы посмотреть, не было ли выдано это значение в ответ
на исключение. Когда этот код загружается или используется в
целочисленной арифметике или в операции сравнения, он всегда
интерпретируется как отрицательное число. Таким образом,
неопределеность не может быть загружена из двоичного целого.

16.1.6 Кодирование типов данных
----------------------------------------------------------------

В таблицах от Таблицы 16-6 до Таблицы 16-9 показано, как каждое
из только что описанных особых значений кодируется для каждого
типа числовых данных. В этих таблицах наименее значимый разряд
показан справа. Он хранится в памяти с низшим адресом. Бит знака
всегда является самым левым битом старшего адресуемого байта.

            Таблица 16-6. Кодирование Двоичных Целых

┌───────────────────────────────────┬─────────┬─────────────────┐
│           Класс                   │  Знак   │    Величина     │
├────┬──────────────────────────────┼─────────┼─────────────────┤
│ П  │ (Наибольший)                 │    0    │     11..11      │
│ о  │                              │    .    │        .        │
│ л  │                              │    .    │        .        │
│ о  │                              │    .    │        .        │
│ ж  │                              │    .    │        .        │
│ и  │                              │    .    │        .        │
│ т  │                              │    .    │        .        │
│ е  │                              │    .    │        .        │
│ л  │                              │    .    │        .        │
│ ь  │                              │    .    │        .        │
│ н  │                              │    .    │        .        │
│ ы  │                              │    .    │        .        │
│ е  │ (Наименьший)                 │    0    │     00..01      │
├────┴──────────────────────────────┼─────────┼─────────────────┤
│             Ноль                  │    0    │     00..00      │
├────┬──────────────────────────────┼─────────┼─────────────────┤
│ О  │ (Наименьший)                 │    1    │     11..11      │
│ т  │                              │    .    │        .        │
│ р  │                              │    .    │        .        │
│ и  │                              │    .    │        .        │
│ ц  │                              │    .    │        .        │
│ а  │                              │    .    │        .        │
│ т  │                              │    .    │        .        │
│ е  │                              │    .    │        .        │
│ л  │                              │    .    │        .        │
│ ь  │                              │    .    │        .        │
│ н  │                              │    .    │        .        │
│ ы  │                              │    .    │        .        │
│ е  │(Наибольший/Неопределенность*)│    1    │     00..00      │
└────┴──────────────────────────────┼─────────┼─────────────────┤
                                    │Слово:   │     15 битов    │
                                    │Короткое:│     31 бит      │
                                    │Длинное: │     63 бита     │
                                    │         │                 │

* Если этот код используется как операнд-источник (как при
  загрузке целого или в целочисленной арифметической команде),
  модуль обработки операций с плавающей точкой интерпретирует
  его как наибольшее отрицательное число, представимое в
  формате... -2**15, -2**31 или -2**63. Модуль передает этот код
  в целочисленный приемник в двух случаях:

  1. Если результат является наибольшим отрицательным числом.

  2. Как ответ на маскированное исключение недопустимой
     операции, в тех случаях, когда он представляет собой особое
     значение - целую неопределенность.


     Таблица 16-7. Кодирование Десятичных Упакованных Целых

┌────────────────┬────┬───────┬─────────────────────────────────┐
│                │    │       │           Величина              │
│     Класс      │Знак│       ├─────┬─────┬─────┬─────┬───┬─────│
│                │    │       │цифра│цифра│цифра│цифра│...│цифра│
├───┬────────────┼────┼───────┼─────┴─────┴─────┴─────┴───┴─────┤
│ П │(Наибольший)│ 0  │0000000│1001  1001  1001  1001  ... 1001 │
│ о │            │ .  │   .   │               .                 │
│ л │            │ .  │   .   │               .                 │
│ о │            │ .  │   .   │               .                 │
│ ж │            │ .  │   .   │               .                 │
│ и │            │ .  │   .   │               .                 │
│ т │            │ .  │   .   │               .                 │
│ е │            │ .  │   .   │               .                 │
│ л │            │ .  │   .   │               .                 │
│ ь │            │ .  │   .   │               .                 │
│ н │            │ .  │   .   │               .                 │
│ ы │            │ .  │   .   │               .                 │
│ е │(Наименьший)│ 0  │0000000│0000  0000  0000  0000 ...  0001 │
│   ├────────────┼────┼───────┼─────────────────────────────────┤
│   │ Ноль       │ 0  │0000000│0000  0000  0000  0000 ...  0000 │
├───┼────────────┼────┼───────┼─────────────────────────────────┤
│   │ Ноль       │ 1  │0000000│0000  0000  0000  0000 ...  0000 │
│   ├────────────┼────┼───────┼─────────────────────────────────┤
│ О │(Наименьший)│ 1  │0000000│0000  0000  0000  0000 ...  0000 │
│ т │            │ .  │   .   │               .                 │
│ р │            │ .  │   .   │               .                 │
│ и │            │ .  │   .   │               .                 │
│ ц │            │ .  │   .   │               .                 │
│ а │            │ .  │   .   │               .                 │
│ т │            │ .  │   .   │               .                 │
│ е │            │ .  │   .   │               .                 │
│ л │            │ .  │   .   │               .                 │
│ ь │            │ .  │   .   │               .                 │
│ н │            │ .  │   .   │               .                 │
│ ы │            │ .  │   .   │               .                 │
│ е │(Наибольший)│ 1  │0000000│1001  1001  1001  1001 ...  1001 │
├───┴────────────┼────┼───────┼─────────────────────────────────┤
│Неопределенность│ 1  │1111111│1111  1111 UUUU** UUUU ...  UUUU │
│              * │    │       │                                 │
└────────────────┼────┴───────┼─────────────────────────────────┤
                 │ - 1 байт - │          - 9 байтов -           │

* В ответ на маскированное исключение недопустимой операции
  командой FBSTP сохраняется упакованная десятичная
  неопределенность. Попытка загрузить это значение через команду
  FBLD приводит к неопределенным результатам.

** UUUU означает, что битовые значения неопределены и могут
   содержать любую величину.


    Таблица 16-8. Кодирование Простых и Двойных Вещественных

┌─────────────────────┬──────────┬─────────────┬────────────────┐
│                     │          │  Смещенный  │    Мантисса    │
│       Класс         │  Знак    │   Порядок   │     ff--ff*    │
├───┬───┬─────────────┼──────────┼─────────────┼────────────────┤
│   │   │             │    0     │    11..11   │     11..11     │
│   │   │ Безответный │          │      .      │       .        │
│   │   │             │          │      .      │       .        │
│   │ N │             │    0     │    11..11   │     10..00     │
│ П │ a ├─────────────┼──────────┼─────────────┼────────────────┤
│ о │ N │             │    0     │    11..11   │     01..11     │
│ л │   │ Сигнальный  │          │      .      │       .        │
│ о │   │             │          │      .      │       .        │
│ ж │   │             │    0     │    11..11   │     00..01     │
│ и ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │    Бесконечность│    0     │    11..11   │     00..00     │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │   │             │    0     │    11..10   │     11..11     │
│ ь │ В │ Нормальные  │          │      .      │       .        │
│ н │ е │             │          │      .      │       .        │
│ ы │ щ │             │    0     │    00..01   │     00..00     │
│ е │ е ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ с │             │    0     │    00..00   │     11..11     │
│   │ т │ Денормальные│          │      .      │       .        │
│   │ в │             │          │      .      │       .        │
│   │ е │             │    0     │    00..00   │     00..01     │
│   │ н ├─────────────┼──────────┼─────────────┼────────────────┤
│   │   │ Ноль        │    0     │    00..00   │     00..00     │
├───┼───┼─────────────┼──────────┼─────────────┼────────────────┤
│   │   │ Ноль        │    1     │    00..00   │     00..00     │
│   │ В ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ е │             │    1     │    00..00   │     00..01     │
│   │ щ │ Денормальные│          │      .      │       .        │
│   │ е │             │          │      .      │       .        │
│   │ с │             │    1     │    00..00   │     11..11     │
│ О │ т ├─────────────┼──────────┼─────────────┼────────────────┤
│ т │ в │             │    1     │    00..01   │     00..00     │
│ р │ е │ Нормальные  │          │      .      │       .        │
│ и │ н │             │          │      .      │       .        │
│ ц │   │             │    1     │    11..10   │     11..11     │
│ а ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │    Бесконечность│    1     │    11..11   │     00..00     │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │   │             │    1     │    11..11   │     00..01     │
│ ь │   │ Сигнальный  │          │      .      │       .        │
│ н │   │             │          │      .      │       .        │
│ ы │ N │             │    1     │    11..11   │     01..11     │
│ е │ a ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ N │ Неопределен.│    1     │    11..11   │     10..00     │
│   │   │             │          │      .      │       .        │
│   │   │ Безответный │          │      .      │       .        │
│   │   │             │    1     │    11..11   │     11..11     │
└───┴───┴─────────────┴──────────┼─────────────┼────────────────┤
                        Простой: │ - 8 битов - │   - 23 бита -  │
                        Двойной: │ - 11 битов -│   - 52 бита -  │

* Так как бит целой части является неявным, то он не хранится.


       Таблица 16-9. Кодирование Расширенных Вещественных

┌─────────────────────┬──────────┬─────────────┬────────────────┐
│                     │          │  Смещенный  │    Мантисса    │
│       Класс         │  Знак    │   Порядок   │    l.ff--ff    │
├───┬───┬─────────────┼──────────┼─────────────┼────────────────┤
│   │   │             │    0     │    11..11   │    1 11..11    │
│   │   │ Безответный │          │      .      │       .        │
│   │   │             │          │      .      │       .        │
│   │ N │             │    0     │    11..11   │    1 10..00    │
│ П │ a ├─────────────┼──────────┼─────────────┼────────────────┤
│ о │ N │             │    0     │    11..11   │    1 01..11    │
│ л │   │ Сигнальный  │          │      .      │       .        │
│ о │   │             │          │      .      │       .        │
│ ж │   │             │    0     │    11..11   │    1 00..01    │
│ и ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │    Бесконечность│    0     │    11..11   │    1 00..00    │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │   │             │    0     │    11..10   │    1 11..11    │
│ ь │ В │ Нормальные  │          │      .      │       .        │
│ н │ е │             │          │      .      │       .        │
│ ы │ щ │             │    0     │    00..01   │    1 00..00    │
│ е │ е ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ с │             │    0     │    00..00   │    0 11..11    │
│   │ т │ Денормальные│          │      .      │       .        │
│   │ в │             │          │      .      │       .        │
│   │ е │             │    0     │    00..00   │    1 00..01    │
│   │ н ├─────────────┼──────────┼─────────────┼────────────────┤
│   │   │ Ноль        │    0     │    00..00   │    0 00..00    │
├───┼───┼─────────────┼──────────┼─────────────┼────────────────┤
│   │   │ Ноль        │    1     │    00..00   │    0 00..00    │
│   │ В ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ е │             │    1     │    00..00   │    0 00..01    │
│   │ щ │ Денормальные│          │      .      │       .        │
│   │ е │             │          │      .      │       .        │
│   │ с │             │    1     │    00..00   │    0 11..11    │
│ О │ т ├─────────────┼──────────┼─────────────┼────────────────┤
│ т │ в │             │    1     │    00..01   │    1 00..00    │
│ р │ е │ Нормальные  │          │      .      │       .        │
│ и │ н │             │          │      .      │       .        │
│ ц │   │             │    1     │    11..10   │    1 11..11    │
│ а ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │    Бесконечность│    1     │    11..11   │    1 00..00    │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │   │             │    1     │    11..11   │    1 00..01    │
│ ь │   │ Сигнальный  │          │      .      │       .        │
│ н │   │             │          │      .      │       .        │
│ ы │ N │             │    1     │    11..11   │    1 01..11    │
│ е │ a ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ N │ Неопределен.│    1     │    11..11   │    1 10..00    │
│   │   │             │          │      .      │       .        │
│   │   │ Безответный │          │      .      │       .        │
│   │   │             │    1     │    11..11   │    1 11..11    │
└───┴───┴─────────────┴──────────┼─────────────┼────────────────┤
                                 │ - 15 битов -│   - 64 бита -  │



16.1.7 Неподдерживаемые форматы
----------------------------------------------------------------

Расширенный формат позволяет задавать множество битовых
вариантов, не попадающих ни в одну из выше упомянутых категорий.
В Таблице 16-10 приведены эти неподдерживаемые форматы.
Некоторые из этих кодировок поддерживались математическим
сопроцессором 80287, однако большинство из них не поддерживается
сопроцессором 387 и модулем обработки операций с плавающей
точкой процессора i486. Эти изменения были сделаны в
соответствии с изменениями в окончательной версии стандарта IEEE
754, который не предусматривает эти типы данных.

Не поддерживаются также кодирование понятий, прежде известных
как псевдо-NaN, псевдо-бесконечность и не-нормальные числа.
Процессор i486 выдает исключение недопустимой операции, в случае
кодирования этих понятий в качестве операндов.

Процессор i486 также не генерирует коды, прежде известные как
псевдо-денормальные числа. Однако, они корректно используются
при кодировании в качестве операндов. Показатель трактуется так,
как если бы он был равен 00..01, а мантисса не изменяется. При
этом генерируется исключение денормального числа.

            Таблица 16-10. Неподдерживаемые Форматы

┌─────────────────────┬──────────┬─────────────┬────────────────┐
│                     │          │  Смещенный  │    Мантисса    │
│       Класс         │  Знак    │   Порядок   │    l.ff--ff    │
├───┬───┬─────────────┼──────────┼─────────────┼────────────────┤
│   │ П │             │    0     │    11..11   │    0 11..11    │
│   │ с │ Безответный │          │      .      │       .        │
│   │ е │             │          │      .      │       .        │
│   │ в │             │    0     │    11..11   │    0 10..00    │
│ П │ д ├─────────────┼──────────┼─────────────┼────────────────┤
│ о │ о │             │    0     │    11..11   │    0 01..11    │
│ л │ N │ Сигнальный  │          │      .      │       .        │
│ о │ a │             │          │      .      │       .        │
│ ж │ N │             │    0     │    11..11   │    0 00..01    │
│ и ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │Псевдо-бесконечн.│    0     │    11..11   │    0 00..00    │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │ В │             │    0     │    11..10   │    0 11..11    │
│ ь │ е │Не-Нормальные│          │      .      │       .        │
│ н │ щ │             │          │      .      │       .        │
│ ы │ е │             │    0     │    00..01   │    0 00..00    │
│ е │ с ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ т │             │    0     │    00..00   │    1 11..11    │
│   │ в │ Псевдо-     │          │      .      │       .        │
│   │ е │ Денормальные│          │      .      │       .        │
│   │ н │             │    0     │    00..00   │    1 00..00    │
├───┼───┼─────────────┼──────────┼─────────────┼────────────────┤
│   │ В │             │    1     │    00..00   │    1 11..11    │
│   │ е │ Псевдо-     │          │      .      │       .        │
│   │ щ │ Денормальные│          │      .      │       .        │
│   │ е │             │    1     │    00..00   │    1 00..00    │
│ О │ с ├─────────────┼──────────┼─────────────┼────────────────┤
│ т │ т │             │    1     │    11..10   │    0 11..11    │
│ р │ в │Не-Нормальные│          │      .      │       .        │
│ и │ е │             │          │      .      │       .        │
│ ц │ н │             │    1     │    00..01   │    0 00..00    │
│ а ├───┴─────────────┼──────────┼─────────────┼────────────────┤
│ т │Псевдо-бесконечн.│    1     │    11..11   │    0 00..00    │
│ е ├───┬─────────────┼──────────┼─────────────┼────────────────┤
│ л │ П │             │    1     │    11..11   │    0 01..11    │
│ ь │ с │ Сигнальный  │          │      .      │       .        │
│ н │ е │             │          │      .      │       .        │
│ ы │ в │             │    1     │    11..11   │    0 00..01    │
│ е │ д ├─────────────┼──────────┼─────────────┼────────────────┤
│   │ о │             │    1     │    11..11   │    0 11..11    │
│   │ N │ Безответный │          │      .      │       .        │
│   │ a │             │          │      .      │       .        │
│   │ N │             │    1     │    11..11   │    0 10..00    │
└───┴───┴─────────────┴──────────┼─────────────┼────────────────┤
                                 │ - 15 битов -│   - 64 бита -  │



16.2 Числовые исключения
----------------------------------------------------------------

Процессор i486 может распознавать шесть классов условий числовых
исключений при выполнении числовых команд:

1.  I - Недопустимая операция

    *   Ошибка стека
    *   Операция, недопустимая стандартом IEEE

2.  Z - Деление-на-ноль

3.  D - Денормализованный операнд

4.  O - Числовое переполнение

5.  U - Числовое отрицательное переполнение

6.  P - Неточный результат (точность)


16.2.1 Обработка числовых исключений
----------------------------------------------------------------

При возникновении числового исключения процессор i486
предпринимает одно из двух возможных действий:

- Модуль обработки операций с плавающей точкой может сам
  обработать исключение, производя наиболее разумный результат и
  не мешая при этом выполнению вычислительной программы.

- Может быть вызван программный обработчик исключений для того,
  чтобы обработать это исключение.

Каждое из приведенных выше шести условий исключений имеет
соответствующий бит флага в слове состояния модуля обработки
операций с плавающей точкой и бит маски в управляющем слове
модуля обработки операций с плавающей точкой. Если
исключение маскировано (соответствующий бит маски в управляющем
слове = 1), то процессор i486 выполняет некоторые действия по
умолчанию и продолжает вычисления. Если исключение
не маскировано (маска = 0), то немедленно вызывается программный
обработчик исключений перед тем, как выполнить следующую
команду WAIT или команду с плавающей точкой, не
принадлежащую к классу управляющих. В зависимости от значения
бита NE управляющего регистра CR0, обработчик исключений
вызывается либо через вектор прерывания 16 (NE = 1), либо через
внешнее прерывание (NE = 0).

Обратите внимание, что если исключения маскированы, то
модуль обработки операций с плавающей точкой может обнаружить
множество исключений в единственной команде, так как он
продолжает выполнение команды после обработки маскированного
ответа. Например, модуль обработки операций с плавающей
точкой мог бы обнаружить денормализованный операнд, обработать
маскированный ответ на это исключение и затем выявить
отрицательное перепольнение.

16.2.1.1 Автоматическая обработка исключений
----------------------------------------------------------------

Процессор i486 имеет шесть фиксированных ответов на каждое
возможное условие исключения, которое он может встретить. Эти
маскированные ответы на исключения разработаны для того, чтобы
сделать работу процессора надежной и приемлемой для большинства
вычислительных прикладных программ.

Примером того, как можно автоматически и надежно обработать даже
серьезные исключения, используя ответы по умолчанию на
исключения, может послужить вычисление параллельного
сопротивления различных резисторов с использованием всего лишь
стандартной формулы (Рисунок 16-3). Если R1 будет равен нулю, то
сопротивление цепи тоже будет равно нулю. При маскированных
исключениях деления на ноль и точности, процессор i486 будет
выдавать корректный результат.

Маскируя или немаскируя особые числовые ситуации в управляющем
слове модуля обработки операций с плавающей точкой, программист
может переложить ответственность за обработку большинства
исключений на процессор i486, оставляя за программным
обработчиком исключений обработку серьезных исключений. Написать
программный продукт, обрабатывающий исключения, часто является
довольно трудным делом и маскированные ответы специально
приспособлены для того, чтобы достичь максимально разумного
результата при каждом условии. Для большинства программных
продуктов маскирование всех исключений приносит
удовлетворительный результат при наименьших усилиях со стороны
программиста. Конкретные исключения иногда бывает полезно
оставить немаскируемыми в процессе отладочной фазы разработки
программного обеспечения, а затем, как только программа
отлажена, маскировать. Например, исключение недопустимой
операции обычно указывает на ошибку в программе, которую следует
исправить.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│           ────────────┬────────────┬────────────┐             │
│                       │            │            │             │
│                       │            │            │             │
│                       >            >            >             │
│                    R1 <         R2 <         R3 <             │
│                       >            >            >             │
│                       │            │            │             │
│                       │            │            │             │
│           ────────────┴────────────┴────────────┘             │
│                                                               │
│                                             1                 │
│     ЭКВИВАЛЕНТНОЕ СОПРОТИВЛЕНИЕ = ─────────────────────       │
│                                     1       1       1         │
│                                   ───── + ───── + ─────       │
│                                     R1      R2      R3        │
│                                                               │
│                                                    240486/101 │
└───────────────────────────────────────────────────────────────┘

Рисунок 16-3. Арифметический Пример Использования Бесконечности

Флаги исключений в слове состояния модуля обработки операций с
плавающей точкой предоставляют собой совокупную запись
исключений, которые произошли с того времени, когда эти флаги
были последний раз очищены. Установленные флаги можно очистить,
только выполнив команду FCLEX (сброс исключений),
переиницианализировав модуль обработки операций с плавающей
точкой или переписав флаги с помощью команд FRSTOR или FLDENV.
Это позволяет программисту маскировать все исключения, запустить
вычисления и затем проверить слово состояния для того, чтобы
посмотреть, была ли обнаружена какое-нибудь исключение в
какой-либо точке вычислений.

16.2.1.2 Программная обработка исключений
----------------------------------------------------------------

Если модуль обработки операций с плавающей точкой встречает
немаскированное условие исключения, то немедленно вызывается
программный обработчик исключений перед тем как выполнить
следующую команду WAIT или не управляющую команду с плавающей
точкой. В зависимости от значения бита NE управляющего регистра
CR0, обработчик исключений вызывается либо через вектор
прерывания 16, либо через внешнее прерывание.

Если NE = 1, то немаскированное исключение с плавающей точкой
обрабатывается через прерывание 16 непосредственно перед
выполнением следующей команды WAIT или не управляющей команды с
плавающей точкой. Прерывание 16 является вызовом операционной
системы, которое в свою очередь вызывает обработчик
исключения. В Главе 9 приведены общие соображения
относительно исключений и прерываний процессора i486.

Если NE = 0 (и ввод IGNNE# не является активным), то
немаскированное исключение с плавающей точкой замораживает
процессор непосредственно перед выполнением следующей
не управляющей команды с плавающей точкой или команды WAIT.
Замороженный процессор ожидает внешнее прерывание, которое
должно исходить от внешнего аппаратного обеспечения в ответ на
вывод FERR# процессора. (Вне зависимости от значения NE,
причиной активности вывода FERR# является немаскированное
числовое исключение.) В этом случае внешнее прерывание вызывает
процедуру обработки исключения. Если NE = 0, но активен ввод
IGNNE#, процессор не обращает внимания на исключение и
продолжает работу. Ошибка, проходящая через внешнее прерывание,
поддерживается только для совместимости с DOS. В Главе 25
приведено дальнейшее обсуждение подобной совместимости.

Процедура обработки исключений является обычно частью
программного обеспечения систем. Типичные ответы на
исключения включают:

- Увеличение на единицу счетчика исключений для дальнейшего
  вывода на экран или принтер.

- Печать или вывод на экран диагностической информации (то есть
  текущее состояние модуля обработки операций с плавающей точкой
  и регистров).

- Прекращение дальнейшего выполнения или использование
  указателей исключений для того, чтобы сделать команду, которая
  будет работать без генерации исключений, и ее выполнение.

Прикладным программистам следует обратиться к справочному
руководству по операционной системе для получения информации о
соответствующих ответах системы на числовые исключения. Для
системных программистов в Главе 19 приводятся некоторые детали
написания программных обработчиков исключений.

16.2.2 Недопустимые операции
----------------------------------------------------------------

Исключение может возникнуть в ответ на следующие два общих
класса операций:

1.  Операции со стеком

2.  Арифметические операции

Флаг стека (SF) слова состояния указывает, какой класс операций
вызвал исключительную ситуацию. Если SF = 1, то операция со
стеком привела к переполнению или отрицательному переполнению.
Если SF = 0, то арифметическая команда встретила недопустимый
операнд.

16.2.2.1 Исключение по стеку
----------------------------------------------------------------

Если SF = 1, указывая на стековую операцию, то бит O/U# кода
условия (бит C1) может показывать, что произошло - переполнение
или отрицательное переполнение стека:

O/U# = 1   Переполнение стека - команда попыталась загрузить
           что-либо в непустой регистр стека.

O/U# = 0   Отрицательное переполнение стека - команда
           попыталась прочитать операнд из пустого регистра
           стека.

Если исключение недопустимой операции маскировано, модуль
обработки операций с плавающей точкой возвращает
неопределенность QNaN. Это значение переписывает принимающий
регистр, разрушая его предыдущее содержание.

Если исключение недопустимой операции не маскировано, то
вызывается обработчик исключений. При этом вершина стека TOP не
изменяется и исходные операнды остаются нетронутыми.

16.2.2.2 Недопустимые арифметические операции
----------------------------------------------------------------

Этот класс включает в себя недопустимые операции, определенные в
стандарте IEEE 854. Модуль обработки операций с плавающей точкой
будет выдавать сообщение о недопустимой операции в любом из
перечисленных в Таблице 16-11 случаев. В этой таблице показаны
также ответы модуля обработки операций с плавающей точкой при
маскированном исключении недопустимой операции. Если
исключение не маскировано, то вызывается обработчик исключений
и операнды остаются неизмененными. Обычно недопустимая операция
указывает на ошибку в программе.

  Таблица 16-11. Маскированные Ответы на Недопустимые Операции

┌───────────────────────────────┬───────────────────────────────┐
│           Условие             │     Маскированный Ответ       │
├───────────────────────────────┼───────────────────────────────┤
│                               │                               │
│ Любая арифметическая операция │ Возвращает неопределенность   │
│ над неподдерживаемым форматом.│ типа QNaN.                    │
│                               │                               │
│ Любая арифметическая операция │ Возвращает QNaN (смотрите     │
│ над сигнальным SNaN.          │ раздел "Правила генерирования │
│                               │ QNaN").                       │
│                               │                               │
│ Операции сравнения и тестиро- │ Устанавливает коды условия    │
│ вания; один или оба операнда  │ как "не сравнимы".            │
│ являются типом NaN.           │                               │
│                               │                               │
│ Сложение противоположных по   │ Возвращает неопределенность   │
│ знаку бесконечностей или      │ типа QNaN.                    │
│ вычитание бесконечностей с    │                               │
│ одинаковым знаком.            │                               │
│                               │                               │
│ Умножение: oo x 0 или 0 x oo. │ Возвращает неопределенность   │
│                               │ типа QNaN.                    │
│ Деление: oo / oo или 0 / 0.   │ Возвращает неопределенность   │
│                               │ типа QNaN.                    │
│ Команды взятия остатка        │ Возвращает неопределенность   │
│ FPREM, FPREM1, когда делитель │ типа QNaN. Устанавливает      │
│ равен 0 или делимое равно oo. │ бит C2.                       │
│                               │                               │
│ Тригонометрические команды    │ Возвращает неопределенность   │
│ FCOS, FPTAN, FSIN, FSINCOS,   │ типа QNaN. Устанавливает      │
│ когда аргумент равен oo.      │ бит C2.                       │
│                               │                               │
│ FSQRT над отрицательным опе-  │ Возвращает неопределенность   │
│ рандом (за исключением FSQRT  │ типа QNaN.                    │
│ (-0) = -0), FYL2X над отрица- │                               │
│ тельным операндом (за исклю-  │                               │
│ чением FYL2X (-0) = -oo),     │                               │
│ FYL2XP1 над отрицательным     │                               │
│ операндом, меньшим -1.        │                               │
│                               │                               │
│ Команды FIST(P), когда ре-    │ Сохраняет целочисленную       │
│ гистр-источник пуст или содер-│ неопределенность.             │
│ жит NaN, oo, или выходит за   │                               │
│ представимый диапазон приемни-│                               │
│ ка.                           │                               │
│                               │                               │
│ Команда FBSTP, когда регистр- │ Сохраняет упакованную         │
│ -источник пуст или содержит   │ целочисленную неопределен-    │
│ NaN, oo, или превышает 18     │ ность.                        │
│ десятичных цифр.              │                               │
│                               │                               │
│ Команда FXCH, когда один или  │ Заменяет пустые регистры на   │
│ оба регистра помечены как     │ неопределенность типа QNaN, а │
│ пустые.                       │ затем обрабатывает измененные │
│                               │ регистры.                     │
│                               │                               │
└───────────────────────────────┴───────────────────────────────┘


16.2.3 Деление на ноль
----------------------------------------------------------------

Если будет предпринята попытка разделить конечный ненулевой
операнд на ноль, модуль обработки операций с плавающей точкой
выдаст исключение деления на ноль. Это возможно при выполнении
команд F(I)DIV(R)(P), также как и при выполнении других
команд, которые имеют внутреннее деление: FYL2X и FXTRACT. Для
того, чтобы выдать бесконечность со знаком при помощи
исключающего ИЛИ знаков операндов, имеется маскированный ответ
на команды FDIV и FYL2X. Для команды FXTRACT регистр ST(1)
устанавливается на минус бесконечность, ST устанавливается на
ноль с тем же знаком, что и начальный операнд. Если
исключение деления на ноль не маскировано, вызывается
обработчик исключений и операнды остаются неизменными.

16.2.4 Денормальные операнды
----------------------------------------------------------------

Если арифметическая команда пытается оперировать денормальными
операндами, модуль обработки операций с плавающей точкой выдает
исключение с денормальными операндами. Денормальные операнды
могут иметь уменьшенную значимость из-за потери младших битов,
следовательно может быть желательно предотвратить операции над
этими операндами в некоторых конкретных программах. Это может
быть достигнуто с помощью обработчика исключений, который
реагирует на немаскированные исключения денормальных чисел.
Большинство пользователей будут маскировать эту исключение для
того, чтобы можно было выполнить вычисления. При этом
пользователь может проанализировать любые потери точности при
получении конечного результата.

Если это исключение маскировано, модуль обработки операций с
плавающей точкой устанавливает бит D в слове состояния, а затем
выполняет команду. Последовательное отрицательное переполнение и
денормальные числа при обработке на процессоре i486 будут
выдавать хорошие результаты, и часто даже лучше, чем полученные
на машинах, которые сводят отрицательные переполнения к нулю.
Фактически, денормальные операнды в простом и двойном формате
точности при загрузке в модуль обработки операций с плавающей
точкой будут нормализованы и приведены к расширенному
вещественному формату. При этом последовательные операции будут
выигрывать от добавочной точности внутреннего вещественного
расширенного формата.

Если это исключение не маскировано, будет установлен бит D и
вызван обработчик исключений. При этом операнды не будут тронуты
командой и могут быть использованы обработчиком для проверки.

Модуль обработки операций с плавающей точкой процессора i486 и
математический сопроцессор 387 обрабатывают денормальные числа
несколько иначе чем сопроцессоры 8087 и 80287. Эти изменения
сделаны из-за пересмотра стандарта IEEE перед его внедрением.
Различия в операциях проявляются при маскировании исключения
денормальных чисел. Модуль обработки операций с плавающей точкой
процессора i486 и математический сопроцессор 387 автоматически
нормализуют денормальные числа. Сопроцессоры 8087 и 80287 выдают
денормальный результат.

Различия в обработке денормальных чисел не лежат на виду.
Исключения денормальных чисел обычно маскированы для
сопроцессора 387 и модуля обработки операций с плавающей точкой
процессора i486. Для программ, которые работают на
математическом сопроцессоре 80287, исключения денормальных
чисел часто не маскируются и необходимо вызывать обработчик
исключений для того, чтобы нормализовать любые денормальные
значения. Такого рода обработчики исключений являются излишними
для процессора i486 и сопроцессора 387 DX - для них обработчик
исключений денормальных чисел используется по умолчанию.

Программа может обнаружить эти ситуации и в процессе работы как
на сопроцессоре 387 или модуле обработки операций с плавающей
точкой процессора i486, так и на старых математических
сопроцессорах 8087/80287. Для сопроцессоров 8087/80287
рекомендуется использовать последовательность кодов, приведенных
на Рисунке 16-4. Этот пример на Рисунке 16-4 можно использовать
для выборочного маскирования исключений денормальных чисел на
процессоре i486 или сопроцессоре 387 DX. Для поддержки
математических сопроцессоров 8087/80287 необходим обработчик
исключений денормальных чисел. Этот пример программы может быть
также использован для установки флага, который позволяет
использовать новые команды, добавленные к основному набору
команд сопроцессоров 8087/287 в устройствах обработки операций с
плавающей точкой i486 и 387.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│                                                               │
│ FINIT            ; Использовать режим бесконечности,          │
│                  ; установленный по умолчанию:                │
│                  ; компьютерный для сопроцессоров 8087/80287, │
│                  ; афинный для сопроцессора 387 DX и i486 FPU │
│ FLD1             ; Генерировать бесконечность                 │
│ FLDZ                                                          │
│ FDIV                                                          │
│ FLD     ST       ; Сформировать отрицательную бесконечность   │
│ FCHS                                                          │
│ FCOMMP           ; Сравнить +бесконечность с -бесконечностью  │
│ FSTSW   temp     ; Для сопроцессоров 8087/80287 они равны     │
│ MOV     AX, temp                                              │
│ SAHF                                                          │
│ JZ      Using_8087                                            │
│                                                               │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

        Рисунок 16-4. Программа Обнаружения Сопроцессора


16.2.5 Числовые переполнения и числовые отрицательные
       переполнения
----------------------------------------------------------------

Если порядок числового результата слишком большой для
принимающего вещественного формата, то модуль обработки операций
с плавающей точкой выдает числовое переполнение. С другой
стороны, если порядок результата слишком мала для того, чтобы
быть представленой в принимающем формате, выдается отрицательное
числовое переполнение. Таким образом, если случается одно из
этих исключений, то это значит, что результат операции вышел за
рамки принимающего вещественного формата.

Большинство алгоритмов обычно производят особо большие и особо
малые числа при промежуточных вычислениях, а не в конечном
результате. Из-за большого диапазона расширенного вещественного
формата, переполнения и отрицательные переполнения являются
относительно редкими событиями в большинстве вычислительных
программных продуктов для процессора i486.

16.2.5.1 Переполнения
----------------------------------------------------------------

Исключение переполнения может возникнуть всегда, когда
округленный истинный результат превышает по значению наибольшее
конечное число в принимающем формате. Исключение может произойти
при выполнении большинства арифметических команд и некоторых
команд перевода формата, а именно: FST(P), F(I)ADD(P),
F(I)SUB(R)(P), F(I)MUL(P), FDIV(R)(P), FSCALE, FYL2X и FYL2XP1.

Ответ на условие переполнения зависит от того, маскировано ли
исключение переполнения:

- Исключение переполнения маскировано. Возвращаемое значение
  зависит от режима округления (смотрите Таблицу 16-12).

- Исключение переполнениния не маскировано. Немаскируемый ответ
  зависит от того, как предполагает команда сохранять результат
  - в стеке или в памяти:

  -  Если в стеке, то истинный результат делится на 2**(24576) и
     округляется. (Смещенный порядок 24576 равен 3 x 2**(13).)
     Мантисса округляется до требуемой точности (для тех
     команд, которые зависят от бита управления точностью (PC)
     управляющего слова, округление идет в зависимости от этого
     бита, в противном случае округляется до расширенной
     точности). При этом бит округления вверх (C1) слова
     состояния устанавливается, если мантисса была округлена с
     избытком.

     Уменьшение порядка числа на 24576 обычно приводит число
     насколько возможно ближе к середине диапазона порядка, так
     что, если это необходимо, его можно использовать в
     последовательных операциях масштабирования с наименьшим
     риском получить дальнейшие исключения. Однако при
     использовании команд FSCALE может случиться, что результат
     будет слишком большой, и произойдет переполнение даже после
     смещения порядка. В этом случае, немаскированный ответ
     является по существу тем же самым, что и маскированный
     округленный до ближайшего, а именно плюс/минус
     бесконечностью. Основная цель - гарантировать, что
     обработчик внутренних прерываний обнаружит, что уменьшение
     показателя на 24576 не приведет к корректной работе без
     определения программистом, который программирует
     показательные функции и процедуры перевода из десятичного в
     бинарный вид, какой обработчик внутренних прерываний
     следует вызвать, если их несколько.

  -  Если в памяти (это может случится только с командами
     сохранения), то никакие результаты в ней не сохраняются.
     Вместо этого, операнд остается нетронутым в стеке. Так как
     данные в стеке имеют формат расширенной точности,
     обработчик исключений либо заново выполняет команду
     сохранения после некоторых исправлений операнда, либо
     округляет мантиссу в стеке до точности принимающего
     формата, как требует стандарт. В конечном счете обработчик
     исключений должен сохранять значение в принимающем формате
     в памяти при продолжении программы.

     Таблица 16-12. Результаты Маскированного Переполнения

┌────────────────────┬──────────────────┬───────────────────────┐
│       Режим        │  Знак Истинного  │      Результат        │
│     Округления     │    Результата    │                       │
├────────────────────┼──────────────────┼───────────────────────┤
│                    │                  │                       │
│ До ближайшего      │        +         │ +oo                   │
│                    │        -         │ -oo                   │
│                    │                  │                       │
├────────────────────┼──────────────────┼───────────────────────┤
│                    │                  │ Наибольшее конечное   │
│ К -бесконечности   │        +         │ положительное число   │
│                    │        -         │ -oo                   │
│                    │                  │                       │
├────────────────────┼──────────────────┼───────────────────────┤
│                    │                  │                       │
│ К +бесконечности   │        +         │ +oo                   │
│                    │        -         │ Наибольшее конечное   │
│                    │                  │ отрицательное число   │
├────────────────────┼──────────────────┼───────────────────────┤
│                    │                  │ Наибольшее конечное   │
│ По направлению     │        +         │ положительное число   │
│ к нулю             │        -         │ Наибольшее конечное   │
│                    │                  │ отрицательное число   │
└────────────────────┴──────────────────┴───────────────────────┘


16.2.5.2 Отрицательные переполнения
----------------------------------------------------------------

Отрицательные переполнения могут возникнуть при выполнении
команд FST(P), FADD(P), FSUB(RP), FMUL(P), F(I)DIV(RP), FSCALE,
FPREM(1), FPTAN, FSIN, FCOS, FSINCOS, FPATAN, F2XM1, FYL2X и
FYL2XP1.

Два события могуть вызвать отрицательное переполнение:

1.  Получение маленького результата, который из-за того, что он
    слишком мал, может привести в дальнейшем к некоторым другим
    исключениям (таким, как переполнение при делении).

2.  Получение неточного результата; то есть полученный результат
    будет отличаться от того, который был бы вычислен при
    неограниченном диапазоне порядка и точности.

Какое из этих событий вызовет исключение отрицательного
переполнения зависит от того, маскировано ли исключение:

1. Исключение отрицательного переполнения маскировано.
   Исключение будет вызвана как при маленьком, так и при
   неточном результате.

2. Исключение отрицательного переполнения не маскировано.
   Исключение будет генерироваться при маленьком результате, не
   игнорироваться при неточности.

Ответ на исключение отрицательного переполнения также зависит от
того, маскировано ли исключение:

1.  Маскированный ответ. Результат является денормальным числом
    или нулем. Также генерируется исключение точности.

2.  Немаскированный ответ. Немаскируемый ответ зависит от того,
    как предполагает команда сохранять результат - в стеке или в
    памяти:

    - Если в стеке, то истинный результат умножается на
      2**(24576) и округляется. (Смещенный порядок 24576 равен 3
      x 2**(13).) Мантисса округляется до требуемой точности
      (для тех команд, которые зависят от бита управления
      точностью (PC) управляющего слова, округление идет в
      зависимости от этого бита, в противном случае округляется
      до расширенной точности). При этом бит округления вверх
      (C1) слова состояния устанавливается, если мантисса была
      округлена с избытком.

      Увеличение порядка числа на 24576 обычно приводит число
      насколько возможно ближе к середине диапазона порядка, так
      что, если это необходимо, его можно использовать в
      последовательных операциях масштабирования с наименьшим
      риском получить дальнейшие исключения. Однако, при
      использовании команды FSCALE может случиться, что
      результат будет слишком маленький, и произойдет
      отрицательное переполнение даже после смещения порядка. В
      этом случае, немаскированный ответ является по существу
      тем же самым, что и маскированный округленный до
      ближайшего, а именно плюс/минус нулем. Основная цель -
      гарантировать, что обработчик внутренних прерываний
      обнаружит, что увеличение показателя на 24576 не приведет
      к корректной работе без определения программистом, который
      программирует показательные функции и процедуры перевода
      из десятичного в бинарный вид, какой обработчик внутренних
      прерываний следует вызвать, если их несколько.

    - Если в памяти (это может случится только с командами
      сохранения), то никакие результаты в ней не сохраняются.
      Вместо этого, операнд остается нетронутым в стеке. Так как
      данные в стеке имеют формат расширенной точности,
      обработчик исключений либо заново выполняет команду
      сохранения после некоторых исправлений операнда, либо
      округляет мантиссу в стеке до точности принимающего
      формата, как требует стандарт. В конечном счете обработчик
      исключений должен сохранять значение в принимающем формате
      в памяти при продолжении программы.

16.2.6 Неточный результат (точность)
----------------------------------------------------------------

Это условие исключения возникает в случае, если результат
операции точно не представим в принимающем формате. Например,
дробь 1/3 нельзя точно представить в двоичной форме. Эта
исключение случается часто и указывает на то, что была несколько
потеряна точность (обычно приемлемо).

По своей природе трансцендентные команды часто являются причиной
возникновения исключений неточности результата.

Бит C1 (округление) слова состояния указывает на то, был ли
результат округлен вверх (C1 = 1) или отсечен (C1 = 0).

Когда происходит потеря точности, то исключению неточности
результа сопутствует исключение отрицательного переполнения.
Если отрицательное переполнение маскировано, то исключение
отрицательного переполнения генерируется только при потере
точности; следовательно также всегда устанавливается и флаг
точности. Если отрицательное переполнение немаскировано, то
может быть или может не быть потери точности; при этом бит
точности указывает, какой из этих случаев имел место.

Это исключение предназначено для прикладных программ, которым
необходимо выполнять только точную арифметику. Большинство
прикладных программ будут маскировать это исключение. Модуль
обработки операций с плавающей точкой передает округленный или
отрицательно переполненный результат в принимающий формат, не
обращая внимания на происходящее внутреннее прерывание.

16.2.7 Приоритетность исключений
----------------------------------------------------------------

Процессор i486 работает с исключениями в соответствии с
предопределенным приоритетом. Приоритеты в обработке
исключений означают, что выбирается исключение с более высоким
приоритетом и далее происходят действия в соответствии с
требованиями именно этого исключения. При этом исключения с
более низкими приоритетами могут и не отмечаться, даже если они
случаются. Например, деление сигнального SNaN на ноль приводит к
исключению недопустимого операнда (из-за SNaN), а не к
исключению деления на ноль; маскированным результатом будет
вещественная неопределенность вида QNaN, а не бесконечность.
Исключения денормальных чисел или неточности результа, однако,
могут генерироваться вместе с исключениями числового
переполнения или числового отрицательного переполнения.

Среди числовых исключений существуют следующие приоритеты:

1. Исключения недопустимой операции подразделяются в порядке
   приоритетов на:

    а.  Отрицательное переполнение стека.

    б.  Переполнение стека.

    в.  Операнд в неподдерживаемом формате.

    г.  Операнд типа SNaN.

2. Операнд типа QNaN. Хотя это и не является исключением, но
   если один операнд имеет тип QNaN, то работа с ним имеет
   приоритет выше, чем низкоприоритетные исключения. Например,
   деление операнда типа QNaN на ноль дает QNaN, а не
   исключение деления на ноль.

3. Все другие выше не упомянутые исключения недопустимых
   операций или деления на ноль.

4. Денормальный операнд. Если маскирован, то продолжается
   выполнение команды, и может иметь место низкоприоритетное
   исключение.

5. Числовое переполнение и числовое отрицательное переполнение.
   При этом может быть отмечен неточный результат.

6. Неточный результат (точность).


16.2.8 Стандартный обработчик исключений, связанных с
       переполнением/отрицательным переполнением
----------------------------------------------------------------

Пока исключения, связанные с переполнением или отрицательным
переполнением, маскированы, не требуется никакое дополнительное
программное обеспечение для того, чтобы обеспечить выходным
данным процессора i486 соответствие с требованиями стандарта
IEEE 854. Если немаскированы, то эти исключения дают обработчику
исключений дополнительные возможности в случае команд
сохранения. Никакие результаты не сохраняются в памяти, вместо
этого операнд остается нетронутым в стеке. Обработчик исключений
может округлить мантиссу операнда в стеке до точности
принимающего формата, как требует стандарт, или подправить
операнд и заново выполнить невыполненную команду.

