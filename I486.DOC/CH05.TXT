Глава 5   Организация памяти
-----------------------------------------------------------------

Организация памяти представляет собой аппаратный механизм,
позволяющий операционной системе создавать для выполняющихся
программ упрощенную среду. Например, при одновременном
выполнении нескольких программ каждой из них должно быть дано
независимое адресное пространство. При разделении всеми этими
программами одного и того же адресного пространства каждая из
них должна была бы выполнять сложные и занимающие много
процессорного времени проверки, чтобы избежать влияния на другие
программы.

Организация памяти состоит из сегментации и подкачки страниц.
Сегментация служит для того, чтобы дать каждой программе
несколько независимых, защищенных адресных пространств. Подкачка
страниц используется для поддержки среды, в которой большие
адресные пространства моделируются на базе небольшой области
оперативной памяти и некоторой дисковой памяти. Разработчики
систем могут использовать как оба этих механизма, так и любой из
них. При одновременном выполнении нескольких программ для защиты
программ от влияния на них других программ можно использовать
любой механизм.

Сегментация позволяет иметь полностью неструктурированную и
простую память, подобную модели памяти 8-битового процессора,
либо высоко структурированную память, с использованием
трансляции адресов и защиты. Средства организации памяти
работают с единицами, которые называются сегментами. Каждый
сегмент представляет собой независимое, защищенное адресное
пространство. Доступ к сегментам управляется данными, в которых
описаны их размер, уровень привилегированности, который нужен
для доступа к ним, типы ссылок к памяти, применимые к этому
сегменту (выборка команды, помещение или извлечение из стека,
операция чтения, операция записи и т.д.), а также его
присутствие в памяти.

Сегментация служит для управления доступом к памяти, что полезно
для нахождения ошибок при разработке программы и для повышения
надежности конечного продукта. Она также используется для
упрощения компоновки объектных модулей кода. Механизм
сегментации делает ненужным создание кодов, независимых от
позиции в памяти, поскольку все ссылки к памяти могут
выполняться относительно базового адреса кодового сегмента и
сегмента данных модуля. Сегментация может быть использована для
создания ПЗУ-резидентных программных модулей, в которых
фиксированные адреса (фиксированные в том смысле, что они не
могут быть изменены) представляют собой смещения относительно
базового адреса сегмента. Различные программные системы могут
иметь модули ПЗУ в различных физических адресах, поскольку
механизм сегментации в любом случае позволяет правильно
направить все ссылки к памяти.

В случае простой архитектуры памяти все адреса относятся к
одному и тому же адресному пространству. Это модель памяти,
используемая 8-битовыми микропроцессорами, такими как 8080, где
логический и физический адреса совпадают. Процессор i486 может
быть использован подобным же образом посредством отображения
всех сегментов в одном и том же адресном пространстве и
запрещения подкачки страниц памяти. Такая модель может
понадобиться при адаптации старых разработок для 32-разрядной
машины без учета новых архитектурных средств этой машины.

Прикладная программа также частично может использовать механизм
сегментации. Частая причина отказа программного обеспечения
состоит в том, что стек растет и "вклинивается" в область
командных кодов или данных программы. Для того, чтобы
предотвратить такого рода ошибку, можно воспользоваться
мехнизмом сегментации. Стек можно поместить в другое адресное
пространство, нежели то, где находятся кодовый сегмент и сегмент
данных. Адреса стека всегда будут относиться к памяти стекового
сегмента, тогда как адреса данных всегда будут относиться к
памяти, распределенной сегменту данных. Стековый сегмент будет
иметь максимальный размер, принудительно установленный
аппаратным обеспечением. Любая попытка увеличить размер стека за
установленное значение приведет к возникновению исключения.

Сложная программная система может использовать все средства,
предоставляемые сегментацией. Например, система, в которой
программы разделяют данные в режиме реального времени, может
иметь возможность очень точно управлять доступом к этим данным.
Когда программа делает попытку неверного доступа к данным, такая
ошибка приводит к генерированию исключения. Это может служить
как вспомогательное отладочное средство при разработке
программы, а также может использоваться для запуска
восстановительных процедур при ошибке в системах,
предназначенных для конечного пользователя.

Аппаратное обеспечение сегментации транслирует сегментированный
(логический) адрес в адрес непрерывного, несегментированного
адресного пространства, который называется линейным адресом.
Если разрешена подкачка страниц, то аппаратное обеспечение
подкачки транслирует линейный адрес в физический адрес. Если
подкачка страниц не разрешена, то в качестве физического адреса
используется сразу линейный адрес. Физический адрес подается на
выходящую из процессора адресную шину.

Подкачка страниц представляет собой механизм, который служит для
моделирования большого несегментированного адресного
пространства при помощи малого фрагментированного адресного
пространства и некоторого объема дисковой памяти. Подкачка
страниц обеспечивает доступ к структурам данных, превышающим по
размеру доступное пространство оперативной памяти, благодаря
тому, что часть таких структур держится в оперативной памяти, а
часть - на диске.

Подкачка выполняется по блокам размером в 4К, которые и
называются страницами. Когда программа пытается обратиться к
странице, которая в этот момент находится на диске, в программе
происходит специальное прерывание. В отличие от прочих
исключений и прерываний, исключение, генерируемое при
транслировании адреса, восстанавливает содержимое регистров
процессора в значения, позволяющие повторить выполнение команды,
вызвавшей данное исключение. Такие специальные действия носят
названия перезапуска команды. Это позволяет операционной системе
прочесть страницу с диска, обновить отображение линейных адресов
в физические адреса для данной страницы и перезапустить
программу. Такой процесс прозрачен для программы.

Если операционная система никогда не устанавливает бит 31
регистра CR0 (бит PG), механизм подкачки страниц никогда не
будет разрешен. Тогда линейные адреса будут одновременно
являться и физическими адресами. Это может быть в тех случаях,
когда разработка, которая была сделана для 16-разрядного
процессора, адаптируется для использования 32-разрядного
процессора. Операционная система, написанная для 16-разрядного
процессора, не использует механизма подкачки страниц, поскольку
размер ее адресного пространства настолько мал (64Кбайт), что
гораздо более эффективным является механизм свопинга между
оперативной памятью и диском целых сегментов, нежели отдельных
страниц памяти.

Подкачка страниц должна быть разрешена для операционных систем,
которые могут поддерживать виртуальную память с подкачкой
страниц по требованию, например UNIX. Подкачка страниц прозрачна
для прикладного программного обеспечения, поэтому операционная
система, которая должна поддерживать прикладные программы,
написанные для 16-битовых процессоров, может выполнять эти
программы с разрешенной подкачкой страниц. В отличие от
подкачки, сегментация не прозрачна для прикладных программ.
Программы, использующие сегментацию, должны выполняться с теми
сегментами, которые были назначены для использования при
разработке этих программ.

5.1  Выбор модели сегментации
-----------------------------------------------------------------

Выбор модели сегментации памяти выполняется на основе требований
надежности и быстродействия. Например, система, состоящая из
нескольких программ, разделяющих данные в режиме реального
времени, будет иметь наилучшие характеристики быстродействия при
выборе модели, которая аппаратно контролирует ссылки к памяти.
Это многосегментная модель памяти.

В качестве другой крайности, рассмотрим систему, состоящую всего
из одной выполняемой программы - такая система позволяет
получить максимальный выигрыш в случае несегментированной
"плоской" модели памяти. Отсутствие в программе "дальних"
указателей и префиксов переопределения сегмента уменьшает размер
кода и увеличивает его быстродействие. Также быстрее выполняются
контекстные перключения, поскольку нет необходимости сохранять и
восстанавливать содержимое сегментных регистров.

Некоторые преимущества от использования сегментации также
обеспечиваются за счет подкачки страниц. Например, разделение
данных может выполняться за счет отображения одних и тех же
страниц памяти в адресное пространство каждой программы.

5.1.1  Плоская модель
-----------------------------------------------------------------

Самой простой моделью является плоская модель. В этом случае все
сегменты отображаются в единое физическое адресное пространство.
Смещение сегмента может относиться либо к области кода, либо к
области данных. Данная модель в наивысшей степени исключает
механизм сегментации из архитектуры, видимой как разработчику
системы, так и прикладному программисту. Такая модель выбирается
для программной среды типа UNIX, которая поддерживает подкачку
страниц, но не поддерживает сегментацию.

Сегмент определяется дескриптором сегмента. Для плоской модели
должно создаваться минимум два дескриптора, один для ссылок к
коду, а другой для ссылок к данным. Оба дескриптора имеют
одинаковое значение базового адреса. Всякий раз при доступе к
памяти содержимое одного из сегментных регистров используется
для выбора дескриптора сегмента. Дескриптор сегмента содержит
базовый адрес сегмента и его границу, а также информацию,
управляющую доступом (см. Рисунок 5-1).

Сегментные            Дескрипторы         Физическая
регистры              сегментов           память

-----------                               --------------------4Гб
|   CS    |----                           | ППЗУ (EPROM)     |
-----------    |                          |------------------|
-----------    |                          |                  |
|   SS    |--  |      ----------------    |                  |
-----------  |  -->   |Доступ|Граница|    |                  |
-----------   ---->   ----------------    |                  |
|   DS    |------->   |Базовый адрес |    |                  |
-----------     -->   ----------------    |                  |
-----------    |                     |    |------------------|
|   ES    |----                      |    |Опер.память(DRAM) |
-----------                           --> -------------------- 0

                  Рисунок 5-1  Плоская модель


В вершине физического адресного пространства обычно помещается
ПЗУ, посколько процессор начинает выполнение с адреса
0FFFFFFF0H. Оперативная память находится в нижней части
адресного пространства, поскольку начальный базовый адрес
сегмента данных DS после инициализации сброса системы
устанавливается в 0.

Для плоской модели каждый дескриптор имеет базовый адрес, равный
0, и границу сегмента 4 гигабайта. Установкой границы сегмента в
значение 4 гигабайта механизм сегментации предотвращает
генерацию исключений для ссылок к памяти, выходящих за границу
сегмента. Исключения могут тем не менее генерироваться
механизмами подкачки страниц или защиты сегментации, но и они
могут быть исключены из модели памяти.

5.1.2  Защищенная плоская модель
-----------------------------------------------------------------

Защищенная плоская модель аналогична плоской модели, за
исключением того, что границы сегментов устанавливаются равными
таким диапазонам адресов, которым соответствует фактически
существующая оперативная память. Общее исключение защиты
генерируется при любой попытке доступа к несуществующей памяти.
Эта модель может использоваться в системах, где запрещен
механизм подкачки страниц, поскольку она обеспечивает
минимальный уровень аппаратной защиты от некоторых типов
программных ошибок.

В этой модели аппаратное обеспечение сегментации предотвращает
обращение программ к несуществующим адресам памяти. Последствия
в случае разрешенного доступа к таким адресам памяти зависят от
аппаратного обеспечения. Например, если процессор не получил
сигнала READY# (сигнала квитирования и завершения цикла шины),
то цикл шины не получит завершения, и произойдет остановка
выполнения программы.

Хотя никакие программы не должны делать попытки доступа к таким
адресам памяти, такие попытки все же могут иметь место
вследствие программных ошибок. Без аппаратного контроля адресов
такие ошибки могут иметь следствием внезапную остановку работы
программы. В случае же аппаратного контроля программный сбой
такого рода обрабатывается установленным образом. Может быть
выдано диагностическое сообщение и сделана попытка запустить
восстановительную процедуру.

Пример защищенной плоской модели показан на Рисунке 5-2. Здесь
дескрипторы сегментов устанавливаются таким образом, чтобы
отражать только физически существующие диапазоны памяти. Сегмент
кода и сегмент данных размещаются в физической памяти типа EPROM
(ППЗУ) и DRAM (оперативная память). Граница кодового сегмента
может быть опционально установлена таким образом, чтобы был
разрешен доступ к области DRAM. Граница сегмента данных должна
быть установлена равной сумме размеров EPROM и DRAM. При
использовании ввода/вывода, управляемого памятью, допустима
адресация сегмента данных за концом области оперативной памяти.


Сегментные     Дескрипторы        Физическая    Логические
регистры       сегментов          память        смещения

------        ----------------    -------- 4Гб  --------
| CS |------> |Доступ|Граница|    |EPROM |      |      |
------        ------------------->|------|      |------|
------        |Базовый адрес |  / |      |      |Память|
| ES |----    ---------------- |  |------|      | I/O  |
------    |                    |  |Память|      |------|
------    |                    |  | I/O  |      |      |
| SS |--  |   ----------------/   |------|      | DRAM |
------  |  -> |Доступ|Граница|    |      |      |      |
------   ---> ----------------    |      |      |------|
| DS |------> |Базовый адрес |    |DRAM  |      |EPROM |
------        ----------------    --------  0   --------

             Рисунок 5-2. Защищенная плоская модель


5.1.3  Многосегментная модель
-----------------------------------------------------------------

Наиболее сложной является многосегментная модель. В данном
случае используются все средства, предоставляемые механизмом
сегментации. Каждой программе дается собственная таблица
дескрипторов сегментов и свои собственные сегменты. Эти сегменты
могут либо поступать в исключительное распоряжение программы.
либо могут разделяться другими конкретными программами. Доступ
между программами и конкретными сегментами может управляться
индивидуально.

Для немедленного использования могут быть готовы до шести
сегментов. Существуют сегменты, для которых селекторы сегмента
загружены в сегментные регистры. Доступ к остальным сегментам
выполняется при помощи загрузки соответствующих селекторов
сегмента в сегментные регистры (см. Рисунок 5-3).

Каждый сегмент представляет собой отдельное адресное
пространство. Хотя они и могут располагаться в смежных блоках
физической памяти, механизм сегментации предотвращает доступ к
содержимому одного сегментом посредством выхода за границу
другого сегмента при чтении. Попытка адресации памяти за концом
сегмента ведет к генерации исключения общей защиты.

Механизм сегментации принудительно устанавливает адресный
диапазон, заданный в дескрипторе сегмента. Ответственность за
распределение каждому сегменту отдельного адресного диапазона
лежит на операционной системе. Могут существовать ситуации,
когда желательно иметь сегменты, разделяющие один и тот же
адресный диапазон. Например, система может иметь и код, и
данные, хранимые в ПЗУ. При доступе в ПЗУ для выборки команд
должен быть использован дескриптор кодового сегмента. При
доступе в ПЗУ для выборки оттуда данных должен быть использован
дескриптор сегмента данных.

Сегментные        Дескрипторы                       Физическая
регистры          сегментов                         память

----------        ----------------                  -------------
|   CS   |------> |Доступ|Граница|                  |           |
----------        ------------------------          |           |
                  |Базовый адрес |        |         |           |
                  ----------------        |         |           |
                                          |         |           |
----------        ----------------        |         |           |
|   SS   |------> |Доступ|Граница|        |         |           |
----------        --------------------------------- |           |
                  |Базовый адрес |        |        \|           |
                  ----------------        |         |-----------|
                                          |         |           |
----------        ----------------        |         |           |
|   DS   |------> |Доступ|Граница|         \        |           |
----------        -----------------------   \       |           |
                  |Базовый адрес |        \  \      |           |
                  ----------------         \  \     |           |
                                            \  \    |           |
----------        ----------------           \  \   |           |
|   ES   |------> |Доступ|Граница|            \  \  |           |
----------        --------------------------   \  \ |           |
                  |Базовый адрес |          |   \  \|           |
                  ----------------          |    \  |-----------|
                                            |     \ |           |
----------        ----------------          |      \|           |
|   FS   |------> |Доступ|Граница|          |       |-----------|
----------        ------------------------------    |           |
                  |Базовый адрес |          |   \   |           |
                  ----------------          |    \  |           |
                                            |     \ |           |
----------        ----------------          |      \|           |
|   GS   |------> |Доступ|Граница|          |       |-----------|
----------        ---------------------     |       |           |
                  |Базовый адрес |     \     \      |           |
                  ----------------      \     \     |           |
                                         \     \    |           |
                  ----------------        \     \   |           |
                  |Доступ|Граница|         \     \  |           |
                  --------------------      \     \ |           |
                  |Базовый адрес |   |       \     \|           |
                  ----------------   |        \     |-----------|
                                     |         \    |           |
                  ----------------   |    ------\---|-----------|
                  |Доступ|Граница|   |   |       \  |           |
                  ------------------------        \ |           |
                  |Базовый адрес |   |             \|           |
                  ----------------   --------       |-----------|
                                             \      |           |
                  ----------------        ----------|-----------|
                  |Доступ|Граница|       |     \    |           |
                  ------------------------      \   |           |
                  |Базовый адрес |               \  |           |
                  ----------------                \ |           |
                                                   \|           |
                  ----------------                  |-----------|
                  |Доступ|Граница|                  |           |
                  --------------------------------  |           |
                  |Базовый адрес |                 \|           |
                  ----------------                  -------------

              Рисунок 5-3.  Многосегментная модель


5.2  Преобразование сегмента
-----------------------------------------------------------------

Логический адрес состоит из 16-битового селектора сегмента и 32-
битового смещения в этом сегменте. Логический адрес
транслируется в линейный адрес сложением смещения и базового
адреса сегмента. Базовый адрес берется из дескриптора сегмента -
структуры данных в памяти, которая содержит информацию о размере
и расположении данного сегмента в памяти, а также информацию для
управления доступа. Дескриптор сегмента берется в одной из двух
таблиц, таблицы глобальных дескрипторов (GDT) или таблицы
локальных дескрипторов (LDT). Для всех программ в системе
существует единая таблица GDT, а также по одной таблице LDT для
каждой отдельной выполняемой в текущий момент программы. Если
позволяет операционная система, то разные программы могут
разделять одну и ту же LDT. Система может быть организована
вообще без таблиц LDT; в этом случае все программы будут
использовать GDT.

Каждый логический адрес связан со своим сегментом (даже если
система отображает все сегменты в одно и том же линейное
адресное пространство). Хотя программа может иметь тысячи
сегментов, для немедленного использования доступны только шесть
из них. Имеется шесть сегментов, селекторы которых загружены в
процессор. Селектор сегмента содержит информацию, используемую
для транслирования логического адреса в соответствующий линейный
адрес.

Для каждого вида ссылки к памяти (пространству кода,
пространству стека и пространствам данных) в процессоре
существуют отдельные сегментные регистры. Они содержат селекторы
текущих используемых сементов. Доступ к другим сегментам требует
загрузки сегментного регистра с помощью разновидности команды
MOV. Одновременно может быть доступно до четырех сегментов
данных, что в сумме с остальными составляет шесть сегментных
регистров.

При загрузке селектора сегмента также происходит загрузка в
сегментный регистр базового адреса, границы сегмента и
информации, управляющей доступом. После этого процессор уже не
обращается к таблицам дескрипторов до тех пор, пока не
произойдет загрузка другого селектора сегмента. Информация,
хранимая процессором, позволяет ему выполнять адресные
транслирования, не тратя на это лишних циклов шины. В системах,
где несколько процессоров имеют доступ к одним и тем же таблицам
дескрипторов, ответственность за перезагрузку сегментных
регистров при модификации таблиц дескрипторов лежит на
программном обеспечении системы. Если этого не сделать, то может
произойти использование старого дескриптора сегмента,
кешированного в сегментный регистр, уже после модификации его
резидентной в памяти версии.

Селектор сегмента содержит 13-разрядный индекс для одной из
дескрипторных таблиц. Индекс умножается на восемь (число байтов
в дескрипторе сегмента) и складывается с 32-битовым базовым
адресом дескрипторной таблицы. Базовый адрес берется из регистра
таблицы глобальных дескрипторов (GDTR), либо из регистра таблицы
локальных дескрипторов (LDTR). Эти регистры содержат линейный
адрес начала дескрипторных таблиц. Бит в селекторе сегмента
определяет, какая таблица должна быть использована, как показано
на Рисунке 5-4.


 Селектор сегмента          Таблица                Таблица
                          глобальных              локальных
--------------------     дескрипторов            дескрипторов
|          |T|     |
|          |I|     |
--------------------
            |                  TI=0                   TI=1
             -------------------------------------------
                                 |                      |
                                \/                     \/
                         -----------------      -----------------
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                         |---------------|      |---------------|
                         |       |       |      |       |       |
                         |---------------|      |---------------|
                         |               |      |               |
                -------> -----------------  --> -----------------
               |                            |
               |                            |
               |                            |
               |  -------------             |    -------------
               |  | Селектор  |             |    | Селектор  |
               |  -------------             |    -------------
               |  | Граница   |             |    |  Граница  |
           --------------------         ----------------------
           |  Базовый  адрес  | GDTR    |  Базовый  адрес    | LDTR
           --------------------         ----------------------

     Рисунок 5-4. Бит TI выбирает таблицу дескрипторов


Преобразованный адрес представляет собой линейный адрес, как
показано на Рисунке 5-5. Если подкачка страниц не используется,
то он одновременно является и физическим адресом. Если подкачка
используется, то физический адрес получается на втором уровне
преобразования адреса. Трансляция адресов описана в разделе 5.3.


            15                0    31                           0
Логический  --------------------   ------------------------------
адрес       |    Селектор      |   |        Смещение            |
            --------------------   ------------------------------
                 |         |                     |
          -------          \/                    |
          |       Таблица                        |
          |    дескрипторов                      |
          |   --------------                     |
          |   |            |                     |
          |   |            |                     |
          |   |------------|                     |
          |   | Дескриптор | Базовый   -----     |
           -->|  сегмента  |---------->| + |<----
              |------------| адрес     -----
              |            |             |
              --------------             |
                            31           \/          0
                           ---------------------------
                 Линейный  |Каталог|Страница|Смещение|
                 адрес     ---------------------------

            Рисунок 5-5. Трансляция адреса сегмента


5.2.1  Сегментные регистры
-----------------------------------------------------------------

Каждый вид ссылок к памяти связан с соответствующим сегментным
регистром. Ссылки к коду, данным и стеку выполняются посредством
доступа к содержимому соответствующих сегментных регистров. Во
время выполнения программы возможен доступ и к другим сегментам,
для чего требуется загрузить селекторы нужных сегментов в
сегментные регистры.

Каждый сегментный регистр имеет "видимую" и "невидимую" часть,
как показано на Рисупке 5-6. Для загрузки видимой части
сегментных регистров используются разновидности команды MOV,
невидимая часть загружается самим процессором.


     Видимая часть         Невидимая часть
     ------------------------------------------------
     |  Селектор   |  Базовый адрес, граница и т.д. | CS
     |----------------------------------------------|
     |                                              | SS
     |----------------------------------------------|
     |                                              | DS
     |----------------------------------------------|
     |                                              | ES
     |----------------------------------------------|
     |                                              | FS
     |----------------------------------------------|
     |                                              | GS
     ------------------------------------------------

     Рисунок 5-6. Сегментные регистры



Для загрузки этих регистров используются команды прикладных
программ, описанные в Главе 3. Имеется два типа таких команд:

1. Команды прямой загрузки, такие как MOV, POP, LDS, LSS, LSG и
   LFS. Эти команды обращаются к сегментным регистрам явно.

2. Неявные команды загрузки, такие как версии команд CALL и JMP
   для дальних указателей. Эти команды изменяют содержимое
   регистра CS в процессе их выполнения.

При использовании этих команд, в видимую часть сегментного
регистра загружаются селектор сегмента. Базовый адрес, границу,
тип и прочую информацию процессор извлекает из дескрипторной
таблицы автоматически и помещает их в невидимую часть
сегментного регистра.

Поскольку большинство команд ссылается на сегменты, селекторы
которых уже загружены в сегментные регистры, процессор может
прибавлять смещения логического адреса к базовому адресу
сегмента без потерь быстродействия.


5.2.2  Селекторы сегмента
-----------------------------------------------------------------

Селектор сегмента указывает на информацию, определяющую сегмент,
которая называется дескриптором сегмента. В программе может
использоваться больше шести сегментов, селекторы которых
занимают сегментные регистры. В таком случае программа
использует разновидности команды MOV для изменения содержимого
этих регистров всякий раз, когда ей требуется доступ к новому
сегменту.

Селектор сегмента идентифицирует дескриптор сегмента, задавая
таблицу дескрипторов и позицию нужного дескриптора в этой
таблице. Селекторы сегмента видны прикладной программе в
качестве части переменной типа указателя, однако обычно значения
селекторов назначаются или модифицируются редакторами связей или
компонующими загрузчиками, но не прикладными программами. Формат
селектора сегмента показан на Рисунке 5-7.

Индекс: выбирает один из 8192 дескрипторов в таблице
дескрипторов. Процессор умножает значение индекса на 8 (число
байтов в дескрипторе сегмента) и складывает результат с базовым
адресом таблицы дескрипторов (берется из регистра GDTR или
LDTR).

Бит-индикатор таблицы (TI): задает используемую таблицу
дескрипторов. Если этот бит очищен, то выбирается таблица GDT;
если же он установлен, то выбирается текущая таблица LDT.

Запрошенный уровень привилегированности (RPL):если это поле
содержит уровень привилегированности с большим значением, чем
программа (т.е. привилегированность меньше), то оно
переопределяет уровень привилегированности программы. Если
программа использует менее привилегированный селектор сегмента,
доступ к памяти происходит с меньшим уровнем
привилегированности. Это свойство используется для защиты от
нарушения безопасности данных, если менее привилегированная
программа пытается использовать более привилегированную
программу для доступа к защищенным данным.


     15                         3  2  1 0
     -------------------------------------
     |                            |T|    |
     |       Индекс               |I|RPL |
     |                            | |    |
     -------------------------------------

     Индикатор таблицы (TI) (0=GDT, 1=LDT)
     Запрошенный уровень привилегированности (RPL)
     (00=наибольшая привилегированность, 11=наименьшая)

                 Рисунок 5-7. Селектор сегмента

Например, системные утилиты или драйверы устройств должны
выполняться с самым высоким уровнем привилегированности с тем,
чтобы иметь возможность доступа к защищенным системным
средствам, таким как управляющие регистры или интерфейс с
периферийными устройствами. Однако, они не должны
взаимодействовать с другими защищенными средствами, даже при
получении такого запроса от менее привилегированных программ.
Если программа запросила прочесть с диска сектор в область
память, занятый более привилегированной программой, например
операционной системой, то RPL может быть использован для
генерации исключения общей защиты, если использованный селектор
сегмента имеет более низкий уровень привилегированности. Данное
исключение возникает даже тогда, когда программа, использующая
данный селектор сегмента, имеет достаточно выский уровень
привилегированности для выполнения такой операции.

Поскольку первый элемент таблицы GDT процессором не
используется, селектор, содержащий индекс со значением 0 и
индикатор таблицы 0 (т.е. селектор, указывающий на первый
элемент GDT), используется в качестве "пустого селектора".
Процессор не генерирует исключения, когда сегментный регистр (не
являющийся регистром CS или SS) загружается пустым селектором.
Однако, исключение генерируется, если сегментный регистр,
содержащий пустой селектор, используется для доступа к памяти.
Это средство может быть использовано для инициализации
неиспользуемых сегментных регистров.

5.2.3  Дескрипторы сегментов
-----------------------------------------------------------------

Дескриптор сегмента представляет собой структуру данных в
памяти, которая сообщает процессору размер и расположение в
памяти сегмента, а также управляющую информацию и информацию о
состоянии сегмента. Дескрипторы обычно создаются компиляторами,
компоновщиками, загрузчиками или операционной системой, но не
прикладными программами. На Рисунке 5-8 показаны два общих
формата дескриптора. Дескриптор системного сегмента более
подробно рассматривается в Главе 6. Все типы дескрипторов
системы имеют один из этих форматов.

База: Определяет расположение сегмента в пределах 4 гигабайтного
физического адресного пространства. Процессор располагает вместе
три поля базового адреса, которые образуют одно 32-битовое
значение. Значения базы сегмента должны быть выравнены по
кратным 16 байтам адресам памяти, что позволяет программам
максимизировать их быстродействие, выравнивая в свою очередь по
кратным 16 байтам адресам памяти код/данные.

Бит грануляции: Включает масштабирование поля Границы масштабным
коэффициентом 4096(2**12). Если этот бит очищен, то граница
сегмента интерпретируется в блоках по 4Кб (т.е. в страницах).
Отметим, что двенадцать наименее значащих битов адреса в случае,
если используется масштабирование, не тестируются. Например,
граница 0 при установленном бите грануляции дает допустимые
смещения от 0 до 4095. Отметим также, что этот коэффициент
действует только на значение поля Границы. Базовый адрес
остается гранулированным по байтам.

Дескрипторы, используемые для сегментов кода и данных
прикладных программ:

               2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
31             4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7            0
---------------------------------------------------------------
|               | | | |A|      | | D | |      |               |
| BASE  31:24   |G|D|0|V|      |P| P |S| TYPE |   BASE 23:16  |
|               | | | |L|      | | L | |      |               |
|-------------------------------------------------------------|
|      Базовый адрес 15:00     |    Граница сегмента 15:00    |
---------------------------------------------------------------

Дескрипторы, используемые для специальных системных сегментов:

               2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
31             4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7            0
---------------------------------------------------------------
|               | | | |A|      | | D | |      |               |
| BASE  31:24   |G|D|0|V|      |P| P |S| TYPE |   BASE 23:16  |
|               | | | |L|      | | L | |      |               |
|-------------------------------------------------------------|
|      Базовый адрес 15:00     |    Граница сегмента 15:00    |
---------------------------------------------------------------

AVL       Доступно для использования системным программным
          обеспечением
BASE      Базовый адрес сегмента
DPL       Уровень привилегированности дескриптора
S         Тип дескриптора
          (0=системный; 1=прикладной)
G         Грануляция
Граница   Граница сегмента
P         Присутствие сегмента
TYPE      Тип сегмента
D         Размер операции по умолчанию
          (Распознается только в дескрипторах кодового сегмента:
           0=16-битовый размер; 1=32-битовый размер)

               Рисунок 5-8  Дескрипторы сегмента

Граница: Определяет размер сегмента. Процессор помещает рядом
два поля границы сегмента, в совокупности образующих одно
20-разрядное значение. Процессор интерпретирует границу одним из
двух слудующих способов, в зависимости от установки бита
грануляции:

1. Если бит грануляции очищен, то граница может принимать
   значения от 1 байта до 1 мегабайта, с приращениями в один
   байт.

2. Если бит грануляции установлен, то граница может принимать
   значения от 4 Килобайт до 4 Гигабайт, с приращениями в 4 Кб.

Для большинства сегментов логический адрес может иметь значение
смещения в диапазоне от 0 до значения границы. Прочие значения
ведут к генерации исключений. Сегменты с расширением вниз
изменяют смысл поля граница на противоположный: они позволяют
адресацию любыми значениями смещения, кроме значений от 0 до
значения границы (см. описание поля Типа, приводимое ниже). Это
позволяет создавать сегменты, для которых увеличение значения
поля Границы приводит к распределению новой памяти в нижней
части адресного пространства, вместо верхней. Сегменты с
расширением вниз предназначены для хранения стеков, но
использовать их не обязательно. Если стек должен быть помещен в
сегмент, который не будет изменять свой размер, то таким
сегментом может быть обычный сегмент данных.

Бит S: Определяет, является ли этот сегмент системным сегментом,
или же сегментом кода или данных. Если бит S установлен, то
сегмент является либо кодовым сегментом, либо сегментом данных.
Если этот бит очищен, то сегмент является системным сегментом.

     Бит D:  Указывает длину операндов и  исполнительных  адресов
сегмента по умолчанию.  Если бит D установлен,  то предполагается
режим 32-разрядных операндов и 32-разрядных исполнительных  адресов.
Если этот бит очищен то предполагается использование 16-разрядных
операндов и адресов.

Тип: Интерпретация этого поля зависит от того, относится ли
данный дескриптор к прикладному, или же к системному сегменту.
Системные сегменты имеют несколько иной формат дескриптора,
рассматриваемый в Главе 6. Поле Типа дескриптора памяти задает
тип доступа, разрешенного к данному сегменту, а также
направление, в котором этот сегмент растет (см. Таблицу 5-1).

            Таблица 5-1. Типы прикладных сегментов

-----------------------------------------------------------------
Число | E | W | A |    Тип    |             Описание
      |   |   |   |дескриптора|
-----------------------------------------------------------------
   0    0   0   0    Данные    Только чтение
   1    0   0   1    Данные    Только чтение, выполнен доступ
   2    0   1   0    Данные    Чтение/запись
   3    0   1   1    Данные    Чтение/запись, выполнен доступ
   4    1   0   0    Данные    Только чтение, расширение вниз
   5    1   0   1    Данные    Только чтение, расширение вниз,
                               выполнен доступ
   6    1   1   0    Данные    Чтение/запись, расширение вниз
   7    1   1   1    Данные    Чтение/запись, расширение вниз,
                               выполнен доступ
-----------------------------------------------------------------
Число | C | R | A |    Тип    |             Описание
      |   |   |   |дескриптора|
-----------------------------------------------------------------
   8    0   0   0    Код       Только выполнение
   9    0   0   1    Код       Только выполнение, выполнен доступ
  10    0   1   0    Код       Выполнение/чтение
  11    0   1   1    Код       Ваполнение/чтение, выполнен доступ
  12    1   0   0    Код       Только выполнение, конформный
  13    1   0   1    Код       Только выполнение, конформный,
                               выполнен доступ
  14    1   1   0    Код       Выполнение/только чтение, конформный
  15    1   1   1    Код       Выполнение/только чтение, конформный,
                               выполнен доступ
-----------------------------------------------------------------

Для сегментов данных три младших бита поля типа можно
интерпретировать как признаки расширения вниз (E), разрешения
записи (W) и того, что к сегменту был выполнен доступ (A). Для
кодовых сегментов три младших бита поля типа можно
интерпретировать как признак конформности (C), разрешения чтения
(R) и выполненного доступа (A).

Сегменты данных могут быть предназначены только для чтения или
для чтения/записи. Загрузка регистра SS селектором сегмента для
любого другого типа сегмента генерирует исключение общей защиты.
Если стековому сегменту требуется иметь возможность изменять
размер, то ему может быть назначен сегмент данных с типом
расширения вниз. Для сегмента с расширением вниз смысл поля
Границы меняется на противоположный. Если для других типов
сегмента допустимыми являются значения смещения в диапазоне от 0
до значения границы (вне этого диапазона генерируется исключение
общей защиты), то для сегмента с расширением вниз значения в
этом диапазоне, напротив, ведут к генерации исключения.
Допустимыми смещениями для сегментов с расширением вниз являются
те, что для сегментов других типов вызывают особую ситуацию.
Сегменты с расширением вверх должны адресоваться смещениями,
меньшими или равными границе сегмента. Смещения же в сегменты с
расширением вниз всегда должны превышать значение границы
сегмента. Такая интерпретация границы сегмента вызывает
распределение области памяти в нижней части сегмента, когда
граница сегмента увеличивается, что является правильным для
стековых сегментов, поскольку они растут в направлении младшего
адреса. Если стек помещается в сегменте, который не меняет
своего размера, то этот сегмент не обязан быть сегментом с
расширением вниз.

Кодовые сегменты могут быть предназначены только для выполнения,
либо для выполнения/чтения. Сегмент с типом "выполнение/чтение"
может быть использован, например, когда в команды кода в ПЗУ
помещены константы. В данном случае константы могут быть
прочитаны либо при помощи команды, имеющей префикс
переопределения сегмента CS, либо при помощи помещения селектора
данного кодового сегмента в сегментный регистр для сегмента
данных.

Кодовые сегменты могут быть либо конформными, либо
не-конформными. Переход выполнения в более привилегированный
конформный сегмент сохранит текущий уровень привилегированности.
Переход выполнения в не-конформный сегмент с другим уровнем
привилегированности приведет к генерации исключения общей
защиты, если не использован шлюз задачи (обсуждение средств
мультизадачности см. в Главе 6). Системные утилиты, не
обращающиеся к средствам защиты, такие как функции
транслирования данных (например, перекодировка EBCDIC/ASCII,
кодирование / декодирование по методу Хафмана, библиотека
математических функций), а также некоторые типы исключений
(например, ошибка деления на ноль, переполнение, обнаруженное
при помощи INTO или превышение диапазона BOUND) могут быть
загружены в конформные кодовые сегменты.

Поле Типа также сообщает о том, был ли к данному сегменту
выполнен доступ. В исходном состоянии дескрипторы сегментов
сообщают о том, что доступ к сегменту был. Если поле Типа затем
установить в значение, означающее, что доступ к сегменту не был
выполнен, процессор восстановит значение, если доступ к сегменту
произошел. Очистив и проверив младший бит поля Типа, программное
обеспечение может контролировать использование сегмента (младший
бит поля Типа также называется битом Доступа).

Например, система разработки программ может очистить все биты
Доступа для сегментов прикладной программы. При сбое в
прикладной программе состояния этих битов могут быть
использованы для генерации карты всех сегментов, к которым
выполнила доступ данная прикладная программа. В отличие от
контрольных точек, которые обеспечиваются механизмом отладки
(см. Главу 11), информация, предоставляемая этим полем,
относится не к физическим адресам, а к сегментам.

Процессор может обновлять поле Типа при доступе к сегменту, даже
если доступ этот произошел в цикле чтения. Если таблицы
дескрипторов были помещены в ПЗУ, аппаратному обеспечению может
потребоваться запретить связь ПЗУ с шиной данных во время цикла
записи. Также может потребоваться возвратить сигнал READY#
процессору в цикле записи в ПЗУ; в противном случае не
произойдет завершение этого цикла. Эти средства аппаратной
конструкции необходимы для использования ПЗУ-резидентных таблиц
дескрипторов с процессором 386 DX, который всегда устанавливает
бит Доступа при загрузке дескриптора сегмента. Однако, процессор
i486 только в том случае, если он еще не установлен. Избежать
попытки записи в таблицы дескрипторов в ПЗУ можно, установив
биты Доступа в каждом дескрипторе.

DPL (Уровень привилегированности дескриптора): Определяет
уровень привилегированности сегмента. Используется для
управления доступом к сегменту при помощи механизма защиты,
описанного в Главе 6.

Бит присутствия сегмента: Если этот бит очищен, то процессор при
загрузке в сегментный регистр селектора данного дескриптора
генерирует исключение "сегмент не присутствует". Это свойство
используется для обнаружения попыток доступа к сегментам,
которые стали недоступными. Сегмент может стать недоступным,
когда системе понадобилось создать свободную память. Для
элементов памяти, таких как символьные шрифты или драйверы
устройств, в тех случаях, когда они в текущий момент не
используются, выполняется отмена распределения памяти. Отмена
распределения памяти такому элементу выполняется маркировкой
такого сегмента как "не присутствующего" (это выполняется при
помощи очистки бита присутствия сегмента). После этого память,
занимаемая данным сегментом, может быть распределена для другого
использования. Когда элемент, для которого было отменено
распределение памяти, понадобится в следующий раз, исключение
"сегмент не присутствует" укажет на то, что необходимо снова
загрузить этот сегмент в память. Если такого рода организация
памяти выполняется способом, не видимым для прикладных программ,
то она называется "виртуальной памятью". Система может работать
с общим размером виртуальной памяти, значительно превышающим
физическую память, благодаря тому, что одновременно в физической
памяти присутствует только несколько сегментов.

На Рисунке 5-9 показан формат дескриптора, когда бит присутствия
сегмента очищен. В этом случае операционная система имеет право
использовать адреса памяти, отмеченные как Доступная, для
хранения там своих собственных данных, например, информации об
отсутствующих сегментах.


                          1 1 1 1 1 1 1
     31                   6 5 4 3 2 1 0 9 8 7          0
     ---------------------------------------------------
     |                     | | D |D|       |           |
     |   Доступная         |0| P |T|  Тип  | Доступная | +4
     |                     | | L | |       |           |
     ---------------------------------------------------
     |                    Доступная                    | +0
     ---------------------------------------------------

   Рисунок 5-9. Дескриптор сегмента (Сегмент не присутствует)

5.2.4  Таблицы дескрипторов сегментов
-----------------------------------------------------------------

Таблица дескрипторов сегментов представляет собой массив
дескрипторов сегментов. Существуют два типа таблиц дескрипторов:

     - Таблица глобальных дескрипторов (GDT)
     - Таблицы локальных дескрипторов (LDT)

Существует единственная для всех задач таблица GDT, а для каждой
выполняемой задачи, кроме того, существует по одной таблице LDT.
Таблица дескрипторов представляет собой массив сегментных
дескрипторов, показанный на Рисунке 5-10. Таблица дескрипторов
имеет переменную длину и может содержать до 8192 (2**13)
дескрипторов. Первый дескриптор в таблице GDT процессором не
используется. Селектор сегмента для данного "пустого
дескриптора" при загрузке его в сегментный регистр не генерирует
есключения, однако исключение генерируется всякий раз при
попытке доступа к памяти с использованием такого дескриптора.
Инициализация сегментных регистров таким селектором сегмента
гарантирует генерацию исключения при ошибочных ссылках на
неиспользуемые сегментные регистры.


              Таблица                Таблица
            глобальных              локальных
           дескрипторов            дескрипторов

           -----------------      -----------------
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+38   |               |+38
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+30   |               |+30
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+28   |               |+28
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+20   |               |+20
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+18   |               |+18
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+10   |               |+10
           |---------------|      |---------------|
           |       |       |      |       |       |
           |---------------|      |---------------|
           |               |+8    |               |+8
           |---------------|      |---------------|
           |Первый         |      |       |       |
           |дескриптор в   |      |---------------|
           |GDT            |      |               |
           |не используется|+0    |               |+0
           -----------------<---  -----------------<--------
                               |                           |
           Регистр             |  Регистр  -------------   |
           GDTR                |  LDTR     | Селектор  |   |
               -------------   |           -------------   |
               | Граница   |   |           |  Граница  |   |
        --------------------   |  ----------------------   |
        |  Базовый  адрес  |----  |  Базовый  адрес    |---
        --------------------      ----------------------

     Примечание:  Адреса даны в шестнадцатиричном формате.

               Рисунок 5-10. Таблицы дескрипторов


5.2.5  Базовые регистры таблиц дескрипторов
-----------------------------------------------------------------

Процессор выполняет поиск таблицы глобальных дескрипторов (GDT)
и таблицы дескрипторов прерываний (IDT) через регистры GDTR и
IDTR, соответственно. Эти регистры содержат 32-битовые базовые
адреса таблиц в линейном адресном пространстве. Они также
содержат 16-битовые значения граничного размера этих таблиц. При
загрузке или сохранении этих регистровв памяти происходит доступ
к 48-битовому "псевдо-дескриптору", как показано на Рисунке
5-11. Для максимизации быстродействия за счет заполнения строки
кеша GDT и IDT должны быть выравнены по границе адреса, кратного
16 байтам.

Граничное значение выражается в байтах. Как и для сегментов, оно
складывается с базовым адресом для получения адреса последнего
допустимого байта. В случае значения границы 0 имеется всего
один допустимый байт. Поскольку дескрипторы сегментов всегда
имеют размер восемь байтов, то граница всегда должна быть на
единицу меньше целочисленного произведения восьми, (т.е. 8N-1).
Команды LGDT и SGDT читают и записывают регистр GDTR; команды
LIDT и SIDT читают и записывают регистр IDTR.

Третья таблица дескрипторов - это локальная таблица (LDT). Она
идентифицируется при помощи 16-битового селектора сегмента,
хранимого в регистре LDTR. Команды LLDT и SLDT читают и
записывают селектор сегмента в регистр LDTR. Регистр LDTR также
содержит базовый адрес и границу для LDT, но эти значения
загружаются процессором автоматически из дескриптора сегмента
для LDT. Для максимизации быстродействия за счет заполнения
строки кеша LDT должна быть выравнена по границе адреса,
кратного 16 байтам.

При попытке сохранения псевдо-дескриптора в режиме пользователя
(уровень привилегированности 3) может быть сгенерирована ошибка
контроля выравнивания. Обычно программы в режиме пользователя не
выполняют сохранение псевдо-дескрипторов, но возможности
генерации такой ошибки можно избежать, поместив
псевдо-дескриптор в адрес нечетного слова (т.е. адрес 2 MOD 4).
Это заставит процессор сохранить выравненное слово, за которым
следует выравненное двойное слово.

     47                      16 15               0
     ----------------------------------------------
     |     Базовый адрес       |    Граница       |
     ----------------------------------------------
     5                        2 1                0

     Порядок следования байтов показан внизу

            Рисунок 5-11. Формат псевдо-дескриптора

5.3  Трансляция страниц
-----------------------------------------------------------------

Линейный адрес представляет собой 32-битовый адрес в однородном,
несегментированном адресном пространстве. Это адресное
пространство может являться большим физическим адресным
пространством (т.е. адресным пространством, состоящим из 4
гигабайт оперативной памяти), либо может использоваться средство
подкачки страниц, моделирующее это адресное пространство при
помощи небольшой области оперативной памяти и некоторого
количесства дисковой памяти. При использовании подкачки страниц
линейный адрес транслируется в соответствующий физический адрес,
либо генерируется исключение. Это исключение дает операционной
системе возможность прочитать страницу с диска (возможно,
вытеснив на диск другую страницу), а затем перезапустить
команду, вызвавшую данное исключение.

Механизм подкачки отличается от механизма сегментации тем, что в
данном случае используются небольшие, имеющие фиксированный
размер страницы. В отличие от сегментов, которые обычно имеют
размер, равный размеру содержащихся в них структур данных,
страницы процессора i486 всегда имеют размер 4К. Если
сегментация является единственной используемой формой трансляции
адреса, структура данных, находящаяся в физической памяти, будет
иметь в памяти все свои компоненты одновременно. При
использовании механизма подкачки страниц структура данных может
частично находиться в оперативной памяти, и частично в дисковой
памяти.

Информация, обеспечивающая отображение линейных адресов в
физические адреса и отвечающая за генерацию исключений в случае
несоответствий, хранится в структурах данных оперативной памяти,
которые называются таблицами страниц. Как и в случае
сегментации, эта информация кешируется в регистрах процессора с
тем, чтобы минимизировать число циклов шины, требуемое для
трансляции адреса. В отличие от механизма сегментации, эти
регистры процессора полностью невидимы для прикладных программ.
(Для целей тестирования эти регистры видны программам,
выполняемым с максимальным уровнем привилегированности:
подробности см. в Главе 10).

Мехпнизм подкачки страниц рассматривает 32-разрядный линейный
адрес как состоящий из трех частей, а именно двух 10-разрядных
индексов страничных таблиц и 12-заррядное смещение в таблице,
адресуемой страничными таблицами. Поскольку как виртуальные
страницы в линейном адресном пространстве, так и физические
страницы памяти выравнены по 4Кбайтной границе страниц,
модифицировать младшие 12 битов адреса нет необходимости. Эти 12
битов напрямую передаются аппаратному обеспечению, работающему с
подкачкой страниц, независимо от того, разрешена ли подкачка в
текущий момент, или запрещена. Отметим, что в этом состоит
отличие от сегментации, поскольку сегменты могут начинаться с
любого адреса байта.

Старшие 20 битов адреса используется для индексации страничных
таблиц. Если все страницы линейного адресного пространства
отображались бы в одной таблице страниц в оперативной памяти, то
для этого потребовалось бы 4Мб памяти. Делается это не так. Для
экономии памяти используются страничные таблицы двух уровней.
Страничная таблица верхнего уровня называется страничным
каталогом. В нем отображаются старшие 10 битов линейного адреса
табличных страниц второго уровня. Во втором уровне страничных
таблиц отображаются средние 10 битов линейного адреса, задающего
базовый адрес страницы в физической памяти (который называется
адресом страничного блока).

На базе содержимого таблицы страниц или каталога страниц может
генерироваться исключение. Оно дает операционной системе
возможность подкачать отсутствующую таблицу страниц с диска.
Благодаря тому, что страничные таблицы второго уровня могут
находиться на диске, механизм подкачки страниц может
поддерживать отображение всего линейного адресного пространства
при помощи всего нескольких страниц памяти.

Регистр CR3 содержит адрес страничного блока каталога страниц.
Поэтому он называется базовым регистром каталога страниц, или
PDBR. Старшие 10 битов линейного адреса умножаются на масштабный
коэффициент четыре (число байтов каждого элемента таблицы
страниц) и складывается со значением регистра PDBR для получения
физического адреса элемента в каталоге страниц. Поскольку адрес
страничного блока всегда имеет незаполненными младшие 12 бит, то
такое сложение выполняется методом конкатенации (замещения
младших 12 битов масштабированным индексом).

При доступе к элементу каталога страниц выполняется несколько
проверок: исключения могут генерироваться, если страница
защищена или отсутствует в памяти. Если особая ситуация не
генерировалась, то старшие 20 битов элемента таблицы страниц
используются в качестве адреса страничного блока таблицы страниц
второго уровня. Средние 10 битов линейного адреса масштабируются
коэффициентом четыре (снова это число равно размеру элемента
таблицы страниц) и конкатенируются с адресом страничного блока
для получения физического адреса элемента в таблице страниц
второго уровня.

И опять, выполняются проверки доступа, в результате которых
возможна генерация исключений. Если же исключений не возникло,
то старшие 20 битов элемента таблицы страниц второго уровня
конкатенируются с младшими 12 битами линейного адреса, образуя
физический адрес операнда (данных) в оперативной памяти.

Хотя такой процесс и может показаться сложным, затраты
процессорного сремени на него невелики. Процессор имеет кеш
элементов таблицы страниц, который называется ассоциативным
буфером трансляции адреса (TBL). TBL удовлетворяет большинство
запросов чтения страничных таблиц. дополнительные циклы шины
затрачиваются только при доступе к новым страницам памяти.
Размер страницы (4К) достаточно велик, поэтому по сравнению с
числом циклов шины, затрачиваемых на выполнение команд и
обращение к данным, число циклов для доступа к таблицам страниц
относительно невелико. Одновременно с этим размер страницы
достаточно мал, чтобы память использовалась наиболее эффективно.
(Независимо от фактической величины структуры данных, она
занимает не меньше одной страницы памяти).

5.3.1  Бит разрешения подкачки страниц PG
-----------------------------------------------------------------

Если подкачка страниц разрешена, используется второй этап
трансляции адреса, генерирующий физический адрес из линейного.
Если подкачка страниц запрещена, то линейный адрес совпадает и
используется как физический адрес.

Подкачка страниц разрешена, если установлен бит 31 (бит PG)
регистра CR0. Этот бит обычно устанавливается операционной
системой во время программной инициализации. Бит PG должен быть
установлен, если в операционной системе должно выполняться более
одной программы в виртуальном режиме 8086, либо при
использовании виртуальной памяти с подкачкой страниц по
требованию.

5.3.2  Линейный адрес
-----------------------------------------------------------------

Формат линейного адреса показан на Рисунке 5-12.


         31             22 21         12 11           0
        -----------------------------------------------
        |    Каталог     |   Таблица   |   Смещение   |
        -----------------------------------------------

             Рисунок 5-12. Формат линейного адреса


                                                       Страничный
     -----------------------------------------------      блок
     |    Каталог     |   Таблица   |   Смещение   |  -----------
     -----------------------------------------------  |         |
           |               |               |          |         |
           |               |               |          | Операнд |
  ---------                |                --------->|         |
 |     Каталог страниц     |    Таблица страниц       |         |
 |     -----------------   |    ------------------    -----------
 |     |               |   |    |                |
 |     |---------------|   |    |----------------|
 ----->|Элемент таблицы|   ---->|Элемент каталога|
       |     страниц   |---     |     страниц    |
       |---------------|  |     |----------------|
       |               |  |     |                |
       |               |  |     |                |
       -----------------  |     ------------------
               ^          |              ^
               |          |              |
     -------   |          ----------------
CR3  |     |---
     -------

          Рисунок 5-13. Трансляция страничного адреса

На Рисунке 5-13 показано, каким образом процессор транслирует
поля линейного адреса Каталога, Таблицы и Смещения в физический
адрес с использованием двух уровней страничных таблиц. Механизм
подкачки страниц использует поле Каталога в качестве индекса
каталога страниц, поле Таблицы в качестве индекса таблицы
страниц, определяемой в каталоге страниц, и поле Смещение для
адресации операнда в странице, заданной в таблице страниц.

5.3.3 Таблицы страниц
-----------------------------------------------------------------

Таблица страниц представляет собой массив, состоящий из
32-разрядных элементов. Таблица страниц сама является страницей
и содержит 4096 байтов памяти, или максимум 1Кб 32-разрядных
элементов. Все страницы, включая каталоги страниц и таблицы
страниц, выровнены по границе 4Кб.

Для адресации страницы памяти используется два уровня таблиц.
Старший уровень называется каталогом страниц. Он адресует до 1К
страничных таблиц второго уровня. Таблица страниц второго уровня
адресует до 1К страниц в физической памяти. Таким образом, все
таблицы, адресуемые одним каталогом страниц, могут адресовать до
1М или 2**20 страниц. Поскольку каждая страница содержит 4К, или
2**12 байтов, таблицы одного каталога страниц покрывают все
линейное адресное пространство процессора i486 (2**20 x 2**12 =
2 **32).

Физический адрес текущего страничного каталога хранится в
регистре CR3, который также называется базовым регистром
каталога страниц (PDBR). Программное обеспечение организации
памяти имеет опции использования одного каталога страниц для
всех задач, одного каталога страниц для каждой задачи, либо
некоторой комбинации этих двух опций. В Главе 10 приводится
информация об инициализации регистра CR3. О том, как содержимое
CR3 может изменяться для каждой задачи, см. в Главе 7.

5.3.4  Элементы таблицы страниц
-----------------------------------------------------------------

Элементы страничных таблиц обоих уровней имеют одинаковый
формат. Этот формат показан на Рисунке 5-14.

5.3.4.1  Адрес страничного блока
-----------------------------------------------------------------

Адрес страничного блока является базовым адресом страницы. В
элементе страничной таблицы старшие 20 битов используются для
задания адреса страничного блока, а младшие 12 битов задают
управляющие биты и биты состояния для данной страницы. В
каталоге страниц адрес страничного блока представляет собой
адрес таблицы страниц второго уровня. В таблице страниц второго
уровня адрес страничного блока - это адрес страницы, которая
содержит команды или данные.

5.3.4.2  Бит присутствия
-----------------------------------------------------------------

Бит Присутствия указывает на то, отображается ли адрес
страничного блока из таблицы страниц страницей в физической
памяти. Если данный бит установлен, то страница находится в
памяти.

Если бит Присутствия очищен, то страница не находится в памяти,
и остальная часть данного элемента таблицы страниц доступна для
использования операционной системой, например, для хранения
информации о том, где находится эта отсутствующая страница. На
Рисунке 5-15 показан формат элемента таблицы страниц, когда бит
Присутствия очищен.


     31                           12 11                    0
    ---------------------------------------------------------
    |                               |     |   | | |P|P|U|R| |
    |Адрес страничного блока 31..12 |AVAIL|0 0|D|A|C|W|/|/|P|
    |                               |     |   | | |D|T|S|W| |
    ---------------------------------------------------------

    P        - Присутствие
    R/W      - Чтение/З пись
    U/S      - Пользователь/Супервизор
    PWT      - Запись Страницы прозрачна
    PCD      - Кеширование на уровне страниц запрещено
    A        - Доступ произошел
    D        - "Грязная"
    AVAIL    - Доступны для использования системным программистом

    Примечание: 0 означает резервирование Intel. Не выполняйте
                определение этих битов.

         Рисунок 5-14. Формат элемента таблицы страниц


     31                                1 0
     --------------------------------------
     |        Доступны                  |0|
     --------------------------------------

         Рисунок 5-15.  Формат элемента таблицы страниц
                 для не-Присутствующей таблицы

Если бит Присутствия на любом уровне таблицы страниц очищен,
когда делается попытка использовать данный элемент таблицы для
адресной трансляции, то происходит такая последовательность
событий:

     1. Операционная система копирует страницу с дисковой памяти
        в физическую память.

     2. Операционная система загружает адрес страничного блока в
        элемент таблицы страниц и устанавливает бит Присутствия.
        Прочие биты, например, бит Чтения/Записи, также могут
        при этом быть установлены.

     3. Поскольку в буфере ассоциативной трансляции (TLB) все
        еще может находиться копия старого элемента таблицы
        страниц, то операционная система очищает этот буфер.
        Буфер TLB и способы его очистки рассматриваются в
        разделе 5.3.5.

     4. Выполняется рестарт программы, вызвавшей исключение.

Поскольку CR3 не имеет бита Присутствия, который указывал бы на
те случаи, когда каталог страниц не находится в оперативной
памяти, каталог страниц, на который указывает CR3, должен
находиться в физической памяти всегда.

5.3.4.3  Биты Доступа и "Грязная"
-----------------------------------------------------------------

Эти биты содержат данные об использовании страницы на обоих
уровнях страничных таблиц. Бит Доступа используется для
сообщения о доступе на чтение или запись к странице или
страничной таблице второго уровня. Бит "Грязная" сообщает о
доступе к странице для записи.

За исключением бита "грязная" в элементах каталога страниц, эти
биты устанавливаются аппаратным обеспечением; однако процессор
не очищает ни один из этих битов. Процессор устанавливает биты
Доступа на обоих уровнях страничных таблиц до операции чтения
или записи страницы. Процессор устанавливает бит "Грязная" в
таблице страниц второго уровня, прежде чем выполнить операцию
записи по адресу, отображаемому данным элементом таблицы. Бит
"Грязная" в элементах каталога страниц не определен.

Операционная система может использовать бит Доступа, когда ей
требуется создать некоторую свободную область памяти, посылая
страницу или таблицу страниц второго уровня на диск.
Периодически очищая биты Доступа в страничных таблицах, она
может определять, какие страницы были использованы последними.
Не используемые страницы являются кандидатами на пересылку в
дисковую память.

Операционная система может использовать бит "Грязная", когда
страница посылается обратно на диск. Очищая бит "Грязная" при
пересылке страницы в оперативную память, операционная система
может определить, произошел ли какой-либо доступ записи к этой
странице. Если имеется копия этой страницы на диске и копия в
оперативной памяти не была изменена операциями записи, то
обновлять соответствующую копию на диске из оперативной памяти
нет необходимости.

О том, как процессор i486 обновляет биты Доступа и "Грязная" в
многопроцессорных системах, написано в Главе 13.

5.3.4.4  Биты Чтения/Записи и Пользователя/Супервизора
-----------------------------------------------------------------

Биты Чтения/Записи и Пользователя/Супервизора используются для
защитных проверок страниц, выполняемых процессором одновременно
с трансляцией адреса. Более подробную информацию о защите см. в
Главе 6.

5.3.4.5  Биты управления кешем страничного уровня
-----------------------------------------------------------------

Биты PCD и PWT используются для организации кеша страничного
уровня. Программное обеспечение может при помощи этих битов
управлять кешированием отдельных страниц или страничных таблиц
второго уровня. Более подробную информацию о кешировании см. в
Главе 12.

5.3.5  Ассоциативный буфер трансляции
-----------------------------------------------------------------

Процессор хранит использованные последними элементы страничных
таблиц во входящем в состав микросхемы кеше, который называется
буфером ассоциативной трансляции, или TLB. Большая часть
подкачки страниц выполняется на базе содержимого TLB. Циклы шины
для обращения к страничным таблицам затрачиваются только при
использовании новых страниц.

TLB невидим для прикладных программ, но видим для операционной
системы. Системные программисты должны очищать TLB (освобождая
его содержимое от элементов страничных таблиц) при изменении
элементов страничных таблиц. Если этого не сделать, то старые
данные, не получившие изменений, могут быть ошибочно
использованы для адресной трансляции. Изменение элемента для
страницы, которая не находится в оперативной памяти, не требует
очистки TLB, поскольку элементы для отсутствующих в памяти
страниц не кешируются.

TLB очищается при загрузке регистра CR3. Регистр CR3 может быть
загружен одним из следующих способов:

     1. Явной загрузкой при помощи команды MOV, например

        MOV CR3,EAX

     2. Неявной загрузкой при помощи переключателя задач, который
        изменяет содержимое регистра CR3. (Более подробную
        информацию о переключении задач см. в Главе 7).

Неверный элемент в TBL может быть очищен при помощи команды
INVLPG. Эта команда бывает полезна при изменении образа
конкретной страницы.

5.4  Объединение сегментной и страничной трансляции
-----------------------------------------------------------------

На Рисунке 5-16 показано объединение Рисунков 5-5 и 5-13,
которое суммирует оба этапа трансляции от логического адреса к
физическому, когда разрешен механизм подкачки страниц. Опции,
предоставляемые обоими этапами адресной трансляции, могут быть
использованы для поддержки различных стилей организации памяти.

5.4.1  Плоская модель
-----------------------------------------------------------------

Когда процессор i486 используется для выполнения программного
обеспечения, не использующего механизма сегментации, может
оказаться желательным удаление средств сегментации процессора.
Процессор i486 не имеет бита режима, который позволял бы
включать и выключать средства сегментации, но точно такой же
эффект может быть достигнут и при помощи отображения адресных
пространств стека, кода и данных в одном и том же диапазоне
линейных адресов. Используемые командами процессора 32-разрядное
смещения позволяют покрывать все линейное адресное пространство.

При использовании механизма подкачки страниц сегменты могут
отображаться во всем линейном адресном пространстве. При
одновременном выполнении более чем одной программы механизм
подкачки страниц может быть использован для того, чтобы дать
отдельное адресное пространство каждой выполняемой программе.



            15                0    31                           0
Логический  -----------------------------------------------------
адрес       |    Селектор        |          Смещение            |
            -----------------------------------------------------
                 |         |                     |
          -------          \/                    |
          |       Таблица                        |
          |    дескрипторов                      |
          |   --------------                     |
          |   |            |                     |
          |   |            |                     |
          |   |------------|                     |
          |   | Дескриптор | Базовый   -----     |
           -->|  сегмента  |---------->| + |<----
              |------------| адрес     -----
              |            |             |
              --------------             |
                                         |
                              -----------
                             |
 Линейный                    |
 адрес                       \/                       Страничный
     -----------------------------------------------      блок
     |    Каталог     |   Таблица   |   Смещение   |  -----------
     -----------------------------------------------  |         |
           |               |               |          |         |
           |               |               |          | Операнд |
  ---------                |                --------->|         |
 |     Каталог страниц     |    Таблица страниц       |         |
 |     -----------------   |    ------------------    -----------
 |     |               |   |    |                |
 |     |---------------|   |    |----------------|
 ----->|Элемент таблицы|   ---->|Элемент каталога|
       |     страниц   |---     |     страниц    |
       |---------------|  |     |----------------|
       |               |  |     |                |
       |               |  |     |                |
       -----------------  |     ------------------
               ^          |              ^
               |          |              |
     -------   |          ----------------
CR3  |     |---
     -------

     Рисунок 5-16. Объединенная  сегментная  и  страничная
                       трансляция адреса

5.4.2  Сегменты, занимающие несколько страниц
-----------------------------------------------------------------

Архитектура процессора допускает существование сегментов,
превышающих по размеру одну страницу (4К). Например, большие
структуры данных могут занимать тысячи страниц. Если подкачка
страниц не используется, то для доступа к любой части структуры
данных требуется присутствие в физической памяти всей структуры
данных. При использовании механизма подкачки страниц в памяти
обязательно присутствие только страницы, содержащей ту часть
данных, к которой в текущий момент выполняется доступ.

5.4.3  Страницы, содержащие несколько сегментов
-----------------------------------------------------------------

Сегменты могут также быть по размеру меньше страницы. Если такой
сегмент будет помещен в отдельную, не содержащую других
сегментов страницу, это означает бесполезную трату памяти.
Например, при помещении в отдельную страницу небольшой структуры
данных, например, занимающего 1 байт семафора, будет
израсходовано 4К памяти. Если используется много таких
семафоров, гораздо эффективней будет упаковать их в одну
страницу.

5.4.4  Невыравненные границы страниц и сегментов
-----------------------------------------------------------------

Архитектура процессора не устанавливает каких-либо
принудительных соотношений между границами страниц и сегментов.
Страница может содержать конец одного сегмента и начало
следующего. Аналогичным образом, сегмент может содержать конец
одной страницы и начало следующей.

5.4.5  Выравненные границы страниц и сегментов
-----------------------------------------------------------------

Программное обеспечение организации памяти может стать проще и
эффективнее при установке некоторого принудительного
выравнивания границ страниц и сегментов. Например, если сегмент,
который может поместиться в пределах одной страницы, размещен в
двух страницах, то доступ к такому сегменту потребует в два раза
больше времени на подкачку содержащих его страниц.

5.4.6  Страничная таблица на каждый сегмент
-----------------------------------------------------------------

Метод объединения механизмов подкачки страниц и сегментации,
упрощающий программное обеспечение организации памяти,
заключается в том, чтобы дать каждому сегменту свою страничную
таблицу, как показано на Рисунке 5-17. Тем самым в каталоге
страниц каждому сегменту будет соответствовать один элемент
таблицы, обеспечивая информацию об управлении доступом для
подкачки страниц, соответствующих данному сегменту.

                                                      Страничные
                                                        блоки
                                                     ------------
    LDT         Каталог страниц   Таблицы страниц -->|          |
-------------    -------------     ------------- |   ------------
|           |    |           |     |           | |
|-----------|    |-----------|     |-----------| |
|           |    |           |     | элемент   |-    ------------
|-----------|    |-----------|     |-----------|     |          |
|           |    |           |     | элемент   |---->------------
|-----------|    |-----------|     |-----------|
|           |    |           |     | элемент   |-
|-----------|    |-----------| --->------------- |   ------------
|Дескриптор |--->|  элемент  |-'                  -->|          |
|-----------|    |-----------|                       ------------
|Дескриптор |--->|  элемент  |-
|-----------|    |-----------| |   -------------
|           |    |           | |   |           |
|-----------|    |-----------| |   |-----------|
|           |    |           | |   |           |     ------------
|-----------|    |-----------| |   |-----------|     |          |
|           |    |           | |   |  элемент  |---->------------
|-----------|    |-----------| |   |-----------|
|           |    |           | |   |  элемент  |-    ------------
-------------    -------------  -->------------- |   |          |
    LDT         Каталог страниц   Таблицы страниц -->------------
                                                      Страничные
                                                         блоки

      Рисунок 5-17. Каждый сегмент может иметь собственную
                       страничную таблицу
