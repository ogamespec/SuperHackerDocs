
Часть I. Прикладное программирование

Глава 2. Основная программная модель
----------------------------------------------------------------

Данная глава описывает окружение для прикладного
программирования (исключая возможности вещественной арифметики),
с точки зрения программистов, работающих на языке ассемблера. В
ней описываются основные особенности архитектуры процессора,
непосредственно влияющие на структуру и работу прикладных
программ. Использование вещественной арифметики описывается
отдельно в Части III.

Описание основной программной модели состаит из следующих
частей:

- Организация памяти

- Типы данных

- Регистры

- Формат команд

- Выбор операндов

- Прерывания и исключения

Примечательно, что ввод/вывод не рассматривается как часть
основной программной модели. Разработчики системы могут сделать
команды ввода/вывода доступными для прикладных программ или
зарезервировать эти функции для операционной системы. Исходя из
этого, особенности ввода/вывода процессора i486(ТМ) описаны в
Части II.

Разделы данной главы содержат описание для каждой конкретной
особенности архитектуры процессора, которая, как правило,
существена для прикладных программ.

2.1 Организация памяти
----------------------------------------------------------------

Память на шине процессора i486 называется физической памятью.
Она организованна как последовательность 8-ми битовых байтов.
Каждому байту соответствует уникальный адрес, называемый
физическим, который может находиться в интервале от 0 до 2**32-1
(4 Гбайт). Диспетчер памяти - это аппаратный механизм для
надежного и эффективного использования памяти. При использовании
данного механизма, прикладные программы не используют прямой
адресации к физической памяти, а адресуются к некоторой модели
памяти, называемой виртуальной памятью.

Диспетчер памяти поддерживает сегментацию и замещение страниц
(подкачку). Сегментация - это механизм, обеспечивающий разбиение
памяти на отдельные независимые адресные пространства. Подкачка
- это механизм поддержки модели большого адресного пространства
ОЗУ, реально используя меньший объем ОЗУ и некоторое дисковое
пространство. Возможно использование одного из указанных
механизмов или их одновременное использование. Адрес,
используемый в программе, называется логическим адресом.
Устройство сегментации преобразует логический адрес в некоторый
промежуточный адрес несегментированного адресного пространства,
называемый линейным. Устройство замещения страниц преобразует
полученный линейный адрес в физический.

Реально, память может представлять собой единое адресное
пространство, похожее на физическую память. Или, она может
представлять собой набор из одного или более независимых
пространств памяти, называемых сегментами. Сегменты могут быть
использованы специально для хранения кода программы (команд),
данных или стека. Фактически, каждая конкретная программа может
использовать до 16383 сегментов различной длины и различного
назначения. Сегментация может быть использована для повышения
надежности программ и систем. Например, размещение стека
программы и ее кода в различных сегментах позволяет избежать
наложения данных и кода в случае переполнения стека.

Вне зависимости от того, используется много сегментов или нет,
логический адрес трактуется как смещение в сегменте и согласно
этому преобразуется в линейный. Каждый сегмент имеет дискриптор,
который содержит его базовый адрес и максимальный размер. Если
смещение меньше размера и нет препядствий для чтения сегмента,
линейный адрес получается сложением базового адреса и смещения.

Линейный адрес, выработанный устройством сегментации,
используется непосредственно как физический адрес, если 31-ый
бит регистра CR0 очищен (описание регистра CR0 смотри в Главе
4). Данный бит регистра указывает, используется или не
используется механизм подкачки страниц. Если же данный бит не
очищен, для преобразования линейного адреса в физический
используется устройство подкачки страниц.

Устройство подкачки страниц обеспечивает другой уровень
организации памяти. Оно разбивает линейное адресное пространство
на блоки фиксированной длины (4К байт), называемые страницами.
Логическое адресное пространство отображается в линейное
адресное пространство, которое отображается на несколько
страниц. Страницы могут находиться как в памяти, так и на диске.
При обращении программы по логическому адресу, он транслируется
в адрес на странице памяти, или генерируется исключение (если
данная страница отсутствует в памяти). При возникновении
исключения, управление передается операционной системе, которая
должна попытаться считать нужную страницу с диска и обновить
таблицу страниц. После этого, работа программы, которая вызвала
исключение возобновляется без генерации исключения.

Если используется несколько различных сегментов, они являются
частью программного окружения, видимого для прикладного
программиста. Если же используется подкачка, то, как правило,
механизм замещения для прикладного программиста остается
невидимым. Исключение составляет случай, когда прикладная
программа взаимодействует с алгоритмом замещения страниц
операционной системы. Данный алгоритм активизируется когда все
страницы памяти использованы и операционная система должна
решить, какую страницу необходимо вытеснить на диск. Все
алгоритмы замещения страниц (исключая метод случайного
вытеснения) в некоторых ситуациях могут работать крайне
неэффективно, что может быть исправлено специальной прикладной
программой.

Архитектура процессора i486 дает разработчикам свободу выбора
модели памяти для каждой отдельной программы, даже если эти
программы выполняются одновременно. Возможен выбор любой модели
организации памяти, являющейся промежуточной между двумя
следующими моделями:

- "Плоское" адресное пространство, при котором пространства
  кодов, стека и данных отображаются в общие линейные адреса. В
  этом случае сегментация игнорируется и позволяется доступ
  любого типа указателя на память к любому типу данных.

- Сегментированное адресное пространство с различными сегментами
  для пространств кода, данных и стека. Может быть использовано
  до 16383 линейных адресных пространств, размером до 4 гигобайт
  каждое.

Обе эти модели могут обеспечивать защиту памяти. Кроме того,
возможен выбор любой модели, промежуточной между указанными.
Принципы выбора модели памяти и способы работы системных
программистов в выбранной модели описаны в Части II - Системное
программирование.

2.1.1 Несегментированная или "Плоская" модель
----------------------------------------------------------------


Несегментированная модель - это самая простая модель памяти.
Несмотря на то, что не существует бита режима или управляющего
регистра, которые позволяли бы включать и выключать механизм
сегментации, необходимый эффект достигается отображением
всех сегментов в единое линейное адресное пространство. В
результате этого все операции с памятью обращаются к общему
пространству памяти.

В плоской модели, сегменты могут покрывать весь 4-х гигабайтный
диапазон физических адресов, или только те адреса, которые
отображаются на физическую память. Преимущество минимального
адресного пространства заключается в том, что оно обеспечивает
минимальный уровень аппаратной защиты от программных ошибок.
Исключение составляет случай, когда логический адрес указывает
на адрес несуществующей памяти.

2.1.2 Сегментированная модель
----------------------------------------------------------------

В сегментированной модели организации памяти, логическое
адресное пространство содержит до 16383 сегментов, размером до 4
-х гигабайт каждый, т.е. общий объем может достигать 2**46 байт
(64 терабайт). Процессор отображает это 64-х терабайтовое
логическое адресное пространство в физическое адресное
пространство (до 4-х гигабайт) в соответствии с механизмом
преобразования адресов, описанным в Главе 5. Прикладные
программисты могут не вдаваться в подробности данного механизма
отображения. Преимущество сегментированной модели заключается в
том, что смещение внутри каждого адресного пространства
проверяется отдельно и доступ к каждому сегменту контролируются
индивидуально.

Указатель на сегментированное адресное пространство состоит из
двух частей:

1. 16-разрядное поле селектора сегмента, которое идентифицирует
   сегмент.

2. Смещение, которое представляет собой 32-разрядный адрес
   внутри сегмента.

Процессор использует селектор сегмента для получения линейного
адреса начала сегмента, называемого базовым адресом. Обращение к
памяти из программ осуществляется при помощи фиксированных
смещений относительно данного базового адреса, что позволяет
загружать в память и выполнять объектные модули без
корректировки адресов (динамическая компановка). Размер сегмента
определяется программистом, что позволяет делать его равным
размеру содержащегося в нем модуля.

2.2 Типы данных
----------------------------------------------------------------

Основными типами данных являются байты, слова и двойные слова
(смотри Рисунок 2-2). Байт образуют восемь соседних битов,
которые нумеруются с 0 до 7, причем бит 0 является самым младшим
значащим битом.

Слово состоит из двух байтов, имеющих последовательные адреса.
Т.о. слово содержит 16 бит, которые нумеруются от 0 до 15. Байт,
содержащий нулевой бит, называется младшим байтом, а байт,
содержащий 15-й бит - старшим байтом. В процессоре i486 младший
байт хранится по меньшему адресу. Адресом слова считается адрес
его младшего байта. Адрес старшего байта может быть использован
для доступа к старшей половине слова.

┌──────────────────────────────────────────────────────────────┐
│                                   ┌───────────────────┐      │
│                                ┌──┴─────────────────┐ │      │
│                              ┌─┴──────────────────┐ │ │      │
│                            ┌─┴──────────────────┐ │ │ │      │
│                          ┌─┴─────────────────┐  │ ├─┘ │      │
│                        ┌─┴────────────────┐  │  │ │   │      │
│                        │                  │  │  │ │   │      │
│                        │                  │  │  │ │   │      │
│                        ├──────────────────┤  │  │ │   │      │
│                        │     ОПЕРАНД      ├──┘  │ ├───┘      │
│                    ─── ├──────────────────┤     │ │          │
│                     │  │                  ├─────┘ │          │
│ Смещение внутри     │  │                  ├───────┘          │
│     сегмента        │  │                  │                  │
│                    ─── └──────────────────┘                  │
│                        ^                                     │
│                        │                                     │
│                        │                                     │
│ Селектор сегмента ─────┘                                     │
│                          15                       0          │
│                          ┌─────────────────────────┐         │
│                          │    Селектор сегмента    │         │
│                          └─────────────────────────┘         │
│ 31                                                0          │
│ ┌──────────────────────────────────────────────────┐         │
│ │           Смещение внутри сегмента               │         │
│ └──────────────────────────────────────────────────┘         │
│                                                              │
│                                                              │
└──────────────────────────────────────────────────────────────┘

              Рисунок  2-1.  Сегментная адресация

Двойное слово состоит из четырех байт, имеющих последовательные
адреса. Т.о. двойное слово содержит 32 бита, которые нумеруются
от 0 до 31. Слово, содержащее нулевой бит, называется младшим
словом, а слово, содержащее 31-й бит - старшим словом. Младшее
слово хранится по меньшему адресу. Адресом двойного слова
считается адрес его младшего слова. Адрес старшего слова может
быть использован для доступа к старшей половине двойного слова.

Для достижения максимальной гибкости в структурах данных и
эффективного использования памяти, слова необязательно
выравнивать по четным адресам. Двойные слова также необязательно
выравнивать по адресам, кратным четырем. Однако, из-за того, что
процессор i486 имеет 32-разрядную шину, обмен данными между
процессором и памятью производится двойными словами,
начинающимися с адресов, кратных четырем. Процессор преобразует
запросы невыровненных слов или двойных слов в последовательность
запросов, допустимых для интерфейса с памятью. Таким образом,
отсутствие выравнивания данных снижает производительность из-за
увеличения количества обращений к памяти. Для повышения
производительности структуры данных (особенно стеки) следует
выравнивать по четным адресам и по адресам, кратным четырем.


┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                                    7              0          │
│                                    ┌───────────────┐         │
│                                    │     Байт      │ БАЙТ    │
│                                    └───────────────┘         │
│                        15                         0          │
│                        ┌─────────────┬─────────────┐         │
│                        │ Старший байт│ Младший байт│ СЛОВО   │
│                        └─────────────┴─────────────┘         │
│                           адрес N+1      адрес N             │
│ 31                     15                         0          │
│ ┌──────────────────────┬───────────────────────────┐         │
│ │    Старшее слово     │      Младшее слово        │ ДВОЙНОЕ │
│ └──────────────────────┴───────────────────────────┘ СЛОВО   │
│   адрес N+3  адрес N+2     адрес N+1      адрес N            │
│                                                              │
└──────────────────────────────────────────────────────────────┘

                Рисунок 2-2. Основные типы данных


┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                                    ┌───────────────┐         │
│                                    │               │ Е       │
│ Двойное слово по адресу A      ─┬─ ├───────────────┤         │
│    содержит 7AFE0636            │  │      7A       │ D       │
│                            ─┬─  │  ├───────────────┤         │
│                             │   │  │      FE       │ C       │
│ Слово по адресу B содержит  │   │  ├───────────────┤         │
│           FE06              │   │  │      06       │ B       │
│                            ─┴─  │  ├───────────────┤         │
│                                 │  │      36       │ A       │
│                        ─┬─     ─┴─ ├───────────────┤         │
│ Байт по адресу 9        │          │      1F       │ 9       │
│ содержит  1F           ─┴─         ├───────────────┤         │
│                                    │               │ 8       │
│                            ─┬─     ├───────────────┤         │
│                             │      │      23       │ 7       │
│ Слово по адресу 2 содержит  │      ├───────────────┤         │
│                             │      │      0B       │ 6       │
│                            ─┴─     ├───────────────┤         │
│                                    │               │ 5       │
│                                    ├───────────────┤         │
│                                    │               │ 4       │
│ Слово по адресу 2 содержит     ─┬─ ├───────────────┤         │
│         74CB                    │  │      74       │ 3       │
│                            ─┬─  │  ├───────────────┤         │
│                             │   │  │      CB       │ 2       │
│ Слово по адресу 1 содержит  │  ─┴─ ├───────────────┤         │
│         CB31                │      │      31       │ 1       │
│                            ─┴─     ├───────────────┤         │
│                                    │               │ 0       │
│                                    └───────────────┘         │
│                                                              │
└──────────────────────────────────────────────────────────────┘

       Рисунок 2-3. Байты, слова и двойные слова в памяти


Т.к. байты, слова и двойные слова являются основными типами
операндов, процессор также поддерживает дополнительную
интерпретацию этих операндов. Специализированные команды
распознают следующие типы данных (смотри Рисунок 2-4):

- Целый тип: знаковое двоичное значение, содержащееся в
  32-разрядном двойном слове, 16-разрядном слове или 8-разрядном
  байте. Все операции предполагают представление чисел в
  дополнительном коде. Знаковый бит расположен в бите 7 в байте,
  в бите 15 в слове и в бите 31 в двойном слове. Он равен 0 для
  положительных чисел и 1 для отрицательных. 8-разрядное целое
  число может изменяться в диапазоне от -128 до +127,
  16-разрядное целое число в диапазоне от -32768 до +32767, а 32
  -разрядное целое число в диапазоне от -2**31 до +2**31-1.

- Обычный тип: беззнаковое двоичное значение, содержащееся в 32-
  разрядном двойном слове, 16-разрядном слове или 8-разрядном
  байте. Значение числа для байта может изменяться от 0 до 255,
  для слова от 0 до 65535 и для двойного слова от 0 до 2**32-1.

- Ближний указатель: 32-разрядный логический адрес, который
  представляет собой относительный адрес внутри сегмента.
  Ближние указатели используются для всех указателей в сплошной
  модели и для ссылок внутри сегмента в сегментированной модели
  памяти.

- Дальний указатель: 48-разрядный логический адрес из двух
  компонентов: 16-разрядного селектора сегмента и 32-разрядного
  относительного адреса. Дальние указатели используются
  программами только в том случае, когда конструкторы системы
  выбирают сегментированную модель памяти.

- Строка: непрерывная последовательность байтов, слов или
  двойных слов. Строка может содержать от 0 до 2**32-1 байтов
  или 4 Гбайт.

- Битовое поле: непрерывная последовательность битов, в которой
  каждый бит рассматривается как независимая переменная. Битовое
  поле может начинаться с любого бита любого байта и может быть
  длиной до 32 бит.

- Битовая строка: непрерывная последовательность битов. Битовая
  строка может начинаться с любого бита любого байта и иметь
  длину до (2**32-1) бит.

- Неупакованный двоично-десятичный тип (НДД): распакованное
  байтовое представление десятичной цифры от 0 до 9.
  Распакованные десятичные числа хранятся как беззнаковые
  байтовые значения по одной цифре в каждом байте. Значение
  цифры определяется младшим полубайтом. Старший полубайт должен
  быть равным нулю при делении и умножении, но может иметь любое
  значение при вычитании или сложении.

- Упакованный двоично-десятичный тип (УДД): упакованное байтовое
  представление двух десятичных цифр от 0 до 9. Каждая цифра
  хранится в своем полубайте. Цифра в старшем полубайте является
  более значимой. Диапазон упакованного десятичного байта
  составляет от 0 до 99.

- Вещественные типы (типы данных с плавающей точкой): описание
  данных для операций с плавающей точкой приводится в Главе 15.

┌──────────────────────────────────────────────────────────────┐
│                                         7     0     Целый    │
│                                        ┌┬┬┬┬┬┬┬┐    1 байт   │
│                                        └───────┘ 7 бит цифры │
│                                         ├──────┤ 1 бит знак  │
│                                        ├┤                    │
│                                 15            0     Целый    │
│                                ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐    1 слово  │
│                                └───────┴───────┘ 15 бит цифры│
│                                 ├──────────────┤ 1  бит знак │
│                                ├┤                            │
│                 31                            0     Целый    │
│                ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ 1 дв. слово │
│                └───────┴───────┴───────┴───────┘ 31 бит цифры│
│                 ├──────────────────────────────┤ 1  бит знак │
│                ├┤                                            │
│                                         7     0     Обычный  │
│                                        ┌┬┬┬┬┬┬┬┐    1 байт   │
│                                        └───────┘ 8 бит цифры │
│                                        ├───────┤             │
│                                 15            0     Обычный  │
│                                ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐    1 слово  │
│                                └───────┴───────┘ 16 бит цифры│
│                                ├───────────────┤             │
│                 31                            0     Обычный  │
│                ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ 1 дв. слово │
│                └───────┴───────┴───────┴───────┘ 32 бит цифры│
│                ├───────────────────────────────┤             │
│                 N                             0     НДД      │
│                ┌┬┬┬┬┬┬┬┐       ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ 4 бит цифра │
│                └───────┘ " " " └───────┴───────┘ в 1 байте   │
│                                         ───┤   ├───          │
│                                 ───┤   ├───                  │
│                 N                             0     УДД      │
│                ┌┬┬┬┬┬┬┬┐       ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ 4 бит цифра │
│                └───────┘ " " " └───────┴───────┘ 4 бит цифра │
│                                         ───┤   ├───          │
│                                     ───┤   ├───  2 в 1 байте │
│                 31                            0  Близкий     │
│                ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ указатель   │
│                └───────┴───────┴───────┴───────┘ 32 бита     │
│                ├───────────────────────────────┤ смещение    │
│  47             31                            0  Дальний     │
│ ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ указатель   │
│ └───────┴──────┴───────┴───────┴───────┴───────┘ 32 бит смещ.│
│                ├───────────────────────────────┤ 16 бит      │
│ ├──────────────┤                                    селектор │
│ ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ Битовое поле│
│ └───────┴──────┴───────┴───────┴───────┴───────┘ до 32 бит   │
│           ├───────────────────────────────┤                  │
│ ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐       ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ Битовая     │
│ └───────┴──────┴───────┘ " " " └───────┴───────┘ строка      │
│           ├───────────────────────────────┤      до 4 Гбит   │
│ ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐       ┌┬┬┬┬┬┬┬┬┬┬┬┬┬┬┬┐ Байтовая    │
│ └───────┴──────┴───────┘ " " " └───────┴───────┘ строка      │
│         ├──────────────────────────────┤         до 4 Гбайт  │
│                                                              │
└──────────────────────────────────────────────────────────────┘

                     Рисунок 2-4. Типы данных

2.3 Регистры
----------------------------------------------------------------

Процессор i486 содержит 16 регистров, которые могут
использоваться прикладными программистами. Как показано на
Рисунке 2-5, ригистры могут быть сгруппированы следующим
образом:

1. Регистры общего назначения (РОН). Это восемь 32-битных
   регистра, которые могут произвольно использоваться
   программистами.

2. Регистры сегментов (РС). Данные регистры содержат селекторы
   сегментов, соответствующих различным формам доступа к памяти.
   Например, существуют специальные сегментные регистры для
   доступа к пространству кода и пространству стека. Шесть
   сегментных регистров определяют, какие сегменты памяти
   доступны в каждый определенный момент времени.

3. Регистр состояния (регистр системных флагов) и управляющие
   регисты (РС и УР). Данные регистры определяют и позволяют
   изменять состояние процессора i486.

2.3.1 Регистры общего назначения.
----------------------------------------------------------------

Регистрами общего назначения называются 32-битные регистры EAX,
EBX, ECX, EDX, EBP, ESP, ESI и EDI. Данные регистры используются
для хранения операндов логических и арифметических команд. Кроме
того, они могут использоваться для хранения операндов при
вычислении адресов (кроме регистра ESP, который не может быть
использован как индексный операнд). Имена указанных регистров
наследованы от имен регистров общего назначения процессора 8086
- AX, BX, CX, DX, BP, SP, SI и DI. В Таблице 2-1 показано, как
можно адресовать младшие 16 бит регистров общего назначения
процессора i486, используя имена регистров процессора 8086.

Каждый байт 16-битных регистров AX, BX, CX и DX также имеет свое
имя. Байты этих регистров называются AH, BH, CH и DH (старшие
байты) и AL, BL, CL и DL (младшие байты).


                  Таблица 2-1. Имена регистров

┌───────────────────┬──────────────────────┬───────────────────┐
│      8 БИТ        │       16 БИТ         │      32 БИТА      │
├───────────────────┼──────────────────────┼───────────────────┤
│       AL          │         AX           │        EAX        │
│       AH          │                      │                   │
│       BL          │         BX           │        EBX        │
│       BH          │                      │                   │
│       CL          │         CX           │        ECX        │
│       CH          │                      │                   │
│       DL          │         DX           │        EDX        │
│       DH          │                      │                   │
│                   │         SI           │        ESI        │
│                   │         DI           │        EDI        │
│                   │         BP           │        EBP        │
│                   │         SP           │        ESP        │
└───────────────────┴──────────────────────┴───────────────────┘

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│              Регистры общего назначения                      │
│                                                              │
│ 31          23           15           7        0 16бит 32бита│
│┌───────────┬───────────┐┌───────────┐┌──────────┐            │
││           │           ││     AH    ││    AL    │  AX   EAX  │
│├───────────┼───────────┤├───────────┤├──────────┤            │
││           │           ││     DH    ││    DL    │  DX   EDX  │
│├───────────┼───────────┤├───────────┤├──────────┤            │
││           │           ││     CH    ││    CL    │  CX   ECX  │
│├───────────┼───────────┤├───────────┤├──────────┤            │
││           │           ││     BH    ││    BL    │  BX   EBX  │
│└───────────┴───────────┘└───────────┘└──────────┘            │
│┌───────────┬───────────┐┌───────────────────────┐            │
││           │           ││           BP          │       EBP  │
│├───────────┼───────────┤├───────────────────────┤            │
││           │           ││           SI          │       ESI  │
│├───────────┼───────────┤├───────────────────────┤            │
││           │           ││           DI          │       EDI  │
│├───────────┼───────────┤├───────────────────────┤            │
││           │           ││           SP          │       ESP  │
│└───────────┴───────────┘└───────────────────────┘            │
│                                                              │
│                            Регистры сегментов                │
│                          15                    0             │
│                         ┌───────────────────────┐            │
│                         │           CS          │            │
│                         ├───────────────────────┤            │
│                         │           SS          │            │
│                         ├───────────────────────┤            │
│                         │           DS          │            │
│                         ├───────────────────────┤            │
│                         │           ES          │            │
│                         ├───────────────────────┤            │
│                         │           FS          │            │
│                         ├───────────────────────┤            │
│                         │           GS          │            │
│                         └───────────────────────┘            │
│                                                              │
│      Регистр состояния ( регистр системных флагов )          │
│      и управляющий регистр ( указатель команд )              │
│ 31                                             0             │
│┌────────────────────────────────────────────────┐            │
││                   EFLAGS                       │            │
│├────────────────────────────────────────────────┤            │
││                    EIP                         │            │
│└────────────────────────────────────────────────┘            │
│                                                              │
└──────────────────────────────────────────────────────────────┘

  Рисунок 2-5. Регистры, используемые прикладными программами

Все регистры общего назначения могут использоваться для адресных
вычислений и для получения результатов большинства
арифметических и логических операций. Однако, некоторые команды
используют фиксированные регистры для хранения операндов.
Например, команды обработки строк используют в качестве
операндов содержимое регистров ECX, ESI и EDI. Использование
фиксированных регистров для некоторых операций позволяет более
компактно кодировать набор команд. Следующие команды используют
фиксированные регистры: умножение и деление с двойной точностью,
ввод/вывод, обработка строк, перекодирование, цикл, сдвиг и
циклический сдвиг, операции со стеком.

2.3.2 Регистры сегментов
----------------------------------------------------------------

Сегментирование позволяет разработчикам систем выбирать
различные модели организации памяти. Проблемы разработки
конкретных моделей памяти подробно рассматривается в Части II -
Системное программирование.

Регистры сегментов содержат 16-разрядные селекторы сегментов,
которые указывают на таблицу распределения памяти. Данная
таблица содержит базовые адреса сегментов и другую информацию,
регламентирующую доступ к памяти. При использовании плоской
(несегментированной) модели все сегменты отображаются в единое
пространство физической памяти, как это показано на Рисунке 2-6.

В каждый момент времени непосредственно доступны не более 6-и
сегментов. Их селекторы содержатся в регистрах CS, DS, SS, ES,
FS и GS. Каждый регистр ассоциируется с сегментом, который
соответствует одному из возможных типов доступа к памяти (коды,
данные или стек). Каждый регистр указывает на конкретный
сегмент, используемый программой и имеющий определенный тип
доступа (смотри Рисунок 2-7). Остальные сегменты могут быть
использованы после загрузки соответствующих селекторов в
сегментные регистры.

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│      Различные логические          Единственное физическое   │
│            сегменты                 адресное пространство    │
│                                                              │
│        ┌──────────────────┐        ┌────────────────────┐    │
│  GS    │                  │        │                    │    │
│  FS    │                  │        │                    │    │
│  ES    │                  │ -----> │                    │    │
│  DS    │                  │        │                    │    │
│  CS    │                  │        │                    │    │
│  SS    │                  │        │                    │    │
│        └──────────────────┘        └────────────────────┘    │
│                                                              │
└──────────────────────────────────────────────────────────────┘

       Рисунок 2-6. Плоская (несегментированная) память


┌──────────────────────────────────────────────────────────────┐
│                                                              │
│                                          Различные адресные  │
│     Различные логические сегменты            пространства    │
│                                          в физической памяти │
│            CS  ┌───────────────────┐     ┌───────────────┐   │
│          SS ┌──┴─────────────────┐ │     │    Сегмент    │   │
│        DS ┌─┴──────────────────┐ │ │     │     кода      │   │
│      ES ┌─┴──────────────────┐ │ │ │     │               │   │
│    FS ┌─┴─────────────────┐  │ ├─┘ │     ├───────────────┤   │
│     ┌─┴────────────────┐  │  │ │   │     │ Сегмент стека │   │
│     │                  │  │  │ │   │     ├───────────────┤   │
│     │                  │  │  │ │   │     │    Сегмент    │   │
│     │                  │  │  │ │   │ --> │    данных     │   │
│     │                  ├──┘  │ ├───┘     │               │   │
│     │                  │     │ │         ├───────────────┤   │
│     │                  ├─────┘ │         │ Сегмент данных│   │
│     │                  ├───────┘         ├───────────────┤   │
│     │                  │                 │ Сегмент данных│   │
│     └──────────────────┘                 ├───────────────┤   │
│                                          │    Сегмент    │   │
│                                          │    данных     │   │
│                                          └───────────────┘   │
└──────────────────────────────────────────────────────────────┘

              Рисунок 2-7. Сегментированная модель

Сегмент, содержащий последовательность исполняемых команд,
называется сегментом кода. Селектор этого сегмента содержится в
регистре CS. Процессор i486 выбирает команды из этого сегмента,
используя содержимое счетчика команд (регистр EIP) как
относительный адрес внутри сегмента. Содержимое регистра CS
изменяется в результате выполнения межсегментных команд
управления потоком (CALL, IRET и JMP), прерываний и исключений.

Вызовы подпрограмм, записи параметров и активизация процедур
обычно требует области памяти, резервириемой под стек. Все
операции со стеком используют регистр SS при обращении к стеку.
В отличие от регистра CS, регистр SS может быть загружен явно с
помощью команды программы.

Остальные четыре регистра являются регистрами сегментов данных
(DS, ES, FS и CS), каждый из которых используется текущей
исполняемой программой. Доступ к четырем раздельным областям
данных имеет целью повысить эффективность программ и
безопасность доступа при обращении к различным типам структур
данных. Например, имеет смысл разнести по разным сегментам
собственные данные программного модуля, данные полученные из
модуля более высокого уровня, динамически создаваемые структуры
данных и данные, разделяемые текущим модулем с другими модулями.
Механизм сегментации позволяет ограничить разрушения неправильно
работающей вследствии ошибки программы только теми сегментами,
которые выделены текущей программе. Операнды, расположенные
внутри сегмента данных адресуются указанием их смещения
непосредственно внутри команды или в регистре общего назначения.

В некоторых случаях (при сложной структуре данных) может
возникнуть необходимость иметь доступ к более чем к четырем
сегментам данных. Доступ к дополнительным сегментам
осуществляется путем перезагрузки регистров DS, ES, FS и GS
прикладной программой в процессе выполнения. Загрузка нужного
сегментного регистра должна происходить до обращения к данным
соответствующего сегмента.

При использовании регистров сегментов, с каждым выбранным
сегментом связывается базовый адрес. При адресации единицы
данных внутри сегмента, к базовому адресу сегмента добавляется
32-разрядный относительный адрес. Если сегмент выбран загрузкой
селектора сегмента в регистр сегмента, то командам манипуляции
данными нужен только этот относительный адрес.

2.3.3 Реализация стека
----------------------------------------------------------------

Операции со стеком поддерживаются тремя регистрами:

1. Регистр сегмета стека (SS). Стеки размещаются в памяти.
   количество стеков в системе ограничивается только
   максимальным числом сегментов. Размер стека не может
   превышать 4 Гбайт, что соответствует максимальному размеру
   сегмента для процессора i486. В каждый момент времени
   доступен только один стек - стек, селектор сегмента которого
   содержится в регистре SS. Этот стек называется текущим,
   однако далее слово "текущий" будет, как правило, опускаться,
   а текущий стек будет называться просто "стеком". Регистр SS
   автоматически используется процессором для выполнения всех
   операций со стеком.

2. Регистр указателя стека (ESP). В регистре ESP содержится
   относительный адрес вершины стека в текущем сегменте стека.
   Его значение используется командами POP и PUSH, при вызове
   подпрограмм и при возврате, исключениями и прерываниями. При
   занесении элемента в стек (смотри Рисунок 2-8), процессор
   уменьшает значение регистра ESP, а затем записывает элемент
   по адресу новой вершины. При извлечении данных из стека,
   процессор копирует элемент, расположенный по адресу вершины,
   а затем увеличивает значение регистра указателя стека. Иными
   словами, стек растет вниз, в сторону уменьшения адресов.

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│      Сегмент стека                                           │
│                                                              │
│ 31                    0                                      │
│┌───────────────────────┐                                     │
││                       │<--------   Начало стека             │
│├───────────────────────┤            ( определяется значением │
││                       │              регистра ESP )         │
│├───────────────────────┤                                     │
││                       │                                     │
│├───────────────────────┤                                     │
││                       │                                     │
│├───────────────────────┤                                     │
││                       │                                     │
│├───────────────────────┤        ┌───────────────────────┐    │
││    Вершина стека      │<-------│           ESP         │    │
│└───────────────────────┘        └───────────────────────┘    │
│                                                              │
│    ┌────┐                         ┌────┐                     │
│    │ │  │ При занесении данных,   │/ \ │ При удалении данных,│
│    │ │  │ вершина стека переме-   │ │  │ вершина стека       │
│    │ │  │ щается к меньшему ад-   │ │  │ перемещается        │
│    │ │  │ рес.                    │ │  │ к большему адресу.  │
│    │\ / │                         │ │  │                     │
│    └────┘                         └────┘                     │
│                                                              │
└──────────────────────────────────────────────────────────────┘

                       Рисунок 2-8 Стеки

3. Регистр указателя базы кадра стека (EBP). Данный регистр, как
   правило, используется для доступа к структурам данных,
   содержащимся в стеке. Например, при входе в подпрограмму,
   стек содержит адрес возврата и некоторое число параметров,
   передаваемых в данную подпрограмму. Подпрограмма, при
   необходимости создания временных локальных переменных,
   использует стек, что приводит к изменению указателя стека по
   мере занесения и удаления данных в стеке. Если перед началом
   выполнения операций со стеком указатель стека копируется в
   базовый указатель кадра стека, последний может быть
   использован для доступа к данным, имеющим фиксированное
   смещение в сегменте стека. Если этого не делать, доступ к
   структурам данных, имеющим фиксированное смещение, может быть
   утерян в процессе занесения в стек и удаления из стека
   временных переменных. При использование регистра EBP для
   хранения адреса пямяти, текущий сегмент обязательно должен
   быть выбран (установлен регистр SS). Т.к. нет необходимости
   указывать сегмент стека в каждой команде, их кодирование
   становится более компактным. Регистр EBP может также
   использоваться для адресации других сегментов. Такие команды
   как ENTER и LEAVE предусматривают автоматическое
   использование регистра EBP для обеспечения удобного доступа к
   переменным.

2.3.4 Регистры флагов
----------------------------------------------------------------

Коды ситуации ( например, перенос, знак, переполнение ) и биты
режимов хранятся в специальном 32-разрядном регистре EFLAGS. На
Рисунке 2-9 показано содержимое этого регистра. Флаги данного
регистра управляют определенными операциями и отражают состояние
процессора i486.

Флаги могут быть условно разделены на три группы: флаги
состояния, управляющие флаги, системные флаги. Системные флаги
обсуждаются в Части II.

2.3.4.1 Флаги состояния
----------------------------------------------------------------

Флаги состояния регистра EFLAGS отражают тип результата
исполнения арифметических операций. Операция MOV не оказывает
влияние на состояние данных флагов. Команды условных переходов и
вызовы подпрограмм дают возможность программе отслеживать
значения флагов состояния и реагировать на них. Например, при
выполнении цикла с уменьшением счетчика цикла и выходом при
равенстве счетчика 0, отслеживается состояние флага ZF, которое
используется оператором условного перехода для повторения
операций цикла или выхода из цикла.

Флаги состояния показаны в Таблице 2-2.

2.3.4.2 Управляющий флаг
----------------------------------------------------------------

Управляющий флаг DF регистра EFLAGS определяет порядок работы
операций со строками.

DF (флаг направления, 10-ий бит)

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│                           1 1 1 1 1 1 1 1 1                     │
│ 31                        8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 │
│┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐│
││ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │   │ │ │ │ │ │ │ │ │ │ │ │ ││
││0│0│0│0│0│0│0│0│0│0│0│0│0│A│V│R│0│N│I O│O│D│I│T│S│Z│0│A│0│P│1│C││
││ │ │ │ │ │ │ │ │ │ │ │ │ │C│M│F│ │T│P L│F│F│F│F│F│F│ │F│ │F│ │F││
││ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │   │ │ │ │ │ │ │ │ │ │ │ │ ││
│└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘│
│                           │ │ │   │  │  │ │ │ │ │ │   │   │   │ │
│ х Проверка выравнивания ──┘ │ │   │  │  │ │ │ │ │ │   │   │   │ │
│ х Флаг режима виртуального ─┘ │   │  │  │ │ │ │ │ │   │   │   │ │
│   процессора 8086             │   │  │  │ │ │ │ │ │   │   │   │ │
│ х Флаг возобновления ─────────┘   │  │  │ │ │ │ │ │   │   │   │ │
│ х Флаг вложенной задачи ──────────┘  │  │ │ │ │ │ │   │   │   │ │
│ х Уровень привилегий ввода-вывода ───┘  │ │ │ │ │ │   │   │   │ │
│ с Флаг переполнения ────────────────────┘ │ │ │ │ │   │   │   │ │
│ у Флаг направления ───────────────────────┘ │ │ │ │   │   │   │ │
│ х Разрешение прерываний ────────────────────┘ │ │ │   │   │   │ │
│ х Флаг ловушки ───────────────────────────────┘ │ │   │   │   │ │
│ с Флаг знака ───────────────────────────────────┘ │   │   │   │ │
│ с Флаг нуля ──────────────────────────────────────┘   │   │   │ │
│ с Флаг вспомогательного переноса ─────────────────────┘   │   │ │
│ с Флаг четности ──────────────────────────────────────────┘   │ │
│ с Флаг переноса ──────────────────────────────────────────────┘ │
│                                                                 │
│ х - системный флаг                                              │
│ с - флаг состояния                                              │
│ у - управляющий флаг                                            │
│                                                                 │
│ 1 или 0 обозначают биты, зарезервированные фирмой Intel         │
│ Данные регистры не используются, а их значения всегда постоянны │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘

                  Рисунок 2-9. Регистр EFLAGS

                  Таблица 2-2 Флаги состояния
┌───────┬─────────────────┬────────────────────────────────────┐
│  Имя  │   Назначения    │   Соответствует условию            │
├───────┼─────────────────┼────────────────────────────────────┤
│ OF    │ переполнение    │ Результат превысил положительный   │
│       │                 │ или отрицательный предел для чисел │
│ SF    │ знак            │ Результат отрицательный (меньше 0) │
│ ZF    │ нуль            │ Результат равен 0                  │
│ AF    │ вспомогательный │ Перенос из 3-го бита               │
│       │ перенос         │ (используется при работе с BCD)    │
│ PF    │ четность        │ Младший байт содержит четное число │
│       │                 │ единиц                             │
│ CF    │ флаг переноса   │ Перенос за пределы значимых цифр   │
│       │                 │ результата                         │
└───────┴─────────────────┴────────────────────────────────────┘

Установка флага DF позволяет устанавливать автоматическое
увеличение или уменьшение счетчиков во время операций со
строками. Если флаг очищен, то счетчики инкрементируются, иначе
декрементируются.

2.3.4.3 Указатель команд
----------------------------------------------------------------

Расширеный указатель команд (EIP) содержит смещение в текущем
сегменте кода следующей подлежащей выполнению команды. Указатель
команд непосредственно не доступен программисту, но он
управляется явно командами управления потоком (переходы,
возвраты и т.д.), прерываниями и исключениями.

Значение регистра EIP увеличивается, указывая последовательно на
границы исполняемых команд. Однако, команды выбираются с
упреждением, в результате чего, значение EIP только
приблизительно соответствует команде, загружаемой в процессор.

Процессор i486 не загружает команды поодиночке. Для загрузки
команд перед их фактическим использованием, существует функция
опережающего просмотра программы. Она обеспечивает загрузку
выравненного 128-битного блока кода, команды которого хранятся в
процессоре в ожидании обработки. ( Выравнивание блока
производится обнулением четырех последних битов его адреса ).
Данные блоки загружаются с игнорированием границ между
командами. Таким образом, во время начала исполнения команды,
она уже загружена в процессор и декодирована. Такой способ
загрузки команд значительно повышает производительность
процессора, т.к позволяет совмещать выполнение команды, с
загрузкой и декодировать команд.

При выполнении команды перехода и вызова подпрограммы, процессор
загружает выравненый блок, содержащий адрес перехода или
подпрограммы. При этом, команды которые были предварительно
загружены и декодированы, отменяются. Если в результате
выполнения предварительной загрузки вырабатывается исключение,
например, выход за рамки сегмента кода, об исключении не
сообщается, пока выполняются команды, предшествующие байту,
выработавшему данное исключение. Если же команда отменяется,
исключение не генерируется вообще.

В режиме реальной адресации упреждающая выборка может привести к
обращению процессора к неожиданному для программиста адресу
памяти. При работе в защищенном режиме исключения отрабатываются
правильно при обращении к данному адресу. В случае же работы
процессора в реальном режиме, не существует аппаратных
механизмов обеспечения правильной работы процессора. Например,
если система не возвращает RDY#-сигнал (сигнал, который
завершает цикл шины), для циклов шины при обращении к
несуществующему адресу, учреждающая выборка должна быть защищена
от обращения к таким адресам. Если в системе предусмотрена
проверка четности, упреждающая выборка должна быть защищена от
обращения по адресу, расположенному за пределами защищенной по
четности памяти. (Наоборот, RDY# может возвращать четный сигнал
для циклов шины при обращении к несуществующим адресам, и ошибки
четности могут игнорироваться при упреждающей выборке за
пределами защищенной по четности памяти. )

Упреждающая выборка может быть сохранена от ссылки на
нежелательные адреса с помощью организации некоторой дистанции
между адресом и последним выполняемым байтом. Например, для
сохранения упреждающей выборки от обращения к адресам от 10000H
до 1000FH, последний исполняемый байт должен иметь адрес меньше
0FFEEH. Выравненный 128-битный блок между последним байтом
последней исполняемой команды и адресом, обращение к которому
недопустимо, должен быть очищен.

Поведение процессора i486 в процессе упреждающей выборки зависит
от конкретной реализации. Фирма Intel(R) оставляет за собой
право изменять в будущем механизм работы процессора при
упреждающей выборке.

2.4 Формат команд
----------------------------------------------------------------

Каждая команда представляет собой закодированную информацию,
содержащую код операции, подлежащей выполнению, тип операндов
для данной операции и указание на расположение этих операндов.
Если операнд расположен в памяти, в команде может содержаться
явное или неявное указание на сегмент, содержащий указанный
операнд.

Команды состоят из отдельных элементов и могут иметь различные
форматы. Точный формат команд приведен в Приложении B, а ниже
описываются основные для всех команд элементы. Из всех описанных
ниже элементов только один (код операции, Коп) обязательно
присутствует в любой команде. Остальные элементы могут
отсутствовать, что определяется характером операции, а также
местоположением и типом операндов. Ниже описаны элементы команды
в том порядке, как они расположены в команде:

- Префиксы: один или несколько байтов, предшествующих команде и
  модифицирующих операцию этой команды. Следующие префиксы могут
  быть использованы в прикладных программах:

  1. Замена (подавление) сегмента - в явной форме указывает,
     какой сегментный регистр должна использовать программа.
     Префикс отменяет действующий по умолчанию выбор сегментного
     регистра.

  2. Размер адреса - переключает разрядность адреса, определяя
     образование 32-разрядных или 16-разрядных адресов. Любой из
     этих размеров может быть выбираемым по умолчанию: данный
     префикс выбирает альтернативный размер.

  3. Размер операнда - переключает разрядность операндов,
     устанавливая их 32-разрядными или 16-разрядными. Любой из
     этих размеров может быть выбираемым по умолчанию: данный
     префикс выбирает альтернативный размер.

  4. Повторение - используется с командами обработки строк;
     заставляет команду воздействовать на каждый элемент строки.

- Код операции (Коп): описывает операцию, выполняемую командой.
  Некоторым командам присущи несколько кодов операций, каждый из
  которых описывает определенный вариант операции.

- Описатель регистра: в команде могут быть описаны один или два
  регистра в качестве операндов. Описатель регистра может
  присутствовать как в байте кода операции, так и в байте
  описателя режима адресации.

- Описатель режима адресации: этот элемент, если он
  присутствует, описывает, является ли операнд содержимым
  регистра или ячейки памяти. Если операнд находится в памяти,
  описатель режима указывает, надо ли использовать смещение,
  индексный регистр, регистр базы и масштабирование.

- SIB (scale-index-base, масштаб-индакс-база) байт: когда
  описатель режима адресации указывает на использование
  индексного регистра для вычисления адреса операнда, SIB байт
  используется для кодирования в команде базового регистра,
  индексного регистра и коэффициента масштабирования.

- Смещение: Если описатель режима адресации указывает, что при
  вычислении адреса операнда будет использовано смещение, в
  состав кода команды включается поле смещения. Смещение
  представляет собой 8-, 16- или 32-разрядное целое число со
  знаком. 8-разрядная форма используется в тех случаях, когда
  значение смещения невелико. Процессор автоматически увеличит 8
  -разрядное смещение до 16- или 32-разрядов, путем
  распространения его знакового разряда.

- Непосредственный операнд: Если этот элемент присутствует, он
  представляет значение операнда команды. Непосрадственные
  операнды могут быть 8-, 16 или 32-разрядными. В случаях когда
  8-разрядный непосредственный операнд используется в команде
  вместе с 16- или 32-разрядным операндом, процессор
  автоматически увеличивает размер 8-разрядного операнда путем
  расширения его знакового разряда. Таким же способом
  16-разрядный операнд преобразуется в 32-разрядный.

2.5 Выбор операнда
----------------------------------------------------------------

Любая команда либо не использует операндов вообще, либо
использует некоторое число операндов. Примером команды без
операндов может служить команда NOP (нет операции). Если же
команда использует операнды, они могут находится в одном из ниже
указаных мест:

- В самой команде (непосредственный операнд, константа).

- В регистре ( 32-разрядный операнд в регистре EAX, EBX, ECX,
  EDX, ESI, EDI, ESP или EBP, 16-разрядный операнд в регистре
  AX, BX, CX, DX, SI, DI, SP или BP, 8-разрядный операнд в
  регистре AH, AL, BH, BL, CH, CL, DH или DL, в одном из
  сегментных регистров, в регистре EFLAGS для операций с
  флагами). Использование 16-разрядных операндов требует
  использования префикса размера 16-разрядного операнда (байта,
  предшествующего команде и содержащего значение 67H).

* В памяти.

* В порте ввода/вывода

Доступ ко всем операндам осуществляеися очень быстро.
Регистровые и непосредственные операнды находятся
непосредственно в процессоре (последние занесены в процессор в
результате упреждающей выборки как часть интерпретируемой
команды). Доступ к операндам, находящимся в памяти
осуществляется тоже довольно быстро, если они помещены в
кэш-память на микросхеме.

Часть команд, в которых предусмотрено использование операндов,
требует явного указания операндов, другие - используют неявно
заданные операнды. Некоторые команды имеют как явные, так и
неявные операнды. Примеру:

Команда с неявным операндом: AAM

  По определению, операнд команды AAM (ASCII-коррекция после
  умножения) содержится в регистре AX.

Команда с явными операндами: XCHG EAX, EBX

  Операнды, для которых выполняется обмен содержимым,
  закодированы непосредственно в команде, вместе с кодом
  операции.

Команда с явным и неявным операндом: PUSH COUNTER

  Переменная расположенная в памяти COUNTER (явный параметр)
  копируется в вершину стека (неявный параметр).

Особенно важно, что большинство команд имеют неявные операнды.
Например, все арифметические операции обновляют регистр EFLAGS.

Команды могут явно ссылаться на один или два операнда. Команды с
двумя операндами, такие как MOV, ADD и XOR всегда перезаписывают
один из двух операндов, помещая туда результат операции. Это
позволяет выделить два вида операндов: операнд-источник (не
изменяется при выполнении операции) и операнд назначения
(приемник) (в который записывается результат операции).

Для большинства команд, один из двух операндов - либо
операнд-источник, либо операнд назначения, может располагатся в
регистре или памяти. Второй операнд должен располагаться в
регистре или непосредственно в команде (последнее только для
операнда-источника). Это позволяет разбить команды, работающие с
двумя операндами на следующие группы:

- Регистр - регистр

- Регистр - память

- Память - регистр

- Непосредственный операнд - регистр

- Непосредственный операнд - память

Однако, некоторые команды работы со строками и со стеком,
перемещают данные из памяти в память. Оба операнда некоторых
команд обработки строк расположены в памяти и указываются
неявно. Операции занесения в стек и удаления из стека позволяют
переносить данные из операнда, расположенного в памяти в стек,
также расположенный в памяти.

Кроме того, существует несколько операций, использующих три
операнда, например, команды IMUL, SHRD и SHLD. Два операнда из
трех указываются явно, как в командах с двумя операндами, а
третий операнд берется из регистра ECX или указывается
непосредственно в команде. Другие команды с тремя операндами,
такие как команды обработки строк с префиксом повторения, берут
все три операнда из регистров.

2.5.1 Непосредственные операнды
----------------------------------------------------------------

Некоторые команды используют данные, расположенные в самой
команде, в качестве операнда (или операндов). Такие операнды
называются непосредственными операндами. Они могут иметь размер
байта, слова или двойного слова. Например:

SHR PATTERN, 2

Один байт данной команды содержит число 2, которое указывает
число битов, на которое необходимо сдвинуть переменную PETTERN.

TEST PETTERN, 0FFFF00FFH

Двойное слово в данной команде содержит маску, которая
используется для проверки переменной PATTERN.

IMUL CX, MEMWORD, 3

Слово в памяти умножается на непосредственный операнд 3 и
результат помещается в регистр CX.

Все арифметические команды (исключая деление) позволяют
использовать непосредственный операнд-источник. Когда операндом
назначения является регистр AL или EAH, при ее кодировании
используется на один байт меньше, чем при кодировании этой же
команды, но с использованием другого регистра общего назначения.

2.5.2 Регистровые операнды
----------------------------------------------------------------

Регистровые операнды могут располагаться в 32-разрядном регистре
общего назначения (EAX, EBX, ECX, EDX, ESI, EDI, ESP или EBP), в
16-разрядном регистре общего назначения (AX, BX, CX, DX, SI, DI,
SP или BP), в 8-разрядном регистре общего назначения (AH, AL,
BH, BL, CH, CL, DH или DL).

В процессоре i486 имеются команды для работы с сегментными
регистрами (CS, DS, ES, SS, FS и GS). Эти команды Могут
использоваться прикладными программистами только если
разработчики системы выбрали сегментированную модель памяти.

Кроме того, процессор i486 имеет команды для изменения отдельных
флагов в регистре EFLAGS. Такие команды существуют для изменения
флагов, которые часто используются. Остальные флаги, которые не
используются так часто, могут быть изменены следующим образом:
содержимое регистра EFLAGS заносится в стек, вносятся
необходимые изменения в копию его содержимого в стеке, а затем
исправленные данные восстанавливаются в регистр.

2.5.3 Операнды в памяти
----------------------------------------------------------------

Команды с явными операндами в памяти должны содержать указание
на сегмент, содержащий операнд и смещение операнда относительно
начала сегмента. Сегменты указываются при помощи префикса замены
сегмента (байта, который помещается перед командой). Если
сегмент не указывается явно, он выбирается автоматически
согласно простому правилу. Смещение операнда в сегменте
указывается одним из следующих способов:

1. Большинство команд, которые обращаются к памяти, содержат
   байт для указания метода адресации операнда. Байт, который
   называется modR/M, помещается после кода операции и
   указывает, где располагается операнд: в памяти или в
   регистре. Если операнд находится в памяти, его адрес
   получается исходя из содержимого сегментного регистра и
   следующих величин: регистра базы, регистра индекса,
   масштабирования и смещения. При использовании индексного
   регистра, байт modR/M следует за байтом, кодирующим индексный
   регистр и масштабирование. Такой способ адресации является
   наиболее гибким.

2. Некоторые команды используют неявные режимы адресации:

   Команда MOV, использующая в качестве операнда-источника или
   операнда назначения регистр AL или EAX, может использовать
   для адресации памяти двойное слово, закодированное в команде.
   Эта специальная форма команды MOV не позволяет использовать
   регистр базы, индексный регистр и масштабирование. Такая
   форма команды на один байт короче, чем при использовании
   других регистров общего назначения.

   Операции обработки строк используют для адресации памяти
   сегментный регистр DS и регистр ESI (команды MOVS, CMPS,
   OUTS, LODS и SCAS) или сегментный регистр ES и регистр EDI
   (команды MOVS, CMPS, INS и STOS).

   Операции работы со стеком используют для адресации памяти
   сегментный регистр SS и регистр ESP (команды, прерывания и
   исключения PUSH, POP, PUSHA, PUSHAD, POPA, POPAD, PUSHF,
   PUSHFD, POPF, POPFD, CALL, RET, IRET и IRETD).

2.5.3.1 Выбор сегмента
----------------------------------------------------------------

Явное указание в команде сегмента не является обязательным. Если
сегмент не указан при помощи префикса замены сегмента, процессор
автоматически выбирает сегмент, согласно правилу, отображенному
в Таблице 2-3. (При использовании плоской модели памяти, правила
выбора сегмента являются "прозрачными" для прикладных программ.)

При различных типах доступа к памяти по умолчанию используются
различные сегменты. Операнды данных, как правило, используют
основной сегмент данных (сегмент DS). Однако, т.к. регистры ESP
и EBP используются для работы со стеком, то при использовании
одного из этих регистров в команде, по умолчанию используется
сегмент стека (сегмент SS).

В качестве префикса замены сегмента может выступать любой
сегментный регистр. Однако, в перечисленных ниже случаях будет
всегда использоваться сегмент, принятый по умолчанию, даже если
используется префикс замены сегментов:

- Для строки-приемника в командах обработки строк используется
  сегмент ES.

- Для операнда-приемника в команде занесения в стек и для
  операнда-источника в команде удаления из стека используется
  сегмент SS.

- При выборе команд используется сегмент CS

2.5.3.2 Вычисление эффективного (исполнительного) адреса
----------------------------------------------------------------

Байт modR/M опеспечивает большую гибкость при выборе форм
адресации. Команды, в которых после кода операции стоит байт
modR/M, наиболее общие из всех команд. Для операндов,
расположенных в памяти и описаных при помощи байта modR/M
относительный адрес в выбранном сегменте складываеися из трех
компонентов:

- Смещение

- Регистр базы

- Регистр индекса (индексный регистр может умножаться на 2, 4
  или 8)

┌────────────┬──────────────────────┬──────────────────────────┐
│ Тип ссылки │ Используемый сегмент │ Правило выбора           │
│            │ Используемый регистр │ сегмента по умолчанию    │
├────────────┼──────────────────────┼──────────────────────────┤
│ Команды    │ Сегмент кода         │ Автоматически при выборе │
│            │ регистр CS           │ команды                  │
├────────────┼──────────────────────┼──────────────────────────┤
│ Стек       │ Сегмент стека        │ Для команд занесения в   │
│            │ регистр SS           │ стек и удаления из стека │
│            │                      │ Для некоторых ссылок с   │
│            │                      │ использованием базовых   │
│            │                      │ регистров ESP и EBP      │
├────────────┼──────────────────────┼──────────────────────────┤
│ Локальные  │ Сегмент данных       │ Все ссылки на данные,    │
│  данные    │ регистр DS           │ кроме стека и строк      │
│            │                      │ назначения               │
├────────────┼──────────────────────┼──────────────────────────┤
│ Строки-    │Дополнительный сегмент│ Приемник в командах      │
│ приемники  │ регистр ES           │ обработки строк          │
└────────────┴──────────────────────┴──────────────────────────┘

        Таблица 2-3 Правила выбора сегмента по умолчанию


Относительный адрес, который получается в результате
суммирования указаных компонентов называется эффективным
(исполнительным) адресом. Каждый из этих компонентов может иметь
как положительное, так и отрицательное значение. На Рисунке 2-10
показаны все возможные варианты формирования исполнительного
адреса при использовании байта modR/M.

Т.к. смещение закодированно непосредственно в команде, оно
используется для адресации фиксированных данных, таких как

- Простые скалярные операнды

- Начало статических массивов

- Смещение поля внутри записи

База и индекс выполняют сходные функции. Оба эти компонента
использует одинаковый набор регистров общего назначения. Оба
могут использоваться для обращения по адресам, которые
изменяются в процессе выполнения программы, таким как:

- Параметры процедуры, локальные переменные в стеке.

- Начало конкретной записи в наборе записей одинаковой
  структуры или в массиве записей.

- Начало одномерного массива в многомерном.

- Начало динамически созданного массива.

При использовании регистров общего назначения в качестве базы и
индекса, следует помнить:

- Использование регистра ESP в качестве индексного регистра
  недопустимо.

- Если в качестве базы используются регистры ESP или EBP, по
  умолчанию выбирается сегмент SS. Во всех остальных случаях
  по умолчанию выбирается сегмент DS.

Использования коэффициента масштабирования позволяет эффективно
организовывать индексацию в массивах с 2-, 4- или 8-разрядными
элементами. Масштабирование индексного регистра выполняется
аппаратно, одновременно с вычислением адреса. Это исключает
выполнение дополнительных операций сдвига или умножения.

┌──────────────────────────────────────────────────────────────┐
│                                                              │
│     СЕГМЕНТ + БАЗА + ( ИНДЕКС * КОЭФФИЦИЕНТ ) + СМЕЩЕНИЕ     │
│                                                              │
│           ┌ ... ┐    ┌     ┐    ┌   ┐    ┌                ┐  │
│  ┌    ┐   │ EAX │    │ EAX │    │ 1 │    │                │  │
│  │ CS │   │ ECX │    │ ECX │    │   │    │  Нет смещения  │  │
│  │ SS │   │ EDX │    │ EDX │    │ 2 │    │                │  │
│  │ DS │   │ EBX │    │ EBX │    │   │    │  8-разрядное   │  │
│  │ ES │ + │ ESP │ +  │ ... │ *  │   │  + │    смещение    │  │
│  │ FS │   │ EBP │    │ EBP │    │ 4 │    │                │  │
│  │ GS │   │ ESI │    │ ESI │    │   │    │  32-разрядное  │  │
│  └    ┘   │ EDI │    │ EDI │    │ 8 │    │    смещение    │  │
│           └     ┘    └     ┘    └   ┘    └                ┘  │
│                                                              │
└──────────────────────────────────────────────────────────────┘

          Рисунок 2-10. Вычисление эффективного адреса

База, индекс и смещение могут использоваться в различных
комбинациях: некоторые из компонентов могут быть пустыми.
Коэффициент масштабирования может использоваться только
совместно с индексом. Каждая возможная комбинация полезна для
общего использования структур данных ассемблерными программами и
программами языков высокого уровня.

Смещение

Одно смещение (без индекса и базы) указывает относительный адрес
операнда. Такая форма адресации используется для доступа к
статическим скалярным операндам. Смещение может иметь размер
байта, слова или двойного слова.

База

Относительный адрес операнда указывается косвенно, в одном из
регистров общего назначения, как для "смещенных" переменных.

База + Смещение

Регистр и смещение могут быть использованы вместе с двух
случаях:

1. Индекс в статических массивах, элементы которых имеют размер,
   отличный от 2, 4 и 8 бит. Смещение в этом случае кодирует
   относительный адрес начала массива. Регистр содержит
   результаты вычислений, которые определяют смещение
   конкретного элемента внутри массива.

2. Доступ к полю записи. В этом случае регистр базы содержит
   адрес начала записи, а смещение представляет собой
   относительный адрес нужного поля.

Важным частным случаем использования такой комбинации (база +
смещение) является доступ к параметрам в записи активации
процедуры. Запись активации процедуры - это кадр стека,
созданный при входе в процедуру. В данном случае, в качестве
базового регистра удобнее всего использовать EBP, т.к. при его
использовании автоматически выбирается сегмент стека. Такой
способ доступа к параметрам процедуры обеспечивает компактное
кодирование команды.

( Индекс * Коэффициент масштабирования ) + Смещение

Эта комбинация обеспечивает наиболее эффективное индексирование
в статических массивах, элементы которых имеют размер 2, 4 или 8
бит. Смещение указывает адрес начала массива, а индексный
регистр содержит порядковый номер нужного элемента. При этом
процессор автоматически преобразует номер элемента в его
смещение относительно начала массива, используя коэффициент
масштабирования.

База + Индекс + Смещение

Совместное использование двух регистров применяется для
поддержки работы с двумерными массивами (смещение содержит адрес
начала массива) или для доступа к отдельным экземплярам массива
записей (смещение содержит относительный адрес поля внутри
записи).

База + ( Индекс * Коэффициент мастабирования ) + Смещение

Такая комбинация обеспечивает эффективное индексирование в
двумерном массиве, если его элементы имеют размер 2, 4 или 8
битов.

2.6 Прерывания и исключения
----------------------------------------------------------------

В процессоре i486 предусмотрены два механизма прерывания
выполнения программы:

1. Исключения - это синхронные события, которые являются
   ответами процессора на возникновение некоторой ситуации во
   время выполнения команды.

2. Прерывание - это асинхронные события, обычно активизируемые
   сигналом от внешнего по отношению к процессору
   устройства, нуждающегося в обслуживании.

Прерывания и исключения сходны по действию: они заставляют
процессор временно приостановить выполнение программы для
запуска программы с более высоким приоритетом. Оcновное отличие
между этими двумя видами прерываний заключается в их
происхождении. Исключение всегда может быть воспроизведено при
помощи перезапуска программы, вызвавшей данное исключение, в то
время как прерывание может иметь более сложную, зависимую от
времени связь с программой.

Как правило, прикладные программисты не вмешиваются в работу
прерываний и исключений: их обрабатывают операционная система,
монитор или драйверы устройств. Более полная информация для
прикладных программистов о прерываниях содержится в Главе 9.
Однако, некоторые типы исключений полезны для прикладных
программистов и многие операционные системы дают прикладным
программистам возможность обслуживать эти исключения
самостоятельно. При этом операционная система определяет
интерфейс между прикладной программой и механизмом исключений
процессор i486. В Таблице 2-4 приведен список прерываний и
исключений.

┌───────────────┬──────────────────────────────────────────────┐
│ Номер вектора │                      Описание                │
├───────────────┼──────────────────────────────────────────────┤
│     0         │ Ошибка даления                               │
│     1         │ Вызов отладчика                              │
│     2         │ Немаскируемое прерывание                     │
│     3         │ Точка останова                               │
│     4         │ Переполнение при выполнении команды INTO     │
│     5         │ Превышение границы индекса массива           │
│     6         │ Неразрешенный код операции                   │
│     7         │ Недоступное устройство                       │
│     8         │ Двойной отказ                                │
│     9         │ ( Зарезервирован Intel(R). Не должен         │
│               │   использоваться. Для i486 не используется ) │
│     10        │ Неразрешенный сегмент состояния задачи       │
│     11        │ Сегмент отсутствует                          │
│     12        │ Исключение по стеку                          │
│     13        │ Общая защита                                 │
│     14        │ Отказ страницы                               │
│     15        │ ( Зарезервирован Intel(R).                   │
│               │   Не должен использоваться )                 │
│     16        │ Ошибка вещественных вычислений               │
│     17        │ Проверка выравнивания адреса                 │
│  18 - 31      │ ( Зарезервирован Intel(R).                   │
│               │   Не должен использоваться )                 │
│  32 - 255     │ Маскируемые прерывания                       │
└───────────────┴──────────────────────────────────────────────┘

               Таблица 2-4 Исключения и прерывания


- Исключение ошибки деления имеет место при выполнении операций
  DIV или IDIV, если делитель равен нулю или частное слишком
  велико для операнда-приемника. ( См. Главу 3 для получения
  более полной информации о командах DIV и IDIV.)

- Исключение для отладки может передовать управление обратно в
  прикладную программу, если оно произошло в результате
  установки флага TF (флага ловушки).

- Исключение останова вызывается командой INT3. Данная команда
  используется некоторыми отладчиками для остановки выполнения
  программы в определенной точке.

- Исключение переполнения запускается в том случае, если
  процессор выполняет команду INTO и при этом флаг переполнения
  (OF) установлен. См. Главу 3 для ознакомления с командой INTO.

- Исключение нарушения границы возникает при исполнении команды
  BOUND, если индекс массива оказывается больше, чем значение
  границы массива. См. Главу 3 для ознакомления с командой BOUND.

- Исключение отсутствия устройства возникает, если процессор
  обнаруживает команду ESC и флаг TS (переключение задачи) или
  EM (присутствие сопроцессора) в управляющем регистре CR0
  установлены.

- Исключение проверки выравнивания адреса генерируется для
  невыравненых операндов в памяти в пользовательском модуле ( 3
  уровень привилегированности ), обеспечивается одновременной
  установкой AM и AC. Для операндов в памяти в режиме
  супервизора ( 0, 1 и 2 уровень привилегированности ), или для
  операндов в памяти, принятых по умолчанию для режима
  супервизора, исключение не генерируется.

При выполнении команды INT всегда генерируется прерывание:
процессор рассматривает это прирывание как исключение. При этом
(как и для всех остальных исключений) вызывается определенная в
прикладной программе или в операционной системе подпрограмма
обработки исключения. Сама команда INT подробно обсуждается в
Главе 3, а для получения более полной информации об исключениях,
необходимо обратиться к Главе 9.

Исключения, возникшие при сегментации и подкачке страниц
обрабатываются несколько иным способом, нежели прерывания.
Обычно, при возникновении исключения или прерывания, содержимое
счетчика команд (регистр EIP) сохраняется в стеке. При обработке
исключения, возникшего при сегментации или подкачке, сначало
восстанавливается содержимое всех регистров процессора в том
состояние, которое было перед началом интерпретации команды,
вызвавшей исключение. Только после этого сохраняется содержимое
счетчика команд, который в этом случае указывает на данную
команду, а не на следующую. Это позволяет операционной системе
обработать исключение и перезапустить вызвавшую его программу.
Данный механизм обработки исключений при сегментации и подкачке
полностью "прозрачен" для прикладной программы.
