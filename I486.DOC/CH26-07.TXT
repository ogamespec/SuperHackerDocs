
FXTRACT - выделение экспоненты и мантиссы

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F4    FXTRACT  19(16-20)   4(2-4)  Разделение ST на экспоне-|
|                                      нту и мантиссу: ST заме- |
|                                      няется экспонентой, в    |
|                                      мантисса помещается в    |
|                                      стек FPU                 |
-----------------------------------------------------------------


Работа команды
--------------

врем <- мантисса ST;
ST <- экспонента ST;
Декремент указателя вершины стека FPU;
ST <- врем;

Описание
--------

FXTRACT разделяет значение в ST на экспоненту и мантиссу.
Экспонента заменяет исходный операнд на стеке, и затем в стек
помещается мантисса. После выполнения команды FXTRACT ST (новая
вершина стека) содержит значение исходной мантиссы, выраженное
действительным числом: его знак тот же, что и знак операнда,
экспонента равна истинному нулю (16.383 или 3FFFH со смещением),
а мантисса идентична мантиссе исходного операнда. ST(1) содержит
значение истинной (несмещенной) экспоненты исходного операнда,
выраденное действиельным числом.

Для того, чтобы проиллюстрировать работу команды FXTRACT,
предположим, что ST содержит число, истинная экспонента которого
равна +4 (т.е. его поле экспоненты содержит 4003H). После
выполнения FXTRACT ST(1) будет содержать действительное число
+4.0; его знак будет положительным, поле экспоненты будет
содержать 4001H (истинное +2), а поле мантиссы будет содержать 1
00..00В. Другими словами, значение в ST(1) будет равно 1.0 x 2*
*2 = 4. Если ST содержит операнд, истинная компонента которого
равна -7 (т.е. поле экспоненты его содержит значение 3FF8H), то
FXTRACT возвратит "экспоненту" равную -7.0l после выполнения
команды поля ST(1) знака и экспоненты будут содержать C001H
(отрицательный знак, истинная экспонента 2), а мантисса будет
равна 1 1100..00В. Другими словами, значение в ST(1) будет равно
-1.75 x 2**2 = -7.0. В обоих случаях после FXTRACT поля ST знака
и мантиссы будут равны соответствующим полям исходного операнда,
а поле экспоненты будет содержать 3FFFH (истинный 0).

Изменяемые флаги модуля операций с плавающей точкой
---------------------------------------------------

С1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
---------------------------------

Z, D, I, IS

Исключения защищенного режима
----------------------------------

#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
---------------------------------------

Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
----------------------------------------

#NM при установленном EM или TS в CR0.


Примечания
----------

FXTRACT (выделить экспоненту и мантиссу) выполняет надмножество
рекомендуемой IEEE функции logb(x).

Если исходный операнд равен нулю, то FXTRACT оставляет в ST(1)
минус бесконечность (экспонента), а ST будет присвоено нулевое
значение со знаком, равным знаку исходного операнда. В этом
случае также возможно генерирование исключения деления на ноль.

ST(7) должен быть пустым, чтобы избежать исключения неверной
операции.

Команда ST(7) полезна для выполнения операций масштабирования
степени и диапазона. Для выполнения общей операции возведения в
степень используются обе команды, FXTRACT и команда
экспоненцирования по основанию 2 F2XM1. Для преобразования чисел
в расширенном действительном формате к десятичному представлению
(например, для печати или вывода на дисплей) требуется не только
команда FBSTP, но и команда FXTRACT, позволяющая
масштабирование, не ведущее к переполнению диапазона
расширенного формата. FXTRACT также может быть полезна при
отладке, поскольку позволяет отдельно рассматривать экспоненту и
мантиссу действительного числа.

-----------------------------------------------------------------

FYL2X - Вычисление  y  x  log x
                             2
-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F1    FYL2X  311(196-329)  13      Замена ST(1) на          |
|                                      ST(1) x log ST и  извле- |
|                                                 2             |
|                                      чение из стека ST        |
-----------------------------------------------------------------

Работа команды
--------------

ST(1) <- ST(1) x log ST;
                    2
извлечение из стека ST;

Описание
--------

Команда FYL2X вычисляет логарифм ST по основанию 2, умножает
логарифм на ST(1) и возвращает полученное значение в ST(1).
Операнд в ST не может быть отрицательным.


Изменяемые флаги модуля операций с плавающей точкой
---------------------------------------------------

C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
---------------------------------

P, U, O, Z, D, I, IS

Исключения защищенного режима
----------------------------------

#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
---------------------------------------

Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
----------------------------------------

#NM при установленном EM или TS в CR0.


Примечания
----------

Если операнд в ST отрицателен, то генерируется исключение
неверной операции.

Команда FYL2X предназначена, совместно с встроенным умножением,
для оптимизации вычисления логарифмов с произвольным
положительным основанием:

                    1
     log x = (log b)   x  log  x
        b        2           2

Команды FLDL2T и FLDL2E загружают константы log 10 и  log e,
                                               2        2
соответственно.

Центральный процессор i486 периодически во время выполнения
данной команды проверяет прерывания. Для обслуживания прерывания
выполнение данной команды отменяется (abort).

-----------------------------------------------------------------

FYL2XP1 - Вычисление  y  x  log (x+1)
                              2

-----------------------------------------------------------------
|Код      Команда  Число       Парал-  Описание                 |
|операции          тактовых    лельное                          |
|                  циклов      выпол-                           |
|                              нение                            |
|D9 F9  FYL2XP1  313(171-326)  13      Замена ST(1) на          |
|                                      ST(1) x log (ST+1.0) и   |
|                                                 2             |
|                                      извлечение из стека ST   |
-----------------------------------------------------------------

Работа команды
--------------

ST(1) <- ST(1) x log (ST+1.0);
                    2
извлечение из стека ST;

Описание
--------

Команда FYL2X вычисляет логарифм (ST+1.0) по основанию 2,
умножает логарифм на ST(1) и возвращает полученное значение в ST
(1). Операнд в ST должен лежать в диапазоне:

-(1-(кв.корень из 2/2)) <= ST <= кв.корени из 2 - 1


Изменяемые флаги модуля операций с плавающей точкой
---------------------------------------------------

C1, как описано в Таблице 15-1; C0, C2, C3 не определены.

Исключения числовых операций
---------------------------------

P, U, D, I, IS

Исключения защищенного режима
----------------------------------

#NM при установленном EM или TS в CR0.

Исключения режима реальных адресов
---------------------------------------

Прерывание 7 при установленном EM или TS в CR0.

Исключения виртуального режима 8086
----------------------------------------

#NM при установленном EM или TS в CR0.


Примечания
----------

Если операнд в ST лежит вне допустимого диапазона, то результат
выполнения команды FYL2XP1 неопределен.

Команда FYL2Xp1 обеспечивает повышенную точность сравнительно с
FYL2X при вычислении логарифмов чисел, очень близких к 1. При
малом значении эпсилон большее количество значащих цифр можно
получить, передав эпсилон как аргумент команды FYL2XP1, чем
передав 1+эпсилон команде FYL2X.

Центральный процессор i486 периодически во время выполнения
данной команды проверяет прерывания. Для обслуживания прерывания
выполнение данной команды отменяется (abort).

-----------------------------------------------------------------

HLT - Останов

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
| F4        HLT        4       Останов                          |
-----------------------------------------------------------------

Работа команды
--------------

Вход в режим останова.


Описание
--------

Команда HLT останавливает выполнение команд и переводит
процессор в режим HLT. Выполнение будет продолжено после
разрешенного прерывания, немаскируемого прерывания или сброса.
Если для возобновления выполнения после команды HLT используется
прерывание (включая немаскируемые), то сохраненное значение
CS:IP (или CS:EIP) будет указывать на команду, следующую за
командой HLT.

Изменяемые флаги
----------------

Отсутствуют

Исключения защищенного режима
----------------------------------

Команда HLT является привилегированной командой; #GP(0), если
текущий уровень привилегированности не равен 0.

Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

#GP(0); команда HLT является привилегированной командой.

-----------------------------------------------------------------


IDIV - Деление со знаком

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /7    IDIV r/m8     19/20  Деление со знаком AX на байт r/m |
|                              (AL=частное, AH=остаток)         |
|F7 /7    IDIV AX,r/m16 27/28  Деление со знаком DX:AX на слово |
|                              EA  (AX=частное, DX = остаток)   |
|F7 /7    DIV EAX,r/m32 43/44  Деление со знаком EDX:EAX на     |
|                              двойное слово r/m                |
|                              (EAX=частное,EDX = остаток)      |
-----------------------------------------------------------------

Работа команды
--------------

врем <- делимое / делитель;
IF врем не помещается в частном
THEN Прерывание 0;
ELSE
  частное <- врем;
  остаток <- делимое MOD (r/m);
FI;

Замечание: деление со знаком. Делитель задается в операнде r/m.
Делимое, частное и остаток используют неявно задаваемые
регистры. См. таблицу в параграфе "Описание".

Описание
--------

Команда DIV выполняет деление со знаком. Делимое, частное и
остаток неявно распределены фиксированным регистрам. Только
делитель задается как явный операнд r/m (регистр/память). Тип
делителя определяет используемые регистры следующим образом:


-----------------------------------------------------------------
  Размер      Делитель      Частное      Остаток      Делимое
-----------------------------------------------------------------
  байт        r/m8          AL           AH           AX
  слово       r/m16         AX           DX           DX:AX
  двойное
  слово       r/m32         EAX          EDX          EDX:EAX
-----------------------------------------------------------------

Если полученное частное слишком велико и не может поместиться в
операнде назначения, либо при делении на 0, генерируется
прерывание 0. Нецелые частные усекаются до 0. Остаток имеет тот
же знак, что и делимое, а его абсолютное значение всегда меньше
абсолютного значения делителя.

Изменяемые флаги
----------------

Флаги OF, SF, ZF, AF, PF, CF не определены.

Исключения защищенного режима
----------------------------------

Прерывание 0, если частное слишком велико для назначенного для
него регистра (AL или AX), или если делитель равен 0; #GP(0) в
случае недопустимого исполнительного адреса операнда памяти в
сегментах CS, DS, ES, FS или GS; #SS(0) в случае недопустимого
адреса в сегменте SS; #PF(код сбоя) в случае страничного сбоя; #
AC для невыравненной ссылки к памяти при текущем уровне
привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 0, если частное слишком велико для назначенного для
него регистра (AL или AX), или если делитель равен 0; Прерывание
13, если какая-либо часть операнда лежит вне пространства
исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев; #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

------------------------------------------------------------------


IMUL - Умножение со знаком

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|F6 /5    IMUL r/m8    13-18/13-18  AX <- AL * байт r/m         |
|F7 /5    IMUL r/m16   13-26/13-26  DX:AX <- AX * слово r/m     |
|F7 /5    IMUL r/m32   12-42/13-42  EDX:EAX <- EAX * двойное    |
|                                   слово r/m                   |
|0F AF /r IMUL r16,    13-26/13-26  регистр-слово <- регистр-   |
|           r/m16                   слово * слово r/m           |
|0F AF /r IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|           r/m32                   регистр-двойное слово *     |
|                                   двойное слово r/m           |
|6B /r ib IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|         r/m16,imm8                расширенный знаком непосред-|
|                                   ственный байт               |
|6B /r ib IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|         r/m32,imm8                r/m32 * расширенный знаком  |
|                                   непосредственный байт       |
|6B /r ib IMUL r16,    13-26        регистр-слово <- регистр-   |
|               imm8                слово * расширенный знаком  |
|                                   непосредственный байт       |
|6B /r ib IMUL r32,    13-26        регистр-двойное слово <-    |
|               imm8                регистр-двойное слово * рас-|
|                                   ширенный знаком непоср.байт |
|69 /r iw IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|         r/m16,imm16               непосредственное слово      |
|69 /r id IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|         r/m32,imm32               r/m32 * непосредственное    |
|                                   двойное слово               |
|69 /r iw IMUL r16,    13-26/13-26  регистр-слово <- r/m16 *    |
|               imm16               непосредственное слово      |
|69 /r id IMUL r32,    13-42/13-42  регистр-двойное слово <-    |
|               imm32               r/m32 * непосредственное    |
|                                   двойное слово               |
-----------------------------------------------------------------

Примечания: Процессор i486 использует алгоритм умножения типа
"early-out". Фактическое число тактовых циклов зависит от
позиции наиболее значащего бита в оптимизируемом множителе.
Оптимизация выполняется как для положительных, так и для
отрицательных значений. Вследствие данного алгоритма даются
минимальные и максимальные количества тактовых циклов. Для
вычисления фактического числа тактовых циклов используется
следующая формула:

Фактическое число тактовых циклов = если m <> 0 то
max(наименьшее целое число, большее (log |m|)) + 6 циклов.
                                        2
Фактическое число тактовых циклов = если m = 0 то 9 циклов.

(где m это множитель)

Если множитель есть операнд памяти, то прибавляется три цикла.


Работа команды
--------------

результат <- множимое * множитель

Описание
--------

Команда IMUL выполняет умножение со знаком. Некоторые формы этой
команды используют неявные операнды-регистры. Комбинации
операндов для всех форм команды показаны в колонке "Описание"
выше.

Команда IMUL очищает флаги OF и CF в следующих условиях:

-----------------------------------------------------------------
   Форма команды       |      Условие очистки флагов CF и OF
-----------------------------------------------------------------
     r/m8                 AL = расширение знаком AL до 16 битов
     r/m16                AX = расширение знаком AX до 32 битов
     r/m32                EDX:EAX = расширение знаком EAX до 16
                          битов
     r16,r/m16            Результат в точности помещается в r16
     r32,r/m32            Результат в точности помещается в r32
     r16,r/m16,imm16      Результат в точности помещается в r16
     r32,r/m32,imm32      Результат в точности помещается в r32
-----------------------------------------------------------------

Изменяемые флаги
----------------

Флаги OF и CF описаны выше в разделе "описание"; флаги SF, ZF,
AF, PF не определены.

Исключения защищенного режима
----------------------------------

#GP(0) в случае недопустимого исполнительного адреса операнда
памяти в сегментах CS, DS, ES, FS или GS; #SS(0) в случае
недопустимого адреса в сегменте SS; #PF(код сбоя) в случае
страничного сбоя; #AC для невыравненной ссылки к памяти при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев; #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Примечания
----------

При использовании некоторых форм аккумулятора (IMUL r/m8, IMUL r
/m16 или IMUL r/m32) результат умножения доступен даже при
установленном флаге переполнения, поскольку размер результата в
два раза превышает размер множимого и множителя. Это достаточно
для обработки любого возможного результата.

-----------------------------------------------------------------

IN - Ввод из порта

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|E4 ib    IN AL,imm8  14,pm=8*/     Ввод байта из непосредствен-|
|                     28**,vm=27    но заданного порта в AL     |
|E5 ib    IN AX,imm8  14,pm=8*/     Ввод слова из непосредствен-|
|                     28**,vm=27    но заданного порта в AX     |
|E5 ib   IN EAX,imm8  14,pm=8*/     Ввод двойного слова из непо-|
|                     28**,vm=27    средственно заданного порта |
|                                   в EAX                       |
|EC       IN AL,DX    14,pm=8*/     Ввод байта из порта DX в AL |
|                     28**,vm=27                                |
|ED       IN AX,DX    14,pm=8*/     Ввод слова из пора DX в AX  |
|                     28**,vm=27                                |
|ED      IN EAX,DX    14,pm=8*/     Ввод двойного слова из порта|
|                     28**,vm=27    DX в EAX                    |
-----------------------------------------------------------------

     Примечания: * если CPL <= IOPL
                ** если CPL >= IOPL

Работа команды
--------------

IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(SRC, width(SRC))
  THEN #GP(0);
  FI;
FI;
DEST <- [SRC]; (* Чтение из адресного пространства ввода/вывода *)

Описание
--------

Команда IN пересылает байт или слово данных из заданного числом
во втором операнде порта в регистр (AL, AX или EAX), заданный
первым операндом. Доступ к любому порту от 0 до 65535
выполняется путем помещения номера порта в регистр DX и
использования команды IN с регистром DX в качестве второго
параметра. Эти команды ввода/вывода могут быть несколько короче
при использовании ввода/вывода через 8-битовый порт в команде.
Старшие восемь битов адреса порта при использовании ввода/вывода
через 8-битовый порт будут равны 0.

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#GP(0), если текущий уровень привилегированности больше (т.е.
привилегированность меньше) уровня привилегированности
ввода/вывода (IOPL) или если любой из соответствующих битов
разрешения ввода/вывода в TSS равен 1.

Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если любой из соответствующих битов разрешения
ввода/вывода в TSS равен 1.

-----------------------------------------------------------------


INC - Инкремент на 1

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|FE /0     INC r/m8  1/3       Инкремент байта r/m на 1         |
|FF /0     INC r/m16 1/3       Инкремент слова r/m на 1         |
|FF /6     INC r/m32 1/3       Инкремент двойного слова r/m на 1|
|40 + rw   INC r16   1         Инкремент слова в регистре на 1  |
|40 + rd   INC r32   1         Инкремент двойного слова         |
|                              в регистре на 1                  |
-----------------------------------------------------------------

Работа команды
--------------

DEST <- DEST + 1;

Описание
--------

Команда DEC прибавляет 1 к операнду. Команда INC не изменяет
флага CF. Для воздействия на флаг CF используйте команду ADD с
непосредственным операндом, равным 1.

Изменяемые флаги
----------------

Флаги OF, SF, ZF, AF и PF устанавливаются в соответствии с
результатом.


Исключения защищенного режима
----------------------------------

#GP(0), если результат должен помещаться в сегмент, для которого
запрещена запись; #GP(0) в случае недопустимого исполнительного
адреса операнда памяти в сегментах CS, DS, ES, FS или GS; #SS(0)
в случае недопустимого адреса в сегменте SS; #PF(код сбоя) в
случае страничного сбоя; #AC для невыравненной ссылки к памяти
при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев; #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

-----------------------------------------------------------------

INS/INSB/INSW/INSD  - Ввод из порта в строку

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|6C      INS r/m8,DX  17,pm=10*/    Ввод байта из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INS r/m16,DX 17,pm=10*/    Ввод слова из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INS r/m32,DX 17,pm=10*/    Ввод двойного слова из      |
|                     32**,vm=30    порта DX в ES:(E)DI         |
|6C      INSB         17,pm=10*/    Ввод байта из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INSW         17,pm=10*/    Ввод слова из порта DX в    |
|                     32**,vm=30    ES:(E)DI                    |
|6D      INSD         17,pm=10*/    Ввод двойного слова из порта|
|                     32**,vm=30    DX в ES:(E)DI               |
-----------------------------------------------------------------

     Примечания: * если CPL <= IOPL
                ** если CPL >= IOPL

Работа команды
--------------

IF AddressSize = 16
THEN использование DI для индексации назначения;
ELSE (* AddressSize = 32 *)
     использование EDI для индексации назначения;
FI;
IF (PE = 1) AND ((VM = 1) OR (CPL > IOPL))
THEN (* Виртуальный режим 8086 или защищенный  режим  при  CPL  >
        IOPL *)
  IF NOT I-O-Permission(SRC, width(SRC))
  THEN #GP(0);
  FI;
FI;
IF команда байтового типа
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение байта  из  адресного
      пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 1 ELSE IncDec <- -1; FI;
FI;
IF AddressSize = 16
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение слова  из  адресного
      пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 2 ELSE IncDec <- -2; FI;
FI;
IF AddressSize = 32
THEN
  ES:[индекс-назначения] <- [DX];  (* Чтение двойного слова
      из  адресного пространства ввода/вывода согласно DX *)
  IF DF = 0 THEN IncDec <- 4 ELSE IncDec <- -4; FI;
FI;
индекс-назначения <- индекс-назначения + IncDec;



Описание
--------

Команда INS пересылает данные из заданного регистром DX порта
ввода в байт памяти или слово памяти по адресу
ES:индекс-назначения. Операнд памяти должен адресоваться
регистром ES; переопределение сегмента невозможно. Регистр
назначения - это регистр DI, если атрибут размера адреса команды
равен 16 битам, или регистр EDI, если атрибут размера адреса
равен 32 бита.

Команда INS не позволяет задавать номер порта непосредственным
значением. Порт должен адресоваться значением в регистре DX.
Перед выполнением команды INS в DX должно быть загружено
правильное значение.

Адрес назначения определяется содержимым регистра индекса
назначения. Перед выполнением команды INS в регистр индекса
назначения должно быть загружено правильное значение.

После выполнения пересылки регистр DI или EDI автоматически
получает соответствующее приращение. Если флаг DF равен 0 (была
выполнена команда CLD), то происходит инкремент регистров DI или
EDI; Если флаг DF равен 1 (была выполнена команда STD), то
происходит декремент регистров DI или EDI. Инкремент или
декремент регистров равен 1 при вводе байта, 2 при вводе слова и
4 при вводе двойного слова.

Команды INSB, INSW и INSD - это синонимы команды INS, работающие
с байтом, словом и двойным словом, соответственно. Команде INS
может предшествовать префикс REP для ввода блока, равного CX
байтов или слов. Эта операция описана для команды REP.

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#GP(0), если текущий уровень привилегированности численно больше
уровня привилегированности ввода/вывода (IOPL) или если любой из
соответствующих битов разрешения ввода/вывода в TSS равен 1. #GP
(0), если результат должен помещаться в сегмент, для которого
запрещена запись; #GP(0) в случае недопустимого исполнительного
адреса операнда памяти в сегментах CS, DS, ES, FS или GS; #SS(0)
в случае недопустимого адреса в сегменте SS; #PF(код сбоя) в
случае страничного сбоя; #AC для невыравненной ссылки к памяти
при текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если любой из соответствующих битов разрешения
ввода/вывода в TSS равен 1. #PF (код сбоя) для страничных сбоев;
#AC для невыравненной ссылки к памяти при текущем уровне
привилегированности, равном 3.

-----------------------------------------------------------------

CALL/INTO - Вызов процедуры прерывания

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|CC        INT 3       26        Прерывание 3 -                 |
|                                ловушка для отладчика          |
|CC        INT 3       44        Прерывание 3 -Защищенный режим,|
|                                та же привилегированность      |
|CC        INT 3       71        Прерывание 3 -Защищенный режим,|
|                                большая привилегированность    |
|CC        INT 3       82        Прерывание 3 - из режима V86, к|
|                                уровню прив-сти PL 0           |
|CC        INT 3       37+TS     Прерывание 3 -Защищенный режим,|
|                                через шлюз задачи              |
|CD ib     INT imm8    30        Прерывание, заданное непосред- |
|                                ственным байтом                |
|CD ib     INT imm8    44        Прерывание  - Защищенный режим,|
|                                та же привилегированность      |
|CD ib     INT imm8    71        Прерывание  - Защищенный режим,|
|                                большая привилегированность    |
|CD ib     INT imm8    86        Прерывание  -  из режима V86, к|
|                                уровню прив-сти PL 0           |
|CD ib     INT imm8    37+TS     Прерывание  - Защищенный режим,|
|                                через шлюз задачи              |
|CE        INTO     Успешно:28   Прерывание 4 - Если флаг пере- |
|                    Сбой  : 3   полнения равен 1               |
|CE        INTO        46        Прерывание 4 -Защищенный режим,|
|                                та же привилегированность      |
|CE        INTO        73        Прерывание 4 -Защищенный режим,|
|                                большая привилегированность    |
|CE        INTO        84        Прерывание 4 - из режима V86, к|
|                                уровню прив-сти PL 0           |
|CE        INTO        39+TS     Прерывание 4 -Защищенный режим,|
|                                через шлюз задачи              |
-----------------------------------------------------------------

Примечание: приближенные значения ts задаются следующей таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды
--------------

Примечание: Следующее операционное описание применимо не только
к вышеупомянутым командам, но и к внешним прерываниям и
исключениям.

IF PE = 0
THEN GOTO РЕЖИМ-РЕАЛЬНЫХ-АДРЕСОВ;
pELSE GOTO ЗАЩИЩЕННЫЙ РЕЖИМ;
FI;

РЕЖИМ-РЕАЛЬНЫХ_АДРЕСОВ:
  Push(FLAGS);
  IF <- 0; (* Очистить флаг прерывания *)
  TF <- 0; (* Очистить флаг ловушки *)
  Push(CS);
  Push(IP);
  (* Коды ошибки в стек не помещались *)
  CS <- IDT[Номер прерывания * 4].селектор;
  IP <- IDT[Номер прерывания * 4].смещение;

ЗАЩИЩЕННЫЙ-РЕЖИМ:
  Вектор прерывания должен быть в пределах границы таблицы IDT,
     иначе #GP(номер вектора * 8 + 2 + EXT);
  Байт дескриптора AR должен указывать на шлюз  прерывания,  шлюз
                                          ловушки или шлюз задачи,
     иначе #GP(номер вектора * 8 + 2 + EXT);
  IF программное  прерывание (* т.е.  вызванное INT n,  INT 3 или
                                          INTO *)
  THEN
    IF DPL дескриптора шлюза < CPL
    THEN #GP(номер вектора * 8 + 2 + EXT);
    FI;
  FI;
  Шлюз должен присутствовать,  иначе #NP(номер вектора * 8 + 2  +
                                          EXT);
  IF шлюз ловушки OR шлюз прерывания
  THEN GOTO ШЛЮЗ-ПРЕРЫВАНИЯ-ИЛИ-ШЛЮЗ-ПРЕРЫВАНИЯ;
  ELSE GOTO ШЛЮЗ-ЗАДАЧИ;
  FI;

ШЛЮЗ-ЛОВУШКИ-ИЛИ-ШЛЮЗ-ПРЕРЫВАНИЯ:
  Рассмотрим селектор  CS  и  дескриптор,  заданный в дескрипторе
                               шлюза;
  Селектор должен быть не-пустым, иначе #GP(EXT);
  Селектор должен быть в границах его дескрипторной таблицы
    ELSE #GP(селектор+EXT);
  Байт дескриптора AR должен указывать кодовый сегмент
    ELSE #GP(селектор+EXT);
  Сегмент должен присутствовать, иначе #NP(селектор+EXT);

  IF не-конформный кодовый сегмент AND DPL < CPL
  THEN GOTO ПРЕРЫВАНИЕ-НА-ВНУТРЕННЕЕ-КОЛЬЦО-ПРИВИЛЕГИРОВАННОСТИ;
  ELSE
    IF конформный кодовый сегмент AND DPL = CPL
    THEN GOTO ПРЕРЫВАНИЕ-НА-ТОТ-ЖЕ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ;
    ELSE #GP(селектор CS + EXT);
    FI;
  FI;

ПРЕРЫВАНИЕ-НА-ВНУТРЕННЕЕ-КОЛЬЦО-ПРИВИЛЕГИРОВАННОСТИ:
  Проверка селектора и дескриптора нового стека в текущем TSS;
    Селектор должен быть не-пустым, иначе #TS(EXT);
    Индекс селектора должен быть в границах дескрипторной таблицы
      ELSE #TS(селектор SS + EXT);
    RPL селектора должен быть равен DPL кодового сегмента
      ELSE #TS(селектор SS + EXT);
    RPL сегмента стека должен быть равен DPL кодового сегмента
      ELSE #TS(селектор SS + EXT);
    Дескриптор должен указывать на доступный для  записи  сегмент
            данных
      ELSE #TS(селектор SS + EXT);
    Сегмент должен присутствовать
      ELSE #SS(селектор SS + EXT);
  IF 32-битовый шлюз
  THEN новый стек должен иметь место для 20 байтов иначе #SS(0)
  ELSE новый стек должен иметь место для 10 байтов иначе #SS(0)
  FI;
  Указатель команд  должен  быть  в  границах  сегмента  CS иначе
                           #GP(0);
  Загрузка нового значения SS и eSP из TSS;
  IF 32-байтовый шлюз
  THEN CS:EIP <- селектор:смещение из шлюза;
  ELSE CS:IP <- селектор:смещение из шлюза;
  FI;
  Загрузка дескриптора CS в невидимую часть регистра CS;
  Загрузка дескриптора SS в невидимую часть регистра SS;
  IF 32-битовый шлюз
  THEN
    Push (дальний указатель на старый стек) (* 3 слова дополняются
                     заполнителями до 4 *);
    Push (EFLAGS);
    Push (дальний   указатель  на  адрес  возврата)  (*  3  слова
                     дополняются заполнителями до 4 *);
  ELSE
    Push (дальний указатель на старый стек) (* 2 слова *)
    Push (FLAGS);
    Push (дальний   указатель  на  адрес  возврата)  (* 2 слова *)

  FI;
  Установка CPL в значение DPL нового кодового сегмента;
  Установка RPL CS в значение CPL;
  IF шлюз   прерывания   THEN  IF  <-  0  (*  флаг  прерывания  0
               (запрещение)  *);  FI;
  TF <- 0;
  NT <- 0;


ПРЕРЫВАНИЕ-ИЗ-РЕЖИМА-V86:
  ВремEFlags <- EFLAGS;
  VM <- 0;
  TF <- 0;
  IF обслуживается через шлюз прерывания THEN IF <- 0;
  ВремSS <- SS;
  ВремESP <- ESP;
  SS <- TSS.SS0; (* изменение на стековый сегмент уровня 0 *)
  ESP <- TSS.ESP0; (* изменение на стековый сегмент уровня 0 *)
  Push(GS);  (* Дополняется до двух слов *)
  Push(FS);  (* Дополняется до двух слов *)
  Push(DS);  (* Дополняется до двух слов *)
  Push(ES);  (* Дополняется до двух слов *)
  GS <- 0;
  FS <- 0;
  DS <- 0;
  ES <- 0;
  Push(ВремSS);  (* Дополняется до двух слов *)
  Push(ВремESP);
  Push(ВремEflags);
  Push(CS);  (* Дополняется до двух слов *)
  Push(EIP);
  CS:EIP <- селектор:смещение из шлюза прерывания;
(* Начинается выполнение новой подпрограммы в защищенном режиме *)

ПРЕРЫВАНИЕ-НА-ТОТ-ЖЕ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ:
  IF 32-битовый шлюз
  THEN Границы  текущего  стека должны позволить поместить туда 10
        байтов, иначе #SS(0);
  ELSE Границы  текущего  стека должны позволить поместить туда 6
        байтов, иначе #SS(0);
  FI;
  IF прерывание было вызвано исключением с кодом ошибки
  THEN Границы  стека должны позволить поместить туда еще 2 байта;
  ELSE #SS(0);
  FI;
  Указатель команд должен находиться в границах CS, иначе #GP(0);
  IF 32-битовый шлюз
  THEN
    Push(EFLAGS);
    Push(дальний указатель  на  адрес  возврата);  (*  3   слова,
         дополненные до 4 слов  *)
    CS:IP <- селектор:смещение из шлюза;
  ELSE (* 16-битовый шлюз *)
    Push(FLAGS);
    Push(дальний указатель  на  адрес  возврата);  (*  2 слова *)
    CS:IP <- селектор:смещение из шлюза;
  FI;
  Загрузка дескриптора CS в невидимую часть регистра CS;
  Установка поля RPL CS равным CPL;
  Push(код ошибки); (* если он имеется *)
  IF шлюз прерывания THEN IF <- 0; FI;
  TF <- 0;
  NT <- 0;

ШЛЮЗ-ЗАДАЧИ:
  Рассмотрим селектор  CS, заданный в дескрипторе шлюза задачи;
    В бите   Локальный/Глобальный  должно  быть  задано  значение
               Глобальный, иначе #TS(селектор TSS);
    Индекс должен быть в границах GDT, иначе #TS(селектор TSS);
    Байт AR должен задавать доступный TSS (нижние биты 00001),
      иначе #TS(селектор TSS);
    TSS должен присутствовать, иначе #NP(селектор TSS);
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ со вложенностью в TSS;
  IF прерывание было вызвано сбоем с кодом ошибки
  THEN
    Границы стека должны позволить поместить туда еще 2 байта,
       иначе ##SS(0);
    Помещение в стек код ошибки;
  FI;
  Указатель команд должен быть в пределах CS, иначе #GP(0);


Описание
--------

Команда INT n программно генерирует вызов оработчика прерывания.
Непосредственный операнд, от 0 до 255, задает номер индекса в
таблице дескрипторов прерываний (IDT) для вызываемой
подпрограммы прерывания. В защищенном режиме IDT состоит из
массива восьми-байтовых дескрипторов; дескриптор для
активизированного прерывания должен обозначать шлюз прерывания,
ловушки или задачи. В режиме реальных адресов IDT представляет
собой массив из указателей длиной в четыре байта. В защищенном
режиме и режиме реальных адресов базовый линейный адрес IDT
определен содержимым IDTR.

Условная команда INTO идентична команде прерывания INT n, за
исключением того, что номер прерывания неявно устанавливается
равным 4, и прерывание происходит только при установленном флаге
переполнения процессора i486.

Первые 32 прерывания резервированы Intel для системных целей.
Некоторые из этих прерываний используются для внутренних
исключений.

Команда INT n в целом ведет себя как дальний вызов, за
исключением того, что флаговый регистр помещается в стек до
адреса возврата. Процедуры прерывания выполняют возврат
посредством команды IRET, которая извлекает из стека флаги и
адрес возврата.

В режиме реальных адресов команда INT n помещает в стек флаги,
регистр CS и IP для возврата в указанной последовательности и
затем выполняет переход к дальнему указателю, индексируемому
номером прерывания.


Изменяемые флаги
----------------

     Отсутствует

Исключения защищенного режима
----------------------------------

#GP, #NP, #SS и #TS, как указано выше в разделе "Работа
команды".


Исключения режима реальных адресов
---------------------------------------

Отсутствуют; если регистр SP или ESP равен 1, 3 или 5 перед
выполнением команды INT или INTO, то процессор переходит в режим
закрытия вследствие недостаточного размера стека.

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если IOPL меньше 3, только для команды INT n, что
позволяет эмуляцию; Прерывание 3 (0CCH) генерирует исключение
контрольной точки; команда INTO генерирует исключение
переполнения при установленном флаге OF.

-----------------------------------------------------------------

