
Глава 10  Инициализация
-----------------------------------------------------------------

Процессор i486 имеет входной штырек, называемый RESET, через
который запускается инициализация сброса системы. При подаче
сигнала на этот штырек некоторые регистры процессора i486
устанавливаются в заведомо известные состояния. Эти известные
состояния, например, состояние регистра EIP, позволяют начать
работу программного обеспечения процессора. Это программное
обеспечение может построить структуры данных в памяти, например,
таблицы GDT и IDT, используемые далее системным и прикладным
программным обеспечением.

Аппаратное обеспечение подает сигнал RESET при включении питания
системы. Аппаратно этот сигнал может быть подан и другими
способами. Например, возможно наличие специальной кнопки для
выполнения инициализации сброса вручную. Сброс может быть также
выполнен аппаратным обеспечением в ответ на получение сигнала о
вхождении в режим останова или закрытия системы.

После инициализации сброса регистр DH содержит число,
идентифицирующее тип процессора. Двоичный объектный код может
быть сделан совместимым с прочими процессорами Intel путем
использования этого числа для выбора правильного программного
обеспечения инициализации. Отметим, что процессор i486 имеет
несколько рабочих режимов. Он начинает работу в режиме,
эмулирующем процессор 8086, который называется режимом реальной
адресации. Если должен использоваться защищенный режим (режим, в
котором доступен набор 32-разрядных команд), то программное
обеспечение инициализации изменяет установку бита режима в
регистре CR0.

10.1  Состояние процессора после сброса
-----------------------------------------------------------------

При включении питания может быть запрошено автотестирование.
Запрос автотестирования выполняется через вход AHOLD по заднему
фронту сигнала RESET. Ответственность за запрос автотестирования
лежит на разработчике аппаратного обеспечения системы. При
выборе автотестирования оно занимает до 2**20 тактовых периодов.
(Intel оставляет за собой право изменять число тактовых периодов
автотестирования без предупреждения).

Если процессор i486 прошел тест нормально, то регистр EAX
очищается. Ненулевое значение регистра EAX после завершения
автотестирования указывает на неисправность процессора. Если
автотестирование не запрашивалось, содержимое регистра EAX после
инициализации сброса является неопределенным (возможно,
не-нулевым). Регистр DX после инициализации сброса содержит
идентификатор типа процессора и номер версии процессора, как
показано на Рисунке 10-1. Регистр DH содержит число 4,
идентифицирующее процессор i486. Регистр DL содержит уникальный
идентификатор номера версии.

Состояние регистра CR0 после включения питания показано на
Рисунке 10-2. Это состояние устанавливает процессор в режим
реальной адресации памяти с отключенным механизмом подкачки
страниц.

После включения питания состояния регистров EBX, ECX, ESI, EDI,
EBP, ESP, GDTR, LDTR, TR, отладочных регистров (кроме DR7) и
стека для операндов с плавающей точкой неопределены. Программное
обеспечение не должно зависеть от неопределенности каких-либо из
этих регистров. Состояния флагов и остальных регистров после
включения питания показаны в Таблице 10-1.


|<---------------------- Регистр EDX  ------------------------->|

                               |<------ Регистр DX ------------>|

31                           16 15           8 7
-----------------------------------------------------------------
|                              | Идентификатор |       Номер    |
|      Резервировано           |   устройства  |       версии   |
|                              |               |    процессора  |
-----------------------------------------------------------------

       Рисунок 10-1. Содержимое регистра EDX после сброса



   --------0 Разрешена    -------0 Контроль выравнивания отменен
  |          подкачка    |
  |          страниц     |     --0 Защита от записи отменена
  |   -----0 Разрешено   |    |
  |  |       кеширование |    |
  |  |   --0 Разрешена   |    |
  |  |  |    запись      |    |
 31 30 28               18   16                 5  4  3  2  1  0
-----------------------------------------------------------------
| P| C| N|             | A| | W|              | N| E| T| E| M| P|
|  |  |  |             |  | |  |              |  |  |  |  |  |  |
| G| D| W|             |  | | P|              | E| T| S| M| P| E|
-----------------------------------------------------------------
                                                |  |  |  |  |  |
                                                |  |  |  |  |  |
0 Внешнее сообщение об ошибке с плавающей точкой   |  |  |  |  |
                             0 (не используется)---   |  |  |  |
                       0 Нет переключения задачи -----   |  |  |
        0 Команда ESC не обнаруживается ловушкой---------   |  |
       0 Команда WAIT не обнаруживается ловушкой------------   |
                                0 Реальный режим---------------

       Рисунок 10-2. Содержимое регистра CR0 после сброса

Отметим, что невидимые части сегментных регистров CS и DS
инициализируются значениями, позволяющими начать выполнение,
несмотря на то, что эти сегменты не были определены. Базовый
адрес кодового сегмента устанавливается на 64К ниже вершины
физического адресного пространства, что позволяет записать в
оперативную память программное обеспечение инициализации.
Базовый адрес сегментов данных устанавливается в нижней части
физического адресного пространства (адрес 0), где начинается
оперативная память. Для предохранения этих адресов никакая
команда, загружающая сегментные регистры, не должна выполняться
до тех пор, пока не будет определена таблица дескрипторов, а ее
базовый адрес и граница загружены в регистр GDTR. Если в
реальном режиме произойдет перезагрузка CS, то этот регистр
будет указывать на младший мегабайт физической памяти.

10.2  Программная инициализация в режиме реальных адресов
-----------------------------------------------------------------

После инициализации сброса программное обеспечение устанавливает
структуры данных, необходимые процессору для выполнения базовых
системных функций, таких как обработка прерываний. Если
процессор остается в режиме реальных адресов, программное
обеспечение организует структуры данных в форме, используемой
процессором 8086. Если процессор должен работать в защищенном
режиме, то программное обеспечение организует структуры данных в
форме, используемой процессорами 80286 и i486, а затем
переключает режимы. См. Рисунок 10-7, где приводится пример.


   Таблица 10-1. Состояние процессора после включения питания

-----------------------------------------------------------------
   Регистр                          Состояние (шестнадцатиричное)
-----------------------------------------------------------------
   EFLAGS                           00000002H  1)
   EIP                              0000FFF0H
   CS                               0F000H  2)
   DS                               0000H   3)
   SS                               0000H
   ES                               0000H   3)
   FS                               0000H
   GS                               0000H
   IDTR (база)                      00000000H
   IDTR (граница)                   03FFH
   DR7                              0000H
-----------------------------------------------------------------
       Регистры модуля операций с плавающей точкой  4)
-----------------------------------------------------------------
   Слово управления                 037FH
   Слово состояния                  0000H
   Слово тега                       0FFFFH
   Смещение IP                      00000000H
   Смещение операнда данных         00000000H
   Селектор CS                      0000H
   Селектор операнда                0000H
   Код операции                     000H
-----------------------------------------------------------------

Примечание: Не определенные биты резервированы. Программное
обеспечение не должно зависеть от состояний каких-либо из этих
битов.

1. Старшие четырнадцать битов регистра EFLAGS после включения
   питания не определены. Все они очищаются.

2. Невидимая часть регистра CS содержит базовый адрес 0FFFF0000H
   и границу 0FFFFH.

3. Невидимые части регистров DS и ES содержит базовый адрес 0 и
   границу 0FFFFH.

4. Регистры модуля операций с плавающей точкой не
   инициализируется до запуска встроенного автотестирования.


10.2.1  Системные таблицы
-----------------------------------------------------------------

В режиме реальных адресов дескрипторные таблицы не используются.
Таблица векторов прерывания, начинающаяся с адреса 0, должна
быть загружена указателями на обработчики исключений и
прерываний, прежде чем эти прерывания могут быть разрешены.
Немаскируемые прерывания разрешены всегда. Если таблица векторов
прерывания и обработчик немаскируемых прерываний требуют
загрузки в оперативную память, то будет существовать некоторый
период времени после инициализации сброса, в течение которого
немаскируемое прерывание не может быть обработано.

10.2.2  Немаскируемые прерывания
-----------------------------------------------------------------

Аппаратное обеспечение реализует механизм, предотвращающий
генерацию немаскируемого прерывания в момент, когда программное
обеспечение не может его обработать. Например, таблица векторов
прерываний и обработчик немаскируемых прерываний может
находиться в ПЗУ. Это позволяет выполнять обработку
немаскируемых прерываний непосредственно после инициализации
сброса. Другое решение состоит в том, чтобы обеспечить механизм,
передающий сигнал немаскируемого прерывания через шлюз И,
управляемый битом в порте ввода/вывода. Аппаратное обеспечение
может очищать этот бит при сбросе процессора, а программное
обеспечение может устанавливать его, когда будет готово к
обработке немаскируемых прерываний. Разработчики системного
программного обеспечения должны знать механизм, используемый
аппаратным обеспечением для защиты программного обеспечения от
немаскируемых прерываний после сброса.

10.2.3  Первая команда
-----------------------------------------------------------------

Выполнение начинается командой, адресуемой исходным содержимым
регистров CS и IP. Чтобы разместить программное обеспечение
инициализации в ПЗУ в верхней части адресного пространства,
старшие 12 битов адресов, выдаваемых для кодового сегмента,
устанавливаются, пока не будет выполнена первая команда,
загружающая регистр CS, например дальний переход или вызов. В
результате выборка команд начинается с адреса 0FFFFFFF0H.
Поскольку размер ПЗУ неизвестен, то первая команда подразумевает
переход к началу программного обеспечения инициализации. Если
должен быть использован защищенный режим, а процессор все еще
находится в реальном режиме, то в пределах ПЗУ-резидентного
программного обеспечения должны выполняться только ближние
переходы. После выполнения дальнего перехода адреса, выданные к
кодовому сегменту, очищаются в 12 старших битов.

10.2.4  Разрешение кеширования
-----------------------------------------------------------------

Кеширование разрешается при очистке битов CD и NW в регистре
CR0. Такое состояние этих битов допускает циклы кеширования,
сквозной записи и аннулирования кеша. Поскольку все строки кеша
после инициализации сброса недостоверны, перед разрешением
кеширования очищать кеш не обязательно.

В ситуациях, когда строки кеша могут быть помечены как
достоверные, перед разрешением кеширования может понадобиться
разрешить кеширование. Это может быть в результате использования
тестовых регистров для выполнения шаблонного тестирования с
использованием кеш-памяти в качестве части тестов во время
программной инициализации.

10.3  Переключение на защищенный режим
-----------------------------------------------------------------

Перед переключением на защищенный режим должен быть создан
минимальный набор структур данных, а также должно быть
инициализировано минимальное количество регистров.

10.3.1  Системные таблицы
-----------------------------------------------------------------

Для того, чтобы программное обеспечение защищенного режима имело
доступ к программам и данным, должна быть создана как минимум
одна дескрипторная таблица, GDT, и два дескриптора. Дескрипторы
необходимы для кодового сегмента и сегмента данных. Стек может
быть помещен в обычном сегменте данных с доступом на
чтение/запись, и специального дескриптора для стека тогда не
требуется. Прежде чем GDT может быть использована, базовый адрес
и граница для GDT должны быть загружены в регистр GDTR при
помощи команды LGDT.

10.3.2  Немаскируемое прерывание
-----------------------------------------------------------------

Если аппаратное обеспечение позволяет генерацию немаскируемых
прерываний, требуется создание IDT и шлюз для обработчика
прерываний. Прежде чем IDT может быть использована, в регистр
IDTR при помощи команды LIDT должен быть загружен базовый адрес
и граница IDT.

10.3.3  Бит PE
-----------------------------------------------------------------

Вход в защищенный режим выполняется установкой бита PE в
регистре CR0. Для установки этого бита могут быть использованы
команды LMSW или MOV CR0 (регистр MSW является частью регистра
CR0). Поскольку интерпретации нескольких команд процессора i486
перекрываются, необходимо отменить команды, которые уже были
считаны процессором. Команда JMP непосредственно после команды
LMSW изменяет последовательность выполнения, что имеет тот же
эффект, что и очищение процессора от выбранных или
декодированных команд.

После входа в защищенный режим сегментные регистры сохраняют
содержимое, которое они имели в режиме реальных адресов.
Программное обеспечение должно перезагрузить все сегментные
регистры. Выполнение в защищенном режиме начинается при CPL
равном 0.

10.4  Программная инициализация в защищенном режиме
-----------------------------------------------------------------

Структуры данных, необходимые в защищенном режиме, определяются
используемыми свойствами организации памяти процессора.
Процессор поддерживает модели сегментации от модели с
единственным, равномерным адресным пространством (плоская
модель) до высокоструктурированной модели с несколькими
независимыми, защищенными адресными пространствами для каждой
задачи (многосегментная модель). Подкачка страниц может
позволить доступ к большим структурам данных, частично
находящимся в памяти, и частично на диске. Обе эти формы
трансляции адреса требуют структур данных, устанавливаемых
операционной системой и используемых аппаратным обеспечением,
отвечающим за организацию памяти.

10.4.1  Сегментация
-----------------------------------------------------------------

Плоская модель без подкачки страниц требует только GDT с одним
дескриптором кодового сегмента и одним дескриптором сегмента
данных. Плоская модель с подкачкой страниц требует дескрипторов
кода и данных для режима супервизора, и другой набор
дескрипторов кода и данных для режима пользователя. В дополнение
требуется каталог страниц и как минимум одна таблица страниц
второго уровня.

Многосегментная модель может потребовать дополнительных
сегментов для операционной системы, а также сегментов и таблиц
LDT для каждой прикладной программы. LDT требуют сегментных
дескрипторов в GDT. Большинство операционных систем, таких как
OS/2, распределяют новые сегменты и LDT по мере необходимости.
Это обеспечивает максимальную гибкость при обработке
динамической программной среды, например для инженерных рабочих
станций. Системы, такие как системы управления процессами, могут
предопределять фиксированное число сегментов и LDT для
фиксированного числа прикладных программ. Это простой и
эффективный способ структурирования программной среды системы,
требующей хорошего быстродействия в режиме реального времени.

10.4.2  Подкачка страниц
-----------------------------------------------------------------

В отличие от сегментации, подкачка страниц управляется битом
режима. Если бит PG в регистре CR0 очищен (это его состояние
после инициализации сброса), механизм подкачки страниц полностью
убирается из архитектуры системы, видимой программисту.

Если бит PG установлен, то подкачка разрешена. Этот бит может
быть установлен при помощи команды MOV CR0. Перед установкой
бита PG должны быть выполнены следующие условия:

- Программное обеспечение создало минимум две страничные
  таблицы, каталог страниц и как минимум одну страничную таблицу
  второго уровня.

- В регистр PDBR (то же, что и регистр CR3) загружен базовый
  адрес каталога страниц.

- Процессор находится в защищенном режиме (в режиме реальных
  адресов подкачка страниц не работает). Если все прочие
  ограничения выполнены, биты PG и PE могут быть установлены
  одновременно.

Как и для бита PE, за установкой бита PG должна немедленно
следовать команда JMP. Кроме того, код, устанавливающий бит PG,
должен находиться в странице с тем же физическим адресом, после
того, как подкачка страниц разрешена.

10.4.3  Задачи
-----------------------------------------------------------------

Если механизм мультизадачности не используется, то инициализация
регистра TR не обязательна.

Если механизм мультизадачности используется, должны быть созданы
TSS и дескриптор TSS для программного обеспечения инициализации.
Дескрипторы TSS не должны помечаться как Занятые при создании:
дескрипторы TSS должны быть помечены как Занятые только в
качестве побочного эффекта при выполнении переключения задачи.
Как и в случае дескрипторов для LDT, дескрипторы для TSS
располагаются в GDT. Команда LTR служит для загрузки селектора
для дескриптора TSS программного обеспечения инициализации в
регистр TR. Данная команда помечает дескриптор TSS как Занятый,
но не выполняет переключения задачи. Селектор должен быть
загружен до выполнения первого переключения задачи, поскольку
переключение задачи копирует состояние текущей задачи в TSS.
После использования команды LTR последующие команды с регистром
TR выполняются при переключении задач. Как и в случае сегментов
и LDT, TSS и дескрипторы TSS могут распределяться как заранее,
так и динамически по необходимости.

10.5  Тестирование TLB
-----------------------------------------------------------------

Процессор i486 обеспечивает механизм тестирования ассоциативного
буфера трансляции (TLB), кеша, используемого для трансляции
линейных адресов в физические. Хотя сбой в аппаратном
обеспечении TLB крайне маловероятно, пользователи могут пожелать
включить тесты TLB в число прочих тестов i486, выполняемых при
включении питания.

Примечание: данный механизм тестирования TLB уникален для
процессора i486 и в будущих версиях процессоров не может
остаться таким же. Программное обеспечение, использующее данный
механизм, может быть несовместимо с будущими процессорами.

10.5.1  Структура TLB
-----------------------------------------------------------------

TLB представляет собой четырех-канальную ассоциативную память.
Его структура показана на Рисунке 10-3. В блоке данных находится
восемь наборов по четыре элемента данных в каждом. Элемент
данных в TLB состоит из 20 битов старшего порядка физического
адреса. Эти 20 битов могут интерпретироваться как базовый адрес
страницы, который по определению имеет 12 очищенных битов
младшего порядка.

TLB транслирует линейный адрес в физический и работает только со
старшими 20 битами каждого из них; младшие 12 битов
(представляющие собой смещение в странице) одинаковы как для
линейного адреса, так и для физического.

Блоку элементов данных соответствует блок элементов
достоверности, аттрибутов и тега (признака). Элемент тега
состоит из 17 старших битов линейного адреса. При трансляции
адреса процессор использует биты 12, 13 и 14 линейного адреса
для выбора одного из восьми наборов, а затем проверяет четыре
тега из этого набора на соответствие старшим 17 битам линейного
адреса. Если соответствие найдено среди тегов выбранного набора,
а соответствующий бит достоверности равен 1, то линейный адрес
транслируется заменой старших 20 битов на 20 битов
соответствующего элемента данных.

     Блок достоверности,                          Блок
     аттрибута и тега                            данных
Блок
LRU  Канал0Канал1Канал2Канал3           Канал0Канал1Канал2Канал3
---  -------------------------          -------------------------
| |  |     |     |     |     |    Набор0|     |     |     |     |
|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| |  |     |     |     |     |    Набор1|     |     |     |     |
|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| |  |     |     |     |     |    Набор2|     |     |     |     |
|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| |  |     |     |     |     |    Набор3|     |     |     |     |
|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| |  |     |/////|     |     |<-->Набор4|     |/////|     |     |
|-|  |-----|-----|-----|-----|  |       |-----|-----|-----|-----|
| |  |     |     |     |     |  | Набор5|     |     |     |     |
|-|  |-----|-----|-----|-----|  |       |-----|-----|-----|-----|
| |  |     |     |     |     |  | Набор6|     |     |     |     |
|-|  |-----|-----|-----|-----|  |       |-----|-----|-----|-----|
| |  |     |     |     |     |  | Набор7|     |     |     |     |
---  -------------------------  |       -------------------------
                                |                   Соответствует
Соответствует заштрихованной     \                  заштрихованной
области выше на рисунке           \                 области выше
-------------------------------    --------------   -------------
|Достоверность|Аттрибут| Тег  |    |Выбор набора|   |  Данные   |
-------------------------------    --------------   -------------
    1 бит      3 бита   \ 17   \   |    3 бита  /     20 битов
                         \битов \  |           /    |           |
                          \31  15\/14      12 /      31       12
                           ------------------       -------------
                           |      |         |       |           |
                           ------------------       -------------
                             Линейный адрес           Физический
                                                         адрес

       LRU =  признак  наиболее  давнего  использования  для
              алгоритма "удаления стариков".

                  Рисунок 10-3.  Структура TLB

Каждому набору соответствует три бита LRU: они отслеживают
используемость данных в наборе и проверяются при необходимости в
новом элементе (а также следят за достоверностью всех элементов
в наборе). Используется алгоритм замены псевдо-LRU.

10.5.2  Тестовые регистры
-----------------------------------------------------------------

Для целей тестирования служат два тестовых регистра, которые
показаны на Рисунке 10-4. Регистр TR6 является командным
регистром тестирования TLB, а регистр TR7 является регистром
данных тестирования TLB. Доступ к ним выполняется посредством
разновидностей команды MOV. Команды MOV определены как в режиме
реальных адресов, так и в защищенном режиме. Тестовые регистры
относятся к привилегированным ресурсам системы: в защищенном
режиме команды MOV, используемые для доступа к ним, могут быть
выполнены только на уровне привилегированности 0 (наивысшая
привилегированность). Попытка чтения или записи в тестовые
регистры из других уровней привилегированности вызывает
исключение общей защиты.

В отличие от TLB процессора 386 DX, доступ к TLB процессора i486
возможен без отключения механизма подкачки страниц. Также, в
отличие от процессора 386 DX, TLB процессора i486 использует для
выбора элементов, которые будут удалены из памяти, когда нужно
распределить память для нового элемента, а TLB заполнен,
алгоритм замены кеша псевдо-LRU.

Командный регистр тестирования TLB (TR6) содержит  команду и
адресный тег:

- C. Это бит Команды (Command). Существует две команды
  тестирования TLB: записи элементов в TLB и выполнения поиска в
  TLB. Для выполнения записи в элемент TLB поместите двойное
  слово в регистр TR6, содержащий очищенный бит С. Для поиска
  (чтения) в TLB поместите двойное слово в регистр TR6,
  содержащий установленный бит С. Операции с TLB запускаются при
  выполнении записи в регистр TR6.

- Линейный адрес. При записи в TLB элемент TLB распределяется по
  данному линейному адресу; остальная часть элемента TLB
  назначается с использованием значения регистра TR7 и значения,
  только что записанного в регистр TR6. При поиске в TLB это
  значение используется в запросе; если обнаруживается
  соответствие одного и только одного элемента TLB, остальные
  поля регистров TR6 и TR7 устанавливаются из соответствующего
  элемента TLB.

                                1 1 1
     31                         2 1 0 9 8 7 6 5 4 3 2 1 0
     -----------------------------------------------------
     |                           |P|P|     |   | | R |   |
     |      Физический адрес     |C|W|L R U|0 0|P| E |0 0| TR7
     |                           |D|T|     |   |L| P |   |
     |---------------------------------------------------|
     |                           | | |D| |U| |W|       | |
     |      Линейный адрес       |V|D|#|U|#|W|#|0 0 0 0|C| TR6
     |                           | | | | | | | |       | |
     -----------------------------------------------------

               Рисунок 10-4. Тестовый регистр TLB

- V. Этот бит обозначает элемент TLB, содержащий достоверные
  (Valid) данные. Элементы TLB, не загруженные элементами
  страничной таблицы, имеют очищенный бит V. Все биты V
  очищаются при записи в регистр CR3, что имеет эффект очистки,
  или сброса, TLB. NLB должен очищаться после модификации
  страничных таблиц, поскольку в противном случае
  немодифицированные данные могут быть использованы для
  трансляции адреса.

- D, D#. Бит D (и его дополнение).

- U, U#. Бит U/S (пользователь/супервизор) (и его дополнение).

- W, W#. Бит R/W (чтение/запись) (и его дополнение).

  Эти биты даются как в их действительной форме, так и в виде
  дополнения для большей гибкости при поиске в TLB. Значение
  этих парных битов приводятся в Таблице 10-2.

Регистр данных тестирования TLB (TR7) содержит данные, считанные
или подлежащие записи в TLB:

- Физический адрес. Это поле данных TLB. При записи в TLB в это
  значение устанавливается элемент TLB, распределенный для
  линейного адреса в регистре TR6. При поиске (чтении) в TLB в
  данное поле загружается поле данных (физический адрес) из TLB.

- PCD. Соответствует биту PCD элемента страничной таблицы.

- PWT. Соответствует биту PWT элемента страничной таблицы.

- LRU. При чтении в TLB соответствует битам, используемым
  алгоритмом замены кеширования псевдо-LRU. Сообщаемые состояния
  представляют собой значение этих битов перед поиском в TLB.
  Значения битов могут изменяться при удачном завершении поиска
  и при записи в TLB.

- PL. При записи в TLB установленный бит PL заставляет
  использовать поле REP регистра TR7 для выбора одного из
  четырех ассоциативных блоков элемента TLB для загрузки. Если
  бит PL очищен, то для выбора блока служит внутренний указатель
  единицы подкачки. Этот внутренний указатель управляется
  алгоритмом замены кеширования псевдо-LRU. При поиске в TLB
  (при чтении) бит PL указывает на успешное чтение (бит PL
  установлен) или отсутствие искомого (бит PL очищен).

- REP. При записи в TLB выбирает, какой из четырех ассоциативных
  блоков TLB будет использован для записи. При чтении TLB при
  установленном бите PL REP сообщает, в каком из четырех
  ассоциативных блоков был найден тег; если же бит PL очищен, то
  содержимое этого поля неопределено.

       Таблица 10-2. Значение парных битов в регистре TR6

-----------------------------------------------------------------
Бит    Бит#     Эффект при поиске в TLB   Эффект при записи в TLB
-----------------------------------------------------------------
 0      0       Несовпадение                    Не определено
 0      1       Совпадение, если бит очищен     Очистка бита
 1      0       Совпадение, если бит установлен Установка бита
 1      1       Совпадение, если бит            Не определено
                очищен или установлен
-----------------------------------------------------------------

10.5.3  Операции тестирования
-----------------------------------------------------------------

Для записи элемента TLB:

1. Перешлите в регистр TR7 двойное слово, которое содержит
   желаемый физический адрес, а также значения PCD, PWT, PL и
   REP. При установленном значении PL поле REP выбирает
   ассоциативный блок, в который должен быть помещен элемент.
   Если бит PL очищен, то используется внутренний указатель.

2. Перешлите в регистр TR6 двойное слово, которое содержит
   соответствующий линейный адрес, а также значения битов V, D,
   U и W. Бит C должен быть очищен.

Не записывайте дублирующиеся теги: результат такого действия
неопределен.

Для просмотра (чтения) элемента TLB:

1. Перешлите в регистр TR6 двойное слово, которое содержит
   соответствующий линейный адрес и аттрибуты. Бит С должен быть
   установлен.

2. Прочитайте регистр TR7. Если бит PL регистра TR7 установлен,
   то остальная часть содержимого регистра сообщает о содержимом
   TLB. Если бит PL очищен, то остальная часть регистра TR7, за
   исключением битов LRU, неопределена.

В целях тестирования бит V работает как еще один адресный бит.
Бит V при запросе поиска всегда должен быть установлен, что
исключает совпадение поиска для неинициализированных тегов.
Поиск при очищенном бите V при наличии неинициализированных
тегов непредсказуем.

10.6  Тестирование кеша
-----------------------------------------------------------------

Процессор i486 обеспечивает механизм тестирования кеша,
используемого для команд и данных. Хотя отказ аппаратного
обеспечения кеширования крайне маловероятен, пользователи могут
включить тестирование исправности кеша в число тестов,
выполняемых автоматически при включении питания.

Примечание: Механизм тестирования кеша уникален для процессора
i486 и может не поддерживаться в точности следующими версиями
процессоров данной линии. Программное обеспечение, использующее
этот механизм, может оказаться несовместимым со следующими
процессорами данной линии.

При выполнении тестирования кеша само кеширование должно быть
отключено.

10.6.1  Структура кеша
-----------------------------------------------------------------

Кеш представляет собой четырехканальную ассоциативную по наборам
данных память. Это означает, что блок данных из заданной позиции
главной памяти может быть записан в любую из четырех позиций
кеша. Четырехканальная ассоциация - это компромисс между
скоростью поиска в кеше с прямым отображением и высоким
соотношением удачных нахождений при поиске в полностью
ассоциативном кеше. Это позволяет осуществлять быстрый поиск в
кеше для нахождения данных, обеспечивая при этом высокую
пропорцию нахождений данных в кеше.

Блок          Блок                               Блок
досто-        тега                               данных
верности/
LRU    Канал0Канал1Канал2Канал3           Канал0Канал1Канал2Канал3
-----  -------------------------          -------------------------
| | |  |     |     |     |     |    Набор0|     |     |     |     |
|-|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| | |  |     |     |     |     |    Набор1|     |     |     |     |
|-|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| | |  |     |     |     |     |    Набор2|     |     |     |     |
|-|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
| | |  |     |     |     |     |          |     |     |     |     |
| | |  |     |     |     |     |          |     |     |     |     |
| | |  |     |     |     |     |          |     |     |     |     |
| | |  |     |     |     |     |          |     |     |     |     |
| | |  |     |     |     |     |          |     |     |     |     |
|-|-|  |-----|-----|-----|-----|          |-----|-----|-----|-----|
|///|  |     |/////|     |     |<-->НаборN|     |/////|     |     |
|-|-|  |-----|-----|-----|-----|  |       |-----|-----|-----|-----|
| | |  |     |     |     |     |  |       |     |     |     |     |
| | |  |     |     |     |     |  |       |     |     |     |     |
| | |  |     |     |     |     |  |       |     |     |     |     |
| | |  |     |     |     |     |  |       |     |     |     |     |
| | |  |     |     |     |     |  |       |     |     |     |     |
|-|-|  |-----|-----|-----|-----|  |       |-----|-----|-----|-----|
| | |  |     |     |     |     |  | Набор |     |     |     |     |
|-|-|  |-----|-----|-----|-----|  |   126 |-----|-----|-----|-----|
| | |  |     |     |     |     |  | Набор |     |     |     |     |
-----  -------------------------  |   127 -------------------------
                                  |
                                  |
                                  |
-------------------  ------------ |               -----------------
|LRU|Достоверность|  |Тег-21 бит| |            -->|Данные-16 битов|
-------------------  ------------ |           |   -----------------
        ^                 ^      Индекс       |
        |                 |      равен N      |
        \/             Совпадение |        Выбирает байт
    X 1 X X               |       |           |
   Строка достоверна  31  \/  11  \/       4  | 0
                     -----------------------------
                     |Поле тега|Поле индекса|XXXX|
                     -----------------------------
                        Физический адрес

LRU =  признак  наиболее  давнего  использования  для  алогоритма
       "удаления стариков"

                  Рисунок 10-5. Структура кеша

Кеш состоит из трех блоков:

- Блок данных - содержит до 8Кбайт данных и команд. Блок данных
  делится на четыре массива, каждый из которых содержит 128
  строк кеша. Каждая строка кеша содержит данные из 16
  последовательно расположенных адресов памяти, начинающихся с
  адреса, кратного 16. каждому 7-разрядноиу индексу массивов
  блока данных соответствует четыре строки кеша, по одной из
  каждого массива. Четыре строки кеша с одинаковым индексом
  называются набором.

- Блок тега - содержит один 21-разрядный тег для каждой строки
  данных в кеше. Блок тега также, следовательно, делится на
  четыре массива, каждый из которых содержит 128 тегов. Тег
  состоит из старших 21 битов физического адреса данных,
  хранимых в соответствующей строке кеша.

- Блок достоверности и LRU ("признак наиболее давнего
  использования, учитываемый при поиске кандидата на удаление из
  кеша") - содержит одно 7-разрядное значение для каждого из 128
  наборов строк кеша. Четыре бита служат для того, чтобы
  пометить отдельно строки набора как достоверные или
  недостоверные. Остальные три бита отслеживают использование
  данных в наборе и проверяются при необходимости заполнения
  строки кеша (когда при этом ни одна из строк в кеше не
  является недостоверной). Как и для TLB, используется алгоритм
  замены кеша псевдо-LRU.

Адресация кеша выполняется путкм разделения старших 28 битов
физического адреса на две части. Из них 21 старший бит
представляет собой поле тега и используется для различения
кешированных данных от любой другой 16-битовой строки данных,
которая могла храниться в том же наборе. Следующие старшие 7
битов называются полем индекса и определяют набор, в котором
могут храниться данные.

10.6.2  Тестовые регистры
-----------------------------------------------------------------

Показанные на Рисунке 10-6 три тестовых регистра служат для
тестирования. Регистр TR3 является регистром данных тестирования
кеша, регистр TR4 является регистром состояния тестирования
кеша, а регистр TR5 является управляющим регистром тестирования
кеша. Доступ к этим регистрам выполняется разновидностями
команды MOV. Команды MOV определены как в режиме реальных
адресов, так и в защищенном режиме. Тестовые регистры являются
привилегированными ресурсами: в защищенном режиме команды MOV,
используемые для доступа к ним, должны выполняться на уровне
привилегированности 0 (наиболее высоком уровне
привилегированности). Любая попытка чтения или записи в тестовые
регистры с другого уровня дает исключение общей защиты.

Регистр данных тестирования кеша (TR3) содержит двойное слово,
записываемое в буфер заполнения кеша, или двойное слово,
считываемое из буфера чтения кеша. Каждый из буферов чтения и
записи имеет память для хранения четырех двойных слов, которые
передаются через данный регистр по одному за раз. Конкретное
двойное слово в любом из буферов адресуется при помощи
2-битового поля Выбора Элемента (биты 2 и 3) регистра TR5.


                                  2 1 0 9 8 7 6 5 4 3 2 1 0
------------------------------------------------------------
|                                    |  Выбор      | E | C |
|       Не используются              |  набора     | N | T | TR5
|                                    |             | T | L |
|----------------------------------------------------------|
|                                    | |     |Достове|Не ис|
|              Тег                   |V|LRU  |рность |польз| TR4
|                                    | |(RD) |(RD)   |уется|
|----------------------------------------------------------|
|                                                          |
|                        Данные                            | TR3
|                                                          |
------------------------------------------------------------

V (VALID)     Достоверность
CTL (CONTROL) Управление
ENT (ENTRY)   Элемент

     Рисунок 10-6. Регистры тестирования кеша

Регистр состояния тестирования кеша (TR4) содержит биты
Достоверности и LRU, а также тег:

- Достоверность (биты 3..6). При поиске в кеше это четыре бита
  Достоверности для набора, к которому выполнялся доступ.

- LRU (признак для "удаления стариков"). При поиске в кеше это
  три бита LRU для набора, к которому происходил доступ. При
  каждой записи эти биты игнорируются: биты LRU в кеше
  обновляются алгоритмом замены кеша псевдо-LRU.

- Достоверность (бит 10). Это бит Достоверности для конкретного
  элемента, к которомы происходил доступ. При поиске в кеше это
  копия одного из битов 3..6. При записи в кеш он является новым
  битом Достоверности для выбранного элемента и набора.

- Тег адреса. При записи в кеш это адрес, который становится
  тегом.

  Управляющий регистр тестирования кеша (TR5) содержит
  7-разрядное поле выбор набора , 2-разрядное поле выбора
  элемента и 2-разрядное поле Управления:

- Управление. Функции, закодированные этими битами, показаны в
  Таблице 10-3.

- Выбор элемента. При чтении или записи в кеш выбирает один из
  четырех элементов в наборе, адресуемом полем Выбора Набора;
  при записи в буфер заполнения кеша или чтении из буфера чтения
  кеша выбирает одно из четырех двойных слов в строке.

- Выбор Набора. Выбирает один из 128 наборов.

Запись в  TR5 с установленным битом 0 или 1 вызывает доступ к
кешу. TR5 не может быть прочитан.

10.6.3  Операции тестирования
-----------------------------------------------------------------

Перед тестированием кеша:

1. Отмените кеширование, установив для этого бит CD в регистре
   CR0.

Для записи в буфер заполнения кеша:

1. Загрузите регистр TR5 значением поля Выбора Элемента, которое
   адресует одно из четырех двойных слов в буфере заполнения
   кеша. Значение поля Управление должно быть равно 00
   (двоичному).

2. Загрузите регистр TR3 данными, подлежащими записи в буфер
   заполнения кеша. Запись в буфер запускается при загрузке
   данного регистра.

3. Повторите шаги 1 и 2 для каждого из трех остальных двойных
   слов в буфере заполнения кеша.


   Таблица 10-3. Кодировка битов Управления тестирования кеша

-----------------------------------------------------------------
Биты управления
Бит 1  Бит 0               Описание
-----------------------------------------------------------------
     00              Запись в буфер заполнения кеша или чтение из
                     буфера чтения кеша
     01              Выполнение записи в кеш
     10              Выполнение чтения из кеша
     11              Очистить кеш (пометить все элементы как
                     недостоверные)
-----------------------------------------------------------------

Для записи в кеш:

1. Загрузите буфер заполнения кеша, как было описано выше.

2. Загрузите регистр TR4 тегом (биты 11..31) и битом
   Достоверности (бит 10). Прочие биты регистра TR4 (биты 0..9)
   не влияют на запись в кеш.

3. Загрузите в регистр TR5 значения полей Управления, Выбора
   Элемента и Выбора Набора. Значение в поле Управления должно
   быть равно 01 (двоичное). Запись в кеш запускается при
   загрузке данного регистра.

Для чтения из кеша:

1. Загрузите в регистр TR5 значения полей Управления, Выбора
   Элемента и Выбора Набора. Значение поля Управления должно
   быть равно 10 (двоичное). Чтение из кеша запускается при
   загрузке данного регистра. Чтение из кеша загружает в регистр
   TR4 тег для считанного элемента, а также биты LRU и
   Достоверности для всего считанного набора. Считывание кеша
   загружает буфер чтения кеша 128 битами данных. Буфер может
   быть считан при помощи следующей процедуры:

Для чтения из буфера чтения кеша:

1. Загрузите регистр TR5 значениями полей Управления и Выбора
   Элемента. Значение Выбора элемента адресует одно из четырех
   двойных слов в буфере чтения кеша. Значение в поле Управления
   должно быть равно 00 (двоичное).

2. Прочитайте двойное слово из буфера чтения кеша, выгрузив для
   этого регистр TR3. Чтение из буфера запускается при выгрузке
   этого регистра.

3. Повторите шаги 1 и 2 для каждого из трех оставшихся двойных
   слов в буфере чтения кеша.

Для очистки кеша:

1 Загрузите в регистр TR5 значение поля Управления. Это значение
  должно быть равно 11 (двоичное). Ни одно из значений остальных
  полей в таком случае значения не имеет. Очистка буфера
  запускается при загрузке данного регистра. Все биты LRU и
  Достоверности очищаются.

10.7  Пример инициализации
-----------------------------------------------------------------

Следующие шаблоны программ обеспечиваются Intel для вашего
удобства при разработке программного обеспечения для процессора
i486:

; simpinit.asm
; Пример кода инициализации для простой плоской (линейной) модели
;
; ***************************************************************
;
; Версия 2.0
; Авторские права Intel Corp., 1988
; Данный  шаблон  должен  помочь  вам  при  разработке  прикладных/
; системных программных средств с использованием микропроцессоров
; семейства Intel i486 (TM) или Intel386(TM). Intel дает вам
; разрешение на любые   модификации   и   использование   данных
; шаблонов по необходимости.
;
;
; ***************************************************************
;
; Это  пример  кода  инициализации,  который  переводит процессоры
; i486, 386 DX, 386 SX или 376 в режим плоской модели адресации.
; Вся памяти рассматривается как простая линейная область RAM.
; Подпрограмм прерывания нет. Построитель создает алиас GDT и
; алиас IDT и помещает их по умолчанию в GDT[1] и GDT[2].
; После входа в защищенный режим данный код выполняет переход к
; подпрограмме начальных действий для прикладной программы на Си.
; Вы  можете  изменить  адрес  перехода  (команды  JMP)   на   ваш
; собственный код или сделать в вашем коде метку C_STARTUP.

NAME simpstart           ; имя объектного модуля
EXTERN c_startup:near    ; это метка перехода после init_code

pe_flag     equ 1        ; для установки бита PE
data_selc   equ 20H      ; смещение _phantom_data_ в GDT (GDT[4])
CODEMACRO   opprefx      ; макрос для изменения размера операнда
            db 66H       ; по умолчанию
EMDM

init_code   SEGMENT ER PUBLIC
; GDT_DESC это общее символическое имя,  на которое имеется ссылка
; в файле, создаваемом построителем. Определение LOCATION в разделе
; TABLE файла построителя указывает на данную метку; построитель
; хранит и базу, и границу для указанной таблицы в этой позиции
; оперативной памяти.

PUBLIC      gdt_desc
gdt_desc    dp ?
; START   это   метка,   указывающая  на  истинное  начало  нашего
; исполняемого кода. Управление самозагрузкой BOOTSTRAP заставляет
; построитель поместить в вектор сброса компонента короткий переход
; к названной метке (в данном случае, START).
PUBLIC      start
; Поскольку этот код инициализиует процессоры i486, 386 DX, 386 SX
; или 376 в защищенный режим,  то первые команды в START проверяют
; тип компонента.  Процессоры i486,  либо 386 DX или  386  SX  при
; сбросе в реальном режиме или режиме совместимости: бит PE очищен,
; а  бит  D  для  CS  не  установлен.  Команды  выполняются  в  их
; 16-битовой форме.  Процессор 376 при сбросе имеет установленный
; бит PE и бит D,  поэтому команды  выполняются  в  их  32-битовой
; форме.
    nop                   ; Команды NOP для инициализации процессо-
    nop                   ; ров i486 или 386 DS или SX
start:
    cld                   ; Очистить флаг направления
    smsw bx               ; Проверить тип процессора при сбросе
    test bl,1             ; для скорости использовать SMSW, а не
    inz pestart           ; MOV

; Загрузка GDTR в REALSTART или PESTART зависит от того, возвращает
; ли аппаратное обеспечение пользователя READY при попытке записи
; в ПЗУ
realstart:                ; Это процессор i486 или 386 DX или
    opprefx               ; 386 SX в 16-битовом реальном режиме,
    mov eax,offset gdt_desc  ; Для получения 32-битового адреса
                          ; указателя GDT используйте префикс
                          ; операнда
    opprefx               ; Для получения адреса относительно
    and eax,0ffffh        ; области сброса используйте префикс
                          ; операнда
    lgdtw cs:[eax]        ; Загрузка в GDTR 24 битов базы

    mov ax,bx             ; Копирование слова состояния машины
    or al,pe_flag         ; Установка бита PE
    lmsw ax               ; Загрузка слова состояния машины при
                          ; установленном бите PE
    jmp next              ; Очистка очереди выборки команд

pestart:                  ; Это процессор 376 в 32-битовом защищен-
                          ; ном режиме
mode
    mov eax,offset gdt_desc  ; Получение 32-битового адреса
                          ; указателя GDT
    and eax,0ffffh        ; Получение адреса относительно области
                          ; сброса
    lgdt cs:[eax]         ; Загрузка 32 битов базы в GDTR
next:
    xor eax,eax           ; Инициализация селекторов данных
    mov al,data_selc      ; GDT[4] это _phantom_data_
    mov ds,ax
    mov ss,ax
    mov es,ax
    mov fs,ax
    mov gs,ax
    test bl,1
    jnz pejump

    opprefx               ; Используйте префикс операнда для
pejump:                   ; перехода к процессору i486, либо
                          ; 386 DX или 386 SX
    jmp far ptr c_startup ; Первый дальний переход переводит A31-20
                          ; в низкое состояние
init_code ENDS

END


; cstart.asm
; Модуль ASM386/486 для инициализации стека и вызова прикладной
; программы на Си
;
; ***************************************************************
;
; Версия 2.0
; Авторские права Intel Corp., 1988
; Данный  шаблон  должен  помочь  вам  при  разработке  прикладных/
; системных программных средств с использованием микропроцессоров
; семейства Intel i486 (TM) или Intel386(TM). Intel дает вам
; разрешение на любые   модификации   и   использование   данных
; шаблонов по необходимости.
;
; ***************************************************************
;
;
NAME cstart              ; имя объектного модуля
EXTRN main:near          ; метка вызываемой прикладной Си-программы
PUBLIC c_startup         ; общее символическое имя, используемое в
                         ; коде инициализации процессора

stack STACKSEG 1024

data SEGMENT RW PUBLIC
data ENDS
code32 SEGMENT ER PUBLIC

c_startup:
   mov esp,stackstart stack  ; Инициализация указателя стека
   call main                 ; Вызов прикладной Си-программы
   hlt                       ; останов процессора

code32 ENDS

/* simple.c
Код прикладной программы C386/486(TM) для примера простой плоской
модели

***************************************************************

Версия 2.0
Авторские права Intel Corp., 1988
Данный шаблон   должен   помочь  вам  при  разработке  прикладных/
системных программных средств  с  использованием  микропроцессоров
семейства  Intel  i486  (TM)  или  Intel386(TM).  Intel  дает  вам
разрешение на любые модификации и использование данных шаблонов по
необходимости.

***************************************************************

*/
char message[]="Работает";

main ()
{
int array_count[10];
array_count[1] = 1;
array_count[2] = 2;
array_count[3] = 3;
array_count[4] = 4;
array_count[5] = 5;
array_count[6] = 6;
array_count[7] = 7;
array_count[8] = 8;
}
-- simple.bld
-- Файл построителя для ввода в BLD386/486 для создания примера
-- простой плоской модели
--
-- **************************************************************
--
-- Версия 2.0
-- Авторские права Intel Corp., 1988
-- Данный шаблон   должен   помочь  вам  при  разработке  прикладных/
-- системных программных средств  с  использованием  микропроцессоров
-- семейства  Intel  i486  (TM)  или  Intel386(TM).  Intel  дает  вам
-- разрешение на любые модификации и использование данных шаблонов по
-- необходимости.
--
-- **************************************************************
--
simple; -- идентификатор компонуемой задачи
SEGMENT
    *segments      (DPL = 0),  -- Дать всем сегментам пользователя
                               -- DPL равный 0
    _phantom_code_ (DPL = 0),  -- Эти два сегмента создаются
                               -- построителем при использовании
                               -- управляющего признака FLAT.
                               -- Их DPL по умолчанию равен 0.
                               -- Здесь они приводятся только
                               -- для справки
    init_code                  -- Помещение кода инициализации в
                               -- область сброса
                 (BASE = 0ffff0900H);

TABLE
          -- Создание GDT
    GDT                        -- GDT_DESC это общее символическое
                               -- имя в модуле инициализации
                               -- "simpstart"
         (LOCATION = gdt_desc, -- В буфер, начинающийся в GDT_DESC.
                               -- BLD386/486 помещает значения базы
                               -- и границы GDT. Буфер должен иметь
                               -- длину 6 байтов. База и граница
                               -- помещаются в этот буфер в виде
                               -- двух байтов границы плюс четыре
                               -- байта базы в формате, требуемом
                               -- для использования в команде GDT.
          BASE = 0ffff0100H
         ); -- конец GDT
TASK                           -- Задача инициализации эмулятора
    main_task                  -- *ICD(TM)-486 или ICE(TM)-386 или
                               -- ICE(TM)-376
         (BASE = 0ffff0200H,
          Data = data,         -- Указывает на сегмент,
                               -- обозначающий исх. значение DS
          CODE = main,         -- main это точка входа, которая
                               -- должна иметь идентификатор public
          STACKS = (stacks),   -- Идентификатор сегмента указывает
                               -- на сегмент стека. Устанавливает
                               -- исходное значение SS:ESP.
          NO INTENABLED        -- Отмена прерываний
);
TABLE
    ldt1 (NOT CREATED);        -- Построитель не помещает LDT в
                               -- объектный модуль, но ее
                               -- содержимое выводится в листинг
END

--
-- Примечание:  ICD-486  это  встроенный   отладчик   центрального
-- процессора i486. Этот продукт запланирован на четвертый квартал
-- 1989 года.
--


echo off
echo simple.bat
echo Пакетный файл DOS  для  генерации  самозагружающейся  простой
echo плоской модели
echo *************************************************************
echo *                                                           *
echo * Версия 2.0                                                *
echo * Авторские права Intel Corp., 1988                         *
echo * Данный шаблон   должен   помочь  вам  при  разработке     *
echo * прикладных/системных программных средств с использованием *
echo * микропроцессоров семейства Intel i486(TM) или Intel386(TM)*
echo * Intel  дает  вам разрешение на любые модификации и        *
echo * использование данных шаблонов по необходимости.           *
echo *                                                           *
echo *************************************************************
REM
REM Следующие два запуска ASM386/486 создадут объектные модули
REM "simpinit.obj"  и  "cstart.obj".  Вследствие  использования  в
REM файлах    привилегированных    команд     ассемблер     выдаст
REM предупреждения. Управляющая директива "debug" заставит ASM386/
REM 486 включить дополнительную информацию, полезную для символи-
REM ческой отладки. Файлы листинга называются "simpinit.lst" и
REM "cstart.lst"
echo *echo asm386 simpinit.asm debug mod486
asm386 simpinit.asm debug mod486
echo (1 предупреждение из-за использования привилегир. команд)
echo *
echo asm386 cstart.asm debug mod486
asm386 cstart.asm debugmod486
echo (1 предупреждение из-за использования привилегир. команд)
REM
REM Запуск C-386/486 создает объектный модуль "simple.obj".
REM Управляющие директивы "regallocate" заставляют компилятор
REM оптимизировать распределение памяти регистровым переменным.
REM Управляющая директива "code" вызывает помещение в  конце файла
REM листинга   псевдо-ассемблерного   текста   листинга.   "Debug"
REM указывает C-386/486 на необходимость включения дополнительной
REM информации, полезной при символической отладке. Файл листинга
REM называется "simple.lst".
echo *
echo c386 simple.c debug regallocate code mod486
c386 simple.c debug regallocate code mod486
REM
REM BND386/486  объединяет входные сегменты и разрешает ссылки
REM адресации символических имен. Директива управления "noload"
REM указывает построителю на необходимость создания компонуемого
REM (а не загрузочного) файла. Директива "debug" указывает на то,
REM что построитель не очищает отладочную информацию. "Object"
REM указывает на то, что выходной файл должен называться "simple.
REM bnd". Файл листинга называется "simple.mp1".
echo *
echo bnd386 simple.obj,simpinit.obj,cstart.obj noload debug object
(simple.bnd) mod486
bnd386 simple.obj,simpinit.obj,cstart.obj noload debug object
(simple.bnd) mod486
REM
REM Целью является абсолютный загружаемый файл (все адреса которого
REM фиксированы   в   памяти),  который  может  быть  загружен  во
REM встроенный аппаратный отладчик  ICD-486(TM)  или  ICE-386(TM),
REM либо встроенный эмулятор ICE-376(TM). BLD386/486 создает такой
REM абсолютный модуль, необходимые дескрипторные таблицы, а также
REM задачу для инициализации эмулятора. Управляющая директива
REM "buildfile"  идентифицирует  "simple.bld"  в  качестве   файла
REM построителя. Управляющая директива "bootstrap" идентифицирует
REM символическое имя "start" как метку команды, на которую должен
REM быть выполнен переход при выполнении перехода самозагрузки,
REM находящегося по адресу 0fffffff0H. Директива "flat" заставляет
REM построитель конфигурировать файл по плоской модели, когда все
REM коды находятся в сегменте _phantom_data_, "mod486" заставляет
REM построитель    выдавать   сообщения,   руководящие   созданием
REM объектного модуля для процессора i486(TM). "mod376" заставляет
REM построитель    выдавать   сообщения,   руководящие   созданием
REM объектного модуля для процессора 376(TM).  Вы  можете  удалить
REM обе   эти   директивы   для  создания  объектного  модуля  для
REM процессора 486(TM)DX. Файл листинга называется "simple.mp2".
REM Конечная система называется "simple".
echo *
echo bld386  simple.bnd  buildfile  (simple.bld) bootstrap (start)
echo flat mod486
bld386  simple.bnd  buildfile  (simple.bld) bootstrap (start) flat
mod486


