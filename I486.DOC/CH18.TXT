
Глава 18. Вычисления
----------------------------------------------------------------


18.1 Средства программирования
----------------------------------------------------------------

В этой главе дано описание вычислительных возможностей
процессора i486(TM) для программистов, работающих с языками
высокого уровня и на ассемблере ASM386/486.

Уровень детализации этой главы дает программистам понимание
основных навыков, которые могут быть использованы для
программирования вычислений, но эта информация не является
полной документацией по описанию всех возможностей процессора.
Полная документация поставляется с каждым программным продуктом.

18.2 Языки высокого уровня
----------------------------------------------------------------

Большое количество языков высокого уровня, которые по
необходимости автоматически используют множество вычислительных
команд, создано для процессоров фирмы Intel(R). Эти
языки включают C-386/486 и PL/M-386/486. Но многие
компиляторы языков высокого уровня поставляются независимыми
организациями, разрабатывающими программное обеспечение.

Каждый из языков высокого уровня имеет специальные числовые
библиотеки, позволяющие программам воспользоваться возможностями
модуля обработки операций с плавающей точкой. При
программировании численных операций в любом из этих языков для
использования этого модуля не нужны никакие программные
добавления.

Программисты, работающие на PL/M-386/486 и на ассемблере
ASM386/486, также могут использовать многие из
программ, содержащихся в библиотеке поддержки языка. Эти
библиотеки включают многие функции, поддерживаемые языками
высокого уровня, включая обработчики исключенций,
преобразователи кодов ASCII в числа с плавающей точкой, и более
сложное множество трансцендентных функций, чем то множество
числовых операций, которое поддерживает процессор i486.

18.1.2 Программы на языке Си
----------------------------------------------------------------

Программисты, работающие на языке Си, при использовании типов
данных double или float автоматически используют для
генерирования числовых операций i486 процессора компилятор языка
Си. Тип float соответствует обычному вещественному формату; тип
double соответствует вещественному формату двойной точности.
Команда #include <math.h> вызывает математические функции, такие
как sin, cos для получения величин типа double. Рисунок 18
иллюстрирует пример программы на Си, демонстрирующий
использование возможностей процессора i486.


┌───────────────────────────────────────────────────────────────┐
│                                                               │
│     /********************************************             │
│     *                                           *             │
│     *             Пример программы на Си        *             │
│     *                                           *             │
│     *********************************************/            │
│                                                               │
│   /** по необходимости подключить /usr/include/stdio.h  **/   │
│   /** для трансцендентных функций подключить math **/         │
│                                                               │
│   #include </usr/include/math.h>                              │
│   #define Pi 3.1415926535897943                               │
│                                                               │
│   main()                                                      │
│   {                                                           │
│     double       sin_result, cos_result;                      │
│     double       angle_deg = 0.0, angle_rad;                  │
│     int          i, no_of_trail = 4;                          │
│                                                               │
│           for ( i = 1; i <= no_of_trail; i++){                │
│                angle_rad = angle_deg * Pi / 180.0;            │
│                sin_result = sin (angle_rad);                  │
│                cos_result = cos(angle_result);                │
│     printf("синус %f градусов равен %f\n",angle_deg,          │
│             sin_result);                                      │
│     printf("косинус %f градусов равен %f\n",angle_deg,        │
│             cos_result);                                      │
│                angle_deg = angle_deg + 30.0;                  │
│               }                                               │
│      /**  так далее  **/                                      │
│   }                                                           │
│                                                               │
└───────────────────────────────────────────────────────────────┘

         Рисунок 18-1. Пример программы на языке Си-386/486.


18.1.3 PL/M-386/486
----------------------------------------------------------------

Программисты, работающие на языке PL/M-386/486, могут получить
доступ к очень полезному подмножеству возможностей
процессораi486. Тип данных REAL языка PL/M-386/486 соответствует
обычному вещественному формату (32 бита). Этот тип данных дает
диапазон чисел порядка 8.43 x 10**(-37) <= │X│ <= 3.38 x
10**(38) и имеет около семи значимых десятичных цифр. Такое
представление чисел отвечает многим применениям
микрокомпьютеров. Преимущество при использовании типа данных
REAL в том, что промежуточные результаты при вычисленииях
представляются компилятором языка PL/M-386/486 в расширенном
вещественном формате. Это означает, что полный диапазон
представления чисел и точности процессора используется для
промежуточных вычислений. Переполнение, отрицательное
переполнение, ошибки округления более вероятны во время
промежуточных вычислений, чем при получении конечного
результата. Представление промежуточных результатов в
вещественном формате с расширенной точностью уменьшает
вероятность переполнения, отрицательного переполнения и
исключает ошибки округления, как серьезные ошибки, до достижения
конца вычислений.

Компилятор генерирует команды по обработке чисел с плавающей
точкой для вычисления выражений, содержащих тип данных REAL в
виде переменных или констант. Это означает, что сложение,
вычитание, умножение, деление, сравнение и присваивание чисел
типа REAL осуществляется модулем обработки данных с плавающей
точкой. С другой стороны, выражения типа INTEGER вычисляются
модулем обработки целочисленных операций.

Пять встроенных процедур (Таблица 18-1) дают программисту,
работающему на языке PL/M-386/486 доступ к командам управления
модулем по обработке данных с плавающей точкой. Перед любой
арифметической операцией обычная программа на PL/M-386/486 будет
инициализировать модуль, используя процедуру INIT$REAL$MATH$
UNIT, а затем для настройки конфигурации установит режим
SET$REAL$MODE. Процедура SET$REAL$MODE загружает управляющее
слово модуля обработки данных с плавающей точкой, и его
16-разрядный параметр имеет формат, указанный для управляющеего
слова в Главе 14. Рекомендуемая величина этого параметра - 033H
(округление до ближайшего, точность 64 бита, блокировка
исключений устраняет ошибочные команды). Другие процедуры могут
использоваться по усмотрению программиста.

Если любая исключение не заблокировано, то обработчик
исключений должен иметь процедуру обработки в форме процедуры
прерывания, которая вызывается через вектор прерывания номер 16.
Обработчик может использовать процедуру GET$REAL$ERROR для
получения младшего байта слова состояния модуля обработки
операций с плавающей точкой и затем очистить флаги маски
исключения. Байт, возвращаемый процедурой GET $REAL $ERROR
cодержит флаги маски, которые могут быть проанализированы для
определения номера исключения.

Процедуры SAVE$REAL$STATUS и RESTORE$REAL$STATUS обеспечивают
многозадачный режим работы, в котором выполняемая задача,
использующая модуль обаботки операций с плавающей точкой, может
быть прервана другой задачей, также использующей модуль
обработки операций с плавающей точкой. Операционная система
отвечает за выполнение процедуры SAVE$REAL$STATUS перед
выполнением любой команды, которая может повлиять на модуль
обработки операций с плавающей точкой. Это процедуры INIT$REAL$
MATH$UNIT и SET$REAL$MODE, а также арифметические команды.
Процедура SAVE$REAL$STATUS сохраняет состояние модуля обработки
операций с плавающей точкой (регистры, статус, управляюще слово
и так далее) в стеке памяти. Процедура RESTORE$ REAL$STATUS
восстанавливает информацию о состоянии; прерванная задача может
вызвать эти процедуры для восстановления состояния модуля
обработки операций с плавающей точкой во время выполнения. Это
дает возможность прерванной задаче начать выполнение с того
места, когда задача была прервана.

    Тавблица 18-1.Встроенные процедуры языка PL/M-386/486

┌─────────────────────┬────────────┬────────────────────────────┐
│                     │  Команда   │                            │
│      Процедура      │ управления │          Описание          │
│                     │    FPU     │                            │
├─────────────────────┼────────────┼────────────────────────────┤
│ INIT$REAL$MATH$UNIT │   FINIT    │ Инициализирует FPU         │
│ STE$REAL$MODE       │   FLDSW    │ Устанавливает маски исклю- │
│                     │            │ чений,  точность  округле- │
│                     │            │ ния и управление бесконеч- │
│                     │            │ ностью                     │
│ GET$REAL$ERROR      │   FNSTSW   │ Сохраняет, а затем очищает │
│                     │   &FNCLEX  │ значение флагов            │
│ SAVE$REAL$STATUS    │   FNSAVE   │ Сохраняет состояние FPU    │
│ RESTORE$REAL$STATUS │   FRSTOR   │ Восстанавливает состояние  │
│                     │            │           FPU              │
└─────────────────────┴────────────┴────────────────────────────┘

18.1.4 Ассемблер ASM386/486
----------------------------------------------------------------

Ассемблер ASM386/486 дает программисту полный доступ ко всем
возможностям процессора.

18.1.4.1 Определение данных
----------------------------------------------------------------

Директивы ассемблера ASM386/486, указанные в таблице 18-2,
выделяют память для числовых переменных и констант. Как и другие
директивы по распределению памяти, ассемблер связывает тип с
любой переменной, определенной с помощью этих директив. Величина
типа измеряется в единицах памяти - байтах(10 для DT, 8 для DQ).
Ассемблер проверяет соответствие типа переменной, используемой в
команде, самой команде. Например, команда FIADD ALPHA будет
ошибочна, если тип переменной ALPHA имеет величину, не равную 2
или 4 байтам, так как целочисленное сложение определено только для
данных типа слово или короткое целое (двойное слово). Тип
операнда также сообщает ассемблеру какую машинную команду
выполнять: хотя для программиста существует только одна команда
FIADD, но для операндов различного типа требуются различные
машинные команды.

Иногда разумно использовать команду с операндом, тип которого не
объявлен. Например, если регистр BX содержит указатель на
переменную типа короткое целое, то программист может пожелать
определить команду FIADD [BX]. Это может быть достигнуто
информированием процессора о типе операнда в команде, то есть
FIADD DWORD PTR [BX]. Соответствующие преобразователи для других
рапределений памяти -  WORD PTR, QWORD PTR и TBYTE PTR.

Однако ассемблер не проверяет типы операндов, используемых в
командах управления процессором. Команда FRSTOR [BP]
подразумевает, что программист поместил в регистр BP указатель
на место (возможно в стеке), в котором заранее была сохранена
запись о состоянии процессора размером 94 байта.

Начальное значение для числовых констант может быть получено
несколькими способами. Двоичные целые константы могут быть
определены как битовые строки, десятичные целые, восьмеричные
целые или шестнадцатиричные строки. Упакованные десятичные
величины обычно записываются как десятичные целые, хотя
ассемблер будет принимать и обрабатывать и другие представления
целых. Вещественные величины могут записываться как обычные
вещественные десятичные числа (с десятичной точкой), как
десятичные числа в научной нотации или как шестнадцатиричные
строки. Использование шестнадцатиричных строк первоначально было
предназначено для определения специальных величин, таких как
бесконечности, NaNs и ненормализованные числа. Большинство
программистов найдут, что обычные и научные десятичные дают
простейший способ инициализации числовых констант. На
рисунке 18-2 дан пример, показывающий несколько способов
пррисвоения данным различных числовых типов одной и той же
начальной величины.

    Таблица 18-2. Директивы распределения памяти ASM386/486.
┌─────────────┬──────────────────────┬──────────────────────────┐
│  Директивы  │    Интерпретация     │       Типы данных        │
├─────────────┼──────────────────────┼──────────────────────────┤
│    DW       │  Определить слово    │ Целое слово              │
│    DD       │  Определить двойное  │ Короткое целое, короткое │
│             │     слово            │ вещественное             │
│    DQ       │  Определить слово    │ Длинное целое, длинное   │
│             │   длиной 4 байта     │ вещественное             │
│    DT       │  Определить 10 байтов│ Упакованное десятичное,  │
│             │                      │ временное вещественное   │
└─────────────┴──────────────────────┴──────────────────────────┘

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│  ; ПРИМЕР ОПРЕДЕЛЕНИЯ КОНСТАНТЫ -126                          │
│  ;                                                            │
│  ;EVEN           ; выравнение слов в памяти                   │
│  WORD-INTEGER     DW   111111111000010B ; битовая строка      │
│  SHORT_INTEGER    DD   0FFFFFF82H       ; шестнадцатиричная   │
│                                         ; константа должна    │
│                                         ; начинаться с цифры  │
│  LONG_INTEGER     DQ   -126             ; обычное десятичное  │
│  SINGLE_REAL      DD   -126.0           ; "научное"           │
│  DOUBLE_REAL      DD   -1.26E2          ; представление       │
│  PACKED_DECIMAL   DT   -126             ; обычное десятичное  │
│                                         ; целое               │
│  ;                                                            │
│  ; в следующем определении 'C005' означает знак и порядок,    │
│  ; '7E00..00' - мантисса, 'R' информирует ассемблер, что      │
│  ;   представленная строка вещественного типа                 │
│  ;                                                            │
│  EXTENDED_REAL     DT    0C0057E00000000000000R               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

       Рисунок 18-2. Пример числовых констант.

Следует заметить, что числовые переменные и константы, следующие
за директивой EVEN, дают уверенность, что операнды будут
представлены выравненными словами. Наилучшее представление
получается, когда данные преобразуются к двойным словам,
расположенным линейно. Все числовые типы данных занимают целое
число слов, так что если блоки переменных объявляются вместе и
перед декларативной частью указано слово EVEN, то память не
растрачивается попусту.

18.1.4.2 Структуры и записи
----------------------------------------------------------------

При программировании вычислений на языке ассемблера ASM386/486
записи RECORD и структуры STRUC могут быть очень полезны. Записи
могут использоваться для определения битовых полей
управляющеющих слов, состояния, признака. На рисунке 18-3
показано одно определение слова состояния и как можно его
использовать в программе, которая опрашивает устройство
обработки операций с плавающей точкой до тех пор, пока не
завершилось выполнение команды.

Так как структуры объединяют различные, но связанные типы данных,
они позволяют получать данные, имитирующие  "реальный мир". То
что структура временно может быть передвинута в памяти,
добавляет ей гибкости. На Рисунке 18-4 дан пример простой
структуры, которая должна быть использована для представления
данных. По необходимости этот пример структуры может быть
реорганизован в целях безопасности и более эффективного
выполнения. Если два двойных вещественных поля были определены
до целочисленных полей, тогда (поддерживая тот факт, что
структура заменяется только адресами, делящимися на 8) все поля
будут оптимально выравнены в памяти для обеспечения
эффективного доступа и кеширования. Структуры также могут
использоваться для определения информации, сохраняемой и
получаемой с помощью команд FSTENV и FLDENV.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│      ; резервирование памяти для слова состояния              │
│      ; STATUS-WORD                                            │
│      ; расположение полей слова состояния                     │
│      STATUS RECORD                                            │
│      &     BUSY :              1,                             │
│      &     COND_CODE3 :        1,                             │
│      &     STACK_TOP :         3,                             │
│      &     COND_CODE2 :        1,                             │
│      &     COND_CODE1 :        1,                             │
│      &     COND_CODE0 :        1,                             │
│      &     INT_REG :           1,                             │
│      &     S_FLAG  :           1,                             │
│      &     P_FLAG  :           1,                             │
│      &     U_FLAG  :           1,                             │
│      &     O_FLAG  :           1,                             │
│      &     Z_FLAG  :           1,                             │
│      &     D_FLAG  :           1,                             │
│      &     I_FLAG  :           1                              │
│      ;                                                        │
│      REDUCE :  FPREM1                                         │
│                FNSTSW   STATUS_WORD                           │
│                TEST     STATUS_WORD, MASK_COND_CODE2          │
│                JNZ      REDUCE                                │
│                                                               │
└───────────────────────────────────────────────────────────────┘

        Рисунок 18-3.Определение записи слова состояния.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│       SAMPLE       STRUC                                      │
│           N_OBS     DD    ?     ;                             │
│           MEAN      DQ    ?     ;                             │
│           MODE      DW    ?     ;                             │
│           STD_DEV   DQ    ?     ;                             │
│           ;                                                   │
│           TEST_SCORES    DW   1000  DUP (?)                   │
│        SAMPLE       ENDS                                      │
│                                                               │
└───────────────────────────────────────────────────────────────┘

              Рисунок 18-4. Определение структуры


18.1.4.3 Методы адресации
----------------------------------------------------------------

Доступ к числовым данным в памяти может быть получен с помощью
методов адресации через байты ModR/M и SIB (необязательно). Это
означает, что числовые типы данных могут быть объединены в
совокупности данных, изменяющиеся от простых к сложным в
соответствии с необходимостью применения. Методы адресации и
нотация ассемблера ASM386/486, используемая для определения
методов в командах, обеспечивают прямой и последовательный
доступ к структурам, массивам, массивам структур и другим
организациям данных. В таблице 18-3 даны несколько примеров
числовых команд вместе с операндами, иллюстрирующие различные
методы адресации.

            Таблица 18-3. Примеры методов адресации

┌────────────────────────────┬───────────────────────────────────┐
│         Код                │         Интерпретация             │
├────────────────────────────┼───────────────────────────────────┤
│  FIADD ALPHA               │ ALPHA - простой скаляр (прямой    │
│                            │ доступ)                           │
│  FDIVR ALPHA, BETA         │ BETA - поле в структуре, которое  │
│                            │ перекрывается с ALPHA ( прямой    │
│                            │ доступ )                          │
│  FMUL QWORD PTR [BX]       │ BX содержит адреса длинных вещест-│
│                            │ венных переменных (косвенная адре-│
│                            │ сация по регистру)                │
│  FSUB ALPHA [SI]           │ ALPHA - массив, SI содержит смеще-│
│                            │ ние относительно начала массива   │
│                            │ (индексный метод доступа)         │
│  FILD [BP], BETA           │ BP содержит адрес структуры в сте-│
│                            │ ке ЦПУ, BETA - поле в структуре   │
│                            │ (базированный метод доступа)      │
│  FBLD TBYTE PTR [BX] [DI]  │ BX содержит адрес упакованного де-│
│                            │ сятичного массива, DI - смещение  │
│                            │ элемента массива (индексный метод │
│                            │ доступа)                          │
└────────────────────────────┴───────────────────────────────────┘

18.1.5 Пример сравнительного программирования
----------------------------------------------------------------

На рисунках 18-5 и 18-6 даны примеры простой числовой программы
ARRSUM на языках ассемблера ASM386/486 и PL/M386/486. В программе
рассматривается массив X$ARRAY, содержащий простые вещественные
величины от 0 до 100; целая переменная N$OF$X указывает
размерность массива. Вычисляются три суммы:

- SUM$X, сумма элементов массива

- SUM$INDEXES, сумма каждого элемента, умноженного на его
  индекс, где первый элемент массива имеет индекс 1, второй - 2 и
  так далее

- SUM$SQUARES, сумма квадратов элементов массива

(Настоящая программа, конечно, кроме этих шагов должна сохранять
и использовать результаты вычислений.) Управляющеему слову
присваивается одна из величин: округление до ближайшего целого,
64-разрядная точность, запрещение прерываний и блокировка всех
исключений, кроме недопустимых операций. Предполагается, что
обработчик исключений был написан с учетом недопустимой
операции, и в случае их обнаружения они обрабатывается по
прерыванию 16.

Версия ARRSUM на языке PL/M-386/486 очень последовательна и
иллюстрирует насколько легко в языке могут быть использованы
числовые возможности процессора i486. После объявления
переменных программа вызывает встроенные процедуры для
инициализации модуля обработки операций с плавающей точкой и
загрузки управляющего слова. Программа "очищает" пременные суммы
и затем выполняет шаги цикла DO. Управление циклом принимает в
расчет, что обычно в языке PL/M-386/486 индекс первого элемента
массива имеет величину 0. При вычислении SUM$INDEXES встроенная
процедура FLOAT преобразует величину I+1 от целого типа к
вещественному, так как язык не поддерживает "смешанного"
арифметического режима. Один из недостатков модуля обработки
операций с плавающей точкой процессора i486, что он не
поддерживает вычисления над смешанными типами данных (все
величины преобразуются к 80-битовому вещественному формату
расширенной точности)

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│       /**************************************************     │
│        *                                                *     │
│        *         МОДУЛЬ СУММА_МАССИВА                   *     │
│        *                                                *     │
│        **************************************************/    │
│                                                               │
│        array$sum:       do;                                   │
│                                                               │
│            declare (sum$x, sum$indexes, sum$squares) real;    │
│            declare x$array(100) real;                         │
│            declare (n$of$x, i) integer;                       │
│            declare control $ FPU literally '033eh';           │
│                                                               │
│            /* Инициализация массива x$array и n$of$x */       │
│            call init$real$math$unit;                          │
│            call set$real$mode(control $ FPU);                 │
│                                                               │
│            /* Очистить суммы */                               │
│            sum$x, sum$indexes, sum$squares = 0.0;             │
│                                                               │
│            /* Цикл по массиву с подсчетом сумм */             │
│            do i = 0 to n$of$x - 1;                            │
│                 sum$x = sum$x + x$array(i);                   │
│                 sum$indexes = sum$indexes + (x$array(i)*      │
│                 float(i+1));                                  │
│                 sum$squares = sum$squares + (x$array(i)*      │
│                 x$array(i));                                  │
│            end;                                               │
│                                                               │
│            /* и так далее */                                  │
│                                                               │
│      end array$sum;                                           │
│                                                               │
└───────────────────────────────────────────────────────────────┘

      Рисунок 18-5. Пример программы на языке PL/M-386/486

Версия программы на ассемблере ASM386/486 (Рисунок 18-6)
определяет внешнюю процедуру INITFPU, которая производит
инициализацию процессора и его эмулятора независимо от текста
исходной программы. После определения данных, настройки
сегментных регистров и указателя стека программа вызывает
процедуру INITFPU и загружает управляющее слово. Вычисления
начинаются со следующих трех команд, которые очищают три
регистра загрузкой 0 в стек. Как показано на Р1исунке 18-7 эти
регистры сохраняют значение вершины стека во время вычислений,
когда временные величины помещаются и удаляются из стека.

Для управления итерацией по массиву XARRAY программа использует
цикл LOOP; в регистр EСX, содержимое которого LOOP автоматически
уменьшает, помещается переменная N_OF_X, число суммируемых
элементов массива. Регистр ESI используется для выборки
(индексирования) элементов массива. Программа выполняется по
массиву с конца к началу, так что регистр ESI инициализируется
указателем на элемент, который должен обрабатываться. Оператор
TYPE используется для определения числа байтов в каждом элементе
массива. Такое представление позволяет изменить тип массива на
вещественный двойной точности простым измененим определения (DD
на DQ) и еще одним проходом ассемблера.

   Рисунок 18-6 Пример программы на языке ассемблер ASM386/486

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│           name         arraysum                               │
│                                                               │
│           ; Определить процедуру инициализации                │
│                                                               │
│           extrn        initFPU:far                            │
│                                                               │
│           ; Выделить память под данные                        │
│                                                               │
│           data         segment  rw  public                    │
│           control_FPU           dw  033eh                     │
│           n_of_x                dd  ?                         │
│           x_array               dd  100 dup (?)               │
│                                                               │
│           sum_squares           dd  ?                         │
│           sum_indexes           dd  ?                         │
│           sum_x                 dd  ?                         │
│           data         ends                                   │
│                                                               │
│           ; Выделить память под стек ЦПУ                      │
│                                                               │
│           stack        stackseg     400                       │
│                                                               │
│           ; Начало тела программы                             │
│                                                               │
│           code         segment  er  public                    │
│                                                               │
│           assume  ds:data, ss:stack                           │
│                                                               │
│           start:                                              │
│               mov      ax, data                               │
│               mov      ds, ax                                 │
│               mov      ax, stack                              │
│               mov      eax, ax                                │
│               mov      esp, stackstart stack                  │
│                                                               │
│           ; Проинициализироавали массив x_array и             │
│           ; переменную n_of_x                                 │
│                                                               │
│           ; Подготовить модуль обработки операций             │
│           ; с плавающей точкой или его эмулятор               │
│                                                               │
│               call     initFPU                                │
│               fldsw    control_FPU                            │
│                                                               │
│           ; Очистить три регистра для хранения                │
│           ; результатов суммирования                          │
│                                                               │
│               fldz                                            │
│               fldz                                            │
│               fldz                                            │
│                                                               │
│                                                               │
│           ; Установить ECX как счетчик цикла и                │
│           ; ES как индекс массива x_array                     │
│                                                               │
│               mov      ecx, n_of_x                            │
│               imul     ecx                                    │
│               mov      esi, eax                               │
│                                                               │
│           ; ESI содержит индекс последнего элемента           │
│           ; массива плюс 1                                    │
│           ; Цикл по массиву с подсчетом суммы                 │
│                                                               │
│           sum_next:                                           │
│           ; возвращение на один элемент назад                 │
│           ; и помещение в стек                                │
│                                                               │
│               sub      esi, type x_array                      │
│               fld      x_array[esi]                           │
│                                                               │
│           ; прибавление к сумме и копирование x               │
│           ; в стек                                            │
│                                                               │
│               fadd     st(3), st                              │
│               fld      st                                     │
│                                                               │
│           ; возведение в квадрат и сложение с суммой          │
│           ; (index+1)                                         │
│                                                               │
│               fmul     st, st                                 │
│               faddp    st(2), st                              │
│                                                               │
│           ; уменьшение индекса для следующей итерации         │
│                                                               │
│               dec      n_of_x                                 │
│               loop     sum_next                               │
│                                                               │
│           ; Перемещение x в память                            │
│                                                               │
│           pop_results:                                        │
│                fstp    sum_squares                            │
│                fstp    sum_indexes                            │
│                fstp    sum_x                                  │
│                fwait                                          │
│                                                               │
│           ;                                                   │
│           ; И так далее.                                      │
│           ;                                                   │
│           code         ends                                   │
│           end    start, ds:data, ss:stack                     │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘


┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                                                               │
│ FLDZ, FLDZ,FLDZ                   FLD X_ARRAY[SI]             │
│       ┌────────┐----------------------┌────────┐             │
│ ST(0) │  0.0   │ SUM_SQUARES     ST(0) │  2.5   │ X_ARRAY     │
│       ├────────┤                       ├────────┤             │
│ ST(1) │  0.0   │ SUM_INDEXES     ST(1) │        │ SUM_SQUARES │
│       ├────────┤                       ├────────┤             │
│ ST(2) │  0.0   │ SUM_X           ST(2) │  0.0   │ SUM_INDEXES │
│       └────────┘                       ├────────┤             │
│                                  ST(3) │  0.0   │ SUM_X       │
│                                        └────────┘             │
│           _________________________________|                  │
│                                                              │
│  FIADD ST(3), ST                             FLD ST           │
│       ┌────────┐----------------------┌────────┐             │
│ ST(0) │  2.5   │ X_ARRAY(19)     ST(0) │  2.5   │ X_ARRAY(19) │
│       ├────────┤                       ├────────┤             │
│ ST(1) │  0.0   │ SUM_SQUARES     ST(1) │  2.5   │ X_ARRAY(19) │
│       ├────────┤                       ├────────┤             │
│ ST(2) │  0.0   │ SUM_INDEXES     ST(2) │  0.0   │ SUM_SQUARES │
│       ├────────┤                       ├────────┤             │
│ ST(3) │  2.5   │ SUM_X           ST(3) │  0.0   │ SUM_INDEXES │
│       └────────┘                       ├────────┤             │
│                                  ST(4) │  2.5   │ SUM_X       │
│                                        └────────┘             │
│           _________________________________|                  │
│                                                              │
│      FMUL ST, ST                  FADDP ST(2), ST             │
│       ┌────────┐----------------------┌────────┐             │
│ ST(0) │  6.25  │ X_ARRAY(19)(2)  ST(0) │  2.5   │ X_ARRAY(19) │
│       ├────────┤                       ├────────┤             │
│ ST(1) │  2.5   │ X_ARRAY(19)     ST(1) │  6.25  │ SUM_SQUARES │
│       ├────────┤                       ├────────┤             │
│ ST(2) │  0.0   │ SUM_SQUARES     ST(2) │  0.0   │ SUM_INDEXES │
│       ├────────┤                       ├────────┤             │
│ ST(3) │  0.0   │ SUM_INDEXES     ST(3) │  2.5   │ SUM_X       │
│       ├────────┤                       └────────┘             │
│ ST(4) │  2.5   │ SUM_X                     |                  │
│       └────────┘                           |                  │
│           _________________________________|                  │
│                                                              │
│     FIMUL N_of_X                  FADDP ST(2), ST             │
│       ┌────────┐----------------------┌────────┐             │
│ ST(0) │  50.0  │ X_ARRAY(19)     ST(0) │  6.25  │ SUM_SQUARES │
│       ├────────┤                       ├────────┤             │
│ ST(1) │  6.25  │ SUM_SQUARES     ST(1) │  50.0  │ SUM_INDEXES │
│       ├────────┤                       ├────────┤             │
│ ST(2) │  0.0   │ SUM_INDEXES     ST(2) │  2.5   │ SUM_X       │
│       ├────────┤                       └────────┘             │
│ ST(3) │  2.5   │ SUM_X                                        │
│       └────────┘                                              │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

            Рисунок 18-7 Команды и регистровый стек

На Рисунке 18-7 показано содержимое регистрового стека
модуля обработки операций с плавающей точкой во время выполнения
команд в цикле программы. Предполагается, что программа
находится в ее первой итерации, величина переменной N_OF_X равна
20, и 20-й элемент массива XARRAY(19) имеет величину 2.5. По
окончании цикла суммы извлекаются из вершины стека, и программа
заканчивается простым перемещением сумм в переменные памяти.

18.2 Параллельная обработка
----------------------------------------------------------------

Так как модуль обработки целочисленных операций и модуль
обработки операций с плавающей точкой являются независимыми
устройствами, то возможно выполнение математических команд
модулем обработки операций с плавающей точкой параллельно с
работой модуля обработки целочисленных операций. Такое
одновременное выполнение различных команд называется
параллельностью.

Нет специальных приемов программирования, необходимых для
параллельного выполнения: команды модулю обработки операций с
плавающей точкой просто размещаются в той же строке, что и
команды модулю обработки целочисленных операций. Целочисленные и
вещественные команды инициализируются в том же порядке, как они
встречаются в потоке команд. Однако в силу того, что
вещественные операции, выполняемые модулем обработки операций с
плавающей точкой, в общем требуют больше времени, чем
целочисленные операции, то модуль обработки целочисленных
операций часто может выполнить несколько своих команд до того,
как модуль обработки операций с плавающей точкой завершит
начатую вещественную команду.

Параллельность часто предполагает очевидные преимущества во
время выполнения, однако также налагает определенные правила,
которые должны быть соблюдены для достижения синхронизации работы
модуля обработки операций с плавающей точкой и модуля обработки
целочисленных операций.

Все языки высокого уровня, ориентируемые на процессоры фирмы
Intel, автоматически имеют и управляют параллельностью модуля
обработки операций с плавающей точкой. Программисты, работающие
на ассемблере, однако должны понимать и управлять некоторыми
областями параллельности для достижение гибкости и эффективности
программ. Эта глава для программистов, работающих на ассемблере,
или программистов-профессионалов, пишущих программы на языках
высокого уровня.

18.2.1 Управление параллельностью
----------------------------------------------------------------

Обработка вычислительных программ может быть разбита на две
части: управление программой и арифметика. Часть по управлению
программой выполняет такие действия как решение - какие функции
выполнять, вычисление адресов числовых операндов и управление
циклом. Арифметическая часть просто выполняет сложение,
вычитание, умножение и другие операции над числовыми операндами.
Процессор i486 предназначен для обработки этих частей раздельно
и эффективно.

Управление параллельностью требует проверки на исключение перед
разрешением процессору изменить значение, только что
используемое модулем обработки операций с плавающей точкой.
Почти все числовые команды могут в случае запрещенной операции
создать числовое исключение. Для программистов, работающих на
языках высокого уровня, вся требуемая синхронизация
автоматически выполняется соответствующим компилятором. Для
работающих на ассемблере синхронизация исключений остается на
совести программиста.

Сложность в том, что программист может не ожидать, что его
вычислительная программа может вызывать исключения, но в
некоторых системах они могут регулярно случаться. Для лучшего
понимания таких недоразумений рассмотрим, что может случиться,
когда модуль обработки операций с плавающей точкой обнаружит
исключение.

В зависимости от операций, определенных проектировщиком
программного обеспечения, в случае исключения процессор i486
может выполнить одну из следующих совокупностей действий:

* Модуль обработки операций с плавающей точкой по умолчанию
  может обрабатывать определенные исключения. Программисты могут
  наложить маску на некоторые типы исключений для указания
  модулю обработки операций с плавающей точкой, что нужно
  делать, чтобы в случае исключительной ситуации получить
  разумный результат. Обработка исключения по умолчанию
  выполняется модулем обработки операций с плавающей точкой как
  часть команды, вызвавшей исключение; никаких внешних указаний
  для исключения не дается. При обнаружении исключительной
  ситуации значение флага заносится в регистр состояния, но
  информация о том, где и когда она произошла, является
  доступной. Если модуль обработки операций с плавающей точкой
  обрабатывает все исключения по умолчанию, тогда необходимость
  синхронизации исключительных ситуации не является явной.
  Однако, как будет показано позднее, это не существенная
  причина, чтобы избегать синхронизации при разработке программ,
  использующих модуль обработки операций с плавающей точкой.

* Альтернативой обработке исключений по умолчанию является
  информирование модуля обработки целочисленных операций о
  случившейся исключительной ситуации. Если имело место
  немаскированное исключение, то модуль обработки операций с
  плавающей точкой приостанавливает дальнейшее выполнение
  числовых команд и сигнализирует о случившемся. При обнаружении
  команды ESC или WAIT управление передается обработчику
  исключений. Обработчик исключений сам выбирает процедуру
  обработки любого исключения, обнаруженного модулем обработки
  операций с плавающей точкой. Некоторые команды ESC не
  осуществляют проверки на исключения. Это FNINIT, FNSTENV,
  FNSAVE, FNSTCW и FNCLEX.

Когда модуль обработки операций с плавающей точкой сигнализирует
о немаскированном исключении, то это означает, что ему требуется
помощь. Тот факт, что исключение не было маскировано, указывает,
что дальнейшее выполнение программы модулем обработки операций с
плавающей точкой неразумно.

Если разрешается параллельное вычисление, то состояние
процессора при обнаружении исключения неопределено. Во
время исключения могли быть изменены некоторые внутренние
регистры и выполнены совершенно различные программы. Для
обработки такой ситуации модуль обработки операций с плавающей
точкой имеет специальные регистры, обновляемые в начале каждой
числовой команды, которые позволяют определить состояние
программы, чтобы попытаться повторенить неудачную команду.

При синхронизации исключений надо иметь уверенность, что
модуль обработки операций с плавающей точкой находится в
хорошо определенном состоянии после случившегося
немаскированного исключения. Без такого определенного состояния
программа обработки исключения не могла бы определить причину
исключительной ситуации и успешно восстановить работу.

В следующих двух главах иллюстрируется необходимость
рассмотрения синхронизации исключений при написании числовых
программ, даже если первоначально предполагалось выполнение без
маскирования исключений. Если программа будет позднее
помещена, где исключения не маскированы, то она может работать
неправильно. Пример, когда несколько команд , написанных без
синхронизации исключений, будет работать правильно, однако
провалится при перенесении в другую среду, приведен на Рисунке
18-8.


18.2.1.1 Некорректная синхронизация исключений
----------------------------------------------------------------

На Рисунке 18-8 даны три команды загрузки целого, вычисления его
квадратного корня и уменьшение целого на 1. Синхронная
работа модуля обработки операций с плавающей точкой разрешит
этой программе работать правильно до тех пор, пока команда FILD
не сгенерирует исключения.

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│                 НЕКОРРЕКТНАЯ СИНХРОНИЗАЦИЯ                    │
│                                                               │
│          FIELD     COUNT  ; команда FPU                       │
│          INC       COUNT  ; целочисленная команда изменения   │
│                           ; операнда                          │
│          FSQRT            ; ошибка из предыдущей команды FPU  │
│                           ; обнаружена здесь                  │
│                                                               │
│                 КОРРЕКТНАЯ СИНХРОНИЗАЦИЯ                      │
│                                                               │
│          FIELD     COUNT  ; команда FPU                       │
│          FSQRT            ; ошибка из предыдущей команды FPU  │
│                           ; обнаружена здесь                  │
│          INC       COUNT  ; целочисленная команда изменения   │
│                           ; операнда                          │
│                                                               │
│                                                               │
└───────────────────────────────────────────────────────────────┘

         Рисунок 18-8. Примеры синхронизации исключений.

Ситуация изменяется, если расширить регистровый стек в память. В
этом случае недопустимое исключение не маскировано. Попытка
извлечения из пустого стека или помещения в полный вызывет
недопустимое исключение.

Прграмма обработки исключений должна распознать эту ситуацию,
исправить значение стека и выполнить первоначальную операцию. В
примере, показанном на рисунке, программа обработки будет
работать неверно. Проблема в том, что значение переменной COUNT
увеличивается до вызова обработчика исключений, поэтому
программа обработки получит неправильное значение переменной
COUNT, что приведет к непредсказуемому поведению программы.

18.2.1.2 Корректная синхронизация исключений
----------------------------------------------------------------

Команда WAIT отвечает за синхронизацию исключений. В случае
немаскированного исключения модуль обработки операций с
плавающей точкой сигнализирует процессору об ошибке. При
обнаружении команды WAIT (или неуправляющей команды ESC) сигнал
об ошибке подтверждается и вызывается программный обработчик
исключений. (Для более детальной информации о различных
механизмах обнаружения ошибок в операциях с плавающей точкой
смотри главу 16.) Если команда WAIT или ESC расположена
правильно, то информация, необходимая процессору для обработки
исключений, еще не будет нарушена.
