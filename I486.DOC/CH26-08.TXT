
INVD - Аннулирование кеша

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|0F 08     INVD       4        Аннулирование всего кеша         |
-----------------------------------------------------------------

Работа команды
--------------

Очистка внутреннего кеша
Сигнал внешнему кешу на очистку

Описание
--------

Происходит очистка внутреннего кеша, и выдается специальный цикл
шины, указывающий на необходимость очистки внешних кешей.
Данные, находящиеся во внешних кешах с обратной записью,
теряются.

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

     Отсутствуют

Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

     Отсутствуют

Примечания
----------

Данная команда зависима от реализации: разные процессоры Intel
могут реализовывать ее функции по-разному.

Ответственность за реакцию на сигнал очистки внешнего кеша лежит
на аппаратном обеспечении.

Данная команда    процессорами    386   не   поддерживается.
Использование команды, совместимой с процессорами 386 см. в
разделе 3.11. Обратная запись "грязных" данных из кеша в
оперативную память рассматривается в описании команды WBINVD.

     Запрещение кеширования рассматривается в разделе 12.2.

-----------------------------------------------------------------


INVLPG - Аннулирование элемента TLB

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|0F 01/7   INVLPG   12 в случае  Аннулирование элемента TLB     |
|                   совпадения                                  |
-----------------------------------------------------------------

Работа команды
--------------

Аннулирование элемента TLB

Описание
--------

Команда INVLPG используется для аннулирования одного элемента в
TLB, который представляет собой кеш, используемый для хранения
элементов страничных таблиц. Если TLB содержит достоверный
элемент, отображающий адрес операнда памяти, то этот элемент
будет помечен как недостоверный.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

При использовании команды с операндом-регистров генерируется
исключение неверного кода операции.

Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

При использовании команды с операндом-регистров генерируется
исключение неверного кода операции.

Примечания
----------

Данная команда зависима от реализации: разные процессоры Intel
могут реализовывать ее функции по-разному.

Данная команда процессорами 386 не поддерживается. Использование
команды, совместимой с процессорами 386 см. в разделе 3.11

Запрещение кеширования рассматривается в разделе 12.2.

-----------------------------------------------------------------

IRET/IRETD - Возврат из прерывания

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|CF        IRET        15        Возврат из прерывания          |
|                                (дальний возврат и извлечение  |
|                                из стека флагов)               |
|CF        IRET        36        Возврат из прерывания          |
|                                к меньшему уровню              |
|                                привилегированности            |
|CF        IRET        TS+32     Возврат из прерывания,         |
|                                другая задача (NT = 1)         |
|CF        IRETD       15        Возврат из прерывания          |
|                                (дальний возврат и извлечение  |
|                                из стека флагов)               |
|CF        IRETD       36        Возврат из прерывания          |
|                                к меньшему уровню              |
|                                привилегированности            |
|CF        IRETD       15        Возврат из прерывания,         |
|                                к режиму V86                   |
|CF        IRET        TS+32     Возврат из прерывания,         |
|                                другая задача (NT = 1)         |
-----------------------------------------------------------------

Примечание: приближенные значения ts задаются следующей
таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды
--------------


IF PE = 0
THEN (* Режим реальных адресов *)
  IF operandSize = 32 (* Команда = IRETD *)
  THEN EIP <- Pop();
  ELSE (* Команда = IRET *)
    IP <- Pop();
  FI;
  CS <- Pop();
  IF OperandSize = 32 (* Команда = IRETD *)
  THEN EFLAGS <- Pop();
  ELSE (* Команда = IRET *)
    FLAGS <- Pop();
  FI;
ELSE (* Защищенный режим *)
  IF VM = 1
  THEN #GP(0);
  ELSE
    IF NT = 1
    THEN GOTO ВОЗВРАТ-ЗАДАЧИ;
    ELSE
      IF VM = 1 в образе флагов, находящемся в стеке
      THEN GOTO ВОЗВРАТ-СТЕКА-К-V86;
      ELSE GOTO ВОЗВРАТ-СТЕКА;
      FI;
    FI;
  FI;
FI; ВОЗВРАТ-СТЕКА-К-V86:  (* Прерванная процедура в режиме V86 *)
  IF верхние 36 байтов стека не в пределах границ
  THEN #SS(0);
  FI;
  IF указатель команд не в границах кодового сегмента THEN #GP(0);
  FI;

  EFLAGS <-   SS:[ESP   +  8];  (*  Устанавливает  VM  прерванной
                                    подпрограммы *)
  EIP <- Pop();
  CS <- Pop(); (* CS ведет себя, как в 8086, т.к. VM = 1 *)
  Потеря <-   Pop();   (*  извлечение  из  стека  с  потерей  уже
                           считанного EFLAGS *)
  ВремESP <- Pop();
  ВремSS <- Pop();
  ES <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  DS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  FS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
  GS <-  Pop();  (*  Извлекаются из стека 2 слова;  старшее слово
                     отбрасывается *)
    SS:ESP <- ВремSS:ВремESP;

  (* Возобновление выполнения в виртуальном режиме 8086 *)

ВОЗВРАТ-ЗАДАЧИ:
  Рассмотрим селектор обратной компоновки задач в TSS, адресуемом
    регистром текущей задачи;
    В бите   Локальный/Глобальный  должно  быть  задано  значение
               Глобальный, иначе #TS(селектор нового TSS);
    Индекс должен быть в границах GDT,  иначе #TS(селектор нового
                                                   TSS);
    Байт AR должен задавать TSS, иначе #TS(селектор нового TSS);
    TSS должен присутствовать, иначе #NP(селектор нового TSS);
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ без вложенности в TSS,  заданный  селектором
                           обратной компоновки задач;
  Обозначение прерванной задачи как NOT BUSY (не занято);
  Указатель команд должен быть в пределах границ кодового сегмента,
  ELSE #GP(0);

ВОЗВРАТ-СТЕКА:
  IF OperandSize = 32
  THEN Третье слово в стеке должно быть в пределах границ стека,
       иначе #SS(0);
  ELSE Второе слово в стеке должно быть в пределах границ стека,
       иначе #SS(0);
  FI;
  RPL селектора   CS   возврата   должен   быть   >=  CPL,  иначе
                       #GP(селектор возврата);
  IF RPL селектора возврата = CPL
  THEN GOTO ВОЗВРАТ-НА-ТОТ-ЖЕ-УРОВЕНЬ;
  ELSE GOTO ВОЗВРАТ-НА-ВНЕШНИЙ-УРОВЕНЬ;
  FI;

ВОЗВРАТ-НА-ТОТ-ЖЕ-УРОВЕНЬ:
  IF OperandSize = 32
  THEN
    Верхние 12  байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
    Селектор CS возврата (в eSP+4) должен быть не-пустым, иначе #
                          #GP(0);
  ELSE
    Верхние 6   байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
    Селектор CS возврата (в eSP+2) должен быть не-пустым, иначе #
                          #GP(0);
  FI;
  Индекс селектора должен быть в границах его таблицы дескрипторов,
          иначе #GP(селектор возврата);
  Байт AR  должен  задавать  кодовый сегмент,  иначе #GP(селектор
          возврата);
  IF не-конформный
  THEN DPL кодового сегмента должен быть = CPL;
  ELSE #GP(селектор возврата);
  FI;
  IF конформный
  THEN DPL  кодового  сегмента  должен   быть   <=   CPL,   иначе
           #GP(селектор возврата);
  Указатель команд должен быть в пределах границ кодового сегмента,
           иначе #GP(0);
  FI;
  IF OperandSize = 32
  THEN
    Загрузка CS:IP из стека;
    Загрузка регистра CS дескриптором нового кодового сегмента;
    Загрузка EFLAGS третьим двойным словом из стека;
    Инкремент eSP на 12;
  ELSE
    Загрузка регистра CS дескриптором нового кодового сегмента;
    Загрузка EFLAGS третьим словом из стека;
    Инкремент eSP на 6;
  FI;

ВОЗВРАТ-НА-ВНЕШНИЙ-УРОВЕНЬ:
  IF OperandSize = 32
  THEN Верхние 20 байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
  ELSE Верхние 10 байтов  в  стеке  должны  быть в пределах границ,
                    иначе #SS(0);
  FI;
  Рассмотрим селектор CS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор возврата);
    Байт AR  должен  задавать  кодовый сегмент,  иначе #GP(селектор
          возврата);
    IF не-конформный
    THEN DPL кодового сегмента должен быть = RPL селектора CS;
    ELSE #GP(селектор возврата);
    FI;
    IF конформный
    THEN DPL  кодового  сегмента  должен   быть   > CPL,
    ELSE #GP(селектор возврата);
    FI;
    Сегмент должен присутствовать, иначе #NP(селектор возврата);

  Рассмотрим селектор SS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор SS);
    RPL селектора должен быть равен RPL селектора CS возврата
          ELSE #GP(селектор SS);
    Байт AR  должен  задавать сегмент данных, доступный для записи,
          иначе #GP(селектор SS);
    DPL сегмента стека должен быть = RPL селектора CS возврата;
    ELSE #GP(селектор SS);
    SS должен присутствовать, иначе #NP(селектор SS);

  Указатель команд должен быть в пределах границ кодового сегмента,
           иначе #GP(0);
  IF OperandSize = 32
  THEN
    Загрузка CS:EIP из стека;
    Загрузка EFLAGS значениями в (eSP+8);
  ELSE
    Загрузка CS:IP из стека;
    Загрузка FLAGS значениями в (eSP+4);
  FI;
  Загрузка SS:eSP из стека;
  Загрузка регистра CS дескриптором CS;
  Загрузка регистра SS дескриптором SS;
  FOR каждого из ES, FS, GS и DS
  DO;
    IF текущее значение регистра недостоверно для внешнего уровня;
    THEN обнуление регистра и очистка флага достоверности;
    FI;
    Чтобы быть    достоверным,    установка    регистра    должна
                 удовлетворять следующим свойствам:
      Индекс селектора должен быть в границах его таблицы
           дескрипторов;
      Байт AR  должен  задавать сегмент данных, доступный для
           записи, или кодовый сегмент, доступный для чтения;
      IF это сегмент данных или не-конформный кодовый сегмент,
      THEN DPL должен быть > CPL, или DPL должен быть < RPL;
  OD;


Описание
--------

В режиме реальных адресов команда IRET извлекает из стека
указатель команд, регистр CS и флаговый регистр, после чего
возобновляет выполнение прерванной подпрограммы.

В защищенном режиме действие команды IRET зависит от установки
флага вложенности задачи (NT) в регистре флагов. При извлечении
из стека нового образа флагов биты IOPL флагового регистра
изменяются только при CPL равном 0.

Если флаг NT очищен, команда IRET возвращается из процедуры
прерывания без переключения задачи. Код, в который происходит
возврат, должен быть равным или менее привилегированным, чем
подпрограмма прерывания (как указывают биты RPL селектора CS,
извлекаемого из стека). Если код назначения менее
привилегирован, то команда IRET также извлекает из стека
указатель стека и SS.

Если флаг NT установлен, то команда IRET выполняется в обратной
последовательности относительно команд CALL или INT, вызвавших
переключение задачи. Обновленное состояние задачи, выполняющей
команду IRET, сохраняется в ее сегменте состояния задачи (TSS).
При повторном входе в задачу впоследствии выполняется код,
который следует за командой IRET.


Изменяемые флаги
----------------

Изменяются все флаги; регистр флагов извлекается из стека.

Исключения защищенного режима
----------------------------------

#GP, #NP или #SS, как указано выше в разделе "Работа команды".


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть извлекаемого из стека
операнда лежит за адресом 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если IOPL меньше 3, что позволяет эмуляцию.

-----------------------------------------------------------------



Jcc - Переход, если условие перехода удовлетворяется

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|77 cb     JA rel8     3,1       Переход короткий, если выше    |
|                                (CF = 0 и ZF = 0)              |
|73 cb    JAE rel8     3,1       Переход короткий, если выше    |
|                                или равно (CF = 0)             |
|72 cb     JB rel8     3,1       Переход короткий, если ниже    |
|                                (CF = 1)                       |
|76 cb    JBE rel8     3,1       Переход короткий, если ниже    |
|                                или равно (CF = 1 или ZF = 1)  |
|72 cb     JC rel8     3,1       Переход короткий, если перенос |
|                                (CF = 1)                       |
|E3 cb   JCXZ rel8     8,5       Переход короткий, если регистр |
|                                CX равен 0                     |
|E3 cb  JECXZ rel8     8,5       Переход короткий, если регистр |
|                                ECX равен 0                    |
|74 cb     JE rel8     3,1       Переход короткий, если равно   |
|                                (ZF = 1)                       |
|74 cb     JZ rel8     3,1       Переход короткий, если 0       |
|                                (ZF = 1)                       |
|7F cb     JG rel8     3,1       Переход короткий, если больше  |
|                                (ZF = 0 и SF = OF)             |
|7D cb    JGE rel8     3,1       Переход короткий, если больше  |
|                                или равно (SF = OF)            |
|7C cb     JL rel8     3,1       Переход короткий, если меньше  |
|                                (SF <> OF)                     |
|7E cb    JLE rel8     3,1       Переход короткий, если меньше  |
|                                или равно (ZF=1 или SF <> OF)  |
|76 cb    JNA rel8     3,1       Переход короткий, если не выше |
|                                (CF = 1 и ZF = 1)              |
|72 cb   JNAE rel8     3,1       Переход короткий, если не выше |
|                                или равно (CF = 1)             |
|73 cb    JNB rel8     3,1       Переход короткий, если не ниже |
|                                (CF = 0)                       |
|77 cb   JNBE rel8     3,1       Переход короткий, если не ниже |
|                                или равно (CF=0 и ZF=0)        |
|73 cb    JNC rel8     3,1       Переход короткий, если нет     |
|                                переноса (CF = 0)              |
|75 cb    JNE rel8     3,1       Переход короткий, если не равно|
|                                (ZF = 0)                       |
|7E cb    JNG rel8     3,1       Переход короткий, если не      |
|                                больше (ZF = 1 или SF <> OF)   |
|7C cb   JNGE rel8     3,1       Переход короткий, если не      |
|                                больше или равно (SF <> OF)    |
|7D cb    JNL rel8     3,1       Переход короткий, если не      |
|                                меньше (SF = OF)               |
|7F cb   JNLE rel8     3,1       Переход короткий, если не мень-|
|                                ше или равно (ZF=0 и SF=OF)    |
|71 cb    JNO rel8     3,1       Переход короткий, если нет     |
|                                переполнения (OF=0)            |
|7B cb    JNP rel8     3,1       Переход короткий, если нет кон-|
|                                троля четности (PF = 0)        |
|79 cb    JNS rel8     3,1       Переход короткий, если нет     |
|                                знака (SF = 0)                 |
|75 cb    JNZ rel8     3,1       Переход короткий, если нет нуля|
|                                (ZF = 0)                       |
|70 cb     JO rel8     3,1       Переход короткий, если         |
|                                переполнение (OF = 1)          |
|7A cb     JP rel8     3,1       Переход короткий, если контроль|
|                                четности (PF = 1)              |
|7A cb    JPE rel8     3,1       Переход короткий, если контроль|
|                                на проверку четности (PF = 1)  |
|7B cb    JPO rel8     3,1       Переход короткий, если контроль|
|                                на проверку нечетности (PF = 0)|
|78 cb     JS rel8     3,1       Переход короткий, если знак    |
|                                (SF = 1)                       |
|74 cb     JZ rel8     3,1       Переход короткий, если ноль    |
|                                (ZF = 1)                       |
|0F 87 cw/dw   JA rel16/32  3,1  Переход ближний, если выше     |
|                                (CF = 0 и ZF = 0)              |
|0F 83 cw/dw  JAE rel16/32  3,1  Переход ближний, если выше     |
|                                или равно (CF = 0)             |
|0F 82 cw/dw   JB rel16/32  3,1  Переход ближний, если ниже     |
|                                (CF = 1)                       |
|0F 86 cw/dw  JBE rel16/32  3,1  Переход ближний, если ниже     |
|                                или равно (CF = 1 или ZF = 1)  |
|0F 82 cw/dw   JC rel16/32  3,1  Переход ближний, если перенос  |
|                                (CF = 1)                       |
|0F 84 cw/dw   JE rel16/32  3,1  Переход ближний, если равно    |
|                                (ZF = 1)                       |
|0F 84 cw/dw   JZ rel16/32  3,1  Переход ближний, если 0        |
|                                (ZF = 1)                       |
|0F 8F cw/dw   JG rel16/32  3,1  Переход ближний, если больше   |
|                                (ZF = 0 и SF = OF)             |
|0F 8D cw/dw  JGE rel16/32  3,1  Переход ближний, если больше   |
|                                или равно (SF = OF)            |
|0F 8C cw/dw   JL rel16/32  3,1  Переход ближний, если меньше   |
|                                (SF <> OF)                     |
|0F 8E cw/dw  JLE rel16/32  3,1  Переход ближний, если меньше   |
|                                или равно (ZF=1 или SF <> OF)  |
|0F 86 cw/dw  JNA rel16/32  3,1  Переход ближний, если не выше  |
|                                (CF = 1 и ZF = 1)              |
|0F 82 cw/dw JNAE rel16/32  3,1  Переход короткий, если не выше |
|                                или равно (CF = 1)             |
|0F 83 cw/dw  JNB rel16/32  3,1  Переход ближний, если не ниже  |
|                                (CF = 0)                       |
|0F 87 cw/dw JNBE rel16/32  3,1  Переход ближний, если не ниже  |
|                                или равно (CF=0 и ZF=0)        |
|0F 83 cw/dw  JNC rel16/32  3,1  Переход ближний, если нет      |
|                                переноса (CF = 0)              |
|0F 85 cw/dw  JNE rel16/32  3,1  Переход ближний, если не равно |
|                                (ZF = 0)                       |
|0F 8E cw/dw  JNG rel16/32  3,1  Переход ближний, если не       |
|                                больше (ZF = 1 или SF <> OF)   |
|0F 8C cw/dw JNGE rel16/32  3,1  Переход ближний, если не       |
|                                больше или равно (SF <> OF)    |
|0F 8D cw/dw  JNL rel16/32  3,1  Переход ближний, если не       |
|                                меньше (SF = OF)               |
|0F 8F cw/dw JNLE rel16/32  3,1  Переход ближний, если не мень- |
|                                ше или равно (ZF=0 и SF=OF)    |
|0F 81 cw/dw  JNO rel16/32  3,1  Переход ближний, если нет      |
|                                переполнения (OF=0)            |
|0F 8B cw/dw  JNP rel16/32  3,1  Переход ближний, если нет кон- |
|                                троля четности (PF = 0)        |
|0F 89 cw/dw  JNS rel16/32  3,1  Переход ближний, если нет      |
|                                знака (SF = 0)                 |
|0F 85 cw/dw  JNZ rel16/32  3,1  Переход ближний, если нет нуля |
|                                (ZF = 0)                       |
|0F 80 cw/dw   JO rel16/32  3,1  Переход ближний, если          |
|                                переполнение (OF = 1)          |
|0F 8A cw/dw   JP rel16/32  3,1  Переход ближний, если контроль |
|                                четности (PF = 1)              |
|0F 8A cw/dw  JPE rel16/32  3,1  Переход ближний, если контроль |
|                                на проверку четности (PF = 1)  |
|0F 8B cw/dw  JPO rel16/32  3,1  Переход ближний, если контроль |
|                                на проверку нечетности (PF = 0)|
|0F 88 cw/dw   JS rel16/32  3,1  Переход ближний, если знак     |
|                                (SF = 1)                       |
|0F 84 cw/dw   JZ rel16/32  3,1  Переход ближний, если ноль     |
|                                (ZF = 1)                       |
-----------------------------------------------------------------

Примечание: Первое число тактовых циклов относится к случаю,
когда условие перехода выполняется (переход происходит); второе
значение относится к случаю, когда условие не выполняется (и
переход не происходит). rel16/32 указывает, что эти команды
отображаются двумя командами : одна с 16-разрядным относительным
смещением, а вторая с 32-разрядным относительным смещением, в
зависимости от атрибута размера операнда данной команды.


Работа команды
--------------

IF условие
THEN
  EIP <- EIP + SignExtend(rel8/16/32);
  IF OperandSize = 16
  THEN EIP <- EIP AND 0000FFFFH;
  FI;
FI;


Описание
--------

Команды условного перехода (за исключением команды JCXZ)
проверяют флаги, которые были установлены предыдущей командой.
Условия для каждой мнемонической формы команды даны в круглых
скобках выше после каждого описания. Термины "меньше" и
"больше" используются при сравнении целых со знаком; "выше" и
"ниже" - для целых без знака.

Если условие выполняется, то происходит переход по адресу,
задаваемому операндом. Использование данной команды наиболее
эффективно, когда цель условного перехода находится в текущем
кодовом сегменте и в пределах от -128 до +127 байтов
относительно первого байта следующей команды.

Цель перехода также может находиться в пределах от -32768 до
+32767 (атрибут размера сегмента 16) или от -2**31 до +2**31-1
(атрибут размера сегмента 32) относительно первого байта
следующей команды. Если цель команды условного перехода
находится в другом сегменте, используйте команду с
противоположным условием перехода, которая "обойдет" команду
дальнего безусловного перехода к другому сегменту. Например, вы
не можете записать:

     JZ FARLABEL;


     Вместо этого напишите:

     JNZ BEYOND;
     JMP FARLABEL;
BEYOND:

Поскольку может существовать несколько способов интерпретации
конкретного состояния флагов, ASM386 обеспечивает более одной
мнемонической формы для большинства кодов операции условного
перехода. Например, если вы сравнили два символа в AX и хотите
выполнить переход, если они равны, используйте команду JE, или,
если вы выполнили операцию И для регистра AX и маской,
записанной в битовом поле, и хотите, чтобы переход происходил
только при результате, равном 0, используйте команду JZ, которая
является синонимом команды JE.

Команда JCXZ отличается от других команд условного перехода тем,
что она проверяет не флаги, а содержимое регистров CX или ECX на
равенство 0. Команда JCXZ полезна в начале условного цикла,
который заканчивается командой условного перехода к началу цикла
(например, LOOPNE метка цели). Команда JCXZ предотвращает
вхождение в цикл при регистре CX или ECX, равном нулю, что может
привести к выполнению цикла 64К или 32Г раз вместо нуля раз.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#GP (0), если смещение, на которое задан переход, лежит вне
границ кодового сегмента.


Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

     Отсутствуют

Примечание
----------

Команда JCXZ выполняется дольше, чем последовательность из двух
команд, сравнивающая регистр-счетчик с нулем и выполняющая
переход в случае равенства.

Все команды ветвления преобразуются для выборки в 16-разрядные
коды, независимо от адреса перехода или возможности кеширования.

-----------------------------------------------------------------

JMP - Переход

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|EB cb     JMP rel8      3        Переход короткий              |
|E9 cw     JMP rel16     3        Переход ближний, смещение     |
|                                 относительно следующей команды|
|FF /4     JMP r/m16     5/5      Переход ближний косвенный     |
|EA cd     JMP ptr16:16 17,pm=19  Переход межсегментный, 4-бай- |
|                                 товый непосредственный адрес  |
|EA cd     JMP ptr16:16  32       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|EA cd     JMP ptr16:16  42+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|EA cd     JMP ptr16:16  42+TS    Переход через шлюз задачи     |
|FF/5d     JMP m16:16   13,pm=18  Переход r/m16:16 косвенный и  |
|                                 межсегментный                 |
|FF /5     JMP m16:16    3        Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|FF /5     JMP m16:16    41+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|FF /5     JMP m16:16    42+TS    Переход через шлюз задачи     |
|E9 cd     JMP rel32     3        Переход ближний, смещение     |
|                                 относительно следующей команды|
|FF /4     JMP r/m32     5/5      Переход ближний косвенный     |
|EA cp     JMP ptr16:32 13,pm=18  Переход межсегментный, 6-бай- |
|                                 товый непосредственный адрес  |
|EA cp     JMP ptr16:32  31       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|EA cp     JMP ptr16:32  42+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|EA cp     JMP ptr16:32  43+TS    Переход через шлюз задачи     |
|FF /5     JMP m16:32   13,pm=18  Переход межсегментный, адрес  |
|                                 в двойном слове r/m           |
|FF /5     JMP m16:32    31       Переход к шлюзу вызова, та же |
|                                 привилегированность           |
|FF /5     JMP m16:32    41+TS    Переход через сегмент состоя- |
|                                 ния задачи                    |
|FF /5     JMP m16:32    42+TS    Переход через шлюз задачи     |
-----------------------------------------------------------------

Примечание: значения ts задаются следующей таблицей:

-----------------------------------------------------------------
                     |          Новая задача
     Старая задача   |-------------------------------------------
                     | к TSS i486 | к TSS 80286 | к TSS VM
-----------------------------------------------------------------
 VM/i486/TSS 80286   |     199    |     180     |     177
-----------------------------------------------------------------

Работа команды
--------------

IF команда = относительный переход JMP
  (* т.е. операнд это rel8, rel16 или rel32 *)
THEN
  EIP <- EUP + rel8/16/32;
  IF OperandSize = 16
  THEN EIP <- EIP AND 0000FFFFH;
  FI;
FI;

IF команда = ближний косвенный переход JMP
  (* т.е. операнд это r/m16 или r/m32 *)
THEN
  IF OperandSize = 16
  THEN
    EIP <- [r/m16 AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    EIP <- [r/m32;
  FI;
FI;


IF (PE = 0 OR (PE = 1 AND VM = 1))
(* режим реальных адресов или виртуальный режим 8086 *)
  AND команда = дальний JMP
  (* т.е. тип операнда равен m16:16, m16:32, ptr16:16, ptr16:32 *)
THEN GOTO РЕЖИМ-РЕАЛЬНЫХ-АДРЕСОВ-ИЛИ-V86
  IF тип операнда = m16:16 или m16:32
  THEN (* косвенный *)
    IF OperandSize = 16
    THEN
      CS:IP <- [m16:16;
      EIP <- EIP AND 0000FFFFH: (* очистка старших 16 битов *)
    ELSE (* OperanfSize = 32 *)
      CS:EIP <- [m16:32;
    FI;
  FI;
  IF тип операнда = ptr16:16 или ptr16:32
  THEN
    IF OperandSize = 16
    THEN
      CS:IP <- ptr16:16;
      EIP <- EIP AND 0000FFFFH: (* очистка старших 16 битов *)
    ELSE (* OperanfSize = 32 *)
      CS:EIP <- ptrm16:32;
    FI;
  FI;
FI;


IF (PE = 1 AND VM = 0) (* Защищенный режим, но не режим V86 *)
  AND команда = дальний JMP
THEN
  IF тип операнда = m16 или m16:32
  THEN (* Косвенный *)
    Проверить доступ к двойному слову EA;
    #GP(0) или #SS(0) IF нарушение границы;
  FI;
  Селектор назначения не должен быть пустым, ELSE #GP(0);
  Индекс селектора назначения должен быть в пределах
    границ дескрипторной таблицы; ELSE #GP(селектор)
  В зависимости от байта AR дескриптора назначения:
    GOTO      КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    GOTO      НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ;
    GOTO      ШЛЮЗ-ВЫЗОВА;
    GOTO      ШЛЮЗ-ЗАДАЧИ;
    GOTO      СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ;
  ELSE #GP(селектор); (* Недопустимый байт AR в дескрипторе *)
FI;


КОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  DPL дескриптора должен быть <= CPL  ELSE  #GP(селектор);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  IF OperandSize = 16
  THEN  Загрузить CS:EIP из указателя назначения;
  ELSE  Загрузить CS:IP  из указателя назначения;
  FI;
  Загрузить регистр CS новым дескриптором сегмента;

НЕКОНФОРМНЫЙ-КОДОВЫЙ-СЕГМЕНТ:
  RPL селектора назначения должен быть <= CPL ELSE #GP(селектор);
  DPL дескриптора должен быть = CPL  ELSE  #GP(селектор);
  Сегмент должен   присутствовать   ELSE  #NP  (селектор);
  Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
  IF OperandSize = 32
  THEN  Загрузить CS:EIP из указателя назначения;
  ELSE  Загрузить CS:IP  из указателя назначения;
  FI;
  Загрузить регистр CS новым дескриптором сегмента;
  Установить поле RPL для CS равным CPL;

ШЛЮЗ-ВЫЗОВА:
  DPL дескриптора должен быть >= CPL  ELSE  #GP(селектор шлюза);
  DPL дескриптора должен быть >= RPL селектора шлюза ELSE
                  #GP(селектор шлюза);
  Шлюз должен присутствовать    ELSE  #NP(селектор шлюза);
  Рассмотрим селектор кодового сегмента в дескрипторе шлюза
                                                 вызова:
    Селектор не должен быть пустым ELSE #GP(0)
    Селектор должен быть в пределах границ его дескрипторной
      таблицы ELSE #GP(селектор CS)
    Байт AR выбранного дескриптора должен обозначать кодовый
      сегмент ELSE #GP (селектор CS)
    IF не-конформный
    THEN DPL дескриптора кодового сегмента должен быть = CPL
    ELSE #GP(селектор CS);
    FI;
    IF конформный
    THEN DPL дескриптора кодового сегмента должен быть <= CPL;
    ELSE #GP(селектор CS);
    Кодовый сегмент должен присутствовать ELSE #NP(селектор CS);
    Указатель команд должен быть в границах кодового сегмента ELSE
                                                #GP(0);
    IF OperandSize = 32
    THEN  Загрузить CS:EIP из шлюза вызова;
    ELSE  Загрузить CS:IP  из шлюза вызова;
    FI;
  Загрузить регистр CS новым дескриптором кодового сегмента;
  Установить поле RPL для CS равным CPL;


ШЛЮЗ-ЗАДАЧИ:
  DPL дескриптора шлюза должен быть >= CPL ELSE #TS(селектор шлюза)
  DPL дескриптора шлюза должен быть >= RPL селектора шлюза ELSE
            #GP(селектор шлюза)
  Шлюз задачи должен присутствовать ELSE #NP(селектор шлюза)
  Исследовать селектор TSS, заданный в дескрипторе шлюза задачи:
    Он должен задавать бит Глобальный/Локальный как Глобальный
      ELSE #GP(селектор TSS)
    Индекс должен находиться в пределах границы GDT
      ELSE #GP(селектор TSS)
    Байт AR   дескриптора   TSS  должен  задавать  доступный  TSS
              (младшие биты 00001);
      ELSE #GP(селектор TSS)
    Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (без вложенности) на TSS
  Указатель команд должен находиться в границе кодового сегмента
      ELSE #GP(0)

СЕГМЕНТ-СОСТОЯНИЯ-ЗАДАЧИ:
  DPL для TSS должен быть >= CPL ELSE #GP(селектор TSS)
  DPL для TSS должен быть >= RPL селектора TSS
     ELSE #GP(селектор TSS)
  Байт AR дескриптора должен задавать доступный TSS (младшие биты
      00001) ELSE #GP(селектор TSS)
  Сегмент состояния задачи (TSS) должен присутствовать
      ELSE #NP(селектор TSS)
  ПЕРЕКЛЮЧЕНИЕ-ЗАДАЧ (без вложенности) на TSS
  Указатель команд  должен находиться в границе кодового сегмента
      ELSE #GP(0);

Описание
--------

Команда JMP передает управление в другую точку потока команд, не
записывая информации для выполнения возврата.

Ниже описано действие для различных форм команды.

Команды перехода с типом назначения r/m16m, r/m32 и r/m32
выполняют ближний переход и не влекут изменения значения
сегментного регистра.

Формы команды перехода JMP rel16 и JMP rel32 складывают смещение
с адресом команды, следующей за JMP, чтобы определить назначение
команды. Форма с rel16 используется, когда атрибут размера
операнда команды равен 16 битам (только атрибут размера сегмента
16); форма с rel32 используется, когда атрибут размера операнда
команды равен 32 битам (только атрибут размера сегмента 32).
Результат сохраняется в 32-разрядном регистре EIP. В случае
rel16 старшие 16 битов регистра EIP очищаются, и таким образом,
получается смещение, размер которого не превышает 16 битов.

Формы JMP r/m16 и JMP r/m32 задают регистр или адрес памяти, из
которого выбирается абсолютное смещение в процедуре. Выбранное
из r/m смещение равно 32 битам для атрибута размера операнда,
равного 32 битам (r/m32), или 16 битам для атрибута размера
операнда, равного 16 битам (r/m16).

Формы команды JMP ptr16:16 и ptr16:32 используют четырехили
шести-байтовые операнды в качестве длинных указателей на
назначение. Формы JMP m16:16 и m16:32 выбирают дальний указатель
из заданного адреса памяти (косвенное обращение). В режиме
реальных адресов или виртуальном режиме 8086 длинный указатель
обеспечивает 16 битов для регистра CS и 16 или 32 бита для
регистра EIP (в зависимости от атрибута размера операнда). В
защищенном режиме обе формы с длинными указателями проверяют
байт прав доступа (AR) в дескрипторе, индексируемом селекторной
частью длинного указателя. В зависимости от значения байта AR
переход будет осуществлять один из следующих типов передачи
управления:

- Переход к кодовому сегменту на том же уровне
  привилегированности.

- Переключение задачи.

Более подробная информация о передаче управления в защищенном
режиме находится в главах 6 и 7.


Изменяемые флаги
----------------

При переключении задачи изменяются все флаги; если же
переключение задачи не происходит, то флаги не изменяются.

Исключения защищенного режима
----------------------------------

Для дальних переходов: #GP, #NP, #SS и #TS, как указано выше.

Для ближних прямых переходов: #GP(0), если процедура находится
за пределами границы кодового сегмента; #AC для невыравненной
ссылки к памяти при текущем уровне привилегированности, равном
3.

Для ближних косвенных переходов: #GP(0) в случае недопустимого
исполнительного адреса операнда памяти в сегментах CS, DS, ES,
FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS; #
GP, если полученное косвенное смещение лежит за границами
кодового сегмента; #PF(код сбоя) в случае страничного сбоя; #AC
для невыравненной ссылки к памяти при текущем уровне
привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев; #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Примечания
----------

Все команды ветвления преобразуются для выборки в 16-байтовые
коды, независимо от адреса перехода или возможности кеширования.

-----------------------------------------------------------------


LAHF - Загрузка флагов в регистр AH

-----------------------------------------------------------------
|Код       Команда  Число      Описание                         |
|операции           тактовых                                    |
|                   циклов                                      |
|                                                               |
|9F        LAHF       3        Загрузка: AH = флаги             |
|                              SF ZF xx AF xx PF xx CF          |
-----------------------------------------------------------------

Работа команды
--------------

AH <- SF:ZF:xx:AF:xx:PF:xx:CF;

Описание
--------

Команда LAHF пересылает младший байт слова флагов в регистр AH.
Биты, от MSB до LSB, это биты знака, нуля, неопределенность,
вспомогательный, неопределенность, контроля четности,
неопределенность и переноса.

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

     Отсутствуют

Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

     Отсутствуют
-----------------------------------------------------------------

LAR  - Загрузка байта прав доступа

-----------------------------------------------------------------
|Код       Команда        Число      Описание                   |
|операции                 тактовых                              |
|                         циклов                                |
|                                                               |
|0F 02 /r  LAR r16,r/m16   11/11   r16 <- r/m16 маскируется FF00|
|0F 02 /r  LAR r32,r/m32   11/11   r32 <- r/m32 маскируется     |
|                                               00FxFF00        |
-----------------------------------------------------------------


Описание
--------

Команда LAR сохраняет отмеченную форму второго двойного слова
дескриптора в качестве исходного селектора, если селектор видим
на текущем уровне привилегированности (модифицированном RPL
селектора) и содержит допустимый тип дескриптора в границах
дескриптора. Регистр назначения загружается старшим двойным
словом дескриптора, маскируемого значением 00FxFF00, и
устанавливается флаг ZF. x указывает на то, что четыре бита,
соответствующие старшим четырем битам границы, в значении,
загружаемом командой LAR, неопределены. Если селектор невидим
или имеет неверный тип, то флаг ZF очищается.

Если задан 32-разрядный размер операнда, то все 32-разрядное
значение целиком загружается в 32-разрядный регистр назначения.
Если задан 16-разрядный размер операнда, то младшие 16 битов
этого значения загружаются в 16-разрядный регистр назначения.

Допустимыми для команды LAR являются все дескрипторы кодовых
сегментов и сегментов данных.

Допустимые типы дескрипторов специальных сегментов и шлюзов для
команды LAR приводятся в следующей таблице:

-----------------------------------------------------------------
  Тип     Имя                             Допустимо/недопустимо
-----------------------------------------------------------------
   0      Недопустимо                           Недопустимо
   1      Доступный TSS 80286                   Допустимо
   2      LDT                                   Допустимо
   3      Занятый TSS 80286                     Допустимо
   4      Шлюз вызова 80286                     Допустимо
   5      Шлюз задачи 80286/i486                Допустимо
   6      Шлюз ловушки 80286                    Допустимо
   7      шлюз прерывания 80286                 Допустимо
   8      Недопустимо                           Недопустимо
   9      Доступный TSS i486                    Допустимо
   A      Недопустимо                           Недопустимо
   B      Занятый TSS i486                      Допустимо
   C      Шлюз вызова i486                      Допустимо
   D      Недопустимо                           Недопустимо
   E      Шлюз ловушки i486                     Допустимо
   F      шлюз прерывания i486                  Допустимо
-----------------------------------------------------------------


Изменяемые флаги
----------------

Флаг ZF установлен, если только селектор не является невидимым
или недопустимого типа, когда флаг ZF очищается.

Исключения защищенного режима
----------------------------------

#GP(0) в случае недопустимого исполнительного адреса операнда
памяти в сегментах CS, DS, ES, FS или GS; #SS(0) в случае
недопустимого адреса в сегменте SS; #PF(код сбоя) в случае
страничного сбоя; #AC для невыравненной ссылки к памяти при
текущем уровне привилегированности, равном 3.

Исключения режима реальных адресов
---------------------------------------

Прерывание 6; команда LAR в режиме реальных адресов не
распознается.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и в режиме реальных адресов.

-----------------------------------------------------------------


