
POP - Извлечение слова из стека

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|8F /0     POP m16      6        Извлечение вершины стека и     |
|                                помещение ее в слово памяти    |
|8F /0     POP m32      6        Извлечение вершины стека и     |
|                                помещение ее в двойное слово   |
|                                памяти                         |
|58+ rw    POP r16      4        Извлечение вершины стека и     |
|                                помещение ее в слово - регистр |
|58+ rd    POP r32      4        Извлечение вершины стека и     |
|                                помещение ее в двойное слово - |
|                                регистр                        |
|1F        POP DS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр DS      |
|07        POP ES       3        Извлечение вершины стека и     |
|                                помещение ее в регистр ES      |
|17        POP SS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр SS      |
|0F A1     POP FS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр FS      |
|0F A9     POP GS       3        Извлечение вершины стека и     |
|                                помещение ее в регистр GS      |
-----------------------------------------------------------------

Работа команды
--------------

IF StackAddrSize = 16
THEN
  IF OperandSize = 16
  THEN
    DEST <- (SS:SP); (* Копирование слова *)
    SP <- SP + 2;
  ELSE (* OperandSize = 32 *)
    DEST <- (SS:SP); (* Копирование двойного слова *)
    SP <- SP + 4;
  FI;

ELSE (* StackAddrSize = 32 *)
  IF OperandSize = 16
  THEN
    DEST <- (SS:ESP); (* Копирование слова *)
    ESP <- ESP + 2;
  ELSE (* OperandSize = 32 *)
    DEST <- (SS:ESP); (* Копирование двойного слова *)
    ESP <- ESP + 4;
  FI;
FI;


Описание
--------

Команда POP заменяет текущее содержимое операнда памяти,
регистра или сегментного регистра словом, снятым с вершины стека
i486, адресуемого SS:SP (при атрибуте размера адреса 16 битов)
или SS:ESP (при атрибуте размера адреса 32 бита). Указатель
стека SP получает приращение 2 при размере операнда 16 битов или
4 при размере операнда 32 бита. После этого указатель
устанавливается на новую вершину стека.

Команда POP CS не является командой процессора i486. Извлечение
из стека в регистр CS осуществляется командой RET.

Если операнд назначения это сегментный регистр (DS, ES, FS или
SS), то извлекаемое из стека значение должно являться
селектором. В защищенном режиме загрузка селектора инициирует
автоматическую загрузку информации дескриптора, связанной с
данным селектором, в скрытую часть сегментного регистра:
загрузка также инициирует контроль достоверности информации
селектора и дескриптора.

Пустое значение (0000-0003) может быть извлечен в регистр DS,
ES, FS или GS, не вызывая исключения защиты. Попытка сослаться
на сегмент, сегментный регистр которого был загружен пустым
значением, вызовет исключение #GP(0). Ссылок к памяти не
происходит. Сегмент при этом сохраняет пустое значение.

Команда POP SS запрещает все прерывания, включая и немаскируемые
прерывания, до конца выполнения следующей команды. Это позволяет
последовательное выполнение команд POP SS и POP eSP без
опасности иметь во время прерывания неверное состояние стека.
Однако, использование команды LSS для загрузки регистров SS и
eSP предпочтительнее.

Загрузка сегментного регистра в защищенном режиме сопровождпется
специальными проверками и действиями, как показано в следующем
листинге:


IF загружается SS:
  IF селектор пустой THEN #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    RPL селектора должен быть равен CPL ELSE #GP(селектор);
    Байт AR  должен  задавать сегмент данных, доступный для записи,
          ELSE #GP(селектор);
    DPL в байте AR должен быть равен CPL ELSE #GP(селектор);
    Сегмент должен   быть   помечен   как   Присутствующий   ELSE
          #NP(селектор);
    Загрузка регистра SS селектором;
    Загрузка регистра SS дескриптором;

IF DS, ES, FS или GS загружается не-пустым селектором:
  Байт AR  должен  задавать сегмент данных или кодовый сегмент,
     доступный для записи чтения, ELSE #GP(селектор);
  IF сегмент данных или не-конформный сегмент кода
  THEN RPL и CPL должны быть меньше или равны DPL в байте AR;
  ELSE #GP(селектор);
  FI;
  Сегмент должен   быть   помечен   как   Присутствующий   ELSE
          #NP(селектор);
  Загрузка сегментного регистра селектором;
  Загрузка сегментного регистра дескриптором;

IF DS, ES, FS или GS загружается пустым селектором:
  Загрузка сегментного регистра селектором;
  Очистка бита Достоверности в невидимой части регистра

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#GP, #SS и #NP, если загружается сегментный регистр; #SS(0),
если текущая вершина стека не находится в границах стекового
сегмента; #GP(0), если назначением является сегмент, недоступный
для записи; #GP(0) в случае недопустимого исполнительного адреса
операнда памяти в сегментах CS, DS, ES, FS или GS; #SS(0) в
случае недопустимого адреса в сегменте SS; #PF(код сбоя) в
случае страничного сбоя; #AC для невыравненной ссылки к памяти
при текущем уровне привилегированности, равном 3.


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев. #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Примечание
----------

Разрешены последовательности   парных  команд  PUSH/POP,  не
требующие дополнительного тактового цикла между ними.

-----------------------------------------------------------------


POPA/POPAD - Извлечение из стека всех регистров общего назначения

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|61        POPA         9        Извлечение из стека  DI,  SI,  |
|                                 BP,  BX,  DX,  CX  и  AX      |
|61        POPAD        9        Извлечение из стека EDI, ESI,  |
|                                EBP, EBX, EDX, ECX  и EAX      |
-----------------------------------------------------------------

Работа команды
--------------

IF OperandSize = 16 (* Команда = POPA *)
THEN
  DI <-  Pop();
  SI <-  POP();
  BP <-  Pop();
  теряется <-  Pop();  (* Пропуск SP *)
  BX <-  Pop();
  DX <-  Pop();
  CX <-  Pop();
  AX <-  Pop();
ELSE (* OperandSize = 32, команда = POPAD *)
  EDI <-  Pop();
  ESI <-  POP();
  EBP <-  Pop();
  теряется <-  Pop();  (* Пропуск ESP *)
  EBX <-  Pop();
  EDX <-  Pop();
  ECX <-  Pop();
  EAX <-  Pop();
FI;


Описание
--------

Команда POPA извлекает из стека восемь 16-битовых регистров
общего назначения. Однако, значение SP вместо загрузки регистра
SP уничтожается. Команда POPA реверсирует действие предыдущей
команды PUSHA, восстанавливая значения регистров общего
назначения, которые они имели перед выполнением команды PUSHA.
Первый извлекаемый регистр - это DI.

Команда POPAD извлекает из стека восемь 32-битовых регистров
общего назначения. Однако, значение ESP вместо загрузки регистра
ESP уничтожается. Команда POPAD реверсирует действие предыдущей
команды PUSHAD, восстанавливая значения регистров общего
назначения, которые они имели перед выполнением команды PUSHAD.
Первый извлекаемый регистр - это EDI.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#SS(0), если начальный или конечный адрес стека не находится в
пределах стекового сегмента; #PF(код сбоя) в случае страничного
сбоя;


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев.

-----------------------------------------------------------------


POPF/POPFD - Извлечение из стека регистров FLAGS или ERFLAGS

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9D        POPF         9,pm=6   Извлечение вершины стека в     |
|                                FLAGS                          |
|9D        POPFD        9,pm=6   Извлечение вершины стека в     |
|                                EFLAGS                         |
-----------------------------------------------------------------

Работа команды
--------------

Флаги <- Pop();


Описание
--------

Команда POPA снимает с вершины стека слово или двойное слово и
помещает его во флаговый регистр. Если атрибут размера операнда
команды равен 16 битам, из стека извлекается слово, и его
содержимое помещается в регистр FLAGS. Если атрибут размера
операнда команды равен 32 бита, из стека извлекается двойное
слово, и его содержимое помещается в регистр EFLAGS.

Информация о регистрах FLAGS и EFLAGS находится в главах 2 и 4.
Отметим, что биты 16 и 17 регистра EFLAGS, называемые VM и RF,
соответственно, не зависят от работы команды POPF и POPFD.

Уровень привилегированности ввода/вывода может быть изменен
только при выполнении на уровне привилегированности 0. Флаг
прерывания изменяется только при выполнении на уровне, как
минимум равном уровню привилегированности ввода/вывода. (Режим
реальных адресов эквивалентен уровню привилегированности 0).
Если команда POPF выполняется при недостаточном уровне
привилегированности, исключение не возникает, но
привилегированные биты не изменяются.

Изменяемые флаги
----------------

Все флаги, за исключением флагов VM и RF.

Исключения защищенного режима
----------------------------------

#SS(0), если вершина стека не находится в пределах стекового
сегмента.


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если уровень привилегированности меньше 3, что
позволяет эмуляцию.

-----------------------------------------------------------------


PUSH - помещение операнда в стек

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|FF /6     PUSH m16     4        Помещение в стек               |
|                                слова памяти                   |
|FF /6     PUSH m32     4        Помещение в стек               |
|                                двойного слова памяти          |
|50+ /r    PUSH r16     1        Помещение в стек               |
|                                слова - регистра               |
|50+ /r    PUSH r32     1        Помещение в стек               |
|                                двойного слова - регистра      |
|6A        PUSH imm8    1        Помещение в стек               |
|                                непосредственного байта        |
|68        PUSH imm16   1        Помещение в стек               |
|                                непосредственного слова        |
|68        PUSH imm32   1        Помещение в стек               |
|                               непосредственного двойного слова|
|0E        PUSH CS      3        Помещение в стек CS            |
|16        PUSH SS      3        Помещение в стек SS            |
|1E        PUSH DS      3        Помещение в стек DS            |
|06        PUSH ES      3        Помещение в стек ES            |
|0F A0     PUSH FS      3        Помещение в стек FS            |
|0F A8     PUSH GS      3        Помещение в стек GS            |
-----------------------------------------------------------------

Работа команды
--------------

IF StackAddrSize = 16
THEN
  IF OperandSize = 16 THEN
    SP <- SP - 2;
    (SS:SP) <- (источник);  (* Назначение слова *)
  ELSE
    SP <- SP - 4;
    (SS:SP) <- (источник);  (* Назначение двойного слова *)
  FI;

ELSE (* StackAddrSize = 32 *)
  IF OperandSize = 16
  THEN
    ESP <- ESP - 2;
    (SS:ESP) <- (источник);  (* Назначение слова *)
  ELSE
    ESP <- ESP - 4;
    (SS:ESP) <- (источник);  (* Назначение двойного слова *)
  FI;


Описание
--------

Команда PUSH декрементирует указатель стека на 2, если атрибут
размера операнда команды равен 16 битам; в противном случае она
декрементирует указатель стека на 4. Затем команда PUSH помещает
операнд в новую вершину стека, на которую указывает указатель
стека.

Команда PUSH ESP помещает в стек значение регистра ESP, в том
виде, который он имел до выполнения команды. В этом состоит
отличие от 8086, где команда PUSH SP помещает в стек новое
значение (декрементированное на 2).

Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#SS(0), если новое значение регистра SP или ESP не находится в
границах стекового сегмента; #GP(0) в случае недопустимого
исполнительного адреса операнда памяти в сегментах CS, DS, ES,
FS или GS; #SS(0) в случае недопустимого адреса в сегменте SS; #
PF(код сбоя) в случае страничного сбоя; #AC для невыравненной
ссылки к памяти при текущем уровне привилегированности, равном
3.


Исключения режима реальных адресов
---------------------------------------

Отсутствуют: если регистр SP или ESP равен 1, процессор
переходит в режим закрытия из-за недостаточного размера памяти
стека.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев. #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

Примечание
----------

При использовании операнда памяти команда PUSH выполняется
дольше, чем последовательность двух команд, пересылающая операнд
через регистр.

Разрешены последовательности   парных  команд  PUSH/POP,  не
требующие дополнительного тактового цикла между ними.

-----------------------------------------------------------------


PUSHA/PUSHAD - Помещение в стек всех регистров общего назначения

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|60        PUSHA        11       Помещение в стек  AX,  CX,  DX,|
|                                 BX, исходного  SP, BP, SI и DI|
|60        PUSHAD       11       Помещение в стек EAX, ECX, EDX,|
|                               EBX, исходного ESP,EBP,ESI и EDI|
-----------------------------------------------------------------

Работа команды
--------------

IF OperandSize = 16 (* Команда = PUSHA *)
THEN
  Врем <- (SP);
  Push(AX);
  Push(CX);
  Push(DX);
  Push(BX);
  Push(Врем);
  Push(BP);
  Push(SI);
  Push(DI);
ELSE (* OperandSize = 32, команда = PUSHAD *)
  Врем <- (ESP);
  Push(EAX);
  Push(ECX);
  Push(EDX);
  Push(EBX);
  Push(Врем);
  Push(EBP);
  Push(ESI);
  Push(EDI);
FI;


Описание
--------

Команды PUSHA и PUSHAD помещают в стек i486 16- или 32-битовые
регистры общего назначения. Команда PUSHA декрементирует
указатель стека (SP) на 16, что соответствует восьми помещаемым
значениям размером в слово. Команда PUSHAD декрементирует
указатель стека (ESP) на 32, что соответствует восьми помещаемым
значениям размером в двойное слово. Поскольку регистры
помещаются в стек в данном порядке, в новом стеке они появятся в
обратном порядке. Последним в стек помещается регистр DI или
EDI.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#SS(0), если начальный или конечный адрес стека не находится в
пределах стекового сегмента; #PF(код сбоя) в случае страничного
сбоя;


Исключения режима реальных адресов
---------------------------------------

Перед выполнением команды PUSHA или PUSHAD процессор 386 DX
переходит в режим закрытия при равенстве регистра SP или ESP 1,
3 или 5; если регистр SP или ESP равен 7, 9, 11, 13 или 15, то
происходит исключение 13.

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев.

-----------------------------------------------------------------


PUSHF/PUSHFD - Помещение в стек флаговых регистров

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|9C        PUSHF        4,pm=3   Помещение в стек FLAGS         |
|9C        PUSHFD       4,pm=3   Помещение в стек EFLAGS        |
-----------------------------------------------------------------

Работа команды
--------------

IF OperandSize = 32
THEN push(EFLAGS);
ELSE push(FLAGS);
FI;


Описание
--------

Команда PUSHF декрементирует указатель стека на 2 и копирует
регистр FLAGS в новую вершину стека; команда PUSHFD
декрементирует указатель стека на 4, и в новую вершину стека
копируется регистр EFLAGS, на которую указывает SS:ESP.
Информацию о регистре EFLAGS см. в главах 2 и 4.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#SS(0), если новое значение регистра ESP не находится в пределах
стекового сегмента.


Исключения режима реальных адресов
---------------------------------------

Отсутствуют: процессор переходит в режим закрытия из-за
недостаточного размера памяти стека.

Исключения виртуального режима 8086
----------------------------------------

Сбой #GP(0), если уровень привилегированности меньше 3, что
позволяет эмуляцию.

-----------------------------------------------------------------


RCL/RCR/ROL/ROR - Циклический сдвиг

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|D0 /2     RCL r/m8,1  3/4       Циклический сдвиг 9 битов      |
|                                (CF, байт r/m) влево 1  раз    |
|D2 /2     RCL r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              CL                (CF, байт r/m) влево CL раз    |
|C0 /2 ib  RCL r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              imm8              (CF, байт r/m) влево imm8 раз  |
|D1 /2     RCL r/m16,1 3/4       Циклический сдвиг 17 битов     |
|                                (CF,слово r/m) влево 1  раз    |
|D3 /2     RCL r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              CL                (CF,слово r/m) влево CL раз    |
|C1 /2 ib  RCL r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              imm8              (CF,слово r/m) влево imm8 раз  |
|D1 /2     RCL r/m32,1 3/4       Циклический сдвиг 33 битов     |
|                          (CF,двойное слово r/m) влево 1  раз  |
|D3 /2     RCL r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              CL          (CF,двойное слово r/m) влево CL раз  |
|C1 /2 ib  RCL r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              imm8        (CF,двойное слово r/m) влево imm8 раз|
|D0 /3     RCR r/m8,1  3/4       Циклический сдвиг 9 битов      |
|                                (CF, байт r/m) вправо 1  раз   |
|D2 /3     RCR r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              CL                (CF, байт r/m) вправо CL раз   |
|C0 /3 ib  RCR r/m8,   8-30/9-31 Циклический сдвиг 9 битов      |
|              imm8              (CF, байт r/m) вправо imm8 раз |
|D1 /3     RCR r/m16,1 3/4       Циклический сдвиг 17 битов     |
|                                (CF,слово r/m) вправо 1  раз   |
|D3 /3     RCR r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              CL                (CF,слово r/m) вправо CL раз   |
|C1 /3 ib  RCR r/m16,  8-30/9-31 Циклический сдвиг 17 битов     |
|              imm8              (CF,слово r/m) вправо imm8 раз |
|D1 /3     RCR r/m32,1 3/4       Циклический сдвиг 33 битов     |
|                          (CF,двойное слово r/m) вправо 1  раз |
|D3 /3     RCR r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              CL          (CF,двойное слово r/m) вправо CL раз |
|C1 /3 ib  RCR r/m32,  8-30/9-31 Циклический сдвиг 33 битов     |
|              imm8        (CF,двойное слово r/m)вправо imm8 раз|
|D0 /0     ROL r/m8,1  3/4       Циклический сдвиг 8 битов      |
|                                (    байт r/m) влево 1  раз    |
|D2 /0     ROL r/m8,   3/4       Циклический сдвиг 8 битов      |
|              CL                (    байт r/m) влево CL раз    |
|C0 /0 ib  ROL r/m8,   3/4       Циклический сдвиг 8 битов      |
|              imm8              (    байт r/m) влево imm8 раз  |
|D1 /0     ROL r/m16,1 3/4       Циклический сдвиг 16 битов     |
|                                (   слово r/m) влево 1  раз    |
|D3 /0     ROL r/m16,  3/4       Циклический сдвиг 16 битов     |
|              CL                (   слово r/m) влево CL раз    |
|C1 /0 ib  ROL r/m16,  3/4       Циклический сдвиг 16 битов     |
|              imm8              (   слово r/m) влево imm8 раз  |
|D1 /0     ROL r/m32,1 3/4       Циклический сдвиг 32 битов     |
|                             (двойное слово r/m) влево 1  раз  |
|D3 /0     ROL r/m32,  3/4       Циклический сдвиг 32 битов     |
|              CL             (двойное слово r/m) влево CL раз  |
|C1 /0 ib  ROL r/m32,  2/4       Циклический сдвиг 32 битов     |
|              imm8           (двойное слово r/m) влево imm8 раз|
|D0 /1     ROR r/m8,1  3/4       Циклический сдвиг 8 битов      |
|                                (    байт r/m) вправо 1  раз   |
|D2 /1     ROR r/m8,   3/4       Циклический сдвиг 8 битов      |
|              CL                (    байт r/m) вправо CL раз   |
|C0 /1 ib  ROR r/m8,   3/4       Циклический сдвиг 8 битов      |
|              imm8              (    байт r/m) вправо imm8 раз |
|D1 /1     ROR r/m16,1 3/4       Циклический сдвиг 16 битов     |
|                                (   слово r/m) вправо 1  раз   |
|D3 /1     ROR r/m16,  3/4       Циклический сдвиг 16 битов     |
|              CL                (   слово r/m) вправо CL раз   |
|C1 /1 ib  ROR r/m16,  3/4       Циклический сдвиг 16 битов     |
|              imm8              (   слово r/m) вправо imm8 раз |
|D1 /1     ROR r/m32,1 3/4       Циклический сдвиг 32 битов     |
|                             (двойное слово r/m) вправо 1  раз |
|D3 /1     ROR r/m32,  3/4       Циклический сдвиг 32 битов     |
|              CL             (двойное слово r/m) вправо CL раз |
|C1 /1 ib  ROR r/m32,  2/4       Циклический сдвиг 32 битов     |
|              imm8           (двойное слово r/m)вправо imm8 раз|
-----------------------------------------------------------------

Работа команды
--------------

(* ROL - циклический сдвиг влево *)
врем <- счетчик;
WHILE(врем <> 0)
DO
  времcf <- старший бит (r/m);
  r/m <- r/m * 2 + (времcf);
  врем <- врем - 1;
OD;
IF счетчик = 1
THEN
  IF старший бит r/m <> CF
  THEN OF <- 1;
  ELSE OF <- 0;
  FI;
ELSE OF <- неопределено;
FI;

(* ROR - циклический сдвиг вправо *)
врем <- счетчик;
WHILE(врем <> 0)
DO
  времcf <- младший бит (r/m);
  r/m <- r/m / 2 + (времcf * 2 ** width(r/m));
  врем <- врем - 1;
OD;
IF счетчик = 1
THEN
  IF (старший бит r/m) <> (бит, соседний со старшим битом r/m)
  THEN OF <- 1;
  ELSE OF <- 0;
  FI;
ELSE OF <- неопределено;
FI;


Описание
--------

Каждая команда циклического сдвига сдвигает биты данного
операнда регистра или памяти. Команда циклического сдвига влево
сдвигают все биты в верхнем направлении, за исключением самого
верхнего бита, который переходит в нижнюю позицию. Команды
циклического сдвига выполняют обратное действие: биты сдвигаются
в нижнем направлении, пока самый нижний бит не окажется сверху.

В случае команд RCL и RCR флаг CF является частью сдвигаемых
данных. Команда RCL сдвигает флаг CF в нижний бит, а верхний бит
сдвигает во флаг CF; команда RCR сдвигает флаг CF в верхний бит,
а нижний бит сдвигает во флаг CF. Для команд ROL и ROR исходное
значение флага CF не является частью результата, но флаг CF
получает копию бита, который был сдвинут с одного конца на
другой.

Сдвиг повторяется число раз, задаваемое вторым операндом,
который представляет собой либо непосредственное значение, либо
содержимое регистра CL. Для уменьшения максимального времени
выполнения команды процессор i486 не позволяет число циклических
сдвигов более 31. При попытке сделать счетчик сдвигов более 31
используются только нижние 5 битов. 8086 не маскирует счетчик
сдвигов. В виртуальном режиме 8086 процессор i486 не маскирует
счетчик сдвигов.

Флаг OF определен только для однократных форм команды (второй
операнд равен 1). В остальных случаях он не определен. Для
сдвигов/циклических сдвигов влево для бита CF после сдвига
выполняется операция XOR с битом результата старшего порядка.
Для сдвигов/циклических сдвигов вправо для двух битов старшего
порядка результата выполняется операция XOR для получения флага
OF.

Изменяемые флаги
----------------

Флаг OF изменяется только в случае циклических сдвигов на 1 бит;
для сдвигов на несколько битов флаг OF неопределен; флаг CF
содержит значение бита, который был в него помещен сдвигом;
флаги SF, ZF, AF и PF не изменяются.

Исключения защищенного режима
----------------------------------

#GP(0), если назначением является сегмент, недоступный для
записи; #GP(0) в случае недопустимого исполнительного адреса
операнда памяти в сегментах CS, DS, ES, FS или GS; #SS(0) в
случае недопустимого адреса в сегменте SS; #PF(код сбоя) в
случае страничного сбоя; #AC для невыравненной ссылки к памяти
при текущем уровне привилегированности, равном 3.


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть операнда лежит вне
пространства исполнительных адресов от 0 до 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев. #AC для невыравненной ссылки к
памяти при текущем уровне привилегированности, равном 3.

-----------------------------------------------------------------


REP/REPE/REPZ/REPNE/REPNZ - Повторение следующей строковой команды

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|F3 6C     REP INS     16+8(E)CX,        Ввод (E)CX байтов из   |
|           r/m8,DX    pm=10+8(E)CX *1/  порта DX в ES:[(E)DI]  |
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 6D     REP INS     16+8(E)CX,        Ввод (E)CX слов   из   |
|          r/m16,DX    pm=10+8(E)CX *1/  порта DX в ES:[(E)DI]  |
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 6D     REP INS     16+8(E)CX,        Ввод (E)CX двойных слов|
|          r/m32,DX    pm=10+8(E)CX *1/ из порта DX в ES:[(E)DI]|
|                      30+8(E)CX *2,                            |
|                      VM=29+8(E)CX                             |
|F3 A4     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX байтов |
|          m8,m8       12+3(E)CX *5      из [(E)SI] в ES:[(E)DI]|
|F3 A5     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX слов   |
|          m16,m16     12+3(E)CX *5      из [(E)SI] в ES:[(E)DI]|
|F3 A5     REP MOVS    5 *3, 13 *4,      Пересылка (E)CX двойных|
|          m32,m32     12+3(E)CX *5      слов                   |
|                                        из [(E)SI] в ES:[(E)DI]|
|F3 6E     REP OUTS    17+5(E)CX,       Вывод (E)CX байтов из   |
|          DX,r/m8     pm=11+5(E)CX *1/ [(E)SI] в порт DX       |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F3 6F     REP OUTS    17+5(E)CX,       Вывод (E)CX слов   из   |
|          DX,r/m16    pm=11+5(E)CX *1/ [(E)SI] в порт DX       |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F3 6F     REP INS     17+5(E)CX,       Вывод (E)CX двойных слов|
|          DX,r/m32    pm=11+5(E)CX *1/ из [(E)SI] в порт DX    |
|                      31+5(E)CX *2,                            |
|                      VM=30+5(E)CX                             |
|F2 AC     REP LODS    5 *3,             Загрузка  (E)CX байтов |
|          m8          7 +4(E)CX *6      из [(E)SI] в AL        |
|F2 AD     REP LODS    5 *3,             Загрузка  (E)CX слов   |
|          m16         7 +4(E)CX *6      из [(E)SI] в AX        |
|F2 AD     REP LODS    5 *3,             Загрузка  (E)CX двойных|
|          m32         7 +4(E)CX *6      слов                   |
|                                        из [(E)SI] в EAX       |
|F3 AA     REP STOS    5 *3,             Заполнение(E)CX байтов |
|          m8          7 +4(E)CX *6      в ES:[(E)DI] из AL     |
|F3 AB     REP STOS    5 *3,             Заполнение(E)CX слов   |
|          m16         7 +4(E)CX *6      в ES:[(E)DI] из AX     |
|F3 AB     REP STOS    5 *3,             Заполнение(E)CX двойных|
|          m32         7 +4(E)CX *6      слов                   |
|                                        в ES:[(E)DI] из EAX    |
|F3 A6    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m8,M8       7 +7(E)CX *6      байтов                 |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 A7    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m16,m16     7 +7(E)CX *6      слов                   |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 A7    REPE CMPS    5 *3,             Поиск несовпадающих    |
|          m32,m32     7 +7(E)CX *6      двойных слов           |
|                                        в ES:[(E)DI] и [(E)SI] |
|F3 AE    REPE SCAS    5 *3,             Поиск не равных     AL |
|          m8          7 +5(E)CX *6      байтов, начиная с      |
|                                          ES:[(E)DI]           |
|F3 AF    REPE SCAS    5 *3,             Поиск не равных     AX |
|          m16         7 +5(E)CX *6      слов  , начиная с      |
|                                          ES:[(E)DI]           |
|F3 AF    REPE SCAS    5 *3,             Поиск не равных     EAX|
|          m32         7 +5(E)CX *6      двойных слов, начиная с|
|                                          ES:[(E)DI]           |
|F2 A6   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m8,M8       7 +7(E)CX *6      байтов                 |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 A7   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m16,m16     7 +7(E)CX *6      слов                   |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 A7   REPNE CMPS    5 *3,             Поиск   совпадающих    |
|          m32,m32     7 +7(E)CX *6      двойных слов           |
|                                        в ES:[(E)DI] и [(E)SI] |
|F2 AE   REPNE SCAS    5 *3,             Поиск    равных     AL |
|          m8          7 +5(E)CX *6      байтов, начиная с      |
|                                          ES:[(E)DI]           |
|F2 AF   REPNE SCAS    5 *3,             Поиск    равных     AX |
|          m16         7 +5(E)CX *6      слов  , начиная с      |
|                                          ES:[(E)DI]           |
|F2 AF   REPNE SCAS    5 *3,             Поиск    равных     EAX|
|          m32         7 +5(E)CX *6      двойных слов, начиная с|
|                                          ES:[(E)DI]           |
-----------------------------------------------------------------

Примечания:  *1  если CPL <= IOPL
             *2  если CPL > IOPL
             *3  (E)CX = 0
             *4  (E)CX = 1
             *5  (E)CX > 1
             *6  (E)CX > 0

Работа команды
--------------

IF AddressSize = 16
THEN в качестве CountReg используется CX;
ELSE (* AddressSize = 32 *) в качестве CountReg используется ECX;
FI;

WHILE CountReg <> 0
DO
  обслуживание подвешенных прерываний (если они есть);
  выполнение примитивной строковой команды;
  CountReg <- CountReg - 1;
  IF примитивная операция это CMPB,CMPW,SCAB или SCAW
  THEN
    IF (команда REP/REPE/REPZ) AND (ZF=1)
    THEN выход из цикла WHILE
    ELSE
      IF (команда REPNZ или REPNE) AND (ZF=0)
      THEN выход из цикла WHILE;
      FI;
    FI;
  FI;
OD;

Описание
--------

Префиксы REP, REPE (повторять пока равно) и REPNE (повторять
пока не равно) применяются в строковых операциях. Каждый префикс
вызывает повторение следующей за ним строковой команды столько
раз, сколько указано счетным регистром или (для префиксов REPE и
REPNE) пока не перестанет удовлетворяться условие, указанное
флагом ZF.

Синонимическими формами префиксов REPE и REPNE являются префиксы
REPZ и REPNZ, соответственно.

Префиксы REP одновременно применяются только к одной строковой
команде. Для повторения блока команд используйте команду LOOP
или другую конструкцию цикла.

Точное описание действий при каждой итерации следущее:

1. Если атрибут размера адреса равен 16  битам,  в  качестве
   регистра-счетчика используется CX; Если же атрибут размера
   адреса равен 32 битам, в качестве регистра-счетчика
   используется ECX;

2. Проверяется регистр CX. Если он равен 0, происходит выход из
   итерации и переход к следующей команде.

3. Уведомление о любых подвешенных прерываниях.

4. Однократное выполнение строковой операции.

5. Декремент регистра CX или ECX на единицу; флаги не
   модифицируются.

6. Если строковая команда это SCAS или CMPS, проверяется флаг
   ZF. Если условие повтоения не выполняется, то происходит
   выход из итерации и переход к следующей команде. Выход из
   итерации происходит, если префикс это REPE, а флаг ZF равен 0
   (последнее сравнение показало не-равенство), либо если
   префикс это REPNE, а флаг ZF равен 1 (последнее сравнение
   показало равенство).

7. Возврат к шагу 1 для следующей итерации.

Выход из повторяющихся команд CMPS и SCAS возможен, когда либо
счетчик отсчитал нужное число раз, либо флаг ZF показал, что
условие повторения не выполняется. Эти два случая можно
различить, используя для этого либо команду JCXZ, либо условные
переходы, проверяющие флаг ZF (команды JZ, JNZ и JNE).

Изменяемые флаги
----------------

Флаг ZF изменяется конструкциями REP CMPS и REP SCAS, как было
описано выше.

Исключения защищенного режима
----------------------------------

     Отсутствуют


Исключения режима реальных адресов
---------------------------------------

     Отсутствуют

Исключения виртуального режима 8086
----------------------------------------

     Отсутствуют

Примечание
----------

Не все порты ввода/вывода способны поддерживать скорость, с
которой выполняются команды REP INS и REP OUTS.

При использовании с не-строковой командой префикс повторения
игнорируется.

-----------------------------------------------------------------


RET - Возврат из процедуры

-----------------------------------------------------------------
|Код       Команда     Число      Описание                      |
|операции              тактовых                                 |
|                      циклов                                   |
|                                                               |
|C3         RET        5         Возврат (ближний) в            |
|                                вызывающую процедуру           |
|CB         RET        13,pm=18  Возврат (дальний) в            |
|                                вызывающую процедуру,          |
|                                та же привилегированность      |
|CB         RET        13,pm=33  Возврат (дальний)              |
|                                меньшая привилегированность,   |
|                                стеки переключения задач       |
|C2 iw      RET imm16  5         Возврат (дальний),             |
|                                извлечение из стека imm16      |
|                                байтов параметров              |
|CA iw      RET imm16  14,pm=17  Возврат (дальний),             |
|                                та же привилегированность,     |
|                                извлечение из стека imm16      |
|                                байтов                         |
|CA iw      RET imm16  14,pm=33  Возврат (дальний),             |
|                                меньшая привилегированность,   |
|                                извлечение из стека imm16      |
|                                байтов                         |
-----------------------------------------------------------------

Работа команды
--------------

IF команда = ближний RET
THEN
  IF OperandSize = 16
  THEN
    IP <- Pop();
    EIP <- EIP AND 0000FFFFH;
  ELSE (* OperandSize = 32 *)
    EIP <- Pop();
  FI;
  IF в команде задан непосредственный операнд
    THEN eSP <- eSP + imm16; FI;
FI;

IF (PE = 0 OR (PE = 1 AND VM = 1))
   (* режим реальных адресов или виртуальный режим 8086 *)
   AND команда = дальний RET
  THEN
    IF OperandSize = 16
    THEN
      IP <- Pop();
      EIP <- EIP AND 0000FFFFH;
      CS <- Pop(); (* Извлечение из стека 16 битов *)
    ELSE (* OperandSize = 32 *)
      EIP <- Pop();
      CS <- Pop(); (* извлечение из стека 32 битов, 16 битов
                      теряются *)
    FI;
    IF в команде задан непосредственный операнд
       THEN eSP <- eSP + imm16; FI;
FI;

IF (PE = 1 AND VM = 0)
   (* Защищенный режим, не виртуальный режим 8086 *)
   AND команда = дальний RET
  THEN
    IF OperandSize = 16
    THEN  третье слово в стеке должно находиться в границах стека
           иначе #SS(0);
    ELSE  второе слово в стеке должно находиться в границах стека
           иначе #SS(0);
    FI;
    RPL селектора возврата должен быть >= CPL
         ELSE #GP(селектор возврата);
    IF RPL селектора возврата = CPL
    THEN GOTO ТОТ-ЖЕ-УРОВЕНЬ;
    ELSE GOTO ВНЕШНИЙ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ;
    FI;
FI;


ТОТ-ЖЕ-УРОВЕНЬ:
  Селектор возврата должен быть не-пустым ELSE  #GP(0)
  Индекс селектора должен быть в границах его таблицы дескрипторов,
      ELSE  #GP(селектор);
  Байт AR дескриптора должен  задавать  кодовый сегмент,
      ELSE #GP(селектор);
  IF не-конформный
  THEN  DPL кодового сегмента должен быть равен CPL;
  ELSE #GP(селектор);
  FI;
  IF конформный
  THEN  DPL кодового сегмента должен быть <= CPL;
      ELSE #GP(селектор);
  FI;
  Кодовый сегмент должен Присутствовать ELSE #NP(селектор);
  Верхнее слово в стеке должно быть в границах стека ELSE #SS(0);
  IP должен быть в границах кодового сегмента ELSE #GP(0);
  IF OperandSize = 32
  THEN
    Загрузка CS:EIP из стека
    Загрузка регистра CS дескриптором
    Инкремент eSP  на  4 плюс непосредственное значение смещения,
              если оно существует
  FI;


ВНЕШНИЙ-УРОВЕНЬ-ПРИВИЛЕГИРОВАННОСТИ:
  IF OperandSize = 32
  THEN Верхние  (16+непосредственное  значение)  байтов  в  стеке
     должны быть в пределах границ стека, иначе #SS(0);
  ELSE Верхние  (8+непосредственное  значение)  байтов  в   стеке
     должны быть в пределах границ стека, иначе #SS(0);
  FI;
  Рассмотрим селектор CS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    Байт AR дескриптора должен  задавать  кодовый сегмент,
          ELSE  #GP(селектор);
    IF не-конформный
    THEN DPL  кодового  сегмента  должен  быть  =  RPL  селектора
          возврата; ELSE #GP(селектор);
    FI;
    IF конформный
    THEN DPL  кодового  сегмента  должен   быть <= RPL селектора
        возврата, ELSE #GP(селектор);
    FI;
    Сегмент должен присутствовать, иначе #NP(селектор);

  Рассмотрим селектор SS возврата и связанный с ним дескриптор:
    Селектор должен быть не-пустым, иначе #GP(0);
    Индекс селектора должен быть в границах его таблицы дескрипторов,
          ELSE #GP(селектор);
    RPL селектора должен быть равен RPL селектора CS возврата
          ELSE #GP(селектор);
    Байт AR дескриптора  должен  задавать сегмент данных, доступный
       для записи, ELSE #GP(селектор);
    DPL дескриптора должен быть = RPL селектора CS возврата;
        ELSE #GP(селектор);
    Сегмент должен присутствовать, иначе #NP(селектор);
    Указатель команд должен быть в пределах границ кодового сегмента,
        ELSE #GP(0);
    Установка CPL равным RPL селектора CS возврата;
    IF OperandMode = 32
    THEN
      Загрузка CS:EIP из стека;
      Установка RPL CS равным CPL;
      Инкремент eSP на 8 плюс непосредственное значение смещения,
         если оно существует;
      Загрузка SS:eSP из стека;
    ELSE  (* OperandMode *)
      Загрузка CS:IP из стека;
      Установка RPL CS равным CPL;
      Инкремент eSP на 4 плюс непосредственное значение смещения,
         если оно существует;
      Загрузка SS:eSP из стека;
    FI;
    Загрузка регистра CS дескриптором CS возврата;
    Загрузка регистра SS дескриптором SS возврата;
    FOR каждого из ES, FS, GS и DS
    DO;
      IF текущее  значение  регистра  недостоверно  для  внешнего
           уровня, регистр устанавливается пустым
           (селектор <- AR <- 0);
      Чтобы быть   достоверным,   установка    регистра    должна
           удовлетворять следующим свойствам:
        Индекс селектора должен быть в границах его таблицы
           дескрипторов;
        Байт AR дескриптора  должен  задавать  сегмент  данных  или
           кодовый сегмент, доступный для чтения;
        IF это сегмент данных или не-конформный кодовый сегмент,
          THEN DPL должен быть >= CPL, или DPL должен быть >= RPL;
        FI;
  OD;


Описание
--------

Команда RET передает управление на адрес возврата, находящийся в
стеке. Адрес обычно помещается в стек командой CALL, а возврат
выполняется к команде, расположенной после команды CALL.

Необязательный числовой параметр команды RET определяет число
байтов (operandMode = 16) или слов (OperandMode = 32), которые
должны быть освобождены после извлечения из стека адреса
возврата. Эти элементы обычно используются как входные параметры
вызываемой процедуры).

Для внутрисегментного (ближнего) возврата адрес в стеке это
смещение сегмента, извлекаемое из стека и помещаемое в указатель
команд. Регистр CS не изменяется. Для межсегментного (дальнего)
возврата адрес в стеке это длинный указатель. Сначала из стека
извлекается смещение, а за ним селектор.

В реальном режиме регистры CS и IP загружаются прямо. В
защищенном режиме межсегментный возврат заставляет процессор
проверить дескриптор, адресуемый селектором возврата. Байт AR
дескриптора должен обозначать кодовый сегмент, равный или менее
привилегированный (с большим или равным числовым номером уровня
привилегированности), нежели текущий уровень
привилегированности. Возврат на меньший уровень
привилегированности вызывает перезагрузку стека из значения,
записанного после блока параметров.

Во время меж-уровневой передачи управления команда RET может
очистить регистры DS, ES, FS и GS. Если эти регистры относятся к
сегментам, которые не могут быть использованы на новом уровне
привилегированности, они очищаются, чтобы предупредить
неразрешенный доступ с нового уровня привилегированности.


Изменяемые флаги
----------------

     Отсутствуют

Исключения защищенного режима
----------------------------------

#GP, #NP или #SS, как указано выше в разделе "Работа команды"; #
PF(код сбоя) в случае страничного сбоя;


Исключения режима реальных адресов
---------------------------------------

Прерывание 13, если какая-либо часть извлекаемого из стека
операнда лежит за адресом 0FFFFH.

Исключения виртуального режима 8086
----------------------------------------

Те же исключения, что и для режима реальных адресов: #PF (код
сбоя) для страничных сбоев.

-----------------------------------------------------------------
