Interrupt List, part 15 of 16
Copyright (c) 1989,1990,1991,1992,1993,1994,1995,1996,1997 Ralf Brown
--------d-67---------------------------------
INT 67 - Adaptec controllers - DRIVE 1 DATA
Desc:	this vector stores the last four bytes of the parameter table for
	  hard disk 1
SeeAlso: INT 64"Adaptec",INT 65"Adaptec",INT 66"Adaptec"
--------b-67---------------------------------
INT 67 - TI Professional PC - SYSTEM DATA (NOT A VECTOR!)
Desc:	this vector contains the TI Pro's system configuration words
	  (see #3153)
SeeAlso: INT 66"TI Professional PC"

Bitfields for TI Professional PC System Configuration doubleword:
Bit(s)	Description	(Table 3153)
 0	8087 present
 31-1	reserved (0)
--------d-67---------------------------------
INT 67 - Pdisk by Scott Garfinkle - Overwritten for Hard Drive information
SeeAlso: INT 64"Pdisk",INT 66"Pdisk"
--------I-67---------------------------------
INT 67 - Sangoma CCPOP 3270 resident module
SeeAlso: INT 61"Sangoma",INT 68"Sangoma"
--------U-67---------------------------------
INT 67 - CUCKOO.COM - INSTALLATION CHECK
Program: CUCKOO is a resident on-screen clock with optional hourly chime or
	  cuckoo by an unknown author with revisions by Thomas A. Lundin
Note:	this is not a vector; when loaded for the first time, CUCKOO.COM uses
	  the last unused (0000h:0000h) vector in the range 60h-67h to store
	  the signature value 434Ch:4F4Bh ('CLOK')
----------67---------------------------------
INT 67 - PC-DRAFT - KEYBOARD DRIVER
	???
Return: ???
Program: PC-DRAFT is a powerful CAD environment by rhv.
SeeAlso: INT 62"PC-DRAFT",INT 64"PC-DRAFT",INT 65"PC-DRAFT",INT 66"PC-DRAFT"
--------N-6700-------------------------------
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE AND WAIT
	AH = 00h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #3154)
	AH = semaphore owner if status=02h
SeeAlso: AH=01h,AH=02h"PC-NET",INT 7F/AH=00h

(Table 3154)
Values for PC-NET semaphore function status:
 00h	successful
 01h	invalid function
 02h	semaphore already locked
 03h	unable to lock semaphore
 04h	semaphore space exhausted
--------N-6701-------------------------------
INT 67 - PC-NET, Alloy NTNX - LOCK SEMAPHORE
	AH = 01h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #3154)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=02h"PC-NET",INT 7F/AH=01h"Alloy"
--------N-6702-------------------------------
INT 67 - PC-NET, Alloy NTNX - UNLOCK SEMAPHORE
	AH = 02h
	DS:DX -> ASCIZ semaphore name (max 64 bytes)
Return: AL = status (see #3154)
	AH = semaphore owner if status=02h
SeeAlso: AH=00h,AH=01h"PC-NET",INT 7F/AH=02h
--------m-671E-------------------------------
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - INSTALLATION CHECK
	AH = 1Eh
Return: AH = 00h if installed
	    AL destroyed
	    ES:DI -> ASCII signature "MemLimit"
SeeAlso: AH=1Fh,INT 21/AX=4402h"386MAX"
--------m-671F-------------------------------
INT 67 U - Qualitas 386MAX v7.00 - MEMLIMIT - API
	AH = 1Fh
	DS:SI -> request packet (see #3155)
Return: AH = status (00h successful, 84h invalid function code, etc.)
SeeAlso: AH=1Eh

Format of 386MAX MEMLIMIT request packet:
Offset	Size	Description	(Table 3155)
 00h	WORD	function code (00h-0Fh)
 02h	WORD	return code (see #3156)
 04h  4 BYTEs	???
 08h	WORD	???
	???

(Table 3156)
Values for 386MAX MEMLIMIT return code:
 00h	unknown request
 01h	invalid parameter for VCPI limit
 02h	VCPI limit set
 03h	invalid parameter for EMS limit
 04h	EMS limit set
 05h	DPMI disabled
 06h	XMS disabled
 07h	XMS limit set
 08h	unable to uninstall
 09h	unloaded
--------m-672763CL01-------------------------
INT 67 - VIDEMS.SYS v1.31+ - INSTALLATION CHECK
	AX = 2763h
	CL = 01h
	BX = signature AAFFh
Return: AH = 00h if VIDEMS is installed
	    CH = 00h if optimization for 80286 is used, 01h otherwise
	    CL = internal revision number (typically 00h to 03h)
	    DX = driver version (DH=major, DL=minor; not a BCD!)
	AH = 84h if not installed but EMS manager is present
Program: VIDEMS is an expanded memory manager from Conea Software Corp. It
	 converts video adapter RAM to LIM 3.2 EMS.
SeeAlso: AX=2763h/CL=02h,AX=2763h/CL=03h
--------m-672763CL02-------------------------
INT 67 - VIDEMS.SYS v1.31+ - FLUSH EMS TO VIDEO RAM
	AX = 2763h
	CL = 02h
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h
--------m-672763CL02-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RELOAD EMS FROM VIDEO RAM
	AX = 2763h
	CL = 02h
	[Yes, I know the registers are duplicated.  Clarification to follow.]
	BX = signature AAFFh
Return: AH = 00h if successful
Notes:	This call is normally used by Conea products only.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=03h
--------m-672763CL03-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RETURN HIDDEN BLOCK SIZE
	AX = 2763h
	CL = 03h
	BX = signature AAFFh
Return: AH = 00h if successful
	    DX = block size in kilobytes
Desc:	Returns the amount of EMS which can be safely used at any time, and
	  can't be destroyed by writing anything to the B800:0000 buffer.
Note:	this function normally returns 184K, while the driver provides up to
	  240K of EMS.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h
--------m-672763CL03-------------------------
INT 67 - VIDEMS.SYS v1.31+ - RETURN PHYSICAL PAGE SIZE
	AX = 2763h
	CL = 03h
	[Yes, I know the registers are duplicated.  Clarification to follow.]
	BX = signature AAFFh
Return: AH = 00h
	DX = size in bytes
Desc:	Used by Conea products to determine if addressing mode has changed.
	  Normally, all VIDEMS versions beginning from 1.10 (or 1.15 - ?) use
	  4K "physical" pages.
Notes:	this function will probably become raw page size in future releases of
	  VIDEMS, which	will support the LIM 4.0 standard.
SeeAlso: AX=2763h/CL=01h,AX=2763h/CL=02h
--------u-672833-----------------------------
INT 67 - Q87 v4+ - PREPARE TO UNLOAD AND GET XMS HANDLE FOR Q87 MEMORY
	AX = 2833h
	EAX = 29482833h (entire EAX value required)
Return: EAX = XMS handle for memory allocated when Q87 was installed
	EBX = status
	    00000000h Q87 is in demo mode (countdown running);
			  Q87 remains active
	    00000001h Q87 is in registered mode; memory manager's IDT, GDT,
			  and optionally CR0 (if BL <> 5Fh on entry) have
			  been restored
	    00000002h Q87 is in demo mode (demo time has expired);
			  Q87 remains active
Note:	this call is used by UNLOAD87 to release the memory used by Q87
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=4321h,INT 21/AX=4321h/BX=0000h
--------m-673F--CX5145-----------------------
INT 67 U - QEMM-386 v4.23+ - INSTALLATION CHECK
	AH = 3Fh
	CX = 5145h ("QE")
	DX = 4D4Dh ("MM")
Return: AH = 00h if installed
	    ES:DI -> QEMM API entry point (see #3157,#3160,#3272)
Notes:	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "QUARTERDECK EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word at offset 12h contains the offset in
	  the handler's segment of the API entry point
	although this function is still undocumented, Quarterdeck has recently
	  documented two alternate methods for determining the QEMM API entry
	  point, as well as several of the API functions
	MICEMM (Micronics Expanded Memory Manager) versions 2.0C and 4D support
	  the alternate QEMM installation check and entry point functions 00h,
	  02h, and 03h; version 4D only provides the signature string if the
	  commandline argument "DV" is provided
	386MAX v6.01 responds to this call, but DESQview 2.42 does not
	  recognize the returned entry point as providing QEMM's capabilities
	  because a) only functions 0Ch (different from QEMM 0Ch) and
			1000h-1009h are supported,
		  b) status is returned as for EMS functions, not QEMM funcs
		  c) the protected-mode entry point returned by function 1000h
			only supports functions 0Ch, 1004h, 1005h, and 100Ah
	the string check mentioned above is not supported by 386MAX
SeeAlso: AX=5BF0h,AH=DDh,AX=FFA5h,INT 15/AX=11DEh,INT 21/AX=4402h/SF=01h
SeeAlso: INT 21/AX=4402h"QEMM",INT 21/AX=4402h"386MAX",INT 2F/AX=D201h/BX=5145h

(Table 3157)
Values for calling QEMM "QPI_GetStatus" function:
	AH = 00h get QEMM state
Return: CF clear
	AL = QEMM state
	    bit 0 set if QEMM turned OFF
	    bit 1 set if in "Auto" mode
Note:	this function is officially documented
SeeAlso: #3158,#3159,#3160,#3272

(Table 3158)
Values for calling QEMM "QPI_SetStatus" function:
	AH = 01h set QEMM state
	AL = new state
	    bit 0 set: place QEMM in OFF state
Return: CF clear if successful
	CF set on error
Note:	this function is officially documented
SeeAlso: #3157

(Table 3159)
Values for calling QEMM QPI function 02h:
	AH = 02h get ???
Return: CF clear
	AX = segment of ??? data structure
	Data Structure
	Offset	Size	Description
	 00h	DWORD	page table entry for ???
		???
SeeAlso: #3160

(Table 3160)
Values for calling QEMM "QPI_GetVersion" function:
	AH = 03h get QEMM version
Return: CF clear
	AX = BX = version in BCD
Notes:	this function is officially documented.	 The most recent official docs
	  state that the version is returned in both AX and BX; older
	  documentation only mentions BX
	MICEMM returns AX=0001h, BX unchanged
SeeAlso: #3157,#3161

(Table 3161)
Values for calling QEMM QPI function 04h:
	AH = 04h allocate 4K page and set AUTO/ON mode
Return: CF clear if successful
	    DX = page number of a 4K page
	CF set if unable to allocate page
Note:	QEMM mode unchanged if not AUTO/OFF
SeeAlso: #3162

(Table 3162)
Values for calling QEMM QPI function 05h:
	AH = 05h free 4K page and turn QEMM off
	DX = page number returned by function 04h
Return: CF clear
Note:	QEMM mode unchanged if not AUTO/ON
SeeAlso: #3161,#3163

(Table 3163)
Values for calling QEMM QPI function 06h:
	AH = 06h make new mapping context???
	DX = page number of 4K page to hold page table
Return: CF clear
Note:	copies page table into given page and then sets ??? page table entry
	  to point at copy
SeeAlso: #3164,#3165

(Table 3164)
Values for calling QEMM QPI function 07h:
	AH = 07h get mapping context
Return: CF clear
	DX = page number of page table for current mapping context
SeeAlso: #3160,#3163,#3165

(Table 3165)
Values for calling QEMM QPI function 08h:
	AH = 08h set mapping context???
	DX = linear page number of page table
Return: CF clear
SeeAlso: #3160,#3163,#3164,#3166,#3168

(Table 3166)
Values for calling QEMM QPI function 09h:
	AH = 09h get linear page number for page table entry
	CX = page table index
Return: CF clear
	DX = linear page number
SeeAlso: #3167

(Table 3167)
Values for calling QEMM QPI function 0Ah:
	AH = 0Ah set linear page number for page table entry
	CX = page table index
	DX = linear page number
Return: CF clear
SeeAlso: #3166

(Table 3168)
Values for calling QEMM QPI function 0Bh:
	AH = 0Bh map 4K pages
	BX = number of pages
	CX = first page number (must be 0100h to allocate HMA)
	DX = EMS handle (memory belonging to EMS handle will be mapped
	      into the address space beginning with the first page
	      allocated to the handle)
Return: AH = 00h
SeeAlso: #3165,#3169

(Table 3169)
Values for calling QEMM QPI function 0Ch:
	AH = 0Ch get available memory
Return: CF clear
	BX = 0001h
	CX = total 4K pages???
	DX = number of 4K pages free
SeeAlso: #3168,#3170

(Table 3170)
Values for calling QEMM QPI function 0Dh:
	AH = 0Dh CRT controller I/O port trapping
	AL = mode
	    00h only trap on I/O ports 03C0h-03C5h, 03C7h, 03CAh-03CFh
	    01h trap on ports 03B4h, 03B5h, 03B8h, 03C6h, 03C8h, 03C9h,
		  03D4h, and 03D5h
	    02h only trap on I/O ports 03C6h, 03C8h, and 03C9h
Return: CF clear

(Table 3171)
Values for calling QEMM QPI function 0Eh:
	AH = 0Eh set cursor virtualization callbacks
	DS:BX -> FAR routine for getting hardware cursor address
	ES:DX -> FAR routine for setting hardware cursor address
Return: CF clear
Note:	both callbacks are invoked with CL indicating which
	  CRT controller register to access (0Eh for high
	  byte of cursor address, 0Fh for low byte)
	the DS:BX callback should return BX=cursor address;
	  ES:DX is called with BL or BH (depending on CL)
	  set to the appropriate half of the cursor's address

(Table 3172)
Values for calling QEMM QPI function 0Fh:
	AH = 0Fh unmap 4K pages
	CX = first page number
	DX = number of pages
Return: CF clear
	AL = 00h/01h if ???
Note:	if CX=0100h and DX=0010h, the HMA is remapped to
	  simulate a disabled A20

(Table 3173)
Values for calling QEMM QPI function 1000h:
	AX = 1000h get protected-mode interface
	DS:SI -> 16-byte buffer for two GDT entries
	ES:DI -> buffer for 4K page table
Return: CF clear
	EAX = offset of protected-mode API entry point
	DS:SI buffer filled with two GDT descriptors
		first is QEMM code segment, second is data???
	ES:DI buffer filled with 4K page table
	DI points to first unused page table entry
SeeAlso: INT 67/AX=DE01h

(Table 3174)
Values for calling QEMM QPI function 1001h:
	AX = 1001h get CPU debug registers
	ES:DI -> buffer for debug registers (8 DWORDs)
Return: CF clear
	BL = INT01 handling (see #3175)
	ES:DI buffer filled

(Table 3175)
Values for calling QEMM QPI function 1002h:
	AX = 1002h set CPU debug registers
	BL = INT01 handling
	    00h	 reflect all debugging exceptions as V86-mode INT 01's
	    else convert debugging exceptions other than single-step
		  into V86-mode INT 03's, single-step to INT 01's
	ES:DI -> buffer containing debug registers (8 DWORDs)
Return: CF clear
Notes:	identical to INT 67/AX=DE09h if BL=01h
	the INT01 handling flag is set to 01h by the general-protection
	  violation handler for certain privileged instructions
SeeAlso: #3174

(Table 3176)
Values for calling QEMM QPI function 1003h:
	AX = 1003h get machine status word CR0
Return: CF clear
	EAX = contents of CR0
SeeAlso: INT 67/AX=DE07h

(Table 3177)
Values for calling QEMM QPI function 1004h:
	AX = 1004h allocate a 4K page
Return: CF clear if successful
	    EDX = linear address of allocated page
	CF set on error
SeeAlso: INT 67/AX=DE04h

(Table 3178)
Values for calling QEMM QPI function 1005h:
	AX = 1005h free 4K page
	EDX = linear address of page to free
Return: CF clear
SeeAlso: INT 67/AX=DE05h

(Table 3179)
Values for calling QEMM QPI function 1006h:
	AX = 1006h NOP
Return: CF set

(Table 3180)
Values for calling QEMM QPI function 1007h:
	AX = 1007h get maximum physical memory address
Return: CF clear
	EDX = physical address of highest 4K memory page
SeeAlso: INT 67/AX=DE02h

(Table 3181)
Values for calling QEMM QPI function 1008h:
	AX = 1008h get physical address of page in first megabyte
	CX = page number (linear address shifted right 12 bits)
Return: CF clear
	EDX = linear address of page
SeeAlso: #3180,#3256,#3257

(Table 3182)
Values for calling QEMM QPI function 1009h:
	AX = 1009h switch to protected mode
	ESI = linear address in first megabyte of system reg values
	      (see INT 67/AX=DE0Ch)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the
	      entry point is required to set up a new stack
	      before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed

(Table 3183)
Values for calling QEMM QPI function 100Ah:
	AX = 100Ah switch back to virtual-86 mode
	DS = selector for data segment from function 1000h
	SS:ESP in first megabyte of linear memory
	interrupts disabled
	STACK:	QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	will switch to virtual86 mode with interrupts disabled, all
	  segment registers loaded, and EAX destroyed.

(Table 3184)
Values for calling QEMM QPI function 11h:
	AH = 11h get memory type map
	AL = zero/nonzero ??? (set by QEMM.COM but apparently ignored
	      by QEMM 6.00)
	ES:DI -> 256-byte buffer for memory types
Return: CF clear
	BL = ???
	ES:DI buffer filled
Note:	each byte of the buffer corresponds to a 4K page, and
	  contains the type of that page: 00h = mappable,
	  02h = mapped ROM, 03h = high RAM, 04h = excluded,
	  05h = video, 06h = ROM, 07h = adapter ROM,
	  08h = split ROM, 09h = page frame, 0Ah = RAMmable,
	  0Bh = conventional, 83h = high RAM under MS Windows

(Table 3185)
Values for calling QEMM QPI function 12h:
	AH = 12h get HIRAM chain
Return: CF clear
	BX = segment of first MCB in high memory
	    0000h if no high memory

(Table 3186)
Values for calling QEMM QPI function 1300h:
	AX = 1300h VIDRAMEGA???
	BL = 00h copy ???
	     nonzero copy ??? (reverse)
Return: CF clear
	AL = status
	    00h if all pages clean
	    01h if any page dirty

(Table 3187)
Values for calling QEMM QPI function 1301h:
	AX = 1301h check if pages modified
	DX:DI = start address of range to check
	CX = length of range in paragraphs
Return: CF clear
	CX = status
	    0000h none of the indicated pages is dirty
		DI destroyed
	    1000h one or more pages is dirty
		DI = low word of first dirty page's linear addr

(Table 3188)
Values for calling QEMM QPI function 1302h:
	AX = 1302h ???
	BL = ???
	BH = ???
	CX = ???
	SI = offset of ???
	DI = offset of ???
	???
Return: CF clear
	???
Note:	disables certain interrupts at the two 8259 PICs during
	  execution; also modifies CRT controller during
	  execution under certain circumstances

(Table 3189)
Values for calling QEMM QPI function 1303h:
	AX = 1303h initialize EGA graphics virtualization
	BX = number of pages (less 1) of EMS to allocate
Return: CF clear if successful
	    DX = EMS handle
	CF set on error

(Table 3190)
Values for calling QEMM QPI function 1304h:
	AX = 1304h shutdown EGA graphics virtualization
	DX = EMS handle being used for virtualization
Return: CF clear

(Table 3191)
Values for calling QEMM QPI function 1305h:
	AX = 1305h select portion of EGA graphics to virtualize???
	(related to graphics virtualization, changes memory mappings)
	CX = start offset within A000h segment of virtualized mem???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #3198) and runs inside a QEMM
	  critical section

(Table 3192)
Values for calling QEMM QPI function 1306h:
	AX = 1306h set DESQview critical section counter address
	ES:BX -> WORD DESQview critical section counter or 0000h:0000h
Return: CF clear
Note:	also sets a pointer in the low-memory part of QEMM to
	  the current value of INT 15 if ES:BX not 0000h:0000h

(Table 3193)
Values for calling QEMM QPI function 1307h:
	AX = 1307h ??? (changes memory mappings for entire A000h segment)
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during
	  execution (see #3198) and runs inside a QEMM
	  critical section

(Table 3194)
Values for calling QEMM QPI function 1308h:
	AX = 1308h start/reset CRT controller I/O trapping
	BL = subfunction
	    00h restore CRTC I/O port trapping to previous state
	    else start trapping all accesses to I/O ports 03B0-03DF
Return: CF clear
Note:	if called more than once in a row with BL nonzero, the
	  original state of the I/O port trapping will be lost

(Table 3195)
Values for calling QEMM QPI function 1309h:
	AX = 1309h Hercules mode-change support
	ES:BX -> new address for Hercules mode-change callback
Return: CF clear
Note:	the callback function is called whenever the CRTC mode
	  register is written, with AL set to the value written

(Table 3196)
Values for calling QEMM QPI function 130Ah:
	AX = 130Ah virtualize EGA/VGA DAC registers (I/O ports 03C8h/03C9h)
	CX:DX -> DAC register virtualization buffer (see #3279)
		or 0000h:0000h to disable
Return: CF clear

(Table 3197)
Values for calling QEMM QPI function 130Bh:
	AX = 130Bh ???
	BL = ??? (??? or 00h)
Return: CF clear
	???
Note:	calls AX=130Eh in some cases

(Table 3198)
Values for calling QEMM QPI function 130Ch:
	AX = 130Ch set interrupts to mask
	BX = interrupts to mask out during AX=1302h,AX=1307h,AX=1308h,
	      AX=130Dh,AX=1310h (BL = master PIC, BH = slave PIC)
Return: CF clear

(Table 3199)
Values for calling QEMM QPI function 130Dh:
	AX = 130Dh map EGA memory at A0000h
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #3198) and runs inside a QEMM critical section
	calls AX=1307h (see #3193)

(Table 3200)
Values for calling QEMM QPI function 130Eh:
	AX = 130Eh ??? (modifies CRT controller setup)
	???
Return: CF clear

(Table 3201)
Values for calling QEMM QPI function 130Fh:
	AX = 130Fh reset ???
Return: CF clear

(Table 3202)
Values for calling QEMM QPI function 1310h:
	AX = 1310h copy modified pages to physical video RAM???
	???
Return: CF clear
Note:	disables certain interrupts at the two 8259 PICs during execution
	  (see #3198) and runs inside a QEMM critical section
	also calls AX=130Dh (see #3199)

(Table 3203)
Values for calling QEMM QPI function 1311h:
	AX = 1311h set ???
	BL = zero/nonzero???
Return: CF clear
Note:	certain operations will be performed with interrupts
	  (as set by AX=130Ch) enabled rather than disabled if
	  called with BL nonzero

(Table 3204)
Values for calling QEMM QPI function 1312h:
	AX = 1312h (v6.02) NOP???
Note:	called by DV 2.42, but appears to be a NOP in QEMM 6.02

(Table 3205)
Values for calling QEMM QPI function 1400h:
	AX = 1400h initialize DESQview "protection level" support
	ES:DI -> protection level configuration (at least 24 bytes)
		(see #3273)
	BL = highest ??? to return (one less than number of words)
Return: CF clear
	AX = ??? (4204h for v6.00)
Note:	QEMM also sets the protected mode INT 02 and INT 06
	  vectors to alternate handlers in certain cases

(Table 3206)
Values for calling QEMM QPI function 1401h:
	AX = 1401h turn off DESQview protection level support
		Return: CF clear
			???
		Notes:	clears the DV critical-section flag address set with
			  function 1306h
			QEMM also sets the protected mode INT 02 and INT 06
			  vectors to the default handlers if they had been
			  revectored by function 1400h

(Table 3207)
Values for calling QEMM QPI function 1402h:
	AX = 1402h set protection level???
		BL = protection level???
		    00h NOP
		    01h ???
		    02h ???
		    other (03h) ???
		ES:DI -> ???
		Return: CF clear
			???
		Format of Data structure:
		Offset	Size	Description
		 00h	WORD	segment of ??? (X, word at X:0136h set to X)
		 02h	WORD	segment of ??? (word at X:0124h set to this)
		 04h	WORD	number of paragraphs of ???
		 06h  3 WORDs	??? (copied to X:0000h)
		 0Ch	WORD	???

(Table 3208)
Values for calling QEMM QPI function 1403h:
	AX = 1403h add ??? to end of list and ??? (execute func 1406h)
		ES:DI -> ??? structure added to end of ??? list
			(at least 31 bytes, DWORD at offset 06h used for
			 storing pointer to next struc, WORD at offset 00h
			 seems to be a key or index)
		Return: CF clear

(Table 3209)
Values for calling QEMM QPI function 1404h:
	AX = 1404h NOP
		Return: CF clear

(Table 3210)
Values for calling QEMM QPI function 1405h:
	AX = 1405h remove ??? from ??? list
		BX = key???
		Return: CF clear

(Table 3211)
Values for calling QEMM QPI function 1406h:
	AX = 1406h ???
		???
		Return: CF clear
			???
		Notes:	this function is a NOP unless protection level 2 or 3
			  is active
			when not a NOP, one of the actions is to write-protect
			  certain memory pages

(Table 3212)
Values for calling QEMM QPI function 1407h:
	AX = 1407h ???
		???
		Return: CF clear
			???
		Note:	same as function 1406h, but only does anything if
			  protection level 2 is active

(Table 3213)
Values for calling QEMM QPI function 1408h:
	AX = 1408h unprotect???
		???
		Return: CF clear
			???

(Table 3214)
Values for calling QEMM QPI function 1409h:
	AX = 1409h abort program causing protection violation???
		???
		Return: CF clear
			???

(Table 3215)
Values for calling QEMM QPI function 140Ah:
	AX = 140Ah set ???
		BX = index of ???
		Return: CF clear
			???
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 3216)
Values for calling QEMM QPI function 140Bh:
	AX = 140Bh get ???
		BX = index of ???
		SI = 0000h
		Return: CF clear
			SI = segment of 256-byte buffer??? or 0000h
		Notes:	no range checking is performed on BX
			this function is a NOP unless protection level 3 active

(Table 3217)
Values for calling QEMM QPI function 15h:
	AH = 15h set timer channel 0 virtualization buffer
		ES:BX -> WORD buffer for timer channel 0 divisor
			0000h:0000h to disable virtualization
		Return: CF clear

(Table 3218)
Values for calling QEMM v5.00+ QPI function 1600h:
	AX = 1600h get memory access status
		ES:DI -> 256-byte buffer
		Return: ES:DI buffer filled
		Note:	each byte of the buffer indicates the status of a 4K
			  page (bit 0 set if read, bit 1 set if written)

(Table 3219)
Values for calling QEMM v5.00+ QPI function 1601h:
	AX = 1601h set memory access status
		ES:DI -> 256-byte buffer containing access statuses (see #3218)

(Table 3220)
Values for calling QEMM v5.00+ QPI function 17h:
	AH = 17h get memory usage statistics
		ES:DI -> 81-byte buffer for memory statistics (see #3277)
		Return: CF clear

(Table 3221)
Values for calling QEMM v5.11+ QPI function 18h:
	AH = 18h check whether conventional memory mapped into address range
		ES:BX = starting address
		CX = number of 4K pages
		Return: CF clear
			AL = 00h one or more pages is remapped
			     01h all pages in range are conventional memory
				(physical address == virtual address)

(Table 3222)
Values for calling QEMM v5.11+ QPI function 19h:
	AH = 19h NOP
		Return: CF set

(Table 3223)
Values for calling QEMM v5.11+ "QPI_UntrappedIORead" function:
	AX = 1A00h get byte from I/O port
	DX = port number
Return: CF clear
	BL = port value
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3224)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWrite" function:
	AX = 1A01h send byte to I/O port
	BL = value to send
	DX = port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3225)
Values for calling QEMM v5.11+ "QPI_UntrappedIOReadIndexed" function:
	AX = 1A02h
	BH = index value to send
	DX = base port number
Return: CF clear
	BL = value read from I/O port (DX+1)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3226)
Values for calling QEMM v5.11+ "QPI_UntrappedIOWriteIndexed" function:
	AX = 1A03h send bytes to two consecutive I/O ports
	BH = value for first I/O port (DX)
	BL = value for second I/O port (DX+1)
	DX = base port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3227)
Values for calling QEMM v7.03+ "QPI_UntrappedIO" function:
	AX = 1A04h
	BX = value to write to port
	CX = direction and size
	    bit 2: output instead of input
	    bit 3: word instead of byte
	DX = I/O port to be accessed
Return: CF clear
	BX = value read (if CX indicates read)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3228)
Values for calling QEMM v7.03+ function 1A05h
	AX = 1A05h
	???
Return: ???

(Table 3229)
Values for calling QEMM v7.03+ "QPI_GetIOCallback" function:
	AX = 1A06h
Return: CF clear
	ES:DI -> current I/O callback function (see #3231)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3230)
Values for calling QEMM v7.03+ "QPI_SetIOCallback" function:
	AX = 1A07h
	ES:DI -> new I/O callback function (see #3231)
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3231)
Values QEMM v7.03+ I/O callback function is called with:
	AL/AX = data to/from trapped port
	CL = I/O direction (00h = IN instruction, else OUT instruction)
	DX = I/O port address
Return: CF clear if port handled by callback function
	CF set if not handled
	all other registers returned to application executing the IN or OUT
	  instruction (allowing arbitrary changes to port address, data value,
	  etc.)
SeeAlso: #3229,#3230

(Table 3232)
Values for calling QEMM v7.03+ "QPI_GetPortTrap" function:
	AX = 1A08h
	DX = I/O port number
Return: CF clear
	BL = trapping state (00h not being trapped, 01h trap installed)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3233)
Values for calling QEMM v7.03+ "QPI_SetPortTrap" function:
	AX = 1A09h
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3234)
Values for calling QEMM v7.03+ "QPI_ClearPortTrap" function:
	AX = 1A0Ah
	DX = I/O port number
Return: CF clear
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3235)
Values for calling QEMM v5.11+ QPI function 1B00h:
	AX = 1B00h get EMM Import Structure address
	ES:DI -> buffer for EMM import data structure (see #3275)
Return: CF set on error
	CF clear if successful
SeeAlso: INT 21/AX=4402h/SF=01h

(Table 3236)
Values for calling QEMM v5.11+ QPI function 1B01h:
	AX = 1B01h disable V86 mode
Return: CF set on error
	    (i.e. no Global EMM Import rec. allocated)
	CF clear if successful
Note:	shuts down EMS and initializes Global EMM Import record; this function
	  is invoked from the callback supplied by INT 2F/AX=1605h

(Table 3237)
Values for calling QEMM v5.11+ QPI function 1B02h:
	AX = 1B02h enable V86 mode
Return: CF set on error
	CF clear if successful
Note:	restarts EMS and frees Global EMM Import record; this function is
	  invoked from the callback supplied by INT 2F/AX=1605h

(Table 3238)
Values for calling QEMM v5.11+ QPI function 1B03h:
	AX = 1B03h MS Windows initializing
	CX = segment from which Windows init broadcast made???
	DX = Windows startup flags
	DI = Windows version number (major in upper byte)
Return: CF clear if successful
	    DS:SI -> V86 mode enable/disable callback
		  (see #2282 at INT 2F/AX=1605h)
	    ES:BX -> startup info structure (see #2279 at INT 2F/AX=1605h)
	CF set on error (unable to start Windows)
SeeAlso: INT 2F/AX=1605h

(Table 3239)
Values for calling QEMM v5.11+ QPI function 1B04h:
	AX = 1B04h MS Windows terminating
Return: CF clear

(Table 3240)
Values for calling QEMM v5.11+ QPI function 1B05h:
	AX = 1B05h determine whether program is driver
	DS:DX -> ASCIZ filename
Return: CF clear
	AL = status
	    01h if string ends in ".DRV"
	    FFh if string ends in "GDI.EXE"
	    00h otherwise
Note:	when MS Windows 3.0 standard mode starts, QEMM patches all drivers
	  until GDI.EXE is loaded

(Table 3241)
Values for calling QEMM v5.11+ QPI function 1B06h:
	AX = 1B06h patch protected-mode check in Windows driver
	CX = length of data pointed at by DS:DX
	DS:DX -> buffer containing Windows driver code
Return: CF clear
Note:	patches all SMSW x/TEST x,1 instruction sequences into MOV x,CS/VERW x
	  sequences, which has the effect that the protected-mode check will
	  only indicate protected mode in native protected mode and not in V86
	  mode

(Table 3242)
Values for calling QEMM v5.11+ QPI function 1B07h:
	AX = 1B07h
BUG: QEMM 6.00-7.01 accept this and branch randomly

(Table 3243)
Values for calling QEMM v5.11+ QPI function 1Bxxh:
	AX = 1B08h to 1BFFh
Return: CF set

(Table 3244)
Values for calling QEMM v5.11+ QPI function 1C00h:
	AX = 1C00h disable IRQ0-7 calldowns
Return: CF clear

(Table 3245)
Values for calling QEMM v5.11+ QPI function 1C01h:
	AX = 1C01h set V86-mode IRQ0-7 handlers
	ES:DI -> 8 DWORDs containing V86-mode handler addresses
Return: CF clear

(Table 3246)
Values for calling QEMM v5.11+ QPI function 1C02h:
	AX = 1C02h disable IRQ8-15 handlers
Return: CF clear

(Table 3247)
Values for calling QEMM v5.11+ QPI function 1C03h:
	AX = 1C03h set V86-mode IRQ8-15 handlers
	ES:DI -> 8 DWORDs containing V86-mode handler addresses
BUG:	although the jump table only contains four entries, QEMM 6.00 will
	  attempt to use it for any value of AL between 00h and 2Ah, thus
	  branching unpredictably for AL=04h-2Ah; QEMM v7.01 behaves
	  similarly for AL=04h-1Bh
Note:	when enabled, the appropriate IRQs are reflected back to the specified
	  handlers in virtual-86 mode after the CPU automatically invokes the
	  protected-mode handler inside QEMM

(Table 3248)
Values for calling QEMM v7.03+ "QPI_SimulateHWInt" function:
	AX = 1C04h
	BX = number of interrupt to simulate
Return: ???
Notes:	this function will allow proper simulation of a hardware interrupt
	  under DESQview and DESQview/X, where the correct interrupt handler
	  may be in a different process with a completely different address
	  space
	this function was officially documented with the release of QEMM v7.50

(Table 3249)
Values for calling QEMM v6.0x only QPI function 1D00h:
	AX = 1D00h switch to pre-Stealth interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	also switches VGA Save table pointer (0040h:00A8h) and overwrites the
	  vectors currently assigned for use by the two interrupt controllers
	  (see INT 67/AX=DE0Ah) with the vectors for INT 08-0F and 70-77 (to
	  avoid crashing the system).
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 3250)
Values for calling QEMM v6.0x only QPI function 1D01h:
	AX = 1D01h restore user interrupt vector table
Return: CF clear if supported (QEMM v6.x)
	CF set if not supported (QEMM v7+)
Notes:	interrupts should be disabled around the AX=1D00h and AX=1D01h calls
	  because QEMM does not modify the memory maps to map in ROM, so
	  an interrupt could be disastrous
	clears any pending IRQ7 at end of function
	functions 1Dxxh are not supported by QEMM v7.01, and always return CF
	  set

(Table 3251)
Values for calling QEMM v6.00+ QPI function 1Dxxh:
	AX = 1D02h to 1DFFh
Return: CF set

(Table 3252)
Values for calling QEMM v6.00+ "QEMM_GET_INFO"/"QPI_GetInfo" function:
	AX = 1E00h get Stealth configuration
Return: CF clear
	BL = memory configuration flags (documented as "reserved") (see #3276)
	BH = (v7.00+) disk buffer flags
	    bit 0: DISKBUFFRAME buffer instead of DISKBUF buffer
	    bit 1: buffer has already been used
	CL = stealth type (00h none, 46h Frame, 4Dh Map, 50h Protect)
	CH = suspend/resume interrupt (00h none)
	DL = (v7.00+) size of QEMM disk buffer in KB (00h none)
	DH = reserved (always 00h for v6.00)
	SI = reserved (always 0000h for v6.00)
	DI = reserved (always 0000h for v6.00)
Note:	this function is officially documented

(Table 3253)
Values for calling QEMM v6.00+ "QPI_GetStealthCount" function:
	AX = 1E01h get number of Stealth'ed ROMs
Return: CF clear
	BX = number of Stealth'ed ROMs
Note:	this function is officially documented

(Table 3254)
Values for calling QEMM v6.00+ "QPI_GetStealthList" function:
	AX = 1E02h
	ES:DI -> buffer for Stealth ROM info (see #3278)
Return: CF clear
	BX = number of Stealth'ed ROMs
	ES:DI buffer filled
Note:	this function is officially documented

(Table 3255)
Values for unimplemented Stealth information functions:
	AX = 1E03h to 1EFFh
Return: CF set


(Table 3256)
Values for calling QEMM v6.00+ "QEMM_GET_PTE"/"QPI_GetPTE" function:
	AX = 1F00h get page table entry
	CX = page number (0000h-010Fh)
Return: CF clear
	EDX = page table entry
Note:	this function is officially documented

(Table 3257)
Values for calling QEMM v6.00+ "QEMM_SET_PTE"/"QPI_SetPTE" function:
	AX = 1F01h set page table entry
	CX = page number (0000h-010Fh)
	EDX = new page table entry
Return: CF clear
Note:	this function is officially documented
SeeAlso: #3181

(Table 3258)
Values for calling QEMM v6.00+ QPI function 1Fxxh:
	AX = 1F02h to 1FFFh
Return: CF set

(Table 3259)
Values for calling QEMM v6.00+ "QEMM_GET_VHI_INFO"/"QPI_GetVHIInfo" function:
	AX = 2000h "QEMM_GET_VHI_INFO" get VirtualHDIRQ information
Return: CF clear
	BL = flags
	    bit 7: VirtualHDIRQ setting respected
		  (set if Stealth active)
	    bits 6-1 reserved
	    bit 0: VirtualHDIRQ currently enabled
		(INT 15/AH=90h suppressed when enabled)
Note:	this function is officially documented
SeeAlso: #3260

(Table 3260)
Values for calling QEMM v6.00+ "QEMM_SET_VHI_INFO"/"QPI_SetVHIInfo" function:
	AX = 2001h set VirtualHDIRQ state
	BL bit 0 = new VirtualHDIRQ state
Return: CF clear
	BL = old VHI setting (bits 0 and 7, see #3259)
Note:	this function is officially documented
SeeAlso: #3259

(Table 3261)
Values for calling QEMM v6.00+ QPI function 20xxh:
	AX = 2002h to 20FFh
Return: CF set

(Table 3262)
Values for calling QEMM v6.00+ "QEMM_COPY_STEALTH_ROMS"/"QPI_CopyStealthRoms":
	AX = 2100h copy data from Stealthed address space
	DS:SI -> start address of hidden memory to copy
	ES:DI -> buffer for copied data
	ECX = number of bytes to copy
Return: CF clear if successful
	CF set on error (no Stealth or DS:SI < C000h:0000h or DS:SI + ECX > 1M)
Note:	this function was officially documented with the release of QEMM 7.50

(Table 3263)
Values for calling QEMM v6.00+ QPI function 21xxh:
	AX = 2101h to 21FFh
Return: CF set

(Table 3264)
Values for calling QEMM v6.03+ QPI function 2200h:
	AX = 2200h DESQview/X support -- get ???
Return: CF clear
	ES:DI -> ???

(Table 3265)
Values for calling QEMM v6.03+ QPI function 2201h:
	AX = 2201h DESQview/X support -- set ???
	ES:DI -> ??? or 0000h:0000h
Return: CF clear if successful
	CF set on error

(Table 3266)
Values for calling QEMM v6.04+ QPI function 2300h:
	AX = 2300h get ???
	BX = which ??? to get (must be 0000h for v6.04)
Return: CF clear if successful
	    ES:DI -> ???
	CF set on error

(Table 3267)
Values for calling QEMM v6.04+ QPI function 2301h:
	AX = 2301h set ???
	BX = which ??? to set (must be 0000h for v6.04)
	ES:DI -> ???
Return: CF clear if successful
	CF set on error

(Table 3268)
Values for calling QEMM v6.04+ QPI function 2302h:
	AX = 2302h clear specified ???
	BX = which ??? to clear (must be 0000h for v6.04)
Return: CF clear if successful
	CF set on error

(Table 3269)
Values for calling QEMM v6.04+ QPI function 23FFh:
	AX = 23FFh clear all ???
Return: CF clear if successful
	CF set on error

(Table 3270)
Values for calling QEMM v6.04+ QPI function 23xxh:
	AX = 2303h to 23FEh
Return: CF set

(Table 3271)
Values for calling QEMM v7.01+ QPI function 24h:
	AH = 24h ST-DBL support
	AL = subfunction
	    00h set ???
		EDX -> information table (EDX = segment SHL 16 + offset)
	    01h ???
Return: CF clear if successful
	CF set on error

(Table 3272)
Values for calling QEMM unimplemented QPI functions:
	AH = 25h to FFh
Return: CF set

Format of QEMM protection level configuration:
Offset	Size	Description	(Table 3273)
 00h	WORD	segment of 128 breakpoint (INT 3) instructions for use in
		  DESQview protection level 3 interrupt vector checking, or
		  0000h to disable; in pl3, INTs 00-7F are pointed at these
		  breakpoints
 02h	DWORD	-> array of actual interrupt handler addresses for INT 00-7F
		  when interrupt vectors are pointed at protection level 3
		  breakpoints
 06h	DWORD	far pointer to ??? region list (see #3274)
 0Ah	DWORD	far pointer to buffer for returned ???
 0Eh	DWORD	seg:ofs of function to call on protection violation???
 12h	WORD	segment of ???
 14h	DWORD	far pointer to DWORD containing number of paragraphs of
		  ??? for segment at offset 12h
	???

Format of protection level Region List:
Offset	Size	Description	(Table 3274)
 00h	WORD	number of PAIRS of pointers to follow
 02h 2N DWORDs	start/end seg:ofs addresses of ??? regions
Note:	QEMM converts the segmented addresses into linear addresses in place

Format of EMM Import structure:
Offset	Size	Description	(Table 3275)
 00h	DWORD	physical address of EMM import struct
 04h	BYTE	major version (v6.00 sets to 01h)
 05h	BYTE	minor version (v6.00 sets to 00h/0Bh)
SeeAlso: INT 21/AX=4402h/SF=01h

Bitfields for memory configuration flags:
Bit(s)	Description	(Table 3276)
 0	conventional memory sorted
 1	conventional memory filled
 2	???
 3	???
 4	expanded memory is in use
 5	???

Format of QEMM 6.0 memory statistics:
Offset	Size	Description	(Table 3277)
 00h	BYTE	01h if Shadow RAM found, 00h otherwise
 01h	DWORD	initial conventional memory in bytes
 05h	DWORD	initial extended memory in bytes
 09h	DWORD	initial expanded memory in bytes
 0Dh	DWORD	initial "top" or "shadow" memory in bytes
 11h	DWORD	Unavailable conventional memory in bytes
 15h	DWORD	Unavailable extended memory in bytes
 19h	DWORD	Unavailable expanded memory in bytes
 1Dh	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 49h for Total unavailable top/shadow.
 21h	DWORD	QEMM code size in bytes
 25h	DWORD	QEMM data size in bytes
 29h	DWORD	bytes used for TASKS=
 2Dh	DWORD	DMA buffer size
 31h	DWORD	bytes used for MAPS=
 35h	DWORD	bytes of high RAM
 39h	DWORD	bytes used by mapped ROMs
 3Dh	DWORD	bytes of conventional memory provided by QEMM
 41h	DWORD	bytes of extended memory NOT converted by QEMM (EXT=xxx)
 45h	DWORD	bytes of EMS/XMS pool memory provided by QEMM
 49h	DWORD	Unavailable "top" or "shadow" memory in bytes
		Add to offset 1Dh for Total unavailable top/shadow.
 4Dh	DWORD	conventional memory overhead in bytes
		(set to 0 by QEMM.COM prior to call)

Format of Stealth ROM info [array]:
Offset	Size	Description	(Table 3278)
 00h	WORD	starting segment of ROM
 02h	WORD	length of ROM in paragraphs

Format of QEMM EGA/VGA DAC register virtualization buffer:
Offset	Size	Description	(Table 3279)
 00h	BYTE	(temp) current color register number
 01h	BYTE	(temp) number of bytes written so far for current color reg
 02h 768 BYTEs	three bytes per color register
--------m-6740-------------------------------
INT 67 - LIM EMS - GET MANAGER STATUS
	AH = 40h
Return: AH = status (00h,80h,81h,84h) (see #3280)
Note:	this call can be used only after establishing that the EMS driver is in
	  fact present
SeeAlso: AH=3Fh,AX=FFA5h,@xxxxh:xxxxh"PMM"

(Table 3280)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 83h	invalid handle
 84h	undefined function requested by application
 85h	no more handles available
 86h	error in save or restore of mapping context
 87h	insufficient memory pages in system
 88h	insufficient memory pages available
 89h	zero pages requested
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Ch	page-mapping hardware state save area is full
 8Dh	save of mapping context failed
 8Eh	restore of mapping context failed
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register or DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A0h	no such handle name
 A1h	a handle found had no name, or duplicate handle name
 A2h	attempted to wrap around 1M conventional address space
 A3h	source array corrupted
 A4h	operating system denied access
--------m-6741-------------------------------
INT 67 - LIM EMS - GET PAGE FRAME SEGMENT
	AH = 41h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = segment of page frame
SeeAlso: AH=58h,AH=68h
--------m-6742-------------------------------
INT 67 - LIM EMS - GET NUMBER OF PAGES
	AH = 42h
Return: AH = status (see also AH=40h)
	    00h function successful
		BX = number of unallocated pages
		DX = total number of pages
BUG:	DOS 6.0 EMM386.EXE causes a system lock-up or reboot if in AUTO mode
	  when this call is made; use AH=46h to ensure that EMM386 is ON
	  before making this call
SeeAlso: INT 2F/AX=2702h
--------m-6743-------------------------------
INT 67 - LIM EMS - GET HANDLE AND ALLOCATE MEMORY
	AH = 43h
	BX = number of logical pages to allocate
Return: AH = status (00h,80h,81h,84h,85h,87h,88h,89h) (see #3280)
	DX = handle if AH=00h
SeeAlso: AH=45h
--------u-674321-----------------------------
INT 67 - Q87 v4+ - INSTALLATION CHECK
	AX = 4321h
	EAX = 87654321h (entire EAX value required)
Return: EAX = 12345678h if Q87 is installed
Note:	this call requires that VCPI services be available; if they are not,
	  this call will not be recognized
BUG:	v4.00-v4.03 will hang on most machines when run under bare DOS with
	  no memory manager, because neither Q87 nor UNLOAD87 checks whether
	  there is a valid INT 67 handler before performing an installation
	  check via INT 67
SeeAlso: AX=2833h,INT 21/AX=4321h
--------m-6744-------------------------------
INT 67 - LIM EMS - MAP MEMORY
	AH = 44h
	AL = physical page number (0-3)
	BX = logical page number
	    or FFFFh to unmap (QEMM)
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh) (see #3280)
SeeAlso: AH=69h
--------m-6745-------------------------------
INT 67 - LIM EMS - RELEASE HANDLE AND MEMORY
	AH = 45h
	DX = EMM handle
Return: AH = status (00h,80h,81h,83h,84h,86h) (see #3280)
SeeAlso: AH=43h
--------m-6746-------------------------------
INT 67 - LIM EMS - GET EMM VERSION
	AH = 46h
Return: AH = status (00h,80h,81h,84h) (see #3280)
	AL = EMM version number if AH=00h
--------m-6747-------------------------------
INT 67 - LIM EMS - SAVE MAPPING CONTEXT
	AH = 47h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Ch-8Eh) (see #3280)
SeeAlso: AH=48h
--------m-6748-------------------------------
INT 67 - LIM EMS - RESTORE MAPPING CONTEXT
	AH = 48h
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Eh) (see #3280)
SeeAlso: AH=47h
--------m-6749-------------------------------
INT 67 - LIM EMS - reserved - GET I/O PORT ADDRESSES
	AH = 49h
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
--------m-674A-------------------------------
INT 67 - LIM EMS - reserved - GET TRANSLATION ARRAY
	AH = 4Ah
Note:	defined in EMS 3.0, but undocumented in EMS 3.2
--------m-674B-------------------------------
INT 67 - LIM EMS - GET NUMBER OF EMM HANDLES
	AH = 4Bh
Return: AH = status (00h,80h,81h,83h,84h) (see #3280)
	BX = number of EMM handles if AH=00h
--------m-674C-------------------------------
INT 67 - LIM EMS - GET PAGES OWNED BY HANDLE
	AH = 4Ch
	DX = EMM handle
Return: AH = status (see #2433)
	BX = number of logical pages if AH=00h
SeeAlso: AH=4Dh
--------m-674D-------------------------------
INT 67 - LIM EMS - GET PAGES FOR ALL HANDLES
	AH = 4Dh
	ES:DI -> array to receive information
Return: AH = status (00h,80h,81h,84h) (see #3280)
	---if AH=00h---
	BX = number of active EMM handles
	array filled with 2-word entries, consisting of a handle and the
	  number of pages allocated to that handle
SeeAlso: AH=4Ch
--------m-674E-------------------------------
INT 67 - LIM EMS - GET OR SET PAGE MAP
	AH = 4Eh
	AL = subfunction
	    00h get mapping registers
	    01h set mapping registers
	    02h get and set mapping registers at once
	    03h get size of page-mapping array
	DS:SI -> array holding information (AL=01h/02h)
	ES:DI -> array to receive information (AL=00h/02h)
Return: AH = status (00h,80h,81h,84h,8Fh,A3h) (see also AH=40h)
	    00h successful
		AL = bytes in page-mapping array (AL=03h only)
		array pointed to by ES:DI receives mapping info (AL=00h/02h)
Notes:	this function was designed to be used by multitasking operating systems
	  and should not ordinarily be used by appplication software.
	MD386 returns the size of the page-mapping array in AX instead of AL
SeeAlso: AH=4Fh
--------m-674F-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET PARTIAL PAGE MAP
	AH = 4Fh
	AL = subfunction
	    00h get partial page map
	       DS:SI -> structure containing list of segments whose mapping
			contexts are to be saved
	       ES:DI -> array to receive page map
	    01h set partial page map
	       DS:SI -> structure containing saved partial page map
	    02h get size of partial page map
	       BX = number of mappable segments in the partial map to be saved
Return: AH = status (00h,80h,81h,84h,8Bh,8Fh,A3h) (see also AH=40h)
	    8Bh one of the specified segments is not mappable
	    A3h contents of partial page map corrupted or count of mappable
		segments exceeds total number of mappable segments in system
	AL = size of partial page map for subfunction 02h
SeeAlso: AH=4Eh
--------m-6750-------------------------------
INT 67 - LIM EMS 4.0 - MAP/UNMAP MULTIPLE HANDLE PAGES
	AH = 50h
	AL = subfunction
	    00h use physical page numbers
	    01h use segment addresses
	DX = handle
	CX = number of entries in array
	DS:SI -> mapping array (see #3281)
Return: AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #3280)
SeeAlso: AH=40h

Format of EMS mapping array entry:
Offset	Size	Description	(Table 3281)
 00h	WORD	logical page number or FFFFh to unmap physical page
 02h	WORD	physical page number or segment address
--------m-6751-------------------------------
INT 67 - LIM EMS 4.0 - REALLOCATE PAGES
	AH = 51h
	DX = handle
	BX = number of pages to be allocated to handle
Return: AH = status (00h,80h,81h,83h,84h,87h,88h) (see #3282)
	BX = actual number of pages allocated to handle

(Table 3282)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 83h	invalid handle
 84h	undefined function requested
 87h	more pages requested than present in system
 88h	more pages requested than currently available
 8Ah	invalid logical page number encountered
 8Bh	invalid physical page number encountered
 8Fh	undefined subfunction
 90h	undefined attribute type
 91h	feature not supported
 A0h	no such handle name
 A1h	duplicate handle name
--------m-6752-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE ATTRIBUTES
	AH = 52h
	AL = subfunction
	    00h get handle attributes
		Return: AL = attribute
			    00h handle is volatile
			    01h handle is nonvolatile
	    01h set handle attributes
		BL = new attribute
		   00h handle is volatile
		   01h handle is nonvolatile
	    02h get attribute capability
		Return: AL = attribute capability
			    00h only volatile handles supported
			    01h both volatile and non-volatile supported
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh-91h) (see #3280)
SeeAlso: AH=53h
--------m-6753-------------------------------
INT 67 - LIM EMS 4.0 - GET/SET HANDLE NAME
	AH = 53h
	AL = subfunction
	    00h get handle name
	       ES:DI -> 8-byte buffer for handle name
	    01h set handle name
	       DS:SI -> 8-byte handle name
	DX = handle
Return: AH = status (00h,80h,81h,83h,84h,8Fh,A1h) (see #3280)
SeeAlso: AH=52h
--------m-6754-------------------------------
INT 67 - LIM EMS 4.0 - GET HANDLE DIRECTORY
	AH = 54h
	AL = subfunction
	    00h get handle directory
	       ES:DI -> buffer for handle directory (see #3283)
	    01h search for named handle
	       DS:SI -> 8-byte name
	    02h get total number of handles
Return: AL = number of entries in handle directory (subfunction 00h)
	DX = value of named handle (subfunction 01h)
	BX = total number of handles (subfunction 02h)
	AH = status (00h,80h,81h,84h,8Fh,A0h,A1h) (see also #3282)
	    A1h a handle found had no name

Format of EMS handle directory entry:
Offset	Size	Description	(Table 3283)
 00h	WORD	handle
 02h  8 BYTEs	handle's name
--------m-6755-------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND JUMP
	AH = 55h
	AL = subfunction
	    00h physical page numbers provided by caller
	    01h segment addresses provided by caller
	DX = handle
	DS:SI -> structure containing map and jump address
Return: (at target address unless error)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #3280)
SeeAlso: AH=56h
--------m-6756-------------------------------
INT 67 - LIM EMS 4.0 - ALTER PAGE MAP AND CALL
	AH = 56h
	AL = subfunction
	    00h physical page numbers provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    01h segment addresses provided by caller
		DX = handle
		DS:SI -> structure containing page map and call address
	    02h get page map stack space required
		Return: BX = stack space required
Return: (if successful, the target address is called.  Use a RETF to return
	 and restore mapping context)
	AH = status (00h,80h,81h,83h,84h,8Ah,8Bh,8Fh) (see #3280)
SeeAlso: AH=55h
--------m-6756FF-----------------------------
INT 67 - RM386 v6.00 - ???
	AX = 56FFh
	DS:SI -> ???
	???
Return: ???
--------m-6757-------------------------------
INT 67 - LIM EMS 4.0 - MOVE/EXCHANGE MEMORY REGION
	AH = 57h
	AL = subfunction
	    00h move memory region
	    01h exchange memory region
	DS:SI -> structure describing source and destination (see #3285)
Return: AH = status (see #3284)
Note:	source and destination may overlap for a move, in which case the copy
	  direction is chosen such that the destination receives an intact copy
	  of the source region

(Table 3284)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware failure
 83h	invalid handle
 84h	undefined function requested
 8Ah	invalid logical page number encountered
 8Fh	undefined subfunction
 92h	successful, but a portion of the source region has been overwritten
 93h	length of source or destination region exceeds length of region
	  allocated to either source or destination handle
 94h	conventional and expanded memory regions overlap
 95h	offset within logical page exceeds size of logical page
 96h	region length exceeds 1M
 97h	source and destination EMS regions have same handle and overlap
 98h	memory source or destination type undefined
 A2h	attempted to wrap around 1M conventional address space

Format of EMS copy data:
Offset	Size	Description	(Table 3285)
 00h	DWORD	region length in bytes
 04h	BYTE	source memory type
		00h conventional
		01h expanded
 05h	WORD	source handle (0000h if conventional memory)
 07h	WORD	source initial offset (within page if EMS, segment if convent)
 09h	WORD	source initial segment (conv mem) or logical page (EMS)
 0Bh	BYTE	destination memory type
		00h conventional
		01h expanded
 0Ch	WORD	destination handle
 0Eh	WORD	destination initial offset
 10h	WORD	destination initial segment or page
--------m-6758-------------------------------
INT 67 - LIM EMS 4.0 - GET MAPPABLE PHYSICAL ADDRESS ARRAY
	AH = 58h
	AL = subfunction
	    00h get mappable physical address array
		ES:DI -> buffer to be filled with array (see #3286)
	    01h get number of entries in m.p.a. array
Return: CX = number of entries in array
	AH = status (00h,80h,81h,84h,8Fh) (see #3284)
Note:	the returned array for subfunction 00h is filled in physical segment
	  address order

Format of EMS mappable physical address entry:
Offset	Size	Description	(Table 3286)
 00h	WORD	physical page segment
 02h	WORD	physical page number
--------m-675857-----------------------------
INT 67 U - NETROOM??? - ???
	AX = 5857h
	BX = function??? (0057h,0059h,0159h seen)
	???
Return: ???
Note:	BX=0059h appears to be analogous to AX=5800h and BX=0159h appears to
	  be analogous to AX=5801h; BX=0057h appears to indicate whether
	  AX=580xh or AX=5857h/BX=0x59h should be used
SeeAlso: AX=5BF0h
--------m-6759-------------------------------
INT 67 - LIM EMS 4.0 - GET EXPANDED MEMORY HARDWARE INFORMATION
	AH = 59h
	AL = subfunction
	    00h get hardware configuration array
		ES:DI -> buffer to be filled with array (see #3287)
	    01h get unallocated raw page count
		Return: BX = unallocated raw pages
			DX = total raw pages
Return: AH = status (see also AH=58h"EMS 4.0")
	    A4h access denied by operating system
Note:	subfunction 00h is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

Format of EMS hardware configuration array:
Offset	Size	Description	(Table 3287)
 00h	WORD	size of raw EMM pages in paragraphs
 02h	WORD	number of alternate register sets
 04h	WORD	size of mapping-context save area in bytes
 06h	WORD	number of register sets assignable to DMA
 08h	WORD	DMA operation type
		0000h DMA with alternate register sets
		0001h only one DMA register set
--------m-675A-------------------------------
INT 67 - LIM EMS 4.0 - ALLOCATE STANDARD/RAW PAGES
	AH = 5Ah
	AL = subfunction
	    00h allocate standard pages
	    01h allocate raw pages
	BX = number of pages to allocate
Return: DX = handle
	AH = status (00h,80h,81h,84h,85h,87h,88h,8Fh) (see #3280)
--------m-675B-------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET
	AH = 5Bh
	AL = subfunction
	    00h get alternate map register set
		Return: BL = current active alternate map register set number
			ES:DI -> map register context save area if BL=00h
	    01h set alternate map register set
		BL = new alternate map register set number
		ES:DI -> map register context save area if BL=0
	    02h get alternate map save array size
		Return: DX = array size in bytes
	    03h allocate alternate map register set
		Return: BL = number of map register set; 00h = not supported
	    04h deallocate alternate map register set
		BL = number of alternate map register set
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Dh,A3h,A4h) (see #3288)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system

(Table 3288)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested
 8Fh	undefined subfunction
 9Ah	specified alternate map register or DMA register set not supported
 9Bh	all alternate map register or DMA register sets currently allocated
 9Ch	alternate map register or DMA register sets not supported
 9Dh	undefined or unallocated alternate map register/DMA register set
 9Eh	dedicated DMA channels not supported
 9Fh	specified dedicated DMA channel not supported
 A3h	source array corrupted
 A4h	operating system denied access
--------m-675B-------------------------------
INT 67 - LIM EMS 4.0 - ALTERNATE MAP REGISTER SET - DMA REGISTERS
	AH = 5Bh
	AL = subfunction
	    05h allocate DMA register set
		Return: BL = DMA register set number, 00h if not supported
	    06h enable DMA on alternate map register set
	       BL = DMA register set number
	       DL = DMA channel number
	    07h disable DMA on alternate map register set
	       BL = DMA register set number
	    08h deallocate DMA register set
	       BL = DMA register set number
Return: AH = status (00h,80h,81h,84h,8Fh,9Ah-9Fh,A3h,A4h) (see #3288)
Note:	this function is for use by operating systems only, and can be
	  enabled or disabled at any time by the operating system
--------m-675BE0-----------------------------
INT 67 - MICEMM v4D, RM386 - GET LINEAR ADDRESS OF MEMORY
	AX = 5BE0h
	ES:BX -> memory for which to get linear address
Return: AH = 00h
	CX:DX = linear address of physical memory corresponding to ES:BX
Program: RAM-MAN/386 is the memory manager included with Helix's Netroom;
	  MICEMM is a memory manager for some Micronics motherboards
Note:	this has been superceded by AX=DE06h, which should be used instead
SeeAlso: AX=5BF0h,AX=5BF1h,AX=DE06h
--------m-675BE1-----------------------------
INT 67 - RM386 v6.00+ - GET MEMORY MANAGER SIZE
	AX = 5BE1h
Return: AH = 00h
	CX = code and data size in bytes
	DX:BX = physical address of RM386 code
	DI:SI = total size of RM386 area including handle tables
	BP = number of additional pages (high DOS, etc.)
SeeAlso: AX=5BE0h,AX=5BE2h
--------m-675BE2-----------------------------
INT 67 - RM386 v6.00+ - GET INTERRUPT VECTORS
	AX = 5BE2h
Return: DS:SI -> V86-mode table (see #3289)
	ES:BX -> ??? (undoc, middle of device driver interrupt routine!)
SeeAlso: AX=5BE0h,AX=5BE1h

Format of RM386 V86-mode table:
Offset	Size	Description	(Table 3289)
 00h	DWORD	original INT 13 vector
 04h	DWORD	original INT 15 vector
 08h	DWORD	original INT 19 vector
 0Ch	DWORD	original INT 21 vector
 10h	DWORD	original INT 4B vector
 14h	DWORD	original INT 67 vector
--------m-675BF0-----------------------------
INT 67 - MICEMM v4D, RM386 - INSTALLATION CHECK
	AX = 5BF0h
Return: AH = 00h if MICEMM or RM386 present
	    BX = code segment of driver
Program: MICEMM is the Micronics Expanded Memory Manager; RM386 is the memory
	  manager included in Helix Software's Netroom
SeeAlso: AH=3Fh,AX=5BE0h,AX=5BF1h
--------m-675BF1-----------------------------
INT 67 - MICEMM v4D, RM386 - GET ADDRESS MAP
	AX = 5BF1h
	ES:BX -> 256-byte (MICEMM) or 512-byte (RM386) buffer for memory types
Return: AH = 00h
	ES:BX buffer filled (see #3290)
Note:	each byte in the buffer specifies the type of a 4K page of memory
SeeAlso: AX=5BE0h,AX=5BF0h

(Table 3290)
Values for MICEMM/RM386 memory type:
 00h	unused (MICEMM), RAM/available (RM386)
 02h	DOS extension (XMS UMB)
 04h	shadowed ROM
 08h	mappable EMS
 10h	page frame
 20h	ROM
 40h	reserved (video memory, etc)
 80h	RAM (MICEMM), Windows UMB (RM386)
--------m-675BF2-----------------------------
INT 67 - RM386 - GET RM386 INTERNAL DATA
	AX = 5BF2h
	CX = size of buffer
	DS:SI -> buffer for internal data
	(documentation says ES:BX -> buffer, SI = offset within RM386)
Return: buffer filled
Note:	the data returned by this function is release-specific
SeeAlso: AX=5BF0h
--------m-675BF3-----------------------------
INT 67 - RM386 - RETURN TO REAL MODE
	AX = 5BF3h
Return: nothing
Note:	use AX=5DE0h instead of this functin
SeeAlso: AX=5BF0h,AX=5DE0h
--------m-675BF4-----------------------------
INT 67 - RM386 v6.00 - GET RM386 GLOBAL FLAGS
	AX = 5BF4h
Return: AH = 00h
	BX = global flags 1 (see #3291)
	CX = global flags 2 (see #3292)
	DX = global flags 3 (see #3293)
	SI = global flags 4 (see #3294)
SeeAlso: AX=5BF0h

Bitfields for RM386 global flags 1:
Bit(s)	Description	(Table 3291)
 0-3	reserved
 4	V86 mode
 5	reserved
 6	80386 or higher CPU
 7,8	reserved
 9	A20 enabled at startup
 10	"HIGH_IO"
 11	ROM
 12	large frame
 13,14	reserved
 15	PS/2-style A20 control

Bitfields for RM386 global flags 2:
Bit(s)	Description	(Table 3292)
 0	HMA in use
 1	XMS present
 2	using XMS driver memory
 3	HIGH (NEAT only)
 4-7	reserved
 8	NOBKTRAP
 9	NORESET
 10	ALTMAP
 11	NOFRAME
 12-15	reserved

Bitfields for RM386 global flags 3:
Bit(s)	Description	(Table 3293)
 0	NOTEST
 1	NOEBDA
 2	Windows3 support
 3	system board mouse
 4	DISKBUF
 5	EBDALOW
 6	A20 global enable flag
 7	A20 flag
 8	EBDA moved to stub
 9	VXD file was found
 10	reserved
 11	NOBOOTMAP
 12	AUTO
 13	PS/2 machine
 14	Compaq ROM merge active
 15	NOHMA set

Bitfields for RM386 global flags 4:
Bit(s)	Description	(Table 3294)
 0	"NOV8259" don't virtualize interrupt controller
 1	NOSCSI
 2	NOSCAN
 3	NOTR
 4	ALTBOOT
 5	NOCOMPQ
 6	KB2TRAP
 7	DESHADOW
 8	Video 7 VGA detected
 9	reserved
 10	NOVGA
 11	NOPS2
 12	DEBUG
 13	NOVKB
 14,15	reserved
--------m-675BF5-----------------------------
INT 67 - RM386 v6.00 - GET RM386 EMS HANDLE COUNT
	AX = 5BF5h
Return: AH = status
	    00h successful
		BX = current number of allocated EMS handles
	    84h function not available
SeeAlso: AX=5BF0h
--------m-675C-------------------------------
INT 67 - LIM EMS 4.0 - PREPARE EXPANDED MEMORY HARDWARE FOR WARM BOOT
	AH = 5Ch
Return: AH = status (see #3295)
Note:	when MS-DOS v6.xx EMM386 is loaded and the keyboard driver supports
	  INT 15/AH=4Fh (keyboard intercept) calls, the system may hang
	  instead of booting if this function is called just prior to a jump
	  to F000h:FFF0h

(Table 3295)
Values for EMS function status:
 00h	successful
 80h	internal error
 81h	hardware malfunction
 84h	undefined function requested
--------m-675D-------------------------------
INT 67 - LIM EMS 4.0 - ENABLE/DISABLE OS FUNCTION SET FUNCTIONS
	AH = 5Dh
	AL = subfunction
	    00h enable OS Function Set
	    01h disable OS Function Set
	    02h return access key (resets memory manager, returns access key at
		next invocation)
	BX,CX = access key returned by first invocation
Return: BX,CX = access key, returned only on first invocation of function
	AH = status (see also AH=5Ch)
	    8Fh undefined subfunction
	    A4h operating system denied access
--------m-675D03-----------------------------
INT 67 u - Nanosoft MD386 - INTERNAL INITIALIZATION
	AX = 5D03h
	???
Return: ???
Program: MD386 is a subset EMS memory manager by Nanosoft specifically
	  designed for use with the MultiDOS Plus multitasker
SeeAlso: AX=5D04h,AX=5E00h
--------m-675D04-----------------------------
INT 67 - Nanosoft MD386 - GET ALTERNATE MAP STRUCTURE
	AX = 5D04h
	BX = alternate register set number
	ES:DI -> 1024-byte buffer for map structure
Return: AH = status (see #3280)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D05h
--------m-675D05-----------------------------
INT 67 - Nanosoft MD386 - GET INTERNAL HANDLE TABLE
	AX = 5D05h
	BX = handle number
	ES:DI -> 1024-byte buffer for handle table
Return: AH = status (see #3280)
	buffer filled if AH=00h
Note:	used for debugging purposes
SeeAlso: AX=5D04h
--------m-675DE0-----------------------------
INT 67 - RM386 - DISABLE RM386
	AX = 5DE0h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE1h
--------m-675DE1-----------------------------
INT 67 - RM386 - ENABLE RM386
	AX = 5DE1h
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE0h
--------m-675DE2-----------------------------
INT 67 - RM386 - GET PAGE TABLE
	AX = 5DE2h
	ES:DI -> 1088-byte buffer for page table
Return: ES:DI buffer filled
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE3h
--------m-675DE3-----------------------------
INT 67 - RM386 - SET PAGE TABLE
	AX = 5DE3h
	ES:DI -> 1088-byte buffer containing page table
Notes:	only the access bits of the page table are used, the remainder is
	  ignored
	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE2h
--------m-675DE4-----------------------------
INT 67 - RM386 - SET WRITE-PROTECTION FOR PAGE IN FIRST MEGABYTE
	AX = 5DE4h
	BL = page number
	BH = access (00h read-only, 01h read-write)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
--------m-675DE5-----------------------------
INT 67 - RM386 - MAP PHYSICAL PAGE TO PHYSICAL SEGMENT
	AX = 5DE5h
	EBX = physical page number
	DX = page number in first megabyte to be remapped (linear-addr SHR 12)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE6h
--------m-675DE6-----------------------------
INT 67 - RM386 - MAP LOGICAL 4K PAGE TO PHYSICAL SEGMENT
	AX = 5DE6h
	BX = logical page number in 4K pages from beginning of memory for EMS
	      handle
	CX = segment in first megabyte to be remapped
	DX = previously-allocated EMS handle
Return: AH = status
	    00h successful
	    83h invalid handle
	    8Ah invalid logical page (out of handle's range)
	    8Bh invalid destination page (not in first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE5h
--------m-675DE7-----------------------------
INT 67 - RM386 - SET PAGE TABLE BITS FOR RANGE OF PAGES
	AX = 5DE7h
	BL = page table bits to be set (bits 2-0 = U/S, R/W, P)
	CX = number of pages to set
	DX = first page number to set (in first megabyte)
Return: AH = status
	    00h successful
	    8Bh invalid destination page (not in first megabyte)
	    A5h invalid page bits
	    A6h invalid page count (overflows first megabyte)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
--------m-675DE8-----------------------------
INT 67 - RM386 - GET PARTIAL PAGE TABLE
	AX = 5DE8h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	ES:DI -> buffer for DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE9h
--------m-675DE9-----------------------------
INT 67 - RM386 - SET PARTIAL PAGE TABLE
	AX = 5DE9h
	BX = starting page number in first megabyte+HMA (0000h-010Fh)
	CX = number of page table entries to get
	DS:SI -> buffer of DWORD page table entries
Return: AH = status (00h successful, 8Bh invalid destination page)
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DE8h
--------m-675DEA-----------------------------
INT 67 - RM386 - V86-MODE I/O PORT TRAPPING CONTROL
	AX = 5DEAh
	BX = function
	    00h globally disable V86-mode trapping
	    01h globally enable V86-mode trapping
		CL = interrupt to use for trapping
	    02h get I/O trapping state
Return: AH = status
	    00h successful
		BX = current trapping state (function 02h)
		    0000h disabled, 0001h enabled
		CX = interrupt used as trap interrupt (functions 00h and 02h)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
	when I/O trapping is enabled and I/O port access occurs, RM386
	  simulates an INT instruction for the specified interrupt; the
	  interrupt handler is responsible for decoding the trapped instruction
	  and performing the appropriate action.  INT 2C/AX=002Dh provides a
	  similar but more-easily used interface.
SeeAlso: AX=5DEBh,AH=EFh"RM386",INT 2C/AX=002Dh
--------m-675DEB-----------------------------
INT 67 - RM386 - V86-MODE I/O TRAPPING PORT CONTROL
	AX = 5DEBh
	BX = function
	    00h disable V86-mode trapping for specified port
	    01h enable V86-mode trapping for specified port
	    02h get V86-mode trapping state for specified port
	DX = port for which to enable/disable/query trapping
Return: AH = status
	    00h successful
		BX = current trapping state (00h off, 01h on) (function 02)
	    A7h invalid port ID
	    A8h reserved port--cannot trap/untrap (DMA/INT/KBD controllers)
Notes:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DEAh
--------m-675DFD-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFDh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFEh
--------m-675DFE-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFEh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh
--------m-675DFF-----------------------------
INT 67 U - RM386 v6.00 - ???
	AX = 5DFFh
	???
Return: ???
Note:	RM386 traps this function on the initial transition to protected
	  mode caused by the INT instruction, which means it can not be
	  overridden simply by hooking the interrupt
SeeAlso: AX=5DFDh,AX=5DFEh
--------m-675E00-----------------------------
INT 67 - Nanosoft MD386 - SET HARDWARE BREAKPOINT
	AX = 5E00h
	DH = breakpoint number (0-3)
	DL = breakpoint attributes (used to set DR7)
	CX:BX = linear address of breakpoint
SeeAlso: AX=5D03h,AX=5E01h
--------m-675E01-----------------------------
INT 67 - Nanosoft MD386 - GET HARDWARE DEBUG REGISTER
	AX = 5E01h
	BL = register number (0-3,7)
Return: CX:BX = value of specified DRx register
SeeAlso: AX=5E00h
--------m-675E02-----------------------------
INT 67 - Nanosoft MD386 - SET DEBUG EXCEPTION HANDLER
	AX = 5E02h
	CX:BX -> exception handler
Note:	the specified exception handler is called with a simulated interrupt
	  whenever a debug exception occurs which was caused by a hardware
	  breakpoint set with the debug registers
SeeAlso: AX=5E04h,AX=5E05h
--------m-675E03-----------------------------
INT 67 - Nanosoft MD386 - ENABLE/DISABLE MEMORY WRITE PROTECTION
	AX = 5E03h
	BL = register map set number
	BH = new state (00h read-only, else read-write)
	CX = linear page number (linear address SHR 12)
Note:	setting write protection in map set 0 will cause the setting to become
	  the default for newly-allocated map sets
--------m-675E04-----------------------------
INT 67 - Nanosoft MD386 - GET DEBUG EXCEPTION
	AX = 5E04h
Return: BL = debug exception (low byte of DR6 register)
SeeAlso: AX=5E02h,AX=5E05h
--------m-675E05-----------------------------
INT 67 - Nanosoft MD386 - IGNORE NEXT DEBUG EXCEPTION
	AX = 5E05h
Note:	may be required when using AX=5E02h for handling instruction
	  breakpoints
SeeAlso: AX=5E02h,AX=5E04h
--------m-6760-------------------------------
INT 67 - EEMS - GET PHYSICAL WINDOW ARRAY
	AH = 60h
	ES:DI -> buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled
--------m-6761-------------------------------
INT 67 - EEMS - GENERIC ACCELERATOR CARD SUPPORT
	AH = 61h
	???
Return: ???
Note:	can be used by accelerator card manufacturer to flush RAM cache,
	  ensuring that the cache accurately reflects what the processor would
	  see without the cache.
--------m-676100-----------------------------
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - INSTALLATION CHECK???
	AX = 6100h
Return: AH = status (00h if installed???)
Note:	STB's RAPIDMAP.SYS EMS driver calls this function and AX=6101h if
	  the signature "GACXXX" is found at offset 0Ah in the INT 67 handler's
	  segment (i.e. a device driver named GACXXX?? has hooked INT 67)
SeeAlso: AX=6101h,INT 02/SI=0714h
--------m-676101-----------------------------
INT 67 - EEMS - STB GENERIC ACCELERATOR CARD SUPPORT - GET ??? ENTRY POINT
	AX = 6101h
Return: AH = status
	---if AH=00h---
	ES:BX -> ??? entry point
SeeAlso: AX=6100h
--------m-6768-------------------------------
INT 67 - EEMS - GET ADDRESSES OF ALL PAGE FRAMES IN SYSTEM
	AH = 68h
	ES:DI -> buffer
Return: AH = status (see also AH=40h)
	AL = number of entries
	buffer at ES:DI filled
Note:	equivalent to LIM 4.0 function 58h
--------m-6769-------------------------------
INT 67 - EEMS - MAP PAGE INTO FRAME
	AH = 69h
	AL = frame number
	BX = page number
	DX = handle
Return: AH = status (see also AH=40h)
Note:	similar to EMS function 44h
SeeAlso: AH=44h,AH=50h,AH=6Ah
--------m-676A-------------------------------
INT 67 - EEMS - PAGE MAPPING
	AH = 6Ah
	AL = subfunction
	    00h save partial page map
		CH = first page frame
		CL = number of frames
		ES:DI -> buffer which is to be filled
	    01h restore partial page map
		CH = first page frame
		CL = number of frames
		DI:SI -> previously saved page map
	    02h save and restore partial page map
		CH = first page frame
		CL = number of frames
		ES:DI = buffer for current page map
		DI:SI = new page map
	    03h get size of save array
		CH = first page frame
		CL = number of frames
		Return: AL = size of array in bytes
	    04h switch to standard map register setting
	    05h switch to alternate map register setting
	    06h deallocate pages mapped to frames in conventional memory
		CH = first page frame
		CL = number of frames
Return: AH = status (see #3280)
Note:	similar to EMS function 4Eh, except that a subrange of pages can be
	  specified
SeeAlso: AH=69h
--------m-676B-------------------------------
INT 67 - DESQview 2.42-2.53 - BUG
	AH = 6Bh
Note:	the EMM.DVR portion of DESQview branches to a random location on this
	  function due to a fencepost error
--------m-67DD-------------------------------
INT 67 - Quadtel QMAPS - API
	AH = DDh
	AL = function
	???
Return: ???
Notes:	details are not yet available
	Hewlett-Packard's HPMM.SYS is a licensed version of QMAPS, and thus
	  supports this API
SeeAlso: AH=3Fh,AX=FFA5h
--------E-67DE00-----------------------------
INT 67 - Virtual Control Program Interface - INSTALLATION CHECK
	AX = DE00h
Return: AH = status
	    00h VCPI is present
		BH = major version number
		BL = minor version number
	    nonzero  VCPI not present
BUG:	MS Windows 3.00 is reported to "object violently" to this call.
SeeAlso: INT 2F/AX=1687h
--------E-67DE01-----------------------------
INT 67 - Virtual Control Program Interface - GET PROTECTED MODE INTERFACE
	AX = DE01h
	ES:DI -> 4K page table buffer
	DS:SI -> three descriptor table entries in GDT
		first becomes code segment descriptor, other two for use by
		  main control program
Return: AH = 00h successful
	    DI -> first unused page table entry in buffer
	    EBX -> protected mode entry point in code segment (see #3296)
	AH = nonzero  failed
Note:	protected mode entry point may be called with AX=DE00h-DE05h and
	  AX=DE0Ch (in each case, all other registers as appropriate for
	  the function)
SeeAlso: INT 2F/AX=1687h,INT 67/AH=3Fh

(Table 3296)
Call QEMM v6.03 protected mode entry point additionally with:
	AX = DF00h ???
		???
		Return: ???
	AX = DF01h ???
		???
		Return: ???
--------E-67DE02-----------------------------
INT 67 - Virtual Control Program Interface - GET MAX PHYSICAL MEMORY ADDRESS
	AX = DE02h
Return: AH = 00h  successful
	    EDX = physical address of highest 4K memory page
	AH nonzero: failed
SeeAlso: AH=3Fh
--------E-67DE03-----------------------------
INT 67 - Virtual Control Program Interface - GET NUMBER OF FREE 4K PAGES
	AX = DE03h
Return: AH = 00h  successful
	    EDX = number of free 4K pages
	AH nonzero: failed
Notes:	returns total number of pages available to ALL tasks in system
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#3296)
SeeAlso: AX=DE04h
--------E-67DE04-----------------------------
INT 67 - Virtual Control Program Interface - ALLOCATE A 4K PAGE
	AX = DE04h
Return: AH = 00h successful
	    EDX = physical address of allocated page
	AH nonzero: failed
Notes:	the client program is responsible for freeing all memory allocated
	  with this call before terminating
	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#3296)
SeeAlso: AH=3Fh,AX=DE03h,AX=DE05h
--------E-67DE05-----------------------------
INT 67 - Virtual Control Program Interface - FREE 4K PAGE
	AX = DE05h
	EDX = physical address of 4K page
Return: AH = status
	    00h successful
	    nonzero failed
Note:	also available in protected mode by calling the protected-mode VCPI
	  entry point (see AX=DE01h,#3296)
SeeAlso: AH=3Fh,AX=DE04h
--------E-67DE06-----------------------------
INT 67 - Virtual Control Program Interface - GET PHYS ADDR OF PAGE IN FIRST MB
	AX = DE06h
	CX = page number (linear address shifted right 12 bits)
Return: AH = status
	    00h successful
		EDX = physical address of page
	    nonzero invalid page number (AH = 8Bh recommended)
SeeAlso: AX=5BE0h
--------E-67DE07-----------------------------
INT 67 - Virtual Control Program Interface - READ CR0
	AX = DE07h
Return: AH = 00h
	EBX = value of Control Register 0
SeeAlso: AH=3Fh,AX=DE07h
--------E-67DE08-----------------------------
INT 67 - Virtual Control Program Interface - READ DEBUG REGISTERS
	AX = DE08h
	ES:DI -> array of 8 DWORDs
Return: AH = 00h
	buffer filled with DR0 first, DR7 last, DR4 and DR5 unused
SeeAlso: AH=3Fh,AX=DE09h
--------E-67DE09-----------------------------
INT 67 - Virtual Control Program Interface - SET DEBUG REGISTERS
	AX = DE09h
	ES:DI -> array of 8 DWORDs holding new values of debug registers
Return: AH = 00h
Note:	values for DR4 and DR5 ignored
SeeAlso: AH=3Fh,AX=DE08h
--------E-67DE0A-----------------------------
INT 67 - Virtual Control Program Interface - GET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Ah
Return: AH = 00h successful
	    BX = first vector used by master 8259 (IRQ0)
	    CX = first vector used by slave 8259 (IRQ8)
	AH nonzero: failed
Note:	CX is undefined in systems without a slave 8259
SeeAlso: AX=DE0Bh,INT 21/AX=250Ch,INT 31/AX=0400h
--------E-67DE0B-----------------------------
INT 67 - Virtual Control Program Interface - SET 8259 INTERRUPT VECTOR MAPPINGS
	AX = DE0Bh
	BX = first vector used by master 8259
	CX = first vector used by slave 8259
	interrupts disabled
Return: AH = 00h successful
	AH nonzero: failed
Notes:	This call merely informs the server that the client has changed the
	  interrupt mappings.  The client may not change the mappings if they
	  have already been changed by the server or another client, and is
	  responsible for restoring the original mappings before terminating.
SeeAlso: AX=DE0Ah,INT 2C/AX=002Ah
--------E-67DE0C-----------------------------
INT 67 - Virtual Control Program Interface - SWITCH TO PROTECTED MODE
	AX = DE0Ch
	ESI = linear address in first megabyte of values for system
	      registers (see #3297)
	interrupts disabled
Return: interrupts disabled
	GDTR, IDTR, LDTR, TR loaded
	SS:ESP must have at least 16 bytes space, and the entry point is
	      required to set up a new stack before enabling interrupts
	EAX, ESI, DS, ES, FS, GS destroyed
Note:	in protected mode, calling the protected-mode VCPI entry point with
	  AX = DE0Ch
	  DS = segment selector mapping entire linear address space obtained
		  via AX=DE01h
	  SS:ESP in first megabyte of linear memory
	  STACK:QWORD  return address from FAR call to 32-bit segment
		DWORD  EIP
		DWORD  CS
		DWORD  reserved for EFLAGS
		DWORD  ESP
		DWORD  SS
		DWORD  ES
		DWORD  DS
		DWORD  FS
		DWORD  GS
	  and interrupts disabled, will switch to virtual86 mode with
	    interrupts disabled, all segment registers loaded, and EAX
	    destroyed.
SeeAlso: AH=3Fh,INT 15/AH=89h,INT D4/AH=10h

Format of system register values for switch to protected mode:
Offset	Size	Description	(Table 3297)
 00h	DWORD	value for CR3
 04h	DWORD	linear address in first megabyte of value for GDTR
 08h	DWORD	linear address in first megabyte of value for IDTR
 0Ch	WORD	value for LDTR
 0Eh	WORD	value for TR
 10h	PWORD	CS:EIP of protected mode entry-point
--------m-67DE0F-----------------------------
INT 67 - Netroom3 - ???
	AX = DE0Fh
	???
Return: ???
Note:	called by Netroom's DPMI.EXE
--------m-67EF-------------------------------
INT 67 - RM386 v6.00+ - EXECUTE XMS FUNCTION
	AH = EFh
	AL = function (00h-12h,80h-8Fh)
	other register as appropriate for XMS function
Return: varies by function (see INT 2F/AX=4310h"XMS")
Note:	these functions appear to be equivalent to the XMS functions with the
	  same numbers
SeeAlso: AX=5DFFh"RM386",INT 2F/AX=4310h"XMS"
--------m-67FFA5-----------------------------
INT 67 - Microsoft EMM386.EXE v4.20+ - INSTALLATION CHECK
	AX = FFA5h
Return: AX = 845Ah/84A5h if loaded
	    BX:CX -> API entry point (see #3298)
Notes:	this call is available even if EMM386 is not providing EMS
	the returned AX is 845Ah inside of MSWindows, 84A5h under bare DOS
	if no other program has hooked INT 67, an alternate installation
	  check is to test for the string
	  "MICROSOFT EXPANDED MEMORY MANAGER 386" at offset 14h in the INT 67
	  handler's segment; the word immediately preceding this string
	  contains the offset of the API entry point
SeeAlso: AH=3Fh,AX=FFA5h/BX=4345h,INT 21/AX=4402h"EMM386.EXE"

(Table 3298)
Call EMM386.EXE API entry point with:
	AH = 00h get memory manager's status
	    Return: AH = status
			bit 0: not active (OFF)
			bit 1: in "Auto" mode
	AH = 01h set memory manager's state
	    AL = new state (00h ON, 01h OFF, 02h AUTO)
	AH = 02h Weitek coprocessor support
	    AL = subfunction
		00h get Weitek support state
		    Return: AL = status
				bit 0: Weitek coprocessor is present
				bit 1: Weitek support is enabled
		01h turn on Weitek support
		02h turn off Weitek support
     --- v4.20-4.41 only ---
	AH = 03h Windows support???
	    AL = subfunction (00h, 01h)
	AH = 04h print copyright notice to standard output
		 (using INT 21/AH=09h)
	AH = 05h print available report
		 (the one shown when running EMM386 from the DOS prompt)
SeeAlso: #1166 at INT 21/AX=4402h/SF=02h,#2271 at INT 2F/AX=12FFh/BX=0106h
--------m-67FFA5BX4345-----------------------
INT 67 U - Compaq CEMM v5.10+ - PRIVATE API
	AX = FFA5h
	BX = 4345h ("CE")
	DX = subfunction
	    0000h unshadow video ROM???
	    0001h shadow video ROM???
	    0002h map pages
		CX = number of pages (00h=one)
		ESI = linear address of first page to map into address space
		EDI = linear starting address at which pages are to be visible
	    0003h get ???
		Return: DX = ??? (0-2)
	    0004h BUG: crashes system due to fencepost error
Return: AH = 84h
	AL = status (84h = error, FFh = success)
Note:	if BX <> 4345h or DX > 0004h on entry, CEMM behaves identically to
	  Microsoft's EMM386 (see AX=FFA5h"EMM386")
SeeAlso: AX=FFA5h"EMM386",#1166 at INT 21/AX=4402h/SF=02h,#3298
--------I-68---------------------------------
INT 68 - Sangoma CCPOP 3270 resident module
SeeAlso: INT 67"Sangoma",INT 92"Sangoma"
--------N-68---------------------------------
INT 68 - Novell NetWare LU6.2
Note:	the installation check consists of testing for the signature string
	  "APPC/PC" nine bytes before the interrupt handler
SeeAlso: AH=01h/SF=1B00h,AH=FAh
--------h-68---------------------------------
INT 68 C - HP Vectra AT - IRQ16 - 8041 SERVICE REQUEST
SeeAlso: INT 08"IRQ0",INT 69"HP Vectra",INT 6F/AH=00h"HP"
--------N-6801--SF1B00-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DISPLAY
	AH = 01h subfn 1B00h
	DS:DX -> control block (see #3299)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2B00h,INT 68"Novell"

Format of APPC/PC "DISPLAY" control block:
Offset	Size	Description	(Table 3299)
 00h 12 BYTEs	reserved
 0Ch	WORD	1B00h (verb "DISPLAY")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	(big-endian) partner logical unit name
 2Ah  8 BYTEs	(big-endian) mode name
 32h	BYTE	logical unit session limit
 33h	BYTE	partner logical unit session limit
 34h	BYTE	node maximum negotiable session limit
 35h	BYTE	current session limit
 36h	BYTE	minimum negotiated winner limit
 37h	BYTE	maximum negotiated loser limit
 38h	BYTE	active session count
 39h	BYTE	active CONWINNER session count
 3Ah	BYTE	active CONLOSER session count
 3Bh	BYTE	session termination count
 3Ch	BYTE	bit 7: SESSION_TERMINATION_TARGET_DRAIN
		bit 6: SESSION_TERMINATION_SOURCE_DRAIN

(Table 3300)
Values for APPC/PC return code:
 0000h	successful
 0001h	BAD_TP_ID
 0002h	BAD_CONV_ID
 0003h	bad logical unit ID
 0008h	no physical unit attached
 0110h	bad state
 01B1h	BAD_PART_LUNAME
 01B2h	bad mode name
 0201h	physical unit already active
 0211h	logical unit already active
 0212h	BAD_PART_SESS
 0213h	BAD_RU_SIZES
 0214h	BAD_MODE_SESS
 0216h	BAD_PACING_CNT
 0219h	EXTREME_RUS
 021Ah	SNASVCMG_1
 0223h	SSCP_CONNECTED_LU
 0230h	invalid change
 0243h	too many TPs
 0272h	adapter close failure
 0281h	GET_ALLOC_BAD_TYPE
 0282h	unsuccessful
 0283h	DLC failure
 0284h	unrecognized DLC
 0286h	duplicate DLC
 0301h	SSCP_PU_SESSION_NOT_ACTIVE
 0302h	data exceeds RU size
 0401h	invalid direction
 0402h	invalid type
 0403h	segment overlap
 0404h	invalid first character
 0405h	table error
 0406h	conversion error
 F0010000h	APPC disabled
 F0020000h	APPC busy
 F0030000h	APPC abended
 F0040000h	incomplete
--------N-6801--SF2000-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ATTACH PHYSICAL UNIT
	AH = 01h subfn 2000h
	DS:DX -> control block (see #3301)
Return: control block updated
SeeAlso: AH=01h/SF=2100h,AH=01h/SF=2B00h

Format of APPC/PC "Attach Physical Unit" control block:
Offset	Size	Description	(Table 3301)
 00h 12 BYTEs	reserved
 0Ch	WORD	2000h (verb "Attach Physical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah	BYTE	version
 1Bh	BYTE	release
 1Ch  8 BYTEs	(big-endian) net name
 24h  8 BYTEs	(big-endian) physical unit name
 2Ch  8 BYTEs	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
		(see also AH=01h/SF=2100h)
 38h	DWORD	00h
 3Ch	BYTE	00h RETURN_CONTROL: COMPLETE
		01h RETURN_CONTROL: INCOMPLETE
--------N-6801--SF2100-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ATTACH LOGICAL UNIT
	AH = 01h subfn 2100h
	DS:DX -> control block (see #3302)
Return: control block updated
SeeAlso: #3305,#3306,#3308,AH=01h/SF=2000h,AH=01h/SF=2200h,AH=01h/SF=2B00h

Format of APPC/PC "Attach Logical Unit" control block:
Offset	Size	Description	(Table 3302)
 00h 12 BYTEs	reserved
 0Ch	WORD	2100h (verb "Attach Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	70  offset to partner logical unit record
 1Ah  8 BYTEs	(big-endian) logical unit name
 22h  8 BYTEs	(big-endian) logical unit ID
 2Ah	BYTE	logical unit local address
 2Bh	BYTE	logical unit session limit
 2Ch	DWORD	pointer to CREATE_TP_EXIT routine,
		FFFFFFFFh = reject incoming ALLOCATEs
		00000000h = queue ALLOCATEs
 30h	DWORD	00h
 34h	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh=don't log errors
 38h	DWORD	00h
 3Ch	BYTE	maximum TPs
 3Dh	BYTE	queue depth
 3Eh	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh=no pswd exit
 42h	DWORD	00h
 46h	WORD	total length of partner records
 48h	var	array of partner logical unit records (see #3303)
SeeAlso: #3305,#3306,#3308

Format of APPC/PC partner logical unit record:
Offset	Size	Description	(Table 3303)
 00h	WORD	length of this partner logical unit record
 02h	WORD	42  offset to mode records
 04h  8 BYTEs	(big-endian) partner logical unit name
 0Ch	BYTE	partner logical unit security capabilities
		bit 7: already verified
		bit 6: conversation level security
		bit 5: session level security
 0Dh	BYTE	partner logical unit session limit
 0Eh	WORD	partner logical unit maximum MC_SEND_LL
 10h  8 BYTEs	(big-endian) partner logical unit DLC name
 18h	BYTE	partner logical unit adapter number
 19h 17 BYTEs	(counted string) partner logical unit adapter address
 2Ah	WORD	total length of mode records
 2Ch 16N BYTEs	array of mode records (see #3304)

Format of mode record:
Offset	Size	Description	(Table 3304)
 00h	WORD	16  length of this mode record
 02h  8 BYTEs	(big-endian) mode name
 0Ah	WORD	RU_SIZE high bound
 0Ch	WORD	RU_SIZE low bound
 0Eh	BYTE	mode maximum negotiable session limit
 0Fh	BYTE	pacing size for receive

Routines defined by LU_LU_PASSWORD_EXIT, CREATE_TP_EXIT, and SYSTEM_LOG_EXIT
pointers are called by pushing the DWORD pointer to the verb on the stack and
then performing a FAR call.

Format of ACCESS_LU_LU_PW verb:
Offset	Size	Description	(Table 3305)
 00h 12 BYTEs	reserved
 0Ch	WORD	1900h (verb "ACCESS_LU_LU_PW")
 0Eh  8 BYTEs	(big-endian) logical unit ID
 16h  8 BYTEs	(big-endian) logical unit name
 1Eh  8 BYTEs	(big-endian) partner logical unit name
 26h 17 BYTEs	(counted string) partner fully qualified logical unit name
 37h	BYTE	password available (0=no, 1=yes)
 38h  8 BYTEs	password
SeeAlso: #3302,#3306,#3308

Format of CREATE_TP verb:
Offset	Size	Description	(Table 3306)
 00h 12 BYTEs	reserved
 0Ch	WORD	2300h (verb "CREATE_TP")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) sense code (see #3307)
 18h  8 BYTEs	(big-endian) TP ID
 20h  8 BYTEs	(big-endian) logical unit ID
 28h	DWORD	(big-endian) conversation ID
 2Ch	BYTE	0 basic conversation, 1 mapped conversation
 2Dh	BYTE	0 no sync level, 1 confirm
 2Eh	BYTE	reserved
 2Fh 65 BYTEs	(counted string) transaction program name
 70h  6 BYTEs	00h
 76h	WORD	length of ERROR_LOG_DATA to return
 78h	DWORD	pointer to ERROR_LOG_DATA buffer
 7Ch  8 BYTEs	(big-endian) partner logical unit name
 84h 18 BYTEs	(counted string) partner fully qualified logical unit name
 96h  8 BYTEs	(big-endian) mode name
 9Eh 12 BYTEs	00h
 AAh 11 BYTEs	(counted string) password
 B5h 11 BYTEs	(counted string) user ID
 C0h	BYTE	0 verification should be performed
		1 already verified
SeeAlso: #3305,#3308

(Table 3307)
Values for APPC/PC sense code:
 00000000h	Ok
 080F6051h	SECURITY_NOT_VALID
 084B6031h	TP_NOT_AVAIL_RETRY
 084C0000h	TP_NOT_AVAIL_NO_RETRY
 10086021h	TP_NAME_NOT_RECOGNIZED
 10086034h	CONVERSATION_TYPE_MISMATCH
 10086041h	SYNC_LEVEL_NOT_SUPPORTED

Format of SYSLOG verb:
Offset	Size	Description	(Table 3308)
 00h 12 BYTEs	reserved
 0Ch	WORD	2600h (verb "SYSLOG")
 0Eh 10 BYTEs	00h
 18h	WORD	(big-endian) type
 1Ah	DWORD	(big-endian) subtype
 1Eh	DWORD	pointer to ADDITIONAL_INFO
 22h	DWORD	(big-endian) conversation ID
 26h  8 BYTEs	(big-endian) TP ID
 2Eh  8 BYTEs	(big-endian) physical unit or logical unit name
 36h	WORD	length of data
 38h	DWORD	pointer to data
 3Ch	BYTE	00h
SeeAlso: #3305,#3306
--------N-6801--SF2200-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DETACH LOGICAL UNIT
	AH = 01h subfn 2200h
	DS:DX -> control block (see #3309)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2100h,AH=01h/SF=2700h

Format of APPC/PC "Detach Logical Unit" control block:
Offset	Size	Description	(Table 3309)
 00h 12 BYTEs	reserved
 0Ch	WORD	2200h (verb "Detach Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h  8 BYTEs	(big-endian) logical unit ID
 20h	BYTE	00h
--------N-6801--SF2700-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - DETACH PHYSICAL UNIT
	AH = 01h subfn 2700h
	DS:DX -> control block (see #3310)
Return: control block updated
SeeAlso: AH=01h/SF=2000h,AH=01h/SF=2100h,AH=01h/SF=2200h

Format of APPC/PC "Detach Physical Unit" control block:
Offset	Size	Description	(Table 3310)
 00h 12 BYTEs	reserved
 0Ch	WORD	2700h (verb "Detach Physical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	BYTE	00h  type: hard
		01h  type: soft
--------N-6801--SF2B00-----------------------
INT 68 - APPC/PC - NETWORK DEVICE CONTROL - ACTIVATE DLC
	AH = 01h subfn 2B00h
	DS:DX -> control block (see #3311)
Return: control block updated
SeeAlso: AH=01h/SF=1B00h,AH=01h/SF=2000h

Format of APPC/PC "Activate DLC" control block:
Offset	Size	Description	(Table 3311)
 00h 12 BYTEs	reserved
 0Ch	WORD	2B00h (verb "Activate DLC")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h  8 BYTEs	(big-endian) DLC name
 20h	BYTE	adapter number
--------N-6802--SF0100-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - ALLOCATE
	AH = 02h subfn 0100h
	DS:DX -> control block (see #3312)
Return: control block updated
SeeAlso: AH=02h/SF=0500h

Format of APPC/PC "Allocate" control block:
Offset	Size	Description	(Table 3312)
 00h 12 BYTEs	reserved
 0Ch	WORD	0100h (verb "Allocate" or "MC_Allocate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(MC_Allocate only) conversation type
		0 basic conversation
		1 mapped conversation
 27h	BYTE	SYNC_LEVEL (00h none, 01h confirm)
 28h	WORD	0000h
 2Ah	BYTE	RETURN_CONTROL
		00h when session allocated
		01h immediate
		02h when session free
 2Bh  8 BYTEs	00h
 33h  8 BYTEs	(big-endian) partner logical unit name
 3Bh  8 BYTEs	(big-endian) mode name
 43h 65 BYTEs	(counted string) TP name
 84h	BYTE	security (00h none, 01h same, 02h pgm)
 85h 11 BYTEs	00h
 90h 11 BYTEs	(counted string) password
 9Bh 11 BYTEs	(counted string) user ID
 A6h	WORD	PIP_DATA length
 A8h	DWORD	pointer to PIP_DATA

(Table 3313)
Values for APPC/PC primary return code:
 0000h	successful
 0001h	parameter check
 0002h	state check
 0003h	allocation error
 0005h	deallocate abended
 0006h	deallocate abended program
 0007h	deallocate abended SVC
 0008h	deallocate abended timer
 0009h	deallocate normal return
 000Ah	data posting blocked
 000Bh	posting not active
 000Ch	PROG_ERROR_NO_TRUNC
 000Dh	PROG_ERROR_TRUNC
 000Eh	PROG_ERROR_PURGING
 000Fh	CONV_FAILURE_RETRY
 0010h	CONV_FAILURE_NO_RETRY
 0011h	SVC_ERROR_NO_TRUNC
 0012h	SVC_ERROR_TRUNC
 0013h	SVC_ERROR_PURGING
 0014h	unsuccessful
 0018h	CNOS partner logical unit reject
 0019h	conversation type mixed
 F001h	APPC disabled
 F002h	APPC busy
 F003h	APPC abended
 F004h	incomplete

(Table 3314)
Values for APPC/PC error code:
 0001h	bad TP ID
 0002h	bad conversation ID
 0004h	allocation error, no retry
 0005h	allocation error, retry
 0006h	data area crosses segment boundary
 0010h	bad TPN length
 0011h	bad CONV length
 0012h	bad SYNC level
 0013h	bad security selection
 0014h	bad return control
 0015h	SEC_TOKENS too big
 0016h	PIP_LEN incorrect
 0017h	no use of SNASVCMG
 0018h	unknown partner mode
 0031h	confirm: SYNC_NONE
 0032h	confirm: bad state
 0033h	confirm: NOT_LL_BDY
 0041h	confirmed: bad state
 0051h	deallocate: bad type
 0052h	deallocate: flush bad state
 0053h	deallocate: confirm bad state
 0055h	deallocate: NOT_LL_BDY
 0057h	deallocate: log LL_WRONG
 0061h	flush: not send state
 0091h	post on receipt: invalid length
 0092h	post on receipt: not in receive state
 0093h	post on receipt: bad fill
 00A1h	prepare to receive:invalid type
 00A2h	prepare to receive: unfinished LL
 00A3h	prepare to receive: not in send state
 00B1h	receive and wait: bad state
 00B2h	receive and wait: NOT_LL_BDY
 00B5h	receive and wait: bad fill
 00C1h	receive immediate: not in receive state
 00C4h	receive immediate: bad fill
 00E1h	request to send: not in receive state
 00F1h	send data: bad LL
 00F2h	send data: not in send state
 0102h	send error: log LL wrong
 0103h	send error: bad type
 0121h	test: invalid type
 0122h	test: not in receive state
--------N-6802--SF0300-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - CONFIRM
	AH = 02h subfn 0300h
	DS:DX -> control block (see #3315)
Return: control block updated
SeeAlso: AH=02h/SF=0400h

Format of APPC/PC "Confirm" control block:
Offset	Size	Description	(Table 3315)
 00h 12 BYTEs	reserved
 0Ch	WORD	0300h (verb "Confirm" or "MC_Confirm")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
--------N-6802--SF0400-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - CONFIRMED
	AH = 02h subfn 0400h
	DS:DX -> control block (see #3316)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Confirmed" control block:
Offset	Size	Description	(Table 3316)
 00h 12 BYTEs	reserved
 0Ch	WORD	0400h (verb "Confirmed" or "MC_Confirmed")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0500-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - DEALLOCATE
	AH = 02h subfn 0500h
	DS:DX -> control block (see #3317)
Return: control block updated
SeeAlso: AH=02h/SF=0100h,AH=02h/SF=0300h

Format of APPC/PC "Deallocate" control block:
Offset	Size	Description	(Table 3317)
 00h 12 BYTEs	reserved
 0Ch	WORD	0500h (verb "Deallocate" or "MC_Deallocate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	00h
 27h	BYTE	type
		00h SYNC_LEVEL
		01h FLUSH
		02h ABEND_PROC
		03h ABEND_SVC
		04h ABEND_TIMER
		05h ABEND
 28h	WORD	(MC_Deallocate only) length of error log data
 2Ah	DWORD	(MC_Deallocate only) pointer to error log data
--------N-6802--SF0600-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - FLUSH
	AH = 02h subfn 0600h
	DS:DX -> control block (see #3318)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Flush" control block:
Offset	Size	Description	(Table 3318)
 00h 12 BYTEs	reserved
 0Ch	WORD	0600h (verb "Flush" or "MC_Flush")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0700-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - GET ATTRIBUTES
	AH = 02h subfn 0700h
	DS:DX -> control block (see #3319)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Get_Attributes" control block:
Offset	Size	Description	(Table 3319)
 00h 12 BYTEs	reserved
 0Ch	WORD	0700h (verb "Get_Attributes" or "MC_Get_Attributes")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h  8 BYTEs	(big-endian) logical unit ID
 2Eh	BYTE	00h
 2Fh	BYTE	SYNC_LEVEL (0=none, 1=confirm)
 30h  8 BYTEs	(big-endian) mode name
 38h  8 BYTEs	(big-endian) own net name
 40h  8 BYTEs	(big-endian) own logical unit name
 48h  8 BYTEs	(big-endian) partner logical unit name
 50h 18 BYTEs	(counted string) partner's fully qualified logical unit name
 62h	BYTE	00h
 63h 11 BYTEs	(counted string) user ID
--------N-6802--SF0800-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - GET CONVERSATION TYPE
	AH = 02h subfn 0800h
	DS:DX -> control block (see #3320)
Return: control block updated
SeeAlso: AH=02h/SF=0300h

Format of APPC/PC "Get_Type" control block:
Offset	Size	Description	(Table 3320)
 00h 12 BYTEs	reserved
 0Ch	WORD	0800h (verb "Get_Type")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(ret) type (0=basic conversation, 1=mapped conversation)
--------N-6802--SF0900-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - POST ON RECEIPT
	AH = 02h subfn 0900h
	DS:DX -> control block (see #3321)
Return: control block updated
SeeAlso: AH=02h/SF=0A00h

Format of APPC/PC "Post_on_Receipt" control block:
Offset	Size	Description	(Table 3321)
 00h 12 BYTEs	reserved
 0Ch	WORD	0900h (verb "Post_on_Receipt")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	WORD	maximum length
 28h	BYTE	fill (0=buffer, 1=LL)
--------N-6802--SF0A00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - PREPARE TO RECEIVE
	AH = 02h subfn 0A00h
	DS:DX -> control block (see #3322)
Return: control block updated
SeeAlso: AH=02h/SF=0900h,AH=02h/SF=0B00h

Format of APPC/PC "Prepare_to_Receive" control block:
Offset	Size	Description	(Table 3322)
 00h 12 BYTEs	reserved
 0Ch	WORD	0A00h (verb "Prepare_to_Receive" or "MC_Prepare_to_Receive")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type (0=SYNC_LEVEL, 1=FLUSH)
 27h	BYTE	locks (0=short, 1=long)
--------N-6802--SF0B00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - RECEIVE AND WAIT
	AH = 02h subfn 0B00h
	DS:DX -> control block (see #3323)
Return: control block updated
SeeAlso: AH=02h/SF=0C00h,AH=02h/SF=0F00h

Format of APPC/PC "Receive_and_Wait" control block:
Offset	Size	Description	(Table 3323)
 00h 12 BYTEs	reserved
 0Ch	WORD	0B00h (verb "Receive_and_Wait" or "MC_Receive_and_Wait")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type of information received (see #3324)
 27h	BYTE	(MC_Receive_and_Wait only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data

(Table 3324)
Values for type of information received:
 00h	data
 01h	data complete
 02h	data incomplete
 03h	confirm
 04h	confirm send
 05h	confirm deallocate
 06h	send
--------N-6802--SF0C00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - RECEIVE IMMEDIATE
	AH = 02h subfn 0C00h
	DS:DX -> control block (see #3325)
Return: control block updated
SeeAlso: AH=02h/SF=0B00h,AH=02h/SF=0F00h

Format of APPC/PC "Receive_Immediate" control block:
Offset	Size	Description	(Table 3325)
 00h 12 BYTEs	reserved
 0Ch	WORD	0C00h (verb "Receive_Immediate" or "MC_Receive_Immediate")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	type of information received (see #3324)
 27h	BYTE	(MC_Receive_Immediate only) fill (0=buffer, 1=LL)
 28h	BYTE	Request_to_Send_Received (0=no, 1=yes)
 29h	WORD	maximum length
 2Bh	WORD	data length
 2Dh	DWORD	pointer to data
--------N-6802--SF0E00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - REQUEST TO SEND
	AH = 02h subfn 0E00h
	DS:DX -> control block (see #3326)
Return: control block updated
SeeAlso: AH=02h/SF=0F00h,AH=02h/SF=1000h

Format of APPC/PC "Request_to_Send" control block:
Offset	Size	Description	(Table 3326)
 00h 12 BYTEs	reserved
 0Ch	WORD	0E00h (verb "Request_to_Send" or "MC_Request_to_Send")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
--------N-6802--SF0F00-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - SEND DATA
	AH = 02h subfn 0F00h
	DS:DX -> control block (see #3327)
Return: control block updated
SeeAlso: AH=02h/SF=0E00h,AH=02h/SF=1000h

Format of APPC/PC "Send_Data" control block:
Offset	Size	Description	(Table 3327)
 00h 12 BYTEs	reserved
 0Ch	WORD	0F00h (verb "Send_Data" or "MC_Send_Data")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	00h
 28h	WORD	data length
 2Ah	DWORD	pointer to data
--------N-6802--SF1000-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - SEND ERROR
	AH = 02h subfn 1000h
	DS:DX -> control block (see #3328)
Return: control block updated
SeeAlso: AH=02h/SF=0F00h

Format of APPC/PC "Send_Error" control block:
Offset	Size	Description	(Table 3328)
 00h 12 BYTEs	reserved
 0Ch	WORD	1000h (verb "Send_Error" or "MC_Send_Error")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	request to send received (0=no, 1=yes)
 27h	BYTE	type (0=program, 1=SVC)
 28h	DWORD	00h
 2Ch	WORD	(MC_Send_Error only) LOG_DATA length
 2Eh	DWORD	(MC_Send_Error only) pointer to LOG_DATA
--------N-6802--SF1200-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - TEST
	AH = 02h subfn 1200h
	DS:DX -> control block (see #3329)
Return: control block updated
SeeAlso: AH=02h/SF=1300h

Format of APPC/PC "Test" control block:
Offset	Size	Description	(Table 3329)
 00h 12 BYTEs	reserved
 0Ch	WORD	1200h (verb "Test" or "MC_Test")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	(MC_Test only) test (0=posted, 1=request_to_send received)
Note:	error code has different interpretations for:
	0 posted data
	1 posted not data (primary return code = 0)
	1 bad TP_ID (primary return code = 1)
--------N-6802--SF1300-----------------------
INT 68 - APPC/PC - CONNECTION CONTROL - WAIT
	AH = 02h subfn 1300h
	DS:DX -> control block (see #3330)
Return: control block updated
SeeAlso: AH=02h/SF=1200h

Format of APPC/PC "Wait" control block:
Offset	Size	Description	(Table 3330)
 00h 12 BYTEs	reserved
 0Ch	WORD	1300h (verb "Wait")
 0Eh	BYTE	1 if MC_ (mapped conversation) form of verb
		0 if basic verb
 0Fh  5 BYTEs	reserved (0)
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) error code (see #3314,#3329)
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	(big-endian) conversation ID
 26h	BYTE	number of conversations to wait on
		Note: error codes have interpretations as for AH=02h/SF=1200h
--------N-6803--SF2400-----------------------
INT 68 - APPC/PC - TP STARTED
	AH = 03h subfn 2400h
	DS:DX -> control block (see #3331)
Return: control block updated

Format of APPC/PC "TP Started" control block:
Offset	Size	Description	(Table 3331)
 00h 12 BYTEs	reserved
 0Ch	WORD	2400h (verb "TP Started")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	(big-endian) TP ID
--------N-6803--SF2800-----------------------
INT 68 - APPC/PC - GET ALLOCATE
	AH = 03h subfn 2800h
	DS:DX -> control block (see #3332)
Return: control block updated

Format of APPC/PC "Get ALLOCATE" control block:
Offset	Size	Description	(Table 3332)
 00h 12 BYTEs	reserved
 0Ch	WORD	2800h (verb "Get ALLOCATE")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h	BYTE	type (00h dequeue, 01h test)
 23h	DWORD	pointer to CREATE_TP record
--------N-6803--SF2A00-----------------------
INT 68 - APPC/PC - CHANGE LOGICAL UNIT
	AH = 03h subfn 2A00h
	DS:DX -> control block (see #3333)
Return: control block updated

Format of APPC/PC "Change Logical Unit" control block:
Offset	Size	Description	(Table 3333)
 00h 12 BYTEs	reserved
 0Ch	WORD	2A00h (verb "Change Logical Unit")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h	DWORD	pointer to CREATE_TP_EXIT routine
		00000000h queue ALLOCATEs
		FFFFFFFFh reject incoming ALLOCATEs
 26h	DWORD	00000000h
 2Ah	DWORD	pointer to SYSTEM_LOG_EXIT routine, FFFFFFFFh= don't log errors
 2Eh	DWORD	00000000h
 32h	BYTE	maximum TPs
 33h	BYTE	00h stop QUEUE_ALLOCATEs
		01h resume QUEUE_ALLOCATEs
 34h	DWORD	pointer to LU_LU_PASSWORD_EXIT routine, FFFFFFFFh = no exit
 38h	DWORD	00000000h
--------N-6804-------------------------------
INT 68 - APPC/PC - TRANSACTION PROCESSING
	AH = 04h
	DS:DX -> control block (see #3334)
Return: control block updated

Format of APPC/PC control block:
Offset	Size	Description	(Table 3334)
 00h 12 BYTEs	reserved
 0Ch	WORD	verb (action)
		2500h TP_ENDED
		2900h TP_VALID
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h	WORD	00h
 1Ah  8 BYTEs	(big-endian) TP_ID
 22h	DWORD	-> CREATE_TP record (only if verb = 2900h)
--------N-6805-------------------------------
INT 68 - APPC/PC - TRANSFER MESSAGE DATA
	AH = 05h
	DS:DX -> control block (see #3335)
Return: control block updated

Format of APPC/PC "Transfer Message Data" control block:
Offset	Size	Description	(Table 3335)
 00h 12 BYTEs	reserved
 0Ch	WORD	1C00h (verb "Transfer Message Data")
 0Eh	BYTE	data type
		00h user defined
		01h NMVT
		02h alert subvectors
		03h PDSTATS subvectors
 0Fh  5 BYTEs	00h
 14h	DWORD	(big-endian) return code (see #3300)
 18h 12 BYTEs	00h
 24h	BYTE	flags (see #3336)
 25h	BYTE	00h
 26h	WORD	length of data
 28h  N BYTEs	data

Bitfields for APPC/PC message transfer flags:
Bit(s)	Description	(Table 3336)
 0	don't add correlation subvector
 1	don't add product set ID subvector
 2	don't do SYSLOG
 3	don't send SSCP_PU_SESSION
SeeAlso: #3335
--------N-6806-------------------------------
INT 68 - APPC/PC - CHANGE NUMBER OF SESSIONS
	AH = 06h
	DS:DX -> control block (see #3337)
Return: control block updated

Format of APPC/PC "Change Number of Sessions" control block:
Offset	Size	Description	(Table 3337)
 00h 12 BYTEs	reserved
 0Ch	WORD	1500h (verb "Change Number of Sessions")
 0Eh  6 BYTEs	00h
 14h	WORD	(big-endian) primary return code (see #3313)
 16h	DWORD	(big-endian) secondary return code (see #3300,#3338)
 1Ah  8 BYTEs	(big-endian) logical unit ID
 22h  8 BYTEs	blanks
 2Ah  8 BYTEs	(big-endian) partner logical unit name
 32h  8 BYTEs	(big-endian) mode name
 3Ah	BYTE	bit 7: use MODE_NAME_SELECT_ALL rather than MODE_NAME
		bit 6: set negotiable values
 3Bh	BYTE	partner logical unit mode session limit
 3Ch	BYTE	minimum CONWINNERS_SOURCE
 3Dh	BYTE	maximum CONWINNERS_TARGET
 3Eh	BYTE	automatic activation
 3Fh	BYTE	00h
 40h	BYTE	flags
		bit 7: drain target
		bit 6: drain source
		bit 5: target responsible, not source

(Table 3338)
Values for secondary return code (see also AH=01h/SF=1B00h):
 0000h	accepted
 0001h	negotiated
 0003h	bad logical unit ID
 0004h	allocation failure, no retry
 0005h	allocation failure, retry
 0151h	can't raise limits
 0153h	all modes must reset
 0154h	bad SNASVCMG limits
 0155h	minimum greater than total
 0156h	mode closed (primary return code = 1)
	CNOS mode closed (primary return code = 18h)
 0157h	bad mode name (primary return code = 1)
	CNOS bad mode name (primary return code = 18h)
 0159h	reset SNA drains
 015Ah	single not SRC response
 015Bh	bad partner logical unit
 015Ch	exceeds maximum allowed
 015Dh	change SRC drains
 015Eh	logical unit detached
 015Fh	CNOS command race reject
--------N-6807-------------------------------
INT 68 - APPC/PC - PASSTHROUGH
	AH = 07h
	DS:DX -> control block (format depends on application subsystem)
Return: control block updated
SeeAlso: AH=FFh
----------684300-----------------------------
INT 68 U - ??? - INSTALLATION CHECK???
	AX = 4300h
Return: AX = F386h if ???
	???
Note:	called by Novell DOS 7.0 EMM386.EXE
SeeAlso: AX=4400h,INT 41/AX=004Fh
----------684400-----------------------------
INT 68 U - ???
	AX = 4400h
	BX = ???
	CX = ???
	DX = ???
	DS:SI = real-mode address of protected-mode GDT
	ES:DI = real-mode address of protected-mode IDT
Return: ???
Note:	called by Novell DOS 7.0 EMM386.EXE if AX=4300h returns AX=F386h
SeeAlso: AX=4300h
--------W-6847-------------------------------
INT 68 - MS Windows debugging kernel - OUTPUT STRING
	AH = 47h
	ES:SI -> string
Notes:	output a string (to inform a debugger of some events)
	KERNEL outputs "Windows Kernel Entry\r\n" on startup
SeeAlso: INT 41/AX=0012h
--------N-68FA-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE APPC
	AH = FAh
	AL bit 0 = new state (0 enable, 1 disable)
SeeAlso: AH=FDh,INT 68"Novell"
--------N-68FB-------------------------------
INT 68 - APPC/PC - CONVERT
	AH = FBh
	DS:DX -> control block (see #3339)
Return: control block updated

Format of APPC/PC "CONVERT" control block:
Offset	Size	Description	(Table 3339)
 00h 12 BYTEs	reserved
 0Ch	WORD	1A00h (verb "CONVERT")
 0Eh  6 BYTEs	00h
 14h	DWORD	(big-endian) return code
 18h	BYTE	conversion
		00h ASCII to EBCDIC
		01h EBCDIC to ASCII
 19h	BYTE	character set
		00h AE
		01h A
		02h G
 1Ah	WORD	length of string to convert
 1Ch	DWORD	pointer to source
 20h	DWORD	pointer to target
--------N-68FC-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE MESSAGE TRACING
	AH = FCh
	AL = new state
	    00h disable tracing
	    01h enable tracing
		DX = number of bytes to keep (0=all)
SeeAlso: AH=FDh,AH=FEh
--------N-68FD-------------------------------
INT 68 - APPC/PC - ENABLE/DISABLE API VERB TRACING
	AH = FDh
	AL = new tracing state (00h disabled, 01h enabled)
SeeAlso: AH=FAh,AH=FCh,AH=FEh
--------N-68FE-------------------------------
INT 68 - APPC/PC - SET TRACE DESTINATION
	AH = FEh
	AL = trace destinations (see #3340)
	DS:DX -> trace stats record if AL bit 0 set (see #3341)
SeeAlso: AH=FCh,AH=FDh

Bitfields for trace destinations:
Bit(s)	Description	(Table 3340)
 0	storage (DS:DX -> trace stats record)
 1	display
 2	file (trace written to file OUTPUT.PC)
 3	printer

Format of APPC/PC Trace Statistics Record:
Offset	Size	Description	(Table 3341)
 00h	DWORD	pointer to storage trace buffer
 04h	WORD	max number of 80-byte records in trace
 06h	WORD	(high-order byte first!) current record number (must init to 0)
 08h	DWORD	(high-order byte first!) number of records written (init to 0)
 0Ch	DWORD	reserved
Note:	do not move record while trace is active
--------N-68FF-------------------------------
INT 68 - APPC/PC - SET PASSTHROUGH
	AH = FFh
	DS:DX -> passthrough exit routine
SeeAlso: AH=07h,INT 68"Novell"
--------b-69---------------------------------
INT 69 - Zenith AT BIOS - ???
Note:	called by INT 09 handler
--------h-69---------------------------------
INT 69 C - HP Vectra AT - IRQ17 - KEYBOARD OUTPUT-BUFFER-FULL SERVICE ROUTINE
SeeAlso: INT 09"IRQ1",INT 68"HP Vectra",INT 6A"HP Vectra"
--------N-690100-----------------------------
INT 69 - DECnet DOS CTERM - INSTALLATION CHECK
	AX = 0100h
Return: AL = FFh if present
SeeAlso: AX=010Fh
--------N-690101-----------------------------
INT 69 - DECnet DOS CTERM - SEND BYTE
	AX = 0101h
	BL = character
	DX = session handle
Return: AH >= 80h on error
SeeAlso: AX=0102h
--------N-690102-----------------------------
INT 69 - DECnet DOS CTERM - READ BYTE
	AX = 0102h
	DX = session handle
Return: AH >= 80h on error
	AH < 80h if successful
	    AL = character
SeeAlso: AX=0101h
--------N-690103-----------------------------
INT 69 - DECnet DOS CTERM - STATUS
	AX = 0103h
	DX = session handle
Return: AH status flags (see #3342)
	AL = reason code if DECnet error (see #3343)
SeeAlso: AX=0104h

Bitfields for DECnet DOS CTERM status flags:
Bit(s)	Description	(Table 3342)
 7	session has been aborted
 6	DECnet error
 1	trace data available
 0	receive data available

(Table 3343)
Values for reason code:
 00h	normal disconnect
 01h	unknown message from host
 02h	protocol violation from host
 03h	could not process the initiate message
 04h	error receiving message from host
 05h	error sending message to host
 06h	error checking for message from host
 07h	remote system does not support CTERM
 08h	remote system does not support correct protocol version
 09h	did not receive BIND message from host
 0Ah	could not send BIND message to host
 0Bh	no more sessions available
 0Ch	session does not exist
 0Dh	not enough memory to complete operation
 0Eh	connection has broken
Index:	error codes;DECnet DOS CTERM|DECnet DOS CTERM;error codes
--------N-690104-----------------------------
INT 69 - DECnet DOS CTERM - DECnet STATUS
	AX = 0104h
	DX = session handle
Return: AX = reason code (see #3343)
Note:	use this call when AX=0103h returns a DECnet error
SeeAlso: AX=0103h
--------N-690105-----------------------------
INT 69 - DECnet DOS CTERM - OPEN SESSION
	AX = 0105h
	DS:BX -> ASCIZ node name
	ES:DX -> buffer for session control block (see #3359 at INT 6A/AH=D0h)
Return: AX <= 0 on error
	AX > 0 session handle
SeeAlso: AX=0103h,AX=0106h,AX=010Ah
--------N-690106-----------------------------
INT 69 - DECnet DOS CTERM - CLOSE SESSION
	AX = 0106h
	DX = session handle
Return: AH = status
	    00h good close
	    other error code (see #3343)
SeeAlso: AX=0103h,AX=0105h
--------N-69010A-----------------------------
INT 69 - DECnet DOS CTERM - GET SESSION CONTROL BLOCK SIZE
	AX = 010Ah
Return: AX = length of session control block in bytes
SeeAlso: AX=0105h
--------N-69010B-----------------------------
INT 69 - DECnet DOS CTERM - GET DECnet SOCKET
	AX = 010Bh
	DX = session handle
Return: AX > 0	DECnet socket for the session
	AX = 0	no match for handle
--------N-69010F-----------------------------
INT 69 - DECnet DOS CTERM - DEINSTALL CTERM
	AX = 010Fh
Return: AH = status
	    00h successful uninstall
	    other error code (see #3343)
Note:	CTERM must have been the last TSR loaded in order to deinstall it
SeeAlso: AX=0100h
Index:	uninstall;DECnet DOS CTERM
--------N-690A-------------------------------
INT 69 - DECnet DOS 2.1+ - DATA LINK LAYER
	AH = 0Ah
	AL = function number (see #3344)
	ES:BX -> Datalink Communication Block (see #3346)
Return: AX = status (see #3345)
SeeAlso: INT 6D"DECnet"

(Table 3344)
Values for DECnet DOS Data Link Layer function:
 00h	initialize
 01h	open portal
 02h	close portal
 03h	enable multicast address
 04h	disable multicast address
 05h	transmit
 06h	request transmit buffer
 07h	deallocate transmit buffer
 08h	read channel status
 09h	read datalink portal list
 0Ah	read information about a datalink portal
 0Bh	read and/or clear counters
 0Ch	request to boot from a network server
 0Dh	enable Ethernet channel
 0Eh	disable Ethernet channel
 0Fh	start MOP/send a System ID message
 10h	stop MOP
 11h	get DECPARM
 12h	set DECPARM
 13h	external loopback

(Table 3345)
Values for DECnet DOS Data Link Layer status:
 00h	successful
 01h	hardware failed to initialize
 02h	channel state was not off (must be off to execute that command)
 03h	channel state is off (must be on to execute that command)
 04h	address not set
 05h	hardware missing
 06h	buffer too small
 07h	no more buffers available
 08h	no more resources available
 09h	promiscuous receiver active
 0Ah	non exclusive
 0Bh	unrecognized portal
 0Ch	protocol type in use
 0Dh	not a valid Multicast address
 0Eh	outstanding calls
 0Fh	hardware doesn't support receiving bad frames
 10h	none outstanding
 11h	no events
 12h	broken
 13h	buffer quota exceeded
 14h	already initialized
 15h	loopback failure
Index:	error codes;DECnet DOS|DECnet DOS;error codes

Format of Datalink Communication Block:
Offset	Size	Description	(Table 3346)
 00h	WORD	portal ID
 02h  6 BYTEs	source address
 08h  6 BYTEs	destination address
 0Eh	DWORD	buffer pointer
 12h	WORD	buffer length
 14h	WORD	operation
 16h	BYTE	pad flag (used on open)
		00h no pad
		01h pad
 17h	BYTE	mode flag (used on open)
		00h 802.3
		01h Ethernet
		02h promiscuous
 18h	DWORD	line status change function
 1Ch	DWORD	received data function
 20h	DWORD	transmitted data function
 24h	BYTE	maximum outstanding transmits/receives
 25h  2 BYTEs	protocol type
 27h	WORD	buffers lost
--------N-694001-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4001h
Return: CF clear
	AX = 0000h
	ES:SI -> ???
Range:	INT 60 to INT 7F, selected by configuration
Note:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
SeeAlso: AX=4002h
Index:	installation check;10NET SYSSVC
--------N-694002-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4002h
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
Note:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
--------N-694101-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4101h
Return: CF clear
	ES:SI -> ???
Range:	INT 60 to INT 7F, selected by configuration
SeeAlso: AX=4102h,AX=4103h,AX=4104h
--------N-694102-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4102h
	???
Return: ???
--------N-694103-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4103h
	???
Return: ???
--------N-694104-----------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AX = 4104h
	???
Return: ???
--------N-6942-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 42h
	AL = function (01h-14h)
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
--------N-6943-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 43h
	AL = function (01h-05h)
	???
Return: ???
--------N-6944-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - ???
	AH = 44h
	AL = function (01h-03h)
	???
Return: ???
Range:	INT 60 to INT 7F, selected by configuration
--------N-6949-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - BUG
	AH = 49h
Note:	due to a fencepost error, this function branches to hyperspace
SeeAlso: AX=4001h,AH=FFh
--------G-696996-----------------------------
INT 69 - ISR.COM v1.00 - SPECIFY INTERRUPT HANDLER
	AX = 6996h
	DS:DX -> interrupt handler or 0000h:0000h to disable
Return: AX = 9669h
Program: ISR (Interrupt Service Reflector) is a TSR by Rich Bono which permits
	  a program to provide hardware interrupt handlers even while being
	  debugged with a debugger that swaps interrupt vectors during
	  debugging.
Note:	the interrupt vector which is to be reflected is set at installation
	  time and cannot be changed
--------N-69FF-------------------------------
INT 69 - 10NET v5.0 - SYSSVC.COM - SIGNAL SYSTEM ERROR
	AH = FFh
Return: never???
Desc:	displays "System Error" message and register dump, then halts system
Range:	INT 60 to INT 7F, selected by configuration
Notes:	the signature "SYSV" immediately before the interrupt handler serves
	  as the installation check
SeeAlso: AX=4001h,AH=49h
--------U-6A---------------------------------
INT 6A - OPTHELP.COM
Program: OPTHELP is an optionally-resident help system for SLR Systems's OPTASM
	  assembler
Range:	INT 60h to INT 7Fh, selected by configuration
--------N-6A---------------------------------
INT 6A - DECnet DOS - LOCAL AREA TRANSPORT PROGRAM - INSTALLATION CHECK
Note:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #3347)
SeeAlso: AH=01h/DH=FFh,INT 6B"DECnet",INT 6D"DECnet"
Index:	installation check;DECnet DOS Local Area Transport

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 3347)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "LAT")
--------h-6A---------------------------------
INT 6A C - HP Vectra AT - IRQ18 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0A"IRQ2",INT 69"HP Vectra",INT 6B"HP Vectra"
--------N-6A0000-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - INSTALLATION CHECK
	AX = 0000h
Return: AX = 4357h ('CW')
Program: Super-TCP is a TCP/IP protocol stack by Frontier Technologies Corp.
Note:	an alternate installation check is to test for the ASCIZ signature
	  "FTC Super-TCP" three bytes past the interrupt handler
SeeAlso: AX=0001h,AX=0002h,AX=000Fh,AX=0010h,INT 21/AH=3Fh"BW-TCP"
SeeAlso: INT 61"FTP Software",INT 62/AH=00h"ETHDEV"
--------N-6A0001-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ???
	AX = 0001h
	BH = function number
	    01h ???
		DS:SI -> ??? 24-byte record1 (see #3349)
		ES:DI -> buffer containing ???
	    02h ???
		DS:SI -> ??? 18-byte record2 (see #3350)
		ES:DI -> buffer containing ???
	    04h ???
		BL = subfunction
		    01h
			DS:SI -> ??? 28-byte record3 (see #3351)
			ES:DI -> buffer containing ???
		    02h
			DS:SI -> ??? 28-byte record3 (see #3351)
			ES:DI -> buffer containing ???
		    03h
			DS:SI -> ??? 28-byte record3 (see #3351)
		    else Return: AX = 0005h
	    05h ???
		DS:SI -> ??? 20-byte record4 (see #3352)
		ES:DI -> buffer containing ???
	    06h ???
		BL = subfunction
		    01h
			DS:SI -> ??? 40-byte record5 (see #3353)
		    02h
			DS:SI -> ??? 20-byte record6 (see #3354)
			ES:DI -> ???
		    03h
			DS:SI -> ??? 20-byte record6 (see #3354)
		    04h
			DS:SI -> ??? 46-byte record7 (see #3355)
		    else Return: AX = 0005h
	    11h ???
		DS:SI -> ??? 28-byte record8 (see #3356)
		ES:DI -> ???
Return: AX = function status (see #3348)
SeeAlso: AX=0000h

(Table 3348)
Values for Super-TCP function status:
 0000h	successful
 0005h	unsupported function
 000Ah	out of memory

Format of record1:
Offset	Size	Description	(Table 3349)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 18 BYTEs	???

Format of record2:
Offset	Size	Description	(Table 3350)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 12 BYTEs	???

Format of record3:
Offset	Size	Description	(Table 3351)
 00h  2 BYTEs	???
 02h	WORD	???
 04h	WORD	size of ES:DI buffer
 06h	WORD	???
 08h	WORD	operation number (for function 0401h)
 0Ah	DWORD	-> ???
 0Eh	WORD	(ret) ???
 10h 12 BYTEs	???

Format of record4:
Offset	Size	Description	(Table 3352)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 14 BYTEs	???

Format of record5:
Offset	Size	Description	(Table 3353)
 00h	BYTE	operation??? (00h-07h)
 01h	BYTE	???
 02h	WORD	(ret) ???
 04h	DWORD	-> ???
 08h  4 BYTEs	???
 0Ch	DWORD	-> ??? or 0000h:0000h
 10h 16 BYTEs	???
 20h	DWORD	???
 24h  4 BYTEs	???

Format of record6:
Offset	Size	Description	(Table 3354)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h 14 BYTEs	???

Format of record7:
Offset	Size	Description	(Table 3355)
 00h	WORD	???
 02h	WORD	???
 04h	WORD	???
 06h 40 BYTEs	???

Format of record8:
Offset	Size	Description	(Table 3356)
 00h  4 BYTEs	???
 04h	WORD	size of ES:DI buffer
 06h  6 BYTEs	???
 0Ch	WORD	(ret) ???
 0Eh	WORD	operation??? (01h-03h)
 10h 12 BYTEs	???
--------N-6A0002-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ???
	AX = 0002h
	BX = ??? (zero/nonzero)
	CX = ??? identifier (see AX=0004h)
	DS:SI -> 40-byte buffer for ??? or 0000h:0000h
	ES:DI -> buffer for ??? or 0000h:0000h
Return: AX = 0000h (successful) ???
	BL = ???
	BH = ???
	CX = ???
	DX = ???
--------N-6A0003-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - GET ??? DATA AREA
	AX = 0003h
Return: CX:DX -> data area (see #3357)

Format of Super-TCP data area:
Offset	Size	Description	(Table 3357)
 00h  2 BYTEs	???
 02h	DWORD	original INT 6A vector
 06h  2 BYTEs	???
 08h 96 BYTEs	array of 16 6-byte ???
 68h	WORD	number of elements of above array in use
 6Ah	WORD	???
	???
--------N-6A0004-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - ALLOCATE ???
	AX = 0004h
	CX = size in ???
Return: AX = 0000h (successful)
	CX = DX = ???
SeeAlso: AX=0005h,AX=000Fh
--------N-6A0005-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - FREE/CLOSE ???
	AX = 0005h
	CX = ??? identifier (from AX=0004h)
Return: AX = status (0000h successful, FFFFh failed)
SeeAlso: AX=0004h,AX=000Fh
--------N-6A000F-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - FREE/CLOSE ALL ???
	AX = 000Fh
Return: AX = 0000h (successful)
SeeAlso: AX=0000h,AX=0004h,AX=0005h
--------N-6A0010-----------------------------
INT 6A U - Super-TCP DOS TSR Kernel v3.57 - UNINSTALL
	AX = 0010h
Return: AX = status
	    0000h successful
	    0002h can't uninstall, interrupt vector hooked by another program
Program: Super-TCP is a TCP/IP protocol stack by Frontier Technologies Corp.
Note:	if AX is not one of the values listed here on entry, Super-TCP
	  returns AX=FFFEh
SeeAlso: AX=0000h
--------N-6A01--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BYTE
	AH = 01h
	DH = FFh
	AL = character
	DL = handle
Return: AH >= 80h on error
SeeAlso: AH=02h
--------N-6A02--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - READ BYTE
	AH = 02h
	DH = FFh
	DL = handle
Return: AH < 80h if successful
	    AL = character
	AH >= 80h on error
SeeAlso: AH=01h
--------N-6A03--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - STATUS
	AH = 03h
	DH = FFh
	DL = handle
Return: AH = status flags (see #3358)

Bitfields for DECnet DOS LAT status flags:
Bit(s)	Description	(Table 3358)
 5	transmit buffer empty
 3	session in start state
 2	session not active
 1	unable to queue transmit data
 0	receive data available
--------N-6AD0--DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - OPEN SESSION
	AH = D0h
	DH = FFh
	AL = password flag
	    FFh no password
	    0Fh password at ES:DI
	ES:BX -> LAT session control block (see #3359)
	ES:DI -> 16-byte blank-padded password (optional)
Return: AH = 00h success
	    DL = handle
SeeAlso: AX=D000h

Format of LAT Session Control Block:
Offset	Size	Description	(Table 3359)
 00h 18 BYTEs	service name
 12h 18 BYTEs	node name (future use)
 24h 18 BYTEs	port name (future use)
 36h	DWORD	-> session stopped post routine
 3Ah	DWORD	-> service table overflow post routine
 3Eh	DWORD	-> transmit post routine
 42h	DWORD	-> receive post routine
 46h	WORD	session status
		04h circuit failure
		08h stop slot received
---LAT v???---
 48h	WORD	slot state (LAT driver use)
 4Ah	WORD	local credits (LAT driver use)
 4Ch	DWORD	-> VCB (LAT driver use)
 50h	WORD	backward slot (LAT driver use)
 52h	WORD	forward slot (LAT driver use)
 54h	WORD	remote slot ID (LAT driver use)
 56h	WORD	local slot ID (LAT driver use)
 58h	WORD	slot byte count (LAT driver use)
 5Ah	BYTE	remote credits (LAT driver use)
 5Bh 255 BYTEs	transmitted data slot
15Ah	BYTE	number of receive data slots (4 recommended)
15Bh	BYTE	number of occupied slots
15Ch	BYTE	index of next receive slot to use
15Dh	BYTE	index of current receive slot
15Eh	WORD	pointer to first received character
160h  N WORDs	pointers to receive slots (buffers); each is 259 bytes
     259N BYTEs	buffers
Note:	set post routines to 0000h:0000h if polled operation will be used
---LAT v4.1.17---
 48h	WORD	session state (LAT driver use)
 4Ah	BYTE	local credits (LAT driver use)
 4Bh	DWORD	-> VCB (LAT driver use)
 4Fh	WORD	backward slot (LAT driver use)
 51h	WORD	forward slot (LAT driver use)
 53h	BYTE	remote slot ID (LAT driver use)
 54h	BYTE	local slot ID (LAT driver use)
 55h	BYTE	slot byte count (LAT driver use)
 56h	BYTE	remote credits (LAT driver use)
 57h 255 BYTEs	transmitted data slot
156h	BYTE	number of receive data slots (4 recommended)
157h	BYTE	number of occupied slots
158h	BYTE	index of next receive slot to use
159h	BYTE	index of current receive slot
15Ah	WORD	pointer to first received character
15Ch  N WORDs	pointers to receive slots (buffers); each is 259 bytes
     259N BYTEs	buffers
Note:	set post routines to 0000h:0000h if polled operation will be used
--------N-6AD000DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - CLOSE SESSION
	AX = D000h
	DH = FFh
	DL = handle
Return: AX = status (see #3360)
SeeAlso: AH=D0h

(Table 3360)
Values for DECnet DOS LAT function status:
 0000h	successful
 0001h	no such session
 0002h	session not running, try again later
--------N-6AD100DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - SEND BREAK
	AX = D100h
	DH = FFh
	DL = handle
Return: AX = 0000h if successful
	AH bit 7 set if unable to send break
--------N-6AD300DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - RESET LAT COUNTERS
	AX = D300h
	DH = FFh
SeeAlso: AX=D400h
--------N-6AD400DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - COPY LAT COUNTERS
	AX = D400h
	DH = FFh
	CX = buffer size
	ES:BX -> buffer for LAT counters
Return: AX = status
	    0000h counters copied into buffer
	    FFFFh buffer too small
SeeAlso: AX=D300h
--------N-6AD500DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - GET NEXT LAT SERVICE NAME
	AX = D500h
	DH = FFh
	ES:BX -> 17-byte buffer for name
Return: AH = 00h if successful
	   ES:BX buffer filled
	AX = FFFFh if end of table or no name available
Notes:	use this function to get the names of the hosts on the network
	successive calls are necessary to get all names
SeeAlso: AX=D600h/DH=FFh
--------N-6AD600DHFF-------------------------
INT 6A - DECnet DOS LOCAL AREA TRANSPORT - LAT SERVICE TABLE RESET
	AX = D600h
	DH = FFh
Return: AX = number of service table entries
	BX = status
	    0000h service table has not overflowed
	    FFFFh service table has overflowed
SeeAlso: AX=D500h
--------N-6B---------------------------------
INT 6B - DECnet DOS - PORT DRIVER
Note:	the installation check consists of testing for a signature area
	  (see #3361) immediately preceding the interrupt handler
SeeAlso: INT 6A"DECnet",INT 6C"DECnet"
Index:	installation check;DECnet DOS Port Driver

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 3361)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "PDV")
--------v-6B---------------------------------
INT 6B - VIRUS - "Saddam" - ORIGINAL INT 21h VECTOR
SeeAlso: INT 21/AX=FFFFh,INT 61"VIRUS",INT 70"VIRUS"
--------h-6B---------------------------------
INT 6B C - HP Vectra AT - IRQ19 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0B"IRQ3",INT 6A"HP Vectra",INT 6C"HP Vectra"
--------S-6B0000-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED WRITE
	AX = 0000h
	CX = length
	ES:BX -> buffer
Return: CX = number of bytes written
Program: NASI is Novell's NetWare Asynchronous Services Interface (purchased
	  from Network Products Corp, who call it NCSI) which runs on
	  workstations; NACS is the NetWare Asynchronous Communications
	  Services module which runs on servers
Notes:	the installation check consists of testing for the signature string
	  "NCSI" three bytes past the interrupt handler; see also AH=02h.
	  As of version 3.0, Novell's NASI can be distinguished from NPC's
	  NCSI by the presence of an 'A' immediately following the signature
	this function is also supported by TelAPI, NPC NCSI, and Connection
	  Manager CLIENT.EXE; for TelAPI, nonzero values in AL specify a
	  connection ID
	Connection Manager returns CF set/AL=FFh if called while an INT 6B
	  call is already in progress
SeeAlso: AX=0100h,AH=18h,INT 14/AH=19h,INT 14/AH=E3h
--------S-6B0100-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - BUFFERED READ
	AX = 0100h
	CX = length of buffer
	ES:BX -> buffer
Return: CX = number of bytes read
Note:	also supported by TelAPI and NPC NCSI; for TelAPI, nonzero values in
	  AL specify a connection ID
SeeAlso: AX=0000h,AH=19h,INT 14/AH=18h,INT 14/AH=E2h,INT 14/AX=FF02h
--------S-6B02-------------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - INSTALL CHECK
	AH = 02h
	AL nonzero
Return: AL = 00h if present and OK
Note:	this function is also supported by TelAPI and NPC NCSI
SeeAlso: AX=0700h
--------S-6B0600-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - CONTROL
	AX = 0600h
	CX = command
	    02h send break
	    04h disconnect
	    06h hold
Return: CF clear if successful
	    AL = 00h
	CF set on error
	    AX < 0
Note:	this function is also supported by TelAPI and NPC NCSI
--------S-6B0700-----------------------------
INT 6B - Novell NASI/NACS, Ungermann-Bass Net One SERIAL I/O - GET STATUS
	AX = 0700h
Return: CH <> 00h if connection active
Notes:	this function is also supported by TelAPI and NPC NCSI
	Novell TelAPI returns CX=FF01h and CF clear
SeeAlso: AH=02h,AH=10h
--------N-6B08-------------------------------
INT 6B - TelAPI - CHECK FOR BREAK SIGNAL
	AH = 08h
	AL = circuit number
Return: CF clear if no breaks
	    AL = 00h
	    CX = 0000h
	CF set if one or more breaks received
Note:	this function also clears ??? flag
SeeAlso: INT 14/AX=FF00h
--------S-6B10-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - GET STATUS
	AH = 10h
	AL = connection ID (Novell TELAPI.EXE)
	CX = ???
	ES:BX -> buffer for status (see #3362)
Return: CF clear if successful
	    CL = ???
	    CH = ???
	CF set on error
	???
Notes:	this function is also supported by TelAPI
	when shelled out to an external protocol from Novell NASI, the circuit
	  whose status indicates that it is connected is the currently active
	  circuit
SeeAlso: AX=0700h,AH=12h,AH=1Fh

Format of NASI status:
Offset	Size	Description	(Table 3362)
 00h	BYTE	number of allocated virtual circuits
 01h	BYTE	reserved
 02h  9 BYTEs	states of emulated circuits 0-8
		00h idle
		01h attached Telnet session, in command state
		02h attached Telnet session, connected with host
		03h-06h ??? (not returned by TelAPI)
Note:	this description is derived from the Novell TelAPI emulation of NASI
--------S-6B11--DX0001-----------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - ALLOCATE A VIRTUAL CIRCUIT
	AH = 11h
	DX = 0001h
	AL = 00h
	ES:BX -> service name string (8 characters, blank-padded)
Return: CF clear if successful
	    AL = virtual circuit number allocated (01h for Novell TELAPI.EXE)
	    CL = ??? (01h for Novell TELAPI.EXE)
	    CH = ??? (01h for Novell TELAPI.EXE)
	CF set on error
	    ???
Note:	this function is also supported by TelAPI
SeeAlso: AH=12h,AH=15h,AH=16h,AH=17h,AH=18h
--------S-6B12-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - VIRTUAL CIRCUIT STATUS
	AH = 12h
	AL = virtual circuit number (0-8)
Return: CF clear if successful
	    AL = virtual circuit number
	    CL = virtual circuit's state
		00h idle
		01h Telnet session, in command state
		02h Telnet session, connected to host
		03h-06h ??? (not returned by TelAPI)
	CF set on error
	    AL = error code
		E2h invalid virtual circuit number
		E4h specified virtual circuit not allocated
Note:	this function is also supported by TelAPI
SeeAlso: AH=10h,AH=15h,AH=1Ah,AH=1Bh,AH=1Fh
--------S-6B13-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE REQUEST/REPLY SERVICE NAME
	AH = 13h
	AL = virtual circuit number
	CL = direction (00h get, nonzero set)
	ES:BX -> buffer for/containing service name
Return: ???
Note:	this function is also supported by TelAPI
SeeAlso: AH=14h,AH=15h
--------S-6B14-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE SERVICE ADDRESS
	AH = 14h
	AL = virtual circuit number
	ES:BX -> buffer for/containing service address
Return: ???
Note:	this function is also supported by TelAPI, which only supports
	  retrieving the address
SeeAlso: AH=13h,AH=15h,AH=21h
--------S-6B15-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - SET/RETRIEVE VIRTUAL CIRCUIT CONFIG
	AH = 15h
	AL = virtual circuit number
	CL = direction (00h get, nonzero set)
	ES:BX -> buffer for/containing virtual circuit config (see #3363)
Return: ES:BX buffer filled
Note:	this function is also supported by TelAPI
SeeAlso: AH=13h"NCSI",AH=14h"NCSI"

Format of virtual circuit configuration:
Offset	Size	Description	(Table 3363)
 00h	WORD	buffer length
 02h	WORD	port ID
 04h	WORD	receive rate
 06h	WORD	receive word length
 08h	WORD	receive stop bits
 0Ah	WORD	receive parity
 0Ch	WORD	transmit rate
 0Eh	WORD	transmit word length
 10h	WORD	transmit stop bits
 12h	WORD	transmit parity
 14h	WORD	DTR
 16h	WORD	RTS
--------S-6B16-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - LOG AND/OR INITIALIZE VIRTUAL CIRCUIT
	AH = 16h
	AL = virtual circuit number
	CL = ??? switch (00h, ???)
Return: CF clear if successful
	    AL = virtual circuit number
	CF set on error
	    ???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=00h
SeeAlso: AH=11h,AH=12h,AH=17h
--------S-6B17-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - DISCONNECT A VIRTUAL CIRCUIT
	AH = 17h
	AL = virtual circuit number
Return: CF clear if successful
	CF set on error
	???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=00h
SeeAlso: AH=11h,AH=16h
--------S-6B18-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - WRITE DATA ON A VIRTUAL CIRCUIT
	AH = 18h
	AL = virtual circuit number
	CX = number of characters to send
	ES:BX -> buffer containing characters to be sent
Return: CF clear if successful
	CF set on error
	???
Note:	this function is also supported by TelAPI, which always returns CF
	  clear and AL=30h
SeeAlso: AX=0000h,AH=12h,AH=19h
--------S-6B19-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - READ DATA ON A VIRTUAL CIRCUIT
	AH = 19h
	AL = virtual circuit number
	CX = number of characters to read
	ES:BX -> buffer for received characters
Return: CX = 0000h if failed
	CX = nonzero (possibly number of characters received) if successful
Note:	this function is also supported by TelAPI
SeeAlso: AX=0100h,AH=12h,AH=18h
--------S-6B1A-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - RECEIVE STATUS
	AH = 1Ah
	???
Return: ???
SeeAlso: AH=12h,AH=1Bh
--------S-6B1B-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - TRANSMIT STATUS
	AH = 1Bh
	???
Return: ???
SeeAlso: AH=12h,AH=1Ah
--------S-6B1C-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - CLEAR RECEIVE BUFFER
	AH = 1Ch
	AL = circuit number
Return: nothing
SeeAlso: AH=1Dh"NCSI",AH=1Eh"NCSI"
--------S-6B1D-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - TRANSMIT BUFFER CONTROL
	AH = 1Dh
	???
Return: ???
SeeAlso: AH=1Ch,AH=1Eh
--------S-6B1E-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - ISSUE CONTROL REQUEST
	AH = 1Eh
	???
Return: ???
SeeAlso: AH=1Ch,AH=1Dh
--------S-6B1F-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - EXTERNAL STATUS
	AH = 1Fh
	???
Return: ???
SeeAlso: AH=10h,AH=12h
--------S-6B20-------------------------------
INT 6B - Connection Manager CLIENT.EXE - ???
	AH = 20h
	???
Return: ???
Program: Connection Manager by Softwarehouse Corp. permits the sharing of
	  serial ports over an IPX or NetBIOS-based network
Note:	CLIENT.EXE returns CF set/AL=F9h if AH is not 00h to 21h on entry
--------S-6B21-------------------------------
INT 6B - NPC NCSI EXTENDED SERIAL I/O - QUERY NAME SERVICE
	AH = 21h
	AL = virtual circuit number
	CL = ??? (00h or 01h)
	ES:BX -> buffer for service name structure (see #3364)
Return: CF clear if successful
	    ES:BX buffer filled
	CF set on error
Notes:	a program should call this function after allocating a virtual circuit
	  and check that the general name matches the requested service
	prior to version 3.0, Novell's NASI returned the first available port;
	  v3.0+ returns the first port found--check the returned status to
	  determine whether the port is available
SeeAlso: AH=14h"NCSI"

Format of NCSI service name structure:
Offset	Size	Description	(Table 3364)
 00h	WORD	buffer length
 02h  8 BYTEs	service name
 0Ah  8 BYTEs	general name
 12h  8 BYTEs	specific name
 1Ah  4 BYTEs	???
---Novell NASI v3.0+ ---
 1Eh	BYTE	port number
 1Fh	BYTE	port status
		00h idle (available)
		01h allocated (available)
		02h connected
		03h on hold
----------6B6B-------------------------------
INT 6B - Tandy SCHOOLMATE PLUS - API
	AH = 6Bh
	AL = E0h to FFh
Note:	details not yet available
----------6C---------------------------------
INT 6C - system resume vector (CONVERTIBLE)
----------6C---------------------------------
INT 6C - DOS 3.2 Realtime Clock update
--------N-6C---------------------------------
INT 6C - DECnet DOS network scheduler
Notes:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #3365)
	also supported by DEC Pathworks for DOS
SeeAlso: INT 6B"DECnet",INT 6D"DECnet",INT 6E"DECnet"
Index:	installation check;DECnet DOS scheduler

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 3365)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "SCH")
--------h-6C---------------------------------
INT 6C C - HP Vectra AT - IRQ20 - HP-HIL CONTROLLER INTERRUPT
SeeAlso: INT 0C"IRQ4",INT 6B"HP Vectra",INT 6D"HP Vectra"
--------V-6D---------------------------------
INT 6D - VIDEO - many VGA - VIDEO BIOS ENTRY POINT
Desc:	points at the original INT 10 entry point set up by the VGA BIOS
Notes:	used by IBM, ATI VGA Wonder, Paradise, Video7, and NCR, and many others
	the Diamond Stealth64 BIOS uses this vector to store the INT 42 vector
	   of the inactive video (see INT 10/AH=12h/BL=35h)
SeeAlso: INT 10/AH=00h,INT 10/AH=0Eh,INT 10/AH=12h/BL=10h
--------V-6D---------------------------------
INT 6D - Trident SVGA - VIDEO BIOS HANDLER
Note:	the BIOS INT 10 handler on various Trident VGA cards consists merely
	  of a call to INT 6D followed by an IRET.
--------N-6D---------------------------------
INT 6D - DECnet DOS (before 2.1) - DATA LINK LAYER PROGRAM
	AH = function
	???
Return: ???
Note:	the installation check consists of testing for a signature area
	  immediately preceding the interrupt handler (see #3366)
SeeAlso: INT 69/AH=0Ah,INT 6C"DECnet",INT 6E"DECnet"
Index:	installation check;DECnet DOS Data Link Layer

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 3366)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "DLL")
--------h-6D---------------------------------
INT 6D C - HP Vectra AT - IRQ21 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0D"IRQ5",INT 6C"HP Vectra",INT 6E"HP Vectra"
--------V-6DBD60-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - ???
	AX = BD60h
	DS:SI -> buffer containing ??? (see #3367)
	???
Return: AX = 00BDh if function executed
	   ???:SI -> 22-byte buffer (inside TSR) filled with ??? (see #3367)
	AX unchanged if function disabled
Note:	this function is a NOP if AX=BD6Fh/BL=01h was called
SeeAlso: AX=BD61h,AX=BD6Fh,AX=BDFFh

Format of Matrox ??? buffer:
Offset	Size	Description	(Table 3367)
 00h  4 BYTEs	???
 04h	WORD	video mode width in pixels
 06h	WORD	video mode height in pixels
 08h	BYTE	???
 09h	BYTE	???
 0Ah	BYTE	???
 0Bh	BYTE	flags
		bit 1: ???
		bit 4: ??? (corresponds to bit 14 for AX=BD61h)
		bit 5: ??? (corresponds to bit 15 for AX=BD61h)
 0Ch	DWORD	-> ??? buffer
 10h	WORD	???
		bit 4: ??? (corresponds to bit 14 for AX=BD61h)
		bit 5: ??? (corresponds to bit 15 for AX=BD61h)
 12h  4 BYTEs	???
SeeAlso: #3368
--------V-6DBD61-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - GET VIDEO MODE INFORMATION
	AX = BD61h
	BX = width in pixels (bits 13-0)
	    bit 14: ???
	    bit 15: ???
	CX = height in pixels
Return: AL = BDh if function supported
	    AH = status
		00h successful
		01h failed (resolution/flags not supported)
	    CX:BX -> video mode data structure (see #3368)
		  (first word is FFFFh if unsupported resolution)
	    EAX high word cleared
SeeAlso: AX=BD60h,AX=BD6Fh,AX=BDFFh

Format of Matrox video mode information (VCE structure):
Offset	Size	Description	(Table 3368)
 00h	WORD	width in pixels
 02h	WORD	height in pixels
 04h	WORD	???
 06h	DWORD	dot clock frequency
 0Ah 25 BYTEs	???
SeeAlso: #3367
--------V-6DBD6F-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - INSTALLATION CHECK
	AX = BD6Fh
	BL = subfunction
	    00h installation check
	    01h disable TSR
	    02h enable TSR (see AX=BD60h)
Return: AX = 00BDh if installed
SeeAlso: AX=BD60h,AX=BD61h,AX=BDFFh
--------V-6DBDFF-----------------------------
INT 6D U - Matrox Multiple Monitor Support v1.0 - UNHOOK INTERRUPT (UNINSTALL)
	AX = BDFFh
Return: AX = 00BDh if supported
Note:	this function revectors INT 6D without checking that it points at the
	  TSR, and does not release the memory occupied by the TSR
SeeAlso: AX=BD60h,AX=BD61h,AX=BD6Fh
--------N-6E---------------------------------
INT 6E - DECnet DOS - DECnet NETWORK PROCESS API
Notes:	this is the main DECnet DOS access, and is described in Digital manual
	  AA-EB46B-TV ("DECnet-DOS Programmer's Reference Manual")
	there is a signature/data area immediately prior to the interrupt
	  handler which may be used as an installation check (see #3369)
Index:	installation check;DECnet DOS

Format of DECnet DOS signature area:
Offset	Size	Description	(Table 3369)
 -5	BYTE	major version number
 -4	BYTE	minor version number
 -3   3 BYTEs	signature (ASCII "DNP")
--------h-6E---------------------------------
INT 6E C - HP Vectra AT - IRQ22 - RESERVED HARDWARE INTERRUPT
SeeAlso: INT 0E"IRQ6",INT 6D"HP Vectra",INT 6F/AH=00h"HP Vectra"
--------N-6F---------------------------------
INT 6F - Novell NetWare - PCOX API (3270 PC terminal interface)
	AX = function
	    0000h enter terminal mode
		Return: AX = status
			    0000h no action requested
			    0001h screen save
	    0001h reset interface and set configuration parameters
		DX = bitfields
		    bits 2-0: model number
		    bits 4-3: I/O address
		    bits 6-5: DMA channel
		Return: nothing
	    0002h set display parameters
		DX = bitfields
		    bits 1-0: OIA mode
		    bits 4-2: monitor support
		Return: nothing
	    0003h read status
		Return: AX = status word (see #3370)
	    0004h read cursor position
		Return: AX = cursor position
	    0005h get character from device buffer
		DX = cursor position
		Return: AH = type (00h data, 01h attribute)
			AL = data or attribute character
	    0006h send character
		DH = type (00h ASCII, 01h extended code)
		DL = ASCII character or extended code
		Return: nothing
	    0007h set timeout
		DX = timeout in seconds
		Return: nothing
	    0008h wait for location to be modified
		DX = cursor position
		Return: AX = status (0000h modified, nonzero timeout)
	    0009h NOP
	    000Ah restore display
		Return: nothing
	    000Bh update device buffer
		Return: AX = cursor positoin
	    000Ch write string to add information area
		DS:DX -> string
		Return: nothing
	    000Dh maintenance operations
		DX = maintenance operation code
		Return: AX = operation status
	    000Eh get control program version
		Return: AH = release number (major version)
			AL = level number (minor version)
	    000Fh get microcode version
		Return: AH = release number (major version)
			AL = level number (minor version)
	    0010h save or display graphics
		BX = length of data buffer
		CX = subfunction request code
		DS:DX -> data buffer
		Return: AX = return code
			CX = length of PIF data
	    0011h perform structured field operation
		CX = request number
		DS:DX -> parameter list
		Return: AX = status word (see #3370)
			CX = error number
	    0012h set cursor position for direct write buffer
		DX = new cursor position
		Return: AX = status word (see #3370)
	    0013h write direct to buffer
		DL = character to be written
		DH = translation option
		Return: AX = status word (see #3370)
	    0014h write direct to buffer without echo
		DL = character to be written
		DH = translation option
		Return: AX = status word (see #3370)
	    0015h set direct write string length
		DX = string value
		Return: nothing
	    0016h write string direct to buffer
		DS:DX -> string
		Return: AX = status word (see #3370)
	    0017h write string direct to buffer, untranslated
		DS:DX -> string
		Return: AX = status word (see #3370)
	    0018h get direct-write cursor position
		Return: AX = cursor position
	    0019h convert row/column to cursor position
		DH = display row (1-43)
		DL = display column (1-132)
		Return: AX = cursor position
	    001Ah convert cursor position to row/column
		DX = cursor position
		Return: AH = display row
			AL = display column
	    001Bh find next field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Ch find previous field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Dh find next unprotected field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Eh find previous unprotected field
		DX = initial cursor position
		Return: AX = field cursor position
	    001Fh find next protected field
		DX = initial cursor position
		Return: AX = field cursor position
	    0020h find previous protected field
		DX = initial cursor position
		Return: AX = field cursor position
	    0021h masked search forward
		DH = mask
		DL = search pattern
		Return: AX = cursor position or 0000h
	    0022h masked search backward
		DH = mask
		DL = search pattern
		Return: AX = cursor position or 0FFFh
	    0023h find field length
		DX = cursor position
		Return: AX = field length
	    0024h read field
		DS:DX -> buffer for field contents
		Return: AX = status word (see #3370)
	    0025h read screen
		DS:DX -> buffer for screen contents
		Return: AX = status word (see #3370)
	    0026h read buffer untranslated
		DX = cursor position
		Return: AX = buffer code
			CX:BX -> 3278/79 device buffer image
	    0027h enable/disable keyboard
		DL = new state of keyboard breaks (00h enabled, 01h disabled)
		Return: nothing
	    0028h select host session
		DL = session short name
		Return: AX = session information
	    0029h retrieve host session name
		AX = short name (DFT) or 0000h (not available, CUT mode)
	    002Ah get current device buffer size
		Return: AX = device buffer size
			CX = segment of EAB
	    002Bh arm modified location trigger
		DX = cursor position
		Return: AX = status (0000h not available, 0001h successful)

Bitfields for PCOX status word:
Bit(s)	Description	(Table 3370)
 0,1	cursor type
 2	cursor inhibited
 3	display inhibited
 4	feature step inhibited
 5	480-character format code
 6,7	unused
 8-10	model number (2-5)
 11	unit has been reset by controller (cleared after status returned)
 12	buffer has been written into (cleared after status returned)
 13	alarm has been sounded (cleared after status returned)
 14-15	monitor type (01 mono, 10 color, 11 hybrid)
--------N-6F00-------------------------------
INT 6F - 10NET - LOGIN
	AH = 00h
	DS:DX -> login record (see #3371)
Return: CL = security level
	AX = status (see #3372)
SeeAlso: AH=01h,AH=80h,INT 21/AX=4402h"10MEMMGR"

Format of 10NET login record:
Offset	Size	Description	(Table 3371)
 00h  8 BYTEs	user name
 08h  8 BYTEs	password
 10h 12 BYTEs	name of SuperStation

(Table 3372)
Values for 10NET status:
 0000h	successful
 01FFh	"RTO_NERR" transmit interrupt lost (time out on response)
 02FFh	"NET_NERR" network (hardware) error
 03FFh	"PAS_NERR" invalid password
 04FFh	"LRN_NERR" local resource not available
 05FFh	"SRN_NERR" server resource not available
 06FFh	"LNM_NERR" already logged in under different name
 07FFh	"LSF_NERR" login security failure (node)
 08FFh	"NLI_NERR" not logged in
 09FFh	"DIVZ_NERR" position calc error
 0AFFh	"NT1_NERR" receive subfunction not = send subfunction (i.e. read,write)
 0BFFh	"RFNC_NERR" request function not in range
 0CFFh	"NSFH_NERR" no more server file handle entries left
 0DFFh	"NFTAB_NERR" no more shared file table entries left
 0EFFh	"NUFH_NERR" no more user file handle entries left
 0FFFh	"CHAT_NERR" chat permit not on
 10FFh	"NSRV_NERR" not a server on request
 11FFh	"NOBD_NERR" no transporter board error
 12FFh	"STO_NERR" time out on send
 13FFh	"INF_NERR" item not found (spool item not on queue)
 14FFh	"DACS_NERR" DOS access incompatible
 15FFh	"RLOCK_NERR" record already locked
 16FFh	"IVP_NERR" invalid parameter
 17FFh	"RLTO_NERR" record lock time out error
 18FFh	"CSPL_NERR" currently spooling to named device
 19FFh	"DRP_NERR" dropped receive message (throttle)
 1AFFh	"SOPV_NERR" open sharing violation
 1BFFh	"NTUF_NERR" no more tuf entries left
 1CFFh	"NOWN_NERR" not file owner on open
 1DFFh	"RSEC_NERR" read security not passed
 1EFFh	"WSEC_NERR" write security not passed
 1FFFh	"GSEC_NERR" group security not passed
 20FFh	"SEC1_NERR" security file failure
 21FFh	"ACT1_NERR" activity file failure
 22FFh	"SPL1_NERR" spool control file failure
 23FFh	"NMT_NERR" device not mounted (spooling)
 24FFh	"RSPL_NERR" spool file has not been terminated
 25FFh	"DNSH_NERR" device not mounted or is not being shared
 26FFh	"DUP_NERR" duplicate node ID
 27FFh	"FNF_NERR" file not found error
 28FFh	"NMF_NERR" no more files
 29FFh	"UN_NERR" unknown internal system error
 2AFFh	"QCP_NERR" print queue is full or corrupted
 2BFFh	"IFNC_NERR" invalid function
 2CFFh	"IVH_NERR" invalid handle
 2DFFh	"TOF_NERR" too many files opened
 2EFFh	"PNF_NERR" path not found
 2FFFh	"SACT_NERR" named file is active
---10NET v5.0+ ---
 30FFh	"NAK_NERR" received NAK on send (destination out of buffers)
 31FFh	"RENT_NERR" reentrancy in driver F_SEND
 32FFh	"RECV_NERR" driver could not be put in receive mode
 33FFh	"NRLT_NERR" no more RLTAB entries left
 34FFh	"DIAL_NERR" function requires an unsupported dialect
 35FFh	"IVD_NERR" invalid device
 36FFh	"NALV_NERR" netname access level violated
 37FFh	"NPIDNF_NERR" network path not found
 38FFh	"SP_NERR" server is paused
 39FFh	"TMNM_NERR" too many remote user names
 3AFFh	"DUPD_NERR" duplicate network device
 3BFFh	"DIU_NERR" shared device in use, can't delete
 3CFFh	"NNWD_NERR" network name was deleted
 3DFFh	"NPFS_NERR" not enough space for print file
 3EFFh	"NNNF_NERR" network name not found (can't find the call name)
 3FFFh	"NB_NERR" network busy
 40FFh	"NDNLE_NERR" network device no longer exists
 41FFh	"NBCLE_NERR" NetBIOS command limit exceeded
 42FFh	"FINT24_NERR" Fail on INT 24h
 43FFh	"PEXP_NERR" password expired
 44FFh	"NPUP_NERR" new password error
 45FFh	"MAXS_NERR" maximum allowed disk space exceeded
 46FFh	"TDOW_NERR" time-of-day/day-of-week error
SeeAlso: #3399
Index:	error codes;10Net|10Net;error codes
--------b-6F00-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_ISR" (internal) - RESPOND TO LOGICAL ISR
	AH = 00h
	BP = ID for driver (see #3373)
	DH = data type (see #3374)
	DL = physical device driver's index (driver ID / 6)
	BX,CX = data
	ES:0000h -> physical device's Describe Record (see #3381)
	---keypress event data---
	    BH = keyboard state (only if bit 5 of DH set) (see #3375)
	    BL = scancode (if bit 4 of DH clear)
	    CX = number of scancodes in list (if bit 4 of DH set)
	    ES:SI -> scancode list (if bit 4 of DH set)
	---motion event data---
	    BX = new X position (abs device) or X increment (relative device)
	    CX = new Y position (abs device) or Y increment (relative device)
	---button event data
	    BL = button information
		bits 15-8 reserved
		bit 7: button state (0 = down, 1 = up)
		bits 6-0: button number (0-7)
	    BH = reserved
Return: AH = status (see #3376)
	BP,DS destroyed
	---if device is keyboard translator---
	    BL = translated scancode
	    BH = new keyboard state (if DH bit 5 set) (see #3375)
	    DH = new scancode type (see #3374)
Notes:	INT 6F corresponds to IRQ23 on the original HP Vectra AT, which is
	  unavailable because of its use as a BIOS extension software interrupt
	the INT 6F handler consists of an instruction to load DS with the
	  driver's data segment followed by an indexed far jump using BP to
	  select the destination vector; since the interrupt handler is
	  located immediately following the dispatch table, the HP_VECTOR_TABLE
	  may be found by looking at offset 0000h in the INT 6F segment, and
	  its size is equal to the offset of the interrupt handler
	each entry in the HP_VECTOR table consists of a DWORD for the driver's
	  entry point address and a WORD for the driver's data segment
	this function is not user-callable, as it is a response to a physical
	  event, and assumes that the caller has already handled the physical
	  interrupt and updated the Describe Record (see #3381) to reflect
	  the event
SeeAlso: INT 6C"HP Vectra",INT 6F/AX=0200h"HP Vectra"

(Table 3373)
Values for HP Vectra EX-BIOS driver ID:
 0000h	V_SCOPY (null driver, but DS value points at system copyright string)
 0006h	V_DOLITTLE (null driver)
 000Ch	V_PNULL (null driver)
 0012h	V_SYSTEM
 0018h	reserved
 001Eh	V_S8259
 0024h	reserved
 002Ah	V_SINPUT
 0030h	reserved
 0036h	V_QWERTY (keyboard translator)
 003Ch	V_SOFTKEY (keyboard translator)
 0042h	V_FUNCTION (keyboard translator)
 0048h	V_NUMPAD (keyboard translator)
 004Eh	V_CCP (keyboard translator)
 0054h	V_SVIDEO
 005Ah	V_STRACK
 0060h	V_EVENT_TOUCH
 0066h	V_EVENT_TABLET
 006Ch	V_EVENT_POINTER
 0072h	reserved
 0078h	reserved
 007Eh	reserved
 0084h	reserved
 008Ah	V_CCPCUR (keyboard translator)
 0090h	V_RAW (keyboard translator)
 0096h	V_CCPNUM (keyboard translator)
 009Ch	V_OFF (keyboard translator)
 00A2h	V_CCPGID (translator: cursor control pad keys to GID data)
 00A8h	V_SKEY2FKEY (keyboard translator)
 00AEh	V_8041
 00B4h	V_PGID_CCP
 00BAh	C_LTABLET
 00C0h	V_LPOINTER (pointing device: mouse, etc.)
 00C6h	V_LTOUCH (touch screen)
 00CCh	V_LHPMOUSE
 00D2h	???
 ...
 0102h	???
 0108h	V_LNULL
 010Eh	reserved
 0114h	V_HPHIL
 011Ah-01C2h reserved
 016Eh	V_SCANDOOR (scancode management chip driver) (ES/QS/RS only)
 01C8h-0228h available

(Table 3374)
Values for HP Vectra EX-BIOS ISR data type:
 00h	reserved "T_KC_R0"
 01h	reserved "T_KC_R1"
 02h	ASCII data
 03h	reserved "T_KC_R3"
 04h	HP150 keyboard (ITF) scancode
 05h	reserved "T_KC_R5"
 06h	device-definable type
 07h	HP Vectra keyboard set
 08h	IBM AT scancode set
 09h	button data
 0Ah	IBM PC scancode set
 0Bh	Softkey keypad (F1-F8)
 0Ch	function key keypad (F1-F10)
 0Dh	HP Cursor Control Pad keypad
 0Eh	Qwerty keypad
 0Fh	Numeric keypad
 1xh	bit 4 set: string of CX scancode of type 0xh at ES:SI
 2xh	bit 5 set: BH contains current keyboard state
 40h	signed 8-bit relative data
 41h	signed 16-bit relative data
 42h	unsigned 8-bit absolute data
 43h	unsigned 16-bit absolute data
 45h	specially-formed data (80x25) generated by V_LTOUCH
 46h	specially-formed data (640x200) generated by V_LTABLET
 47h	specially-formed data (640x200) generated by V_LPOINTER

Bitfields for HP Vectra EX-BIOS keyboard state:
Bit(s)	Description	(Table 3375)
 0	Alt pressed
 1	Left Shift pressed
 2	Right Shift pressed
 3	Ctrl pressed
 4	CapsLock active
 5	NumLock active
 6	Right unlabeled key pressed (some international keyboards)
 7	Left unlabeled key pressed (some international keyboards)
SeeAlso: #0499

(Table 3376)
Values for HP Vectra EX-BIOS status:
 00h	successful
 02h	unsupported function
 04h	not serviced
 06h	done (no further processing should be performed on the ISR event)
 F2h	device is out of paper
 F4h	device is offline
 F6h	no more space for more drivers
 F8h	driver is busy
 FAh	bad parameter
 FEh	operation failed
Note:	status codes are always even; negative values (>= 80h) indicate errors
	  while positive values indicate exceptional conditions

Format of HP EX-BIOS driver header data:
Offset	Size	Description	(Table 3377)
 00h	WORD	driver attributes (see #3378)
 02h	WORD	string index of driver's name
 04h	WORD	driver's default logical device vector (see #3373)
 06h	WORD	driver's parent class (bitset) (see #3379)
 08h	WORD	driver's child class (bitset)
 0Ah	WORD	driver's parent vector
 0Ch	WORD	driver's child vector
 0Eh	BYTE	major subaddress
 0Fh	BYTE	minor subaddress
Notes:	this structure is located at offset 0 in the driver's data segment,
	  which in turn may be read from the HP_VECTOR_TABLE (refer to note in
	  main entry)
	only the first WORD is required, and everything from offset 6 onward
	  is only required if the device wishes to perform device mapping
SeeAlso: #3380,#3381

Bitfields for HP EX-BIOS driver header attributes:
Bit(s)	Description	(Table 3378)
 15	this is a complete driver header
 14	"ATR_DEVCFG" reserved
 13	driver can be mapped with the parent vector at offset 0Ah
 12	driver can be mapped with the child vector at offset 0Ch
 11-9	driver type
	000 reserved vector
	001 free vector
	010 EX-BIOS service
	011 logical driver (mapped from parent to child)
	100 mappable driver (cannot be last in driver chain)
	101 mappable driver that is last in driver chain
	110 input driver (mappable)
	111 reserved
 8	"ATR_STRING" reserved
 7	call SF_START whenever driver is remapped
 6-5	addressing requirements
	00 no subaddresses required
	01 requires major address be stored at offset 0Eh
	10 requires minor address be stored at offset 0Fh
	11 required major,minor, and mid addresses (minor in low nybble of
	      offset 0Fh, mid address in high nybble of 0Fh)
 4	driver can be shared between several parent drivers
 3	driver can be shared between several child drivers
 2	this driver header is in ROM
 1	"ATR_YIELD" reserved
 0	reserved
SeeAlso: #3377,#3379

Bitfields for HP EX-BIOS driver class:
Bit(s)	Description	(Table 3379)
 15	maps F1 to F8 softkeys
 14	keyboard
 13	cursor pad
 12	console device
 11	serial output device (may be capable of limited input)
 10	"CL_COMM" reserved
 9	interfaces multiple resources transparent to operating system
 8	serial output device filter (can be mapped between logical and physical
	  driver to perform translations)
 7	addressed block device
 6	priority boot device
 5	logical graphics input device
 4	physical graphics input device (can map to child of another driver)
 3	"CL_GID" can map to an event
 2	physical touch device
 1	reserved
 0	class extension bit
Note:	special values: FFFFh maps to all other devices (V_PNULL), and 0000h
	  maps to no other driver
SeeAlso: #3377

Format of HP EX-BIOS global data area:
Offset	Size	Description	(Table 3380)
 00h 20 BYTEs	reserved
 14h	BYTE	sound driver status
 15h	BYTE	number of pending key clicks (max 4) (see AH=34h/BP=0012h)
 16h	BYTE	current tick duration scaling factor
 17h	BYTE	current key click volume
 18h	WORD	current beep period (10 us increments) (see AH=3Ch/BP=0012h)
 1Ah	WORD	current beep duration (10 us increments)
 1Ch	BYTE	number of pending beep functions (max 4) (see AH=3Ah/BP=0012h)
 1Dh	BYTE	reserved
 1Eh	WORD	next unused string index number
 20h	...	reserved
SeeAlso: #3377

Format of HP EX-BIOS Driver Describe Record:
Offset	Size	Description	(Table 3381)
 00h 16 BYTEs	EX-BIOS driver header data (see #3377)
 10h	BYTE	device GID type
		bits 7-4: device type
		bits 3-0: physical device link address
 11h	BYTE	physical device ID (see #3383)
 12h	WORD	logical device status bits (see #3382)
 14h	BYTE	physical device vector number (driver ID / 6)
 15h	BYTE	maximum number of axes reported (0-2)
 16h	BYTE	device class
		bits 7-4: current class
		bits 3-0: default class
 17h	BYTE	number of buttons/prompts
		bits 7-4: number of prompts
		bits 3-0: number of buttons
 18h	BYTE	reserved
 19h	BYTE	(physical devices only) maximum output burst length
 1Ah	BYTE	(physical devices only) number of write registers
 1Bh	BYTE	(physical devices only) number of read registers
 1Ch	BYTE	button transition flags (bit 0 = button0, etc.)
 1Dh	BYTE	current button states (bit 0 = button0, etc.)
 1Eh	WORD	device resolution
 20h	WORD	maximum x-axis count
 22h	WORD	maximum y-axis count
 24h	WORD	X position data for absolute devices
 26h	WORD	Y position data for absolute devices
 28h	WORD	X delta for relative devices
 2Ah	WORD	Y delta for relative devices
 2Ch	WORD	(logical devices only) X-axis scaling accumulator
		(fraction of one logical unit)
 2Eh	WORD	(logical devices only) Y-axis scaling accumulator
		(fraction of one logical unit)

Bitfields for HP logical device status flags:
Bit(s)	Description	(Table 3382)
 15-5	reserved
 4	event enabled
 3	tracking enabled
 2	clipping enabled
 1	button error occurred
 0	interrupt in progress
SeeAlso: #3381

(Table 3383)
Values for HP-HIL device ID:
 00h-02h reserved
 03h	Swiss-French keyboard
 04h-06h reserved
 07h	Canadian-English keyboard
 08h-0Ah reserved
 0Bh	Italian keyboard
 0Ch	reserved
 0Dh	Dutch keyboard
 0Eh	Swedish keyboard
 0Fh	German keyboard
 10h-12h reserved
 13h	Spanish keyboard
 14h	reserved
 15h	Belgian (Flemish) keyboard
 16h	Finnish keyboard
 17h	UK keyboard
 18h	French-Canadian keyboard
 19h	Swiss-German keyboard
 1Ah	Nerwegian keyboard
 1Bh	Frensh keyboard
 1Ch	Danish keyboard
 1Dh	Katakana keyboard
 1Eh	Latin American-Spanish keyboard
 1Fh	US-American keyboard
 20h-2Bh reserved
 2Ch-2Fh tone generator
 30h-3Fh reserved
 40h-5Bh reserved (character entry)
 5Ch-5Fh barcode reader
 60h-67h reserved (relative positions)
 68h-6Bh mouse
 6Ch-6Fh trackball
 70h-7Fh reserved (relative positions)
 80h-87h reserved (absolute positions)
 88h-8Bh touchpad
 8Ch-8Fh touch screen
 90h-97h graphics tablet
 98h-9Fh reserved (absolute positions)
 A0h-BFh compressed keyboard (91-93 keys)
 C0h-DFh extended keyboard (107-109 keys)
 E0h-FFh standard keyboard (85-87 keys)
--------N-6F01-------------------------------
INT 6F - 10NET - LOGOFF
	AH = 01h
	DS:DX -> superstation ID or nulls (12 bytes)
Return: CX = number of files closed
	AX = status (see also #3372)
	    08FFh superstation ID not already logged in
SeeAlso: AH=00h"10NET",AH=81h
--------N-6F02-------------------------------
INT 6F - 10NET - STATUS OF NODE
	AH = 02h
	DS:DX -> 512-byte status record (see #3385)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: INT 21/AX=5E01h"10NET"

(Table 3384)
Values for 10NET station type:
 00h	workstation
 01h	superstation
 02h	gateway station
 03h	gateway active
 04h	logged into multiple superstations
 05h	reserved

Format of 10NET node status record:
Offset	Size	Description	(Table 3385)
 00h  8 BYTEs	user name (0 if none)
 08h	BYTE	station type (see #3384)
 09h 24 BYTEs	list of superstations logged into more than one superstation
 21h 12 BYTEs	node ID
 2Dh	WORD	message count for this station (send for user node, receive for
		  superstations)
---for superstations only---
 2Fh	WORD	drives allocated (bit 0=A:, bit 1=B:,...)
 31h	BYTE	user service flags (see #3386)
 32h	BYTE	printers allocated (bit 0=LPT1,...)
 33h	BYTE	number of unprinted spool files
 34h	BYTE	number of opened files
 35h	BYTE	number of logged on nodes
 36h	BYTE	primary drive (1=A:)
 37h	BYTE	reserved
 38h  N BYTEs	list of logged on node IDs (each 12 bytes, max 37 IDs)
1F4h  3 BYTEs	time: sec/min/hrs
1F7h  3 BYTEs	date: day/mon/year-1980

Bitfields for 10NET user service flags:
Bit(s)	Description	(Table 3386)
 7	gate
 6	print permit on
 4	SUBMIT is on
 3	mail waiting for node
 2	calendar waiting for you
 1	news waiting for you
 0	mail waiting for you
--------b-6F0200-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_INIT" - START INITIALIZING DRIVER
	AX = 0200h
	BP = driver ID (see #3373)
	BX = "last-used DS" value from HP global data area (see #3380)
Return: AH = status (see #3376)
	BX = new "last-used DS" value
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0202h,AH=0Ch"F_INS_FIXOWNDS"
--------b-6F0202-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_START" - COMPLETE DRIVER INITIALIZ.
	AX = 0202h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0204h"HP Vectra"
--------W-6F0204-----------------------------
INT 6F C - MS Windows 3.0 - DOS APPLICATION SWITCH HOOK
	AX = 0204h
Return: AX = status
	    0000h switch is allowed
	    other switch not allowed
Note:	intercepting this call will allow a DOS application to ensure that
	  Windows will not switch away from it.
--------b-6F0204-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_REPORT_STATE" - GET DRIVER STATE
	AX = 0204h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	DX = device state from Logical Describe Record (see #3381,#3387)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0206h"HP Vectra"

Bitfields for HP Vectra V_HPHIL driver state:
Bit(s)	Description	(Table 3387)
 0	link configuration in progress
 1	reserved
 2	no devices attached
 3	general failure
 4,5	reserved
 6	HP-HIL driver open
 7	reserved
 8	link has been reconfigured
 9	error during output request
 10	reserved
 11	output request complete
 12	timeout
 13-15	reserved
--------b-6F0206-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_VERSION_DESC" - GET DRIVER VERSION
	AX = 0206h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BX = driver release date code
	    (BL = BCD years since 1960, BH = BCD week number within year)
	CX = length of version string
	ES:DI -> version string
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0204h"HP Vectra",AX=0208h
--------b-6F0208-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_DEF_ATTR" - RESET TO DEFAULT ATTR
	AX = 0208h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=020Ah,AX=020Ch
--------b-6F020A-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_GET_ATTR" - GET CURRENT ATTRIBUTES
	AX = 020Ah
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BX,CX = current attributes
	BP,DS destroyed
	---for V_LTOUCH, V_LPOINTER---
	    BX = logical width
	    CX = logical height
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Ch
--------b-6F020C-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_SET_ATTR" - SET DEVICE ATTRIBUTES
	AX = 020Ch
	BP = driver ID (see #3373)
	BX,CX = new attributes
	---for V_LTOUCH, V_LPOINTER---
	    BX = new logical width
	    CX = new logical height
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Ah
--------b-6F020E-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_OPEN" - RESERVE DRIVER FOR ACCESS
	AX = 020Eh
	BP = driver ID (see #3373) for V_HPHIL, others
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	place device in open state, which allows output to the device
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=0210h
--------b-6F0210-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_CLOSE" - RELEASE DRIVER
	AX = 0210h
	BP = driver ID (see #3373) for V_HPHIL, others
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	place device in closed state, which disallows output to the device
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh
--------b-6F0212-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_TIMEOUT" - REPORT REQUESTED TIMEOUT
	AX = 0212h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	report to driver that a previously-requested timeout interval has
	  expired
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0214h,AX=0216h
--------b-6F0214-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_INTERVAL" - 60 HZ INTERVAL EXPIRED
	AX = 0214h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	report to driver that a previously-requested 60 Hz interval has
	  expired
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0212h,AX=0216h
--------b-6F0216-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_SYSTEM SF_TEST" - PERFORM HARDWARE TEST
	AX = 0216h
	BP = driver ID (see #3373)
Return: AH = status (see #3376)
	BP,DS destroyed
	---on failure---
	CX = length of reason string
	ES:DI -> string describing error
SeeAlso: AH=00h"HP Vectra",AX=0200h,AX=0208h,AX=020Eh,AX=0212h,AX=0214h
--------N-6F03-------------------------------
INT 6F - 10NET - GET ADDRESS OF CONFIGURATION TABLE
	AH = 03h
	DS:DI -> node ID (optional)
Return: ES:BX -> configuration table (see #3388)
SeeAlso: AH=13h,INT 21/AX=5E01h"10NET"

Format of 10NET configuration table:
Offset	Size	Description	(Table 3388)
-41	WORD	local device table address
-39	WORD	extended network error mapping table address
-37	WORD	shared device table address
-35	WORD	mounted device table address
-33	BYTE	receive buffer counter
-32	BYTE	collect buffer counter
-31	WORD	TUF address
-29	BYTE	enable flag
-28	BYTE	FCB keep flag
-27	WORD	reserved
---up to here, 10NET v3.3---
-25	WORD	count of dropped Send6F
-23	WORD	buffer start address
-21	WORD	comm driver base address
-19	WORD	send/receive retry count
-17	BYTE	number of 550ms loops before timeout
-16	WORD	UFH address
-14	WORD	CDIR address
-12	WORD	LTAB address
-10	WORD	SFH address
-8	WORD	FTAB address
-6	WORD	RLTAB address
-4	WORD	SMI address
-2	WORD	NTAB address
 00h	WORD	address of first CT_DRV
 02h	BYTE	number of DRV entries
 03h  8 BYTEs	login name
 0Bh 12 BYTEs	node ID (blank-padded)
 17h  6 BYTEs	node address
 1Dh	BYTE	flag
 1Eh	BYTE	CT_CFLG (chat permit)
		bit 1: sound bell
		bit 0: CHAT permit
 1Fh	BYTE	CT_PSFLG (see #3389)
 20h	BYTE	in 10Net flag
 21h	WORD	receive message count
 23h	WORD	send message count
 25h	WORD	retry count
 27h	WORD	failed count
 29h	WORD	driver errors
 2Bh	WORD	dropped responses/CHATs
 2Dh  9 BYTEs	LIST ID/NTAB address (3 entries--LPT1-3)
 36h  6 BYTEs	AUX ID/NTAB address (2 entries--COM1-2)
 3Ch	BYTE	active CB channel
 3Dh	BYTE	received 6F messages on queue
 3Eh  9 BYTEs	activity counters for channels 1-9
---beyond here, 10NET v3.3---
 47h	BYTE	bit 0: RS232 gate
		bit 1: Send6F gate (user set)
 48h	DWORD	pointer into gate (user set)
 4Ch	DWORD	pointer into 10Net send
 50h  N WORDs	addresses of timer blocks

Bitfields for CT_PSFLG:
Bit(s)	Description	(Table 3389)
 5	PRINT permit
 4	KB initiated
 3	CHAT called FOXPTRM
 2	SUBMIT active
 1	SUBMIT received
 0	SUBMIT permit
--------N-6F04-------------------------------
INT 6F - 10NET - SEND
	AH = 04h
	DS:BX -> send record (see #3390)
	DS:DX -> data (max 1024 bytes)
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AH=05h"10NET",AH=09h"10NET",AH=0Ah"10NET"

Format of 10NET send record:
Offset	Size	Description	(Table 3390)
 00h 12 BYTEs	receiving node's ID
		if first byte has high-order bit set, message is directed to
		  the CT_RGATE vector at the receiver
		if second byte is 00h, first byte is taken as a CB
		  channel number and delivered to all nodes on same channel
 0Ch	WORD	 length of data at DX
--------b-6F04--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_BASEHPVT" - GET HP_VECTOR_TABLE ADDRESS
	AH = 04h
	BP = 0012h (driver ID for V_SYSTEM)
Return: AH = status (see #3376)
	ES = segment of HP_VECTOR_TABLE (see also AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_INS_XCHGFIX",AH=08h"F_INS_XCHGRSVD"
--------b-6F04--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_INIT" - RESET TRACKING DRIVER TO DEFAULTS
	AH = 04h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_TRACK_ON",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------b-6F0400-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_LOCK" - RESERVE SUB-ADDRESSES
	AX = 0400h
	BP = driver ID (see #3373)
	DH,DL = major,minor address (optional)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	reserve specified sub-addresses on an already-allocated driver for
	  exclusive access
Note:	this function is documented as present but unsupported in the drivers
	  V_LTABLET, V_LPOINTER, and V_LTOUCH
SeeAlso: AX=0200h"HP Vectra",AX=0402h"SF_UNLOCK"
--------b-6F0400BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_SVC" - UNMASK 8041 SVC INT
	AX = 0400h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h"SF_DISABLE_SVC",AX=0404h"SF_ENABLE_KBD"
SeeAlso: AX=0408h"SF_ENABLE_HPHIL"
--------b-6F0400BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DEF_LINKS" - SET DEFAULT PARENTS
	AX = 0400h
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	set the parent vectors in the physical device driver headers to their
	  system defaults
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=002Ah,AX=0404h/BP=002Ah
SeeAlso: AH=06h"F_INQUIRE"
--------b-6F0400BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_ID_HP" - INSTALLATION CHECK
	AX = 0400h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BX = 4850h ('BP')
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0402h/BP=0054h,AX=0404h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0400BP00CC-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_MOUSE_COM" - INIT INT 33 HANDLER
	AX = 0400h
	BP = 00CCh (driver ID for V_LHPMOUSE)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=00CCh
--------b-6F0402-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_UNLOCK" - RELEASE SUB-ADDRESSES
	AX = 0402h
	BP = driver ID (see #3373)
	DH,DL = major,minor address (optional)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	release specified sub-addresses from exclusive access
Note:	this function is documented as present but unsupported in the drivers
	  V_LTABLET, V_LPOINTER, and VLTOUCH
SeeAlso: AX=0200h"HP Vectra",AX=0400h"SF_LOCK"
--------b-6F0402BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_SVC" - MASK 8041 SVC INT
	AX = 0402h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=001Eh,AX=0406h/BP=001Eh
SeeAlso: AX=040Ah/BP=001Eh
--------b-6F0402BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_GET_LINKS" - GET DRIVER LINK FIELDS
	AX = 0402h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer for link table (see #3391)
Return: AH = status (see #3376)
	ES:SI buffer filled
	BP,DS destroyed
Desc:	get the parent and child vectors for the seven supported physical
	  device drivers
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_DEF_LINKS",AX=0404h"SF_SET_LINKS"
SeeAlso: AH=06h"F_INQUIRE"

Format of HP Vectra EX-BIOS driver link table:
Offset	Size	Description	(Table 3391)
 00h	BYTE	vector number of HP-HIL device #1's child
 01h	BYTE	vector number of HP-HIL device #1's parent
	...
 0Ch	BYTE	vector number of HP-HIL device #7's child
 0Dh	BYTE	vector number of HP-HIL device #7's parent
--------b-6F0402BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_GET_INFO" - GET DISPLAY INFO
	AX = 0402h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0404h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0402BP00CC-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_MOUSE_COM" - FORCE INT 33 INIT
	AX = 0402h
	BP = 00CCh (driver ID for V_LHPMOUSE)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	set up INT 33 even if no mouse is installed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=00CCh
--------b-6F0404-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_TRACK_ON" - GRAPHICS CURSOR ON
	AX = 0404h
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	enables graphics cursor tracking of the logical device's movement
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0406h"SF_TRACK_OFF"
--------b-6F0404BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_KBD" - UNMASK 8041 OBF INT
	AX = 0404h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_ENABLE_SVC",AX=0406h"SF_DISABLE_KBD"
SeeAlso: AX=0408h"SF_ENABLE_HPHIL"
--------b-6F0404BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_LINKS" - SET DRIVER LINK FIELDS
	AX = 0404h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer containing link table (see #3391)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	specify the parent and child vectors for the seven supported physical
	  device drivers
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_DEF_LINKS",AX=0402h"SF_GET_LINKS"
SeeAlso: AH=06h"F_INQUIRE"
--------b-6F0404BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_SET_INFO" - SET EXT-CTRL INFO
	AX = 0404h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0406h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0406-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_TRACK_OFF" - GRAPHICS CURSOR OFF
	AX = 0406h
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	disables graphics cursor tracking of the logical device's movement
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0404h"SF_TRACK_ON"
SeeAlso: AX=0408h"SF_CREATE_EVENT"
--------b-6F0406BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_KBD" - MASK 8041 OBF INT
	AX = 0406h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h"SF_DISABLE_SVC",AX=0404h"SF_ENABLE_KBD"
SeeAlso: AX=040Ah"SF_DISABLE_HPHIL"
--------b-6F0406BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_MOD_INFO" - SET EXT-CTRL REG
	AX = 0406h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0408h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0406BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_RECONFIGURE" - RECONFIG LINK
	AX = 0406h
	BP = 0114h (driver ID for V_HPHIL)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=020Eh,AX=0408h"SF_CRV_WR_PROMPTS"
SeeAlso: AX=0410h"SF_CRV_SELF_TEST"
--------b-6F0408-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CREATE_EVENT" - SET EVENT HANDLER
	AX = 0408h
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
	ES:SI -> new event handler (see AH=00h"HP Vectra")
	DX = new handler's DS
Return: AH = status (see #3376)
	ES:SI -> old event handler
	DX = old handler's DS
	BP,DS destroyed
Desc:	specify routine to be called on logical device events
Note:	when events occur, the event handler is called with the same registers
	  as the "F_ISR" function on AH=00h"HP Vectra"
SeeAlso: AH=00h"HP Vectra",AX=0400h"SF_LOCK",AX=0406h"SF_TRACK_OFF"
SeeAlso: AX=040Ah"SF_EVENT_ON",AX=040Ch"SF_EVENT_OFF",AH=06h"F_SAMPLE"
--------b-6F0408BP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABLE_HPHIL" - UNMASK HP-HIL INT
	AX = 0408h
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=001Eh,AX=0404h/BP=001Eh
SeeAlso: AX=040Ah/BP=001Eh
--------b-6F0408BP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_GET_RES" - GET VIDMODE RESOLUTN
	AX = 0408h
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0406h/BP=0054h,AX=040Ah/BP=0054h
--------b-6F0408BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_WR_PROMPTS" - WRITE PROMPT
	AX = 0408h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = prompt number
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=020Eh,AX=0406h/BP=0114h,AX=040Ah/BP=0114h

Bitfields for HP Vectra V_HPHIL device address indicator:
Bit(s)	Description	(Table 3392)
 15-14	reserved
 13	address in DH is valid (must be set, clear is reserved)
 12	valid value in DL
 11-0	reserved
--------b-6F040A-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_EVENT_ON" - ENABLE EVENT HANDLER
	AX = 040Ah
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0408h"SF_CREATE_EVENT",AX=040Ch"SF_EVENT_OFF"
SeeAlso: AX=040Eh"SF_CLIPPING_ON"
--------b-6F040ABP001E-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISABLE_HPHIL" - MASK HP-HIL INT
	AX = 040Ah
	BP = 001Eh (driver ID for V_S8259)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0402h/BP=001Eh,AX=0406h/BP=001Eh
SeeAlso: AX=0408h/BP=001Eh
--------b-6F040ABP0054-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_VID_SET_MODE" - SET VIDEO MODE
	AX = 040Ah
	BP = 0054h (driver ID for V_SVIDEO)
	???
Return: AH = status (see #3376)
	BP,DS destroyed
	???
Note:	only partially documented
SeeAlso: AX=0400h/BP=0054h,AX=0402h/BP=0054h,AX=0404h/BP=0054h
SeeAlso: AX=0406h/BP=0054h,AX=0408h/BP=0054h
--------b-6F040ABP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CREATE_INTR" - CREATE INTERVAL ENTRY
	AX = 040Ah
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be called regularly (vector addr / 6)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	add a driver to the list (max eight) of drivers which will be called
	  by the HP's 8041 at 60 Hz
Note:	the newly added entry will not be called until enabled with
	  AX=040Eh/BP=00AEh
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040ABP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_WR_ACK" - ACKNOWLEDGE DEVICE
	AX = 040Ah
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = acknowledge number (specific if 01h-07h, generic otherwise)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0406h/BP=0114h,AX=040Ch/BP=0114h
--------b-6F040C-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_EVENT_OFF" - DISABLE EVENT HANDLER
	AX = 040Ch
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0408h"SF_CREATE_EVENT",AX=040Ah"SF_EVENT_ON"
--------b-6F040CBP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DELET_INTR" - DELETE INTERVAL ENTRY
	AX = 040Ch
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be removed (vector addr / 6)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	remove a driver to the list (max eight) of drivers which will be called
	  by the HP's 8041 at 60 Hz
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=0410h/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040CBP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPEAT" - SET KEY REPEAT RATE
	AX = 040Ch
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = repeat rate (00h = 30 Hz, 01h = 60 Hz)
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=0114h,AX=040Eh/BP=0114h
--------b-6F040E-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLIPPING_ON" - ENABLE CLIPPING
	AX = 040Eh
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	causes the physical device's motion to be clipped to prevent overflow
	  or underflow of the logical position
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=0410h"SF_CLIPPING_OFF"
--------b-6F040EBP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_ENABL_INTR" - START INTERRUPT SRVICE
	AX = 040Eh
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver to be called regularly (vector addr / 6)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	enable 60 Hz calling of a driver previously added to the list of
	  drivers to be called by the HP's 8041
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=0410h/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F040EBP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_DISABLE_REPEAT" - KEY REPT OFF
	AX = 040Eh
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=0114h,AX=0410h/BP=0114h
SeeAlso: AX=0416h/BP=0114h
--------b-6F0410-----------------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLIPPING_OFF" - DISABLE CLIPPING
	AX = 0410h
	BP = driver ID (see #3373) for V_LPOINTER, V_LTOUCH, V_LTABLET
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	disables clipping of the physical device's motion, which may cause
	  overflow or underflow of the logical position
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=040Eh"SF_CLIPPING_ON"
--------b-6F0410BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_DISBL_INTR" - END INTERRUPT SERVICE
	AX = 0410h
	BP = 00AEh (driver ID for V_8041)
	BH = vector number of driver (vector addr / 6)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	disable 60 Hz interval calls to the specified driver
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0410BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_SELF_TEST" - PERFORM SELFTEST
	AX = 0410h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	ES:SI -> buffer for result
Return: AH = status (see #3376)
	CX = number of bytes in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=0114h,AX=0412h/BP=0114h
--------b-6F0412BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_RAMSW" - SET RAM SWITCH IN 8041
	AX = 0412h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	sets a flag in the 8041 indicating that a second 256K bank of RAM
	  on the motherboard is enabled
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0414h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0412BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPORT_STATUS" - GET DEVSTATUS
	AX = 0412h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	ES:SI -> 15-byte buffer for status
Return: AH = status (see #3376)
	CX = number of bytes returned in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=0410h/BP=0114h,AX=0414h/BP=0114h
--------b-6F0414BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLR_RAMSW" - CLEAR 8041 RAM SWITCH
	AX = 0414h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	clears a flag in the 8041 indicating that a second 256K bank of RAM
	  on the motherboard is enabled, causing the second bank to be disabled
Note:	this function should normally never be called
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0418h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0414BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CRV_REPORT_NAME" - GET DEV NAME
	AX = 0414h
	BP = 0114h (driver ID for V_HPHIL)
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	ES:SI -> 15-byte buffer for name
Return: AH = status (see #3376)
	CX = number of bytes returned in buffer
	BP,DS destroyed
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=00h"HP Vectra",AX=0412h/BP=0114h
--------b-6F0416BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_SET_CRTSW" - SET CRT TO MULTIMODE
	AX = 0416h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	sets a flag in the 8041 indicating that the primary display is the
	  Multimode graphics adapter (default)
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0412h/BP=00AEh,AX=0418h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0416BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_KEYBOARD_REPEAT" - SET TYPEMATIC
	AX = 0416h
	BP = 0114h (driver ID for V_HPHIL)
	BH = what to set (00h typematic rate, 01h delay, 02h both)
	BL = flag (00h = non-CCP keypad, 01h = Cursor Control Pad only)
	DL = rate
	    bits 7-4: delay value
	    bits 3-0: typematic rate
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Eh/BP=0114h,AX=0418h/BP=0114h
--------b-6F0418BP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_CLR_CRTSW" - SET CRT TO MONOCHROME
	AX = 0418h
	BP = 00AEh (driver ID for V_8041)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	clears a flag in the 8041, indicating that the primary display is the
	  monochrome adapter
SeeAlso: AH=00h"HP Vectra",AX=040Ch/BP=00AEh,AX=040Eh/BP=00AEh
SeeAlso: AX=0414h/BP=00AEh,AX=0416h/BP=00AEh,AX=041Ah/BP=00AEh
--------b-6F0418BP0114-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_KEYBOARD_LED" - SET KEYBOARD LEDS
	AX = 0418h
	BP = 0114h (driver ID for V_HPHIL)
	BL = new LED states
	    bit 0: scroll lock
	    bit 1: NumLock
	    bit 2: CapsLock
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Eh/BP=0114h,AX=0416h/BP=0114h
--------b-6F041ABP00AE-----------------------
INT 6F - HP Vectra EX-BIOS - "F_IO_CTRL SF_PASS_THRU" - SEND DATA BYTE TO 8041
	AX = 041Ah
	BP = 00AEh (driver ID for V_8041)
	BL = byte to send to 8041
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Ah/BP=00AEh,AX=040Eh/BP=00AEh
--------N-6F05-------------------------------
INT 6F - 10NET - RECEIVE
	AH = 05h
	CX = number of seconds before timeout
	DS:DX -> receive buffer (see #3393)
Return: CF clear if successful
	    AH = FEh if dequeued message is a CB message
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AH=04h"10NET"

Format of 10NET receive buffer:
Offset	Size	Description	(Table 3393)
 00h 12 BYTEs	sending node's ID
 0Ch	WORD	length of message
 0Eh  N BYTEs	message (maximum 1024 bytes)
--------b-6F06-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BYTE" - WRITE A BYTE OF DATA TO DEVICE
	AH = 06h
	BP = driver ID (see #3373) for V_HPHIL, others
	AL = value to output
	---if driver is V_HPHIL---
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	output a byte to a specific HP-HIL device register
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=04h"HP Vectra",AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BUFFER"
--------b-6F06-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_SAMPLE" - POLL CURRENT ABSOLUTE POSITION
	AH = 06h
	BP = driver ID (see #3373) for V_LTOUCH, V_LPOINTER, V_LTABLET, etc.
Return: AH = status (see #3376)
	BX = current logical X position
	CX = current logical Y position
	DL = button transitions (bit N = button N state has changed)
	DH = current button states (bit N = current button N state)
	ES:0000h -> logical device's Describe Record (see #3381)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=040Ah"SF_EVENT_ON",AX=040Eh"SF_CLIPPING_ON"
--------b-6F06--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGFIX" - EXCH VALUES WITH FIXED VECTOR
	AH = 06h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (see #3376)
	DX = old value for DS
	ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	replace an existing EX-BIOS driver at a fixed HPVT location without
	  initialization
SeeAlso: AH=00h"HP Vectra",AH=04h"F_INS_BASEHPVT",AH=08h"F_INS_XCHGRSVD"
SeeAlso: AH=0Ah"F_INS_XCHGFREE",AH=0Ch"F_INS_FIXOWNDS"
--------b-6F06--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE" - GET DRIVER PHYSICAL DESCRIBE RECORD
	AH = 06h
	BP = 002Ah (driver ID for V_SINPUT)
	AL = HP-HIL physical device number (01h-07h)
Return: AH = status (see #3376)
	ES:SI -> physical describe record for driver
	BP,DS destroyed
Note:	the returned physical describe record must not be modified
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=08h/BP=002Ah,AH=0Ah/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah
--------b-6F06--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_ON" - ENABLE CURSOR TRACKING
	AH = 06h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------N-6F07-------------------------------
INT 6F - 10NET - LOCK HANDLE
	AH = 07h
	BX = file handle
	CX:DX = starting offset in file
	SI = record length
Return: CF clear if successful
	CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
SeeAlso: AH=08h"10NET",AH=0Fh,INT 21/AH=5Ch
--------N-6F08-------------------------------
INT 6F - 10NET - UNLOCK HANDLE
	AH = 08h
	BX = file handle
	AL = mode
	    00h unlock all
	    01h unlock record at CX:DX
Return: CF clear if successful
	CF set on error
	    AX = error code (see also AH=00h)
		0002h file not found
SeeAlso: AH=07h,AH=0Fh,INT 21/AH=5Ch
--------b-6F08-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BYTE" - READ A BYTE OF DATA FROM DEVICE
	AH = 08h
	BP = driver ID (see #3373) for V_HPHIL (0114h), others
	---if device is V_HPHIL---
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #3376)
	AL = value read from device
	BP,DS destroyed
Desc:	generic read-byte function; for driver V_HPHIL, retrieves the value
	  of a specific HP-HIL device register
Note:	this function is only available if the driver is in the open state
	  (see AX=020Eh"SF_OPEN")
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BUFFER"
--------b-6F08--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGRSVD" - EXCH VALUES WITH RESRVED VECTOR
	AH = 08h
	BP = 0012h (driver ID for V_SYSTEM)
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (00h,F6h) (see also #3376)
	    00h successful
		BX = vector address used
		DX = old value for DS
		ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	exchange the supplied entry point and DS with the values in the next
	  reserved entry in the HP_VECTOR_TABLE
Note:	returns AH=F6h if no more reserved vectors are available
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=0Ah/BP=0012h
SeeAlso: AH=0Ch/BP=0012h
--------b-6F08--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_ALL" - GET DRIVER STATUS TABLE
	AH = 08h
	BP = 002Ah (driver ID for V_SINPUT)
	ES:SI -> buffer for device status table (see #3394)
Return: AH = status (see #3376)
	ES:SI buffer filled
	BP,DS destroyed
Note:	the returned physical describe record must not be modified
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=0Ah/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah

Format of HP Vectra HP-HIL physical device status table:
Offset	Size	Description	(Table 3394)
 00h	BYTE	status for HP-HIL device #1
		bit 0: device present
		bits 7-2 reserved
 01h	BYTE	device ID for HP-HIL device #1
	...
 0Ch	BYTE	status for HP-HIL device #7
 0Dh	BYTE	device ID for HP-HIL device #7
--------b-6F08--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_TRACK_OFF" - DISABLE CURSOR TRACKING
	AH = 08h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	also removes the graphics cursor sprite from the screen
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=06h"F_TRACK_ON"
SeeAlso: AH=0Ah"F_DEF_MASKS",AH=0Ch"F_SET_LIMITS_X"
--------N-6F09-------------------------------
INT 6F - 10NET - SUBMIT
	AH = 09h
	DS:BX -> submit record (see #3395)
SeeAlso: AH=04h"10NET"

Format of 10NET submit record:
Offset	Size	Description	(Table 3395)
 00h 12 BYTEs	destination node ID (must be logged in)
 0Ch	WORD	length+2 of following 'command line' text
 0Eh  N BYTEs	command line text (<=100 bytes), system adds CR
--------N-6F0A-------------------------------
INT 6F - 10NET - CHAT
	AH = 0Ah
	DS:BX -> control parameters (see #3396)
	DS:DX -> chat message (see #3397)
SeeAlso: AH=04h"10NET",AH=8Ah

Format of 10NET chat control parameters:
Offset	Size	Description	(Table 3396)
 00h  8 BYTEs	sender ID, defaults to node's userID if nulls
 08h  8 BYTEs	destination user ID, 'EVERYONE' may be used
 10h 12 BYTEs	destination node ID

Format of 10NET chat message:
Offset	Size	Description	(Table 3397)
 00h	WORD	length+2 of following text
 02h  N BYTEs	text, max 101 bytes
--------b-6F0A-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BUFFER" - WRITE A BUFFER TO DEVICE
	AH = 0Ah
	BP = driver ID (see #3373) for V_HPHIL (0114h), others
	CX = number of bytes to write
	ES:DI -> buffer containing data
	---if driver is V_HPHIL---
	BX = device address indicator (see #3392)
	DH = HP HIL device major address
	DL = HP-HIL device register (00h-7Fh)
Return: AH = status (see #3376)
	CX = number of unwritten bytes left in buffer
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BLOCK",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=0Eh"F_PUT_WORD"
--------b-6F0A-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_BLOCK" - WRITE BLOCKS TO DEVICE
	AH = 0Ah
	BP = driver ID (see #3373) for block device
	DH = device major number
	DL = device minor number
	ES:DI -> command block (see #3398)
Return: AH = status (see #3376)
	BX = operation status
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=0Eh"F_PUT_WORD"

Format of HP Vectra F_PUT_BLOCK/F_GET_BLOCK command block:
Offset	Size	Description	(Table 3398)
 00h	DWORD	data transfer address
 04h	WORD	number of blocks
 06h	DWORD	block address (some devices only use low word)
--------b-6F0A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_XCHGFREE" - EXCH VALUES WITH FREE VECTOR
	AH = 0Ah
	BP = 0012h (driver ID for V_SYSTEM)
	DX = new value for DS
	ES:DI -> new CS:IP entry point
Return: AH = status (00h,F6h) (see also #3376)
	    00h successful
		BX = vector address used
		DX = old value for DS
		ES:DI -> old CS:IP entry point
	BP,DS destroyed
Desc:	exchange the supplied entry point and DS with the values in the next
	  free entry in the HP_VECTOR_TABLE
Note:	returns AH=F6h if no more reserved vectors are available
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=08h/BP=0012h
SeeAlso: AH=0Ch/BP=0012h
--------b-6F0A--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_FIRST" - GET PHYSICAL DRIVER VECTOR
	AH = 0Ah
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #3376)
	BX = vector address for first HP-HIL device
	BP,DS destroyed
Note:	all seven HP-HIL devices use consecutive vectors in the
	  HP_VECTOR_TABLE
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=08h/BP=002Ah
SeeAlso: AH=0Ch/BP=002Ah
--------b-6F0A--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_DEF_MASKS" - DEFINE GRAPHICS CURSOR MASKS
	AH = 0Ah
	BP = 005Ah (driver ID for V_STRACK)
	BH = width of save area in bytes
	BL = hot-spot X coordinate
	CH = height in scan lines
	CL = hot-spot Y coordinate
	ES:SI -> sprite mask (screen mask followed by XOR sprite mask)
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	the save area is one byte wider than the actual sprite mask; the total
	  size of the sprite is at most 144 bytes
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=0Ch"F_SET_LIMITS_X",AH=10h"F_PUT_SPRITE",AH=12h"F_REMOVE_SPRITE"
--------N-6F0B-------------------------------
INT 6F - 10NET - LOCK SEMAPHORE, RETURN IMMEDIATELY
	AH = 0Bh
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see #3399)
Note:	same as INT 60/AH=12h
SeeAlso: AH=0Ch"10NET",INT 60/AH=12h

(Table 3399)
Values for 10NET status:
 00h	successful
 01h	semaphore currently locked
 02h	server not responding
 03h	invalid semaphore name
 04h	semaphore list is full
 05h	invalid drive ID
 06h	invalid Ethernet address
 07h	not logged in
 08h	write to network failed
 09h	semaphore already logged in this CPU
SeeAlso: #3372
Index:	error codes;10-Net|10-Net;error codes
--------N-6F0C-------------------------------
INT 6F - 10NET - UNLOCK SEMAPHORE
	AH = 0Ch
	AL = drive number or 0
	ES:SI = Ethernet address or 0
	DS:BX -> 31-byte ASCIZ semaphore name
Return: AL = status (see also #3399)
	    01h semaphore not locked
Note:	same as INT 60/AH=13h
SeeAlso: AH=0Bh,INT 60/AH=13h
--------b-6F0C-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BUFFER" - READ A BUFFER OF DATA FROM DEVICE
	AH = 0Ch
	BP = driver ID (see #3373) for V_HPHIL (0114h), others
	CX = number of bytes or blocks to read
	DS:SI -> buffer for received data
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BUFFER",AH=0Ch"F_GET_BLOCK"
SeeAlso: AH=10h"F_GET_WORD"
--------b-6F0C-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_BLOCK" - READ BLOCKS OF DATA FROM DEVICE
	AH = 0Ch
	BP = driver ID (see #3373)
	DH = device major number
	DL = device minor number
	ES:DI -> command block (see #3398)
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BX = operation status
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ah"F_PUT_BLOCK",AH=0Ch"F_GET_BUFFER"
SeeAlso: AH=10h"F_GET_WORD"
--------b-6F0C--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXOWNDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 0Ch
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), which should return the routine's DS
	  in BX.  If the SF_INIT call returns with error code FEh, the power-on
	  self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=08h/BP=0012h
SeeAlso: AH=0Eh/BP=0012h,AH=12h/BP=0012h
--------b-6F0C--BP002A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INQUIRE_ENTRY" - GET GID DRIVER ENTRY POINT
	AH = 0Ch
	BP = 002Ah (driver ID for V_SINPUT)
Return: AH = status (see #3376)
	ES:BX -> physical GID driver CS:IP
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AX=0400h/BP=002Ah,AH=06h/BP=002Ah,AH=08h/BP=002Ah
SeeAlso: AH=0Ah/BP=002Ah
--------b-6F0C--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SET_LIMITS_X" - SET HORIZONTAL TRACKING LIMITS
	AH = 0Ch
	BP = 005Ah (driver ID for V_STRACK)
	CX = minimum X coordinate
	DX = maximum X coordinate
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=005Ah,AH=08h/BP=005Ah,AH=0Eh/BP=005Ah
SeeAlso: AH=10h/BP=005Ah,AH=12h/BP=005Ah,INT 33/AX=0007h
--------N-6F0D-------------------------------
INT 6F - 10NET - "WHO" - ENUMERATE USERS ON NETWORK
	AH = 0Dh
	AL = type code
	    01h return superstations only
	    02h return non-superstations only
	    otherwise return all
	CX = length of data buffer
	DS:DX -> array of records to be filled (see #3400)
Return: CL = number of records returned (responding stations)
SeeAlso: AH=16h,AH=8Dh

Format of station record:
Offset	Size	Description	(Table 3400)
 00h 12 BYTEs	node ID
 0Ch	BYTE	station flags (see #3401)
---if AL = 01h---
 0Dh	BYTE	version number
 0Eh	WORD	level number of 10Net software in responding node
---if AL = 02h---
 0Dh  8 BYTEs	user ID
 15h	BYTE	version number
 16h	WORD	level number

Bitfields for station flags:
Bit(s)	Description	(Table 3401)
 1	workstation
 2	superstation
 3	xgate
 4	active gate
--------N-6F0E-------------------------------
INT 6F - 10NET - SPOOL/PRINT
	AH = 0Eh
	DS:DX -> spool/print record (see #3403)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #3372)
		17FFh device not mounted
		18FFh already spooling to named device

(Table 3402)
Values for 10NET spooler operation code:
 0000h	initiate spool
 0001h	abort print
 0002h	close spool
 0003h	delete spool
 0004h	print
 0005h	get report info
 0006h	set chat template
 0007h	queue
 0008h	return queue
 0009h	queue non-spooled file for printing

Format of 10NET Spool/Print record:
Offset	Size	Description	(Table 3403)
 00h	WORD	operation code (see #3402)
 02h 11 BYTEs	file name in FCB format
---if operation code = 00h or 06h---
 0Dh	BYTE	notification flags (see #3404)
 0Eh	BYTE	days to keep (FFh=forever)
 0Fh	BYTE	bits 0,1: device (1=LPT1)
		bits 4-7: remote drive to store spool file (1=A,...)
 10h	WORD	length of following data area
 12h  N BYTEs	up to 64 bytes of description
---if operation code = 03h---
 0Dh  8 BYTEs	user ID to associate with filename
---if operation code = 04h---
 0Dh	WORD	block number
 0Fh  8 BYTEs	user ID to associate with filename
---if operation code = 05h---
 0Dh	BYTE	RRN to start retrieve
 0Eh	BYTE	bits 0,1: local print device (LPTx)
		bit 3: if set, return entries for all users
 0Fh	WORD	length of following area
 11h  N BYTEs	up to 1500 bytes to receive $SCNTL records returned
---if operation code = 07h---
 0Dh	BYTE	queue number
 0Eh	BYTE	bits 0,1: local print device (LPTx)
 0Fh	WORD	number of bytes of test print to be done
 11h	BYTE	code:
		01h print device
		02h test print count
		03h prn
---if operation code = 08h---
 0Dh	BYTE	queue location or $SCNTL location to start access
		returns next item for access:
		    00h-7Fh queued items
		    80h-FEh non-queued, non-printed items
		    FFh	no more items
 0Eh	WORD	unused
 10h	WORD	length of following area
 12h  N BYTEs	up to 64 bytes to receive $SCNTL records (see #3405)
---if operation code = 09h---
 0Dh  3 BYTEs	unused
 10h  N BYTEs	path to non-spooled file to be queued for printing

Bitfields for notification flags:
Bit(s)	Description	(Table 3404)
 7	queue to top
 6	do ID page
 5	no form feed
 4	reserved
 3	explicit queuing only
 2	notify at print completion
 1	notify server operator, with reply
 0	notify at print start

Format of 10NET $SCNTL record:
Offset	Size	Description	(Table 3405)
 00h  8 BYTEs	user ID
 08h 11 BYTEs	filename in FCB format
 13h  6 BYTEs	node ID
 19h  3 BYTEs	creation date
 1Ch	BYTE	notification flags (see #3404)
 1Dh	BYTE	retention time in days
 1Eh	BYTE	printing device (LPTx)
 1Fh  3 BYTEs	date last printed (0 = never)
 22h	BYTE	device containing spoolfile
 23h	WORD	bytes to print for test print
 25h	WORD	block number to start print
 27h	BYTE	reserved
--------b-6F0E-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_WORD" - WRITE WORD OF DATA TO DEVICE
	AH = 0Eh
	BP = driver ID (see #3373)
	DX = data word
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=06h"F_PUT_BYTE",AH=0Ah"F_PUT_BUFFER",AH=10h"F_GET_WORD"
--------b-6F0E-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_WORD" - WRITE A WORD OF DATA
	AH = 0Eh
	BP = driver ID (see #3373)
	??? details not yet available
Return: ???
SeeAlso: AH=06h"HP Vectra",AH=0Ah"HP Vectra",AH=10h"HP Vectra"
--------b-6F0E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXGETDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 0Eh
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with the "last used DS" value in BX;
	  the routine should adjust BX and return the new value.  If the
	  SF_INIT call returns with error code FEh, the power-on self-test
	  sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h,AH=0Ch/BP=0012h
SeeAlso: AH=10h/BP=0012h,AH=14h/BP=0012h
--------b-6F0E--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SET_LIMITS_Y" - SET VERTICAL TRACKING LIMITS
	AH = 0Eh
	BP = 005Ah (driver ID for V_STRACK)
	CX = minimum Y coordinate
	DX = maximum Y coordinate
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=005Ah,AH=08h/BP=005Ah,AH=0Ch/BP=005Ah
SeeAlso: AH=10h/BP=005Ah,AH=12h/BP=005Ah,INT 33/AX=0008h
--------N-6F0F-------------------------------
INT 6F - 10NET v5.0 - "RM LOCK" - ???
	AH = 0Fh
	???
Return: ???
SeeAlso: AH=07h,AH=08h"10NET"
--------N-6F10-------------------------------
INT 6F - 10NET - ATTACH/DETACH PRINTER
	AH = 10h
	AL = subfunction
	    00h initiate spooling if LPT1 is mounted
	    01h terminate spooling if LPT1 is mounted
SeeAlso: INT 21/AX=5D08h
--------b-6F10-------------------------------
INT 6F - HP Vectra EX-BIOS - "F_GET_WORD" - READ WORD OF DATA FROM DEVICE
	AH = 10h
	BP = driver ID (see #3373)
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	DX = data word
	BP,DS destroyed
SeeAlso: AH=08h"F_GET_BYTE",AH=0Ch"F_GET_BUFFER",AH=0Eh"F_PUT_WORD"
--------b-6F10--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIXGLBDS" - INSTALL VALUES IN FIXED VECTOR
	AH = 10h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = vector address used
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with BX set to the EX-BIOS global
	  data area. If the SF_INIT call returns with error code FEh, the
	  power-on self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=06h/BP=0012h
SeeAlso: AH=0Ch/BP=0012h,AH=0Eh/BP=0012h,AH=12h/BP=0012h,AH=16h/BP=0012h
--------b-6F10--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_PUT_SPRITE" - DISPLAY GRAPHICS CURSOR SPRITE
	AH = 10h
	BP = 005Ah (driver ID for V_STRACK)
	BX = X coordinate
	CX = Y coordinate
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h"F_TRACK_INIT",AH=08h"F_TRACK_OFF"
SeeAlso: AH=12h"F_REMOVE_SPRITE",INT 33/AX=0004h
--------N-6F11-------------------------------
INT 6F - 10NET - LOCK FCB
	AH = 11h
	AL = mode
	    01h sequential
	    02h random
	    03h random block
		CX = number of records
	DS:DX -> FCB (see #1000 at INT 21/AH=0Fh)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #3372)
		0002h file not found
SeeAlso: AH=12h,INT 21/AH=0Fh
--------N-6F12-------------------------------
INT 6F - 10NET - UNLOCK FCB
	AH = 12h
	AL = mode
	    00h sequential
	    01h random
	    02h random block
		CX = number of records
	DS:DX -> FCB (see #1000 at INT 21/AH=0Fh)
Return: CF clear if successful
	CF set on error
	    AX = error code (see also #3372)
		0002h file not found
SeeAlso: AH=11h
--------b-6F12--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEOWNDS" - INSTALL VALUES IN FREE VECTOR
	AH = 12h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), which should return the routine's DS
	  in BX.  If the SF_INIT call returns with error code FEh, the power-on
	  self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Ch/BP=0012h,AH=14h/BP=0012h
SeeAlso: AH=16h/BP=0012h,AH=18h/BP=0012h
--------b-6F12--BP005A-----------------------
INT 6F - HP Vectra EX-BIOS - "F_REMOVE_SPRITE" - REMOVE GRAPHICS CURSOR SPRITE
	AH = 12h
	BP = 005Ah (driver ID for V_STRACK)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=06h"F_TRACK_ON",AH=10h"F_PUT_SPRITE"
--------N-6F13-------------------------------
INT 6F - 10NET v3.3+ - GET REMOTE CONFIGURATION TABLE ADDRESS
	AH = 13h
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	    ES:BX = configuration table address on given machine
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AH=03h
--------N-6F14-------------------------------
INT 6F - 10NET v3.3+ - GET REMOTE MEMORY
	AH = 14h
	BX:SI = address of remote memory
	CX = length (<=1024 bytes)
	DS:DX -> node ID, 12 bytes blank-padded
	DS:DI -> area to receive remote memory image
Return: CF clear if successful
	    CX = amount of memory copied to DS:SI
	CF set on error
	    AX = error code (see #3372)
--------b-6F14--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEGETDS" - INSTALL VALUES IN FREE VECTOR
	AH = 14h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with the "last used DS" value in BX;
	  the routine should adjust BX and return the new value.  If the
	  SF_INIT call returns with error code FEh, the power-on self-test
	  sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Eh/BP=0012h,AH=12h/BP=0012h
SeeAlso: AH=16h/BP=0012h
--------N-6F1501-----------------------------
INT 6F - 10NET v3.3+ - GET SHARED DEVICE ENTRY
	AX = 1501h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> 85-byte buffer for shared device table entry (see #3406)
Return: CF clear if successful
	    ES:DI buffer contains shared device table entry of BXth device
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AX=1502h,AX=1503h,AX=9501h

Format of 10NET shared device table entry:
Offset	Size	Description	(Table 3406)
 00h  8 BYTEs	device
 08h  8 BYTEs	alias
 10h 64 BYTEs	path
 50h  8 BYTEs	password
 58h	BYTE	access
 59h  4 BYTEs	mask
--------N-6F1502-----------------------------
INT 6F - 10NET v3.3+ - SET SHARED DEVICE ENTRY
	AX = 1502h
	DS:SI -> node ID, 12 bytes blank-padded
	ES:DI -> valid shared device table entry
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AX=1501h,AX=1503h,AX=9502h
--------N-6F1503-----------------------------
INT 6F - 10NET v3.3+ - DELETE SHARED DEVICE ENTRY
	AX = 1503h
	BX = zero-based index
	DS:SI -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AX=1501h,AX=1502h,AX=9503h
--------N-6F16-------------------------------
INT 6F - 10NET v5.0 - "GL WHO" - ???
	AH = 16h
	???
Return: ???
SeeAlso: AH=0Dh
--------b-6F16--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FREEGLBDS" - INSTALL VALUES IN FREE VECTOR
	AH = 16h
	BP = 0012h (driver ID for V_SYSTEM)
	ES:DI -> new CS:IP entry point
Return: AH = status (00h) (see #3376 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
Note:	on installation, the given entry point will be invoked with an SF_INIT
	  call (see AX=0200h"SF_INIT"), with BX set to the EX-BIOS global
	  data area.  If the SF_INIT call returns with error code FEh, the
	  power-on self-test sequence will be called.
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=10h/BP=0012h,AH=12h/BP=0012h
SeeAlso: AH=14h/BP=0012h,AH=18h/BP=0012h
--------N-6F17-------------------------------
INT 6F - 10NET v3.3+ - MOUNT
	AH = 17h
	AL = local drive number (0=A:)
	BL = remote drive letter or '1'..'3' for LPTn or '4' or '5' for COMx
	DS:DX -> node ID, 12 bytes blank-padded
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AH=18h
--------N-6F18-------------------------------
INT 6F - 10NET v3.3+ - UNMOUNT
	AH = 18h
	AL = local drive number (0=A:)
	BL = type
	    00h	    disk
	    01h-03h LPTn
	    04h,05h COMx
Return: CF clear if successful
	CF set on error
	    AX = error code (see #3372)
SeeAlso: AH=17h
--------b-6F18--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_INS_FIND" - FIND DRIVER BY ATTRIBUTES
	AH = 18h
	BP = 0012h (driver ID for V_SYSTEM)
	AL = sense of test (00h equal, 02h non-equal)
	BX = AND mask
	DX = pattern
	SI = first vector address to search
	DI = offset in HP header of field to test
Return: AH = status (00h,FEh) (see #3376 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
	---if AH=00h---
	SI = first matching vector address
Desc:	compare successive drivers' header fields starting at address SI
	  until the header field AND BX is either equal or non-equal to DX
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=0Ch/BP=0012h,AH=10h/BP=0012h
SeeAlso: AH=12h/BP=0012h,AH=16h/BP=0012h
--------N-6F19-------------------------------
INT 6F U - 10NET v5.0 - AUDIT
	AH = 19h
	???
Return: ???
SeeAlso: AH=99h
--------N-6F1A-------------------------------
INT 6F U - 10NET v5.0 - "BULL" - ???
	AH = 1Ah
	???
Return: ???
--------N-6F1B-------------------------------
INT 6F U - 10NET v5.0 - "GMOUNT" - ???
	AH = 1Bh
	???
Return: ???
--------N-6F1C-------------------------------
INT 6F U - 10NET v5.0 - "GLOGIN" - GET LOGIN LIST
	AH = 1Ch
	???
Return: ???
--------N-6F1D-------------------------------
INT 6F U - 10NET v5.0 - "TABDATA" - ???
	AH = 1Dh
	???
Return: ???
--------N-6F1E-------------------------------
INT 6F U - 10NET v5.0 - "SCHED" - ???
	AH = 1Eh
	???
Return: ???
--------b-6F1E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_RAM_GET" - GET EX-BIOS FREE RAM AREA
	AH = 1Eh
	BP = 0012h (driver ID for V_SYSTEM)
Return: AH = status (00h) (see #3376 at INT 6F/AH=00h"HP Vectra")
	BX = last-used DS
	DX = maximum DS
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=04h/BP=0012h,AH=20h/BP=0012h,AH=22h/BP=0012h
--------N-6F1F-------------------------------
INT 6F U - 10NET v5.0 - "WHOAMI" - ???
	AH = 1Fh
	???
Return: ???
--------N-6F20-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 20h
	???
Return: ???
--------b-6F20--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_RAM_RET" - RESERVE EX-BIOS MEMORY
	AH = 20h
	BP = 0012h (driver ID for V_SYSTEM)
	BX = new value for "last-used DS"
	DX = new value for "maximum DS"
Return: AH = status (00h) (see #3376 at INT 6F/AH=00h"HP Vectra")
	BP,DS destroyed
Note:	the F_INS_FIXGETDS and F_INS_FREEGETDS functions
	  (see AH=0Eh/BP=0012h,AH=14h/BP=0012h) also modify the values returned
	  by this call, requiring care if both methods are used to allocate
	  memory
SeeAlso: AH=00h"HP Vectra",AH=0Eh/BP=0012h,AH=14h/BP=0012h,AH=1Eh/BP=0012h
--------N-6F21-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 21h
	???
Return: ???
--------N-6F22-------------------------------
INT 6F U - 10NET v5.0 - ???
	AH = 22h
	???
Return: ???
--------b-6F22--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_CMOS_GET" - READ CMOS MEMORY
	AH = 22h
	BP = 0012h (driver ID of V_SYSTEM)
	BL = address of CMOS byte to read
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	AL = byte read
	BP,DS destroyed
Note:	supported by ES, QS, and RS series HP Vectras
SeeAlso: AH=00h"HP Vectra",AH=1Eh/BP=0012h,AH=24h/BP=0012h
--------b-6F24--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_CMOS_RET" - WRITE CMOS MEMORY
	AH = 24h
	BP = 0012h (driver ID of V_SYSTEM)
	BL = address of CMOS byte to write
	AL = new value
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	updates the CMOS checksum fields (both IBM-standard and HP checksums)
SeeAlso: AH=00h"HP Vectra",AH=22h/BP=0012h
--------b-6F2A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_YIELD" - GIVE UP CPU TO OTHER TASKS
	AH = 2Ah
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376)
	BP,DS destroyed
Note:	this is a hook for multitasking systems
SeeAlso: AH=00h"HP Vectra",INT 15/AX=1000h,INT 2F/AX=1680h
--------b-6F30--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK_ENABLE" - TURN ON KEYCLICKS
	AH = 30h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
Desc:	enables keyclicks and flushes any pending keyclicks
SeeAlso: AH=32h/BP=0012h,AH=34h/BP=0012h,AH=36h/BP=0012h
--------b-6F32--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK_DISABLE" - TURN OFF KEYCLICKS
	AH = 32h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	disables keyclicks and flushes any pending keyclicks
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=38h/BP=0012h
--------b-6F34--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_CLICK" - GENERATE KEYCLICK
	AH = 34h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376)
	BP,DS destroyed
Desc:	generate a keyclick if fewer than four clicks are already pending
Note:	if keyclicks are already pending, the remaining click count is
	  incremented and the function returns immediately
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=36h/BP=0012h,AH=3Ah/BP=0012h
--------b-6F36--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP_ENABLE" - ENABLE BEEPS
	AH = 36h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=30h/BP=0012h,AH=34h/BP=0012h,AH=38h/BP=0012h
--------b-6F38--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP_DISABLE" - DISABLE BEEPS
	AH = 38h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=32h/BP=0012h,AH=36h/BP=0012h
--------b-6F3A--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_BEEP" - SOUND BEEP WITH CURRENT VALUES
	AH = 3Ah
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
Desc:	make a sound of the frequency and duration defined in the EX-BIOS
	  global data area (see #3380)
SeeAlso: AH=00h"HP Vectra",AH=34h/BP=0012h,AH=36h/BP=0012h,AH=38h/BP=0012h
SeeAlso: AH=3Ch/BP=0012h,AH=3Eh/BP=0012h
--------b-6F3C--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_SET_BEEP" - SET BEEP FREQUENCY AND DURATION
	AH = 3Ch
	BP = 0012h (driver ID of V_SYSTEM)
	BX = frequency in Hz (1-25000, 0 = off)
	DX = duration in 10-microsecond increments
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=3Ah/BP=0012h,AH=3Eh/BP=0012h,#3380
--------b-6F3E--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_SND_TONE" - SOUND TONE WITH FREQ AND DURATION
	AH = 3Eh
	BP = 0012h (driver ID of V_SYSTEM)
	BX = frequency in Hz (1-25000, 0 = off)
	DX = duration in 10-microsecond increments
Return: AH = status (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=3Ah/BP=0012h,AH=3Ch/BP=0012h,AH=40h/BP=0012h
--------b-6F40--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_FREE_INDEX" - FIND FREE STRING INDEX
	AH = 40h
	BP = 0012h (driver ID of V_SYSTEM)
Return: AH = status (see #3376)
	BX = next free string index
	BP,DS destroyed
Desc:	get the next string index available to user programs
SeeAlso: AH=00h"HP Vectra",AH=42h/BP=0012h,AH=44h/BP=0012h,AH=46h/BP=0012h
--------b-6F42--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_DEL_BUCKET" - DEL HEADER FROM BUCKET LIST
	AH = 42h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> bucket header (see #3407)
Return: AH = status (00h,FEh) (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=40h/BP=0012h,AH=44h/BP=0012h

Format of HP Vectra EX-BIOS bucket header:
Offset	Size	Description	(Table 3407)
 00h	DWORD	pointer to next bucket header (FFFFh:FFFFh if last)
 04h	WORD	upper bound on string index
 06h	WORD	lower bound on string index
 08h	DWORD	pointer to array of string offset pointers
 0Ch	WORD	segment of strings
Note:	the strings pointed at by the offset pointers are byte-counted ASCIZ
	  strings
--------b-6F44--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_PUT_BUCKET" - ADD HEADER TO BUCKET HDR LIST
	AH = 44h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> bucket header (see #3407)
Return: AH = status (00h) (see #3376)
	BP,DS destroyed
SeeAlso: AH=00h"HP Vectra",AH=42h/BP=0012h,AH=46h/BP=0012h
--------b-6F46--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_STRING" - FIND STRING IN BUCKET LIST
	AH = 46h
	BP = 0012h (driver ID of V_SYSTEM)
	BX = string index
Return: AH = status (00h,other) (see #3376)
	BP,DS destroyed
	---if successful---
	CX = length of string (excluding count byte and terminating NUL)
	DS:SI -> header for string
	ES:DI -> found string
SeeAlso: AH=00h"HP Vectra",AH=44h/BP=0012h,AH=48h/BP=0012h
--------b-6F48--BP0012-----------------------
INT 6F - HP Vectra EX-BIOS - "F_STR_GET_INDEX" - GET INDEX FOR STRING
	AH = 48h
	BP = 0012h (driver ID of V_SYSTEM)
	ES:DI -> ASCIZ string
Return: AH = status (00h,other) (see #3376 at AH=00h"HP Vectra")
	BP,DS destroyed
	---if successful---
	BX = index for the given string
SeeAlso: AH=00h"HP Vectra",AH=40h/BP=0012h,AH=46h/BP=0012h
--------A-6F636FBX6D70-----------------------
INT 6F - Clara Empricost - TSR Version - INSTALLATION CHECK
	AX = 636Fh ('co')
	BX = 6D70h ('mp')
	CX = 696Eh ('in')
	SS:DX -> WORD to set if installed
Return: SS:DX word set to 636Fh if installed
Program: Condition List Action Rejection Algorithm for the Evaluation
	  of Music at Pseudo-Random Idea COnstruction STage
	  (CLARA EMPRICOST) is an experimental program by Silas Brown
SeeAlso: AX=636Fh/BX=6D70h"UNINSTALL"
--------A-6F636FBX6D70-----------------------
INT 6F - Clara Empricost - TSR Version - UNINSTALL
	AX = 636Fh ('co')
	BX = 6D70h ('mp')
	CX = 6F73h ('os')
Return: nothing -- call installation check to determine whether successful
Program: Condition List Action Rejection Algorithm for the Evaluation
	  of Music at Pseudo-Random Idea COnstruction STage
	  (CLARA EMPRICOST) is an experimental program by Silas Brown
Notes:	 Saves any unfinished task and prevents processing of
	   new tasks, even if can't uninstall
	 If INT 28h or INT 6Fh have been chained since installation,
	   returns without changing interrupts or freeing memory
	 do not call while DOS is active (i.e. InDOS flag is nonzero or INT 28
	   is active and InDOS > 1)
SeeAlso: AX=636Fh/BX=6D70h"INSTALLATION CHECK"
--------N-6F80-------------------------------
INT 6F - 10NET v5.0 - LOGIN
	AH = 80h
	DS:DX -> login record (see #3408)
Return: CF clear if successful
	    BL = number of days until password expires (00h = never)
	    CL = security level
	CF set on error
	    AX = status (see #3372)
SeeAlso: AH=00h,AH=81h

Format of 10NET login record:
Offset	Size	Description	(Table 3408)
 00h  8 BYTEs	user name
 08h  8 BYTEs	password
 10h 15 BYTEs	server node ID
 1Fh  8 BYTEs	new password
 27h	BYTE	invoke mode (00h command line, 01h interactive)
--------N-6F81-------------------------------
INT 6F - 10NET v5.0 - LOGOUT
	AH = 81h
	DS:DX -> server node ID (DX=0000h for universal logout)
Return: AX = status (see #3372)
SeeAlso: AH=01h,AH=80h
--------N-6F8A-------------------------------
INT 6F - 10NET v5.0 - CHAT
	AH = 8Ah
	DS:BX -> chat parameters (see #3409)
	DS:DX -> chat message (see #3410)
Return: CF clear if successful
	CF set on error
	    AX = status (see #3372)
SeeAlso: AH=0Ah"10NET"

Format of 10NET chat parameters:
Offset	Size	Description	(Table 3409)
 00h  8 BYTEs	sender's user name
 08h  8 BYTEs	destination user name
 10h 15 BYTEs	destination node (0 if broadcast-style chat)

Format of 10NET chat message:
Offset	Size	Description	(Table 3410)
 00h	WORD	message length
 02h  N BYTEs	chat message contents
--------N-6F8D-------------------------------
INT 6F - 10NET v5.0 - "WHO" - ENUMERATE USERS ON NETWORK
	AH = 8Dh
	BX = service mask (see #3411)
	CX = length of buffer
	DS:DX -> buffer for array of Who data structures (see #3412)
Return: CF clear if successful
	    CX = number of nodes matching service mask
	    DS:DX buffer filled
	CF set on error
	    AX = status (see #3372)
SeeAlso: AH=0Dh

Bitfields for 10NET service mask:
Bit(s)	Description	(Table 3411)
 0	workstation
 1	file server
 2	print server
 3	de-spool server

Format of 10NET Who data structure:
Offset	Size	Description	(Table 3412)
 00h  8 BYTEs	user name
 08h 15 BYTEs	node ID
 17h  3 BYTEs	unique portion of Ethernet address
 1Ah	BYTE	Who group number
 1Bh	WORD	service mask (see #3411)
 1Dh	DWORD	serial number
 21h	BYTE	maximum concurrent users with same serial number allowed on net
 22h	BYTE	chat mask (see #3413)
 23h	BYTE	internal system bits (see #3414)
 24h  9 BYTEs	version number in format MM.mm.xxx
 2Dh	BYTE	number of shared directories
 2Eh	BYTE	number of shared printer queues

Bitfields for 10NET chat mask:
Bit(s)	Description	(Table 3413)
 0	chat permitted
 1	bell enabled
 2	chat keyboard initiated
 3	in INT 16 handler
 4	in Get Input
 5	display has timed out
 6	chat is idle

Bitfields for 10NET internal system bits:
Bit(s)	Description	(Table 3414)
 0	submit permitted
 1	submit initiated
 2	submit executing
 3	internal client call/chat/spool/autospool
 4	in spool termination
 5	print permitted
 6	waiting for keyboard input
--------N-6F9501-----------------------------
INT 6F - 10NET v5.0 - GET SHARED DEVICE ENTRY
	AX = 9501h
	BX = zero-based index
	DS:SI -> server's node ID
	ES:DI -> buffer for shared device structure (see #3415)
Return: CF clear if successful
	CF set on error
	    AX = status (see #3372)
SeeAlso: AX=1501h,AX=9502h,AX=9503h,AX=9504h

Format of 10NET shared device structure:
Offset	Size	Description	(Table 3415)
 00h  8 BYTEs	alias
 08h	BYTE	type (02h modem, 03h print queue, 04h directory)
 09h	BYTE	access rights
		bit 0: read
		bit 1: write
		bit 2: create
 0Ah  8 BYTEs	password
 12h 32 BYTEs	comment
---directory---
 32h 64 BYTEs	pathname of shared directory
---print queue---
 32h	BYTE	notification bit mask (see #3416)
 33h	BYTE	job control bit mask (see #3417)
 34h	WORD	number of days to retain file
 36h	WORD	test print length
 38h	BYTE	number of copies to print
 39h	BYTE	compression algorithm
 3Ah	BYTE	tab width (00h = don't expand)
 3Bh	BYTE	priority
 3Ch	WORD	time to open queue (FFFFh = always)
 3Eh	WORD	time to close queue
 40h	WORD	pause following queue switch, in clock ticks
 42h	WORD	pause between print jobs, in clock ticks
 44h	BYTE	associate queue file existence mask
		bit 0: queue switch file exists
		bit 1: initiate file exists
		bit 2: abort file exists
 45h  6 BYTEs	character sequence for page eject
 4Bh	BYTE	status of print queue
		bit 0: queue is closed
 4Ch	WORD	number of jobs on queue
 4Eh	WORD	offset of next print job to be dispatched (FFFFh = none)
 50h	BYTE	number of print devices in printer pool
 51h	WORD	offset of first print device structure (FFFFh if empty)

Bitfields for notification flags:
Bit(s)	Description	(Table 3416)
 0	user at print start
 1	operator at start, with reply
 2	user at print completion
 3	operator at completion, with reply
 4	user on queue switch
 5	operator on queue switch, with reply
 6	user on print error

Bitfields for 10NET job control mask:
Bit(s)	Description	(Table 3417)
 0	print banner page
 1	eject page at end of job
 2	mark as "held" (queue but don't print)
 3	rush job (queue at top)
 4	overwrite file with zeros before deletion
 5	hyperspool if possible
--------N-6F9502-----------------------------
INT 6F - 10NET v5.0 - SET SHARED DEVICE ENTRY
	AX = 9502h
	DS:SI -> server's node ID
	ES:DI -> shared device structure (see #3415)
Return: CF clear if successful
	CF set on error
	    AX = status (see #3372)
SeeAlso: AX=1502h,AX=9501h,AX=9503h,AX=9504h
--------N-6F9503-----------------------------
INT 6F - 10NET v5.0 - DELETE SHARED DEVICE
	AX = 9503h
	BX = zero-based index
	DS:SI -> server's node ID
Return: CF clear if successful
	CF set on error
	    AX = status (see #3372)
SeeAlso: AX=1503h,AX=9501h,AX=9502h,AX=9504h
--------N-6F9504-----------------------------
INT 6F - 10NET v5.0 - ENUMERATE USERS OF SHARED DEVICE
	AX = 9504h
	BX = zero-based shared device index
	CX = zero-based user index
	DS:SI -> server's node ID
Return: CF clear if successful
	    ES:DI -> node ID of the CX'th user of the BX'th device
	CF set on error
	    AX = status (see #3372)
SeeAlso: AX=9501h,AX=9502h,AX=9503h
--------N-6F99-------------------------------
INT 6F - 10NET v5.0 - AUDIT
	AH = 99h
	DS:SI -> server's node ID
	ES:DI -> data to be appended to audit trail file (max 106 bytes)
Return: CF clear if successful
	CF set on error
	    AX = status (see #3372)
SeeAlso: AH=19h,AH=9Ch
--------N-6F9C-------------------------------
INT 6F - 10NET v5.0 - GET LOGIN LIST
	AH = 9Ch
	BX = zero-based index
Return: CF clear if successful
	    DS:DI -> BX'th node ID that caller's machine is logged into
	CF set on error
	    AX = status (see #3372)
--------H-70---------------------------------
INT 70 C - IRQ8 - CMOS REAL-TIME CLOCK
Desc:	this interrupt is called when the real-time clock chip generates an
	  alarm or periodic interrupt, among others.  The periodic interrupt
	  occurs 1024 times per second.
Notes:	many BIOSes turn off the periodic interrupt in the INT 70h handler
	  unless in an event wait (see INT 15/AH=83h,INT 15/AH=86h).
	may be masked by setting bit 0 on I/O port A1h
SeeAlso: INT 08,INT 0F"HP 95LX",INT 15/AH=01h"Amstrad",INT 15/AH=83h
SeeAlso: INT 15/AH=86h,INT 1A/AH=02h,INT 58"DESQview",MEM FEE00320h
--------v-70---------------------------------
INT 70 - VIRUS - "Stupid" - ORIGINAL INT 21h VECTOR
Note:	the virus sets this interrupt to be the same as INT 21, and then
	  performs only INT 70 calls; since INT 70 is also generated by the
	  real-time clock on the PC/AT and higher, this could cause random
	  actions on an infected system
SeeAlso: INT 6B"VIRUS",INT 9E"VIRUS",INT E0"VIRUS"
--------H-71---------------------------------
INT 71 C - IRQ9 - REDIRECTED TO INT 0A BY BIOS
Notes:	may be masked by setting bit 1 on I/O port A1h
	the default BIOS handler invokes INT 0A for compatibility, since the
	  pin for IRQ2 on the PC expansion bus became the pin for IRQ9 on the
	  AT expansion bus.
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 0A"IRQ2",INT 59"IRQ9"
--------H-72---------------------------------
INT 72 C - IRQ10 - RESERVED
Note:	may be masked by setting bit 2 on I/O port A1h
SeeAlso: INT 5A"IRQ10"
--------H-73---------------------------------
INT 73 C - IRQ11 - RESERVED
Note:	may be masked by setting bit 3 on I/O port A1h
SeeAlso: INT 5B"IRQ11"
--------H-74---------------------------------
INT 74 C - IRQ12 - POINTING DEVICE (PS)
Notes:	may be masked by setting bit 4 on I/O port A1h
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 33/AX=0000h,INT 33/AX=0024h,INT 5C"NetBIOS"
--------H-75---------------------------------
INT 75 C - IRQ13 - MATH COPROCESSOR EXCEPTION (AT and up)
Desc:	redirected to INT 02 by the BIOS, for compatibility with the PC
Notes:	may be masked by setting bit 5 on I/O port A1h
	not all clones wire the coprocessor to generate this IRQ; some systems
	  generate an NMI (see INT 02) or assert the -ERROR pin on the CPU
	  (see INT 10"COPROCESSOR")
	under DESQview, only the INT 15h vector and BASIC segment address (the
	  word at 0000h:0510h) may be assumed to be valid for the handler's
	  process
SeeAlso: INT 10"COPROCESSOR",INT 5D"IRQ13"
--------H-76---------------------------------
INT 76 C - IRQ14 - HARD DISK CONTROLLER OPERATION COMPLETE (AT and later)
Notes:	may be masked by setting bit 6 on I/O port A1h
	on the PS/2, this interrupt is designed to be shared with other
	  devices that produce an operation-complete interrupt, though
	  the only current user is the hard disk
SeeAlso: INT 0E"IRQ6",INT 15/AH=91h,INT 5E"IRQ14"
--------H-77---------------------------------
INT 77 C - IRQ15 - RESERVED (AT,PS)
Note:	may be masked by setting bit 7 on I/O port A1h
SeeAlso: INT 5F"IRQ15"
--------H-77---------------------------------
INT 77 C - IRQ15 - POWER CONSERVATION (Compaq SLT/286)
Note:	may be masked by setting bit 7 on I/O port A1h
SeeAlso: INT 15/AX=4600h,INT 5F"IRQ15"
--------E-78---------------------------------
INT 78 - UofSalford DBOS DOS extender - API
	AH = function
	    00h (PB) display 32-bit memory specified by command argument
	    01h (PT) display 32-bit instruction(s) specified by command arg
	    02h specify offset to subsequent PB and PT commands
	    03h switch to protected mode
		DWORD following INT instruction point to map; protected-mode
			  entry point is immediately following the DWORD
		Return: never
		Note:	if bit 31 of the map address is set, only a stub was
			  loaded by DOS and DBOS will load the entire program
	    04h specify that subsequent load (AH=03h) should leave program in
		  memory
	    05h release program from memory
	    06h set break point at address and option count from commandline
	    07h resume program execution
	    08h single-step program
	    09h set read/write breakpoint using 386 debug registers
	    0Ah set write breakpoint using 386 debug register
	    0Bh set memory byte to new value
	    0Ch display CPU registers
	    0Dh run until specified program address reached
	    0Fh print trace from program map
	    10h specify an offset using a map symbol
	    14h print memory without any offset
	    18h switch DBOS into/out of test mode (ON/OFF commandline args)
	    1Dh get address of real/protected-mode communication buffer
		Return: ES:BP -> comm buffer
	    1Eh set real-mode memory size (specify how much real-mode memory
		  to leave free when running FTN77 programs)
	    22h uninstall DBOS
	    24h force DBOS to emulate coprocessor instructions
	    26h set named DBOS switches from commandline
	    27h reset named DBOS switched from commandline
	    2Ah set list of dynamic link libraries to contents of commandline
		  file
	    35h specify that subsequent load (AH=03h) should stop at first
		  instruction
Return: ???
Notes:	DBOS supports functions 00h through 50h; many of these functions
	  provide a low-level debugging interface
	command arguments are read from the calling program's PSP
SeeAlso: INT 79"DBOS"
Index:	uninstall;DBOS DOS extender
--------E-78---------------------------------
INT 78 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ0
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 08,INT 10/AH=FFh"GO32",INT 79"GO32"
--------A-78---------------------------------
INT 78 R - AutoCAD Device Interface - PLOTTER - SEND COMMAND
	AX = function
	    0001h begin plot
		BX = file level
		    0000h ASCII file
		    0001h binary file
		    0002h AutoCAD DXB file
		    0003h installed ADI driver
	    0002h end plot (close plotter)
	    0003h move (pen up)
		BX = new X position
		CX = new Y position
	    0004h move (pen down)
		BX = new X position
		CX = new Y position
	    0005h select pen
		BX = pen number
	    0006h select drawing speed
		BX = drawing speed N
	    0007h select line style
		BX = line style N
	    0008h raise pen
	    0009h abort plot
Return: AX = 0000h (may be used for driver status in future releases)
SeeAlso: INT 79"AutoCAD",INT 7A/AX=0001h"AutoCAD",INT 7B/AX=8001h"AutoCAD"
--------d-78---------------------------------
INT 78 - ADP-60 IDE controller - ORIGINAL INT 13
SeeAlso: INT 79"ADP-60"
--------s-78-------------------------------
INT 78 - ULTRAMID - API
	AX = function
	--- digital functions ---
	    0000h start digital
		ES:DI -> Sound Structure
		Return: AX = voice used
	    0001h play next buffer
		ES:DI -> Sound Structure
	    0002h set panning
		BX = pan
		CX = voice
	    0003h set volume
		BX = volume
		CX = voice
	    0004h set rate (not yet implemented)
	    0005h pause digital
		CX = voice
	    0006h restart digital
		CX = voice
	    0007h stop digital
		CX = voice
	    0008h get digital position
		CX = voice
		Return: AX:DX -> position in PC buffer
	    0009h get voice status (not yet implemented)
	--- MIDI functions ---
	    000Ah load MIDI patches
		ES:DI -> MIDI track just after the Mtrk header
		BX:DX = length of MIDI track
	    000Bh load XMIDI patches
		ES:DI -> event buffer including the EVNT header
	    000Ch load patch
		CX = MIDI number of patch
	    000Dh unload patch
		CX = MIDI number of patch
	    000Eh start sequence
	    000Fh unload all patches
	    0010h MIDI out byte
		CX = MIDI byte
	    0011h MIDI out string
		CX = length
		ES:DI -> string of MIDI data
	    0012h all notes off
	--- resource functions ---
	    0013h allocate memory
		BX:DX = size of GUS memory needed
		Return: AX:DX = address of memory, or 0000:0000 if not avaiable
	    0014h free memory
		BX:DX = address of memory to be freed
	    0015h uninstall
	    0016h sem enter
	    0017h sem leave
	    0018h add external semaphore
		BX:DX -> external semaphore
	    0019h clear external semaphore
		BX:DX -> external semaphore
	    001Ah application start
	    001Bh application end
	--- v1.12 ---
	    001Ch ???
	    001Dh ???
	    001Eh ???
	    001Fh ???
Program: UltraMid is a TSR from Advanced Gravis to play MIDI and digital data
	   through the Gravis UltraSound (GUS)
Range:	INT 78 to INT 7F
Notes:	the installation check is testing for the signature "ULTRAMID" at
	  offset 0103h in the interrupt handler's segment
SeeAlso: INT 2F/AX=CD00h"ULTRAMID",INT 7E/AH=00h"SBOS",INT 7E/AX=00FEh"SBOS"
Index:	uninstall;UltraMID
--------d-7800-------------------------------
INT 78 - TARGA.DEV - CMC International SCSI device driver - SET I/O PORT
	AH = 00h
	DX = interface board I/O port
Return: CF set on error
	    AL = error code (see #3418)
Note:	if this routine is not called, the port is the driver's default
	  (usually 0280h or 0300h)
	an installation check is performed by TARGA.DEV upon initialization
	  by checking for the string "SCSI" at offset 03h into the interrupt
	  handler
SeeAlso: AH=01h,AH=02h
Index:	installation check;TARGA.DEV

(Table 3418)
Values for TARGA.DEV error code:
 00h	illegal command given to SCSI code
 01h	invalid I/O port specified (must be from 100H to 3F8H, and must be on
	  an 8-port boundary)
 02h	invalid DMA channel specified (must be from 1 to 3)
 03h	invalid SCSI board number specified (must be from 0 to 7)
 04h	error from data register test during self-test
 05h	SCSI input signals not all 0 when SCSI RST activated
 06h	SCSI input signals not all 0 before selecting a SCSI device
 07h	BSY signal is active; SCSI bus is busy
 08h	SCSI board not selected, BSY signal did not come on in response to
	  raising SEL
 09h	time-out waiting for status state, signifying end of DMA transfer
--------E-780000-----------------------------
INT 78 - HugeRealMode Driver - INSTALLATION CHECK
	AX = 0000h
Return: AX = DBCAh if installed
Program: the HugeRealMode driver was published in the German DOS Extra Nr. 20
	  (1992), and makes a 4G flat address space (for both data and code)
	  available to real-mode DOS programs
SeeAlso: AX=0001h
--------E-780001-----------------------------
INT 78 - HugeRealMode Driver - GET ENTRY POINT
	AX = 0001h
Return: ES:BX -> far call entry point (see #3420,#3435)
SeeAlso: AX=0000h

(Table 3419)
Values for HugeRealMode Server error code:
 00h	successful
 01h	unknown function
 02h	A20 disabled
 03h	A20 enabled
 04h	memory allocation error
 05h	memory not fixeable (LOCK)
 06h	memory not deallocaable
 07h	memory not moveable (UNLOCK)
 08h	change in memory allocation size not possible
 09h	file error (with .XMF-file)
 0Ah	memory error (with .XMF-file)
 0Bh	unknown procedure (currently Turbo Pascal unit only)

(Table 3420)
Call HugeRealMode Server "Enable A20" function with:
	AL = 00h
Return: AX = error code (see #3419)
Note:	The HugeRealMode Server requires an XMS-driver like HIMEM.SYS loaded
	  before HUGEREAL (for XMS-memory allocation and A20 control). It
	  utilizes some undocumented 386+ features to enable 4G code and data
	  segments (flat memory model) in the CPUs real-mode. It is not
	  compatible with V86-mode (as with most EMM386). For maximum speed
	  and compatibility with DOS it uses a two stage interrupt model
	  (see #3423)
SeeAlso: #3421,#3422,#3423

(Table 3421)
Call HugeRealMode Server "Disable A20" function with:
	AL = 01h
Return: AX = error code (see #3419)
SeeAlso: #3420,#3422

(Table 3422)
Call HugeRealMode Server "Query A20 State" function with:
	AL = 02h
Return: AX = A20 state (0000h disabled, 0001h enabled)
SeeAlso: #3420,#3421

(Table 3423)
Call HugeRealMode Server "Enable Two-Stage Interrupt Model" function with:
	AL = 03h
Return: AX = error code (see #3419)
Notes:	If the two stage interrupt model is disabled, the IP must stay below
	  1MB, because the high word of EIP is not saved correctly by the
	  standard interrupt management in real mode.  Routines in extended
	  memory may only be called with interrupts disabled (only usable for
	  very short routines).
	If the two stage interupt model is enabled, these conventions are not
	  required.  The outer (transparent) ISRs save the higher word of EIP
	  in the high word of CR3 (possible modification: in memory, if this
	  is not safe) and then invoke the standard ISRs.
	Because of this handling, one should use pseudo segmented code even in
	  extended memory (64K blocks located on 64K boundaries) to avoid the
	  misalignment of the saved EIP (in CR3). Another way is to track and
	  realign CR3 each time when jumping over a 64K boundary in extended
	  memory
SeeAlso: #3420,#3424

(Table 3424)
Call HugeRealMode Server "Disable Two-Stage Interrupt Model" function with:
	AL = 04h
Return: AX = error code (see #3419)
SeeAlso: #3420,#3423

(Table 3425)
Call HugeRealMode Server "Get Segment Address Of Server-Management Range" with:
	AL = 05h
Return: AX = error code (see #3419)
	ES = segment address
SeeAlso: #3435

(Table 3426)
Call HugeRealMode Server "Allocate Memory" function with:
	AL = 06h
	DX = length in KB
Return: AX = error code (see #3419)
	DX = handle
	EBX = start address of allocated block
SeeAlso: #3427,#3428

(Table 3427)
Call HugeRealMode Server "Deallocate Memory" function with:
	AL = 07h
	DX = handle
Return: AX = error code (see #3419)
SeeAlso: #3426,#3428

(Table 3428)
Call HugeRealMode Server "Modify Allocated Memory Size" function with:
	AL = 08h
	DX = handle
	BX = new size in KB
Return: AX = error code (see #3419)
	EBX = new address
SeeAlso: #3426,#3427

(Table 3429)
Call HugeRealMode Server "Load .XMF-file" function with:
	AL = 09h
	ES:BX -> filename (see #3430)
Return: AX = error code (see #3419)
	ECX = target address
Notes:	memory must be allocated before loading
	.XMF file format (eXtended Memory executable File format) is supported
	  by the HugeRealMode server for easier handling of XMS-code.
	The utility CONFXMF converts .OBJ-files (.COM 'tiny' model) to
	  .XMF-format
SeeAlso: #3426

Format of .XMF program file header:
Offset	Size	Description	(Table 3430)
 00h	DWORD	signature "XMF_"
 04h	WORD	length of programs code
 06h	WORD	count of 32bit addresses to relocate
 08h	WORD	offset to code start (releative to file start) (see #3431)
 0Ah	WORD	relocation table
Note:	each word contains a 16bit address, where a relocation has to be
	  performed
SeeAlso: #3429,#3431

Format of .XMF-file code header:
Offset	Size	Description	(Table 3431)
 00h	WORD	count of exported functions
 02h  N PWORDs	48bit pointers (16bit segment+32bit offset) to each function
		(16bit segment is always zero)
 var		start of program's code
SeeAlso: #3429,#3430

(Table 3432)
Call HugeRealMode Server "Set Segment Limits" function with:
	AL = 0Ah
	BL = segment limits (see #3433)
Return: AX = error code (see #3419)
SeeAlso: #3425

Bitfields for HugeRealMode Server segment limits:
Bit(s)	Description	(Table 3433)
 7	CS size: 1=4GB, 0=64KB
 6-5	not used
 4	SS size: 1=4GB, 0=64KB
 3	GS size
 2	FS size
 1	ES size
 0	DS size
SeeAlso: #3432

(Table 3434)
Call HugeRealMode Server "Transfer Memory From DOS To XMS" function with:
	AL = 0Bh
	ES:SI = source address
	EDI = target address
	ECX = length
Return: AX = error code
SeeAlso: #3435

(Table 3435)
Call HugeRealMode Server "Transfer Memory From XMS To DOS" function with:
	AL = 0Ch
	ESI = source address
	ES:DI = target address
	ECX = length
Return: AX = error code
SeeAlso: #3434
--------d-7801-------------------------------
INT 78 - TARGA.DEV - GET I/O PORT
	AH = 01h
Return: DX = current interface board I/O port
SeeAlso: AH=00h,AH=03h"TARGA"
--------d-7802-------------------------------
INT 78 - TARGA.DEV - SET DMA CHANNEL
	AH = 02h
	AL = interface board DMA channel
Return: CF set on error
	AL = error code (see #3418)
Note:	if this routine is not called, the DMA channel is the driver's default
	  (usually 3)
SeeAlso: AH=00h,AH=03h"TARGA"
--------d-7803-------------------------------
INT 78 - TARGA.DEV - GET DMA CHANNEL
	AH = 03h
Return: AL = current interface board DMA channel
SeeAlso: AH=01h,AH=02h
--------d-7804-------------------------------
INT 78 - TARGA.DEV - SET SCSI DEVICE NUMBER
	AH = 04h
	AL = SCSI device number
Return: CF set on error
	AL = error code (see #3418)
Note:	if this routine is not called, the device number used is the driver's
	  default (usually 0)
SeeAlso: AH=02h,AH=05h
--------d-7805-------------------------------
INT 78 - TARGA.DEV - GET SCSI DEVICE NUMBER
	AH = 05h
Return: AL = current SCSI device number
SeeAlso: AH=03h"TARGA",AH=04h
--------d-7806-------------------------------
INT 78 - TARGA.DEV - SET/CLEAR EARLY RETURN MODE
	AH = 06h
	AL = new state
	    00h clear early return mode
	    01h set early return mode
Note:	if early return mode is set then SCSI will return with no errors
	  when the last DMA transfer is started in a call with AH=13h or AH=14h
	if this routine is not called, early return mode is cleared
SeeAlso: AH=13h,AH=14h,AH=15h
--------d-7808-------------------------------
INT 78 - TARGA.DEV - INTERFACE BOARD SELF-TEST
	AH = 08h
Return: CF set on error
	AL = error code (see #3418)
Note:	the SCSI bus is also reset
SeeAlso: AH=09h
--------d-7809-------------------------------
INT 78 - TARGA.DEV - RESET SCSI BUS
	AH = 09h
Return: AL = error code if carry set (see #3418)
SeeAlso: AH=08h
--------d-7810-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND
	AH = 10h
	DS:SI -> command bytes (see #3436)
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3418)
SeeAlso: AH=11h,INT 21/AX=4403h"ST-01"

Format of SCSI Command:
Offset	Size	Description	(Table 3436)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7811-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND, RECEIVE DATA (PROGRAMMED I/O)
	AH = 11h
	DS:SI -> command bytes (see #3437)
	ES:BX -> data storage area
	CX = number of data bytes to transfer
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3418)
Note:	this command receives data internally one byte at a time
SeeAlso: AH=10h,AH=13h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3437)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7812-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND AND DATA (PROGRAMMED I/O)
	AH = 12h
	DS:SI -> command bytes (see #3438)
	ES:BX -> data storage area
	CX = number of data bytes to transfer
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3418)
Note:	this command sends data internally one byte at a time
SeeAlso: AH=14h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3438)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7813-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND, RECEIVE DATA (DMA)
	AH = 13h
	DS:SI -> command bytes (see #3439)
	ES:BX -> data storage area
	DX:CX = number of data bytes to transfer
Return: AH = SCSI status byte (if early return mode is clear)
	CF clear if successful
	    AL = SCSI message byte (if early return mode is clear)
	CF set on error
	    AL = error code (see #3418)
Note:	this command receives data using DMA
SeeAlso: AH=11h,AH=12h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3439)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7814-------------------------------
INT 78 - TARGA.DEV - SEND SCSI COMMAND AND DATA (DMA)
	AH = 14h
	DS:SI -> command bytes (see #3440)
	ES:BX -> data storage area
	DX:CX = number of data bytes to transfer
Return: AH = SCSI status byte (if early return mode is clear)
	CF clear if successful
	    AL = SCSI message byte (if early return mode is clear)
	CF set on error
	    AL = error code (see #3418)
Note:	this command sends data using DMA
SeeAlso: AH=12h,AH=13h

Format of TARGA.DEV SCSI Command:
Offset	Size	Description	(Table 3440)
 00h	BYTE	length of command
 01h	???	command bytes
--------d-7815-------------------------------
INT 78 - TARGA.DEV - FINISH DATA TRANSFER (DMA)
	AH = 15h
Return: AH = SCSI status byte
	CF clear if successful
	    AL = SCSI message byte
	CF set on error
	    AL = error code (see #3418)
Note:	if AH=06h was previously called to set the early return mode, this
	  function finishes a command AH=13h or AH=14h which returned before
	  the last DMA transfer was finished
SeeAlso: AH=06h,AH=13h,AH=14h
--------V-79---------------------------------
INT 79 - AVATAR.SYS - FAST GET KEYSTROKE
Return: CF set if no keystroke available
	    AX = FFFFh
	CF clear if key pressed
	    AX = keystroke
Program: AVATAR.SYS is a CON driver by George Adam Stanislav which interprets
	  AVATAR command codes just as ANSI.SYS interprets ANSI commands
Note:	if a keystroke is available, it is removed from the keyboard buffer
	  before being returned
SeeAlso: INT 29,INT 2F/AX=1A00h/BX=4156h
--------E-79---------------------------------
INT 79 - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ1
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 09,INT 78"GO32",INT 7A"GO32"
--------d-79---------------------------------
INT 79 U - ADP-60 IDE adapter - ???
SeeAlso: INT 78"ADP-60"
--------E-79---------------------------------
INT 79 - DBOS DOS Extender
	details not available
Desc:	this interrupt is used by an MS Windows virtual device driver with
	  which the DBOS extender communicates when run inside a Windows
	  Enhanced Mode DOS box
SeeAlso: INT 78"DBOS"
--------A-790001-----------------------------
INT 79 R - AutoCAD Device Interface - DIGITIZER - INITIALIZE
	AX = 0001h
	BX = interface level (0001h)
Return: AX = status (0000h initialization failed, 0001h init successful)
	BX = digitizer type
	    0000h relative pointing device (mouse, etc.)
	    0001h digitizing tablet
	CX = digitizer dataflow type
	    0000h continuous
	    0001h pauses between packets
SeeAlso: AX=0002h,AX=0003h,INT 7A/AX=0001h"AutoCAD"
--------A-790002-----------------------------
INT 79 R - AutoCAD Device Interface - DIGITIZER - TERMINATE
	AX = 0002h
SeeAlso: AX=0001h,AX=0003h
--------A-790003-----------------------------
INT 79 R - AutoCAD Device Interface - DIGITIZER - GET DIGITIZER STATUS
	AX = 0003h
Return: AX = status
	    0000h nothing
	    0002h tracking point (no button pressed)
		BX = X coordinate
		CX = Y coordinate
	    0003h picked point (button 0,A,B,C,D pressed)
		BX = X coordinate
		CX = Y coordinate
	    0004h button pick
		BX = button number
	    0005h button and coordinates
		BX = button number
		CX = X coordinate
		DX = Y coordinate
SeeAlso: AX=0001h,AX=0002h
--------N-7A---------------------------------
INT 7A U - Topware Network Operating System - ???
	AL = ???
	???
Return: ???
SeeAlso: INT 21/AX=FF00h"Topware",INT 2F/AX=FF00h
--------N-7A---------------------------------
INT 7A - X.PC Packet software interface
	ES:BX -> parameter block
SeeAlso: INT 60/AX=01FFh
--------E-7A---------------------------------
INT 7A - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ2
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0A"IRQ2",INT 79"GO32",INT 7B"GO32"
--------P-7A---------------------------------
INT 7A O - PRINDIR - API (moved to INT 7C, then INT 2F/AX=7F00h)
SeeAlso: INT 7C"PRINDIR",INT 2F/AX=7F00h"PRINDIR"
--------N-7A---------------------------------
INT 7A - Novell NetWare - LOW-LEVEL API - Notes
Note:	this interrupt is used for IPX/SPX access in NetWare versions through
	  2.0a; in later versions, you should use INT 2F/AX=7A00h to get an
	  entry point even though INT 7A still exists.	For both INT 7A and
	  the FAR entry point, BX contains the function number; IPX is
	  sometimes called internally with BX bit 15 set, which causes the
	  handler to bypass some initial checks and an optional call to the
	  IPX Windows support handler set with INT 2F/AX=7AFFh/BX=0000h
	  (see #2573)
SeeAlso: INT 2F/AX=7A00h,INT 64"Novell",INT 7A/BX=0000h
--------N-7A----BX0000-----------------------
INT 7A - Novell NetWare - IPX Driver - OPEN SOCKET
	BX = 0000h
	AL = socket longevity
	    00h open until close or terminate
	    FFh open until close
	DX = socket number (high byte in DL)
	    0000h dynamic allocation
	    else  socket to open (see #3441)
Return: AL = return code
	    00h success
		DX = socket number
	    FEh socket table full
	    FFh socket already open
Notes:	TSRs which need to use sockets should set AL to FFh, non-resident
	  programs should normally use AL=00h
	IPX can be configured to support up to 150 open sockets on a
	  workstation, and defaults to 20
	this function is supported by Advanced NetWare 1.02+
SeeAlso: INT 7A/BX=0001h,INT 7A/BX=0004h,INT 7A/BX=0023h

(Table 3441)
Values for IPX socket number:
 0451h	File Service (NetWare Core Protocol)
 0452h	Service Advertising Protocol (see #3449)
 0453h	Routing Information Packet (see #3452)
 0455h	NetBIOS Packet
 0456h	diagnostics
 0457h	server serial numbers (labeled "Copy Protection" by Lanalyzer)
 2222h	NetWare Core Protocol
 4000h-7FFFh used for dynamic allocation
 4444h	Brightwork Development's SiteLock server
 5555h	Brightwork Development's SiteLock client (workstation)
 8000h-FFFFh assigned by Novell
 869Ch	ID Software's DOOM
Note:	SiteLock is an application metering product using IPX to communicate
	  between the application and the license server
--------N-7A----BX0001-----------------------
INT 7A - Novell NetWare - IPX Driver - CLOSE SOCKET
	BX = 0001h
	DX = socket number (high byte in DL) (see #3441)
Notes:	also cancels events set by any Event Control Blocks for the socket
	the program must close all open sockets before terminating
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0000h
--------N-7A----BX0002-----------------------
INT 7A - Novell NetWare - IPX Driver - GET LOCAL TARGET
	BX = 0002h
	ES:SI -> target internetwork address (see #3456 at INT 7A/BX=000Bh)
	ES:DI -> 6-byte buffer for local target
Return: AL = return code
	    00h success
	       CX = expected one-way transfer time (clock ticks) for a 576-byte
		      packet
	       ES:DI -> local target
	    FAh unsuccessful (no path to destination)
Notes:	the internetwork address consists of a 4-byte network address followed
	  by a 6-byte node address.  The local target is only a 6-byte node
	  address.  If the target is in the same network, the local target is
	  just the node address of target; otherwise, the local target is the
	  node address of the bridge that leads to the target.
	this function may be called from inside IPX and AES Event Service
	  Routines, but not from other interrupt handlers
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0009h
--------N-7A----BX0003-----------------------
INT 7A - Novell NetWare - IPX Driver - SEND PACKET
	BX = 0003h
	ES:SI -> Event Control Block (see #3442,#3443)
Notes:	returns immediately; IPX attempts to send the packet in the background
	this function is supported by Advanced NetWare 1.02+
	this function is nearly identical to BX=000Fh, except that it always
	  copies the source address into the IPX header assumed to be at the
	  beginning of the first fragment
SeeAlso: BX=0004h,BX=000Fh,INT 21/AH=EEh"Novell"

Format of IPX Event Control Block:
Offset	Size	Description	(Table 3442)
 00h	DWORD	Link
 04h	DWORD	-> Event Service Routine (00000000h if none) (see #3446)
 08h	BYTE	in use flag (see #3444)
 09h	BYTE	completion code (see #3445)
 0Ah	WORD	(big-endian) socket number (see #3441)
 0Ch  4 BYTEs	IPX workspace
 10h 12 BYTEs	driver workspace
 1Ch  6 BYTEs	immediate local node address
 22h	WORD	fragment count
 24h	var	fragment descriptors
		Offset	Size	Description
		 00h	DWORD	-> fragment data
		 04h	WORD	size of fragment in bytes.
Notes:	ESR is a far procedure that is called when the ECB has been handled.
	  On call, the in use flag is zero if the ECB has been handled,
	  non-zero otherwise. If the flag is zero, the completion code holds
	  the result of the event.
	the first fragment should start with an IPX header (see #3447)
	all fragments are concatenated and sent in one piece
	node address FFh FFh FFh FFh FFh FFh broadcasts to all nodes
SeeAlso: #3443

Format of AES-ECB:
Offset	Size	Description	(Table 3443)
 00h	DWORD	Link
 04h	DWORD	ESR (Event Service Routine) address (see #3446)
 08h	BYTE	in use flag (see #3444)
 09h  5 BYTEs	AES workspace
SeeAlso: #3442

(Table 3444)
Values for ECB in use flag:
 00h	available
 E0h	AES temporary
 F6h	\ special IPX/SPX processing for v3.02+
 F7h	/
 F8h	IPX in critical section
 F9h	SPX listening
 FAh	processing
 FBh	holding
 FCh	AES waiting
 FDh	AES couting down delay time
 FEh	awaiting packet reception
 FFh	sending packet
SeeAlso: #3442,#3443,#3445

(Table 3445)
Values for ECB completion code:
 00h	success
 ECh	remote terminated connection without acknowledging packet
 EDh	abnormal connection termination
 EEh	invalid connection ID
 EFh	SPX connection table full
 F9h	event should not be cancelled
 FAh	cannot establish connection with specified destination
 FCh	cancelled
 FDh	malformed packet
 FEh	packet undeliverable
 FFh	physical error
SeeAlso: #3442,#3444

(Table 3446)
Values Event Service Routine is called with:
	AL = caller's identity (00h = AES, FFh = IPX)
	ES:SI -> event control block
	interrupts disabled
Return: all registers preserved
SeeAlso: #3442,#3447

Format of IPX header:
Offset	Size	Description	(Table 3447)
 00h	WORD	(big-endian) checksum
 02h	WORD	(big-endian) length in bytes of total packet
 04h	BYTE	transport control
 05h	BYTE	packet type (see #3448)
 06h 10 BYTEs	destination internetwork address
 10h	WORD	(big-endian) destination socket
 12h 10 BYTEs	source internetwork address
 1Ch	WORD	(big-endian) source socket
Notes:	an IPX packet has the identical format as a Xerox Network Standard
	  (XNS) packet
	the application must set packet type, destination address, and
	  destination socket; IPX/SPX set the remaining fields
SeeAlso: #3442,#3458

(Table 3448)
Values for IPX packet type:
 00h	unknown packet type
 01h	routing information packet
 02h	echo packet
 03h	error packet
 04h	packet exchange packet (always use this one for data)
 05h	SPX packet (see #3458)
 11h	NetWare Core Protocol (also used by Service Advertising Protocol)
 14h	Propagated Packet (for NetWare), NetBIOS name packet
 15h-1Eh experimental protocols
Note:	undocumented packet type 14h will cross up to 16 networks deep in
	  all directions; as Aaron Martin of Origin Systems discovered, the
	  first 64 bytes of the IPX data in such packets should be considered
	  reserved, as IPX places the traversed server nodes there.

Format of Service Advertising Protocol Service Query Packet:
Offset	Size	Description	(Table 3449)
 00h 30 BYTEs	IPX header
 1Eh	WORD	(big-endian) query type
		0001h general find service
		0003h find nearest server
 20h	WORD	(big-endian) server type
		(see #1543 at INT 21/AH=E3h"CONNECTION CONTROL")
SeeAlso: #3450

Format of Service Advertising Protocol Server Identification Packet:
Offset	Size	Description	(Table 3450)
 00h 30 BYTEs	IPX header
 1Eh	WORD	(big-endian) response type
		0002h general service
		0004h nearest service
 20h 64N BYTEs	server entries (1-7) (see #3451)
SeeAlso: #3449,#3452

Format of SAP server entry:
Offset	Size	Description	(Table 3451)
 00h	WORD	(big-endian) server type
		(see #1543 at INT 21/AH=E3h"CONNECTION CONTROL")
 02h 48 BYTEs	ASCIZ server name
 32h  2 WORDs	(big-endian) network number
 34h  3 WORDs	(big-endian) node number
 3Ch	WORD	(big-endian) socket number
 3Eh	WORD	(big-endian) number of hops between caller and server
		10h = Server Shutdown Advertising Packet
SeeAlso: #3450

Format of IPX Routing Information packet:
Offset	Size	Description	(Table 3452)
 00h 30 BYTEs	IPX header
 1Eh	WORD	operation (0001h request, 0002h response)
 20h 8N BYTEs	network entries (1-50) (see #3453)
SeeAlso: #3450

Format of RIP network entry:
Offset	Size	Description	(Table 3453)
 00h	DWORD	network number (FFFFFFFFh = general request)
 04h	WORD	(response) number of hops
 06h	WORD	(response) number of clock ticks to reach destination
--------N-7A----BX0004-----------------------
INT 7A - Novell NetWare - IPX Driver - LISTEN FOR PACKET
	BX = 0004h
	ES:SI -> Event Control Block (see BX=0003h)
Return: AL = status
	    00h successful
	    FFh no listening socket for packet
Desc:	this function provides IPX with an ECB for receiving an IPX packet, but
	  does not wait for a packet to arrive
Notes:	the application must open a socket and initialize the ECB's ESR
	  address, socket number, fragment count, and fragment descriptor
	  fields before invoking this function
	there is no limit on the number of ECBs which may simultaneously be
	  listening on a socket
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0000h,BX=0003h
--------N-7A----BX0005-----------------------
INT 7A - Novell NetWare - IPX Driver - SCHEDULE IPX EVENT
	BX = 0005h
	AX = delay time in clock ticks
	ES:SI -> Event Control Block (see BX=0003h)
Note:	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0006h,BX=0007h,BX=0008h
--------N-7A----BX0006-----------------------
INT 7A - Novell NetWare - IPX Driver - CANCEL EVENT
	BX = 0006h
	ES:SI -> Event Control Block (see BX=0003h)
Return: AL = return code (see #3454)
Notes:	cannot cancel packets which the node's driver has already sent
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0005h

(Table 3454)
Values for IPX return code:
 00h	success
 F9h	event in use
 FCh	event cancelled
 FFh	unsuccessful, event not in use, or unrecognized ECB flag
--------N-7A----BX0007-----------------------
INT 7A - Novell NetWare - IPX Driver - SCHEDULE SPECIAL EVENT
	BX = 0007h
	AX = delay time
	ES:SI -> Event Control Block (see BX=0003h)
Note:	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0006h
--------N-7A----BX0008-----------------------
INT 7A - Novell NetWare - IPX Driver - GET INTERVAL MARKER
	BX = 0008h
Return: AX = interval marker in clock ticks (big-endian???)
Notes:	may be used to measure the time elapsed between two events, up to one
	  hour
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0005h
--------N-7A----BX0009-----------------------
INT 7A - Novell NetWare - IPX Driver - GET INTERNETWORK ADDRESS
	BX = 0009h
	ES:SI -> buffer for own internetwork address (see #3455)
Return: ES:SI buffer filled
	SI destroyed
Note:	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0002h,BX=000Bh

Format of IPX internetwork address:
Offset	Size	Description	(Table 3455)
 00h  4 BYTEs	(big-endian) network number
 04h  6 BYTEs	(big-endian) node number within network
--------N-7A----BX000A-----------------------
INT 7A - Novell NetWare - IPX Driver - RELINQUISH CONTROL
	BX = 000Ah
Desc:	this call indicates that the application is idle and permits the IPX
	  driver to do some work
Note:	this function is supported by Advanced NetWare 1.02+
SeeAlso: INT 15/AX=1000h,INT 21/AH=89h,INT 2F/AX=1680h
--------N-7A----BX000B-----------------------
INT 7A - Novell NetWare - IPX Driver - DISCONNECT FROM TARGET
	BX = 000Bh
	ES:SI -> internetwork address (see #3456)
Return: nothing
Notes:	this function permits the network software on the remote machine to
	  remove any virtual connection with the calling machine
	only use in point-to-point networks
	should never be called from within an Event Service Routine
	this function is supported by Advanced NetWare 1.02+
SeeAlso: BX=0002h,BX=0009h

Format of IPX internetwork address:
Offset	Size	Description	(Table 3456)
 00h  4 BYTEs	(big-endian) destination network
 04h  6 BYTEs	(big-endian) destination node
 0Ah  2 BYTEs	(big-endian) destination socket
--------N-7A----BX000C-----------------------
INT 7A U - Novell NetWare - IPX Driver - internal - INITIALIZE NETWORK ADDRESS
	BX = 000Ch
	CX:DX = global network address (see INT 7A/BX=0002h)
	ES:DI -> "OSINCRITICALSECTION" flag
	DS:SI -> current mode for socket
Note:	the address cannot be changed once it has been initialized
SeeAlso: INT 7A/BX=0024h
--------N-7A----BX000D-----------------------
INT 7A U - Novell NetWare - IPX Driver - internal - IPX GET PACKET SIZE
	BX = 000Dh
Return: AX = maximum packet size
	CX = retry count
SeeAlso: BX=001Ah
--------N-7A----BX000E-----------------------
INT 7A U - Novell NetWare - IPX Driver - internal - TERMINATE SOCKETS
	BX = 000Eh
Return: nothing
Notes:	this function terminates all sockets opened with the current mode; this
	  may be intended for future enhancements as the socket mode never
	  changes in v2.15
	called by the NetWare shell if a program terminates
--------N-7A----BX000F-----------------------
INT 7A - Novell NetWare - IPX Driver - INTERNAL - SEND PACKET
	BX = 000Fh
	ES:SI -> Event Control Block (see BX=0003h)
Note:	nearly identical to function 0003h, but does not copy address into
	  the first fragment, and bypasses normal error checking
SeeAlso: BX=0003h
--------N-7A----BX0010-----------------------
INT 7A - Novell NetWare - SPX Driver - INSTALLATION CHECK
	BX = 0010h
	AL = 00h
Return: AL = status
	    00h if SPX not installed
	    F0h if IPX not installed
	    FFh if SPX loaded
		BH = SPX major version
		BL = SPX minor version
		CX = maximum SPX connections
		DX = SPX connections available
Notes:	this function is supported by Advanced NetWare 2.1+
	this interrupt is used for IPX/SPX access in NetWare versions through
	  2.0a; in later versions, you should use INT 2F/AX=7A00h to get an
	  entry point even though INT 7A still exists.	For both INT 7A and
	  the FAR entry point, BX contains the function number
	IPX is sometimes called internally with BX bit 15 set, which causes the
	  entry point handler to bypass some checks and an optional call to
	  the IPX Windows support handler set with INT 2F/AX=7AFFh/BX=0000h
	  (see #2573)
SeeAlso: BX=0015h
--------N-7A----BX0011-----------------------
INT 7A - Novell NetWare - SPX Driver - ESTABLISH SPX CONNECTION
	BX = 0011h
	AL = retry count
	AH = watchdog flag
	ES:SI -> Event Control Block (see #3442 at BX=0003h)
Return: AL = status (00h,EFh,FDh,FFh) (see #3457)
	DX = assigned connection ID number
Desc:	attempt to establish a connection with a listening socket
Notes:	there should always be at least two SPX ECB's listening to a socket, so
	  that NetWare can perform its internal packet exchanges
	the first fragment should start with a SPX header (see #3458).	Fill
	  in all destination addresses.
	this function is supported by Advanced NetWare 2.1+
SeeAlso: BX=0000h,BX=0012h,BX=0013h,BX=0014h,BX=0015h

(Table 3457)
Values for SPX function status:
 00h	attempting to contact destination socket
 EEh	no such connection
 EFh	local connection table full
 FDh	buffer size not 42 or fragment count not 1
 FFh	sending socket not open

Format of SPX header:
Offset	Size	Description	(Table 3458)
 00h	WORD	(big-endian) checksum
 02h	WORD	(big-endian) length in bytes of total packet
 04h	BYTE	transport control
 05h	BYTE	packet type (see #3448 at INT 7A/BX=0003h)
 06h 10 BYTEs	destination internet address
 10h	WORD	(big-endian) destination socket
 12h 10 BYTEs	source internet address
 1Ch	WORD	(big-endian) source socket
 1Eh	BYTE	connection control (see #3459)
 1Fh	BYTE	datastream type
		FEh terminate connection request packet
		FFh terminate connection acknowledgement packet
		other user-defined, ignored by SPX
 20h	WORD	(big-endian) source connection ID
 22h	WORD	(big-endian) destination connection ID
 24h	WORD	(big-endian) sequence number
 26h	WORD	(big-endian) acknowledge number
 28h	WORD	(big-endian) allocation number
SeeAlso: #3447

Bitfields for SPX connection control:
Bit(s)	Description	(Table 3459)
 3-0	unused???
 4	end of message
 5	reserved
 6	acknowledgement required
 7	system packet
--------N-7A----BX0012-----------------------
INT 7A - Novell NetWare - SPX Driver - LISTEN FOR SPX CONNECTION
	BX = 0012h
	AH = watchdog flag (00h disabled, 01h enabled)
	AL = retry count (00h = default)
	ES:SI -> Event Control Block (see #3442 at BX=0003h)
Return: nothing
Notes:	there should always be at least two SPX ECB's listening to a socket, so
	  that NetWare can perform its internal packet exchanges
	this function is supported by Advanced NetWare 2.1+
SeeAlso: BX=0011h,BX=0013h,BX=0014h
--------N-7A----BX0013-----------------------
INT 7A - Novell NetWare - SPX Driver - TERMINATE SPX CONNECTION
	BX = 0013h
	DX = connection ID to terminate
	ES:SI -> Event Control Block (see #3442 at BX=0003h)
Note:	this function is supported by Advanced NetWare 2.1+
SeeAlso: BX=0011h,BX=0012h,BX=0014h
--------N-7A----BX0014-----------------------
INT 7A - Novell NetWare - SPX Driver - ABORT SPX CONNECTION
	BX = 0014h
	DX = connection ID to terminate
Return: nothing
Notes:	this function is supported by Advanced NetWare 2.1+
	this function does not tell the other side that the connection has been
	  terminated
	also aborts any outstanding Establish Connection, Terminate Connection,
	  and Send Sequenced Packet commands
SeeAlso: BX=0011h,BX=0013h
--------N-7A----BX0015-----------------------
INT 7A - Novell NetWare - SPX Driver - GET SPX CONNECTION STATUS
	BX = 0015h
	DX = connection ID
	ES:SI -> status buffer (see #3460)
Return: AL = return code (00h,EEh) (see also #3457)
	    00h connection still valid
		ES:SI -> status buffer filled
Note:	this function is supported by Advanced NetWare 2.1+
SeeAlso: BX=0010h,BX=0011h

Format of SPX status buffer:
Offset	Size	Description	(Table 3460)
 00h	BYTE	connection state
		01h waiting to establish connection
		02h starting (attempting to create connection)
		03h connection established
		04h terminating
 01h	BYTE	watchdog flag
		bit 0: used internally by SPX
		bit 1: SPX watchdog is monitoring connection
		bits 2-7 used internally by SPX
 02h	WORD	(big-endian) source connection ID
 04h	WORD	(big-endian) destination connection ID
 06h	WORD	(big-endian) sequence number of next packet sent
 08h	WORD	(big-endian) acknowledge number, expected sequence number of
		  next received packet
 0Ah	WORD	(big-endian) maximum sequence number remote SPX may send
		  without ACK from local SPX
 0Ch	WORD	(big-endian) remote acknowledge number, next sequence number
		  remote SPX expects to receive
 0Eh	WORD	(big-endian) remote allocation number, maximum sequence number
		  local SPX may send
 10h	WORD	(big-endian) connection socket
 12h  6 BYTEs	immediate node address--bridge on local network to destination
 18h 10 BYTEs	destination internetwork address (see #3456 at INT 7A/BX=000Bh)
 22h	WORD	(big-endian) retransmit count
 24h	WORD	(big-endian) estimated roundtrip delay
 26h	WORD	(big-endian) retransmitted packets
 28h	WORD	(big-endian) suppressed packets
 2Ah 12 BYTEs	??? (v2.15)
--------N-7A----BX0016-----------------------
INT 7A - Novell NetWare - SPX Driver - SEND SPX PACKET
	BX = 0016h
	DX = connection ID
	ES:SI -> Event Control Block (see BX=0003h)
Notes:	this function is supported by Advanced NetWare 2.1+
	CX may need to be 0001h ???
SeeAlso: BX=0011h,BX=0017h
--------N-7A----BX0017-----------------------
INT 7A - Novell NetWare - SPX Driver - LISTEN FOR SPX PACKET
	BX = 0017h
	DX = connection ID (unused in v2.15)
	ES:SI -> Event Control Block (see BX=0003h)
Notes:	this function is supported by Advanced NetWare 2.1+
	CX may need to be 0001h ???
SeeAlso: BX=0011h,BX=0016h
--------N-7A----BX0018-----------------------
INT 7A U - Novell NetWare - IPX Driver - internal - ADD DIAGNOSTIC ELEMENT
	BX = 0018h
	ES:SI -> diagnostic element (see #3461) to be added to Diagnostic Queue
Note:	this function is supported on file servers only under v2.15; v3.02 also
	  supports it on workstations
SeeAlso: BX=0019h

Format of IPX diagnostic element:
Offset	Size	Description	(Table 3461)
 00h	DWORD	pointer to next diagnostic element
 04h	DWORD	pointer to function for ???
 08h	DWORD	pointer to function for ???
--------N-7A----BX0019-----------------------
INT 7A U - Novell NetWare - IPX Driver - internal - CANCEL DIAGNOSTIC ELEMENT
	BX = 0019h
	ES:SI -> diagnostic element (see BX=0018h) to be removed
Note:	this function is supported on file servers only under v2.15; v3.02 also
	  supports it on workstations
SeeAlso: BX=0018h
--------N-7A----BX001A-----------------------
INT 7A - Novell NetWare - IPX Driver - GET DRIVER MAXIMUM PACKET SIZE
	BX = 001Ah
Return: AX = maximum packet size with preamble (at least 576 bytes)
	CX = IPX retry count
	DS,FLAGS preserved
SeeAlso: BX=000Dh
--------N-7A----BX001B-----------------------
INT 7A U - Novell NetWare - IPX Driver - INTERNAL
	BX = 001Bh
	???
Return: ???
Notes:	this function is supported on file servers only under v2.15; v3.02 also
	  supports it on workstations
	used by NetWare Access Server, which may call INT 15/AX=1117h with
	  BX=0000h in some cases (it uses a modified DESQview)
--------N-7A----BX001C-----------------------
INT 7A U - Novell NetWare - NetWare Access Server - GET ???
	BX = 001Ch
Return: AX = length of ???
	ES:BX -> ???
Notes:	these functions are NOPs for standard IPX drivers such as IPXODI v2.12
SeeAlso: INT 2F/AX=7AF1h,INT 7A/BX=001Dh,INT 7A/BX=001Eh
--------N-7A----BX001D-----------------------
INT 7A U - Novell NetWare - NetWare Access Server - GET ??? ECB AND SOCKET
	BX = 001Dh
Return: DX = socket number chosen by IPX
	ES:SI -> ECB in IPX's code segment (will be listening)
	BX corrupted
Notes:	these functions are NOPs for standard IPX drivers such as IPXODI v2.12
SeeAlso: INT 2F/AX=7AF1h,INT 7A/BX=001Ch,INT 7A/BX=001Eh
--------N-7A----BX001E-----------------------
INT 7A U - Novell NetWare - NetWare Access Server - GET ??? ECB
	BX = 001Eh
Return: ES:SI -> ECB
	BX corrupted
Notes:	these functions are NOPs for standard IPX drivers such as IPXODI v2.12
SeeAlso: INT 2F/AX=7AF1h,INT 7A/BX=001Ch,INT 7A/BX=001Dh
--------N-7A----BX001F-----------------------
INT 7A - Novell NetWare - IPXODI v2.12+ - GET IPX INFORMATION
	BX = 001Fh
	DX = 0000h
Return: AX = ???
	BX:CX -> ??? entry point (see #3462) (undocumented)
	DX = feature flags
	    bit 0: IPXODI rather than dedicated IPX
	    bit 1: checksumming functions 0020h-0022h supported
	ES:SI -> array of words containing used socket number (undocumented);
		0000h ends array
	all other registers except DS and FLAGS may be destroyed
Note:	IPXODI v2.12 is distributed as part of the Personal NetWare system
	  bundled with Novell DOS 7
SeeAlso: BX=0020h,INT 2F/AX=7A2Fh

(Table 3462)
Call IPXODI entry point with:
	ES:SI -> ECB??? (offset 24h is far pointer to ??? data)
--------N-7A----BX0020-----------------------
INT 7A - Novell NetWare - IPXODI v2.12+ - SEND WITH CHECKSUM
	BX = 0020h
	ES:SI -> ECB (see #3442 at INT 7A/BX=0003h)
Return: DS,FLAGS preserved
	BX,BP corrupted (documented as potentially destroying all other regs)
Desc:	generate a checksum for the packet data and store it in the IPX
	  checksum field before transmitting the packet
SeeAlso: BX=001Fh,BX=0021h,BX=0022h,INT 2F/AX=7A2Fh
--------N-7A----BX0021-----------------------
INT 7A - Novell NetWare - IPXODI v2.12+ - IPX GENERATE CHECKSUM
	BX = 0021h
	ES:SI -> ECB data (see #3442 at INT 7A/BX=0003h)
Return: ES,DS,SI preserved
	BX,BP corrupted, all other registers potentially destroyed
Notes:	the checksum and TransportControl fields of the IPX packet are updated
	this function enables interrupts and is fully reentrant
SeeAlso: BX=001Fh,BX=0020h,BX=0022h,INT 2F/AX=7A2Fh
--------N-7A----BX0022-----------------------
INT 7A - Novell NetWare - IPXODI v2.12+ - IPX VERIFY CHECKSUM
	BX = 0022h
	ES:SI -> ECB data (see #3442 at INT 7A/BX=0003h)
Return: AX = status (0000h checksum matches)
	DS,ES,SI preserved
	BX,BP corrupted, all other registers potentially destroyed
Note:	this function enables interrupts and is fully reentrant
SeeAlso: BX=001Fh,BX=0020h,BX=0021h,INT 2F/AX=7A2Fh
--------N-7A----BX0023-----------------------
INT 7A - Novell NetWare - IPXODI v2.12+ - OPEN LOOK-AHEAD SOCKET
	BX = 0023h
	DX = socket number (0000h for dynamic allocation)
	ES:SI -> Look Ahead handler (see #3463)
	BP = desired lookahead size (0000h-0080h)
Return: AL = status
	    00h successful
		DX = assigned socket number (big-endian)
	    FEh maximum number of sockets already open
	    FFh specific socket already opened by another application
	DS,FLAGS preserved
	all other registers may be destroyed
Notes:	the socket will always be long-lived, and must thus be explicitly
	  closed with INT 7A/BX=0001h before the Look Ahead handler code is
	  removed from memory (i.e. the program terminates)
	this function is only supported if INT 2F/AX=7A00h returns ES:BX
	  pointing at an IPX version greater than 3.30
	the desired lookahead size is the smallest-size packet (including IPX
	  header) that should be passed to the lookahead handler when it
	  arrives
SeeAlso: INT 7A/BX=0000h,INT 7A/BX=0001h

(Table 3463)
Call IPX Look-Ahead handler with:
	AX = packet's destination socket
	DS:SI -> look-ahead structure (see #2655 at INT 2F/AX=C000h"LSL")
	DF clear
	interrupt disabled (must remain disabled)
Return: AX = packet use
	    0000h application want packet
		ES:SI -> ODI ECB (see #2656 at INT 2F/AX=C000h"LSL")
	    8001h application does not want packet
	ZF set if AX=0000h
	DS,DI,BP,SS,SP preserved
	interrupts disabled
--------N-7A----BX0024-----------------------
INT 7A U - Novell NetWare - IPXODI v2.20+ - SET INTERNETWORK ADDRESS
	BX = 0024h
	ES:SI -> buffer containing internetwork address (see #3456)
Return: BX,CX,SI,DI,ES destroyed
Note:	this function differs from INT 7A/BX=000Ch in that it unconditionally
	  sets the address
SeeAlso: INT 7A/BX=000Ch
--------A-7A0001-----------------------------
INT 7A R - AutoCAD Device Interface - DISPLAY - INITIALIZE (INIT1)
	AX = 0001h
	BX = configuration
	CX = interface level (0001h)
Return: AX = status
	    0000h initialization failed
	    0001h pre-v4.0 driver initialized successfully
	    0003h post-v3.1 driver initialized successfully (driver truncates
		  excessivly long packets)
	BX = width of graphics area in pixels, or 0000h if using packet
		  communication
	DX:CX -> packet-mode entry point (see #3464)
SeeAlso: AX=0001h,AX=0200h,AX=07D0h,INT 61/AX=0007h"OPTIMA",INT 78"AutoCAD"
SeeAlso: INT 79/AX=0001h,INT 7B/AX=8001h"AutoCAD",INT 7C"AutoShade"

(Table 3464)
Call packet-mode entry point with:
STACK:	DWORD	pointer to request packet (see #3465)
	WORD	length of packet

Format of request packet:
Offset	Size	Description	(Table 3465)
 00h	WORD	function number (00h-45h for Compaq VGADI41.EXE)
--------A-7A0200BX0000-----------------------
INT 7A R - AutoCAD Device Interface - RENDERING DEVICE - INITIALIZE (RDLINKUP)
	AX = 0200h
	BX = 0000h
	CX = interface level (0001h)
Return: BX = 0000h (driver uses packet communication)
	DX:CX -> packet-mode entry point (see #3464)
SeeAlso: AX=0001h"AutoCAD",INT 79/AX=0001h,INT 7B/AX=8001h"AutoCAD"
--------I-7A04-------------------------------
INT 7A - IBM 3270 Workstation Program API - CREATE A QUEUE
	AH = 04h
	???
Return: ???
SeeAlso: AH=06h
--------I-7A06-------------------------------
INT 7A - IBM 3270 Workstation Program API - DELETE A QUEUE
	AH = 06h
	???
Return: ???
SeeAlso: AH=04h
----------7A07D0-----------------------------
INT 7A R - AutoCAD Device Interface - Compaq VGADI41.EXE - GET ENTRY POINT
	AX = 07D0h
Return: AX = ??? (0003h)
	BX = 0000h
	DX:CX -> ADI entry point (see AX=0001h)
SeeAlso: AX=0001h
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - SESSION SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 0000h
	DX = ID of session manager (SESSMGR)
	AL = service (see #3466)
	ES:DI -> control block
Return: ???

(Table 3466)
Values for service:
 01h	get session ID
 02h	get session info
 04h	dettach from session
 05h	attach to session
 06h	get list of windows available
 07h	get environment of window
 08h	get 'PIF' (program information file) info
 0Ah	get base window ID
 0Bh	get cursor info
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - KEYBOARD SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 0000h
	DX = ID of keyboard manager
	AL = service number (see #3467)
	ES:DI -> control block
Return: ???

(Table 3467)
Values for 3270 Workstation Program keyboard service:
 01h	connect to keyboard
 02h	disconnect from keyboard
 03h	read from keyboard
 04h	send keystroke to session
 05h	disable input
 06h	enable input
 07h	update status code
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - WINDOW SERVICES
	AH = 09h
	BX = 8020h (synchronous request)
	CX = 00FFh
	DX = ID of window service controller (WSCTRL)
	AL = service number (see #3468)
	ES:DI -> control block
Return: ???

(Table 3468)
Values for 3270 Workstation Program window service:
 01h	connect to WS control
 02h	disconnect from WS control
 03h	add a window
 04h	change window's position on screen
 05h	change window's size
 06h	change window's color
 07h	change window's position in the presentation space
 08h	hide/unhide toggle
 09h	enlarge/reduce toggle
 0Ah	change screen background color
 0Bh	get window's position on screen
 0Ch	get window's size
 0Dh	get window's color
 0Eh	get window's position in the presentation space
 0Fh	determine whether hidden
 10h	determine whether enlarged
 11h	get background color
 12h	get window names
 13h	delete all windows from profile
 14h	pick active window
 15h	redraw screen
 16h	redraw window
 17h	delete a window from profile
 18h	get active window
 19h	get active screen
 1Ah	get window data
 1Bh	change window data
 1Ch	select active screen
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - PRESENTATION SPACE SERVICES
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of PCPSM
	AL = service
	    01h define presentation space
	    02h delete presentation space
	    03h display presentation space
	    04h position cursor in presentation space
	    05h change default presentation space
	ES:DI -> control block
Return: ???
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - 3270 EMULATION
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of 3270EML
	AL = service
	    01h connect
	    02h disconnect
	ES:DI -> control block
Return: ???
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - OPERATOR INFORMATION AREA
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of OIAM
	AL = service
	    01h read Operator Information Area
	    02h read OIA subset
	ES:DI -> control block
Return: ???
Note: the OIA is the 25th line on the Host session
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - TRANSLATE DATA
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of XLATE
	AL = service
	    01h translate from host characters to ASCII and vice versa
		(determined by control block byte 11)
	ES:DI -> control block
Return: ???
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - COPY SERVICE
	AH = 09h
	BX = 8020h
	CX = 00FFh
	DX = ID of copy service
	AL = service
	    01h copy string from one presentation space to another
	    02h copy block from one presentation space to another
	    03h connect to PC session for copy
	    04h disconnect PC session from copy
	ES:DI -> control block
Return: ???
--------I-7A09--BX8020-----------------------
INT 7A - IBM 3270 Workstation Program API - Multi-DOS
	AH = 09h
	BX = 8020h
	CX = 00FFh
	ES:DI -> control block
	DX = ID of INDJQRY
		get environment size
	   = ID of INDJASY
		request DOS functions from workstation
	   = ID of MEMORY
		AL = function
		    01h allocate memory
		    02h deallocate memory
		    03h modify allocated size
Return: ???
--------I-7A09-------------------------------
INT 7A - IBM 3270 Workstation Program API - HOST SERVICES
	AH = 09h
	BX = request type (4000h async, 8028h synchronous)
	CX = 0000h
	DX = ID of MFIC
	AL = service (see #3469)
	ES:DI -> control block

(Table 3469)
Values for 3270 Workstation Program host service:
 01h	connect to host
 02h	disconnect from host
 03h	read DFT structured data from host
 04h	write DFT structured data to host
 05h	create a host buffer
--------I-7A13-------------------------------
INT 7A - IBM 3270 Workstation Program API - GET DATA FROM A QUEUE
	AH = 13h
	???
Return: ???
----------7A7A-------------------------------
INT 7A - Canon IX-30F Image Scanner SI3.SYS - INTERFACE
	AH = 7Ah
	???
Return: AX = status
	    0000h success
	    000Eh undefined function code
Range:	unknown, selected by device driver commandline arguments
--------I-7A81-------------------------------
INT 7A - IBM 3270 Workstation Program API - RESOLVE A GATE NAME
	AH = 81h
	ES:DI -> 8-char blank-padded gate name (see #3470)
Return: DX = gate ID

(Table 3470)
Values for 3270 Workstation Program gate name:
 "SESSMGR "
 "KEYBOARD"
 "WSCTRL  "
 "MFIC	  "
 "PCPSM	  "
 "3270EML "
 "COPY	  "
 "XLATE	  "
 "OIAM	  "
 "MEMORY  "
 "INDJQRY "
 "INDJASY "
--------I-7A83-------------------------------
INT 7A - IBM 3270 Workstation Program API - GET COMPLETION RESULTS
	AH = 83h
	???
Return: ???
--------I-7AFDCB-----------------------------
INT 7A - IBM Personal Communications/3270 - INSTALLATION CHECK
	AX = FDCBh
Return: DX:AX -> PCS/3270 signature block if loaded (see #3471)

Format of Personal Communications/3270 signature block:
Offset	Size	Description	(Table 3471)
 04h	WORD	PCS/3270 signature (5741h)
 06h	WORD	version (0501h = PCS/3270 v1.0)
--------I-7AFE01-----------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL SEND/RECEIVE FUNCTION
	AX = FE01h
	???
Return: ???
SeeAlso: AX=FE02h
--------I-7AFE02-----------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL SEND/RECEIVE FUNCTION
	AX = FE02h
	???
Return: ???
SeeAlso: AX=FE01h
--------I-7AFF01-----------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API INITIALIZATION
	AX = FF01h
	ES:DI -> API function handler routine
Return: CX = 1200h
SeeAlso: AX=FF02h,AX=FF03h
--------I-7AFF02-----------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API TERMINATION
	AX = FF02h
Return: CX = 1200h
SeeAlso: AX=FF01h
--------I-7AFF03-----------------------------
INT 7A - IBM PC3270 EMUL PROG v3 - INTERNAL API INITIALIZATION
	AX = FF03h
	ES:DI -> send/receive function handler routine
Return: CX = 1200h
SeeAlso: AX=FF01h
--------I-7AFF04-----------------------------
INT 7A U - IBM PC3270 EMUL PROG v3 - INTERNAL ???
	AX = FF04h
	ES:DI -> ???
Return: CX = 1200h
--------f-7B---------------------------------
INT 7B - Btrieve API (single user)
	DS:DX -> 38-byte parameter record (see #3472)
Return: return code field set
Note:	Btrieve sets low byte of vector to 33h; this serves as the installation
	  check
SeeAlso: INT 2F/AX=AB01h,INT 7F/AX=0200h

Format of Btrieve parameter record:
Offset	Size	Description	(Table 3472)
 00h	DWORD	pointer to data buffer
 04h	WORD	data buffer length
 06h	DWORD	pointer to 90-byte record containing positioning info
		(should be same for all calls for same file)
 0Ah	DWORD	pointer to 38-byte FCB info buffer
		(should be same for all calls for same file)
 0Eh	WORD	function code (see #3473)
 10h	DWORD	pointer to file name/key buffer
 14h	BYTE	key length
 15h	BYTE	key number
 16h	DWORD	pointer to status code (see #3474)
 1Ah	WORD	interface code (version specific)
		6176h version 5.10

(Table 3473)
Values for function code:
 00h	open
 01h	close
 02h	insert
 03h	update
 04h	delete
 05h	get_equal
 06h	get_next
 07h	get_prev
 08h	get_greater
 09h	get_gr_eql
 0Ah	get_less
 0Bh	get_less_eq
 0Ch	get_first
 0Dh	get_last
 0Eh	create
 0Fh	stat
 10h	extend
 11h	set_dir: set directory information
 12h	get_dir: get directory information
 13h	begin_trans
 14h	end_trans
 15h	abort_trans
 16h	get_pos: get record position number
 17h	get_direct: get data by sending record position
 18h	step_next
 19h	stop
 1Ah	version
 1Bh	unlock
 1Ch	reset
 1Dh	set owner
 1Eh	clear owner
 1Fh	create supplemental index
 20h	drop supplemental index
 21h	step first
 22h	step last
 23h	step previous
 24h	get next extended: get multiple records using a filter
 25h	get previous extended: get multiple records using a filter
 26h	step next extended: get multiple records using a filter
 27h	step previous extended: get multiple records using a filter
 28h	insert extended: insert one or more records
 31h	???
Notes:	add 50 (32h) to any "get" operation to just return the key data
	add 100 (64h) for a single-record wait lock (automatically released
	  on next get)
	add 200 (C8h) for a single-record nowait lock (nowait lock returns
	  error 54h or 55h if record already locked)
	add 300 (12Ch) for a multiple-record wait lock (not released until
	  unlock called)
	add 400 (190h) for a multiple-record nowait lock (nowait lock returns
	  error 54h or 55h if record already locked)

(Table 3474)
Values for Btrieve status code:
 00h	successful
 01h	invalid operation
 02h	I/O error
 03h	file not open
 04h	key value not found
 05h	duplicate key value
 06h	invalid key number
 07h	different key number
 08h	invalid positioning
 09h	end of file
 0Ah	modifiable key value error
 0Bh	invalid file name
 0Ch	file not found
 0Dh	extended file error
 0Eh	pre-image open error
 0Fh	pre-image I/O error
 10h	expansion error
 11h	close error
 12h	disk full
 13h	unrecoverable error
 14h	record manager inactive
 15h	key buffer too short
 16h	data buffer length overrun
 17h	position block length
 18h	page size error
 19h	create I/O error
 1Ah	number of keys
 1Bh	invalid key position
 1Ch	invalid record length
 1Dh	invalid key length
 1Eh	not a Btrieve file
 1Fh	file already extended
 20h	extended I/O error
 22h	invalid extension name
 23h	directory error
 24h	transaction error
 25h	transaction is active
 26h	transaction control file I/O error
 27h	end/abort transaction error
 28h	transaction max files
 29h	operation not allowed
 2Ah	incomplete accelerated access
 2Bh	invalid record address
 2Ch	null key path
 2Dh	inconsistent key flags
 2Eh	access to file denied
 2Fh	maximum open files
 30h	invalid alternate sequence definition
 31h	key type error
 32h	owner already set
 33h	invalid owner
 34h	error writing cache
 35h	invalid interface
 36h	variable page error
 37h	autoincrement error
 38h	incomplete index
 39h	expanded memory error
 3Ah	compression buffer too short
 3Bh	file already exists
 3Ch	reject count reached
 3Dh	work space too small
 3Eh	incorrect descriptor
 3Fh	invalid extended insert
 40h	filter limit reached
 41h	incorrect field offset
 4Ah	automatic transaction abort
 4Dh	Btrieve engine busy or resource locked by another user
 4Eh	deadlock detected
 50h	conflict
 51h	lock error
 52h	lost position
 53h	read outside transaction
 54h	record in use
 55h	file in use
 56h	file table full
 57h	handle table full
 58h	incompatible open mode
 5Ah	redirected device table full
 5Bh	server error
 5Ch	transaction table full
 5Dh	incompatible lock type
 5Eh	permission error
 5Fh	session no longer valid
 60h	communications environment error
 61h	data message too small
 62h	internal transaction error
--------I-7B---------------------------------
INT 7B - Eicon Access API (3270/5250 gateways)
SeeAlso: INT 5C"NetBIOS"
--------E-7B---------------------------------
INT 7B - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ3
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0B,INT 10/AH=FFh"GO32",INT 7A"GO32",INT 7C"GO32"
--------A-7B---------------------------------
INT 7B CR - AutoCAD Device Interface - PRINTER/PLOTTER - SEND PLOTTING DATA
	AX = data length (0000h-7FFFh)
	CX:BX -> data to be plotted
	DX = vertical position of line on page
Return: nothing
Notes:	This interrupt is called by AutoCAD to perform its output
	A data length of 0000h indicates that a blank line is to be output
SeeAlso: AX=8001h,AX=8002h,INT 78"AutoCAD",INT 7A/AX=0001h"AutoCAD"
--------e-7B---------------------------------
INT 7B U - MCI Express v2.11+ - DRIVER.EXE - ???
Program: MCI Express is a front end to MCI Mail; DRIVER.EXE is its
	  communication driver
----------7B---------------------------------
INT 7B - Novell XQL - XQL PRIMITIVES MANAGER API
	DS:DX -> parameter block (see #3476)
Return: parameter block updated

(Table 3475)
Values for Novell XQL function number:
 00h	log in
 01h	log out
 02h	"tNewFcn"
 03h	"tFreeFcn"
 04h	"tMoveFldFcn"
 05h	"tFieldFcn"
 06h	"tDescribeFcn"
 07h	"tFetchFcn"
 08h	"tComputeFcn"
 09h	"tOrderFcn"
 0Ah	"tRestrictFcn"
 0Bh	"tJoinFcn"
 0Ch	"tInsertFcn"
 0Dh	"tUpdateFcn"
 0Eh	"tUpdallFcn"
 0Fh	"tRemoveFcn"
 10h	"tRemallFcn"
 11h	"tResetFcn"
 12h	"tTransFcn"
 13h	"tStatFcn"
 14h	"tDDCreFcn"
 15h	"tStoreFcn"
 16h	"tRecallFcn"
 17h	"tStopFcn"
 18h	"tDDFileFcn"
 19h	"tDDFieldFcn"
 1Ah	"tDDIndexFcn"
 1Bh	"tDDModFcn"
 1Ch	"tDDViewFcn"
 1Dh	"tDDDrpFcn"
 1Eh	"tDDPathFcn"
 1Fh	"tDDAttrFcn"
 20h	"tDDFcn"
 21h	"tSecurFcn"
 22h	"tUserFcn"
 23h	"tAccessFcn"
 24h	"tPswdFcn"
 25h	"tCharFcn"
 26h	"tVersionFcn"
 27h	"tCnvFcn"
 28h	"tValFcn"
 29h	"tMaskFcn"
SeeAlso: #3476

Format of XQL parameter block:
Offset	Size	Description	(Table 3476)
 00h  4 BYTEs	signature "XQLP"
 04h	WORD	function number (see #3475)
 06h	WORD	handle
 08h	WORD	status
 0Ah	WORD	session ID
 0Ch	var	data record (varies by function)
---function 00h---
 0Ch	DWORD	-> user name
 10h	DWORD	-> password
 14h	DWORD	-> dictionary
 18h	DWORD	-> filepath
 1Ch	DWORD	-> machine name
 20h	WORD	process ID
---function 01h---
 no additional fields???
---function 02h---
 0Ch	DWORD	-> filename
 10h	DWORD	-> owner name
 14h	WORD	open mode
---function 03h---
 no additional fields???
---function 04h---
 0Ch	WORD	"frompos"
 0Eh	WORD	"topos"
---function 05h---
 0Ch	WORD	subfunction
 0Eh	WORD	position
 10h	WORD	count
 12h	DWORD	-> field list
---function 06h---
 0Ch	WORD	subfunction
 0Eh	WORD	length of description
 10h	WORD	position
 12h	WORD	count
 14h	DWORD	pointer to description list
---function 07h---
 0Ch	WORD	data length
 0Eh	WORD	"op"
 10h	DWORD	"select"
 14h	DWORD	"reject"
 18h	DWORD	pointer to data buffer
---function 08h---
 0Ch	DWORD	-> field name
 10h	WORD	field type
 12h	WORD	field size
 14h	WORD	"flddec"
 16h	WORD	"explen"
 18h	DWORD	pointer to "expbuf"
---function 09h---
 0Ch	WORD	count
 0Eh	DWORD	-> field list
---function 0Ah---
 0Ch	WORD	"newexp"
 0Eh	WORD	"explen"
 10h	DWORD	-> "expbuf"
---function 0Bh---
 0Ch	DWORD	-> filename
 10h	DWORD	-> owner name
 14h	WORD	type of join
 16h	WORD	"pCount"
 18h	DWORD	-> "pNames"
 1Ch	WORD	"sCount"
 1Eh	DWORD	-> "sNames"
---functions 0Ch, 0Dh, 0Fh---
 0Ch	WORD	file count
 0Eh	DWORD	-> file list
 12h	DWORD	count
 16h	DWORD	-> buffer
---function 0Eh---
 0Ch	WORD	file count
 0Eh	DWORD	-> file list
 12h	WORD	"op"
 14h	DWORD	"select"
 18h	DWORD	"reject"
 1Ch	WORD	count
 1Eh	DWORD	-> "res"
 22h	DWORD	-> "comp"
---function 10h---
 0Ch	WORD	file count
 0Eh	DWORD	-> file list
 12h	WORD	"op"
 14h	DWORD	"select"
 18h	DWORD	"reject"
---function 11h---
 0Ch	DWORD	machine name
---function 12h---
 0Ch	WORD	option
---function 13h---
 0Ch	WORD	subfunction
 0Eh	WORD	length of buffer
 10h	DWORD	-> buffer
---function 14h---
 0Ch	WORD	subfunction
 0Eh	DWORD	-> filename
 12h	WORD	"create"
 14h	DWORD	-> pathname
 18h	DWORD	-> owner name
 1Ch	WORD	owner access restrictions
 1Eh	WORD	number of fields
 20h	DWORD	-> field list
 24h	WORD	number of keys
 28h	DWORD	-> key list
 2Ch	WORD	"buflen"
 2Eh	DWORD	-> create parameters
---function 15h---
 0Ch	DWORD	-> "StoreName"
 10h	WORD	length of buffer
 12h	DWORD	-> buffer
---function 16h---
 0Ch	DWORD	-> "RecallName"
 10h	WORD	owner number
 12h	DWORD	-> owner list
 16h	WORD	open mode
 18h	WORD	length of buffer
 1Ah	DWORD	-> buffer
---function 17h---
 no additional fields???
---function 18h---
 0Ch	WORD	"rtype"
 0Eh	WORD	count
 10h	DWORD	-> "filebuf"
 14h	WORD	length of following buffer
 16h	DWORD	-> output buffer
---functions 19h, 1Ah---
 0Ch	WORD	"rtype"
 0Eh	WORD	count
 10h	DWORD	-> field buffer
 14h	WORD	length of following buffer
 16h	DWORD	-> output buffer
---function 1Bh---
 0Ch	WORD	subfunction
 0Eh	DWORD	-> filename
 12h	WORD	"create"
 14h	DWORD	-> pathname
 18h	DWORD	-> owner name
 1Ch	WORD	owner access restrictions
 1Eh	WORD	field count
 20h	DWORD	-> field list
 24h	WORD	number of keys
 26h	DWORD	-> list of keys
---function 1Ch---
 0Ch	WORD	count
 0Eh	DWORD	-> view name
 12h	WORD	length of following buffer
 14h	DWORD	-> output buffer
---function 1Dh---
 0Ch	DWORD	-> filename
 10h	WORD	file type
 12h	WORD	"deletepath"
---function 1Eh---
 0Ch	WORD	"dirtype"
 0Eh	DWORD	-> pathname
---function 1Fh---
 0Ch	WORD	function
 0Eh	DWORD	-> field name
 12h	WORD	attribute
 14h	WORD	size of buffer
 16h	DWORD	-> buffer for attributes
---function 20h---
 0Ch	DWORD	-> directory path
 10h	WORD	function
---function 21h---
 0Ch	DWORD	-> master password
 10h	WORD	"securityflag"
---function 22h---
 0Ch	DWORD	-> master password
 10h	WORD	function (add/modify/remove)
 12h	DWORD	-> user name
 16h	DWORD	-> password
 1Ah	WORD	global rights
 1Ch	WORD	count
 1Eh	WORD	length of following buffer
 20h	DWORD	-> "userbuf"
---function 23h---
 0Ch	DWORD	-> master password
 10h	DWORD	-> user name
 14h	WORD	function (allow/deny/getrights)
 16h	WORD	rights
 18h	DWORD	-> filename
 1Ch	WORD	number of field names in following buffer
 1Eh	DWORD	-> field names
 22h	WORD	maximum buffer length
 24h	DWORD	-> output buffer
---function 24h---
 0Ch	DWORD	-> user name
 10h	DWORD	-> password
---function 25h---
 0Ch	WORD	"charFcn"
 0Eh	WORD	"charType"
 10h	WORD	"charValue"
---function 26h---
 0Ch	DWORD	-> buffer
---function 27h---
 0Ch	WORD	option
 0Eh	WORD	type
 10h	WORD	size
 12h	WORD	"dec"
 14h	WORD	"dsize"
 16h	DWORD	-> value
 1Ah	DWORD	-> "retval"
 1Eh	DWORD	-> mask
 22h	WORD	"justify"
---function 28h---
 0Ch	DWORD	-> field name
 10h	WORD	length of buffer
 12h	DWORD	-> buffer for data
---function 29h---
 0Ch	WORD	option
 0Eh	WORD	type
 10h	WORD	size
 12h	WORD	"dec"
 14h	WORD	length of mask
 16h	DWORD	-> mask
--------A-7B8001-----------------------------
INT 7B R - AutoCAD Device Interface - PRINTER/PLOTTER - BEGIN PLOT
	AX = 8001h
	BX = file level
	    0000h binary file
	    0001h CAD/camera image file
	    0002h installed ADI driver
	CX = horizontal size in pixels
	DX = vertical size in pixels
Return: AX = status (0000h initialization failed, 0001h init successful)
	BX = allowed output format
	    0000h monochrome
	    0001h color (4 bits per pixel)
SeeAlso: AX=8002h,AX=8003h,INT 7B"AutoCAD",INT 7C"AutoShade"
--------A-7B8002-----------------------------
INT 7B R - AutoCAD Device Interface - PRINTER/PLOTTER - END PLOT
	AX = 8002h
SeeAlso: AX=8001h,AX=8003h
--------A-7B8003-----------------------------
INT 7B R - AutoCAD Device Interface - PRINTER/PLOTTER - ABORT PLOT
	AX = 8003h
SeeAlso: AX=8001h,AX=8002h
--------r-7C---------------------------------
INT 7C U - IBM REXX88PC command language
	???
--------E-7C---------------------------------
INT 7C - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ4
Program: GO32.EXE is a DOS extender included as part of the 80386 port of the
	  GNU C/C++ compiler by DJ Delorie and distributed as DJGPP
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0C,INT 7B"GO32",INT 7D"GO32"
--------P-7C---------------------------------
INT 7C - PRINDIR v8.02-8.xx - API
	AH = function
	   00h set output to Invisible mode
	   01h set output to LPT1
	   02h set output to LPT2
	   03h set output to LPT3
	   04h set output to COM1
	   05h set output to COM2
	   06h set output to COM3
	   07h set output to COM4
	   08h set output to screen
	   09h set output to file
	   0Ah change file path
	       ES:DI -> new path
	       CX = length of path (max 41, but not range-checked)
	   0Bh change file name
	       ES:DI -> new filename
	       CX = length of new name (max 41, but not range-checked)
	   0Ch set redirected device
		(01h = LPT1 ... 03h = LPT3, 04h = COM1 ... 07h = COM4)
	   0Dh force buffer dump
	   0Eh set display color
	       AL = new color attribute (see #0013 at INT 10/AH=08h)
	   0Fh set popup hotkey
	       AL = hotkey scancode
	   10h toggle byte display
	       AL = new state (00h off, 01h on)
	   11h change buffer flush delay
	       AL = timer ticks before flush
Return: AX = status
	    0000h successful
	    0001h invalid function or nothing in buffer to be dumped
	    (documented as "nonzero = error")
Program: PRINDIR is a shareware printer-redirection program by J.M. Allen
	  Creations
Notes:	the installation check consists of testing for the ASCIZ signature
	  "PRINDIR N.NN" (where N.NN is the version number) two bytes beyond
	  the start of the interrupt handler
	prior versions of PRINDIR used INT 7A instead of INT 7C
SeeAlso: INT 7A"PRINDIR",INT 2F/AX=7F00h"PRINDIR"
Index:	hotkeys;PRINDIR
--------A-7C---------------------------------
INT 7C - AutoShade v2 - RENDERING HARDCOPY DRIVER
Note:	this is the default interrupt vector for rendering hardcopy drivers
	  instead of INT 7A used by AutoCAD drivers
SeeAlso: INT 7A/AX=0001h"AutoCAD"
--------N-7C---------------------------------
INT 7C - SK-UPPS/SK-PASSPORT Data Link Interface (DLI) API
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of it Data Link Interface, allowing the
	  use of any of several network transport layers; this product is
	  called SK-PASSPORT in the USA.
Notes:	The installation check consists of testing for the ASCII signature
	  string "UPPS_DLI" immediately preceding the interrupt handler.
	To find the service interrupt being used by the driver, an application
	  should scan through the interrupt table until it finds an interrupt
	  vector with the "UPPS_DLI" string.
	There may be more than one DLI loaded, each having its own service
	  interrupt.
SeeAlso: AX=0000h,AX=0002h,AX=000Fh
Index:	installation check;SK-UPPS
--------N-7C0000-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET DRIVER VERSION
	AX = 0000h
Return: AH = major DLI version
	AL = minor DLI version
	DX = OEM signature (see #3477)
	CL = DLI 2.8+ topology: 1=Ethernet, 2=FDDI, 3=Token-Ring
SeeAlso: AX=0002h,AX=000Bh,AX=000Dh,AX=000Eh

(Table 3477)
Values for SK-UPPS Data Link Interface OEM signature (defined by SK):
 0001h		experimental
 3343h	('3C')	3COM
 4942h	('IB')	IBM
 4943h	('IC')	Intellicom
 494Eh	('IN')	Intel
 4B4Fh	('KO')	Kodiak
 4D41h	('MA')	Madge
 4E45h	('NE')	Novell
 4F43h	('OC')	Olicom
 5349h	('SI')	Siemens
 534Bh	('SK')	Schneider & Koch (SysKonnect)
 5744h	('WD')	Western Digital
--------N-7C0001-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DOWN DRIVER
	AX = 0001h
Return: AX = completion code (see #3478)
Note:	the DLI will refuse to unload if there are any protocols
	  (see AX=0007h) or clients (see AX=0010h) active.
Index:	uninstall;SK-UPPS Data Link Interface

(Table 3478)
Values for SK-UPPS completion code:
 0000h	SUCCESS
 0005h	INVALID_MULTICAST
 0006h	BUFFER_TOO_SMALL
 0007h	NO_BUFFERS_LEFT
 0008h	NO_RESOURCES_LEFT
 000Bh	ILLEGAL_PROTOCOL_ID
 000Ch	PROTOCOL_IN_USE
 000Dh	NO_MULTICAST_ADDRESS
 000Fh	PROTOCOLS_ACTIVE
 0010h	CLIENTS_ACTIVE
 001Bh	INVALID_MODE
 001Ch	MODE_NOT_SUPPORTED
 FFFFh	UNKNOWN_SERVICE
--------N-7C0002-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET DRIVER STATUS
	AX = 0002h
	ES:DI -> Status Information Block (SIB) (see #3490)
Return: AX = completion code (see #3478)
Note:	GET DRIVER INFO (AX=000Eh) should be used instead.
SeeAlso: AX=0000h,AX=000Bh,AX=000Dh,AX=000Eh
--------N-7C0003-----------------------------
INT 7C - SK-UPPS Data Link Interface API - CHANGE DRIVER ADDRESS
	AX = 0003h
	ES:DI -> new node address (6 bytes)
Return: AX = completion code (see #3478)
Note:	the DLI will refuse to change the address if any protocols
	  (see AX=0007h) are active
SeeAlso: AX=0001h,AX=000Eh
--------N-7C0004-----------------------------
INT 7C - SK-UPPS Data Link Interface API - REQUEST BUFFER
	AX = 0004h
	DX = protocol ID (see AX=0007h,#3481)
Return: AX = completion code (see also #3478)
	    0000h successful
		ES:BX -> Memory Buffer (Mbuf) (see #3479)
Note:	if the DLI has no free Mbufs, it will set an internal flag for the
	  protocol and later call the protocol's Event Upcall with
	  EV_BUFFER_AVAILABLE (see #3485,#3486) as soon as an Mbuf becomes
	  available.  There will only be one "buffer available" Upcall, even
	  if this function has been called several times before.
SeeAlso: AX=0005h,AX=0006h,AX=0012h,AX=0013h

Format of SK-UPPS Memory Buffer (Mbuf):
Offset	Size	Description	(Table 3479)
 00h	DWORD	-> NEXT Mbuf (linked list)
 04h	WORD	OFFSET of actual data within DATA area
 06h  2 BYTEs	reserved (currently unused)
 08h	WORD	LENGTH of actual data found in DATA area starting at OFFSET
 0Ah  2 BYTEs	reserved (currently unused)
 0Ch	DWORD	-> DATA area (size can be obtained via AX=000Eh call)
 10h	WORD	PROTOCOL ID of protocol currently "owning" the Mbuf
 12h	BYTE	IN USE flag; nonzero if Mbuf still in use by DLI (see AX=0006h)
 13h	BYTE	RECEIVE STATUS (bit 0-7 only; see AX=0007h - Receive Upcall)
--------N-7C0005-----------------------------
INT 7C - SK-UPPS Data Link Interface API - RELEASE BUFFER
	AX = 0005h
	ES:BX -> Mbuf (see #3479)
Return: nothing
SeeAlso: AX=0004h
--------N-7C0006-----------------------------
INT 7C - SK-UPPS Data Link Interface API - TRANSMIT FRAME
	AX = 0006h
	ES:BX -> Mbuf (see #3479)
Return: nothing
Notes:	The DLI will send LENGTH bytes found in the Mbuf's DATA area starting
	  at OFFSET. A complete and valid frame must be stored there. The DLI
	  will only copy the current node address (see AX=0003h) to the
	  source node field of the frame's MAC header.
	On Ethernet, the DLI will always send a minimum of 60 bytes, regardless
	  of the value found in the LENGTH field.
	This function returns immediately; the DLI will call the protocol's
	  Transmit Upcall (see #3480) when the frame has been sent.
	The Mbuf's IN USE field will be non-zero until the DLI calls the
	  Transmit Upcall.
SeeAlso: AX=0002h,AX=0004h,AX=0013h

(Table 3480)
Values SK-UPPS Transmit Upcall is called with:
	ES:BX -> Mbuf (NEXT field destroyed)
	interrupts disabled
Note:	On FDDI the bytes of the source and destination node fields in the MAC
	  header have been bit-swapped to physical address format.
--------N-7C0007-----------------------------
INT 7C - SK-UPPS Data Link Interface API - REGISTER PROTOCOL
	AX = 0007h
	ES:BX -> Protocol Control Block (see #3481)
Return: AX = completion code (see #3478)
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of its Data Link Interface, allowing the
	  use of any of several network transport layers
SeeAlso: AX=0008h,AX=000Bh

Format of SK-UPPS Protocol Control Block (PCB):
Offset	Size	Description	(Table 3481)
 00h	WORD	(big-endian) protocol type
 02h	WORD	protocol mode (see #3482)
 04h	DWORD	-> Receive Upcall routine (see #3483)
 08h	DWORD	-> Transmit Upcall routine
 0Ch	DWORD	-> Event Upcall routine (see #3485)
 10h	DWORD	-> ASCIZ protocol name (zero if none)
 14h	WORD	protocol ID will be returned here (always non-zero)

Bitfields for SK-UPPS protocol mode:
Bit(s)	Description	(Table 3482)
 0	promiscuous mode; protocol receives all frames regardless of their
	  destination (PROTOCOL TYPE must be FFFFh)
 1	if set, protocol's Event Upcall will be called on entry and exit of the
	  DLI's Interrupt Service Routine (see #3486)
 2	DLI 2.2+ hook mode; protocol receives all directed frames destined for
	  this station (PROTOCOL TYPE must be FFFFh)
 3	DLI 2.3+ receive error frames (only valid in promiscuous mode (0))
 4-5	DLI 2.5+ frame type:
	00 Ethernet II; specify type code in PROTOCOL TYPE field (high-low)
	01 IEEE 802.2; specify Service Access Point (SAP) in MSB
	      (offset 0) of PROCOTOL TYPE field; LSB must be zero
	10 IEEE 802.2 with SNAP header; specify type code in PROTOCOL TYPE
	      field (high-low)
	11 reserved (currently unused)
 6	DLI 2.5+ if set, protocol's Event Upcall will be called with event code
	  EV_BUFFER_WANTED, when DLI runs out of Mbufs
 7	DLI 2.7+ chain mode; if set, client allows the specified frame type to
	  be shared with other clients
 8	DLI 2.8+ receive non-LLC frames rather than LLC frames
 9	DLI 2.8+ receive all multicast frames (see also AX=0009h)
 10-15	reserved (currently unused; must be zero)
Notes:	If PROTOCOL TYPE is FFFFh and neither the "promiscuous" nor the "hook"
	  mode is set, the protocol receives all frames that did not match
	  any registered frame type (demultiplexor mode).
	Protocols using "promiscuous", "hook" or "chain" mode should always
	  return from the Receive Upcall with the received Mbuf in ES:BX and
	  the Carry Flag set. The DLI will then pass the Mbuf to the FEED BACK
	  BUFFER function (see AX=000Fh).
	Some DLIs do not support all or even any of the "promiscuous",
	  "receive non-LLC" and "receive all multicasts" mode bits.
SeeAlso: #3481

(Table 3483)
Values SK-UPPS Receive Upcall is called with:
	ES:BX -> Mbuf
	AX = receive status (see #3484) (also stored in Mbuf's RECEIVE STATUS field)
	interrupts disabled
Return: nothing
SeeAlso: #3485

Bitfields for SK-UPPS receive status:
Bit(s)	Description	(Table 3484)
 0-2	reserved (0), currently unused
 3	frame check sequence (FCS) error
 4	overflow (frame too long)
 5	framing error
 6	reserved (0), currently unused
 7	non-LLC frame (see #3482 [bit 8])
 8-15	reserved (0), currently unused
Notes:	The protocol's Receive Upcall routine will be called whenever a frame
	  matching the specified frame type is received. A received frame is
	  passed to the protocol in the Mbuf's DATA area at OFFSET and its size
	  is LENGTH bytes.
	The receive status passed to the Receive Upcall in register AL is
	  always zero, except for protocols using "non-LLC" mode (8 of PCB's
	  protocol mode field) or "promiscuous" mode together with "receive
	  error frames" (0 & 3).
	Upcalls are FAR routines and must return with a RET FAR. If the Carry
	  Flag is set on return from a Receive or Transmit Upcall, then ES:BX
	  must point to an Mbuf, which the DLI will then pass to the RELEASE
	  BUFFER function (see AX=0005h). See also notes for PROTOCOL MODE.

(Table 3485)
Values SK-UPPS Event Upcall is called with:
	AX = event code (see #3486)
Return: nothing
Note:	All Event Upcalls may be ignored by the protocol.
SeeAlso: #3483

(Table 3486)
Values for SK-UPPS Event Upcall event code:
 00h	EV_BUFFER_AVAILABLE client may now call REQUEST BUFFER (AX=0004h)
 01h	EV_ISR_START	    start of Interrupt Service Routine
 02h	EV_ISR_END	    end of ISR (see #3482 [bit 1])
 03h	EV_BUFFER_WANTED    DLI temporarily out of Mbufs
 04h	EV_NETWORK_STATUS   DLI 2.8+ network status -- DX=status (see #3487)
 05h	EV_IO_CONTROL	    DLI 2.8+ I/O control -- DX=subfunc (see AX=0016h)
SeeAlso: #3485

Bitfields for EV_NETWORK_STATUS in register DX:
Bit(s)	Description	(Table 3487)
	Token-Ring		FDDI
 15	SIGNAL_LOSS		SIGNAL_LOSS
 14	HARD_ERROR		HARD_ERROR
 13	SOFT_ERROR		SOFT_ERROR
 12	TRANSMIT_BEACON		TRANSMIT_BEACON
 11	LOBE_WIRE_FAULT		PATH_TEST_FAILED
 10	AUTO_REMOVAL		SELF_TEST_REQUIRED
 9	reserved		reserved
 8	REMOVE_RECEIVED		REMOTE_DISCONNECT
 7	COUNTER_OVERFLOW	reserved
 6	SINGLE_STATION		DUPLICATE_ADDRESS
 5	RING_RECOVERY		NO_RING_OP_STATUS
 4	reserved		VERSION_MISMATCH
 3	reserved		STUCK_BYPASS
 2	reserved		FDDI_EVENT
 1	reserved		RING_OP_CHANGE
 0	reserved		reserved
Note:	EV_NETWORK_STATUS is not supported on Ethernet
--------N-7C0008-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DISABLE PROTOCOL
	AX = 0008h
	BX = protocol ID (see #3481)
Return: AX = completion code (see #3478)
Note:	the DLI will handle any Mbufs given to TRANSMIT FRAME (AX=0006h) as if
	  they had been given to TRANSMIT FRAME RELEASE (AX=0013h).
	all multicast addresses registered for this protocol will be disabled.
	after this function returns, the protocol's Upcall routines will no
	  longer be called.
SeeAlso: AX=0007h,AX=000Bh
--------N-7C0009-----------------------------
INT 7C - SK-UPPS Data Link Interface API - REGISTER MULTICAST
	AX = 0009h
	BX = protocol ID (see #3481)
	ES:DI -> multicast address (6 bytes)
Return: AX = completion code (see #3478)
Notes:	The broadcast address is always enabled.
	Set bit 9 of PCB's protocol mode field in REGISTER PROTOCOL call
	  (AX=0007h) to receive all multicast frames.
SeeAlso: AX=000Ah,AX=0014h
--------N-7C000A-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DISABLE MULTICAST
	AX = 000Ah
	BX = protocol ID (see #3481)
	ES:DI -> multicast address (6 bytes)
Return: AX = completion code (see #3478)
SeeAlso: AX=0009h,AX=0014h
--------N-7C000B-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET PROTOCOL LIST
	AX = 000Bh
	ES:DI -> protocol ID buffer
	CX = number of 2-byte protocol IDs that may be stored in buffer
Return: AX = completion code (see #3478)
	CX = number of active protocols (regardless of value returned in AX)
	protocol ID buffer filled with active protocol IDs
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of its Data Link Interface, allowing the
	  use of any of several network transport layers
Note:	If the buffer supplied is too small, CX still contains the total number
	  of active protocols and the buffer has been filled until full.
SeeAlso: AX=000Ch,AX=0014h
--------N-7C000C-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET PROTOCOL STATUS
	AX = 000Ch
	BX = protocol ID (see #3481,AX=000Bh)
	ES:DI -> Protocol Status Block (see #3488)
Return: AX = completion code (see #3478)
SeeAlso: AX=000Bh,AX=0014h

Format of SK-UPPS Protocol Status Block (PSB):
Offset	Size	Description	(Table 3488)
 00h	DWORD	-> ASCIZ protocol name
 04h	WORD	protocol mode (see #3482)
 06h	WORD	protocol type (see AX=0007h)
 08h	WORD	number of registered multicasts (see AX=0009h,AX=0014h)
--------N-7C000D-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET DRIVER STATISTICS
	AX = 000Dh
	BX = flag: 0=don't clear statistics, 1=clear statistics
	ES:DI -> Statistics Data Block (see #3489)
Return: AX = completion code (see #3478)
SeeAlso: AX=0002h,AX=0015h

Format of SK-UPPS Statistics Data Block (SDB):
Offset	Size	Description	(Table 3489)
 00h	DWORD	node uptime in ticks (1/18.21 sec.)
 04h	DWORD	bytes received
 08h	DWORD	bytes transmitted
 0Ch	DWORD	frames received
 10h	DWORD	frames transmitted
 14h	DWORD	multicast bytes received
 18h	DWORD	multicast frames received
 1Ch	DWORD	unrecognized frames
 20h	WORD	missed frames
 22h	WORD	frame check sequence (FCS) errors
 24h	WORD	framing errors
 26h	WORD	babbling errors
 28h	WORD	late collision errors
 2Ah	WORD	loss of carrier errors
 2Ch	WORD	16 retries failed errors
 2Eh	WORD	overflow errors
Note:	fields 26h through 2Ch are always zero, except in some very old
	  versions of the DLI.	Use GET MEDIA STATISTICS (AX=0015h) to get
	  more detailed information.
--------N-7C000E-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DLI 2.5+ - GET DRIVER INFO
	AX = 000Eh
	ES:DI -> Driver Information Block (see #3490)
	BX = offset of 1st field within DIB to be returned
	CX = number of bytes to be returned
Return: AX = completion code (see #3478)
	CX = number of bytes copied (regardless of value returned in AX)
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of its Data Link Interface, allowing the
	  use of any of several network transport layers
SeeAlso: AX=0000h,AX=0002h,AX=000Bh,AX=000Dh,AX=0015h

Format of SK-UPPS Driver Information Block (DIB):
Offset	Size	Description	(Table 3490)
 00h  6 BYTEs	physical node address (from adapter's ROM)
 06h  6 BYTEs	current node address (see AX=0003h)
 0Ch	BYTE	adapter id (defined by OEM)
 0Dh	BYTE	IRQ line (FFh if none)
 0Eh	DWORD	-> shared memory (zero if none)
 12h	DWORD	size of shared memory (zero if none)
 16h	WORD	base I/O port (zero if none)
 18h	BYTE	DMA line (FFh if none)
 19h	BYTE	DLI 2.4+ topology (see AX=0000h)
 1Ah	WORD	size of an Mbuf's DATA area (see #3479)
 1Ch  2 BYTEs	reserved (currently unused)
 1Eh	WORD	total number of Mbufs the DLI has
 20h	WORD	maximum number of Mbufs that can be allocated via REQUEST
		  BUFFER (AX=0004h) and SYNC REQUEST BUFFER (AX=0012h)
 ---- end of Status Information Block returned by GET DRIVER STATUS (AX=0002h)
 22h	DWORD	-> ASCIZ adapter name
 26h	WORD	number of I/O ports used (zero if none)
 28h	DWORD	line speed in bits/sec.
--------N-7C000F-----------------------------
INT 7C - SK-UPPS Data Link Interface API - FEED BACK BUFFER
	AX = 000Fh
	ES:BX -> Mbuf (see #3479)
Return: nothing
Notes:	A protocol may call this function instead of returning the Mbuf
	  directly from the Receive Upcall if it is running in "promiscuous",
	  "hook" or "chain" mode.
SeeAlso: AX=0007h
--------N-7C0010-----------------------------
INT 7C - SK-UPPS Data Link Interface API - CLIENT HOOK
	AX = 0010h
Return: nothing
Notes:	An application having no active protocols may call this function to
	  prevent the DLI from unloading.
SeeAlso: AX=0001h,AX=0011h
--------N-7C0011-----------------------------
INT 7C - SK-UPPS Data Link Interface API - CLIENT UNHOOK
	AX = 0011h
Return: nothing
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of its Data Link Interface, allowing the
	  use of any of several network transport layers
SeeAlso: AX=0010h
--------N-7C0012-----------------------------
INT 7C - SK-UPPS Data Link Interface API - SYNC REQUEST BUFFER
	AX = 0012h
	DX = protocol ID (see #3481)
Return: AX = completion code (see #3478)
	if AX=0000h: ES:BX -> Mbuf (see #3479)
Note:	If the protocol wants to be informed when an Mbuf becomes available,
	  REQUEST BUFFER (AX=0004h) should be used instead.
SeeAlso: AX=0004h,AX=0005h,AX=0006h,AX=0013h
--------N-7C0013-----------------------------
INT 7C - SK-UPPS Data Link Interface API - TRANSMIT FRAME RELEASE
	AX = 0013h
	ES:BX -> Mbuf (see #3479)
Return: nothing
Notes:	Returns immediately; The protocol's Transmit Upcall will NOT be called.
	The Mbuf may no more be used by the protocol in any way (i.e. the
	  Mbuf's IN USE field may not be polled).
SeeAlso: AX=0004h,AX=0013h
--------N-7C0014-----------------------------
INT 7C - SK-UPPS Data Link Interface API - GET MULTICAST LIST
	AX = 0014h
	BX = protocol ID (see #3481,AX=000Bh)
	ES:DI -> multicast address buffer
	CX = number of 6-byte multicast addresses that may be stored in buffer
Return: AX = completion code (see #3478)
	CX = number of registered multicast addresses for this protocol
	  (regardless of value returned in AX)
	multicast address buffer filled with multicast addresses registered for
	  this protocol
Note:	If the buffer supplied is too small, CX still contains the total number
	  of registered multicast addresses for this protocol and the buffer
	  has been completely filled
SeeAlso: AX=000Bh,AX=0009h,AX=000Ch
--------N-7C0015-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DLI 2.6+ - GET MEDIA STATISTICS
	AX = 0015h
	ES:DI -> media-specific statistics buffer (see #3491,#3492,#3493)
	BX = offset of 1st field within MSS to be returned
	CX = number of bytes to be returned
Return: AX = completion code (see #3478)
	CX = number of bytes copied (regardless of value returned in AX)
Note:	not supported by all DLIs (will return AX=FFFFh if not supported).
SeeAlso: AX=0000h,AX=000Dh

Format of SK-UPPS media-specific statistics for Ethernet:
Offset	Size	Description	(Table 3491)
 00h	DWORD	alignment errors
 04h	DWORD	frame check sequence (FCS) errors
 08h	DWORD	single collision frames
 0Ch	DWORD	multiple collision frames
 10h	DWORD	signal quality error (SQE) test errors
 14h	DWORD	deferred transmissions
 18h	DWORD	late collisions
 1Ch	DWORD	excessive collisions
 20h	DWORD	internal MAC transmit errors
 24h	DWORD	carrier sense errors
 28h	DWORD	excessive deferrals
 2Ch	DWORD	frame too longs
 30h	DWORD	in range length errors
 34h	DWORD	out of range length fields
 38h	DWORD	internal MAC receive errors

Format of SK-UPPS media-specific statistics for FDDI:
Offset	Size	Description	(Table 3492)
 00h	DWORD	SMT operating version id (refer to ANSI 7.1.2.2)
 04h	DWORD	SMT CF state: 1=Isolated, 2= Wrap_S, 3=Wrap_A, 4=Wrap_B,
		  5=Wrap_AB, 6=Thru (refer to ANSI SMT 9.7.4.3)
 08h	DWORD	SMT frames sent
 0Ch	DWORD	SMT frames received
 10h	DWORD	SMT ring up count
 14h  6 BYTEs	MAC upstream neighbour
 1Ah  6 BYTEs	MAC downstream neighbour
 20h	DWORD	MAC frame counter (refer to ANSI MAC 2.2.1)
 24h	DWORD	MAC error counter ( " )
 28h	DWORD	MAC lost counter ( " )
 2Ch	BYTE	port 1 link error estimate (ranges from 10**-4 to 10**-15 and
		  is reported as the absolute value of the exponent)
 2Dh	BYTE	port 2 link error estimate ( " )
 2Eh  2 BYTEs	reserved (currently unused)
 30h	DWORD	attachment class: 1=single-attachment (S PORT),
		  2=dual-attachment (A/B PORT pairs), 3=concentrator (M PORTs)
 34h	DWORD	attachment optical bypass present: 1=true, 2=false

Format of SK-UPPS media-specific statistics for Token-Ring:
Offset	Size	Description	(Table 3493)
 00h  6 BYTEs	upstream neighbour
 06h	WORD	local ring number
 08h	DWORD	ring up count
 0Ch	DWORD	signal loss errors
 10h	DWORD	lobe wire faults
 14h	DWORD	ring recovery count
 18h	DWORD	line errors
 1Ch	DWORD	burst errors
 20h	DWORD	ARI/FCI errors
 24h	DWORD	lost frame errors
 28h	DWORD	receive congestion errors
 2Ch	DWORD	frame copied errors
 30h	DWORD	token errors
 34h	DWORD	DMA bus errors
 38h	DWORD	DMA parity errors
 3Ch	DWORD	receive overflow errors
--------N-7C0016-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DLI 2.8+ - DRIVER I/O CONTROL
	AX = 0016h
	DX = subfunction; bits 14-15 specify direction of I/O:
		00 no data at all (ES:BX undefined)
		01 driver -> application (GET)
		10 application -> driver (SET)
		11 both directions (GET/SET)
	ES:BX -> I/O buffer (optional)
	CX = size of buffer (if ES:BX valid)
Return: AX = completion code; defined by OEM
Program: SK-UPPS is the Schneider & Koch Universal Portable Protocol Stack,
	  which provides an API on top of its Data Link Interface, allowing the
	  use of any of several network transport layers
Notes:	not supported by all DLIs (will return AX=FFFFh if not supported)
	subfunction codes are defined by OEMs
SeeAlso: AX=0001h
--------N-7C0017-----------------------------
INT 7C - SK-UPPS Data Link Interface API - DLI 2.8+ - INTERRUPT REQUEST
	AX = 0017h
Return: AX = completion code (see #3478)
Notes:	not supported by all DLIs (will return AX=FFFFh, if not supported).
	must be called with interrupts disabled; when the client re-enables
	  interrupts, an interrupt will be generated and reported to the client
	  through an Event Upcall (see #3485 [EV_ISR_START/EV_ISR_END])
SeeAlso: AX=0007h
--------t-7D---------------------------------
INT 7D O - [obsoleted proposal] - ALTERNATE MULTIPLEX INTERRUPT
Note:	this interface has been moved to INT 2D; there are no known
	  implementations on INT 7D
SeeAlso: INT 2D"AMIS",INT 2F"NOTES"
--------S-7D---------------------------------
INT 7D U - YTERM 1.4 - CLOCK SUPPORT
SeeAlso: INT 7E"YTERM"
--------E-7D---------------------------------
INT 7D - DJGPP GO32.EXE DOS EXTENDER - RELOCATED IRQ5
Notes:	this vector is overwritten when GO32 starts but is not restored by
	  early versions of the extender
	the newest versions of GO32 dynamically allocate the vectors used
	  for the relocated IRQs, much as DESQview does (see INT 50"DESQview")
SeeAlso: INT 0D"IRQ5",INT 7C"GO32",INT 7E"GO32"
--------U-7D---------------------------------
INT 7D - HyperPAD v2.2 - API ACCESS
Note:	this vector is hooked but immediately passed on (without checking
	  whether the previous handler was 0000h:0000h).  The sole purpose of
	  this vector is to provide the address of the data area described
	  below (see #3494).

Format of HyperPAD data area:
Offset	Size	Description	(Table 3494)
 -16h	DWORD	pointer to ??? FAR function
 -12h	DWORD	pointer to callback setting function
		[C calling conventions, (*callback)(int (_loadds far *)()) ]
 -0Eh 6 BYTEs	signature "BRC001"
 -08h	DWORD	pointer to previous INT 7D handler
 -04h	DWORD	pointer to ??? data
 00h		HyperPAD INT 7D handler
----------7D---------------------------------
INT 7D - IBM DOS 6.1 E.EXE - ???
Note:	E.EXE checks whether this interrupt is in use (not 0000h:0000h),
	  and if it is used, attempts to load E55VGA.EX instead of the
	  default E.EX overlay.	 However, E55VGA.EX is not included in
	  IBM DOS 6.1.
--------G-7D00-------------------------------
INT 7D - SCSILink - RESET SCSI BUS
	AH = 00h
Program: SCSILink is a TSR by Cross Products Ltd which allows its PC-hosted
	  cross assemblers and similar products to communicate with Cross
	  Products hardware debuggers
Desc:	reset all devices on the SCSI bus
Note:	the installation check is the signature "SCSILINK" immediately prior
	  to the interrupt handler
Index:	installation check;SCSILink
--------G-7D01-------------------------------
INT 7D - SCSILink - CONNECT TO TARGET
	AH = 01h
	AL = target ID
Return: CF clear if successful
	CF set on error
	    AL = initiator error
	    AH = target error
Desc:	arbitrate the use of the bus and select the specified target device
--------G-7D02-------------------------------
INT 7D - SCSILink - SEND COMMAND
	AH = 02h
	ES:BX -> parameter block (see #3495)
Return: CF clear if successful
	CF set on error
	    AL = initiator error
	    AH = target error
Desc:	send the specified command block to the target device and perform any
	  related I/O

Format of SCSILink parameter block:
Offset	Size	Description	(Table 3495)
 00h	DWORD	size of command block
 04h	DWORD	address of command block (see #3496)
 08h	DWORD	size of buffer
 0Ch	DWORD	address of buffer

Format of SCSILink command block:
Offset	Size	Description	(Table 3496)
 00h		info not yet available
--------G-7D03-------------------------------
INT 7D - SCSILink - SET TIMEOUT
	AH = 03h
	AL = timeout selector (see #3497)
	BX = new value in 55ms ticks
Desc:	change an internal timeout value to allow communication with very
	  slow targets

(Table 3497)
Values for SCSILink timeout selector:
 00h	time to wait for bus (default 18)
 01h	time to wait for new phase (default 5)
 02h	maximum time to send/receive block (default 18)
 03h	time to wait for reselect (default 180)
--------G-7D04-------------------------------
INT 7D - SCSILink - GET ERROR STRING
	AH = 04h
	AL = error number
Return: ES:BX -> ASCIZ error string for error number
--------G-7D05-------------------------------
INT 7D - SCSILink - GET ADDRESS
	AH = 05h
Return: AL = DMA channel
	AH = initiator ID
	BX = card address
Desc:	determine the current hardware configuration
--------G-7D06-------------------------------
INT 7D - SCSILink - PUT DATA
	AH = 06h
	CX = number of bytes to store (0001h-0100h)
	ES:BX -> data to be saved
Return: CF clear if successful
	CF set on error
	    AL = error code (01h = too much data)
Note:	the specified data is stored in SCSILink's PSP
SeeAlso: AH=07h
--------G-7D07-------------------------------
INT 7D - SCSILink - GET DATA
	AH = 07h
	CX = number of bytes to retrieve (0001h-0100h)
	ES:BX -> buffer for data
Return: CF clear if successful
	CF set on error
	    AL = error code (01h = too much data)
Note:	retrieve data previously stored with AH=06h
SeeAlso: AH=06h
--------G-7D08-------------------------------
INT 7D - SCSILink - TERMINATE SESSION
	AH = 08h
Desc:	indicate to any other programs that intercept INT 7D that the program
	  has finished with the link
Note:	the program should call this function even if a SCSI error caused its
	  termination
--------G-7D09-------------------------------
INT 7D - SCSILink - POLL REQUEST
	AH = 09h
	AL = target ID
Return: AL = status
	    FEh resident driver experienced SCSI error
	    FFh resident driver handleded event
Desc:	give any drivers chained onto INT 7D a chance to handle an exception
	  not specifically handled by the calling program
Notes:	this service exists so that resident disk servers, etc. can continue
	  running even while debuggers and profilers are active
	the resident driver assumes that a connection has been established and
	  attempts to leave the target connected
--------!---Section--------------------------
