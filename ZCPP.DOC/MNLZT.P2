
			 Часть 2

        С П Р А В О Ч Н О Е   Р У К О В О Д С Т В О
        ───────────────────────────────────────────


                ПОДРОБНОЕ РУКОВОДСТВО ПО УСТАНОВКЕ СИСТЕМЫ
              ──────────────────────────────────────────────


Системные требования

      - Персональный компьютер  под  управлением  MS-DOS 2.0
        или более поздней версии.

      - Два устройства для гибких дисков или одно устройство
        для гибких дисков и один жесткий диск.

      - 256 Кб доступной оперативной памяти.

   Прежде чем Вы сможете начать писать  C++  программы,  ис-
пользуя Zortech C++ компилятор, необходимо корректно устано-
вить систему на Вашем диске (или дискетах).


Установка системы на жесткий диск

   Программа ZTCSETUP.EXE  (с  первой  дискеты дистрибутива)
устанавливает Zortech C++ на Вашем жестком диске. Она созда-
ет каталог C:\ZORTECH и некоторое число подкаталогов. Струк-
тура создаваемых каталогов такова:

                    ┌─────────────────────┐
                    │        C : \        │
                    └──────────┬──────────┘
                               │
                       ┌───────┴───────┐
                       │ Z O R T E C H │
                       └───────┬───────┘
                               │
     ┌─────────────┬───────────┴─┬─────────┬──────────┐
     │             │             │         │          │
 ┌───┴───┐ ┌───────┴───────┐ ┌───┴───┐ ┌───┴───┐ ┌────┴────┐
 │ B I N │ │ I N C L U D E │ │ L I B │ │  F G  │ │ U T I L │
 └───────┘ └───────┬───────┘ └───────┘ └───────┘ └─────────┘
                   │
            ┌──────┴──────┐
            │  S  Y  S    │
            └─────────────┘


   Затем ZTCSETUP копирует все необходимые для использования
Zortech  C++ файлы с дистрибутивных дисков в соответствующие
каталоги:


   C:\ZORTECH            Главный каталог, содержащий read.me
                         и MAKE файлы

   C:\ZORTECH\BIN        Все исполняемые файлы (.EXE и .COM)

   C:\ZORTECH\LIB           Все  библиотечные  файлы  (.LIB)

   C:\ZORTECH\INCLUDE       Все файлы заголовков (.H и .HPP)

   C:\ZORTECH\INCLUDE\SYS           Файл  заголовков  STAT.H

   C:\ZORTECH\UTIL                                   Утилиты

   C:\ZORTECH\FG            Демонстрационные примеры быстрой
                            (FLASH) графики


   Перед запуском ZTCSETUP Вам следует скопировать дистрибу-
тивные  диски и использовать для установки их рабочие копии.
Затем Вам следует положить дистрибутивные диски и их рабочие
копии в надежное место.  Чтобы запустить ZTCSETUP, поставьте
рабочую копию системного диска N 1 на  устройство  A:.  Если
устройство A:  не является текущим, наберите A: и затем наж-
мите на Enter. На приглашение A:> наберите ZTCSETUP и нажми-
те клавишу Enter.

   Далее следуйте  выводимым  на экран инструкциям.  По мере
копирования файлов с каждой дискеты Вас  приглашают  ставить
новую дискету.  И, ставя ее, Вы должны быть твердо уверены в
том, что она является той, которая требуется.


Переменные окружения

   Ваши файлы  AUTOEXEC.BAT и CONFIG.SYS должны быть измене-
ны. Подробности требуемых изменений смотрите в разделе Быст-
рый  Старт (QUICK START).  После изменения этих файлов пере-
загрузите Ваш компьютер для установки  системного окружения.
Если Вы удовлетворены умолчаниями системы, то можете перехо-
дить к использованию Zortech C++.  Если же Вы захотите изме-
нить заданную по умолчанию организацию системы, Вам придется
также  изменить  параметры  установки  контекстно-зависимого
подсказчика  (Context  Sensitive Help) и редактора ZED.  Вам
нужно будет просмотреть соответствующие разделы Руководства,
чтобы узнать, как это сделать.


Изменение маршрутов  к каталогам (directory paths) и перемен-
ных окружения

   Если Вы  хотите  изменить  эти  умолчания  при  установке
Zortech C++,  Вам нужно будет понять,  как Zortech C++  ищет
маршруты  (пути) для исполняемых,  включаемых и библиотечных
файлов.  На каждом шаге работы Zortech C++ обязательно опре-
деляет  местонахождение  различных файлов,  для того,  чтобы
функционировать правильно.  Для некоторых шагов такие  файлы
являются исполняемыми,  как,  например, компилятор, редактор
связей (linker) или оптимизатор. Для других шагов это исход-
ные  файлы,  названные  в директивах препроцессора #include,
или библиотечные файлы,  используемые редактором связей.

   Каталоги ищутся  в определенном порядке.  Наивысший прио-
ритет дается для каталога, заданного полным именем файла или
ключом в командной строке. Далее используются маршруты, опре-
деленные в переменных окружения.  В некоторых случаях умолча-
нием служит текущий каталог.

   Пять переменных  окружения  используются  для определения
маршрутов в Zortech C++;  PATH,  INCLUDE,  LIB,  TMP и TEMP.
PATH  определяет  маршрут для поиска исполняемых файлов.  Он
используется главным образом для команд командному процессо-
ру MS-DOS.  Если ни один из маршрутов не определен, по умол-
чанию используется текущий каталог.

   INCLUDE переменная окружения  определяет  маршрут  поиска
файлов, названных в директивах препроцессора #include. Любое
имя файла в #include директиве,  содержащее путь к каталогу,
должно быть найдено в этом каталоге или оно не будет найдено
никогда.

   Файлы, имена которых заключены в угловые скобки (<  и >),
компилятор ищет по маршрутам,  определенным переменной окру-
жения INCLUDE. Если файл не найден в каком-нибудь из INCLUDE
каталогов,  то это означает, что файл не найден. В этом слу-
чае текущий каталог не просматривается.

   Если INCLUDE переменная окружения не была  определена, то
просматривается только текущий каталог.  Любой файл,  заклю-
ченный в двойные кавычки,  ищется в текущем  каталоге,  если
только определение каталога не содержится внутри кавычек.

   LIB переменная окружения содержит маршруты поиска библио-
тек,  используемых редактором связей. Библиотека времени ис-
полнения  и  библиотечные  имена,  передаваемые  в командной
строке без определения каталога,  ищутся  в  LIB  каталогах.
Связь  между  текущим каталогом и маршрутом,  определенным в
LIB,  такая же, как и для указанной выше переменной INCLUDE;
если LIB определена,  то редактор связей будет просматривать
только эти каталоги. Если же LIB не определена, используется
только текущий каталог.

   Переменная TMP определяет, где компилятору следует созда-
вать свои временные файлы.  Если это возможно,  наиболее эф-
фективно, чтобы TMP ссылалась на RAM - диск. Если TMP не оп-
ределена,  то вместо нее используется переменная TEMP.  Если
ни одна из этих переменных не указана,  используется текущий
каталог.

   Например, если переменные окружения были установлены сле-
дующим образом:

   SET PATH=C:\ZORTECH\BIN

   SET INCLUDE=C:\ZORTECH\INCLUDE;C:\SOURCE

   SET LIB=C:\ZORTECH\LIB;C:\OTHERLIBS

приведенные ниже примеры являются корректными:

   #include <stdio.h>

Компилятор будет искать  stdio.h   в   C:\ZORTECH\INCLUDE  и
                                       C:\SOURCE.

   #include  "macros.c"

Компилятор будет искать macros.c в текущем каталоге, а затем
                           в C:\ZORTECH\INCLUDE и C:\SOURCE.

   ZTC  \NEWCODE\SOURCE.C  MYLIB.LIB

ZTC попытается   оттранслировать   и   скомпоновать   (link)
\NEWCODE\SOURCE.C. При компоновке ZTC будет искать библиоте-
ку MYLIB.LIB и библиотеку поддержки времени исполнения в ка-
талогах C:\ZORTECH\LIB и C:\OTHERLIBS.  Для  запуска  самого
ZTC и исполняемых компонент внутри ZTC вначале осуществляет-
ся  поиск  в  текущем   каталоге,   а   затем   в   каталоге
C:\ZORTECH\BIN. Поскольку ни TMP, ни TEMP переменные окруже-
ния не определены,  временные файлы компилятора создаются  в
текущем каталоге.



Переменная окружения  CFLAGS

   Переменная окружения CFLAGS используется ZORTECH  C++ для
стандартного  дополнения командной строки для ZTC по умолча-
нию, которая передается компилятору и редактору связей.
   Например, если CFLAGS установлен в

      SET CFLAGS = -w

(-w -  это  режим компилятора для подавления предупреждающих
сообщений),то предупреждающие  сообщения  будут  подавляться
при  исполнении  ZTC,  как если бы ключ -w был включен в ко-
мандную строку.


Установка системы на гибкие диски

      Хотя имеется возможность установки ZORTECH C++ на гиб-
      ких дисках (если Вы имеете достаточный  опыт),  мы  не
      рекомендуем делать этого.  Однако,  для тех, кто реши-
      тельно настроен это проделать, мы предлагаем следующую
      схему действий:

   Предлагается, чтобы  файлы  компилятора и системные файлы
заголовков размещались на диске "COMPILER" (компилятор). Ре-
дактор  связей и используемые библиотечные файлы для избран-
ной модели памяти  следует  разместить  на  отдельном  диске
"LINKER"  (редактор связей),  а редактор ZED и Ваши исходные
файлы - на третьем диске "DEVELOPMENT"  (разработка).  Такая
организация  неизбежно подразумевает переключение (swapping)
между дисками "COMPILER" и "LINKER" на устройстве A:,  в  то
время как диск "DEVELOPMENT" остается на устройстве B:.


  КОНТЕКСТНО  ЗАВИСИМЫЕ  ПОДСКАЗКИ  (CONTEXT SENSITIVE HELP)
  ──────────────────────────────────────────────────────────

Введение

   Программа ZTCHELP.COM обеспечивает  контекстно  зависимые
подсказки  для  ZORTECH  C  и C++.  Эта резидентная в памяти
программа написана на Zortech  C  и  использует  программные
средства  "быстрого реагирования" на клавиши (ZORTECH HOTKEY
TOOLKIT).

   Когда при редактировании программы Вы почувствуете  необ-
ходимость  заглянуть  в  Руководство,  хорошенько подумайте.
Просто разместите курсор на команде или функции,  по которой
требуется подсказка,  и нажмите на клавишу активизации подс-
казчика.  Резидентный подсказчик создаст окно на экране, за-
ботясь  о  том,  чтобы  не перекрывать указанную функцию,  и
представит Вам соответствующие страницы вспомогательной  ин-
формации из Руководства.

   После этого Вы можете просмотреть  информацию на экране и
даже запросить дальнейшую подсказку по любому связанному во-
просу.  Когда  Вы  соответствующим образом освежите Вашу па-
мять,  Вы можете вернуться в редактор и завершить программу,
зная, что помощь вызывается простым нажатием клавиши.


Конфигурирование системы

   Если Вы использовали  программу  ZTCSETUP  для  установки
Zortech C++ на жестком диске,  Вы должны были получить копию
ZTCHELP.COM в каталоге \ZORTECH\BIN.  По умолчанию  клавишей
вызова  этой программы является <ALT><H>.  Вам нет необходи-
мости реконфигурировать эту программу,  кроме случая,  когда
установленное умолчание является неудовлетворительным.

   Если Вы хотите изменить умолчания конфигурации,  Вам сле-
дует использовать программу ZTCHCONF.EXE,   которая распола-
гается на дискете N 5. Если Вы запустите программу и ответите
на ее вопросы,  она создаст  специально  приспособленную для
Вас версию ZTCHELP.COM,  которая станет резидентным подсказ-
чиком. Хотя ни в какой момент конфигурирования неустановлен-
ная версия Вашей программы не подвергается риску, всегда хо-
рошим правилом является защита всех дисков  перед их исполь-
зованием!  Элементами,  которые разрешается  приспосабливать
к своим нуждам, являются:

Быстрая командная клавиша  -  Какую  комбинацию  клавиш   Вы
   (HOTKEY)                   предпочитаете.

   Прерывание    - Система  Zortech  требует доступа к неис-
   (INTERRUPT)     пользуемому прерыванию. Вы можете выбрать
                   из диапазона от  0x70  до  0x7F.

   Характеристики - Информация о Вашем экране. Доступные оп-
   экрана           ции:
   (SCREEN CHARAC-  1. Разрешение программе  определять  тип
   TERISTICS)                                         экрана
                    2. Умолчания  для  цветного  дисплея
                    3. Умолчания  для  монохромного  дисплея
                    4. Определяет Ваши собственные  значения
                    Q. Выход

   Имена файлов   - Вы можете выбрать,  где расположить help
   (FILENAMES)      файлы:  ZTC.HLP, ZTC.HDX  и рабочий файл
                    TEMP.FIL

   После конфигурирования  HELP системы Вам следует скопиро-
вать новый ZTCHELP.COM файл в каталог, который указан в мар-
шруте PATH.


Установка системы

   Пропустите этот раздел, если Вы уже установили систему по-
мощи (HELP), используя  ZTCSETUP.

   Для запуска системы помощи Вам потребуются файлы  ZTC.HLP,
ZTC.HDX и отконфигурированная версия резидентного подсказчика
(ZTCHELP.COM).    Вам   не   нужны   файлы   ZTCHCONF.EXE  и
ZTCHELP.UNI.  Они могут остаться на дистрибутивном диске; Вы
затребуете их,  если  когда-либо будете менять конфигурацию.
Скопируйте ZTC.HLP  и  ZTC.HDX  в выбранное Вами место,  за-
тем скопируйте ZTCHELP.COM  в любой каталог.

   Замечание: Если Вы использовали ZTCSETUP.EXE для установ-
              ки  ZORTECH  C++,  программа  подсказчик  была
              передана  на  Ваш   жесткий  диск  в   каталог
              \ZORTECH\BIN.

   Вы можете решить загружать ZTCHELP  в  Вашем AUTOEXEC.BAT
файле или лишь перед сеансом с Зортехом; выбор за Вами!


Загрузка резидентного подсказчика

   Если  система  подсказок не устанавливается автоматически
AUTOEXEC.BAT файлом,  она может быть установлена резидентной
в памяти в любое  время.  Чтобы загрузить программу,  просто
введите: ZTCHELP. Сообщение об установке будет отображено на
экране для  подтверждения  командной  клавиши и типа экрана.
Если Вы попытаетесь перезагрузить программу, Вам будет сооб-
щено, что она уже резидентна в памяти.  После выдачи сообще-
ния об установке программы вновь появится подсказка DOS и Вы
можете продолжить работу с ZED и редактировать Ваши исходные
C файлы.


Удаление резидентного подсказчика

   В том случае,  если ZTCHELP была  последней установленной
резидентно в памяти программой,  она может быть удалена вво-
дом следующей команды в ответ на приглашение DOS:

   ZTCHELP /r

(Полагая, что ZTCHELP.COM находится в текущем каталоге или в
 каталоге, включенном в команду PATH).


Вызов подсказки

   Когда Вам потребуется помощь, просто разместите курсор на
(или рядом)  функции,  по которой требуется подсказка и наж-
мите на выбранную Вами "горячую" клавишу  вызова.  На экране
появится окно с соответствующей  подсказкой.  Если подсказка
не может быть найдена для указанной функции,  Вам будет дана
подсказка по теме,  ближайшей  тому слову, которое Вы ищете.
Если подходящий раздел подсказок найти не удалось, Вам будет
отображен на экран индексный указатель, который позволит Вам
двигаться в поисках  подходящей  подсказки.  Вместе с тем, в
HELP  системе Вы можете использовать  нижеследующие  клавиши
для движения по вспомогательной информации.


Сводный список клавиш

   Курсор влево/вправо/вверх/вниз
   (Cursor Left/Right/Up/Down)
   Страница  вверх/вниз            -  перемещения  по инфор-
   (Page up/down)                     мации и индексу.
   Home/End

   Ввод (Enter)                    -  вход на следующий уро-
                                      вень подсказок.

   Esc                             -  В  режиме   подсказки:
                                      выход с восстановлени-
                                      ем экрана.  В индексе:
                                      возвращает на предыду-
                                      щий  уровень  или при-
                                      ложения, или help фай-
                                      ла.

   F1                              -  В  режиме   подсказки:
                                      просто выход с чисткой
                                      окна.

   F10                             -  В  режиме   подсказки:
                                      вызывает окно  исполь-
                                      зуемых клавиш.

   F9                              -  Переходы  через  темы.

   ?                               -  В  режиме   подсказки:
                                      вход в индекс.



                           ОКРУЖЕНИЕ  РЕДАКТИРОВАНИЯ  -  ZED
                           ─────────────────────────────────



   ZED является интегрированным окружением  редактора/компи-
лятора, которое позволяет Вам редактировать  C  и C++  прог-
раммы и транслировать их из редактора. Это освобождает прог-
раммиста от цикла  редактирование/сохранение (редактируемого
файла) /трансляция/ и вновь редактирование,  что существенно
повышает производительность.  ZED  легок в использовании для
начинающих, но имеет и мощные средства,  чтобы быть полезным
для квалифицированных программистов. Те, кто постоянно поль-
зуется  редактором   WORDSTAR(TM),  найдет,  что большинство
команд WORDSTAR будет также работать и в ZED.

   В ZED можно  редактировать до 5 файлов одновременно и эти
файлы могут быть любого размера  (если только имеется доста-
точно установленной памяти на Вашей машине).

   ZED работает  на IBM (TM)  PC/XT/AT  и совместимых с ними
персональных компьютерах под управлением DOS версии 2.10 или
более поздней и требует как минимум  256 Кб  памяти (большая
память  требуется для редактирования  более чем одного файла
или для трансляции файлов из редактора).

   Если Вы использовали ZTCSETUP, ZED был установлен в стан-
дартной конфигурации и  должен  использоваться с каталоговой
структурой, созданной программой установки,  как это описано
в подробном руководстве по установке системы. Если Вы хотите
сделать свою версию  ZED,  пожалуйста,  посмотрите следующий
ниже параграф Конфигурирование.

   Вы имеете возможность научиться использовать ZED без того,
чтобы постоянно обращаться к Руководству. Бегло  просмотрите
это Руководство,  чтобы  получить некоторые идеи о том,  что
ZED может делать,  а затем испытайте их.  Используйте помощь
(F1) и меню до тех пор,  пока не найдете,  что они замедляют
Вашу работу.  Тогда  обращайтесь к клавишному выбору из меню
и/или списку альтернативных ключей для сокращения пути выпол-
нения некоторой работы.  Большинство функций  редактирования
может быть  выполнено одной или двумя  нажатиями на клавиши,
но, пока Вы не изучили быстрые комбинации клавиш, просто на-
жмите Esc, чтобы увидеть основное командное меню.



Вход в редактор

   Находясь в рабочем каталоге, наберите ZED и далее имя фай-
ла,    который    Вы    хотите    редактировать   (например,
ZED myprog.cpp). ZED допускает полные имена (pathnames), по-
этому Вы не ограничены при редактировании файлов текущим ка-
талогом. Экран будет выглядеть следующим образом:

Zed-Zortech Editor-Version 2.60   Press Esc for command menu
┌──────────────────────────────────────────────────────────┐
│  0:  1:  1 INSERT                        C:\MYPROG.C   1 │
│>────>─────>──────>────>────>────>─────>─────>─────>───── │
└──────────────────────────────────────────────────────────┘
<─
<─
<─
<─
─>     /*<─
─>     ─> ... ТЕКСТ ВАШЕЙ ПРОГРАММЫ <-
─>     /*<─
<─
<─
<─
││
││
││
││
││

   Первая строка  показывает  номер версии Вашей копии ZED и
напоминает  Вам,  что командное меню доступно при нажатии на
Esc. Эта строка используется также для строки меню (menu li-
ne).

   Вторая строка является строкой состояния и используется
для отображения состояния редактирования.

┌──────────────────────────────────────────────────────────┐
│  0:  1:  1 INSERT                          C:\MYPROG.C 1 │
│>────>─────>──────>────>────>────>─────>─────>─────>───── │
└──────────────────────────────────────────────────────────┘

   Первая цифра указывает общее число символов, набранных до
сих пор,  следующие две цифры указывают позицию курсора (но-
мер строки,  номер столбца).  Следующее  поле  заменяется на
число,  когда фиксируется клавишная макрокоманда или на 'P',
когда макрокоманда извлекается.

   INSERT означает, что все, что Вы вводите, будет вставлять-
ся  в позиции курсора.  OVERTYPE в этом месте  означает,  что
введенный текст будет поверх ранее введенного текста.

   AUTOINDENT  (автоматическая втяжка) может появиться в этой
строке, когда она включена (используя Shift Tab).

   Последние два поля  указывают на имя редактируемого файла
и номер буфера редактора ZED (ZED имеет 5 буферов, позволяю-
щих Вам редактировать до 5 файлов одновременно).

   Третья  строка  представляет  собой линейку со стрелками,
соответствующими позициям табуляции (tab).

   Вы можете также запустить ZED без каких-либо  параметров.
В этом случае имя файла будет "no file".  Когда отображается
"no file",  ZED позволяет Вам, если Вы хотите, редактировать
свои буфера в памяти, но в этом случае Вы должны будете ис-
пользовать команду EDIT (Esc F E  или Alt E) для того, чтобы
ZED мог автоматически сохранить их для Вас.

                 П Р Е Д У П Р Е Ж Д Е Н И Е

 ┌─────────────────────────────────────────────────────────┐
 │ Если Вы используете команду Read для считывания файла в │
 │ буфер и команду  Write  для  записи  буфера  обратно на │
 │ диск, ZED не будет автоматически сохранять для Вас ста- │
 │ рую копию и Вы можете легко по ошибке перезаписать цен- │
 │ ный для Вас исходный файл.                              │
 └─────────────────────────────────────────────────────────┘

   Write  и  Read  предназначаются  для записи частей буфера
в файл на диске и считывания их в другой файл,  или для под-
держки ряда стандартных функций, используемых с незначитель-
ными изменениями в нескольких исходных файлах.


Привязки клавиш

   Во всех последующих описаниях  команд  последовательности
клавиш  для  доступа к перечисленным командам даются в скоб-
ках.  Например, (Esc E R) означает нажать Esc (для доступа к
основному меню),  затем E (для меню редактирования) и R (для
функции восстановления).  Заметим также, что иногда Вам пот-
ребуется зажимать комбинацию клавиш. Комбинация клавиш обоз-
начается следующим образом:

   ^Q          - Нажать на клавишу  Q  при  зажатой  клавише
                 Control.

   ^Break      - Нажать на клавишу  Break  (часто помеченной
                 "Scroll Lock") при зажатой клавише Control.

   Alt+X       - Нажать на  клавишу  X  при  зажатой клавише
                 Alt.

   Shift+Tab   - Нажать на клавишу  Tab  при зажатой клавише
                 Shift.


Функциональные клавиши

   F1     HELP - Нажимать в любое время для вызова контекст-
                 но-зависимого подсказчика.

   F2     UNDO - Восстановление  последнего  удаленного Вами
                 текста.  ZED запоминает  до  100  удаленных
                 элементов    (максимум   10000   символов).
                 (Esc E R)

   F3     Вставка сохраненного блока буфера в позиции курсо-
          ра. (Esc B R)

   F4     Удаляет текст между курсором и TAG маркером, поме-
          щая его в буфере сохранения блока. (Esc B S)

   F5     Меняет местами TAG маркер и курсор. (Esc M T)

   F6     Помещает TAG маркер в позицию курсора. (Esc B T)

   F7     Поиск в прямом направлении  (текстовой строки, за-
          заданной Вами по Esc S F). (Esc S N)

   F8     Поиск в обратном направлении. (Esc S L)

   F9     Удаляет  строку от позиции  курсора до конца теку-
          щей строки.  Если  курсор находится в самом начале
          строки - удаляет всю строку и подтягивает последу-
          ющие строки,  чтобы заполнить пространство экрана.
          Если курсор находится в конце строки, присоединяет
          эту строку к следующей. (Esc D E)

   F10    Удаляет слово.  Если  курсор  указывает на пробел,
          удаляются все пробелы  до начала  следующего слова
          (или конца строки). (Esc D W)

   Вы можете  посмотреть  список  назначенных функциональных
клавиш нажатием F1 при редактировании.  Все эти функции (ис-
ключая HELP)  могут  быть также исполнены при помощи  меню -
- клавишные  выборы из меню  изображаются  в  скобках  после
каждой команды. Вы можете также использовать, если захотите,
ZCONFIG для изменения назначений этим  клавишам.


Клавиши управления курсором

Клавиши управления курсором используются  следующим образом:

   Left arrow    Перемещает  курсор  влево,  если  он не в 1
                 столбце.

   Right arrow   Перемещает курсор вправо, если он не в кон-
                 це строки.

   Up arrow      Перемещает курсор вверх на 1 строку.

   Down arrow    Перемещает курсор вниз  на 1 строку.

   Home          Перемещает  курсор в начало текущей строки.
                 (Esc M L)

   End           Перемещает  курсор в конец  текущей строки.
                 (Esc M R)

   Ctrl+Left     Перемещение влево на одно слово.

   Ctrl+Right    Перемещение вправо на одно слово.

   PgUp          Перемещает курсор вверх на 10 строк  (число
                 строк может быть изменено - смотрите раздел
                 по ZCONFIG).

   PgDn          Перемещает курсор вниз на  10  строк (число
                 строк может быть изменено - смотрите раздел
                 по ZCONFIG).

   Ctrl+Home     Перемещает курсор в начало экрана. (Esc M P)

   Ctrl+End      Перемещает курсор в конец экрана. (Esc M M)

   Ctrl+PgUp     Переход в начало файла. (Esc M S)

   Ctrl+PgDn     Переход к концу файла. (Esc M T)

   Ins           Переключение между режимами вставки (INSERT)
                 и замены (OVERTYPE).

   Del           Удаляет символ под курсором.

   Backspace     Если установлен INSERT режим,  удаляет сим-
                 вол слева от курсора. В OVERTYPE режиме
                 лишь перемещает курсор влево.

   Shift+Tab     Влючает/выключает   режим   'автоматической
                 втяжки' (auto-indent). (Esc E A)


           Заметим,  что многие из этих  функций  могут быть
           также  выполнены  с использованием  меню - выборы
           меню изображаются в скобках после каждой команды.

   Если Вы хотите,  то можете использовать ZCONFIG для изме-
нения этих назначений клавишам.


Клавиши, совместимые с системой Wordstar

   ┌───────────────────────────────────────────────────────┐
   │ (Заметим, что ^ означает удержание в нажатом состоя-  │
   │  нии  клавиши Control и нажатие на следующую клавишу) │
   └───────────────────────────────────────────────────────┘

   ┌───────────────────────────────────────────────────────┐
   │ Заметим,  что некоторые из этих  функций  могут быть  │
   │ также выполнены с использованием меню. Вы можете так- │
   │ использовать ZCONFIG, если пожелаете,  для изменения  │
   │ назначений этим клавишам.                             │
   └───────────────────────────────────────────────────────┘


   ^S    Перемещение на символ влево

   ^A    Перемещение на слово влево

   ^G    Удаление символа

   ^L    Повторяемые Поиск/Замена

   ^D    Перемещение на символ вправо

   ^F    Перемещение на слово влево

   ^T    Удалить слово

   ^Q    Вход в меню быстрых перемещений (quick move)

   ^E    Перемещение на строку вверх

   ^R    Перемещение на страницу вверх

   ^U    Удалить строку

   ^K    Вход в Block file меню

   ^X    Перемещение на строку вниз

   ^C    Перемещение на страницу вниз

   ^V    Переключение INSERT режима

   ^B    Форматировать часть текущего буфера


Прочие управляющие клавиши

   Остальные управляющие  клавиши  порождают  такие же коды,
как и прочие клавиши клавиатуры.

от ^F1 до ^F10    Фиксирует макрос для соответствующей функ-
                  циональной клавиши.  Запись  макроса может
                  также  производиться через Record меню, от
                  (Esc R 1) до (Esc R 0). При желании Вы мо-
                  жете  использовать  ZCONFIG  для изменения
                  этих назначений.

   ^Break         Прерывает все, что бы Вы не делали. Вы мо-
                  жете нажать Break в любой момент. Когда Вы
                  поступите так,  система ответит предупреж-
                  дающим сообщением  "Interrupted press Esc".
                  Нажатие  Esc вернет Вас в режим редактиро-
                  вания.

                  Если Вы нажмете ^Break во время сохранения
                  файла, файл не будет сохранен на диске.
                  Если Вы прервете загрузку файла или редак-
                  цию,  когда  часть файла была уже считана,
                  эта  часть  файла  останется  в  текстовом
                  буфере, но имя файла будет заменено на "no
                  file" и любая  попытка сохранить файл при-
                  ведет к запросу  нового  имени файла.  Это
                  предотвращает  Вас от случайного  усечения
                  файла.


Дополнительные клавиши (клавиши с Alt)

   Alt+A     Поиск строки,  игнорируя верхний/нижний регистр
             (cAse) (Esc S C)

   Alt+B     Перемещение к маркеру начала блока (Block)
             (Esc M B)

   Alt+C     Запуск компилятора (Compile) (Esc O O)

   Alt+D     Выход на формирование команды DOS (Esc O D)

   Alt+E     Редактирование файла (Edit) (Esc F E)

   Alt+F     Поиск (Find) строки (Esc S F)

   Alt+G     Повсеместная  (Global)  замена найденной строки
             (Esc S G)

   Alt+H     Зарезервирована  для  резидентного  подсказчика
             (help'а)

   Alt+I     Ввод (Input) (чтение)  файла в текст с позиции курсора
             (Esc F R)

   Alt+J     Перемещение  курсора  к  соответствующей  скоб-
             ке / концу блока (Esc M [)

   Alt+K     Перемещение к маркеру конца блока (blocK)
             (Esc M K)

   Alt+L     Установка левой (Left) границы

   Alt+M     Установка правой границы (Margin)

   Alt+N     Перемещение к строке, заданной номером (Number)
             в файле (Esc M N)

   Alt+O     Сравнить (cOmpare) два буфера (Esc O C)

   Alt+P     Распечатать (Print) часть буфера (Esc O P)

   Alt+Q     Выход (Quit) из текущего буфера редактирования,
             отказываясь от любых изменений (Esc F A)

   Alt+R     Замена (Replace) найденной строки (Esc F S)

   Alt+S     Сохранение (Save) текущей версии файла на диске
             (Esc F S)

   Alt+T     Установка длины табуляции (Tab) (Esc T T)

   Alt+U     Выравнивание (jUstify) C комментариев по право-
             му краю (Esc E C)

   Alt+V     Сохранение (saVe)  текущего  буфера и выход  из
             редактора  (^K X)

   Alt+W     Запись  (Write)   части буфера в файл (Esc F W)

   Alt+X     Выход в DOS (Esc F W)

   Alt+Y     Пометить начало блока (Esc B B)

   Alt+Z     Пометить конец блока (Esc B K)

   Alt+1     Редактировать буфер 1

   Alt+2     Редактировать буфер 2

   Alt+3     Редактировать буфер 3

   Alt+4     Редактировать буфер 4

   Alt+5     Редактировать буфер 5

   Alt+6     Не используется

   Alt+7     Не используется

   Alt+8     Не используется

   Alt+9     Перемещает текст влево на 1 позицию (Esc E -)

   Alt+0     Перемещает  текст  вправо  на  1 табуляцию
             (Esc E +)

   Все эти функции могут быть выполнены с использованием ме-
ню; выборы меню изображаются в скобках после каждой команды.
В предыдущих описаниях заглавные буквы объясняют, почему бы-
ла выбрана конкретная дополнительная клавиша для команды.

           Заметим, что эти назначения клавишам - всего лишь
           умолчания,  которые  используются автором ZED. Вы
           можете использовать  ZCONFIG  для их изменения по
           своему желанию.

   Мы советуем Вам после более  близкого  ознакомления с ZED
воспользоваться  ZCONFIG, чтобы установить  столько  клавиш,
сколько Вы можете запомнить, для наиболее часто используемых
Вами команд, так, чтобы у Вас лишь изредка возникала потреб-
ность пользоваться меню.

   Alt+F1 ... Alt+F10  извлекают макросы, записанные при по-
мощи ^F1 ... ^F10. Вы также можете использовать для извлече-
ния (Playback) выбор клавишного меню (Esc P 1) ... (Esc P 0).
Вы можете воспользоваться  ZCONFIG  для изменения назначений
этим клавишам по Вашему усмотрению.


Подсказки во время работы

   Когда Вы нажимаете F1,  появляется экран контекстно-зави-
симого подсказчика.  Этот  экран  обычно содержит по крайней
мере одну опцию-ссылку, которая  подсвечивается.  Чтобы пос-
мотреть другие страницы help'а, переместите курсор в позицию
опции-ссылки,  ссылающейся на требуемую  функцию  (используя
клавиши перемещения курсора, Home и End) и нажмите Return.

   Когда Вы прочитаете  экран(ы) подсказки,  нажмите  Escape
или F1, чтобы вернуться в то место,  где Вы до этого работа-
ли. Вы можете редактированием файла  ZED.HLP  изменить текст
подсказок (Смотрите ниже пункт "Файл подсказок"  в параграфе
"Конфигурирование").

   Этот файл  помощи  является  дополнением к резидентному в
памяти подсказчику по C++, который может быть вызван в любой
момент просто нажатием на Alt и который охватывает синтаксис
C++ и библиотечные функции.


О меню

   ZED имеет два типа меню.

   Меню-полоса (bar-menu) смотрится как список опций в верх-
ней части экрана,  с первой подсвеченной опцией.  Объяснение
текущей опции появляется во второй строке (часто лишь список
опций  подменю).  Для  выбора  подсвеченной опции нажмите на
Return.

   Для перемещения подсветки  используйте  клавиши  "стрелка
влево" и "стрелка вправо" или пробел и backspace.  Вы можете
заметить, что каждая опция имеет только одну заглавную букву
(обычно первую) - Вы можете выбрать  опцию   непосредственно
(без предварительного ее подсвечивания)  нажатием на клавишу
этой буквы.

   Вы можете также  вернуться из любого меню без осуществле-
ния выбора опции  нажатием на Escape. Заметим также, что та-
кие клавиши как функциональные,  управления курсором, управ-
ляющие и дополнительные клавиши,  которые  только перемещают
курсор  или  изменяют  текст,  все равно работают,  даже  из
меню-полосы.

   Оконные меню (window menus) раскрываются вниз в окно, за-
крывающее часть редактируемого Вами  текста.  Они имеют одну
опцию в строке и разъяснение по текущей (подсвеченной) опции,
появляющееся в последних двух строчках окна. Для выбора под-
свеченной опции нажмите на Return. Для перемещения подсветки
используйте клавиши управления  курсором  "стрелка вверх"  и
"стрелка вниз" или пробел и backspace.

   Как и в меню-полосе каждая  опция  имеет  только одну за-
главную букву (обычно первую) - Вы можете выбрать опцию  не-
посредственно (без  предварительного ее подсвечивания) нажа-
тием на клавишу этой буквы.  Вы  можете  также  вернуться из
любого меню, не сделав выбора,  нажатием на Escape.  Функци-
ональные, управления курсором,  управляющие и дополнительные
клавиши не работают из оконного меню.

   Вы можете использовать ZCONFIG для размещения оконных ме-
ню в любом месте экрана или для превращения  оконного меню в
меню-полосу  (и наоборот).  Вы обнаружите,  что хотя оконные
меню дают более детальные имена опций,  меню-полосы работают
быстрее и не ограничивают перемещения курсора.  Когда-нибудь
Вы лучше изучите  все меню  и  обнаружите,  что  превращение
всех меню в меню-полосы ускорит Вашу работу с ZED.


Главное меню

   Главное меню  ZED  становится  доступным  при  нажатии на
Escape. Опции главного меню следующие:

      File          Для сохранения текущего файла,  редакти-
                    рования нового файла(ов), чтения и запи-
                    си частей файлов и т.д.

      Move          Для быстрого перемещения курсора по фай-
                    лу.

      Edit          Для замены режима или  выполнения полез-
                    ных редактирующих операций, подобно UNDO,
                    замены режима прописных/строчных (upper/
                    lower)  букв и т.д.

      Blocks        Для пометки,  удаления,  копирования или
                    перемещения  блоков  текста или размеще-
                    ния невидимых маркеров в тексте, к кото-
                    рым позднее можно будет перемещаться.

      Delete        Для удаления текста.

      Search        Для поиска строк с возможной  заменой на
                    другую строку.

      Other         Разнообразные команды - Трансляция, Сбор-
                    ка, Сравнение файлов, Печать, другие DOS
                    команды, постоянное сохранение разных ус-
                    тановок редактора на диске.

      Record        Запись  последовательностей клавиш (key-
                    strokes)  в макрос  или файл.  Сохраняет
                    клавишные макросы на диске.

      Playback      Вызывает последовательности клавиш, запи-
                    санные по опции Record.

      Text          Установка  позиций  табуляции  и границ,
                    форматирование  параграфов и другие раз-
                    мечающие текст команды.

      1 - 5         Переход к буферу  1,2,3,4 или 5.  Каждый
                    из пяти  буферов  редактора может содер-
                    жать  отдельный файл,  так что Вы можете
                    одновременно редактировать некоторое чис-
                    ло независимых файлов с исходными текста-
                    ми программ. ZED запоминает для кажджого
                    буфера  позицию  курсора  и все  позиции
                    различных маркеров. Существует также ко-
                    манда   сравнения двух буферов,  которая
                    очень полезна  для  модификации  одним и
                    тем  же способом схожих исходных  файлов
                    или для выяснения того,  какие изменения
                    были  сделаны  в самой  последней версии
                    исходного файла.


Меню 'файлы' (Files)

   Когда файл уже  отредактирован,  предыдущая  версия файла
сохраняется для возможного восстановления  (backup).  Обычно
файл копии восстановления имеет то же  имя,  что и оригинал,
но с расширением  ".BAK".  Вы можете  использовать  ZCONFIG,
чтобы заставить ZED хранить все копии восстановления в одном
каталоге  (чтобы Вы могли легко удалить их,  когда израсходу-
ется дисковое  пространство);  в этом случае файл копии вос-
становления будет иметь то же имя, что и оригинал, но в ука-
занном  каталоге.  Эта опция особенно  удобна для исходных C
файлов,  когда  файлы  заголовков (.h) и исходные (.c) файлы
имеют одно имя,  но разные расширения,  поскольку полное имя
файла и расширение сохраняются в файле-копии.


      Edit          (Alt + E) Сохраняет  текущий  файл (если
                    он есть),  затем запрашивает на редакцию
                    новый файл. Если нужно, можете использо-
                    вать полное имя файла. Подробности ввода
                    имен файлов смотрите  ниже.  Вам следует
                    всегда использовать опцию  Edit,  хотите
                    ли Вы считать в память существующий файл
                    для  редактирования  или  создать  новый
                    файл.

      Save          (Alt + S)  Сохраняет все изменения, сде-
                    ланные до этого, на диске  и  продолжает
                    редактирование файла.  Эта команда отно-
                    сится к таким командам, которые (особен-
                    но при  сбое  по питанию)  Вы хотели бы,
                    чтобы исполнялись более часто.  Мы сове-
                    туем Вам использовать эту команду доста-
                    точно часто,  если Вы  добавляете  много
                    текста в файл, что в этом случае обосно-
                    вано.  Эта команда выполняется так,  как
                    если бы Вы сохранили файл и вновь вызва-
                    ли его на редакцию, так что будет созда-
                    ваться копия  восстановления,  с потерей
                    любой предыдущей  копии.  Эта команда не
                    влияет на позицию курсора.

      Abort         (Alt + Q)  Отказывается от любых измене-
                    ний, сделанных в текущем буфере с момен-
                    та последнего сохранения и чистит буфер.
                    Если Вы  меняли  буфер,  Abort  запросит
                    подтверждения, прежде чем уничтожить все
                    изменения.

      Read          (Alt + I)  Считывает  содержимое файла в
                    буфер, в позицию  курсора.  Эта  команда
                    предназначается для включения одного фай-
                    ла в другой или для создания нового фай-
                    ла на основе  существующего файла,  но с
                    другим именем.


      Write         (Alt + W)  Записывает часть текущего бу-
                    фера на диск.  Эта команда удобна, когда
                    Ваш исходный файл  становится громоздким
                    и Вы хотите разделить его  на  различные
                    части, или, когда Вы хотите извлечь нес-
                    колько функций из исходного  файла.  Она
                    также полезна, если Вы решите, что хоти-
                    те оставить Ваш исходный файл неизменен-
                    ным, но сохранить отредактированную вер-
                    сию его под другим именем.

                    Когда Вы выбрали Write и ввели имя файла
                    для записи,  Вам показывается меню "раз-
                    мер" (Size),  так что Вы сможете решить,
                    какую часть буфера записать в файл.

      eXit          (Alt + X)  Пытается  завершить редактор.
                    Если какой-либо  буфер  редактировался с
                    момента последнего сохранения, отобража-
                    ет каждый такой буфер и запрашивает Вас,
                    хотите ли  Вы  сохранить  его. Ответ 'y'
                    или  Return  сохранит  буфер и продолжит
                    работу. Ответ  'q' проигнорирует все из-
                    менения,  которые  делались в буфере,  и
                    продолжит  работу.  Любой  другой  ответ
                    возвращает в режим  редактирования. Если
                    ни один из  буферов  не был изменен либо
                    Вы ответили 'y', Return,  или 'q' на все
                    вопросы, - выход из редактора (возвраща-
                    ясь в DOS).


      1 - 5         (от Alt + 1  до  Alt + 5)   Смена буфера

   Быстрые клавиши,  которые  соответствуют  этим  командам,
изображаются  в скобках,  следующих за каждой командой.  Эти
клавиши могут быть изменены в ZCONFIG.

   Когда ZED загружает файл, он отображает первый экран фай-
ла по мере его загрузки,  но продолжает загрузку до тех пор,
пока не загрузится весь файл. На время загрузки высвечивает-
ся сообщение: "Загрузка файла"  ("Loading file"), за которым
идет имя файла.

   Если Вы измените свое намерение во время загрузки длинно-
го файла, Вы можете нажать Control-Break для прерывания заг-
рузки. Если Вы сделаете так,  то часть файла останется в бу-
фере.


   Ввод имен файлов

   Имя файла, используемое последним, представляется в каче-
стве умолчания. Для использования этого имени нажмите Enter.
Вы можете также редактировать имя файла аналогично редактиро-
ванию буфера следующим образом:

      F1               Показать подсказку.

      Стрелка влево    Перемещает  курсор влево на 1 символ.

     ^Стрелка влево    Перемещает  курсор влево на 1  слово.

      Стрелка вправо   Перемещает курсор вправо на 1 символ.

     ^Стрелка вправо   Перемещает курсор вправо на 1  слово.

      Home             Перемещает  курсор  в  начало строки.

      End              Перемещает  курсор  в   конец строки.

      Del              Удаляет   символ  в  позиции курсора.

     ^T или F10        Удаляет   следующее   слово.

      F9               Удаляет  строку от позиции курсора до
                       конца строки.

     ^Y                Удаляет всю строку.

      Return           Ввод строки.

      Ins              Переключение режима вставки (Insert).
                       В режиме вставки  курсор  меняется на
                       мигающий подчерк.  Все,  что бы Вы не
                       ввели, будет оставляться, сдвигая ос-
                       тальные символы вправо. В обычном ре-
                       жиме (перезаписи - overtype),  курсор
                       меняется на подсвеченный  прямоуголь-
                       ник. Все, что бы Вы не вводили, будет
                       заменять символ под курсором.

      Esc            Прекращает  выполнение текущей команды.

      Backspace      Если  курсор  находится  в конце строки
                     или установлен режим вставки  (курсор -
                     - мигающий подчерк),  Backspace удаляет
                     символ слева  от  курсора.  В противном
                     случае Backspace лишь перемещает курсор
                     на 1 символ влево.

         Заметим, что, если Вы хотите набрать совершенно дру-
         гую строку,  нажмите вначале F9 или ^Y  для очистки
         умолчания.  Если Вы забудете сделать это,  и старая
         строка длиннее,  чем новая,  Вам следует нажать F9,
         прежде чем нажать на Return, чтобы очистить послед-
         ние несколько символов, оставшихся от старой строки.

   В любой момент времени, когда у Вас запрашивается имя фай-
ла, Вы можете ввести недоопределенное имя (например, *.* или
\include\*.h и т.д.).  На экране будет изображен список всех
файлов, удовлетворяющих такому имени.  После этого Вы можете
использовать клавиши управления  курсором для перемещения по
списку и нажать на  Return  при выборе требуемого Вам файла.
Вы можете также нажать  на  Esc,  чтобы  вернуться к запросу
имени файла и ввести другое имя файла.


   Меню "размер" (Size)

   Функция Write  работает с частью  буфера - меню  "размер"
позволяет Вам выбрать, с какой именно частью:

      Word           От позиции курсора до конца  следующего
      (слово)        слова.

      End of line    От  позиции  курсора  до конца  текущей
      (конец строки) строки.

      Line           Вся текущая строка.
      (строка)

      Paragraph      От позиции курсора до ближайшей, полно-
      (абзац)        стью пустой строки.

      Block          Помеченный блок.
      (блок)

      Tag            Все, что между курсором и TAG маркером.
      (тэг)

      ]              Все между курсором и следующей соответ-
                     ствующей скобкой '}'.

      All buffer     Весь буфер.
      (весь буфер)

      No of lines    Определяет  сколько  строк  писать.
      (число строк)


Меню "перемещение курсора" (moves)

      Left           (  Home) Перемещает   курсор  в  начало
                              текущей строки.

      toP            (^ Home) Перемещает   курсор  в верхнюю
                              часть экрана.

      Start          (^ PgUp) Перемещает   курсор  в  начало
                              файла.

      Right          (  End)  Перемещает  курсор в конец те-
                              кущей строки.

      bottoM         (^ End)  Перемещает   курсор  в  нижнюю
                              часть экрана.

      End            (^ PgDn) Перемещает курсор в конец фай-
                              ла.

      Number         (Alt+N)  Запрашивает номер строки и за-
                              тем  перемещает  курсор  в эту
                              строку.

      Tag            ( F5 )   Меняет местами  курсор  и  TAG
                     маркер. Каждый буфер редактора ZED име-
                     ет TAG маркер,  который  может быть ис-
                     пользован  для перемещения вперед и на-
                     зад между двумя местами в буфере - ког-
                     да Вы нажимаете F5 (или Esc M T), TAG и
                     курсор меняются местами, так что повтор-
                     ное нажатие на F5 (Esc M T)  возвращает
                     Вас туда, где Вы были. TAG маркер может
                     быть также  использован  в качестве ог-
                     раничителя блока (весь текст между кур-
                     сором и TAG  маркером считается блоком).
                     Для установки TAG маркера  используется
                     F6 или смотрите меню Blocks.

      [              (Alt + J) Если курсор находится на скоб-
                     ке  (, ), [, ], {, }, - перемещает кур-
                     сор в соответствующую закрывающую скоб-
                     ку.  В противном случае перемещает кур-
                     сор в конец  текущего  блока  программы
                     (ограниченного скобками { и } ).
                     Это средство полезно при определении то-
                     го,  когда  переменная  выходит  за  об-
                     ласть своего действия.  Для этого просто
                     поместите  курсор на объявление перемен-
                     ной и нажмите (Alt + J).

      Block          (Alt + B)  Перемещает  курсор к маркеру
                     начала блока. Для установки маркера на-
                     чала блока используйте  (Alt + Y), либо
                     смотрите меню Blocks.

      blocK          (Alt + K)  Перемещает  курсор к маркеру
                     конца блока. Для установки маркера кон-
                     ца блока  используйте  (Alt + Z),  либо
                     смотрите меню Blocks.

      1 - 9          Перемещает  курсор к невидимому нумеро-
                     ванному в диапазоне  от 1 до 9 маркеру.
                     Для  установки  маркера  смотрите  меню
                     Blocks.   Заметим,  что  перемещение  к
                     маркеру является  единственным способом
                     узнать, где он находится.

   Быстрые клавиши,  которые  соответствуют  этим  командам,
изображаются в скобках,  следующих за каждой  командой.  Эти
клавиши могут быть изменены с помощью ZCONFIG.


Меню "редакция"  (Edit)

      Insert         Установка режима вставки  (Insert). Лю-
                     бые символы,  которые Вы введете, будут
                     вставляться в позиции курсора.  Нажатие
                     на Enter вставляет новую строку. Вы мо-
                     жете также  использовать клавишу  (Ins)
                     или (^V) для переключения между режима-
                     ми вставки  и 'перезаписи'  (Overtype).
                     ZED помнит,  какой режим является теку-
                     щим.

      Overtyp        Установка режима 'перезаписи' (Overtype).
                     Любые символы,  которые Вы введете, бу-
                     дут заменять символы в позиции курсора,
                     за исключением случая, когда Вы находи-
                     тесь  в конце  строки;  в этой ситуации
                     символы будут добавляться к строке.
                     Нажатие на Enter лишь перемещает курсор
                     на следующую строку. Вы можете также ис-
                     пользовать  клавишу (Ins) или (^ V) для
                     переключения режимов  вставки и переза-
                     писи.

      Rest           (F2)  Восстанавливает последний удален-
                     ный элемент в позиции курсора. Редактор
                     помнит до  100  удаленных элементов (до
                     10000  символов)  и Вы можете  взять их
                     все назад,  нажимая на F2.  Эта команда
                     полезна   для   перемещения  небольшого
                     текста в буфере (удаляете текст,  затем
                     перемещаетесь туда,  куда хотите помес-
                     тить текст,  и  затем  восстанавливаете
                     удаленное),  а также и для  исправления
                     ошибок.

      Lower          Преобразует часть  буфера к нижнему ре-
                     гистру  (lower  case).  При выборе этой
                     команды  Вам  предъявляется  меню Size,
                     и Вы можете решить,  какую часть буфера
                     преобразовать  к нижнему  регистру.  По
                     умолчанию  в  этом  меню   используется
                     Word - остаток текущего слова.

      Upper          Преобразует часть  буфера в верхний ре-
                     гистр (upper case). При выборе этой ко-
                     манды Вам  предъявляется  меню  Size, и
                     Вы  можете решить, какую  часть  буфера
                     преобразовать к верхнему  регистру. Оп-
                     цией умолчания  в  этом  меню  является
                     Word - остаток текущего слова.

      Graphic         Вставляет  специальный ASCII графичес-
                      кий символ в позиции курсора.  Эта ко-
                      манда используется  для вставки графи-
                      ческих  символов и печати  управляющих
                      символов.   Вы можете  вставить  любую
                      ASCII литеру, кроме следующих:

                      0     Null  символы запрещены  в  ZED.

                      9     Это символ табуляции  (ТАB),  он
                            вставляется клавишей ТАB.

                      10    Символ  перевода  строки   (line
                            feed) - определяет конец строки.

                      13     Символ возврата  (Return) - оп-
                             ределяет конец строки.

                      26     Символ конца файла  (EOF) - оп-
                             ределяет конец файла.

                      Посмотрите руководство по Вашему прин-
                      теру для уточнения  управляющих  кодов
                      принтера.

      Setseg          Инициализирует последовательный номер.
                      Смотрите команду seQuence.

      seQuence        Вставляет текущее значение порядкового
                      номера в текст и увеличивает его значе-
                      ние. Эти две смежные команды  полезны,
                      если Вы хотите список последовательных
                      чисел (например, список #define). Вна-
                      чале,  при помощи (Esc E S) устанавли-
                      вается  первоначальное значение после-
                      довательному   номеру   (например, 1).
                      После этого  Вы можете определить мак-
                      рос  (например)  следующими  клавишами
                      (End Esc E Q  Down), и oн будет встав-
                      лять последовательные  номера  в конец
                      каждой  строки  всякий  раз,  когда Вы
                      исполните его.

      Comment         (Alt + U)  Выравнивает по правому краю
                      и завершает  C  комментарий  в текущей
                      строке. Эта команда помогает легко вы-
                      равнять все Ваши комментарии по право-
                      му краю, чтобы они смотрелись аккурат-
                      но и приятно для глаз. Команда работа-
                      ет только с однострочными комментария-
                      ми.  Вам никогда не надо набирать зак-
                      рывающих  */ ,  команда  автоматически
                      поставит их,  если этих  символов нет.
                      Если в текущей строке нет открытия ком-
                      ментария /* , команда ничего не делает.
                      Если Вы не установили  правую  границу
                      (используя Esc T R), по умолчанию пред-
                      полагается 79 позиций.

      +               (Alt + 0) Перемещает часть буфера впра-
                      во на одну позицию табуляции. При выбо-
                      ре этой команды Вам предъявляется меню
                      Size, так что Вы можете решить,  какую
                      часть  буфера  перемещать.  Опцией  по
                      умолчанию  является [ - остаток  теку-
                      щего C блока (заканчивающегося }).

      -               (Alt + 9) Перемещает часть буфера вле-
                      во на одну позицию табуляции. При выбо-
                      ре этой команды Вам предъявляется меню
                      Size,  так что Вы можете решить, какую
                      часть  буфера  перемещать.  Опцией  по
                      умолчанию  является [ - остаток  теку-
                      щего C блока (заканчивающегося }). Эти
                      команды  полезны для аккуратной втяжки
                      блоков C программ, когда Вы добавляете
                      новую пару фигурных скобок в некоторый
                      существующий текст программы.

   Последние две команды могут прерываться по Control-Break.

      Auto            (Shift Tab)  Включает/выключает 'режим
                      автоматической  втяжки' (Auto-indent).
                      Режим  автоматической втяжки вставляет
                      пробелы и табуляции в начало каждой но-
                      вой строки и она выравнивается по пре-
                      дыдущей строке.  Это полезно, когда Вы
                      пишете некоторый новый текст программы
                      внутри установленных  фигурных  скобок
                      так,  что  он аккуратно  выравнивается
                      для отражения логики программы.  Авто-
                      матическая  втяжка  добавляет  пробелы
                      и/или символы  табуляции  всякий  раз,
                      когда Вы нажимаете на клавишу <Return>.
                      Если Вы  просто  набираете непрерывный
                      текст (подобно этому руководству), ис-
                      пользуя    форматтер,   автоматическая
                      втяжка не нужна. ZED  запоминает уста-
                      новку  режима  автоматической втяжки с
                      момента последнего использования.

      1 - 5           Изменяет номер буфера  редактирования.

   Быстрые клавиши, соответствующие этим командам, изобража-
ются в скобках следом за каждой командой.  Эти клавиши могут
быть изменены в ZCONFIG.


   Меню "размер" (Size)

   Команды  Lower,  Upper, + и - работают  с частью буфера -
меню "размер" Size позволяет  Вам  выбрать,  с  какой именно
частью:

      Word            От позиции курсора до конца следующего
                      слова.

      End of line     От позиции  курсора  до конца  текущей
                      строки.

      Line            Вся текущая строка.

      Paragraph       От позиции курсора до следующей пустой
                      строки.

      Block           Помеченный блок.

      Tag             Все между  курсором  и  TAG  маркером.

      ]               Все  между  курсором и следующей соот-
                      ветствующей '}'.

      All buffer      Весь буфер.

      No of liner     Определяет, сколько строк преобразовы-
                      вать/перемещать.


Меню "блоки" (Blocks)

      Block           (Alt + Y) Помещает маркер начала блока
                      в позиции курсора.

      blocK           (Alt + Z) Помещает маркер  конца блока
                      в позиции курсора.  Эти маркеры блоков
                      используются  в качестве  альтернативы
                      TAG  маркеру для пометки области текс-
                      та.  При использовании  TAG  маркера и
                      курсора в качестве ограничителей блока,
                      работа происходит быстрее, но Вы може-
                      те использовать  маркеры  блока,  если
                      Вам с ними удобнее.  Обычно, когда оба
                      маркера  блока   размещены  в  тексте,
                      блок подсвечивается. При желании Вы мо-
                      жете убрать подсветку  (смотрите опцию
                      Hilite).

      Delete          Удаляет текущий  помеченный блок и по-
                      мещает его в буфер хранения блока. Бу-
                      фер хранения используется для всех пе-
                      ремещений блока и всегда  содержит ко-
                      пию последнего удаленного, скопирован-
                      ного,  перемещенного  или  сброшенного
                      Вами блока.  Но прежде Вы должны иметь
                      помеченный Вами с помощью  (Esc B B) и
                      (Esc B K) блок.

      Move            Удаляет текущий помеченный  блок и по-
                      мещает его в буфер  хранения,  а затем
                      копирует буфер  хранения в текст в по-
                      зиции курсора. Прежде, чем эта команда
                      будет работать,  Вам  необходимо иметь
                      отмеченный   с  помощью   (Esc B B)  и
                      (Esc B K) блок.

      Copy            Копирует текущий помеченный блок в бу-
                      фер хранения,  а затем  копирует буфер
                      хранения  в  текст в позиции  курсора.
                      Прежде, чем эта команда будет работать,
                      Вам необходимо иметь помеченный с помо-
                      щью (Esc B B)  и (Esc B K) блок.  Если
                      Вам нужно более одной копии,  то, либо
                      повторите эту команду, либо просто на-
                      жмите F3 для каждой последующей копии.

      Save            (F4) Удаляет весь текст между курсором
                      и TAG маркером и помещает  его в буфер
                      хранения. Самый быстрый способ для ко-
                      пирования или перемещения блоков текс-
                      та следующий: Переместите курсор в на-
                      чало блока и нажмите  F6 - TAG  маркер
                      установится в позиции  курсора.  Пере-
                      местите курсор в конец блока и нажмите
                      F4 - блок  исчезнет.  Если  Вы  хотите
                      скопировать   блок  (а не  переместить
                      его), сразу же нажмите F3 - блок вновь
                      появится.  Переместите курсор в нужную
                      позицию и нажмите  F3 - блок  появится
                      вторично.  Если  Вам  необходимо более
                      одной копии,  просто нажимайте клавишу
                      F3 для каждой следующей копии.

      Restore         (F3) Копирует буфер хранения блока об-
                      ратно в текст в позиции курсора.

      Tag             (F6) Помещает TAG маркер в позиции кур-
                      сора. Заметим,  что  F5 меняет местами
                      TAG маркер и курсор, так что Вы можете
                      увидеть, где находится TAG маркер.

      Hilite          Переключает  изображение текущего бло-
                      ка на инверсное. Обычно, когда оба мар-
                      кера размещены в тексте,  блок изобра-
                      жается подсвеченным. Эта команда вклю-
                      чает или выключает эту подсветку.  ZED
                      запоминает, использовалась ли подсвет-
                      ка с момента последней работы с редак-
                      тором.

      Yank            Сбрасывает  (копирует)  часть текста в
                      буфер хранения  блока,  без  изменения
                      текста.  Переводит Вас в меню Size для
                      определения  того,  какую часть текста
                      требуется сбросить. Вы можете вставить
                      этот текст в любом буфере редактирова-
                      ния в позиции курсора  нажатием на  F3
                      (или Esc B R). Эта команда, в частнос-
                      ти,  полезна  для  перемещения  блоков
                      текста  из  одного  файла в другой без
                      изменения файла источника.

      1 - 9           Размещает невидимый маркер (от 1 до 9)
                      в позиции курсора. Вы можете вернуться
                      к этому маркеру, используя соответству-
                      ющий  выбор в меню  "перемещение курсо-
                      ра" (Moves), от (Esc M 1) до (Esc M 9).

   Быстрые клавиши, которые соответствуют этим командам, изо-
бражены в скобках после  каждой  команды.  Эти клавиши могут
быть изменены ZCONFIG'ом.



Меню "удаление" (Delete)

   Вы  можете  удалить  любую  часть  буфера.  Какую  именно
часть - зависит от Вашего выбора в меню "размер" (Size):

      Word            (F10) От позиции курсора до конца сле-
                      дующего слова.

      End of line     (F9) От позиции курсора до конца теку-
                      щей строки.

      Line            (^ Y) Всю текущую строку.

      Paragraph       От позиции курсора до следующей пустой
                      строки.

      Block           Помеченный блок.

      Tag             Все, что между курсором и TAG маркером.

      ]               Все, что  между  курсором  и следующей
                      соответствующей '}'.

      All buffer      Удаляет весь буфер (БУДЬТЕ ОСТОРОЖНЫ -
                      - Вы можете не восстановить (UNDO) его.

      No of lines     Определяет, сколько строк удалять (на-
                      чиная  со строки.  где расположен кур-
                      сор). Вы можете не восстановить (UNDO)
                      их, если удалите слишком много строк.


   Быстрые клавиши, соответствующие этим командам, изобража-
ются в скобках,  следующих за каждой  командой.  Эти клавиши
могут быть изменены  ZCONFIG'ом.  Все, что Вы удаляете, хра-
нится в UNDO стеке и может быть восстановлено нажатием F2 или
(Esc E R).

      Если удаляется какой-либо блок, больший 10000 символов,
      то он не может быть восстановлен.



Меню "поиск" (Search)

      Find       (Alt + F)  Задает искомую строку. ZED запо-
                 минает эту строку,  пока Вы не измените ее,
                 так что повторные поиски легко осуществимы.
                 Эта команда  только  задает  строку поиска,
                 чтобы  действительно  найти ее,  необходимо
                 нажать на  F7 (поиск в прямом  направлении)
                 или F8 (поиск в обратном направлении).

      Case       (Alt + A)  Задает строку поиска  (игнорируя
                 различия  нижнего/верхнего  регистра).  ZED
                 запоминает эту строку,  пока Вы не измените
                 ее, так что повторные поиски легко осущест-
                 вимы.  Эта команда только задает строку по-
                 иска, чтобы действительно найти ее, необхо-
                 димо нажать на F7 (поиск в прямом направле-
                 нии) или F8 (поиск в обратном направлении).

      Next       (F7)   Поиск  следующего  появления  строки
                 (поиск в прямом  направлении).  Прежде  чем
                 использовать эту команду,  Вам  следует за-
                 дать строку поиска, используя указанные вы-
                 ше команды Find и Case.

      Last       (F8)  Поиск  предыдущего  появления  строки
                 (поиск в обратном направлении).  Прежде чем
                 использовать  эту команду,  Вам следует за-
                 дать строку поиска, используя указанные вы-
                 ше команды Find и Case.

      Replace    (Alt + R)  Заменяет найденный  элемент дру-
                 гой строкой.  Замещающая строка будет у Вас
                 запрашиваться. Если курсор  уже находится в
                 позиции строки поиска, она тут же будет за-
                 менена. В противном случае нажмите F7 или F8
                 для поиска строки, после чего Вы будете оп-
                 рошены о том, хотите ли Вы заменить найден-
                 ную строку.  Нажмите 'y' (или Enter), чтобы
                 заменить  строку  и  любую  другую клавишу,
                 чтобы избежать замены.

      Global     (Alt + G)   Замена по всей оставшейся части
                 файла (автоматически,  без запросов об уда-
                 лении).  Замещающая строка будет у Вас зап-
                 рашиваться. Если курсор уже находится в по-
                 зиции строки поиска, она тут же будет заме-
                 нена, как и все остальные строки,  от пози-
                 ции курсора  до  начала или конца  файла (в
                 зависимости от установки  поиска в обратном
                 или прямом направлениях).  В противном слу-
                 чае нажмите F7  или  F8  для поиска строки,
                 после чего Вы будете опрошены о том, дейст-
                 вительно ли Вы хотите повсеместно  заменить
                 строку.  Нажмите на 'y' (или Enter),  чтобы
                 осуществить замену или на любую другую кла-
                 вишу, чтобы оставить файл без изменения.

      eXit       Возврат к редактированию.

   Быстрые клавиши, соответствующие этим командам, изобража-
ются в скобках,  следующих за каждой  командой.  Эти клавиши
могут быть изменены ZCONFIG'ом.  Если Вы хорошо знаете Word-
star, Вы можете использовать команды  Wordstar  для поиска и
замены (^Q F  или  ^Q A).  Команды поиска могут быть прерва-
ны по Control-Break.


   Ввод строк

   Последняя  используемая строка  представляется в качестве
умолчания. Чтобы использовать ее,  нажмите Enter.  Вы можете
также редактировать строку следующим образом:

       F1             Отображает подсказку.

       Стрелка влево  Перемещает курсор  влево на 1 позицию.

      ^Стрелка влево  Перемещает  курсор  влево  на 1 слово.

       Стрелка вправо Перемещает курсор вправо на 1 позицию.

      ^Стрелка вправо Перемещает курсор  вправо  на 1 слово.

       Home           Перемещает  курсор  в  начало  строки.

       End            Перемещает  курсор   в  конец  строки.

       Del            Удаляет  символ   в  позиции  курсора.

      ^T или F10      Удаляет следующее слово.

       F9             Удаляет символы от позиции  курсора до
                      конца строки.

      ^Y              Удаляет всю строку.

       Return         Принимает  строку в том виде,  как она
                      изображена  (безотносительно того, где
                      находится курсор).

       Ins            Переключение режима вставки.  В режиме
                      вставки курсор заменяется на мерцающий
                      или на подчерк. Все, что Вы набираете,
                      будет  вставляться,  сдвигая остальные
                      символы  вправо.   В  обычном   режиме
                      (перезаписи) курсор заменяется на под-
                      свеченный  прямоугольник.

       Esc            Сбрасывает текущую команду.

       Backspace      Если  курсор  находится в конце строки
                      или установлен режим  вставки (мерцаю-
                      щий  курсор  или  подчерк),  Backspace
                      удаляет  символ  слева  от  курсора. В
                      противном случае  Backspace лишь пере-
                      мещает курсор влево на 1 позицию.

      ЗАМЕЧАНИЕ:  Если Вы хотите  набрать  совершенно другую
      строку, нажмите вначале на F9  или ^Y для сброса умол-
      чания.  Если Вы забыли сделать  это,  и старая  строка
      длиннее новой,  Вам  следует  нажать  F9 до нажатия на
      Return,  чтобы убрать последние  несколько символов,
      оставшихся от старой строки.


Меню "прочее" (Other)

      cOmpile      (Alt+C)  Транслирует программу из буфера.
                   Вы имеете возможность транслировать файлы
                   только с расширениями  ".c"  или  ".cpp".
                   Более подробную  информацию по компиляции
                   смотрите ниже.

      Compare      (Alt+O)  Дает  Вам  возможность  сравнить
                   содержимое любых двух буферов. Просто вы-
                   берите  номер  буфера,  с которым  хотите
                   сравнить текущий буфер. Сравнение начина-
                   ется с текущей  позиции  курсора в каждом
                   буфере и завершается при первом  отличии.
                   Если  Вы заметили  различие и хотите про-
                   должить сравнение, просто переместите кур-
                   сор в каждом буфере так, чтобы они указы-
                   вали на  одинаковые  символы  и повторите
                   сравнение. Команда сравнения может преры-
                   ваться по Control-Break.

      DOS          (Alt+D)  Запускает программу  DOS и потом
                   возвращает  к  редактированию.  Вы можете
                   даже запустить копию командного процессо-
                   ра DOS (когда Вы получите A> или C> приг-
                   лашение) введением пустого имени програм-
                   мы (запустите DOS команду  EXIT для возв-
                   рата  в редактор,  если Вы сделаете так).
                   Эта команда  не работает  с версиями  DOS
                   более ранними,  чем версия 2.10.  Если Вы
                   запускаете  DOS версии  2 или  3 и все же
                   имеете неприятности с этой командой, пос-
                   мотрите ниже замечание по COMSPEC.

      Print        (Alt+P)   Печатает   часть  буфера - меню
                   "размер" (Size) выбирает, какую часть бу-
                   фера печатать. Команда print может преры-
                   ваться по Control-Break.

   Быстрые командные клавиши, которые соответствуют этим ко-
мандам, изображаются в скобках, следующих за каждой командой.
Эти клавиши могут быть изменены с помощью ZCONFIG.


   Ввод строк

   Ввод строки режимов компиляции,  параметров команды DOS и
и пр. производится так же, как описано в меню "Search", под-
раздел "Ввод строк".


Компиляция (Compiling)

   Как только Вы выбрали опцию компиляции,  Вы можете ввести
любые ключи компилятора.  Для большинства программ Вам вовсе
не потребуются какие-либо ключи,  так что  Вы можете  просто
нажать на Return.

   Для более подробной информации о допустимых  ключах смот-
рите раздел о компиляторе. Кратко ключи таковы:

      -b        Используется большой (Big) компилятор.

      -v        Многословный (Verbose) вывод из компилятора.

      -c        Только компиляция (Compile) (без редакции
                связей).

      -r        Создает код для ПЗУ (ROM-read-only memory).

      -did=tx   #define id tx.

      -s        Включается проверка переполнения стека
                (Stack).

      -e        Показывает действие  (Effect) препроцессора.

      -u        Подавляет автоматические (aUtomatic) макросы.

      -llist    Создает файл листинга (List) с именем list.

      -w        Подавляет предупреждающие  (Warning) сообще-
                ния об ошибках.

      -ipath    Поиск включаемых (Include) файлов по маршру-
                ту path.

      -p        Отключает автопрототипирование.

      -O        Оптимизация - требует больших накладных рас-
                ходов.

      -O-sw     Отключает   режимы  оптимизатора  (например,
                -O-dc).

      -O+sw     Включает   режимы  оптимизатора   (например,
                -O+space).

      -f        Порождает код для 8087.

      -ofile    Вывод (Output) в файл file.

      -j        Используются символы азиатского языка.

      -a        Нет ограничений  выравнивания  (Alignment) в
                структурах.

      -J        умолчание для литерных (char) - беззнаковый
                (unsigned).

      -C        Включение  информации  отладчика  Codeview в
                EXE файл.

      -B        Запуск программы  BUNCH по завершении редак-
                тора  связей  (необходимо  использовать этот
                ключ при сборке MSLINK'ом программ на C++).

      -g        Включает  информацию о номерах  строк в .obj
                файл и создает .map файл.

      -kfile    После  компиляции  программы (но не сборки),
                запускает  MAKE,  используя  file в качестве
                командного  (project)  файла  (по  умолчанию
                makefile).

      -Kfile    Аналогичен -k, но без предварительной компи-
                ляции программы.

      -m<m>     Устанавливает  модель  (памяти) - <m>  может
                быть одним из :

                   S   Малая (Small) модель.

                   SI  Малая модель с только целой (Integer)
                       арифметикой.

                   I   Малая модель с только целой арифмети-
                       кой.

                   T   Тонкая  (Tiny) модель (COM файл).

                   TI  Тонкая  модель с только целой арифме-
                       тикой.

                   M   Средняя (Medium) модель.

                   MI  Средняя модель с только целой арифме-
                       тикой.

                   C   Компактная (Compact) модель.

                   CI  Компактная модель с целой арифметикой.

                   L   Большая модель (Large).

                   LI  Большая  модель с целой  арифметикой.

                   По умолчанию используется модель S.

   Если Вы не установили ключи -c, -k или -K (т.е. Вы хотите
не только оттранслировать,  но и собрать (link)  программу),
Вы можете включить имена других объектных файлов и библиотек,
введя их здесь  (и отделяя друг от друга  пробелами).  Ключи
компилятора вспоминаются автоматически при последующих вызо-
вах ZED.
   ZED затем запускает  программу  ZTC1 или  ZTCPP1 (которая
должна быть где-нибудь на Вашем маршруте) с входной информа-
цией для нее, берущейся непосредственно из памяти. Это уско-
ряет компиляцию во время проверки синтаксиса Вашей программы.
   Вы можете еще более увеличить скорость  трансляции,  имея
электронный диск и сказав ZED об этом в ZCONFIG'е - диск бу-
дет использоваться для  созданного  компилятором  временного
файла.
   Компилятор останавливается на первой ошибке и курсор рас-
полагается  около  этой  ошибки.   Если  это  предупреждение
(Warning), Вы можете нажать на Enter,  чтобы продолжить ком-
пиляцию или на Esc,  чтобы прекратить ее. Если это фатальная
ошибка, любая клавиша приведет к аварийному  завершению ком-
пиляции.  Если фатальных  ошибок не произошло,  ZED сохранит
Ваш исходный  файл на диске  и затем  автоматически запустит
ZTG  (если требуется), ZTC2, LINK,  BUNCH и EXE2BIN или MAKE
(если требуется).
   Если Вы  хотите  держать  библиотечные файлы  Zortech или
включаемые  файлы  в  иных  каталогах,  нежели  используемые
ZTCSETUP, Вам следует запустить ZCONFIG, чтобы сообщить  ре-
дактору  ZED,  какие каталоги использовать для этого.


Компиляция проектов с многими исходными файлами

   Если  Вы компилируете  проект,  который состоит из многих
взаимосвязанных  исходных  файлов,  Вы можете упростить этот
процесс, создав файл проекта и используя команду MAKE.  Если
Вы имеете только один проект в подкаталоге  (как большинство
людей), Вы можете назвать Ваш файл проекта MAKEFILE.

   Все подробности о  утилите MAKE и проектных файлах даются
в разделе  MAKE настоящего руководства. Если Вы создали файл
проекта,  то можете откомпилировать текущую программу, а за-
тем  модернизировать  весь проект одной командой. Чтобы сде-
лать это,  включите  ключ  -k в  флаги компиляции. Вы можете
редактировать и транслировать исходные файлы,  написанные на
других языках (например, ассемблере), используя ключ -K.

      Заметим, что -k и -K ключи имеют место только для ком-
      пиляции из редактора  ZED  при использовании (Esc O O)
      или  (Alt+C)  команд.  Ключи не допускаются программой
      ZTC - чтобы  запустить  MAKE  из  DOS, наберите просто
      MAKE в ответ на приглашение DOS!


Отладка и исполнение программ DOS

   'Собрав' Вашу программу,  Вы,  возможно,  захотите прове-
рить ее.  Введите  любые  требуемые  параметры  на подсказку
"Program parameters" ("Параметры программы")  и ZED запустит
Вашу программу,  которая затем возвратит  управление обратно
редактору.

      Заметим, что если Вы используете ключи -k или -K,  ZED
      не запустит  автоматически  Вашу программу.  Вы можете
      запустить  Вашу программу,  либо используя команду DOS
      (Esc O D), либо путем включения вызова программы в Ваш
      makefile.

   Если Вы не хотите сразу запускать Вашу программу, нажмите
Esc. Вы можете, конечно, и без перетрансляции запустить Вашу
программу (или любую другую  DOS  программу)  в любое время,
используя для этого DOS команду (Esc O D).


                      ПРЕДУПРЕЖДЕНИЯ

┌──────────────────────────────────────────────────────────┐
│ ZED не может справиться с запуском программ, которые за- │
│ вершаются и остаются  резидентными  в памяти  (например, │
│ SIDEKICK или MODE).  Это не  о з н а ч а е т,  что Вы не │
│ можете запустить Sidekick с помощью ZED,  а значит толь- │
│ ко,  что Вы  не  можете  загрузить  Sidekick  в  память, │
│ используя ZED команды (Esc O D) или (Alt+D), так как ZED │
│ в этом случае  вступит в конфликт по памяти с этой рези- │
│ дентной программой.                                      │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ Под управлением  некоторых более поздних версий DOS, ко- │
│ манда SET не будет работать при запуске из редактора. Это│
│ происходит потому,  что новая копия  COMMAND.COM  хранит │
│ свою собственную копию строк окружения,  которые исчеза- │
│ ют, когда COMMAND возвращает управление ZED.  Кто знает, │
│ почему  Microsoft  вдруг  ввела  эту  неудачную  возмож- │
│ ность' без компенсации этого путем введения  чего-то по- │
│ добного экспортируемой команде UNIX.                     │
└──────────────────────────────────────────────────────────┘

┌──────────────────────────────────────────────────────────┐
│ Очень  просто  написать  на C программы,  которые делают │
│ ужасные вещи с памятью,  не принадлежащей им  (например, │
│ используя неинициализированный или  NULL  указатель),  и │
│ такая программа может легко помешать редактору ZED снова │
│ завладеть управлением или,  с другой стороны,  испортить │
│ память   ZED   (а  также  и  DOS).   Безопасности   ради │
│ с о х р а н и т е   в с е   Ваши измененные буфера перед │
│ запуском новой программы !                               │
└──────────────────────────────────────────────────────────┘


Проблемы с MS DOS

   MS DOS команда (Esc O D)  и команда  компиляции (Esc O O)
не работают под управлением более ранней,  чем  2.11  версии
MS DOS.

   Автоматический запуск программы после трансляции работает
только,  если запущена версия MS DOS 3.00 или более поздняя.
Это так потому,  что ранние версии  COMMAND.COM не разрешают
командам иметь имена файлов с полными маршрутами.

   Если Вы запускаете  корректную версию  MS DOS  и все же у
Вас есть неприятности,  проверьте достаточность памяти.  Вам
потребуется  256 Kб плюс размер всех файлов,  которые Вы ре-
дактируете,  прежде  чем  Вы  сможете запустить  даже  самые
простейшие команды.

   Если у Вас достаточно  памяти и имеете  правильную версию
MS DOS, все же эти команды будут работать только, если пере-
менная окружения COMSPEC установлена корректно. Это объясня-
ется в руководстве по MS DOS, но обычно все так и есть кроме
случая, когда Вы загружаетесь  с  гибкого  диска  (и позднее
убираете этот диск) или работаете в сети. В любом случае Вам
следует  выяснить, где может быть найдена  на  жестком диске
копия COMMAND.COM (например, C:\COMMAND.COM),  и затем доба-
вить следующую строку в файл AUTOEXEC.BAT:

SET COMSPEC=C:\COMMAND.COM

В этой строке не должно быть  пробелов,  кроме указанного


Меню "запись" (Record) и "извлечение" (Playback)

   Вы можете сохранить  комбинацию клавиш в одном из 10 мак-
росов.

   Чтобы сделать это, зажмите Ctrl и любую из функциональных
клавиш (F1-F10). Все, что Вы введете (максимум до 63 клавиш),
будет запоминаться как соответствующее  этой  функциональной
клавише.  Для напоминания  Вам о том,  что  Вы  записываете,
строка  статуса  показывает  номер   записываемого   макроса
(в положении  между  позицией  (номером  столбца)  курсора и
INSERT/OVERTYPE).  Для прекращения  записи повторно  зажмите
Ctrl и функциональную клавишу.  Чтобы извлечь макрос, просто
нажмите Alt и ту же функциональную клавишу.

   Вы можете также записывать и извлекать  макросы с помощью
меню. Чтобы записать макрос, выберите меню  "запись" (Esc R)
и зажмите любую из числовых клавиш (от 0 до 9).  Чтобы прек-
ратить запись, выберите снова меню  "запись" и зажмите ту же
клавишу. Для извлечения макроса с помощью меню, выберите ме-
ню "извлечение" (Esc P) и зажмите  соответствующую  числовую
клавишу.

   В меню  "извлечение" есть опция  (NUMBER)  для повторения
макроса любое число раз.  Если Вы хотите  остановить однажды
начатое повторение макроса,  зажмите  Ctrl-Break клавишу. Вы
можете  сохранить  все  макросы в файле  для последующего их
извлечения, используя для этого (Esc R W) для сохранения ма-
кросов и (Esc R R) для их извлечения.

      Все макросы запоминаются и будут автоматически доступ-
      ны в следующий раз, когда Вы запустите ZED.

   Если Вы хотите запомнить более длинные макросы, Вы можете
записать  комбинацию клавиш в файл,  используя (Esc R L) для
начала и завершения записи и (Esc P L)  для извлечения их из
файла.   Любое  извлечение   макроса  может быть прервано по
Control-Break.

   В любой момент,  когда у Вас запрашивается  имя файла, Вы
можете   ввести   неопределенное   имя   (например, *.*  или
\include\*.h  и т.д.).  Список всех файлов,  удовлетворяющих
этому имени, будет показан на экране. Вы можете использовать
клавиши  управления курсором для перемещения по списку и за-
тем нажать на Return для выбора нужного Вам файла. Вы можете
также нажать на Escape  для  возврата к запросу имени файла,
чтобы ввести другое имя.


Меню "текст" (Text)

      Update     Эта команда  просто  перерисовывает экран в
                 случае аппаратного сбоя или других проблем.
                 Если  текст  выглядит  странно или кажется,
                 что курсор  находится  в невероятном месте,
                 попробуйте исполнить эту команду.  Если все
                 же текст  выглядит не так,  попробуйте вер-
                 нуться в начало файла по  Ctrl+PgUp а затем
                 обратно.

      Lmargin    (Alt+L)  Устанавливает левую границу. Левая
                 граница используется  командой форматирова-
                 ния (Format) и при  автоматическом переносе
                 слов   (word-wrap).   Когда   Вы  нажимаете
                 <Return>  в конце  строки,  установка левой
                 границы игнорируется. Это делает легким пе-
                 чатание втянутых абзацев, подобных этому.

      Rmargin    (Alt+M) Устанавливает правую границу. Здесь
                 производится перенос слов.  Если Вы устано-
                 вите ее в ноль, перенос слов не производит-
                 ся вовсе.

      Tabs       (Alt+T)  Расставляет интервальные метки та-
                 буляции - обычно столбцы табуляции   распо-
                 лагаются через каждые 8 символов, но Вы мо-
                 жете расставить их чаще  для  сильно струк-
                 турированных   программ.   Стандартные  DOS
                 команды  PRINT и TYPE  используют установку
                 табуляций через 8 символов,  исходные файлы
                 с нестандартными позициями  табуляций можно
                 печатать  только  в  ZED.   Если у Вас есть
                 такой исходный файл и  Вы  хотите  печатать
                 его вне редактора  ZED  (или  редактировать
                 его в другом редакторе),  Вам нужно исполь-
                 зовать  команду  Spaces (смотрите ниже) для
                 преобразования всех  табуляций в соответст-
                 вующее число пробелов.

      Format     (^B)   Используется  для  текстовых  файлов
                 (подобно  этому руководству) - команда раз-
                 бирает  часть  буфера  таким образом, что в
                 каждой  строке  размещается столько текста,
                 сколько  возможно  разместить между левой и
                 правой границами. Меню "размер" дает возмож-
                 ность решить Вам, какую часть буфера форма-
                 тировать;  умолчанием является  один  абзац
                 (который  определяется как текст от позиции
                 курсора до следующей целиком пустой строки).
                 Вызывает  ужасную  путаницу для большинства
                 C программ !

      Spaces     Преобразует  табуляции  в пробелы в буфере.
                 Меню  "размер"  позволяет Вам решить, какую
                 часть буфера преобразовывать.

      tAbs       Преобразует  пробелы  в табуляции в буфере.
                 Меню  "размер" позволяет Вам решить,  какую
                 часть буфера преобразовывать.

   Быстрые клавиши, соответствующие этим командам, изобража-
ются в скобках после каждой команды.  Эти клавиши могут быть
переопределены в ZCONFIG.
   Последние три команды могут прерываться по Control-Break.


   Форматирование  и  автоматическая втяжка (formatting  and
                                                 autoindent)

   Если у Вас установлена правая граница, осуществляется ав-
томатический перенос слов  между левой  и правой  границами.
Нажатие на возврат каретки, однако, оставляет курсор в столб-
це 1, какой бы ни была установка левой границы. Это происхо-
дит из-за того,  что обычно  Вы нажимаете на возврат каретки
только  в  конце  абзаца и хотите  втянуть  следующий  абзац
правее или левее, нежели текущая левая граница.
   Если режим автовтяжки включен,  нажатие на возврат карет-
ки оставляет курсор в том же столбце,  в котором расположено
начало текста из предыдущей строки. Комбинация этих двух оп-
ций позволяет Вам устанавливать  автоматическое форматирова-
ние,как Вы того хотите.
   Текущие границы и установки табуляций сохраняются при вы-
ходе из редактора и автоматически восстанавливаются при пос-
ледующем вызове ZED.
   Если Вы обычно используете значение шага табуляции, отлич-
ное от стандартного значения 8, и хотите печатать Ваши файлы
вне ZED,  Вам следует преобразовать все табуляции в файле на
пробелы.  Команды Spaces и tAbs очень полезны также, если Вы
хотите  заменить  установленный  шаг табуляции без изменения
изображения  файла - нужно  лишь  преобразовать  табуляции в
пробелы, используя старое значение шага табуляции,  изменить
значение шага табуляции на новое и затем обратно  преобразо-
вать пробелы в табуляции.


Предыдущая версия файла

   Обычно ZED сохраняет копию любого  измененного Вами файла
под тем же  именем,  что и оригинал,  но с расширением .BAK.
Это несколько неудобно,  если Вы редактируете файлы с одина-
ковыми  именами,  но разными расширениями (например, zed.c и
zed.h)  т.к.  копии  перезаписывают одна другую. Аналогично,
если Вы имеете  жесткий диск со сложной каталоговой структу-
рой и истощили свой запас дискового пространства,  Вы должны
искать по всему дереву каталогов файлы  .BAK для их удаления
освобождения дисковой памяти. Если Вы установите каталог для
копий (используя ZCONFIG),  ZED будет размещать копии файлов
в этом каталоге, используя те же самые имена файлов, что и у
оригиналов. Это означает,  что Вы имеете корректно именован-
ные копии  всех  Ваших  файлов и все  они  находятся в одном
месте.

   Это будет работать, только если диск, содержащий исходный
файл, имеет каталог с указанным именем,  т.к. ZED использует
системный вызов DOS MV для перемещения исходного файла в ка-
талог дублей, a это не работает для разных дисков.


Структура меню

   Это образ-шпаргалка структуры  меню.  Опции главного меню
находятся  в  левом  столбце,  а подменю вдоль одной строки.
Под каждой опцией подменю указана  быстрая клавиша, приводя-
щая Вас прямо к этой опции (см. таблицу на след. стр.).


Конфигурирование


   Программа ZCONFIG.EXE предоставляется для установки быст-
рых клавиш, маршрутов к каталогам, формата экрана, цвета эк-
рана и строки статуса, позиций меню.
   ZCONFIG создает файл ZED.CFG,  содержащий подробности ус-
тановок  конфигурации.  Этот файл обычно  создается в том же
самом  каталоге,  что и ZED.EXE.  Если ZED.EXE не может быть
найден где-либо на маршрутах PATH, ZED.CFG будет создаваться
в текущем каталоге.  Для поиска ZED.CFG  ZED вначале просма-
тривает текущий каталог, а затем все каталоги из PATH. Таким
образом, если Вы хотите установить несколько файлов конфигу-
рации (предположительно, для различного типа работ по редак-
тированию),  Вам  нужно  скопировать каждый  ZED.CFG  файл в
отдельный каталог и запустить ZED в этом каталоге.

   ZED.CFG  файл перезаписывается также при выходе из редак-
тора для сохранения следующих деталей:

      ZTC флаги компилятора (ZTC compiler flags)
      Шаг табуляции (Tab size)
      Левая граница (Left Margin)
      Правая граница (Right Margin)
      Подсветка блока (Block highlighting ON orOFF)-включена
                                                     или нет
      Режим редактирования (Insert/Overtype)
      Клавиши макросов (Key macros)
      Автовтяжка (Auto-indent)-включена или нет

   Ниже описываются различные возможности, доступные из про-
граммы ZCONFIG.


   Установка быстрых командных клавиш (Hotkeys)

   Эта опция позволяет Вам установить, какие нажатия клавиши
исполняют команды редактора.
   Список всех команд,  которые Вы можете выполнить в редак-
торе, изображается на экране.
   Используйте клавиши управления курсором  (Up, Down, PgUP,
PgDn, Home, End,  Right, Left) для перемещения курсора к той
команде,  которая Вам нужна.  Затем нажмите клавишу  Return,
следующую за какой угодно клавишей (или комбинацией клавиш),
которую Вы хотите  ассоциировать  с этой командой.  Если эта
клавиша уже используется для другой команды, Вы будете опро-
шены о подтверждении того, что это то, что Вы хотите, перед
внесением изменением.

┌────────┬──────────────────────────────────────────────────
│ Главное│
│  меню  │
├────────┼────────┬──────┬───────┬────────┬────────┬────────
│        │  Edit    Save   Abort   Read     Write     eXit
│ File   │
│        │ Alt E    Alt S  Alt Q   Alt I    Alt W     Alt X
├────────┼──────────────────────────────────────────────────
│        │  Left           Start   Right    bottoM    End
│ Move   │
│        │  Home    ^Home  ^PgUp   End      ^End      ^PgDn
├────────┼──────────────────────────────────────────────────
│        │Insert   Overtype Rest   Lower    Upper     Sefseq
│ Edit   │
│        │(Toggle insert Key)  F2
├────────┼──────────────────────────────────────────────────
│        │ Block    blocK   Delete  Move    Copy      Save
│ Block  │
│        │ Alt Y    Alt Z                              F4
├────────┼──────────────────────────────────────────────────
│        │ Word    End line Line   Paragra  Block      Tag
│ Delete │
│        │ F10     F9       ^Y
├────────┼──────────────────────────────────────────────────
│        │ Find    Case     Next   Last     Again    Replace
│ Search │
│        │ Alt F   Alt A    F7     F8       ^L        Alt R
├────────┼──────────────────────────────────────────────────
│        │ cOmpile Compare  Dos    Print     eXit
│ Other  │
│        │ Alt C   Alt O    Alt D  Alt P
├────────┼──────────────────────────────────────────────────
│        │ 1 ─ 9,0  Write   Read   Log
│ Record │
│        │ F1 ─ F10
├────────┼──────────────────────────────────────────────────
│        │ 1 ─ 9,0  Write   Read   Log      Number
│Playback│
│        │ Alt F1 ─ F10
├────────┼──────────────────────────────────────────────────
│        │ Lmargin  Rmargin Tablen  Format   Update   Spaces
│ Text   │
│        │ Alt L    Alt M   Alt T    ^B
├────────┼──────────────────────────────────────────────────
│        │ (Change buffer)
│ 1 - 5  │
│        │ Alt 1 - 5
└────────┴──────────────────────────────────────────────────

		       Окончание таблицы - на след. странице

   ────────────────────────────────────────────────────────┐
                                                           │
                                                           │
   ─┬─────────┬────────┬────────┬───────┬───────┬──────────┤
      1 - 5                                                │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
      Number     Tag             Block   Block     1 - 9   │
                                                           │
      Alt N      F5     Alt J    Alt B   Alt K             │
   ────────────────────────────────────────────────────────┤
      seQuenc  Comment    +        -      Auto     1 - 5   │
                                                           │
       Alt U            Alt 0    Alt 9  Shift+Tab  Alt 1-5 │
   ────────────────────────────────────────────────────────┤
      Restore   Tag     Hilite   Jank    1 - 9             │
                                                           │
        F5      F6                                         │
   ────────────────────────────────────────────────────────┤
              All buf  No of lines                         │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
      Global    eXit                                       │
                                                           │
      Alt G                                                │
   ────────────────────────────────────────────────────────┤
                                                           │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
                                                           │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
                                                           │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
      tAbs      eXit                                       │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┤
                                                           │
                                                           │
                                                           │
   ────────────────────────────────────────────────────────┘
   Команды редактора перечислены также в разделе  ZCONFIG.


   Если команда уже имеет 3 набора клавиш, ассоциированных с
ней, то команда, на которую указывает курсор,  вначале будет
удалена из списка. Вы можете также использовать клавишу Del,
чтобы просто  удалить  клавишу из списка команды.

   Доступными являются следующие команды:

Сохранить файл на диске и продолжить редакти-
                                       рование   Esc F S
Сохранить файл и редактировать новый файл        Esc F E
Аннулировать все изменения в текущем файле       Esc F Q
Вставить содержимое файла с позиции курсора      Esc F R
Записать часть текущего буфера на диск           Esc F W
Сохранить все измененные буфера на диске
   Оставляет Вас в редакторе, сохранив и очистив
                                      все буфера.

Сохранить файл и выйти
   Сохраняет текущий буфер на диске и чистит его.
   Затем переходит к другим  буферам.  Если буфер
   не был изменен, он чистится. Если же буфер был
   изменен,  Вы переводитесь в режим редактирова-
   ния этого буфера.

Выход из программы                               Esc F X
Преобразование части буфера к нижнему  регистру  Esc E U
Преобразование части буфера к верхнему регистру  Esc E L
Вставить  ASCII  графический  символ  в позиции
                                        курсора  Esc E G
Вставить   последовательный  номер  в  текст  и
                                  увеличить его  Esc E Q
Установить начальное значение последовательного
                                   номера числа  Esc E S
Выровнять  по  правому  краю  CИ  комментарий в
                                         строке  Esc E C
Переместить часть  буфера  вправо  на 1 позицию
                                      табуляции  Esc E +
Переместить  часть  буфера  влево  на 1 позицию
                                      табуляции  Esc E -
Переключить режим автовтяжки                     Esc E A

Оттранслировать программу из текущего буфера     Esc O O
Сравнить  содержимое  двух  буферов              Esc O C
Выполнить команду DOS                            Esc O D
Распечатать часть буфера                         Esc O P

Поиск строки                                     Esc S F
Поиск строки с игнорированием регистров          Esc S C
Заменить найденную строку на другую              Esc S R
Заменить все найденные строки                    Esc S G

Поиск строки (совместимый с Wordstar)            Ctrl Q F
Поиск и замена строки (совместимые с Wordstar)   Ctrl Q A

Сохранить макросы в файле на диске               Esc R W
Извлечь макросы из дискового файла               Esc R R

Повторить макрокоманду несколько раз             Esc P N

Установить левую границу                         Esc T L
Установить правую границу                        Esc T R
Установить позиции табуляции                     Esc T T
Переформатировать часть буфера                   Esc T F
Преобразовать табуляции в пробелы в части буфера Esc T S
Преобразовать пробелы в табуляции в части буфера Esc T A

Зарегистрировать все нажатия клавиш в файле      Esc R L

Извлечь нажатия клавиш из файла регистрации      Esc P L

Сбросить часть буфера в буфер хранения блока     Esc B Y

Переместить курсор в строку с определенным номе-
                                            ром  Esc M N

Клавиша табуляции                                Tab
Главное меню                                     Esc
Wordstar ^Q(uick - быстрое) меню                 Ctrl Q
Wordstar (bloc)^K меню                           Ctrl K
Меню "файлы"                                     Esc  F
Меню 'перемещения курсора'                       Esc  M
Меню 'редакция'                                  Esc  E
Меню 'блоки'                                     Esc  B
Меню 'удаление'                                  Esc  D
Меню 'поиск'                                     Esc  S
Меню 'прочее'                                    Esc  O
Меню 'запись'                                    Esc  R
Меню 'извлечение'                                Esc  P
Меню форматирования текста                       Esc  T

Обновление экрана (при сбоях)                    Esc T U
Поместить текстовый маркер 1 в позицию курсора   Esc B 1
Поместить текстовый маркер 2 в позицию курсора   Esc B 2
Поместить текстовый маркер 3 в позицию курсора   Esc B 3
Поместить текстовый маркер 4 в позицию курсора   Esc B 4
Поместить текстовый маркер 5 в позицию курсора   Esc B 5
Поместить текстовый маркер 6 в позицию курсора   Esc B 6
Поместить текстовый маркер 7 в позицию курсора   Esc B 7
Поместить текстовый маркер 8 в позицию курсора   Esc B 8
Поместить текстовый маркер 9 в позицию курсора   Esc B 9

Переместиться в текстовый маркер 1               Esc M 1
Переместиться в текстовый маркер 2               Esc M 2
Переместиться в текстовый маркер 3               Esc M 3
Переместиться в текстовый маркер 4               Esc M 4
Переместиться в текстовый маркер 5               Esc M 5
Переместиться в текстовый маркер 6               Esc M 6
Переместиться в текстовый маркер 7               Esc M 7
Переместиться в текстовый маркер 8               Esc M 8
Переместиться в текстовый маркер 9               Esc M 9
Переместиться в соответствующую скобку - (,[,{   Esc M [

Пометить начало блока                            Esc B B
Пометить конец блока                             Esc B K

Поместить TAG в текущую позицию курсора          Esc B T
Поменять местами TAG и курсор                    Esc M T
Переместиться к началу блока                     Esc M B
Переместиться к концу блока                      Esc M K

Показать/скрыть текущий блок                     Esc B H
Переместить помеченный блок в позицию курсора    Esc B M
Скопировать помеченный блок в позицию курсора    Esc B C
Переместить текст между позицией курсора и TAG
                        в буфер хранения блока   Esc B S
Скопировать текст между позицией курсора и TAG
                        в буфер хранения блока   Esc B Y

Включить режим вставки (Insert)                  Esc E I
Включить режим "затирания" (Overtype)            Esc E O
Переключение режимов вставки/затирания           Ins

Переместить курсор вверх на 1 строку             Up arrow
Переместить курсор в начало экрана               Esc M P
Переместить курсор вверх на 1 страницу           PgUp
Переместить курсор в начало файла                Esc M S
Переместить курсор вниз на 1 строку              Down arrow
Переместить курсор в конец экрана                Esc M M
Переместить курсор вниз на 1 страницу            PgDn
Переместить курсор в конец файла                 Esc M E
Переместить курсор влево на 1 позицию            Left arrow
Переместить курсор влево на 1 слово              Ctrl left
Переместить курсор в левую часть экрана          Esc M L
Переместить курсор вправо на 1 позицию           Right arrow
Переместить курсор вправо на 1 слово             Ctrl right
Переместить курсор в конец строки                Esc M R

Вставить новую строку в позиции курсора          Ctrl N
Прокрутка (scroll) текста вниз на 1 строку       Ctrl W
Прокрутка текста вверх на 1 строку               Ctrl Z

Удалить символ под курсором                      Del

Возвратиться на шаг/удалить символ слева от
                                      курсора    Backspace
Удалить слово справа от курсора                  Esc D W
Удалить до конца строки                          Esc D E
Удалить всю строку                               Esc D L
Удалить помеченный блок                          Esc B D

Контекстный поиск в прямом направлении           Esc S N
Контекстный поиск в обратном направлении         Esc S P
Повторить поиск последнего образца               Esc S A
Восстановить последний удаленный элемент в по-
                                  зиции курсора  Esc E R

Редактировать буфер 1                            Esc 1
Редактировать буфер 2                            Esc 2
Редактировать буфер 3                            Esc 3
Редактировать буфер 4                            Esc 4
Редактировать буфер 5                            Esc 5

Сохранить набор клавиш в макроопределении 10     Esc R 0
Сохранить набор клавиш в макроопределении 1      Esc R 1
Сохранить набор клавиш в макроопределении 2      Esc R 2
Сохранить набор клавиш в макроопределении 3      Esc R 3
Сохранить набор клавиш в макроопределении 4      Esc R 4
Сохранить набор клавиш в макроопределении 5      Esc R 5
Сохранить набор клавиш в макроопределении 6      Esc R 6
Сохранить набор клавиш в макроопределении 7      Esc R 7
Сохранить набор клавиш в макроопределении 8      Esc R 8
Сохранить набор клавиш в макроопределении 9      Esc R 9

Повторить макрос 10                              Esc P 0
Повторить макрос 1                               Esc P 1
Повторить макрос 2                               Esc P 2
Повторить макрос 3                               Esc P 3
Повторить макрос 4                               Esc P 4
Повторить макрос 5                               Esc P 5
Повторить макрос 6                               Esc P 6
Повторить макрос 7                               Esc P 7
Повторить макрос 8                               Esc P 8
Повторить макрос 9                               Esc P 9

Выдать подсказку                                 F1



   Установка маршрутов (Files)

      Ramdisk       Где размещать  временные  файлы во время
                    компиляции. Должен  содержать  двоеточие
                    (имя диска)   или  завершаться  обратным
                    слэшем (каталог).
                    (например,  \TMP\  или  D:)

      Help          Полное имя файла подсказок редактора ZED
                    (например,  C:\ZORTECH\BIN\ZED.HLP\).

      Backup        Каталог,  в котором  размещаются  старые
                    версии файлов.  Не должен  содержать имя
                    диска,  так как дубли файлов всегда хра-
                    нятся на том же диске,  что и оригиналы.
                    Смотрите  выше параграф "предыдущая вер-
                    сия файла".

      Libs          Маршрут,  на котором Вы храните  Zortech
                    библиотеки (*.OBJ и *.LIB). Должен содер-
                    жать двоеточие  (если имя диска) или за-
                    вершаться обратным слэшем (если каталог).
                    (например, C:\ZORTECH\LIB\)

      Include       Маршрут к каталогу, на котором Вы храни-
                    те включаемые файлы (*.h и *.hpp).  Дол-
                    жен содержать двоеточие (если имя диска)
                    или завершаться обратным слэшем (если ка-
                    талог). (например. C:\ZORTECH\INCLUDE\).

      Printer       Имя устройства печати (например, PRN или
                    LPT1 или COM1).

      Eof           Включает символ ^Z в конец файлов.  Этот
                    режим должен быть включен  для совмести-
                    мости с Wordstar. Некоторые программы не
                    распознают  ^Z  в качестве маркера конца
                    файла и требуют,  чтобы  этот переключа-
                    тель был выключен.


   Вид экрана (Screen)

      Scroll        Использует аппаратный режим  'прокрутки'
                    (Scroll)  для перемещения  до <n> строк;
                    по умолчанию 10. ZED будет 'прокручивать'
                    текст на экране, если он перемещается на
                    число строк не большее <n>, и будет пере-
                    рисовывать весь экран, если текст переме-
                    щается на большее, чем <n>, число строк.
                    Некоторые экраны раздражающе мерцают при
                    перемещении  и нескольких строк.  Если у
                    Вас  такой экран,  установите  это число
                    'прокрутки'  маленьким.  Если  прокрутка
                    плавная, быстрая и не вызывает мерцания,
                    установите   значение  числа  'прокрутки'
                    максимальным   (до  максимального  числа
                    строк Вашего экрана).

      Lines         Перемещает n строк, когда нажаты клавиши
                    PgUp или PgDn;  по умолчанию 10. Если Вы
                    предпочитаете использовать клавиши  PgUp
                    и PgDn для перемещения всего экрана, ус-
                    тановите это число  равным  числу  строк
                    текста,  изображаемых редактором  ZED на
                    Вашем экране  (22 строки для большинства
                    экранов).

      Update        Модернизирует,  по крайней мере, n строк
                    при  'прокрутке';  по умолчанию 1.  Если
                    клавиша  нажимается до завершения обнов-
                    ления экрана, модернизация экрана приос-
                    танавливается,  но не раньше,  чем обно-
                    вится это число  строк.  Чем  больше это
                    число, тем в большей степени экран соот-
                    ветствует текущему состоянию при прокрут-
                    ке или быстром листании файла, но листа-
                    ние при этом происходит медленней.

      Horison       Перемещает n столбцов,  когда курсор вы-
                    ходит за экран;  по  умолчанию  16.  ZED
                    обычно скачкообразно перемещает в сторо-
                    ну за один раз 16 символов. Если Вы пред-
                    почитаете большие  или меньшие 'прыжки',
                    измените это значение.

      Tab           ASCII символ для представления табуляций;
      Character     по умолчанию 26.  Символ 26  (маленькая,
                    направленная вправо стрелка) использует-
                    ся для изображения табуляций на экране в
                    редакторе ZED. Если Вам не хочется, что-
                    бы символы табуляции изображались на эк-
                    ране,   установите  это  значение  в  32
                    (т.е. пробел).

      Newline       Использует  ASCII символ n для представ-
                    ления  конца  строки;  по  умолчанию 27.
                    Символ 27 (маленькая, направленная влево
                    стрелка)  используется для представления
                    конца  строки на экране в редакторе ZED.
                    Если Вы  не хотите,  чтобы  конец строки
                    изображался  на  экране,  установите это
                    значение в 32 (т.е. пробел).

      Eof           Использует  ASCII символ n для представ-
                    ления конца  файла;   по умолчанию  186.
                    Символ  186 (двойная вертикальная черта)
                    используется  для того,  чтобы показать,
                    что изображение на экране 'вышло' за ко-
                    нец файла. Если Вы не хотите, чтобы сим-
                    вол изображался, установите его значение
                    в 32 (т.е. пробел).

      Ruler         Использует  ASCII символ n для 'заполне-
                    ния'  строки-линейки;  по умолчанию  205
                    (двойная горизонтальная черта).

      Video         Устанавливает видео режим;  по умолчанию
                    3 (80х25 цветной). Это параметр для BIOS
                    вызова "установить видео режим"  (INT 10
                    hex, AH = 0, AL = этому значению).
                    Устанавливает следующие значения:

                    2  Color  Grafics  adapter  80х25  mono
                    3  Color  Grafics  adapter  80х25  color
                    7  Mono   Display  adapter  80х25
                       (если Вы не имеете цветного монитора)
                    55 ATI  EGA  Wonder card   132х44  mono
                    99      EGA - adapter       80х44  color
                       (это специальное значение,  поддержи-
                        ваемое ZED)

                    ZED  не  поддерживает  режимы с меньшим,
                    чем 80, числом позиций столбцов. Если Вы
                    знаете другие  допустимые  видео режимы,
                    которые работают на Вашей машине, можете
                    использовать   их.    При   определенных
                    BIOS/монитор комбинациях можно испортить
                    Ваш монитор  установкой  видео  режима в
                    незаконное  значение,   поэтому   БУДЬТЕ
                    ОЧЕНЬ  ОСТОРОЖНЫ !

      Cursor        Устанавливает вид основного  редактирую-
                    щего курсора; по умолчанию  000F  (Hex).
                    Это параметр BIOS вызова "установить вид
                    курсора"  (INT 10 hex,  AH = 1, CX = это
                    значение). Это значение должно быть вве-
                    дено в шестнадцатиричном  виде.  Старший
                    байт  (первые два шестнадцатиричных сим-
                    вола)  определяет начало блока курсора и
                    младший байт (следующие два шестнадцати-
                    ричных символа)  определяет  конец блока
                    курсора.  В большинстве  мониторов  000F
                    задает блочный курсор,  а 0B0C дает кур-
                    сор-подчерк.

      Moves         Включает/выключает режим, в котором кур-
                    сор при перемещении вправо от конца стро-
                    ки переходит  на следующую  строку и при
                    перемещении   курсора  влево  от  начала
                    строки  курсор  переходит  на предыдущую
                    строку.
                    По умолчанию,  если  Вы  держите нажатой
                    клавишу перемещения курсора  влево  (или
                    вправо), курсор устанавливается в начале
                    (или конце) строки. Если Вы выберите эту
                    опцию, курсор будет  перескакивать в ко-
                    нец предыдущей строки (начало  следующей
                    строки),  как это происходит в Wordstar.
                    Эта опция переключает  режим на противо-
                    положный.

      Dumb          Включает/выключает режим  'осмысленного'
                    перемещения курсора. Перемещение курсора
                    обычно происходит 'осмысленно', т.е. кур-
                    сор будет возвращаться в ту же самую по-
                    зицию, если Вы перемещаете его вверх или
                    вниз и затем возвращаете в прежнюю стро-
                    ку, даже, если курсор был в другой пози-
                    ции и на другой строке. Если Вы выберите
                    эту опцию, курсор будет вести себя,  как
                    в Wordstar.


   Цвета экрана (Colors and More colors)

      menuBar       Цвет для строки меню.

      menuOption    Цвет для 'подсвеченной' опции меню.

      menuPromt     Цвет для подсказки в меню.

      Strings       Цвет для вводимых строк и т.п.

      Warnings      Цвет для сообщений об ошибках  и предуп-
                    реждениях редактора.

      Window        Цвет для окошек меню.

      Option        Цвет для 'подсвеченных'  опций в оконных
                    меню.
      Status        Цвет для строки  статуса  (состояния ре-
                    дактирования.

      Ruler         Цвет для строки-линейки.

      Errors        Цвет для  сообщений  об  ошибках  компи-
                    лятора.

      Detail        Цвет для уточнения ошибки компилятора.

      Text          Цвет для редактируемого текста.

      Block         Цвет для выделенного блока.

      Help          Цвет для текста подсказок "помощника".

   Позиция курсора на верхней строке  изображается подсвечи-
ванием символа под курсором.

      Overtype      Цвет для курсора в режиме  'надпечатыва-
                    ния' (обычно черный на белом).
      Insert        Цвет  для  курсора  в  режиме  'вставки'
                    (мерцающий в инверсном изображении).

Переместите курсор к 'Z', являющимся нужным цветом, и нажмите 
клавишу Enter. Если Вы решите не менять цвет, то нажмите Esc.

   Разметка экрана (Lines)

   Эта опция позволяет Вам изменить экранную разметку. Выби-
райте номер строки  от 1 до 8 для каждого элемента опции. Вы
можете перекрывать эти строки, как Вам требуется.  Некоторые
перекрытия могут дать странное изображение.

      Menu       Строка для меню-строки (меню-полосы)
                 (по умолчанию 1)

      Prompt *   Строка подсказки/пояснения в меню
                 (по умолчанию 2)

      Status     Строка,  содержащая  информацию  о  статусе
                 (по умолчанию 2)

      Warnings   Сообщения об ошибках редактора
                 (по умолчанию 1)

      Input      Строка  для ввода  пользователем  текстовых
                 строк и т.п. (по умолчанию 1)

      Ruler *    Где установить строку-линейку
                 (по умолчанию 3)

      Errors     Строка для сообщений об ошибках компилятора
                 (по умолчанию 2)

      Detail     Строка для детального сообщения компилятора
                 об ошибке (по умолчанию 3)

*  Prompt  и  Ruler  строки могут быть исключены  установкой
   их номеров строк в 0.

   Позиции окон

   Оконное меню позволяет Вам изменять  позиции  окон  меню.
Выберите,  для какого меню  Вы хотите  установить позицию, и
используйте клавиши  управления курсоров  для перемещения по
экрану к требуемой позиции.  Как Вы можете видеть из умолча-
ний, перекрывать эти меню можно по своему желанию. Некоторые
перекрытия  могут дать  странное  изображение,  в частности,
когда меню перекрывают статус-строку.  Вы можете переместить
оконное меню так, что часть его исчезнет с экрана.  Это сде-
лает недоступным некоторые из опций этого меню,  т.к. курсор
не может перемещаться за границу экрана для их выбора.
   Если Вы предпочитаете,  чтобы Ваши  меню  располагались в
верхней строке (в стиле Lotus 123), переместите каждое окон-
ное меню в левый верхний угол экрана. Следующие меню доступ-
ны для выбора их позиции:

      Main        Главное меню
      File        Меню 'Файлы'
      Mooc        Меню 'Перемещение курсора'
      Edit        Меню 'Редакция'
      Blocks      Меню 'блоки'
      Delete      Меню 'удаление'
      Search      Меню 'поиск'
      Other       Меню 'Прочее'
      Record      Меню 'запись'
      Playbock    Меню 'извлечение'
      Text        Меню 'текст'
      K           Wordstar ^K (блок) меню
      Q           Wordstar ^Q (быстрые перемещения) меню


   Обрамление окон (Boxes)

   Меню  `обрамление окон'  позволяет  Вам выбрать  символы,
используемые для границ оконных  меню.  Просто введите ASCII
код литеры для каждой позиции. По умолчанию принято:

   Опция меню           Часть границы            Значение по
                                                 умолчанию
        7             левый верхний угол             218
        8             верхняя  сторона               196
        9             правый верхний угол            191
        4             левая  сторона                 179
        6             правая  сторона                179
        1             нижний левый угол              192
        2             нижняя  сторона                196
        3             нижний правый угол             217

   Более подробно ASCII значения всех IBM графических симво-
лов можно найти в руководстве по DOS или можно поэксперимен-
тировать в ZED, используя (Esc E G) функцию.

   Распечатка конфигурации (Print)

   Вы  можете  распечатать  текущие  установки  конфигурации
(включая  быстрые  командные клавиши).  Печать  выводится на
печатающее устройство  в  соответствии  с  Directories/Print
меню.

      Файл подсказок

   Стандартный  файл  подсказок для редактора ZED называется
ZED.HLP. Если Вы при помощи ZCONFIG будете изменять назначе-
ния 'быстрым' командным клавишам, Вы можете, соответственно,
изменить и имя файла  подсказок.  Поскольку  файл  подсказок
является обычным текстовым файлом,  он может редактироваться
с помощью редактора ZED как и любой другой файл. Пожалуйста,
обратите внимание на то, что Вам  не  следует  редактировать
файл подсказок,  пока редактор использует его.  Лучше скопи-
руйте ZED.HLP  в файл с другим именем,  отредактируйте его и
затем верните его на прежнее место.
   Файл подсказок  состоит  из  некоторого  числа  страниц с
вспомогательной информацией.  Страницы разделяются символами
перевода формата  (код  графического  символа 12).  Когда Вы
редактируете  файл  подсказок,  следите,  чтобы  не  сделать
какую-нибудь из страниц слишком большой для экрана. Страницы
нумеруются (первая  страница  имеет  номер 0)  для снабжения
текста ссылки  при  создании  элементов  перекрестных ссылок
помощи.
   Элемент перекрестной ссылки помощи  обозначается символом
повернутого вправо треугольника (код 16),  номером страницы,
и символом повернутого влево треугольника (код 17). По край-
ней мере,  Вы должны включить в каждую страницу помощи, ука-
зывающую на индексную страницу помощи (страницу 20).  Разре-
шается иметь до 40 страниц  помощи и до 50 перекрестных ссы-
лок на каждой странице.



                                         КОМПИЛЯТОР  ZORTECH
                                         ───────────────────

Обзор процесса компиляции


	      .C              .CPP        .ASM   .OBJ  .LIB
        ┌──────┴────┐           │           │      │     │
   ┌────┴───┐  ┌────┴───┐  ┌────┴───┐  ┌────┴───┐  │     │
   │  ZTC1  │  │ ZTC1B  │  │ ZTCPP1 │  │  MASM  │  │     │
   └────┬───┘  └────┬───┘  └────┬───┘  └────┬───┘  │     │
        └───────────┼───────────┘           │      │     │
               .TMP ├───────────┐           │      │     │
                    │      ┌────┴───┐       │      │     │
                    │      │  ZTG   │       │      │     │
                    │      └────┬───┘       │      │     │
                    │       .TMO│           │      │     │
                    ├───────────┘           │      │     │
            ┌───────┴──────┐                │      │     │
       ┌────┴───┐     ┌────┴───┐            │      │     │
       │  ZTC2  │     │  ZTC2B │            │      │     │
       └────┬───┘     └────┬───┘            │      │     │
            └───────┬──────┴────────────────┴──────┘     │
                    │.OBJ                                │
          ┌─────────┴──────┐                             │
          │   ┌────────────┼───┬─────────────────────────┘
       ┌──┴───┴─┐       ┌──┴───┴─┐
       │  BLINK │       │ MSLINK │      ┌──────────────────┐
       └───┬────┘       └┬──────┬┘      │ От исходного кода│
           │         .EXE├──┐   │.MAP   │  к  исполняемому │
           │             │┌─┴───┴──┐    │                  │
           │             ││ BUNCH  │    │      ZTC.COM     │
           │             │└───┬────┘    └──────────────────┘
           └─────────────┼────┘
                         ├────────┐
                         │   ┌────┴────┐
                         │   │ EXE2BIN │
                         │   └────┬────┘

                       .EXE     .COM

1.    Исходные C++ файлы создаются  пользователем при помощи
   стандартного текстового редактора. Система обработки тек-
   стов (текстовый процессор)  может быть использована в ре-
   жиме с выключенным форматированием.

2.    ZTCPP1  обрабатывает исходный файл и создает временный
   промежуточный файл.

3.    ZTC2  обрабатывает этот файл (результат работы ZTCPP1)
   и создает обычный объектный файл типа .OBJ.

4.    Шаги 1, 2 и 3 выполняются для каждого файла  C++ прог-
   раммы.

5.    Запускается  линкер  (редактор  связей),  он  собирает
   все .OBJ-файлы вместе с (нужными)  библиотечными процеду-
   рами в один файл типа .EXE,  который может быть непосред-
   ственно исполнен.

6.    Если нужно получить файл типа .COM,  запускается прог-
   рамма EXE2BIN, которая преобразует .EXE файл в .COM файл.

7.    Весь процесс компиляции может быть автоматизирован пос-
   редством программы управления компиляцией ZTC.COM.

   Нотация этого раздела Руководства

   [ ]     возможные (факультативные) элементы.

   { }     элементы,  которые могут повторяться ноль или бо-
           лее раз.


   ZTC1.EXE, ZTC1B.EXE и ZTCPP1.EXE

   Все замечания о ZTC1.EXE относятся также  и к ZTC1B.EXE и
ZTCPP1.EXE.
   ZTC1.EXE и ZTCPP1.EXE являются первым проходом соответст-
венно C компилятора и  C++ компилятора.  Они читают исходный
файл,  выполняют все функции  препроцессора,  контроль  всех
синтаксических  ошибок и генерируют  файл со сжатым промежу-
точным  представлением;  это входной  файл для ZTG или ZTC2.
   ZTC1B - просто версия ZTC1,  которая работает гораздо бо-
лее сложными  программами без переполнения памяти,  зато она
много медленнее.


      Командная строка

   Ключи и параметры командной строки:
   Для компиляции C файла:

   ZTC1 infile {ключи}

   Для компиляции C++ файла:

   ZTCPP1 infile {ключи}


      Входной файл (infile)

   Это исходный файл.  Если расширение опущено, оно принима-
ется равным  ".C" для ZTC1 и ".CPP" для ZTCPP1.


      Ключи

   =nnnn   Устанавливает  размер  внутреннего стека компиля-
           тора.  Попытайтесь  использовать этот ключ,  если
           получите от компилятора  сообщение о переполнении
           стека  ("stack overflow"). Подходящие  десятичные
           значения для nnnn при таких попытках:
              ZTC1      от   2000   до   10000
              ZTC1B     от   5000   до   30000
              ZTCPP1    от   5000   до   30000

   -a      Подавляет  выравнивание  в структурах.  Нормально
           поля в структурах выравниваются  по  16-разрядным
           границам,  чтобы оптимизировать скорость выполне-
           ния на ЭВМ с 16-разрядной  шиной  (например, AT).

   -A      Включает  строгий  контроль  совместимости с ANSI
           стандартом.
           Эквивалентно исполнению:  #define  _STDC_  1
           Следующие ключевые слова в этом режиме не воспри-
           нимаются:
              far  huge  near  pascal  cdecl

   -d[macro[=Text]]
   -D[macro[=тext]]

           Если задан ключ  '-d' (без параметров), то компи-
           лятор считает строку
              #define  DEBUG  1
           включенной  в компилируемый  текст  перед  первой
           строкой входного файла. Аналогично,
              Ключ  -dимямакро  дает строку
              #define  имямакро  1
              Ключ  -dmacro=text  дает строку
              #define macro text
           В ключе не должно быть пробелов.  Если они нужны,
           следует включить весь текст ключа в одинарные или
           двойные кавычки. Например, '-D macro="Это текст"'
           дает строку
              #define  macro  "Это текст"

   -e      Показывает  работу  препроцессора;  сообщения  об
           ошибках  выдаются и записываются в файл листинга,
           если он задан.  Это удобно при проверке того, что
           результаты  макроподстановок  совпадают с ожидае-
           мыми.

   -f      Генерирует в  код  команды  процессора  8087  или
           80287. Это заметно ускоряет выполнение, уменьшает
           размер кода и повышает точность вычислений. Смот-
           рите раздел об опциях вычислений с плавающей точ-
           кой.

   -g      Вставляет в код  информацию о номерах строк в ис-
           ходном файле. Представление совместимо с отладчи-
           ками SYMDEB и CODEVIEW  фирмы Microsoft. Информа-
           ция о номерах строк  значительно увеличивает раз-
           мер объектного файла.

   -Iincludepath

           Включает указанный маршрут в те, по которым ищет-
           ся файл при исполнении  #include.  Маршрут  может
           как заканчиваться, так и не заканчиваться \. Нес-
           колько маршрутов нельзя задавать одним -I.  Ката-
           логи, в которых ищется включаемый файл,  просмат-
           риваются в следующем порядке:
              Для <...> файлов (т.е. файлов в директивах ви-
              да #include <имя файла>):
                 -I маршруты, в заданном порядке.
                 Маршруты переменной окружения INCLUDE.
              Для "..." файлов (т.е. файлов в директивах ви-
              да #include "имя файла"):
                 Текущий каталог.
                 -I маршруты, в заданном порядке.
                 Маршруты переменной окружения INCLUDE.

   -j[0|1|2]  Различает двухбайтовые литеры азиатского языка
           внутри литерных констант и строк. Если литера сов-
           падает с началом двухбайтовой последовательности,
           следующий байт не проверяется на совпадение с '\'
           или  закрывающей  кавычкой.  Второй байт не может
           быть 0, возвратом каретки (0х0D) или концом файла
           (0х1A).

              0 - японский (умолчание)
                 0х81..0х9F  и  0хE0..0хFC  означают  начало
                 двухбайтовой последовательности.

              1 - тайваньский и китайский
                 0х81..0хFC   означают  начало  двухбайтовой
                 последовательности.

              2 - корейский
                 0х81..0хFD   означают  начало  двухбайтовой
                 последовательности.

   -J      Работа с литерами  как с беззнаковыми  (unsigned)
           по умолчанию. Tип char становится  unsigned char,
           а "строка"  становится  значением  типа  unsigned
           char *. Этот ключ полезен  для  быстрого переноса
           программ,  которые рассчитаны на то, что char яв-
           ляется беззнаковым (по умолчанию char имеет знак).
           Заметьте, что поведение библиотечных функций этим
           ключом не затрагивается,  если только они тоже не
           перекомпилируются.

	      Программы, зависящие от "знаковости" char, не-
              переносимы и рано или поздно становятся источ-
              ником проблем. Рекомендуемая практика:

              signed char   Требуется,  чтобы  этот char был 
                            со знаком.

	      unsigned char Необходимо,  чтобы этот char был 
                            беззнаковым.

	      char          Программа не зависит от "знаково-
                            сти" этого char.

           Если позже возникнет необходимость перенести про-
           грамму на более старый компилятор, не поддержива-
           ющий ключевое слово signed, то сделайте так:

              #ifndef _ZTC_  /* если не Zortech C */

              #define signed /* убираем ключевое слово */

              #endif

   -l[listfile]  Генерация файла листинга с именем listfile.
                 Если listfile опущен, имя строится по умол-
                 чанию, т.е. как имя входного файла с расши-
                 рением .LST.   В этом файле  будет отражена
                 и работа  процессора,  если  задан  также и
                 ключ -e.   В файл  включаются  сообщения об
                 ошибках и номера строк.

   -m[S|M|C|L]   Выбор модели памяти задается буквой, следу-
                 ющей за  -m.  Моделям присущи следующие ог-
                 раничения:


                    Модель                    Код     Данные

                 S - Small    (Малая)         64К      64К

		 M - Medium   (Средняя)        1М      64К

		 C - Compact  (Компактная)    64К       1М

		 L - Large    (Большая)        1М       1М

           Нет, T модель памяти не забыта. Программа в T мо-
           дели  (.COM)  создается при редактировании связей
           специальным  образом  для  программы  в S модели.
           Смотрите раздел о создании .COM файлов.  За даль-
           нейшей  информацией  обратитесь  также к разделам
           "Сложные черты  системы" и "Интерфейс с ассембле-
           ром".

   -ooutfile  Задает имя выходного файла (outfile), отличное
           от нормального. Нормально имя выходного (промежу-
           точного) файла то же, что и у входного файла,  но
           с расширением .TMP.

   -p      Выключение автопрототипирования. Это обеспечивает
           беспроблемную компиляцию старых программ. Смотри-
           те раздел по автопрототипированию во второй части.

   -r      Включение строгого прототипирования. Функции дол-
           жны  объявляться и прототипироваться до использо-
           вания.  Заметим, что int func() будет интерпрети-
           роваться как int func (void).

   -u      Подавляет определения  предопределенных макросов.
           Смотрите  раздел  о  предопределенных макросах во
           второй части.

   -v      "Разговорчивая" компиляция.  Выводится имя каждой
           встречаемой при компиляции функции.  Режим позво-
           ляет определить,  где в программе  находится про-
           цесс компиляции, если возникают неприятности.

   -w      Подавляет  сообщения об ошибках уровня предупреж-
           дений.

   -x      Не останавливать компиляцию при достижении лимита
           количества ошибок.  Компиляция продолжается и вы-
           водятся все обнаруженные ошибки.


      Переменные окружения

   Переменная окружения INCLUDE проверяется:  она должна со-
держать маршруты для поиска  файлов в  #include  директивах.
Формат тот же, что и для  PATH - переменной  окружения  DOS.
Пример   команды,   которая   могла  бы  быть   помещена  в
AUTOEXEC.BAT:

   SET INCLUDE=C:\ZORTECH;C:\ZORTECH\INCLUDE

   Это заставит ZTC1 или ZTCPP1 добавить каталоги C:\ZORTECH
и C:\ZORTECH\INCLUDE для поиска файлов в директивах #include.

   Примеры:

1. ZTC1 hello

      Компилировать  входной  файл  hello.c  в выходной файл
      hello.tmp.

2. ZTC1 hello -od:XYZ -l -dabc -i\compiler\

      Компилировать входной файл hello.c в файл d:XYZ.  Соз-
      дать файл листинга  hello.lst.  Определить макрос abc.
      Искать файлы в #include директивах по маршруту \compi-
      ler\.



ZTG.EXE

   ZTG.EXE  является программой глобальной оптимизации.  Она
исполняется над входным файлом,  произведенным одной из трех
программ - ZTCPP1,  ZTC1  или  ZTC1B,  и ее выходной файл, в
свою очередь, является вводом для ZTC2.EXE или ZTC2B.EXE.
   На этом проходе не возникает  синтаксических ошибок в ис-
ходном файле;  все такие ошибки в исходном файле обнаружива-
ются на первом проходе.


      Командная строка

   ZTG ввод [-овывод] {(+|-)ключи} [-v] [=nnnn]

   ввод     Выходной файл от ZTCPP1,  ZTC1  или ZTC1B.  Если
            расширение в имени файла не указано,  оно прини-
            мается равным .TMP .
   вывод    Выходной файл для ZTG. Если он не задан, имя вы-
            ходного файла формируется как имя входного файла
            с расширением .TMO .
   -v       "Разговорчивая"  компиляция  (перечисляет  имена
            функций по мере их обработки).
   =nnnn    Установка размера  внутреннего  стека  программы
            ZTG. Этот режим полезен при получении от ZTG со-
            общения  "Stack Overflow"  (Переполнение стека).
            Стоит попробовать значения от 5000 до 30000.


      Прочие ключи

   Для остальных ключей "+" задает включение соответствующей
оптимизации, а "-" - выключение.

   all      Выполнение всех оптимизаций (умолчание).
   cnp      Распространение констант.
   cp       Распространение копий.
   da       Удаление ненужных присваиваний.
   dc       Удаление неисполняемого кода.
   dv       Удаление ненужных переменных. Вычисление облас-
            тей действия.
   gcse     Глобальные общие подвыражения.
   li       Удаление инвариантов из цикла.
   liv      Индуктивные переменные цикла.
   loop     Итеративное применение оптимизаций.
   none     Не выполнять никаких оптимизаций.
   reg      Выполнять наше собственное распределение регист-
            ров.
   space    Предпочитать  оптимизацию размера памяти оптими-
            зации скорости исполнения.
   time     Предпочитать оптимизацию скорости исполнения оп-
            тимизации размера памяти.
   vbe      Очень нагруженные выражения.
   w        Включить предупреждения (вроде использования не-
            инициализированной переменной).

      Примеры:

   ZTCPP1 demo
   ZTG demo
   ZTC2 demo
   LINK demo

   означает компиляцию,  оптимизацию и редакцию связей прог-
раммы demo.cpp.

   ZTG demo +space -w

   означает оптимизацию  с  предпочтением  экономии памяти и
выключенными предупреждениями.



   ZTC2.EXE и ZTC2B.EXE

   Все замечания о ZTC2.EXE относятся и к  ZTC2B.EXE.  ZTC2B
является версией ZTC2,  которая может работать с более слож-
ными  программами без выхода за границы памяти,  но работает
гораздо медленней.

   ZTC2     вход [-oвыход] [-s] [-v] [=nnnn]

   ZTC2   - генератор кода для 8086,  преобразующий выходной
файл из-под ZTCPP1, ZTC1, ZTC1B или ZTG в .OBJ файл, который
может участвовать в редакции связей. На этом проходе не воз-
никает синтаксических ошибок, все они индицируются на первом
проходе.  При успешном  завершении  ZTC2  промежуточный файл
(вход) уничтожается.


      Входной файл

   Вход - входной файл. Если расширение в имени файла отсут-
ствует или равно .C,  оно принимается равным  .TMP  или .TMO
(.TMO файлы - результат работы ZTG).


      Ключи

   =nnnn    Устанавливает размер  внутреннего стека компиля-
            тора.  Этот режим стоит попробовать при заверше-
            нии  компиляции  с  сообщением  "stack overflow"
            (переполнение стека). Подходящие значения (деся-
            тичные):

		      ZTC2   от 2000 до 10000

		      ZTC2B  от 5000 до 30000

   -oвыход  Если ключ задан, он определяет имя выходного фай-
            ла;  по умолчанию имя выходного  файла совпадает
            с именем входного файла, но с расширением .OBJ.

   -s       Вызывает контроль переполнения стека при входе в
            каждую функцию.

   -v       Компиляция  в "разговорном" режиме.  Выводит имя
            каждой функции при ее обработке.



   Команда ZTC

   ZTC - программа управления компиляцией. Команда ZTC похо-
жа на команду CC в Юникс. ZTC выполняет все проходы компиля-
тора,  редакцию связей, BUNCH, EXE2BIN и даже MASM, если не-
обходимо.  Программа из одного  или нескольких  файлов может
быть создана одной командой.
   ZTC воспринимает файлы различных типов, в том числе исход-
ные  C и C++,  исходные на ассемблере, объектные и объектные
библиотеки.  Исходные C файлы (.C)  компилируются при помощи
ZTC1 или ZTC1B. Исходные C++ файлы (.CPP)  компилируются при
помощи ZTCPP1. Ассемблерные файлы  (.ASM)  компилируются при
помощи MASM.
   Объектные файлы  (.OBJ) включаются на этапе редакции свя-
зей.  Библиотечные файлы (.LIB) включаются на этапе редакции
связей в библиотечном разделе.

   Синтаксис ZTC:

   ZTC      {ключи} файл1 {файл2}

   Выходной файл (если только ключ -o не переопределяет его)
есть имя файла1 с обрезанными  маршрутом и расширением и до-
бавленным подходящим расширением (.OBJ, .EXE или .COM).  ZTC
допускает для файл1 и файл2 использование шаблонов имени фай-
ла. Если имена заданы без расширения, ZTC в следующем поряд-
ке ищет  файлы:  .CPP  .C  .ASM  .LIB.   Ключи для ZTC - это
все ключи ZTC1 и ZTC2 плюс:

   -A       Включает контроль  строгой  совместимости с ANSI
            стандартом.

   -b       Использовать ZTC1B и ZTC2B; полезен, если ZTC1 и
            ZTC2 переполняют память.

   -B       Исполнить BUNCH над полученным .EXE файлом.  Это
            необходимо,если один из модулей - C++ модуль,  и
            был использован LINK фирмы Microsoft.

   -c       Лишь компилировать/ассемблировать  исходные фай-
            лы, но не линковать их.

   -co      Линкование для  CodeView.  При компоновке должен
            быть использован  MS-LINK (редактор связей фирмы
            Microsoft);  LINK фирмы  Zortech не поддерживает
            CodeView.

   -cpp     Использовать ZTCPP1 и для .C, и для .CPP файлов.
            Нормально  ZTC пытается  использовать  ZTC1  или
            ZTC1B для файлов с расширением .C.

   -g       Генерировать .MAP файл при редакции связей.  При
            этом в .OBJ файлы помещается отладочная информа-
            ция.

  -m[M][i]  M задает модель  памяти;  i сообщает о том,  что
            программа является чисто целочисленной  (что вы-
            зывает  подключение  INT.OBJ,  в случае -mi, st,
            OBJ при редакции связей).  M может быть одной из
            следующих букв:

               S   S модель (умолчание)
               M   M модель
               C   C модель
               L   L модель
               T   T модель (смотрите .COM программы)

            Примеры: без ключа -m
                            Малая модель  .EXE с плаваю-
                            щей точкой.
                     -msi   Малая модель с только целыми.
                     -mt    COM файл с плавающей точкой.
                     -mti   COM файл с только целыми.

   -o       Выполнять оптимизацию (запускать ZTG.EXE).

   -o+флаг

   -o-флаг  Запускать оптимизатор с +режимом или с -режимом.

   -oимяфайла   Задает выходной файл. Если задано и -c,  это
                .OBJ файл, иначе - .COM или .EXE файл.

   =nnnn    Устанавливает размер  стека  для  ZTCPP1,  ZTC1,
            ZTC1B, ZTG, ZTC2 и ZTC2B,  где  nnnn = размер  в
            байтах. Командные  строки  программ выводятся по
            мере исполнения. Если командная строка LINK длин-
            нее 127 литер,  ZTC создает для редактора связей
            командный файл с именем exefile.LNK  и запускает
            редактор связей с этим файлом.

  -r        Режим  строгого  прототипирования.  Все  функции
            должны  быть  объявлены и прототипированы до ис-
            пользования.  В этом режиме int func() будет ин-
            терпретироваться как int func (void).

   -v       Компиляция в "разговорчивом" режиме (будет также
            выводиться номер версии).


   Переменные окружения

   ZTC использует следующие переменные окружения:

   INCLUDE  Фактически используется программами ZTC1,  ZTC1B
            и  ZTCPP1;  задает  маршруты для поиска файлов в
            директивах препроцессора #include.  Эти маршруты
            используются после маршрутов, заданных ключом -i.

   TMP      Маршрут к каталогу,  в который записываются про-
            межуточные файлы. Если эта переменная не опреде-
            лена, по умолчанию используется текущий каталог.
            Это же относится и к редактору связей.

   LIB      Фактически используется программой  LINK (редак-
            тором связей). Задает маршруты к библиотекам.

   CFLAGS   Добавление  к командной  строке  ZTC.  Например,
            чтобы всегда  вкючать "разговорчивую" компиляцию
            и использовать ZTC1B и ZTC2B:

               SET CFLAGS=-v -b


                  Примеры

   1.          ZTC  -c  myprog  -o+space
            Компилировать myprog.c в myprog.obj, с оптимиза-
            цией, ориентированной на экономию памяти.

   2.          ZTC  myprog
            Компилировать и линковать myprog.c  в myprog.exe

   3.          ZTC  -ml  file1.c  file2.c
            Компилировать file1  и  file2, используя большую
            модель памяти и затем  собрать (слинковать) их в
            FILE1.EXE.

   4.    ZTC myprog.c mog.cpp myprog1.asm my.lib myprog2.obj
            а. Компиляция с языка C файла MYPROG.C.
            б. Компиляция с языка C++ MOD.CPP
            в. Компиляция с ассемблера  (MASM)  MYPROG1.ASM.
            г. Редакция связей (линкование) файлов:
               MYPROG.OBJ, MOD.OBJ, MYPROG1.OBJ, MYPROG2.OBJ,
               MY.LIB  в  MYPROG.EXE.

   5.          ZTC  *.C  -otest.exe
            Компилировать все .C файлы  в текущем каталоге и
            собрать (слинковать) их в файл TEST.EXE.



                                         СПРАВОЧНИК  ПО  C++
                                         ───────────────────


Комментарии

   В C++ //  начинает  комментарий,  который  оканчивается с
концом строки, на которой появился. C++ поддерживает и обыч-
ные C комментарии, использующие символы /* в качестве начала
комментария и */ - в качестве конца комментария. Такие ком-
ментарии не могут быть  вложенными.  Чтобы  закомментировать
блоки кода, рекомендуется использовать #if 0 и #endif.


Идентификаторы

   Идентификатор может содержать до 127 значащих литер. Боль-
шее количество регистрируется как синтаксическая ошибка. Раз-
решены подчерки, буквы и цифры. Регистр букв (большие/малень-
кие) существенен.


   Ключевые слова

   Следующие слова являются зарезервированными:

      auto, break, case, char, class, const, continue,
      default, delete, do, double, else, entry, enum,
      extern, far, float, for, friend, goto, if, inline,
      int, long, near, new, overload, operator, public,
      register, return, short, signed, sizeof, static,
      struct, switch, this, typedef, union, unsigned,
      virtual, void, volatile, while

   Идентификаторы, которые не следует употреблять во избежа-
ние конфликтов с другими реализациями:

      asm, cdecl, fortran, huge, pascal


   Конфликты с библиотечными именами


   Необходимо с осторожностью использовать внешние идентифи-
каторы,  начинающиеся  с  подчерка (_),  поскольку  подобные
идентификаторы  используются  в  библиотеках  и генерируются
компилятором. C++ допускает широкое совместное использование
имен, т.е. использование совпадающих по написанию  идентифи-
каторов в различных смыслах; поэтому многие глобальные имена
имеют одно "произношение" в C++ и другое (т.е. идентификатор
заносится в .OBJ файл с изменениями) - в  редакторе  связей.
Чтобы обеспечить  максимальную  совместимость с отладчиками,
генерируемые имена находятся в том же пространстве имен, что
и нормальные C идентификаторы. Возникают потенциальные конф-
ликты имен. Для минимизации вероятности такого события:

   * Никогда  не  используйте  идентификаторы,  начинающиеся
     или кончающиеся подчерком.

   * При работе с глобальными  совместно используемыми функ-
     циями  объявляйте  их в одном и том же порядке в каждом
     модуле.  Фактически только первая должна быть объявлена
     первой в каждом модуле, поскольку только первая не под-
     вергается преобразованию имени,  так как иначе у Вас не
     будет возможности хранить  совместно используемые функ-
     ции в библиотеке.

   * Просмотрите  создаваемый  редактором связей  .MAP  файл
     несколько раз,  чтобы получить представление о способах
     генерации  имен компилятором и затем избегать использо-
     вания похожих имен.

   * Если  Вы  используете  конструкторы или деструкторы для
     статических  переменных,  не используйте  один и тот же
     исходный файл для генерации более чем одного объектного
     файла с тем, чтобы затем собрать (слинковать) их вместе.
     Причина в том, что имя для уникальности строится из име-
     ни исходного файла. Например, по файлу test.cpp сгенери-
     руются такие глобальные имена:

         _STItest_cpp_  и  STDtest_cpp_


Литерные константы

   Стандартная  литерная  константа  заключается в одиночные
кавычки,  например,  'a'.  Литеры также могут быть представ-
лены "ESC-последовательностью".  Она  задает  битовое  пред-
ставление  кода литеры в шестнадцатиричном  или восьмиричном
формате.  ESC-последовательность  начинается  с  обратной
наклонной черты (backslash) \ .

битовое представление   \nnn   восьмиричный    код    литеры
битовое представление   \xnn   шестнадцатеричный  код литеры

   ESC-последовательность  \0 - специальный  случай,  пред-
ставление литеры NULL. Другие литеры могут быть представлены
такими ESC-последовательностями:

  новая строка (new-line)                     \n
  горизонтальная табуляция (horizontal tab)   \t
  вертикальная табуляция (vertical tab)       \v
  возврат на символ (backspace)               \b
  возврат каретки (carriage return)           \r
  перевод страницы (form feed)                \f
  обратная черта (backslash)                  \\
  одинарная кавычка                           \'
  двойная кавычка                             \"

   Допускаются "мультилитерные"  константы.  Например,  'ab'
эквивалентно 0х6162. 'abcd' эквивалентно 0х61626364L.


Типы

   Следующие базовые типы данных реализованы как:

      char            => 8 бит со знаком
      usigned char    => беззнаковые 8 бит
      int             => 16 бит со знаком
      unsigned        => беззнаковые 16 бит
      long            => 32 бита со знаком
      unsigned long   => беззнаковые 32 бита
      float           => 32 бита с плавающей точкой
      double          => 64 бита с плавающей точкой
      near pointer    => 16-битовое  смещение  в  сегменте
      far pointer     => 16-битовый адрес  сегмента и 16-би-
                            товое смещение

   Значения хранятся в памяти,  где наименее значащий ("пра-
вый")  байт имеет наименьший  адрес.  Следующие базовые типы
эквивалентны:

      short           => int
      signed short    => int
      unsigned short  => unsigned
      unsigned int    => unsigned
      signed int      => int
      signed long     => long
      long float      => double
      long double     => double


Константы и неявно изменяющиеся переменные (const и volatile)

   Спецификаторы const и  volatile  определяют,  как и когда
компилятор  будет  работать  с объектом.  Спецификатор const
объявляет  объект  константой,  которой  нельзя присваивать.
Объект может быть объявлен с const потому, что он размещен в
ПЗУ или не должен модифицироваться (как, скажем, таблица дан-
ных). Компилятор будет рассматривать присваивания константам
как ошибку.  Спецификатор volatile сообщает компилятору, что
объект может  изменить значение, даже если программа явно не
меняет его.  Объект нужно  объявлять как  volatile, если это
привязанный к памяти  регистр  устройства или объект данных,
разделяемый отдельными процессами. Описатель volatile решает
проблему программистов, работающих с неявно изменяемыми дан-
ными и  использующих  компилятор.

   Компиляторы с минимальной оптимизацией читают  переменную
всякий раз,  когда нужно ее значение.  Компиляторы с большей
оптимизацией,  как ZORTECH C++,  читают  значение переменной
первый раз, когда оно нужно, а затем  хранят его во внутрен-
них регистрах для последующих чтений. А если объект объявлен
как volatile,  то оптимизатор читает переменную  каждый раз,
когда требуется ее значение.

   Пример:

      const int a=3;    /* гарантируем, что a неизменяема */
      volatile int flag;
                 /* флаг может быть установлен асинхронно */
      func()
      {
         flag = 0;
         while (flag==0);              /* ждем прерывания */
      }
            /* предположим,  что при возникновении  прерыва-
               ния от таймера всегда вызывается service() */
      service()
      {
         flag = 1; /* индицируем, что возникло прерывание */
      }


Внешние и глобальные переменные

   Есть три типа глобальных объявлений:

   extern int v1;
   int v2 = 67;
   int v3;

   Первое объявление означает,  что память под v1 фактически
отводится в некотором другом  модуле.  Второе означает,  что
память под v2 отводится в этом блоке,  а в других модулях на
нее можно ссылаться посредством внешних (extern) объявлений,
т.е. объявлений первого типа.  Третье объявление создает об-
щий блок (common block) для v3.

   Общие блоки  создаются, когда  переменная объявляется как
глобальная, но без инициализации. Это значит, что объявление
общего блока может быть во многих исходных модулях, но толь-
ко один экземпляр v3 фактически будет размещен, и все объяв-
ления v3 будут относиться к нему.

   Если в одном модуле  имеется объявление общего блока, а в
другом - глобальное  объявление с инициализацией,  то память
отведется  в  соответствии  со  вторым  обявлением  и прочие
объявления общего блока типа первого  объявления будут отно-
ситься именно к ней.

   Является  ошибкой  объявление инициализированной глобаль-
ной переменной с одним именем в нескольких модулях. Является
также ошибкой  объявление  внешних переменных при отсутствии
где-либо общего блока или глобального объявления с инициали-
зацией для них.  Общие блоки размещаются в сегменте c_common
и инициализируются нулем стартовым кодом из C.OBJ. Общие бло-
ки заносятся в  .OBJ  файл как  COMDEF  записи, что является
Microsoft-расширением формата стандартного .OBJ  файла фирмы
Intel.


Выравнивание данных

   Все объекты данных выравниваются по границе 16-разрядного
слова. Это ускоряет исполнение кода на центральных процессо-
рах с 16-разрядной шиной данных  (как IBM-AT).  Выравнивание
можно подавить, если задать при компиляции ключ "-a". В этом
случае при появлении  двух  или более идущих подряд литерных
полей в структуре первое  будет  выравнено по границе слова,
а последующие - по границе байта.


Параметры функций

   Некоторые типы в качестве параметров  функций модифициру-
ются:

   char            изменяется на int
   float           изменяется на double
   array of        (массив из ...) изменяется  на pointer to
   unsigned char   изменяется на unsigned

   Примеры

      int func(a,b,c,d)
      char a;
      short b;
      float c;
      int d[];

   эквивалентно:

      int func(a,b,c,d)
      int a;
      int b;
      double c;
      int *d;


Указатели

   Указатели являются "квалифицированными", т.е. указателями
на определенный тип, что проверяется компилятором. Для прео-
доления этого ограничения можно использовать явное приведе-
ние (cast) указателей, например:

   char *p;
   int *a;
   a = (int *) p; /* приведение позволяет избежать синтакси-
                     ческой ошибки */


Инициализация

   Статические и глобальные переменные  инициализируются ну-
лем, если иного не задано. Автоматические переменные при от-
сутствии явной инициализации в начальный момент содержат му-
сор.  Объединения можно инициализировать по типу его первого
члена.

   Пример:

union a {
           int i1;
           float f1;
           double d1;
        }  union_a = 0x123;       /* инициализация для i1 */


Операции с плавающей точкой

   Все операции с плавающей точкой выполняются над значения-
ми с двойной точностью (double), например:

      float a, b, c;
      a = b * c;

   эквивалентно:

      float a, b, c;
      a = (float) ((double) b * (double) c);

         Заметьте,  что +0 и -0 оба допустимы, отличны друг
         от друга и означают ноль.

   Ошибки операций с плавающей точкой можно перехватить, пе-
реписав процедуру CXFERR,  имеющуюся в исходных библиотечных
файлах (FLOAT.ASM).


Препроцессор

   Первый проход компилятора включает препроцессор,  который
поддерживает  все директивы,  определенные  ANSI стандартом.
Директивы препроцессора начинаются с литеры #, которая долж-
на быть первой "непустой" литерой на строке. Пробелы и табу-
ляции могут быть между #  и директивой.  Вот директивы, под-
держанные препроцессором:

   #if, #else, #endif, #elif, #ifdef, #ifndef, #error,
   #line, #define, #undef, #include, #pragma,  #message,
   #exit

   В текущей  версии прагматы не реализованы;  все директивы
#pragma молча  игнорируются.  Результаты  препроцессирования
могут быть  визуализированы  при помощи  ключей  '-e' и '-l'
в  командной  строке  ZTC1, ZTC1B или ZTCPP1.


Макросы

   Макроподстановки поддерживаются в полном объеме. Зациклен-
ные макроопределения вроде

      #define unix unix

раскрываются как 'unix'. Подстановка аргументов внутри строк
не производится. Например,  если препроцессор встречает сле-
дующее определение:

      #define X(y) printf("y = %d\n", y)

то    X(abc);      будет раскрыто как:

      printf("y = %d\n", abc);

   Заметьте, что y в строке не была замещена.  Если макрооп-
ределение написано так:

      #define X(y) printf(#y " =%d\n",y);

то эта же подстановка выполнится так:

      printf("abc" " =%d\n",abc);

   При этом смежные строки будут сконкатенированы.


Предопределенные макросы

   Следующие макросы заранее  определены при компиляции. Они
могут быть отменены ключом -u.

      _ZTC_        Раскрывается как номер версии компилятора
                   (в шестнадцатиричном виде). Например, для
                   версии 4.02 : 0х402.
      DLC          Раскрывается так же, как и _ZTC_. Обеспе-
                   чивает совместимость с  Datalight C.  Для
                   будущих разработок не использовать.
      MSDOS        Раскрывается как 1.
      I8086        Раскрывается как 1.

   Один из следующих  макросов  определен и установлен в 1 в
зависимости от модели памяти:

      M_186SM
      M_186MM
      M_186CM
      M_186LM

      SPTR        Определен и установлен в 1 для S и M моде-
                  лей.
      LPTR        Определен и установлен в 1 для C и L моде-
                  лей.
      c_plusplus  Определен и установлен в 1, если использу-
                  ется ZTCPP1.

   Следующие макросы соответсвуют рекомендациям  ANSI C и не
могут быть отменены ключом -u.

      _LINE_   Устанавливается в текущий  номер строки в ис-
               ходном файле.
      _FILE_   Устанавливается  в строку с именем  исходного
               файла.
      _DATE_   Устанавливается  в  строку  с текущей  датой.
      _TIME_   Устанавливается в строку с текущим  временем.

   Следующие макросы определены и установлены в 1,  если за-
дан ключ -A :

      _STDC_


Включаемые файлы

      #include "имяфайла"

   Имя  файла  ищется в текущем каталоге.  Если его там нет,
используется  список  маршрутов,  заданный ключом '-I' в ко-
мандной строке,  а затем - список маршрутов,  заданный пере-
менной окружения INCLUDE.

      #include <имяфайла>

   Имя файла сначала ищется в каталогах по маршрутам, задан-
ным в ключе '-I' командной  строки,  затем - по маршрутам из
переменной окружения INCLUDE и, наконец,- в текущем каталоге.

   Литера 'обратная черта'  в строках,  задающих маршруты, в
директивах  #include не рассматривается  как "ескейп литера"
(как в '\n').  Это позволяет записать маршрут в самом опера-
торе включения  так же,  как в командной строке  ДОС или еще
где-либо. Некоторые  компиляторы MSDOS требуют, чтобы строка
содержала двойные обратные черты  (\\)  для  разделения имен
каталогов. Например:

      #include "c:\include\stat.h"           //нынешний ZTC
      #include "c:\\include\\stat.h"     //более старые ком-
                                         //пиляторы.


Прочие директивы препроцессора

   Поддерживаются две нестандартных директивы препроцессора:
#message и #exit.

      1. #message строка <перевод строки>

         Строка выводится на дисплей в процессе  компиляции.
         Например:

      #if INTONLY
      #message "компиляция только для целых"
      #endif


      2. #exit константное выражение <перевод строки>

         Заставляет компилятор  прекратить компиляцию,  зак-
         рыть все выходные  файлы и завершиться со статусом,
         равным  константному  выражению.  Статус завершения
         можно  проверить в командном файле, используя функ-
         цию DOS ERRORLEVEL.

   Пример:

         #if sizeof(int) != 2
         #message "Целые должны быть двухбайтовыми"
         #exit 1  /* завершение компиляции с errorlevel=1 */
         #endif


Ограничения

   Литер в строке:                           без ограничения
   Литер в идентификаторе:                   127
   Литер во внешнем идентификаторе:          127
   Литер в строке:                           без ограничения
   Число вариантов (case) в переключателе:   без ограничения
   Литер в параметре макроса:                без ограничения
   Число параметров макроса:                 127
   Число параметров функции:                 без ограничения
   Длина текста макроподстановки:            без ограничения
   Число индексов в массиве:                 без ограничения
   Сложность объявления:                     без ограничения
   Глубина вложенности #include:             14
   Число маршрутов для #include:             10
   Глубина вложенности #if:                  10
   Число параметров командной строки:        32 (при  выпол-
      нении раскрытия имен файлов со * или ?, что приводит к
      прикомпоновке  одного  из  _MAINx.OBJ,  где x - одна из
      букв S, M, C, L, - без ограничения)

      Замечание: "без ограничения" означает, что отсутствуют
                  ограничения компилятора. Однако, могут воз-
                  никнуть ограничения памяти.


Прототипирование функций

   Прототипирование  позволяет объявить число и тип парамет-
ров, передаваемых функции. С этого места компилятор проверя-
ет каждое обращение к функции и сообщает об ошибке, если вы-
зов не соответствует прототипу. Эта черта контроля типов вы-
полняет значительную часть функций утилиты LINT ОС ЮНИКС.

   Объявления  прототипов  могут быть в нескольких различных
формах для различных форм функций C++.  Объявление прототипа
может специфицировать каждый параметр,  некоторые аргументы,
позволять  произвольное  число  параметров  любого  типа или
объявить, что никаких параметров не передается.  Кроме того,
новый тип (void *),  использованный с прототипами,  является
родовым указателем.

   Объявления прототипов функций во многом  похожи на старые
"внешние" объявления (extern func();), но добавляются описа-
ния типов параметров. Эти описания типов параметров являются
абстрактным  вариантом  типа.  Для удобства чтения программы
можно включать в прототип и имена параметров, эти имена игно-
рируются.  Например,

      extern int fseek(FILE *, long, int);

   Функция fseek объявляется  имеющей три параметра;  первый
параметр - указатель на тип  FILE,  второй - длинное целое и
третий - целое.  Объявление также определяет, что fseek пос-
тавляет целое.  Функция, которая не должна иметь никаких па-
раметров, объявляется со списком параметров void:

      abort(void);

   Это объявление функции  утверждает,  что abort никогда не
должен вызываться с какими-либо параметрами.

   Объявления  функций с неизвестным числом параметров неиз-
вестного типа формируется при помощи старого внешнего объяв-
ления функции. Это обеспечивает совместимость с более стары-
ми программами. Например:

      extern int printf();

   Это вполне законное объявление,  однако,  его можно улуч-
шить, зная, что первый параметр printf - строка литер. Более
точное объявление для printf таково:

      extern int printf(char * ...);

   Теперь первый параметр  printf должен быть литерной стро-
кой, а прочие - в любом числе и любого типа.

   "Тип родового указателя" (generic pointer type) использу-
ется,  когда тип указателя может варьироваться в зависимости
от приложения.  Например, при вызове процедуры отведения па-
мяти  malloc  она  возвращает указатель на тип, какой нужно,
скажем,  на массив литер или на структуру.  Когда вызывается
процедура освобождения памяти free, указатель может быть лю-
бого  типа.  Родовой  указатель  формируется при помощи типа
void в качестве базового. Например:

      extern void *malloc(unsigned);
      extern int free(void *);


   Индуцированное прототипом приведение (cast)

   Объявление прототипа функции дает дополнительную информа-
цию компилятору о функции и последующих вызовах ее. Если фа-
ктический параметр в вызове  функции не того типа,  но может
быть к нему приведен, то компилятор выполнит необходимое при-
ведение.  Компилятор не сообщит об ошибке, если такое приве-
дение можно выполнить. Следующий пример показывает, как ком-
пилятор приведет int к long в вызове fseek.

      extern int fseek(FILE *, long, int);
      int ret;
      FILE *fd;
         ret = fseek(fd, 15, 0);              //что написано
         ret = fseek(fd, (long)15, 0);      //как понимается


   Прототипирование char и float

   Прототипы также позволяют компилятору производить меньший
код, используя дополнительную информацию о функции и переда-
ваемых ей параметрах.  Если  функция  объявлена с параметром
типа float  или  char,  компилятор может решить не расширять
char до  int  или float до double.  Это экономит команды при
каждом обращении к функции. Компилятор должен знать прототип
функции и для  компиляции  вызова  функции, и для компиляции
самой функции,  поскольку типы char и float должны обрабаты-
ваться корректно.  Дополнительные  примеры  прототипирования
включены в библиотечные файлы заголовков.


Автопрототипирование

   Автопрототипирование есть процесс, при котором, если про-
тотип  функции не задан явно,  компилятор  генерирует его по
тому,  как функция  используется.  Последующие использования
проверяются  на  соответствие со сгенерированным прототипом.
Это может оказаться большим подспорьем  при  поиске  неясных
ошибок. Скажем, для

      { char c;
        unsigned char uc;
        signed char sc;
        int i;
        unsigned u;
        long l;
        unsigned long ul;
        float f;
        double d;
        char  *p;

        func2(c,uc,sc,i,u,l,ul,f,d,p);
      }

прототип для func2 эквивалентен следующему:

      int func2( int,unsigned,int,int,unsigned,
                 long,unsigned long,double,double,char *);

и то же для:

      func2(c,uc,sc,i,u,l,ul,f,d,p);
      char c;
      unsigned char uc;
      signed char sc;
      int i;
      unsigned u;
      long l;
      unsigned long ul;
      float f;
      double d;
      char *p;
      {
         ...
      }

что не то же самое, что:

int func2 (char c, unsigned char uc, signed char sc,
           int i, unsigned u, long l, unsigned ling ul,
           float f, double d, char *p);

В последнем случае "приведения по умолчанию" не выполняются.
Функции, которые воспринимают  различное  число  параметров,
такие как printf()  и  scanf(),  должны прототипироваться до
использования.  Прототипы всех библиотечных функций включены
в соответствующие .h файлы.


Совместимость с C

   Все усилия были приложены, чтобы довести до максимума сов-
местимость между Zortech C и Zortech C++. Программы, которые
ранее компилировались  Zortech C,  должны  компилироваться и
исполняться без модификации с учетом следующего:

      * В C++ имена  структур,  объединений  и  перечислений
        (struct, union, enum)  находятся в общем  поле имен.
        В C они находятся в отдельном поле имен. Это значит,
        что в C++(в отличие от C) нельзя давать именам-ярлы-
        кам структур,  объединений и перечислений те же име-
        на, что и переменным.

      * C++ резервирует несколько новых ключевых слов, кото-
        рые нельзя употреблять как имена переменных.

      * C++ библиотека  должна при редакции связей использо-
        ваться до C библиотеки:  если у Вас есть добавленные
        C библиотеки, они будут нормально работать, пока они
        не конфликтуют с именами из C++ библиотеки и совмес-
        тимы с  Microsoft  (C компилятор этой фирмы).  Более
        ранние версии Zortech C были совместимы с Lattice.

   Пожалуйста, обращайтесь в  Zortech  за деталями по поводу
обновления Ваших добавленных в Zortech библиотек.


Определенные пользователем приведения типов


   Нельзя определять  собственные приведения над беззнаковым
(unsigned) типом. Например:

      struct
      {   operator int();                    /* допустимо */
          operator unsigned int();        /* не допустимо */
      }   stuff;

   В версии Zortech C++ 1.7 это ограничение снято.


Совместимость с C++ фирмы AT&T


   В  Zortech C++  у конструкторов и деструкторов  не должно
быть указано никакого возвращаемого типа.

   В ATT C++ в начало main() вставляется вызов _entry(), что-
бы вызвать все конструкторы модулей.  В Zortech C++ этот вы-
зов выполняется в стартовом модуле C.OBJ.

   Zortech C++  рассматривает объявления  глобальных функций
не членов (класса) с пустыми скобками так же, как в C (неиз-
вестное число  параметров  неизвестного типа).  ATT трактует
это как функции с нулем параметров.


Замечания, ошибки, предостережения при программировании на C++

   C++ -  молодой  язык,  и имеется немало  "темных углов" в
нем,  для которых не видно хороших решений. Вот некоторые из
них:

      * Статические переменные, локальные в функции,  не мо-
        гут иметь конструкторов или деструкторов.

      * При объявлении параметров функций-членов всегда сле-
        дует использовать  метод  полного  прототипирования,
        как в :

           int abc::def(int i)  {...}

        в противопоставлении с :

           int abc::def(i) int i;  {...}

      * Если Вы присваиваете переменной this внутри констру-
        ктора, проверьте,  что это делается по любому  марш-
        руту  (в теле  конструктора).  Это критически важно,
        если класс:

           1.  Имеет члены с конструкторами.
	   2.  Имеет виртуальные функции.
	   3.  Является  производным  от класса с каким-либо
               из вышеназванных свойств.

   Код, который нужно просмотреть:

      stack::stack()
      {
         if (this == 0);
         {  this = my_allocator();
                     //сюда компилятор вставит вызовы конст-
                       рукторов
         }
      }

   Это следует записать следующим образом:

      stack::stack()
      {
         if (this == 0);

         {  this = my_allocator();
                       //сюда вставятся вызовы конструкторов
         }
         else
         {  this = this;             //излишнее присваивание
                       //сюда вставятся вызовы конструкторов
         }
      }

         Заметьте, что это проблема и для  C++ трансляторов;
         они просто не сообщают Вам об этом.

   На самом деле не  существует 100% надежного пути компиля-
тору сделать это для Вас. Нужно помнить, что вызовы констру-
кторов для членов  класса привязываются к каждому присваива-
нию переменной this.  Если таких присваиваний в конструкторе
нет, компилятор генерирует одно в начале, в виде:

      if (this == 0)
      this = _new((long) sizeof(*this));
                     //сюда компилятор вставит вызовы конст-
                       рукторов


Совместное использование модулей на C и C++

   Отдельно скомпилированные  C и C++  объектные файлы могут
свободно  перемешиваться при сборке в один исполняемый.  Нет
необходимости  даже в том,  чтобы модуль, содержащий main(),
был откомпилирован при помощи C++. Предостережения:

      * Если Вы не используете  библиотеки по умолчанию, ко-
        торые автоматически вставляются в .OBJ файл компиля-
        тором, задавайте  C++ библиотеку редактору связей до
        C библиотеки.

      * Исполняемый C++ файл  должен быть собран  редактором
        связей,  который соберет все так, чтобы конструкторы
        и деструкторы вызывались для статических переменных.
        Альтернатива - исполнить  программу  BUNCH  вслед за
        редактором связей. BUNCH поддерживается транслятором
        C++.  На сегодня она требует .MAP файл,  чтобы найти
        таблицы в .EXE файле.  Если .MAP файл не текущий (не
        соответствует .EXE), BUNCH,  вероятно,  сломает  Ваш
        .EXE файл.  ZTC  сгенерирует  .MAP  файл  и исполнит
        BUNCH автоматически, если будет задан ключ -B.

      * Будьте внимательны,  составляя  makefile так,  чтобы
        для каждого файла запускался "правильный" транслятор.

      * По умолчанию расширением имен C файлов  является  .C

      * По умолчанию расширением  имен  C++  файлов является
        .CPP

      * Вы должны знать, как C++ компилятор генерирует имена
        для совместно используемых (overload) функций и тому
        подобных вещей,  если  хотите  обращаться к ним из C
        файла. Если сомневаетесь, используйте OBJTOASM, что-
        бы взглянуть на получившиеся в объектном файле имена,
        или просмотрите  созданный  редактором  связей  файл
        соответствия (map)


   Разное

      * Нет "большой" версии ZTCPP1. ZTCPP1  всегда большой!

      * Конструкторы в модулях вызываются из _entry(), кото-
        рая вызывается стартовым кодом из C.OBJ. Таким обра-
        зом,   обычно  используемая   "заплата"  -  помещать
        _entry() первым оператором в main() - не нужна. Этот
        вызов всегда там,  но  _entry из C библиотеки просто
        возвращает управление,  в то время как _entry из C++
        библиотеки  вызывает  конструкторы в модулях.

      * Деструкторы в модулях вызываются из exit(), так что
        C++ и C имеют разные реализации exit(). По заверше-
        нии main() C.OBJ вызывает exit().

      * Указатели  на  конструкторы  и деструкторы в модулях
        хранятся в глобальном массиве _CTDT_PTR.  Таблица (к
        сожалению) фиксированного размера.  Если нужно изме-
        нить размер,  можно  модифицировать  файл  CTDTPTR.C
        (прилагается)  или  просто  включить в один из своих
        исходных файлов описание для _CTDT_PTR [что угодно].
        Формат таблицы разъясняется в CTDTPTR.C.

      * Помните, что таблица _CTDT_PTR должна быть заполнена.
        Компилятор  не  может  сделать  этого, так как он не
        имеет сведений о других модулях. Есть два пути:

           1. Модифицировать редактор связей, чтобы он делал
              это. LINK Zortech (BLINK) делает это автомати-
              чески.

           2. Перепаковать .EXE  файл после редакции связей.
              BUNCH фирмы Zortech делает это. Если использо-
              ван редактор связей фирмы Microsoft, нужно за-
              пустить BUNCH над полученным .EXE файлом (.MAP
              файл также необходим).

      * Чтобы использовать CodeView, выполните следующие ша-
        ги, убедившись, что Microsoft LINK находится (по пе-
        ременной  окружения PATH) перед Zortech LINK:

           1. Откомпилировать  исходные  модули с режимом -g
              (если нужна информация о номерах строк).

           2. Линковать с режимами /co и /m. Должен быть ис-
              пользован  редактор  связей  фирмы  Microsoft,
              поскольку Zortech LINK (BLINK) молча игнориру-
              ет режим /co.

           3. Выполнить BUNCH над выходным файлом.

           4. Запустить CodeView над результатом.

           5. Если Вы используете ZTC.COM, то так:

                 ZTC -g -co -B файл...

      * Zortech C++  использует развитые возможности формата
        .OBJ файлов. В частности,  он генерирует  COMDEF за-
        писи и зависит от корректности работы ключа  DOSSEG.
        Старые версии редакторов связей  Microsoft будут ло-
        маться при работе с этими средствами.  Мы рекоменду-
        ем к использованию  редактор связей,  поставляемый с
        MASM 5.0 и более поздние,  если Вы хотите работать с
        Microsoft LINK.  Zortech LINK (BLINK)  работает нор-
        мально, но не поддерживает  CodeView, exepack опцию,
        оверлейную структуру и некоторые другие сложные воз-
        можности, доступные в Microsoft LINK.

















			   ПРОГРАММЫ  РЕДАКТИРОВАНИЯ  СВЯЗЕЙ
                           ─────────────────────────────────



BLINK.EXE


   Сборка (линкование, компоновка, редакция связей) программ
в некоторой модели памяти  требует  задания  соответствующей
библиотеки именно для этой модели памяти. Библиотеки для мо-
делей перечислены в следующей таблице:

   Модель       C              FG-графика       C++
   памяти       библиотека                      библиотека

   S или T      ZLS.LIB        FGS.LIB          PLS.LIB

   M            ZLM.LIB        FGM.LIB          PLM.LIB

   C	        ZLC.LIB        FGC.LIB          PLC.LIB

   L            ZLL.LIB        FGL.LIB          PLL.LIB

      Замечание:  Следует  убедиться,  что  объектные файлы,
      откомпилированные  для разных моделей памяти,  не лин-
      куются вместе.


   Ни ZTC,  ни ZED не разбираются в  FGx.LIB  библиотеках, и
одна из них  должна быть явно включена в список сборки, если
используются графические функции.

   BLINK функционально замещает  Microsoft LINK. Причины для
этого:

      * Имеется много версий MS-LINK, и многие старые версии
        не будут корректно собирать программы в Zortech C.

      * Некоторые старые версии  MS-LINK не будут работать с
        библиотечными файлами,  у которых размер страницы 16
        байт.

      * MS-LINK теперь не поддерживается всеми копиями
        MS-DOS.

      * BLINK автоматически выполняет перепаковку .EXE файла,
        что требуется для C++. Это исключает занимающий вре-
        мя дополнительный  проход  (BUNCH),  необходимый при
        использовании MS-LINK.


   Работа с ZTC


   Убедитесь, что BLINK  будет найден (по маршрутам) раньше,
чем MS-LINK. ZTC  использует общее подмножество команд обоих
редакторов связей.  ZTC автоматически создает командный файл
редактора, если командная строка для редактора (связей) пре-
вышает лимит длины строки в ДОС.


   Использование


   BLINK объектные файлы, exe файл, map файл,
                          библиотечные файлы [ключи...] ;

      объектные файлы     объектные файлы,  разделенные плю-
                          сами (+)

      exe файл            имя для результирующего .EXE файла,
                          по умолчанию конструируется из име-
                          ни первого .OBJ файла добавлением
                          (заменой на) расширения .EXE.

      map файл            имя для .MAP файла

      библиотечные файлы  библиотечные файлы и каталоги, раз-
                          деленные плюсами

   Ключи


      /CO[DEVIEW]    Игнорируется.  Информацию  о сборке для
                     отладки  смотрите  в  разделе Отладка с
                     CodeView.

      /CR[OSSREF]    Записывает файл  перекрестных  ссылок в
                     "mapfile.CRF".

      /CT[DTTABLESIZE]:nn     Устанавливает  размер  таблицы
                    _CTDT_PTR равным nn (по умолчанию - 256).

      /DO[SSEG]      Специальное  упорядочивание  сегментов,
                     используемое  микрософтовскими  языками
                     высокого уровня.

      /HE[LP]        Заставляет BLINK высветить список теку-
                     щих доступных опций (режимов).

      /I[NFORMATION] Печатает  информацию о работе  линкера,
                     включая имена обрабатываемых  объектных
                     файлов, порядок и размещение.

      /LI[NENUMBERS] Включать номера строк и соответствующие
                     адреса в .MAP файл.

      /M[AP]         Записать полный map файл.

      /MO[REINFORMATION]   Печатать дополнительную  информа-
                           цию по мере работы редактора свя-
                           зей.

      /NOC[TDTWARNING]     Не предупреждать,  что переполни-
                     лась таблица _CTDT_PTR.

      /NOD[EFAULTLIBRARYSEARCH]
                           Игнорировать библиотеки, заданные
                     в .OBJ файлах.

      /NOI[GNORECASE]      Различать  регистры (верхний/ниж-
                     ний регистр клавиатуры).

      /ST[AСK]:nn    Установит размер стека исполняемого фай-
                     ла равным nn.


   Переменные окружения


   BLINK использует маршрут из переменной  окружения TMP для
записи своих временных файлов. Объектные файлы ищутся снача-
ла в текущем каталоге, затем по маршрутам переменной окруже-
ния LIB. Библиотечные файлы ищутся сначала в текущем катало-
ге,  затем в заданных каталогах и далее - по маршрутам пере-
менной окружения LIB.  Команды для BLINK могут быть помещены
в файл  (называемый  linker  response file - командный  файл
редактора связей). В этом случае запуск BLINK выглядит так:

   BLINK @file.lnk

где file.lnk содержит что-нибудь вроде:

      FILE1+FILE2+
      FILE3
      EXEFILE
      MAPFILE
      LIBFILE/M

что эквивалентно следующему:

      BLINK file+file2+file3,exefile,mapfile,libfile/m



   Различия между BLINK и MS-LINK


      * У BLINK нет "диалогового" режима.

      * В командных строках BLINK недопустимы пробелы.

      * BLINK  не понимает пробелы  в качестве  разделителей
        собираемых  объектных  файлов;  разделять  пары имен
        файлов должен знак плюс (+).

      * BLINK не требует точки с запятой (;) в конце команды,
        но он игнорирует ее, если она есть.

      * BLINK не строит оверлейную структуру.

      * BLINK не имеет режима упаковки .EXE файлов.

      * BLINK не генерирует исполняемых файлов,  совместимых
        с CodeView.

      * BLINK распознает  C++  объектный модуль и соответст-
        венно заполняет таблицу _CTDT_PTR; MS-LINK не делает
        этого.

      * BLINK   генерирует  чуть  меньшие  .EXE  файлы,  чем
        MS-LINK (он просто вычеркивает некоторые бесполезные
        "прокладки"  из  заголовка).  Кажется,  единственный
        эффект от этого тот,  что  программа  EXE2BIN  фирмы
        Microsoft  не может  преобразовать  выход  от BLINK.
        Нужно использовать  Zortech EXE2BIN,  который  будет
        работать с  .EXE  файлами и из-под  BLINK,  и из-под
        MS-LINK. Microsoft EXE2BIN, по-видимому, ожидает,
        что размер заголовка файла кратен 256, а не 16, как
        специфицировано.

      * BLINK  не  поддерживает некоторые  наименее понятные
        возможности MS-LINK.

      * BLINK  ищет  в  библиотеках  неопределенные  внешние
        имена в том порядке, в котором библиотеки заданы. Он
        начинает  с  начала  списка  библиотек  для  каждого
        оставшегося внешнего  имени.  Используется первое из
        встретившихся.  Документация по MS-LINK говорит, что
        он ведет  себя  так же,  однако,  поведение  MS-LINK
        заставляет  предположить,  что он использует  "самый
        эффективный" подход.

   Сообщения об ошибках перечислены в Приложении 2.



BUNCH.EXE


   Назначение


   BUNCH читает  .EXE  файл и соответствующий .MAP файл. Она
заполняет (подправляет) таблицу _CTDT_PTR в .EXE файле, что-
бы та содержала  указатели  для статических  конструкторов и
деструкторов. BUNCH нужна в случае, когда один или более мо-
дулей,  собранных в .EXE файл - C++ модули,  и .EXE файл был
собран  посредством Microsoft LINK.  Если использовался Zor-
tech BLINK,  BUNCH  не нужна,  так как этот  BLINK заполняет
таблицу автоматически.



   Работа с ZTC


   Ключ -B заставит  ZTC автоматически вызвать  BUNCH после
LINK.

   Если задан ключ  -co, и хотя  бы один из исходных файлов,
поданных в ZTC,  имеет расширение .CPP (т.е. является исход-
ным C++ файлом),  то  BUNCH будет  запущена,  поскольку лишь
MS-LINK  может  генерировать   .EXE  файлы,   совместимые  с
CodeView.



   Использование


       BUNCH [-m[smcl]] [-tNNN] exefile

          -m[smcl]    использованная модель памяти
                      (s - умолчание)

          -tNNN       установка  размера  таблицы  _CTDT_PTR
                      (умолчание = 256 указателей на функции)

          exefile     .EXE файл (из этого имени  вычисляется
                       и имя .MAP файла).


   .COM файлы


    BUNCH должна быть исполнена над .EXE файлом до того, как
он будет преобразован в  .COM файл посредством  EXE2BIN.
В этом случае используйте,если нужно, ключ -ms (это режим по
умолчанию).


   Переменные окружения


   BUNCH использует переменную окружения TMP для размещения
в соответствующем каталоге своих временных файлов.

      Пример

      Заполнение для программы prog.exe,  использующей C мо-
      дель памяти:

          BUNCH -mc prog


   Ошибки


   Если  BUNCH обнаруживает  ошибку в процессе  подправления
.EXE файла, она уничтожает его, поскольку, возможно, уже его
подпортила. Если .MAP файл,  соответствующий  .EXE файлу, не
тот, что сгенерирован вместе с .EXE файлом, BUNCH, вероятно,
испортит .EXE файл.


EXE2BIN.COM


   EXE2BIN преобразует .EXE файлы в .COM файлы.
   Синтаксис:

      exe2bin file.exe file.com


   Каждое имя файла должно быть поименовано полностью.
Например, .COM  программа из объектного файла hello.obj
запишется так:

      link ct+hello,hello;
      exe2bin hello.exe hello.com
      del hello.exe



   Целочисленные программы


   Значительная экономия размера  программы может быть полу-
чена,  если Вы не используете вычислений с плавающей точкой.
При редакции  связей  включите в сборку  файл  INT.OBJ. Этот
файл предотвращает подключение из библиотеки процедур работы
с плавающей точкой. При попытке выполнить операцию с плаваю-
щей точкой выдается сообщение:

Floating point not loaded
(Плавающая точка не загружена)

Ключ -mi приводит к включению INT.OBJ в сборку.

      Примеры

         1.
            BLINK myprog+int;
         Слинковать myprog как целочисленную.

         2.
            ZTC -msi myprog
         Откомпилировать и слинковать myprog  в малой модели
         памяти и как целочисленную.



   Создание .COM программ


   .COM файл - это просто образ памяти для программы,  кото-
рая будет исполняться. .EXE  файл устроен сложнее, он содер-
жит информацию о размещении, по которой MS DOS загружает ее.
.COM файлы меньше,  чем .EXE  файлы,  и загружаются быстрее.
Чтобы создать .COM файл, используйте стартовый объектный мо-
дуль  CT.OBJ при сборке, указав его первым среди компануемых
объектных файлов. Объем кода Вашей программы плюс статически
размещаемые данные должны быть менее 64 K.  Пропустите полу-
ченный от редактора связей .EXE файл через утилиту  EXE2BIN,
чтобы создать .COM  файл.  Все  это можно сделать при помощи
ZTC, использовав ключ -mt.

      ЗАМЕЧАНИЕ:  Игнорируйте  предупреждение  об отсутствии
      сегмента стека от редактора связей.  Если Вы использо-
      вали  Zortech BLINK,  следует  использовать  и Zortech
      EXE2BIN, а не Microsoft.  Микрософтовская EXE2BIN соз-
      даст неправильную программу. Zortech EXE2BIN совмести-
      ма и с Microsoft LINK, и с Zortech BLINK.





                                        ИСПОЛНЕНИЕ  ПРОГРАММ
                                        ────────────────────

      PROGNAME [=nnnn] {параметры}

   Когда программа запускается, происходит следующее:

      1.   Сканируется командная строка. Если найдено =nnnn,
           nnnn берется как размер в байтах памяти, отведен-
           ной под стек;  =nnnn удаляется из командной стро-
           ки.  Остаток командной строки разбивается на зна-
           чения для argc и argv[]. Пробелы и табуляции раз-
           деляют аргументы. Пробелы и табуляции могут вклю-
           чаться в аргумент,  если  он  заключен в " или '.
           Перед включением аргумента в  argv[] кавычки уби-
           раются. Команды перенаправления ввода/вывода <, >,
           >> и | обрабатываются MS DOS и не доходят до прог-
           раммы.

      2.   Размещается стек,  используя,  если задано, nnnn,
           иначе  используется глобал _stack.

      3.   Определяется, имеется ли в наличии МП 8087, 80287
           или 80387.

      4.   Вызывается функция _entry(). В C++ _entry() вызы-
           вает  статические  конструкторы,  в C _entry() не
           делает ничего.

      5.   Вызывается _main(argc,argv). В норме _main() про-
           сто вызывает  main().  Если,  однако,  при сборке
           подключен _MAINX.OBJ (где X одна из букв S,M,C,L),
           _main()  выполнит раскрытие
           шаблонов (wildcard expansion)  над  argc и argv и
           передаст модифицированные аргументы в main().

      6.   При  возврате  из  _main()   вызывается  exit(0);
           exit()  отрабатывает вызов функций,  заданных об-
           ращениями к atexit(),  вызов статических деструк-
           торов (для C++) , уничтожение и закрытие файлов.

      7.   В конце своей  работы  exit()  вызывает  _exit(),
           которая возвращает управление  в  MS DOS. Все это
           разъясняется  с  утомительными деталями  в  файле
           C.ASM,  который  находится  на  диске с исходными
           текстами библиотек, поставляемом отдельно.



Расширение командной строки аргументов


   Аргументы  из  командной  строки по умолчанию  передаются
функции  main() в точности такими,  как определено в команд-
ной строке. В системе Юникс (UNIX) интерпретатор команд рас-
крывает  аргументы с именами файлов,  которые содержат "шаб-
лонные" (wildcard) литеры (* или ?) до всех имен файлов, со-
ответствующих спецификации файла. Например,

      prog *.c

заставит  юниксовскую  программу (prog)  иметь  аргумент для
каждого  файла с расширением .c  в argv[].  "*.c"  не  будет
включено в argv[].

   Zortech C  программы могут получать  раскрытые имена фай-
лов - аргументы,  если использовать  процедуру из  _MAIN.OBJ
для раскрытия имен файлов - аргументов до вызова  main.  Для
этого нужно включить  объектный файл  _MAIN.OBJ  в сборку на
этапе редакции связей.


   Команда для редакции связей могла бы быть такой:

      BLINK _MAIN+PROG,PROG;


   Команда для ZTC могла бы быть такой:

      ZTC PROG.C _MAIN.OBJ


   Когда  вызывается  main (argc, argv),  argc  будет  равно
общему числу файлов, подходящих к спецификации шаблона файла
(в частности, при отсутствии подходящих файлов аргументов не
будет). argv[]  будет  содержать аргумент для каждого такого
имени файла, но самой спецификации шаблона файла включено не
будет.  Например,

      PROG ABC *.C "*.h" '*.obj'

будет представлена для main() как если бы:

      PROG ABC a.c b.c "*.h" '*.obj'

   Заметьте, что раскрытие шаблонов не производится, если ар-
гумент "защищен" одиночными или двойными кавычками.



Управление размером стека


   Размер стека может быть задан следующими способами:

      1.   Параметром  командной  строки '=размерстека'  при
           запуске программы.

      2.   Заданием описания  int _stack=nnnn;  где-нибудь в
           исходном тексте программы, где 'nnnn' есть размер
           стека в байтах.

      3.   Модификацией стартового модуля C.ASM.

      ЗАМЕЧАНИЕ:  Не используйте параметр  /STACK  редактора
      связей для установки размера стека.  По умолчанию раз-
      мер стека 2048 байт. Используйте контроль переполнения
      стека, если есть подозрения. Симптомами могут быть "ми-
      стические"  поломки. Компиляция программы с ключом  -s
      включает контроль переполнения стека на входе в каждую
      функцию.



















                                     ГЛОБАЛЬНЫЙ  ОПТИМИЗАТОР
                                     ───────────────────────

Введение


   Что такое глобальная оптимизация ?


   Глобальный Оптимизатор (в отличие от локального оптимиза-
тора) анализирует и оптимизирует весь код функции как целое.
Типичные же локальные оптимизаторы  единовременно рассматри-
вают лишь оператор или короткие  последовательности операто-
ров. Глобальный Оптимизатор использует мощную технику анали-
за потока данных (Data Flow Analysis - DFA) для сбора инфор-
мации о функции.  Чем больше известно о функции,  тем больше
возможно оптимизаций.  Вот  почему  глобальные  оптимизаторы
улучшают код сильнее, чем это могут сделать локальные.


   Зачем это нужно ?


   Верно, что большинство  C++  программ  можно настроить на
конкретную машину и что у глобального оптимизатора мало пре-
образований,  которые нельзя было бы продублировать в исход-
ном тексте. Однако, этого обычно не делается, поскольку:

      * Цели простоты поддержки и надежности  могут быть бо-
        лее важными, чем запутанный, зато настроенный код.

      * Код, настроенный на  одну  машину,  может  оказаться
        плохо подходящим для другой (наиболее очевидный при-
        мер этого - различная поддержка регистровых перемен-
        ных в разных ЭВМ).

      * Настройка кода занимает у программистов много време-
        ни.  Программное  обеспечение и должно повышать про-
        дуктивность программистов,  и глобальный оптимизатор
        в значительной степени снимает необходимость в наст-
        ройке программ.

      * Анализатор C++ использует простые методы при подста-
        новке вызовов inline (открыто подставляемых) функций,
        оставляя глобальному оптимизатору работу по приведе-
        нию к более приемлемому коду.


   Когда мне использовать его ?


   Предлагаемый здесь Глобальный  Оптимизатор работает очень
медленно в сравнении с двумя другими проходами.  Поэтому его
стоит применять только к уже отлаженным процедурам.  От него
также не будет пользы в применении к  "заброшенным" програм-
мам.  Он наиболее полезен для часто  используемых  программ.

   "Правило большого  пальца":
если число исполнений программы,  умноженное  на выигрыш  во
времени, больше, чем время, потраченное на оптимизацию,  она
целесообразна.


   Какого улучшения скорости можно мне ожидать?


   Типичные, связанные с вычислениями программы ускорятся на
величину до 30%. Занятые в основном вводом/выводом программы
могут вообще не ускориться. Наиболее заметные ускорения про-
изойдут в маленьких, но часто используемых, циклах. Наимень-
шие ускорения  произойдут  в  коде,  состоящем в основном из
вызовов функций.


   Делает  ли  Глобальный Оптимизатор  ненужным программиро-
вание на ассемблере?


   Нет, оптимизированный  код  далеко  еще не так хорош, как
аккуратно  сконструированный  ассемблерный.  Одной из причин
этого является то, что программист знает об алгоритме больше,
чем компилятор.  Компилятор  будет всегда выбирать консерва-
тивный (осторожный) вариант оптимизации,  гарантирующий, что
выполнятся только безопасные  оптимизирующие преобразования.
Однако, во многих проектах нет возможности тратить человеко-
-часы на аккуратное конструирование всего проекта на ассемб-
лере,  и оптимизирующий  компилятор в этом случае предлагает
наиболее эффективное по цене решение.


   Чего не умеет Глобальный Оптимизатор


   Глобальный  Оптимизатор не будет  заменять  неэффективные
алгоритмы эффективными.  Он, например,  не распознает сорти-
ровку методом пузырька и не заменит ее на быструю сортировку.

   Безотносительно  к тому,  насколько  хорошим  мог бы быть
компилятор, обычно наиболее значительные увеличения скорости
исполнения достигаются при улучшении используемого алгоритма.


Использование


   Запуск оптимизатора посредством ZTC


   Для запуска при помощи ZTC используйте ключ -o. Заметьте,
что ключ -o,  за которым  следует имя файла,  задает для ZTC
выходной файл!  Например:

      ZTC demo -o

означает:  компилировать,  оптимизировать  и линковать  demo

      ZTC demo -otest.exe

означает: компилировать и линковать demo,  получившийся файл
назвать test.exe. Оптимизатор не запускается.

      ZTC demo -o -otest.exe

означает:  компилировать,  оптимизировать и затем  линковать
demo, получившийся файл назвать test.exe.



   Автономный запуск


   ZTG исполняется над выходом от  ZTCPP1, ZTC1 или ZTC1B, и
выход от ZTG является входом для ZTC2 или ZTC2B.

      ZTG вход [-oвыход] {(+|-)режим} [-v]

      вход     Файл,  являющийся выходом от ZTCPP1, ZTC1 или
               ZTC1B. Если расширение не задано, оно предпо-
               лагается равным .TMP.

      выход    Имя для выходного файла ZTG.  Если не задано,
               имя выходного файла формируется из имени вход-
               ного файла добавлением расширения .TMO.

      -v       Режим "разговорчивой" компиляции (имена функ-
               ций перечисляются по мере их обработки).




   Другие режимы


   Для остальных режимов  + означает включение  оптимизации,
а  '-'  - выключение.

      all      Выполнять все оптимизации (умолчание).

      cnp      Распространение констант.

      cp       Распространение копий.

      da       Удаление излишних присваиваний.

      dc       Удаление излишнего кода.

      dv       Удаление излишних переменных. Вычисление гра-
	       ниц существования.
      gcse     Глобальные общие подвыражения.

      li       Вынесение инвариантов из цикла.

      liv      Индуктивные переменные цикла.

      loop     Итерация до отсутствия оптимизаций.

      none     Не выполнять никаких оптимизаций.

      reg      Выполнять наше распределение регистров.

      space    Оптимизация, ориентированная на экономию
               памяти.
      time     Оптимизация, ориентированная на экономию
               времени (+time - умолчание).
      vbe      Очень нагруженные выражения.

      w        Включение  предупреждений  (скажем, что пере-
               менная используется до первого присваивания).

   Примеры:

      ZTCPP1 demo
      ZTG demo
      ZTC2 demo
      BLINK demo;

значит: компилировать, оптимизировать и линковать программу
demo.cpp.

      ZTG demo +space -w

значит: оптимизация с предпочтением экономии памяти и выклю-
ченными предупреждениями.


Дальнейшая информация


   Распространение констант  (+cnp)


   Рассмотрим код:

      A=5;
      for(i=0;  i<A; i++)
            abc[i]=A;

   Очевидно, что A всегда на протяжении цикла будет равно 5.
Поэтому ее можно заменить на 5:

      A=5;
      for(i=0;  i<5; i++)
            abc[i]=5;

   Возможность  распространения  констант  часто  возникает,
когда выполняется вращение цикла (loop rotation).



   Распространение копий (+cp)


   Распространение копий похоже на распространение констант,
только копируются переменные, а не константы.

      A=b;
      for(i=0;  i<A; i++)
            abc[i]=A;

   Заменяется на:

      A=b;
      for(i=0;  i<b; i++)
            abc[i]=b;

   Распространение копий часто вскрывает излишние присваива-
ния, которые могут быть удалены (такие, как присваивание A).



   Удаление излишних присваиваний (+da)

   Такие  присваивания  переменным,  которые в дальнейшем не
используются, удаляются.

      int abc()
      {
         int f;
         static int g = 0;
         if (g!=3)
         {
            f=3;               /* излишнее присваивание f */
            g=3;          /* это присваивание не излишнее */
         }
      }



   Удаление неисполняемого кода (+dc)


   Излишний, неисполняемый код - это код, на который никогда
не попадет управление, и поэтому он удаляется. Иногда излиш-
ний код может быть неочевидным:

      #define VALUE 0
      if (VALUE>10)
            a=dead+code;        /* этот оператор излишний */



   Удаление излишних переменных
   Вычисление границ существования
   Распределение регистров при помощи раскраски (+dv)


   Излишние переменные - это автоматические переменные, кото-
рые объявляются, но никогда не используются.  Они часто воз-
никают в результате других оптимизаций.  Границы существова-
ния переменной это часть функции,  в рамках которой значение
переменной нужно сохранять. Если границы существования нуле-
вые,  то переменная излишняя.  Если две или более переменных
имеют непересекающиеся границы существования,  они могут за-
нимать одно место в памяти. Это становится важным при разме-
щении большого числа  переменных  в малом  числе  регистров.
Процессор 8088 имеет малое число регистров, каждый со специ-
альными  возможностями,   так  что  трудно   "резервировать"
регистры под регистровые переменные. Вместо этого вычисляют-
ся границы существования каждого  регистра  и сравниваются с
границами существования переменной. Если они не пересекаются,
переменная размещается на регистре. Это называется "раскрас-
ой" (coloring) и аналогично раскраске графа переменных опре-
деленным числом  цветов,  равным числу регистров, так, чтобы
в любой точке не было двух переменных одного цвета.



   Глобальные общие подвыражения (+gcse)


   Объединение общих  подвыражений есть исключение  излишних
вычислений.



   Вынесение инвариантов из цикла (+li)


   Если в теле цикла имеется  выражение,  но его значение не
меняется, то оно является инвариантом цикла,  и его вычисле-
ние можно вынести из цикла.

      while(f())
            g(b*c);              /* b*c - инвариант цикла */

становится:

      T = b*c;
      while(f())
            g(T);



   Индуктивные переменные цикла (+liv)


Вот как происходит замещение  индуктивной переменной цикла:

      for (i=0; i<10; i++)
        a[i*2+3]=5;

становится:

      for (T=&a[3]; t<&a[23]; T+=2)
        *T=5;

Это обычно одно из самых  плодотворных направлений ускорения
программы.


   Итерация до отсутствия дальнейших оптимизаций (+loop)


   Выполнение многих оптимизаций часто делает возможной даль-
нейшую оптимизацию.  Этот флаг говорит  оптимизатору продол-
жать, пока он не сможет обнаружить дальнейших оптимизаций.


   Выполнять наше распределение регистров (+reg)


   Использование  регистрового  класса   памяти   (описатель
register) не нужно, поскольку оптимизатор помещает на регист-
ры так много переменных, как только возможно. Какие перемен-
ные имеют приоритет, зависит от того,  как часто они исполь-
зуются и как глубоко вложены в циклы.

   Поскольку оптимизатор генерирует  новые переменные и изы-
мает исходные, автоматическое распределение регистров сущест-
венно.
   Однако, если использован  этот  флаг,  оптимизатор  будет
"отдавать честь" описателям "register" в исходном тексте.


   Соотношение  между  памятью и скоростью  (+space и +time)


   Иногда может быть сделан выбор между  оптимизацией по па-
мяти и по скорости. Один специальный пример для этого случая:

      while (f())
            g();

Экономия памяти дает:

      goto L1;
      do
      {
         g();
      L1:   ;
      }  while (f());

Оптимизация скорости дает:

      if (f())
      {
        do
          g();
        while(f());
      }


   Очень нагруженные выражения (+vbe)


   Очень нагруженными считаются выражения, которые обнаружи-
ваются на более чем одном маршруте по графу управления:

      if (condition)
            a=b*c;
        else
           d=b*c;

Здесь  b*c  -  очень  нагруженное  выражение.
Оптимизация:

      T=b*c;
      if  (condition)
             a=T;
         else
             d=T;

Заметьте,  что  это  экономит  лишь  память,  но  не  время.



Советы и замечания


   Использование ключевых слов const и volatile


   Ключевое слово  const говорит,  что переменная никогда не
модифицируется,  и оптимизатор может не предполагать худшего
о ее изменении. Ключевое слово volatile говорит оптимизатору,
что переменная может измениться асинхронно, так что чтение и
запись в нее недопустимо  оптимизировать.  Const полезно для
статических  таблиц,  volatile  используется  для аппаратных
адресов (вроде видеопамяти) и для данных,  которые могут из-
мениться при возникновении  прерывания (как переменные DOS и
BIOS или флаги, устанавливаемые драйвером прерывания).


   Примеры:

      const static int a=5, b[3]={1,2,7};
      extern volatile bool flag;



   Если возникли проблемы


   Что делать, если программа работает,  когда откомпилиро-
вана без оптимизатора,  но ломается,  если откомпилирована с
ним.

   Оптимизатор использует весьма строгую интерпретацию опре-
деления языка  C++  и старается  удовлетворить ей.  По языку
некоторые  аспекты  поведения программы не определены, и это
неопределенное  поведение может быть различным в зависимости
от того,  запускался ли оптимизатор.  Некоторые причины,  по
которым код может изменить поведение, будучи оптимизирован:

1. Код зависит  от  порядка  выполнения  побочных  эффектов.
   Скажем:

      a=f1()+f2();

   Исполняется ли f1() или f2() первой, неопределено.  Поря-
   док вычислений может быть задан явным использованием вре-
   менных переменных, скажем:

      tmp=f1(); a=tmp+f2();

   Теперь порядок вычислений гарантирован.

2. В коде разыменовываются  неинициализированные  указатели.
   Поскольку оптимизатор  меняет физическое размещение пере-
   менных,  неинициализированные  переменные могут содержать
   другие значения.
3. Код хранит данные  за концом  или до начала массивов дан-
   ных, размещаемых при помощи malloc().
4. Код  ссылается на  данные,  которые были  освобождены при
   помощи realloc() или free().
5. Переменная, которая может быть  модифицирована  на уровне
   прерываний, не объявлена с описателем volatile.
6. В оптимизаторе есть ошибка.

   Не считая последнего варианта, перекомпиляция с оптимиза-
тором может порождать те же проблемы,  что и при переходе на
другой компилятор.  Приверженность стандартной практике "пе-
реносимого" программирования  минимизирует  все проблемы ис-
пользования оптимизатора.






				     СЛОЖНЫЕ  ЧЕРТЫ  СИСТЕМЫ
                                     ───────────────────────



Модели памяти


   В Zortech по умолчанию выбирается  малая  (Small)  модель
памяти.  Если нужно писать очень большие  программы, следует
использовать одну из больших моделей. Сегментная архитектура
процессоров  семейства  8086  усложняет  адресацию в больших
программах.  Создатели больших программ сталкиваются с выбо-
ром между эффективностью и полной адресуемостью.  Эти комби-
нации  адресуемости и эффективности  отражены в пяти моделях
памяти, используемых в Zortech C++.


   Сегментная архитектура 8088/8086


   Процессор имеет 16-битовые регистры, но 20 адресных линий,
то есть адресует до одного  мегабайта памяти.  Легко видеть,
что абсолютный адрес не может содержаться в одном 16-битовом
регистре.  Чтобы преодолеть это,  используется  сегментация.
Память делится на сегменты до 64 К (максимальное число, кото-
рое  помещается  в  16-битовый  регистр).  Абсолютный  адрес
теперь можно вычислить, прибавляя смещение (OFFSET) от нача-
ла сегмента к адресу начала сегмента (SEGMENT).

   Однако,  адрес  начала  сегмента  тоже должен храниться в
16-битовом регистре. Для этого старшие 16 разрядов /абсолют-
ного адреса/ помещаются в регистр и предполагается, что пос-
ледние четыре - нули. Таким образом, адресация памяти в 8086
выполняется созданием 20-битового физического адреса из двух
16-битовых чисел, называемых Сегмент  (Segment)  и  Смещение
(Offset).  Физический  адрес вычисляется сдвигом 16-битового
сегмента  влево  на 4 бита и  затем  сложением со смещением.
Имеется четыре специальных сегментных регистра: 
CS, DS, SS и ES.  

   CS  является регистром  сегмента кода (code segment),  он
всегда содержит сегмент исполняемого в этот момент кода.

   DS является регистром  сегмента  данных  (data segment);
он обычно содержит сегмент глобальных и статически размещен-
ных данных.

   SS является регистром сегмента стека (stack segment);  он
содержит сегмент аппаратного стека.

   ES является дополнительным  сегментным  регистром  (extra
segment) и используется для адресации любого сегмента. Обыч-
но ES  используется для доступа по дальним (far) указателям.



   Пять различных моделей [памяти]


   Zortech C++  предлагает пять  различных  моделей  памяти,
называемых T-модель, S-модель, M-модель, C-модель и L-модель.
Эти модели памяти  определяются  ограничениями на память под
код и данные программы. M и L модели используют дальние (FAR)
вызовы (команду обращения к функции, использующую и сегмент,
и смещение) функций.

   Эти дальние вызовы могут перепрыгивать до миллиона байт в
памяти, но они менее эффективны,  чем ближние (near) команды
вызова.  Следующая  таблица показывает ограничения адресации
для каждой модели.


	  Модель             Размер               Размер
          Памяти             Кода                 Данных

            T                64K                  64K   *

	    S                64K                  64K

	    M                1M                   64K

	    C                64K                  1M

	    L                1M                   1M


      *  Сумма  кода  плюс  статические и глобальные  данные
         должна быть менее 64 K.


   Выбор модели памяти


   Выбор  модели  памяти - это выбор  между  адресуемостью и
эффективностью.   Использование  (по  умолчанию)  S-модели -
- наиболее эффективный и для большинства программ правильный
выбор.  Очевидно,  если программа занимает более 64 килобайт
под код или данные, требуется другая модель памяти.  Вот как
выбирать среди них:

      1. Если суммарный код программы и ее библиотечных функ-
         ций будет более  64 килобайт,  следует использовать
         M модель либо L модель.

      2. Если  суммарный код программы не превышает 64 кило-
         байт, S модель или  C  модель будет более эффектив-
         ной.



Указатели


   Указатель - это переменная,  которая  содержит физический
адрес.  Имеется два типа  указателей,  называемые   "дальний
указатель" и "ближний указатель".



   Ближние указатели


   Ближние указатели можно использовать для доступа к любому
месту в рамках 64-килобайтного сегмента. Он требует лишь два
байта памяти для хранения смещения и,  таким образом,  более
эффективен  и по  занимаемой  памяти и времени,  нужному для
доступа по нему.  Предполагается,  что сегментный регистр DS
содержит  правильное  значение  сегмента.  Ближние указатели
используются по умолчанию в T, S и M моделях памяти для ука-
зателей на данные. Ближние указатели используются для указа-
телей на функции в T, S и C моделях.



   Дальние указатели


   Дальние указатели требуют четырех байт памяти,  поскольку
состоят из двухбайтового  сегмента и двухбайтового смещения.
Сегмент является базовым адресом и будет заноситься на соот-
ветствующий сегментный  регистр,  а  смещение  задает индекс
относительно этого базового адреса.

   Дальние  указатели  являются  умолчанием  для  указателей
данных  в  C и L  моделях  и  указателей  функций  в  M  и L
моделях.



   Макросы для работы с дальними указателями


   Следующие макросы  позволяют Вам определить,  являются ли
указатели ближними или дальними.


      #define SPTR 1          /* 1, если указатели на данные
                                занимают 2 байта, иначе 0 */

      #define LPTR 1          /* 1, если указатели на данные
                                занимают 4 байта, иначе 0 */

      #define LCODE 1          /* 1  при M и L моделях (ука-
                                затели  на функции  занимают
                                4 байта), иначе 0 */

   Смотрите также раздел "Предопределенные Макросы".

   Макрос MK_FP (seg, off) создает дальний указатель из сег-
мента и смещения.   MK_FP,  FP_SEG и FP_OFF  описаны в Части
Третьей - "Библиотека Функций".


   Нормализация дальних указателей


   Дальний указатель "нормализован", если его смещение мень-
ше 16.  Это значит,  что абсолютный адрес может быть получен
добавлением 4  младших битов  смещения из указателя справа к
сегменту из него же.  Если  дальние указатели нормализованы,
их можно  сравнивать,  в то время  как два ненормализованных
дальних указателя могут  указывать на один и тот же абсолют-
ный адрес,  но иметь  различные  значения  своих  регистров.
Например:


      Сегмент        Смещение        Адрес

      0х1234         0х0098          0х123D8
      0х123D         0х0008          0х123D8

   Во втором  примере  указатель уже нормализован.  Смещение
содержит одну шестнадцатиричную цифру,  т.е. меньше 16 деся-
тичных. Дальние указатели могут быть нормализованы при помо-
щи библиотечной функции _farptr_norm(). Например,

      #include <dos.h>
      char far *p;                   /* p не нормализован */
      p=_farptr_norm(p);         /* p теперь нормализован */



   Арифметика над дальними указателями


   Вычисления, включающие дальние указатели,  сильно отлича-
ются от вычислений, использующих ближние указатели.  Разница
объясняется тем,  что дальний указатель состоит из двух ком-
понент. Для эффективного программирования следует разобрать-
ся с этими  различиями.  Некоторые генерируемые компилятором
операции работают и с сегментом, и со смещением, а некоторые,
с другой стороны, используют только смещение.

   При операциях,  которые  используют  только  смещение  от
длинного указателя, может возникнуть "переполнение" (wrap)
сегмента. Это случается, когда смещение достигает максималь-
ного значения  и затем  "оборачивается"  в  ноль.  Операции,
которые "задевают" только смещение:

      +   -      +=      -=      ++

      >   <      >=      <=      --

   Операции,  которые работают над полным  32-разрядным зна-
чением:

       ==      !=      !

   Эти операции сравнивают обе компоненты  дальнего указате-
ля,  но они не выполняют нормализации перед выполнением опе-
раций. Поэтому ==  дает ноль  для  двух указателей,  которые
указывают  на  одно и то же место,  но имеют разные значения
сегмента. Можно избежать этой проблемы,  нормализовав указа-
тели перед выполнением сравнения ==. Например:

      #include <dos.h>
      char *p1, *p2;
      if (_farptr_norm(p1) ==  _farptr_norm(p2))

В большинстве программ вышеназванные операции не вызовут ка-
ких-либо проблем.  Полная 32-разрядная арифметика может быть
выполнена над длинными указателями следующим образом:

      1. Преобразовать дальний указатель  в long  посреством
         _farptr_tolong()

      2. Выполнить операцию (операции)

      3. Преобразовать результат назад  в дальний  указатель
         посредством _farptr_fromlong()

Например, чтобы прибавить 100000 к указателю,  можно сделать
следующее:

   #include <dos.h>
   char *p;
   p = _farptr_fromlong(_farptr_tolong(p)+100000);

   Дальний указатель может быть инициализирован определенным
аппаратным адресом при помощи MK_FP().  Например, чтобы соз-
дать указатель на  дисплейную  память ПЭВМ типа IBM в случае
монохромного дисплея:

   #include <dos.h>
   main()
   {
     unsigned *p;
     int i;
        p = MK_FP(0хB000,0);         /* дисплейная память *)
        for(i=0; i < 80*25; i++)
             p[i] = 0х0700+' ';
   }



Использование ключевых слов near и far


   Выбираемый по умолчанию тип для указателя на данные может
быть "перекрыт" явным использованием  ключевых слов  near  и
far. Объявления выглядят так:

   int far *p;       /* p - <дальний указатель на><целое> */
   int * far *p;               /* p - <дальний указатель на>
                                   <указатель на> <целое> */

   Ключевые слова near  и far  право-ассоциативны,  т.е. они
относятся к * справа от них.  В отличие  от  этого  ключевые
слова const и volatile являются лево-ассоциативными. Да, это
запутывает; вот еще примеры:
      /* объявим p как <указатель на> <изменяемый ближний
                                указатель на> <const int> */
   int const near * volatile *p;

   Помните,  что <указатель на> становится <ближним указате-
лем на> в T, S и M  моделях  и <дальним указателем на> - в C
и L моделях. Ключевые слова  near  и far  не санкционированы
ANSI, они являются расширениями, поддерживающими сегментную
архитектуру интеловских ЦП. Если задан ключ (режим) компиля-
ции -A (ANSI компиляция), эти ключевые слова не будут распо-
знаваться.  В любом случае, рекомендуется избегать использо-
вания идентификаторов near и far в качестве имен переменных.



   Использование ближних указателей


   Ближние указатели можно использоватьь в  C  и  L  моделях
только в случае, когда данные по указателю  адресуются через
DS регистр, поскольку генератор кода предполагает, что ближ-
ние указатели указывают внутри сегмента данных.  Это значит,
что ближние указатели могут быть  использованы лишь для ука-
зания на статические и глобальные данные, но не на автомати-
ческие (в стеке)  данные и не на параметры функций.  Главная
польза от ближних  указателей - ускорение действий  в  C и L
моделях.



   Использование дальних указателей


   Дальние указатели полезны во многих случаях. Типичное ис-
пользование - прямой  доступ к видеопамяти или областям дан-
ных BIOS. Например, код для очистки монохромного  текстового
экрана мог бы быть таким:

   #include <dos.h>
   unsigned far *vp,u;      /* строим указатель на начало
                                                  дисплея */
   vp = MK_FP(0хB000,0);
   for (u = 0; u < 80*25; u++)
      vp[u] = 0х0700 + ' ';


   Преобразования между ближними и дальними указателями


   Дальний указатель может быть  преобразован в ближний так:

   #include <dos.h>
   char near *np, far *fp;
   np = (char near *) FP_OFF(fp):

      Заметьте, что FP_SEG(fp) должно быть равно DS!

   Ближние указатели могут быть преобразованы в дальние так:

   #include <dos.h>
   char near *np, far *fp;
   fp = MK_FP(getDS(),(unsigned) np);

      Заметьте, как извлекается значение  DS для встраивания
      в дальний указатель.


Подавление выравнивания в структурах


   По умолчанию  члены  структуры  выравниваются  по границе
слова за исключением  случая,  когда  две или более литерных
переменных следуют одна за другой; в этом случае первая пере-
менная выравнивается по границе слова, а следующие - по гра-
нице байта.  Выравнивание в структурах может быть подавлено,
так что члены структуры  выравниваются по границе байта. Это
подавление  полезно при определении структуры,  которая ото-
бражается на аппаратное устройство или заранее  определенный
элемент данных вроде элемента справочника MS DOS.
   Подавление выравнивания  работает только внутри структур,
все остальное все равно будет  выравниваться по границе сло-
ва. Каждая структура в массиве структур, откомпилированном с
режимом -a, будет начинаться с границы слова.

       ЗАМЕЧАНИЕ:   Все  файлы,  ссылающиеся  на  структуру,
       должны  быть откомпилированы с одним режимом выравни-
       вания.  Если два файла  ссылаются  на одну структуру,
       и один  откомпилирован с режимом -a,  а другой - нет,
       могут возникнуть с трудом обнаруживаемые ошибки.

Пример

    ┌──────────────────────────────────────────────────┐
    │   Смещения  в  байтах                            │
    ├────────────────────┬──────────────┬──────────────┤
    │                    │ Нормальное   │ Подавленное  │
    │                    │ выравнивание │ выравнивание │
    ├────────────────────┼──────────────┼──────────────┤
    │ struct dat         │              │              │
    │ {                  │              │              │
    │ char name[5];      │    0         │    0         │
    │ int age;           │    6         │    5         │
    │ char sex;          │    8         │    7         │
    │ char street[7];    │    10        │    8         │
    │ long height;       │    18        │    15        │
    │ };                 │              │              │
    ├────────────────────┼──────────────┼──────────────┤
    │ sizeof(struct dat) │    22        │    19        │
    └────────────────────┴──────────────┴──────────────┘



Отладка C++ программ


   Использование отладчиков


   Откомпилированные посредством Zortech C++ программы могут
отлаживаться посредством отладчиков третьего поколения, тре-
бующих номеров  строк в исходном  коде (тексте).  Компилятор
C++ обеспечивает номера строк в объектном файле, когда прог-
рамма компилируется  с  режимом "-g".   В этом режиме размер
объектного файла значительно возрастает. Для сборки и отлад-
ки получающихся программ  нужно  обратиться к руководству по
соответствующему отладчику.


   Другая поддержка


   В библиотеке времени исполнения имеются некоторые средст-
ва,  помогающие в определении обычных ошибок во время испол-
нения. Вот эти средства:

Если в printf передается нулевой указатель  (NULL)  там, где
ожидается литерный указатель,  используется строка "(null)".
Например:

      printf("String '%s'\n",NULL);

выдаст:

      String '(null)'

Если нулевой  ближний указатель  разыменовывается,  строка в
0-м  слове  сегмента  данных  ("ERROR: NULL pointer")  может
стать подходящей:

      char buf[100];
      strcpy(buf,NULL);
      printf("Строка '%s'\n,buf)'

выдаст (в T, S и M моделях):

      Строка 'ERROR: NULL pointer'



   Отладка с CodeView


   Отладчик CodeView фирмы  Microsoft является ориентирован-
ным на номера строк отладчиком в терминах  исходного текста.
Для получения при  его  использовании  наилучших результатов
стоит следовать немногим правилам, перечисленным ниже.

      * #include  файлы следует ограничить #define макросами
        и описаниями, поскольку CodeView  не способен отсле-
        живать при  исполнении  переключение на такие файлы.

      * Ввиду  "строково-ориентированной"  природы  CodeView
        каждый оператор в исходном тексте стоит  располагать
        на отдельной строке.

      * CodeView не одолеет  сложные макросы,  так что, если
        подозрение падает на макрос, следует записать вместо
        него результат макроподстановки.

      * Следует компилировать  исходные  модули в режиме -g.

      * Следует собирать программу с режимами /co (CodeView)
        и /m  (map, т.е. с  построением  файла  соответствия
        кода и текста). Следует использовать редактор связей
        фирмы Microsoft.

      * При наличии в сборке C++ модулей,  следует использо-
        вать утилиту BUNCH.

      * Исполните  CodeView  над  результатом (вышеописанных
        действий).

   При работе с ZTC.COM нужно запускать ее так:

      ZTC -g -co -B файл...

   Убедитесь, что Microsoft LINK доступен по маршрутам ранее
Zortech LINK /в  текущей  версии  Zortech  собственный  LINK
ZORTECH находится под именем BLINK/.
   Отметим, что совместимость с CodeView ограничена глобаль-
ными переменными и нумерацией строк.  Локальные (автоматиче-
ские) переменные не могут наблюдаться.
   Для подробной  информации по отладке следует обратиться к
руководству по CodeView фирмы Microsoft.





                                              ИНСТРУМЕНТАРИЙ
                                              ──────────────

MAKE

   Зортеховская утилита  MAKE  подобна юниксовской утилите с
тем же  названием и обладает полным набором ee возможностей,
но в MS DOS. Имеются макросы, полная  проверка  зависимости,
внутренние  команды  MS DOS  и  содержательные  сообщения об
ошибках.


   Что такое MAKE ?


   MAKE - это утилита, автоматизирующая поддержку построения
программы.  Вместо того, чтобы набирать команды для компиля-
ции и сборки своей программы (программ),  можно записать все
необходимые шаги в текстовый файл,  называемый MAKEFILE, а в
дальнейшем просто выдавать команду MAKE,  когда нужно отком-
пилировать и собрать программу.

   Это особенно полезно для программ,  построенных из многих
исходных файлов,  поскольку  будут повторно  компилироваться
лишь те из них, которые обновлялись.  MAKE делает это, срав-
нивая время и дату для каждого соответствующего  файла перед
выполнением каждого шага задания. Это подразумевает, что для
использования  MAKE требуется всегда устанавливать на машине
дату  и время.  MAKE  выполняет  задания на построение новой
версии программы согласно  файлу  описания.  Например,  шаги
построения программы из одного  C++  файла могли бы быть та-
кими:

1. Компилировать  исходную  программу в объектную программу.

2. Собрать объектную программу с C++ библиотекой.

   MAKE отличается от пакетного исполнения тем, что выполня-
   ет только необходимые действия,  в то время как командный
   файл будет исполнять все задания независимо от того, нуж-
   ны они или нет.



   Начало работы с MAKE

   Этот параграф описывает начальную установку MAKE и демон-
стрирует пример сеанса.


   Командный файл для MAKE (MAKEFILE)

   Файл описания (работ для MAKE),  задающий действия по по-
строению программы, называется MAKEFILE.  Это - имя по умол-
чанию для файла описания; так он будет называться и в насто-
ящем руководстве.
   MAKEFILE является текстовым файлом  и создается текстовым
редактором (например, ZED). Он содержит одну или более строк
зависимости, за каждой из которых следует одна или несколько
командных строк.  Строка зависимости содержит цель, за кото-
рой следует двоеточие и список (возможно, пустой) файлов за-
висимости, т.е. файлов,  необходимых для создания цели.  Ко-
мандные строки следуют за строкой зависимости и должны начи-
наться с пробела или табуляции.  Командные  строки  являются
выполнимыми командными строками, т.е. теми,  которые  обычно
нужно вводить в ответ на приглашение MS DOS.

ФАЙЛ_ЦЕЛЬ: ЗАВИСИМЫЙ_ФАЙЛ1 ЗАВИСИМЫЙ_ФАЙЛ2
           КОМАНДА 1
           КОМАНДА 2


   Пример MAKEFILE

HELLO.EXE:  HELLO.OBJ         #  Цель / Строка зависимости
            ZTC HELLO.OBJ     #  Команда / Строка-правило

HELLO.OBJ:  HELLO.CPP         #   Цель
            ZTC -c HELLO.CPP  #   Команда

   Здесь показано, как создать MAKEFILE для программы, запи-
санной в одном исходном файле. В примере выше целью является
HELLO.EXE,  который зависит от HELLO.OBJ, а тот, в свою оче-
редь, - от HELLO.CPP.
   Cначала MAKE проверяет,  является ли HELLO.CPP по дате  и
времени более свежим,  чем  HELLO.OBJ.  Если это так  или же
HELLO.OBJ  не существует,  то выполняется  командная  строка

ZTC -c HELLO.CPP

При этом создастся  HELLO.OBJ,  который  будет более свежим,
чем любой ранее существовавший файл, в том числе  HELLO.EXE.
Поэтому команда

ZTC HELLO.OBJ

также будет выполнена.  Чтобы  использовать  вышеприведенный
MAKEFILE, нужно просто набрать

MAKE <Enter>

   Файлы зависимости

   Файлами зависимости являются все файлы, изменение которых
вызывает изменение  получающегося целевого файла.  Например,
модификация исходного C++ файла  дает  изменение  объектного
файла,  вызванное  компиляцией.  Но зависимость от исходного
файла не единственная.  Если исходный файл  включает  другие
файлы /при помощи  #include/,  то эти включаемые файлы также
являются файлами зависимости. Например, пусть имеется строка

   #include "DEFS.HPP"

в исходном файле prog.cpp.  Тогда строка в  MAKEFILE  должна
быть такой:

   PROG.OBJ: PROG.CPP DEFS.HPP

Это значит, что PROG.OBJ  зависит от PROG.CPP и от DEFS.HPP.


   Второй пример

   MAKEFILE может содержать комментарии,  чтобы описать, что
должен делать  MAKE.  Комментарии  начинаются с литеры '#' и
продолжаются до конца строки.
   # MAKE файл построения служебной программы dump

   dump.exe : dump.obj           # первая   целевая   строка
              ZTC dump.obj       # первая  командная  строка

   dump.obj : dump.cpp stdio.h   # цель - dump.obj
              ZTCPP1 dump        # команда   на   компиляцию
              ZTC2 dump          # Второй проход компилятора

   Этот  MAKEFILE  сначала  приведет к компиляции  dump.cpp,
если  он новее  dump.obj  или  dump.obj  не  найден.   Затем
dump.obj  будет линковаться,  если не существует /не найден/
dump.exe или если dump.obj новее, чем dump.exe. Если на пер-
вом шаге  MAKE dump.cpp был рекомпилирован,  то dump.exe бу-
дет собран, потому  что dump.obj окажется новее.  Затем MAKE
заканчивает работу и возвращает управление в MS DOS.


   MAKEFILE при нескольких исходных файлах


   EXAM9A.EXE :  EXAM9A.OBJ EXAM9B.OBJ     #Целевая строка
                 ZTC EXAM9A.OBJ EXAM9B.OBJ #Сборка
                 EXAM9A                    #Запуск программы

   EXAM9A.OBJ :  EXAM9A.CPP                #Целевая строка
                 ZTC -c EXAM9A.CPP         #Компиляция C++
                                           #модуля

   EXAM9B.OBJ :  EXAM9B.ASM                #Целевая строка
                 MASM EXAM9B;              #Ассемблирование
                                       #модуля на ассемблере

   Этот пример прежде всего заставит MAKE сравнить даты/вре-
мена exam9a.obj и exam9a.cpp и,  если нужно,  запустить ком-
пиляцию. Вторым шагом будет сравнение дат/времен  exam9b.obj
и exam9b.asm  и,  при необходимости,  ассемблирование.  Если
какой-то из этих шагов привел к выполнению или какой-либо из
объектных файлов новее, чем любой из существующих exam9a.exe,
то будет произведена сборка.
   Если exam9b  был написан на C++ ,  а не на ассемблере, то
последние две строчки должны быть примерно такими:

   EXAM9B.OBJ: EXAM9B.CPP                  #Целевая строка
               ZTC -c EXAM9B               #Компиляция


   Запуск MAKE


   MAKE  запускается набором  "MAKE"  в ответ на приглашение
MS DOS.  В этом случае MAKE будет читать MAKEFILE по умолча-
нию и выполнять  заданные в нем зависимости и  команды.  Для
предыдущего примера нижеследующая программная выдача показы-
вает,  что и в каком порядке делает MAKE при построении слу-
жебной программы dump:

   ┌──────────────────────────────────────────────────────┐
   │ B>MAKE                                               │
   │ ZTCPP1 dump                                          │
   │ ZTC2 dump                                            │
   │ ZTC dump.obj                                         │
   │ BLINK 2.12 Copyright (c) 1986-88 by Zortech, written │
   │                                  by Bjorn N. Freeman │
   │ BLINK complete. Time: 5.45 seconds                   │
   │                                                      │
   │ B>                                                   │
   │                                                      │
   └──────────────────────────────────────────────────────┘


   Если  затем  попытаться  повторно построить программу при
помощи MAKE:

   ┌──────────────────────────────────────────────────────┐
   │ B>MAKE                                               │
   │ Target file "dump.exe" is up to date                 │
   │                                                      │
   │ B>                                                   │
   │                                                      │
   └──────────────────────────────────────────────────────┘

   / MAKE выдала сообщение: 'целевой файл "dump.exe"
     соответствует текущему состоянию' /


   Использование MAKE в командной строке:

      MAKE {цель} {macro=текст} {-dilnqst} [-fфайл]

   Ключи:

      Цель           Что является целью MAKE
      macro=текст    Определяет  macro  как указанный текст.
                     Это определение  перекрывает  любое оп-
                     ределение внутри makefile.
      -d             Вывод отладочной информации
      -fфайл         В качестве  MAKEFILE  используется файл
      -f-            Читать  makefile  из stdin (стандартный
                     файл ввода, обычно - клавиатура)
      -i             Игнорировать ошибки при исполнении пра-
                     вил MAKE
      -l             Показать макро  расширения  в  makefile
      -n             MAKE не исполняет правила, а записывает
                     их в stdout (стандартный  файл  вывода,
                     обычно - экран дисплея)
      -q             Возвратиться с уровнем ошибки
                     (errorlevel)  1,  если  правила  должны
                     быть исполнены
      -s             Не выдавать  эхо  при исполнении правил
      -t             Просто "тронуть" устаревшие файлы.


   Использование аргументов MAKE


   По умолчанию цель для MAKE - первый целевой файл, указан-
ный в MAKEFILE,  если только он не задан в командной строке.
Так, задавая цель в аргументе,  можно использовать MAKEFILE,
который строит  несколько  служебных  программ,  если  нужна
только одна из  них.   Некоторые  MAKEFILE  не только строят
программы,  но и также тестируют и устанавливают их.  В этом
случае  задание  цели  позволит пользователю только строить,
только тестировать или только устанавливать новую программу.

   Определение макросов в командной строке обеспечивает воз-
можность модифицировать исполнение или смысл того, что делает
MAKE.


   Определенные пользователем макросы

   MAKE   поддерживает  определенные  пользователем макросы.
Макрос - это строка из одной или более  литер,  определенная
один раз в  MAKEFILE.  Если макрос  (его имя)  встречается в
нижеследующих строках  зависимости или командных строках, он
заменяется на  определение.  Макросы  определяются  строками
вида:

      MACRO = макро_определение

Макро определение включает весь текст между литерой = и кон-
цом строки.  Макро определение может быть продолжено на сле-
дующей строке, если первая завершается литерой \. Вызов мак-
роса задается как знак доллара и имя макроса,  заключенное в
круглые скобки.  Однолитерные имена макросов не требуют ско-
бок. Например:

   $(MACRO)
   $A
   $(ONE_TWO)

   Однобуквенные имена макросов не нуждаются в () при расши-
рении.  Определения для макросов ищутся в следующем порядке:

      1. Определения из командной строки.
      2. Определения из MAKEFILE.
      3. Определения из окружения.
      4. Макрос раскрывается как пусто (ничего).



   Предопределенные макросы


   MAKE  понимает макросы,  не определенные в MAKEFILE; они,
однако, заранее определены в программе MAKE. Вот эти макросы:

      $?   Список зависимостей, которые новее цели

      $**  Полный список зависимостей

      $*   Имя текущей цели без расширения

      $<   Формирует имя текущей  цели,  если оно сделано по
           неявному правилу

      $@   Полное имя цели

      $$   Раскрывается как $


   Режимы исполнения правил

   Чтобы обеспечить MAKE полный  доступ ко всем возможностям
MS DOS, имеются  три флага,  сообщающие MAKE о том,  как ис-
полнять команды. Флаг правила ставится непосредственно перед
командой.

      +      Вынуждает использование  COMMAND.COM при испол-
             нении  команды.   Это  полезно  при  исполнении
             командных  файлов и правил,  включающих  каналы
             (pipes) и перенаправление ввода/вывода.

      -      Игнорировать  статус  завершения этого правила.
             Это заставляет MAKE продолжать  вычисления даже
             при возникновении ошибки в этой команде.

      @      Не выводить эхо  при  исполнении этого правила.

      Пример

   install:
      -rm \bin \prog
      +prog >file


   Внутренние команды MS DOS

   Следующие команды являются внутренними  командами MS DOS,
т.е. MAKE исполняет их, запуская COMMAND.COM  и передавая ей
командную строку для выполнения.

         break             echo              rmdir
         cd                erase             ren
         chdir             exit              rename
         cls               if                time
         copy              md                type
         ctty              mkdir             ver
         date              pause             verify
         del               rd                vol
         dir               rem


   Специальные цели


	.SILENT      То же,  как  если бы -s был задан в ко-
                     мандной  строке   /MAKE/.   Не  следует
                     ставить ':' после этого.

        .IGNORE      То же,  что и  -i  в  командной  строке
                     /для MAKE/. Не ставьте ':' после этого.

        .DEFAULT     Правила,  следующие  за этой целью, вы-
                     полняются для  целей,  которые не имеют
                     своих, следующих за целевой строкой,
                     правил.


   Перенаправление вывода

   Для длинных и "разговорчивых" MAKE файлов вывод от MAKE и
все  сообщения  можно  перенаправить в регистрационный (log)
файл с тем, чтобы просмотреть позднее.

   MAKE >log

      Заметьте,  что  только вывод в  stdout  от запускаемых
      посредством MAKE программ будет перенаправлен. ZTC.COM,
      ZTCPP1.EXE   и  т.д.  все  отлично   перенаправляются.
      MASM 4.0 и ранние версии - нет.


   Неявные правила

   Можно определить для MAKE,  как  неявно  создавать  новые
файлы. Обычно используемое правило говорит MAKE, как ей соз-
давать объектный файл  (.OBJ) из C++ исходного файла (.CPP).
Когда такое правило  определено,  необходимо задать для MAKE
лишь зависимости, MAKE будет знать, как построить цель.

   Неявные правила  задаются  как расширение имени исходного
файла, за которым сразу идет расширение имени файла назначе-
ния.  Предопределенные  макросы  используются в командах для
описания  имен  файлов.  Например,  вот  правило  построения
объектного файла из C++ файла:

   .cpp.obj :
               ZTC -c $*

   Простой MAKEFILE мог бы быть таким:

   .cpp.obj :                     # без зависимостей
               ZTC -c $*          # общее правило

   hello.exe:  hello.obj          # целевая строка
               ZTC $*.obj         # сборка hello.obj

   # целевая строка для hello.obj не нужна,
   # поскольку MAKE знает, как создать .obj файл.

   Часто используется и правило для создания объектного фай-
ла из исходного ассемблерного файла. Это делается по следую-
щему правилу:

   .asm.obj :
        MASM $*;


   Создание командных файлов для редактора связей


   MAKE может  автоматически  создавать  командные файлы для
редактора связей. Командный файл для редактора связей исполь-
зуется редактором для определения собираемых файлов (смотри-
те Ваше руководство по редактору связей). Преимущество того,
что MAKE создает командный файл редактора связей, заключает-
ся в необходимости редактировать один лишь  MAKEFILE при до-
бавлении  или  удалении  файлов из сборки  Вашей  программы.
В противном случае необходимо  редактировать  и  MAKEFILE, и
командный файл редактора связей при изменении схемы построе-
ния Вашей программы.

   Командный файл редактора  связей  строится при помощи ко-
манды MS DOS ECHO,  записывая эхо каждой строки в этот файл.
Вывод команды  ECHO  следует перенаправить в командный файл,
используя ">" и ">>".  Первая строка должна быть перенаправ-
лена посредством ">",  так,  что файл создается (или обреза-
ется до нулевой длины). Все последующие строки перенаправля-
ются директивой ECHO посредством ">>".

   Например:

   #
   # MAKE файл только для сборки!
   #

   myprog.exe: file1.obj file2.obj
               link @linker.rsp

   # Создает новый командный файл линкера
   # при изменении MAKEFILE

   linker.rsp  :   makefile
                   echo file1.obj+file2.obj > linker.rsp
                   echo myprog.exe  >>linker.rsp
                   echo myprog.map  >>linker.rsp
                   echo mylib.lib   >>linker.rsp


   Список отличий от MAKE системы Юникс

   Зортеховская программа MAKE разработана настолько совмес-
тимой с юниксовской MAKE,  насколько это практично в окруже-
нии MS DOS.  Базовые различия между MS DOS и UNIX приводят к
отличиям в Zortech MAKE, и допущения, которые можно делать в
окружении UNIX, не могут быть сделаны в MS DOS.

      * В Zortech MAKE нет правил, определенных по умолчанию.
      * Многие команды (языка Shell) в  UNIX  отличаются или
        не имеют аналога в MS DOS.
      * Максимальная  длина команды после макроподстановок -
        127 литер.
      * Поскольку '\' используется как разделитель в маршру-
        те MS DOS, будьте осторожны с вещами типа :

        LIB =\Zortech\

        поскольку  последняя \ вызовет  продолжение  строки.

   О сообщениях об ошибках смотрите ПРИЛОЖЕНИЕ.



TOUCH


   TOUCH  изменяет  дату и время последней модификации пере-
численных в командной строке файлов на текущую дату и время.
Формат команды:

   TOUCH file1 file2 ...

   TOUCH используется вместе с MAKE для установки дат файлов
с целью модификации работы MAKE. Например,  чтобы перекомпи-
лировать все C++ исходные файлы  программы,  а не только те,
что были модифицированы, можно дать следующие команды:

   TOUCH *.CPP
   MAKE

   Аналогично,  если один или несколько  файлов редактирова-
лись, но изменения касались  исключительно  комментариев или
других вещей, не влияющих на получающийся объектный файл, то
объектные файлы можно  "тронуть"  (TOUCH),  и MAKE не станет
без нужды переделывать их.

   TOUCH *.obj
   MAKE



OBJTOASM


   OBJTOASM  дизассемблирует .OBJ  файлы  (строит  текстовый
файл на языке ассемблера по  .OBJ файлу).  Если в .OBJ файле
имеются  записи номеров строк, то OBJTOASM  выдаст смешанный
исходно-ассемблерный текст. Вывод  может быть  перенаправлен
в другой файл.


   Использование

      OBJTOASM файл [исходныйфайл]

   Подразумевается  расширение .OBJ. Если 'исходныйфайл' за-
дан, OBJTOASM полагает,  что это  тот  самый  исходный файл,
которому соответствуют  записи  номеров строк в .OBJ  файле.
В противном случае ('исходныйфайл' не задан) OBJTOASM исполь-
зует имя исходного файла, указанное в .OBJ файле.

      Пример

         Чтобы откомпилировать file.cpp и поместить получив-
         шийся ассемблерный код в file.asm :

            ZTC -c -g file
            OBJTOASM file > file.asm

      Ошибки

         Некоторые команды не распознаются правильно (как ко-
         манды 8087).  Выход не может быть ассемблирован без
         некоторого  предварительного "ручного" редактирова-
         ния. Сегменты данных игнорируются.







                                   ИНТЕРФЕЙС  С  АССЕМБЛЕРОМ
                                   ─────────────────────────


   Этот раздел руководства предполагает, что читатель знаком
с процессором 8086, ассемблером 8086 и C++.  Подпрограммы на
языке  ассемблера  могут  писаться и собираться вместе с C++
программой. Обычно функции пишутся на ассемблере потому, что:

    * Подпрограмма должна быть как можно более быстрой.

    * Не все возможности компьютера  или системы команд дос-
      тупны посредством языка  C++ и его библиотечных проце-
      дур.

    * Нужно  обеспечить интерфейс с функциями,  откомпилиро-
      ванными другим компилятором.


Программные разделы

   Код и данные в объектном  файле,  созданном компилятором,
сгруппированы в разделы.  Горизонтальные  линии ограничивают
области адресуемости посредством сегментных  регистров.  Эти
разделы имеют следующие имена и свойства:


   T модель памяти (.COM программы)

───────────────────────────────────────────────────────────────
Заме- Смеще- Содержание      Имя      Класс   Группа Сегментный
чание ние                    сегмента                регистр
───────────────────────────────────────────────────────────────
1     0х000  PSP                                     CS
2     0х100                  _TEXT    CODE    CGROUP
3                            C_ETEXT  ENDCODE CGROUP
───────────────────────────────────────────────────────────────
5                            NULL     BEGDATA DGROUP DS,SS
6            инициализиро-   _DATA    DATA    DGROUP
7            ванные данные   CONST    CONST   DGROUP
8     _edata неинициализиро- _BSS     BSS     DGROUP
             ванные данные
15           общие данные    c_common BSS     DGROUP
16    _end   не используется STACK    STACK   DGROUP
11           стек
17           куча
───────────────────────────────────────────────────────────────
13           дальняя куча
───────────────────────────────────────────────────────────────

      Заметьте, что зортеховские .COM файлы не такие же, как
      у    других   компиляторов.   У  других   компиляторов
      CS==SS==DS  для .COM файлов,  и общий размер программы
      плюс стек плюс куча  должен быть менее 64K.  У Zortech
      В .COM файлах лишь размер  кода  плюс  DGROUP  области
      должны быть менее 64K.  Таким образом, могут быть соз-
      даны значительно большие .COM программы. Заметьте, что
      единственная  разница  между  программой  в T модели и
      программой в S модели в том, как она линкуется.


   S модель памяти


───────────────────────────────────────────────────────────────
Заме- Смеще- Содержание      Имя      Класс   Группа Сегментный
чание ние                    сегмента                регистр
───────────────────────────────────────────────────────────────
1     0х000  PSP
───────────────────────────────────────────────────────────────
2                            _TEXT    CODE           CS

3                            C_ETEXT  ENDCODE
───────────────────────────────────────────────────────────────
4            Прочие сегменты
───────────────────────────────────────────────────────────────
5                            NULL     BEGDATA DGROUP DS,SS

6            инициализиро-   _DATA    DATA    DGROUP

7            ванные данные   CONST    CONST   DGROUP

8     _edata неинициализиро- _BSS     BSS     DGROUP
             ванные данные

9            общие данные    c_common BSS     DGROUP

10    _end   не используется STACK    STACK   DGROUP

16           стек

17           куча
───────────────────────────────────────────────────────────────
13           дальняя куча
───────────────────────────────────────────────────────────────





   M модель памяти


───────────────────────────────────────────────────────────────
Заме- Смеще- Содержание      Имя      Класс   Группа Сегментный
чание ние                    сегмента                регистр
───────────────────────────────────────────────────────────────
1     0х000  PSP
───────────────────────────────────────────────────────────────
14                          ??_TEXT   CODE           CS
───────────────────────────────────────────────────────────────
3                            C_ETEXT  ENDCODE
───────────────────────────────────────────────────────────────
4            Прочие сегменты
───────────────────────────────────────────────────────────────
5                            NULL     BEGDATA DGROUP DS,SS

6            инициализиро-   _DATA    DATA    DGROUP

7            ванные данные   CONST    CONST   DGROUP

8     _edata неинициализиро- _BSS     BSS     DGROUP
             ванные данные

9            общие данные    c_common BSS     DGROUP

10    _end   не используется STACK    STACK   DGROUP

16           стек

17           куча
───────────────────────────────────────────────────────────────
13           дальняя куча
───────────────────────────────────────────────────────────────

















   C модель памяти


───────────────────────────────────────────────────────────────
Заме- Смеще- Содержание      Имя      Класс   Группа Сегментный
чание ние                    сегмента                регистр
───────────────────────────────────────────────────────────────
1     0х000  PSP
───────────────────────────────────────────────────────────────
2                            _TEXT    CODE           CS
3                            C_ETEXT  ENDCODE
───────────────────────────────────────────────────────────────
4            Прочие сегменты
───────────────────────────────────────────────────────────────
5                            NULL     BEGDATA DGROUP DS

6            инициализиро-   _DATA    DATA    DGROUP

7            ванные данные   CONST    CONST   DGROUP

8     _edata неинициализиро- _BSS     BSS     DGROUP
             ванные данные

9            общие данные    c_common BSS     DGROUP

10    _end   не используется STACK    STACK   DGROUP
───────────────────────────────────────────────────────────────
11           стек                                    SS
───────────────────────────────────────────────────────────────
12           куча
───────────────────────────────────────────────────────────────
13           дальняя куча
───────────────────────────────────────────────────────────────
















   L модель памяти


───────────────────────────────────────────────────────────────
Заме- Смеще- Содержание      Имя      Класс   Группа Сегментный
чание ние                    сегмента                регистр
───────────────────────────────────────────────────────────────
1     0х000  PSP
───────────────────────────────────────────────────────────────
14                           ??_TEXT  CODE           CS
───────────────────────────────────────────────────────────────
3                            C_ETEXT  ENDCODE
───────────────────────────────────────────────────────────────
4            Прочие сегменты
───────────────────────────────────────────────────────────────
5                            NULL     BEGDATA DGROUP DS

6            инициализиро-   _DATA    DATA    DGROUP

7            ванные данные   CONST    CONST   DGROUP

8     _edata неинициализиро- _BSS     BSS     DGROUP
             ванные данные

9            общие данные    c_common BSS     DGROUP

10    _end   не используется STACK    STACK   DGROUP
───────────────────────────────────────────────────────────────
11           стек                                    SS
───────────────────────────────────────────────────────────────
12           куча
───────────────────────────────────────────────────────────────
13           дальняя куча
───────────────────────────────────────────────────────────────


    Замечания:

 1. Префикс программного сегмента (Program Segment Prefix).

 2. Весь код программы находится в этом сегменте.

 3. Сегмент нулевой длины, чтобы можно было найти конец кода.

 4. Любые другие сегменты.

 5. Начало сегмента данных.

 6. Все статически инициализируемые данные.

 7. В будущем константные данные, генерируемые компилятором,
    будут здесь.

 8. Начало неинициализированных данных.

 9. Данные,  размещенные  в общих (common) блоках.

10. Используется  для нахождения конца сегментов класса BSS.
    Все сегменты  класса  BSS  очищаются  в ноль  стартовым
    кодом. Сегмент STACK имеет длину 128 байт. Этого  доста-
    точно, чтобы DOS могла "запалить" программу, и стартовый
    код мог разместить реальный стек. Командная строка копи-
    руется в 128 байт, так что она адресуема через DS.

11. Размер стека определяется во время исполнения; стек раз-
    мещается здесь в своем собственном сегменте.

12. Куча начинается за стеком. Последовательные обращения  к
    malloc() и подобным ей функциям продвигают вперед размер
    кучи. Если при размещении новой памяти нет, то будет раз-
    мещен новый сегмент там, где даст память DOS.  Размер ку-
    чи никогда не уменьшается.

13. Данные в дальней куче размещаются при обращении  к функ-
    ции farmalloc() и ей подобным.  Каждое  последовательное
    обращение создает свой собственный сегмент, обычно адре-
    суемый через ES. Области в дальней куче отдаются назад в
    DOS  при помощи farfree().

14. ?? заменяется на имя исходного файла. Код каждого модуля
    помещается в свой отдельный сегмент кода.

15. Используется для нахождения конца сегментов  класса BSS.
    Все сегменты класса BSS очищаются в 0 в CT.OBJ.  Сегмент
    стека имеет нулевую длину.

16. Размер стека определяется во время исполнения; стек раз-
    мещается здесь. Он растет к сегменту STACK.

17. Куча начинается за стеком. Имеется два случая:

    а. if  (_okbigbuf!=0)     //если _okbigbuf - истина,  то
         размер кучи равен 64K минус суммарный размер DGROUP
         сегментов и стека.

    б. if  (_okbigbuf==0)    //если _okbigbuf - ложь, то раз-
         мер кучи растет  по мере необходимости до 64K минус
	 суммарный размер DGROUP сегментов и стека.


   Дополнительную информацию можно получить при чтении C.ASM,
SBRK.ASM и,  в руководстве по редактору связей, - о том, как
работает ключ /DOSSEG.  Файлы C.ASM и SBRK.ASM  находятся на
диске исходных текстов библиотечных файлов.


Общее размещение

   Ассемблерный код должен  быть  разделен на разделы кода и
данных (сегменты). В сегмент кода будут помещаться исполняе-
мый код и функции, вызываемые из C++. В сегмент данных поме-
щаются статические и глобальные данные.

   Псевдо-операции для  определения  сегментов кода и данных
в каждой модели данных различны.  Поэтому  следует использо-
вать макросы begcode, endcode, begdata, enddata, которые оп-
ределены в  MACROS.ASM  для каждой модели памяти.  Общий вид
исходного ASM файла таков:

   INCLUDE MACROS.ASM   ;  определяет макросы моделей памяти
      (здесь должны быть  EXTRN  операторы для функций  C++,
       которые будут вызываться)

   begdata              ;  задает  начало   сегмента  данных
      (здесь идут EXTRN  операторы  для  внешних  глобальных
       данных)

   enddata              ;  задает  конец   сегмента   данных

   begcode   имямодуля  ;  задает  старт  сегмента  кода
      (здесь идет исполняемый код)

   endcode   имямодуля  ;  задает  конец  сегмента  кода

   END                  ;  задает  конец  модуля


Сборка подпрограмм

   Поскольку в 8088 нельзя индексировать указатель стека SP,
но можно - указатель  базы BP,  то именно BP регистр целиком
занят под указатель на текущую  область стека.  Подпрограмма
вызывается выталкиванием  параметров в стек,  справа налево,
затем управление передается подпрограмме.  Вызванная подпро-
грамма выталкивает в стек старое значение BP, затем устанав-
ливает BP указывающим на это значение /в стеке/, размещает в
стеке память под  все  локальные  переменные и выталкивает в
стек SI и DI, если они нужны. Затем исполняется тело подпро-
граммы.

   При возврате: из стека восстанавливаются DI и SI, освобож-
дается память локальных переменных,  выталкивается на BP его
старое значение и выполняется возврат управления.  Затем вы-
зывающий код убирает из стека параметры.


Область стека

   Область  стека  функции - это текущее  состояние  стека и
переменных в нем в точке исполнения  функции.  Область стека
в норме выглядит так:


                       Память больших адресов

                 ┌──────────────────────────────────┐
                 │      Предыдущие области стека    │
                 ├──────────────────────────────────┤
                 │           Параметры              │
                 ├──────────────────────────────────┤
                 │         Адрес возврата           │
     ┌────┐      ├──────────────────────────────────┤
     │ BP │─────>│       Старое значение BP         │
     └────┘      ├──────────────────────────────────┤
                 │ Локальные и временные переменные │
                 ├──────────────────────────────────┤
                 │                SI                │
     ┌────┐      ├──────────────────────────────────┤
     │ SP │─────>│                DI                │
     └────┘      └──────────────────────────────────┘
                        Память меньших адресов

   Стек растет вниз (к меньшим адресам).


Возвращаемые функциями значения

   Ближние указатели (near pointers), целые (int), целые без
знака (unsigned int), литерные (char) и короткие (short) все
возвращаются через AX.  Длинные  (long)  и длинные без знака
(unsigned long)  возвращаются через  DX,AX,  где DX содержит
наиболее значимые  (левые) 16 бит,  а AX  содержит  наименее
значимые (правые) 16 бит.  Дальние указатели  (far pointers)
возвращаются через DX,AX,  где DX содержит сегмент, а AX со-
держит смещение.
   Значения двойной  точности  (double)  возвращаются  через
AX,BX,CX,DX,  где AX содержит наиболее  значимые 16 бит и DX
содержит наименее значимые.
   Когда функция возвращает структуру, фактически она возвра-
щает указатель на  структуру,  которая  находится в сегменте
статических данных (это означает, что возвращающие структуру
функции не являются повторно входимыми).


Использование регистров

   Функции могут изменять значения AX,BX,CX,DX и ES. Функции
должны сохранять значения в SI,DI,BP,SP,SS,CS,DS.  Флаг нап-
равления всегда должен быть установлен "вперед".


Выравнивание данных

   Данные  должны  выравниваться по  16-разрядным  границам,
чтобы максимально использовать  скорость  16-разрядной шины.
Код выравнивается по 8-разрядным границам.


Макросы из MACROS.ASM

   В MACROS.ASM имеются макросы, помогающие в создании неза-
висимых от модели памяти ассемблерных файлов. Вот эти макро-
сы:

      begcode  ; задает начало сегмента кода

      endcode  ; задает конец сегмента кода

      begdata  ; задает  начало  сегмента   инициализирован-
               ; ных данных

      enddata  ; задает  конец  сегмента  инициализированных
               ; данных

      callm    ; ближний или дальний вызов функции

      func     ; определяет  ближнюю  либо  дальнюю  функцию

      c_endp   ; определяет конец функции

      SIZEPTR  ; размер  в  байтах  указателя  по  умолчанию
               ; (2 для T,S,M моделей, 4 для C,L моделей)

      P        ; смещение первого параметра от BP

      LPTR     ; не ноль, если указатели - дальние (C или L)

      SPTR     ; не ноль, если указатели ближние (T,S или M)

      LCODE    ; не ноль, если код большой (M или L)


Простой пример для S-модели


   Этот простой пример содержит обращение к функции на языке
ассемблера для  установки  курсора  в позицию с координатами
x,y.  Все макросы были раскрыты,  вызывающая  функция на C++
была оттранслирована на язык ассемблера, чтобы показать, как
компилятор транслирует C++ функцию. Для трансляции C++ функ-
ции использована утилита  OBJTOASM.EXE.

   Сначала рассмотрим C++ функцию:

   main()
   {
      gotoxy(10,20);      /* установить позицию курсора в
                                       ряд 10, колонка 20 */
   }

   После компиляции  C++ программы в объектный файл и приме-
нения утилиты  OBJTOASM для получения нижеследующего эквива-
лента на языке ассемблера:

   _TEXT segment
   _main:
      mov   AX,014h   ; занести 20 в AX
      push  AX        ; вытолкнуть в стек (2 байта)
      mov   AX,0Ah    ; занести 10 в AX
      push  AX        ; вытолкнуть в стек (2 байта)
      calln _gotoxy   ; вызвать функцию gotoxy() (выталкива-
                      ; ет IP)
      add   SP,4      ; скорректировать  указатель стека (на
                      ; 4 байта)
      ret
   _TEXT ends

      Заметьте,  что переменные  заталкиваются в стек справа
      налево.

  Сначала номер колонки (20) заносится в AX и выталкивается в
стек. Затем номер ряда (10) заносится в AX и выталкивается в
стек.  Наконец, выполняется вызов  gotoxy()  с выталкиванием
IP (instruction pointer - указатель команды) в стек.

   Подчерк  у  идентификаторов  функций _main()  и _gotoxy()
добавляется компилятором,  чтобы  удовлетворить  соглашениям
Microsoft по вызовам. Сегмент _TEXT является CODE сегментом.
Ниже  показано,   как   выглядит   стек  после  обращения  к
_gotoxy(10,20).

		   ┌─────────────────────────┐
                   │            20           │
                   ├─────────────────────────┤
                   │            10           │
                   ├─────────────────────────┤
                   │            IP           │
                   └─────────────────────────┘

   В заключение рассмотрим листинг функции  на языке ассемб-
лера. Все макросы определены в MACROS.ASM.

include MACROS.ASM    ; подключает определения макросов
begcode gotoxy        ; задает начало сегмента кода

   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   ; Процедура интерфейса C++.
   ; Помещает курсор в row, col.
   ; Использование:
   ;  void gotoxy(int row, int col);
      c_public gotoxy      ; делает gotoxy глобальной
   func  gotoxy            ; определяет начало функции
      push  BP             ; сохраняет старую  область стека
      mov   BP,SP          ; устанавливает BP указывающим на
                           ; старый BP
      mov   DH,P[BP]       ; DH = row (ряд)
      mov   DL,P+2[BP]     ; DL = col (колонка)
      mov   AH,2           ; код функции BIOS, устанавливаю-
                           ; щей позицию курсора.
      xor   BX,BX          ; страница 0
      int   10h            ; видео прерывание BIOS
      pop   BP             ; восстановление старого BP
      ret                  ; возврат в вызывавшую функцию
   c_endp   gotoxy         ; определяет конец функции
   endcode  gotoxy         ; определяет  конец сегмента кода
   end

   Функция на языке ассемблера начинается  с выталкивания BP
в стек и занесения  указателя  стека в BP.  Это обеспечивает
далее доступ к переменным (параметрам), помещенным в стек вы-
зывающей C++ функцией.

   Этот доступ обеспечивается использованием BP для указания
смещений  внутри  стека.  В  примере  выше  мы  использовали
MOV DH,P[BP]  для доступа к номеру ряда (строки) и занесения
его в DH.  Диаграмма ниже показывает переменные и их позиции
в стеке. P раскрывается как 4 в T, S и C моделях и как 6 - в
M и L моделях. Это смещение от  BP  до  первого  параметра в
стеке.

		 ┌──────────────────────────┐
                 │            20            │  BP + 6
                 ├──────────────────────────┤
                 │            10            │  BP + 4
                 ├──────────────────────────┤
                 │            IP            │  BP + 2
                 ├──────────────────────────┤
                 │      предыдущий  BP      │  BP + 0
                 └──────────────────────────┘

   После завершения функции следует восстановить BP и возвра-
титься  в  вызывающую  функцию.  Команда  'ret'  восстановит
IP из  стека  и  начнет  исполнение  команды,  следующей  за
'calln _gotoxy'.  Следующей  командой  в нашей  C++  функции
является 'ADD SP,4'.  Она установит  SP  в позицию,  которая
была до выполнения двух команд 'PUSH AX'.  Пример выше отно-
сится к T (тонкой),  S (малой)  и  C  (компактной)  моделям.
В L (большой) и M (средней) моделях CS также выталкивается в
стек при дальнем вызове.  Это изменит  позицию  переменных в
стеке до следующих значений:

                 ┌──────────────────────────┐
                 │            20            │  BP + 8
                 ├──────────────────────────┤
                 │            10            │  BP + 6
                 ├──────────────────────────┤
                 │            CS            │  BP + 4
                 ├──────────────────────────┤
                 │            IP            │  BP + 2
                 ├──────────────────────────┤
                 │      предыдущий  BP      │  BP + 0
                 └──────────────────────────┘

   Использование макроса P (определенного в MACROS.ASM) поз-
воляет компенсировать это различие.


Следующий пример

   Вот пример ассемблерной  процедуры,  реализующей нижесле-
дующую C++ функцию  (эта функция не слишком полезна,  но она
иллюстрирует,  как  делать такие вещи).  Процедура  написана
так, что будет  ассемблироваться  корректно для любой модели
памяти.
                                               // C++ МОДУЛЬ
   extern var1;
   int var2;
   extern func1();
   int func2(pa,a)
   int *pa,a;
   {
        int b;
        *pa = b;
        var2 = b + var1 + func1(&b,a);
        return a - var2;
   }

   Листинг ассемблерного модуля

                                       ; Ассемблерный МОДУЛЬ
   include MACROS.ASM
   begdata                       ; задает старт сегмента
      extrn     _var1:word       ; данных
   _var2 dw     0                ; размещает var2
   enddata                       ; конец сегмента данных
   if LCODE                      ; если модель с большим
                                 ; кодом
      extrn     _func1: far      ; то дальняя функция
   else
      extrn     _func1: near     ; иначе ближняя функция
   endif
   begcode      func2
      c_public  func2            ; делаем func2 глобальной
   func         func2            ; определяем функцию func2
      push      BP               ; сохраняем старый указа-
                                 ; тель области действия
      mov       BP,SP            ; устанавливаем новый
                                 ; указатель области
      sub       SP,2             ; создаем место для b
      mov       AX,-2[BP]        ; AX = b
   if SPTR                       ; если малая модель памяти
      mov       BX,P[BP]         ; BX = pa
      mov       [BX],AX          ; *pa = b
   else                          ; иначе большая модель
                                 ; памяти
      les       BX,P[BP]         ; ES:BX = pa
      mov       ES:[BX],AX       ; *pa = b
   endif
      push      P+SIZEPTR[BP]    ; вталкиваем "a" в стек
   if LPTR                       ; если дальние указатели
      push      SS               ; вталкиваем сегмент от b
   endif
      lea      AX,-2[BP]         ; AX = смещение от b
      push     AX
      callm    func1             ; вызов func1 (&b, a)
      add      SP,SIZEPTR+2      ; восстановление стека
      add      AX,_var1          ; func1 возвращает резуль-
                                 ; тат в AX
      add      AX,-2[BP]         ; AX = b + var1 + func1(a)
      mov      _var2,AX
      mov      AX,P+SIZEPTR[BP]  ; AX = a
      sub      AX,_var2          ; AX = a - var2
      mov      SP,BP             ; счеркиваем локальные
                                 ; переменные
      pop      BP                ; восстанавливаем старый
                                   указатель области
      ret                       ; в AX возвращаемое значение
   c_endp      func2             ; конец функции func2
   endcode     func2             ; конец сегмента кода
   END                           ; конец модуля

      Заметьте, что операторы EXTRN для кода должны быть вне
      пар begcode/endcode, иначе можно получить сообщение об
      ошибках  фиксации (fixup errors) от линкера при исполь-
      зовании M или L моделей.


Запуск MASM

   Включаемый файл MACROS.ASM  устанавливает макросы в зави-
симости от требуемой модели  памяти.  Модель памяти задается
определением соответствующего имени в командной строке:
   MASM /MX /DI8086? /R  модуль;
где вместо ? должно  быть  S, M, C  или  L  в зависимости от
того, какая модель требуется.  S-модель  выбирается по умол-
чанию (это можно понять,  глядя  на  файл  MACROS.ASM).  Для
программ в T-модели не нужно определять I8086T;  следует ис-
пользовать  S-модель.  (Вспомните,  что разница между  T и S
моделями возникает при сборке  (редакции связей),  но не при
компиляции или ассемблировании).
   Ключ /MX  необходим,  чтобы  все  глобальные  имена  были
чувствительны к регистру  (различались заглавные и прописные
буквы). Не используйте ключ /ML,  поскольку при этом некото-
рые версии  MASM  будут некорректно ассемблировать возможные
коды (opcodes) 8087.
   Ключ /R включает ассемблирование  возможных  кодов  8087.
   Специальная поддержка вызова  MASM  встроена в ZTC.  Если
параметр-файл  для ZTC оканчивается на .ASM,  ZTC попытается
ассемблировать  его  посредством  MASM.  Если для ZTC задана
модель памяти,  то  ZTC  передаст  MASM  соответствующее имя
(define). Аналогично ключи ZTC -g, -D, -v и -I после их пре-
образования в соответствующие ключи MASM, передаются ему.
   Этот механизм следует использовать только с версией 5.0 и
поздними версиями  MASM,  так как для ранних версий ключ /Zd
(ZTC -g) недопустим.
   Файл  C.ASM с диска исходных текстов библиотек (поставля-
ется отдельно) нельзя ассемблировать  версиями  MASM,  пред-
шествующими 5.0.  Причина в том, что более старые ассемблеры
не поддерживают псевдо-опцию DOSSEG.