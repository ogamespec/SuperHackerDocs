
                           Часть 3

             Б И Б Л И О Т Е К А  Ф У Н К Ц И Й



                                         БИБЛИОТЕКА  ФУНКЦИЙ
                                         ───────────────────


   Библиотечные функции естественно разделяются на две кате-
гории:

     * функции, совместимые с ANSI стандартом языка "C";
     * несовместимые с ANSI стандартом дополнительные библи-
       отечные функции

   ANSI C  функции   заложены  в  предложенный  Американским
Институтом Национальных Стандартов  стандарт для языка прог-
раммирования "C".  Эти функции обеспечивают  наибольшую сте-
пень переносимости между различными операционными окружения-
ми так же, как и большинство специфических  MS DOS  функций.
ANSI стандарт - это расширение исходного языка, предложенно-
го Kernighan и Ritchie, включающее  в стандарт языка "C" ряд
черт языка C++.
   Библиотека Zortech C очень тесно согласуется с предложен-
ным ANSI стандартом, а также содержит большое число дополни-
тельных функций,  разработанных для облегчения программистам
использования  аппаратуры и ресурсов  операционной  системы.
Библиотечные функции,  которые  включаются в предварительный
ANSI стандарт, помечаются следующим обращзом: /* ANSI */.
   Использование  таких  функций  увеличивает  переносимость
прикладных программ. Этот раздел руководства содержит описа-
ние сообщений о системных  ошибках и ошибках  математических
функций,  файлов заголовков и перечисленных в алфавитном по-
рядке  функций.  До этого дается информация о двух отдельных
группах функций:

      * функции работы с файлами
      * функции управления памятью

   Некоторые Zortech  функции  требуют  специальных знаний о
микропроцессоре  8086,  аппаратуре  персонального компьютера
или  операционной  системе  MS DOS.  Многое  из  этого можно
узнать при чтении следующих документов:

      - Технический справочник по IBM PC (аппаратура).
      - Справочник программиста по MS DOS (фирма Microsoft).


Обмен с файлами


   Виды файлов

   Файлы  могут быть считаны или записаны  в  двух  режимах:
текстовом режиме и двоичном режиме.  Двоичный режим является
"родным" для MS DOS.  В нем файлы считываются и записываются
байт за байтом,  откуда и куда  указано.  В текстовом режиме
производятся различные преобразования, как-то:

      Вывод:  если указывается литера "перевод строки" '\n',
              в действительности записываются '\r'\n' (лите-
              ры "возврат каретки" и "перевод строки").

      Ввод:  при вводе  "возврат каретки" '\r' игнорируется,
             а литера control Z (0х1A) помечает конец файла.

   Обычные текстовые файлы (например,  файл исходного текста
программы) должны использовать текстовый режим,  который вы-
бирается по умолчанию.  Файлы,  содержащие  двоичные данные,
должны  использовать  двоичный  режим.  Смотрите  о  функции
fopen() для объяснения подробностей  открытия  файлов в раз-
личных режимах.


   Высокий и низкий уровни обмена с файлами

   Имеется два набора  программ  обмена с файлами:  высокого
уровня и низкого уровня.  Программы высокого уровня читают и
пишут файлы как в текстовом,  так и в двоичном режимах. Низ-
коуровневые программы читают и пишут файлы только в двоичном
режиме.

   Высокоуровневые  и  низкоуровневые  программы  никогда не
следует  использовать  одновременно с одним и тем же файлом.
Программисту,как правило,следует использовать высокоуровневые
программы,поскольку они в большей степени переносимы.


   Низкий уровень обмена с файлами

   Программы низкого уровня для обмена с файлами - это функ-
ции creat(), open(), close(), lseek(), read() и write(). Они
реализуются как прямое обращение (hooks) к операционной сис-
теме MS DOS.

   Файл, с которым работают эти функции, задается дескрипто-
ром файла (handle).  Ввод/вывод  является небуферизованным и
двоичным. Ниже перечислены некоторые дескрипторы специальных
файлов, которые всегда открыты:

      0   Стандартное устройство ввода.
      1   Стандартное устройство вывода.
      2   Стандартное устройство вывода сообщений об ошибках.
      3   Стандартное дополнительное (auxiliary) устройство.
      4   Стандартное печатающее устройство.


   Высокий уровень обмена с файлами

   Функции обмена с файлами высокого уровня, включая функции
fopen(), fread(), fwrite() и fclose(),  построены  на основе
низкоуровневых функций.  Эти  функции  взаимодействуют через
указатель потока ввода/вывода (объявленного как FILE *). Вы-
сокоуровневые  функции  осуществляют  буферизованный  обмен.
Пять потоков ввода/вывода всегда открыты, это:

      stdin    Стандартный ввод
      stdout   Стандартный вывод
      stderr   Стандартный вывод сообщений об ошибках
      stdaux   Стандартный дополнительный поток (auxiliary)
      stdprn   Стандартный принтер

   Для использования высокоуровневых функций Вы должны вклю-
чить строку

      #include <stdio.h>

в начало Вашего файла исходного текста программы.


Распределение памяти


   'Куча' (Heap)

   'Куча' - это область памяти,  распределяемой динамически.
Память  распределяется  и освобождается  при  помощи функций
malloc(), realloc(), calloc() и free().

   Для  S (малой),  M (средней)  и  T (тонкой)  моделей про-
странство для 'кучи' может распределяться в  MS DOS  целиком
за раз или по мере необходимости. Большинство программ будет
использовать схему  распределения памяти по умолчанию, кото-
рая расширяет сегмент данных, используя все доступное прост-
ранство памяти (до 64K) при запуске программы.

   Другая   схема   выделения   пространства   под  'кучу' -
'по  необходимости' - используется  для  программ,   которые
исполняют другие  программы,  т.е.  используют  функции типа
spawn().
   Распределение памяти под 'кучу' 'по необходимости' остав-
ляет максимальное количество  доступной памяти дочерним про-
цессам.  Вторая  схема  выбирается  при объявлении и инициа-
лизации переменной _okbigbuf  0.  Следующий пример показыва-
ет, как выбирается вторая схема распределения памяти:

      int _okbigbuf = 0; /* Использовать схему распределения
                            памяти 'по необходимости' */

   _okbigbuf != 0 означает использование больших дисковых бу-
феров для потока ввода/вывода вне сегмента  данных.  Все это
управление запрограммировано в C.ASM.
   C.ASM - это стартовый  C  модуль,  который  автоматически
прикомпоновывается в начало  Вашей программы и инициализиру-
ет сегментные регистры в соответствии с используемой моделью
памяти;  C.ASM также  гарантирует,  что программа имеет кор-
ректную структуру, как это требует MS DOS. Этот модуль уста-
навливает также схему  распределения  памяти,  которая будет
использоваться для получения памяти из сегментов данных.

   Для получения более подробной информации по распределению
памяти смотрите раздел 'интерфейс с ассемблером'  справочно-
го руководства.


   Стек (Stack)

   Стек растет вниз по направлению к статически  размещенным
данным. Если стек переходит границу  выделенного пространст-
ва,  то статически  распределенные  данные будут разрушены и
программа может выполняться необъяснимым  образом.  Для про-
верки того,  что стек не нарушает границу,  имеется  функция
_chkstack().

   Функцию _chkstack() следует вызывать из функций, которые,
возможно, используют слишком много  стекового  пространства.
Если это случается, _chkstack() аварийно  завершает выполне-
ние программы с сообщением  о  переполнении  стека.

   Ключ -s  компилятора может  использоваться  для генерации
программы с проверкой переполнения стека  при входе в каждую
функцию. Хотя это увеличивает  размер  программы и влияет на
скорость исполнения, но обеспечивает помощь при решении проб-
лемы переполнения стека. Если обнаружится переполнение стека,
сообщение:

      STACK OVERFLOW

выводится на экран терминала и программа аварийно завершает-
ся. Размер стека может быть установлен статически путем ини-
циализации глобальной переменной _stack:

   unsigned _stack = nnnn;

в начале Вашей программы;  'nnnn' - это размер в байтах тре-
буемого стека.  По умолчанию  размер  стека равен 2048 байт.
Допустимыми значениями для nnnn являются 1024 ... 30000. Па-
мять,  распределенная под стек, не забирается от статических
данных в C и L моделях памяти,так как стек помещается в свой
собственный сегмент.


Глобальные переменные

   Имеется несколько глобальных переменных,  которые опреде-
ляют состояние частей программы. Здесь описываются имена пе-
ременных и их использование.


   _8087

   Всякий раз в начале использования программы определяется,
имеется ли в наличии сопроцессор 8087, 80287 или 80387. Если
есть,  все  вычисления  с плавающей точкой могут выполняться
этим сопроцессором. Если же его нет, все вычисления с плава-
ющей точкой программно  эмулируются.  Глобальная  переменная
_8087 определяется в файле  C.ASM и может  быть проверена на
предмет наличия сопроцессора _8087. Если значение переменной
_8087 равно 0, сопроцессора  8087  нет. Значение переменной,
равное 1,  указывает на то,  что  сопроцессор  8087  найден;
2 - имеется 80287; 3 - имеется 80387.

   Поведение Zortech библиотек также управляется этой пере-
менной. Например:

      extern int _8087;
         if(_8087)
            printf("8087 присутствует\n");
         else
            printf("8087 отсутствует\n");


      Варианты арифметики с плавающей точкой

   Предлагается четыре способа выполнения операций с плаваю-
щей точкой:

      1. Нет никаких операций с плавающей точкой.  Не загру-
         жать из библиотеки  программы выполнения операций с
         плавающей точкой.

      2. Все операции с плавающей  точкой  исполнять в 8086.
         Если имеется 8087, не использовать его.

      3. Выполнять  операции с плавающей  точкой,  используя
         8086. Если имеется 8087, использовать его для вычис-
         лений вместо 8086. Библиотечные математические функ-
         ции переключить на встроенные  8087 программы, если
         есть 8087. Эта опция используется по умолчанию.

      4. Генерирует прямой код для  8087.  Для запуска прог-
         раммы требуется наличие 8087.


      Преимущества:

      1. Размер результирующей  программы  становится значи-
         тельно меньше.

      2. 8087 не нужен.  Результаты в  точности  повторяются
         на всех 8086 машинах. Компилятор сам использует эту
         опцию.

      3. Без 8087 работает  также как 2,  но при наличии ис-
         пользуется 8087 и программа будет работать быстрее.

      4. Генерируется  самый  быстрый  и  компактный код,  и
         потенциально получаются  наиболее точные результаты
         (арифметика в 8087 выполняется с использованием  80
         бит против 64 бит для 8086). Относительное увеличе-
         ние скорости,  получаемое  при  использовании 8087,
         весьма сильно зависит от отношения скоростей 8087 и
         основного процессора), а также от используемой Вами
         версии  8087  (80287,  80387,  совместимые  с  ними
         и т.д.). Для персонального компьютера эти улучшения
         становятся  заметными на программах, интенсивно ис-
         пользующих операции с плавающей точкой.


      Недостатки:

      1. Нельзя выполнить никакой  операции с плавающей точ-
         кой.

      2. Самый медленный код.  Менее точные вычисления. Раз-
         мер программы велик.

      3. Результаты могут зависеть от того, имеется ли сопро-
         цессор  8087.  Программа  того же размера как и для
         случая 2.

      4. Для работы требуется 8087.  Исполнение  команд про-
         цессора 8087 при его отсутствии  может вызвать крах
         системы.


      Вариант 1:

   Программа создается явной  прикомпоновкой модуля INT.OBJ.
INT.OBJ  определяет  все точки входа программ библиотеки для
работы с плавающей точкой, так что ни одна из таких программ
не выбирается  из  библиотеки.  Если  происходит  какой-либо
вызов  программы  вычислений с плавающей точкой,  печатается
сообщение:

    FLOATING POINT NOT LOADED (программы выполнения операций
                             с плавающей точка не загружены)

и программа останавливается.  Один и тот же  INT.OBJ  модуль
используется для всех моделей памяти.

   Прикомпоновка модуля INT.OBJ может быть указана программе
ZTC с помощью флага [-mi]. ZTC использует переменную окруже-
ния LIB для поиска  INT.OBJ и передает его редактору связей.
Например:

      ZTC -mi hello


      Вариант 2:

   Вариант 2 реализуется  при  помощи  следующего  фрагмента
программы:

      main()
      {  extern int _8087;
         _8087 = 0;       /* никогда не использовать 8087 */
         ...
      }


      Вариант 3:

   Вариант 3 реализуется по умолчанию.


      Вариант 4:

   Вариант 4 создается при трансляции программы  посредством
ZTC с флагом -f.
Например:

      ZTC file -f

   Поскольку  код  программы, оттранслированной с флагом -f,
будет приводить к краху  системы при ее запуске и отсутствии
8087,  очень рекомендуем в этом случае включить в Вашу прог-
рамму следующий фрагмент:

      main ()
      {  extern int _8087;
         if(_8087==0)            /* если 8087 отсутствует */
               {  printf("Эта программа требует 8087\n");
                  exit(1);            /* останов программы*/
               }
           ...
      }

   Более 'отчаянные'  программисты,  которые  используют ва-
риант 4, могут модифицировать и перекомпилировать эти библи-
отеки для удаления из них всех не 8087 программ работы с пла-
вающей точкой для того,  чтобы  сделать  программу  меньше и
несколько быстрее.

   Одни те же Zortech библиотеки используются во всех вариан-
тах.

      Заметим,  что нет различий в  call/return  соглашениях
      между функциями, поэтому obj модули,  которые компили-
      руются в разных вариантах, могут свободно компоновать-
      ся вместе.

   Например, прикладная программа, которая осуществляет мат-
ричные преобразования, может иметь две версии преобразований:

      ZTC -c -f matrix -DINLINE8087 -omatrix87.obj
      ZTC -c matrix
      ZTC main matrix.obj matrix87.obj

   Файл matrix.c может содержать:

      #ifdef INLINE8087
      void matrix87()
                    /* для версии с 8087 нужно другое имя */
      #else
      void matrix()
      #endif
      {
         ...
      }

   Файл main.c может содержать:

      extern int _8087;
      ...

      if(_8087)                      /* если имеется 8087 */
         matrix87();      /* используется версия для 8087 */
      else
         matrix();
          /* используется версия с программной реализацией*/
                                       /* плавающей точки */

   Таким образом исполняемая  программа  может  пользоваться
всеми преимуществами сопроцессора 8087, но также будет рабо-
тать корректно и при его отсутствии.  Подобные примеры можно
увидеть в библиотечном файле math.c.


   _okbigbuf (только для T, S и M моделей памяти)

   Эта переменная определяет,  какую схему распределения па-
мяти использовать. Существует два способа распределения:

      Способ 1:

         Распределяет всю доступную память (до 64K) под 'ку-
         чу' при старте программы.  Этот способ используется
         по умолчанию.

      Способ 2:

         Память распределяется под 'кучу' только при необхо-
         димости. Этот способ должен быть использован,  если
         потребуется функция spawn.  Для использования этого
         способа объявите  _okbigbuf  как это показано ниже.
         Для более подробной  информации смотрите 'Распреде-
         ление памяти'.

      Использование:

         int _okbigbuf = 0;    /* Отводить память по мере */
                                         /* необходимости */

   _okbigbuf!=0  означает также использование больших диско-
вых буферов для потока ввода/вывода вне сегмента данных. Все
это управляется модулем C.ASM.


   _osmajor

   Эта переменная определяет основной номер исполняемой вер-
сии MS DOS. Значение  _osmajor  будет равно 3 при работе под
управлением MS DOS 3.2 или 2 при работе под MS DOS 2.0.

      Использование:

         extern unsigned char _osmajor;


   _osminor

   Эта переменная определяет  дополнительный номер исполняе-
мой версии MS DOS.  Значение _osminor будет равно 11 при ра-
боте  под  управлением  MS DOS 2.11  или  1  при  работе под
MS DOS 3.1.

      Использование:

         extern unsigned char _osminor;



   _psp

   Эта переменная  содержит  адрес сегментного параграфа для
префикса программных сегментов. Эта переменная может исполь-
зоваться для построения 'дальних' указателей, обеспечивающих
доступ к префиксу  программных  сегментов из программы поль-
зователя.

      Использование:

         extern unsigned _psp;


   errno

   Этой переменной присваиваются номера ошибок после исполь-
зования некоторых библиотечных функций при появлении ошибок.
Значения errno следующие:

      E2BIG                       100
      EACCES                        5
      EBADF                         6
      EDOM                        102
      EEXIST                       80
      EMFILE                        4
      ENOENT                        2
      ENOEXEC                      01
      ENOMEM                        8
      ENOTDIR                       3
      ERANGE                      103

      Использование:

         extern int errno;

   Смотрите также файл  errno.h  для описания смысла каждого
значения ошибки.



                                      СООБЩЕНИЯ  ОБ  ОШИБКАХ
                                      ──────────────────────

   Ошибки ДОС


   В таблицах ниже перечислены сообщения об ошибках, возвра-
щаемые функцией perror(), с соответствующим номером ошибки в
errno.

      E2BIG          Список  аргументов   слишком   большой.
                     (Список аргументов превышает 128 байт).

      EACCES         Отказ в разрешении доступа.
                     (Например, запись в файл, открытый толь-
                     ко по чтению).

      EBADF          Плохой дескриптор файла.

      EDOM           Аргумент математической функции вне об-
                     ласти определения.

      EEXIST         Файл уже существует.

      EMFILE         Слишком много открытых файлов.

      ENOENT         Нет такого файла или каталога.

      ENOEXEC        Ошибка формата исполняемого файла.

      ENOMEM         Нет  достаточного  пространства памяти.
                     (Например,  недостаточно памяти для ис-
                     полняемой функции).

      ENOTDIR        Маршрут к каталогу не найден.

      ERANGE         Результат вне диапазона значений.
                     (Аргумент математической  функции слиш-
                      ком велик).

   Смотрите пример из описания библиотеки по функции perror()
для выяснения использования этих сообщений об ошибках.


   Ошибки математических функций


   Ошибки, встречающиеся при исполнении математических функ-
ций, возвращаются функцией matherror().

   math.h

      DOMAIN         Недопустимая операция.

      OVERFLOW       Результат  слишком  велик для его пред-
                     ставления.

      PLOSS          Частичная потеря точности значимости.

      SING           Особенность аргумента, (например, нуле-
      		     вое значение передается функции  log(),
		     требующей ненулевого параметра).

      TLOSS          Полная потеря точности значимости.

      UNDERFLOW      Результат слишком мал для его представ-
                     ления.


                                            ФАЙЛЫ  ЗАГОЛОВКИ
                                            ────────────────

assert.h

   Определяет макрос assert().

   Если  идентификатор  NDEBUG  не был определен в командной
строке компилятора или в #define  директиве,  макрос опреде-
лен и служит  для проверки  заданного  параметром выражения.
Если это утверждение ложно, печатается сообщение и программа
завершается.
   Если  NDEBUG  определен,  assert  определяется как пустой
текст. В результате все assert утверждения как бы становятся
комментариями.


conio.h

   Объявляет  прототипы для функций ввода/вывода на консоль.

      getch     getche     inp     inpw     outp     oupw


ctype.h

   Определяет макросы и константы,  используемые при класси-
фикации литер.

      isalnum    isalpha    isascii    iscntrl    isdigit
      isgraph    islower    isprint    ispunct    isspace
      isupper    isxdigit   toascii

   В  файл  ctype.h  включено  также  глобальное  объявление
массива  _ctype.  Этот  массив  является  ориентированной на
ASCII таблицей кодов классификации.


direct.h

   Объявляет  прототипы  для  функций работы с каталогогами.

      chdir          getcwd          mkdir          rmdir


disp.h

   Определяет макросы,  объявляет  константы и прототипы для
функций прямого доступа к экрану.

      disp_close         disp_eeol           disp_eeop
      disp_endstand      disp_flush          disp_getmode
      disp_move          disp_open           disp_pokew
      disp_printf        disp_putc           disp_reset43
      disp_scroll        disp_set43          disp_setattr
      disp_setmode       disp_usebios        disp_startstand
      disp_setcursortype


dos.h

   Определяет  макросы,  константы и объявляет  интерфейсные
функции для  MS DOS и IBM PC.  Они  включают в себя доступ к
вводу/выводу через порты, определения видов файлов, процедур
обработки прерываний, а также структуры регистров.

   Объявления прототипов dos-пакета:

      dos_abs_disk_read               dos_abs_disk_write
      dos_getdiskfreespace            dos_get_ctrl_break
      dos_get_verify                  dos_set_ctrl_break
      dos_set_verify

   Объявления прототипов для функций MS DOS работы с катало-
гами:

      findfirst                       findnext

   Объявления  прототипов функций для 'дальнего' распределе-
ния памяти:

      farmalloc            farcalloc             farrealloc
      farfree              farcoreleft

   Объявления функций доступа к портам ввода/вывода:

      inp           inpw           outp            outpw

   Регистровые структуры,  используемые функциями  intdos(),
intdosx(), int86(), int86x():

      WORDREGS         BYTEREGS        REGS         SREGS

   Макросы   для   работы   с   дальними   указателями
(сегмент:смещение):

            FP_SEG        FP_OFF         MK_FP


fg.h

   Определяет константы, типы, прототипы функций пакета быст-
рой графики.  Следующие  константы соответствуют графическим
режимам:

      FG_CGAMEDRES  0х04  IBM CGA , 320*200,  цветной
                                                (режим 0х04)
      FG_CGAHIRES   0х06  IBM CGA , 640*200     (режим 0х06)

      FG_EGACOLOR   0х0E  IBM EGA  с нормальным цветным ото-
                                   бражением    (режим 0х0E)
      FG_EGAMONO    0х0F  IBM EGA  с IBM монохромным монито-
                                   ром          (режим 0х0F)
      FG_EGAECD     0х10  IBM EGA  с улучшенным цветным ото-
                                   бражением    (режим 0х10)
      FG_VGA11      0х11  IBM VGA , 640*480,  1 цвет.

      FG_VGA12      0х12  IBM VGA , 640*480,  16 цветов.

      FG_VGA13      0х13  IBM VGA , 320*200,  256 цветов.

      FG_HERCHALF   0х02  Hercules ("Геркулес"), монохромный,
                               1 страница дисплейной памяти.
      FG_HERCFULL   0х03  Hercules, монохромный,  2 страницы
                                          дисплейной памяти.
      FG_TOSHIBA    0хFA  TOSHIBA J-3100.

      FG_8514A            Графический адаптер IBM 8514A.

   Функции:

      fg_adjustxy         fg_drawarc       fg_writebox
      fg_drawbox          fg_drawdot       fg_drawellipse
      fg_drawline         fg_drawlinep     fg_drawmatrix
      fg_drawthickline    fg_enclose       fg_fillbox
      fg_flush            fg_getcolormap   fg_init
      fg_init_all         fg_init_cga      fg_init_cgamedres
      fg_init_egacolor    fg_init_egaecd   fg_init_egamono
      fg_init_herc        fg_blit          fg_init_toshiba
      fg_init_vga11       fg_init_vga12    fg_init_vga13
      fg_putc             fg_puts          fg_readbox
      fg_readdot          fg_restore       fg_save
      fg_setactivepage    fg_setcolormap   fg_setdisplaypage
      fg_text_mode        fg_term          fg_setlinepattern

   Типы линий:

      FG_LINE_MEDIUM_DOTTED             FG_LINE_LONG_DASH
      FG_LINE_DENSE_DOTTED              FG_LINE_SHORT_DASH
      FG_LINE_MEDIUM_DASHED             FG_LINE_MAX
      FG_LINE_DASH_DOTTED               FG_LINE_SOLID
      FG_LINE_SPARSE_DOTTED             FG_LINE_USER_DEFINED
      FG_LINE_DASH_W_2_DOTS

   Цвета:

      FG_BLACK                FG_BLUE             FG_GREEN
      FG_CYAN                 FG_BLUE_GREEN       FG_RED
      FG_PURPLE               FG_YELLOW           FG_WHITE
      FG_LIGHT_BLUE_GREEN     FG_LIGHT_GREEN      FG_GRAY
      FG_LIGHT_BLUE           FG_LIGHT_RED        FG_MAGENTA
      FG_LIGHT_CYAN           FG_LIGHT_WHITE      FG_BROWN
      FG_LIGHT_MAGENTA        FG_HIGHLIGHT        FG_BLINK



errno.h

   Определяет мнемонические константы, используемые функцией
perror.

      Смотрите раздел по сообщениям об ошибках.



int.h

   Содержит объявления функций и структур для программ обра-
ботки прерываний.

      int_getvector         int_intercept        int_off
      int_restore           int_setvector        int_on



io.h

   Содержит объявления  функций для  низкоуровневой работы с
файлами.

      close      creat     delete     filesize     getDS
      isatty     lseek     open       read         remov
      rename     write     unlink



limits.h

   Определяет предельные значения и диапазоны числовых вели-
чин.



math.h

   Объявляет прототипы математических функций:

      acos       asin       atan        atan2        atof
      ceil       cos        cosh        exp          fabs
      floor      fmod       frexp       hypot        ldex
      log        log10      modf        poly         pow
      sin        sinh       sqrt        tan          tanh



msmouse.h

   Объявляет прототипы для MS-MOUSE функций работы с 'мышью':

      msm_condoff        msm_getpress      msm_getrelease
      msm_getstatus      msm_hidecursor    msm_init
      msm_lightpenoff    msm_lightpenon    msm_readcounters
      msm_setareax       msm_setareay      msm_setcurpos
      msm_setgraphcur    msm_setratio      msm_settextcur
      msm_showcursor     msm_signal        msm_setthreshhold
      msm_term


process.h

   Объявляет прототипы всех  функций  управления процессами:

   _exit       execl        execlp      execv         execvp
   spawnl      spawnlp      spawnv      spawnvp


setjmp.h

   Объявляет тип  jmp_buf,  используемый  функциями setjmp и
   longjmp (также объявленными).


signal.h

   Определяет следующие значения для сигналов:

      SIG_DFL     SIG_ERR     SIG_IGN     SIGABRT     SIGFPE
      SIGILL      SIGINT      SIGSEGV     SIGTERM

   Объявляет функции raise() и signal().


sound.h

   Объявляет прототипы для функций работы со звуком:

             sound_beep    sound_click    sound_tone

stdarg.h

   Определяет макросы,  используемые для чтения списка аргу-
ментов переменной длины:

      va_list         va_start         va_arg         va_end


stddef.h

   Определяет общие типы данных.

      errno        Глобальная  переменная,  содержащая номер
                   сообщения об ошибке.
      ptrdiff_t    Синоним типа,  который является разностью
                   двух указателей.
      size_t       Синоним типа,  который может быть исполь-
                   зован для хранения размера переменной.

stdio.h

   Определяет константы, типы,  макросы  и прототипы функций
для потокового ввода/вывода.

      bdos        clearerr    fclose      feof      ferror
      fflush      fgetc       fgets       fileno    filesize
      flushall    fopen       fprintf     fputc     fputs
      fread       freopen     fscanf      fseek     ftell
      fwrite      getc        getch       getchar   getche
      gets        max         min         printf    putc
      putchar     puts        rewind      stdaux    stderr
      stdin       stdout      stdprn      scanf     setbuf
      setvbuf     sprintf     sscanf      ungetc    vfprintf
      vprintf     vsprintf

      BUFSIZ    размер  по умолчанию  буфера,  используемого
                для потокового ввода/вывода.
      _NFILE    Определяет  максимальное число  одновременно
                открытых файлов.
      EOF       Определяет значение, возвращаемое программой
                ввода/вывода при обнаружении конца файла.
      NULL      Нулевое значение указателя.

      BIGBUF    Размер  буфера  для  использования в потоках
                ввода/вывода при _okbigbuf==1.


stdlib.h

   Объявляет прототипы для следующих функций:

      abort        abs          atexit      atof       atoi
      bsearch      calloc       div         exit       free
      getenv       itoa         labs        atol       ldiv
      malloc       qsort        rand        realloc    srand
      strtod       strtol       strtoul     system


string.h

   Объявляет прототипы функций обработки строк:

      strcat      strchr      strcmp      strcmpl    strcpy
      strcspn     strdup      strerror    strlen     strlwr
      strncat     strncmp     strncpy     strnset    strpbrk
      strrchr     strrev      strset      strspn     strstr
      strtok      strupr      swab

   Объявляет прототипы функций работы с памятью:

      memcpy          memcmp          memchr          memset



sys\stat.h

   Определяет  флаги,  используемые  при создании и открытии
файлов. Объявляет прототипы функций для stat() и fstat().

      S_IFCHR         S_IFDIR         S_IFMT         S_IFREG
      S_IEXEC         S_IREAD         S_IWRITE

   stat.h  не может включаться в  C++  файлы,  stat.h  годен
только для C файлов из-за конфликта имен между struct stat и
int stat().



time.h

   Объявляет прототипы функций работы со временем.

      asctime     clock      ctime       difftime     gmtime
      localtime   mktime     strftime    time













                                       БИБЛИОТЕЧНЫЕ  ФУНКЦИИ
                                       ─────────────────────


   Описание  каждой   библиотечной  функции  имеет  разделы:

      использование
      описание
      пример
      возвращаемое значение
      рекомендация,

описанные ниже.

      имя_функции

   Каждая библиотечная  функция  начинается с имени функции.
Каждое  имя  функции   предназначено   для  использования  в
C-программе и может включать ведущий подчерк (`_'),  заглав-
ные буквы (`FP_OFF')  и совместное  использование  регистров
(`getDS').  Важно  отметить,  что  использование  `printf' и
`PRINTF' не эквивалентно.

      Использование:

   Во-первых, в этом разделе содержится директива компилято-
ру #include <filename.h>.  <filename.h> является именем фай-
ла заголовков, содержащего прототип функции. Прототип содер-
жит описание типа возвращаемого  значения и входных парамет-
ров. Файл заголовков может также  содержать  описание типов,
структур и констант, используемых функцией.
   Последующая информация содержит  описание прототипа функ-
ции в том же виде, как он определен в файле заголовков. Воз-
можно объявление функции путем приведения прототипа функции,
включенного  в  этот файл,  вместо  использования  директивы
`#include'.
   Поскольку функция может  использовать другие типы данных,
включенные в файл заголовков, включение этого файла обеспечи-
вает необходимый контроль ошибок, а не только объявление про-
тотипа функции.

      Описание:

   Содержит  информацию о назначении  функции,  описывает ее
аргументы и другие детали использования функции.

      Пример:

   В большинстве случаев  приводится  полностью  законченный
вычислительный пример,  который можно  ввести  и  выполнить.
Каждый пример включает все необходимые файлы заголовков, ис-
пользуемые  функцией.  В  большинстве  случаев  используется
также stdio.h файл. Это обусловлено тем, что printf является
функцией с переменным числом  параметров,  так что включение
stdio.h  файла,  содержащего прототип функции printf, гаран-
тирует проведение надлежащего контроля.

      Возвращаемое значение:

   Специфицирует значение, возвращаемое функцией.  Во многих
случаях возвращаемое значение информирует об успехе или неу-
даче.  Хотя не всегда необходимо контролировать возвращаемое
значение,  такой контроль ошибок  поможет гарантировать над-
лежащее исполнение Вашей программы.

      Рекомендация:

   Отсылает к другим  аналогичным  или вспомогательным функ-
циям.



abort		               СБРОСИТЬ ВЫПОЛНЕНИЕ ПРОГРАММЫ

      Использование:

         #include <stdlib.h>
         void abort (void);                       /* ANSI */

      Описание:

         Прекращает выполнение текущей программы. Аналогична
         вызову функции _exit с ненулевым значением статуса.

      Пример:

         #include <stdio.h>
         #include <stdlib.h>
         main ()
         {
           FILE * fp;
           fp=fopen("file.dat", "r");
           if (fp==NULL)
             {
               fprintf(stderr, "Не могу открыть file.dat\n");
               abort();
             }
           printf("Файл открыт\n");
         }

      Возвращаемое значение:

         Нет возвращаемого значения.

      Рекомендация:

         Смотрите также exit, _exit, raise


abs		                  АБСОЛЮТНОЕ ЗНАЧЕНИЕ ЦЕЛОГО

      Использование:

         #include <stdlib.h>
         int abs(int i);                          /* ANSI */

      Описание:

         Вычисляет  абсолютное  значение  целого  аргумента.

      Пример:

         #include <stdlib.h>
         #include <stdio.h>
         main ()
         {
           int numbr, absval;
           numbr = -3;
           absval= abs(numbr);
           printf("abs от (%d) равно %d\n",
                     numbr,absval);
         }

      Возвращаемое значение:

         Возвращает абсолютное значение целого аргумента.

      Рекомендация:

         Смотрите labs.



acos     				          АРККОСИНУС

      Использование:

         #include <math.h>
         double acos(double x);

      Описание:

	 Вычисляет arccos (x) в диапазоне [0, пи].  Аргумент
         x должен быть в диапазоне [-1, 1].

      Пример:

         #include <math.h>
         #include <stdio.h>
         main ()
         {
           double x, y;
           x = .94;
           y = acos(x);
           printf("Арккосинус от %f равен %f\n",x,y);
         }

      Возвращаемое значение:

         Возвращает значение  arccos  от входного аргумента.
         Если величина x меньше -1 или больше 1,  устанавли-
         вает еrrno в EDOM,  в stderr печатает сообщение об
         ошибке DOMAIN  и возвращает значение 0.  Обработку
         ошибки  можно модифицировать  посредством  функции
         matherr.

      Рекомендация:

         Смотрите также asin, atan, atan2.



asctime                                           ДАТЬ ВРЕМЯ

      Использование:

        #include <time.h>
        char * asctime(struct tm * ntime);        /* ANSI */

     Описание:

        Преобразует   аргумент,   являющийся  указателем  на
        структуру tm, в ASCII строку из 26 литер, включая за-
        вершающий 0:

           DDD MMM dd hh:mm:ss YYYY\n\0

        где:

           DDD       -  день недели
           MMM       -  месяц
           dd        -  день месяца
           hh:mm:ss  -  часы:минуты:секунды
           YYYY      -  год

        Значение  ntime  может  быть  получено  обращением к
        localtime(), возвращающей указатель на структуру tm,
        определенную в time.h.

     Пример:

        #include <time.h>
        #include <stdio.h>
        main ()
        {
          time_t  tclock;
          time(& tclock);
          printf("Текущие дата и время: %s\n",
             asctime(localtime(& tclock)));
        }

     Возвращаемое значение:

        Возвращает указатель на строку литер, содержащую дату
        и время.  Строка имеет статический класс и перезаписы-
        вается при каждом обращении к asctime.

     Рекомендация:

        Смотрите также clock, ctime, difftime, localtime.


asin                                                АРКСИНУС

      Использование:

         #include <math.h>
         double asin(double x);                   /* ANSI */

      Описание:

         Вычисляет    значение   arcsin(x)    в    диапазоне
         [-пи/2, пи/2].  Значение  аргумента x должно быть в
         диапазоне [-1, 1].

      Пример:

         #include <math.h>
         #include <stdio.h>
         main ()
         {
           double x, y;
           x = .94;
           y = asin(x);
           printf("Арксинус от %f равен %f\n", x, y);
         }

      Возвращаемое значение:

         Возвращает значение  arcsin  от входного аргумента.
         Если значение меньше -1 или больше 1, устанавливает
         errno в EDOM, печатает DOMAIN сообщение об ошибке в
         stderr и возвращает 0. Обработку ошибки можно моди-
         фицировать посредством функции matherr.

      Рекомендация:

         Смотрите также atan, atan2, acos.



assert                                 ПРОВЕРИТЬ УТВЕРЖДЕНИЕ

      Использование:

         #include <assert.h>
         void assert(expression);                 /* ANSI */

      Описание:

         Макрос assert  oсуществляет  внутренний  контроль в
         программе. Он проверяет аргумент expression (выраже-
         ния) и в случае,  если оно равно 0 (т. е. ложно), то
         прекращает исполнение программы; перед этим печатает
         на стандартном устройстве вывода ошибок сообщение:

     Assertion failure: 'expression' on line ?? in file '???'
   (Ошибка утверждения: 'выражение' в строке ?? в файле '???')

      Пример:

         #include <assert.h>
         #include <stdio.h>
         char * string= "";               /* пустая строка*/
         int value=1;
         main ()
         {
           assert(value>0);
           printf("Прошли assert(value>0)\n");
           assert(*string != '0');
         }

      Возвращаемое значение:

         Нет возвращаемого значения.



atan, atan2                                       АРКТАНГЕНС

      Использование:

         #include <math.h>
         double atan(double x);                   /* ANSI */
         double atan2(double x, double y);        /* ANSI */

      Описание:

         atan   вычисляет   значение  arctg(x)  в  диапазоне
         [-пи/2, пи/2].  atan2 вычисляет значение arctg(y/x)
         в диапазоне [-пи, пи].  atan2 использует знаки x, y
         для определения  квадранта,  к которому принадлежит
         результат.

      Пример:

         #include <math.h>
         #include <stdio.h>
         main ()
         {
           double x, y;
           x = 1.0;
           y = atan(x);
           printf("Арктангенс от %f равен %f\n", x, y);
         }

      Возвращаемое значение:

      Обе  функции  возвращают  значение  arctg  от входного
      аргумента (аргументов).  Если x и y оба 0, atan2 уста-
      навливает errno в EDOM,  печатает сообщение DOMAIN  об
      ошибке в stderr и возвращает 0. Обработку ошибки можно
      модифицировать посредством функции matherr.

      Рекомендация:

         Смотрите также acos, asin.



atof, atoi, atol                   ПРЕОБРАЗОВАТЬ В ПЛАВАЮЩЕЕ
                                   ПРЕОБРАЗОВАТЬ В ЦЕЛОЕ
                                   ПРЕОБРАЗОВАТЬ В ДЛИННОЕ
      Использование:

         #include <stdlib.h>
         double atof(char* nptr)                  /* ANSI */
         int atoi(char *nptr)                     /* ANSI */
         long atol(char *nptr)                    /* ANSI */

      Описание:

         Преобразует строку по указателю nptr в целое (atoi),
         удвоенной точности (atof) или длинное (atol) значе-
         ние.  Строка может иметь  ведущие пробелы,  символы
         табуляции, знаки + или -. Преобразование заканчива-
         ется на первой подходящей литере. Если первая же ли-
         тера не подходит, результатом является 0.

      Пример:

         #include <math.h>
         #include <stdio.h>
         #include <stdlib.h>
         main ()
         {
           printf("atof function=%e\n",   atof("123.5e15"));
           printf("atoi function=%d\n", atoi("153"));
           printf("atol function=%ld\n",atol("1234 string"));
         }

      Возвращаемое значение:

         Возвращаются значения:  целое,  удвоенной точности,
         длинное, получаемые преобразованием строки. Возвра-
         щается 0, если во входной строке нет подходящих ли-
         тер.

      Рекомендация:

         Смотрите также ecvt, fcvt, strtod, strtol, scanf.


bdos, bdosx                              ВЫЗВАТЬ ФУНКЦИЮ DOS

      Использование:

         #include <bios.h>
         int bdos(int func, unsigned DX, unsigned AL);
         int bdosx(int func, char *ptr);

      Описание:

         Вызывают функцию MSDOS (прерывание 21h).  func есть
         номер функции,  DX и AL являются значениями, загру-
         женными в регистры  DX  и  AL перед вызовом функции.
         bdosx отличается от bdos лишь тем что вместо AL и DX
         в пару регистров DS:DX загружается аргумент по ptr.

      Пример:

         #include <bios.h>
         main ()
         {
           bdos(2, 'c')           /* высветить букву  c */
         }

      Возвращаемое значение:

         После вызова  системы обе функции возвращают значе-
         ние в регистре AX.

      Рекомендация:

         Смотрите также intdos, intdosx, int86, int86x.



bioskey, _bios_keybrd                   РАБОТА С КЛАВИАТУРОЙ

      Использование:

         #include <bios.h>
         int bioskey(int flag);
         int _bios_keybrd (int flag);

      Описание:

         Оба имени обозначают одну функцию. Два произношения
         нужны  для совместимости  с разными  компиляторами.
         bioskey  передает флаг для  BIOS_прерывания  0x14 -
         - прерывание от клавиатуры. Значения flag:

            0 - чтение значения ввода с клавиатуры из буфера
                ввода. Ждет ввода, если буфер пуст.

            1 - определение наличия значений нажатых  клавиш
                в буфере ввода от клавиатуры.

            2 - чтение состояния клавиш типа 'shift'.

      Возвращаемое значение:

         Если flag=0, то возвращаемое значение является рас-
         ширенным кодом клавиши. ASCII код клавиши находится
         при этом в младшем байте, а скан-код ее - в старшем
         байте.  Если младший байт нулевой,  то это не ASCII
         код (это может быть стрелка  или функциональная кла-
         виша). Если flag=1, то 0 возвращается при отсутствии
         ввода от клавиатуры в буфере ввода; в противном слу-
         чае возвращается расширенный код клавиши.  При этом,
         код клавиши остается  в буфере ввода  и еще доступен
         для чтения. Если flag=2, то возвращаемое значение ин-
         формирует о состоянии 'shift' клавиш:

            0x01 - нажата правая shift клавиша
            0x02 - нажата левая  shift клавиша
            0x04 - нажата клавиша Ctrl
            0x08 - нажата клавиша Alt
            0x10 - включен  ключ Scrolllock
            0x20 - включен  ключ Numlock
            0x40 - включен  ключ Capslock
            0x80 - включен  ключ Ins

      Пример:

         #include <bios.h>
         #include <stdio.h>
         main ()
         {
           int key, shift;
           int lastshift = 0;
           while (1)
           {
             shift=bioskey(2);
             if(shift!=lastshift)
                            /* Если изменился shift статус*/
               printf("shift = 0x%02x\n", shift);
                                 /* Если клавиша нажата*/
             if (bioskey(1))
             {                           /* Читаем клавишу*/
               Key=bioskey(0);
               if ((Key & 0xFF)== 'q') break;
               printf("Клавиша = 0x%04x\n", Key);
             }
             lastshift=shift;
           }
         }


bsearch                             ДВОИЧНЫЙ ПОИСК В МАССИВЕ

      Использование:

         #include <stdlib.h>
         void *bsearch(const void *key, const void *base,
                                  size_t num, size_t width,
            int(*cmp)(const void *elem1,const void *elem2));
                                                  /* ANSI */

      Описание:

         Выполняет двоичный поиск в упорядоченном массиве из
         num  элементов по указателю  base элемента, равного
         key.  Каждый элемент массива имеет размер width бай-
         тов. Алгоритм поиска реализует функция *cmp, опреде-
         ленная пользователем.  Она должна использовать  два
         аргумента, являющихся указателями на элементы, и во-
         звращать одно из значений:

            <0 - elem1 меньше elem2
             0 - elem1 совпадает с elem2
            >0 - elem1 больше elem2

      Пример:

         #include <stdio.h>
         #include <stdlib.h>
         #include <string.h>
         #define SIZE(arr)(sizeof(arr)/sizeof(arr[0]))
         int array[]={1254,3427,1111,3901,6677,0101};
         int intcmp(int *p1, int *p2)
         {
           return(*p1 - *p2);
         }
         main()
         {
           int * pointer;
           int Key = 3901;
           pointer = (int *) bsearch(& Key, array,
                     SIZE(array), sizeof(int), intcmp);
           if(pointer)
           {
             printf("[ %d] имеется в массиве\n", Key);
           }
           else
           {
             printf("[ %d] отсутствует в массиве\n", Key);
           }
         }

      Возвращаемое значение:

         Возвращается  указатель на соответствующий  элемент
         массива base или NULL, если таковой не найден.


calloc                                           ДАТЬ ПАМЯТЬ

      Использование:

         #include <stdlib.h>
         void * calloc(unsigned numelems, size_t sizelem);
                                                  /* ANSI */
      Описание:

         Выделяет блок памяти под numelems элементов и разме-
         ром sizelem байтов каждый. Память обнуляется и возв-
         ращается указатель на нее. В случае ошибки(например,
         недостаточно памяти) возвратится NULL. Если numelems
         или sizelem равен 0,возвращается NULL. Размер запра-
         шиваемой памяти не должен превышать 64 Кбайта.

      Возвращаемое значение:

         В случае успеха  возвращается указатель на выделен-
         ную память; в противном случае - NULL.

      Рекомендация:
         Смотрите также free,  malloc,  realloc,  farcalloc.

      Пример:

                             /* компилировать в C или L модели*/
      #include <stdlib.h>
      #include <stdio.h>
      #include <dos.h>
      #define num 50
      main()
      {
        long * buffer;
        unsigned int segment, offset;
        buffer = calloc(num, sizeof(long));
        if(! buffer)
           {
             fprint(stderr, "Calloc не сработала\n");
             abort();
           }
        segment = FP_SEG(buffer);
        offset = FP_OFF(buffer);
        printf("Память размещена в сегменте
                %x смещение:   %x\n", segment, offset);
        free(buffer);
      }


ceil				         ЦЕЛАЯ ВЕРХНЯЯ ГРАНЬ

      Использование:

         #include <math.h>
         double ceil(double x);                   /* ANSI */

      Описание:

         Вычисляет значение удвоенной точности, представляю-
         щее наименьшее целое, которое больше или равно x.

      Пример:

         #include <math.h>
         #include <stdio.h>
         main()
         {
           double x = 5.3, result;
           result = ceil(x);
           printf("The ceil of %f is %f \n", x, result);
         }

      Возвращаемое значение:

         Возвращает значение удвоенной точности, равное наи-
         меньшему целому, превышающему x.

      Рекомендация:

         Смотрите также floor, fmod.


chdir      		             СМЕНИТЬ ТЕКУЩИЙ КАТАЛОГ

      Использование:

         #include <direct.h>
         int chdir(char * path);

      Описание:

         Это системный вызов, который делает текущим каталог
         (directory) по специфицированному аргументом  марш-
         руту (path). Последний должен приводить к существу-
         ющему каталогу.

      Пример:

         #include <direct.h>
         #include <stdio.h>
         char * path = "\\temp";
         main()
         {
           int result;
           result = chdir(path);
           if(result != 0)
              printf("Не могу перейти к каталогу %s\n",
                      path);
           else
              printf("Текущим стал каталог %s\n", path);
         }

      Возвращаемое значение:

         Возвращается  0  в случае  успеха  и -1 в противном
         случае с установлением errno.

      Рекомендация:
         Смотрите также mKdir, rmdir.


_chkstack                                     ПРОВЕРИТЬ СТЕК

      Использование:

         #include <stddef.h>
         size_t _chkstack(void);

      Описание:

         Определяет переполнение стека, прекращает программу
         с сообщением об этом. Эта функция могла бы вызывать-
         ся из рекурсивных и прочих функций,  которые исполь-
         зуют большую часть стека. Контроль переполнения сте-
         ка может выполняться автоматически установкой ключа
         -s для ZTC2.

      Пример:
                           /* do_tree - рекурсивная функция */
         do_tree(t)
         struct tree * t;
         {
         #ifdef _ZTC_     /* определен, если Zortech C\C++ */
          _chkstack();
         #endif
              .
              .
              do_tree(t ─> left);
              do_tree(t ─> right);
         }

      Возвращаемое значение:

         Возвращает число свободных байтов, оставшихся в сте-
         ке,  если стек еще не переполнен.

clearerr                               СБРОСИТЬ  ФЛАГ ОШИБКИ

      Использование:

         #include <stdio.h>
         void clearerr(FILE * fp);               /* ANSI */

      Описание:
         Сбрасывает  ошибку  и  флаг EOF,  связанные с пото-
         ком fp.

       Пример:
          #include <stdio.h>
          main()
          {
            FILE *stream;
            char * string = "пример данных";
            stream = fopen("file.dat", "r");
            fprintf(stream, "%s\n", string);
            if(ferror(stream))
              {
                fprintf(stderr,"Ошибка записи в file.dat\n");
                clearerr(stream);
              }
           printf"При записи в файл ошибок не было\n");
           fclose(stream);
         }

       Возвращаемое значение:

          Нет.

       Рекомендация:

          Смотрите также feof, ferror.


clock                          ОПРЕДЕЛИТЬ ПРОЦЕССОРНОЕ ВРЕМЯ

      Использование:

         #include <time.h>
         clock_t clock(void);                     /* ANSI */

      Описание:

         Определяет  процессорное время,  использованное вы-
         зывающим процессом в момент обращения к clock.  IBM
         PC имеет дискретность  1/18 сек.  Другие компьютеры
         под управлением  MS DOS имеют дискретность  в 1 сек,
         хотя возвращаемое в качестве результата время выра-
         жается в сотых долях секунды.

      Пример:

         #include <stdio.h>
         #include <time.h>
         main()
         {
           clock_t process;
           process = clock()/CLK_TCK;
           printf("Процессорное время в секундах =%d\n",
                   process);
         }

      Возвращаемое значение:

         Возвращает  время,  апроксимирующее  использованное
         вызывающей программой процессорное время. Деля воз-
         вращаемое clock() значение на величину,  определяе-
         мую макросом CLK_TCK, получите время в секундах.

      Рекомендация:

         Смотрите также asctime, ctime, difftime, localtime.


close                                           ЗАКРЫТЬ ФАЙЛ

      Использование:

         #include <io.h>
         int close(int fd);

      Описание:

         Закрывает файл,  ассоциированный с дескриптором fd.

      Пример:

         #include <io.h>
         #include <dos.h>
         #include <stdio.h>
         main()
         {
           int fd, result;
           fd = open("CON", O_RDONLY);
           if(fd<0)
             {
               fprintf(stderr, "Не могу открыть CON\n");
               abort();
             }
           result = close(fd);
           printf("Результат от close %d\n", result);
         }

      Возвращаемое значение:

         Возвращает  0  в  случае  успеха  и -1 с установкой
         errno в противном случае.

      Рекомендация:

         Смотрите также open, unlink.


cos, cosh                   КОСИНУС, КОСИНУС ГИПЕРБОЛИЧЕСКИЙ

      Использование:

         #include <math.h>
         double cos(double x);                    /* ANSI */
         double cosh(double x);                   /* ANSI */

      Описание:

         Возвращают значение косинуса (cos) или гиперболиче-
         ского косинуса (cosh) от x, где x - в радианах.

      Пример:

         #include <math.h>
         #include <stdio.h>
         main()
         {
           double value = 2.5556, result, hycos;
           result = cos(value);
           printf("The cosine of %f is %f\n", value, result);
           hycos = cosh(value);
           printf("The hyperbolic cosine of %f is %f\n",
                  value, hycos);
         }

      Возвращаемое значение:

         Возвращаются значения cos(x) или ch(x) соответстве-
         нно. В случае ошибки возвращается 0.


creat                                          СОЗДАТЬ  ФАЙЛ

      Использование:

         #include <io.h>
         #include <sys\stat.h>
         int creat(char * name, int pmode);

      Описание:

         Системный вызов  creat()  либо создает  новый файл,
         либо открывает и чистит существующий.  Pmode задает
         режимы чтения-записи файла в дальнейшем, после пер-
         вого закрытия.  Pmode  принимает  одно (или оба) из
         следующих значений, определенных  в stat.h :

      #define S_IREAD  0000400  /* read permission, owner */

      #define S_IWRITE 0000200 /* write permission, owner */

         Когда требуются обе константы, их следует соединить
         логической  операцией  (или)  OR.  Под  управлением
         MS DOS  нет  возможности  дать разрешение только на
         запись.  В настоящее время значение pmode игнориру-
         ется.

      Пример:

         #include <io.h>
         #include <sys\stat.h>
         main()
         {
           int fp;
           fp = creat("file.dat",S_READ|S_WRITE);
           IF(FP==-1)
              printf("Не могу создать (creat) file.dat\n");
         }

      Возвращаемое значение:

         Если возникает ошибка, возвращается -1 и устанавли-
         вается errno в одно из значений:

            ENOENT - Нет такого файла или каталога.

            EMFILE - Слишком много открытых файлов.

            EACCES - Разрешение не выдано.

         Аналогично используемым в  chdir(),  close() и т.д.
         Если файл создан, creat возвращает дескриптор управ-
         ления файлом в MS DOS.

      Рекомендация:

         Смотрите также dos_creat, close, fopen, open.


ctime                                ДАТЬ  КАЛЕНДАРНОЕ ВРЕМЯ

      Использование:

         #include <time.h>
         char *ctime(time_t *ntime);              /* ANSI */

      Описание:

         Преобразует  календарную  дату  и  время,  заданную
         ntime, ко времени в форме ASCII строки литер.

      Пример:

         #include <time.h>
         #include <stdio.h>
         time_t ntime;
         main()
         {
           time(&ntime);
           printf("Текущее время %s\n", ctime(&ntime));
         }

      Возвращаемое значение:

         Возвращает  указатель  на статическую  строку из 26
         ASCII литер в виде:

            DDD MMM dd hh:mm:ss YYYY\n\0

         где:

            DDD       -  день недели
            MMM       -  месяц
            dd        -  день месяца
            hh:mm:ss  -  часы:минуты:секунды
            YYY       -  год

         Строка перезаписывается при каждом вызове ctime().

      Рекомендация:

         Смотрите также asctime, clock, difftime, localtime,
         time.


difftime                         ОПРЕДЕЛИТЬ  ОТРЕЗОК ВРЕМЕНИ

      Использование:

         #include <time.h>
         double difftime(time_t time2, time_t time1);
                                                  /* ANSI */
      Описание:

         Вычитает time1 из time2.

      Пример:

         #include <stdio.h>
         #include <time.h>
         main()
         {
           register int delay;                /* Задержка */
           time_t start, finish;
           time(&start);
           for (delay = 0; delay<1000; delay++)
                printf("%d\n", delay);
           time(&finish);
           printf("Задержка длилась %f секунд",
                                   difftime(start, finish));
         }

      Возвращаемое значение:

         Возвращает разницу time1 и time2 в секундах.

      Рекомендация:

      Смотрите также  asctime, clock, ctime, localtime, time


Display Package                            Пакет отображения

      Использование:

         #include <disp.h>
         void disp_close(void);

         Выталкивает вывод и завершает  использование пакета
         отображения.

         void disp_box(int type, int attr, unsigned row,
              unsigned col, unsigned brow, unsigned rcol);

         Рисует  рамку с бордюром type и атрибутом attr. На-
         чиная с левого верхнего угла в  row,col  и кончая в
         нижнем правом угле в brow,rcol.

         Значения type определяют:

            0   -   двойную бордюрную линию

            1   -   одинарную бордюрную линию

            2   -   толстый бордюр.

         void disp_eeol(void);
         Чистит остаток  текущей строки,  включая литеру под
         курсором.

         void disp_eeop(void);
         Чистит экран, начиная  с текущей  позиции  курсора.

         void disp_endstand(void);
         Выключает инверсный режим отображения. Должна вызы-
         ваться после disp_startstand.

         void disp_flush(void);
         Выталкивает вывод на экран.  Бывает  необходима для
         подготовки экрана к ожидаемому вводу пользователя.

         int disp_getmode(void);
         Возвращает  текущий  режим  отображения   (Смотрите
         disp_setmode).

         void disp_move(int row, int col);
         Сдвигает курсор к позиции  row.col.  Позиция  0,0
         есть верхний левый угол дисплея.

         void disp_open(void);
         Инициализирует дисплейный пакет. В процессе обраще-
         ния определяются  тип  дисплея и адресация экранной
         памяти. Инициализируются все глобалы.

         unsigned disp_peekw(int row, int col);
         Считывает  атрибут  литеры в заданной  позиции дис-
         плея.

         unsigned disp_peekbox(unsigned * save, unsigned row,
                unsigned col, unsigned brow, unsigned rcol);
         Запоминает прямоугольную область экрана, определен-
         ную верхним левым углом  (row,col) и нижним правым
         (brow,rcol), в буфере save.

         void disp_pokebox(unsigned * save, unsigned row,
                unsigned col, unsigned brow, unsigned rcol);
         Восстанавливает прямоугольную область экрана, опре-
         деленную  верхним левым углом  (row, col)  и нижним
         правым (brow, rcol), из буфера save.

         void disp_pokew(int row, int col, int attr,charc);
         Записывает литеру с указанным  атрибутом в специфи-
         цированную позицию.

         void disp_printf(char *format, ...);
         Осуществляет  непосредственный  форматный  вывод на
         экран (Смотрите описание функции printf).

         void disp_putc(int c);
         Записывает  литеру c в текущую позицию экрана,  ис-
         пользуя атрибут литеры,  установленный  посредством
         disp_setattr().   Отрабатывает  табуляцию,  перевод
         строки, возврат каретки, backspace и т.д. корректно.

         void disp_reset43(void);
         Сбрасывает текстовый  режим  80х43 EGA  назад в ре-
         жим 80х25.

         void disp_scroll(int lines, unsigned ulrow,
              unsigned ulcol, unsigned lrrow, unsigned lrcol,
                                              unsigned attr);
         Прокручивает содержимое экрана вверх:

            lines - количество строк прокрутки
            ulrow - верхний ряд двигаемой области
            ulcol - верхний левый столбец
            lrrow - нижний ряд двигаемой области
            lrcol - нижний правый столбец
            attr  - видеоатрибут для остальных областей
                    (частей экрана).

         void disp_set43(void);
         Устанавливает текстовый режим отображения 80х43 EGA.
         Не должна  использоваться,  пока  дисплейный  пакет
         открыт.  Эта  функция требует наличия адаптеров EGA
         или VGA. Действительное  количество строк на экране
         записывает в disp_numrows.

         void disp_setattr(int attr);
         Устанавливает атрибут  литер,  записываемых посред-
         ством disp_putc()  и  disp_printf().  Ниже приведен
         список атрибутов, описанных в файле disp.h :

            DISP_REVERSEVIDEO         ИНВЕРСНЫЙ
            DISP_NORMAL               НОРМАЛЬНЫЙ
            DISP_UNDERLINE            ПОДЧЕРКИВАНИЕ
            DISP_NONDISPLAY           НЕ ВЫСВЕЧИВАЕМЫЙ

         Следующие атрибутные биты могут быть добавлены опе-
         рацией OR:

            DISP_INTENSITY            ИНТЕНСИВНЫЙ
            DISP_BLINK                МИГАНИЕ

         void disp_setcursortype(int startline*256+endline);
         Устанавливает размер курсора. По умолчанию, DOS ис-
         пользует:

                           начало      конец   использование
            Monochrome       11          12      11*256+12
            Color            6           7        6*256+7

         void disp_setmode(unsigned char mode);
         Устанавливает режим  отображения.  Если потребуется
         не текущий режим отображения,  вызов функции должен
         предшествовать обращению к disp_open(). Ниже приве-
         дены номера режимов:

            0 - 40х25     черно-белый алфавитно-цифровой EGA
                          адаптер
            1 - 40х25     цветной   алфавитно-цифровой   EGA
                          адаптер
            2 - 80х25     черно-белый алфавитно-цифровой EGA
                          адаптер
            3 - 80х25     цветной   алфавитно-цифровой   EGA
                          адаптер
            4 - 320х200   4-цветный  графический EGA адаптер

            5 - 320х200   черно-белая   графика  на  цветном
                          EGA адаптере
            6 - 640х200   черно-белая   графика  на  цветном
                          EGA адаптере
            7 - 80х25     черно-белый  алфавитно-цифровой на
                          монохромном EGA адаптере
            D - 320х200   16-цветная графика на EGA адаптере

            E - 640х200   16-цветная графика на EGA адаптере

            F - 640х350   4-цветная графика на монохромном
                          EGA адаптере
           10 - 640х350   16-цветная графика на EGA адаптере

         void disp_startstand(void);
         Устанавливает инверсный  режим отображения для всех
         последующих выводимых  литер.  Инверсный режим ото-
         бражения снимается обращением к disp_endstand().

         void disp_usebios(void);
         Устанавливает  режим  записи  литер  на экран через
         BIOS,  а не непосредственно в видео память дисплея.
         Это  улучшает  переносимость программы при снижении
         скорости работы.  Вызов должен следовать за обраще-
         нием к disp_open().

      Описание:

         Дисплейный пакет обеспечивает быстрый ввод/вывод на
         экран PC и надежную совместимость. Процедуры пакета
         пишут  непосредственно в видео память, выигрывая на
         скорости.  Эти процедуры  не пойдут на компьютерах,
         не являюшщихся совместимыми с  IBM PC  по принципам
         отображения или в части BIOS. Ниже приведены глоба-
         лы, которые инициализируются при вызове disp_open().
         Эти глобалы следует только читать:

            unsigned char disp_mono - 0 для цветного и 1 для
                                       монохромного адаптера
            unsigned char disp_snowycga - отличен  от  0 для
                                          "снежного" IBM CGA
            unsigned char disp_mode - текущий  режим отобра-
                            жения (Смотрите disp_setmode()).
            unsigned char disp_inited - отличен  от 0,  если
                           дисплейный пакет инициализирован.
            unsigned char disp_ega - отличен  от  0  для IBM
               EGA или VGA адаптеров.
            unsigned disp_base - адрес сегмента видео памяти
               (MDA = 0B000)(CGA = 0B800).
            int disp_numrows - количество отображаемых строк

            int disp_numcols - количество отображаемых столб-
                               цов
            int disp_cursorrow - номер строки, в которой пози-
                               ционирован курсор
            int disp_cursorcol - номер столбца,  задающего по-
                               зицию курсора.

      Возвращаемое значение:

         disp_getmode  возвращает текущий режим отображения.

      Рекомендация:

         Смотрите также printf, putc.

      Пример:

         #include <disp.h>
         #include <conio.h>
         char *string="Пример мигающей строки";
         int cursor=((6*256)+11);
         main()
         {
           char ch;
           disp_open();
           disp_startstand();
           disp_printf("Строка выведена после обращения к
                                       disp_startstand\n");
           disp_endstand();
           disp_setattr(DISP_BLINK | DISP_NORMAL);
           disp_printf("%s\n", string);
           disp setattr(DISP_INTENSITY | DISP_NORMAL);
           disp_printf("Установлен атрибут высокой яркости\n");
           disp setattr(DISP_NORMAL);
           disp_usebios();
           disp_printf("Строка высвечена при помощи BIOS\N");
           disp_printf("Меняем размер курсора");
           disp_setcursortype(cursor);
           disp_flush();
           ch = getch();
           disp_close();
         }


div                                                   ДЕЛИТЬ

      Использование:

         #include <stdlib.h>
         div_t div(int numerator, int denominator); /* ANSI */

      Описание:

      Делит делимое на делитель,  возвращая частное и остаток

      Пример:

         #include <stdlib.h>
         main()
         {
           div_t answ;
           int ina, inb;
           puts("Введите два целых:");
           scanf("%d %d", &ina, &inb);
           answ = div(ina, inb);
           printf("Частное=%d, и остаток=%d\n",
                          answ.quot, answ.rem);
         }

      Возвращаемое значение:

         Возвращает структуру типа div_t.

      Рекомендация:

         Смотрите также ldiv.


DOS Package                                Пакет функций DOS

      Использование:

         #include <dos.h>
         int dos_abs_disk_read(int drive, int num_sec,
                              int start_sec, char *buffer);
         int dos_abs_disk_write(int drive, int num_sec,
                              int start_sec, char *buffer);
         int dos_creat(char *name, unsigned attribute);
         int dos_get_cntl_break(void);
         long dos_getdiskfreespace(int drive);
         int dos_get_verify(void);
         void dos_set_verify(int on_off);
         void dos_set_cntl_break(int on_off);

      Описание:

         dos_abs_disk_read, dos_abs_disk_write
         Передают  управление  функциям  DOS  для выполнения
         чтения или записи диска соответственно. Номера уст-
         ройств (drive): 0 для устройства A, 1 - для B и т.д.
         до 25. Количество секторов для чтения и записи спе-
         цифицируется num_sec.  Start_sec  определяет первый
         сектор чтения или записи.  Buffer является источни-
         ком или приемником данных.

         dos_creat
         Создает файл в DOS окружении.  Байт атрибутов соот-
         ветствует   описанию   в  DOS  Technical  Reference
         Manual. Описание атрибутов содержится в dos.h файле:

            FA_RDONLY - 0x01 - только чтение
            FA_HIDDEN - 0x02 - скрытый файл
            FA_SYSTEM - 0x04 - системный файл
            FA_LABEL  - 0x08 - метка тома
            FA_DIREC  - 0x10 - каталог
            FA_ARCH   - 0x20 - архивный бит

         dos_get_verify
         Возвращает статус верификации DOS. Это отличное от
         нуля значение,  если VERIFY (проверка записи) вклю-
         чена,  и  0 в противном  случае  (Смотрите  команду
         VERIFY в DOS  Technical Reference Manual).

         dos_get_cntl_break
         Возвращает статус break  управления  DOS.  Это от-
         личное от нуля значение, если реакция на прерывание
         break включена и  0  в противном  случае  (Смотрите
         BREAK команду в DOS Reference Manual).

         dos_getdiskfreespace
         Возвращает  значение объема незанятого пространства
         на диске. Drive определяет устройство:  0 - умолча-
         ние (текущее устройство), 1 - A, 2 - B  и т.д.

         dos_set_verify
         Устанавливает  режим верификации записи (считывание
         после записи). Эта функция имеет тот же эффект, что
         и команды MS DOS VERIFY ON или VERIFY OFF.

         dos_set_cntl_break
         Включает или выключает режим реакции на break. Зна-
         чение аргумента ненулевое включает  режим  break, и  
	 0 - выключает. Эта функция имеет тот же эффект, как 
	 и команда BREAK для командного процессора DOS.

      Пример:

         #include <dos.h>
         #include <stdio.h>
         char buffer [512];
         main()
         {
           char *offset;
           long result;
           int drive = 0;
           result = dos_getdiskfreespace(drive);
           printf("Default drive=%ld bytes free\n", result);
           dos_abs_disk_read(0,1,0,buffer);
           offset = &buffer[3];
           printf("Boot record OEM=%s\n", offset);
         }

      Возвращаемое значение:

         dos_creat
         Возвращает DOS дескриптор файла , если файл создан,
         в противном случае  возвращает -1  и  устанавливает
         errno.

         dos_get_cntl_break, dos_get_verify
         Возвращают  отличное от нуля значение,  если статус
         включен, и 0 в противном случае.

         dos_getdiskfreespace
         Возврашщает объем доступного дискового пространства
         в байтах в формате long int.

         dos_set_verify, dos_set_cntl_break
         Не возвращают значение.

         dos_abs_disk_read, dos_abs_disk_write
         Возвращают 0 в случае  успеха.  Ненулевое  значение
         указывает  на  ошибку.  Младший  байт  содержит код
         ошибки  DOS.  Старший  байт  содержит  спецификацию
         ошибки BIOS(Смотрите DOS Technical Reference Manual)


ecvt     			ПРЕОБРАЗОВАТЬ ЧИСЛО В СТРОКУ

      Использование:

         #include <stdlib.h>
         char * ecvt(double val, int ndig, int *pdecpt,
               int *psign);

      Описание:

         Преобразует значение  удвоенной точности в строку и
         возвращает указатель на строку.  Число  создаваемых
         цифр задает ndig.  Число соответственно округляется.
         Позиция десятичной точки относительно первой (левой)
         цифры строки запоминается в *pdecpt.  Если  *pdecpt
         отрицательно, точка находится на соответствующее ко-
         личество позиций левее начала строки.  В *psign за-
         поминается 0, если val>0,  и отличное от 0 значение
         в противном случае. Строка записывается в статичес-
         ки выделенную память, которая используется совмест-
         но с ecvt() и обновляется при каждом обращении.

      Пример:

         #include <stdio.h>
         #include <stdlib.h>
         char *buffer;
         int dec, sign;
         main()
         {
           buffer = ecvt(98.69138432, 5, &dec, &sign);
           printf("buffer = \"%s\", decimal = %d,
                   sign = %d\n", buffer, dec, sign);
         }

      Возвращаемое значение:

         Возвращает указатель на строку.

      Рекомендация:

         Смотрите также fcvt, sprintf.



execl - execvp                             ЗАПУСТИТЬ ПРОЦЕСС

   Использование:

      #include <process.h>
      #include <errno.h>    /* Только для контроля ошибок */
      int execl(char * name, char *arg0, *arg1,..., *argn,
                                                      NULL);
      int execv(char * name, char *argv[]);
      int execlp(char * name, char *arg0, *arg1,..., *argn,
                                                      NULL);
      int execvp(char * name, char *argv[]);

   Описание:

      exec - функции  создают  и выполняют новый порожденный
      процесс.  Успешное  выполнение  exec вызывает замену в
      памяти родительского процесса на порожденный  процесс,
      для которого должно быть достаточно памяти. Exec пере-
      записывает новую программу на место текущей и начинает
      исполнение. Name специфицирует эту программу. Если эта
      спецификация не содержит описания пути  доступа к фай-
      лу программы и файл не содержится  в текущем каталоге,
      то в случае execvp и execlp для поиска файла использу-
      ется переменная окружения PATH.  Параметры обращения к
      подпроцессу образуются из строк литер,  заданных в об-
      ращении к exec. Они образуют список аргументов,  сово-
      купная длина которых,  исключая arg0, не должна превы-
      шать 128 символов. Аргумент arg0 игнорируется. Он вклю-
      чен по соображениям совместимости.  Аргумент argv, ис-
      пользуемый в execv и execvp,  является массивом указа-
      телей на строки.  Последний указатель  в  argv  должен
      быть NULL.

   Возвращаемое значение:

      В случае успешного обращения exec не возвращает управ-
      ления. В случае ошибки возвращает значение -1. Внешняя
      переменная errno будет установлена в значение, иденти-
      фицирующее ошибку.  Эти значения декларированы в файле
      errno.h:

         E2BIG  - Список аргументов превышает 128 байт.

	 ENOENT - Не найден файл.

   Рекомендация:

      Смотрите также abort, exit, spawn, system.

   Пример:

      #include <process.h>
      #include <errno.h>
      #include <stdio.h>
      main(int argc, char * argv[])
      {
        char *args[4];
        int result;
        arg[0] = "arg0";
        arg[1] = "arg1";
        arg[2] = "arg2";
        arg[3] = "arg3";
        switch (argv[1][0])
        {
          case `1':
             execl("myprog.exe", "arg0", "arg1", "arg2",
                                               "arg3",NULL);
             break;
          case `2':
             execlp("myprog.exe", "arg0", "arg1", "arg2",
                                              "arg3", NULL);
             break;
          case `3':
             execv("myprog.exe", "args");
             break;
          case `4':
             execvp("myprog.exe", "args");
             break;
          default:
             printf("Введите число между 1 и 4 в командной
                                                 строке\n");
             exit(1);
        }
          printf("Процесс myprog.exe не исполнен.\n");
      }



exit, _exit                   ЗАВЕРШИТЬ ВЫПОЛНЕНИЕ ПРОГРАММЫ

   Использование:

      #include <stdlib.h>
      void exit(int exitstatus);
      void _exit(int exitstatus);                 /* ANSI */

   Описание:

      exit вызывает все статические деструкторы (для C++ про-
      грамм),  выталкивает буфера вывода, закрывает выходные
      файлы и возвращает управление MS DOS со статусом выхо-
      да exitstatus.
      _exit не вызывает статические деструкторы и не освобож-
      дает  буфера,  а  немедленно  возвращает  управление в
      MS DOS.  exit предпочтительно использовать в C++ прог-
      раммах. exitstatus обычно 0 для указания на нормальное
      завершение программы.  Значение, отличное от нуля, ин-
      дицирует ошибку. Только младший байт exitstatus посту-
      пает к родительскому  процессу.  Статус  выхода  может
      быть использован посредством имени ERRORLEVEL в команд-
      ных (batch) файлах.

   Возвращаемое значение:

      Не возвращает значения.


   Рекомендация:

      Смотрите abort.

   Пример:

      #include <stdlib.h>
      #include <stdio.h>
      main(int argc, char * argv[])
      {
        FILE *fp;
        if(argc>1)
           {
             fp = fopen(argv[1],"r");
             if(fp == NULL)
               {
                 fprintf(stderr, "Не могу открыть файл
                                        \"%s\"\n", argv[1]);
                 exit(1);
               }
           }
        else
           {
              fprintf(stderr, "Файл не задан \n");
              exit(1);
           }
      }


exp                                               ЭКСПОНЕНТА

   Использование

      #include <math.h>
      double exp(double x);                       /* ANSI */

   Описание:

      Вычисляет экспоненту аргумента x.

   Пример:

      #include <math.h>
      main()
      {
        double dnum, xpnt;
        dnum:=3.1415926;
        xpnt = exp(dnum);
        printf("The exp(%f) = %f\n", dnum, xpnt);
      }


   Возвращаемое значение:

      Возвращает значение экспоненты аргумента x. В случае
      переполнения (оverflow) устанавливает errno в ERANGE.
      В случае потери значимости (underflow) возвращает 0
      и не устанавливает errno.


   Рекомендация:

      Смотрите также log, pow, sqrt.



fabs                       АБСОЛЮТНОЕ ЗНАЧЕНИЕ ВЕЩЕСТВЕННОГО

   Использование:

      #include <math.h>
      double fabs(double x);                     /* ANSI */

   Описание:

      Возвращает абсолютное  значение  числа x,  заданного с
      удвоенной точностью.

   Пример:

      #include <math.h>
      #include <stdio.h>
      main()
      {
        double numbr, absval;
        numbr = -1.0;
        absval = fabs(numbr);
        printf("fabs от (%f) равно %f\n", numbr, absval);
      }

   Возвращаемое значение:

      Возвращает абсолютное значение аргумента.

   Рекомендация:

      Смотрите также abs, labs.



farcalloc - farrealloc                РАБОТА С ДАЛЬНЕЙ КУЧЕЙ

   Использование:

      #include <dos.h>
      void far *farmalloc(unsigned long size);
      void far *farcalloc(unsigned long number, unsigned
                                                 long size);
      long farcoreleft(void);
      void farfree(void far *memblock);
      void far *farrealloc(void far *memblock, unsigned long
                                                   newsize);

   Описание:

      farmalloc   - Отводит память размером  size  в дальней
                    куче.
      farcalloc   - Отводит память под массив длиной  number
                    элементов, каждый из которых длиной size
                    байтов, в дальней куче.
      farcoreleft - Возвращает величину памяти в дальней ку-
                    че.
      farfree     - Освобождает блок памяти memblock,  выде-
                    ленный прежде в дальней куче.
      farrealloc  - Переопределяет размер ранее загруженного
                    блока памяти memblock значением newsize.

         Заметим,  что вся доступная память (RAM) может быть
         задействована; может быть выделен блок памяти более
         64 Кб и для  доступа к блокам  памяти  используются
         дальние указатели.

   Эти функции непосредственно обращаются к MS DOS.  Они бо-
лее медленны, чем, например, malloc. Они могут также предотв-
ратить переполнение кучи в S, M, T моделях памяти (и полезны
прежде всего для ее расширения). Указатели на загруженную па-
мять должны быть освобождены прежде, чем завершится програм-
ма,  в противном случае память останется занятой до перезаг-
рузки компьютера.

   Пример:

      #include <stdio.h>
      #include <dos.h>
      main()
      {
        char far *memblock;
        long allocate = 65000;
        printf("%lu байтов памяти свободны\n",farcoreleft());
        memblock = farmalloc(allocate);
        if (memblock == NULL)
        {
          printf("не смогли разместить блок памяти\n");
          exit(1);
        }
        printf("%lu байтов отведено", allocate);
        printf("%lu байтов памяти свободно\n",farcoreleft());
        allocate/=2;
        memblock = farrealloc(memblock, allocate);
        printf("память переразмещается до %lu байтов",
                                                  allocate);
        printf("%lu байтов памяти свободно\n",farcoreleft());
        farfree(memblock);
        printf("блок памяти освобожден");
        printf("%lu байтов памяти свободно\n",farcoreleft());
      }

   Возвращаемое значение:

      farmalloc   - возвращает дальний указатель на размещен-
                    ный блок памяти или NULL, если нет доста-
                    точного количества памяти.

      farcalloc   - возвращает дальний указатель на загружен-
                    ный блок памяти или NULL, если нет доста-
                    точного количества памяти.

      farcoreleft - возвращает величину памяти в дальней ку-
                    че.

      farfree     - ничего не возвращает.

      farrealloc  - возвращает адрес перезагруженного блока,
                    который может быть отличен от исходного.

   Рекомендация:

      Смотрите также calloc, free, malloc, realloc.


_farptr_norm                 НОРМАЛИЗОВАТЬ ДАЛЬНИЙ УКАЗАТЕЛЬ
_farptr_fromlong               ДАЛЬНИЙ УКАЗАТЕЛЬ ИЗ ДЛИННОГО
_farptr_tolong                   ДАЛЬНИЙ УКАЗАТЕЛЬ В ДЛИННОЕ

   Использование:

      #include <dos.h>
      void far *_farptr_norm(void far *ptr);
      void far *_farptr_fromlong(long value);
      long _farptr_tolong(void far *ptr);

   Описание:

      _farptr_norm нормализует дальний указатель таким обра-
      зом, что смещение становится менее 16. _farptr_fromlong
      преобразует long к нормализованному дальнему указателю.
      Параметр задает  линейный  адрес от 0.  _farptr_tolong
      преобразует дальний  указатель к линейному адресу типа
      long, представленному данным указателем.

   Возвращаемое значение:

      _farptr_norm возвращает нормализованный дальний указа-
      тель. _farptr_fromlong возвращает нормализованный даль-
      ний указатель. _farptr_tolong возвращает значение типа
      long.

   Пример:

      #include <stdio.h>
      #include <dos.h>
      main()
      {
        void far * pin, far * pout;
        long value;
        pin = MK_FP(0x1100, 0x2678);
        pout = _farptr_norm(pin);
        printf("%lp после нормализации должен стать"
                            "1367:0008, а фактически=%lp\n",
                                                 pin, pout);
        value = 0xB7543;
        pout = _farptr_fromlong(value);
        printf("Преобразование  0x%lX  в дальний указатель"
               "должно быть B754:0003, \n фактически=%lp\n",
                                               value, pout);
        pin = MK_FP(0xbB754, 0x0013>);
        value = _farptr_tolong(pin);
        printf("Преобразование %lp в long должно быть"
               "0xB7553, \n it actually is 0x%lX\n", pin,
                                                     value);
      }


fclose                                          ЗАКРЫТЬ ФАЙЛ

   Использование:

      #include <stdio.h>
      int fclose(FILE *fp);                       /* ANSI */

   Описание:

      Закрывает  файл,  ассоциированный с fp.  Буфер вывода,
      связанный с fp, перед закрытием выталкивается.

   Пример:

      #include <stdio.h>
      main()
      {
        FILE *fp;
        fp = fopen("file.dat", "r");
        if (fp==NULL)
           printf("Файл данных не открыт\n");
        else
           {
             fclose(fp);
             printf("Файл file.dat закрыт при помощи
                                                fclose\n");
           }
      }

   Возвращаемое значение:

      Возвращает 0, если поток успешно  закрыт,  и -1 в про-
      тивном случае.

   Рекомендация:

      Смотрите также close, fopen, freopen.


fcvt    ПРЕОБРАЗОВАТЬ DOUBLE В СТРОКУ С ФИКСИРОВАННОЙ ТОЧКОЙ

   Использование:

      #include <process.h>
      char *fcvt(double val, int nfrac, int *pdecpt,
                 int *psign);

   Описание:

      То же,  что и ecvt(),  за исключением того,  что nfrac
      специфицирует здесь  количество  цифр,  которое должно
      быть после десятичной точки.

   Пример:

      #include <stdio.h>
      #include <process.h>
      main()
      {
        char *buffer;
        int dec, sign;
        buffer = fcvt(98.69138432, 5, &dec, &sign);
        printf("buffer=\"%s\", decimal = %d, sign = %d\n",
                                       buffer, dec, sign);
      }

   Возвращаемое значение:

      Возвращает указатель на статическую строку цифр, пере-
      записываемую при каждом обращении к ecvt или fcvt.

   Рекомендация:

      Смотрите также ecvt, sprintf.


feof                           ПРОВЕРКА ПРИЗНАКА КОНЦА ФАЙЛА

   Использование:

      #include <stdio.h>
      int feof (FILE *fp);                        /* ANSI */

   Описание:

      Определяет, находится ли поток fp в конце файла.

   Пример:

      #include <stdio.h>
      #define BUFSIZE 128
      char buffer [BUFSIZE];
      main()
      {
        FILE *fp;
        fp = fopen("file.dat", "r");
           {
             while(!feof(fp))
             fgets(buffer, BUFSIZE, fp);
           }
        printf("Файл прочитан, встретился EOF \n", buffer);
      }

   Возвращаемое значение:

      Ненулевое значение, если текущая позиция является кон-
      цом(т.е. установлен флаг `eof'). После установки флага
      не разрешены операции чтения. Флаг опускается при опе-
      рациях rewind, fseek, и при закрытии потока. Возвраща-
      ет 0, если флаг не установлен.

   Рекомендация:

      Смотрите также clearerr, ferror.



ferror                      ПРОВЕРКА ПРИЗНАКА ОШИБКИ В ФАЙЛЕ

   Использование:

      #include <stdio.h>
      int ferror (FILE * fp);                     /* ANSI */

   Описание:

      Контролирует флаг `error' в потоке fp. Этот флаг опус-
      кается по rewind, clearerr, fseek или при закрытии по-
      тока.

   Пример:

      #include <stdio.h>
      main()
      {
        int c;
        if ((c=fgetc(stdin))==EOF)
           if (ferror(stdin))
              {
                fprintf(stderr, "Ошибка чтения\n");
                clearerr(stdin);
              }
        printf("Без ошибок\n");
      }


   Возвращаемое значение:

      Ненулевое значение,  если  установлен флаг ошибки, 0 в
      противном случае.

   Рекомендация:

      Смотрите также clearerr, feof.



fflush                                ВЫТОЛКНУТЬ БУФЕР ФАЙЛА

   Использование:

      #include <stdio.h>
      int fflush(FILE *fp);                       /* ANSI */

   Описание:

      Выталкивает буфер, связанный с потоком fp. Если файл
      открыт по записи,  буфер сбрасывается на файл.  Если
      файл открыт по чтению, буфер чистится.

   Пример:

      #include <stdio.h>
      FILE *fp;
      main()
      {
        if (!(fp = fopen("file.dat", "w")))
            return;
        fflush(fp);  /* выталкиваем  буфер  на  диск  для */
                     /* защиты  данных  перед выполнением */
                     /* операции, могущей сломать систему */
      }

   Возвращаемое значение:

      Возвращает 0, если буфер вытолкнут успешно,  в против-
      ном случае возвращает EOF.

   Рекомендация:

      Смотрите также fclose, flushall.



fgetc                                   ВЗЯТЬ БАЙТ ИЗ ФАЙЛА

   Использование:

      #include <stdio.h>
      int fgetc(FILE *fp);                        /* ANSI */


   Описание:

      Читает  и  возвращает следующий  байт  из  потока  fp.


   Пример:

      #include <stdio.h>
      main()
      {
        int ch;
        fputs("Вводите данные, в конце - ctrl-Z:  ", stdout);
        while((ch = fgetc(stdin))!=EOF)
           fputc(ch, stdout);
      }

   Возвращаемое значение:

      Возвращает байт при  успешном  чтении  или  EOF,  если
      встретится конец файла или ошибка чтения.

   Рекомендация:

      Смотрите также  fputc, putchar, getc, getchar, getche,
      getch.


fgets                                  ВЗЯТЬ СТРОКУ ИЗ ФАЙЛА

   Использование:

      #include <stdio.h>
      char *fgets(char *str, int n, FILE *fp);    /* ANSI */

   Описание:

      Считывает  литеры из потока fp в строку  по  указателю
      str.  Чтение заканчивается,  когда  встречается литера
      `\n' (новая строка), конец файла, возникает ошибка чте-
      ния или число прочитанных  литер  достигает n-1. Строка
      завершается 0.  Литера '\n' (новая строка) включается в
      строку (перед 0).


   Пример:

      #include <stdio.h>
      main()
      {
        char buffer[225];
        int buflen;
        char *result;
        buflen=255;
        fputs("Введите строку данных\n", stdout);
        result=fgets(buffer, buflen, stdin);
        if (!result)
            printf("\n конец файла (EOF) или ошибка
                                               (ERROR)\n");
        else fputs(buffer, stdout);
      }

   Возвращаемое значение:

      Возвращает строку  str  в случае успеха.  Если не было
      прочитано  ни  одной  литеры и произошла ошибка чтения
      или встречен EOF, возвращает NULL,  а строка str оста-
      ется без изменения.  Если  возникла ошибка при чтении,
      возвращает NULL, а в строке возможен мусор.

   Рекомендация:

      Смотрите также fputs, gets, puts.



fileno                                 ДАТЬ ДЕСКРИПТОР ФАЙЛА

   Использование:

      #include <stdio.h>
      int fileno(FILE *fp);

   Описание:

      Возвращает дескриптор файла,  ассоциированного с пото-
      ком fp (`file handle'в MS DOS).

   Пример:

      #include <stdio.h>
      main()
      {
        int fd,
        fd = fileno(stderr);
        printf("Дескриптор файла stderr равен %d\n", fd);
        fd = fileno(stdaux);
        printf("Дескриптор файла stdaux равен %d\n", fd);
        fd = fileno(stdprn);
        printf("Дескриптор файла stdprn равен %d\n", fd);
      }

   Возвращаемое значение:

      Возвращает дескриптор файла. Об ошибках не сообщается.

   Рекомендация:

      Смотрите также fopen, freopen.


filesize                                  ДАТЬ РАЗМЕР ФАЙЛА

   Использование:

      #include <io.h>
      long filesize(char *filename);

   Описание:

      Определяет  размер  файла  в байтах.  Имя файла должно
      быть именем  существующего  файла,  закрытого в данный
      момент.

   Пример:

      #include <io.h>
      main()
      {
        long size;
        size = filesize("file.dat);
        printf("Размер файла file.dat равен %d\n", size);
      }

   Возвращаемое значение:

      Возвращает длину  файла  в байтах в случае  успеха,  в
      противном случае возвращает -1L и устанавливает errno.

   Рекомендация:

      Смотрите также stat, fstat.


findfirst, findnext                  ПОИСК ФАЙЛОВ ПО ШАБЛОНУ

   Использование:

      #include <dos.h>
      struct FIND *findfirst(char*partname, int attribute);
      struct FIND *findnext(void);

   Описание:

      Системные вызовы findfirst и findnext используются для
      поиска файлов, соответствующих шаблону,  который может
      охватывать целое множество файлов  посредством исполь-
      зования символов  `*' или `?'  в  имени  файла или его
      расширении  (но не в описании  пути  доступа к файлу).
      Аргумент `attribute' является атрибутом искомого файла.
      В обращении к findfirst может быть задано более одного
      атрибутного бита.  Соответствующие описания атрибутных
      битов находятся в dos.h файле:

            АТРИБУТ             ТИП ФАЙЛА
           FA_RDONLY               0x01
           FA_HIDDEN               0x02
           FA_SYSTEM               0x04
           FA_LABEL                0x08
           FA_DIREC                0x10
           FA_ARCH                 0x20

      В случае нулевого  значения  `attribute'  отыскиваются
      все обычные файлы.  Указатель на возвращаемую структу-
      ру является статическим,  так что, если эта информация
      нужна,  она должна быть  скопирована  в другой  буфер.
      Обращение к findnext дает следующий  файл,  подходящий
      по шаблону,  заданному  в  предшествующем  обращении к
      findfirst. Поэтому вызовы findnext должны следовать за
      вызовом findfirst.

   Пример:

      #include <stdio.h>
      #include <dos.h>
      main()
      {
        struct FIND *p;
        printf("Вывод каталога *.*\n");
        p = findfirst("*.*", 0);
        while (p)
           {
             printf("%s\n", p->name);
             p = findnext();
           }
      }


   Возвращаемое значение:

      В случае успеха  возвращает  указатель  на статическую
      структуру FIND,  определенную в dos.h файле,  или NULL
      для индикации конца поиска или ошибки.



floor                                            ЦЕЛАЯ ЧАСТЬ

   Использование:

      #include <math.h>
      double floor(double x);                     /* ANSI */

   Описание:

      Возвращает наибольшее целое  (в виде числа с удвоенной
      точностью), не превышающее x.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double d;
        d=floor(4.8);
        printf("floor от 4.8 равен %f\n", d);
        d=floor(-4.8);
        printf("floor от -4.8 равен %f\n", d);
      }

   Возвращаемое значение:

      Возвращает результат типа double.

   Рекомендация:

      Смотрите также ceil, fmod.


flushall              ВЫТОЛКНУТЬ БУФЕРА ВСЕХ ОТКРЫТЫХ ФАЙЛОВ

   Использование:

      #include <stdio.h>
      int flushall(void);


   Описание:

      Функция flushall выталкивает  буфера ввода/вывода всех
      открытых потоков. Все потоки после работы flushall oc-
      таются открытыми. Любая операция чтения читает в буфе-
      ра новые данные.


   Пример:

      #include <stdio.h>
      main ()
      { int totalflushed;
            totalflushed = flushall();
      }

   Возвращаемое значение:

      Возвращает число открытых потоков.

   Рекомендация:

      Смотрите также fflush


fmod                          ОСТАТОК ОТ ДЕЛЕНИЯ  ДВУХ ЧИСЕЛ

   Использование:

      #include <math.h>
      double f mod (double x, double y);

   Описание:

      fmod выдает в плавающем формате остаток от деления од-
      ного числа на другое.  Она возвращает x, если он ноль,
      либо число F с тем же знаком, что у x, - такое, что
      x = L*y + F для некоторого целого L  и  |F| < |y|.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main ()
      {
        double x, y, d;
        x = 5.0; y = 3.0;
        d = fmod (x,y);
        printf("fmod(%.2f, %.2f) = %f\n,x,y,d);
      }

   Возвращаемое значение:

      fmode возвращает остаток в формате с плавающей точкой.

   Рекомендация:

      Смотрите также ceil, floor, modf

fopen                                           ОТКРЫТЬ ФАЙЛ

   Использование:

      #include <stdio.h>
      FILE *fopen(char *name, char *mode);        /* ANSI */

   Описание:

      Открывает файл, заданный именем name. Mode есть строка
      символов, указывающая режим доступа к файлу. Возможные
      значения mode:

      `r'     - для чтения
      `w'     - для записи (если файл существует, он обреза-
                ется по началу)
      `a'     - для добавления  (если  файл  существует,  то
                открывается для записи в конец файла,  иначе
                он создается)
      `r+'    - для чтения и записи
      `w+'    - для чтения и записи  (если файл  существует,
                он обрезается, иначе он создается)
      `a+'    - для чтения и записи  (если файл  существует,
                производится позиционирование в конец файла,
                иначе он создается)

      Дополнительно в строку mode может быть добавлен символ
      `b' для открытия файла в двоичном режиме (умолчание за-
      дает текстовый режим). Если файл открыт и для чтения и
      для записи,  только чтение  или только запись может вы-
      полняться.  Чтобы переключиться от чтения к записи или
      наоборот, необходимо вызвать  fseek()  применительно к
      данному потоку,  если только при чтении (вводе) не был
      встречен признак EOF (Еnd Of File) конца файла.

   Пример:

      #include <stdio.h>
      main()
      {
        FILE *fp;
        fp = fopen("file.dat", "r");
        printf("Открыли текстовый файл\n");
        if (fp) fclose(fp);
        fp = fopen("CON",  "wb");
        printf("Звуковой сигнал\n");
        fputc(0x07, fp);
        if (fp) fclose(fp);
        fp = fopen("CON",  "rb");
        printf("Введите строку\n");
        if (fp && fgetc(fp)==3);
        printf("\n Введено Ctrl-C\n");
        if (fp) fclose(fp);
        fp = fopen("PRN", "w");
        printf("Пишем на принтер\n");
        if (fp) fclose(fp);
        fp = fopen("file.dat", "a+");
        printf("Обновляем файл в коде ASCII\n");
        if (fp) fclose(fp);
      }

   Возвращаемое значение:

      Возвращает  указатель  на  FILE  для  открытого файла.
      Значение NULL указывает на наличие ошибки.

   Рекомендация:

      Смотрите также fclose, freopen, open


FP_OFF, FP_SEG                             СЕГМЕНТ, СМЕЩЕНИЕ

   Использование:

      #include <dos.h>
      unsigned FP_OFF(int far *long_pointer);
      unsigned FP_SEG(void far *long_pointer);

   Описание:

      FP_OFF  и  FP_SEG используются для извлечения из даль-
      него указателя сегмента и смещения. Эти функции реали-
      зованы как макросы.

   Пример:

      #include <dos.h>
      #include <stdio.h>
      main()
      {
        char far *p;
        unsigned int segment, offset;
        p = MK_FP(0xb000, 0);
        segment = FP_SEG(p);
        offset = FP_OFF(p);
        printf("Сегмент для моновидео:
           сегмент:смещение = %04x:%04\n", segment, offset);
      }

   Возвращаемое значение:

      FP_SEG возвращает 16-битовое значение, являющееся сег-
      ментной частью дальнего указателя.
      FP_OFF   возвращает  16-битовое  значение,  являющееся
      смещением в границах сегмента дальнего указателя.

   Рекомендация:  Смотрите также  MK_FP.


fprintf                               ФОРМАТНЫЙ ВЫВОД В ФАЙЛ

   Использование:

      #include <dos.h>
      int fprintf(FILE *stream, const char * format,...);
                                                  /* ANSI */

   Описание:

      Осуществляет форматированный вывод в специфицированный
      поток.  Описание format совпадает с аналогичным описа-
      нием для printf.

   Пример:

      #include <stdio.h>
      main()
      {
        fprintf(stdout, "Это пример\n");
      }

   Возвращаемое значение:

      Возвращает количество записанных литер либо отрицате-
      льное значение в случае ошибки.

   Рекомендация:

      Смотрите также printf, sprintf, vfprintf.


fputc                                    ЗАПИСЬ БАЙТА В ФАЙЛ

   Использование:

      #include <stdio.h>
      int fputc (int c, FILE *fp);                /* ANSI */

   Описание:

      Записывает байт `c' в поток fp.

   Пример:

      #include <stdio.h>
      FILE * fp;
      main()
      {
        char * line = "Это пример";
        fp = stdout;
        while (*line)
        fputc (*line++, fp);
      }

   Возвращаемое значение:

      Возвращает байт, записанный в поток.  В случае ошибки
      возвращает EOF.

   Рекомендация:

      Смотрите также fgetc, getc, getchar.


fputs                                   ЗАПИСЬ СТРОКИ В ФАЙЛ

   Использование:

      #include <stdio.h>
      int fputs(char *s, FILE *fp);               /* ANSI */

   Описание:

      Записывает строку 's', исключая завершающую литеру О,
      в поток fp

   Пример:

      #include <stdio.h>
      main()
      {
        if (fputs("Hello World\n", stdout)==-1)
        fprintf(stderr, "Ошибка вывода\n");
      }

   Возвращаемое значение:

      Возвращает 0 в случае успеха и не 0 при ошибке записи.

   Рекомендация:

      Смотрите также fgets, gets, puts.


fread                                        ЧИТАТЬ ИЗ ФАЙЛА

   Использование:

      #include <stdio.h>
      int fread(void * p, unsigned sizelem, unsigned n,
                                       FILE *fp); /* ANSI */

   Описание:

      Читает n элементов из потока fp в массив по указателю
      p; sizelem - размер элемента массива в байтах.

   Пример:


      #include <stdlib.h>
      main()
      {
        char *dest;
        int size=1;
        int number=256, numread;
        FILE *fp;
        if ((fp=fopen("file.dat", "r"))==NULL)
           return;
        dest=calloc(256,1);
        numread=fread(dest, size, number, fp);
        printf("Всего прочитано %d\n", numread);
        fprintf(stdout, "Прочитанные данные\n, %s", dest);
        free(dest);
      }

   Возвращаемое значение:

      Возвращает количество полностью прочитанных элементов.
      В случае ошибки или встречи  конца файла возвращаемое
      значение будет меньше n.

   Рекомендация:

      Смотрите также fwrite, read



free                                       ОСВОБОДИТЬ ПАМЯТЬ

   Использование:

      #include <stdlib.h>
      int free(void *p);                          /* ANSI */

   Описание:

      Освобождает память по указателю p.  Эта память  должна
      быть выделена ранее с использованием  функций  calloc,
      malloc или realloc.  Если p = NULL, free бездействует.
      Если был использован флаг компилятора строгой ANSI со-
      вместимости, то free возвращает void (т. е. не возвра-
      щает значения).

   Предостережение: не освобождайте данные более одного раза,
                    не работайте с освобожденными данными.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        char * p:
        if ((p = malloc(1000))==NULL)
             printf("Не могу отвести память\n");
              if (free(p) == -1)
                abort();   /* Что-то ужасно плохо */
      }

   Возвращаемое значение:

      Возвращает 0 в случае  успеха или  -1,  если  испорчен
      механизм управления памятью  или  p  ошибочно.  Значе-
      ние -1 указывает на наличие  серьезной  ошибки в прог-
      рамме. free игнорирует несуразные указатели.

   Рекомендация:

      Смотрите также calloc, malloc, realloc.


freopen                                ОТКРЫТЬ ФАЙЛ ПОВТОРНО

   Использование:

   #include <stdio.h>
   FILE *freopen(char *name, char *mode, FILE *fp); /* ANSI */

   Описание:

      Закрывает файл fp. Ошибки при закрытии файла игнориру-
      ются. Открывает новый файл и связывает с ним поток fp.
      Name и mode имеют тот же смысл, что определен в fopen.

   Пример:

      #include <stdio.h>
      main()
      {
        fp = freopen("file.dat", "w+", stdout);
        if (fp == NULL)
            fprintf(stderr, "Ошибки при freopen\n");
        else
            fprintf(fp, "Эти данные пойдут в file.dat\n");
      }

   Возвращаемое значение:

      В случае успеха возвращает fp, иначе NULL.

   Рекомендация:

      Смотрите также fclose, fopen, open.


frexp                         ЭКСПОНЕНЦИАЛЬНОЕ ПРЕДСТАВЛЕНИЕ

   Использоваение:

      #include <math.h>
      double frexp(double value, int *eptr);       /* ANSI */

   Описание:

      Представляет значение двойной  точности  value  в виде
      мантиссы x  и  показателя  e,  так  что  value==x*2**e,
      x>.5  и  x<=1.0.  e запоминается по  eptr, а значение x
      возвращается как результат.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double d1,d2;
        int i;
        d2=15.3;
        d1=frexp(d2,&i);
        printf("d1=%f i=%d\n", d1, i);
      }

   Возвращаемое значение:

      Возвращает мантиссу экспоненциального представления (x).

   Рекомендация:

      Смотрите также ldexp, modt.


fscanf                               ФОРМАТНЫЙ ВВОД ИЗ ФАЙЛА

   Использование:

      #include <stdio.h>
      int fscanf(FILE *fp, char *format,...)      /* ANSI */

   Описание:

      Читает литеры из входного потока fp.  Считанные литеры
      преобразуются в соответствии со строкой формата.  Пре-
      образованные литеры запоминаются по указанным аргумен-
      там-указателям. Отметим, что аргументы должны быть ука-
      зателями, по которым fscanf запишет введенные значения

   Пример:

      #include <stdio.h>
      char fst[10], *lst="    ";
      int ttl;
      main()
      {
        int rt;
        rt = fscanf(stdin, "%s %s %d",fst,lst,&ttl);
        return rt=3;
      }

    Возвращаемое значение:

       Возвращает количество успешно проведенных преобразо-
       ваний.  Процесс заканчивается при встрече первой не-
       подходящей литеры или признака конца файла (EOF).
       Ноль на выходе означает, что не обработано ни одного
       поля.

    Рекомендация:  Смотрите также scanf.


fseek                                   ПОЗИЦИОНИРОВАТЬ ФАЙЛ

   Использование:

      #include <stdio.h>
      #include <io.h>
      int fseek(FILE *fp,long offset,int origin); /* ANSI */

   Описание:

      Устанавливает позицию в файле, связаннном с потоком fp.
      Смещение в байтах является величиной со знаком и берет-
      ся  относительно origin.  Значения origin определены в
      io.h файле:

         SEEK_SET     -  начало файла
         SEEK_CUR     -  текущая позиция
         SEEK_END     -  конец файла

      Если файл  открыт в текстовом  режиме,  смещение может
      быть только значением,  возвращенным  ftell,  а origin
      должно быть 0,  или offset должно быть 0.  Если непос-
      редственно перед вызовом  fseek  работала  ungetc,  ее
      результаты теряются.  Если файл  был  открыт  в режиме
      чтения/записи,  следом за fseek можно выполнить чтение
      или запись.

   Пример:

      #include <stdio.h>
      #include <io.h>
      main()
      {
        FILE *fp;
        fp = fopen("file.dat", "r+");
        fseek(fp, 0L, SEEK_END);   /* Перейти в конец файла */
        fseek(fp, 0L, SEEK_SET);   /* Перейти в начало файла */
        fseek(fp, 20L, SEEK_SET);  /* Перейти на смещение 200 */
      }

   Возвращаемое значение:

      Возвращает  0  в случае  успеха и ненулевое значение в
      случае ошибки.

   Рекомендация:

      Смотрите также ftell, lseek.


fstat                                     ВЗЯТЬ СТАТУС ФАЙЛА

   Использование:

      #include <sys\stat.h>
      int fstat(int fd, struct stat *buf);

   Описание:

      Извлекает информацию относительно открытого файла fd и
      запоминает ее в структуре stat по указателю buf. Струк-
      тура содержит следующие поля:

         st_dev      - номер дискового устройства с файлом fd
                       или значение fd,  если fd является уст-
                       ройством

         st_mode     - битовая маска,  содержащая информацию
                       об открытии файла:

                       S_IFCHR - если fd является устройством
                       S_IFREG - если fd  - обычный файл
                       S_IREAD - если файл открыт по чтению
                       S_IWRITE - если файл открыт по записи

         st_nlink    - всегда 1

         st_rdev     - то же, что и st_dev

         st_size     - размер файла в байтах

         st_atime    - время последней модификации

         st_ctime    - то же, что и st_atime

         st_mtime    - то же, что и st_atime

      Три не упомянутых выше поля: st_ino, st_vid, st_did, -
      не имеют смысла в DOS. Они установлены в 0 и обеспечи-
      вают совместимость с UNIX.

      Замечание: fstat не может быть вызван из C++ программы

   Пример:

      #include <dos.h>
      #include <sys\stat.h>
      #include <stdio.h>
      #include <io.h>
      #include <time.h>
      #include <errno.h>
      struct stat buf;
      int fh, result;
      main()
      {
        fh=open("file.dat", O_RDONLY);
        result=fstat("fh, &buf");
        if (result !=0)
            printf("Плох дескриптор файла\n");
        else
          {
            printf("Размер файла: %ld\n", buf.st_size);
            printf("Номер устройства: %d\n", buf.st_dev);
            printf("Время модификации: %s",
                    ctime(&buf.st_atime));
          }
      }

   Возвращаемое значение:

      Возвращает 0, если информация успешно извлечена, и -1,
      если плох дескриптор файла, с установкой errno в EBADF.

   Рекомендация:

      Смотрите также stat, findfirst, findnext, isatty.


ftell                                   ДАТЬ ПОЗИЦИЮ В ФАЙЛЕ

   Использование:

      #include <stdio.h>
      long ftell(FILE *fp);                       /* ANSI */

   Описание:

      Возвращает текущую позицию в файле,  связанном с пото-
      ком fp. Если файл открыт в текстовом режиме, возвраща-
      емое значение  может не отражать  точного  количества
      действительно считанных или записанных байтов.

   Пример:

      #include <stdio.h>
      long position;
      FILE *fp;
      main()
      {
        fp=fopen("file.dat", "a");
        fprintf(fp, "Пример строки данных\n");
        position=ftell(fp);      /* берем позицию в файле */
        printf("Текущая позиция в файле: %ld\n", position);
        fclose(fp);
      }

   Возвращаемое значение:

      Возвращает текущую позицию в файле или -1, если встре-
      тилась ошибка, с установлением errno.

   Рекомендация:

      Смотрите также fseek, isatty.


fwrite                                         ПИСАТЬ В ФАЙЛ

   Использование:

      #include <stdio.h>
      int fwrite(void *buffer, unsigned sizelem, unsigned n,
                 FILE *fp);                       /* ANSI */

   Описание:

      Записывает  n элементов размером sizelem байтов каждый
      из buffer в поток fp.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        char *buffer;
        unsigned sizelem, n;
        FILE *fp;
        int wrtn;
        buffer=calloc(255,1);
        sizelem=1;
        n=255;
        fp=fopen("file.dat", "a");
        strcpy(buffer, "\n Пример данных\n");
        wrtn=fwrite(buffer, sizelem, n, fp);
        free(buffer);
      }

   Возвращаемое значение:

      Возвращает количество полностью записанных  элементов,
      которое может быть меньше n, если имела место ошибка.

   Рекомендация:

   Смотрите также fread, write


getc, getchar, getche, getch             ВЗЯТЬ БАЙТ ИЗ ФАЙЛА

   Использование:

      #include <stdio.h>             /* getc(), getchar() */
      #include <conio.h>             /* getche(), getch() */
      int getc(FILE *fp);                         /* ANSI */
      int getchar(void);                          /* ANSI */
      int getche(void);
      int getch(void);

   Описание:

      getc извлекает один байт из потока fp.
      getchar извлекает один байт из потока stdin.
      getche извлекает один байт из потока stdin  и выдает
      эхо, т.е. выводит байт в stdout. Эта процедура возвра-
      щает значение, как только байт введен, не ожидая нажа-
      тия клавиши <RETURN>.
      getch, в отличие от getche, не обеспечивает эхо-вывода
      в stdout.

      getche и getch  обращаются  непосредственно  к MS DOS.
      Они обходятся без нормальной буферизации, используемой
      getchar и getc.

      ЗАМЕЧАНИЕ: ungetc нельзя использовать совместно с getch
                 и getche.

   Пример:

      #include <conio.h>
      #include <stdio.h>
      main()
      {
        int c;
        printf("Введите литеру и затем нажмите RETURN:");
        c=getchar();
        printf("То был пример с getchar\n");
        getc(stdin);
        printf("Введите литеру: ");
        c=getche();
        printf("То был пример с getche\n");
        printf("Hажмите на функц. клавишу и потом на литеру");
        c=getch();
        printf("\n Литера [%c] - пример с getch",c);
      }

   Возвращаемое значение:

      Каждая из функций возвращает прочитанный байт.  getc и
      getchar возвращают EOF в случае ошибки.  getch и getche
      игнорируют ошибки.

   Рекомендация:

      Смотрите также fgetc, putc, putchar, ungetc.



getcwd                                  ДАТЬ ТЕКУЩИЙ КАТАЛОГ

   Использование:

      #include <direct.h>
      char *getcwd(char *buffer, int length);

   Описание:

      Возвращает имя  устройства и описание  пути к текущему
      каталогу в заданном буфере. Если buffer равен NULL, то
      getcwd вызывает  malloc() с заявкой на память размером
      length байтов. Length является длиной  buffer, который
      должен быть достаточно большим, чтобы включить информа-
      цию вместе с заключительным 0.

   Пример:

      #include <direct.h>
      #include <stdio.h>
      main()
      {
        char buff[66];
        if (getcwd(buff, sizeof(buff))==NULL)
            perror("ошибка getcwd");
        else
            printf("%s", buff);
      }


   Возвращаемое значение:

      Возвщает buffer в случае успеха и NULL в случае ошибки,
      c устанавлением  errno в одно из значений:

         ENOMEM   -   исчерпание памяти
         ERANGE   -   описание  пути  доступа  длиннее,  чем
                      length-1.

   Рекомендация:

      Смотрите также  chdir, mkdir, rmdir.


getDS                             ВЗЯТЬ ЗНАЧЕНИЕ РЕГИСТРА DS

  Использование:

     #include <io.h>
     int getDS(void);

   Описание:

      Возвращает значение регистра DS (Data segment - сегмент
      данных).

   Пример:

      #include <stdio.h>
      #include <io.h>
      main()
      {
        unsigned int data_seg;
        data_seg = getDS();
        printf("Текущее содержимое DS равно %x\n", data_seg);
      }

   Возвращаемое значение:

      Возвращает текущее значение регистра DS.

   Рекомендация:  Смотрите также  segread.


getenv                                        ДАТЬ ОКРУЖЕНИЕ

   Использование:

      char getenv(char *name);                    /* ANSI */

   Описание:

      Отыскивает в списке переменных окружения строку  вида
      <NAME>=<value> и возвращает указатель на строку value,
      если NAME найдена.  Строка <NAME> должна быть набрана
      заглавными буквами.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        char *path;
        path = getenv("PATH");
        printf("PATH = %s\n", path);
      }

   Возвращаемое значение:

      Возвращает  указатель  на строку  значения  переменной
      окружения.  В случае,  если окружение не содержит ука-
      занного имени, возвращает NULL.


gets                                             ВВОД СТРОКИ

   Использование:

      #include <stdio.h>
      char *gets(char *str);                      /* ANSI */

   Описание:

      Считывает байты из потока  stdin в строку  str  до тех
      пор,  пока не встретит  признак новой строки или конца
      файла. Признак "новая строка"(newline) не записывается
      в строку. Строка завершается 0. Строка должна быть до-
      статочно большой, чтобы вместить результат.

   Пример:

      #include <stdio.h>
      main()
      {
        char buffer[125];
        printf("Наберите строку:");
        gets(buffer);
        printf("Была введена строка: %s\n", buffer);
      }

   Возвращаемое значение:

      Возвращает str. В случае ошибки чтения или при встрече
      конца файла в начале чтения возвращает NULL.

   Рекомендация:

      Смотрите также  fgets, puts.


hypot                                             ГИПОТЕНУЗА

   Использование:

      #include <math.h>
      double hypot(double x, double y);

   Описание:

      Вычисляет длину гипотенузы прямоугольного треугольника
      со сторонами  x,  y.  Гипотенуза  является  значением,
      полученным вычислением квадратного корня из (x*x+y*y).

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double x, y;
        printf("Введите плавающее x:");
        scanf("lf", &x);
        printf("Введите плавающее y:");
        scanf("lf", &y);
        printf("Гипотенуза на катетах [%f, %f] равна [%f]\n",
                                          x, y, hypot(x,y));
      }

   Возвращаемое значение:

      Длина гипотенузы, построенной на катетах x, y.


index 			               НАЙТИ ЛИТЕРУ В СТРОКЕ

   Использование:

      char *index(char *s, int c);

   Описание:

      Отыскивает первое вхождение литеры `c' в строку `s'.
      Эта функция идентична strchr.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char string2[50] = "2 пример строки";
      main()
      {
        printf("\n Пример на index %s \n",
                                       index(string2, 'и'));
      }


   Возвращаемое значение:

      Возвращает указатель на `c', если `c' найдена в строке
      `s', и NULL в противном случае.

   Рекомендация:

      Смотрите также  strchr, strcpy, strcmp, strrchr.


inp, inpw                                      ВВОД ИЗ ПОРТА

   Использование:

      #include <dos.h>
      int inp(int port_address);
      int inpw(int port_address);

   Описание:

      Обеспечивают интерфейс  С  с аппаратными портами 8086,
      реализуя команды 8086 in и out обмена с портами.

         inp:   считывает байт  из указанного порта.
         inpw:  считывает слово из указанного порта.

         Компилятор генерирует в код соответствующие команды.
         Можно использовать вместо этого "настоящие" обраще-
         ния к функциям,если поместить в головной файл после
         #include  <dos.h>  отмену  макроподстановок:
         #undef inp    и    #undef inpw.

   Возвращаемое значение:

      Возвращает  значение,  считанное  из  данного  порта.

   Рекомендация:

      Смотрите также :  outp, outpw.

   Пример:

      /* Эта функция выключит MDA курсор */
      #include <dos.h>
      int porta, portb, bytea, byteb;
      main()
      {
        char result;
        porta = 0x3b4;
        portb = 0x3b5;
        bytea = 10;
        byteb = 32;
        result = inpw(porta);
        printf("Значение,приняеое из порта bp %x равно
                %x шестн.\n",porta, result);
        outp(porta, bytea);
        outp(portb, byteb);
      }
      /* Эта функция включит MDA курсор */
      #include <dos.h>
      int porta, portb, bytea, byteb;
      main()
      {
        porta = 0x3b4;
        portf = 0x3b5;
        bytea = 10;
        byteb = 11;
        outp(porta, bytea);
        outp(portb, byteb);
      }



Interrupt Package                Пакет работы с прерываниями

   Использование:

      #include <int.h>
      void int_getvector(unsigned vector, unsigned *poffset,
                                        unsigned *psegment);
      int int_intercept(unsigned vector, int (*funcptr)
                 (struct INT_DATA *pd), unsigned stacksize);
      void int_off(void);
      void int_on(void);
      int int_restore(unsigned vector);
      void int_setvector(unsigned vector, unsigned offset,
                                          unsigned segment);

   Описание:

      Пакет работы с прерываниями спроектирован как общецеле-
      вой пакет по управлению прерываниями 8086. Для каждого
      вектора прерываний  можно  определить  новую  реакцию.
      C функция, обрабатывающая прерывание, определяет, свя-
      зано ли прерывание с прежним  вектором  прерывания или
      нет.

      int_intercept    связывает   стандартную   C - функцию
      (*funcptr) с вектором прерывания для обработки данного
      прерывания  при  его появлении.  Параметр vector опре-
      деляет вектор прерывания 8086 (0...255), с которым свя-
      зывается функция. Аргумент stacksize определяет количе-
      ство байтов памяти,  отводимой под стек для функции об-
      работки.  Размер стека должен быть не менее 256 байтов.

      Если функция  обработки  прерывания (*funcptr)() возв-
      ратит нулевое значение, то будет вызвана прежняя функ-
      ция  обработки  прерывания, cвязанная с этим вектором,
      иначе выполнится возврат из прерывания.
      Значения из регистров  могут быть считаны или записаны
      через указатель (*pd) на структуру  INT_DATA,  который
      поступает к (*funcptr)(). Существует несколько правил,
      которым необходимо следовать, занимаясь обработкой пре-
      рываний на C:

         1). Ни MS DOS, ни BIOS не могут быть вызваны в про-
             цессе обработки прерывания, если при этом может
             произойти прерывание.  Это объясняется тем, что
             MS DOS и BIOS не являются повторно входимыми.
         2). Нельзя при обработке прерывания или в вызванной
             отсюда функции использовать в стеке памяти боль-
             ше, чем отведено под стек.
         3). Не обращайтесь к какой-либо функции,  не являю-
             щейся   повторно  входимой.   (Результат  будет
             непредсказуем).
         4). Непозволительно выполнение операций  ввода/вы-
             вода в обработке прерывания.
         5). Когда   используются   переменные,   изменяемые
             при  обработке  прерывания,  объявляйте  их как
             `volatile'.
         6). Отключите для функции обработки прерывания конт-
             роль переполнения стека.

      int_off  выключает прерывания 8086 командой CLI (clear
      interrupt flag).
      int_on   включает   прерывание   8086   командой   STI
      (set interrupt flag).

      Функция int_restore является обратной к int_intercept.
      int_restore отключает первоначальный обработчик преры-
      ваний, который был подцеплен к указанному вектору пос-
      редством  int_intercept. Поэтому int_restore не должна
      вызываться до обращения к int_intercept,  связывающего
      (новую) реакцию с этим вектором прерываний.

      int_getvector получает  содержимое  указанного вектора
      прерываний, разлагает его на сегмент и смещение и запо-
      минает их в переменных psegment и poffset.

      int_setvector   устанавливает  адрес  пользовательской
      процедуры,  используя  offset и segment,  в  указанном
      векторе прерываний.

   Пример:

      #include <int.h>
      volatile int ctrl_c_count = 0;
      int do_ctrl_c();
      main()
      {
        int_intercept(0х23, do_ctrl_c, 256);
                                    /* установили реакцию */
        while(ctrl_c_count<3)
           printf("Число Ctrl C равно %d/n", ctrl_c_count);
        int_restore(0х23);         /* восстановили старую */
      }
      do_ctrl_c()
      {
        ++ctrl_c_count;
        return 1;
      }

   Возвращаемое значение:

      Значение, возвращаемое  int_intercept  и  int_restore,
      индицирует успех или неудачу.  0 возвращается в случае
      успеха и -1  в противном случае.

         ПРЕДУПРЕЖДЕНИЕ: Переопределение прерывания является
                         тонкой процедурой,  требующей хоро-
                         шего понимания  MS DOS  и семейства
                         IBM PC для успешного применения.


int86, int86x                         ПРОГРАММНОЕ ПРЕРЫВАНИЕ

   Использование:

      #include <dos.h>             /* структуры регистров */
      int int86(int intnum, union REGS *regsin,
                            union REGS *regsout);
      int int86x(intnum, union REGS *regsin,
                 union REGS *regsout, struct SREGS *segregs);

   Описание:

      Эти функции  выполняют  программное  прерывание  8086.
      intnum является номером прерывания (0...255).

      regsin  является  указателем на структуру,  содержащую
      значения регистров AX,BX,CX,DX,SI и DI,  поступающих с
      прерыванием.

      segregs является значением сегментных регистров,  пос-
      тупающих с прерыванием.

      regsout является указателем на структуру, в которую за-
      писываются возвращаемые значения регистров.

      Структуры REGS и SREGS определены в dos.h файле. Отсы-
      лаем Вас к руководствам  по  аппаратуре и программному
      обеспечению для знакомства с номерами прерываний и со-
      ответствующими функциями на Вашей машине.

   Пример:

      /* Эта функция  воспринимает ввод с клавиатуры и пишет
         строку на экран посредством BIOS */
      #include <dos.h>
      #include <stdio.h>
      #define MAXKEY 19
      #define BEEP printf("\007")
      void print(void);
      void biosprt(void);
      char buf [MAXKEY], *ptr;
      int colm = 30, i;
      union REGS r;
      main()
      {
        system("cls");
        printf("Введите строку из 20 литер\n\n");
        gets(buf);
        if (strlen(buf) > 20)
             printf("Строка длинна, обрезаем\n");
        print();
      }
      void print()
      {
        r.h.ah = 0х02;
        r.h.bh = 0;
        r.h.dh = 12;
        r.h.d1 = colm;
        int86 (0х10, &r, &r);
        for (ptr=buf,i=0; i<=MAXKEY; (biosprt()),i++,ptr++);
      }
      void biosprt()
      {
        r.h.ah = 0х09;
        r.h.al = *ptr;
        r.x.cx = 1;
        r.h.bl = 0х0f;
        r.h.bh = 0;
        int86(0x10, &r, &r);
        r.h.ah = 0x02;
        r.h.bh = 0;
        r.h.dh = 12;
        r.h.dl = ++colm;
        int86 (0х10, &r, &r);
      }

   Возвращаемое значение:

      Возвращают значение регистра  AX в 8086  по завершению
      прерывания.  Состояние флага 'carry' можно получить из
      x.cflag  в regsout.  Не пользуйтесь int86 и int86x для
      прерываний 0x25 или 0x26.  Используйте  для этих целей
      abs_disk_read/ write.

   Рекомендация:

      Смотрите также  intdos, bdos.



intdos, intdosx                  СИСТЕМНЫЙ ВЫЗОВ ФУНКЦИИ DOS

   Использование:

      #include <dos.h>             /* структуры регистров */
      int intdos(union REGS *regsin, union REGS *regsout);
      int intdosx(union REGS *regsin, union REGS *regsout,
                                     struct SREGS *segregs);

   Описание:

      Эти функции выполняют системный вызов DOS  (прерывание
      0x21).  Отсылаем  Вас к руководству по DOS за деталями
      обращения и выполнения функций.

      regsin  является  указателем на структуру,  содержащую
      значения регистров AX, BX, CX, DX, SI и DI,  поступаю-
      щие с прерыванием.

      regsout  является указателем  на структуру,  в которую
      будут записаны возвращаемые значения регистров.

      segregs  является указателем на структуру,  содержащую
      сегментные  регистры,  поступающие  с  прерыванием для
      intdosx. Объединение REGS и структура SREGS определены
      в dos.h файле.

   Пример:

      #include <dos.h>
      union REGS inregs, outregs;
      struct SREGS segregs;
      main()
      {
        char far *string = "Печать этой строки $";

        inregs.h.ah = 9;
        inregs.x.dx = FP_OFF(string);
        segregs.ds = FP_SEG(string);
        intdosx(&inregs, &outregs, &segregs);
      }
   Возвращаемое значение:

      Значение, которое было в AX на конец прерывания.

   Рекомендация:

      Смотрите также  int86, int86x, bdos.



isatty                                 ОПРЕДЕЛИТЬ ТИП ПОТОКА

   Использование:

      #include <io.h>
      int isatty (int fd);


   Описание:

      Определяет,  связан ли дескриптор fd с терминалом,
      принтером или последовательным портом.

   Пример:

      #include <stdio.h>
      #include <io.h>
      main()
      {
        if (isatty (fileno(stdin)))
            printf("stdin связан с клавиатурой\n");
        else
            printf("stdin связан с файлом\n");
      }

   Возвращаемое значение:

      Возвращает ненулевое  значение,  если устройство явля-
      ется терминалом,  консолью и т.д., и 0,  если с чем-то
      подобным дисковому файлу.

   Рекомендация:  Смотрите также  fstat.


is package                         Пакет классификации литер

   Использование:

      #include <ctype.h>
      int isalnum(int c);                         /* ANSI */
      int isalpha(int c);                         /* ANSI */
      int isascii(int c);
      int iscntrl(int c);                         /* ANSI */
      int isdigit(int c);                         /* ANSI */
      int isgraph(int c);                         /* ANSI */
      int islower(int c);                         /* ANSI */
      int isprint(int c);                         /* ANSI */
      int ispunct(int c);                         /* ANSI */
      int isspace(int c);                         /* ANSI */
      int isupper(int c);                         /* ANSI */
      int isxdigit(int c);                        /* ANSI */

   Описание:

      Эти макросы  классифицируют  литеры по заданному приз-
      наку. Каждый возвращает ненулевое значение в  качестве
      истинности утверждения и ноль в противном случае.

      isascii  возвращает  ненулевое значение для всех ASCII
      значений 0...127. Все другие макросы используют целое,
      лежащее в диапазоне - 1...255.  Все значения,  лежащие
      вне этого диапазона, приводят к ошибочным ответам. Эти
      макросы реализованы также и как библиотечные функции.

   Пример:

      #include <ctype.h>
      #include <stdio.h>
      main()
      {
        printf("Isalnum(%c)=%d\n", '$', isalnum('$'));
        printf("Isalpha(%c)=%d\n", 'f', isalpha('f'));
        printf("Isascii(%c)=%d\n", 0xe4, isascii(0xe4));
        printf("Iscntrl(%c)=%d\n", 0x09, iscntrl(0x09));
        printf("Isdigit(%c)=%d\n", 0x32, isdigit(0x32));
        printf("Isgraph(%c)=%d\n", 0x0ea, isgraph(0x0ea));
        printf("Islower(%c)=%d\n", 'A', islower('A'));
        printf("Isprint(%c)=%d\n", 0x40, isprint(0x40));
        printf("Ispunct(%c)=%d\n", ',', ispunct(','));
        printf("Isspace(%c)=%d\n", ' ', isspace(' '));
        printf("Isupper(%c)=%d\n", 'd', isupper('d'));
        printf("Isxdigit(%c)=%d\n", 0x0d, isxdigit(0x0d));
      }

   Возвращаемое значение:

      isalnum  возвращает не ноль,  если 'c'  есть буква или
      цифра.

      ialpha возвращает не ноль, если 'c' есть буква.

      isascii возвращает не ноль, если 'c' в диапазоне
      0..127.

      iscntrl  возвращает не ноль,  если 'c' является управ-
      ляющим символом (из диапазона (0, 0x1F) или c==0x7F).

      isdigit возвращает не ноль в случае цифры 0...9.

      isgraph возвращает не ноль, если 'c' является печатае-
      мым символом (исключая пробел).

      islower возвращает не ноль, если 'c' есть один из сим-
      волов нижнего регистра.

      isprint возвращает не ноль, если 'c' является печатае-
      мым символом (включая пробел).

      ispunct возвращает не ноль, если 'c' есть символ пунк-
      туации.

      isspace возвращает не ноль в случае символа табуляции,
      новой строки, вертикальной табуляции, возврата каретки,
      пробела и перевода формата (form feed).

      isupper возвращает не ноль, если 'c' является одним из
      символов верхнего регистра.

      isxdigit  возвращает не ноль,  если 'c' является одним
      из символов 0..9, A..F или a..f.

   Рекомендация:

      Смотрите также toascii.


itoa                                   ПРЕДСТАВЛЕНИЕ ЦЕЛОГО

   Использование:

      #include <stdlib.h>
      char * itoa(int value, char * str, int radix);

   Описание:

      Преобразует  value  в строку,  заканчивающуюся  нулем,
      используя radix. Radix задает основание системы исчис-
      ления и должен быть в диапазоне 2...36. Если value от-
      рицательно и radix равен 10,  первой литерой str будет
      '-'. Результат записывается в строку str, которая долж-
      на быть достаточно велика, чтобы результат поместился.

   Возвращаемое значение:

      Возвращает str. Ошибки не возвращаются.

   Пример:

      #include <stdlib.h>
      #include <stdio.h>
      main()
      {
        char buffer[10];
        int value = 67;
        char *ptr;
        ptr = itoa(value, buffer, 2);
        printf("Число %d как двоичное=\"%s\"\n",value,
                                                    buffer);
        ptr=itoa(value, buffer, 8);
        printf("Число %d как восьмеричное=\"%s\"\n",value,
                                                    buffer);
        ptr=itoa(value, buffer, 16);
        printf("Число %d как 16-ричное=\"%s\"\n",value,
                                                    buffer);
      }


kbhit                            ПРОВЕРКА ВВОДА С КЛАВИАТУРЫ

   Использование:

      #include <conio.h>
      int kbhit(void);

   Описание:

      Проверяет наличие ввода с клавиатуры (нажатие клавиши).

   Пример:

      #include <stdio.h>
      #include <conio.h>
      main()
      {
        printf("Приготовившись, нажмите любую клавишу\n");
        while(!kbhit());
        printf("\n Была нажата клавиша (%c)\n", getch());
      }

   Возвращаемое значение:

      Возвращает не ноль в случае нажатия клавиши клавиатуры
      и ноль в противном случае.



labs                            АБСОЛЮТНОЕ ЗНАЧЕНИЕ ДЛИННОГО

   Использование:

      #include <stdio.h>
      long labs(long i);                          /* ANSI */

   Описание:

      Вычисляет абсолютное значение длинного целого.


   Пример:

      #include <stdlib.h>
      #include <stdio.h>
      main()
      {
        long lng, result;
        lng = -314159L;
        result = labs(lng);
        printf("Абсолютное значение от (%ld) равно (%ld)\n",
                    lng, result);
      }

   Возвращаемое значение:

      Возвращает абсолютное значение длинного целого.

   Рекомендация:

      Смотрите также abs.


ldexp                                             ЭКСПОНЕНТА

   Использование:

      #include <math.h>
      double ldexp(double x, int exp);            /* ANSI */

   Описание:

      Вычисляет значение x*(2**exp).

   Пример:

      #include <math.h>
      #include <stdio.h>
      main()
      {
        double x,y;
        int exp;
        x = 1.5;
        exp = 5;
        y = ldexp(x,exp);
        printf("The ldexp(%f exp %d)=\n", x, exp, y);
      }

   Возвращаемое значение:

      Возвращает вычисленное значение x*(2**exp).


      Рекомендация:

      Смотрите также  exp, frexp, log, log10, modf.



ldiv                                 ДЕЛЕНИЕ ЧИСЕЛ ТИПА long

   Использование:

      #include <stdlib.h>                         /* ANSI */
      ldiv_t ldiv(long int numerator, long int denominator);

   Описание:

      Делит  numerator на  denominator,  возвращая частное и
      остаток.  Если делитель ноль,  программа завершается с
      сообщением об ошибке.  Аргументы и возвращаемые значе-
      ния имеют тип long.

   Возвращаемое значение:

      Возвращает структуру ldiv_t,  содержащую частное и ос-
      таток.

   Рекомендация:

      Смотрите также  div.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        long numer, denom;
        ldiv_t result;
        numer = 3;
        denom = 2;
        printf("Делимое = %ld и делитель = is %ld\n", numer,
                denom);
        result = ldiv(numer, denom);
        printf("Частное = %ld\n", result.quot);
        printf("Остаток = %ld\n", result.rem);
      }



localtime                                ДАТЬ  МЕСТНОЕ ВРЕМЯ

   Использование:

      #include <time.h>
      struct tm *localtime(time_t *time);         /* ANSI */

   Описание:

      Преобразует  время,  записанное  в формате  time_t,  в
      структуру tm.  time_t выражается в секундах с 1 января
      1970 года.  Оно может быть  получено с помощью функции
      time. Localtime производит коррекцию, учитывающую вре-
      менной пояс и, возможно, поправку на сдвиг,  связанную
      с экономией дневного времени. Поля структуры tm:

      struct tm {
         tm_sec,                         /* секунды 0..59 */
         tm_min,                         /* минуты  0..59 */
         tm_hour,                        /* час дня 0..23 */
         tm_mday,                    /* день месяца 1..31 */
         tm_mon,                           /* месяц 0..11 */
         tm_year,                       /* год после 1900 */
         tm_wday,         /* день недели, 0..6 (Sun..Sat) */
         tm_yday,                    /* день года, 0..365 */
         tm_isdst;        /* >0, если есть поправка на сдвиг,
                             =0, если нет поправки,
                             <0, если неизвестно */
      }

   Возвращаемое значение:

      Возвращает  указатель  на  статическую  структуру  tm,
      которая обновляется при каждом вызове функции.

   Пример:

      #include <time.h>
      #include <stdio.h>
      main()
      {
        struct tm *t;
        time_t ltime;
        time(&ltime);
        t = localtime(&ltime);
        printf("Дата: %d-%d-%d\n", t-> tm_mday,
                         t->tm_mon+1, t->tm_year);
      }


   Рекомендация:

      Смотрите также  time, asctime, ctime, mktime.


log, log10                                          ЛОГАРИФМ

   Использование:

      #include <math.h>
      double log(double x);                       /* ANSI */
      double log10(double x);                     /* ANSI */

   Описание:

      Log вычисляет натуральный логарифм x.  Значение x дол-
      жно быть больше 0. Log10 вычисляет десятичный логарифм
      x (x должен быть больше 0).

   Пример:

      #include <math.h>
      #include <stdio.h>
      main(int argc, char **argv)
      {
        double d, result;
        d = atof(argv[1]);
        result = log(d);
        printf("The log of %.2f is %f\n", d, result);
        result = log10(d);
        printf("The log10 of %.2f is %f\n", d, result);
      }

   Возвращаемое значение:

      Возвращают вычисленное значение или ошибку,  связанную
      с областью определения, если x <= 0.

   Рекомендация:

      Смотрите также  exp, pow, sqrt.


longjmp                                      ДЛИННЫЙ ПЕРЕХОД

   Использование:

      #include <setjmp.h>
      void longjmp (jmp_buf env, int value);      /* ANSI */
      int setjmp (jmp_buf env);                   /* ANSI */

   Описание:

      Эти  функции  позволяют  осуществлять  переходы  между
      функциями. Они могут быть полезны при обработке ошибок
      или прерываний,  происшедших в низкоуровневых процеду-
      рах программы.
      setjmp сохраняет окружение стека в переменной  env для
      дальнейшего использования в longjmp.
      longjmp восстанавливает окружение,  сохраненное  ранее
      посредством setjmp в буфере env. value, возвращаемое в
      окружение, как бы поставляет setjmp.

      ЗАМЕЧАНИЕ:  Окружение должно быть зафиксировано с ис-
                  пользованием setjmp, вызываемой из той же
                  функции, которая содержит обращение к фу-
                  нкции longjmp, или из "родительской", т.е.
                  функции,  содержащей обращение к той, что
                  вызывает longjmp.

      После завершения  longjmp выполнение программы продол-
      жается, как если бы соответствующее обращение к setjmp
      возвратило value. value никогда не будет 0. Если value
      передано как 0, будет возвращено значение 1.

   Возвращаемое значение:

      setjmp  возвращает  0.  longjmp не имеет возвращаемого
      значения.

   Пример:

      #include <setjmp.h>
      #include <stdio.h>
      void doscall(void);
      jmp_buf environment;
      int error_val = -1;
      main()
      {
        int error code;
        error_code = setjmp(environment);
        if (error_code !=0)
            {
              printf("Вызван longjmp\n");
              exit(1);
            }
        printf("Вызван setjmp\n");
        doscall();
      }
      doscall()
      {
        longjmp(environment, error_val);
      }


lseek                              ИЗМЕНИТЬ ПОЗИЦИЮ В ФАЙЛЕ

   Использование:

      #include <io.h>
      long lseek(int fd, long offset, int mode);


   Описание:

      Изменяет текущую позицию чтения/записи в файле, задан-
      ном дескриптором fd. Параметр mode может принимать одно
      из следующих значений:

         SEEK_SET - Указатель сдвигается на offset байтов от
                    начала файла.

         SEEK_CUR - Сдвиг на offset байтов относительно теку-
                    щей позиции.

         SEEK_END - Сдвиг на offset байтов от конца файла.

   Возвращаемое значение:

      Возвращает смещение в байтах новой позиции относитель-
      но начала файла. В случае ошибки возвращает -1 и уста-
      навливает errno.

   Рекомендация:

      Смотрите также  fseek.

   Пример:

      #include <stdio.h>
      #include <io.h>
      #include <dos.h>
      main()
      {
        int fp;
        long offset, lpos;
        fp = open("file.dat", O_RDWR);
        if (fp<0)
            return;
        offset = 0L;
        lpos = lseek(fp, offset, SEEK_SET)
        printf("Текущая позиция=%ld\n", lpos);
        offset = 10L;
        lpos = lseek(fp, offset, SEEK_CUR);
        printf("Текущая позиция=%ld\n", lpos);
        offset = 50L;
        lpos = lseek(fp, offset, SEEK_END);
        printf("Текущая позиция=%ld\n", lpos);
        close(fp);
      }



malloc                                       ОТВЕСТИ ПАМЯТЬ

   Использование:

      #include <stdlib.h>
      void *malloc(unsigned numbytes);            /* ANSI */

   Описание:

      Размещает  блок памяти объемом  numbytes  байтов. Если
      numbytes равен 0, то возвращает NULL.

   Пример:

      #include <stdlib.h>
      #include <stdio.h>
      #define NUM_INTS 7623
      int *memblock;
      main()
      {
        memblock = malloc(NUM_INTS*sizeof(int));
        if (memblock==NULL)
            printf("Нехватка памяти\n");
        else
            printf("Память отведена\n");
        free(memblock);
      }

   Возвращаемое значение:

      Возвращает указатель на размещенный блок памяти.  Либо
      возвращает NULL  при недостатке памяти  или  в  случае
      numbytes==0.

   Рекомендация:

      Смотрите также calloc, free, realloc, farmalloc.



matherr              ОБРАБОТКА ОШИБКИ МАТЕМАТИЧЕСКОЙ ФУНКЦИИ

   Использование:

      #include <math.h>
      int matherr(struct exception *e);

   Описание:

      matherr вызывается  при  обнаружении  ошибки функциями
      math библиотеки.  Пользователь может использовать биб-
      лиотечный вариант этой функции или определить собстве-
      нную одноименную процедуру  в своей программе.  Указа-
      тель на структуру exception должен поступать  в проце-
      дуру пользователя, берущую обработку ошибки на себя.

   Возвращаемое значение:

      Возвращение 0 означает, что ошибка обработана правиль-
      но, 1 означает, что ошибка не может быть обработана.

   Пример:

      #include <stdio.h>
      #include <math.h>
      #include <string.h>
      main()
      {
        printf("log(-1) = %e\n", log(-1));
      }
      int matherr(x)
      struct exception *x;
      {
        if (x -> type == DOMAIN)
            {
              if (strcmp(x -> name, "log")==0)
                 {
                   x -> retval = log(-(x -> arg1));
                   return(1);
                 }
            }
        return(0);
      }

memchr - memset                  РАБОТА С БАЙТАМИ В МАССИВАХ

   Использование:                             /* все ANSI */

      #include <string.h>
      void *memchr(void *buf, int c, unsigned count);
      int  memcmp(void *buf1, void *buf2, unsigned count);
      void *memcpy(void *buf1, void *buf2, unsigned count);
      void *memmove(void *buf1, void *buf2, unsigned count);
      void *memset(void *buf, int val, unsigned count);

   Описание:

      memchr отыскивает в буфере  buf  байт со значением 'c'.
      Поиск продолжается среди  count  количества байтов или
      до встречи значения 'c'.

      memcmp последовательно сравнивает байты буферов buf1 и
      buf2 и продолжает это,  пока они совпадают,  либо пока
      не выполнит заданное количество сравнений count. memcmp
      возвращает целое, меньшее, равное или большее 0 в зави-
      симости от результата сравнения  последней пары байтов.

      memcpy и memmove копируют count байтов из buf2 в buf1.
      memcpy работает быстрее,  но не работает,  если buf1 и
      buf2 перекрываются (имеют общую часть).Возвращают buf1.

      memset устанавливает первые count байтов в buf равными
      val. Возвращает buf.

   Возвращаемое значение:

      memchr возвращает указатель на позицию найденной литеры
      'c' в буфере, либо NULL.

      memcpy и memmove возвращают buf1.
      memset возвращает buf.
      memcmp возвращает значения:

         <0         buf1 < buf2
         =0         buf1 = buf2
         >0         buf1 > buf2

   Пример:

      #include <string.h>
      #include <stdio.h>
      char buffer[50];
      char buffer2[50]="Пример строки\n";
      char srccpy[]="Пример 2 строки\n";
      char * result;
      int reslt;
      main()
      {
        printf("Работает функция memcpy\n");
        memcpy(buffer, buffer2, 15);
        printf("Работает функция memchr\n");
        result = memchr(buffer, 'т', 50);
        if (result != NULL)
            printf("Литера(т) найдена в (%d)\n",
                                 result-buffer+1);
        else
            printf("Ошибка-(т) не найдена\n");
        printf("Работает функция memcmp\n");
        reslt = memcmp(buffer, buffer2, 50);
        printf("Результат memcmp: %s\n", reslt;
        printf("Buffer before memmove : %s", buffer);
        result = memmove(buffer, srccpy, sizeof(srccpy));
        printf("Буфер после memmove : %s", buffer);
        printf("Буфер до memset : %s", buffer);
        result = memset(buffer, 'x', 6);
        printf("Буфер после memset : %s", buffer);
      }

   Рекомендация:

      Смотрите также strcmp, strcat, strset, strchr.


mkdir                                        СОЗДАТЬ КАТАЛОГ

   Использование:

      #include <direct.h>
      int mkdir(char * pathname);

   Описание:

      Создает новый  каталог,  заданный параметром pathname.
      Если pathname содержит более одной компоненты,  только
      последняя компонента должна  быть  новой,  а все пред-
      шествующие должны быть существующими каталогами.

   Пример:

      #include <stdio.h>
      #include <direct.h>
      main()
      {
        int result;
        result = mkdir("\\temp");
        if (result==0)
            printf("Каталог \\temp создан\n");
        else
            printf("Не могу создать каталог \\temp\n");
      }

   Возвращаемое значение:

      Возвращает 0 в случае  успеха  и -1 в случае неудачи с
      устанавкой errno.

   Рекомендация:

      Смотрите также rmdir, chdir.


MK_FP                              СОЗДАТЬ ДАЛЬНИЙ УКАЗАТЕЛЬ

   Использование:

      #include <dos.h>
      void far *MK_FP(unsigned seg, unsigned off);

   Описание:

      Преобразует  значения сегмента (segment) и  смещения
      (offset) в дальний указатель.

   Пример:

      #include <dos.h>
      #include <stdio.h>
      main()
      {
        char far *p;
        unsigned int segment=0xb800, offset=0;
        p = MK_FP(segment, offset);
        printf("The CGA видео буфер в %lp\n", p);
      }

   Возвращаемое значение:

      Возвращает дальний указатель.

   Рекомендация:

      Смотрите также FP_SEG, FP_OFF.


mktime                                   ПРЕОБРАЗОВАТЬ ВРЕМЯ

   Использование:

      #include <time.h>
      time_t mktime(struct tm *ntime);            /* ANSI */

   Описание:

      Преобразует структуру tm в time_t.

   Пример:

      #include <time.h>
      #include <stdio.h>
      main()
      {
        struct tm ntime;
        time_t set;
        time(&set);
        ntime = *localtime(&set);
        printf("Секунд с 1 января 1970 прошло %ld",
                             mktime(&ntime));
        printf("Время: %s", asctime(&ntime));
      }

   Возвращаемое значение:

      Время в секундах после  00:00:00 1 января 1970 года по
      Гринвичу.

   Рекомендация:

      Смотрите также asctime, ctime, localtime, time.


modf                             ДРОБНАЯ И ЦЕЛАЯ ЧАСТЬ ЧИСЛА

   Использование:

      #include <math.h>                           /* ANSI */
      double modf(double x, double *ptr);

   Описание:

      Вычисляет дробную и целую части значения  аргумента x
      со знаком.Целая часть 'x'со знаком запоминается в ptr.

   Пример:

      #include <math.h>
      #include <stdio.h>
      main()
      {
        double x, y, n;
        x = -41.56789;
        y = modf(x, &n);
        printf("modf(%f)=fractional %f and integer : %f",
                                                  x, y, n);
      }

   Возвращаемое значение:

      Возвращает дробную часть аргумента x со знаком.

   Рекомендация:

      Смотрите также frexp, ldexp.


Mouse Package                           Пакет работы с мышью

   Использование:

      #include <msmouse.h>
      int msm_init(void);
      void msm_term(void);
      void msm_hidecursor(void);
      void msm_showcursor(void);
      int msm_getstatus(unsigned *curposx,unsigned *curposy);
      void msm_setcurpos(unsigned curposx,unsigned curposy);
      int msm_getpress(unsigned *count, unsigned *curposx,
                                          unsigned *curposy);
      int msm_getrelease(unsigned *count, unsigned *curposx,
                                          unsigned *curposy);
      void msm_setgraphcur(int hotx, int hoty, int *pmasks);
      void msm_setareax(unsigned minx, unsigned maxx);
      void msm_setareay(unsigned miny, unsigned maxy);
      void msm_settextcur(int select, int scanstart,
                                      int scanstop);
      void msm_readcounter(int *countx, int *county);
      void msm_signal(unsigned mask,void(*func)(unsigned mask,
         unsigned state,unsigned curposx,unsigned curposy),
                                                 void *stack);
      void msm_lightpenon(void);
      void msm_lightpenoff(void);
      void msm_setratio(unsigned ratiox, unsigned ratioy);
      void msm_condoff(unsigned upperx, unsigned uppery,
                       unsigned lowerx, unsigned lowery);
      void msm_setthreshhold(unsigned speed);

   Описание:

      Этот пакет является  интерфейсом  к  Microsoft  мыши и
      должен  использоваться  вместе с руководством по прог-
      раммированию мыши. Для дальнейшего знакомства отсылаем
      Вас к  Mouse  Programming Manual.

   Пример:

      #include <stdio.h>
      #include <msmouse.h>
      main()
      { if (msm_init()==-1)
           { printf("Мышь инициализирована успешно\n");
             msm_showcursor();
             while(1)
               {
                 int status;
                 unsigned x, y;
                 status = msm_getstatus(&x, &y);
                 if (status & LEFT_BUTTON)
                    {
                     msm_hidecursor();
                     printf("x=%n,y=%n\n",x,y);
                     msm_showcursor();
                    }
               if (status & RIGHT_BUTTON)
                    break;
               }
           msm_term();
           }
        else
            printf("Инициализация мыши не прошла\n");
      }

   Возвращаемое значение:

      Смотрите Mouse Manual Programming.


open                                            ОТКРЫТЬ ФАЙЛ

   Использование:

      #include <io.h>
      int open (char *pathname, int rwmode);

   Описание:

      Открывает файл,  заданный параметром pathname.  Rwmode
      специфицирует режим доступа к файлу посредством одного
      из значений:

         O_RDONLY   -   по чтению
         O_WRONLY   -   по записи

   Возвращаемое значение:

      Возвращает дескриптор файла в случае  успеха  и  -1  в
      случае неудачи, устанавливая при этом errno.

   Рекомендация:

      Смотрите также close, creat, dos_creat, fopen.

   Пример:

      #include <stdio.h>
      #include <dos.h>
      #include <io.h>
      #include <sys/stat.h>
      main()
      {
        char *fname;
        unsigned int mode;
        int fd;
        mode = O_RDONLY;
        fname = "file.dat";
        fd = open(fname, mode);
        if (fd==-1)
            perror("Ошибка открытия файла");
        else
            {
              printf"\n файл : %s открыт для чтения\n",
                                                     fname);
              close(fd);
            }
        mode = O_WRONLY;
        fname = "CON";
        fd = open(fname, mode);
        if (fd<0)
          printf("\n Ошибка открытия консоли на запись: %s\n",
                                                       fname);
        else
           {
             printf("\n Файл %s открыт на запись\n",
                                                     fname);
             close(fd);
           }
        mode = O_WRONLY | O_CREAT;
        fname = "file.dat";
        fd = open(fname, mode);
        if (fd==-1)
            perror("Ошибка открытия файла");
        else
           {
             printf("\n Файл %s открыт на вывод\n", fname);
             close(fd);
           }
      }


outp, outpw                                     ВЫВОД В ПОРТ

   Использование:

      #include <dos.h>
      void outp(int port_address, int value);
      void outpw(int port_address, int value);

   Описание:

      Эти функции  обеспечивают интерфейс с аппаратными пор-
      тами ввода/вывода 8086, используя команды 'in' и 'out'
      процессора 8086.

	outp  -  пишет младший байт value в указанный порт.
        outpw  -  записывает значение слова в указанный порт.

      Если включен файл dos.h,  компилятор "открыто подстав-
      ляет код для outp и outpw.

   Рекомендация:

      Смотрите также inp, inpw.

   Пример;

      /* Эта функция выключает курсор IBM MDA. */
      #include <dos.h>
      int porta, portb, bytea, byteb;
      main()
      {
        char result;
        porta = Ox3B4;
        portb = Ox3B5;
        bytea = 10;
        byteb = 32;
        result = inpw(porta);
        printf("Значение из порта %x равно %x hex\n",
                                          porta, result);
        outp(porta,bytea);
        outp(portb,byteb);
      }
      /* Эта функция включает курсор IBM MDA. */
      #include <dos.h>
      int porta, portb, bytea, byteb;
      main()
      {
        porta = Ox3B4;
        portb = Ox3B5;
        bytea = 10;
        byteb = 11;
        outp(porta,bytea);
        outp(portb,byteb);
      }

      Эти функции не возвращают значения.


peek                                ПЕРЕСЛАТЬ БУФЕР ИЗДАЛЕКА

   Использование:

      void peek(unsigned seg, unsigned offset, void *buf,
                                              int numbytes);

   Описание:

      Пересылает  numbytes  байтов  из  памяти,   по  адресу
      seg:offset, в буфер по указателю buf.

   Возвращаемое значение:

      Нет возвращаемого значения.

   Рекомендация:

      Смотрите также poke.

   Пример:

      /* Эта программа воспримет как аргумент командной стро-
         ки on или off,  чтобы включить/выключить numlock. */
      #include <stdio.h>
      #include <string.h>
      main(int argc, char *argv[])
      {
        char state1, state2;
        int i;
        for (i=0; i<argc; i++)
           {
             strupr(argv[i]);
           }
        if ((strncmp(argv[1], "ON", 2)==0))
            {
              printf("Включаю numlock \n");
              peek(0,0x417,&state1,1);
              state1 |= 0x20;
              poke(0,0x417, &state1, 1);
            }
        else
           if ((strncmp(argv[1],"OFF",3)==0))
               {
                 printf("Выключаю numlock \n");
                 peek(0,0x417, &state1,1);
                 state1 &= ~0x20;
                 poke(0,0x417, &state1, 1);
               }
           else
             {
               printf("\n Введите ON или OFF как аргумент
                                       командной строки\n");
               exit(1);
             }
      }


perror                            ВЫДАТЬ СООБЩЕНИЕ ОБ ОШИБКЕ

   Использование:

      #include <stdlib.h>
      void perror(char *msg);                     /* ANSI */

   Описание:

      Воспроизводит  сообщение о последней  ошибке,  имевшей
      место при системном  вызове или обращении к библиотеч-
      ной функции, на стандартное устройство вывода. Печата-
      ется аргумент msg, затем двоеточие, затем сообщение об
      ошибке.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        FILE * fp;
        char *string = "Сообщение об ошибке";
        if ((fp=fopen("file.dat","r"))==NULL)
           perror(string);
        else
           printf("Файл открыт на чтение\n");
        fclose(fp);
      }

   Возвращаемое значение:

      Нет возвращаемого значения.

   Рекомендация:

      Смотрите также  strerror.



poke                                  ПЕРЕСЛАТЬ БУФЕР ДАЛЕКО

   Использование:

      void poke(unsigned seg, unsigned offset, void *buf,
                                              int numbytes);

   Описание:

      Пересылает numbytes байтов из буфера buf в память, за-
      данную полным адресом seg:offset.

      Возвращаемого значения нет.

   Рекомендация:

      Смотрите также  peek.

   Пример:

      /* смотрите пример для реек */
      #include <stdio.h>
      #include <string.h>
      main(int argc, char *argv[])
      {
        char state1, state2;
        int i;
        for (i=o; i<argc; i++)
            {
              strupr(argv[i]);
            }
        if ((strncmp(argv[1], "ON",2)==0))
           { printf("Numlock включен\n");
             peek(0,0x417, &state1,1);
             state1 |= 0x20;
             poke(0,0x417,&state1,1);
           }
        else
           if((strncmp(argv[1], "OFF",3)==0))
              { printf("Numblock выключен\n");
                peek(0,0x417, & state1,1);
                state1 &= ~0x20;
                poke(0,0x417,&state1,1);
              }
           else
              { printf("\n Введите ON или OFF как аргумент
                                       командной строки\n");
                exit(1);
              }
      }


poly                                                 ПОЛИНОМ

   Использование:

      #include <math.h>
      double poly(double x, int deg, double coeff[]);

   Описание:

      Вычисляет выражение вида:

         (...(x*coeff[deg]+coeff[deg-1])*x...)*x+coef[0].

   Пример:

      #include <stdio.h>
      #include <math.h>
      double coeff[4];
      main()
      {
        double x=1.2, y;
        coeff[0]=0.0;
        coeff[1]=1.0;
        coeff[2]=2.0;
        coeff[3]=3.0;
        y = poly(x,3,coeff);
        printf("Полином от %f равен %f\n", x, y);
      }

   Возвращаемое значение:

      Возвращает вычисленное значение.



pow                                                  СТЕПЕНЬ

   Использование:

      #include <math.h>
      double pow(double x, double y);             /* ANSI */

   Описание:

      Вычисляет значение x в степени y. Ошибка области опре-
      деления  имеет место в случае,  если x = 0 и y<=0 либо
      x<=0 и y не целое.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double x=3,y=2, result;
        result=pow(x,y);
        printf("%.2f в степени %.2f равно : %.2f\n",
                                               x,y,result);

   Возвращаемое значение:

      Возвращает вычисленное значение.

   Рекомендация:

      Смотрите также exp, log, sqrt.


printf, fprintf, sprintf                     ФОРМАТНЫЙ ВЫВОД

   Использование:

      #include <stdio.h>
      int fprintf(FILE *fp,char *format,...);     /* ANSI */
      int printf(char *format,...);               /* ANSI */
      int sprintf(char *buffer,char *format,...); /* ANSI */

   Описание:

      Осуществляют форматную печать.

         fprintf   -  пишет литеры в поток fp.
         printf    -  пишет литеры в поток stdout.
         sprintf   -  пишет литеры в память buffer.

      Аргументы  интерпретируются  в соответствии со строкой
      формата,  оканчивающейся 0.  Строка  формата  является
      последовательностью  литер  со  встроенными  командами
      преобразования.  Литеры,  не являющиеся частью команд,
      подлежат выводу. Команды преобразования состоят из :

┌────────────────────────────────────────────────────────────┐
│'%'{flag}[field_width]['.'precision][l или L]conversion_char│
└────────────────────────────────────────────────────────────┘

   где :

      %       Означает начало команды преобразования.
              Чтобы напечатать '%', надо использовать '%%'.

      flag characters     Литеры режимов

         -     - Означает необходимость выравнивания
                 информации по левому краю поля вывода.
         +     - Означает, что преобразование, включающее
                 знак, должно начинаться с + или -.
        пробел
       (space) - Означает, что в случае преобразования поло-
                 жительного  результат начинается с пробела.
                 Режим + перекрывает режим space.

         #     - Имеет смысл  для преобразования 'x' или 'X'
                 и приводит к добавлению перед  выводом сим-
                 волов 0x или 0X.
                 Для преобразования 'о' в вывод  добавляется
                 лидирующий ноль.
                 В случае преобразований e, E, f, g, G всег-
                 да появляется  десятичная  точка.  Если это
                 преобразование  g  или  G,  замыкающие 0 не
                 будут опускаться.

      Field_width      Ширина поля

         Десятичное целое, управляющее минимальным количест-
         вом печатаемых  литер.  Если  действительное  число
         литер меньше, чем  field_width,  это  число  допол-
         няется пробелами.  Если строка цифр field_width на-
         чинается с 0, для дополнения используется 0.

         Если field_width есть литера *, действительное зна-
         чение длины поля вывода берется из следующего цело-
         го аргумента. Если field_width отрицательно, счита-
         ется, что задан флаг '-',  а в качестве field_width
         берется  абсолютное  значение.  Если действительное
         число литер превосходит field_width, это поле соот-
         ветственно увеличивается.

      Precision    Точность

         Эта строка цифр, следующая за '.',  определяет точ-
         ность преобразования. Если цифры за точкой отсутст-
         вуют, точность равна 0.  Для  преобразования  целых
         точность есть минимальное количество выводимых цифр.
         Для 'g' и 'G'- это максимальное количество значащих
         цифр. Для 'e', 'E' и 'f'- это количество цифр после
         десятичной точки.  Для 's' - это максимальное коли-
         чество литер в строке. Если точность включает лиди-
         рующий 0, тогда свободное поле вывода заполняется 0.

      l

         В случае спецификаций преобразования o, b, u, x, X,
         i, d  используемый аргумент  должен быть типа long,
         исключение составляет преобразование p, когда аргу-
         мент должен  быть  дальним  указателем.  Для других
         преобразований этот флаг игнорируется.

      L

         Этот флаг игнорируется.

      Conversion_char    Преобразующая литера

         Это одна из литер  d, i, o, b, u, x, X, f, e, E, g,
         G, c, s, p, n, %.  Действие  других  литер  неопре-
         делено.

      d,i,o,b,u,x,X

         Соответсвующий целый аргумент преобразуется в стро-
         ку цифр, причем, 'o' производит беззнаковое восьме-
         ричное, `b' - беззнаковое двоичное, 'u' - беззнако-
         вое десятичное,  'x' и 'X' - беззнаковое шестнадца-
         тиричное,  'i' и 'd' - десятичное со знаком. В слу-
         чае  'x'  используются  строчные  цифры,   в случае
         'X' - заглавные.  Если не специфицирована точность,
         используется  умолчание 1.  Если  реально выводится
         меньше цифр,  чем определено  точностью,  вывод до-
         полняется  лидирующими  пробелами.  Если аргумент и
         точность равны 0, ничего не печатаются.

      c

         Младший значащий  байт  целого аргумента печатается
         как литера.

      e,E

         Аргумент типа  double  печатается,  используя пред-
         ставление ([-]d.dddddd+-dd). Здесь перед десятичной
         точкой одна цифра и precision цифр после. Умолчание
         для precision равно 6. Если precision 0, десятичная
         точка не печатается.  В экспоненте вместо 'e' будет
         использовано 'E',  если задана литера 'E'. В экспо-
         ненте присутствуют как минимум две цифры.

      f

         Аргумент  типа  double  печатается  в  виде  строки
         [-]dd.dddd.  Количество цифр после десятичной точки
         задается precision,  которое  по умолчанию равно 6.
         Если precision 0,  дробная часть и десятичная точка
         не печатаются.

      g,G

         Аргумент типа double  печатается c помощью  формата
         'f' или 'e'  (или 'E',  если  задан  'G'  формат) в
         зависимости от величины аргумента. 'e' используется,
         если  экспонента <  3  или  экспонента > precision.
         Precision задает количество значащих  цифр; умолча-
         ние  равно 6.  Десятичная  точка  появляется,  если
         предшествует цифре. Замыкающие 0 опускаются.

      n

         Аргумент  является  указателем на целое,  в которое
         записывается количество цифр,  напечатанных к этому
         моменту. Никакие литеры не печатаются и не преобра-
         зуются.

      p

         Аргумент  является  указателем,  значение  которого
         (адрес) печатается в виде  segment:offset для даль-
         него указателя  или в виде XXXX для ближнего указа-
         теля.

      s

       Аргумент является указателем на строку.  Литеры печа-
       таются до замыкающего 0, или до исчерпания литер, ко-
       личество которых задано precision. Умолчание precision
       равно 32767. Замыкающий 0 не печатается.

    %

       Печатается литера '%'.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        char * msg="Целыми форматами являются:";
        int number=10;
        double num=345.2356;
        printf("%s Hex: 0%x, Decimal:%d, Octal: %o\n",
                         msg, number, number, number);
        printf("\n Точность плавающей точки
                 для PI: %.2f, %.4f, %.8f\n", PI,PI,PI);
        printf("\n %.4f Экспоненциальный формат : %E\n",
                                                   num,num);
      }

   Возвращаемое значение:

      Возвращает количество  напечатанных  литер.  Если име-
      ла место ошибка, возвращаемое значение отрицательно.

   Рекомендация:

      Смотрите также scanf, vprintf, vsprintf, vfprintf.


putc, putchar                            ВЫВОД ЛИТЕРЫ В ФАЙЛ

   Использование:

      #include <stdio.h>
      int putc(int c, FILE *fp);                  /* ANSI */
      int putchar(int c);                         /* ANSI */

   Описание:

      Записывает  литеру 'c' в поток  fp (putc) или в stdout
      (putchar).

   Пример:

      #include <stdio.h>
      main()
      {
        char *string = "Это пример для putc()";
        int i, ch;
        for (i=0; (i<strlen(string))&&((ch=putc(string[i],
                                      stdout)) !=EOF); i++);
             putchar('.');
        putchar('\n');
      }

   Возвращаемое значение:

      Возвращает записанную литеру или EOF в случае ошибки
      записи.

   Рекомендация:

      Смотрите также fputc, getc, getchar.


puts                                     ВЫВОД СТРОКИ В ФАЙЛ

   Использование:

      #include <stdio.h>
      int puts(char *s);                          /* ANSI */

   Описание:

      Записывает строку s в поток stdout ( без завершающе-
      го 0 ), затем записывает newline.
   Пример:

      #include <stdio.h>
      main()
      {
        char *string="Выводим эту строку посредством puts(),";
        char *string2="Puts вставляет литеру newline.";
        puts(string);
        puts(string2);
      }

   Возвращаемое значение:

      Возвращает положительное значение, либо EOF в случае
      ошибки.

   Рекомендация:

      Смотрите также fputs, gets.



qsort                           БЫСТРАЯ СОРТИРОВКА ТАБЛИЦЫ

   Использование:

      #include <stdio.h>
      void qsort(void *base, unsigned nel, unsigned size,
                 int (*compar)(void *, void *));  /* ANSI */

   Описание:

      Реализует быструю сортировку таблицы данных.

         base   -  указатель на таблицу.
         nel    -  количество элементов таблицы.
         size   -  размер в байтах элемента таблицы.
         compar -  имя функции, реализующей алгоритм сравне-
                   ния двух аргументов, заданных указателями.
                   Функция поставляется программистом и долж-
                   на возвращать целое, которое меньше, рав-
                   но или больше 0 в соответствии с резуль-
                   татом сравнения двух аргументов.

   Возвращаемое значение:

      Нет возвращаемого значения.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      #include <string.h>
      #define MAXL 10
      unsigned char *line[MAXL];
      comp(unsigned char **a, unsigned char **b);
      {
        return strcmp(*a, *b);
      }
      main()
      {
        int j,k;
        unsigned char buffer[82];
        printf("Введите 10 строк данных\n");
        for (j=0; j<MAXL; ++j)
           {
             printf("Строка: %d\n", j+1);
             if (!fgets(buffer,80,stdin))
                 break;
             line[j]=malloc(strlen(buffer)+1);
             strcpy(line[j],buffer);
           }
        printf("\n\n Сортируем 10 строк из stdin:\n");
        qsort(line, j, sizeof(unsigned char *), comp);
        for (k=0; k<j; ++k)
           printf("Строка: %d%s\n", k+1,line[k]);
      }


raise                                       ВОЗБУДИТЬ СИГНАЛ

   Использование:

      #include <signal.h>
      int raise(int sig);                         /* ANSI */

   Описание:

      Вырабатывает сигнал в выполняемой программе. Тип sig
      сигнала обсуждается в описании функции signal(). По
      сигналу вызывается текущая процедура обработки сигна-
      лов. Полное описание дано для функции signal().

   Возвращаемое значение:

      Возвращает 0 или значение, отличное от 0, в случае не-
      удачи.

   Рекомендация:

      Смотрите также signal.

   Пример:

      #include <signal.h>
      #include <stdio.h>
      void div_zero(int val);
      {
        printf("Возникло деление на 0\n");
        exit(0);
      }
      main()
      {
        float numerator = 3.0;
        float denominator = 0.0;
        if (signal(SIGFPE,&div_zero)==SIG_ERR)
           {
             printf("Не могу установить SIGFPE!\n");
             abort();
           }
        if (denominator==0)
           raise(SIGFPE);
        else
           printf("Результат деления равен %f\n",
                                     numerator/denominator);
      }


rand                                      СЛУЧАЙНАЯ ВЕЛИЧИНА

   Использование:

      #include <stdlib.h>
      int rand(void);                             /* ANSI */

   Описание:

      rand  возвращает  случайное  число в диапазоне от 0 до
      32767. Смотрите далее описание srand.

   Возвращаемое значение:

      Возвращает целый (int) результат.

   Рекомендация:

      Смотрите также srand.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        int i;
        for(i=0; i<20; i++);
        printf("i: %d rand(): %d\n", i, rand());
      }

read                                    ЧИТАТЬ БЛОК ИЗ ФАЙЛА

   Использование:

      #include <io.h>
      int read (unsigned fd, void *buffer, unsigned length);

   Описание:

      Системный вызов  read  берет  (читает)  очередной блок
      литер из файла,  связанного с дескриптором  файла  fd.
      Число байтов,  считываемых в буфер buffer определяется
      параметром length. Пересылка производится без преобра-
      зований (это обращение к MS DOS).

   Возвращаемое значение:

      Возвращает число реально считанных литер,  которое мо-
      жет быть меньше,  чем   length,  если встретился конец
      файла. Если произошла ошибка чтения, возвращается зна-
      чение -1 и устанавливается errno.

   Рекомендация:

      Смотрите также fread, open, write.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      #include <dos.h>
      #include <io.h>
      #define BYTECOUNT 255
      main()
      {
        char *buffer;
        int fd, numread, count;
        if (( fd = open("file.dat", O_RDONLY))== -1)
          {
            perror("open failed on file file.dat");
            exit(1);
          }
        buffer = malloc(BYTECOUNT+1);
        for (count = 0; count < BYTECOUNT; count++)
             buffer[count]=`\0';
        numread = read(fd, buffer, BYTECOUNT);
        printf("/n Число считанных литер %d\n",numread);
        close(fd);
        free(buffer);
      }


realloc                           ПЕРЕРАЗМЕСТИТЬ БЛОК ПАМЯТИ

   Использование:

      #include <stdlib.h>
      void *realloc(void *ptr, unsigned size);     /* ANSI */

   Описание:

      realloc изменяет размер ранее выделенного  блока памя-
      ти, на который указывает ptr. Размер этого блока после
      обращения к realloc определяется параметром size. Если
      size равен 0,  блок освобождается и возвращается NULL.
      Если ptr равен  NULL,  то отводится  (по malloc)  size
      байтов памяти и возвращается  указатель на этот массив
      памяти.  Если для расширения  текущего  блока места не
      хватает, будет размещен новый блок, а текущий блок ос-
      вободится. Текущие данные перепишутся в новый блок.

   Возвращаемое значение:

      Возвращается  указатель на переразмещенный  блок памя-
      ти. Если нет подходящей памяти для выполнения realloc,
      возвращается NULL (но память по ptr не освобождается).

   Рекомендация:

      Смотрите также  calloc, free, malloc.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      #include <string.h>
      main()
      {
        char *ptr;
        ptr = realloc(NULL, 20*sizeof(char));
        strcpy(ptr, "Это первая часть, ");
        ptr = realloc(ptr, 100*sizeof(char));
        strcat(ptr, "Это вторая часть);
        printf("%s\n", ptr);
        realloc(ptr, 0);
      }


rename  		                  ПЕРЕИМЕНОВАТЬ ФАЙЛ

   Использование:

      #include <stdio.h>
      rename (char *oldname, char *newname);       /* ANSI */

   Описание:

      Заменяет у файла  oldname  это  имя  на  newname.  Как
      oldname,  так и newname могут содержать имя устройства
      и маршруты, но оба имени должны ссылаться на одно и то
      же устройство.


   Пример:

      #include <stdio.h>
      #include <io.h>
      main()
      {
        int return_code;
        char *oldname, *newname;
        oldname = "data.fil";
        newname = "file.dat";
        return_code = rename(oldname, newname);
        printf("\n%s %s renamed to %s\n", oldname,
             return_code == 0 ? "was": "was not", newname);
      }

   Возвращаемое значение:

      rename возвращает 0, если имя файла было успешно изме-
      нено, и ненулевое значение,  если замена не произошла,
      устанавливая при этом errno.


rewind			 УСТАНОВИТЬ УКАЗАТЕЛЬ ФАЙЛА В НАЧАЛО

   Использование:

      #include <stdio.h>
      void rewind(FILE *fp);                      /* ANSI */

   Описание:

      rewind устанавливает указатель файла,  связанный с по-
      током, в его начало.  Это  эквивалентно  использованию
      fseek(fp, 0L, SEEK_SET)  с  очищенным   флагом  ошибок
      для fp.

   Пример:

      #include <stdio.h>
      main()
      {
        FILE *fp;
        char *string = "String one, example string";
        char *string2 = "xxxxxxxxxxxxxx";
        fp = fopen("file.dat", "w+");
        fprintf(fp, "%s, &string);
        rewind(fp);
        fscanf(fp, "%s", &string2);
        printf("Из файла назад прочли: %s\n", string2);
      }

   Возвращаемое значение:

      rewind ничего не возвращает.

   Рекомендация:

      Смотрите также  fseek.


rmdir					     УДАЛИТЬ КАТАЛОГ

   Использование:

      #include <direct.h>
      int rmdir(char *pathname);

   Описание:

      rmdir   удаляет   каталог,   определенный   аргументом
      pathname.  Каталог  должен быть пустым и не может быть
      корневым каталогом или текущим рабочим каталогом.  Все
      промежуточные каталоги также должны существовать.

   Пример:

      #include <stdio.h>
      #include <direct.h>
      main()
      {
        int result;
        result = rmdir("\\temp");
        if (result == 0)
            printf("Каталог \\temp удален\n");
        else
            printf("Не смогли удалить каталог \\temp \n")];
      }

   Возвращаемое значение:

      Функция  rmdir возвращает 0,  если каталог был удален.
      Возвращенное значение -1 означает ошибку, при этом ус-
      танавливается errno.

   Рекомендация:

      Смотрите также  mkdir, chdir.



sbrk                                УВЕЛИЧИТЬ СЕГМЕНТ ДАННЫХ

   Использование:

      void *sbrk(unsigned count);

   Описание:

      sbrk пытается расширить сегмент данных на число байтов,
      указанных в count. При успешном завершении возвращает-
      ся указатель на добавленную память, в противном случае
      возвращается -1.  Для T,S и M моделей памяти,  если не
      была объявлена переменная _okbigbuf,  то вся доступная
      память, размером до 64 Кб,  присоединяется при запуске
      программы и sbrk будет всегда сбоить  (т.е. возвращать
      -1). Если переменная _okbigbuf объявлена в программе и
      инициализирована 0,  то в  'куче'  размещаетсят только
      требуемая программе память и здесь полезна sbrk.

      Для C и L моделей памяти,  если sbrk() не может расши-
      рить сегмент данных,  она будет пытаться  присоединить
      новый сегмент.

            sbrk()  является общей частью функций  calloc(),
            malloc() и realloc().
            Приложениям  следует  избегать  использовать эту
            функцию.

   Возвращаемое значение:

      Если не хватило  памяти  для  удовлетворения  запроса,
      sbrk возвращает -1  и  устанавливает   errno.  В про-
      тивном случае возвращается указатель на блок памяти.

   Рекомендация:

      Смотрите также  calloc, free, malloc, realloc.


   Пример:

      #include <string.h>
      #include <stdio.h>
      void *sbrk(int);
      main()
      {
        unsigned int count = 100;
        char *ptr;
        ptr = sbrk(count);
        if (ptr == (char *)-1)
            {
              perror("No available space for sbrk\n");
              return;
            }
        strcpy(ptr, "String of data:");
        strcat(ptr, "another string added\n");
        fputs(ptr, stdout);
      }


scanf                                         ФОРМАТНЫЙ ВВОД

   Использование:

      #include <stdio.h>
      int scanf(char *format,...);                /* ANSI */
      int fscanf(FILE *fp, char *format,...);     /* ANSI */
      int sscanf(char *buffer, char *format,...); /* ANSI */

   Описание:

      Это процедуры форматного ввода.  Многоточия обозначают
      аргументы (от 0 и более), которые являются указателями
      на переменные для ввода информации;

      fscanf   читает из входного потока fp.
      scanf    читает из stdin.
      sscanf   читает из указанного буфера buffer. Считывае-
               мые  литеры  преобразуются  в  соответствии с
               форматной строкой, и эти преобразованные зна-
               чения размещаются по аргументам-указателям.

      Аргументы должны  быть  указателями  на то, куда будут
      записываться значения.

      Форматная строка состоит из:

         1. Пробелов,  литер  табуляции  и новой строки, ко-
            торые вызывают  пропуск ввода  до  следующей, не
            'белой' (whitespace) литеры.
         2. Других литер,  кроме  литеры %,  которые "один в
            один" переправляются во ввод.
         3. Спецификаций  преобразования,  которые  выглядят
            следующим образом:

    ┌──────────────────────────────────────────────────────┐
    │ '%'['*'][ширина поля][точность]литера преобразования │
    └──────────────────────────────────────────────────────┘

      Эта строка определяет,  каким образом вводимые символы
      должны  преобразовываться и записываться  по  соответ-
      ствующим аргументам-указателям. Преобразование продол-
      жается до первой неподходящей  входной  литеры или ис-
      черпания ширины поля.
      Символ '*' является флагом подавления присваивания. Он
      вызывает выполнение преобразования, но результат игно-
      рируется и для него не нужен соответствующий аргумент-
      -указатель.
      Если  число  аргументов-указателей меньше спецификаций
      преобразования, результат непредсказуем. Если же число
      аргументов-указателей больше, лишние указатели игнори-
      руются.

      Ширина поля (field_width)
      ────────────────────────
         Это последовательность десятичных цифр,  определяю-
         щая максимальное число литер в поле ввода.

      Точность (precision)
      ────────────────────
         L или l (Нижний регистр L)
            Если 'l' используется с одной из (d, i, o, u, x)
            литер преобразования, то она означает, что аргу-
            мент является указателем на long, а не на int. l
            или L флаг,  при использовании (e) или (f) литер
            преобразования, означает,  что аргумент является
            указателем на double, а не на float.

         h  Аргумент является указателем на short.

      Литера преобразования (conv_char)
      ─────────────────────────────────
         К литерам преобразования относятся:

      d          Ожидается   ввод  целого  числа,  аргумент-
                 -указатель должен быть  указателем  на int.

      e,f,g,E,G  Ожидается ввод числа с плавающей  за пятой.
                 Формат числа такой же, как и в Cи.
                 Аргумент должен  быть указателем  на  float
                 (или double, если используется 'l' или 'L').

      i          Ожидается ввод целого числа. Если число на-
                 чинается с 0, оно воспринимается как восьме-
                 ричное.  Если число начинается с 0x или 0X,
                 оно шестнадцатиричное. Аргумент должен быть
                 указателем на int.

      b          Ожидается ввод  двоичного  числа.  Аргумент
                 должен быть указателем на целое.

      o          Ожидается ввод  восьмеричного числа.  Аргу-
                 мент должен быть указателем на int.

      x,X        Ожидается   ввод  шестнадцатиричного  числа
                 (адреса).  Аргумент  должен быть указателем
                 на int.

      p          Ожидается  ввод  шестнадцатиричного  числа.
                 Аргумент  должен быть указателем  на указа-
                 тель.

      u          Ожидается ввод  беззнакового  целого числа.
                 Аргумент должен быть указателем на unsigned.

      n          По указателю, заданному аргументом, записы-
                 вается число  литер,  считанных к этому мо-
                 менту при этом обращении к scanf().

      [          Ожидается  ввод  строки  литер.  Между  [ и
                 закрывающей ] должны быть литеры,  допусти-
                 мые в этой строке.  Если за скобкой [ сразу
                 следует литера^,  допустимыми литерами вво-
                 димой  строки  являются  все за исключением
                 перечисленных между ^ и ].  Аргумент должен
                 быть  указателем на строку.  В конце строки
                 добавляется 0.

      s          Ожидается  ввод строки литер. Аргумент дол-
                 жен быть  указателем  на строку.  Поле вво-
                 да заполняется до тех пор, пока не считает-
                 ся пробел или литера новой строки,  которые
                 не  являются  частью  поля  ввода.  К концу
                 строки добавляется 0.

      c          Ожидается ввод литеры. Аргумент должен быть
                 указателем на литеру. Если определена шири-
                 на поля (field_width), то считывается опре-
                 деленное  шириной  поля число литер и аргу-
                 мент в этом случае должен  быть  указателем
                 на массив литер, достаточный для размещения
                 результата.

      %          Соответствует вводу литеры %.

         Символы преобразования e, g и x  могут быть заглав-
         ными.  Другие же символы будут давать непредсказуе-
         мые результаты. Неподходящие литеры остаются непро-
         читанными из входного потока.  Нет прямого пути оп-
         ределения  того,  достигнуты ли точные соответствия
         или были подавления присваиваний, кроме использова-
         ния символа преобразования %n.

   Пример:

      #include <stdio.h>
      main()
      {
        unsigned int result, val;
        printf("Введите десятичное число:");
        result = scanf("%i", &val);
        printf("The decimal number [%d] is [%4x]
                    hexadecimal", val, val);
      }

   Возвращаемое значение:

      Возвращается число присвоенных элементов ввода, исклю-
      чая преобразования с подавленным  присваиванием.  Если
      встречается конец  файла  до того,  как были выполнены
      какие-либо присваивания и возникли какие-либо конфлик-
      ты  (формата  и  ввода),  возвращается  значение  EOF.
      Scanf() обычно завершает работу, когда достигает конца
      строки формата.

   Рекомендация:

      Смотрите также printf, fscanf, sscanf



segread                           ЧИТАТЬ СЕГМЕНТНЫЕ РЕГИСТРЫ

   Использование:

      #include <dos.h>              /* структуры регистров*/
      void segread (struct SREGS *segregs);

   Описание:

      Считывает значения сегментных  регистров и помещает их
      в SREGS.

   Пример:

      #include <dos.h>
      #include <stdio.h>
      struct SREGS segregs;
      unsigned code_seg, data_seg, stack_seg, extra_seg;
      main()
      {
        segread(&segregs);
        code_seg = segregs.cs;
        stack_seg = segregs.ss;
        data_seg = segregs.ds;
        extra_seg = segregs.es;
        printf("\n Регистры сегментов сейчас содержат:\n");
        printf("\n CS: %4x\nDS: %4x\nSS: %4X\nES: %4x\n",
                code_seg, data_seg, stack_seg, extra_seg);
      }

   Возвращаемое значение:

      Нет.

   Рекомендация:

      Смотрите также intdosx, int86x, getDS.


setbuf                                  УСТАНОВИТЬ БУФЕР В/В

   Использование:

      #include <stdio.h>
      void setbuf(FILE *stream, char *buffer);    /* ANSI */

   Описание:

      Функция  setbuf задает буфер для считывания или записи
      байтов в поток. Если аргумент buffer равен NULL, поток
      не буферизован.  Если же  buffer не равен NULL,  то он
      является указателем на буфер,  который будет использо-
      ваться в последующих вызовах read и write. buffer дол-
      жен  указывать  на  литерный  массив  размером  BUFSIZ
      (BUFSIZ определен в stdio.h). Определенный пользовате-
      лем буфер используется потом вместо  размещенного сис-
      темой по умолчанию буфера ввода/вывода.

   Пример:

      #include <stdio.h>
      char buffer [BUFSIZ];
      FILE *fp;
      main()
      {
        fp = fopen("file.dat", "r");
        setbuf(fp, buffer);
        printf("Теперь поток пркреплен к буферу \n");
      }

   Возвращаемое значение:

      Нет.

   Рекомендация:

      Смотрите также setvbuf.


setjmp                    УСТАНОВИТЬ ТОЧКУ ДЛИННОГО ПЕРЕХОДА

   Использование:

      #include <setjmp.h>
      int setjmp(jmp_buf env);                    /* ANSI */

   Описание:

      Смотрите описание longjmp.


setvbuf                                 УСТАНОВИТЬ БУФЕР В/В

   Использование:

      #include <stdio.h>                           /* ANSI */
      int setvbuf(FILE *fp, char *buf,int mode,size_t size);

   Описание:

      Функция setvbuf определяет тип и размер буфера, исполь-
      зуемого для потока. В дополнение к параметрам функции,
      следующая глобальная переменная  воздействует на пове-
      дение этой функции:

    _okbigbuf

      Эта переменная используется только в  T, S и M моделях
      памяти и управляет размещением буферов,  когда buf ра-
      вен NULL.  Эта  перемнная  статически инициализируется
      в 0 или 1 программистом (по умолчанию в библиотеке ус-
      танавливается  значение 1).  Если  _okbigbuf равна 1 и
      модель памяти T, S или M,  то setvbuf()  пытается рас-
      положить буфер вне сегмента данных. Если это не выпол-
      няется и size <= BUFSIZ, setvbuf() пытается разместить
      буфер внутри сегмента данных.
      Буфер, который находится вне сегмента данных,  помеча-
      ется установкой  флага  _IOBIGBUF  в fp─>_flags.  Если
      _okbigbuf  равна  0  или  модель  памяти  C или L,  то
      setvbuf() пытается  разместить буфер  внутри  сегмента
      данных.  Буфер, размещенный посредством setvbuf(), по-
      мечается установкой флага _IOMYBUF в fp─>flags.  Смот-
      рите параграф под названием  Глобальные Переменные для
      более подробной информации по _okbigbuf.

    Параметры функции следующие:

      fp      Указатель на поток,  который уже открыт,  но в
              котором еще не было  никаких  операций  чтения
              или записи.

      buf     Указатель на буфер  или  NULL.  Если  NULL, то
              setvbuf() использует  malloc() или farmalloc(),
              чтобы  попытаться  разместить  буфер  размером
              size байт. Если buf не равен NULL, он указыва-
              ет на буфер, который setvbuf() будет связывать
              с потоком fp.

      mode    Режим; должен быть одним из следующих значений:

            _IONBF    Нет буферизации.  Параметры buf и size
                      игнорируются. Небуферизованный ввод/вы-
                      вод означает,  что  записанные  данные
                      немедленно передаются в DOS. Когда дан-
                      ные   читаются,   считывается  столько,
                      сколько требуется.

            _IOLBF    Выполняется  строчная буферизация. Ре-
                      ально  ввод/вывод  выполняется,  когда
                      читается или записывается новая строка.

            _IOFBF    Полная буферизация. Данные считываются
                      сразу целым буфером.  Данные записыва-
                      ются только по заполнению буфера.

      size    Если buf равен NULL,  то size - это число бай-
              тов размещаемого  буфера.  Если  buf  не равен
              NULL,  то size должен быть числом байтов в бу-
              фере, на который указывает buf.

   Возвращаемое значение:

      При успешном  завершении  различные  поля,  на которые
      ссылается fp, модернизируются,  чтобы указывать на бу-
      фер и возвращается 0. Если недостаточно памяти под бу-
      фер или параметр mode недопустим, возвращается ненуле-
      вое значение.


   Пример:

      #include <stdio.h>
      main(argc, argv)
      int argc;
      char *argv[];
      {
        FILE *fp;
        static char buf [100];
                       /* сделаем stdprn небуферизованным */
        setvbuf(srdprn, NULL, _IONBF, 0);
        fprintf(stdprn, "unbuffered\n");
        if (argc == 2)              /* есть один аргумент */
            fp = fopen(argv[1], "w");
        else
            fp = stdout;  /* используем стандартный вывод */
        if (setvbuf(fp,buf,_IOLBF,sizeof(buf)))
            printf("setvbuf сработал неудачно\n");
        else
          {
            fprintf(fp, "Это передается в fp\n");
            fclose(fp);
          }
      }

   Рекомендация:

      Смотрите также setbuf.


signal                          УСТАНОВИТЬ РЕАКЦИЮ НА СИГНАЛ

   Использование:

      #include <signal.h>
      void (*signal(int sig, void (*func)(int)))(int);

   Описание:

      Функция  signal  позволяет  программе  определить, как
      следует обрабатывать сигналы от операционной  системы.
      Аргумент sig должен быть одной из следующих констант :

         SIGABRT       Ненормальное завершение

         SIGFPE        Ошибка арифметики с плаваюшей точкой

         SIGILL        Неверная инструкция (команда ЦП)

         SIGINT        Прерывание CTRL+C

         SIGSEGV       Нарушение границ сегмента

         SIGTERM       Завершение по CTRL+break

      Нижеописанные  макросы  определяют значения для  func:

         SIG_DFL       Обработка сигнала по умолчанию

         SIG_IGN       Игнорирование сигнала

      Функция  signal  устанавливает ответ на сигнал.  Когда
      возникает сигнал, вначале режим обработки этого сигна-
      ла устанавливается в SIG_DFL, а затем вызывается функ-
      ция  обработки  сигнала  func  и  ей  передается пара-
      метр sig.

   Пример:

      #include <stdio.h>
      #include <signal.h>
                   /* ниже наша функция обработки сигнала */
      void ctrl_break(int val)
      {
        signal (SIGINT, SIG_IGN);
        printf("Для завершен : ");
        getch();
        exit(0);
      }
      main()
      {
        if (signal(SIGINT,(&ctrl_break)) == SIG_ERR)
            {
              perror("Не смог установить SIGINT!");
              abort();
            }
        raise(SIGINT);
      }

   Возвращаемое значение:

      signal возвращает предыдущее значение func. Возвращае-
      мое значение SIG_ERR указывает на ошибку и errno прис-
      ваивается положительное значение.

   Рекомендация:

      Смотрите также  raise.


sin, sinh                       СИНУС, СИНУС ГИПЕРБОЛИЧЕСКИЙ

   Использование:

      #include <math.h>
      double sinh(double x);                      /* ANSI */
      double sin (double x);                      /* ANSI */

   Описание:

      Функции sin и sinh  возвращают синус и гиперболический
      синус аргумента x. Для sin  x задается в радианах.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double x = 4.3, d;
        d = sin (x);
        printf("The sine of (%d)is (%d)/\n", x, d);
        d = sinh(x);
        printf("The hyperbolic sine of (%d) is (%d)\n",x,d);
      }

   Возвращаемое значение:

      sin возвращает  синус  аргумента x.   sinh  возвращает
      гиперболический синус аргумента x.


Sound Package                        Пакет работы со звуком

   Использование:

      #include <sound.h>
      void sound_tone(int cycles, int uptime, int dntime);
      void sound_beep(int freg);
      void sound_click();

   Описание:

      sound_tone   генерирует тона. Задаются число циклов и
                   временные интервалы.
      sound_beep   заставляет динамик 'гудеть'.
                 Частота 1000 Hz приблизительно соответствует
                 1331 для параметра freg.
      sound_click  заставляет динамик 'щелкнуть'.

   Пример:

      #include <stdio.h>
      #include <sound.h>
      main()
      {
        int cycles=5000, uptime=50, dntime=50, freg=1331;
        char ch;
        printf("Sound using sound_click\n");
        sound_click();
        printf("Press any key:");
        ch = getch();
        printf("\nSound using sound_tone\n");
        sound_tone(cycles, uptime, dntime);
        printf("Press any key:");
        ch = getch();
        printf("\nSound using sound_beep\n");
        sound_beep(freg);
      }


spawn                                        СОЗДАТЬ ПРОЦЕСС

   Использование:

      #include <process.h>
      int spawnl(int mode, char *pathname,
                char *arg0, *arg1, ... , *argn, NULL);
      int spawnlp(int mode, char *filename,
                  char *arg0, *arg1, ... , *argn, NULL);
      int spawnv(int mode, char *pathname, char *argv[]);
      int spawnvp(int mode, char *filename, char *argv[]);

   Описание:

      Системный вызов  spawn  создает и исполняет новый про-
      цесс - потомок. Более просто - запускается новая прог-
      рамма и затем старая программа продолжается. Системный
      вызов работает подобно вызову подпрограммы.
      Создание нового  подпроцесса требует наличия свободной
      памяти, доступной для исполнения порожденного процесса,
      наряду с той, что занята текущей программой.  Смотрите
      введение в этот раздел руководства, где описана работа
      с памятью при вызове spawn. Флаг mode игнорируется. Он,
      возможно,  будет использоваться в последующих версиях.
      Для mode используйте значение 0.
      Аргумент  filename  определяет  запускаемую программу.
      Только для spawnlp и spawnvp: если  filename не содер-
      жит маршрута и не находится в текущем каталоге, то для
      поиска файла  используется  переменная окружения PATH.
      Argv[0]  не передается подпроцессу и используется лишь
      для  совместимости,  но в целях  переносимости  должен
      быть всегда  включен. Этот параметр должен быть именем
      запускаемой программы.
      Командная строка,  передаваемая порождаемой программе,
      составляется из символьных строк в spawn вызове,  пер-
      вая строка - это  arg1  и т.д.  Общая длина этих строк
      не должна превышать 128 символов.
      Аргумент argv, используемый в вызовах spawnv и spawnp,
      является массивом указателей на char. Последний указа-
      тель в argv должен быть NULL для индикации конца спис-
      ка.

   Пример:

      #include <stdio.h>
      main()
      {
        char *args[4];
        args[0] = "ztc1.exe";
        args[1] = "stuff";
        args[2] = "morestuff";
        args[3] = NULL;
        if (spawnv(0, "C:ZTC1.EXE", args) == -1)
            fprintf(stderr, "exec failed!\n");
      }

   Возвращаемое значение:

      Возвращаемое значение дает статус завершения порожден-
      ной программы. Значение 0 говорит о том, что порожден-
      ная программа выполнилась успешно.  Положительное зна-
      чение говорит о том,  что порожденная программа испол-
      нилась,  но была сброшена или завершилась из-за ошибки
      исполнения;  возвращаемое  значение  является статусом
      завершения порожденного процесса. Отрицательное значе-
      ние говорит  о том,  что  порожденный  процесс  не был
      исполнен, и устанавливается errno.

   Рекомендация:

      Смотрите также abort, exit, exec, system.


sprintf                              ФОРМАТНЫЙ ВЫВОД В БУФЕР

   Использование:

      #include <stdio.h>                          /* ANSI */
      int sprintf(char *buffer, char *format, ...);

   Описание:  Смотрите printf.


sqrt                                       КВАДРАТНЫЙ КОРЕНЬ

   Использование:

      #include <math.h>
      double sqrt(double x);                      /* ANSI */

   Описание:

      Функция sqrt возвращает квадратный корень аргумента x.
      Если x  отрицательное  число,  то возникает ошибка об-
      ласти определения  (domain error).

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double x;
        for (x=1.0; x<=20.0; ++x)
             printf("The square root of %.4f is %.4f\n",
                                                x, sqrt(x));
      }

   Возвращаемое значение:

      sqrt возвращает результат типа double.

   Рекомендация:  Смотрите также exp, log, pow.


srand                       ИНИЦИАЛИЗАЦИЯ СЛУЧАЙНОЙ ВЕЛИЧИНЫ

   Использование:

      #include <stdlib.h>
      void srand(unsigned seed);                  /* ANSI */

   Описание:

      srand инициализирует  ("засевает" начальным значением)
      генератор случайных чисел (rand()). Если srand() никог-
      да не вызывалось,  то подразумевается, что  вызывалась
      srand(1).

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      main()
      {
        int i;
        srand(9);
        for (i=0; i<20; i++)
             printf("i: %d rand(): %d\n", i, rand());
      }

   Возвращаемое значение:

      Нет.

   Рекомендация:

      Смотрите также rand.


sscanf                             ФОРМАТНЫЙ ВЫВОД ИЗ БУФЕРА

   Использование:

      #include <stdio.h>
      int sscanf(char *buffer, char *format,...); /* ANSI */

   Описание:

      Смотрите функцию scanf.

   Пример:

      #include <stdio.h>
      char *string = "1.24...";
      char str[8];
      float fp;
      int i;
      main()
      {
        sscanf(string, "%s", str);
        sscanf(string, "%f", &fp);
        sscanf(string, "%d", &i);
        printf("String : %s\n", str);
        printf("Float : %f\n", fp);
        printf("Integer : %d\n", i);
      }



stat                                     ЧИТАТЬ СТАТУС ФАЙЛА

   Использование:

      #include <sys\stat.h>
      int stat(char *path, struct stat *buf);

   Описание:

      Функция stat  берет  информацию  о файле или каталоге,
      определенном параметром path, и помещает ее в структу-
      ру, на которую указывает buf.  Описание структуры типа
      stat смотрите в функции fstat.

   Возвращаемое значение:

      stat  возвращает 0,  если информация о состоянии файла
      или каталога восстановлена. При ошибке функция возвра-
      щает -1 и устанавливает errno в ENOENT, что указывает
      на плохой маршрут.

   Рекомендация:

      Смотрите также: fstat, filesize.

         ЗАМЕЧАНИЕ:  stat и  fstat  не могут быть вызваны из
                     C++ файла,  потому  что  есть  конфликт
                     имен между функцией int stat() и струк-
                     турой struct stat.  Если Вам необходимы
                     эти  функции,   использование   stat.h,
                     fstat() и stat()  должно  быть выделено
                     в C файл.

   Пример:

      #include <stdio.h>
      #include <time.h>
      #include <sys\stat.h>
      #include <string.h>
      #include <stdlib.h>
      main()
      {
        char *date;
        int ret;
        struct stat buf;
        if ((ret = stat("file.dat", &buf))!=0)
          {
            fprintf(stderr, "stat failure error .%d", ret);
            abort();
          }
        date = asctime(localtime(&buf.st_ctime));
        printf("\n %s\n", date);
        printf("\n %d mode\n", buf.st_mode);
        printf("\n %ld size\n", buf.st_size);
      }


strcat - strdup                           Работа со строками

   Использование:

      #include <string.h>
      char *strcat(char *string1, const char *string2);
                                                  /* ANSI */
      char *strchr(const char *string, int ch);   /* ANSI */
      int strcmp(const char *string1, const char *string2);
                                                  /* ANSI */
      int strcmpl(const char *string1, const char *string2);
      int *strcpy(char *string1, const char *string2);
                                                  /* ANSI */
      size_t strcspn(const char *string1,
                                       const char *string2);
                                                  /* ANSI */
      char *strdup(const char *string);

   Описание:

      strcat    Добавляет  копию   string2  в  конец  строки
                string1.  Прикладная  программа ответственна
                за то, что в строке имеется достаточно прост-
                ранства для размещения  результата.  Функция
                возвращает string1.

      strchr    Ищет первое  появление  литеры  ch  в строке
                string.  Возвращает  указатель на литеру ch.
                Возвращается  NULL,  если литера в строке не
                найдена. Функция  strchr  идентична  функции
                index().

      strcmp    Посимвольно  сравнивает  две строки,  strcmp
                возвращает:

                   <0,   если string1 меньше string2
                   =0,   если string1 равно  string2
                   >0,   если string1 больше string2

      strcmpl   Сравнивает две строки,  трактуя  литеры ниж-
                него и верхнего регистра как одинаковые.

      strcpy    Копирует строку  string2 в string1,  включая
                завершающую литеру '\0'. Возвращает string1.

      strcspn   Исследует строку string1 на первое появление
                литеры из строки string2.  Возвращает  длину
                начального сегмента строки string1,  состоя-
                щего из литер, не найденных в строке string2.
                Если ни одна из литер строки string1 не появ-
                ляется в string2,  возвращается  общая длина
                строки string1 без завершающей литеры '\0'.

      strdup    Присоединяет память при помощи вызова malloc,
                копирует  в  нее строку  string  и возвращает
                указатель на присоединенную память.  Функция
                возвращает  NULL,  если память не может быть
                отведена.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char string1[50] = " 1 Example string ";
      char string2[50] = " 2 Example string ";
      char buffer[50] = " Rubbish - string ";
      main()
      {
        printf("strcat example [%s]\n",
                                  strcat(string1, string2));
        printf("strchr example [%s]\n",
                                  strchr(string1, '2'));
        printf("strcmp example [%d]\n",
                                  strcmp(string1, string2));
        printf("strcmpl example [%d]\n",
                                 strcmpl(string1, string2));
        printf("strcpy example [%s]\n",
                                  strcpy(buffer,  string1));
        printf("strcspn example [%d]\n",
                                     strcspn(string1, "s"));
        printf("strdup example [%s]\n", strdup(string2));
      }



strerror                       ПОЛУЧИТЬ ИНФОРМАЦИЮ ОБ ОШИБКЕ

   Использование:

      #include <string.h>
      char *strerror(int errornum);               /* ANSI */

   Описание:

      Отображает  errornum  в строку  сообщения  об ошибке и
      возвращает указатель на эту строку.

   Пример:

      #include <stdio.h>
      #include <errno.h>
      #include <io.h>
      #include <dos.h>
      #include <string.h>
      int fp;
      main()
      {
        errno = 0;
        if ((fp = open("file", О_RDONLY)) == -1)
          {
            printf(strerror(errno));
          }
        close(fp);
      }

   Возвращаемое значение:

      strerror  возвращает  указатель на строку сообщения об
      ошибке.

   Рекомендация:

      Смотрите также  perror.


strlen                                     ДАТЬ ДЛИНУ СТРОКИ

   Использование:

      #include <string.h>
      size_t strlen(char *string);                /* ANSI */

   Описание:

      Возвращает длину строки без завершающей литеры '\0'.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char *string = "Example string ";
      size_t result;
      main()
      {
        result=strlen(string);
        printf("Длина строки: [%s] равна [%d]\n",
                                            string, result);
      }

   Возвращаемое значение:  Возвращает длину строки.


strlwr                           ПРИВЕСТИ К НИЖНЕМУ РЕГИСТРУ

   Использование:

      #include<string.h>
      char *strlwr(char *string);

   Описание:

      Преобразует  все литеры  верхнего  регистра в строке в
      литеры нижнего регистра.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char *string = "Mixed Case String";
      main()
      {
        printf("strlwr Example:[%s]\n", strlwr(string));
      }

   Возвращаемое значение:

      Возвращается string.

   Смотрите также  strupr.


strncat - strpbrk                         Работа со строками

   Использование:

      #include <string.h>
      char *strncat(char *string1, const char *string2,
                    size_t n);                    /* ANSI */
      int strncmp(const char *string1, const char *string2,
                    size_t n);                    /* ANSI */
      char *strncpy(char *string1, const char *string2,
                    size_t n);                    /* ANSI */
      char *strnset(char *string, int ch, size_t n);
      char *strpbrk(const char *string1,
                                       const char *string2);
                                                  /* ANSI */

   Описание:

      strncat    Добавляет  минимум из n  и  strlen(string2)
                 литер в конец строки  string1 и приписывает
                 завершающий '\0'.  Пользователь отвечает за
                 обеспечение достаточного  места  в  string1
                 для размещения результата.  Функция возвра-
                 щает string1.

      strncmp    Сравнивает n первых литер string2 и string1.
                 Сравнение завершается после n литер или дос-
                 тижения конца одной из строк. Strncmp возв-
                 ращает:

                    <0,   если string1 меньше string2;
                    =0,   если string1 равно  string2;
                    >0,   если string1 больше string2.

      strncpy    Копирует первые n литер  строки  string2  в
                 строку   string1.   Если  string2   длиннее
                 string1,  результат исполнения не будет за-
                 вершаться  '\0'.  Если  в  string2 меньше n
                 литер,  строка string1 будет дополнена до n
                 литерами '\0'. Функция возвращает string1.

      strnset    Инициализирует не более n первых литер стро-
                 ки string  литерой  ch.  Функция возвращает
                 string.

      strpbrk    Возвращает  указатель на первое появление в
                 строке   string1  любой  литеры  из  строки
                 string2 либо NULL, если ни одна литера стро-
                 ки string2 не входит в строку string1.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char string[50] = "Пример строки";
      char *string2 = "Добавим эту строку";
      char buffer[50];
      main()
      {
        printf("Пример с strncat [%s]\n",
                        strncat(string, string2, 50));
        printf("\n Пример с strncmp [%d]\n",
                        strncmp(string, string2, 10));
        printf("\n Пример с strncpy [%s]\n",
                        strncpy(buffer, string2, 10));
        printf("\n Пример с strnset [%s]\n",
                        strnset(string2, 'x', 9));
        printf("\n Пример с strpbrk [%s]\n",
                        strpbrk(string2, "s"));
      }


strrchr - strset                          Работа со строками

   Использование:

      #include <string.h>
      char *strrchr(const char *string, int ch);  /* ANSI */
      char *strrev(char *string);
      char *strset(char *string, int ch);

   Описание:

      strrchr()    Ищет последнее вхождение литеры ch в стро-
                   ке string и возвращает  указатель на него
                   либо NULL,  если  эта литера в строке от-
                   сутствует.

      strrev()     Меняет порядок (последовательность) литер
                   в строке  string на обратную,  оставляя в
                   конце строки завершающий '\0'. Возвращает
                   string.

      strset()     Инициализирует строку  string литерой ch,
                   не изменяя  завершающий '\0'.  Возвращает
                   string.
   Пример:

      #include <stdio.h>
      #include <string.h>
      char string[50] = "Пример строки;
      char *string2 = "Добавляемая строка;
      main()
      {
        printf("Пример про strrchr [%s]\n",
                                strrchr(string, 'и'));
        printf("\n Пример про strrev [%s]\n",
                                strrev(string));
        printf("\n Пример про strset [%s]\n",
                                strset(string2, ' '));
      }


strspn                      ДАТЬ ДЛИНУ СОВПАДАЮЩЕЙ ПОДСТРОКИ

   Использование:

      #include <string.h>
      size_t strspn(const char *string1,
                          const char *string2);   /* ANSI */

   Описание:

      Функция возвращает  длину  начального  сегмента строки
      string1,  который  полностью  состоит  из литер,  най-
      денных в строке string2.

   Пример:

      #include <string.h>
      #include <stdio.h>
      char *string = "Example";
      char *cmp = "aEx";
      main()
      {
        int result;
        printf("Длина начальной подстроки в строке [%s],
                содержащей [%s]  литеры\n", string, cmp);
        printf("strspn равно [%d]\n", strspn(string, cmp));
      }



strstr                                       НАЙТИ ПОДСТРОКУ

   Использование:

      #include <string.h>
      char *strstr(const char *string1,
                          const char *string2);   /* ANSI */
   Описание:

      Функция возвращает указатель на первое вхождение стро-
      ки string2 в строку string1.

   Пример:

      #include <string.h>
      #include <stdio.h>
      char *string = "Пример строки";
      char *cmp = "стр";
      main()
      {
        printf("Пример на strstr [%s]\n", strstr(string, cmp));
      }

   Возвращаемое значение:

      strstr возвращает NULL,  если string2 не была найдена.
      Если  длина  строки  string2  равна  0,   возвращается
      string1.


strtod - strtoul                   ПРЕОБРАЗОВАТЬ ИЗ А/Ц ВИДА

   Использование:

      #include <stdlib.h>
      double strtod(char *nptr, char **endptr);   /* ANSI */
      long strtol(char *nptr, char **endptr, int base);
                                                  /* ANSI */
      unsigned long strtoul(const char *nptr,char **endptr,
                                  int base);      /* ANSI */

   Описание:

      strtod     Преобразует строку ASCII, на которую указы-
                 вает nptr, в значение типа  double. Функция
                 воспринимает  ведущие  табуляции и пробелы,
                 затем возможный знак и далее  строку цифр с
                 необязательной десятичной  точкой.  Функция
                 strtod завершает  считывание строки на пер-
                 вой литере,  не  являющейся  частью  числа.
                 Указатель на эту  литеру  будет  записан по
                 адресу endptr, если endptr не равен NULL.

      strtol     Преобразует ASCII строку, на которую указы-
                 вает nptr,  в длинное  (long)  целое число.
                 Функция воспринимает  ведущие  "пробельные"
                 литеры и далее строку цифр с возможным зна-
                 ком. Функция strtol прекращает чтение стро-
                 ки на первой  литере,  не являющейся частью
                 записи числа. Указатель на эту литеру будет
                 записан по адресу  endptr,  если  endptr не
                 NULL.

                 Если  параметр  base  (основание)  равен 0,
                 первая литера  после  необязательного знака
                 будет определять основание  преобразования.
                 Если эта первая  литера '0',  а вторая - не
                 'x' или 'X',  то такая строка считается за-
                 писью восьмеричного  числа.  Если же первая
                 литера  равна '0',  а вторая - 'x' или 'X',
                 то такая  строка  будет  интерпретироваться
                 как запись шестнадцатеричного  числа.  Если
                 первая литера от '1' до '9',  то строка ин-
                 терпретируется как запись десятичного цело-
                 го. Буквам A-Z нижнего или верхнего регист-
                 ра (т.е.  прописным или заглавным) присваи-
                 ваются  значения от 10  до 35.  Разрешаются
                 только те литеры,  значения  которых меньше
                 чем base. Если  base не равно 0, его значе-
                 ние должно быть между 2 и 36.

      strtoul    Преобразует ASCII строку, на которую указы-
                 вает nptr, в десятичное число типа unsigned
                 long.
                 Описание - аналогично strtol().

   Возвращаемое значение:

      strtod     Если корректное значение  вызывает перепол-
                 нение,  в зависимости от знака возвращается
                 плюс или минус HUGE_VAL  и errno устанавли-
                 вается в ERANGE.   Если недопустимая литера
                 встретилась до разрешенных, возвращается 0.
                 При  потере  значимости  возвращается  0  и
                 errno устанавливается в ERANGE.

      strtol     Если корректное значение  вызывает перепол-
                 нение,  в зависимости от знака возвращаются
                 LONG_MAX  или LONG_MIN и errno устанавлива-
                 ется в  ERANGE.   Если  недопустимая литера
                 встречается до разрешенных, возвращается 0.

      strtoul    Если корректное  значение вызывает перепол-
                 нение,  возвращается  значение  ULONG_MAX и
                 errno устанавливается в ERANGE.  Если недо-
                 пустимый символ встречается до разрешенных,
                 возвращается 0.

   Рекомендация:

      Смотрите также  atof, atoi, atol.

   Пример:

      #include <stdio.h>
      #include <stdlib.h>
      char *string, *string2;
      main()
      {
        unsigned long result;
        long result1;
        double result2;
        int base;
        string = "3.1415926Stop here";
        result2 = strtod(string,&string2);
        printf("String [%s] strtod = [%f]\n",
                                   string, result2);
        base = 8;
        string = "1011013";
        result1 = strtol(string, &string2, base);
        printf("String [%s] strtol [%ld] (base 8)\n",
                                            string, result);
        base = 2;
        string = "1011013";
        result = strtoul(string, &string2, base);
        printf("String [%s] strtoul=[%ld] (base 2)\n",
                                            string, result);
      }


strupr                          ПРИВЕСТИ К ВЕРХНЕМУ РЕГИСТРУ

   Использование:

      #include <string.h>
      char *strupr(char *string);

   Описание:

      Функция преобразует все литеры нижнего регистра строки
      string в соответствующие литеры верхнего регистра.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char *string = "Строка В Разных Регистрах";
      main()
      {
        printf("Пример со strupr [%s]\n", strupr(string));
      }

   Возвращаемое значение:

      Функция возвращает string.

   Рекомендация:  Смотрите также  strlwr.


swab                                  ПОПАРНО ПОМЕНЯТЬ БАЙТЫ

   Использование:

      #include <string.h>
      void swab(char *source, char *destination, int n);

   Описание:

      Копирует n байтов строки source,  меняя местами каждую
      пару смежных байт.  Преобразованная  строка помещается
      в строку destination (назначение). Целое число n долж-
      но быть  четным,  так  как  символы  меняются  местами
      попарно.

   Пример:

      #include <stdio.h>
      #include <string.h>
      char *string1 = "badefehgjilknm";
      char *string2 = "..............";
      main()
      {
        swab(string1, string2, 14);
        printf("string1 [%s] string2 [%s]\n",
                                     string1, string2);
      }

   Возвращаемое значение: Нет.


system                                       ОБРАЩЕНИЕ К DOS

   Использование:

      #include <stdlib.h>
      int system(char *string);                   /* ANSI */

   Описание:

      Функция system  обеспечивает  передачу  строки  string
      командному процессору DOS, как если бы эта строка была
      набрана за терминалом. Текущая программа ожидает конца
      исполнения команды, а затем возобновляет работу.

      Не существует способа для определения статуса заверше-
      ния программ, запускаемых по system. Если Вам требует-
      ся статус завершения,  используйте одну из функций по-
      рождения (spawn).

   Возвращаемое значение:

      Если недостаточно  свободной памяти для загрузки и за-
      пуска COMMAND.COM или COMMAND.COM не найдена,  возвра-
      щается -1, в противном случае возвращается 0.

   Рекомендация:  Смотрите также  exec, spawn.

         Заметим,  что  так  как при  использовании  функции
         system  загружается  отдельная  копия  COMMAND.COM,
         функция не может  быть  использована  для установки
         переменных окружения текущего окружения (т.е. окру-
         жения на момент исполнения программы) с помощью ко-
         манды SET.  Например, фрагмент программы:

	          system("SET ABC=DEF");

	 не будет иметь полезного действия.

   Пример:

      #include <stdlib.h>
      main()
      {
        system("set >>path.log");
        system("cls");
        system("type path.log");
        system("pause");
        system("erase path.log");
        system("cls");
        system("ver");
        system("pause");
        system("cls");
        system("dir /w");
      }


tan, tanh                   ТАНГЕНС, ТАНГЕНС ГИПЕРБОЛИЧЕСКИЙ

   Использование:

      #include <math.h>
      double tan(double x);                       /* ANSI */
      double tanh(double x);                      /* ANSI */

   Описание:

      Эти функции возвращают тангенс (tan) и гиперболический
      тангенс (tanh) аргумента x, измеряемого в радианах.

   Пример:

      #include <stdio.h>
      #include <math.h>
      main()
      {
        double d = .45987;
        printf("The tangent of .45987 is [%f]\n", tan(d));
        d = .495287;
        printf("The hyperbolic tan  of .495287 is [%f]\n",
                                                   tanh(d));
      }

   Возвращаемое значение:

      Функция возвращает  тангенс либо  гиперболический тан-
      генс x.


time                                            ДАТЬ   ВРЕМЯ

   Использование:

      #include <time.h>
      time_t time(time_t *timeptr);               /* ANSI */

   Описание:

      Функция time возвращает текущее время в секундах, про-
      шедшее с 00:00:00  1 января 1970 года и записывает это
      значение в *timeptr, если timeptr не равен NULL.

   Пример:

      #include <time.h>
      #include <stdio.h>
      main()
      {
        time_t ntime;
        time(&ntime);
        printf("Время: %s\n", ctime(&ntime));
      }

   Возвращаемое значение:

      Функция  time  возвращает  число  секунд,  прошедших с
      00:00:00 1 января 1970 года.


   Рекомендация:

      Смотрите также  ctime, asctime, localtime, mktime.


toascii, tolower, toupper                          B ASCII,
						   B НИЖНИЙ,
   Использование:                                  B ВЕРХНИЙ

      #include <ctype.h>
      int toascii(int c);
      int tolower(int c);                         /* ANSI */
      int toupper(int c);                         /* ANSI */

   Описание:

      toascii    Принимает любое целое значение и сбрасывает
                 в 0 все, кроме 7 младших разрядов,  опреде-
                 ляющих ASCII литеру.

                 Если  c  уже имеет правильное значение, оно
                 возвращается неизмененным.

      tolower    Преобразует любое целое значение c в диапа-
                 зоне от A до Z в прописную литеру.

      toupper    Преобразует целое  значение  c  в диапазоне
                 от a до z в заглавную литеру.

      Эти функции реализуются  как  макросы,  определенные в
      ctype.h; они включены и в библиотеку функций, как функ-
      ции.  Если эти макросы не определены и файл ctype.h не
      включен в программу,  будут  использованы библиотечные
      функции.

   Пример:

      #include <ctype.h>
      #include <stdio.h>
      main()
      {
        printf("Заглавная литера [%c]\n", toupper(0x6d));
        printf("Прописная литера [%c]\n", tolower(0x4d));
        printf("Сделаем ascii литеру [%c]\n",toascii(0x0e));
      }

   Возвращаемое значение:

      toascii    Возвращает 7 младших разрядов  c.

      tolower    Возвращает c, преобразованное  в  прописную
                 литеру, если оно  было  заглавной  литерой.
                 В противном случае  c  возвращается неизме-
                 ненным.

      toupper    Возвращает c,  преобразованное  в заглавную
                 литеру,  если оно  было  строчной  литерой.
                 В противном случае  c  возвращается неизме-
                 ненным.


ungetc                                     ВОЗВРАТИТЬ ЛИТЕРУ

   Использование:

      #include <stdio.h>
      int ungetc (int c, FILE *fp);               /* ANSI */

   Описание:

      Функция  ungetc возвращает литеру  c  во входной поток
      fp, откуда считывается  следующей  операцией  ввода из
      потока. Если между выполнением функции ungetc() и пос-
      ледующим чтением выполнялась функция fseek(),  возвра-
      щенная  литера  теряется.  Между  чтениями  может быть
      возвращена только одна  литера.  Признак  конца  файла
      EOF не может быть возвращен в поток.

   Возвращаемое значение:

      ungetc возвращает символ  c  в случае  успеха,  и EOF,
      если символ не может быть возвращен.

   Рекомендация:

      Смотрите также  getc, getchar, putc, putchar.

   Пример:

      #include <stdio.h>
      #include <ctype.h>
      main()
      {
        char ch;
        FILE *stream;
        stream = fopen("file.dat", "r");
        while ((ch = fgetc(stream)) !=EOF )
              if (isspace(ch))
                  break;
        ungetc(ch, stream);
        ch = fgetc(stream);
        fclose(stream);
      }


unlink                                          УДАЛИТЬ ФАЙЛ

   Использование:

      #include <io.h>
      int unlink(char *filename);

   Описание:

     unlink удаляет файл,  определяемый строкой имени файла.

   Пример:

      #include <stdio.h>
      #include <io.h>
      #include <stdlib.h>
      main()
      {
        int value;
        char buffer[13];
        char *result;
        printf("Назовите удаляемый файл: ");
        result = gets(buffer);
        value = unlink(result);
        if (value == 0)
            printf("Стерли [% ] с диска\n", result);
        else
            printf("Не удалось стереть [%s]\n", result);
      }

   Возвращаемое значение:

      Unlink возвращает 0 в случае успешного удаления файла,
      либо -1 в случае возникновения ошибки;  при этом уста-
      навливается errno.



utime                       ИЗМЕНИТЬ ВРЕМЯ МОДИФИКАЦИИ ФАЙЛА

   Использование:

      #include <time.h>
      int utime (char *path, time_t times[]);

   Описание:

      Utime изменяет время модификации файла,  определяемого
      аргументом  path.  Аргумент  times  задает новое время
      модификации для этого файла.
      Массив времен должен содержать последнее время доступа
      и последнее время модификации файла соответственно.Пос-
      кольку в MS DOS нет понятия времени последнего доступа,
      этот элемент игнорируется.  Если аргумент times, опре-
      деляющий  время,  равен нулю,  то используется текущее
      время.

   Возвращаемое значение:

      Utime возвращает 0 в случае успешного выполнения, и -1
      в случае возникновения ошибки; при этом устанавливает-
      ся errno.

   Рекомендация:

      Смотрите также time.

   Пример:

      #include <time.h>
      #include <stdio.h>
      main(int argc, char *argv[])
      {
        if (argc ! = 2)
        {
        fprintf(stderr, "Использование:: utime [файл.имя]\n");
        abort();
        }
        if (utime(argv[1], NULL) == -1)
        {
        fprintf(stderr, "Не могу обновить файл [%s]\n",
                                              argv[1]);
            abort();
        }
      }


va_arg - va_start      РАБОТА С ПЕРЕМЕННЫМ ЧИСЛОМ ПАРАМЕТРОВ

   Использование:

      #include <stdarg.h>
      type va_arg(va_list arg_ptr, type);         /* ANSI */
      void va_end(va_list arg_ptr);               /* ANSI */
      void va_start(va_list arg_ptr, prev_parm);  /* ANSI */

   Описание:

      Эти макросы используются для того,  чтобы поддерживать
      список аргументов,  используемых в функциях с перемен-
      ным числом аргументов (например, в функции vprintf).

      Тип va_list представляет собой список переменного чис-
      ла аргументов, определяемый в stdarg.h, вместе с этими
      тремя макросами; этот тип позволяет обрабатывать спис-
      ки аргументов  функции,  когда ей еще неизвестно число
      передаваемых аргументов.

      Массив  va_list  содержит информацию,  необходимую для
      va_arg и va_end.  Когда  вызванная функция вводит спи-
      сок аргументов, она объявляет переменную типа va_list.

      Функция  va_start  вызывается первой для инициализации
      списка аргументов,  причем arg_ptr указывает на первый
      аргумент в этом списке  va_list.  Параметр prev_parm -
      - параметр, предшествующий  первому  аргументу.  После
      обращения к va_start каждый вызов  va_arg  будет брать
      данные названного  типа из указанного места и увеличи-
      вать значение arg_ptr.

      va_end сбрасывает arg_ptr в NULL.

   Пример:

      Смотрите vprintf.

   Возвращаемое значение:

      va_arg возвращает текущий аргумент.
      va_start  и  va_end равнозначны void.


vprintf, vfprintf, vsprintf                  ФОРМАТНЫЙ ВЫВОД

   Использование:

      #include <stdio.h>
      #include <stdarg.h>
      int vfprintf(FILE *stream, const char *format,
                         va_list arg_ptr);        /* ANSI */
      int vprintf(const char *format, va_list arg_ptr);
                                                  /* ANSI */
      int vsprintf(char *buffer, const char *format,
                         va_list arg_ptr);        /* ANSI */

   Описание:

      Эти  функции   аналогичны   соответственно   printf(),
      fprintf()  и  sprintf()  за исключением того, что дан-
      ные берутся из va_list arg_ptr.
      Смотрите аналоги для формата.

   Возвращаемое значение:

      Функция возвращает число выведенных литер при успешном
      завершении или отрицательное  число  при возникновении
      ошибки.

   Рекомендация:

      Смотрите также  fprintf, printf, sprintf.

   Пример:

      #include <stdarg.h>
      #include <stdio.h>
      varprint(char *format, ...)
      {
        va_list arg_ptr;
        va_start(arg_ptr, format);
        vprintf(format, arg_ptr);
        va_end(arg_ptr);
      }
      main()
      {
        char *string = "STRING";
        int  hnum = 0xb000;
        varprint("Вызов c %s пар-ом и с %x 16-м пар-м\n",
                                             string, hnum);
        varprint("Или без параметров\n");
      }


write                                          ПИСАТЬ В ФАЙЛ

   Использование:

      #include <io.h>
      int write(int fd, void *buffer, unsigned length);

   Описание:

      Функция  записывает  length  байтов из буфера buffer в
      файл, определенный дескриптором файла fd. Эта операция
      чисто  'двоичная' и без  буферизации.  Реализуется как
      непосредственный вызов DOS.

   Возвращаемое значение:

      Функция write возвращает число  действительно записан-
      ных в файл байтов или  -1 при ошибке, устанавливая при
      этом errno.

   Пример:

      #include <io.h>
      #include <stdio.h>
      #include <string.h>
      #include <dos.h>
      main()
      {
        unsigned int fd;
        char *buffer = "Данные для записи в файл";
        unsigned int count;
        int nwritten;
        count = strlen(buffer);
        fd = open("file.dat", O_WRONLY);
        if (fd == -1)
            {
              fputs("Не могу открыть файл", stdout);
              return;
            }
        nwritten = write(fd, buffer, count);
        printf("\n WRITE:\n%u байтов записано в файл\n",
                                                  nwritten);
        close(fd);
      }















                               ВВЕДЕНИЕ  В  БЫСТРУЮ  ГРАФИКУ
                               ─────────────────────────────



   Быстрая графика (FG) является набором интерфейсных графи-
ческих процедур для IBM PC (и совместимых с ним компьютеров)
в среде ZORTECH C  компиляторов. Эти процедуры оптимальны по
скорости и памяти и большинство написано на ассемблере.  Они
поддерживают адаптеры типа Hercules, EGA, CGA, VGA и Toshiba
3100.
   Процедура инициализации  автоматически распознает и наст-
раивается на большинство существующих графических плат. Мож-
но вручную подавить  (т.е. назначить другую)  настройку пос-
редством переменной окружения либо во время компиляции.
   Имеется два набора  библиотек.  Один является отладочным,
обеспечивающим контроль  допустимости  значений  фактических
параметров   функций.   При  обнаружении  ошибки  вызывается
_assert() с сообщением об ошибке.  Это обеспечивает помощь в
поиске трудных для локализации ошибок в программе.  Отладоч-
ный вариант требует некоторых небольших издержек по скорости
и памяти,  поэтому  для полностью  отлаженного  кода имеется
"боевая" версия библиотеки.
   Файл "fg.h" должен включаться в модули,  использующие эти
функции и переменные.  Большинство из вызываемых функций яв-
ляются  макросами,  поэтому использование этого файла обяза-
тельно.


Определение базовой координатной системы

   FG использует правостороннюю координатную систему.


     y^
      │                       Здесь x  и  y являются коорди-
      │                       натами пикселей.
      │
      │
    0 ┼─────────────────> x
      0                

Типы переменных

   fg_coord_t   Тип данных для любых координат.

   fg_box_t     Тип  данных  для  координат  ограничивающего
                прямоугольника  (рамки).  Рамка  должна быть
                нормализована,  т.е. координата FG_X1 меньше
                или равна координате FG_X2, координата FG_Y1
                меньше  или равна  координате  FG_Y2  (более
                подробную информацию можно найти в параграфе
                "Константы  FG").  Другими  cловами,  первая
                точка рамки  является  всегда  нижним  левым
                углом, а вторая - верхним правым углом.

   fg_pbox_t    Указатель на рамку.

   fg_line_t    Тип данных  для координат  (отрезка)  линии.
                Для выборки координат  линий используются те
                же самые константы, что и для рамок,  но ли-
                нии не должны специально подвергаться норма-
                лизации перед обращением к функциям.

   fg_color_t   Тип для цвета.

   fg_pline_t   Указатель на линию.

   fg_hangle_t  Дескриптор сохраненной области экрана. Смот-
                рите fg_save()  и  fg_restore().

Константы FG

   Константы именуются идентификаторами с заглавными буквами.
Они определяются в файле "fg.h". Они должны всегда использо-
ваться по именам, а не по значениям, подставляемым в резуль-
тате обращения к макросам,  поскольку в будущих версиях гра-
фического пакета эти значения могут измениться.


Адаптеры графического дисплея

   Ниже  перечислены  значения,  возвращаемые  fg_init_all()
(смотрите  определение  fg_init_all()  для  более  детальной
информации); глобальная переменная fg_display получает то же
самое значение.

     ЗАМЕЧАНИЕ:    fg_init_all()   пытается  определить  тип
     подключенного   графического  устройства.  Возможно пе-
     реопределение  этого  типа  во  время  исполнения  пос-
     редством  установки  переменной  окружения   FG_DISPLAY
     в  одно   из   нижнеприведенных   значений.   Например,
     SET FG_DISPLAY=HERCFULL.

      FG_NULL      Вся  графика  сводится к работе с битовой
                   картой.

      FG_HERCFULL  Hercules "Геркулес" монохромный дисплей с
                   2 дисплейными страницами.

      FG_HERCHALF  Hercules монохромный дисплей с 1 дисплей-
                   ной страницей.

      FG_EGAECD    IBM EGA  с расширенным (enhanced) цветным
                   дисплеем.

      FG_EGACOLOR  IBM EGA  с обычным  цветным  дисплеем.

      FG_EGAMONO   IBM EGA  с монохромным  дисплеем.

      FG_CGAHIRES  IBM CGA  в режиме  640*200  пикселей.

      FG_CGAMEDRES IBM CGA  в режиме  320*200.

      FG_TOSHIBA   TOSHIBA 3100.

      FG_8514A	   IBM 8514A графический адаптер.

      FG_VGA11     IBM VGA  в режиме 0х11.

      FG_VGA12     IBM VGA  в режиме 0х12.

      FG_VGA13     IBM VGA  в режиме 0х13.

   Другие значения переменной FG_DISPLAY:

      HERC         HERCULES   монохромный  дисплей с 1 или 2
                   страницами, (что уточняется при инициали-
                   зации функцией fg_init_all().


Доступ к координатам рамок и линий

      FG_X1     Используются в качестве индексов рамок и ли-
      FG_Y1     ний, скажем, конструкция [FG_X1] обеспечива-
      FG_X2     ет доступ к x координате левой стороны рамки.
      FG_Y2

       ┌───────────────────────────────────────────────────┐
       │                                                   │
       │    ┌──────────┐  ───  y2                ┌─── y2   │
       │    │          │                        /│         │
       │    │          │                       / x2        │
       │    └──────────┘  ───  y1             /            │
       │    │          │               y1 ───┐             │
       │    x1         x2                    │             │
       │                                     x1            │
       │                                                   │
       └───────────────────────────────────────────────────┘
                    FG координаты рамок и линий

   Эти константы, а не абсолютные значения,  следует исполь-
зовать для доступа к элементам массива,  что позволяет избе-
жать проблем с дисплейными  адаптерами, использующими разные
системы координат.


Маски

   Масочные константы  передаются (как параметры) почти всем
функциям для индикации битовых плоскостей, доступных для из-
менения.  Маска имеет смысл только для плат,  поддерживающих
более двух цветов. Для плат типа EGA, поддерживающих в режи-
ме высокого разрешения 16 цветов одновременно, действительны
4 бита маски, пакуемые в младшие биты.
   В большинстве приложений необходим доступ ко всем точкам.
Это обеспечивается значением ~0. Управление доступностью би-
товых плоскостей посредством масок  полезно в следующих слу-
чаях:

        * Если имеются 2 битовых плоскости (2 бита/пиксель),
          Вы можете рисовать различные образы на каждой. Из-
          меняя затем карту цветов,  можно включать и выклю-
          чать плоскости независимо друг от друга,  создавая
          эффект мультипликации.

        * Курсор может быть записан на свою собственную плос-
          кость,  что  сделает  его независимым от остальной
          графики.


Запись режимов

   Одна из следующих величин  передается  почти всем функци-
ям для индикации типа выполненяемой операции на экране.

   FG_MODE_SET   Режим установки цветов в активную  страницу
                 с учетом действующей маски.
   FG_MODE_XOR   Режим проведения операции XOR  (исключающее
                 или)  над записанным и записываемым цветами
                 в активной странице.

   Типы линий

   Одно из следующих значений поступает к функциям рисования
линий для индикации типа рисуемой линии.

   FG_LINE_SOLID            сплошная
   FG_LINE_LONG_DASH        длинный штрих
   FG_LINE_MEDIUM_DOTTED    средний пунктир
   FG_LINE_DASH_DOTTED      штрих - пунктир
   FG_LINE_MEDIUM_DASHED    средний штрих
   FG_LINE_DASH_W_2_DOTS    штрих и два пунктира
   FG_LINE_SHORT_DASH       короткий штрих
   FG_LINE_DENSE_DOTTED     плотный пунктир
   FG_LINE_SPARSE_DOTTED    редкий пунктир
   FG_LINE_USER_DEFINED     Этот тип линии определяется прик-
                            ладной   программой  посредством
                            fg_setlinepattern().
   FG_LINE_MAX              Максимальное количество одновре-
                            менно определенных типов линий.

Доступные цвета

   Эти значения поступают к функциям в качестве  аргументов,
определяя цвета линий, точек, рамок и т.д. Из всего разнооб-
разия  графических  мониторов ни один  не  поддерживает  все
названные ниже цвета. Некоторые  поддерживают только два. FG
определяется так, что будет предоставлено,  по крайней мере,
два из этих цветов, доступных на всех поддерживаемых платах.
Эти значения выбираются по умолчанию.  Если Вы измените цве-
товую  карту,  смысл этих значений соответственно изменится.
Все эти значения не действительны до обращения к fg_init ().
Если цвет недоступен,  он установлен в -1.

   FG_BLACK              Черный. Всегда доступен.
   FG_BLUE               Голубой.
   FG_GREEN              Зеленый.
   FG_CYAN               Циан (Темно-синий, сине-зеленый).
   FG_BLUE_GREEN         Сине-зеленый. То же, что и CYAN.
   FG_RED                Красный.
   FG_MAGENTA            Фиолетовый.
   FG_PURPLE             Пурпурный. То же, что и MAGENTA.
   FG_WHITE              Белый. Всегда доступен.
   FG_GRAY               Серый.
   FG_LIGHT_BLUE         Светло-голубой.
   FG_LIGHT_GREEN        Светло-зеленый.
   FG_LIGHT_CYAN         Светлый циан.
   FG_LIGHT_BLUE_GREEN   Светло-сине-зеленый. То же, что и
                         LIGHT_CYAN.
   FG_LIGHT_RED          Светло-красный.
   FG_LIGHT_MAGENTA      Светло-фиолетовый.
   FG_BROWN              Коричневый.
   FG_LIGHT_WHITE        Светло-белый.
   FG_HIGHLIGHT          Обычно интенсивный белый.
   FG_COLOR_MAX          Максимальное число цветов, поддержи-
                         ваемое любым  устройством.  Смотрите
                         также fg_ncolormap и fg_nsimulcolor.


					   ОБЩИЕ  ПЕРЕМЕННЫЕ
					   ─────────────────

   Значения этих переменных  имеют  смысл в промежутке между
обращениями к fg_init() и fg_term().  Эти значения не должны
в этом промежутке  модифицироваться  прикладными программами
(исключением являются fg_activepage  и  fg_displaypage).


fg_displaybox (КООРДИНАТЫ РАМКИ ДИСПЛЕЯ)

   Тип:
              fg_box_t  fg_displaybox;
   Описание:
              Рамка дисплея.

              (fg_displaybox[FG_X1],   fg_displaybox[FG_Y1])
              являются координатами нижнего левого угла дис-
              плея.
              (fg_displaybox[FG_X2],   fg_displaybox[FG_Y2])
              являются  координатами  верхнего  правого угла
              дисплея.



fg_charbox (КООРДИНАТЫ РАМКИ ЛИТЕРЫ)

   Тип:
              fg_box_t  fg_charbox;
   Описание:
              Рамка литеры.

              (fg_charbox[FG_X1], fg_charbox[FG_Y1])=(0,0).
              (fg_charbox[FG_X2], fg_charbox[FG_Y2]) являют-
              ся координатами  правого  верхнего  угла рамки
              литеры.



fg_ncolormap (РАЗМЕР ПАЛИТРЫ)

   Тип:
              int fg_ncolormap;
   Описание:
              Количество элементов в карте цветов.
   Пример:
              Для платы EGA с расширенным (Enhanced) цветным
              дисплеем  это  значение  равно 64.  Для  платы
              Hercules оно равно 2.


fg_nsimulcolor (ЧИСЛО ЦВЕТОВ)

   Тип:
              int fg_nsimulcolor;
   Описание:
              Число одновременно доступных цветов,  равное 2
              в степени n, где n - число бит на пиксель.
   Пример:
              Для платы EGA  с расширенным  цветным дисплеем
              это значение равно 16 (4 бита на пиксель). Для
              платы Hercules оно равно 2 (1 бит на пиксель).
              Количество бит на пиксель равно количеству би-
              товых плоскостей.


fg_pixelx, fg_pixely (РАЗМЕРЫ ПИКСЕЛЯ)

   Тип:
              int fg_pixelx, fg_pixely;
   Описание:
              Типичная высота и ширина пикселя в микрометрах.
              Поскольку для реального  монитора эти значения
              программно определить невозможно, они соответ-
              ствуют типичномумонитору, используемому с этой
              графикой.


fg_numpages (ЧИСЛО СТРАНИЦ)

   Тип:
              int fg_numpages;
   Описание:
              Количество дисплейных страниц, нумеруемых от 0
              до (fg_numpages-1).
   Пример:
              Адаптер EGA с 256 Кб оперативной памяти (RAM)
              будет иметь 2 графические страницы с номерами
              0 и 1.


fg_display (ТИП АДАПТЕРА)

   Тип:
              int fg_display;
   Описание:
              Тип графической платы, установленной в компью-
              тер.  Эта переменная устанавливается в одно из
              значений  FG_NULL,  FG_EGAECD,  FG_HERCULES, и
              т.д., описанных среди констант FG.


fg_activepage (НОМЕР АКТИВНОЙ СТРАНИЦЫ)

   Тип:
              unsigned fg_activepage;
   Описание:
              Текущая  активная  страница,   к  которой  от-
              носятся   все  графические  команды.   Функция
              fg_setactivepage()  устанавливает и меняет но-
              мер текущей страницы.


fg_displaypage (НОМЕР ОТОБРАЖАЕМОЙ СТРАНИЦЫ)

   Тип:
              unsigned fg_displaypage;

   Описание:
              Текущая  страница,  отображенная  на мониторе.
              Номер  дисплейной  страницы  устанавливается и
              изменяется функцией fg_setdisplaypage().




	ФУНКЦИИ,  ПОСТАВЛЯЕМЫЕ  ПОЛЬЗОВАТЕЛЕМ  ФАКУЛЬТАТИВНО
	────────────────────────────────────────────────────

   Пользователь пакета  FG  может  определять  перечисленные
ниже функции,  которые по умолчанию поддерживаются библиоте-
кой.

_assert                                          УТВЕРЖДЕНИЕ

   Тип:
              void   _assert(char *string _p,  char *file_p,
                                         unsigned int line);
   Описание:
              Функция  вызывается при обнаружении таких про-
              граммных  ошибок,  как  приход  координаты вне
              пределов дисплея.  Она должна печатать сообще-
              ние, указанное 'string_p', имя исходного файла
              'file_p' и номер строки  'line'  в этом файле.
              Она не должна возвращать  управление;  настоя-
              тельно рекомендуется завершить (exit) програм-
              му с возвратом в ДОС;  настоятельно рекоменду-
              ется также вызвать  fg_term  перед возвратом в
              DOS, восстановив текстовый режим отображения.


fg_lineclip                              КЛИППИРОВАНИЕ ЛИНИИ

   Тип:
             int fg_lineclip(fg_pbox_t clip,
                 fg_pline_t line_in, fg_pline_t line_out);

   Описание:

	     fg_pbox_t clip        Клиппирующая   рамка  для
                                   линии  line_in.

	     fg_pline_t line_in    Линия,   которая   должна
                                   пройти клиппирование (об-
                                   резание)    относительно
                                   клиппирующей рамки.

	     fg_pline_t line_out   Результирующая линия. Воз-
                                   вращает  ненулевое значе-
                                   ние,  если один или более
                                   пикселей линии `line_out'
                                   находится  внутри клиппи-
                                   рующей рамки. В противном
                                   случае  возвращает  ноль.
                                   Если программист не удов-
                                   летворен работой функций,
                                   вызываемых этой  процеду-
                                   рой   (fg_drawlineclip(),
                                   fg_drawbox(),
                                   fg_drawthickline()),   он
                                   может  обеспечить альтер-
                                   нативу.


			    ОБЩИЕ  ФУНКЦИИ  БЫСТРОЙ  ГРАФИКИ
	                    ────────────────────────────────


fg_adjustxy               СКОРРЕКТИРОВАТЬ ТЕКУЩИЕ КООРДИНАТЫ

   Использование:

   #include <fg.h>
   void fg_adjustxy(int rot, int n,
   fg_coord_t *px, fg_coord_t *py, fg_pbox_t box);

   Описание:

   int rot              Одна из констант  FG_ROT0, FG_ROT90,
                        FG_ROT180, FG_ROT270.

   int n                Количество  литер или объектов,  уже
                        выведенных.

   fg_coord_t *px, *py  Указатели на координаты  начала пер-
                        вой литеры строки.

   fg_pbox_t box        Ограничивающая   рамка   литеры  или
                        объекта.


   x и y координаты для вывода очередной литеры (или объекта,
   ограниченного рамкой),  вычисляются  с  учетом  заданного
   вращения. *px и *py  устанавливаются указывающими на оче-
   редную литеру (объект). Процедура наиболее полезна в комп-
   лекте с fg_drawmatrix() и fg_puts().

   Пример:

      {
        static char test_string[]="Это тест";
        fg_coord_t x,y;
        ...
        x=fg_displaybox[FG_X1] + displaybox[FG_X2];
        x-=sizeof(test_string)*(fg_charbox[FG_X2]+1);
        x /=2;
        y=(fg_displaybox[FG_Y1]+fg_displaybox[FG_Y2)/2;
        fg_puts(FG_WHITE, FG_MODE_SET, ~0,  FG_ROT0, x,
                y, test_string, fg_displaybox);
        fg_adjustxy(FG_ROT0, sizeof(test_string)-1, &x,
                    &y, fg_charbox);
               /* x  и  y  сейчас установлены в конец строки
                                             `test string'*/
      }


fg_blit                                    ПЕРЕМЕСТИТЬ РАМКУ

   Использование:

   #include <fg.h>
   void fg_blit(fg_pbox_t src_box,
   fg_coord_t(x, fg_coord_t y, int dstpage, int srcpage);

   Описание:

   Осуществляет перемещение  прямоугольной  области пикселей
   по экрану.

   src_box   Определяет исходный прямоугольник пикселей. Он,
             естественно,  не должен вылезать за рамку всего
             экрана  fg_displaybox  как до,  так и после его
             перемещения к новым координатам.
   x, y      Задают координаты нижнего левого угла результи-
             рующего прямоугольника.
   dstpage   В какую дисплейную страницу поместить перемеще-
             нный прямоугольник пикселей.
   srcpage   Из какой страницы  брать исходный прямоугольник
             пикселей.

   Клиппирование не производится.  Перекрытие исходной и ре-
   зультирующей  областей обрабатывается так,  что  читаемые
   пиксели не уничтожаются записываемыми.  Эта функция может
   также  использоваться для копирования  страниц  с  полной
   рамкой src_box,  равной fg_displaybox,  и результирующими
   координатами (0,0).

   Пример:

	   /*  копирование страницы из `oldpage' в `page' */
   fg_blit(fg_displaybox, 0, 0, page, oldpage);


fg_box_cpy                                 СКОПИРОВАТЬ РАМКУ

   Использование:

   #include <fg.h>
   pbox_t fg_box_cpy(pbox_t to, pbox_t from);

   Описание:

   Копирует рамку `from' в рамку `to'.  Возвращает указатель
   на рамку `to'.

   Пример:

   fg_box_cpy(destination_box, source_box);



fg_drawarc                                   НАРИСОВАТЬ ДУГУ

   Использование:

   #include <fg.h>
   void fg_drawarc(fg_color_t color, int mode,
                   int mask, fg_coord_t x, fg_coord_t y,
                   fg_coord_t radius, int startangle,
                   int endangle, fg_pbox_t clipbox);

   Описание:

   Рисует круговую дугу в направлении против часовой стрелки
   от начального углового смещения радиуса до конечного.

   x, y        Центр окружности.
   radius      Радиус окружности.
   clipbox     Клиппирующая рамка для дуги.
   startangle  Значение от 0 до 3600 (десятые доли градуса).
   endangle    Значение от 0 до 3600. Чтобы нарисовать  пол-
               ную окружность, используются значения 0, 3600.
               Заметим, что нулевой радиус или нулевое угло-
               вое расстояние будут отрисованы как один пик-
               сель.

   Хотя единицей  угловых  расстояний  служит  десятая часть
   градуса,   максимально  возможная  ошибка  достигает  для
   некоторых углов 3 градусов. Дуга является круговой в пик-
   селях,  но ввиду  разницы  расстояний  между  пикселями в
   направлениях по x и y на большинстве дисплеев дуга выгля-
   дит эллипсом.  Для исправления недостатка можно использо-
   вать  fg_drawellipse() с соответствующим масштабированием
   x и y радиусов,  вычисленных с использованием  fg_pixelx,
   fg_pixely.

   Пример:

   fg_drawarc (FG_WHITE, FG_MODE_XOR,~0, 0,
            fg_displaybox[FG_Y2]+10, fg_displaybox[FG_Y2]/2,
                                 1800, 3600, fg_displaybox);



fg_drawbox                          НАРИСОВАТЬ ПРЯМОУГОЛЬНИК

   Использование:

   #include <fg.h>
   void fg_drawbox(fg_color_t color, int mode, int mask,
        int line_type, fg_pbox_t box, fg_pbox_t clipbox);

   Описание:

   Рисует контур  прямоугольника  на экране и клиппирует его
   относительно рамки clipbox. Рисуемый прямоугольник должен
   быть нормализован,  т.е. первая пара координат должна за-
   давать нижний левый угол, а вторая - правый верхний.


   Пример:

   {
     fg_box_t box_to_draw;
     box_to_draw[FG_X1]=10;
     box_to_draw[FG_Y1]=0;
     box_to_draw[FG_X2]=20;
     box_to_draw[FG_Y2]=30;
     box_to_draw(FG_WHITE, FG_MODE_SET, ~0,
     FG_LINE_DENSE_DOTTED, box_to_draw,
     fg_displaybox);
   }


fg_drawdot                                  НАРИСОВАТЬ ТОЧКУ

   Использование:

   #include <fg.h>
   void fg_drawdot(fg_color_t color, int mode,
        int mask, fg_coord_t x, fg_coord_t y);

   Описание:

   Рисует  точку  (x, y).  Точка  должна  быть  внутри рамки
   fg_displaybox.

   Пример:

   fg_drawdot(FG_WHITE, FG_MODE_SET,~0, 0, 0);


fg_drawellipse                             НАРИСОВАТЬ ЭЛЛИПС

   Использование:

   #include <fg.h>
   void fg_drawellipse(fg_color_t color, int mode, int mask,
        fg_coord_t x, fg_coord_t y, fg_coord_t xradius,
        fg_coord_t yradius, int startangle,
        int endangle, fg_pbox_t clipbox);

   Описание:

   Рисует дугу эллипса  против  часовой стрелки между задан-
   ными угловыми смещениямим радиуса.

   x, y                      Центр  эллипса.
   xradius, yradius          Длины  полуосей  эллипса.
   clipbox                   Клиппирующий  прямоугольник.
   startangle                Принимает значение от 0 до 3600
                             (десятые доли градуса).
   endangle                  Принимает значение от 0 до 3600
                             (десятые доли градуса).

   Чтобы нарисовать эллипс целиком, используйте значения 0 и
   3600  для угловых  размеров.  Имейте ввиду,  что в случае
   нулевого  значения  одного из радиусов или разности углов
   будет нарисован один пиксель.

   Рекомендация:

   Смотрите также  fg_drawarc.


fg_drawline, fg_drawlinep                   НАРИСОВАТЬ ЛИНИЮ

   Использование:

   #include <fg.h>
   void fg_drawline(fg_color_t color,
                    int mode, int mask, int line_type,
                    fg_pline_t line);
   void fg_drawlinep(fg_color_t color,
                     int mode, int mask,
                     int line_type, fg_pline_t line);

   Описание:

   Рисуют линию от точки (x1, y1) до точки (x2, y2), исполь-
   зуя указанные тип линии, цвет, режим и маску. Линия долж-
   на  уже  быть  клиппирована  относительно  fg_displaybox.
   fg_drawlinep() отличается от fg_drawline() тем,  что кон-
   цевые точки линии рисует независимо от типа линии.

   Пример:

   {
     fg_line_t line_to_draw;
                       /* Линия из верхнего левого угла к */
                          /* нижнему правому углу дисплея */
     line_to_draw[FG_X1]=fg_displaybox[FG_X2];
     line_to_draw[FG_Y1]=fg_displaybox[FG_Y1];
     line_to_draw[FG_X2]=fg_displaybox[FG_X1];
     line_to_draw[FG_Y2]=fg_displaybox[FG_Y2];
     fg_drawline[FG_WHITE, FG_MODE-SET, ~0,
     FG_LINE_SOLID, line_to_draw);
   }


fg_drawlineclip            ОТКЛИППИРОВАТЬ и НАРИСОВАТЬ ЛИНИЮ

   Использование:

   #include <fg.h>
   void fg_drawlineclip(fg_color_t color,
                        int mode, int mask, int line_type,
                        fg_pline_t line, fg_pbox clipbox);

   Описание:

   Клиппирует линию относительно  `clipbox'  и рисует остав-
   шуюся  часть.   Для  клиппирования  используется  функция
   fg_lineclip(). Если результат неудовлетворителен, програм-
   мист может включить альтернативную  функцию с тем же име-
   нем (см.`fg_lineclip()').

   Относительно прочих  (помимо clipbox)  входных параметров
   смотрите описание fg_drawline().


fg_drawmatrix                             НАРИСОВАТЬ МАТРИЦУ

   Использование:

   #include <fg.h>
   void fg_drawlineclip(fg_color_t color,
                        int mode, int mask, int rotation,
                        fg_coord_t x, fg_coord_t y, char *p,
                        fg_pbox_t b, fg_pbox_t clipbox);

   Описание:

   Рисует матрицу точек  размерами (b[X2]+1)*(b[Y2]+1). Мат-
   рица рисуется сверху вниз,  т.е. первый ряд (строка) дан-
   ных по указателю p рисуется в верхнем  ряду  матрицы.  На
   дисплей выводятся только те пиксели, для которых соответ-
   ствующие биты установлены в 1.  Тем самым изображение мо-
   жет накладываться на то, что уже находится на экране. Для
   получения другого результата следует  предварительно выз-
   вать fg_fillbox().

   Входные параметры:

      color, mode, mask   Цвет, режим и маска,  используемые
                          при выводе матрицы.
      rotation, x, y      FG_ROTx  используется для поворота
                          относительно x, y,  а (x, y) явля-
                          ется нижним левым углом места, ку-
                          да записывается матрица.
      p                   Указатель  на  данные, управляющие
                          рисованием,  которые являются мас-
                          сивом длиной (b[X2+1+7])/8*(b[Y2+1])
                          байтов.  (Здесь первый сомножитель
                          задает число байтов, соответствую-
                          щих ряду матрицы, а второй - число
                          рядов; каждый ряд начинается с на-
                          чала байта).  Бит 0 байта соответ-
                          ствует крайнему  правому  пикселю,
                          бит 7 байта - крайнему левому.
      b                   Охватывающая рамка. (Задает разме-
                          ры матрицы).  b[FG_X1]=d[FG_Y1]=0.
      clipbox             Клиппирующий прямоугольник.

   Пример:

   {
     static char mouse_cursor={0xF0, 0xC0, 0xA0, 0x10, 0x08};
     static fg_box_t mouse_box={0, 0, 4, 4};
     fg_drawmatrix(FG_WHITE, FG_MODE_SET,~0, FG_ROT0, 0, 0,
                   mouse_cursor, mouse_box,  fg_displaybox);
                                        /* Это рисуется как:

                           X X X X 0
                           X X 0 0 0
                           X 0 X 0 0
                           0 0 0 X 0
                           0 0 0 0 X

где X устанавливаются в WHITE (белый), а нули остаются
                                           без изменения. */
   }

fg_drawthickline                    НАРИСОВАТЬ ТОЛСТУЮ ЛИНИЮ

   Использование:

   #include <fg.h>
   void fg_drawthickline(fg_color_t color, int mode,
                         int mask, int line_type,
                         fg_pline_t line, fg_pbox_t clip,
                         int thickness);

   Описание:

   Рисует толстую линию.  `Перо' рисует так, как если бы оно
   было квадратным, т.е. толщина (thickness) задается в пик-
   селях.  Смотрите  fg_drawlineclip(),  содержащее описание
   входных параметров и сходный пример.


fg_fillbox                           ЗАПОЛНИТЬ ПРЯМОУГОЛЬНИК

   Использование:

   #include <fg.h>
   void fg_drawthickline(fg_color_t color,
                         int mode, int mask, fg_pbox_t box);

   Описание:

   Закрашивает рамку.  Рамка "box" должна быть уже отклиппи-
   рована.  Эта функция может  быть  использована для чистки
   экрана, если рамка эквивалентна fg_displaybox.

   Пример:

					 /* чистка экрана */
   fg_fillbox(FG_BLACK, FG_MODE_SET, ~0,
              fg_displaybox);


fg_flush                               ВЫТОЛКНУТЬ НА ДИСПЛЕЙ

   Использование:

   #include <fg.h>
   void fg_flush(void)

   Описание:

   Выталкивает задержанный вывод на дисплей. Ждет установле-
   ния экрана. Этот вызов должен бы предшествовать ожидаемо-
   му вводу  пользователя, чтобы обеспечить нужное состояние
   экрана.

   Пример:

   fg_flush();



fg_getcolormap                 ЧИТАТЬ ПАЛИТРУ (КАРТУ ЦВЕТОВ)

   Использование:

   #include <fg.h>
   void fg_getcolormap(fg_color_t *color_array,
                       int max_entries);

   Описание:

   Выбирает  значения из текущей карты цветов.

      max_entries    Максимальное число цветов, которое мож-
                     но  записать  в  массив  color_array[].
                     Действительное   количество  записанных
                     цветов    будет   равно    меньшему  из
                     fg_nsimulcolor  и  max_entries.

      color_array    Массив цветов.  Значения между 0 и
                     fg_ncolormap-1.
   Пример:

   {
     fg_color_t color_array[16];
     fg_getcolormap(color_array,16);
   }



fg_init                     ИНИЦИАЛИЗИРОВАТЬ БЫСТРУЮ ГРАФИКУ

   Использование:

   #include <fg.h>
   void fg_init(void)

   Описание:

   Инициализирует  графический  режим после вызова  fg_term.
   Смотрите fg_init_all() и родственные ей функции.  fg_init
   восстановит  графический режим в состоянии на момент пос-
   леднего вызова fg_term().

   Пример:

   fg_init();

   Функция  полезна для временного  переключения в текстовый
   режим.

   fg_init_all();                   /* фрагмент программы* /
   fg_term();
   system("cdir");
   fg_init();                       /* фрагмент программы* /
   fg_term();



fg_init_null - fg_init_vga12             ИНИЦИАЛИЗИРОВАТЬ FG

   Использование:

   #include <fg.h>

   Функции прототипы               Переменная  окружения для
                                   fg_init_all
   int fg_init_null (void)
   int fg_init_all  (void)
   int fg_init_egaecd (void)       FG_EGAECD
   int fg_init_egacolor (void)     FG_EGACOLOR
   int fg_init_egamono (void)      FG_EGAMONO
   int fg_init_herc (void)         FG_HERC или
                                   FG_HERCFULL
   int fg_init_cga (void)          FG_CGAHIRES
   int fg_init_cgamedres ()        FG_CGAMEDRES
   int fg_init_8514a ()            FG_8514A
   int fg_init_toshiba (void)      FG_TOSHIBA
   int fg_init_vga11 (void)        FG_VGA11
   int fg_init_vga12 (void)        FG_VGA12

   Описание:

   Каждая из функций  открывает  дисплейное  устройство.  До
   открытия запоминает текущий режим дисплейного устройства,
   так что в дальнейшем  он будет восстановлен при обращении
   к fg_term(). Устанавливает дисплейное устройство в графи-
   ческий режим. Устанавливает в ноль номер текущей дисплей-
   ной страницы. Заносит характеристики текущего дисплейного
   устройства в глобальные переменные:

   fg_display  устанавливается в возвращаемое функциями зна-
   чение, fg_activepage  и  fg_displaypage устанавливаются в
   ноль. Страница 0 устанавливается в FG_BLACK (черный).

   Возвращаемое значение:

   Целое,  задает тип открытого дисплейного устройства, одно
   из FG_EGAECD, FG_VGA11 и пр. В случае неудачи возвращает-
   ся FG_NULL.

   fg_init_all() пытатется определить тип наличной  дисплей-
   ной графики и открывает это дисплейное устройство.  Пере-
   менная окружения FG_DISPLAY перезаписывается. Это полезно
   для нестандартных плат или для плат, эмулирующих несколь-
   ко других плат.
   fg_init_herc() исходит из предположения,  что графическое
   устройство является устройством типа HERCULES.  Оно будет
   открыто, если имеется 1 или 2 доступные страницы.
   fg_init_null() открывает графическое устройство - битовую
   карту (bit_bucket). Всегда возвращает FG_NULL.

   Первая попытка  открытия  графического  устройства должна
   осуществляться вызовом  одной  из  fg_init_XXX() функций.
   Последующие попытки открыть  дисплей  (после  возвращения
   из текстового режима,  установленного  fg_term()),  можно
   делать, используя fg_init_(). Вызов fg_init_() выполняет-
   ся много быстрее вызова fg_init_XXX().  По мере появления
   новых устройств  соответствующие  функции будут названы и
   обеспечены.

   Пример:

   {
     if (fg_init_all()==FG_NULL)
        {
          fputs("Не могут открыть графическое устройство.\h",
                stderr);
          exit(1);
        }
   }


fg_line_cpy                                 КОПИРОВАТЬ ЛИНИЮ

   Использование:

   #include <fg.h>
   fg_pline_t fg_line_cpy(fg_pline_t to, fg_pline_t from);

   Описание:

   Копирует линию  "from"  в линию  "to".  Возвращает  "to".

   Пример:

   fg_line_cpy(destination_line, source_line);



fg_putc                                       ВЫВЕСТИ ЛИТЕРУ

   Использование:

   #include <fg.h>
   void fg_putc(fg_color_t color, int mode, int mask,
                int rotation, fg_coord_t x, fg_coord_t y,
                char out_char, fg_pbox_t clip_box);

   Описание:

   Посылает  литеру  на экран,  используя  специфицированные
   вращение, цвет, маску и режим. x, y задают позицию левого
   нижнего угла литеры,  относительно которой литера повора-
   чивается на заданный угол.  Задействованные пиксели клип-
   пируются относительно заданного прямоугольника `clipbox'.

   Пример:

   fg_putc(FG_WHITE, FG_MODE_SET,~0,
           FG_ROT270, 100, 100, `Z',  fg_displaybox);


fg_puts                                       ВЫВЕСТИ СТРОКУ

   Использование:

   #include <fg.h>
   void fg_puts(fg_color_t color, int mode,
   int mask, int rotation, fg_coord_t x,
   fg_coord_t y, char *out_string, fg_pbox_t clip);

   Описание:

   Выводит строку на графическое устройство. Использует спе-
   цифицированные цвет, режим,  маску и вращение.  Начальная
   точка левого  нижнего угла первой  литеры  задается коор-
   динатами x, y. Выводимая строка `out_string' клиппируется
   относительно `clip'.

   Пример:

   fg_puts(FG_WHITE, FG_MODE_SET,~0, FG_ROT0,
   0, 0, "Hello world.", fg_displaybox);


fg_readbox                                      ЧИТАТЬ РАМКУ

   Использование:

   #include <fg.h>
   void fg_readbox(fg_pbox_t b, fg_color_t *p);

   Описание:

   Считывает  пиксели,  заключенные в прямоугольнике `b',  с
   экрана  в массив элементов типа  fg_color_t  по указателю
   `p'.  В каждый элемент массива записывается  цвет каждого
   пикселя.  Число  записанных байтов равно,  следовательно,
   числу заключенных в рамку пикселей, умноженному на размер
   fg_color_t.  Запись идет по рядам, которые записываются в
   порядке возрастания y  (т.е.  запись  начинается с левого
   нижнего угла).

   Пример:

   {
     fg_color_t *color_p;
     fg_box_t read_box;
     unsigned int bytes;
     read_box[FG_X1]=10;
     read_box[FG_Y1]=0;
     read_box[FG_X2]=100;
     read_box[FG_Y2]=100;
     bytes=read_box[FG_X2]-read_box[FG_X1]+1;
     bytes *=read_box[FG_Y2]-read_box[FG_Y1]+1;
     bytes *=sizeof(fg_color_t);
     color_p=malloc(bytes);
     assert(color_p !=NULL);
     fg_readbox(read_box, color_p);
     ...
                            /* необязательно та же рамка,
                           но обязательно того же размера */
     read_box[FG_X1]+=20;
     read_box[FG_X2]+=20;
     read_box[FG_Y1]+=30;
     read_box[FG_Y2]+=30;
     fg_writebox(read_box, color_p);
   }


fg_readdot                                      ЧИТАТЬ ТОЧКУ

   Использование:

   #include <fg.h>
   fg_color_t fg_readdot(fg_coord_t x, fg_coord_t y);

   Описание:

   Читает цвет точки с координатами x, y. (x, y) должна нахо-
   диться внутри fg_displaybox.

   Пример:

   {
     fg_color_t dot_color;
     dot_color=fg_readdot(0,0);
   }


fg_restore                                      ВОССТАНОВИТЬ

   Использование:

   #include <fg.h>
   void fg_restore(fg_handle_t handle);

   Описание:

   Восстанавливает область экрана, сохраненную функцией
   fg_save().

      hangle      Значение, возвращаемое fg_save();  в даль-
                  нейшем недействительно. Не может использо-
                  ваться в последующих вызовах fg_restore().

   Пример: Смотрите fg_save().



fg_save                                            СОХРАНИТЬ

   Использование:

   #include <fg.h>
   fg_handle_t fg_save(fg_pbox_t box);

   Описание:

   Сохраняет область экрана.  Эта область может быть восста-
   новлена fg_restore().  Заметим,  что сохраненная  область
   может быть  восстановлена в той же самой позиции страницы
   (или той же позиции  другой страницы, если активная стра-
   ница сменилась).

   Пример:

   {
     fg_box_t save_box;
     fg_handle_t save_handle;
     save_box[FG_X1]=save_box[FG_Y1]=0;
     save_box[FG_X2]=save_box[FG_Y2]=100;
     save_handle=fg_save(save_box);
     assert (save_handle !=NULL);
     ...
     fg_restore (save_handle);
   }

   Возвращаемое значение:

  fg_handle_t    Дескриптор для использования в fg_restore().

  NULL           В случае ошибки (вероятно, нехватка памяти).


fg_setactivepage                УСТАНОВИТЬ АКТИВНУЮ СТРАНИЦУ

   Использование:

   #include <fg.h>
   void fg_setactivepage(unsigned int pagenum);

   Описание:

   Изменяет номер активной страницы.  Активная страница есть
   страница, в которой  работают  все  процедуры FG графики.
   Не обязательно,  что эта страница является  отображаемой.
   `pagenum'   должен   быть   меньше,   чем   fg_numpages.
   fg_activpage  устанавливается  в `pagenum'.

   Пример:

   fg_setactivepage(1);

   Рекомендация:  Смотрите также fg_setdisplaypage.


fg_setcolormap                            УСТАНОВИТЬ ПАЛИТРУ

   Использование:

   #include <fg.h>
   void fg_setcolormap(fg_color_t carray[], int max);

   Описание:

   Устанавливает все цвета в карте  цветов.  Карта цветов не
   модифицируема, если fg_ncolormap==fg_nsimulcolor.

   carray   Массив цветов, размерностью fg_nsimulcolor. Зна-
            чения между 0 и fg_ncolormap-1.
   max      Максимальное число элементов, которые можно про-
            честь из массива  color_array[].  Действительное
            число  прочтенных  цветов - минимум  из
            fg_nsimulcolor и max.



fg_setdisplaypage             УСТАНОВИТЬ ДИСПЛЕЙНУЮ СТРАНИЦУ

   Использование:

   #include <fg.h>
   void fg_setdisplaypage(unsigned pagenum);

   Описание:

   Изменяет номер дисплейной  страницы.  Дисплейная страница
   есть страница, наблюдаемая на экране  дисплея.  `pagenum'
   должен быть меньше, чем fg_numpages.

   Пример:

   fg_setdisplaypage(0);

   Рекомендация:  Смотрите также  fg_setactivepage.

   Выход:

      fg_displaypage, установленная в `pagenum'.


fg_setlinepattern                    УСТАНОВИТЬ ШАБЛОН ЛИНИИ

   Использование:

   #include <fg.h>
   void fg_setlinepattern(int line_type, int pattern);

   Описание:

   Устанавливает шаблон для вывода линии.

   line_type   Значение между 0 и FG_LINE_MAX-1. Последующее
               использование  этого значения будет использо-
               вать этот шаблон.
   pattern     16-битовое значение, определяющее шаблон. На-
               чало шаблона определяет бит 15, затем спуск к
               биту 0 и затем повторение. Если fg_drawlinep()
               должна всегда рисовать  только точку в начале
               линии, бит 15 должен быть установлен в 1.

   Пример:

   {
                            /* очень-очень редкий пунктир */
     fg_setlinepattern(FG_LINE_USER_DEFINED, 0x8000);
   }


fg_term                        ПЕРЕЙТИ В РЕЖИМ А/Ц ТЕРМИНАЛА

   Использование:

   #include <fg.h>
   void fg_term(void)

   Описание:

   Закрывает дисплейное  устройство.  Дисплей возвращается в
   предшествовавшее  fg_init() состояние.  Если fg_init() не
   вызывалась,  ничего  не делает.  То же справедливо,  если
   fg_term() вызывается вслед за  fg_term().  Таким образом,
   процедура  осуществляет  экстренный  возврат к текстовому
   режиму безотносительно к тому, установлен графический ре-
   жим или нет.

   Пример:

   fg_term();          /* Возвращение к текстовому режиму */


fg_writebox                                     ПИСАТЬ РАМКУ

   Использование:

   #include <fg.h>
   void fg_writebox(fg_pbox_t box, fg_color_t *p);

   Описание:

   Обратная к функции fg_readbox(). Пишет пиксели в активную
   страницу.

      box       Ограничивающий прямоугольник для записи пик-
                селей.
      p         Указатель на массив цветов, по одному  цвету
                на каждый пиксель.

   Пример:

   Смотрите fg_readbox

   Рекомендация:  

   Cмотрите также fg_readbox.