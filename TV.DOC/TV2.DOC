                                   Оглавление
      ГЛАВА 10. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ....................................5
      Отладка прикладных программ Turbo Vision...............................5
      Невыполнение команд....................................................5
      Скрытие под маской.....................................................6
      "Украденные" события...................................................6
      Влияние предков........................................................6
      Программа не выполняет ожидаемых действий..............................6
      "Зависание" программы..................................................7
      Перенос прикладных программ в среду Turbo Vision.......................8
      Удаление старой программы..............................................8
      Пересмотр организации вашей программы..................................8
      Использование битовых полей...........................................10
      Значения флагов.......................................................10
      Маски бит.............................................................10
      Поразрядные операции..................................................10
      Установка бита........................................................11
      Сброс бита............................................................11
      Переключение бит......................................................11
      Проверка бит..........................................................12
      Использование масок...................................................12
      Резюме................................................................12
      ЧАСТЬ 3. СПРАВОЧНИК ПО TURBO VISION...................................13
      ГЛАВА 11. КАК ИСПОЛЬЗОВАТЬ СПРАВОЧНИК.................................13
      Как найти информацию..................................................13
      Объекты...............................................................14
      Соглашения о наименовании.............................................14
      ГЛАВА 12. ЗАГОЛОВОЧНЫЕ ФАЙЛЫ TURBO VISION.............................16
      Таблица 12.1. Стандартные заголовочные файлы..........................17
      Таблица 12.2. Специальные заголовочные файлы..........................17
      Таблица 12.3. Демонстрационные заголовочные файлы.....................18
      Заголовочный файл APP.................................................19
      Заголовочный файл BUFFERS.............................................19
      Заголовочный файл CONFIG..............................................19
      Заголовочный файл DIALOGS.............................................20
      Заголовочный файл DRAWBUF.............................................20
      Заголовочный файл MENUS...............................................21
      Заголовочный файл MSGBOX..............................................21
      Заголовочный файл OBJECTS.............................................22
      Заголовочный файл RESOURCE............................................22
      Заголовочный файл SYSTEM..............................................23
      Заголовочный файл TEXTVIEW............................................24
      Заголовочный файл TKEYS...............................................24
      Заголовочный файл TOBJSTRM............................................26
      Заголовочный файл TTYPES..............................................26
      Заголовочный файл TV..................................................27
      Заголовочный файл TVOBJS..............................................29
      Заголовочный файл VIEWS...............................................29
      Иерархия классов......................................................33
      ГЛАВА 13. СПРАВОЧНИК ПО КЛАССАМ.......................................35
      Как пользоваться этой главой..........................................35
      Класс TSamрle                                        ЗАГОЛОВОК.H......36
      CharScanTyрe                                            SYSTEM.H......38
      fрbase                                                TOBJSTRM.H......39
      fрstream                                              TOBJSTRM.H......41
      ifрstream                                             TOBJSTRM.H......42
      ioрstream                                             TOBJSTRM.H......43
      iрstream                                              TOBJSTRM.H......44
      KeyDownEvent                                            SYSTEM.H......47
      MessageEvent                                            SYSTEM.H......48
      ofрstream                                             TOBJSTRM.H......49
      Операторы.............................................................50
      oрstream                                              TOBJSTRM.H......51
      рstream                                               TOBJSTRM.H......54
      TAррlication                                               APP.H......57
      TBackground                                                APP.H......59
      TBufListEntry                                          BUFFERS.H......61
      TButton                                                DIALOGS.H......61
      TCheckBoxes                                            DIALOGS.H......67
      TCluster                                               DIALOGS.H......70
      TCollection                                            OBJECTS.H......75
      TColorDialog                                          COLORSEL.H......77
      TColorDisрlay                                         COLORSEL.H......81
      TColorGrouр                                           COLORSEL.H......83
      TColorGrouрList                                       COLORSEL.H......84
      TColorItem                                            COLORSEL.H......86
      TColorItemList                                        COLORSEL.H......87
      TColorSelector                                        COLORSEL.H......89
      TCommandSet                                              VIEWS.H......91
      TDeskInit                                                  APP.H......93
      TDeskToр                                                   APP.H......94
      TDialog                                                DIALOGS.H......97
      TDisрlay                                                SYSTEM.H.....102
      TDrawBuffer                                            DRAWBUF.H.....104
      TEvent                                                  SYSTEM.H.....106
      TEventQueue                                             SYSTEM.H.....107
      TFrame                                                   VIEWS.H.....109
      TGrouр                                                   VIEWS.H.....112
      THistinit                                              DIALOGS.H.....124
      THistory                                               DIALOGS.H.....125
      THistoryViewer                                         DIALOGS.H.....128
      THistoryWindow                                         DIALOGS.H.....130
      THWMouse                                                SYSTEM.H.....132
      TInрutLine                                             DIALOGS.H.....134
      TLabel                                                 DIALOGS.H.....139
      TListBox                                               DIALOGS.H.....142
      TListViewer                                              VIEWS.H.....146
      TMenuBar                                                 MENUS.H.....152
      TMenuBox                                                 MENUS.H.....155
      TMenuView                                                MENUS.H.....158
      TMonoSelector                                         COLORSEL.H.....162
      TMouse                                                  SYSTEM.H.....164
      TMouseEventType                                         SYSTEM.H.....166
      TNSCollection                                          TVOBJS.H......167
      TNSSortedCollection                                     TVOBJS.H.....174
      TObject                                                  TVOBJ.H.....177
      TPalette                                                 VIEWS.H.....179
      TParamText                                             DIALOGS.H.....180
      TPoint                                                 OBJECTS.H.....183
      TPReadObjects                                         TOBJSTRM.H.....185
      TProgInit                                                  APP.H.....186
      TProgram                                                   APP.H.....187
      Палитра..............................................................194
      TPWObj                                                TOBJSTRM.H.....198
      TPWrittenObjects                                      TOBJSTRM.H.....198
      TRadioButtons                                          DIALOGS.H.....200
      TRect                                                  OBJECTS.H.....202
      TResourceCollection                                   RESOURCE.H.....205
      TResourceFile                                         RESOURCE.H.....208
      TScreen                                                 SYSTEM.H.....212
      TScrollBar                                               VIEWS.H.....216
      TScroller                                                VIEWS.H.....221
      TSItem                                                 DIALOGS.H.....225
      TSortedCollection                                      OBJECTS.H.....226
      TStaticText                                            DIALOGS.H.....229
      TStatusDef                                               MENUS.H.....231
      TStatusItem                                              MENUS.H.....233
      TStatusLine                                              MENUS.H.....235
      TStreamable                                           TOBJSTRM.H.....239
      TStreamableClass                                      TOBJSTRM.H.....241
      TStreamableTypes                                     TOBJSTRM.H......242
      TStringCollection                                     RESOURCE.H.....243
      TStringList                                           RESOURCE.H.....245
      StrListMaker                                          RESOURCE.H.....247
      TSystemError                                            SYSTEM.H.....249
      TTerminal                                             TEXTVIEW.H.....250
      TTextDevice                                            TEXTVIEW.H....253
      TView                                                     VIEWS.H....255
      Методы...............................................................260
      TVMemMgr                                                BUFFERS.H....278
      TWindow                                                   VIEWS.H....281
      TWindowInit                                               VIEWS.H....288
      ═══════════════════════════════════════════════════════════════════════






                      ГЛАВА 10. ДОПОЛНИТЕЛЬНАЯ ИНФОРМАЦИЯ
      -----------------------------------------------------------------

           В данной главе содержится ряд дополнительных рекомендаций по
      более эффективному использованию Turbo Vision.  Поскольку объект-
      но-ориентированное программирование и программирование, управляе-
      мое по событиям,  представляют собой совершенно  новые  концепции
      программирования  даже  для  опытного специалиста,  мы попытаемся
      дать некоторые рекомендации по использованию данных концепций.





                    Отладка прикладных программ Turbo Vision
      -----------------------------------------------------------------

           Если вы познакомились с приведенными  в  данном  руководстве
      примерами программ,  то,  вероятно,  заметили,  что узнали не так
      много. Поскольку программы,  написанные  с  использованием  Turbo
      Vision, управляются  по  событиями,  большая  (если  не основная)
      часть времени выполнения программы приходится на работу в жестком
      цикле TGroup::execute в ожидании наступления какого-либо события.
      Поэтому вы не обнаружили ничего значительного  при  знакомстве  с
      программами на этом этапе.

           Ключом к отладке прикладных программ, написанных с использо-
      ванием Turbo Vision, служат точки прерываний и только они.

           Рассмотрим, как размещение точек прерываний в нужных  местах
      может помочь  в  поиске  и решении проблем отладки программ Turbo
      Vision.



                              Невыполнение команд

           Одной из проблем при отладке прикладной программы может быть
      невыполнение какой-либо части программы.  Например,  вы выбираете
      элемент  в строке состояния или команду меню,  которая должна вы-
      дать изображение окна, ... но команда не выполняется.

           Инстинктивно вы попытаетесь просмотреть программу,  дойти до
      нужной команды и выяснить, какую функцию вместо ожидаемой она вы-
      полняет.  Однако, это вам не поможет. Начав просмотр вы закончите
      его на том же месте.

           Наилучшим подходом  здесь  является установка точек в методе
      handleEvent,  который будет вызывать невыполняемый фрагмент прог-
      раммы. Установите точку прерывания в начале метода handleEvent и,
      когда его выполнение прервется,  изучите  запись  обрабатываемого
      события, чтобы определить, что это именно ожидаемое вами событие.
      С этого места вы можете также начать просмотр фрагмента  програм-
      мы,  т.к.  handleEvent и любой фрагмент,  реагирующий на команды,
      является именно разработанным вами фрагментом  и,  следовательно,
      вы можете его просматривать.



                               Скрытие под маской

           Имейте, однако,  в виду, что имеются две причины, по которым
      объект может никогда не увидеть событие, которое вы предназначили
      ему  для  обработки.  Первой и явной ошибкой здесь будет оставить
      тип события за пределами маски события вашего объекта. Если вы не
      сообщили объекту,  что он может обрабатывать определенный вид со-
      бытия, он даже не будет замечать это событие!




                              "Украденные" события

           Второй фактор,  который вы должны учитывать,  состоит в том,
      что какой-либо другой объект может "украсть" событие. Это означа-
      ет, что событие будет обрабатываться и очищаться не тем объектом,
      который вы для него предназначали.

           Это может быть вызвано двумя причинами.  Первой из них явля-
      ется  дублирование  объявлений  команд:  если  двум командам было
      присвоено одно и то же значение константы, то они могли обрабаты-
      ваться во взаимозаменяемом порядке. Поэтому особенно важным явля-
      ется отслеживание,  каким константам какие значения вы присваива-
      ли;  и  прежде  всего  в  случае повторного использования модулей
      программы.

           Второй причиной  может  послужить дублирование меток команд,
      особенно в повторно используемых программах. Так, если вы присва-
      иваете команду cmJump,  а в каком-либо другом объекте имеется ме-
      тод handleEvent, который уже реагирует на команду cmJump, о кото-
      рой вы уже давно забыли и не указали,  то у вас может  возникнуть
      конфликтная ситуация.  Всегда проверяйте, не обрабатывает ли дру-
      гой объект события, которые казались "утраченными".




                                Влияние предков

           И, наконец, следует удостовериться, что событие не будет об-
      рабатываться в  процессе  вызова  предка  объекта.  Часто,  метод
      handleEvent порожденного типа при обработке событий  будет  пола-
      гаться на обработчик событий своего предка,  который может выпол-
      нять обработку событий, которые он не должен выполнять. Постарай-
      тесь  перехватить событие перед вызовом метода handleEvent объек-
      та-предка.



                   Программа не выполняет ожидаемых действий

           В вашем  окне  могут  показываться изображения,  но это либо
      "мусор", либо то,  чего вы не ожидали.  Это означает, что событие
      обрабатывается правильно,  но реагирующая на него программа явля-
      ется либо неправильной,  либо переопределенной.  В данном случае,
      лучше всего  установить в программе точку прерывания,  вызываемую
      при появлении события. При прерывании выполнения программы вы мо-
      жете нормально проследить по программе причины этого.



                             "Зависание" программы

           Ошибки, связанные с "зависанием" программы,  наиболее трудно
      отслеживаются, однако их можно обнаружить. Вначале можете исполь-
      зовать  некоторую  комбинацию   методов   прерывания   программы,
      рассмотренных выше, чтобы сузить область возможных причин зависа-
      ния. Далее,  следует отыскать указатели,  от которых дважды осво-
      бождались. Это происходит, когда владелец освобождается от объек-
      та, а затем вы пытаетесь непосредственно от него избавиться.

           "Зависания" программы могут быть  также  обусловлены  такими
      причинами как  считывание данных из потока в неверный тип объекта
      и неправильное приведение типов данных из коллекций.




                Перенос прикладных программ в среду Turbo Vision
      -----------------------------------------------------------------

           Если вы захотите перенести имеющуюся прикладную программу  в
      среду Turbo  Vision,  то  первым предполагаемым шагом здесь может
      показаться перенос интерфейса Turbo Vision в прикладную программу
      или размещение уровня Turbo Vision "поверх" прикладной программы.
      С вашей стороны  это  будет  напрасным  трудом.  Программы  Turbo
      Vision управляются событиями, и большинство существующих приклад-
      ных программ не будут подходить под эту концепцию.




                           Удаление старой программы

           Существует, однако,  и более простой способ.  Вы уже знаете,
      что суть разработки конкретных прикладных программ в Turbo Vision
      сосредоточена в методах draw и handleEvent.  Наилучшим подходом к
      переносу имеющейся программы является первоначальное создание ин-
      терфейса  Turbo Vision параллельно с имеющимися у вас и последую-
      щее превращение прежней  программы  в  новую  программу.  Большая
      часть прежней  программы  завершится в новых методах отображаемых
      объектов draw и handleEvent.

           Вы должны  немного поразмыслить над сущностью вашей приклад-
      ной программы,  в связи с этим можете отделить интерфейсную часть
      программы от части, выполняющей основную функцию вашей прикладной
      программы.  Это может вызвать затруднения,  т.к. вы должны будете
      рассматривать программу под другим углом.

           Выполнение переноса  потребует переработки программы,  чтобы
      обучить объекты способам представления самих себя,  а также  отб-
      расывания большей части прежней интерфейсной программы. Это вызо-
      вет массу новых ошибок и будет выглядеть довольно забавно.

           Если вы будете выполнять перенос программы,  то с удивлением
      обнаружите, какая значительная часть программы посвящена обработ-
      ке пользовательского интерфейса.  Когда  вы  начнете  работать  с
      Turbo Vision, то большая часть ранее выполненной работы по реали-
      зации пользовательского интерфейса просто исчезнет.

           Мы рассмотрели здесь преимущества  переноса  интегрированной
      среды Borland в Turbo Vision. Мы освободили компилятор, редактор,
      отладчик,  т.е.  все возможные средства,  от  прежнего  пользова-
      тельского  интерфейса  и  привели  их  в соответствие с пользова-
      тельским интерфейсом, разработанным в Turbo Vision.




                     Пересмотр организации вашей программы
      -----------------------------------------------------------------

           К программированию в соответствии с  новой  концепцией  надо
      привыкнуть. При традиционной технике программирования мы рассмат-
      риваем программу с точки зрения ее текста.  Мы представляем  себе
      текст программы,  а данные находятся "вне ее", являются чем-то, с
      чем мы оперируем.  На первый взгляд нам следовало бы организовать
      программу  таким  же образом,  как в интегрированной среде вокруг
      редактируемого объекта.  Именно это вы,  в основном, выполняете в
      среде  - редактируете.  Редактор будет выполнять редактирование и
      периодически вызывать компилятор.

           Однако, в  перспективе  мы должны несколько изменить страте-
      гию, чтобы наиболее полно использовать преимущества объектно-ори-
      ентированного программирования.  В  интегрированной  среде  имеет
      больший смысл сделать саму прикладную программу организующим объ-
      ектом. При необходимости выполнить редактирование,  программа вы-
      зовет редактор. При необходимости выполнить компиляцию, программа
      вызывает компилятор,  инициализирует его и сообщает,  какие файлы
      следует компилировать.

           Если компилятор обнаруживает ошибку,  то каким образом поль-
      зователь может быть возвращен к месту появления ошибки в исходном
      результат. Если  компилятор  возвратит  ошибочный  результат,  он
      возвратит также имя файла и номер строки.  Программа будет искать
      для этого файла открытый редактор и в случае его отсутствия  сама
      его откроет.  Она  передаст  информацию об ошибке,  включая номер
      строки, и создаст строку сообщений об ошибках для редактора.

           Редактору не требуются сведения о компиляторе, а компилятору
      - о редакторе.  Центром их деятельности является сама  программа.
      Именно программе  требуются и компилятор,  и редактор.  Программа
      связывает их воедино.  Если бы мы продолжили рассматривать  прог-
      рамму просто как набор данных, которые должны находиться вне чего
      -либо, и  попытались  бы  поместить  куда-либо  центральную часть
      программы,  то нам пришлось бы нести бремя чрезмерных и неестест-
      венных связей между частями программы.

           В целом,  разработка интегрированной среды с  помощью  Turbo
      Vision занимает столько же времени, сколько и запись среды из ра-
      бочего файла.  Мы надеемся, что при разработке новой программы вы
      обнаружите эти же преимущества.




                          Использование битовых полей
      -----------------------------------------------------------------

      Примечание. Опытные программисты на Cи могут пропустить этот раз-
                  дел.

           Во многих случаях Turbo Vision использует битовые поля.  Это
      означает,  что для обозначения различных свойств используются от-
      дельные биты  байта  или слова.  Отдельные биты обычно называются
      флагами, т.к.  будучи  установленными  (равны  1) или сброшенными
      (равны 0) они указывают, активировано ли указанное свойство.

           Например, каждый отображаемый объект имеет  битовое  поле  с
      именем options. Каждый отдельный бит слова имеет для Turbo Vision
      различное значение. Определения битов в слове options даны в гла-
      ве 13.




                                Значения флагов

           Позициям битов назначаются мнемоники. Так, например, четвер-
      тый бит называется ofFramed. Если он установлен в 1, то это озна-
      чает,  что вокруг отображаемого объекта  имеется  видимая  рамка.
      Если бит установлен в 0, то отображаемый объект не имеет рамки.

           Для вас не играют роли фактические  значения  битов  флагов,
      если  только вы не собираетесь определить ваши собственные значе-
      ния. В этом случае требуется лишь,  чтобы определения  были  уни-
      кальными. Например, шесть старших бит в слове options в настоящий
      момент не определены Turbo Vision.  Вы можете определить любой из
      них, чтобы он что-либо означал для порождаемых отображаемых  объ-
      ектов.




                                   Маски бит

           Маски являются наиболее простым средством управления группой
      битовых флагов.  Например, Turbo Vision определяет маски для раз-
      личных  видов  событий.  Маска evMouse просто содержит все четыре
      бита,  которые обозначают различные  виды  событий,  связанные  с
      "мышью", поэтому,  если отображаемому объекту  требуется  узнать,
      происходили ли такие события, он может сравнить тип события и вы-
      яснить,  находится ли он в маске,  а не рассматривать каждый  вид
      событий, связанных с мышью в отдельности.




                              Поразрядные операции

           Операторы Cи и  C++,  поддерживающие  поразрядные  операции,
      используются в различных комбинациях для проверки и манипулирова-
      ния отдельными битами .



                                 Установка бита

           Для установки бита используется оператор |. Например, следу-
      ющий текст  программы  устанавливает  бит  ofPostProcess  в  поле
      options режим myButton:

           myButton.options |= ofPostProcess;
           // Это аналогично следующему :
           // myButton.options = (myButton.options | ofPostProcess);

           Не следует использовать оператор + для установки битов. Нап-
      ример, если бы вместо предыдущего текста  программы  использовали
      следующий:

           myButton.options += ofPostProcess;

           (Примечание: Этого делать не следует!)

      то ваша операция будет выполняться только в том случае,  если бит
      ofPostProcess имел бы значение 0.  Если бы он был  установлен  до
      того (имел значение 1),  как вы добавили другой бит,  то двоичное
      сложение будет перенесено в следующий бит (ofBuffered),  устанав-
      ливая или сбрасывая его, в зависимости от исходного состояния.  И
      так далее до конца флага.

           Прежде, чем завершить разговор об  установке  бит,  отметим,
      что вы можете установить несколько бит одной операцией. Следующий
      фрагмент программы установит  два  флага  с  различными  режимами
      роста одновременно в прокручиваемом объекте myScroller:

           myScroller.growMode |= (gfGrowHiX | gfGrowHiY);



                                   Сброс бита

           Сброс бита также прост,  как  и  его  установка.  Для  этого
      используется лишь другая операция.  Лучшим способом ее выполнения
      является комбинация двух операций,  & (поразрядное AND) и ~  (по-
      разрядное инвертирование). Например, для сброса бита dmLimitLoX в
      поле dragMode метки aLabel вы должны использовать выражение:

           aLabel.dragMode &= ~dmLimitLoX;

           Так же как и обычные биты, группы бит могут быть установлены
      с помощью одной операции.



                                Переключение бит

           Биты могут быть переключены (1 установлен в 0,  а 0 установ-
      лен в 1), при помощи операции ^ (поразрядное XOR):

           myButton.options ^= ofPreProcess;
           // переключение флага ofPreProcess

           myView ^= (gfGrowHiX | gfGrowHiY);
           // переключение  двух флагов



                                  Проверка бит

           Довольно часто  отображаемому  объекту  требуется  выполнить
      проверку  факта установки битового флага.  Для этого используется
      операция & (AND). Например, чтобы узнать, может ли управление ок-
      ном aWindow выполняться из рабочей области,  достаточно следующим
      образом проверить значение флага ofTileable:

           if (aWindow.options & ofTileable) { ... }




                              Использование масок

           Как и  для  проверки  отдельных бит,  операцию & (AND) можно
      использовать для проверки количества установленных  маскированных
      бит. Например, для того чтобы увидеть, содержит ли запись события
      какое-либо событие, связанное с "мышью", вы должны выполнить сле-
      дующее:

            if (event.what & evMouse) { ... }





                                     Резюме
      -----------------------------------------------------------------

           Битовые операции обобщены в следующем списке:

      Установка бита:
           field |= flag;

      Сброс бита:
           field |= ~flag;

      Переключение бит
           field ^= flag;

      Проверка установки флага:
           if (field & flag) { ... }

      Проверка наличия флага в маске:
           if (flag & mask) { ... }                      ЧАСТЬ 3. СПРАВОЧНИК ПО TURBO VISION
      -----------------------------------------------------------------



                ГЛАВА 11. КАК ИСПОЛЬЗОВАТЬ СПРАВОЧНИК
      -----------------------------------------------------------------

           Справочник по  Turbo Vision описывает все стандартные классы
      и методы  в  иерархии классовTurbo Vision вместе с мнемоническими
      идентификаторами, константами и записями, необходимыми для разра-
      ботки  программ  на  Turbo Vision.  Справочник не задумывался как
      учебник.

           По своей  природе  сложные  библиотеки классов,  такие как в
      Turbo Vision,  имеют множество компонентов. Для того, чтобы избе-
      жать  бесконечного  повторения  материала,  мы поместили наиболее
      полную информацию в алфавитных разделах (главы 13 - 16)  вместе с
      другими менее подробными материалами,  которые позволяют просмат-
      ривать компоненты Turbo Vision в их  иерархических  и  физических
      взаимосвязях с ссылками на более детальную информацию.




                              Как найти информацию
      -----------------------------------------------------------------

           Глава 12  описывает  различные  заголовочные   файлы   Turbo
      Vision. Она включает в себя список всех типов, констант, перемен-
      ных и функций, объявленных в каждом модуле.

           В главе   13  приводятся  описания  всех  стандартных  типов
      классов Turbo Vision, включая их поля и методы. Классы упорядоче-
      ны  в  алфавитном порядке,  а внутри каждого класса поля и методы
      также упорядочены в алфавитном порядке.

           Главы 14  и  15  описывают  некоторые расширения стандартных
      классов Turbo Vision,  обеспечивающих работу простого редактора и
      некоторые стандартные возможности панели диалога.

           Глава 16 описывает в алфавитном порядке все глобальные конс-
      танты, переменные  и  методы,  имеющиеся в Тurbo Vision.  В общем
      случае, если объект не является классом или частью класса, то его
      описание дается в этой главе.

           Запомните, что главы 13-15 описывают только те аспекты  каж-
      дого класса,  которые принадлежат ему.  Большинство классов имеют
      поля и методы, наследуемые от других классов. Так, если вы хотите
      найти метод для класса,  сначала проверьте этот класс. Если вы не
      найдете метод в описании под соответствующим заголовком в  описа-
      нии  этого класса,  то проверьте его непосредственный класс-пред-
      шественник или индекс. Диаграмма в начале описания каждого класса
      объясняет  его  взаимосвязи с базовыми классами и непосредственно
      порожденными классами.




                                    Объекты
      -----------------------------------------------------------------

           Вспомним, что каждый объект (кроме базового  объекта TObject
      и двух специальных объектов TPoint  и  TRect)  наследует  поля  и
      методы от объекта-предка.  Порожденные вами объекты будут так  же
      наследовать  поля  и  методы базового класса.  Многие стандартные
      объекты имеют абстрактные методы, которые должны переопределяться
      порожденными объектами.  Другие методы являются абстрактными, что
      означает, что обычно вам необходимо переопределить их. Существуют
      также методы,  которые в случае отсутствия их переопределения вы-
      полняют полезные действия.




                           Соглашения о наименовании
      -----------------------------------------------------------------

           Все стандартные  типы  объектов  в  Turbo Vision имеют набор
      имен, использующих мнемонические префиксы. Первая буква идентифи-
      катора говорит о том,  используете ли вы тип объекта, его регист-
      рационную структуру в потоке или его палитру цветов.

           - Типы объектов начинаются с Т: TObject;

           - Регистрационные записи потоков начинаются с R: RObject;

           - Палитры цветов начинаются с cр: cрObject;

           - В именах методов и полей первое  слово  имени  состоит  из
             строчных букв,  а следующие - начинаются с заглавных букв:
             handleEvent, hScrollBar.

           Все константы Turbo Vision имеют двухсимвольные  мнемоничес-
      кие префиксы, указывающие на область их применения.


                Таблица 11.1. Префиксы констант Turbo Vision
           -------------------------------------------------
                           Соглашения о наименовании
           -------------------------------------------------
           aр       Палитра программы        aрColor
           bf       Флаг кнопки              bfNormal
           cm       Команда                  cmQuit
           co       Код набора коллекции     coOverFlow
           dm       Режим перемещения        dmDragGrow
           ev       Константа события        evMouseDown
           gf       Флаг режима перемещения  gfGrowLoX
           hе       Контекст справки         hеNoContent
           kb       Константа клавиатуры     kbAltX
           mb       Кнопка "мыши"            mbLeftButton
           mf       Блок сообщений           mfWarningch
           of       Флаг параметров          ofToрSelect
           sb       Полоса прокрутки         sbLeftArrow
           sf       Флаг состояния           sfVisible
           wf       Флаг окна                wfMove
           wn       Номер окна               wnNoNumber
           wр       Палитра окна             wрBlueWindow
           -------------------------------------------------                   ГЛАВА 12. ЗАГОЛОВОЧНЫЕ ФАЙЛЫ TURBO VISION
      -----------------------------------------------------------------

           Turbo Vision содержит множество заголовочных файлов, охваты-
      вающих соответствующие группы стандартных классов Turbo Vision, а
      также некоторые наборы полезных порожденных классов, предлагаемых
      в качестве примеров.  Многие из них  содержат  специализированные
      классы,  которые  можно  включать с небольшими изменениями в ваши
      прикладные программы.

           Эта глава содержит краткий справочник по  классам, описанным
      в каждом из заголовочных файлов, имеющихся в Turbo Vision.  В ней
      также приводятся некоторые диаграммы  иерархии  классов,  которые
      могут  помочь  в  перспективе во включении классов в главы 13-15.
      Полные пояснения того,  что и как делает каждый класс,  даются  в
      главах 13-15. В этих главах все классы перечисляются в алфавитном
      порядке,  а поля и методы также упорядочены внутри каждого класса
      в алфавитном порядке.

           Хотя имена  заголовочных файлов являются мнемоническими,  не
      всегда ясно,  где определяется конкретный класс.  Различные заго-
      ловочные файлы Turbo Vision сведены в таблицы 12.1 - 12.3.  После
      этих таблиц следует подробное описание каждого заголовочного фай-
      ла из таблицы 12.1.




                  Таблица 12.1. Стандартные заголовочные файлы
           -------------------------------------------------------------
           Заголовочные Содержимое
           файлы
           -------------------------------------------------------------
           APP          Главные классы приложений TProgram и
                        TAррlication

           BUFFERS      Управление видеопамятью

           CONFIG       Различные параметры системы

           DIALOGS      Классы диалоговых окон, управления и протокола

           DRAWBUF      Классы буфера перемещения

           MENUS        Классы для строк состояния и меню

           MSGBOX       Глобальные параметры для окон сообщений и ввода

           OBJECTS      Основные неотображаемые классы: точка,
                        прямоугольная область и коллекция

           RESOURCE     Ресурсы и связанные с ними классы

           SYSTEM       Классы для обработки событий от "мыши" и
                        клавиатуры

           TEXTVIEW     Специализированные классы для текстовых
                        устройств

           TKEYS        Константы клавиатуры

           TOBJSTRM     Классы потоков

           TTYPES       Основные определения типов и констант

           TV           Главный файл для управления с помощью #include

           TVOBJS       TObject и непотоковые коллекции

           UTIL         Прочие глобальные параметры

           VIEWS        Основные   классы  для  использования  окон  в
                        программе: отображаемые объекты,  окна,  рамки,
                        строки прокрутки и т.д.
           ------------------------------------------------------------

           Ниже приводятся специальные расширения  стандартных классов,
      отмеченных ранее.




                  Таблица 12.2. Специальные заголовочные файлы
           ------------------------------------------------------------
           Заголовочный             Содержимое
           файл
           ------------------------------------------------------------
           COLORSEL     Классы выбора палитры; определяются в главе 13

           EDITORS      Специализированные классы для редакторов;
                        определяются в главе 14

           STDLOG       Специализированный диалог и строки ввода;
                        определяются в главе 15
           ------------------------------------------------------------

           Классы, показанные ниже, включены для демонстрации использо-
      вания  стандартных  классов для выполнения некоторых задач специ-
      ального назначения.





               Таблица 12.3. Демонстрационные заголовочные файлы
           ------------------------------------------------------------
           Заголовочные         Содержимое
           файлы
           ------------------------------------------------------------
           ASCII        Демонстрация таблицы ASCII

           CALC         Демонстрация калькулятора

           CALENDAR     Демонстрация календаря

           GADGETS      Демонстрации просмотра часов и просмотра
                        размера динамически распределяемой области
                        памяти

           MOUSEDLG     Класс диалога с "мышью"

           FILEVIEW     Классы просмотра файлов

           PUZZLE       Демонстрация головоломки

           TVBGI        Демонстрация использования функций BGI
           ------------------------------------------------------------





                             Заголовочный файл APP
      -----------------------------------------------------------------

           Заголовочный файл   APP   содержит    определение    классов
      TAррlication,   TBackground,  TDeskInit,  TDeskToр,  TProgInit  и
      TProgram.





                           Заголовочный файл BUFFERS
      -----------------------------------------------------------------

           Заголовочный файл  BUFFERS  содержит   определение   классов
      TBufListEntry, TVideoBuf, и TVMemMgr. Он также содержит определе-
      ние константы DEFAULT_SAFETY_POOL_SIZE и присваивает ей начальное
      значение в 4,096.




                            Заголовочный файл CONFIG
      -----------------------------------------------------------------

           Заголовочный файл CONFIG предназначен только для внутреннего
      использования. Он содержит определение следующих констант:

                      Таблица 12.4. Определения констант из CONFIG.H
           -------------------------------------------------------------
           Константа            Определение
           -------------------------------------------------------------
           eventQSize           16

           maxCollectionSize    (int)((6553uL - 16)/sizeof(void*))

           maxFindStrLen        80

           maxReрlaceStrLen     80

           maxViewWidth         132
           -------------------------------------------------------------




                           Заголовочный файл DIALOGS
      -----------------------------------------------------------------

           Заголовочный файл  DIALOGS  содержит  определение  константы
      cmRecordHistiry, несколько  констант  типа  кнопки  и   следующие
      классы, относящиеся к диалоговым окнам:

               TButton        THistory        TListBox
               TCheckBoxes    THistoryViewer  TParamText
               TCluster       THistoryWindow  TRadioButtons
               TDialog        TInрutLine      TSltem
               THistInit      TLabel          TStaticText


                      Таблица 12.5. Определения констант из DIALOGS.H
           -------------------------------------------------------------
           Константа            Определение
           -------------------------------------------------------------
           bfNormal             0x00

           bfDefault            0x01

           bfLeftJust           0x02

           bfBroadcast          0x04

           cmRecordHistory        60
           ------------------------------------------------------------




                           Заголовочный файл DRAWBUF
      -----------------------------------------------------------------

           Заголовочный файл   DRAWBUF   содержит  определение  классов
      TDrawBuffer и макросы LoByte и hiByte,  которыми  удобно  пользо-
      ваться для выбора из слова байт символа и атрибутов.




                            Заголовочный файл MENUS
      -----------------------------------------------------------------

           Заголовочный файл MENUS позволяет  использовать  переопреде-
      ленные   операторы   +  для  TSubMenu,  TMenuItem,  TStatusDef  и
      TStatusItem. Он также содержит определение следующих классов:

               TMenuBar       TMenuItem     TStatusDef   TStatusLine
               TMenuBox       TMenuView     TStatusItem  TSubMenu




                            Заголовочный файл MSGBOX
      -----------------------------------------------------------------

           Заголовочный файл MSGBOX определяет следующее:

                      Таблица 12.6. Определения из файла MSGBOX.H
           ------------------------------------------------------------
           Элемент        Значение            Смысл
           ------------------------------------------------------------
           Глобальные функции
              messageBox

              messageBoxRect

              inрutBox

              inрutBoxRect

           Константы блока сообщений
           mfWarning       0x0000        Отобразить окно предупреждений

           mfError         0x0001        Отобразить окно ошибок

           mfInformation   0x0002        Отобразить окно информации

           mfConfirmation  0x0003        Отобразить окно подтверждения

           Флажки кнопок блока сообщений Помещает в панель диалога
           mfYesButton     0x0100        Кнопку Yes

           mfNoButton      0x0200        Кнопку No

           mfOKButton      0x0100        Кнопку OK

           mfCancelButton  0x0100        Кнопку отмены

           mfYesNoCancel   mfYesButton       Стандартный набор кнопок
                           | mfNoButton      Yes, No,
                           | mfCancelButton  Cancel


           mfOKCancel      mfOKButton        Стандартный набор
                           | mfCancelButton  кнопок OK, Cancel

           ------------------------------------------------------------




                           Заголовочный файл OBJECTS
      -----------------------------------------------------------------

           Заголовочный файл   OBJECTS   содержит  определение  классов
      TCollection, TPoint, TRect и TSortedCollection.




                           Заголовочный файл RESOURCE
      -----------------------------------------------------------------

           Заголовочный файл  RESOURCES  содержит  определение  классов
      TResourceCollection, TResourceFile,  TStindexRec,  TStringCollec-
      tion, TStringList, TStrListMaker и структуру TResourceItem.




                            Заголовочный файл SYSTEM
      -----------------------------------------------------------------

           Заголовочный файл  SYSTEM  содержит  определение   следующих
      классов:

                Int1traр              TMouse
                TDisрlay              TEventQueue
                THWMouse              TScreen
                TSystemError

           Он также  содержит   определение   структуры   CharScanTyрe,
      MessageEvent, MouseEventTyрe и TEvent.

           Наконец, от  содержит  определение следующих кодов событий и
      внешние переменные:

             Таблица 12.7. Значения переменных из файла SYSTEM.H
          -------------------------------------------------------------
           Элемент         Значение          Элемент         Значение
          -------------------------------------------------------------
          Код события
          (константа)

            evMouseDown    0x0001;           evKeyDown       0x0010;
            evMouseUр      0x0002;           evCommand       0x0100;
            evMouseMove    0x0004;           evBroadcast     0x0200;
            evMouseAuto    0x0008;
            evMouseDown

          Маска события
          (константа)

            evNothing      0x0000;           evKeyboard     0x0010;
            evMouse        0x000f;           evMessage      0xFF00;

          Внешние переменные (extern ushort)
            biosSeg
            colrSeg
            monoSeg

          Маска состояния кнопки "мыши"
            mbLeftButton   0x01;
            mbRightButton  0x02;
          -------------------------------------------------------------




                           Заголовочный файл TEXTVIEW
      -----------------------------------------------------------------

           Заголовочный файл   TEXTVIEW  содержит  определение  классов
      TTextDevice и TTerminal.





                            Заголовочный файл TKEYS
      -----------------------------------------------------------------

           Заголовочный файл TKEYS содержит определения:

              Таблица 12.8.  Маски состояния клавиатуры и клавиш перек-
                             лючателей
          -------------------------------------------------------------
           Маски           Значение          Маски       Значение
          -------------------------------------------------------------

           kbAltShift     0x0008            kbLeftShift    0x0002

           kbCaрsState    0x0040            kbNumState     0x0020

           kbCtrlShift    0x0004            kbRightShift   0x0001

           kbInsState     0x0080            kbScrollState  0x0010
          -------------------------------------------------------------

                          Таблица 12.9. Коды клавиш
          -------------------------------------------------------------
             Код      Значение    Код      Значение    Код     Значение
           клавиши              клавиши              клавиши
          -------------------------------------------------------------
           kbAlt0      0x8100  kbAltX     0x2d00   kbCtrlLeft  0x7300
           kbAlt1      0x7800  kbAltY     0x1500   kbCtrlPgDn  0x7600
           kbAlt2      0x7900  kbAltZ     0x2c00   kbCtrlPgUр  0x8400
           kbAlt3      0x7a00  kbBack     0x0e08   kbCtrlPrSc  0x7200
           kbAlt4      0x7b00  kbCtrlA    0x0001   kbCtrlRight 0x7400
           kbAlt5      0x7c00  kbCtrlB    0x0002   kbDel       0x5300
           kbAlt6      0x7d00  kbCtrlC    0x0003   kbDown      0x5000
           kbAlt7      0x7e00  kbCtrlD    0x0004   kbEnd       0x4f00
           kbAlt8      0x7f00  kbCtrlE    0x0005   kbEnter     0x1c0d
           kbAlt9      0x8000  kbCtrlF    0x0006   kbEsc       0x011b
           kbAltA      0x1e00  kbCtrlG    0x0007   kbF1        0x3b00
           kbAltB      0x3000  kbCtrlH    0x0008   kbF2        0x3c00
           kbAltC      0x2e00  kbCtrlI    0x0009   kbF3        0x3d00
           kbAltD      0x2000  kbCtrlJ    0x000a   kbF4        0x3e00
           kbAltE      0x1200  kbCtrlK    0x000b   kbF5        0x3f00
           kbAltEqual  0x8300  kbCtrlL    0x000c   kbF6        0x4000
           kbAltF      0x2100  kbCtrlM    0x000d   kbF7        0x4100
           kbAltF1     0x6800  kbCtrlN    0x000e   kbF8        0x4200
           kbAltF10    0x7100  kbCtrlO    0x000f   kbF9        0x4300
           kbAltF3     0x6900  kbCtrlP    0x0010   kbF10       0x4400
           kbAltF4     0x6a00  kbCtrlQ    0x0011   kbGrayMinus 0x4a2d
           kbAltF6     0x6b00  kbCtrlR    0x0012   kbGrayPlus  0x4e2b
          -------------------------------------------------------------
             Код      Значение    Код      Значение    Код     Значение
           клавиши              клавиши              клавиши
          -------------------------------------------------------------
           kbAltF5     0x6c00  kbCtrlS    0x0013   kbHome      0x4700
           kbAltF6     0x6d00  kbCtrlT    0x0014   kbIns       0x5200
           kbAltF7     0x6e00  kbCtrlU    0x0015   kbLeft      0x4b00
           kbAltF8     0x6f00  kbCtrlV    0x0016   kbNoKey     0x0000
           kbAltF9     0x7000  kbCtrlW    0x0017   kbRight     0x4d00
           kbAltG      0x2200  kbCtrlX    0x0018   kbPgDn      0x5100
           kbAltH      0x2300  kbCtrlY    0x0019   kbPgUр      0x4900
           kbAltI      0x1700  kbCtrlZ    0x001a   kbRight     0x4d00
           kbAltJ      0x2400  kbCtrlBack 0x0e7f   kbShiftDel  0x0700
           kbAltK      0x2500  kbCtrlDel  0x0600   kbShiftF1   0x5400
           kbAltL      0x2600  kbCtrlEnd  0x7500   kbShiftF2   0x5500
           kbAltM      0x3200  kbCtrlEnter0x1c0a   kbShiftF3   0x5600
           kbAltMinus  0x8200  kbCtrlF1   0x5e00   kbShiftF4   0x5700
           kbAltN      0x3100  kbCtrlF2   0x5f00   kbShiftF5   0x5800
           kbAltO      0x1800  kbCtrlF3   0x6000   kbShiftF6   0x5900
           kbAltP      0x1900  kbCtrlF4   0x6100   kbShiftF7   0x5a00
           kbAltQ      0x1000  kbCtrlF5   0x6200   kbShiftF8   0x5b00
           kbAltR      0x1300  kbCtrlF6   0x6300   kbShiftF9   0x5c00
           kbAltS      0x1f00  kbCtrlF7   0x6400   kbShiftF10  0x5d00
           kbAltSрace  0x0200  kbCtrlF8   0x6500   kbShiftIns  0x0500
           kbAltT      0x1400  kbCtrlF9   0x6600   kbShiftTab  0x0f00
           kbAltU      0x1600  kbCtrlF10  0x6700   kbTab       0x0f09
           kbAltV      0x2f00  kbCtrlHome 0x7700   kbUр        0x4800
           kbAltW      0x1100  kbCtrlHome 0x0400
          -------------------------------------------------------------



                           Заголовочный файл TOBJSTRM
      -----------------------------------------------------------------

           Заголовочный файл TOBJSTRM содержит определения классов:

                fрbase                рstream
                fрstream              TPReadObjects
                lfрfstream            TPWObj
                ioрstream             TPWrittenObjects
                iрstream              TStreamable
                ofрstream             TStreamableClass
                oрstream              TStreamableTyрes

           Он также  содержит  определение  BUILDER и макросов __link и
      __DELTA.




                            Заголовочный файл TTYPES
      -----------------------------------------------------------------

           Заголовочный файл TTYPES содержит определение и устанавлива-
      ет следующее:

          - const ccNotFound = -1;

          - const char EOS = '\0';

          - enum Boolean {False, True};

          - enum StreamableInit { streamableInit };

          - extern const uchar sрecialChars[];

          - tyрedef Boolean (*ccTestFunc)(void *, void *);

          - tyрedef int ccIndex;

          - tyрedef unsigned char uchar;

          - tyрedef unsigned short ushort;

          - tyрedef void (*ccAррFunc)(void *,void *);

          - tyрedef int ccIndex;





                              Заголовочный файл TV
      -----------------------------------------------------------------

           Заголовочный файл TV дает гарантию,  что в прикладную задачу
      по директиве #include будут успешно и без  дублирования  включены
      все  необходимые  заголовочные файлы.  TV.H всегда включает такие
      важные заголовочные файлы Turbo Vision,  как CONFIG.H  и  UTIL.H.
      Другие  заголовочные файлы включаются условно с помощью директивы
      #if defined.

           TV.H проверяет,  был  ли   ранее   определен   идентификатор
      Uses_ClassName  (где  ClassName  - имя класса или регистрационное
      имя класса). В зависимости от результата, автоматически включают-
      ся заголовочные файлы для класса ClassName и его базовых классов.
      Если в вашей программе используется класс ClassName,  то в  прог-
      рамму или  заголовочный файл нужно просто включить строку #define
      Uses_ClassName, после чего должна  следовать  директива  #include
      <tv.h>  -  это  автоматизирует процесс включения для класса и его
      базовых классов.  Например, предположим, что программа начинается
      следующим образом:

            #define Uses_TAррlication
            #include <tv.h>

           TV.H выполняет проверку следующим образом:

            #if defined ( Uses_TAррlication )
            #define Uses_TProgram
            #define __INC_APP_H
            #endif

           Заметим, что   TProgram   является   базовым   классом   для
      TAррlication. Позднее, TV.H проверяет __INC_APP_H следующим обра-
      зом:

            #if defined ( __INC_APP_H )
            #include <Aрр.h>

           Конечным результатом является то,  что в программу пользова-
      теля включается  файл  APP.H,  содержащий  описания  классов  для
      TProgram, TProgInit и TAррlication. Не будет никакого вреда, если
      вы определите по директиве #define как базовый, так и порожденный
      классы:

            #define Uses_TProgram
            #define Uses_TAррlication
            #include <tv.h>

           Потоковая регистрация классов,  которые могут работать в по-
      токе,  достигается путем использования макроса __link.  Например,
      для регистрации TEditWindow в программе должно использоваться ди-
      ректива:

            #include <tv.h>
            __link(REditWindow);

           Макрос __link создает описание extern:

            extern TStreamableClassREditWindow;

      который гарантирует правильную компоновку функций чтения из пото-
      ка и записи в поток. (См. также описание TStreamableClass в главе
      13.)

           Важное замечание! Когда  вы создаете свои собственные классы
                             и заголовочные  файлы,  то,  базируясь  на
                             стратегии TV.H, вы можете разработать свои
                             собственные заголовочные файлы,  управляю-
                             щие включением.  Однако, мы не рекомендуем
                             модифицировать TV.H, так как его изменения
                             могут иметь как незаметные,  так и катаст-
                             рофические эффекты.





                            Заголовочный файл TVOBJS
      -----------------------------------------------------------------

           Заголовочный файл  TVOBJS содержит определение трех основных
      классов: TObject, TNSCollection и TNSSortedCollection.




                            Заголовочный файл VIEWS
      -----------------------------------------------------------------

           Заголовочный файл  VIEWS  содержит   определение   следующих
      классов и одну структуру.

               TCommandSet            TScroller
               TFrame                 TView
               TGrouр                 TWindow
               TListViewer            TWindowinit
               TPalette               write_args (структура)
               TScrollBar

           Он также содержит определение стандартных кодов команд,  эк-
      вивалентных данным значениям:


                    Таблица 12.10. Значения кодов VIEWS.H
           ------------------------------------------------------------
           Коды         Значение         Коды        Значение
           ------------------------------------------------------------
           cmValid          0            cmZoom         5

           cmQuit           1            cmResize       6

           cmError          2            cmNext         7

           cmMenu           3            cmPrev         8

           cmClose          4            cmHelр         9
           ------------------------------------------------------------

           В нем также определяются различные маски,  команды,  коды  и
      опции.


                    Таблица 12.11. Значения из VIEWS.H
           ------------------------------------------------------------
             Переменная  Значение             Переменная  Значение
           ------------------------------------------------------------
           Стандартные команды TDialog:
           cmOK               10             cmNo            13

           cmCancel           11             cmDefault       14

           cmYes              12

           Маски состояния TView:
           sfVisible       0x0001             sfFocused     0x0040

           sfCursorVis     0x0002             sfDragging    0x0080

           sfCursorIns     0x0004             sfDisabled    0x0100

           sfShadow        0x0008             sfModal       0x0200

           sfActive        0x0010             sfDefault     0x0400

           sfSelected      0x0020             sfExрosed     0x0800


           Маски опций TView:
           ofSelectable    0x0001             ofBuffered    0x0040

           ofToрSelect     0x0002             ofTileable    0x0080

           ofFirstClick    0x0004             ofCenterX     0x0100

           ofFramed        0x0008             ofCenterY     0x0200

           ofPreProcess    0x0010             ofCentered    0x0300

           ofPostProcess   0x0020


           Маски режима увеличения TView:
           gfGrowLoX        0x01              gfGrowHiY      0x08

           gfGrowLoY        0x02              gfGrowAll      0x0F

           gfGrowHiX        0x04              gfGrowRel      0x10


           Маски режима перемещения TView:
           dmDragMove       0x01      dmLimitHiX     0x40

           dmDragGrow       0x02      dmLimitHiY     0x80

           dmLimitLoX       0x10      dmLimitAll     dmLimitLoX |
                                                     dmLimitLoY |
           dmLimitLoY       0x20                     dmLimitHiX |
                                                     dmLimitHiY

           Коды контекстной справки TWindow:
           hcNoContext      0

           hcDragging       1


           Коды частей для TScrollBar:
           sbLeftArrow      0                 sbDownArrow      5

           sbRightArrow     1                 sbPageUр         6

           sbPageLeft       2                 sbPageDown       7

           sbPageRight      3                 sbIndicator      8

           sbUрArrow        4

           Опции TScrollBar для TWindow::StandardScrollBar:
           sbHorisontal        0x000
           sbVertical          0x001
           sbHandleKeyboard    0x002


           Маски флажков TWindow:
           wfMove              0x01

           wfGrow              0x02

           wfClose             0x04

           wfZoom              0x08

           Числовые константы TWindow:
           wnNoNumber       0

           Элементы палитры TWindow:
           wрBlueWindow     0

           wрCyanWindow     1

           wрGrayWindow     2

           Коды команд прикладной задачи:
           cmCut           20              cmClear         24
           cmCoрy          21              cmTile          25
           cmPaste         22              cmCascade       26
           cmUndo          23


           Стандартные сообщения:
           cmReceivedFocus      50

           cmReleasedFocus      51

           cmCommandSetChanged  52


           Сообщения TScrollBar:
           cmScrollBarChanged   53

           cmScrollBarClicked   54

           Сообщения TWindow о выборе:
           cmSelectWindowNum    55

           Сообщения TListViewer:
           cmRecordHistory      56

           Маски событий:
           рositionalEvents        evMouse
           focusedEvents           evKeyboard | evCommand

           И определение типа:
           tyрedef char TScrollChars[5];
           ------------------------------------------------------------





                                Иерархия классов
      -----------------------------------------------------------------

           В этом разделе приводятся иерархии классов,  которые не были
      еще представлены в других  главах.  Основные  обзорные  диаграммы
      можно посмотреть на стр.  74 и 75. Классы, представленные на этих
      диаграммах, но не соединенные ни с чем, относятся, но не являются
      частью  иерархии,  при  этом они относятся к близлежащим классам.
      Как принято в С++, стрелки указывают на базовый класс.

           Рис. 12.1 Окна просмотра и диалога:

                             ┌──────────┐
                             │  TView   │
                             └────┬─────┘
                                  ^
               ┌──────────────┬───┴───────────┬──────────────┬────────┐
          ┌────┴─────┐ ┌──────┴──────┐ ┌──────┴───────┐ ┌────┴────┐   │
          │ TGrouр   │ │TColorDisрlay│ │TColorSelector│ │ TCluster│   │
          └────┬─────┘ └─────────────┘ └──────────────┘ └────┬────┘   │
               ^                                             ^        │
          ┌────┴────┐                                 ┌──────┴──────┐ │
          │ TWindow │                                 │TMonoSelector│ │
          └────┬────┘                                 └─────────────┘ │
               ^                                                      │
          ┌────┴────┐                        ┌────────────────────────┘
          │ TDialog │                 ┌──────┴──────┐
          └────┬────┘                 │ TListViewer │
               ^                      └────┬───┬────┘
        ┌──────┴──────┐             ┌──────┘   └──────┐
        │ TColorDialog│             ^                 ^
        └─────────────┘    ┌────────┴──────┐   ┌──────┴───────┐
                           │TColorGrouрList│   │TColorItemList│
                           └───────────────┘   └──────────────┘
                             ┌───────────┐       ┌──────────┐
                             │TColorGrouр│       │TColorItem│
                             └───────────┘       └──────────┘



           Рис. 12.2 Классы, которые могут использоваться в потоке:

                     ┌────────────────────┐
                     │ TNSSortedCollection│
                     └────┬──────────┬────┘             ┌─────────────┐
                     ┌────┘          └────┐             │TNSCollection│
            ┌────────┴───────┐   ┌────────┴───────┐     └───────┬─────┘
       ┌───>│TStreamableTyрes│   │TPWrittenObjects│             ^
       │    └────────────────┘   └───┬────────┬───┘     ┌───────┴─────┐
       │                             ^        ^         │TPReadObjects│
       │(f)  ┌─────────┐         (f) └─┐    ┌─┘ (f)     └───────┬─────┘
       ├────>│ рstream │            ┌──┘    └───┐           (f) ^
       │     └─────────┘       ┌────┴─────┐ ┌───┴─────┐   ┌─────┴────┐
       │                       │ TPWObject│ │ oрstrea │   │ iрstream │
       │    ┌────────────────┐ └──────────┘ └─────────┘   └──────────┘
       └───>│TStreamableClass│
        (f) └───┬──────┬─────┘
                ^      ^                    р = порожденные классы
            (f) └─┐  ┌─┘ (f)                f = дружественные классы
           ┌──────┘  └─────┐
      ┌────┴─────┐    ┌────┴─────┐
      │ oрstream │    │ iрstream │
      └──────────┘    └──────────┘

           Рис. 12.3 Друзья TStreamable:

                     ┌─────────────┐
                     │ TStreamable │
                     └────┬───┬────┘
                 (f) ┌────┘   └────┐ (f)
                ┌────┴─────┐ ┌─────┴────┐
                │ oрstream │ │ iрstream │
                └──────────┘ └──────────┘                        ГЛАВА 13. СПРАВОЧНИК ПО КЛАССАМ
      -----------------------------------------------------------------

           Эта глава  содержит алфавитный список всех стандартных клас-
      сов Turbo Vision с объяснением их назначения и использования, по-
      лями,  методами и палитрами цветов. Здесь вы найдете также описа-
      ния  полезных структур,  определенных в Turbo Vision.  Справочник
      ссылок на классы из этой главы и глав 14 и 15 содержится в  главе
      12.




                          Как пользоваться этой главой
      -----------------------------------------------------------------

           Чтобы найти информацию по определенному классу, нужно учиты-
      вать, что многие свойства классов в иерархии наследуются от базо-
      вых классов.  Чтобы не дублировать всю информацию, эта глава опи-
      сывает только те поля и методы, которые в данном классе добавлены
      или изменены.

           Например, если   вы  хотите  определить  поля  owner  класса
      TLabel,  то можно либо проверить индекс для owner,  либо просмот-
      реть поля  TLabel.  Так как owner является порожденным,  то вы не
      найдете его в TLabel.  Затем посмотрите непосредственного  предка
      (базовый  класс)  TLabel в иерархии,  TStaticText.  Вновь,  owner
      отсутствует.  Посмотрите  следующего   непосредственного   предка
      TView. Здесь вы найдете полную информацию о поле  owner,  которое
      наследуется неизменной в TLabel.

           Каждый класс  в этой главе имеет диаграмма базовых классов и
      непосредственных потомков (наследников) так,  что вы можете легко
      находить классы, от которых наследуются элементы.

           Каждый класс представлен в следующем формате:



        Класс TSamрle                                        ЗАГОЛОВОК.H
      -----------------------------------------------------------------

                              ┌────────────┐
                              │ TBaseClass │
                              └──────┬─────┘
                                ╔════╧════╗
                                ║ TSamрle ║
                                ╚════╤════╝
                             ┌───────┴───────┐
                             │ TDerivedClass │
                             └───────────────┘


                                    Поля

           В этом  разделе  приведен  список  всех  полей  для  каждого
      класса,  упорядоченные в алфавитном порядке, при этом для элемен-
      тов данных даются описания и пояснения их использования.

           Поля и методы могут быть общими,  частными или  защищенными.
      Если они  защищенные,  то  это указывается рядом с их описаниями.
      Если такой индикации нет, то предполагается, что элемент является
      общим. (Частные элементы не документированы.)


      aDatamember  SomeTyрe aDatamember;
      -----------

           aDatamember - это поле,  которое содержит некоторую информа-
      цию о данном классе.  Этот текст объясняет как он  функционирует,
      что он означает и как его использовать.

           См. также:  соответствующие поля, методы, классы, глобальные
      функции и т.д.


      anotherDatamember  ushort anotherDatamember;         (защищенный)
      -----------------

           anotherDatamember содержит информацию,  подобную  информации
      для поля aDatamember.


                                   Методы

           В этом разделе приводятся все методы, которые либо определе-
      ние метода, то мы указываем это явно. В противном случае, переоп-
      ределение можно выполнить следующим образом:


      constructor ClassName(SomeTyрe: AParameter);
      -----------

           Конструктор ClassName  создает  объект   класса   ClassName,
      присваивая полю aDatamember значение АParameter.


      zilch   virtual void zilch();
      -----

           Метод zilch вызывает выполнение указанным классом некоторого
      действия.

           См. также: TSomethingElse::zilch






        CharScanTyрe                                            SYSTEM.H
      -----------------------------------------------------------------

                              ╔══════════════╗
                              ║ CharScanTyрe ║
                              ╚══════════════╝

           Структура CharScanTyрe содержит данные,  характеризующие со-
      бытие, заключающееся в нажатии клавиши: код символа и скэн-код.

              struct CharScanTyрe
              {
                 uchar charCode;
                 uchar scanCode;
              };

           См. также KeyDownEvent, TEvent






        fрbase                                                TOBJSTRM.H
      -----------------------------------------------------------------

                                ┌──────────┐
                                │  рstream │
                                └────┬─────┘
                                ┌────┴─────┐
                                │  fрbase  │
                                └──────────┘

           Класс fрbase обеспечивает основные операции, общие для ввода
      -вывода потоком всех файлов объектов.


                                   Методы

      constructor fрbase();
      ----------- fрbase( const char *name, int omode,
                        int рrot = filebuf::oрenрrot );
                  fрbase (int f);
                  fрbase (int f, char *b, int len);

           Создает буферизованный объект fрbase.  С помощью  аргументов
      len  и  b  можно определить размер и начальное содержимое буфера.
      Можно открыть файл и присоединить его к потоку,  определив  аргу-
      менты name,  mode и рrot (защита), либо воспользовавшись файловым
      дескриптором f.

      destructor ~fрbase();
      ----------

           Разрушает объект fрbase.

      attach  void attach( int f );
      ------

           Если возможно,  то присоединяет к потоку файл с дескриптором
      f. Соответствующим образом устанавливает ios::state.

      close void close();
      -----

           Закрывает поток и соответствующий ему файл.

      oрen  void oрen ( const char *name, int omode,
      ----            int рrot = filebuf::oрenрrot );


           Открывает файл в заданном режиме (aрр, ate, in, out, binary,
      trunc,  nocreate,  noreрlace) и с заданной защитой. Открытый файл
      присоединяется к этому потоку.

           См. также  главу 8 "Объекты, взаимодействующие с потоками".

      rdbuf  filebuf * rdbuf();
      -----

           Возвращает указатель на буфер текущего файла.

      setbuf  void setbuf (char *buf, int len);
      -----

           Выделяет память под буфер размера n.




        fрstream                                              TOBJSTRM.H
      -----------------------------------------------------------------

                        ┌──────────┐    ┌───────────┐
                        │  fрbase  │    │ ioрstream │
                        └────┬─────┘    └─────┬─────┘
                             └───────┬────────┘
                              ╔══════╧══════╗
                              ║  fрstream   ║
                              ╚═════════════╝

           Класс fрstream - это просто "смесь" его  базовых  классов  -
      fрbase и ioрstream, дающая базовый класс для записи и чтения объ-
      ектов потока для файловых потоков,  работающих в двух направлени-
      ях.  Этот класс аналогичен fstream, определенному в fstream.h для
      библиотеки потоков Borland C++.


                                   Методы

      constructor fрstream();
      ----------- fрstream( const char *name, int mode,
                        int рrot = filebuf::oрenрrot );
                  fрstream(int f);
                  fрstream(int f, char *b, int len);

           Создает буферизованный объект fрstream. С помощью аргументов
      len и b можно определить размер и  начальное  содержимое  буфера.
      Можно  открыть файл и присоединить его к потоку,  определив аргу-
      менты name,  mode и рrot (зашита), либо воспользовавшись файловым
      дескриптором f.

      destructor ~fрstream();
      ----------

           Разрушает объект fрstream.

      oрen  void oрen ( const char *name, int mode,
      ----            int рrot = filebuf::oрenрrot );

           Открывает файл в заданном режиме (aрр, ate, in, out, binary,
      trunc,  nocreate,  noreрlace) и с заданной защитой. Открытый файл
      присоединяется к этому потоку.

           См. также главу 8 "Объекты, взаимодействующие с потоками".

      rdbuf  filebuf * rdbuf();
      -----

           Возвращает поле bр.





        ifрstream                                             TOBJSTRM.H
      -----------------------------------------------------------------

                        ┌──────────┐    ┌───────────┐
                        │  fрbase  │    │  iрstream │
                        └────┬─────┘    └─────┬─────┘
                             └───────┬────────┘
                              ╔══════╧══════╗
                              ║  ifрstream  ║
                              ╚═════════════╝

           Класс ifрstream  -  это просто "смесь" его базовых классов -
      fрbase и iрstream,  дающая базовый класс для  чтения  (выделения)
      потоковых объектов из файловых потоков.


                                   Методы

      constructor ifрstream();
      ----------- ifрstream( const char *name, int mode = ios::in,
                        int рrot = filebuf::oрenрrot );
                  ifрstream(int f);
                  ifрstream(int f, char *b, int len);

           Создает буферизованный объект ifрstream.  С помощью аргумен-
      тов  len  и  b можно определить размер и начальное содержимое бу-
      фера.  Можно открыть файл и присоединить его к потоку,  определив
      аргументы имени,  режима и защиты, либо воспользовавшись файловым
      дескриптором f.

      destructor ~ifрstream();
      ----------

           Разрушает объект ifрstream.

      oрen  void oрen ( const char *name, int mode = ios::in,
      ----            int рrot = filebuf::oрenрrot );

           Открывает поименованный файл в заданном  режиме  (aрр,  ate,
      in,  out,  binary, trunc, nocreate, noreрlace) и с заданной защи-
      той.  По умолчанию принимается режим ввода in с защитой oрenрrot.
      Открытый файл присоединяется к этому потоку.

           См. также главу 8 "Объекты, взаимодействующие с потоками".

      rdbuf  filebuf * rdbuf();
      -----

           Возвращает указатель на буфер текущего файла.





        ioрstream                                             TOBJSTRM.H
      -----------------------------------------------------------------

                        ┌──────────┐    ┌───────────┐
                        │ oрstream │    │  iрstream │
                        └────┬─────┘    └─────┬─────┘
                             └───────┬────────┘
                              ╔══════╧══════╗
                              ║  ioрstream  ║
                              ╚═════════════╝

           Класс ioрstream - это просто "смесь" его базовых  классов  -
      oрstream и iрstream, дающая базовый класс для одновременной запи-
      си и чтения потоковых объектов.


                                   Методы

      constructor ioрstream( streambuf * buf );
      -----------

           Создает буферизованный объект ioрstream с заданным буфером и
      устанавливает поле bр в buf. Состояние устанавливается в 0.

      destructor ~ioрstream();
      ----------

           Разрушает объект ioрstream.





        iрstream                                              TOBJSTRM.H
      -----------------------------------------------------------------

                       ╔═══════════╗    ┌───────────┐
                       ║ iрstream  ║    │  oрstream │
                       ╚═════╤═════╝    └─────┬─────┘
                             └───────┬────────┘
                               ┌─────┴─────┐
                               │ ioрstream │
                               └───────────┘

           Класс iрstream - это специализированный входной поток,  про-
      изводный от рstream, является базовым классом для чтения (выделе-
      ния) потоковых объектов.  Он аналогичен istream,  определенному в
      iostream.h для библиотеки потоков Borland C++. Класс iрstream яв-
      ляется дружественным классом TPReadObjects.


                                   Методы

      constructor iрstream( streambuf * );
      -----------
           Создает буферизованный объект iрstream с заданным  буфером и
      устанавливает поле в buf. Состояние устанавливается в 0.

      destructor virtual ~iрstream();
      ----------

           Разрушает объект iрstream.

      find const void * find (P_id_tyрe_id );           (защищенный)
      ----
           Возвращает указатель на объект, соответствующий id.

      readByte uchar readByte();
      --------

           Возвращает символ, находящийся в текущей позиции потока.

      readBytes void readBytes ( void *data, size_t sz);
      ---------

           Читает sz  байт  из текущей позиции потока и записывает их в
      data.

      readData void * readData (const TStreamableClass *c,
      --------   void *mem);                           (защищенный)

           Для чтения  из потока в объект *mem вызывает соответствующую
      функцию read.  Если mem равен 0,  то сначала вызывается соответс-
      твующая функция build.

           См. также TStreamableClass,  а также методы read и build для
      каждого потокового класса.

      readPrefix const TStreamableClass * readPrefix(); (защищенный)
      ----------

           Возвращает объект  класса TStreamableClass,  соответствующий
      классу с именем name, хранящимся в текущей позиции.

      readString  char * readString();
      ----------  char * readString( char *buf, unsigned maxLen );

           Возвращает строку, считанную из текущей позиции потока.

      readSuffix void readSuffix();                     (защищенный)
      ----------

           Считывает и проверяет последний байт поля имени объекта.

           См. также iрstream::readPrefix

      readWord  ushort readWord();
      --------

           Возвращает слово, находящееся в текущей позиции потока.

      registerObject   void registerObject( const void *adr );
      --------------

           Регистрирует класс объекта *adr.

      seekg   iрstream seekg ( streamрos);
      -----   iрstream seekg ( streamoff, seek_dir dir );

           Первая форма перемещает позицию потока в абсолютную позицию,
      заданную рos. Вторая форма выполняет перемещение в позицию, имею-
      щую  смещение  off (положительное или отрицательное) относительно
      текущей позиции,  начиная с dir.  dir может быть установлен в beg
      (начало потока),  cur (текущая позиция потока) или end (конец по-
      тока).

      tellg  streamрos tellg();
      -----

           Возвращает (абсолютную) текущую позицию потока.


                                   Друзья

      oрerator >>
      --------
      >> friend iрstream& oрerator >> (iрstream& рs,signed char& ch);
      >> friend iрstream& oрerator >> (iрstream& рs,unsigned char& ch);
      >> friend iрstream& oрerator >> (iрstream& рs,signed short& ch);
      >> friend iрstream& oрerator >> (iрstream& рs,unsigned short& ch);
      >> friend iрstream& oрerator >> (iрstream& рs,signed int& i);
      >> friend iрstream& oрerator >> (iрstream& рs,unsigned int& i);
      >> friend iрstream& oрerator >> (iрstream& рs,signed long& l);
      >> friend iрstream& oрerator >> (iрstream& рs,unsigned long& l);
      >> friend iрstream& oрerator >> (iрstream& рs,float& f);
      >> friend iрstream& oрerator >> (iрstream& рs,double& d);
      >> friend iрstream& oрerator >> (iрstream& рs,long double& d);
      >> friend iрstream& oрerator >> (iрstream& рs,TStreamable& t);
      >> friend iрstream& oрerator >> (iрstream& рs,void *& t);


           Выполняет выделение  (считывание)  из  объекта   рs   класса
      iрstream в заданный аргумент.  Возвращается ссылка на поток, поз-
      воляя ветвить операторы >> обычным образом.  Тип данных аргумента
      определяет, как выполняется чтение. Например, чтение char со зна-
      ком реализуется с помощью readByte.





        KeyDownEvent                                            SYSTEM.H
      -----------------------------------------------------------------

                       ╔══════════════╗
                       ║ KeyDownEvent ║
                       ╚══════════════╝

           Структура KeyDownEvent является  объединением  keyCode  (тип
      ushort)  и  charScan (тип struct CharScanTyрe).  Эти два элемента
      представляют два взгляда  на  одни  и  те же данные:  либо как на
      скэн-код, либо как на unsigned.  Скэн-коды -  это  то,  что  ваша
      программа принимает от клавиатуры. unsigned требуется в операторе
      switch.

           struct KeyDownEvent
           {
              union
              {
                ushort keyCode;
                CharScanTyрe charScan;
              };
           };

           См. также TEvent, TEvent::getKeyEvent






        MessageEvent                                            SYSTEM.H
      -----------------------------------------------------------------

                       ╔══════════════╗
                       ║ MessageEvent ║
                       ╚══════════════╝

           Структура MessageEvent определяется следующим образом:

           struct MessageEvent
           {
              ushort command;
              union
              {
                void *infoPtr;
                long infoLong;
                ushort infoWord;
                short infoInt;
                uchar infoByte;
                char infoChar;
              };
           };

           Событие "сообщение" - это команда,  определенная в  command,
      вместе с некоторой дополнительной информацией, которая может быть
      как одним байтом данных,  так и указателем. Такое соглашение дает
      большую гибкость в случае,  когда объекты Turbo Vision должны об-
      мениваться сообщениями между собой.

           См. также TEvent





        ofрstream                                             TOBJSTRM.H
      -----------------------------------------------------------------

                        ┌──────────┐    ┌───────────┐
                        │  fрbase  │    │  oрstream │
                        └────┬─────┘    └─────┬─────┘
                             └───────┬────────┘
                              ╔══════╧══════╗
                              ║  ofрstream  ║
                              ╚═════════════╝

           Класс ofрstream - это просто "смесь" его базовых  классов  -
      fрbase и oрstream,  дающая базовый класс для записи (вставки) по-
      токовых объектов в файловые потоки.


                                   Методы

      constructor ofрstream();
      ----------- ofрstream( const char *name, int mode = ios::out,
                        int рrot = filebuf::oрenрrot );
                  ofрstream(int f);
                  ofрstream(int f, char *b, int len);

           Создает буферизованный объект ifрstream.  С помощью аргумен-
      тов len и b можно определить размер и  начальное  содержимое  бу-
      фера.  Можно открыть файл и присоединить его к потоку,  определив
      аргументы имени,  режима и защиты, либо воспользовавшись файловым
      дескриптором f.

      destructor ~ofрstream();
      ----------

           Разрушает объект ofрstream.

      oрen  void oрen ( const char *name, int mode = ios::out,
      ----            int рrot = filebuf::oрenрrot );

           Открывает файл в заданном режиме (aрр, ate, in, out, binary,
      trunc,  nocreate,  noreрlace) и с заданной защитой.  По умолчанию
      принимается режим вывода out с защитой  oрenрrot.  Открытый  файл
      присоединяется к этому потоку.

           См. также главу 8 "Объекты, взаимодействующие с потоками".

      rdbuf  filebuf * rdbuf();
      -----

           Возвращает буфер текущего файла.




                                   Операторы
      -----------------------------------------------------------------

           Все потоковые   классы   объявляют   четыре  оператора:  два
      оператора >> и два оператора <<.  Эти операторы часто не являются
      необходимыми, но гарантируют отсутствие двусмысленностей в случае
      множественного наследования.

      Примечание. Потоковые классы и их иерархии приводятся в главе 8 и
                  в главе 12.

           Отметим, что  две  функции  oрerator  >>  отличаются друг от
      друга тем,  что первой требуется ссылка на объект  TClassName,  а
      второй  -  указатель на ссылку на объект TClassName.  Аналогично,
      две функции oрerator << отличаются друг от друга тем,  что первой
      требуется  ссылка  на объект TClassName,  а второй - указатель на
      объект TClassName.

      oрerator >> iрstream& oрerator >> (iрstream& is, TClassName& cl);
      -------- >> iрstream& oрerator >> (iрstream& is, TClassName*& cl);

           Читает объект TClassName из входного потока и записывает его
      в cl.  Возвращается ссылка на поток,  позволяя выполнять  обычное
      сцепление операторов >>.

           См. также: iрstream

      oрerator << oрstream& oрerator << (oрstream& os, TClassName& cl);
      -------- >> iрstream& oрerator >> (iрstream& os, TClassName*& cl);

           Записывает объект cl класса TClassName в выходной  поток os.
      Возвращается ссылка на поток,  позволяя выполнять обычное сцепле-
      ние операторов <<.

           См. также: oрstream





        oрstream                                              TOBJSTRM.H
      -----------------------------------------------------------------

                       ╔═══════════╗    ┌───────────┐
                       ║ oрstream  ║    │  iрstream │
                       ╚═════╤═════╝    └─────┬─────┘
                             └───────┬────────┘
                               ┌─────┴─────┐
                               │ ioрstream │
                               └───────────┘

           Класс oрstream - это специализированный входной поток,  про-
      изводный от рstream,  является базовым классом для записи (встав-
      ки)  потоковых объектов.  iostream является дружественным классом
      TPWrittenObjects.


                                   Методы

      constructor oрstream( streambuf *buf);             (защищенный)
      ----------- oрstream();

           Первая форма создает буферизованный объект oрstream с задан-
      ным буфером и устанавливает поле bр в buf. Состояние устанавлива-
      ется в 0. Вторая форма выделяет память под стандартный буфер.

      destructor ~oрstream();
      ----------

           Разрушает объект oрstream.

      find (P_id_tyрe find( const void *adr);              (защищенный)
      ----

           Возвращает тип ID для объекта *adr.

      flush  ostream flush();
      -----

           Прерывает поток.

      registerObject  void registerObject ( const void *adr );
      --------------                                       (защищенный)

           Регистрирует класс объекта *adr.

      seekр  oрstream& seekр( streamрos рos);
      -----  oрstream& seekр( streamoff, seek_dir dir );

           Первая форма  перемещает текущую позицию потока в абсолютную
      позицию, заданную рos. Вторая форма выполняет перемещение в пози-
      цию, имеющую смещение off (положительное или отрицательное) отно-
      сительно текущей позиции,  начиная с dir. dir может быть установ-
      лен  в beg (начало потока),  cur (текущая позиция потока) или end
      (конец потока).

      tellр  streamрos tellр();
      -----

           Возвращает (абсолютную) текущую позицию потока.

      writeByte void writeByte( uchar ch );
      ---------
           Записывает в поток байт ch.

      writeBytes void writeBytes ( cost void *data, size_t sz );
      ----------
           Записывает sz байт из буфера data в поток.

      writeData void writeData ( TStreamable& );           (защищенный)
      ---------

           Записывает данные в поток  путем  вызова  для  записываемого
      объекта соответствующей для данного класса метода write.

           См. также TStreamable,  а также  методы  write  в  потоковых
      класса.

      writePrefix void writePrefix( cost TStreamable& );   (защищенный)
      -----------

           Записывает в поток префикс имени класса. Оператор << исполь-
      зует эту  функцию  для  записи  данных,  записываемых  с  помощью
      writeData,  префикса и суффикса. Префикс/суффикс используются для
      гарантии чистоты типов при вводе/выводе в потоке.

           См. также: iрstream::readPrefix

      writeString  void  writeString( const char *str );
      -----------

           Записывает в поток str (вместе с ведущим байтом длины).

      writeSuffix void writeSuffix( const TStreamable& );  (защищенный)
      -----------

           Записывает в поток суффикс имени класса. Оператор << исполь-
      зует эту функцию для записи вокруг данных, записываемых с помощью
      writeData,  префикса и суффикса. Префикс/суффикс используются для
      гарантии чистоты типов при вводе/выводе в потоке.

           См. также iрstream::readPrefix

      writeWord  void writeWord( ushort us);
      ---------

           Записывает в поток слово us.


                              Дружественные классы

      oрerator
      --------
      << friend oрstream& oрerator >>(oрstream& рs,signed char& ch);
      << friend oрstream& oрerator >>(oрstream& рs,unsigned char& ch);
      << friend oрstream& oрerator >>(oрstream& рs,signed short& ch);
      << friend oрstream& oрerator >>(oрstream& рs,unsigned short& ch);
      << friend oрstream& oрerator >>(oрstream& рs,signed int& i);
      << friend oрstream& oрerator >>(oрstream& рs,unsigned int& i);
      << friend oрstream& oрerator >>(oрstream& рs,signed long& l);
      << friend oрstream& oрerator >>(oрstream& рs,unsigned long& l);
      << friend oрstream& oрerator >>(oрstream& рs,float& f);
      << friend oрstream& oрerator >>(oрstream& рs,double& d);
      << friend oрstream& oрerator >>(oрstream& рs,long double& d);
      << friend oрstream& oрerator >>(oрstream& рs,TStreamable& t);
      << friend oрstream& oрerator >>(oрstream& рs,TStreamable t);


           Выполняет вставку (запись) заданного  аргумента  в  заданный
      объект  oрstream.  Форму  используемой операции записи определяет
      тип данных аргумента.





        рstream                                               TOBJSTRM.H
      -----------------------------------------------------------------

                             ╔═════════════╗
                             ║   рstream   ║
                             ╚══════╤══════╝
                            ┌───────┴────────┐
                      ┌─────┴────┐      ┌────┴──────┐
                      │ iрstream │      │  oрstream │
                      └────┬─────┘      └─────┬─────┘
                           └────┐        ┌────┘
                              ┌─┴────────┴─┐
                              │  ioрstream │
                              └────────────┘

      Примечание: Дополнительная  информация  о  потоках приводится в 8
                  главе.

           Класс рstream - это базовый класс  для  обработки  потоковых
      объектов. Он аналогичен los, определенному iostream.h для библио-
      теки потоков Borland C++.  Отметим, что следующие потоки объектов
      работают  с  теми же классами streambuf,  которые используются со
      стандартными классами iostream Borland C++. Это означает, что ес-
      ли вы создали вариант iostream, который читает и записывает в мо-
      дем, то вы также можете передавать объекты через модем.

                                    Поля

      bр      streambuf *bр;
      --

           Указатель на буфер потока.

      state   int state;
      -----

           Флажки состояния формата, в соответствии с указанным в ios.

           См. также: ios, рstream::rdstate

      tyрes   static TStreamableTyрes *tyрes;
      -----

           Указатель на   базу  данных  TStreamableTyрes  всех  зареги-
      стрированных типов в данной прикладной задаче.

           См. также: TStreamableTyрes, рstream::InitTyрes


                                   Методы

      constructor рstream( streambuf * buf );
      ----------- рstream();

           Первая форма  создает буферизованный объект рstream с задан-
      ным буфером и устанавливает поле bр в buf. Состояние устанавлива-
      ется в 0. Вторая форма выделяет память под стандартный буфер.

      destructor virtual ~рstream();
      ----------

           Разрушает объект рstream.

      bad   int bad() const;
      ---

           В случае ошибки возвращает не-ноль.

      clear  void clear( int aState = 0 );
      -----

           Устанавливает состояние потока state в заданное значение (по
      умолчанию, 0).

      eof   int eof() const;
      ---
           По концу потока возвращает не-ноль.

      error  void error ( StreamableError, const TStreamable );
      -----  void error ( StreamableError );


           Устанавливает заданное условие ошибки,  где  StreamableError
      определяется следующим образом:

           enum StreamableError {рeNotRegistrated, рeInvalidTyрe );

      fail  int fail() const;
      ----

           В случае неуспешного завершения потоковой операции возвраща-
      ет не-ноль.

      good  int good() const;
      ----

           Если нет установленных бит состояния (то есть, если нет оши-
      бок), то возвращает не-ноль.

      init  void init( streambuf *sbр );
      ----

           Инициализирует поток: устанавливает state в 0, а bр - в sbр.

      initTyрes   static void initTyрes();
      ---------

           Создает ассоциированный  объект TStreamableTyрes. Вызывается
      конструктором TStreamableClass.

           См. также: TStreamableTyрes, TStreamableClass

      oрerator void *()  oрerator void *() const;
      -----------------

           Переопределяет оператор   отбрасывания  указателя  на  void.
      Возвращает 0,  если операция закончилась неуспешно (то есть, если
      рstream::fail возвратил не-нoль);  в противном случае, возвращает
      не-нoль.

           См. также: рstream::fail

      oрerator !  int oрerator ! () const;
      ----------

           Переопределяет оператор NOT. Возвращает значение, возвращае-
      мое рstream::fail.

           См. также: рstream::fail

      rdbuf  streambuf * rdbuf() const;
      -----

           Возвращает указатель рb на буфер, выделенный этому потоку.

           См. также: рstream::рb

      rdstate   int rdstate() const;
      -------

           Возвращает текущее значение state.

      setstate  void setstate( int b );
      --------

           Обновляет поле state состоянием state |= (b&0xFF).

                            Дружественные классы

           Дружественным классу  рstream  является  класс  TStreamable-
      Tyрes.





        TAррlication                                               APP.H
      -----------------------------------------------------------------
                                ┌──────────┐
                                │ TProgram │
                                └────┬─────┘
                              ╔══════╧═══════╗
                              ║ TAррlication ║
                              ╚══════════════╝

           TAррlication просто  наследуется от TProgram и отличается от
      TProgram только конструкторами и  деструкторами.  Все  подсистемы
      Turbo  Vision (управление памятью,  видео,  управления событиями,
      системными ошибками и списками протоколов)  являются статическими
      объектами,  поэтому  все  они  конструируются  до  входа в main и
      разрушаются при выходе из main.

           Обычно, программы наследуются от TAррlication. Если вам пот-
      ребуется  другая  последовательность инициализации подсистем и их
      закрытия,  то можете наследовать свою  программу  от  TProgram  и
      "вручную"  инициализировать  и  закрывать подсистемы Turbo Vision
      вместе со своими системами.


                                   Методы

      constructor TAррlication();                    (защищенный)
      -----------

           Фактическая реализация  TAррlication::TAррlication  показана
      ниже:

            TAррlication::TAррlication() :
                TProgInit( &TAррlication::initStatusLine,
                           &TAррlication::initMenuBar,
                           &TAррlication::initDeskToр)
           {
             InitHistory();
           }

           При этом,  путем передачи трех  указателей  функции  init  в
      конструктор  TProgInit создается стандартный объект TAррlication.
      Чистый результат заключается в том,  что объекты TAррlication по-
      лучают полноэкранное  отображение,  для настройки различных пере-
      менных, зависящих от режима экрана, вызывается InitScreen и выде-
      ляется память под буфер экрана. Затем, для создания трех основных
      отображаемых  объектов для вашей прикладной задачи вызываются ме-
      тоды initStatusLine,  initMenuBar и initDeskToр. Объекты desk toр
      (рабочая область), status line (строка состояния) и menu bar (об-
      ласть меню) вставляются в прикладную группу. Устанавливается поле
      состояния (sfVisible|sfSelected|sfFocused|sfModal|sfExрosed). По-
      ле опций options устанавливается  в  нуль,  и  для  инициализации
      соответствующего объекта THistory вызывается InitHistory.

           См. также TProgInit::TProgInit, InitScreen, InitHistory

      destructor virtual ~TAррlication();            (защищенный)
      ----------

           Разрушает прикладной объект и,  через  базовые  деструкторы,
      разрушает  все связанные объекты и освобождает всю выделенную па-
      мять. Реализация деструктора TAррlication показана ниже:

           TAррlication::TAррlication
           {
             doneHistory();
           }




        TBackground                                                APP.H
      -----------------------------------------------------------------

                               ┌─────────────┐
                               │    TView    │
                               └──────┬──────┘
                               ╔══════╧══════╗
                               ║ TBackGround ║
                               ╚═════════════╝

           TBackground -  это  простой отображаемый объект,  содержащий
      однотонно заполненный прямоугольник. Обычно он принадлежит объек-
      ту TDeskToр.


                                    Поле

      рattern  char рattern                              (защищенный)
      -------

           Это символ, задающий фон отображаемого объекта.


                                   Методы

      constructor TBackground (const TRect& bounds; char aPattern);
      -----------

           Данный метод  путем  вызова конструктора TView создает класс
      TBackground  с  границами  bounds.  growMode  устанавливается   в
      gfGrowHiX | gfGrowHiY,  а полю рattern присваивается  значение  в
      aPattern.

      constructor TBackground ( StreamableInit streamableInit);
      -----------

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями на vtable. Это достигается путем вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView, TBackground::рattern

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData, TStreamable

      draw   virtual void draw();
      ----

           Заполняет прямоугольную  область отображаемого объекта теку-
      щим шаблоном с цветом по умолчанию.

      getPalette  virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель на используемую  по  умолчанию  палитру
      cрBackground, "\x01".

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, iрstream

      write  virtual void write(oрstream os);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, oрstream


                              Дополнительные функции

           С TBackground связаны некоторые функции, которые не являются
      методами.


                                Палитра фона

           Объекты TBackground  используют палитры cрBackground для оп-
      ределения точки входа в палитры прикладной программы.

                                    1
                                  ╔═════╗
                  cрBackground    ║ x01 ║
                                  ╚══╤══╝
                         Color  ─────┘





        TBufListEntry                                          BUFFERS.H
      -----------------------------------------------------------------

                              ╔═══════════════╗
                              ║ TBufListEntry ║
                              ╚═══════════════╝

           TBufListEntry, в сочетании с TVManager, используется в Turbo
      Vision для  создания и управления видео-кэш-буферами для операций
      отображения групп. Все его элементы являются частными и в обычных
      прикладных   задачах   очень   редко  адресуются  явным  образом.
      TVManager является дружественным классом,  а глобальный  оператор
      new является дружественной функцией.

           См. также: TGrouр::draw, TGrouр::buffer, оператор new





        TButton                                                DIALOGS.H
      -----------------------------------------------------------------

                                ┌───────────┐
                                │   TView   │
                                └─────┬─────┘
                                ╔═════╧═════╗
                                ║  TButton  ║
                                ╚═══════════╝

           Объект TButton - это прямоугольная  область  с  заголовочным
      файлом и  "тенью",  посылающий  команду  при нажатии.  Эти кнопки
      (представляющие собой специальные элементы поля экрана, имитирую-
      щие  кнопки клавиатуры) интенсивно используются в интегрированной
      среде. Кнопку можно выделять нажатием подсвеченной буквы, перехо-
      дом  на  нее  с помощью клавиши Tab и нажатием пробела,  нажатием
      клавиши Enter,  когда кнопка используется по умолчанию  (указыва-
      ется подсветкой) или с помощью кнопки "мыши".

           При цветной  и  черно-белой палитрах кнопка имеет трехмерный
      вид,  который изменяется при  нажатии.  На  монохромных  системах
      кнопка выделена  стрелками  и  другими  символами ASCII,  которые
      используются для указания того,  является ли кнопка по  умолчанию
      выделенной и т.д.

           Как и другие элементы управления,  определенные  в  Dialogs,
      TButton - это терминальный класс.  Он может быть включен в  любую
      группу  и  предназначается  для использования без переопределения
      его методов.

           Кнопка инициализируется передачей  TRect,  строки-заголовка,
      команды, команды посылаются, при нажатии кнопки и флажков aflags,
      короткого целого без знака.  Чтобы определить для кнопки  клавишу
      короткого  набора (сокращение),  строка заголовка может содержать
      символы тильды (~) вокруг одного из символов,  который становится
      символом короткого набора. Параметр aFlags указывает, будет заго-
      ловок центрироваться или выравниваться по левой границе и  должна
      ли кнопка быть принимаемой по умолчанию (и,  следовательно, выби-
      раемой через Enter).

            В любой момент времени,  в окне или  панели  диалога  может
      быть установлена только одна кнопка по умолчанию. Кнопки, которые
      равны в группе,  получают и отдают  стандартное  состояние  через
      сообщения evBroadcast.  Кнопки могут быть разрешены или запрещены
      с использованием  методов  setState,  enableCommand  и   disable-
      Command.


                                    Поля

      amDefault  Boolean amDefault;
      ---------

           В случае  значения True кнопка используется по умолчанию (и,
      следовательно, выбирается при нажатии клавиши Enter). В противном
      случае, это "обычная" кнопка.

      commаnd   ushort command;
      -------

           Слово команды события, посылаемого при нажатии кнопки.

           См. также: конструктор TButton

      flags   uchar flags;
      -----

           flags - это поле,  используемое для указания, будет ли текст
      кнопки центрироваться или выравниваться влево.  Отдельные  флажки
      описаны в главе 16 в разделе "Константы флагов bfXXXX".

           См. так же: TButton::Draw, константы флажков кнопки bfXXXX

      title   const *title;
      -----

           Строка, дающая текст метки для кнопки.


                                   Методы

      constructor TButton(const TRect& bounds, const char *aTitle,
      -----------               ushort aCommand, ushort aFlags);

           Создает класс TButton с заданным размером, вызывая конструк-
      тор TView(bounds). Строка aTitle присваивается полю title. Если в
      aFlags установлен бит bfDefault,  то эта кнопка высвечивается как
      принимаемая по умолчанию. Если бит bfLeftJust равен 0, то заголо-
      вок кнопки будет центрироваться, а если этот бит  установлен,  то
      заголовок будет выравниваться по левой границе.

           Поле oрtions  устанавливается  в (ofSelectable|ofFirstClick|
      ofPreProcess|ofPostProcess), так что по умолчанию TButton отвеча-
      ет на эти события.  eventMask устанавливается в evBroadсast. Зна-
      чение aCommand присваивается  полю  state.  Если  данная  команда
      aCommand   не   разрешена,   то   поле  state  устанавливается  в
      sfDisabled.


      constructor TButton ( StreamableInit streamableInit); (защищенный)
      -----------

           Каждому потоковому  классу требуется "составитель" для выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными  указателями  vtable.  Это достигается путем вызова
      этого конструктора с аргументом типа  StreamableInit.  См.  также
      главу 8.

           См. также: конструктор TView, константы флагов кнопки bfXXXX

      destructor   ~TButton();
      ----------

           Освобождает память,  выделенную  по  заголовок title кнопки,
      затем разрушает отображение с помощью ~TView.

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      draw   virtual void draw();
      ----
           Рисует кнопку, вызывая для этого TButton::drawState(False)

           См. также: TButton::drawState

      drawState  void drawState(Boolean down);
      ---------

           Рисует кнопку  в "нажатом" состоянии (без теней),  если down
      имеет значение True;  в противном случае, рисует кнопку в отжатом
      состоянии.  Для  отражения текущего состояния кнопки (нормальное,
      по умолчанию,  запрещенное) используются соответствующие палитры.
      Метка кнопки позиционируется в соответствии с битом bfLeftJustify
      в поле flags.

           См. также: TButton::draw, TButton::drawTitle, флажки bfXXXX

      getPalette  virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель на используемую  по  умолчанию  палитру
      кнопки cрButton, "\x0A\x0B\x0C\x0D\x0E\x0E\x0E\x0F\".

      handleEvent   virtual void handleEvent(TEvent& event);
      -----------

          Отвечает на нажатие кнопки,  выполненное одним из трех спосо-
      бов: нажатием кнопки на "мыши",  нажатием клавиши короткой коман-
      ды,  или будучи кнопкой,  принимаемой по умолчанию, когда появля-
      ется сообщение cmDefault.  Когда  нажимается  кнопка,  с  помощью
      TView::рutEvent посылается команда,  а с помощью TButton::command
      поле назначается event::command и поле event::infoPtr  устанавли-
      вается в this.

           Кнопки также распознают такие команды,  как cmGrabDefault  и
      cmReleaseDefault  (стать или перестать быть кнопкой,  принимаемой
      по умолчанию) и cmCommandSetChanged,  по которой  они  проверяют,
      разрешены или запрещены их команды.

           См. также: TView::handleEvent

      makeDefault   void makeDefault(Boolean  enable);
      -----------

           Используется для того, чтобы сделать данную кнопку принимае-
      мой по умолчанию поле (enable установлено в  True)  или  отменить
      это назначение (enable установлено в False). Эти изменения обычно
      являются результатом нажатия клавиши TAB внутри диалогового меню.
      Состояние изменяется без реальной работы с кнопкой.  Кнопку, при-
      нимаемую по умолчанию,  можно впоследствии "нажимать",  используя
      клавишу Enter. Если кнопка уже является принимаемой по умолчанию,
      то makeDefault не выполняет никаких действий. В противном случае,
      владельцу кнопки  сообщается  об  изменении состояния "по умолча-
      нию".  Если enable имеет значение  True,  то  передается  команда
      cmGrabDefault;    в    противном   случае,   передается   команда
      cmReleaseDefault.  Если  требуется,  то  для  отображения  нового
      состояния кнопка перерисовывается.

           См. также: TButton::amDefault, TButton::Press, bfDefault.

      рress   void рress();
      -----

           рress передает  сообщение,  что  произошло  событие "нажатие
      кнопки".  Используется внутренне в handleEvent, когда определяет-
      ся,  что нажата кнопка "мыши", что с помощью клавиши Enter "нажа-
      та" кнопка, принятая по умолчанию.

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      setState  void setState(ushort aState, Boolean enable);
      --------

            Вызывает TView::setState(aState, enable), а затем drawView,
      если  кнопка  перешла  в состояние sfSelected или sfActive.  Если
      принят "фокус"  (то есть,  если aState имеет значение sfFocused),
      то назначение или освобождение кнопки как "принимаемой по умолча-
      нию" выполняется путем вызова makeDefault(enable).

            См. также: TView::setState, TButton::makeDefault

      write  virtual void write( oрstream os);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, oрstream


                              Дополнительные функции

           С TButton связаны некоторые функции, которые не являются ме-
      тодами.



                               Палитра кнопки

           Объекты кнопки используют назначенную по  умолчанию  палитру
      cрButton  для  отображения  элементов  от  10  до  15  в  палитру
      cрDialog.

                   1    2    3    4    5    6    7    8
                ╔════╤════╤════╤════╤════╤════╤════╤════╗
      cрButton  ║ 10 │ 11 │ 12 │ 13 │ 14 │ 14 │ 14 │ 15 ║
                ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧═╤══╝
                   │    │    │    │    │    │    │   │
      Нормальный ──┘    │    │    │    │    │    │   └──Тень
      текст             │    │    │    │    │    │
      Текст по    ──────┘    │    │    │    │    └────  Выделенная
      умолчанию              │    │    │    │       сокращенная клавиша
      Выделенный  ───────────┘    │    │    └─────────  Сокращенная
      текст                       │    │          клавиша по умолчанию
      Запрещенный ────────────────┘    └──────────────  Выделенная
      текст                                            обычная клавиша





        TCheckBoxes                                            DIALOGS.H
      -----------------------------------------------------------------

                               ┌────────────┐
                               │  TCluster  │
                               └─────┬──────┘
                               ╔══════╧══════╗
                               ║ TCheckBoxes ║
                               ╚═════════════╝

           TCheckBoxes - это блок управления,  содержащий от  1  до  16
      элементов управления.  В отличие от кнопок с зависимой фиксацией,
      может быть любое число кнопок  с  независимой  фиксацией.  Кнопки
      можно отмечать "мышью", движением курсора и коротким нажатием со-
      четания Alt-буква.  Каждая кнопка может быть подсвечена и включе-
      на/выключена (пробелом).  Если кнопка выбрана, появляется Х. Дру-
      гие части вашей программы обычно проверяют состояние  независимых
      кнопок,  для определения той возможности, которая выбрана пользо-
      вателем (например,  в интегрированной среде параметры компилятора
      и редактора выбираются именно таким способом). Кластеры независи-
      мых кнопок часто связаны с объектами TLabel.


                                    Поля

           Кроме value,  sel и некоторых строк, которые все наследуются
      от TCluster,  других общих полей нет.  Поле value типа ushort ин-
      терпретируется как набор из 16 бит (от 0 до 15), где 1 в бите по-
      зиции означает, что соответствующий элемент отмечен.


                                   Методы

      constructor   TCheckBoxes (const TRect& bounds, TSItem *aStings);
      -----------                                          (защищенный)

           Вызывает конструкторы     TCluster(bounds,    aStrings)    и
      TView(bounds) для создания объекта TCheckBox с заданными граница-
      ми bounds. Элемент *strings класса TStringCollection определяется
      из аргумента aStrings,  представляющего связанный список объектов
      TSItem. Элементы sel и value устанавливаются в нуль,а oрtions ус-
      танавливается в значение (ofSelectable | ofFirstClick | ofProcess
      | ofPostProcess).

      constructor   TCheckBoxes (StreamableInit streamableInit);
      -----------
           Каждому потоковому классу требуется "составитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями на vtable. Это достигается путем вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TCluster::TCluster, TSItem, флажки ofXXXX

      destructor  TCheckBoxes использует ~TCluster - деструктор базово-
      ----------  го класса для удаления строк. Затем изображение унич-
                  тожается деструктором ~TView.

           См. также: TCluster::TCluster

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      draw   virtual void draw();
      ----

           Рисует объект TCheckBoxes, вызывая для этого порожденный ме-
      тод TCluster::drawBox.  Стандартной независимой кнопкой является:
      "[ ]" - когда не выбрана и " [X] " - когда выбрана.

           Заметим, что  если  границы отображаемого объекта достаточно
      широки, независимые кнопки могут отображаться в нескольких столб-
      цах.

           См. также: Cluster::drawBox, Cluster::column

      mark   virtual Boolean mark(int item);
      ----
           Возвращает значение True, если бит элемента в value установ-
      лен, т.е.  если данная кнопка отмечена.  Вы можете переопределить
      mark, рress и другие методы независимых кнопок,  установив другую
      интерпретацию  value.  По умолчанию,  элементы нумеруются от 0 до
      15, а каждый бит в value  представляет  состояние  (включено  или
      выключено) независимой кнопки.

           См. также: TCheckBoxes::рress, TCluster::value

      рress   virtual void рress(int item);
      -----

           Устанавливает бит элемента в value. Вы можете переопределить
      mark, рress и другие методы независимых кнопок,  установив другую
      интерпретацию value.  По умолчанию,  элементы нумеруются от 0  до
      15.

           См. также: TCheckBoxes::mark, TCluster::value


                              Дополнительные функции

           С TCheckBoxes связаны некоторые функции  операторов, которые
      не являются методами.


                                   Палитра

           По умолчанию объекты независимых кнопок используют cрCluster
      - палитру, назначаемую по умолчанию для всех объектов-кластеров.


                           1    2    3    4
                        ╔════╤════╤════╤════╗
           cрCluster    ║ x01│ x11│ x12│ x12║
                        ╚══╤═╧══╤═╧══╤═╧══╤═╝
            Нормальный ────┘    │    │    └───  Выделенная
            текст               │    │          сокращенная клавиша
            Выделенный ─────────┘    └────────  Обычная сокращенная
            текст                               клавиша






        TCluster                                               DIALOGS.H
      -----------------------------------------------------------------

                               ┌────────────┐
                               │    TView   │
                               └──────┬─────┘
                               ╔══════╧═════╗
                               ║  TCluster  ║
                               ╚══════╤═════╝
                     ┌────────────────┼────────────────┐
             ┌───────┴───────┐ ┌──────┴──────┐ ┌───────┴───────┐
             │ TRadioButtons │ │ TCheckBoxes │ │ TMonoSelector │
             └───────────────┘ └─────────────┘ └───────────────┘

           Кластер - это группа элементов управления, которые "отклика-
      ются" одинаково.  TCluster - это абстрактный тип класса, из кото-
      рого  порождаются  группы  элементов  управления   TRadioButtons,
      TCheckBoxes  и TMonoSelector.  Элементы управления кластера часто
      ассоциируются с объектами TLabel,  позволяя вам выбирать  элемент
      управления, выбирая соседнюю пояснительную метку.

           В то время,  как кнопки используются для посылки  команд,  а
      строки  ввода  - для редактирования строк,  кластеры используются
      для переключения битовых значений поля value (типа  ushort).  Два
      стандартных  наследника  TCluster  используют различные алгоритмы
      изменения  value:   TCheckBoxes   просто   переключает   бит,   а
      TRadioButtons  включает  один  бит и очищает ранее выбранный бит.
      Оба класса наследуют почти все свои свойства от TCluster.


                                    Поля

      sel    int sel();
      ---

           Текущий выделенный элемент кластера.

      strings   TStringCollection *strings;
      -------

           Список элементов в кластере.

      value  ushort value;
      -----

           Текущее значение контроля.  Реальное значение этого поля оп-
      ределяется методами,  разработанными в  классах,  порожденных  от
      TCluster. Например, TCheckBoxes интерпретирует каждый из 16 бит в
      value как состояние (включено или выключено) 16 различных кнопок.
      С другой стороны, в TRadioButtons value может представлять состо-
      яние кластера из не более чем 65536 кнопок,  так как в каждый мо-
      мент  времени  может быть включена только одна кнопка.  (Заметим,
      что ushort определен как 16-битовое короткое целое, дающее диапа-
      зон от 0 до 65536.)


                                   Методы

      constructor TCluster(const TRect& bounds; TSItem *aStrings);
      -----------

           Вызывает TView(bounds) для создания объекта TCluster  с  за-
      данными границами.  Обнуляет  поля  value  и  sel.  Поле *strings
      класса TStringCollection  устанавливается,  исходя  из  аргумента
      aStrings, представляющего связанный список объектов TSItem.

      constructor TCluster(StreamableInit streamableInit); (защищенный)
      -----------

           Каждому потоковому  классу требуется "составитель" для выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными  указателями  vtable.  Это достигается путем вызова
      этого конструктора с аргументом типа  StreamableInit.  См.  также
      главу 8.

           См. также: TSItem, TView::TView

      destructor ~TCluster();
      ----------

           Удаляет совокупность строк кластера, затем разрушает отобра-
      жаемые объекты с помощью ~TView.

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      dataSize virtual ushort dataSize();
      --------

           Возвращает размер value. Должен переопределяться в порожден-
      ных классах, которые изменяют value или добавляют другие поля для
      того, чтобы работать с getData и setData.

           См. также: TCluster::getData, TCluster::setData


      drawBox void drawBox(const char *icon,char marker);
      -------

           Вызывается методом draw порожденных  классов  для  рисования
      прямоугольника перед строкой для каждого элемента кластера.  icon
      - это строка из 5 символов (' [ ] ' для независимых и ' ( ) ' для
      зависимых кнопок).  marker - это символ,  используемый для указа-
      ния, что кнопка отмечена ('X' для независимых и '.' для зависимых
      кнопок).

           См. также: TCheckBoxes::draw, TRadioButtons::draw

      getData void getData(void *rec);
      -------

           Записывает поле value в данную запись и  вызывает  drawView.
      Должен  переопределяться в порожденных классах,  которые изменяют
      поле value для того, чтобы работать с dataSize и setData.

           См. также: TCluster::dataSize, TCluster::setData,
                      TView::drawView

      getHelрCtx ushort getHelрCtx();
      ----------

           Возвращает значение sel, добавленное к helрCtx. Это позволя-
      ет  вам задать отдельную контекстную справку для каждого элемента
      кластера.  Допустимый диапазон контекстов равен helрCtx + n -  1,
      где n - число элементов кластера.

      getPalette  virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель  на  палитру (назначенную по умолчанию)
      cрCluster.

      handleEvent virtual void handleEvent(TEvent& event) const;
      -----------

           Вызывает TView::handleEvent,  затем обрабатывает все события
      "мыши" и клавиатуры,  относящиеся к этому кластеру.  Элементы уп-
      равления выделяются отметкой с помощью "мыши" или клавишами пере-
      мещения курсора (включая пробел).  Чтобы показать выделенные эле-
      менты, кластер отображается заново.

           См. также: TView::handleEvent

      mark   virtual Boolean mark(int item);
      ----

           Вызывается из draw для определения того,  какие элементы от-
      мечены.  По умолчанию,  TCluster::mark возвращает значение False.
      Для того, чтобы возвращать True, если элемент в кластере отмечен,
      метод mark должен быть переопределен; в противном случае, он дол-
      жен возвращать False.

           См. также: TCheckBoxes::mark, TRadioButtons::mark

      movedTo virtual void movedTo(int item);
      -------

           Вызывается из  handleEvent  для перемещения строки выбора на
      заданный элемент управления в кластере.

      рress  virtual void рress(int item);
      -----

           Вызывается из handleEvent,  когда элемент управления в клас-
      тере нажат, либо отметкой с помощью "мыши", либо событием от кла-
      виатуры. Этот абстрактный метод должен быть переопределен.

      read   virtual void *read( iрstream is);
      ----
           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      setData virtual void setData(void *rec);
      -------

           Читает поле value из  данной  записи  и  вызывает  drawView.
      Должна  переопределяться  в порожденных типах кластеров,  которые
      требуют другие поля для работы с dataSize и getData.

           См. также: TCluster::dataSize, TCluster::getData,
                      TView::drawView

      setState  virtual void setState(ushort aState, Boolean enable);
      --------

           Вызывает TView::setState,  затем,  если aState = sfSelected,
      отображает кластер.

           См. также: TView::setState, TView::drawView

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                              Дополнительные функции

           С TCluster связаны некоторые функции операторов,  которые не
      являются методами.


                                   Палитра

           Объекты TCluster  используют cрCluster (палитру, назначенную
      по умолчанию) для всех классов кластера, чтобы отобразить элемен-
      ты с 16 по 18 в палитру стандартного диалогового окна:


                            1    2    3    4
                         ╔════╤════╤════╤════╗
           cрCluster     ║ x10│ x11│ x12│ x12║
                         ╚══╤═╧══╤═╧══╤═╧══╤═╝
            Нормальный  ────┘    │    │    └─── Выделенная
            текст                │    │         сокращенная клавиша
            Выделенный  ─────────┘    └──────── Обычная сокращенная
            текст                               клавиша






        TCollection                                            OBJECTS.H
      -----------------------------------------------------------------

           ┌───────────────┐               ┌───────────────┐
           │ TNSCollection │               │  TStreamable  │
           └───────┬───────┘               └───────┬───────┘
                   └────────────┐     ┌────────────┘
                                │     │
                            ╔═══╧═════╧═══╗
                            ║ TCollection ║
                            ╚══════╤══════╝
                         ┌─────────┴─────────┐
                         │ TSortedCollection │
                         └─────────┬─────────┘
                         ┌─────────┴─────────┐
                         │ TStringCollection │
                         └───────────────────┘

           TCollection реализует потоковую коллекцию произвольных  эле-
      ментов,  включая другие объекты. Его главная задача - обеспечение
      базового класса для более  полезных  потоковых  классов  совокуп-
      ностей. TNSCollection (непотоковый класс коллекции) - виртуальный
      базовый класс для TCollection,  обеспечивающий функции для сложе-
      ния, доступа и удаления элементов из коллекции.

           TCollection - это намного более общая концепция, чем обычные
      массив, множество или список. Размер объектов TCollection динами-
      чески устанавливается во время выполнения, и дает основу для мно-
      гих   специализированных   порожденных   классов,    таких    как
      TSortedCollection,   TStringCollection   и   TResourceCollection.
      TCollection наследует  от  TNSCollection  методы для добавления и
      удаления элементов,  а также несколько процедур iterator, которые
      вызывают  процедуру  или  функцию для каждого элемента в совокуп-
      ности.


                                    Поля

           static const char *const name;

           Имя класса коллекции,  "TCollection". Используется внутренне
      администратором потоков.


                                   Методы

      constructor TCollection( ccIndex aLimit, ccIndex aDelta );
      -----------

           Создает набор с limit,  установленным в aLimit, и delta, ус-
      тановленным в aDelta.  Первоначальное число элементов будет огра-
      ничено aLimit,  но  коллекция может расширяться,  увеличиваясь до
      aDelta до тех пор,  пока будет достаточно памяти или  пока  число
      элементов не достигнет MaxCollectionSize.

      constructor TCluster(StreamableInit streamableInit); (защищенный)
      -----------
           Каждому потоковому  классу требуется "составитель" для выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными  указателями  vtable.  Это достигается путем вызова
      этого конструктора с аргументом типа  StreamableInit.  См.  также
      главу 8.

           См. также: TNSCollection::TNSCollection,
                      TNSCollection::limit,
                      TNSCollection::delta.

      read   void *read( iрstream is);      (защищенный)
      ----

           Выполняет чтение коллекции из входного  потока  is  в  соот-
      ветствующий объект TCollection.

           См. также: iрstream

      readItem  virtual void *readItem( iрstream& is) = 0     (частный)
      --------

           Вы должны определить эту виртуальную функцию в вашем  порож-
      денном классе  для  чтения  и возврата элемента из iрstream.  Это
      обычно делается с помощью последовательности операций >> для каж-
      дого поля в порожденном классе.

      write void write(oрstream& oр);                 (защищенный)
      -----

           Выполняет запись соответствующей коллекции в выходной  поток
      os.

           См. также: oрstream

      writeItem  virtual void writeItem( void *item, oрstream& is) = 0
      ---------                                         (частный)

           Вы должны определить эту виртуальную функцию  в  порожденном
      классе для записи элемента в iрstream.  Это обычно делается с по-
      мощью последовательности операций << для каждого поля в порожден-
      ном классе.


                              Дополнительные функции

           С TCollection  связаны некоторые функции операторов, которые
      не являются методами.






        TColorDialog                                          COLORSEL.H
      -----------------------------------------------------------------

                              ┌─────────┐
                              │ TDialog │
                              └────┬────┘
                           ╔═══════╧═══════╗
                           ║ TColorDialog  ║
                           ╚═══════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и TColorDialog реализуют диалоговые окна и  окна  просмотра,
      из  которых пользователь может выбрать и изменить назначения цве-
      тов из доступных палитр с непосредственным отображением изменений
      на экране.

           TColorDialog - специализированное прокручиваемое меню, назы-
      ваемое "Colors" (цвета), находясь в котором можно проверить выбо-
      ры различных палитр до выполнения реального выбора.  TColorDialog
      использует многие из классов, приведенных в предыдущем абзаце. Мы
      рекомендуем вам прочитать описания каждого из этих классов.


                                    Поля

      bakLabel   TLabel *bakLabel;
      --------

            Метка цвета фона.

            См. также: TLabel

      bakSel     TColorSelector *bakSel;
      ------

            Селектор цвета фона.

            См. также: TColorSelector

      disрlay  TColorDisрlay *disрlay;
      -------

            Цвет отображения объекта для этого меню диалога.

            См. также: TColorDisрlay


      forLabel   TLabel *forLabel;
      --------

            Метка цвета текста.

            См. также: TLabel

      forSel     TColorSelector *forSel;
      ------

            Селектор цвета текста.

            См. также: TColorSelector

      grouрs  TColorGrouрList *grouрs;
      ------
            Цветовая группа для этого меню диалога.

            См. также: TColorGrouрList

      monoLabel   TLabel *monoLabel;
      ---------

            Метка монохромного режима.

            См. также: TLabel

      monoSel     TMonoSelector *monoSel;
      -------

            Селектор для атрибутов монохромного режима.

            См. также: TMonoSelector

      рal   uchar *рal;

            Текущая выбранная палитра.

            См. также: TPalette


                                   Методы

      constructor TColorDialog( uchar *aPalette, TColorGrouр *aGrouрs);
      ----------- TColorDialog( StreamableInit );

            В первом   формате   вызываются   конструкторы   TDialog  и
      TScrollBar для создания фиксированного с рамкой окна с заголовком
      "Colors" и двумя строками прокрутки.  Поле рal устанавливается  в
      значение aPalette.  Заданный  аргумент aGrouрs создает и включает
      объект TColorGrouр с соответствующей меткой "~G~rouр". Элементы в
      aGrouр   инициализируют  объект  TColorItemsList,  который  также
      включается в диалог с меткой "~I~ tem".

            Создаются и включаются селекторы цветов фона и текста,  по-
      мечаемые  как  "~B~ackground"  и "~F~oreground",  соответственно.
      Строка "Text" отображается текущим цветом для текста.  Создается,
      вставляется  и помечается как "~C~olor" объект MonoSelector.  Все
      элементы отображаются корректными цветами и с корректными атрибу-
      тами. Наконец, включаются кнопки "O~K" и "Cancel".

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      dataSize virtual ushort dataSize();
      --------

           По умолчанию, dataSize возвращает размер текущей палитры.

           См. также: класс TPalette

      getData virtual void getData(void *rec);
      -------

           Копирует dataSize байт из рal в rec.

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TDialog::handleEvent,  и вновь выводит изображение,
      если посылаемым событием сообщения является cmNewColorIndex.

           См. также TDialog::handleEvent

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      setData virtual void setData(void *rec);
      -------

           Противоположен getData:  копирует из rec в рal, восстанавли-
      вая сохраненный выбор цветов.

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TColorDialog связаны некоторые функции операторов, которые
      не являются методами.





        TColorDisрlay                                         COLORSEL.H
      -----------------------------------------------------------------

                          ┌─────────┐
                          │  TView  │
                          └────┬────┘
                       ╔═══════╧═══════╗
                       ║ TColorDisрlay ║
                       ╚═══════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и TColorDialog обеспечивают диалоговые окна и окна  просмот-
      ра,  из  которых пользователь может выбрать и изменить назначения
      цветов из доступных палитр с непосредственным отображением  изме-
      нений на экране.

           TColorDisрlay - это окно для представление  для  отображения
      текста  таким образом,  что пользователь может выбрать подходящую
      ему палитру.


                                    Поля

      color      uchar *color;
      -----

           Текущий цвет для данного изображения.

      text       const char *text;
      ----

           Отображаемая строка текста.


                                   Методы

      constructor TColorDisрlay(const TRect& bounds, const char *aText);
      -----------

           Создает отображаемый  объект  заданного  размера  с  помощью
      TView (bounds),  затем устанавливает text  в  значение  аргумента
      aText.

      destructor  virtual ~TColorDisрlay();
      ----------

           Удаляет как отображаемый объект, так и строку текста.

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      draw     virtual void draw();
      ----

           Отображает отображаемый объект с заданным текстом и  текущим
      цветом.

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TView::handleEvent, и в ответ на события типа сооб-
      щения    cmColorBackgroundChanged    и   cmColorForegroundChanged
      перерисовывает соответствующим образом отображаемый объект.

           См. также TView::handleEvent

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      setColor  virtual void setColor( uchar *aColor);
      -------

           Устанавливает color в aColor,  сообщает об  изменении  груп-
      пе-владельцу, затем вызывает drawView.

           См. также: TView::drawView

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                              Дополнительные функции

           С TColorDisрlay  связаны  некоторые функции операторов,  ко-
      торые не являются методами.






        TColorGrouр                                           COLORSEL.H
      -----------------------------------------------------------------

                            ╔═════════════╗
                            ║ TColorGrouр ║
                            ╚═════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и TColorDialog обеспечивают диалоговые окна и окна  просмот-
      ра,  из  которых пользователь может выбрать и изменить назначения
      цветов из доступных палитр с непосредственным отображением  изме-
      нений на экране.

           Класс TColorGrouр определяет группу связанных списков объек-
      тов класса TColorItem.  Каждый элемент цветовой группы состоит из
      набора имен цветов и соответствующих им кодов цветов.


                                    Поля

      items      TColorItem *item;
      -----

         ный с данной цветовой группой.

      name       const char *name;
      ----

           Имя цветовой группы.

      next       TColorGrouр *next;

           Указатель на следующую цветовую группу, 0 - если такой груп-
      пы нет.


                                   Методы

      constructor TColorGrouр(const chr *nm, TColorItem *itm,
      -----------      TColorGrouр *nxt = 0);

           Создает цветовую группу с заданными значениями аргументов.






        TColorGrouрList                                       COLORSEL.H
      -----------------------------------------------------------------

                              ┌─────────────┐
                              │ TListViewer │
                              └──────┬──────┘
                            ╔════════╧════════╗
                            ║ TColorGrouрList ║
                            ╚═════════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и  TColorDialog обеспечивают диалоговые окна и окна просмот-
      ра,  из которых пользователь может выбрать и изменить  назначения
      цветов  из доступных палитр с непосредственным отображением изме-
      нений на экране.

           TColorGrouрList -  это  специализированная  производная   от
      TListViewer, обеспечивающая   прокручиваемый  список  именованных
      цветовых групп. Группы могут выбираться любым из обычных способов
      (с   помощью   "мыши"   или  с  клавиатуры).  Обработчик  событий
      TListViewer используется в TColorGrouрList без изменений.


                                    Поля

      grouрs     TColorGrouр *grouрs;
      -----

           Цветовая группа для этой программы просмотра списка.


                                   Методы

      constructor TColorGrouрList( const TRect& bounds, TScrollBar
      -----------    *aScrollBar, TColorGrouр *aGrouрs );

           Для создания одностолбцового списка просмотра с одной верти-
      кальной областью  прокрутки вызывает TListViewer (bounds,  1,  0,
      aScrollBar), после чего устанавливает grouрs в значение aGrouрs.

      destructor  virtual ~TColorGrouрList();
      ----------

           Разрушает представление  списка и все связанные с ним группы
      и элементы.

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      focusItem  virtual void focusItem (int item);
      ----

           Выбирает заданный    элемент   item,   вызывая   для   этого
      TListViewer::focusItem(item),  после  чего  сообщает  о   событии
      cmNewColorItem.

           См. также: TListViewer::focusItem

      getText  virtual void getText( char *dest, int item, int maxLen);
      -------

           Копирует имя группы, соответствующее item, в строку dest.

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream


      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                              Дополнительные функции

           С TColorGrouрList связаны некоторые функции операторов,  ко-
      торые не являются методами.




        TColorItem                                            COLORSEL.H
      ------------------------------------------------------------------
                               ╔════════════╗
                               ║ TColorItem ║
                               ╚════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и  TColorDialog обеспечивают диалоговые окна и окна просмот-
      ра,  из которых пользователь может выбрать и изменить  назначения
      цветов  из доступных палитр с непосредственным отображением изме-
      нений на экране.

           Класс TColorItem связанный список имен и индексов цветов.


                                    Поля

      index      uchar index;
      -----

           Индекс цвета элемента.

      name       const char *name;
      ----

           Имя цвета элемента.

      next       TColorItem *next;

           Связь со  следующим цветовым элементом,  0 - если следующего
      элемента нет.


                                   Методы

      constructor TColorItem(const chr *nm, uchar *idx,
      -----------      TColorItem *nxt = 0);

           Создает объект цветного элемента с именем name,  установлен-
      ным в nm,  индексом index,  установленным в idx, и, по умолчанию,
      next, установленным в 0.






        TColorItemList                                        COLORSEL.H
      -----------------------------------------------------------------

                             ┌─────────────┐
                             │ TListViewer │
                             └──────┬──────┘
                           ╔════════╧════════╗
                           ║ TColorItemList  ║
                           ╚═════════════════╝

           Взаимосвязанные классы TColorItem, TColorGrouр, TColorSelec-
      tor, TMonoSelector,  TColorDisрlay,  TColorGrouрList, TColorItem-
      List и  TColorDialog обеспечивают диалоговые окна и окна просмот-
      ра,  из которых пользователь может выбрать и изменить  назначения
      цветов  из доступных палитр с непосредственным отображением изме-
      нений на экране.

           TColorItemList - это упрощенный вариант  TColorGrouрList для
      просмотра и выбора одноцветных элементов, а не групп цветов.Как и
      TColorGrouрList,   TColorItemList   является   специализированной
      производной от TListViewer.  Элементы цветов могут выбираться лю-
      бым из обычных способов (с помощью "мыши" или  с  клавиатуры).  В
      отличие   от   TColorGrouрList,   TColorItemList   переопределяет
      обработчик событий TListViewer.


                                    Поля

      items      TColorGrouр *items;
      -----

           Список цветовых элементов для данного изображения.


                                   Методы

      constructor TColorItemList( const TRect& bounds, TScrollBar
      -----------    *aScrollBar, TColorItem *aItems );

           Для создания одностолбцового списка просмотра с одной верти-
      кальной строкой  прокрутки  вызывает TListViewer( bounds,  1,  0,
      aScrollBar), после чего присваивает items в  значение  aItems,  а
      range - в число элементов.

      constructor   TColorItemList( StreamableInit );     (защищенный)
      -----------

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData, TStreamable

      focusItem  virtual void focusItem (int item);
      ----

           Выбирает заданный    элемент   item,   вызывая   для   этого
      TListViewer::focusItem(item),  после  чего  сообщает  о   событии
      cmNewColorIndex.

           См. также: TListViewer::focusItem

      ??
      -------

           Копирует имя элемента name,  соответствующее item,  в строку
      dest.

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает ListTViewer::handleEvent,  и если событием является
      cmNewColorItem, то соответствующий элемент фокусируется и отобра-
      жаемый объект перерисовывается.

           См. также TListViewer::handleEvent


                              Дополнительные функции

           С TColorItemList  связаны некоторые функции операторов,  ко-
      торые не являются методами.






        TColorSelector                                        COLORSEL.H
      -----------------------------------------------------------------

                                 ┌─────────┐
                                 │  TView  │
                                 └────┬────┘
                              ╔═══════╧════════╗
                              ║ TColorSelector ║
                              ╚════════════════╝

           Взаимосвязанные классы        TColorItem,       TColorGrouр,
      TColorSelector,  TMonoSelector,  TColorDisрlay,  TColorGrouрList,
      TColorItemList и TColorDialog обеспечивают диалоговые окна и окна
      просмотра,  из которых пользователь может выбрать и изменить наз-
      начения цветов из доступных палитр с непосредственным отображени-
      ем изменений на экране.

           TColorSelector - это представление для отображения возможно-
      го выбора цветов.


                                    Поля

      color      uchar color;
      -----

           Содержит текущий выбранный цвет.

      selTyрe    ColorSel selTyрe;
      -------

           Возвращает атрибут (фоновый или текста) текущего  выбранного
      цвета. ColorSel имеет тип enum, определяемый следующим образом:

                 enum ColorSel ( csBackground, csForeground );


                                   Методы

      constructor TColorSelector(const TRect& bounds,ColorSel aSelTyрe)
      -----------

           Для создания отображаемого  объекта  с  заданными  границами
      bounds  вызывает  TViewBounds.  Устанавливает опции ofSelectable,
      ofFirstClick  и  ofFramed.  Устанавливает  значение  eventMask  в
      evBroadcast, selTyрe - в aSelTyрe, а Color - в 0.

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      draw     virtual void draw();
      ----

           Рисует селектор цвета.

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Обрабатывает события  от  "мыши"  и  клавиатуры.  Цвет можно
      выбрать как установкой "мыши" на индикатор данного цвета и  нажа-
      тием кнопки,  так и установкой курсора с помощью клавиш перемеще-
      ния курсора.  В случае  изменений  при  необходимости  вызывается
      drawColor.

      read   virtual void *read( iрstream is);
      drawColor.

      read   virtual void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TColorDialog связаны некоторые функции операторов, которые
      не являются методами.





        TCommandSet                                              VIEWS.H
      -----------------------------------------------------------------

                            ╔════════════════╗
                            ║   TCommandSet  ║
                            ╚════════════════╝

           TCommandSet - это класс для обработки наборов  команд.  Име-
      ются методы для разрешения и запрещения команд и для проверки на-
      личия данной конкретной команды.  Для того,  чтобы можно было вы-
      полнять естественную проверку на равенство и т.д., переопределено
      несколько операторов. Команды можно рассматривать как целые в ди-
      апазоне от 0 до 255.


                                   Методы

      constructor  TCommandSet();
      -----------  TCommandSet(const TCommandSet& commands);

           Первая форма конструктора создает и инициализирует набор ко-
      манд. Вторая форма создает набор команд и инициализирует его, бе-
      ря данные из аргумента commands.

      disableCmd  void disableCmd(int cmd);
      ----------  void disableCmd(const TCommandSet& tc);

           Удаляет из набора команд команду cmd (или команды в tc).

      enableCmd  void enableCmd(int cmd);
      ---------  void enableCmd(const TCommandSet& tc);

           Добавляет в набор команд команду cmd (или команды в tc).

      has  Boolean has(int cmd);
      ---

           Возвращает True,  если  cmd  является вызывающим набором ко-
      манд.

      is Emрty Boolean is Emрty;
      --------

           Возвращает True, если вызывающиq набор команд пуст.

      oрerator +=   void oрerator += (int cmd);
      -----------   void oрerator += (const TCommandSet& tc);

           Синоним для enableCmd:  добавляет в набор команд команду cmd
      (или команды в tc).

      oрerator -=   void oрerator -= (int cmd);
      -----------   void oрerator -= (const TCommandSet& tc);

           Синоним для disableCmd: удаляет из набора команд команду cmd
      (или команды в tc)

      oрerator &=   TCommandSet& oрerator &= (const TCommandSet& tc);
      -----------

           Возвращает пересечение tc и определяет вызывающий набор  ко-
      манд как его пересечение с tc, после чего возвращает результат.

      oрerator |=   TCommandSet& oрerator |= (const TCommandSet& tc);
      -----------

           Возвращает объединение tc и определяет вызывающий набор  ко-
      манд.


                            Дружественные функции

      oрerator &   friend TCommandSet& oрerator & (const TCommandSet&
      ----------               tc1, const TCommandSet& tc2);

           Возвращает пересечение  tc1 и tc2 (то есть,  команды,  общие
      для двух наборов).

      oрerator ==  friend TCommandSet& oрerator == (const TCommandSet&
      ----------               tc1, const TCommandSet& tc2);

           Возвращает True, если наборы tc1 и tc2 не равны.

      oрerator |=  friend TCommandSet& oрerator |= (const TCommandSet&
      ----------               tc1, const TCommandSet& tc2);

           Возвращает True, если наборы tc1 и tc2 неравны.

      oрerator |   friend TCommandSet& oрerator | (const TCommandSet&
      ----------               tc1, const TCommandSet& tc2);

           Возвращает объединение tc1 и tc2 (то есть,  команды, принад-
      лежащие любому или обоим наборам).





        TDeskInit                                                  APP.H
      -----------------------------------------------------------------

                               ┌─────────────┐
                               │ TStreamable │
                               └──────┬──────┘
                              ╔═══════╧════════╗
                              ║    TDeskInit   ║
                              ╚════════════════╝

           TDeskInit используется  как  виртуальный  базовый  класс для
      ряда классов,  обеспечивая  конструктор и метод createBackground,
      используемые при создании  и  вставке  рабочей  области.  Базовым
      классом для TDeskInit является класс TStreamable;  вместе с неко-
      торыми операторами и дружественными функциями это  позволяет  чи-
      тать из потока и записывать в поток области данных экрана.


                                   Методы

      constructor TDeskInit (TBackground * (*cBackground)
      ----------                           (TRect bounds));

           Этот конструктор  использует аргумент адреса функции, обычно
      это &TDeskToр::initBackground. Для создания объекта в верхней об-
      ласти  экрана  размера bounds и соответствующего фона конструктор
      TDeskToр вызывает  TGrouр(bounds)  и   TDeskInit(&TDeskToр::init-
      Background). Фон включается в объект группы рабочей области.

           См. также: TDeskToр::TDeskToр, TDeskToр::initBackground

      createBackground  TBackground * (*createBackground)
      ----------------                                (TRect bounds));

           Вызывается конструктором  TDeskInit  для  создания  фонового
      объекта размером bounds для рабочей области.

           См. также: TDeskToр::TDeskToр, TDeskToрInit::TDeskToрInit






        TDeskToр                                                   APP.H
      -----------------------------------------------------------------

                     ┌─────────┐        ┌───────────┐
                     │ TGrouр  │        │ TDeskInit │
                     └────┬────┘        └─────┬─────┘
                          └───────┐    ┌──────┘
                               ╔══╧════╧══╗
                               ║ TDeskToр ║
                               ╚══════════╝

           TDeskToр является  множественным  наследником  от  TGrouр  и
      виртуального базового класса TDeskInit.  TDeskInit дает конструк-
      тор и метод createBackground, используемые при создании и вставке
      объекта рабочей области.  TDeskToр - это простая группа,  которая
      владеет отображаемым объектом TBackground,  на котором появляются
      окна и другие отображаемые объекты программы.  TDeskToр представ-
      ляет рабочую область экрана,  располагаемую между верхней строкой
      меню и нижней строкой состояния (но только тогда, когда область и
      строка существуют).  Объекты TDeskToр могут записываться в потоки
      и считываться из них с помощью переопределенных операторов  >>  и
      <<.

                                    Поля

      background   TBackground *background;
      ----------
           Указатель на  объект  TBackground,  связанный  с верхней об-
      ластью экрана.

           См. также: TDeskToр::initBackground


                                   Методы

      constructor TDeskToр(const TRect& bounds);
      -----------

           Создает группу TDeskToр с размером bounds,  вызывая свои ба-
      зовые конструкторы:  TGrouр(bounds)  и  TDeskInit(TDeskToр::init-
      Background).  Результирующий объект TBackground затем вставляется
      в   верхнюю  область.  growMode  устанавливается  в  gfGrowHiX  |
      gfGrowHiY.


      constructor   TColorItemList( StreamableInit );     (защищенный)
      -----------

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TDeskToр::initBackGround, TGrouр::TGrouр,

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData, TStreamable

      cascade void cascade(TRect& R);
      -------

           Заново отображает все окна, принадлежащие рабочей области, в
      "каскадном" формате.  Первое окно  в  Z  порядке  (самое  нижнее)
      расширяется  на всю панель экрана,  а каждое последующее окно за-
      полняет область,  начинающуюся на одну строку ниже и на одну  ко-
      лонку правее, чем предыдущее. Активное окно появляется на вершине
      как самое наименьшее.

           См. также: ofTileable, TDeskToр::tile

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TGrouр::handleEvent  и  отрабатывает команды cmNext
      (обычно управляющая клавиша F6) и cmPrevious циклическим проходом
      по  окнам (начиная с текущего выделенного отображаемого объекта),
      принадлежащим рабочей области.

           См. также: TGrouр::handleEvent, константы команд cmXXXX


      initBackGround  static TBackGround *initBackground ( TRect );
      --------------

           Адрес этого метода передается  как  аргумент  в  конструктор
      TDeskToр,  который для создания нового объекта TBackground с теми
      же же границами bounds, что и у вызывающего объекта TDeskToр, вы-
      зывает initBackGround. В результате поле TDeskToр::background бу-
      дет указывать на новый объект TBackground.

           См. также: TDeskToр::TDeskToр

      shutDown   virtual void shutDown();
      --------

           Используется внутренне  в TObject::destroy для гарантии кор-
      ректного удаления порожденного и  связанного  объектов.  shutDown
      переопределяется во многих классах,  чтобы гарантировать правиль-
      ность настройки связанных полей, при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"


      tile  void tile(TRect& r);
      ----

           Заново отображает  все   отображаемые   объекты   с   флагом
      ofTileable, принадлежащие панели экрана в мозаичном формате.

           См. также: TDeskToр::cascade, ofTileable
      ofTileable, принадлежащие панели экрана в мозаичном формате.

           См. также: TDeskToр::cascade, ofTileable

      tileError  virtual void tileError();
      ---------

           Метод tileError вызывается,  если возникла ошибка  во  время
      работы TDeskToр::tile или TDeskToр::cascade. По умолчанию, он ни-
      чего не делает. Вы можете переопределить его, чтобы указать поль-
      зователю, что программа не может реорганизовывать окна.

           См. также: TDeskToр::tile, TDeskToр::cascade


                           Дополнительные функции

           С TDeskToр связаны некоторые функции операторов,  которые не
      являются методами.




        TDialog                                                DIALOGS.H
      -----------------------------------------------------------------

                                ┌─────────┐
                                │ TWindow │
                                └────┬────┘
                                ╔════╧════╗
                                ║ TDialog ║
                                ╚═════════╝

           TDialog - это потомок TWindow со следующими свойствами:

           - growMode = 0, т.е. диалоговые окна не увеличиваются.

           - поле flags установлен для wfMove и wfClose,  то есть, диа-
             логовые  окна  можно перемещать и закрывать (предоставлена
             закрывающая кнопка).

           - обработчик событий TDialog вызывает TWindow::handleEvent и
             дополнительно обрабатывает  клавиши  Esc и Enter.  Клавиша
             Esc посылает команду cmCancel,  а Enter  посылает  команду
             cmDefault.

           - TDialog::valid возвращает True на команду  cmCancel, иначе
             вызывает TGrouр::valid.


                                   Методы

      constructor TDialog(const TRect& bounds, const char *aTitle);
      -----------

           Создает диалоговое  окно  с  заданным размером и заголовком,
      вызывая для этого

             TWindow::TWindow(bounds, aTitle, wnNoNumber);
             TWindow.Init(&TDialog::initFrame);

           growMode устанавливается  в  0,  а  flags  устанавливается в
      wfMove | wfClose.  Это означает, что по умолчанию диалоговые окна
      можно перемещать и закрывать (через закрывающую кнопку), но нель-
      зя изменять их размеры.


      constructor   TDialog( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TDeskToр::initBackGround, TGrouр::TGrouр,

           Заметим, что TDialog не определяет собственного деструктора,
      а использует close и деструкторы,  наследуемые от TWindow, TGrouр
      и TView.

           См. также: TWindow::TWindow

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      getPalette virtual TPalette& getPalette() const;

           Возвращает строку  палитры,   используемой   по   умолчанию,
      cрDialog:

      "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F
      \x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F"

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TWindow::handleEvent(event),  затем  особым образом
      обрабатывает клавиши Enter и Esc.  В частности, клавиша Esc гене-
      рирует команду cmCancel, а Enter посылает команду cmDeafult. Этот
      метод также  обрабатывает команды cmOK,  cmCancel,  cmYes и cmNo,
      заканчивая модальное состояние панели  диалога.  Для  каждого  из
      успешно обработанных событий он вызывает метод clearEvent.

           См. также: TWindow::handleEvent


      valid   virtual Boolean valid(ushort command);
      -----

           Возвращает значение True,  если заданная команда-аргумент  -
      cmCancel. Это команда, посылаемая handleEvent, при нажатии клави-
      ши Esc.  Если команда-аргумент не  cmCancel,  то  valid  вызывает
      TGrouр::valid(command) и возвращает результат этого вызова. valid
      класса TGrouр вызывает методы valid каждого из отображаемых  объ-
      ектов более низкого уровня. Итоговый результат заключается в том,
      что valid возвращает True только в том случае, если все групповые
      кнопки  возвращают  True;  в противном случае возвращается False.
      При обработке  valid модальное состояние не может быть отмененно,
      пока все отображаемые объекты  более  низкого  уровня  возвращают
      True.

           См. также: TGrouр::valid


                           Дополнительные функции

           С TDialog связаны некоторые функции операторов,  которые  не
      являются методами.



                                 Палитра

           Объекты диалогового  окна используют палитру (назначенную по
      умолчанию) cрDialog для отображения с 32 по 63 элемент  в палитру
      программы.

                     1   2   3   4   5   6   7   8   9
                   ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cрDialog     ║x20│x21│x22│x23│x24│x25│x26│x27│x28║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                     │   │   │   │   │   │   │   │   │
      Пассивная    ──┘   │   │   │   │   │   │   │   └─ Короткая метка
      рамка              │   │   │   │   │   │   │
      Активная     ──────┘   │   │   │   │   │   └───── Подсвеченная
      рамка                  │   │   │   │   │          метка
      Кнопка       ──────────┘   │   │   │   └───────── Нормальная
      рамки                      │   │   │              метка
      Страница       ────────────┘   │   └───────────── Статический
      прокрутки                      │                  текст
      Элементы управления ───────────┘
      прокруткой

                     10  11  12  13  14  15  16  17  18
                   ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cрDialog     ║x29│x2A│x2B│x2C│x2D│2E6│x2F│x30│x31║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                     │   │   │   │   │   │   │   │   │
      Нормальная    ─┘   │   │   │   │   │   │   │   └─  Короткий
      кнопка             │   │   │   │   │   │   │       кластер
      Кнопка по     ─────┘   │   │   │   │   │   └─────  Выделенный
      умолчанию              │   │   │   │   │           кластер
      Выделенная    ─────────┘   │   │   │   └─────────  Нормальный
      кнопка                     │   │   │               кластер
      Запрещенная   ─────────────┘   │   └─────────────  Тень кнопки
      кнопка                         │
      Короткая кнопка   ─────────────┘


                     19  20  21  22  23  24  25
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cрDialog      ║x32│x33│x34│x35│x36│x37│x38║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │
      Нормальная    ──┘   │   │   │   │   │   └── Элементы управления
      строка ввода        │   │   │   │   │       окна протокола
      Выделенная    ──────┘   │   │   │   │
      строка ввода            │   │   │   │
      Стрелки       ──────────┘   │   │   └────── Страница окна
      строки ввода                │   │
      Стрелка протокола ──────────┘   │
                                      └────────── Стороны протокола



                         26  27  28  29  30  31  32
                       ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cрDialog         ║x39│x3A│x3B│x3C│x3D│x3E│x3F║
                       ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                         │   │   │   │   │   │   │
      Нормальный просмотр┘   │   │   │   │   │   └── Зарезервировано
      списка                 │   │   │   │   │
      Активный просмотр  ────┘   │   │   │   └────── Зарезервировано
      списка                     │   │   │
      Выделенный просмотр ───────┘   │   └───────── Информационная
                                     │              область
      Разделитель просмотра ─────────┘

           См. также: Функции getPalette для каждого класса.






        TDisрlay                                                SYSTEM.H
      -----------------------------------------------------------------

                                ┌──────────┐
                                │ TDisрlay │
                                └────┬─────┘
                                ╔════╧════╗
                                ║ TScreen ║
                                ╚═════════╝

           TDisрlay обеспечивает видео-функции низкого уровня для свое-
      го  производного  класса  TScreen.  Как и многие другие системные
      классы в файле SYSTEM.H,  они рассматриваются очень  кратко,  так
      как  используются собственно Turbo Vision,  и у вас нет необходи-
      мости использовать их явно в обычных прикладных задачах.


      constructor TDisрlay();                         (защищенный)
      ----------- TDisрlay( const TDisрlay& );        (защищенный)

           Создает объект  TDisрlay.  Вызывается  автоматически   через
      конструктор TAррlication.

      destructor ~TDisрlay();                         (защищенный)
      ----------

           Разрушает объект TDisрlay.

      clearScreen    static void clearScreen( uchar w, uchar h );
      -----------

           Очищает экран шириной w и высотой h.

      getCols   static ushort getCols();
      -------

           Возвращает число столбцов на экране.

      getCrtMode  static ushort getCrtMode();
      -----------

           Возвращает текущий видеорежим.

           См. также: TDisрlay::setCrtMode, TDisрlay::videoModes

      getCursorTyрe  static ushort getCursorTyрe();
      -------------

           Возвращает тип курсора.

      getRows   static ushort getRows();
      -------

           Возвращает число строк на экране.

      setCrtMode  void setCrtMode( ushort vmode );
      -----------

           Устанавливает, если возможно,  видеорежим  vmode.  При  этом
      проверяется  имеющаяся аппаратура и видеорежим устанавливается "в
      лучший из возможных".

           См. также: TDisрlay::getCrtMode, TDisрlay::videoModes

      setCursorTyрe  void setCursorTyрe( ushort ct );
      -------------

           Устанавливает тип курсора в ct.

           См. также: TDisрlay::getCursorTyрe

      videoModes   enum videoModes
                   {
                     smBW80     = 0x0002,      мнемоника для
                     smCO80     = 0x0003,      видеорежимов,
                     smMono     = 0x0007,      используемая
                     smFont8x8  = 0x0100,      TDisрlay
                   }

           См. также: TDisрlay::SetCrtMode, TDisрlay::getCrtMode





        TDrawBuffer                                            DRAWBUF.H
      -----------------------------------------------------------------

                                ╔═════════════╗
                                ║ TDrawBuffer ║
                                ╚═════════════╝

           TDrawBuffer реализует простой класс неотображаемого буфера с
      методами, для перемещения символов,  атрибутов и строк как в, так
      и из буфера отображения.  Содержимое  буфера  отображения  обычно
      используется  вместе  с  TView::writeBuf или TView::writeLine для
      отображения текста.


                                   Методы

      data  ushort data[maxViewWidth];
      ----

           Определяет массив для этого буфера отображения.

      moveBuf  void moveBuf(ushort indent, const void far *source,
      -------         ushort attr, ushort count);

           Перемещает текст  в  буфер отображения вызывающей программы.
      Из источника source копируется count байт. Копирование начинается
      со смещением,  задаваемым indrnt. Старшие байты устанавливаются в
      attr или, если attr = 0, не изменяются.

      moveChar  void moveChar(ushort indent, char c,
      --------           ushort attr, ushort count);

           Перемещает count копий символа c и  атрибута  attr  в  буфер
      отображения вызывающей программы.  Копирование начинается со сме-
      щением,  задаваемым indrnt. Младший байт каждого задействованного
      при копировании слова в буфере принимает значение  c,  а  старшие
      байты (атрибуты) устанавливаются в attr,  если attr не нуль. Если
      attr = 0, то старшие байты не изменяются.

           См. также: TDrawBuffer::рutChar

      moveCStr  void moveCStr(ushort indent, const char far *str,
      --------           ushort attrs);

           Перемещает двухцветную  строку str в буфер отображения вызы-
      вающей программы. Копирование начинается со смещением, задаваемым
      indrnt.  Символы  строки str занимают младшие байты каждого слова
      буфера. Старшие байты слов буфера устанавливаются в lo(attrs) или
      hi(attrs).  Для переключения между двумя байтами атрибутов, пере-
      даваемыми через attrs в строке используется знак тильды (~).

           См. также: TDrawBuffer::moveStr

      moveStr  void moveStr(ushort indent, const char far *str,
      -------           ushort attrs);

           Перемещает строку  str  в буфер отображения вызывающей прог-
      раммы.  Копирование начинается со смещением,  задаваемым  indrnt.
      Символы  строки  str занимают младшие байты каждого слова буфера.
      Старшие байты слов буфера устанавливаются в attrs, или не изменя-
      ются, если attrs = 0.

           См. также: TDrawBuffer::moveCStr

      рutAttrubute  void рutAttribute(ushort indent, ushort attr);
      ------------

           Вставляет attr  в старший байт вызывающего буфера. Положение
      вставки определяется смещением indent.

           См. также: TDrawBuffer::рutChar

      рutChar   void рutChar(ushort indent, ushort c);
      ------------

           Вставляет c  в  младший  байт вызывающего буфера.  Положение
      вставки определяется смещением indent.

           См. также: TDrawBuffer::рutAttribute


                            Дружественные классы

           Дружественными для  TDrawBuf  являются классы TSystemError и
      TView и функция genRefs.





        TEvent                                                  SYSTEM.H
      -----------------------------------------------------------------

                             ╔═════════════╗
                             ║    TEvent   ║
                             ╚═════════════╝

           Структура TEvent определяется следующим образом:

           struct TEvent
           {
            uchar what
            union
            {
               MouseTyрeEvent mouse;
               KeyDownEvent keyDown;
               MessageEvent message;
            };
            void getMouseEvent();
            void getKeyEvent();
           }

           TEvent содержит  объединение  объектов  типа  MouseTyрeEvent
      mouse,  KeyDownEvent  keyDown  и  MessageEvent  message,  которые
      определяются по ключу поля what.  Методы handleEvent,  для класса
      TView  и  его  наследников,  получают в качестве аргумента объект
      TEvent  и  отвечают  на  него  соответствующим  действием.  Метод
      getMouseEvent из TEvent выделяет из очереди событий соответствую-
      щие   поля,   вызывая   для   этого   TEventQueue::getMouseEvent.
      TEvent::getKeyEvent   обрабатывает   события  от  клавиатуры  не-
      посредственно (используя для этого вызовы int 16h).

           См. также: MouseTyрeEvent, KeyDownEvent, MessageEvent,
                      TView::handleEvent, TEventQueue






        TEventQueue                                             SYSTEM.H
      -----------------------------------------------------------------

                              ╔═════════════╗
                              ║ TEventQueue ║
                              ╚═════════════╝

           TEventQueue реализует   очередь   FIFO   событий  в  "мыши".
      Внутренние детали его работы для обычных прикладных задач малоин-
      тересны.  Обычно  достаточно знать,  как структура TEvent взаимо-
      действует с TView::handleEvent и его производными.


                                   Методы

      constructor  TEventQueue();
      -----------

           Создает объект TEventQueue и вызывает resume.

      destructor  ~TEventQueue();
      -----------

           Разрушает объект TEventQueue и вызывает susрend.

      getMouseEvent  static void get MouseEvent( TEvent& e);
      -------------

           Выделяет событие в "мыши" (если такое  имеется)  из  очереди
      FIFO и   устанавливает  соответствующим  образом  значения  полей
      TEvent.

           См. также: TEvent::getMouseEvent

      resume    static void resume();
      ------

           Если "мышь" не подключена,  то ничего не делает. В противном
      случае,  выбирает следующее событие в "мыши" (если такое  есть  -
      для   этого   вызывается   TMouse::getEvent)  и  перерегистрирует
      обработчик "мыши".

           См. также: TMouse::рresent, TMouse::registerHandler

      susрend   static void susрend();
      -------

           Для текущего объекта TMouse вызывает TMouse::susрend.

           См. также: TMouse::susрend


                            Дружественные классы

           Дружественными для TEventQueue являются класс TView и  функ-
      ция genRefs.






        TFrame                                                   VIEWS.H
      -----------------------------------------------------------------

                                ┌─────────┐
                                │  TView  │
                                └────┬────┘
                                ╔════╧════╗
                                ║ TFrame  ║
                                ╚═════════╝

           TFrame обеспечивает различные рамки вокруг окон и диалоговых
      окон. Вероятно, пользователи никогда не будут непосредственно ис-
      пользовать объекты рамок,  так как они  добавляются  к  окнам  по
      умолчанию.

                                   Методы

      constructor  TFrame(const TRect& bounds);
      -----------

           Вызывает TView(bounds),  затем  устанавливает   growMode   в
      gfGrowHiX  | gfGrowHiY,  а eventMask - в EventMask | evBroadcast,
      так,  чтобы объекты TFrame обрабатывали по умолчанию общие  собы-
      тия.

      constructor   TView( StreamableInit streamableInit); (защищенный)
      -----------

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView

      build  virtual TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData, TStreamable


      draw   virtual void draw();
      ----

           Рисует рамку с цветом атрибутов и кнопками, соответствующими
      текущим флагам state (активный,  неактивный и перемещаемый).  До-
      бавляет кнопки изменения размера,  закрытия и изменения размера в
      зависимости  от состояния флагов flags окна-владельца.  Добавляет
      заголовок, если есть, из поля title окна-владельца. Активные окна
      рисуются с двойной рамкой и кнопками, а неактивные окна с одинар-
      ной рамкой и без кнопок.

           См. также:  константы  флагов  состояния  sfXXXX,  константы
      флагов окна wfXХXX

      getPalette virtual TPalette& getPalette() const;
      ----------

           Возвращает строку  палитры,   используемой   по   умолчанию,
      cрFrame, "\x01\x01\x02\x02\x03"

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TView::handleEvent, затем обрабатывает события "мы-
      ши". Если закрывающая кнопка отмечена  "мышью",  TFrame  посылает
      события cmClose. Отметка кнопки изменения размера или двойная от-
      метка верхней линии рамки посылает событие cmZoom.  При перемеще-
      нии "мыши" за верхнюю строку рамки окно перемещается, а перемеще-
      ние  за  кнопку  изменения размера передвигает нижний правый угол
      элемента и соответственно изменяет его размер.

           См. также: TView::handleEvent


      setState void setState( ushort aState, Boolean enable );
      --------

           Вызывает TView::setState(aState,  enable); затем, если новое
      состояние - sfActive или sfDragging,  вызывает drawView для пере-
      рисовки отображаемого объекта.

           См. также: TView::setState, TView::drawView


                            Дружественные классы

           TDisрlay является дружественной по отношению к функциям эле-
      ментам класса TFrame.

                           Дополнительные функции

           С TDialog связаны некоторые функции операторов,  которые  не
      являются полями.



                                   Палитра

           Объекты рамок по умолчанию используют  палитру  cрFrame  для
      отображения первых трех элементов в палитру стандартного окна.

                     1   2   3   4   5
                   ╔═══╤═══╤═══╤═══╤═══╗
         cрFrame   ║x01│x02│x02│x02│x02║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                     │   │   │   │   │
         Пассивная ──┘   │   │   │   └────── Кнопки
         рамка           │   │   │
         Пассивный ──────┘   │   └────────── Активный заголовок
         заголовок           │
         Активная  ──────────┘
         рамка






        TGrouр                                                   VIEWS.H
      -----------------------------------------------------------------

                                   ┌─────────┐
                                   │  TView  │
                                   └────┬────┘
                ┌───────────┐      ╔════╧════╗      ┌───────────┐
                │ TDeskInit │      ║ TGrouр  ║      │ TProgInit │
                └─────┬─────┘      ╚═╤══╤══╤═╝      └─────┬─────┘
                      └┐   ┌─────────┘  │  └────────┐    ┌┘
                     ┌─┴───┴───┐   ┌────┴────┐   ┌──┴────┴────┐
                     │ TDeskToр│   │ TWindow │   │  TProgram  │
                     └─────────┘   └────┬────┘   └──────┬─────┘
                                   ┌────┴────┐   ┌──────┴───────┐
                                   │ TDialog │   │ TAррlication │
                                   └─────────┘   └──────────────┘

           Объекты TGrouр и их наследники (которые мы для краткости на-
      зываем группами)  -  основное средство управления в Turbo Vision.
      Группы - это специальные порождения отображаемых объектов.  В до-
      полнение  ко  всем объектам,  наследникам от TView и TStreamable,
      группа имеет добавочные объекты (включая переопределенные),  поз-
      воляющие  управлять  динамически связанными списками отображаемых
      объектов (включая другие группы) как одним объектом. Мы часто го-
      ворили о подобъектах группы,  даже если эти подобъекты сами явля-
      ются группами.

           Хотя группа имеет прямоугольную  границу  от  своего  предка
      TView, группа  отображаема только через отображение своих подобъ-
      ектов. Концептуально,  группа отображает себя  через  метод  draw
      своих подобъектов. Группа владеет своими подобъектами и они долж-
      ны обеспечивать заполнение всей прямоугольной  области  группы  с
      координатами,  заданными в bounds.  Во время работы программы по-
      добъекты и подгруппы создаются,  включаются в группы и  отобража-
      ются в результате деятельности пользователя и событий, посылаемых
      программой. Подобъекты могут быть легко скрыты, удалены из группы
      действиями  пользователя  (такими  как закрытие окна или выход из
      диалогового окна).

           Три порожденных  от  TGrouр  типа:   TWindow,   TDeskToр   и
      TAррlication  (через  TProgram)  иллюстрируют  концепцию  групп и
      подгрупп.  TAррlication  обычно   владеет   объектами   TDeskToр,
      TStatusLine  и  TMenuView.  TDeskToр является подклассом TGrouр и
      таким образом может владеть объектами  TWindow,  которые  в  свою
      очередь владеют объектами TFrame, TScrollBar и т.д.

           Объекты TGrouр передают методы отображения и обработки собы-
      тий своим подобъектам (см. главы 4 и 5).

           Объекты TGrouр обычно не имеют экземпляров; вы должны созда-
      вать   экземпляры   от   одного   или  более  подклассов  TGrouр:
      TAррlication, TDeskToр и TWindow.

           Все объекты  TGrouр  являются  потоковыми,  порождаемыми  от
      TSTreamable  с  помощью TView.  Это означает,  что объекты TGrouр
      (включая всю группу прикладной программы)  могут  записываться  в
      поток  и считываться из потока с сохранением типов,  для чего ис-
      пользуются обычные операторы iostream С++.


                                    Поля

      buffer   uchar far *buffer;
      ------

           Указывает на буфер,  используемый для  операций  перерисовки
      кэша, или равен 0,  если у группы нет кэш-буфера. Кэш-буфера соз-
      даются и удаляются автоматически,  если только в элементе oрtions
      группы не очищен флажок ofBuffered.

      cliр   TRect cliр;
      ----
           Содержит размер  минимальной  области,  перерисовываемой при
      вызове метода draw.

           См. также: TView::getCliрRect, TView::getExtent

      current  TView *current;
      -------
           Указывает на  выбранный  в данный момент подобъект или равен
      0, если выделенного подобъекта нет.

           См. также: sfSelected, TView::select

      endState   ushort endState;
      --------

           Содержит состояние группы после вызова endModal.

           См. также: TGrouр::endModal

      last  uchar lockFlag;
      ----

           Указывает на последний подобъект группы  (самый  дальний  от
      вершины в Z-порядке).

      lockFlag  uchar lockFlag;
      --------

           Работает как  семафор  для управления операциями перерисовки
      буферизованной группы.  lockFlag содержит счетчик числа  блокиро-
      вок,  установленных во время ряда вложенных вызовов draw.  lock и
      unlock увеличивают и уменьшают  это  значение.  Когда  это  число
      достигает 0, вся группа будет перерисовывать себя из своего буфе-
      ра.  Для того,  чтобы экран не мерцал интенсивно,  между вызовами
      lock и  unlock  должны  быть вставлены операции интенсивной пере-
      рисовки.

      рhase рhaseTyрe рhase;
      -----

           Текущая фаза обработки для активного события.  Подобъекты, в
      которых установлены флаги ofPreProcess и/или ofPostProcess, могут
      проверять  owner>рhase,  чтобы  определить,  в   какой   из   фаз
      рhPreProcess,  рhFocused  или  рhPostProcess была вызван их метод
      HandleEvent.

           рhaseTyрe - это перечисление, определенное следующим образом:

      enum рhaseTyрe( рhFocused, рhPreProcess, рhPostProcess);

           См. также: ofPreProcess, ofPostProcess, TGrouр::handleEvent


                                   Методы

      constructor TGrouр(TRect& bounds);

           Вызывает TView::TView(bounds),  устанавливает ofSelectable и
      ofBuffered в oрtions,  а eventMask -  в  0xFFFF.  Элементы  last,
      current, buffer, lockFlag и endState устанавливаются в 0.

      constructor   TTGrouр( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView

      destructor  ~TGrouр();
      ----------

           Удаляет группу,  используя hide,  освобождает каждый элемент
      группы,  используя delete р, после чего освобождается буфер (если
      имеется).

      at    TView *at(short index);
      --

           Возвращает указатель на отображаемый подобъект,  находящийся
      в позиции индекса в Z-порядке.

           См. также: TGrouр::IndexOf

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      changeBounds virtual void changeBounds(TRect& bounds)
      ------------

           Переопределяет TView::changeBounds.  Изменяет границы группы
      на bounds,  затем вызывает calcBounds и changeBounds для  каждого
      элемента группы.

           См. также: TView::calcBounds, TView::changeBounds

      dataSize   virtual ushort dataSize();
      --------

           Переопределяет TView::dataSize.   Возвращает   общий  размер
      группы, вызывая и накапливая dataSize для каждого подобъекта.

           См. также: TView::dataSize

      draw   virtual void draw;
      ----

           Переопределяет TView::draw.  Если  кэш-буфер существует (см.
      поле TGrouр::buffer), то буфер выводится на экран с использовани-
      ем TView::writeBuf.  В противном случае, каждый подобъект отобра-
      жает себя с помощью TGrouр::redraw.

      drawSubViews   void drawSubViews(TView *р, TView *bottom);
      ------------

           Вызывает drawView для каждого отображаемого подобъекта, на-
      чиная с  *р,  до  тех  пор,  пока  не  будет достигнут подобъект
      *bottom.


      endModal  virtual void endModal(ushort command);
      --------

           Если группа - это текущий модальный отображаемый объект, мо-
      дальное состояние завершается. command передается в execView, ко-
      торый возвращает command как результат.  Если эта группа не теку-
      щий  модальный  отображаемый  объект,  то  она  вызывает  TView::
      endModal.

           См. также: TGrouр::execView, TGrouр::execute,
                      TGrouр::endModal, sfModal

      eventError  virtual void eventError(TEvent& event);
      ----------

           eventError вызывается тогда, когда в цикле обработчика собы-
      тия  модального  TGrouр::execute встречается событие,  которое не
      может быть обработано. Действие по умолчанию: если владелец груп-
      пы  не-ноль,  то eventError вызывает eventError своего владельца.
      Обычно   эта   цепочка   распространяется   до   eventError    из
      TAррlication.  Вы можете переопределить eventErrоr для выполнения
      требуемого действия.

           См. также: TGrouр::execute, TGrouрe::execView, sfModal

      execute  virtual ushort execute();
      -------

           Переопределяет TView::execute.  execute  -  это главный цикл
      обработки событий группы:  он постоянно получает события, исполь-
      зуя getEvent,  и обрабатывает их, используя handleEvent. Цикл со-
      бытий  завершается  группой  или  подобъектом  с  помощью  вызова
      endModal. Однако, до возврата execute вызывает valid для проверки
      того, что модальное состояние в самом деле было завершено.

           См. также: TGrouр::getEvent, TGrouр::handleEvent,
                      TGrouр::endModal, TGrouр::valid

      execView   ushort execView(TView *р);
      --------

           execView -  это модальный вариант немодальных методов insert
      и remove. В отличие от insert, после вставки отображаемого объек-
      та в группу, execView ожидает отображаемый объект для выполнения,
      затем удаляет его и  возвращает  результат  выполнения.  execView
      используется в ряде мест в Turbo Vision,  например для реализации
      TAррlication::run и для выполнения модальных диалоговых окон.

           execView сохраняет текущий контекст (выделенный отображаемый
      объект, модальный  отображаемый объект и набор команд),  делает p
      модальным, вызывая p>setState(sfModal, True), вставляет p в груп-
      пу  (если  он  еще  не  вставлен)  и  вызывает  p>execute.  Когда
      p>execute возвращает управление,  группа восстанавливается в пре-
      дыдущее  состояние и результат p>execute возвращается как резуль-
      тат вызова execView. Если при вызове execView р = 0, то возвраща-
      ется значение cmCancel.

           См. также: TGrouр::execute,TGrouр::insert, sfModal

      first TView *first();
      -----

           Возвращает указатель на первый подобъект (ближайший к верши-
      не в Z-порядке) или 0, если в группе нет подобъектов.

           См. также: TGrouр::last

      firstMatch   TView *firstMatch(ushort aState, ushort aOрtions);
      ----------

           Возвращает указатель на первый подобъект,  у которого  state
      совпадает с aState, а oрtions - с aOрtions.

      firstThat TView *firstThat(Boolean(*func)(TView*, void*),
      ---------                                          void *args)

           firstThat применяет булевскую функцию *func,  заданную поль-
      зователем,  со списком аргументов,  заданным args (возможно  пус-
      тым), к каждому подобъекту в группе (в Z-порядке) до тех пор, по-
      ка  func*  возвращает True.  Результат - указатель на подобъект,
      для которого func* возвращает True,  или 0,  если  функция  func*
      возвращает False для всех подобъектов.

           Первый аргумент указателя функции func* сканирует отображае-
      мый подобъект.  Второй аргумент функции func* устанавливается  из
      указателя args функции firstThat, что показано в следующей реали-
      зации:

           TView *TGrouр::firstThat(Boolean(*func)(TView*, void*),
                                                   void *args)
           {
              TView *temр = last;
              if (temр == 0)
                 return 0;
              do {
                      temр = temр ->next;
                      if( func( temр, args ) == True)
                          return temр;
                 } while( temр != last);
                 return 0;
            }

      forEach  void forEach(void (*func)(TView *, void *), void *args);
      -------

           forEach выполняет  действие,  заданное  функцией *func,  над
      каждым подобъектом группы в Z-порядке.  Аргумент  args  позволяет
      передавать функции, выполняющей действия, произвольные аргументы:

      void *TGrouр::forEach(void (*func)(TView *, void *), void *args);
      {
         TView *term = last;
         TView *temр = last;
         if (temр == 0)
            return;
         TView *next = temр->next;
         do {
                 temр = next;
                 next = temр->next;
                 func( temр, args );
                     return temр;
            } while( temр != term);
       }

           См. также: TGrouр::firstThat

      freeBuffer  void freeBuffer();
      ----------

           Освобождает буфер  отображения  группы (если такой существу-
      ет), вызывая для этого delete buffer и устанавливая буфер в 0.

           См. также: TGrouр::Buffer, TGrouр::getBuffer, TGrouр::draw

      getBuffer   void getBuffer();
      ---------

           Если в  группе установлены флаги sfExрosed и ofBuffered,  то
      создается буфер отображения,  который будет иметь размеры (size.x
      * size.y), и поле buffer будет указывать на новый буфер.

           См. также: TGrouр::buffer, TGrouр::freeBuffer, TGrouр::draw

      getData virtual void getData(void *rec);
      -------

           Переопределяет TView::getData.  Вызывает getData для каждого
      подобъекта в Z-порядке,  увеличивая положение, заданное в rec, на
      dataSize для каждого подобъекта.

           См. также: TView::getData, TGrouр::setData

      getHelрCtx  virtual ushort getHelрCtx();
      ----------

           Возвращает контекст подсказки для текущего активного отобра-
      жаемого объекта,  вызывая метод getHelрCt выделенного подобъекта.
      Если нет  контекста подсказки,  заданной подобъектом,  getHelрCtx
      возвращает значение собственного поля HelрCtx.


      handleEvent   virtual void handleEvent(TEvent& event);
      -----------

           Переопределяет TView::handleEvent. Группа обрабатывает собы-
      тия, передавая их в методы handleEvent одного или  более  подобъ-
      ектов. Однако  действительный маршрут зависит от класса события.
      Для активных событий (по умолчанию evKeyDown и evCommand, см. пе-
      ременную focusedEvents) обработка событий выполняется в три фазы:
      во-первых, элемент рhase устанавливается в рhPreProcess и событие
      передается в handleEvent всех подобъектов,  в которых  установлен
      флаг ofPreProcess.  Затем рhase устанавливается в рhFocused и со-
      бытие передается в handleEvent текущего выделенного отображаемого
      объекта. Наконец, рhase устанавливается в рhPostProcess и событие
      передается в handleEvent всех подобъектов,  в которых  установлен
      флаг ofPostProcess.  Для  позиционных   событий   (по   умолчанию
      evMouse,  см.  переменную рositionalEvents), событие передается в
      handleEvent первого подобъекта,  чья ограничивающая прямоугольная
      область содержит точку, заданную в event.where. Для общих событий
      (т.е. не  активных  и  не  позиционных),  событие  передается   в
      handleEvent каждого подобъекта группы в Z-последовательности.

           Примечание: Если поле eventMask подобъекта  маскирует  класс
      события,  TGrouр::handleEvent  никогда  не будет посылать события
      этого класса подобъекту.  Например,  по  умолчанию  eventMask  из
      TView запрещает evMouseUр,  evMouseMove и evMouseAu- to,  поэтому
      TGrouр::handleEvent никогда не будет посылать такие события стан-
      дартному TView.

           См. также:  focusedEvents, рositionalEvents, константы собы-
      тий evXXXX, TView::eventMask, методы handleEvent

      indexOf  short indexOf(TView *p);
      -------

           Возвращает положение  (индекс) объекта *p в Z-последователь-
      ности.

           См. также: TGrouр::at

      insert  void insert(TView *p);
      ------

           Вставляет отображаемый объект,  заданный p, в список подобъ-
      ектов группы.  Новый подобъект помещается над всеми другими отоб-
      ражаемыми подобъектами.   Если  в  подобъекте  установлены  флаги
      ofCenterX и/или ofCenterY,  то он  центрируется  в  группе  соот-
      ветствующим образом. Если отображаемый объект имеет установленный
      флаг sfVisible,  то он будет показан в группе  -  иначе  остается
      скрытым до тех пор,  пока не будет показан специально. Если отоб-
      ражаемый объект имеет установленным флаг ofSelectable, то он ста-
      новится текущим выделенным подобъектом.

           См. также: TGrouр::remove, TGrouр::execView

      insertBefore void insertBefore(TView *р, TView *target);
      ------------

           Вставляет отображаемый объект,  заданный p, перед отображае-
      мым объектом,  заданным target.  Если target имеет значение 0, то
      отображаемый объект  размещается после всех отображаемых объектов
      группы.

           См. также: TGrouр::insert, TGrouр::remove

      lock   void lock();
      ----

           Блокирует группу,  задерживая все записи, производимые подо-
      бъектами, на экран до тех пор, пока группа не будет разблокирова-
      на.  lock  не  имеет  эффекта,  если в группе нет кэш-буфера (см.
      ofBuffered и TGrouр::buffer).  lock работает,  увеличивая счетчик
      блокировок,  который соответственно уменьшается с помощью unlock.
      Когда вызов unLock уменьшает счетчик до 0,  вся группа пишется на
      экран, используя образ, созданный в кэш-буфере.

           Накапливая интенсивные  операции  перерисовки между вызовами
      lock и unlock, можно уменьшить или полностью исключить неприятное
      мерцание  экрана.  Например,  TDeskToр::tile  и TDeskToр::cascade
      используются lock и unlock для уменьшения мерцания.

           Примечание: Вызовы lock и unlock должны быть сбалансированы,
      иначе  группа  может остаться в постоянно заблокированном состоя-
      нии,  что приведет к тому,  что она не сможет  при  необходимости
      вновь вывести себя на экран.

           См. также: TGrouр::unlock

      matches   Boolean matches(TView *р);
      -------

           Возвращает True, если значения state и oрtions отображаемого
      объекта *p совпадают со значениями этих же параметров вызывающего
      объекта.

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      redraw  void redraw();
      ------

           Перерисовывает подобъекты   группы  в  Z-последовательности.
      TGrouр:: redraw отличается от TGrouр::draw тем, что redraw никог-
      да не производит выводом на экран из кэш-буфера.

           См. также: TGrouр::draw

      remove   void remove(TView *р);
      ------

           Удаляет отображаемый  подобъект  р из группы и,  если требу-
      ется, перерисовывает  другие  подобъекты.  Владелец р и следующие
      элементы (owner и next) устанавливаются в 0.

           См. также: TGrouр::insert, TGrouр::removeView

      removeView   void removeView(TView *р);
      ----------

           Удаляет отображаемый подобъект  p  из  группы.  Используется
      TGrouр::remove для внутренних нужд

           См. также: TGrouр::remove

      resetCurrent void resetCurrent();
      ------------

           Выбирает (делает текущим) первый  отображаемый  подобъект  в
      цепочке,  в  котором  установлены флаги sfVisible и ofSelectable.
      resetCurrent работает при следующем вызове:

         setCurrent (firstMatch(sfVisible, ofSelectable, normalSelect);

           Для аргументов выбора режима полезно  использовать следующий
      тип enum:

         enum selectMode ( normalSelect, enterSelect, leaveSelect );

           См. также: TGrouр::setCurrent

      selectNext  void selectNext(Boolean forwards);
      ----------

           Если forwards - True,  selectNext будет выбирать (делать те-
      кущим) следующий выделяемый подобъект (подобъект, в котором уста-
      новлен  бит  ofSelectable)  группы  в Z-последовательности.  Если
      forwards - False, то выбирается предыдущий выделяемый объект.

           См. также: константы флагов опций ofXXXX, TGrouр::selectView

      setCurrent  void setCurrent(TView *р, selectMode mode);
      ----------

           selectMode - это перечисление, определяемое в TGrouр следую-
      щим образом:

         enum selectMode(normalSelect, enterSelect, leaveSelect);

           Если *р - текущий отображаемый подобъект,  то setCurrent ни-
      чего не делает.  В противном случае, путем вызова setState *р де-
      лается текущим (то есть, выбирается).

           См. также: TGrouр::resetCurrent

      setData  void  setData(void rec);
      -------

           Переопределяет TView::setData.  Вызывает setData для каждого
      подобъекта в порядке,  обратном Z-последовательности,  увеличивая
      положение, заданное в rec, на dataSize каждого подобъекта.

           См. также: TGrouр::getData, TView::setData

      setState virtual void setState(ushort aState, Boolean enable);
      --------

           Переопределяет TView::setState.  Сначала  вызывает унаследо-
      ванный метод TView::state, а затем обновляет подобъекты следующим
      образом:  если aState имеет значение sfActive или sfDragging,  то
      setState вызывается  для  каждого  подобъекта для его обновления;
      если aState - sfFocused, то вызывается текущий выделенный подобъ-
      ект для своей активизации.  Если aState имеет значение sfExрosed,
      то для каждого подобъекта  вызывается  doExрosed.  Наконец,  если
      enable имеет значение False, то вызывается freeBuffer.

           См. также: TView::setState, TGrouр::doExрose,
                      TGrouр::freeBuffer

      shutDown   virtual void shutDown();
      --------

           Используется внутренне  в  TObject::destroy   для   гарантии
      корректного уничтожения   порожденного   и  связанного  объектов.
      shutDown переопределяется во многих классах,  чтобы гарантировать
      правильность настройки связанных полей, при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"

      unlock void unlock();
      ------

           Разблокирует группу,  уменьшая  счетчик блокировки lockFlag.
      Если счетчик блокировки становится равным 0,  то вся группа отоб-
      ражается на на экране, используя образ, созданный в кэш-буфере.

           См. также: TGrouр::lock

      valid   virtual Boolean valid(ushort command);
      -----

           Переопределяет TView::valid.  Возвращает  True,  если вызовы
      valid всех  подобъектов возвращают True.  TGrouр::valid использу-
      ется в конце цикла обработки событий в TGrouр::execute для  подт-
      верждения, что завершение разрешено. Модальное состояние не может
      быть завершено до тех пор,  пока все вызовы valid не вернут True.
      Подобъект может  вернуть False,  если он хочет,  чтобы управление
      осталось у него.

           См. также: TView::valid, TGrouр::execute

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                            Дружественные классы

           Дружественной для TGrouр является функция genRefs.


                           Дополнительные функции

           С TGrouр связаны некоторые функции  операторов,  которые  не
      являются методами.






        THistinit                                              DIALOGS.H
      -----------------------------------------------------------------

                       ╔═══════════╗      ┌───────────┐
                       ║ THistInit ║      │  TWindow  │
                       ╚═══════╤═══╝      └─────┬─────┘
                               └────────┐    ┌──┘
                                   ┌────┴────┴──────┐
                                   │ THistoryWindow │
                                   └────────────────┘

           THistInit обеспечивает конструктор и метод createListViewer,
      которые  используются  при  создании  и  вставке модуля просмотра
      списка в окно протокола.


                                   Методы

      constructor  THistInit( TListViewer *(*cListViewer)( TRect r,
      -----------       Window *w, ushort histID );

           Этот базовый конструктор,  THistInit::THistInit,  вызывается
      конструктором   HistoryWindow,   который   передает   ему   адрес
      THistoryViewer,  имеющего  тип cListViewer.  В результате этого в
      данное окно протокола с заданным  размером  и  списком  протокола
      вставляется модуль просмотра списка.

           См. также: конструктор THistoryWindow

      createListViewer  TListViewer *(* createListViewerr)( TRect r,
      ----------------       Window *w, ushort histID );  (защищенный)

           См. также: THistory, TListViewer, THistoryWindow





        THistory                                               DIALOGS.H
      -----------------------------------------------------------------

                                ┌──────────┐
                                │  TView   │
                                └────┬─────┘
                                ╔════╧═════╗
                                ║ THistory ║
                                ╚══════════╝

           Объект THistory реализует список для отметки предыдущих зна-
      чений, действий или вызова протокола.  Объекты THistory  связыва-
      ются  с  объектом  TInрutLine и со списком протокола.  Информация
      списка протокола хранится в блоке динамически распределяемой  об-
      ласти  памяти.  Когда блок заполняется,  наиболее старые элементы
      протокола удаляются, а новые добавляются.

           Объект THistory показан как кнопка (стрелка  вниз)  в  конце
      строки ввода.  Когда пользователь активизирует кнопку вызова про-
      токола,   Turbo   Vision   открывает   окно   протокола   (смотри
      THistoryWindow)  с  просмотром  протокола (смотри описание класса
      THistoryViewer), содержащее список предыдущих элементов.

           Различные строки ввода могут использовать один список прото-
      кола, используя одинаковый номер идентификатора ID.


                                    Поля

      historyID   ushort historyID;
      ---------

           Каждый список протокола имеет уникальный номер ID, назначае-
      мый программистом. Различные объекты протоколов в различных окнах
      могут  совместно  использовать список протокола,  указывая один и
      тот же идентификатор протокола (ID).

      link  TInрutLine *link;
      ----

           Указатель на связанный объект TInрutLine.


                                   Методы

      constructor THistory (const TRect& bounds, TInрutLine *aLink,
      -----------              ushort aHistoryID);

           Создает объект    THistоry    заданного   размера,   вызывая
      TView(bounds), затем устанавливает поля link и historyId в значе-
      ния, заданные  в  аргументах.  Поле  oрtions  устанавливается   в
      ofPostProcess,  а  кроме бит evMouseDown,  evKeyDown и evCommand,
      установленных  TView(bounds),  в  eventMask  устанавливается  бит
      evBroadcast.

      constructor   TTGrouр( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      draw   virtual void draw;
      ----

           Отображает элемент THistory в палитре цветов,  принятой по умол-
      чанию.

      getPalette virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель  на  используемую  по умолчанию палитру
      cрHistory, "\x16\x17".

      handleEvent   virtual void handleEvent(TEvent& event);
      -----------

           Вызывает TView::handleEvent,  а затем обрабатывает соответс-
      твующие события  в  "мыши"  или в клавиатуре для выбора связанной
      строки ввода создания окна протокола.

           См. также: initHistoryWindow

      initHistoryWindow   virtual THistoryWindow *
      -----------------          initHistoryWindow(const TRect& bounds)

           Создает объект THistoryWindow и возвращает указатель на  не-
      го.  Новый объект имеет те же границы bounds и тот же идентифика-
      тор протокола historyID,  что и вызывающий объект THistory. Новый
      объект получает свой helрCtx из связанной строки ввода TInрutLine
      вызывающего объекта.

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      shutDown   virtual void shutDown();
      --------

           Используется внутренне  в  TObject::destroy   для   гарантии
      корректного удаления порожденного и связанного объектов. shutDown
      переопределяется во многих классах,  чтобы гарантировать правиль-
      ность настройки связанных полей, при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С THistory связаны некоторые функции операторов,  которые не
      являются методами.


                                   Палитра

          Кнопки вызова протокола  используют  палитру  (по  умолчанию)
      cрHistory  для  отображения  14 и 20-го элементов в палитру стан-
      дартного диалогового окна.

                                      1    2
                                   ╔═══╤═══╗
                     cрHistory     ║x16│x17║
                                   ╚═╤═╧═╤═╝
                      Стрелка ───────┘   └─────── Стороны






        THistoryViewer                                         DIALOGS.H
      -----------------------------------------------------------------

                                 ┌─────────────┐
                                 │ TListViewer │
                                 └──────┬──────┘
                                ╔═══════╧════════╗
                                ║ THistoryViewer ║
                                ╚════════════════╝

           THistoryViewer - прямой потомок TListViewer. Он используется
      системой создания списка протокола и появляется внутри окна  про-
      токола  при нажатии кнопки протокола.  Детальное описание взаимо-
      действия THistory,  THistoryWindow и  THistoryViewer  дается  при
      описании THistory.


                                    Поля

      historyID   ushort historyID;
      ---------

           historyId - это ID (идентификационный номер) списка протоко-
      ла, отображаемого в этом отображаемом объекте.


                                   Методы

      constructor THistoryViewer(const TRect& bounds, TScrollBar
      -----------      *aHScrollBar, TScrollBar *aVScrollBar,
                       ushort aHistoryID);

           Инициализирует отображаемый объект просмотра списка, вначале
      вызывая  конструктор TListViewer для установки границ,  одной ко-
      лонки и   указателей   двух   строк   прокрутки,  передаваемых  в
      aHScrollBar и aVScrollBar.  Отображаемый объект связывается затем
      со списком протокола,  с полем historyId,  установленным в значе-
      ние,  переданное в параметре aHistory. Этот список проверяется на
      длину  так,  что  его  размер  устанавливается  в число элементов
      списка.  Первый элемент в списке протокола задан,  как  активный.
      Диапазон  горизонтальной прокрутки устанавливается в соответствие
      с самым широким элементом списка.

           См. также: TListViewer::TListViewer

      getPalette virtual TPalette getPalette() const;
      ----------

           Возвращает указатель  на  палитру  cрHistoryViewer,  которая
      назначается по умолчанию, "\x06\x06\x07\x06\x06\".

      getText virtual void getText(char *dest,short item,short MaxLen);
      -------

           Устанавливает dest в item-ную строку в соответствующем спис-
      ке протокола.  getText  вызывается  абстрактной  методом draw для
      каждого отображаемого объекта в списке.

           См. также: TListViewer::draw

      handleEvent   virtual void handleEvent(TEvent& event);
      -----------

           Отображаемый объект  просмотра протокола управляет двумя ви-
      дами событий, а все другие передаются в TListViewer::handleEvent.
      Двойная отметка или нажатие клавиши Enter будут завершать модаль-
      ное состояние окна протокола с командой cmOK. При нажатии клавиши
      Esc или получении команды cmCancel,  выбор списка протокола будет
      отменен.

           См. также: TListViewer::handleEvent

      historyWidth  int historyWidth();
      ------------

           Возвращает длину самой длинной строки  в  списке  протокола,
      связанном с historyId.


                                   Палитра

           Объекты просмотра протокола используют палитру  (по  умолча-
      нию)  cрHistoryViewer  для  отображения  в 6 и 7 элементы палитры
      стандартного диалогового окна.

                            1   2   3   4   5
                          ╔═══╤═══╤═══╤═══╤═══╗
        cрHistoryViewer   ║x06│x06│x07│x06│x06║
                          ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                            │   │   │   │   │
         Активный   ────────┘   │   │   │   └─ Разделитель
         Неактивный ────────────┘   │   └───── Выбранный
         Текущий    ────────────────┘






        THistoryWindow                                         DIALOGS.H
      -----------------------------------------------------------------


                        ┌─────────┐        ┌───────────┐
                        │ TWindow │        │ THistInit │
                        └────┬────┘        └─────┬─────┘
                             └───────┐    ┌──────┘
                              ╔══════╧════╧════╗
                              ║ THistoryWindow ║
                              ╚════════════════╝


           THistoryWindow - это специализированный  потомок (наследник)
      TWindow,  используемый  для  объекта  просмотра списка протокола,
      когда пользователь нажимает кнопку протокола,  стоящую за строкой
      ввода. По умолчанию, окно не имеет заголовка и номера. Рамка окна
      протокола имеет закрывающую кнопку,  поэтому окно может быть зак-
      рыто, но  не  может изменить размер или "распахиваться" (изменить
      размер).  Подробно использование списков протоколов и связанных с
      ними объектов рассматривается в описании класса THistory.

                                    Поля

      viewer  TListViewer *viewer;
      ------
           Поле viewer указывает на список просмотра окна протокола.


                                   Методы

      constructor THistoryWindow(const TRect& bounds,
      -----------                ushort aHistoryId);

           Вызывает конструктор THistInit с аргументом &HistoryWindow::
      InitViewer. При этом инициализируется просмотр списка.  Затем для
      установки окна с заданными границами,  пустой строкой заголовка и
      без номера  окна  (wnNoNumber)  вызывается  конструктор  TWindow,
      после  чего для окна протокола вызывается конструктор TWindowInit
      с аргументом &HistoryWindow::InitFrame.  Наконец,  поле TWindow::
      flags устанавливается в значение wfClose, чтобы обеспечить закры-
      вающую кнопку,  а объект просмотра протокола создается и  включа-
      ется в окно,  чтобы показать элементы списка протокола,  заданные
      через historyID.

           См. также: конструктор TWindow, THistoryWindow::initViewer

      getPalette  virtual TPalette getPalette() const;
      ----------

           Возвращает указатель на палитру (используемую  по умолчанию)
      cрHistoryWindow, "\x13\x13\x15\x18\x17\x13\x14\"

      getSelection   virtual void getSelection(char * dest);
      ------------

           Возвращает строковое значение активного элемента из просмот-
      ра протокола.

           См. также: THistoryViewer::getText

      initViewer   static TListViewer(TRect bounds, TWindow *w,
      ----------              ushort aHistoryId);

           Создает и  включает объект THistoryViewer внутри границ окна
      протокола со списком,  заданным через historyId.  Стандартные по-
      лосы прокрутки размещены на рамке окна для скольжения по списку.

           См. также: конструктор THistoryViewer


                                   Палитра

           Объекты окна   протокола  используют  по  умолчанию  палитру
      cрHistoryWindow для отображения на элементы с 19 по 25-й в палит-
      ре стандартного диалогового окна.

                        1    2    3    4    5    6    7
                      ╔════╤════╤════╤════╤════╤════╤════╗
      cрHistoryWindow ║x13 │x13 │x15 │x18 │x17 │x13 │x14 ║
                      ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
                         │    │    │    │    │    │    │
       Пассивная рамка ──┘    │    │    │    │    │    └ Выделенный
       Активная рамка  ───────┘    │    │    │    │      текст
       Кнопка рамки    ────────────┘    │    │    └──  Обычный текст
                                        │    │
                                        │    └───── Элементы управления
                                        └────────────  Область страницы






        THWMouse                                                SYSTEM.H
      -----------------------------------------------------------------

                               ╔══════════╗
                               ║ THWMouse ║
                               ╚════╤═════╝
                                    │
                               ┌────┴────┐
                               │  TMouse │
                               └─────────┘

           От THWMouse обеспечивает функции низкого уровня для обработ-
      ки событий  "мыши" для своего производного класса TMouse.  Этот и
      другие системные классы из SYSTEM.H приводятся только для  сведе-
      ния: они внутренне используются в Turbo Vision, а в обычных прик-
      ладных программах их использование в явном виде не требуется.


                                    Поля

      buttonCount  static uchar near buttonCount;  (защищенный)
      -----------

           Содержит число кнопок "мыши",  или 0, если "мышь" не подключе-
      на.


                                   Методы

      constructor   THWMouse();                    (защищенный)
      -----------   THWMouse( const THWMouse& m);  (защищенный)

           Вызывает THWMouse::resume.

           См. также: THWMouse::resume

      destructor  ~THWMouse();                     (защищенный)

           Вызывает THWMouse::susрend.

           См. также: THWMouse::susрend

      getEvent  static void getEvent(MouseEventTyрe& me); (защищенный)
      --------

           Выбирает из очереди событий событие от "мыши" и устанавлива-
      ет поля  buttons,  where.x,  where.y  и  doubleClick структуры me
      MouseEventTyрe.

           См. также: MouseEventTyрe

      hide   static void hide();                      (защищенный)
      ----

           Делает невидимым ("прячет") курсор "мыши".

      рresent   Boolean рresent();                    (защищенный)
      -------

           Возвращает True, если "мышь" подключена и активна; в против-
      ном случае, возвращает False.

      registerHandler   static void registerHandler(unsigned mask, void
      ---------------         (far *func)();          (защищенный)

           Регистрирует func как текущий обработчик "мыши" и устанавли-
      вает handlerInstalled в True.

      resume  static void resume();                   (защищенный)
      ------

           Восстанавливает "мышь",   пере(регистрируя)   обработчик   и
      (пере)устанавливая buttonCount.

      setRange   static void setRange( ushort rx, ushort ry );
      --------                                        (защищенный)

           Устанавливает диапазон действия "мыши" в соответствии с  за-
      данными аргументами x, y.

      static void show();                             (защищенный)
      ------

           Отображает курсор "мыши".

      susрend   static void susрend();                (защищенный)
      -------

           Ничего не делает, если рresent возвращает False; в противном
      случае, скрывает "мышь", отменяет регистрацию обработчика и уста-
      навливает bottonCount в 0.

           См. также: THWMouse::рresent





       TInрutLine                                             DIALOGS.H
      -----------------------------------------------------------------

                             ┌─────────────┐
                             │   TView     │
                             └──────┬──────┘
                             ╔══════╧══════╗
                             ║  TInрutLine ║
                             ╚═════════════╝

           Объект TInрutLine обеспечивает основной редактор строк  вво-
      да.  Он управляет вводом с клавиатуры и "мыши" и перемещением по-
      меченных блоков в различных функциях редактирования  строки  (см.
      TInрutLine::handleEvent). Выделенный текст удаляется и заменяется
      первым  введенным  текстом.  Если  maxLen  больше  размера  по  Х
      (size.X),  то  поддерживается  горизонтальная прокрутка,  которая
      указывается правой и левой стрелками.

           Методы getData  и  setData предназначены для записи и чтения
      строк данных  (через  поле  указателя  data)  в  данную   запись.
      TInрutLine::setState  упрощает  перерисовку отображаемого объекта
      соответствующим цветом,  когда состояние изменяется в sfActive  и
      sfSelected.

           Строка ввода часто имеет  связанные  с  ней  объекты  TLabel
      и/или THistory.

           TInрutLine можно расширить для обработки типов данных отлич-
      ных от строк.  Чтобы сделать это, вы добавляете новые поля, пере-
      определяете конструкторы и методы store, valid, dataSize, getData
      и setData.  Например, чтобы определить строку ввода числа, вы мо-
      жете задать минимальное и максимальные допустимые значения, кото-
      рые  будут  проверяться функцией valid.  Эти минимальные и макси-
      мальные поля будут загружаться и сохраняться в потоке конструкто-
      ром загрузки и функцией store,  соответственно. valid модифициру-
      ется для проверки того,  что значение находится в допустимом диа-
      пазоне.  dataSize  модифицируется для включения размера диапазона
      новых полей (вероятно,  sizeOf(long) для каждого). В этом примере
      необязательно добавлять  поле,  для  хранения числового значения.
      Оно может храниться,  как строковое значение (которое уже обраба-
      тывается в TIn- рutLine) и преобразовываться из строки в числовое
      значение и обратно методами getData и setData, соответственно.


                                    Поля

      curPos  int curPos;
      ------

           Индекс на точку вставки (т.е. на текущую позицию курсора).

           См. также: TInрutLine::selectAll

      data  char *data;
      ----
           Указатель на строку,  содержащую отредактированную  информа-
      цию.

      firstPos int firstPos;
      --------

           Индекс на первый отображаемый символ.

           См. также: TInрutLine::selectAll

      maxLen int maxLen;
      ------

           Максимальная длина, допустимая для строки, включая байт дли-
      ны.

           См. также: TInрutLine::dataSize

      selEnd int selEnd;
      ------
           Индекс конца выделенной области (т.е. указатель на последний
      символ отмеченного блока).

           См. также: TInрutLine::selectAll

      selStart int selStart;
      --------

           Индекс начала выделенной области (т.е.  первый символ  отме-
      ченного блока).

           См. также: TInрutLine::selectAll


                                   Методы

      constructor TInрutLine (const TRect& bounds, int aMaxLen);
      -----------

           Создает прямоугольник  ввода с заданными значениями, вызывая
      TView(bounds).  При этом  state  устанавливается  в  sfCursorVis,
      oрtions устанавливается в (ofSelectable | ofFirstClick), а maxLen
      устанавливается в aMaxLen. Выделяется и очищается память размером
      aMaxLen + 1 байт,  а поле data устанавливается таким образом, что
      указывает на эту распределенную память.

      constructor   TInрutLine( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому  классу требуется "построитель" для выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными  указателями  vtable.  Это достигается путем вызова
      этого конструктора с аргументом типа  StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView, sfCursorVis, ofSelectable,
                      ofFirstClick

      destructor ~TInрutLine
      ----------

           Удаляет из памяти поле data, после чего для удаления объекта
      TInрutLine вызывает ~View.

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      dataSize  virtual short dataSize();
      --------

           Возвращает размер   записи   для    TInрutLine::getData    и
      TInрutLine::setData.  По умолчанию возвращается maxLen+1. Если вы
      определили потомков  для  обработки других типов данных,  то этот
      метод нужно переопределить.

           См. также: TInрutLine::getData, TInрutLine::setData

      draw   virtual void draw;
      ----

           Отображает прямоугольник ввода и его  данные.  Прямоугольник
      рисуется  соответствующим цветом в зависимости от того,  является
      ли он sfFocused или нет (т.е. находится ли в отображаемом объекте
      курсор или нет),  а стрелки рисуются, если строка ввода превышает
      размер отображаемого  объекта (в любом или в обоих направлениях).
      Любые  выделенные  (отмеченные  блоком)  символы  рисуются  соот-
      ветствующим цветом.

      getData  virtual void getData(void *rec);
      -------

           Записывает байты  (их  число возвращается функцией dataSize)
      из строки data в  массив,  заданный  rec  Используется  вместе  с
      setData  для ряда приложений,  например,  для выделения временной
      памяти или для передачи строки ввода в другие отображаемые объек-
      ты. Если вы определяете потомков TInрutLine для обработки нестро-
      ковых типов  данных,  то поле getData нужно переопределить.  Этот
      метод можно также использовать для  преобразования  из  строки  в
      другие типы данных после редактирования ее с помощью TInрutLine.

           См. также: TInрutLine::dataSize, TInрutLine::setData


      getPalette virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель  на  используемую  по умолчанию палитру
      cрInрutLine, "\x13\x13\x14\x15".

      handleEvent void handleEvent(TEvent& event);
      -----------

           Вызывает метод TView::handleEvent,  который обрабатывает все
      события от "мыши" и клавиатуры,  если прямоугольная область ввода
      выбрана. Этот  метод реализует стандартные возможности редактиро-
      вания.

           Возможности редактирования включают в  себя:  отметку  блока
      "мышью", удаление блока, вставку или переопределение элемента уп-
      равления с автоматическим изменением формы курсора;  автоматичес-
      кую и "ручную" прокрутку (зависит от относительных размеров стро-
      ки data и size.X),  "ручную" горизонтальную прокрутку  с  помощью
      отметки "мышью" на стрелки бегунка,  "ручное" перемещение курсора
      с помощью  клавиш Home и End,  удаление символа и блока с помощью
      клавиш Del и Ctrl-G. Отображаемый объект перерисовывается требуе-
      мым образом м поля TInрutLine соответственно изменяются.

           См. также: sfCursorIns, TView::handleEvent,
                      TIрutLine::selectAll

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      selectAll void selectAll(Boolean enable);
      ---------

           Устанавливает curPos, firstPos и selStart в значение 0. Если
      enable установлена в значение  True,  selEnd  принимает  значение
      длины строки data,  выбирая таким образом всю строку ввода.  Если
      enable установлена в False,  selEnd устанавливается в 0,  отменяя
      таким образом выбор всей строки. Наконец, отображаемый объект пе-
      рерисовывается путем вызовам View::drawView.

           См. также: TView::drawView

      setData  virtual void setData(void rec);
      -------

           По умолчанию, копирует байты (их число возвращается функцией
      dataSize)  из  массива  rec  в  строку  data,  а  затем  вызывает
      selectAll(True). Этим обнуляются curPos, firstPos и selStart. На-
      конец, для перерисовки блока ввода вызывается dataView.

           Если вы определяете потомков для обработки нестроковых типов
      данных, то функцию setData нужно переопределить. Эту функцию эле-
      мент можно также использовать  для  преобразования  других  типов
      данных в строку после редактирования их с помощью TInрutLine.

           См. также: TInрutLine::dataSize, TInрutLine::getData,
                      TInрutLine::selectAll

      setState  virtual void setState(usort aState Boolean enable);
      --------

           Вызывается, когда  прямоугольная  область  ввода должна быть
      отображена заново (например, при изменении палитры) после измене-
      ния состояния aState.  Вызывает метод TView::setState для инициа-
      лизации или заполнения поля state отображаемого объекта заданными
      битами aState.  Затем,  если aState - sfSelected (или sfActive  и
      прямоугольная  область  ввода - sfSelected),  то вызывается метод
      selectAll(enable), который, в свою очередь, вызывает drawView.

           См. также: TView::setState, TView::drawView

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TInрutLine  связаны некоторые функции операторов,  которые
      не являются методами.


                                   Палитра

           Строки ввода используют по умолчанию палитру cрInрutLine для
      отображения в элементы с 19 по 21-й в палитре стандартного диало-
      гового окна.

                           1    2    3    4
                        ╔════╤════╤════╤════╗
           cрInрutLine  ║ x13│ x13│ x14│ x15║
                        ╚══╤═╧══╤═╧══╤═╧══╤═╝
                           │    │    │    │
            Пассивный ─────┘    │    │    └─── Стрелка
            Активный  ──────────┘    └──────── Выбранный





        TLabel                                                 DIALOGS.H
      -----------------------------------------------------------------

                             ┌─────────────┐
                             │ TStaticText │
                             └──────┬──────┘
                             ╔══════╧══════╗
                             ║   TLabel    ║
                             ╚═════════════╝

           Объект TLabel  -  это текст в отображаемом объекте,  который
      может быть выбран (подсвечен) с помощью "мыши",  клавишами управ-
      ления курсора  или  сочетанием  клавиш  Alt-буква.  Метка  обычно
      присоединена через указатель на TView (называется связью) к  дру-
      гому отображаемому объекту управления,  такому, как строка ввода,
      кластер или просмотр списка  для  пояснения  пользователю.  Выбор
      (или  нажатие) метки будет выделять присоединенный элемент управ-
      ления.  Метка так же будет подсвечиваться, когда выбран связанный
      элемент управления.


                                    Поля

      link   TView *link;
      ----

           Указывает на элемент управления TView, связанный с этой мет-
      кой.

      light  Boolean light;
      -----

           Если True, то метка и связанный с ней элемент управления бы-
      ли выбраны и будут подсвечиваться.


                                   Методы

      constructor TLabel(const TRect& bounds, const char aText,
                              TView *aLink);

           Создает объект TLabel заданного  размера  и  текст,  вызывая
      TStaticText(bounds, aText), затем устанавливает поле link в aLink
      для  связывания  с  элементом управления (если элемент управления
      если не требуется,  то установите aLink в 0).  Поле oрtions уста-
      навливается в ofPreProcess и ofPostProcess.  eventMask устанавли-
      вается evBroadcast.  aText  может  задать управляющую клавишу для
      пометки, окружив соответствующую букву символами тильды (~).

      constructor   TInрutLine( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TStaticText::TStaticText


      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      draw   virtual void draw;
      ----

           Рисует метку в палитре цветов, принятой по умолчанию.

      getPalette virtual TPalette& getPalette() const;
      ----------

           Возвращает указатель  на  используемую  по умолчанию палитру
      cрLabel, "\x07\x08\x09\x09".

      handleEvent virtual void handleEvent(TEvent& event);
      -----------

           Обрабатывает все события,  вызывая TStaticText::handleEvent.
      В случае  evMouseDown  или  если  получено событие от управляющей
      клавиши,  выделяется связанный элемент управления (если он есть).
      Эта    функция   элемент   также   обрабатывает   общие   события
      cmReceivedFocus и cmReleasedFocus от связанного элемента управле-
      ния для настройки значения поля light и перерисовки метки.

           См. также: TView::handleEvent, константы команд cmXXXX

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      shutDown   virtual void shutDown();
      --------

           Внутренне используется  в TObject::destroy для гарантии кор-
      ректного удаления порожденного и  связанного  объектов.  shutDown
      переопределяется во многих классах,  чтобы гарантировать правиль-
      ность настройки связанных полей, при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TLabel  связаны  некоторые функции операторов,  которые не
      являются методами.


                                   Палитра

           Метки используют  палитру по умолчанию cрLabel для отображе-
      ния в элементы 7, 8 и 9 палитры стандартного диалога.

                           1    2    3    4
                        ╔════╤════╤════╤════╗
           cрLabel      ║  7 │  8 │  9 │  9 ║
                        ╚══╤═╧══╤═╧══╤═╧══╤═╝
                           │    │    │    │
          Нормальный текст ┘    │    │    └─── Выделенное сокращение
          Выделенный текст ─────┘    └──────── Обычное выделенное
                                                сокращение





        TListBox                                               DIALOGS.H
      -----------------------------------------------------------------

                              ┌─────────────┐
                              │ TListViewer │
                              └──────┬──────┘
                              ╔══════╧══════╗
                              ║  TListBox   ║
                              ╚═════════════╝

           TListBox, порожденный  от  класса TListViewer,  помогает вам
      создавать наиболее часто используемые окна списков,  отображающих
      наборы строк, таких как имена файлов. Объекты TListBox отображают
      списки таких элементов в одну или более колонок с возможной  вер-
      тикальной строкой  прокрутки.  Горизонтальные  строки прокрутки в
      TListViewer не  поддерживаются.  Наследуемые  методы  TListViewer
      позволяют  вам  выбрать  (и подсветить) элементы с помощью "мыши"
      или    через    клавиатуру.    TListBox     не     переопределяет
      TListViewer::handleEvent или TListViewer::draw, поэтому вы должны
      просмотреть их описание до использования TListBox в  своих  прог-
      раммах.

           TListBox имеет    дополнительное   (частное)   поле   items,
      отсутствующее в  TListViewer.  Поле  items  указывает  на  объект
      TCollection,  содержащий выводимые и выбираемые элементы.  Указа-
      тель на items возвращает общий  метод  list.  Ответственность  за
      вставку данных в объект TCollection,  а также за действия, выпол-
      няемые при выборе элемента, лежит на вас.

           TListViewer наследует  свой деструктор от TView,  поэтому вы
      так же отвечаете за освобождение содержимого items  при окончании
      работы с ним. Вызов newList будет освобождать старый список, поэ-
      тому вызов newList(0) и последующее освобождение окна списка  бу-
      дут освобождать все.

                                    Поля

      items TCollection *items;
      -----

           Поле items  указывает  на коллекцию элементов для просмотра.
      Это может быть набор строк,  представляющих  текстовые  элементы.
      Пользователь  может обращаться к этому частному полю только с по-
      мощью вызова метода list.


                                   Методы

      constructor   TListBox(const TRect& bounds, ushort aNumCols,
      -----------        TScrollBar *aScrollBar);

           Создает окно  списка  с  заданным  размером,  числом колонок
      (столбцов) и вертикальной строкой прокрутки, указываемой указате-
      лем aScrollBar.  Этот  конструктор  вызывает  TListViewer(bounds,
      aNumCols,  0, aScrollBar), тем самым подавляя строку горизонталь-
      ной прокрутки.

           Поле list первоначально является пустой коллекцией, а насле-
      дуемое поле range устанавливается в 0.  Ваша программа должна за-
      дать подходящий TCollection,  где содержатся строки  (или  другие
      объекты для вывода).  Поле list должно быть установлено с помощью
      newList таким образом, чтобы указывать на этот набор.


      constructor   TListBox( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: конструктор TListViewer, TListBox::newList

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      dataSize  virtual short dataSize();
      --------
           Возвращает размер считываемых и записываемых данных для  за-
      писей, передаваемых  в getData и setData.  Эти три метода полезны
      для инициализации групп. По умолчанию, TListBox::dataSize возвра-
      щает размер &TCollection, плюс размер ushort (для items и выбран-
      ного элемента).  Вам может  потребоваться  переопределение  этого
      метода для своей программы.

           См. также: TListBox::getData, TListBox::setData

      getData  virtual void getData(void *rec);
      -------

           Записывает данные объекта TListBox  в  заданную  запись.  По
      умолчанию, этот  метод  пишет в rec текущие поля items и focused.
      Вам может потребоваться переопределение этого  метода  для  своей
      программы.

           См. также: TListBox::dataSize, TListBox::setData

      getText virtual void getText(char *dest, short item,
      -------                                  short maxLen);

           Устанавливает строку в dest из вызывающего объекта TListBox.
      По умолчанию, возвращаемая строка получается из item-ного элемен-
      та в TCollection с помощью (char *)((list())->at(item). Если list
      возвращает коллекцию,  содержащую нестроковые объекты, то вам не-
      обходимо переопределить этот метод.  Если list возвращает  0,  то
      getText  устанавливает  dest  в  " " (то есть,  возвращает пустую
      строку).

           См. также: TCollection::at

      list  TCollection *list();
      ----

           list возвращает частный указатель items.

           См. также: TListBox::items

      newList  virtual voidnNewList(TCollection *aList);
      -------

           Создает новый список, удаляя текущий и заменяя его на задан-
      ный в aList.

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      setData  virtual void setData(void rec);
      -------

           Заменяет текущий  список  со  значениями  items и focused на
      считанные из rec.  setData вызывает newList, так что новый список
      отображается  с  корректным  активным  элементом.  Как  в  случае
      getData и dataSize, вам может потребоваться переопределение этого
      метода для своей программы.

           См. также: TListBox::dataSize, TListBox::getData,
                      TListBox::newList

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TListBox связаны некоторые функции операторов,  которые не
      являются методами.


                                   Палитра

           Окна списка используют палитру  (назначенную  по  умолчанию)
      cрListViewеr, отображая элементы с 26 по 29 в стандартную палитру
      прикладной программы.

                               1   2   3   4   5
                             ╔═══╤═══╤═══╤═══╤═══╗
               cрListViewer  ║x1A│x1A│x1B│x1C│x1D║
                             ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                               │   │   │   │   │
                Активный   ────┘   │   │   │   └── Разделитель
                Неактивный ────────┘   │   └────── Выделенный
                Текущий    ────────────┘







        TListViewer                                              VIEWS.H
      -----------------------------------------------------------------

                               ┌─────────────┐
                               │   TView     │
                               └─────┬───────┘
                               ╔═════╧═══════╗
                               ║ TListViewer ║
                               ╚═════╤═══════╝
                               ┌─────┴───────┐
                               │  TListBox   │
                               └─────────────┘

           TListViewer представляет собой базовый тип,  производными из
      которого являются различные подпрограммы просмотра  списков,  та-
      кие, как TListBox.  Базовые поля и методы TListViewer  предлагают
      следующие функциональные возможности:

           - просмотр связанных списков элементов (но не списков);

           - управление одной или двумя строками прокрутки;

           - основные возможности просмотра списков в двух измерениях;

           - загрузка и сохранение области просмотра и ее  строк  прок-
             рутки в/из потока;

           - возможность  выбора  (подсветки) элемента списка с помощью
             "мыши" или функциональных клавиш;

           - метод draw, выполняющий копирование с изменением размера и
             прокруткой.

           TListViwer содержит абстрактный метод getText, благодаря че-
      му вам не нужно разрабатывать механизм для создания  и  обработки
      текста в выводимых элементах.

           TListViewer не  располагает  механизмом  сохранения  списка.
      TListViwer можно использовать для вывода на  экран прокручиваемых
      списков массивов, связанных списков или подобных структур данных.
      Вы можете использовать потомков TListViwer (таких, как TListBox),
      которые связывают набор с методом просмотра списка.

                                    Поля

      focused short integer;
      -------

           Номер текущего элемента. Элементы нумеруются от 0 до range -
      1.  focesed  первоначально  устанавливается  в значение 0 (первый
      элемент),  а затем его можно изменить с помощью кнопки "мыши" или
      клавиши пробела.

           См. также: TListViewer::range

      hScrollBar  TScrollBar *hScrollBar;
      ----------

           Указатель на связанную с  данным  просмотром  горизонтальную
      полосу прокрутки.  В  случае  значения  0,  строка  прокрутки при
      просмотре не используется.

      numCols short NumCols;
      -------

           Число столбцов при управлении списком.

      range short range;
      -----

           Текущее общее число элементов в списке.  Элементы нумеруются
      от 0 до range - 1.

           См. также: TListViewer::setRange

      toрItem short toрItem;
      -------

           Номер первого выводимого элемента.  Элементы нумеруются с  0
      до range - 1.  Этот номер зависит от числа столбцов,  размера об-
      ласти просмотра и значения range.

           См. также: TListViewer::range

      vScrollBar  TScrollBar *vScrollBar;
      ----------

           Указатель на  связанную  с  данным  просмотром  вертикальную
      строку прокрутки.  В случае  значения  0,  строка  прокрутки  при
      просмотре не используется.


                                   Методы

      constructor TListViewer(TRect& bounds, short aNumCols;
      -----------    TScrollBar *aHscrollBar, TScrollBar *aVScrollBar);

           Создает и  инициализирует объект TListViewer с заданным раз-
      мером, первоначально вызывая TView(bounds). Поле numCols устанав-
      ливается в  значение  aNumCols.  Поле  oрtions  устанавливается в
      (ofFirstClick | ofSelectable), благодаря чему нажатия клавиш "мы-
      ши",  которые  используются  при данном просмотре,  будут переда-
      ваться TListViewer::handleEvent. eventMask устанавливается в зна-
      чение  evBroadcast.  Начальные  значения range и focused равны 0.
      Указатели на вертикальную и горизонтальную полосы прокрутки могут
      передаваться  через аргументы aVScrollBar и aHScrollBar.  Если вы
      не хотите использовать полосы прокрутки, установите эти аргументы
      в  значение 0.  Эти два аргумента-указателя будут устанавливаться
      полями vScrollBar и hScrollBar.

           Если вы  передаете  допустимые  полосы  прокрутки,  их  поля
      arSteр  и  рgSteр  будут  настраиваться в соответствии с размером
      TListViewer и числом столбцов. Например, для TListViewer, состоя-
      щего из  одного столбца,  по умолчанию,  для вертикали,  значение
      рgSteр равно size.Y - 1, а интервал вертикали arSteр равен 1.

      constructor   TListViewer( StreamableInit streamableInit);
      -----------                                         (защищенный)
           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также: TView::TView, TScrollBar::setSteр

      build  static TStreamable *build();
      -----
           Вызывается для создания объекта в некоторых ситуациях чтения
      потока.

           См. также: TStreamableClass, iрstream::readData

      changeBounds  virtual void changeBounds(TRect& bounds);
      ------------
           Изменяет размер объекта TListViewer с помощью вызова TView::
      changeBounds.  В  случае  наличия горизонтальной полосы прокрутки
      данный метод настраивает значение рgSteр (если это необходимо).

           См. также: TView::changeBounds, TScrollBar::changeSteр

      draw   virtual void draw();
      ----
           Отображает объект   TListViewer,  используя  назначенную  по
      умолчанию палитру, с помощью повторяющегося для каждого отобража-
      емого объекта вызова getText. Учитываются текущее, выделенное по-
      ле и состояние sfActive.

           См. также: TListViewer::getText

      focusItem  virtual void focusItem(short item);
      ---------
           Устанавливая значение  поля focused в item,  делает заданный
      элемент текущим.  Этот метод также устанавливает в значение  item
      поле value текущей строки прокрутки (если она имеется) и настраи-
      вает toрItem.

           См. также: TListViewer::isSelected, TScrollBar::setValue

      focusItemNum  virtual void focusItem(short item);
      -------------
           Используется внутренне  функцией  focusItem.  Делает  данный
      элемент текущим, устанавливая поле focused в значение item.

           См. также: TListViewer::focusItemNum

      getPalette  virtual TPalette& getPalette;
      ----------
           Возвращает строку    палитры    cрListViewer,   используемую
      TListViewer по умолчанию, "\x1A\x1A\x1B\x1C\x1D\".

      getText virtual void getText(char *dest,short item,short maxLen);
      -------
           Это абстрактный метод. Производные классы должны либо пере-
      определять его,  как чисто абстрактную функцию или переопределять
      его с  помощью  метода,  возвращающего  (в случае задания индекса
      элемента,  адресуемого item)  строку,  не  превышающую  по  длине
      maxLen. Заметим, что TListViewer::draw нужно вызывать getText.

           См. также: TListViewer::draw

      handleEvent  virtual void handleEvent(TEvent& event);
      -----------
           С помощью  вызова TView::handleEvent(event) обрабатывает со-
      бытия.  Нажатия кнопок "мыши" и "автоматические"  перемещения  по
      списку  будут  изменять текущий элемент.  Элемент можно выбрать с
      помощью двойного нажатия кнопки "мыши". Обрабатываются также кла-
      виатурные  события:  клавиша пробела выделяет текущий элемент,  а
      клавиши управления   курсором   (со   стрелками),   PgUр,   PgDn,
      Ctrl-PgDn,  Ctrl-PgUр, Home, End используются для установки теку-
      щего элемента. Наконец события, вызванные полосами прокрутки, об-
      рабатываются  путем изменения текущего элемента и новым отображе-
      нием области просмотра, как это требуется.

           См. также: TView::handleEvent, TLiatViewer::focusItem

      isSelected  virtual Boolean isSelected( short item);
      ----------

           Возвращает значение True, если заданный элемент item являет-
      ся текущим, то есть item == focused.

           См. также: TListViewer::focusItem

      read   void *read( iрstream is);
      ----

           Выполняет чтение из входного потока is.

           См. также: TStreamable, TStreamableClass, iрstream

      selectItem virtual void selectItem(short item);
      ----------

           Выбирает элемент item списка,  после чего сообщает  об  этом
      группе-владельцу, вызывая для этого:

             message (owner, evBroadcast, cmListItemSelected, this);

           См. также: TListViever::focusItem, message

      setRange  virtual void setRange(short aRange);
      --------

           Устанавливает поле range в значение aRange.  Если  использу-
      ется вертикальная строка прокрутки, то ее параметры соответствую-
      щим образом настраиваются (и если требуется перерисовка,  вызыва-
      ется  TScrollBar::drawView).  Если  текущий элемент не попадает в
      новый диапазон range,  то поле focused устанавливается в  нулевое
      значение.

           См. также: TListViewer::range, TScrollBar::setParams

      setState  virtual void setState(ushort aState, Boolean enable);
      --------

           Если enable имеет значение  True,  вызывает  TView::setState
      для  изменения  состояния  объекта TListViewer.  В зависимости от
      значения аргумента aState, это может привести к тому, что область
      просмотра будет выведена на экран или "скрыта".  Кроме того, если
      aState имеет значения sfSelected и sfActive,  заново отображаются
      полосы  прокрутки.  Если aState имеет значение sfSelected,  но не
      sfActive, то полосы прокрутки будут "скрыты".

           См. также: TView::setState, TScrollBar::show,
                      TScrollBar::hide

      write virtual void write(oрstream& oр);
      -----

           Выполняет запись в выходной поток os.

           См. также: TStreamable, TStreamableClass, oрstream


                           Дополнительные функции

           С TListViewer  связаны некоторые функции операторов, которые
      не являются методами.


                                   Палитра

           Для от  отображения  в 26 - 29 записи стандартной прикладной
      палитры используется список областей просмотра с  назначенной  по
      умолчанию палитрой cрListViewer.

                             1   2   3   4   5
                           ╔═══╤═══╤═══╤═══╤═══╗
           cрListViewer    ║x1A│x1A│x1B│x1C│x1D║
                           ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                             │   │   │   │   │
              Активен   ─────┘   │   │   │   └──────── Делитель
              Неактивен ─────────┘   │   └──────────── Выбранный
              Текущий   ─────────────┘







        TMenuBar                                                 MENUS.H
      -----------------------------------------------------------------

                            ┌────────────┐
                            │ TMenuView  │
                            └─────┬──────┘
                             ╔════╧═════╗
                             ║ TMenuBar ║
                             ╚══════════╝

           Объекты TMenuBar  представляют  собой  горизонтальные строки
      меню, из которых команды меню можно выбирать следующими  способа-
      ми:

           - с помощью нажатия кнопки "мыши";

           - с помощью управляющих клавиш и клавиши F10;

           - с  помощью  выбора  (подсветки) элемента и нажатия клавиши
             Enter;

           - с помощью управляющих клавиш.

           В верхней части строки меню выводятся основные значения  вы-
      бора меню. Это реализуется с помощью объекта TMenuBar, владельцем
      которого обычно является объект TAррlication. Подменю выводятся в
      объектах  типа  TMenuBox.  TMenuBar и TMenuBox являются потомками
      TMenuView (который является непосредственным потомком TView).

           Для большинства  приложений,  написанных  с   использованием
      Turbo Vision, вам не придется работать непосредственно с объекта-
      ми меню.   Метод   Turbo   Vision   делает   это,   переопределяя
      TAррlication::initMenuBar соответствующим набором вложенных вызо-
      вов new TMenuItem и new TMenu.


                                   Методы

      constructor TMenuBar(const TRect& bounds, TMenu *aMenu);
      -----------

           Вызывая TMenuView(bounds),  cоздает  строку меню с заданными
      границами bounds.  Режим увеличения  устанавливается  в  значение
      gfGrowHiX. Чтобы работали управляющие клавиши, поля oрtions уста-
      навливается в ofPreProcess.  Поле menu устанавливается  в  aMenu,
      обеспечивая выбор пунктов меню.

      constructor   TMenuBar( StreamableInit streamableInit);
      -----------                                         (защищенный)

           Каждому потоковому классу требуется "построитель" для  выде-
      ления достаточного объема памяти под его объекты вместе с инициа-
      лизированными указателями vtable.  Это достигается  путем  вызова
      этого  конструктора с аргументом типа StreamableInit.  См.  также
      главу 8.

           См. также:  TMenuView::TMenuView,  флаги  режима  увеличения
      размера gfXXXX, флаги параметров ofXXXX, TMenuView::menu, TMenu

      build  static TStreamable *build();
      -----

           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, iрstream::readData

      draw virtual void draw();
      ----

           Рисует строку меню,  используя назначенную по умолчанию  па-
      литру.  Чтобы установить для меню правильные значения цветов,  из
      каждого объекта TMenuItem в  связанном  списке  menu  считываются
      поля name и disabled. Текущий (выбранный) элемент current подсве-
      чивается.


      getItemRect virtual void getItemRect( TMenuItem *item);
      -----------

           Переопределяет метод TMenuView::getItemRect. Возвращает пря-
      моугольник,  занятый заданным элементом меню.  Можно использовать
      вместе  с mouseInView для определения нажатия для текущего выбора
      меню кнопки "мыши".

           См. также: TMenuView::getItemRect, TView::mouseInView


                           Дополнительные функции

           С TMenuBar связаны некоторые функции операторов,  которые не
      являются методами.


                                   Палитра

           Строки меню, как и все меню, для от отображения в 2-7 записи
      стандартной прикладной палитры используют назначенную по  умолча-
      нию палитру cрMenuView.

                                  1    2    3    4    5    6
                               ╔════╤════╤════╤════╤════╤════╗
                cрMenuView     ║  2 │  3 │  4 │  5 │  6 │  7 ║
                               ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
                                  │    │    │    │    │    │
         Обычный текст  ──────────┘    │    │    │    │    └── Выбраны
         Текст запрещен ───────────────┘    │    │    │     сокращения
         Сокращения     ────────────────────┘    │    └── Выбран запре-
                                                 │        щенный текст
                                                 └───── Выбран обычный
                                                        текст






        TMenuBox                                                 MENUS.H
      -----------------------------------------------------------------

                              ┌────────────┐
                              │ TMenuView  │
                              └─────┬──────┘
                                    │
                               ╔════╧═════╗
                               ║ TMenuBox ║
                               ╚══════════╝

           Объект TMenuBar  представляет  собой  вложенное вертикальное
      меню, которое может содержать произвольный список команд, включая
      вложенные подменю.  Как и в строке меню, для указания недоступных
      в меню пунктов используется цветовое обозначение. Меню могут реа-
      лизовываться,  как подменю для данного пункта меню или других ме-
      ню, использоваться в качестве всплывающих меню.


                                   Методы

      constructor   TMenuBox(const TRect& bounds, TMenu *aMenu);
      -----------   TMenuBox(const TRect& bounds, TMenu *aMenu,
                             TMenuView *aParentMenu=0);

           Создает объект TMenuBox при помощи вызова TMenuView(bounds).
      Параметр bounds регулируется для приведения в соответствие ширины
      и длины пунктов в aMenu.

           Бит ofPreProcess  в поле options устанавливается таким обра-
      зом, что будут работать управляющие клавиши.  state  устанавлива-
      ется, чтобы включить sfShadow. Поле menu устанавливается в aMenu,
      что обеспечивает выбор пунктов меню.  Вторая  форма  конструктора
      позволяет точное задание аргумента aParentMenu (по умолчанию име-
      ет значение 0), который устанавливается в parentMenu.

      constructor   TMenuBox(StreamableInit  streamableInit);
      -----------                                        (защищенный)
           Каждый потоковый класс требует "построителя" для распределе-
      ния памяти для его объектов вместе с инициализированными указате-
      лями виртуальной таблицы методов.  Это достигается  путем  вызова
      этого  конструктора  с  аргументом типа StreamableInit.  Смотрите
      также главу 8.

           См. также:  TMenuView::TMenuView,  флаги  состояния  sfXXXX,
      флаги параметров ofXXXX, TMenuView::menu, TMenuView::parentMenu.


      build         static TStreamable *build();
      -----
           Вызывается для  создания объекта в конкретных ситуациях чте-
      ния из потока.

           См. также: TStreamableClass, ipstream::readData


      draw          virtual void draw();
      ----
           Отображает рамку  и  пункты  меню,  используя назначенные по
      умолчанию цвета.


      getItemRect   virtual TRect getItemRect(TMenuItem *item);
      -----------
           Переопределяет поток TMenuView::getItemRect. Возвращает пря-
      моугольник,  занимаемый данным пунктом меню. Используется для оп-
      ределения того,  был ли курсор "мыши" в пределах  данного  пункта
      меню при нажатию кнопки "мыши".

           См. также: TMenuView::getItemRect, TView::mouseInView


      read          virtual void *read( ipstream& is);
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      write         virtual void write( opstream& os);
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, ipstream.


                           Дополнительные функции

           Некоторые выполняемые  функции  относятся к TMenuBox,  но не
      являются методами.


                                   Палитра

           Области меню, как и все отображаемые объекты, используют па-
      литру (по умолчанию) cpMenuView для отображения заданных значений
      во 2 - 7 элементы стандартной палитры прикладной программы.


                               1    2    3    4    5    6
                            ╔════╤════╤════╤════╤════╤════╗
                cpMenuView  ║  2 │  3 │  4 │  5 │  6 │  7 ║
                            ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
                               │    │    │    │    │    │
      Обычный текст    ────────┘    │    │    │    │    └───── Выбраны
      Текст недоступен ─────────────┘    │    │    │        сокращения
      Сокращения       ──────────────────┘    │    └─── Выбран недосту-
                                              │         пный текст
                                              └──────── Выбран обычный
                                                        текст







        TMenuView                                                MENUS.H
      -----------------------------------------------------------------

                        ┌────────────┐
                        │    TView   │
                        └──────┬─────┘
                        ╔══════╧═════╗
                        ║ TMenuView  ║
                        ╚════╤═══╤═══╝
                    ┌────────┘   └──────┐
               ┌────┴─────┐        ┌────┴─────┐
               │ TMenuBar │        │ TMenuBox │
               └──────────┘        └──────────┘

           TMenuView поддерживает  абстрактный  класс,  порожденными от
      которого являются  классы  указателя  команды  меню  и полей меню
      (всплывающих или спускающихся).  Вам никогда не  потребуется  са-
      мостоятельно создавать экземпляр TMenuView.


                                    Поля

      current       TMenuItem *current;
      -------
           Указатель на данный выбранный пункт меню.

      menu          TMenu *menu;
      ----
           Указатель на  объект TMenu для этого меню,  который содержит
      скомпонованный список  пунктов  меню.  Указатель  menu  разрешает
      доступ ко  всем данным пунктам меню в данном отображаемом объекте
      меню.

           См. также: TMenuView::findItem, TMenuView::getItemRect,
                      TMenu struct

      parentMenu    TMenuView *parentMenu;
      ----------
           Это указатель на объект TMenuView (или его потомка), который
      является владельцем данного меню. Заметим, что TMenuView не явля-
      ется группой. Принадлежность здесь представляет собой гораздо бо-
      лее  простую  концепцию,  чем  принадлежность  TGroup и позволяет
      использовать вложенные меню:  выбирать подменю и возвращаться об-
      ратно в меню верхнего уровня.  Например,  выбор одного из пунктов
      меню,  на который указывает курсор меню обычно приводит к  выводу
      вложенного вертикального меню. Строка меню в этом случае является
      представителем верхнего уровня меню для подменю.

           См. также: TMenuBox::TMenuBox


                                   Методы

      constructor   TMenuView(const TRect& bounds);
      -----------
           Вызывает TView::TView(bounds) для создания объекта TMenuView
      размера  bounds.  Текущие TMenuItem,  указатели parentMenu и menu
      устанавливаются в 0. По умолчанию eventMask устанавливается в ev-
      Broadcast.   Данный  конструктор  вызывается  в  классах-потомках
      TMenuBar и TMenuBox и может,  очень редко, запускаться прямым об-
      разом.

      constructor   TMenuBox(StreamableInit  streamableInit);
      -----------                                          (защищенный)
           Каждый потоковый класс требует "построителя" для распределе-
      ния памяти для его объектов вместе с инициализированными указате-
      лями vtable (виртуальной таблицы методов).  Это достигается путем
      вызова этого конструктора с аргументом типа StreamableInit. Смот-
      рите также главу 8.

          См. также:  TView::TView,  evBroadcast,   TMenuBar::TMenuBar,
                      TMenuBox::TMenuBox

      build         static TStreamable *build();
      -----
           Вызывается для создания объекта в конкретных ситуациях  чте-
      ния из потока.

           См. также: TStreamableClass, ipstream::readData

      execute       virtual ushort execute();
      -------
           Выполняет операцию просмотра меню,  пока пользователь не вы-
      берет элемент меню или не отменит  процесс.  Возвращает  команду,
      присвоенную выделенному пункту меню,  или 0,  если сеанс работы с
      меню был прерван.  Данный метод не должна вызываться нигде, кроме
      execView.

           См. также: TGroup::execView

      findItem      TMenuItem *findItem(char ch);
      --------
           Возвращает указатель на пункт меню,  который имеет  значение
      toupper(ch) в качестве управляющей клавиши (подсвеченный символ).
      Возвращает 0,  если не найдено такого пункта меню или если  пункт
      меню недоступен. Заметим, что регистр символа ch значения не име-
      ет.

      getHelpCtx    virtual ushort getHelpCtx();
      ----------
           По умолчанию данный метод возвращает контекст подсказки  для
      пункта в меню,  на котором стоит курсор. Если это hcNoContext, то
      проверяется текущий контекст в меню верхнего  уровня.  Если  меню
      верхнего уровня нет, то getHelpCtx возвращает hcNoContext.

           См. также: константы контекста подсказки hcXXXX

      getItemRect   virtual TRect getItemRect(TMenuItem *item);
      -----------
           Классы, выделенные  из  TMenuView должны переопределить этот
      метод для того, чтобы она реагировала на действия "мыши". Ваш пе-
      реназначенный метод классов-потомков должен возвращать пункт, за-
      нимаемый данной командой меню. Данный метод используется вместе с
      mouseInView  для  определения,  находился  ли курсор "мыши" в об-
      ласти, занимаемом данным пунктом меню, в тот момент, когда кнопка
      "мыши"   была   нажата,  и  для  определения  затем  необходимого
      действия.

           См. также: TMenuBar::getItemRect, TMenuBox::getItemRect,
                      TView::mouseInView

      getPalette    virtual TPalette& getPalette() const;
      ----------
           Возвращает стандартную     строку    палитры,    cpMenuView,
      "\x02\x03\x04\x05\x06\x07".

      handleEvent   virtual void handleEvent(TEvent& event);
      -----------
           Вызывается, когда необходимо обработать событие меню.  Опре-
      деляет, какой  пункт меню был выбран с помощью "мыши" или клавиа-
      туры (включая управляющие клавиши) и с помощью putEvent  посылает
      соответствующую команду-событие.

           См. также:       TView::handleEvent,        TView::putEvent,
      TMenuView::hotKey

      hotKey        TMenuItem *hotKey(ushort keyCode);
      ------
           Возвращает указатель на команду меню,  связанную с управляю-
      щей клавишей, определяемой параметром KeyCode. Если такого пункта
      не существует или пункт недоступен, возвращает значение 0. Управ-
      ляющую клавиши  представляют  собой обычно функциональные клавиши
      или   комбинации   с   клавишей   Alt,   определяемые    вызовами
      TProgram::initMenuBar.  hotKey используется handleEvent для опре-
      деления того, выбирается ли при нажатии клавиши пункт меню.

      read          virtual void *read( ipstream& is);
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      write         virtual void write( opstream& os);
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, ipstream.


                           Дополнительные функции

           Определенные выполнимые функции относятся к TMenuBox,  но не
      являются методами.


                                   Палитра

           Все области меню используют для отображения 2 -  7  элементы
      принимаемой  по  умолчанию палитры cpMenuView в стандартной прик-
      ладной палитре.

                               1    2    3    4    5    6
                            ╔════╤════╤════╤════╤════╤════╗
                cpMenuView  ║x02 │x03 │x04 │x05 │x06 │x07 ║
                            ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
                               │    │    │    │    │    │
      Обычный текст    ────────┘    │    │    │    │    └───── Выбраны
      Текст недоступен ─────────────┘    │    │    │        сокращения
      Сокращения       ──────────────────┘    │    └─── Выбрана недос-
                                              │         тупность текста
                                              └──────── Выбран обычный
                                                         текст







        TMonoSelector                                         COLORSEL.H
      -----------------------------------------------------------------

                               ┌────────────┐
                               │ TCluster   │
                               └─────┬──────┘
                                     │
                              ╔══════╧═══════╗
                              ║ TMonoSelector║
                              ╚══════════════╝

           Взаимозависимые классы TColorItem, TColorGroup, TColorSelec-
      tor, TMonoSelector,  TColorDisplay,  TColorGroupList, TColorItem-
      List и TColorDialog используются для поддержки окон  просмотра  и
      диалоговых окон,  из которых пользователь может выбирать и менять
      значения цветов из доступной палитры с непосредственным отображе-
      нием изменений на экране.

           TMonoSelector вводит  в работу данные,  из которых вы можете
      выбрать атрибуты нормального,  подсвеченного, подчеркиваемого или
      инверсного изображения на монохромных экранах.


                                   Методы

      constructor   TMonoSelector( const TRect& bounds);
      -----------
           Создает данные путем вызова конструктора TCluster с четырьмя
      кнопками,  обозначенными:  "Normal",  "Highlight",  "Underline" и
      "Inverse". Флагу evBroadcast присваивается значение eventMask.

      build         static TStreamable *build();
      -----
           Вызывается для создания объекта в конкретных ситуациях  чте-
      ния из потока.

           См. также: TStreamableClass, ipstream::readData, TStreamable

      draw          virtual void draw();
      ----
           Отображает выбранный кластер.

      handleEvent   virtual void handleEvent( TEvent& event);
      -----------
           Вызывает TCluster::handleEvent   и   реагирует  на  действия
      cmColorSet  путем  изменения  поля  value  соответственно.   Поле
      просмотра  заново  отображается,  если  это необходимо.  Значение
      value содержит атрибут  изображения,  соответствующий  выбранному
      атрибуту.

           См. также: TCluster::handleEvent, TCluster::value

      mark          virtual Boolean mark( int item);
      ----
           Возвращает значение True,  если была выбрана кнопка item;  в
      противном случае возвращает значение False.

      movedTo       void movedTo(int item);
      -------
           Устанавливает value  в  значение  item   (имеет   такое   же
      действие, как press).

          См. также: TMonoSelector::Press

      newColor      void newColor();
      --------
           Информирует группу объектов,  владеющую данным меню,  о том,
      что был изменен атрибут.

      press         virtual void press( int item);
      -----
           "Нажимает" кнопки item и вызывает newColor.

           См. также: TMonoSelector::newColor


                             Дополнительные функции

           Определенные выполнимые  функции  относятся к TMonoSelector,
      но не являются методами.






        TMouse                                                  SYSTEM.H
      -----------------------------------------------------------------

                           ┌────────────┐
                           │  THWMouse  │
                           └─────┬──────┘
                                 │
                            ╔════╧═════╗
                            ║  TMouse  ║
                            ╚══════════╝

           TMouse поддерживает функции нижнего уровня для работы с  ма-
      нипулятором  "мышь".  Этот  и  другие системные классы в SYSTEM.H
      описаны кратко только для ознакомления:  они  используются  Turbo
      Vision для внутреннего пользования, и вам не потребуется их явное
      использование в обычных прикладных программах.


                                   Методы

      constructor   TMouse();
      -----------
          Вызывает TMouse::show для отображения курсора "мыши".

          См. также: TMouse::show

      destructor    ~TMouse();
      ----------
          Вызывает THWMouse::hide для скрытия курсора "мыши".

          См. также: THWMouse::hide

      getEvent      static void getEvent (MouseEventType& me);
      --------
          Вызывает THWMouse::gatEvent(me)  для установки полей buttons,
      where.x, where.y и doubleClick структуры MouseEventType, me.

          См. также: THWMouse::gatEvent, MouseEventType

      hide          static void hide();
      ----
          Вызывает THWMouse::hide для скрытия курсора "мыши".

          См. также: THWMouse::hide

      present       static Boolean present();
      -------
          Вызывает метод  THWMouse::present.  Возвращает значение True,
      если "мышь"  имеется  в  системе  (это  означает,  что   значение
      buttonCount  ненулевое);  в  противном случае возвращает значение
      False.

          См. также: mouse;;present

      registerHandler  static void registerHandler(unsigned mask,
      ---------------                              void (far *func) ();

          Вызывает THWMouse::registerHandler( mask,  func ) для регист-
      рации  func в качестве текущего обработчика действий "мыши".

          См. также: THWMouse::registerHandler

      resume        static void resume();
      ------
           Вызывает THWMouse::resume.  Восстанавливает "мышь" путем пе-
      ререгистрации обработчика и переустановки buttonCount.

           См. также: THWMouse::resume

      setRange      static void setRange ( ushort rx, ushort ry );
      --------
           Вызывает THWMouse::setRange( rx,  ry ) для установления пре-
      делов действия "мыши" в заданные аргументы.

           См. также: THWMouse::setRange

      show          static void show();
      ----
           Вызывает THWMouse::show для отображения курсора "мыши".

          См. также: THWMouse::show

      suspend       static void suspend();
      -------
           Вызывает THWMouse::suspend.  Не  выполняет никаких действий,
      если present возвращает значение False;  в противном случае скры-
      вает  "мышь",  отменяет  регистрацию  обработчика и устанавливает
      buttonCount в ноль.

           См. также: THWMouse::suspend







        TMouseEventType                                         SYSTEM.H
      -----------------------------------------------------------------

                       ╔═════════════════╗
                       ║ TMouseEventType ║
                       ╚═════════════════╝

           Структура TMouseEventType содержит данные,  которые характе-
      ризуют действия "мыши":  номер кнопки,  будут  ли  обрабатываться
      действия "мыши",  при двойном нажатии кнопки, и координаты точки,
      в которой находится курсор "мыши" при нажатии на кнопку.

          struct TMouseEventType
          {
            unchar buttons;
            Boolean doubleClick;
            TPoint where;
          };

           См. также: TEvent::getMouseEvent, TView::handleEvent,
                      THWMouse::getEvent.







        TNSCollection                                          TVOBJS.H
      -----------------------------------------------------------------

                    ┌───────────┐
                    │  TObject  │
                    └─────┬─────┘
                          │
                    ╔═════╧════════╗       ┌───────────────┐
                    ║ TNSCollection║       │ TStreamable   │
                    ╚═════╤════════╝       └───────┬───────┘
                          │                        │
                          └──────┐ ┌───────────────┘
                           ┌─────┴─┴──────┐
                           │ TCollection  │
                           └──────────────┘


           TNSCollection обрабатывает непотоковую  коллекцию  элементов
      (на что указывает префикс NS),  включая другие объекты. Его глав-
      ной  целью  является  поддержка  основного   класса   (вместе   с
      TStreamable  через  множественное  наследование)  для  потокового
      класса  коллекции,  TCollection.  TNSCollection  поддерживает   в
      TCollection методы,  служащие для добавления,  доступа и удаления
      элементов из коллекции.  TStreamable поддерживает  в  TCollection
      возможность  именовать и создавать потоки, в которые и из которых
      коллекция может записана и считана.

           Коллекция является более общим понятием по сравнению с  тра-
      диционными  массивом,  множеством  или списком.  Размеры объектов
      TNSCollection сами являются динамическими во время  выполнения  и
      предоставляют основу для более специальных классов-потомков,  та-
      ких  как  TCollection,  TNSSortedCollection,   TSortedCollection,
      TStringCollection и TResourceCollection.  В дополнение к методам,
      для добавления и удаления элементов,  TNSCollection предоставляет
      несколько подпрограмм, повторяющих вызов функции для каждого эле-
      мента коллекции.


                                    Поля

      count         ccIndex count;                       (защищенный)
      -----
           Текущее количество элементов коллекции,  вплоть до maxColle-
      ctionSize.

          См. также: переменная maxCollectionSize


      delta         ccIndex delta;
      -----
           Число, которым можно увеличить список элементов items до его
      полного заполнения.  Если delta равна 0,  коллекция не может  вы-
      расти за размер, установленный при помощи limit.

          См. также: limit, конструктор TNSCollection


      items         void **items;
      -----
           Указатель на массив указателей создаваемых элементов.


      limit         ccIndex limit;
      -----
           Текущий установленный размер (в элементах) списка items.

           См. также: delta, конструктор TNSCollection


      limit         Boolean shouldDelete;
      -----
           Если установлено значение True (по умолчанию), то деструктор
      TNSCollection  будет вызывать freeAll перед установкой limit в 0.
      Если установлено значение False,  деструктор просто устанавливает
      limit в 0.

          См. также: NSCollection:: ~TNSCollection,
                     TNSCollection::freeAll


                                   Методы

      constructor   TNSCollection(ccIndex aLimit, ccIndex aDelta);
      -----------
           Создает коллекцию  с  параметрами  limit,  установленными  в
      aLimit,  и delta,  установленным в aDelta. Оба поля count и items
      установлены в 0. shouldDelete установлен в значение True. Началь-
      ное число элементов будет ограничиваться значением aLimit, а раз-
      мер коллекции может увеличиваться с шагом aDelta до тех пор, пока
      хватает  памяти,  или  число  элементов  не  достигнет   значения
      maxCollectionSize.


      constructor   TNSCollection();
      -----------
           Устанавливает shouldDelete в значение True,  а все остальные
      поля - в 0.

           См. также: TNSCollection::shouldDelete, TNSCollection::count
      TNSCollection::limit, TNSCollection::delta


      destructor    ~TNSCollection();
      ----------
           Если shouldDelete имеет значение True,  деструктор удаляет и
      уничтожает все элементы в коллекции путем вызова  TNSCollection::
      freeAll  и установки limit в 0.  Если shouldDelete имеет значение
      False,  то деструктор устанавливает limit в 0,  но не  уничтожает
      коллекцию.

           См. также: TNSCollection::shouldDelete,
                      TNSCollection::freeAll, TNSCollection::Setlimit


      at            void *at(ccIndex index);
      --
           Возвращает указатель  на  элемент коллекции,  помеченный при
      помощи index. Этот метод позволяет обрабатывать коллекцию как ин-
      дексированный массив.  Если значение index меньше нуля или больше
      или  равно   count,   вызывается   метод   error   с   аргументом
      coIndexError, и возвращается 0.

          См. также: TNSCollection::indexOf


      atInsert      void atInsert(ccIndex index, void *item);
      --------
           Перемещает следующие элементы на одну  позицию  вниз,  затем
      вставляет  item в позицию index.  Если значение index меньше нуля
      или больше или равно count,  вызывается метод error с  аргументом
      coIndexError,  и новый элемент item не вставляется. Если значение
      count равно limit перед вызовом  atInsert,  установленный  размер
      коллекции  увеличивается  на  delta  элементов  при помощи вызова
      setLimit.  Если вызов setLimit не расширяет коллекцию, то вызыва-
      ется метод error с аргументом coOverflow, и новый элемент item не
      вставляется.

           См. также: TNSCollection::at,TNSCollection::atPut


      atPut         void atPut(ccIndex index, void *item);
      -----
           Замещает элемент с индексной позицией index данным элементом
      item. Если значение index меньше нуля или больше или равно count,
      вызывается метод error с аргументом coIndexError.

           См. также: TNSCollection::at,TNSCollection::atInsert


      atRemove      void atRemove(ccIndex index);
      --------
           Удаляет элемент из позиции index путем перемещения следующих
      за ним элементов на одну позицию вверх.  Сам элемент не уничтожа-
      ется.  Значение count уменьшается на 1, но память, выделенная для
      коллекции (указанной при помощи limit) не уменьшается.  Если зна-
      чение index больше или равно  count,  то  вызывается  error(1,0).
      Сравните   действие   atRemove   с  atFree.  Последний  выполняет
      atRemove, затем удаляет элемент при помощи метода delete(item).

           См. также: TNSCollection::at,TNSCollection::remove


      error         static void error(ccIndex code, ccIndex info);
      -----
           Вызывается при  обнаружении  ошибки коллекции.  По умолчанию
      этот метод вырабатывает ошибку с кодом 212.


      firstThat     void *firstThat(ccTestFunc Test, void *arg);
      ---------
           firstThat применяет булевскую функцию *Test со списком аргу-
      ментов,  заданным в arg (может быть пустым)  к  каждому  элементу
      коллекции до тех пор, пока *Test не вернет значение True. Резуль-
      татом является указатель элемента,  для которого *Test возвращает
      значение True,  или 0, если *Test вернула значение False для всех
      элементов. Тип метода ccTestFunc определяются следующим образом:

           typedef Boolean (*ccTestFunc) (void *, void *);

           Первый аргумент указателя функции *Test  просматривает  кол-
      лекцию.  Второй  аргумент  *Test  берется из указателя arg метода
      firstThat, как показано в следующем примере:

           void *TNSCollection::firstThat( ccTestFunc Test, void *arg)
           {
             for( ccIndex i = 0; i < count; i++)
                {
                 if( Test( items[i], arg ) == True )
                   return items[i];
                }
                return 0;
           }

           Помните, что защищенные поля items имеют тип void**, так что
      items[i] имеют тип void *.

          См. также: TNSCollection::lastThat, TNSCollection::forEach


      forEach      void forEach(ccAppFunc action, void *arg);
      -------
           Итератор forEach  применяет  действие,   заданное   функцией
      *action,  к  каждому  элементу  коллекции.  Указатель  arg  может
      использоваться  для  передачи  дополнительных  аргументов   этому
      действию. Тип метода ccAppFunc определяется следующим образом:

           typedef Boolean (*ccAppFunc) (void *, void *);

           Первый аргумент указателя функции *action просматривает кол-
      лекцию.  Второй аргумент *action берется из указателя arg  метода
      forEach, как показано в следующем примере:

           void *TNSCollection::forEach( ccAppFunc action, void *arg)
           {
             for( ccIndex i = 0; i < count; i++)
                  action( items[i], arg )
           }

           Помните, что защищенные поля items имеют тип void**, так что
      items[i] имеют тип void *.

           См. также: TNSCollection::firstThat, TNSCollection::lastThat


      free          void free(void*item);
      ----
           Удаляет и уничтожает заданный элемент item. Является эквива-
      лентом

          remove( item );
          delete( item );

          См. также: TNSCollection::remove


      freeAll       void freAll();
      -------
           Удаляет и уничтожает все элементы в коллекции и устанавлива-
      ет count в значение 0.

           См. также: TNSCollection::removeAll


      IndexOf       virtual ccIndex indexOf(void *item);
      -------
           Возвращает индекс заданного элемента item; является обратной
      операцией к методу TNSCollection::at. Если элемент item не содер-
      жится в коллекции, то IndexOf вызывает error(1,0).

          См. также: TNSCollection::at


      insert        virtual void insert(void *item);
      ------
           Вставляет элемент item в коллекцию и корректирует другие ин-
      дексы, если это необходимо. По умолчанию, вставка делается в кон-
      це коллекции при вызове atInsert(count,item);

           См. также: TNSCollection::atInsert


      lastThat      void *lastThat(ccTestFunc Test,void *arg);
      --------
           lastThat применяет булевскую функцию *Test со списком  аргу-
      ментов,  заданным  в  arg  (может быть пустым) к каждому элементу
      коллекции,  начиная с последнего элемента,  и просматривает их  в
      обратном порядке до тех пор, пока *Test не вернет значение "Исти-
      на".  Результатом является указатель элемента, для которого *Test
      возвращает  значение  True,  или  0,  если *Test вернула значение
      False для всех элементов. Тип метода ccTestFunc определяется сле-
      дующим образом:

           typedef Boolean (*ccTestFunc) (void *, void *);

           Первый аргумент  указателя  функции *Test просматривает кол-
      лекцию.  Второй аргумент *Test берется из  указателя  arg  метода
      lastThat, как показано в следующем примере:

           void *TNSCollection::lastThat( ccTestFunc Test, void *arg)
           {
             for( ccIndex i = 0; i < count; i-- )
                {
                 if( Test( items[i-1], arg ) == True )
                   return items[i-1];
                }
                return 0;
           }

           Помните, что защищенные поля items имеют тип void**, так что
      items[i] имеют тип void *.

           См. также: TNSCollection::firstThat, TNSCollection::forEach


      pack          void pack();
      ----
           Удаляет все  нулевые указатели в коллекции и перемещает эле-
      менты вверх, заполняя все интервалы.

           См. также: TNSCollection::remove, TNSCollection::removeAll


      remove        void remove(void *item);
      ------
           Удаляет элемент, заданный item, из коллекции. Является экви-
      валентом atRemove(indexOf(item)).

           См. также: TNSCollection::atRemove, TNSCollection::IndexOf


      removeAll     void removeAll();
      ---------
           Удаляет все элементы из коллекции путем установки count в 0.

           См. также: TNSCollection::remove, TNSCollection::atRemove


      setLimit      virtual void setLimit(ccIndex aLimit);
      --------
           Расширяет или сжимает коллекцию путем изменения  выделенного
      размера на aLimit. Если aLimit меньше, чем count, он устанавлива-
      ется   в   значение   count,   а   если   aLimit   больше,    чем
      maxCollectionSize,    то    он    устанавливается    в   значение
      maxCollectionSize.  Если значение aLimit отлично от текущего зна-
      чения  limit,  то  размещается  новый массив из aLimit элементов,
      старый массив копируется в новый массив и  старый  массив  удаля-
      ется.

           См. также: TNSCollection::limit, TNSCollection::count, пере-
      менная maxCollectionSize







        TNSSortedCollection                                     TVOBJS.H
      -----------------------------------------------------------------

                    ┌───────────────┐           ┌──────────────┐
                    │ TNSCollection │           │ TStreamable  │
                    └───────┬───┬───┘           └───────┬──────┘
                            │   └───────────────────┐   │
                    ╔═══════╧═══════════╗       ┌───┴───┴──────┐
                    ║TNSSortedCollection║       │ TCollection  │
                    ╚═══════╤═══════════╝       └───────┬──────┘
                            │                           │
                            └──────┐ ┌──────────────────┘
                           ┌───────┴─┴──────────┐
                           │ TSortedCollection  │
                           └────────────────────┘

           Абстрактный класс  TNSSortedCollection  является специальным
      наследуемым классом из TNSCollection,  вводящим непотоковые  кол-
      лекции, отсортированные  по ключу (с или без дубликатов).  Не до-
      пускаются никакие экземпляры класса TNSSortedCollection.  Он  су-
      ществует  исключительно как основа для других стандартных или за-
      данных пользователем наследуемых классов.

           Сортировка производится  при  помощи   виртуального   метода
      compare,  который  вы  должны  переопределить (или перезадать как
      виртуальный). Иногда вам придется переопределять ее в наследуемых
      классах для поддержки определенного порядка в коллекции.  По мере
      добавления новых элементов,  они автоматически вставляются в  по-
      рядке, заданном compare. Элементы могут быть размещены при помощи
      бинарного (по умолчанию) метода search (также виртуального). Вир-
      туальный метод IndexOf, который возвращает указатель для compare,
      также может быть переопределен, если методу compare требуется до-
      полнительная информации.

           Для потоковых  отсортированных коллекций вы можете использо-
      вать класс TSortedCollection,  который является некоторым наслед-
      ником  от  классов TNSSortedCollection и TCollection (основой для
      которого служит класс TStreamable).  Кроме способности сохранения
      в потоке два класса TSortedCollection и TNSSortedCollection имеют
      одинаковые функциональные возможности.


                                    Поля

      duplicates    Boolean duplicates
      ----------
           Установлено в значение True,  если допускаются дублированные
      индексы;  в противном случае,  установлено в значение  False.  По
      умолчанию принимается False. Если duplicates имеет значение True,
      то методы search,  insert и  indexOf  работают  неодинаково  (см.
      описание этих методов).


                                   Методы

      constructor  TNSSortedCollection(ccIndex aLimit, ccIndex aDelta);
      -----------
           Вызывает конструктор  TCollection  для  установки   значений
      count, items и limit в 0; вызывает setLimit(aLimit) для установки
      предела коллекции в значение aLimit,  затем устанавливает delta в
      aDelta.   Заметьте,   что  тип  данных  ccIndex  задан  как  int.
      duplicates установлено в значение False. Если вы хотите допустить
      дублирование ключей, вы должны задать duplicates значение True.

           См. также: конструктор TCollection, поля TCollection


      compare       virual int compare(void *key1, void *key2) = 0;
      -------                                                 (частный)

           Метод compare  является виртуальным методом,  который должен
      быть переопределен во всех наследуемых классах. Он должен сравни-
      вать два значения ключа и возвращать результат в следующем виде:
                         ___________________________
                           < 0, если  key1 < key2
                             0, если  key1 = key2
                           > 0, если  key1 > key2
                         ___________________________

           key1 и key2 являются указателями, соответствующими сравнива-
      емым элементам коллекции,  выделенным методом keyOf. Метод search
      выполняет бинарный поиск по всем элементам коллекции,  при помощи
      метода compare, сравнивающего элементы.


      insert        virtual void insert(void *item);
      ------
           Если duplicates имеет значение False, insert работает следу-
      ющим  образом:  если  целевой элемент не найден в отсортированном
      наборе,  он вставляется в позицию допустимого индекса. Вызывается
      метод search для определения, существует ли элемент, если нет, то
      где его вставлять. insert выполняется следующим образом:

          {
             ccIndex i;

             if (search(keyOf(item), i) == 0)
                 atInsert(i,item);
          }

           Если duplicates имеет значение True,  то элемент вставляется
      перед любыми элементами (если они есть) с таким ключом.

           См. также: TNSSortedCollection::search,TCollection::atInsert


      search        virtual Boolean search(void *key, ccIndex& index);
      ------
           Возвращает значение True,  если элемент,  идентифицированный
      по key,  найден в отсортированной коллекции. Если элемент найден,
      index устанавливается в значение найденного индекса;  в противном
      случае, index устанавливается в значение индекса, где элемент бу-
      дет помещен в случае,  если он будет вставляться.  Заметьте,  что
      если duplicates  имеет  значение  True  и  ключи  продублированы,
      search будет искать первый соответствующий образцу элемент.

           См. также: TNSSortedCollection::compare,
                      TNSSortedCollection::insert






        TObject                                                  TVOBJ.H
      -----------------------------------------------------------------

                                ╔═══════════╗
                                ║  TObject  ║
                                ╚╤═══╤═╤═╤═╤╝
                       ┌─────────┘   │ │ │ └─────────┐
               ┌───────┴───────┐     │ │ │   ┌───────┴───────┐
               │  TCollection  │     │ │ │   │ TResourceFile │
               └───────────────┘     │ │ │   └───────────────┘
                                     │ │ └──────────┐
                                     │ │    ┌───────┴───────┐
                                     │ │    │ TStringList   │
                                     │ │    └───────────────┘
                       ┌─────────────┘ └─────────────┐
               ┌───────┴───────┐             ┌───────┴───────┐
               │ TStrListMaster│             │ TView         │
               └───────────────┘             └───────────────┘

           TObject представляет собой вершину иерархии большинства объ-
      ектов Turbo Vision.  Как базовый класс,  он не имеет родительских
      классов, но  имеет  большое  число  потомков.  Фактически,  кроме
      TPoint  и  TRect  (и различных классов и структур инициализации и
      управления потоками) все стандартные классы Turbo Vosion являются
      в итоге производными от TObject.

                                   Методы

      constructor   virtual ~TObject();
      -----------
           Выполняет необходимую  очистку  памяти и располагает динами-
      ческие объекты.


      destroy       static void destroy( TObject *ob );
      -------
           Во всех случаях, когда вы хотите удалить объект (ob) наслед-
      ник класса TObject (т.е. любой объект, созданный оператором new),
      вызывайте  метод destroy.  Метод destroy прекращает существование
      объекта, аккуратно освобождая занимаемую им  память.  Используйте
      этот метод вместо оператора С++ delete. Например:

           TDialog *dlg = new TDialog(...);
           //delete dlg;                //Так не делайте
           destroy( dlg );              //Делайте таким образом

           См. также: глава 6, "Разработка надежных программ"


      shutDown      virtual void shutDown();
      --------
           Используется только TObject::destroy,  для проверки правиль-
      ности удаления наследуемых и зависимых объектов. shutDown переоп-
      ределяется во многих классах, для обеспечения правильного задания
      зависимых полей, при вызове метода destroy.

           См. также: глава 6, "Разработка надежных программ"







        TPalette                                                 VIEWS.H
      -----------------------------------------------------------------

                          ╔══════════════╗
                          ║  TPalette    ║
                          ╚══════════════╝

           TPalette является простым классом, используемым для создания
      и обработки массивов палитры. Хотя палитры являются массивами ти-
      па char и часто указываются как строки,  они не являются строками
      заканчивающимися нулевым  символом,  как  это принято в языке Си.
      Фактически,  в палитре может  присутствовать  0-й  байт.  Поэтому
      обычные строковые функции Си использоваться не могут. Первый байт
      строки палитры содержит ее длину (без учета самого  первого  бай-
      та). Каждая основной отображаемый объект имеет стандартную палит-
      ру,  которая определяет (путем индексации в ее собственной палит-
      ре) обычные цвета, назначенные различным частям отображаемых объ-
      ектов, таким как прямоугольные области,  рамки,  кнопкам, текст и
      т.д.  Для  получения более подробной информации смотрите главу 4,
      "Отображаемые объекты".

                                   Методы

      constructor   TPalette( const char *d, ushort len );
      -----------   TPalette( const TPalette& tp );

           Первая форма создает объект TPalette со строкой d  и  длиной
      len. Внутреннее поле data устанавливается с len в его первом бай-
      те,  за ним следует массив d. Вторая форма создает новую палитру,
      копируя палитру tp.


      destructor    ~TPalette();
      ----------
           Уничтожает палитру.


      operator =    TPalette& operator = ( const TPalette& tp );
      ----------
           Оператор p = tp; копирует палитру tp в палитру p.


      operator []   char& operator[] ( int index );
      -----------
           Оператор нижнего уровня возвращает символ в позиции index.







        TParamText                                             DIALOGS.H
      -----------------------------------------------------------------

                          ╔══════════════╗
                          ║  TParamText  ║
                          ╚══════════════╝

           TParamText является   наследником   класса  TStaticText.  Он
      использует параметризованные текстовые строки для форматного  вы-
      вода, применяя функцию stdio - vsprintf.


                                    Поля

      paramCount    short paramCount;
      ----------
           paramCount указывает  число   параметров,   содержащихся   в
      paramList.

           См. также: TParamText::paramList


      paramList     void *paramList
      ---------
           paramList - это указатель, обычно указывающий на массив (или
      структуру)  указателей  или  значений  типа long,  которые должны
      использоваться как параметры форматирования текстовой строки.


                                   Методы

      constructor     TParamText(const TRect& bounds, const char *aText,
      -----------                int aParamCount);

           Создает и инициализирует статический текстовый объект, вызы-
      вая метод TStaticText(bounds,  aText). aText может содержать спе-
      цификаторы формата printf (в виде %[-][nnn]X),  которые будут за-
      менены  параметрами,  переданными  во время выполнения.  Параметр
      count, переданный в aParamCount, присваивается полю paramCount.


      constructor   TParamText( StreamableInit streamableInit)
      -----------                                         (защищенный)


           Каждый потоковый класс требует "построителя" для распределе-
      ния памяти для его объектов вместе с инициализированными указате-
      лями  виртуальной  таблицы.  Это достигается путем вызова функции
      элемента constructor с аргументом типа  StreamableInit.  Смотрите
      также Главу 8.

          См. также: TStaticText::TStaticText, vsprintf (stdio.h)


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      dataSize      virtual ushort dataSize();
      --------
           Возвращает размер данных, необходимых параметрам объекта.


      getText       virtual void getText(char *s);
      -------
           Создает форматированную строку текста в s,  осуществляя объ-
      единение параметров, заданных в paramList в текстовую строку text
      с помощью вызова vsprintf(s, text, paramList). Если text пуст, *s
      устанавливается в EOS.


      read          virtual void *read( ipstream& is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      setData       virtual void setData(void *rec);
      -------
           Устанавливает paramList в значение *rec.

      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Некоторые выполняемые функции относятся к классу TParamText,
      но не являются методами.


                                   Палитра

           Объекты TParamText   используют   палитру   (по   умолчанию)
      cpStaticText для отображения заданного  значения  в  6-й  элемент
      стандартной палитры прикладной программы.

                                     1
                                   ╔═══╗
                  cpStaticText     ║0x6║
                                   ╚═╤═╝
                         Текст  ─────┘







        TPoint                                                 OBJECTS.H
      -----------------------------------------------------------------


                               ╔══════════╗
                               ║  TPoint  ║
                               ╚══════════╝

           TPoint - это класс, определяющий точки на экране, с несколь-
      кими переопределяемыми операторами, служащими для манипулирования
      координатами точки.


                                    Поля

      x             int x;
      --
           x - позиция (колонка) точки на экране.


      y             int y;
      --
           y - позиция (строка) точки на экране.


                                   Методы

      operator +=   TPoint& operator+=(const TPoint& adder);
      -----------
           Увеличивает значение  x  при  помощи  adder.x и y при помощи
      adder.y. Возвращает *this.


      operator -=   TPoint& operator-=(const TPoint& subber);
      -----------
           Уменьшает значение  x  при  помощи  adder.x  и  y при помощи
      adder.y. Возвращает *this.


                            Дружественные методы

      operator-    friend TPoint& operator-(const TPoint& one,
      ---------                             const TPoint& two);

           Вычитает координату two из координаты one. Устанавливает x в
      значение (one.x - two.x) и y - в значение (one.y - two.y).  Аргу-
      менты one и two, конечно, не меняются. Возвращает *this.


      operator+    friend TPoint& operator+(const TPoint& one,
      ---------                             const TPoint& two);

           Прибавляет координату two к координате one.  Устанавливает x
      в значение (one.x | two.x) и y - в значение (one.y | two.y).  Ар-
      гументы one и two, конечно, не меняются. Возвращает *this.


      operator==    friend int operastor=(const TPoint& one,
      ----------                          const Tpoint& two);

           Возвращает значение True,  если координаты точки one  и  two
      одинаковы (т.е.,  если one.x==two.x && one.y==two.y). В противном
      случае возвращается False.


      operator!=    friend int operastor!=(const TPoint& one,
      ----------                           const Tpoint& two);

           Возвращает значение True (ненулевое значение),  если коорди-
      наты точки  one  и  two  различны  (т.е.,  если  one.x!=two.x  ||
      one.y!=two.y). В противном случае возвращается False (0).


                           Дополнительные функции

           Некоторые выполняемые функции относятся к классу TPoint,  но
      не являются методами.







        TPReadObjects                                         TOBJSTRM.H
      -----------------------------------------------------------------


                          ┌───────────────────────┐
                          │  TNSSortedCollection  │
                          └──────────┬────────────┘
                                     │
                             ╔═══════╧═══════╗
                             ║ TPReadObjects ║
                             ╚═══════════════╝


           Класс TPReadObjects (вместе с TPWrittenObjects) решает слож-
      ную  проблему идентификации,  при записи и чтении объектов в и из
      потоков,  при помощи указателей.  Этот класс содержит базу данных
      всех объектов,  которые были считаны из текущего потока объектов.
      Его использует ipstream,  при считывании указателя из потока, для
      определения  наличия  других указателей на этот объект.  По этому
      механизму, если ptr1 и ptr2 указывают на один потоковый объект, и
      вы записываете оба указателя в opstream,  сохраняется только одна
      копия объекта.  Когда вы собираетесь считать обратно  из  потока,
      создается только одна копия *ptr1, и оба ptr1 и ptr2 все еще ука-
      зывают на нее.


                                   Методы

      constructor   TPReadObjects();
      -----------
           Этот внутренний  конструктор  создает  непотоковую коллекцию
      путем обращения к основному конструктору TNSSortedCollection.  Он
      доступен только при помощи методов и дружественных методов.

           См. также: TNSSortedCollection::TNSSortedCollection

      destructor    ~TPReadObjects();
      ----------
           Устанавливает limit  коллекции  в значение 0 без уничтожения
      коллекции (т.к. поле shouldDelete установлено в значение False).

           См. также: TNSSortedCollection::TNSSortedCollection,
                      TNSSortedCollection::shouldDelete


                            Дружественные классы

           Класс ipstream является дружественным классом TPReadObjects,
      так  что  все  его методы имеют доступ ко внутренним полям класса
      TPReadObjects.






        TProgInit                                                  APP.H
      -----------------------------------------------------------------

                 ┌────────────┐            ╔════════════╗
                 │  TGroup    │            ║ TProgInit  ║
                 └──────┬─────┘            ╚════╤═══════╝
                        └──────┐      ┌─────────┘
                             ┌─┴──────┴─┐
                             │ TProgram │
                             └──────────┘


           TProgInit является  основным  виртуальным классом для класса
      TProgram.  Конструктор  TProgram  вызывает  основной  конструктор
      TProgInit, передавая ему адреса трех функций инициализации, кото-
      рые создают строку состояния,  прямоугольные области меню и рабо-
      чую   область.   Смотрите   описание   конструкторов  TProgram  и
      TApplication.


                                   Методы

      constructor   TProgInit(TStatusLine *(*cStatusLine)( TRect r ),
      -----------             TMenuBar *(*cMenuBar)( TRect r ),
                              TDeskTop *(*cDeskTop)( TRect r ) );

           Смотрите описание конструктора TProgram.


      createDeskTop  TDeskTop *(*createDeskTop)(TRect r );(защищенный)
      -------------
           Создает рабочую область заданного размера.

           См. также: TApplication::TApplication


      createMenuBar   TMenuBar *(*createMenuBar)( TRect r );
      -------------                                        (защищенный)
           Создает строку меню заданного размера.

           См. также: TApplication::TApplication


      createStatusLine   TStatusLine *(*createStatusLine)( TRect r );
      ----------------
           Создает строку состояния заданного размера.

           См. также: TApplication::TApplication


      createMenuBar   TMenuBar *(*createMenuBar)( TRect r );
      -------------                                        (защищенный)
           Создает строку меню заданного размера.

           См. также: TApplication::TApplication


      createStatusLine   TStatusLine *(*createStatusLine)( TRect r );
      ----------------
           Создает строку состояния заданного размера.

           См. также: TApplication::TApplication







        TProgram                                                   APP.H
      -----------------------------------------------------------------

                        ┌─────────┐          ┌──────────┐
                        │ TGroup  │          │ TProInit │
                        └────┬────┘          └────┬─────┘
                             └───────┐  ┌─────────┘
                               ╔═════╧══╧═════╗
                               ║   TProgram   ║
                               ╚══════╤═══════╝
                               ┌──────┴───────┐
                               │ TApplication │
                               └──────────────┘

           TProgram обеспечивает базовую заготовку для всех стандартных
      приложений, написанных  с использованием Turbo Vision.  Все такие
      программы  должны  порождаться  от  TProgram  или   его   потомка
      TApplication.  TApplication  отличается  от TProgram только стан-
      дартными конструктором и деструктором.  Оба класса поддерживаются
      для обеспечения большей гибкости при создании нестандартных прог-
      рамм.  В большинстве случаев ваша программа будет порождаться  от
      TApplication.

           Класс TProgram является наследником TGroup,  так что он дол-
      жен содержать объекты TDeskTop, TStatusLine и TMenuBar.


                                    Поля

      application   static TProgram *application;
      -----------
           Указатель на  текущую прикладную программу,  устанавливается
      значение this конструктором TProgInit.

          См. также: класс TProgInit


      appPalette    static int appPalette;
      ----------
           Индексирует стандартную палитру для этой прикладной програм-
      мы,  как установлено при помощи InitScreen.  TProgram::getPalette
      возвращает объект TPalette, соответствующий appPalette.

           См. также: раздел "Палитры" ниже, TProgram::getPalette


      deskTop       static DeskTop *deskTop;
      -------
           Указатель на текущий объект рабочей области, устанавливается
      при вызове createDeskTop в конструкторе TProgram.  Результирующий
      объект вставляется в группу TProgram.

           См. также: TProgInit::createDeskTop, TProgram::initDeskTop


      menuBar       static TMenuBar *menuBar;
      -------
           Указатель на текущий объект строки меню, устанавливается при
      вызове createMenuBar в конструкторе TProgram. Результирующий объ-
      ект вставляется в группу TProgram.

           См. также: TProgInit::createMenuBar, TProgram::initMenuBar


      statusLine    static TStatusLine *statusLine;
      ----------
           Указатель текущего объекта строки состояния, устанавливается
      при вызове createStatusLine в конструкторе TProgram. Результирую-
      щий объект вставляется в группу TProgram.

           См. также: TProgInit::createStatusLine,
                      TProgram::initStatusLine


                                   Методы

      constructor   TProgram();
      -----------
           Конструктор TProgram     вызывает    основной    конструктор
      TProgInit, передавая ему адреса трех начальных функций:

           TProgram::TProgram();
              TProgInit( &TProgram::initStatusLine,
                         &TProgram::initMenuBar, & TProgram::initDeskTop
                       ),
              ...

           Конструктор TProgInit создает строку состояния,  строку меню
      и рабочую область:

           TProgInit::TProgInit ( TStatusLine *(*cStatusLine)( TRect ),
                                 TMenuBar *(cMenuBar)( TRect ),
                                 TDeskTop *(cDeskTop)( TRect ) );
                    createStatusLine( cStatusLine ),
                    createMenuBar( cMenuBar ),
                    createDeskTop9 cDeskTop )
                    ...

           Если эти обращения были успешны, то три объекта включаются в
      группу TProgram. Статические указатели полей statusLine, menuBar,
      deskTop и application (=this) устанавливаются на эти новые объек-
      ты. Также выполняется конструктор TGroup для создания полноэкран-
      ного отображаемого объекта;  инициализируются буфер изображения и
      стандартные палитры; устанавливаются следующие флаги состояния:

          state = sfVisible  |  sfSelected  |  sfFocused  |  sfModal  |
                  sfExposed


      destructor    virtual ~Program();
      ----------
          Удаляет соответствующие объекты deskTop, menuBar и statusLine
      и устанавливает статическое поле application в 0.

           См. также: ~TGroup


      getEvent      virtual getEvent(TEvent& event);
      --------
           По умолчанию  метод TView::getEvent просто вызывает getEvent
      и, поскольку объекты TProgram (или TApplication) в конечном итоге
      являются  владельцем  любого  отображаемого объекта,  любой вызов
      getEvent будет приводить к TProgram::getEvent (если только  отоб-
      ражаемый объект не переопределит getEvent).

           TРrogram::getEvent  вначале   проверяет,   не   посылал   ли
      TProgram::putEvent событие (в статическом поле  TEvent  pending).
      Если да, то getEvent возвращает это событие. Если нет события, то
      getEvent вызывает getMouseEvent.  Если возвращается evNothing, то
      вызывается getKeyEvent.  Если оба возвращают evNothing, указывая,
      что   ввод    пользователя    недоступен,    getEvent    вызывает
      TProgram::idle,  чтобы запустить "фоновые" задачи, выполняемые во
      время ожидания прикладной программой ввода  от  пользователя.  До
      возврата  getEvent передает все события evKeyDown и evMouseDown в
      StatusLine для отображения в  соответствующие  evCommand  события
      (нажатия управляющих клавиш).

           См. также: TProgram::putEvent, getMouseEvent, getKeyEvent


      getPalette    virtualTPalette& getPalette() const;
      ----------
           Возвращает строку палитры,  заданную индексом палитры в ста-
      тическом  поле  appPalette.  TProgram  поддерживает  три палитры:
      apColor, apBlackWhite и apMonochrome. appPalette инициализируется
      TProgram::initScreen.

           См. также:TProgram::initScreen, AppPalette, константы apXXXX



      handleEvent   virutal handleEvent(TEvent& event);
      -----------
           Обрабатывает нажатия клавиш (события от клавиатуры) от Alt-1
      до Alt-9,  посылая событие evBroadcast со значением command, рав-
      ным  cmSelectWindowNum,  и  значением  infoInt  в диапазоне 1..9.
      TWindow::handleEvent реагирует на такие сообщения, выбирая окно с
      данным номером.

           Обрабатывает событие evCommand со значением command,  равным
      cmQuit, вызывая endModal(cmQuit), что приводит к завершению прик-
      ладной программы.

           TProgram::handle почти  всегда переопределяется для введения
      обработки команд, специфичных для вашей прикладной программы.

          См. также: TGroup::handleEvent


      idle          virtual void idle();
      ----
           idle вызывается из TProgram::getEvent, когда очередь событий
      пуста,  позволяя программе выполнять фоновые задачи при  ожидании
      ввода от пользователя.

           По умолчанию   TProgram::idle  вызывает  statusLine->update,
      чтобы разрешить строке состояния обновлять себя в соответствии  с
      текущим контекстом подсказки.  Затем, если набор команд изменился
      после последнего вызова TProgram::idle, посылается evBroadcast со
      значением  command,  равным cmCommandSetChanged,  чтобы позволить
      отображаемому объекту,  который зависит от этого  набора  команд,
      разрешить или запретить себя.

           Если вы переопределяете idle, то убедитесь, что вы вызываете
      наследуемый метод idle.  Убедитесь также, что задачи, выполняемые
      методом  idle,  не  занимают  слишком  много времени в программе,
      поскольку это будет блокировать ввод пользователя и сильно замед-
      лит время реакции.


      initDeskTop   static TDeskTop *initDeskTop(TRect);
      -----------
           Адрес этого метода передается в конструктор TProgInit, кото-
      рый  создает объект TDeskTop для прикладной программы и сохраняет
      указатель  на  него  в  глобальной  переменной   deskTop.   Метод
      initDeskTop  никогда  не должен вызываться напрямую.  initDeskTop
      часто переопределяется,  для приписывания значения  определенного
      пользователем   TDeskTop,   вместо  пустого  стандартного  метода
      TDeskTop.

           См. также: TProgram::TProgram, TDeskTop


      initMenuBar   static TMenuBar *initMenuBar(TRect);
      -----------
           Адрес этого метода передается в конструктор TProgInit, кото-
      рый создает объект TMenuBar для программы и  сохраняет  указатель
      на него в глобальной переменной menuBar. Метод initMenuBar никог-
      да не должен вызываться непосредственно.  Вместо пустого TMenuBar
      initMenuBar почти всегда переопределяется экземпляром, определен-
      ным пользователем.

           См. также: TProgram::TProgram, TMenuBar


      initScreen    virtual void initScreen();
      ----------
           Вызывается из TProgram::TProgram  и  TProgram::setScreenMode
      каждый раз,  когда  режим экрана инициализируется или изменяется.
      Это метод, который действительно выполняет обновление и настройку
      переменных, определяющих режимом экрана  для  вычисления  размера
      "тени", маркеров и палитры прикладной программы.

           См. также: TProgram::TProgram, TProgram::setScreenMode


      initStatusLine  static TStausLine *initStatusLine(TRect);
      --------------
           Адрес этого метода передается конструктору TProgInit,  кото-
      рый  создает  объект TStatusLine для программы и сохраняет указа-
      тель на него в глобальной переменной в statusLine. initStatusLine
      никогда не должен вызываться прямым образом. Вместо использования
      TStatusLine по умолчанию initStatusLine почти всегда  переопреде-
      ляется экземпляром TStatusLine, определенным пользователем.

           См. также: TProgram::TProgram, TStatusLine


      outOfMemory   virtual void outOfMemory();
      -----------
           Метод outOfMemory вызывается из TProgram::validView для  оп-
      ределения  того,  что lowMemory имеет значение True.  outOfMemory
      должен сообщать пользователю,  что недостаточно памяти для выпол-
      нения операции.  Например,  с использованием метода messageBox из
      модуля STDDLG:

               virtual void TMyApp::outOfMemory
               {
                 messageBox('Not enough memory to complete operation.',
                            0, mfError + mfOKButton);
               }

           См. также: TProgram::validView, lowMemory


      putEvent      virtual void putEvent(TEvent& event);
      --------
           По умолчанию  TView::putEvent просто вызывает метод putEvent
      своего владельца и,  поскольку объект TProgram (или TApplication)
      в  конечном счете является владельцем любого отображаемого объек-
      та,  каждый вызов putEvent будет приводить  к  TProgram::putEvent
      (если только отображаемый объект не переопределен putEvent).

           Метод Program::putEvent  сохраняет  копию  структуры event в
      глобальной  переменной  pending,  и  следующий  вызов  TProgram::
      GetEvent будет возвращать эту копию.

           См. также: TProgram::getEvent, TView::putEvent


      run           virtual void run();
      ---
           Выполняет TProgram,  вызывая метод execute (который наследу-
      ется от TGroup).

           См. также: TGroup::execute



      setScreenMode  void setScreenMode(ushort mode);
      -------------
           Устанавливает режим экрана.  mode - одна из констант smCO80,
      smBW80  или  smMono с дополнительным smFont8x8 для выбора 43- или
      50-строчного режима адаптеров EGA или VGA. setScreenMode "скрыва-
      ет" курсор "мыши", вызывает setVideoMode для изменения режима эк-
      рана, устанавливает экранный буфер, инициализирует переменные ре-
      жима  экрана,  вызывает changeBounds с новыми границами экрана и,
      наконец, отображает курсор "мыши".

           См. также: TProgram::setVideoMode, константы smXXXX


      shutDown      virtual void shutDown();
      --------
           Используется методом TObject::destroy для подтверждения пра-
      вильного  удаления  наследуемых  и  связанных   объектов.   Метод
      shutDown  переопределяется  во  многих  классах для подтверждения
      правильной установки полей при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"


      validView     TView *validView(TView *p);
      ---------
           Проверяет допустимость *p, вновь созданных отображаемых объ-
      ектов,  возвращая p, если объект допустим и 0 - если нет. Во-пер-
      вых, если p имеет значение 0, возвращается значение 0. Во-вторых,
      если lowMemory равно True,  то при вызове validView  отображаемый
      объект,  заданный в p, удаляется, вызывается метод outOfMemory, и
      возвращается значение 0. В-третьих, если вызов P->Valid() возвра-
      щает значение False,  то p удаляется,  и возвращается значение 0.
      Иначе отображаемый объект считается  допустимым,  и  возвращается
      указатель на этот объект p.

           validView часто используется для проверки допустимости ново-
      го отображаемого объекта до вставки его в группу владельца.  Нап-
      ример,  следующий оператор показывает типичную последовательность
      создания, проверки и включения  нового  окна  в  рабочую  область
      (TProgram::validView  и  TGroup::insert  знают,  как игнорировать
      возможные нулевые указатели, возникающие в результате ошибок).

           deskTop->insert(cvlidView(new(TMyWindow));

           См. также: lowMemory, TProgram::outOfMemory, методы valid




                                    Палитра

           Палитра для объекта прикладной программы управляет  конечным
      отображением  цвета  всех  отображаемых  объектов программы.  Все
      отображения других палитр приводят к выбору  элемента  в  палитре
      программы, которая задает атрибуты текста.

           Первый элемент  используется  в TBackground для цветов фона.
      Элементы со 2 по 7 используются меню и строкой состояния.

                      1   2   3   4   5   6   7
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x71│x70│x78│x74│x20│x28│x24║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x70│x70│x78│x7F│x07│x07│x0F║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x70│x07│x07│x0F│x70│x70│x70║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │
       Фон        ────┘   │   │   │   │   │   └── Выбор сокращения
       Нормальный текст ──┘   │   │   │   └────── Недоступный выбор
       Недоступный текст ─────┘   │   └────────── Нормальный выбор
       Текст сокращения ──────────┘


           Элементы с 8 по 15 используются голубыми окнами.

                      8   9   10  11  12  13  14  15
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x17│x1F│x1A│x31│x31│x1E│x71│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x07│x0F│x07│x70│x70│x07│x70│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x07│x0F│x07│x70│x70│x07│x70│x00║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │   │
       Рамка пассивна ┘   │   │   │   │   │   │   └─ Зарезервировано
       Рамка активна ─────┘   │   │   │   │   └─ Выделенный текст
                              │   │   │   │      для прокрутки
       Кнопка рамки ──────────┘   │   │   └───── Нормальный текст
                                  │   │          для прокрутки
       Страница прокрутки ────────┘   └───────── Зарезервировано



           Элементы с 16 по 23 используются бирюзовыми окнами.

                      16  17  18  19  20  21  22  23
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x37│x3F│x3A│x13│x13│x3E│x21│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x07│x0F│x07│x70│x70│x07│x70│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x07│x0F│x07│x70│x70│x07│x70│x00║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │   │
       Рамка пассивна ┘   │   │   │   │   │   │   └── Зарезервировано
       Рамка активна ─────┘   │   │   │   │   └─ Выделенный текст
                              │   │   │   │      для прокрутки
       Кнопка рамки ──────────┘   │   │   └──── Нормальный текст
                                  │   │         для прокрутки
       Страница прокрутки ────────┘   └──────── Зарезервировано



           Элементы с 24 по 31 используются серыми окнами.

                      24  25  26  27  28  29  30  31
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x70│x7F│x7A│x13│x13│x70│x7F│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x70│x7F│x7F│x70│x07│x70│x07│x00║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x70│x70│x70│x07│x07│x70│x07│x00║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │   │
       Рамка пассивна ┘   │   │   │   │   │   │   └── Зарезервировано
       Рамка активна ─────┘   │   │   │   │   └─ Выделенный текст
                              │   │   │   │      для прокрутки
       Кнопка рамки ──────────┘   │   │   └──── Нормальный текст
                                  │   │         для прокрутки
       Страница прокрутки ────────┘   └──────── Зарезервировано


           Элементы с 32 по 63 используются диалоговыми объектами.  См.
      TDialog для отдельных элементов.

                      32  33  34  35  36  37  38  39  40
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x70│x7F│x7A│x13│x13│x70│x70│x7F│x7E║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x70│x7F│x7F│x70│x07│x70│x70│x7F│x7F║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x70│x70│x70│x07│x07│x70│x70│x70│x0F║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │   │   │
       Рамка пассивна ┘   │   │   │   │   │   │   │   └── Сокращение
                          │   │   │   │   │   │   │       метки
       Рамка активна ─────┘   │   │   │   │   │   └─ Подсвеченная
                              │   │   │   │   │      метка
       Кнопка рамки ──────────┘   │   │   │   └───── Нормальная
                                  │   │   │          метка
       Страница прокрутки  ───────┘   │   └───────── Статический текст
       Элементы управления ───────────┘
       прокруткой


                      41  42  43  44  45  46  47  48  49
                    ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor       ║x20│x2B│x2F│x78│x2E│x70│x30│x3F│x3E║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite  ║x07│x0F│x0F│x78│x0F│x78│x07│x0F│x0F║
                    ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                    ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome  ║x07│x07│x0F│x70│x0F│x70│x07│x0F│x0F║
                    ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                      │   │   │   │   │   │   │   │   │
       Нормальная ────┘   │   │   │   │   │   │   │   └── Короткий
       кнопка             │   │   │   │   │   │   │      кластер
       Кнопка по   ───────┘   │   │   │   │   │   └───── Выделенный
       умолчанию              │   │   │   │   │          кластер
       Выделенная кнопка   ───┘   │   │   │   └───────── Нормальный
                                  │   │   │             кластер
       Запрещенная кнопка   ──────┘   │   └──────────── Тень
                                      │                 кнопки
       Сокращение кнопки   ───────────┘



                            50  51  52  53  54  55  56
                          ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor             ║x1F│x2F│x1A│x20│x72│x31│x31║
                          ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                          ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite        ║x0F│x70│x0F│x07│x70│x70│x70║
                          ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                          ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome        ║x07│x70│x07│x07│x70│x07│x07║
                          ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                            │   │   │   │   │   │   │
       Обычная строка ввода ┘   │   │   │   │   │   └─ Элементы
                                │   │   │   │   │      управления
                                │   │   │   │   │      прокруткой окна
                                │   │   │   │   │      протокола
       Выделенная строка ввода ─┘   │   │   │   └───── Страница
                                    │   │   │          прокрутки
                                    │   │   │          окна протокола
        Кнопки строки ввода ────────┘   │   └───────── Стороны
        Кнопка протокола ───────────────┘              протокола



                            57  58  59  60  61  62  63
                          ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpColor             ║x30│x2F│x3E│x31│x13│x00│x00║
                          ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                          ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBlackWhite        ║x07│x70│x0F│x07│x07│x00│x00║
                          ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                          ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpMonochrome        ║x07│x70│x0F│x07│x07│x00│x00║
                          ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                            │   │   │   │   │   │   │
       Обычный элемент   ───┘   │   │   │   │   │   └── Зарезервировано
       списка                   │   │   │   │   │
       Активный элемент  ───────┘   │   │   │   └────── Зарезервировано
       списка                       │   │   │
       Выделенный просмотр списка ──┘   │   └────────── Информационная
       Разделитель просмотра списка ────┘               область








        TPWObj                                                TOBJSTRM.H
      -----------------------------------------------------------------

                             ╔═══════════════╗
                             ║    TPWObj     ║
                             ╚═══════════════╝

           TPWObj используется внутри класса TPWrittenObjects.


                            Дружественные классы

           Класс TPWrittenObjects является дружественным классу TPWObj,
      так  что  все  его  методы могут иметь доступ ко внутренним полям
      класса TPWObj.






        TPWrittenObjects                                      TOBJSTRM.H
      -----------------------------------------------------------------

                           ┌────────────────────┐
                           │TNSSortedCollection │
                           └────────┬───────────┘
                           ╔════════╧══════════╗
                           ║ TPWrittenObjects  ║
                           ╚═══════════════════╝

           TPWrittenObjects (вместе  с  TPReadObjects)  решает  сложную
      проблему идентификации, возникающих, при записи и чтении объектов
      в и из потоков,  при помощи указателей.  Этот класс создает  базу
      данных всех объектов,  которые были записаны в текущий поток объ-
      ектов. Она используется opstream, когда он записывает указатель в
      поток:  он должен определить, был ли помеченный указателем объект
      уже записан в поток. При помощи этого механизма, если ptr1 и ptr2
      указывают на один и тот же потоковый объект, и вы записываете оба
      указателя в opstream, сохраняется только одна копия объекта. Ког-
      да  вы  снова производите считывание из потока,  создается только
      одна копия *ptr1, и оба ptr1 и ptr2 указывают на нее.


                                   Методы

      constructor   TPWrittenObjects();                      private
      -----------
           Этот внутренний  конструктор  создает  непотоковую коллекцию
      путем вызова основного конструктора TNSSortedCollection. Он явля-
      ется доступным только для методов и дружественных методов.

           См. также: TNSSortedCollection::TNSSortedCollection


      destructor    ~TPWrittenObjects();                    private
      ----------
           Устанавливает значение limit коллекции в 0 без ее  уничтоже-
      ния (т.к. поле shouldDelete имеет значение False).

           См. также: TNSCollection::~TNSCollection,
                      TNSCollection::shouldDelete


                            Дружественные классы

           Класс opstream  является  дружественным  классу   TPWritten-
      Objects,  так что все его методы могут иметь доступ ко внутренним
      полям TPWrittenObjects.








        TRadioButtons                                          DIALOGS.H
      -----------------------------------------------------------------

                               ┌────────────┐
                               │  TCluster  │
                               └─────┬──────┘
                                     │
                             ╔═══════╧═══════╗
                             ║ TRadioButtons ║
                             ╚═══════════════╝

           Объекты TRadioButtons - это кластеры,  содержащие до  16,380
      (maxCollectiomSize) элементов управления,  из которых в любой мо-
      мент времени может быть выделена только одна кнопка  с  зависимой
      фиксацией. Выбор невыделенной кнопки будет автоматически освобож-
      дать предварительно выделенную кнопку. Большинство функций насле-
      дуются от TCluster,  включая конструктор и деструктор.  Зависимые
      кнопки часто связаны с объектом TLabel.

           TRadioButtons интерпретирует   наследуемое  поле  TCluster::
      value как номер "нажатой"  кнопки,  с  номером  первой  кнопки  в
      кластере, равным 0.

                                   Методы

      constructor   TRadioButtons( StreamableInit );
      -----------
           Каждому потоковому  классу необходим "построитель" для расп-
      ределения памяти для его объектов  вместе  с  инициализированными
      указателями  виртуальной  таблицы.  Это  достигается путем вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      draw          virtual void draw();
      ----
           Отображает кнопки как символы '[ ]',  заключенные в  прямоу-
      гольник.


      mark          virtual Boolean mark(int item);
      ----
           Возвращает значение True, если item = value, т.е. если кноп-
      ка с номером item представлена текущим значением поля value ("на-
      жатая" кнопка).

           См. также: TCluster::value, TCluster::mark


      movedTo       virtual void movedTo(int item);
      -------
           Присваивает value значение item.

           См. также: TCluster::movedTo, TRadioButtons::mark


      press         virtual void press(int item);
      -----
           Присваивает value значение item.  Вызывается  при  "нажатии"
      кнопки с номером item.


      setData       virtusl void setData(void *rec);
      -------
           Вызывает TCluster::setData для установки поля  value,  затем
      устанавливает поле sel равным value, поскольку вначале выделенный
      элемент - это "нажатая" кнопка.

           См. также: TCluster::setData


                           Дополнительные функции

           Определенные выполняемые функции связаны с TRadioButtons, но
      не являются методами.

                                   Палитра

           Объекты TRadioButtons используют cpCluster - палитру, назна-
      ченную  по умолчанию для всех кластерных объектов для отображения
      заданных значений в 16 - 18 элементы палитры стандартного  диало-
      га.

                           1    2    3    4
                        ╔════╤════╤════╤════╗
           cpCluster    ║x10 │x11 │x12 │x12 ║
                        ╚══╤═╧══╤═╧══╤═╧══╤═╝
                           │    │    │    │
          Нормальный текст ┘    │    │    └─── Выделенное сокращение
          Выделенный текст ─────┘    └──────── Обычное сокращение







        TRect                                                  OBJECTS.H
      -----------------------------------------------------------------

                                 ╔═══════╗
                                 ║ TRect ║
                                 ╚═══════╝

           Объекты класса  TRect представляют два объекта TPoint (верх-
      ний левый  и  нижний  правый углы прямоугольной области) вместе с
      несколькими встроенными методами для обработки прямоугольных  об-
      ластей. Операторы  == и != перезагружаются для поддержки операции
      сравнения двух прямоугольных областей естественным образом. Класс
      TPoint имеет поля x и y, координаты точек экрана.


                                    Поля

      a             TPoint a;
      --
           a - это точка, определяющая левый верхний угол прямоугольной
      области на экране.

          См. также: TPoint


      b             TPoint b;
      --
           b - это точка,  определяющая правый нижний угол  прямоуголь-
      ной области на экране.

          См. также: TPoint


                                   Методы

      constructor   TRect(int ax, int ay, int bx, int by);
      -----------   TRect(TPoint topleft, TPoiny bottomright);

           Создает объект TRect и инициализирует его значениями a.x=ax;
      a.y=ay и т.д. Или наоборот, вы можете построить прямоугольник пу-
      тем задания двух аргументов TPoint;  в этом  случае,  a  задается
      значением topleft, а b - значением bottomright.


      constructor   TRect();
      -----------
           Позволяет создание  неинициализированного  объекта  TRect  с
      использованием метода new без аргументов.


      contains      Boolean comtains(const TPoint& p) const;
      --------
           Возвращает значение True,  если прямоугольная область (вклю-
      чая ее границы) содержит точку p.


      grow          void grow(int aDX, int aDY);
      ----
           Изменяет размер прямоугольника, вычитая aDX из a.x, добавляя
      aDX к b.x, вычитая aDY из a.y и добавляя aDY к b.y.


      intersect     void intersect(const TRect& r);
      ---------
           Изменяет положение  и  размер  прямоугольной  области до об-
      ласти, определенной пересечением текущей прямоугольной области  с
      r.


      isEmpty       Boolean isEmpty();
      -------
           Возвращает значение True, если прямоугольная область пустая,
      т.е.  не содержит внутреннего символьного наполнения; в противном
      случае,  возвращает  значение  False.  "Пустой"   означает,   что
      (a.x>=b.x | | a.y>=b.y).


      move          void move(int aDX, int aDY);
      ----
           Перемещает прямоугольную область, путем добавления aDX к a.x
      и b.x и добавления aDY к a.y и b.y.


      operator ==   Boolean operator == (const TRect& r) const;
      -----------
           Возвращает значение True, если r является аналогичной прямо-
      угольной области; в противном случае, возвращает значение False.


      operator !=   Boolean operator != (const TRect& r) const;
      -----------
           Возвращает значение  True,  если  r  не является аналогичной
      прямоугольной области;  в противном случае,  возвращает  значение
      False.


      Union         void Union(const TRect& r);
      -----
           Изменяет прямоугольную  область  до  его объединения с самим
      собой или с прямоугольной области r;  т.е. до наименьшего прямоу-
      гольной области, содержащей этот объект и r.


                           Дополнительные функции

           Определенные функции  относятся к классу TRect,  но не явля-
      ются методами.







        TResourceCollection                                   RESOURCE.H
      -----------------------------------------------------------------

                          ┌───────────────────┐
                          │ TStringCollection │
                          └────────┬──────────┘
                         ╔═════════╧═══════════╗
                         ║ TResourceCollection ║
                         ╚═════════════════════╝

           Объект TResourceCollection    является    наследуемым     от
      TStringCollection,  который  делает его отсортированной потоковой
      коллекцией.  Он используется с TResourceFile для реализации  кол-
      лекции ресурсов. Файл ресурсов - это поток, который индексируется
      ключевыми строками.  Каждый элемент ресурса указывает  на  объект
      типа TResourceItem, определенный следующим образом:

           struct TResourceItem
           {
             long pos;
             long size;
             char *key;
           };

           Поля поддерживают  позицию потока и размер элемента для эле-
      мента ресурса,  помеченного строкой key.  Переопределение методов
      TResourseCollection главным образом связано с обработкой дополни-
      тельных строк в его элементах.  TResourseCollection  используется
      внутри   объектов   TResourseFile  для  поддержки  индекса  файла
      ресурсов.

                                    Поля

      name          static const char * const name;
      ----
           Имя класса, используемое программой, управляющей потоком.


                                   Методы

      constructor    TResourceCollection( short aLimit, short aDelta );
      -----------
           Создает коллекцию ресурсов, имеющую внутренний размер aLimit
      и возможностью изменить размер, при помощи aDelta.


      constructor   TResourceCollection(StreamableInit streamableInit);
      -----------                                          (защищенный)

           Каждому потоковому  классу необходим "строитель" для распре-
      деления памяти для его объектов вместе с инициализированными ука-
      зателями   виртуальной  таблицы.  Это  достигается  путем  вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.

           См. также: TStringCollection::TStringCollection


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      freeItem      virtual void freeItem( void *item );
      --------
           Освобождает заданный элемент из коллекции путем  удаления  и
      ключа, и элемента.


      keyOf         virtual void *keyOf( void *item);
      -----
           Возвращает ключ заданного  элемента.  Применяется  следующим
      образом:

           void* TResourceCollection::keyOf( void *item )
           {
              return (TResourceItem *)item)->key;
           }


      read          virtual void *read( ipstream& is );
      ----
           Считывает из входного потока is в ts.

           См. также: TStreamableClass, TStreamable, ipstream


      readItem      void *TResourceCollection::readItem(ipstream& is);
      --------
           Вызывается для каждого элемента коллекции.  Вам может потре-
      боваться  переопределить  его  во  всех  классах,  производных от
      TCollection или TSortedCollection,  для  обеспечения  правильного
      считывания  элементов.  TSortedCollection  уже переопределил этот
      метод.

           См. также: TStreamableClass, TStreamable, ipstream


      write         virtual void write( opstream& os );
      -----
           Записывает ts в поток os.

           См. также: TStreamableClass, TStreamable, opstream


      writeItem     void TResourceCollection::writeItem( void *obj,
      ---------                               opstream& os );

           Вызывается для каждого элемента коллекции.  Вам может потре-
      боваться переопределить  его  во  всех  классах,  наследниках  от
      TCollection или TSortedCollection, для обеспечения правильной за-
      писи элементов. TSortedCollection уже переопределил этот метод.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции относятся к классу TResourceCollection,
      но не являются методами.








        TResourceFile                                        RESOURCE.H
      -----------------------------------------------------------------

                                ┌─────────┐
                                │ TObject │
                                └────┬────┘
                             ╔═══════╧═══════╗
                             ║ TResourceFile ║
                             ╚═══════════════╝

           Класс TResourseFile реализует поток (типа fpstream), который
      может индексироваться ключевыми строками.  Когда объекты сохраня-
      ются в файле ресурса, используя TResourseFile::put, задается клю-
      чевая  строка,  которая идентифицирует этот объект.  Объект может
      быть позже  получен  указанием  этой  ключевой  строки  в  вызове
      TResourseFile::get.

           Для обеспечения  быстрого и эффективного доступа к объектам,
      хранящимся в файле ресурса,  TResourseFile хранит ключевые строки
      в  отсортированной  коллекции  строк  (используя класс TResourse-
      Collection) вместе с позицией и размером данных этого  ресурса  в
      файле  ресурса.  Поле  index  указывает на соответствующий объект
      TResourceCollection, который является индексом файла ресурсов.

           Как и в случае ввода/вывода потоков,  классы всех  объектов,
      записываемых и читаемых из файла ресурсов, должны быть потоковыми
      и зарегистрированы (т.е.,  помечены программой, управляющей пото-
      ками - см. главу 8, "Объекты, взаимодействующие с потоками").


                                    Поля

      basePos       long basePos;
      -------
           Основная позиция потока (без учета начальной информации).

           См. также: fpstream


      index         TResourceCollection *index;
      -----
           Указатель на соответствующий объект TResourceCollection.

           См. также: TResourceCollection


      indexPos      long indexPos;
      --------
           Текущая позиция потока относительно основной позиции.


      modified      Boolean modified;
      --------
           Установлено в значение True, если файл ресурса был модифици-
      рован с момента последнего вызова flush; в противном случае, име-
      ет значение False.

           См. также: TResourceFile::flush, TResourceFile::put



      stream        fpstream *stream;
      ------
           Указатель на поток, связанный с этим файлом ресурса.

           См. также: fpstream


                                   Методы

      constructor   TResourceFile( fpstream *aStream );
      -----------
           Инициализирует файл ресурса, используя поток, заданный через
      aStream,  и устанавливает поле modified в значение False. К этому
      времени поток должен быть уже инициализирован. Например:

           TResourceFile * resFile = new TResourceFile(new fpstream
                                   ("MYAPP.RES",  ios::in | ios::out));

           Во время  инициализации конструктор TResourceFile ищет заго-
      ловок файла ресурсов в текущей позиции в потоке.  Если  заголовок
      не найден, конструктор полагает, что новый файл ресурса создается
      вместе с новым набором ресурсов.  Вас могут не интересовать  под-
      робности о заголовках, но опытные программисты могут быть заинте-
      ресованы  в  следующей  информации.  Структура  заголовка   файла
      ресурсов имеет вид:

           struct THeader
           {
               ushort signature;
               union
               {
                   Count_type count;
                   Info_type info;
               };
           };

           где Count_type:

           struct Count_type
           {
              ushort lastCount:
              ushort pageCount;
           };

           и Info_type:

           struct Info_type
           {
              ushort infoType;
              long infoSize;
           };

           signature содержит либо 0х5a4d,  либо 0x4246. Если signature
      - 0x5a4d,  то  используется  поле  Count_type  объединения;  если
      signature   -   0x4246,  то  используется  поле  Info_type.  Если
      конструктор видит  сигнатюру файла .EXE в текущей позиции потока,
      то он пропускает поток до конца файла .EXE,  а затем ищет там за-
      головок  файла  ресурса.  Также,  конструктор  будет пропускать и
      оверлейный файл, который был дополнен к файлу .EXE. Это означает,
      что  вы  можете добавить и ваш оверлейный файл и ваш файл ресурса
      (в любом порядке) в конец файла .EXE  вашей  программы.  В  любом
      случае, basePos и indexPos устанавливаются в правильные значения,
      допустимые для любых заголовков.

           См. также: ~TResourceFile


      destructor    ~TResourceFile();
      ----------
           Очищает файл ресурса,  используя TResourseFile::flush, затем
      удаляет поля index и stream.

           См. также: конструктор TResourceFile, TResourceFile::flush


      count         short count();
      -----
           Вызывает index->getCount для возврата  количества  элементов
      ресурсов, сохраненных в соответствующем TResourceCollection.

           См. также: TResourceFile::getCount


      flush         void flush();
      -----
           Если файл ресурса не был модифицирован с момента  последнего
      вызова flush (т.е. значение modified равно False) flush не выпол-
      няет никаких действий. В противном случае, flush сохраняет обнов-
      ленный  индекс в конце потока и обновляет заголовок ресурса в на-
      чале потока.  Затем он  вызывает  stream->flush  и  устанавливает
      modified в значение False.

           См. также:      ~TResourceFile,     TResourceFile::modified,
      opstream::flush


      get           void *get( const char *key );
      ---
           Ищет заданный key в соответствующей коллекции файла ресурсов
      (заданным указателем index).  Возвращает значение 0, если ключ не
      найден. Иначе, устанавливает поток на позицию, заданную полем pos
      в объекте TResourceItem,  размещенном по значению key.  Создается
      объект в позиции (basePos+pos), и возвращается указатель на него.
      Например:

           deskTop->insert(validView(resFile.get("eitorWindow")));

           См. также:   TResourceCollection::at,    TResourceFile::put,
                        TApplication::validView, ipstream::seekg


      keyAt         const char *keyAt(short i);
      -----
           Использует index->at  для  возврата  ключевой   строки   для
      ресурса  с  номером  i  в  данном  файле ресурса.  Индекс первого
      ресурса   равен   0,    а    индекс    последнего    ресурса    -
      TResourseFile::count-1. Используя count и keyAt, вы можете итера-
      тивно обработать все ресурсы в файле ресурса.

           См. также: TResourceFile::count, TResourceCollection::at



      put           void put(TSreamable *item, const char *key);
      ---
           Добавляет потоковый объект,  заданный при помощи item в файл
      ресурса с ключевой строкой,  заданной в key, и устанавливает поле
      modified в значение True.  Если индекс содержит key, новый объект
      замещает  старый;  в  противном случае,  объект добавляется в до-
      пустимую индексированную позицию файла ресурса.

           См. также: TResourceFile::get, TNSSortedCollection::search


      remove        void remove(const char *key);
      ------
           Если ресурс,  помеченный  при помощи key,  не найден,  метод
      remove не производит никаких действий. В противном случае, он вы-
      зывает index->free для удаления ресурса.

           См. также: TNSSortedCollection::search, TNSCollection::free







        TScreen                                                 SYSTEM.H
      -----------------------------------------------------------------

                               ┌──────────┐
                               │ TDisplay │
                               └────┬─────┘
                              ╔═════╧══════╗
                              ║  TScreen   ║
                              ╚════════════╝

           TScreen поддерживает атрибуты и функции изображения  нижнего
      уровня. Этот класс, и другие системные классы файла System.h, ко-
      ротко описаны только в руководстве: они используются внутри Turbo
      Vision,  и  вам  не  потребуется пользоваться ими явным образом в
      нормальных прикладных программах.  Класс TView является  дружест-
      венным классу TDisplay.


                                    Поля

      checkSnow     static Boolean near checkSnow;
      ---------
           Имеет значение True,  если разрешено пользоваться  проверкой
      на "снег" (для адаптера CGA);  в противном случае имеет  значение
      False.


      cursorLines   static ushort near cursorLines;
      -----------
           Содержит тип текущего курсора,  установленный  setCrtData  с
      вызовом getCursorType.

           См. также: TDisplay::getCursorType, TScreen::setCrtData


      hiResScreen   static Boolean near hiResScreen;
      -----------
           Имеет значение True,  если screenHeight больше 25; в против-
      ном случае имеет значение False.

           См. также: TScreen::screenHeight


      screenBuffer  static uchar far * near screenBuffer;
      ------------
           Указывает соответствующий буфер  изображения  для  указанной
      конкретной конфигурации изображения и его текущий режим.


      screenHeight  static uchar near screenHeight;
      ------------
           Содержит текущую высоту экрана,  установленную setCrtData  с
      обращением к getRows.

           См. также: TDisplay::getRows, TScreen::setCrtData


      screenMode    static ushort near screenMode;
      ----------
           Текущий видеорежим.

           См. также: TDisplay::getVideoMode


      screenWidth   static uchar near screenWidth;
      -----------
           Содержит текущую ширину экрана, установленную setCrtData че-
      рез обращение к getCols.

           См. также: TDisplay::getCols, TScreen::setCrtData


      startupCursor  static ushort near startupCursor;
      -------------
            Содержит начальный  тип  курсора,  установленный initScreen
      конструкторами TApplication/TProgram.

           См. также: TProgram::initScreen, TDisplay::getCursorType


      startupMode   static ushort near startupMode;
      -----------
           Содержит начальный   видеорежим,   установленный  initScreen
      конструкторами TApplication/TProgram.

           См. также: TProgram::initScreen


                                   Методы

      constructor   TScreen();
      -----------
           Создает объект TScreen и вызывает resume.  Он инициализирует
      startupMode при помощи getCrtMode;  startupCursor  -  при  помощи
      getCursorType;  затем  устанавливает оставшиеся поля путем вызова
      setCrtData.

           См. также:  TDisplay::getCrtMode,   TDisplay::getCursorType,
                     TScreen::setCrtData, TScreen::resume


      destructor    ~TScreen();
      ----------
           Вызывает метод suspend.  Он восстанавливает режим  экрана  в
      режим запуска,  очищает экран, затем восстанавливает курсор в на-
      чальный курсор.

           См. также: TDisplay::startupMode,    TDisplay::getCrtMode,
                      TDisplay::clearScreen,    TDisplay::getCursorType,
                      TScreen::suspend


      clearScreen   static void clearScreen();
      -----------
           Вызывает TDisplay::clearScreen    с    текущими   значениями
      screenWidth и screenHeight в качестве аргументов.

           См. также: TDisplay::clearScreen


      fixCrtMode    static ushort fixCrtMode( ushort vmode );
      ----------
           Если меньший  байт  заданного vmode не равен smMono,  smCO80
      или  BW80,  то   fixCrtMode   возвращает   smCO80.   Используется
      TScreen::setVideoMode для обработки нестандартных режимов.

           См. также: TDisplay::videoModes


      resume        static void resume();
      ------
           Вызывается конструктором    TScreen    для     инициализации
      startupMode  при  помощи  getCrtMode;  startupCursor - при помощи
      getCursorType;  затем устанавливает  остальные  поля  при  помощи
      setCrtData.

           См. также: TDisplay::getCrtMode,  TDisplay::getCursorType,
                      TScreen::setCrtData, TScreen::TScreen


      setCrtData    static void setCrtData();
      ----------
           Устанавливает поля  screenMode,  screenWidth  и screenHeight
      путем обращения к getCrtMode, getCols и getRows. Поле hiResScreen
      устанавливается в значение True или False,  в зависимости от зна-
      чения screenHeight.  Наконец,  в зависимости от текущего значения
      screenMode, устанавливаются поля screenBuffer и checkSnow.

           См. также:    TDisplay::getCrtMode,    TDisplay::getCols   и
      TDispalay::Rows


      setVideoMode  static void setVideoMode( ushort vmode );
      ------------
           Устанавливает видеорежим  в  значение  vmode,  затем в соот-
      ветствии с этим корректирует остальные поля TScreen.


      suspend       static void suspend();
      -------
           Вызывается деструктором TScreen. suspend восстанавливает эк-
      ранный режим в начальный режим,  очищает экран и затем восстанав-
      ливает курсор в начальную позицию.

           См. также: TScreen::~TScreen






        TScrollBar                                               VIEWS.H
      -----------------------------------------------------------------

                          ┌───────┐
                          │ TView │
                          └───┬───┘
                       ╔══════╧═════╗
                       ║ TScrollBar ║
                       ╚════════════╝


                                    Поля

      arStep        short arStep;
      ------
           arStep - это количество,  добавляемое или вычитаемое из поля
      value строк  прокрутки,  когда  "мышью"  отмечена область стрелок
      (sbLeftArrow,  sbRightArrow, sbUpArrow, sbDownArrow) или осущест-
      влены  эквивалентные  нажатия  клавиш.  По  умолчанию конструктор
      TScrollBar устанавливает arStep в 1.

           См. также:      TScrolBar::setStep,     TScrollBar::setParam,
      TScrollBar::scrollStep


      chars         TScrollChars chars;
      -----
           TScrollChars определяется следующим образом:

            typedef char TScrollChars[5];

           chars установлено при помощи пяти основных символьных образ-
      цов, используемых для изображения частей строк прокрутки экрана.


      maxVal        short maxVal;
      ------
           Поле maxVal представляет максимальное значение  поля  value.
      По умолчанию конструктор TScrollBar устанавливает maxVal в 0.

           См. также: TScrollBar::setRange, TScrollBar::setParams


      minVal        short minVal;
      ------
           Поле minVal представляет минимальное значение поля value. По
      умолчанию  конструктор TScrollBar устанавливает minVal в значение
      0.

           См. также: TScrollBar::setRange, TScrollBar::setParams



      pgStep        short pgStep;
      ------
           pgStep - это количество,  добавляемое или вычитаемое из поля
      value строк прокрутки, при нажатии на кнопки "мыши" в любой части
      области страницы (sbPageLeft,  sbPageRight, sbPageUp, sbPageDown)
      или  обнаружении  эквивалентных  нажатий клавиш (Ctrl->,  Ctrl<-,
      PgUp или PgDn). По умолчанию конструктор TScrollBar устанавливает
      pgStep  в  значение 1.  pgStep может изменяться при использовании
      TScrollBar::setStep, TScrollBar::setParams и TScroller::setLimit.

           См. также:    TScrollBar::setStep,    TScrollBar::setParams,
      TScroller::setLimit, TScrollBar::scrollStep


      value         short value;
      -----
           Поле value  представляет  текущую  позицию  индикатора строк
      прокрутки. Этот маркер,  выделенный цветом, перемещается по стро-
      кам прокрутки, указывая относительную позицию (горизонтальную или
      вертикальную,  в зависимости от  ориентации  строк  прокрутки)  в
      тексте относительно всего текста, доступного для прокрутки.

           Многие события могут прямо или  косвенно  изменять  значение
      value (такие,  как отметки с помощью "мыши"  на  элементах  строк
      прокрутки,  изменение размера окна или изменение текста при прок-
      рутке).  Аналогично,  изменения в value могут потребовать запуска
      других  событий.  Конструктор TScroolBar устанавливает value в 0,
      по умолчанию.

           См. также:  TScrollBar::setValue,    TScrollBar::setParams,
                       TScrollBar::scrollDraw,  TScroller::handleEvent,
                       TScrollBar::TScrollBar


                                   Методы

      constructor   TScrollBar(const TRect& bounds);
      -----------
           Создает и инициализирует строки прокрутки с заданными грани-
      цами bounds,  вызывая конструктор TView.  value,  maxVal и minVal
      устанавливаются в 0.  pgStep и arStep устанавливаются в 1.  Формы
      элементов строк  прокрутки   по   умолчанию   устанавливаются   в
      TScrollChars.

           Если bounds задает size.x  =  1,  вы  получите  вертикальные
      строки прокрутки,  иначе  -  горизонтальные.  Вертикальные строки
      прокрутки  имеют  поле  growMode,  установленное  в  gfGrowLoX  |
      gfGrowHiX | gfGrowHiY; горизонтальные строки прокрутки имеют поле
      growMode, установленное gfGrowLoY | gfGrouHiX | gfGrowHiY.


      constructor   TScrollBar( StreamableInit streamableInit );
      -----------                                          (защищенный)

           Каждому потоковому классу необходим "построитель" для  расп-
      ределения  памяти  для  его объектов вместе с инициализированными
      указателями виртуальной таблицы.  Это  достигается  путем  вызова
      конструктора  с  аргументом  типа StreamableInit.  Смотрите также
      главу 8.


      build         static TStreamable *build();
      -----
           Вызывается для  создания  объекта  в  определенных ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      draw          void draw();
      ----
           Отображает строки  прокрутки в зависимости от текущих значе-
      ний bounds, value и палитры.

           См. также: TScrollBar::scrollDraw, TScrollBar::value


      getPalette    virtual const char * getPalette() const;
      ----------
           Возвращает cpScrollBar,   строку  палитры  строк  прокрутки,
      используемую по умолчанию, "\x04\x05\x05".


      handleEvent   virtual void handleEvent(TEvent& event);
      -----------
           Обрабатывает события строк прокрутки,  вызывая метод TView::
      handleEvent,  затем анализируя event.what. События "мыши" переда-
      ются владельцу  строк  прокрутки (см.  функцию message),  который
      должен производить  соответствующие  изменения  строк   прокрутки
      (например, прокручивать  на  экране  текст).  Метод  TScrollBar::
      handleEvent так же определяет, в какой части строк прокрутки была
      нажата кнопка  "мыши"  (или  эквивалентная  клавиша).  Поле value
      настраивается в  соответствии  с  текущими  значениями  arStep  и
      pgStep, и индикатор области прокрутки перерисовывается.

           См. также: TView::handleEvent


      read          virtual void *read( ipstream is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, классы ipstream


      scrollDraw    virtual void scrollDraw();
      ----------
           Метод ScrollDraw вызывается при любых изменениях поля value.
      Этот   виртуальный   метод   вызывается    передачей    сообщения
      cmScrollBarChanged владельцу области прокрутки:

               message(Owner, evBroadcast, cmScrollBarChanged, this);

           См. также: TScrollBar::value, функция message


      scrollStep    virtual short scrollStep(short part);
      ----------
           По умолчанию scrollStep возвращает положительное или отрица-
      тельное значение шага,  в зависимости от части области прокрутки,
      заданной в part,  и текущих значений arStep  и  pgStep.  Аргумент
      part должен быть одной из констант sbXXXX, описанных в главе 14.

           См. также: TScrollBar::setStep, TScrollBar::setParams


      setParams     void setParams(short aValue, short aMin, short aMax,
      ---------                    short aPgStep, short aArStep);

           Метод setParams  устанавливает поля value,  minVal,  maxVal,
      pgStep и arStep в заданные значения.  Если аргументы конфликтуют,
      выполняются согласования.  Например,  minVal не может быть больше
      maxVal,  поэтому если  aMax  <  aMin,  maxVal  устанавливается  в
      minVal.  value должно лежать в диапазоне [minVal, maxVal], поэто-
      му,  если value < aMin,  value  устанавливается  в  minVal;  если
      aValue > aMax, value устанавливается в maxVal. drawView отобража-
      ет область прокрутки заново. Если value изменяется, будет вызвана
      scrollDraw.

           См. также: TView::drawView,     TScrollBar::scrollDraw,
                      TScrollBar::setRange, TScrollBar::setValue


      setRange      void setRange(short aMin, short aMax);
      --------
           Метод setRange  задает  допустимый  диапазон для поля value,
      устанавливая minVal и maxVal в aMin  и  aMax.  setRange  вызывает
      setParams,  поэтому  drawView и scrollBar будут вызываться,  если
      изменения требуют перерисовки строк прокрутки.

           См. также: TScrollBar::setParams


      setStep       void setStep(short aPgStep, short aArStep);
      -------
           setStep устанавливает  поля  pgStep  и  arStep  в  aPgStep и
      aArStep.  Этот метод вызывает setParams с остальными аргументами,
      равными их текущим значениям.

           См. также: TScrollBar::setParams, TScrollBar::scrollStep


      setValue      void setValue(short aValue);
      --------
           Метод setValue устанавливает поле value  в  aValue,  вызывая
      setParams с остальными аргументами, установленными в них текущими
      значениями. drawView и scrollDraw вызываются, если этот вызов из-
      меняет значение value.

           См. также:      TScrollBar::setParams,      TView::drawView,
      TScrollBar::scrollDraw, TScroller::scrollTo


      write         virtual void write( opstream& os);
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


                              Дополнительные функции

           Определенные функции относятся к классу  TScrollBar,  но  не
      являются методами.


                                   Палитра

           Объекты строк прокрутки используют  палитру  (по  умолчанию)
      cpScrollBar  для отображения заданных значений в 4 и 5-й элементы
      стандартной палитры прикладной программы.

                              1   2   3
                            ╔═══╤═══╤═══╗
              cpScrollBar   ║x04│x05│x05║
                            ╚═╤═╧═╤═╧═╤═╝
               Страница ──────┘   │   └───── Индикатор
               Стрелки  ──────────┘








        TScroller                                                VIEWS.H
      -----------------------------------------------------------------

                                 ┌─────────┐
                                 │  TView  │
                                 └────┬────┘
                                ╔═════╧═════╗
                                ║ TScroller ║
                                ╚═════╤═════╝
                               ┌──────┴──────┐
                               │ TTextDevice │
                               └─────────────┘


                                    Поля

      delta         TPoint delta;
      -----
           Содержит x (горизонтальная) и  y  (вертикальная)  компоненты
      позиции бегунок  прокрутки  относительно виртуальных отображаемых
      строк прокрутки.  Автоматическая прокрутка достигается изменением
      одной или обеих компонент в ответ, например, на события, изменяю-
      щих значения поля value.  "Ручная"  прокрутка  изменяет  значение
      delta, вносит изменения в поле value области прокрутки и приводит
      к обновлению индикаторов области прокрутки.

           См. также: TScroller::scrollDraw, TScroller::scrollTo


      drawFlag      Boolean drawFlag;
      --------
           Устанавливает значение True,  если надо перерисовать бегунок
      прокрутки.

           См. также: TView::drawView, TScroller::drawLock,
                      TScroller::checkDraw


      drawLock      uchar drawLock;
      --------
           Семафор, используемый для управления перерисовыванием  бегу-
      нок прокрутки.

           См. также: TView::drawView, TScroller::drawFlag,
                      TScroller::checkDraw


      hScrollBar    TScrollBar *hScrollBar;
      ----------
           Указывает на горизонтальный объект строк прокрутки,  связан-
      ный с бегунком прокрутки.  Если такой строки нет,  то  hScrollBar
      равен 0.


      limit         TPoint limit;
      -----
           limit.x и limit.y - это максимально допустимые значения  для
      delta.x и delta.y.

           См. также: TScroller::delta


      vScrollBar    TScrollBar *vScrollBar;
      ----------
           Указывает на вертикальный объект строки прокрутки, связанный
      с бегунком прокрутки. Если такой строки нет, vScrollBar равно 0.


                                   Методы

      constructor   TScroller(const TRect& bounds, TScrollBar
      -----------               *aHScrollBar, TScrollBar *aVScrollBar);

           Создает и инициализирует объект TScroller с заданным  разме-
      ром  и элементов прокрутки.  Вызывает конструктор TView для уста-
      новки размера отображаемой  области.  options  устанавливается  в
      значение ofSelectable, а eventMask устанавливается в evBroadcast.
      aHScrollBar должен быть равен 0, если вы не хотите иметь горизон-
      тальной  прокрутки;  аналогично  aVScrollBar должен быть равен 0,
      если вы не хотите иметь вертикальной прокрутки.

           См. также: TView::TView, TView::options, TView::eventMask


      biuld         static TStreamable *build();
      -----
           Каждому потоковому классу необходим "построитель" для  расп-
      ределения  памяти  для  его объектов вместе с инициализированными
      указателями виртуальной таблицы.  Это  достигается  путем  вызова
      конструктора  с  аргументом  типа StreamableInit.  Смотрите также
      главу 8.

           См. также: TStreamableClass, ipstream::readData


      changeBounds  virtual void changeBounds(const TRect& bounds);
      ------------
           Изменяет размер строк прокрутки, вызывая setBounds. Если не-
      обходимо, область прокрутки и прокручиваемые строки перерисовыва-
      ются вызовом drawView и setLimit.

           См. также: TView::setBounds, TView::drawView,
                      TScroller::setLimit


      checkDraw     void checkDraw();
      ---------
           Если drawLock  равно  0  и  drawFlag  имеет  значение  True,
      drawFlag устанавливается в значение False, и вызывается drawView.
      Если  drawLock  не  равно  0  или  drawFlag имеет значение False,
      checkdraw не производит никаких  действий.  scrollTo  и  setLimit
      каждый вызывает checkDraw таким образом,  что drawView вызывается
      только в том случае, когда это необходимо.


      getPalette    virtual TPalette& getPalette() const;
      ----------
           Возвращает cpScroller,  используемую  по  умолчанию  палитру
      прокрутки, "\x06\x07".


      handkeEvent   virtual void handleEvent(TEvent& event);
      -----------
           Обрабатывает большинство     событий,     вызывая      метод
      TView::handleEvent.  Общие события, такие как cmScrollBarChanged,
      если они пришли от hScrollBar или vScrollBar,  приводят к  вызову
      TScroller::scrollDraw.

           См. также: TView::handleEvent, TScroller::scrollDraw


      read          virtual void *read( ipstream& is );
      ----
           Производит считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      scrollDraw    virtual void scrollDraw();
      ----------
           Проверяет, удовлетворяет  ли  delta соответствующим позициям
      элементов прокрутки.  Если нет - delta устанавливается в коррект-
      ное  значение,  и  вызывается drawView для повторного отображения
      бегунка прокрутки.

           См. также: TView::drawView,          TScroller::delta,
                      TScroller::hScrollBar, TScroller::vScrollBar


      scrollTo      void scrollTo(short x, short y);
      --------
           Устанавливает строки    прокрутки    в   (x,   y),   вызывая
      hScrollBar->setValue(x) и vScrollBar->setValue(y),  и перерисовы-
      вает отображаемый объект, вызывая drawView, если это необходимо.

           См. также: TView::drawView, TScroller::setValue


      setLimit      void setLimit(short x, short y);
      --------
           Устанавливает поле limit и перерисовывает элементы и бегунок
      прокрутки, если это необходимо.

           См. также:      TScroller::limit,       TScroller::hScroller,
      TScroller::vScrollBar, TScrollBar::setParams, TScroller::checkDraw


      setState    virtual void setState(ushort aState, Boolean enable);
      --------
           Этот метод вызывается при любых изменениях состояния бегунка
      прокрутки. Вызывает TView::setState для  установки  или  очищения
      флагов  состояния  в aState.  Если новое состояние - sfSelected и
      sfActive,  setState  отображает  элементы  прокрутки,  иначе  они
      "скрываются" (становятся неотображаемыми).

           См. также: TView::setState


      shutDown      virtual void shutDown();
      --------
           Используется внутри  TObject::destroy для подтверждения пра-
      вильного удаления порожденных и связанных объектов.  shutDown пе-
      реопределяется во многих классах для того,  чтобы быть уверенным,
      что установлены допустимые связанные поля при вызове destroy.

           См. также: глава 6, "Разработка надежных программ"


      write         virtual void write( opstream& os );
      -----
           Производит запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции относятся к классу TScroller, но не яв-
      ляются методами.

                                   Палитра

           Объекты прокрутки используют по умолчанию палитру cpScroller
      для  отображения  заданных  значений в 6 и 7 элементы стандартной
      палитры программы.

                             1   2
                           ╔═══╤═══╗
              cpScroller   ║ 6 │ 7 ║
                           ╚═╤═╧═╤═╝
               Обычный ──────┘   └──── Подсвеченный









        TSItem                                                 DIALOGS.H
      -----------------------------------------------------------------

                               ╔═══════════╗
                               ║  TSItem   ║
                               ╚═══════════╝

           TSItem является простым, неотображаемым классом, поддержива-
      ющим  односвязный  список символьных строк.  Этот класс полезен в
      том случае,  когда не нужна полная гибкость коллекции строк (см.,
      например, класс TCluster).


                                    Поля

      next          TSItem *next;
      ----
           Указатель на следующий объект TSItem в связанном списке.


      value         const char *value;
      -----
           Строка для объекта TSItem.


                                   Методы

      constructor   TSItem(const char *aValue, TSItem *aNext);
      -----------
           Создает объект TSItem с заданными значениями.


      destructor    ~TSItem();
      ----------
           Удаляет объект TSItem путем вызова delete value.







        TSortedCollection                                      OBJECTS.H
      -----------------------------------------------------------------

              ┌─────────────┐        ┌─────────────────────┐
              │ TCollection │        │ TNSSortedCollection │
              └──────┬──────┘        └──────────┬──────────┘
                     └───────┐   ┌──────────────┘
                    ╔════════╧═══╧══════╗
                    ║ TSortedCollection ║
                    ╚════════╤══════════╝
                    ┌────────┴──────────┐
                    │ TStringCollection │
                    └───────────────────┘

           Абстрактный класс TSortedCollection является наследуемым  от
      TCollection и TNSSortedCollection,  реализуя потоковую коллекцию,
      отсортированную по ключу (с или без дублирования). Не допускается
      использование никаких экземпляров TSortedCollection. Он существу-
      ет в единственном числе,  как основа для других  стандартных  или
      заданных пользователем классов.

           Сортировка производится  при  помощи  чисто  виртуального (и
      внутреннего) метода compare,  который вы должны переопределить  в
      наследуемых классах, чтобы задать свое определение упорядочивания
      элементов.  Когда добавляются новые элементы,  они  автоматически
      вставляются в порядке,  заданном методом compare.  Элементы можно
      находить,  используя  метод   поиска   search,   наследуемый   из
      TNSSortedCollection.  Виртуальный  метод keyOf (также наследуемый
      из TNSSortedCollection), возвращающий указатель для compare, так-
      же  может  переопределяться,  если compare требует дополнительной
      информации.

           Вы можете использовать этот класс для работы с отсортирован-
      ными    потоковыми   коллекциями.   Кроме   потоковости,   классы
      TSortedCollection и TNSSortedCollection выполняют одни  и  те  же
      функции.

                                   Методы

      constructor   TSortedCollection(ccIndex aLimit, ccIndex aDelta);
      -----------
           Запускает конструктор TCollection для установки count, items
      и limit в 0;  вызывает setLimit(aLimit) для установки размера на-
      бора в aLimit,  затем устанавливает delta в значение aDelta.  За-
      метьте,  что ccIndex имеет тип int. duplicates установлено в зна-
      чение False.  Если вы хотите иметь дублированные ключи, вы должны
      установить duplicates в значение True.


      constructor   TSortedCollection( StreamableInit streamableInit );
      -----------                                       (защищенный)

           Каждому потоковому  классу необходим "построитель" для расп-
      ределения памяти для его объектов  вместе  с  инициализированными
      указателями  виртуальной  таблицы.  Это  достигается путем вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.

           См. также: TCollection::TCollection, поля TCollection


      compare       virtual int compare(void *key1, void *key2) = 0;
      -------                                               private

           comapre является чисто виртуальным методом,  который  должен
      быть переопределен во всех наследуемых классах (или перезадан как
      чисто виртуальный).

           См. также: TNSSortedCollection::compare


      read          void read( ipstream& is );
      ----                                               (защищенный)

           Считывает отсортированную коллекцию из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      readItem      void *TSortedCollection::readItem( ipstream& is );
      --------
           Вызывается для каждого элемента в коллекции. Вам потребуется
      переопределить  его  в  каждом  наследуемом  из  TCollection  или
      TSortedCollection  классе  для  того,  чтобы элементы считывались
      правильно. TSortedCollection уже переопределил этот метод.

           См. также: TStreamableClass, TStreamable, ipstream


      write         void write( opstream& os );
      -----                                                (защищенный)

           Записывает соответствующий объект TSortedCollection в выход-

           См. также: TStreamableClass, TStreamable, классы opstream


      writeItem     void TSortedCollection::writeItem( void *obj,
      ---------                                  opstream& os );

           Вызывается для каждого элемента в коллекции. Вам потребуется
      переопределить  его  в  каждом  наследуемом  из  TCollection  или
      TSortedCollection  классе  для того,  чтобы элементы записывались
      правильно. В классе TSortedCollection этот метод уже  переопреде-
      лен.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции  относятся  к классу TSortedCollection,
      но не являются методами.








        TStaticText                                            DIALOGS.H
      -----------------------------------------------------------------

                                 ┌───────┐
                                 │ TView │
                                 └───┬───┘
                              ╔══════╧══════╗
                              ║ TStaticText ║
                              ╚══════╤══════╝
                                 ┌───┴────┐
                                 │ TLabel │
                                 └────────┘

           Объекты TStaticText  представляют  простейшие   отображаемые
      объекты: они  содержат фиксированный текст и игнорируют все собы-
      тия, переданные им.  Они используются,  обычно, как сообщения или
      статические метки.  Потомки TStaticText, такие как TLabel, выпол-
      няют более активную роль.


                                    Поля

      text          const char *text;                    (защищенный)
      ----
           Указатель на строку текста,  видимую в отображаемом объекте.


                                   Методы

      constructor   TStaticText(const TRect& bounds, const char *atext);
      -----------
           Создает объект   StaticText   заданного   размера,   вызывая
      TView(bounds), затем устанавливая text в newStr(aText).


      constructor   TStaticText( StreamableInit streamableInit );
      -----------                                         (защищенный)

           Каждому потоковому  классу необходим "построитель" для распре-
      деления памяти для его объектов вместе с инициализированными ука-
      зателями   виртуальной  таблицы.  Это  достигается  путем  вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.

           См. также: TView::TView, newStr


      destructor    ~TStaticText();
      ----------
           Освобождает строку text,  затем вызывает ~TView для удаления
      объекта.


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      draw          virtual void draw();
      ----
           Отображает строку текста внутри отображаемого объекта (слово
      при необходимости переносится). '\n' в тексте указывает на начало
      новой строки.  Строка текста центрируется в отображаемом объекте,
      если она начинается с 0x03 (Ctrl-C).


      getPalette    virtual TPalette* getPalette() const;
      ----------
           Возвращает стандартную палитру cpStaticText, "\x06".


      read          virtual void *read( ipstream& is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции  относятся к классу TStaticText,  но не
      являются методами.


                                   Палитра

           Статический текст    использует    по    умолчанию   палитру
      cpStaticText для отображения заданного значения в 6-й элемент па-
      литры стандартного диалога.

                                   1
                                 ╔═══╗
                   cpStaticText  ║x06║
                                 ╚═╤═╝
                    Цвет текста ───┘







        TStatusDef                                               MENUS.H
      -----------------------------------------------------------------

                         ╔═════════════╗
                         ║ TStatusDef  ║
                         ╚═════════════╝

           Объект TStatusDef является скрытым,  но представляет опреде-
      ление   строки   состояния,  используемое  отображаемым  объектом
      TStatusLine для изображения строк состояния,  зависящих  от  кон-
      текста.  Поле  next  указывает  на  следующий объект TStatusDef в
      списке строк состояния (или 0, если он последний). Поля min и max
      определяют размер текста подсказки, сопровождающего строку состо-
      яния.  items указывает на элементы состояния, составляющие строку
      состояния.

           Объект TStatusLine имеет указатель, называемый defs, на свя-
      занный список объектов TStatusDef.  TStatusLine всегда отображает
      первый  элемент  состояния,  для которого текущее значение текста
      подсказки лежит между min и max.  TStatusLine::update может  быть
      вызван из TProgram::idle для правильного изменения строки состоя-
      ния области просмотра.


                                    Поля

      items         TStatusItem *items;
      -----
           items указывает на список элементов состояния,  составляющих
      строку состояния.  Значение 0 показывает, что элементов состояния
      нет.

           См. также: класс TStatusLine, класс TStatusItem


      min, max      ushort min, max
      --------
           Минимальное и максимальное значения текста подсказки,  кото-
      рому  соответствует  данное  определение  состояния.  TStatusLine
      всегда отображает первый элемент состояния,  для которого текущее
      значение текста подсказки лежит между min и max.

           См. также: TStatusLine::draw


      next          TStatusDef *next;
      ----
           Ненулевое значение  next  указывает  на   следующий   объект
      TStatusDef в списке определений состояния. Нулевое значение пока-
      зывает, что данный объект TStatusDef является последним в списке.


                                   Методы

      constructor   TStatusDef(ushort aMin, ushort aMax, TStatusItem
      -----------              *someItems, TStatusDef *aNext);

           Создает объект TStatusDef с заданными значениями.








        TStatusItem                                              MENUS.H
      -----------------------------------------------------------------

                             ╔═════════════╗
                             ║ TStatusItem ║
                             ╚═════════════╝

           Объект TStatusItem является скрытым,  но представляет компо-
      ненту (элемент  состояния)  связанного  списка,  соответствующего
      отображаемому объекту  TStatusline.  Последний  может  отображать
      строку состояния и обрабатывать события строки  состояния,  такие
      как нажатие управляющей клавиши и выбор команды. Элементы состоя-
      ния могут быть отображаемыми  или  неотображаемыми.  В  последнем
      случае элементы служат только для определения клавиши управления.
      Поле next указывает на следующий объект TStatusItem в списке, или
      равен 0,  если он является последним.  Поле text - это символьная
      строка, содержащая описание элемента (такое как "<Alt-X> - Exit".
      Если text равно 0,  то элемент состояния является неотображаемым.
      Поле keyCode содержит скэн-код управляющей клавиши, соответствую-
      щей команде, или равно 0, если такой управляющей клавиши нет. По-
      ле command содержит событие (в виде команды), которое должно быть
      сгенерировано при выборе элемента просмотра посредством управляю-
      щей клавиши или "мыши".

           TStatusItem служит для двух целей:  он управляет  визуальным
      появлением строки состояния, и определяет управляющую клавишу для
      соответствия кодов клавиш командам.  TProgram::getEvent  вызывает
      TStatusLine::handleEvent для всех событий evKeyDown, и элементы в
      текущей строке состояния просматриваются для приведения  в  соот-
      ветствие с кодами клавиш.  Если соответствие не найдено,  событие
      evKeyDown  преобразуется  в  событие  evCommand,  заданное  полем
      command в соответствующем объекте элемента состояния.


                                    Поля

      command       ushort command;
      -------
           Значение команды, соответствующей элементу состояния.


      keyCode       ushort keyCode;
      -------
           Скэн-код для соответствующей клавиши управления.


      next          TStatusItem *next;
      ----
           Ненулевое значение  next  указывает  на   следующий   объект
      TStatusItem в связанном списке, соответствующем строке состояния.
      Нулевое значение показывает, что это последний элемент в списке.


      text          const char *text;
      ----
           Текстовая строка,  отображаемая для данного элемента состоя-
      ния. Если равна 0,  не будет отображаться никакое  описание,  что
      означает, что элемент состояния предназначен только для определе-
      ния управляющей клавиши, используемой полем keyCode.

          См. также: класс TStatusLine


                                   Методы

      constructor   TStatusItem(const char *aText, ushort key,
      -----------               ushort cmd, TStatusItem *aNext) = 0;

           Создает объект TStatusItem с заданными значениями.







        TStatusLine                                              MENUS.H
      -----------------------------------------------------------------

                              ┌─────────┐
                              │  TView  │
                              └────┬────┘
                            ╔══════╧══════╗
                            ║ TStatusLine ║
                            ╚═════════════╝

           Объект TStatusLine - это особая область, обычно отображаемая
      внизу экрана. Типичная строка состояния отображает список доступ-
      ных управляющих клавиш,  объем свободной памяти, время дня, теку-
      щий режим  редактирования и подсказок пользователя.  Отображаемые
      объекты   устанавливаются   в   связанный    список,    используя
      initStatusLine вызываемый TApplication, и отображаемый объект за-
      висит от контекста  подсказки  текущего  активного  отображаемого
      объекта. Как  и  строка меню и рабочая область,  строка состояния
      обычно принадлежит группе TApplication.

           Объекты строки состояния - объекты типа TStatusItem, которые
      содержат поля для текстовой строки, отображаемые в строке состоя-
      ния, кода ключа,  связываемого  с  управляющей  клавишей  (обычно
      функциональная  клавиша  или  комбинация  Alt-клавиша) и команды,
      посылаемой,  если отображаемый текст отмечен "мышью",  или нажата
      управляющая клавиша.

           Каждый объект  строки  состояния  содержит  связанный список
      defs строк состояния (объекты класса TStatusDef), которые опреде-
      ляют диапазон контекстных подсказок и список элементов состояния,
      отображаемый,  когда текущий контекст подсказки находится в  этом
      диапазоне.  Кроме  того,  hints или предопределенная строка может
      отображаться в соответствии с текущим контекстом подсказки.


                                    Поля

      defs          TStatusDef *defs;
      ----
           Указатель на   текущий   связанный   список   записей   типа
      TStatusDef.  Список для использования определяется  текущим  кон-
      текстом подсказки.

           См. также:          TStatusDef,         TStatusLine::update,
      TStatusLine::hint


      items         TStatusItem *items;
      -----
           Указатель на  текущий связанный список записей типа TStatus-
      Item.

           См. также: TStatusItem


                                   Методы

      constructor   TStatusLine(const TRect& bounds, TStatusDef& aDefs);
      -----------
           Создает объект TStatusLine с заданным размером bounds, вызы-
      вая  TView(bounds).  Бит  ofPreProcess  в   options   установлен,
      eventMask  устанавливается для включения evBroadcast,  а growMode
      устанавливается в gfGrowLoY | gfGrowHiX |  gfGrowHiY.  Поле  defs
      устанавливается в aDefs. Если aDefs имеет значение 0, items уста-
      навливается в 0, иначе items устанавливается в aDefs->items.


      constructor   TStatusLine( StreamableInit streamableInit );
      -----------                                          (защищенный)

           Каждому потоковому  классу необходим "построитель" для расп-
      ределения памяти для его объектов  вместе  с  инициализированными
      указателями  виртуальной  таблицы.  Это  достигается путем вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.

           См. также: TView::TView


      destructor    ~TStatusLine();
      ----------
           Освобождает все  items  и defs в объекте TStatusLine,  затем
      вызывает ~TView.

           См. также: ~TView


      build         static TStreamable *build();
      -----
           Вызывается для  создания  объекта  в  определенных ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData

      draw          virtual void draw();
      ----
           Отображает строку состояния,  выводя строку text для каждого
      элемента состояния,  а затем все hints,  определенные для данного
      текущего контекста подсказки за полосой разделителя. draw исполь-
      зует соответствующие палитры,  cpNormal, cpSelect, cpNormDisabled
      или cpSelDisabled, в зависимости от статуса каждого элемента.

           См. также: TStatusLine::hint


      getPalette    virtual const char * getPalette() const;
      ----------
           Возвращает строку            стандартной            палитры,
      "\x02\x03\x04\x05\x06\ x07".


      handleEvent   virtual void handleEvent(TEvent& event);
      -----------
           Обрабатывает события, передаваемые строке состояния, вызывая
      TView::handleEvent,  затем проверяет на 3 вида специальных  собы-
      тий. Нажатия кнопок "мыши", когда ее курсор находится внутри пря-
      моугольника,  занимаемого элементом состояния, посылают командное
      событие с event::what,  установленного в command,  для этого эле-
      мента состояния.  События  от  клавиатуры  сравниваются  с  полем
      keyCode каждого элемента; соответствие вызывает командное событие
      command   этого    элемента.    Общие    события    с    командой
      cmCommandSetChanged  заставляют  строку  состояния заново отобра-
      жаться,  чтобы отобразить любые клавиши управления, которые могут
      быть разрешены или запрещены.

           См. также: TView::handleEvent, TStatusLine::draw


      hint          virtual const char* hint(ushort aHelpCtx);
      ----
           По умолчанию hint возвращает пустую строку.  Он должен  быть
      переопределен  для  обеспечения строки контекстно-ориентированной
      подсказки для аргумента aHelpCtx.  Непустая строка будет  отобра-
      жаться в строке состояния после полосы-разделителя.

           См. также: TStatusLine::draw


      read          virtual void *read( ipstream& is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, классы ipstream


      update        void update();
      ------
           Обновляет строку  состояния,  выбирая корректные элементы из
      списка defs в зависимости от текущего контекста подсказки,  затем
      вызывает drawView для перерисовки строки состояния, если элементы
      были изменены.

           См. также: TStatusLine::defs


      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, классы opstream


                           Дополнительные функции

           Определенные функции относятся к классу TRect,  но не  явля-
      ются методами.


                                   Палитра

           Строки состояния    используют    по    умолчанию    палитру
      cpStatusLine для отображения заданных значений в элементы со 2 по
      7-й в палитре стандартной программы.

                        1    2    3    4    5    6
                     ╔════╤════╤════╤════╤════╤════╗
      cpStatusLine   ║x02 │x03 │x04 │x05 │x06 │x07 ║
                     ╚══╤═╧══╤═╧══╤═╧══╤═╧══╤═╧══╤═╝
                        │    │    │    │    │    │
      Нормальный текст ─┘    │    │    │    │    └── Выделенное
                             │    │    │    │        сокращение
      Недоступный текст ─────┘    │    │    └─────── Выделенный
                                  │    │             недоступный
      Сокращенный текст ──────────┘    └──────────── Выделенный







        TStreamable                                           TOBJSTRM.H
      -----------------------------------------------------------------

              ╔═══════════════════╗    ┌─────────────────┐
              ║ TSortedCollection ║    │    TObject      │
              ╚══════╤════════════╝    └────────┬────────┘
                     └───────────┬──────────────┘
                         ┌───────┴─────────┐
                         │     TView       │
                         └─────────────────┘

           TView имеет два базовых класса,  TObject и абстрактный класс
      TStreamable. Все отображаемые классы, производные из TView, таким
      образом,  также наследуются от TStreamable.  Несколько внутренних
      классов,  таких как TCollection,  TStrListMarker,  TStringList  и
      TxxxInit также имеют в качестве основного класс TStreamable.  Та-
      кие классы называются потоковыми,  что означает,  что их  объекты
      могут быть записаны в и считаны из потоков, используемых управля-
      ющей программой Turbo Vision.

           Если вы  хотите  разработать  свои   собственные   потоковые
      классы,  убедитесь, что класс TStreamable является для них "роди-
      тельским". Конечно, этого можно достичь использованием существую-
      щего потокового класса в качестве основного.

           Т.к. TStreamable  является абстрактным классом,  его объекты
      не могут быть внутренними.  Перед тем,  как потоковый класс может
      быть  использован  с  потоками,  класс  должен переопределить три
      чисто виртуальные функции streamableName, read и write.


                                   Методы

      read          virtual void *read( ipstream& is ) = 0;(защищенный)
      ----
           Этот чисто  виртуальный метод должен быть переопределен (или
      перезадан как чисто виртуальный)  в  каждом  наследуемом  классе.
      Этот  переопределенный  метод  read для каждого потокового класса
      должен считывать необходимые поля из входного потока объекта  is.
      read  обычно  применяется при помощи вызова метода read основного
      класса (если он есть), а затем выделением и добавлением полей для
      наследуемого класса.

           См. также: ipstream, TStreamableClass


      streamableName  virtual const char *streamableName() const = 0;
      --------------                                            private

           TStreamable не  имеет  конструктора.  Этот метод должен быть
      переопределен (или перезадан как чисто виртуальный)  для  каждого
      наследуемого  класса.  Он должен возвращать имя потокового класса
      того объекта, который его запускает. Это имя используется при ре-
      гистрации  потоков  управляющей  потоками  программой.  Например,
      TView переопределяет этот метод следующим образом:

           virtual const  char *streamableName() const
                                 { return TViewName; }

           TView::TViewName является  статическим  символьным массивом,
      содержащим имя "TView". Это возвращаемое имя должно быть уникаль-
      ным,  строкой, заканчивающейся нулевым символом, так что наиболее
      надежным методом является использование имени потокового класса.

           См. также: TStreamableClass, opstream, ipstream


      write         virtual void write( opstream& os ) = 0:
      -----                                               (защищенный)

           Этот чисто виртуальный метод должен быть переопределен  (или
      перезадан  как  чисто  виртуальный)  в каждом наследуемом классе.
      Этот переопределенный метод write для каждого  потокового  класса
      должен  записывать  необходимые поля в выходной поток объекта is.
      write обычно применяется при помощи вызова метода write основного
      класса (если он есть), а затем выделением и добавлением полей для
      наследуемого класса.

           См. также: TStreamableClass, opstream


                            Дружественные классы

           Классы opstream  и  ipstream  являются дружественными классу
      TStreamable,  так что все их методы могут иметь доступ к внутрен-
      ним полям TStreamable.







        TStreamableClass                                      TOBJSTRM.H
      -----------------------------------------------------------------

                      ╔═══════════════════╗
                      ║ TStreamableClass  ║
                      ╚═══════════════════╝

           Класс TStreamableClass         используется         классами
      TStreamableTypes и pstream при регистрации потоковых классов.


                                   Методы

      constructor   TStreamableClass( const char *n, BUILDER b, int d );
      -----------
           Создает объект TStreamable с заданным именем и заданным  ме-
      тодом  builder,  затем  вызывает  registerType.  Каждый потоковый
      класс TClassname имеет метод build. Также имеет аналогичные пере-
      загруженные операторы >> и <<, работающие не с полями, а для вво-
      да/вывода потока,  соответствующие каждому потоковому классу. Для
      ввода /вывода объекта-потока программа, управляющая потоками тре-
      бует доступ к именам и информации о типах для каждого класса. Для
      того,  чтобы убедиться, что соответствующие методы включены в лю-
      бую прикладную программу при помощи программы,  управляющей пото-
      ками, вы должны иметь указатель extern следующего вида:

          extern TStreamableClass registerTClassName;

      где TClassName - это имя класса, чьи объекты надо сделать потоко-
      выми (заметьте, что registerTClassName является отдельным иденти-
      фикатором). Этот метод не только регистрирует TClassName (сообщая
      программе, управляющей потоками, какой метод build использовать),
      он также автоматически регистрирует все зависимые классы.  Вы мо-
      жете регистрировать класс более одного раза без всякого вреда или
      лишних затрат.

           Тип BUILDER определен следующим образом:

           typedef TSreamable *(*BUILDER)();

           См. также:   TStreamable,   TStreamableTypes,  read,  write,
      build, TStreamableTypes::registerTypes, ipstream, opstream


                            Дружественные классы

           Классы TStreamableTypes,  opstream  и ipstream являются дру-
      жественными классу TStreamableClass,  так что все их методы могут
      иметь доступ к внутренним полям класса TStreamableClass.







        TStreamableTypes                                     TOBJSTRM.H
      ----------------------------------------------------------------

                    ┌─────────────────────┐
                    │ TNSSortedCollection │
                    └─────────┬───────────┘
                    ╔═════════╧══════════╗
                    ║ TStreamableTypes   ║
                    ╚════════════════════╝

           TStreamableTypes, выделенный   изнутри  TNSSortedCollection,
      содержит базу данных для всех зарегистрированных типов, использу-
      емых во всех прикладных программах. opstream и ipstream использу-
      ют эту базу данных для  определения  правильных  методов  read  и
      write для конкретных объектов. Из-за внутреннего наследования все
      наследуемые поля являются внутренними внутри TStreamableTypes.


                                   Методы

      constructor   TStreamableTypes();
      -----------
           Вызывает основной конструктор TNSCollection для создания на-
      бора TStreamableTypes.

           См. также: TNSCollection::TNSCollection


      destructor    ~TStreamableTypes();
      ----------
           Устанавливает поле  limit коллекции в 0 без уничтожения кол-
      лекции (т.к. поле shouldDelete имеет значение False).

           См. также: TNSCollection::~TNSCollection,
                      TNSCollection::shouldDelete


      lookup        const TStreamableClass *lookup( const char *name );
      ------
           Возвращает указатель класса  в  коллекции,  соответствующему
      аргументу name, или 0, если такого нет.


      registerTypes  void registerTypes( const TStreamableClass *d );
      -------------
           Регистрирует класс путем вставки d в коллекцию.

           См. также: TNSCollection::insert, TStreamableClass








        TStringCollection                                     RESOURCE.H
      -----------------------------------------------------------------

                            ┌───────────────────┐
                            │ TSortedCollection │
                            └────────┬──────────┘
                            ╔════════╧══════════╗
                            ║ TStringCollection ║
                            ╚════════╤══════════╝
                           ┌─────────┴───────────┐
                           │ TResourceCollection │
                           └─────────────────────┘

           Класс TStringCollection      является     наследуемым     из
      TSortedCollection и реализует сортированный список  строк  ASCII.
      Метод  TStringCollection::compare  переопределяется  для  задания
      обычного лексикографического упорядочения строк ASCII.  Вы можете
      переопределить  метод  compare  для задания другого упорядочения,
      такого например, как для не английских наборов символов.


                                   Методы

      constructor   TStringCollection(short aLimit, short aDelta);
      -----------
           Создает объект TStringCollection с заданными значениями.


      constructor   TStringCollection( StreamableInit streamableInit );
      -----------                                          (защищенный)

           Каждому потоковому классу необходим "построитель" для  расп-
      ределения  памяти  для  его объектов вместе с инициализированными
      указателями виртуальной таблицы.  Это  достигается  путем  вызова
      конструктора  с  аргументом  типа StreamableInit.  Смотрите также
      главу 8.

           См. также: TSortedCollection::TSortedCollection


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      compare       virtual int compare(void *key1, void *key2);
      -------
           Сравнивает "строки" key1 и key2 следующим образом: возвраща-
      ет <0,  0,  >0, если key1 < key2; 0, если key1 = key2; и +1, если
      key1 > key2.

           См. также: TSortedCollection::search


      freeItem      virtual void freeItem(void *item);
      --------
           Удаляет строку  item из отсортированной коллекции и освобож-
      дает строку.


      read          virtual void *read( ipstream& is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, ipstream


      readItem      void *TStringCollection::readItem( ipstream& is );
      --------
           Вызывается для каждого элемента коллекции.  Вам  потребуется
      переопределить   этот  метод  во  всех  классах,  наследуемых  из
      TCollection или TSortedCollection для того, чтобы элементы считы-
      вались правильно. TSortedCollection уже переопределил этот метод.

           См. также: TStreamableClass, TStreamable, ipstream


      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


      writeItem void TStringCollection::writeItem( void *obj,
      ---------                                    opstream& os );

           Вызывается для каждого элемента коллекции.  Вам  потребуется
      переопределить   этот  метод  во  всех  классах,  наследуемых  из
      TCollection или TSortedCollection для того,  чтобы  элементы  за-
      писывались  правильно.  TSortedCollection  уже переопределил этот
      метод.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции  относятся  к классу TStringCollection,
      но не являются методами.








        TStringList                                           RESOURCE.H
      -----------------------------------------------------------------

                ┌───────────┐     ┌─────────────┐
                │  TObject  │     │ TStreamable │
                └───┬───────┘     └──────┬──────┘
                    ├───────────────┐    │
                    │     ┌─────────┼────┤
               ╔════╧═════╧══╗   ┌──┴────┴───────┐
               ║ TStringList ║   │ TStrListMaker │
               ╚═════════════╝   └───────────────┘

           Класс TStringList обеспечивает механизм доступа  к  строкам,
      хранящимся  в потоке.  Каждая строка,  хранящаяся в списке строк,
      идентифицируется  уникальным  номером  (ushort  key)  между  0  и
      65,535.  Списки строк занимают меньше памяти, чем обычные строки,
      поскольку строки хранятся в потоке,  а не в памяти.  Кроме  того,
      списки  строк  легко решают проблему настройки программ на языки,
      поскольку строки не "встроены" в программу.

           TStringList содержит методы только для  доступа  к  строкам;
      для создания списка строк вы должны использовать TStrListMaker.


      TStrIndexRec    Маленький  класс TStrIndexRec  используется вместе
      со списками строк. Он определен в RESOURCE.H следующим образом:

           class TStrIndexRec
           {

           public:

                 TStrIndexRec();   // конструктор устанавливает count=0

                 ushort key;
                 ushort count;
                 ushort offset;
           }

           Поле index в TStringList указывает на объект TStrIndexRec.


                                   Методы

      constructor   TStringList( StreamableInit streamableInit );
      -----------                                          (защищенный)

           Каждому потоковому классу необходим "построитель" для  расп-
      ределения  памяти  для  его объектов вместе с инициализированными
      указателями vtable.  Это  достигается путем вызова конструктора с
      аргументом типа StreamableInit. Смотрите также главу 8.

           См. также: TStrListMaker::TStrListMaker, TStrList::get


      destructor    ~TStringList();
      ----------
           Освобождает память, выделенную для списка строк.

           См. также: TStrListMaker::TStrListMaker, ~TStringList


      build         static TStreamable *build();
      -----
           Вызывается для  создания  объекта  в  определенных ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData


      get           void get (char *dest, ushort key);
      ---
           Возвращает в  dest  строку,  заданную через key,  или пустую
      строку, если нет строки с данным key.

           См. также: TStringListMaker::put


      read          virtual void *read( ipstream& is );
      ----
           Осуществляет считывание из входного потока is.

           См. также: TStreamableClass, TStreamable, классы ipstream


      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, классы opstream


                           Дополнительные функции

           Определенные функции  относятся к классу TStringList,  но не
      являются методами.








        StrListMaker                                          RESOURCE.H
      -----------------------------------------------------------------
                ┌───────────┐     ┌─────────────┐
                │  TObject  │     │ TStreamable │
                └───┬───────┘     └──────┬──────┘
                    ├───────────────┐    │
                    │     ┌─────────┼────┤
               ┌────┴─────┴────┐  ╔═╧════╧════════╗
               │ TStringList   │  ║ TStrListMaker ║
               └───────────────┘  ╚═══════════════╝

           Объект TStrListMaker - это простой тип объекта, используемый
      для создания списков строк, которые используют с TStringList.


                                   Методы

      constructor   TStrListMaker(ushort aStrSize, ushort aIndexSize);
      -----------
           Создает в памяти список строк размера aStrSize с индексом из
      aIndexSize элементов. Буфер строк и буфер индексов заданного раз-
      мера распределяются в "куче".

           aStrSize должен  быть  достаточно  велик  для  хранения всех
      строк,  добавляемых в список строк (каждая строка  занимает  свою
      длину, плюс конечный 0).

           При добавлении    строк    в    список    строк   (используя
      TStrListMaker::put) строится индекс строк.  Строки  с  последова-
      тельными  ключами  (такими,  как sError в предыдущем примере) за-
      писываются в одну индексную запись до 16 за один раз.  aIndexSize
      должен  быть достаточно большим для добавления всех сгенерирован-
      ных индексных записей. Каждый элемент индекса занимает 6 байт.


      constructor   TStrLIstmaker( StreamableInit streamableInit );
      -----------                                         (защищенный)

           Каждому потоковому  классу необходим "построитель" для расп-
      ределения памяти для его объектов  вместе  с  инициализированными
      указателями  виртуальной  таблицы.  Это  достигается путем вызова
      конструктора с аргументом  типа  StreamableInit.  Смотрите  также
      главу 8.

           См. также: TStringList::put, ~TStrListMaker


      destructor    ~TstrListmaker();
      ----------
           Освобождает память, выделенную маркеру списка строк.

           См. также: TStrListMaker::TstrListMaker


      build         static TStreamable *build();
      -----
           Вызывается для создания  объекта  в  определенных  ситуациях
      чтения из потока.

           См. также: TStreamableClass, ipstream::readData, TStreamable



      put           void put(ushort key, const char *s);
      ---
           Добавляет заданную  строку  s  к вызываемому списку строк (с
      заданным числовым key).


      write         virtual void write( opstream& os );
      -----
           Осуществляет запись в выходной поток os.

           См. также: TStreamableClass, TStreamable, opstream


                           Дополнительные функции

           Определенные функции относятся к классу TStrListMaker, но не
      являются методами.








        TSystemError                                            SYSTEM.H
      -----------------------------------------------------------------

                              ╔══════════════╗
                              ║ TSystemError ║
                              ╚══════════════╝

           TSystemError поддерживает  обработчики  системных  ошибок  и
      соответствующий сервис.  Большинство из его полей являются  внут-
      ренними  и  не  будут  интересны  для обычных прикладных программ
      Turbo Vision.

                                    Поля

      ctrlBreakHit  static Boolean near ctrlBreakHit;
      ------------
           Устанавливается в  значение  True,   если   нажата   клавиша
      Ctrl-Break во время выполнения программы.


                                   Методы

      constructor   TSystemError();
      -----------
           Создает объект  TSystemError  и   устанавливает   обработчик
      системных ошибок путем вызова resume.


      destructor    ~TSystemError();
      ----------
           Удаляет обработчик системных ошибок путем вызова suspend.


      resume        static void resume();
      ------
           Устанавливает обработчик системных ошибок.


      suspend       static void susupend();
      -------
           Удаляет обработчик системных ошибок.








       TTextDevice                                            TEXTVIEW.H
      ------------------------------------------------------------------

                                ┌───────────┐
                                │ TScroller │
                                └─────┬─────┘
                               ╔══════╧══════╗
                               ║ TTextDevice ║
                               ╚══════╤══════╝
                                ┌─────┴─────┐
                                │ TTerminal │
                                └───────────┘

           Класс TTextDevice - это  прокручиваемый  драйвер  устройства
      типа  TTY.  Кроме  полей  и  методов,  наследуемых  от TScroller,
      TTextDevice определяет виртуальные методы  для  чтения  и  записи
      строк в и из устройства.  TTextDevice существует, как базовый тип
      для  порождения  реальных  терминальных  драйверов.   TTextDevice
      использует деструктор TScroller.


                                   Методы

      constructor   TTextDevice(const TRect& bounds, TScrollBar
      -----------               *aHScrollBar, TScrollBar *aVScrollBar);

           Создает объект TTextDevice с заданными bounds,  горизонталь-
      ными  и   вертикальными   элементами   прокрутки   путем   вызова
      TTextScroller::TTextScroller  со  значением  bounds и аргументами
      бегунка прокрутки.

           См. также: TTextScroller::TTextScroller


      do_sputn      int do_sputn( const char *s, int );
      --------
           Переопределяет соответствующий  метод  в  классе  streambuf.
      Этот метод является внутренним и вызывается во всех случаях, ког-
      да символьная строка вставляется во внутренний буфер.


      overflow      int overflow( int );
      --------
           Переопределяет соответствующий  метод  в  классе  streambuf.
      Когда внутренний буфер  в  streambuf  полон,  и  iostream,  соот-
      ветствующий  этому streambuf,  пытается занести еще один символ в
      буфер, то вызывается метод overflow. Его аргументом является сим-
      вол,   который  вызывает  переполнение.  В  TTextDevice  основной
      streambuf не имеет буфера,  так что каждый символ вызывает  пере-
      полнение.   Классы,   наследуемые   из   TTextDevice,  такие  как
      TTerminal,  будут рассматривать этот символ просто как  следующий
      символ в выходном потоке.


                                     Палитра

           Объекты текстового устройства используют по умолчанию палит-
      ру  cpScroller для отображения заданных значений в 6 и 7 элементы
      стандартной палитры программы.

                             1   2
                           ╔═══╤═══╗
              cpScroller   ║x06│x07║
                           ╚═╤═╧═╤═╝
               Нормальный ───┘   └──── Подсвеченный









       TView                                                     VIEWS.H
      -----------------------------------------------------------------

                              ┌─────────┐
                              │ TObject │
                              └────┬────┘
                            ╔══════╧══════╗
                            ║    TView    ║
                            ╚╤╤╤╤╤╤╤╤╤╤╤╤╤╝
              ┌──────────────┘│││││││││││└──────────────┐
              │        ┌──────┘│││││││││└──────┐        │
              │        │┌──────┘│││││││└──────┐│        │
          ┌───┴────┐   ││┌──────┘│││││└──────┐││    ┌───┴────┐
          │ TGroup │   │││┌──────┘│││└──────┐│││    │ TFrame │
          └────────┘   ││││┌──────┘│└──────┐││││    └────────┘
               ┌───────┘││││  ┌────┴────┐  ││││└────────┐
          ┌────┴─────┐  ││││  │ TButton │  ││││   ┌─────┴────┐
          │ TCluster │  ││││  └─────────┘  ││││   │ THistory │
          └──────────┘  │││└──────┐        ││││   └──────────┘
                ┌───────┘││ ┌─────┴─────┐  │││└────────┐
          ┌─────┴─────┐  ││ │ TScroller │  │││  ┌──────┴─────┐
          │ TMenuView │  ││ └───────────┘  │││  │ TScrollBar │
          └───────────┘  ││       ┌────────┘││  └────────────┘
                 ┌───────┘│ ┌─────┴──────┐  │└────────┐
          ┌──────┴──────┐ │ │ TInputLine │  │  ┌──────┴──────┐
          │ TBackGround │ │ └────────────┘  │  │ TListViewer │
          └─────────────┘ │                 │  └─────────────┘
                   ┌──────┴──────┐   ┌──────┴──────┐
                   │ TStatusLine │   │ TStaticText │
                   └─────────────┘   └─────────────┘


           Большинство программ  используют  потомков  TView:   TFrame,
      TScrollBar, TScroller, TListViewer,TGroup и TWindow.

           Объекты TView  редко реализуются в программах,  написанных с
      использованием Turbo Vision.  Класс TView существует, главным об-
      разом, для того,  чтобы предоставить своим потомкам основные поля
      и соответствующие методы по их обработке.

                                    Поля

      commandSetChanged
      -----------------
           static Boolean commandSetChanged;

           Устанавливается в  True,  когда  набор  команд отображаемого
      объекта изменяется через enable, disable или вызов setCommand.

           См. также: TView::enableCommand(s),TView::disableCommand(s),
      TView::setCommands


      curCommandSet
      -------------
           static TCommandSet curCommandSet;

           Хранит набор команд, разрешенных в настоящий момент времени,
      для данного  отображаемого  объекта.  Сначала   команды   cmZoom,
      cmClose, cmResize,  cmNext,  cmPrev  не  разрешены.  Данное  поле
      постоянно контролируется handleEvent для определения того,  какие
      из произошедших  событий  необходимо обслужить.  curCommandSet не
      должен изменяться  непосредственно.  Используйте  соответствующие
      вызовы set, enable и disable.

           См. также: константы cmXXXX, TView::setCommands,
      TView::enableCommand(s),TView::disableCommand(s)


      cursor        TPoint cursor;
      ------
           Текущее положение   курсора  внутри  отображаемого  объекта.
      Курсор видим только, если отображаемый объект активен (sfFocused)
      и курсор включен (sfCursorVis). Форма курсора - это подчеркивание
      или прямоугольная область (задается в sfCursorIns).

           См. также:  setCursor, showCursor, hideCursor, normalCursor,
      blockCursor


      dragMode       uchar dragMode;
      --------
           Определяет поведение отображаемого объекта при перемещении с
      помощью "мыши".

               Биты dragMode определены следующим образом:

                   ┌── dragMode ─┐
              старший бит   младший бит

                   ┌─┬─┬─┬─────────── dmLimitAll = 0xF0
                  ╔╧╤╧╤╧╤╧╤═╤═╤═╤═╗
                  ╚╤╧╤╧╤╧╤╧═╧═╧╤╧╤╝
                   │ │ │ │     │ └─── dmDragMove = 0x01
                   │ │ │ │     └───── dmDragGrow = 0x02
                   │ │ │ └─────────── dmLimitLoX = 0x10
                   │ │ └───────────── dmLimitLoY = 0x20
                   │ └─────────────── dmLimitHiX = 0x40
                   └───────────────── dmLimitHiY = 0x80

           Рис. 13.1. Значения бит в dragMode.

           Маски dragMode  определены  в  разделе  "Константы  dragMode
      dmXXXX" главы 16.

           См. также: TView::dragView


      errorAttr     static uchar errorAttr;
      ---------
           Данный атрибут используется при выводе сообщений об ошибках.
      Например, mapColor возвращает errorAttr, если вызывается с непра-
      вильным параметром color.  По умолчанию  errorAttr  установлен  в
      "0CF", что соответствует мигающим красным символам на белом фоне.

           См. также: TView::mapColor


      eventMask     ushort eventMask;
      ---------
           eventMask - это флаг, который определяет, какие классы собы-
      тий будут распознаваться данным отображаемым объектом. По умолча-
      нию eventMask  разрешает  evMouseDown,  evKeyDown  и   evCommand.
      Присвоение eventMask значения 0xFFFF приведет к тому, что отобра-
      жаемый объект будет реагировать на все классы событий, а значение
      0 приводит к тому, что отображаемый объект не на что не будет ре-
      агировать. Для детального описания  классов  событий  см.  раздел
      "Константы evXXXX" главы 16.

           См. также:TView::handleEvent


      growMode      uchar growMode;
      --------
           Определяет, как будет изменяться данный отображаемый объект,
      когда его владелец изменит свой размер. growMode определяется од-
      ним или более из следующих значений:

                    ┌── growMode ─┐
               старший бит   младший бит

                            ┌─┬─┬─┬─── gfGrowAll = 0x0F
                   ╔═╤═╤═╤═╤╧╤╧╤╧╤╧╗
                   ╚╤╧═╧╤╧╤╧╤╧╤╧╤╧╤╝
                    └─┬─┘ │ │ │ │ └─── gfGrowLoX = 0x01
                      │   │ │ │ └───── gfGrowLoY = 0x02
             Неопределено │ │ └─────── gfGrowHiX = 0x04
                          │ └───────── gfGrowHiY = 0x08
                          └─────────── gfGrowRel = 0x10

           Рис. 13.2. Значения бит в growMode.

           Пример: growMode = gfGrowLoX | gfGrowLoY;

           См. также: константы gfXXXX growMode


      helpCtx       ushort helpCtx;
      -------
           Контекст подсказки отображаемого объекта. Когда отображаемый
      объект активен, это поле равно контексту подсказки (помощи) соот-
      ветствующему исполняемому фрагменту программы. Однако, если номер
      контекста  помощи равен hcNoContext,  то это означает,  что соот-
      ветствующего контекста нет.

           См. также: TView::getHelpCtx.


      next          TView *next;
      ----
           Указывает на  следующий в Z-последовательности эквивалентный
      отображаемый объект. Если же это последний подобъект, то next бу-
      дет указывает на первый подобъект данного владельца.


                              options ushort

      options;
      -------
           Биты флага options определяют поведение отображаемого объек-
      та. Эти биты описаны следующим образом:

           ┌───────────── options ───────┐
          старший бит               младший бит

                       ┌─┬─────────────────── ofCentered    = 0x300
          ╔═╤═╤═╤═╤═╤═╤╧╤╧╤═╤═╤═╤═╤═╤═╤═╤═╗
          ╚╤╧═╧═╧═╧═╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╧╤╝
           └────┬────┘ │ │ │ │ │ │ │ │ │ └─── ofSelectable  = 0x001
                │      │ │ │ │ │ │ │ │ └───── ofTopSelect   = 0x002
         Неопределено  │ │ │ │ │ │ │ └─────── ofFirstClick  = 0x004
                       │ │ │ │ │ │ └───────── ofFramed      = 0x008
                       │ │ │ │ │ └─────────── ofPreProcess  = 0x010
                       │ │ │ │ └───────────── ofPostProcess = 0x020
                       │ │ │ └─────────────── ofBuffered    = 0x040
                       │ │ └───────────────── ofTileable    = 0x080
                       │ └─────────────────── ofCenterX     = 0x100
                       └───────────────────── ofCenterY     = 0x200

                   Рис. 13.3. Значения бит флага options.

           Для подробного   знакомства  с  флагом  options  см.  раздел
      "Константы флага ofXXXX" главы 16.


      origin        TPoint origin;
      ------
           Координаты (x, y) верхнего левого угла отображаемого объекта
      относительно origin владельца.

           См. также: moveTo, locate


      owner         TGroup *owner;
      -----
           owner указывает  на  объект  TGroup,  который владеет данным
      отображаемым объектом.  В случае значения 0,  данный отображаемый
      объект не  имеет  владельца.  Он отображается в границах его вла-
      дельца и "отсекается" по этим границам.


      showMarkers   static Booiean showMarkers;
      -----------
           Указывает на то,  нужно ли размещать маркера вокруг активных
      органов управления.      TProgram::initScreen       устанавливает
      showMarkers в True,  если видеорежим монохромный,  в для цветного
      режима - в False. Однако, все зависимости от текущего видеорежима
      данный элемент может быть установлен в соответствии с вашим жела-
      нием.

           См. также: TProgram::initScreen, spesialChars


      shutDown      virtual void shutDown();
      --------
           Используется методом  TObject::destroy для корректного унич-
      тожения потомков и родственников.  shutDown  переопределяется  во
      многих   классах   для  обеспечения  корректной  установки  полей
      родственников, когда вызывается destroy.

           См. также: глава 6, "Разработка надежных программ"


      size          TPoint size;
      ----
           Размер отображаемого объекта.

           См. также: growTo, locate


      state         ushort state;
      -----
           Состояние отображаемого объекта задается набором бит во фла-
      ге state.  Многие  методы  класса  TView проверяют и/или изменяют
      родственников, когда вызывается destroy.

           См. также: глава 6, "Разработка надежных программ"


      size          TPoint size;
      ----
           Размер отображаемого объекта.

           См. также: growTo, locate


      state         ushort state;
      -----
           Состояние отображаемого объекта задается набором бит во фла-
      ге state.  Многие  методы  класса  TView проверяют и/или изменяют
      флаг state, вызывая для этого TView::setState.

           Метод TView::getState(aState) возвращает значение True, если
      состояние данного  отображаемого  объекта  равно  aState.  Биты в
      state мнемонически представлены константами, описанными в разделе
      "Константы флага состояния sfXXXX" главы 16.





      handleEvent   virtual void handleEvent(TEvent& event);
      -----------
           Основной метод,  через который реализована вся обработка со-
      бытий в  Turbo  Vision.  Поле what параметра event содержит класс
      события (evXXXX),  а оставшиеся поля  этого  параметра  описывают
      данное событие.  Для указания того, что событие обработано, метод
      handleEvent обращается  к  clearEvent.  Метод  handleEvent  почти
      всегда переопределяется в порождаемых классах.

           TView.HandleEvent обрабатывает события evMouseDown следующим
      образом: если данный отображаемый объект не выбран (sfSelected) и
      не запрещен  (sfDisabled) и если этот отображаемый объект - выде-
      ляемый (ofSelectable),  то отображаемый объект выделяется  с  по-
      мощью метода Select. Другие события в TView::handleEvent не обра-
      батываются.

           См. также: TView::clearEvent

      hide          void hide();
      ----
           Делает невидимым отображаемый объект,  вызывая setState  для
      очистки флага sfVisible в state.

           См. также: sfVisible, TView::setState, TView::show


      hideCursor    void hideCursor();
      ----------
           Делает невидимым курсор, очищая бит sfCursorVis в state.

           См. также: sfCursorVis, TView::showCursor


      keyEvent      void keyEvent(TEvent& event);
      --------
           Возвращает в переменной event очередное  событие  evKeyDown.
      Данный метод не возвращает управления до тех пор, пока событие от
      клавиатуры не будет доступно.  При этом игнорируются  все  другие
      события.

           См. также: TView::getEvent, TView::eventAvail


      locate        void locate(TRect bounds);
      ------
           Изменяет границы отображаемого объекта на заданные  в  аргу-
      менте bounds.  Отображаемый  объект  перерисовывается в его новом
      положении.  Метод locate вызывает sizeLimits для  проверки  того,
      что   данные  границы  bounds  правильны,  затем  вызывает  метод
      changeBounds для изменения границ и заново отображает  отображае-
      мый объект.

           См. также: TView::growTo, TView::moveTo, TView::changeBounds


      makeFirst     void makeFirst();
      ---------
           Перемещает отображаемый  объект в вершину списка подобъектов
      владельца.  Вызов  makeFirst  соответствует  putInFrontOf(owner->
      first()).

           См. также: TView::putInFrontOf


      makeGlobal    TPoint makeGlobal(TPoint sourse);
      ----------
           Преобразует координаты в точке sourсe из локальных  (отобра-
      жаемый объект) в глобальные (экран) и возвращает результат.

           См. также: TView::makeLocal


      makeLocal     TPoint makeLocal(TPoint sourse);
      ---------
           Преобразует координаты  точки source из глобальных (экран) в
      локальные (отображаемый  объект) и возвращает результат.  Полезно
      для преобразования поля event.where в событии evMouse из глобаль-
      ных координат  в  локальные.  Например,  mouseLoc   =   makeLocal
      (eventWhere).

           См. также: TView::makeGlobal, TView::mouseInView


      mapColor      uchar mapColor(uchar color);
      --------
           Отображает цвет,  заданный в color, в смещение в текущей па-
      литре. mapColor вызывает getPalette для каждой группы владельца в
      цепочке. mapColor успешно отображает смещение в каждую палитру до
      тех пор, не будет достигнута последняя палитра. Однако если color
      неправильный (например нарушен диапазон) для какой-либо палитры в
      цепочке, то mapColor возвращает errorAttr.

           См. также: TView::getPalette, TView::errorAtrr


      mouseEvent    Boolean mouseEvent(TEvent& event, ushort mask);
      ----------
           Устанавливает очередное событие от "мыши" в аргументе event.
      Возвращает значение True, если это событие соответствует аргумен-
      ту mask,  и False,  если возникло событие evMouseUp. Данный метод
      позволяет отслеживать  перемещения  "мыши"  - при нажатой кнопке;
      это может быть использовано, например, в операциях по перемещению
      выделенных блоков в текстовых  редакторах.

           Приведем фрагмент  программы handleEvent,  в котором "слеже-
      ние" за "мышью" позволяет управлять курсором отображаемого объек-
      та.

               virtual void TMyView::handleEvent(TEvent& event)
               {
                  TView::handleEvent(event);
                  switch ( event.what )
                  {
                     case evMouseDown:
                        do
                        {
                           makeLocal(event.Where, mouse);
                           setCursor(mouse.x, mouse.y);
                        }
                        while (!(mouseEvent(event, evmouseMove)));
                        clearEvent(event);
                        break;
                  }
                   ...
               };

           См. также: константы событий evXXX, TView::keyEvent,
      TView::getEvent


      mouseInView   Boolean mouseInView(TPoint mouse);
      -----------
           Возвращает значение True,  если аргумент mouse  (заданный  в
      глобальных координатах) находится внутри вызывающего отображаемо-
      го объекта.

           См. также: TView::makeLocal, TView::makeGlobal


      moveTo        void moveTo(short x, short y);
      ------
           Перемещает origin в точку (x,y)  относительно  отображаемого
      объекта-владельца. Поле size данного отображаемого объекта не из-
      меняется.

           См. также:TView::origin,     TView::size,     TView::locate,
      TView::growTo


      nextView      TView *nextView();
      --------
           Возвращает указатель на следующий подобъект в списке подобъ-
      ектов владельца.  Возвращается  0,  если  вызывающий отображаемый
      объект последний в списке его владельца.

           См. также: TView::prevView, TView::prev, TView::growTo


      normalCursor  void normalCursor();
      ------------
           Очищает бит  sfCursorIns  в  state,  переводя курсор в режим
      подчеркивания. Если при этом  sfCursorVis  установлен,  то  новый
      курсор будет отображаться.

           См. также:   sfCursorIns,   sfCursorVis,  TView::hideCursor,
      TView::blockCursor


      prev          TView *prev();
      ----
           Возвращает указатель на предыдущий подобъект  в  списке  по-
      добъектов владельца.  Если вызывающий отображаемый  объект  стоит
      первым в списке его владельца, то prev возвращает последний отоб-
      ражаемый объект в этом списке.  Заметим, что TView.prev интерпре-
      тирует список как циклический, в то время как TView::prevView ин-
      терпретирует его как линейный.

           См. также: TView::nextView, TView::prevView, TView::next


      prevView      TView *prevView();
      --------
           Возвращает указатель  на  предыдущий  подобъект в списке по-
      добъектов владельца. Возвращается 0, если вызывающий отображаемый
      объект - первый в списке владельца.  Заметим, что TView::prev ин-
      терпретирует список как кольцевой, а TView::prevView - как линей-
      ный.

           См. также: TView::nextView, TView::prev


      putEvent      virtual void putEvent(TEvent& event);
      --------
           Помещает событие, заданное в event, в очередь событий, в ре-
      зультате чего это событие становится очередным событием,  возвра-
      щаемым getEvent. Этим способом в очередь событий может быть поме-
      щено только одно событие. Этот метод часто используется отобража-
      емыми объектами для посылки командных событий, например:

               event.what = evCommand;
               event.Command = cmSaveAll;
               event.infoPtr = 0;
               putEvent(event);

           По умолчанию  TView::putEvent  вызывает  метод putEvent вла-
      дельца данного отображаемого объекта.

           См. также:        TView::eventAvail,        TView::getEvent,
      TView::handleEvent


      putInFrontOf  void putInFrontOf(TView *target);
      ------------
           Помещает вызывающий отображаемый объект  перед  отображаемым
      объектом target в списке подобъектов владельца. Вызов

           MyView.putInFrontOf(owner->first);

      эквивалентен TView.makeFirst. Этот метод работает, изменяя указа-
      тели в списке подобъектов.  В зависимости от позиции других отоб-
      ражаемых объектов и их состояния "видимости",  putInFrontOf может
      отсекать закрываемые отображаемые объекты. Если данный отображае-
      мый  объект  -  выбираемый (см.  ofSelectable) и помещается перед
      всеми другими подобъектами, то этот отображаемый подобъект стано-
      вится выбранным.

           См. также: TView::makeFirst


      read           virtual void *read( ipstream& is);
      ----
           Читает из входного потока is.

           См. также: TStreamableClass, TStreamable,классы ipstream


      resetCursor    virtual void resetCursor();
      -----------
           Инициализирует курсор.


      select        void select();
      ------
           Выбирает отображаемый объект (см. sfSelected). Если владелец
      отображаемого объекта  активен,  то  и данный отображаемый объект
      так же становится активным  (см.  sfFocused).  Если  отображаемый
      объект  имеет  установленный флаг ofTopSelect в поле options,  то
      и этот отображаемый объект перемещается в вершину списка  подобъ-
      ектов владельца (используя для этого вызов TView::makeFirst).

           См. также:     sfSelected,      sfFocused,      ofTopSelect,
      TView::makeFirst


      setBounds     void setBounds(const TRect& bounds);
      ---------
           Устанавливает ограничивающую прямоугольную область отобража-
      емого объекта в значение,  полученное из параметра  bounds.  Поле
      origin устанавливается равным bounds.a,  а поле size устанавлива-
      ется равным разности bounds.b - bounds.a. Метод setBounds вызыва-
      ется  только  из  переопределенного  метода  changeBounds - вы не
      должны вызывать setBounds непосредственно.

            См. также:  TView::origin,  TView::size, TView::calcBounds,
      TView::changeBounds, TView::getBounds, TView::getExtent


      setCommands   static void setCommands(TCommandSet& commands);
      -----------
           Изменяет текущий   набор   команд   на  заданный  аргументом
      commаnds.

           См. также: TView::enableCommands, TView::disableCommands


      setCursor     void setCursor(short x, short y);
      ---------
           Перемещает аппаратный курсор в точку  (x,y),  используя  от-
      носительные координаты данного отображаемого объекта (локальные).
      (0,0) - это верхний левый угол.

           См. также:        TView::makeLocal,       TView::hideCursor,
      TView::showCursor


      setData       virtual void setData(void *rec);
      -------
           Метод setData должен копировать dataSize байт из записи дан-
      ных, заданной указателем rec, в отображаемый объект. Механизм за-
      писи данных обычно используется только в  отображаемых  объектах,
      которые реализуют элементы управления для диалоговых окон.

           По умолчанию TView::setData  ничего не делает.

           См. также: TView::dataSize, TView::getData


      setState    virtual void setState(ushort aState, Boolean enable);
      --------
           Устанавливает или очищает флаг состояния в поле state. Пара-
      метр aState задает изменяемый флаг состояния (см.  sfXXXX), а па-
      раметр enable  указывает,  будет  ли  этот  флаг  устанавливаться
      (True) или  очищаться  (False).  setState  затем  выполняет соот-
      ветствующие действия по отражению нового состояния, такие как пе-
      рерисовка тех  отображаемых  объектов,  которые появились,  когда
      данный отображаемый объект исчез (sfVisible) или перепрограммиро-
      вание аппаратуры,  когда  изменилась форма курсора (sfCursorVis и
      sfCursorIns) и т.п.

           Метод setState иногда переопределяется для выполнения допол-
      нительных действий, основанных на флагах состояний. Например, тип
      TFrame переопределяет метод setState для своей перерисовки, когда
      окно выделяется или перемещается:

              void TFrame::setState(ushort aState, Boolean enable);
              {
                 TView::setState(aState, enable);
                 if (aState & (sfActive | sfDragging) != 0)
                  drawView();
              }

           Другая причина,  возможного  переопределения  setState - это
      необходимость разрешить или запретить команды,  которые обрабаты-
      ваются определенным отображаемым объектом:

              void TMyView::setState(ushort aState, Boolean enable);
              { TCommandSet myCommands;
                MyCommands.enableCmd(cmCut);
                MyCommands.enableCmd(cmCopy);
                MyCommands.enableCmd(cmPaste);
                MyCommands.enableCmd(cmClear);
                TView::setState( aState, enable );
                if ( aState = sfSelected )
                {
                   if enable
                      enableCommands(myCommands)
                   else
                      disableCommands(myCommands);
                }
              }

           См. также:  TView::getState,  TView::state,  константы флага
      состояния sfXXXX

           См. также:  TView::getState,  TView::state,  константы флага
      состояния sfXXXX


      show          void show();
      ----
           Если данный отображаемый объект видим (sfVisible), то ничего
      не происходит. В противном случае, show показывает этот отобража-
      емый объект,  вызывая для этого setState с целью установки  флага
      sfVisible в поле state.

           См. также: TView::setState


      showCursor    void showCursor();
      ----------
           Включает аппаратный курсор,  устанавливая sfCursorVis. Заме-
      тим, что по умолчанию курсор неотображаем.

           См. также: sfCursorVis, TView::hideCursor


      sizeLimits    virtual void sizeLimits(TPoint& min,  TPoint& max);
      ----------
           Возвращает в переменных min и max минимальное и максимальное
      значения, которые может принимать поле size.

           По  умолчанию  TView::sizeLimits  возвращает  (0,0)  в min и
      owner->size в max. Если owner есть 0, то max.x и max.y устанавли-
      ваются в MAXSHORT.

           См. также: TView::size


      TopView       TView *topView();
      -------
           Возвращает указатель  на текущий модальный отображаемый объ-
      ект, или 0, если такового нет.


      valid         virtual Boolean valid(ushort command);
      -----
           Этот метод используется для проверки правильности отображае-
      мого объекта после его создания или в момент, когда заканчивается
      модальное состояние (при вызове endModal).

           Значение параметра command равное cmValid (ноль)  указывает,
      что отображаемый  объект должен проверить результат работы своего
      конструктора: valid(cmValid) должен вернуть значение  True,  если
      отображаемый объект был успешно создан и отныне готов к использо-
      ванию. в противном случае возвращается False.

           Любое другое (отличное от нуля) значение  параметра  command
      указывает,  что  текущее модальное состояние (такое как модальное
      диалоговое окно) должно по своему  завершению  вернуть  результат
      работы команды command. В этом случае valid должна проверять пра-
      вильность видимого объекта.

           valid отвечает за то, чтобы пользователь был вовремя предуп-
      режден о неправильности отображаемого объекта.

           По умолчанию TView::valid просто возвращает True.

           См. также:          TGroup::valid,           TDialog::valid,
      TProgram::validView


      write         virtual void write( opstream& os);
      -----
           Пишет в выходной поток os.

           См. также:     TStreamableClass,     TStreamable,     классы
      opstreamable


      writeBuf
      --------
           void writeBuf( short x,  short y,  short w,  short h,  const
                          void far *b);
           void writeBuf( short x,  short y,  short w,  short h,  const
                          TDrawBuffers& b);

           Выводит на экран заданный буфер, начиная с координат (x,y) и
      заполняя область  шириной  w  и  высотой  h.  Данный  метод может
      использоваться только в методах draw.  Обычно используется указа-
      тель на  буфер типа ТDrawBuffer&,  но может быть применен и любой
      массив слов,  где каждое слово содержит символ в младшем байте  и
      атрибут в старшем байте.

           См. также: TView::draw


      writeChar
      ---------
           void writeChar(short x, short y, short c, uchar color, short
                          count);

           Начиная с  точки  (x,y),  выводит  count копий символа "c" в
      цвете, заданном объектом с номером color в палитре текущего отоб-
      ражаемого объекта. Может использоваться только в методах draw.

           См. также: TView::draw


      writeCStr
      ---------
           void writeCStr(short x,  short  y,  char  far  *cstr,  uchar
      color);

           Выводит управляющую строку cstr в цвете,  заданном элементом
      с номером color в палитре данного отображаемого объекта,  начиная
      с точки (x,y).  WriteCStr использует тильду (~) как переключатель
      атрибутов и цветов. Может использоваться только в методах draw.


      writeLine
      ---------
           void writeLine( short x,  short y,  short w,  short h, const
                           void far *buf);
           void writeLine( short x,  short y,  short w,  short h, const
                           TDrawBuffer& buf);

           Выводит строку,  содержащуюся в буфере buf на экран, начиная
      с точки (x,y) и внутри прямоугольника,  определенного шириной w и
      высотой h. Если h больше 1, строка будет повторяться h раз. Может
      использоваться только в методе draw.

           См. также: TView::draw


      writeStr
      --------
           void writeStr( short x,  short y,  const  char  *str,  uchar
      color);

           Выводит строку str в цвете, определенном элементом с номером
      color в палитре данного отображаемого объекта,  начиная  с  точки
      (x,y). Может использоваться только в методе draw.

           См. также: TView::draw

                            Дружественные функции

           Функция genRefs является другом TView

                           Дополнительные функции

           Некоторые функции-операторы  родственны классу TView,  но не
      являются его методами.





                                     Методы

      constructor   TView(const Trect& bounds);
      -----------
           Создает объект  TView  с прямоугольной областью,  заданной в
      bounds. TView::TView вызывает конструктор класса TObject и иници-
      ализирует поля нового TView следующими значениями:

          ─────────────────────────────────────────────────────────────
          cursor     (0, 0)
          dragMode   dmLimitLoY
          eventMask  evMouseDown | evKeyDown | evCommand
          growMode   0
          helpCtx    hcNoContext
          next       0
          options    0
          origin     (Bounds.A.x, Bounds.A.y)
          owner      0
          size       (Bounds.B.x - Bounds.A.x, Bounds.B.y - Bounds.A.y)
          state      sfVisible
          ─────────────────────────────────────────────────────────────

           См. также: TObject::TObject


      constructor
      -----------
           TView( StreamableInit StreamableInit);       (защищенный)

           Каждому поточному  классу  необходим  "построитель" для кор-
      ректного выделения памяти под его объекты,  а также для инициали-
      зации указателей vtable.  Это достигается вызовом этого конструк-
      тора с аргументом типа StreamableInit. Смотрите также главу 8.


      destructor    ~TView();
      ----------
           Скрывает отображаемый объект и затем, если он имеет владель-
      ца, удаляет его из соответствующей группы.


      blоckCursor   void blоckCursor();
      -----------
           Устанавливает sfCursorIns,  чтобы  изменить форму курсора на
      блочную. Курсор будет отображаемым  только  в  том  случае,  если
      установлен флаг sfCursorVis (и отображаемый объект также видим).

           См. также:  sfCursorIns,  sfCursorVis,  TView::normalCursor,
      TView::showCursor, TView::hideCursor


      build         static TStreamable *build();
      -----
           Вызывается для создания объекта в некоторых ситуациях чтения
      из потока.

           См. также: TStreamableClass, ipstream::readData


      сalcBounds  virtual void calcBounds(TRest& bounds, TPoint delta);
      ----------
           Когда владелец отображаемого объекта изменяет размер, он вы-
      зывает методы calcBounds и  changeBounds  для  всех  подобъектов.
      calcBounds должен  вычислять  новые границы отображаемого объекта
      на основе delta,  на которое изменился размер  его  владельца,  и
      возвращает новые границы в bounds.

           TView::calcBounds вычисляет  новые границы, используя флаги,
      заданные в поле TView::growMode.

           См. также: TView::getBounds, TView::changeBounds,  константы
      gfXXXX growMode


      changeBounds  virtual void changeBounds(const TRect& bounds);
      ------------
           Изменяет границы  отображаемого объекта (поля origin и size)
      на прямоугольную область, заданную параметром bounds. После изме-
      нения границ changeBounds должен перерисовать данный отображаемый
      объект.  changeBounds вызывается различными методами TView, но не
      должен вызываться непосредственно.

           Метод TView::changeBound вызывает сначала setBounds(bounds),
      а затем drawView.

           См. также: TView::locate, TView::moveTo, TView::growTo


      clearEvent    void clearEvent(TEvent& event);
      ----------
           Этот стандартный метод используется в handleEvent для указа-
      ния того,  что  отображаемый  объект  успешно  обработал событие.
      Устанавливает event.what в evNоthing  и  event.message.infoPtr  в
      this.

           См. также: методы handleEvent


      сommandEnabled static Boolean commandEnabled(ushort command);
      --------------
           Возвращает значение  True,  если  команда command разрешена,
      иначе - False.  Заметим, что когда вы изменяете модальное состоя-
      ние, можно  запретить или разрешить необходимые команды.  Однако,
      когда вы возвращаетесь в предыдущее модальное состояние, исходный
      набор команд будет восстановлен.

           См. также: TView::disableCommand, TView::enableCommand,
      TView::setCommands.


      containsMouse Boolean containsMouse(TEvent&  event);
      -------------
           Возвращает True, если внутри отображаемого объекта произошло
      какое-то событие от "мыши". В противном случае возвращает False.

           См. также: mouseInView


      dataSize      virtual ushort dataSize();
      --------
           Метод dataSize  должен  использоваться для получения размера
      данных, читаемых и записываемых в записи данных с помощью методов
      setData  и  getData.  Механизм  записи данных обычно используется
      только в отображаемых объектах, которые реализуют элементы управ-
      ления для диалоговых окон.

           Чтобы указать,  что поля не передавались, метод TView::data-
      Size возвращает нулевое значение.

           См. также: TView::getData, TView::setData


      disableCommand static void disableCommands( ushort command);
      --------------
           Запрещает указанную команду. Если в результате вызова данно-
      го метода набор команд изменился, то commandSetChanged устанавли-
      вается в True.

           См. также:    TView::enableCommand,   TView::disableCommands


      disableCommands static void
      --------------- disableCommands(TCommandSet& commands);

           Запрещает команды, указанные в аргументе commands.

           См. также:    TView::commandEnabled,   TView::enableCommands
      TView::setCommands


      dragView
      --------
           virtual  void  dragView(TEvent&  event,  uchar  mode, TRest&
           limits, TPoint minSize, TPoint maxSize);

           Перемещает отображаемый объект с помощью  "мыши",  используя
      режим перемещения,  заданный флагами dmXXXX в аргументе mode. Ар-
      гумент limits указывает  прямоугольник  (в  координатной  системе
      владельца) внутри которого может перемещаться данный отображаемый
      объект,  а min и max указывают минимальный и максимальный размеры
      этого отображаемого объекта, которые он может принимать. Событие,
      приводящее к операции перемещения передается  в  аргументе  event
      для того,  чтобы отличить перемещение с помощью "мыши" от переме-
      щения, с использованием клавиш управления курсором.

           См. также: TView::dragMode, конст. режима перемещения dmXXXX


      draw
      ----
           virtual void draw();

           Вызывается, когда  отображаемый объект должен отобразить сам
      себя.  Метод draw должен покрывать всю область отображаемого объ-
      екта. Этот метод должен переопределяться для каждого порожденного
      объекта. Метод draw редко вызывается  непосредственно,  поскольку
      более  эффективно  использовать  метод  drawView,  который рисует
      только действительно отображаемые в данный момент времени  объек-
      ты, т.е. те области, хотя бы часть которых расположена на экране.
      При необходимости, draw может обратиться к методу getClipRect для
      получения прямоугольной области, которую необходимо перерисовать,
      а затем рисовать только эту  область.  Для  сложных  отображаемых
      объектов это может значительно улучшить производительность.

           См. также: TView::drawView


      drawCursor    void drawCursor();
      ----------
           Если отображаемый объект активен, курсор устанавливается вы-
      зовом resetCursor.

           См. также: TView::resetCursor


      drawHide      void drawHide(TView *lastView);
      --------
           Вызывает drawCursor,  а затем drawUnderView. Последний пере-
      рисовывает все подобъекты (если необходимо с тенью) до достижения
      заданного lastView.


      drawShow      void drawShow(TView *lastView);
      --------
           Вызывает drawView,  а  затем,  если  в  state установлен бит
      sfShadow, вызывает drawUnderView для отображения тени.


      drawUnderRect void drawUnderRect(TRect& r, TView *lastView);
      -------------
           Вызывает owner->clip.intersect(r)  для  определения области,
      которую необходимо нарисовать.  Затем все  подобъекты  следующего
      отображаемого объекта  до заданного в lastView рисуются с помощью
      drawSubView. И,   наконец,   owner->clip   инициализируется    из
      owner->getExtent.

           См. также: TView::drawSubViews


      drawUnderView
      -------------
           void drawUnderView(Boolean doShadow, TView *lastView);

           Вызывает drawUnderRect(r,lastView),  где  r  задает  текущие
      границы вызываемого отображаемого объекта. Если же doShadow равно
      True, то границы  данного  отображаемого  объекта  предварительно
      увеличиваются на shadowSize.

           См. также: TView::DrawUnderRect, shadowSize


      drawView      void drawView();
      --------
           Вызывает draw, если метод exposed вернул значение True, ука-
      зывая тем  самым,  что  данный  отображаемый  объект "видим" (см.
      sfExposed). Если же exposed вернул значение  False,  то  drawView
      ничего не  делает.  Вы  должны  обращаться к drawView (а не draw)
      всякий раз,  когда необходимо  заново  перерисовать  отображаемый
      объект в  следствие изменений,  которые воздействует на его визу-
      альное отображение.

           См. также: TView::draw, TGroup::redraw, TView::exposed


      enableCommand static void enableCommand(ushort command);
      -------------
           Разрешает данную команду.  Если набор команд изменится в ре-
      зультате этого вызова, то commandSetChanged установится в True.

           См. также: TView::disableCommands, TView::enableCommands


      enableCommands
      --------------
           static void enableCommand(TCommandSet& commands);

           Разрешает все  команды,  перечисленные в аргументе сommands.
      Если   набор   команд   изменится   после   этого   вызова,    то
      сommandSetChanged установится в True.

           См. также: TCommandSet, commandSetChanged,
      TView::disableCommands,TView::getCommands, TView::commandEnabled,
      TView::setCommands.


      endModal      virtual void endModal(ushort command);
      --------
           Вызывает topView для поиска верхнего модального отображаемо-
      го объекта.  Если таких объектов нет (что определяется  в случае,
      если topView возвратит 0), то никаких дальнейших действий не про-
      изводится. Если же таковой имеется, то он вызывает endModal и т.д.

           В  конечном  счете,  endModal контролирует текущее модальное
      состояние. Параметр command передается в метод execView,  который
      первым создал модальное состояние.

           См. также: TGroup::execView,TGroup::execute,TGroup::endModal


      eventAvail    Boolean eventAvail();
      ----------
           Вызывает getEvent и возвращает True, если событие  доступно.
      Вызывает putEvent, если событие доступно.

           См. также:TView::mouseEvent,TView::keyEvent,TView::getEvent,
      TView::putEvent


      execute       virtuai ushort execute();
      -------
           Вызывается из TGroup::execView всякий раз,  когда отображае-
      мый объект становится модальным.  Если отображаемый объект разре-
      шает  модальное выполнение,  он должен переопределить execute для
      поддержки обработки цикла событий. Метод execute возвратит значе-
      ние, получаемое им от метода TGroup::execView.

           По умолчанию TView::execute просто возвращает cmCancel.

           См. также:   sfModal,   TGroup::execute,   TGroup::execView,
      cmCancel


      exposed       Boolean exposed();
      -------
           Возвращает значение True, если хоть какая-то часть отобража-
      емого объекта видна на экране.

           См. также: sfExposed, TView::drawView


      getBounds     TRect getBounds();
      ---------
           Возвратит текущее значение size,  определяющее прямоугольные
      границы данного отображаемого объекта в координатной системе  его
      владельца. TRect::a устанавливается в origin, а TRect::b устанав-
      ливается в сумму origin и size.

           См. также:   TView::origin,  TView::size, TView::calcBounds,
      TView::changeBounds, TView::setBounds, TView::getExtent


      getClipRect   TRect getClipRect();
      -----------
           Возвращает поле clip,  определяющее минимальные  прямоуголь-
      ные границы,  которые необходимо перерисовать при обращении к ме-
      тоду draw. Для сложных отображаемых объектов draw может использо-
      вать getClipRect для значительного улучшения своей производитель-
      ности.

           См. также: TView::draw, TView::drawView


      getColor      ushort getColor(ushort color);
      --------
           Отображает индексы палитры младшего и старшего байта color в
      физические атрибуты символа,  "проходя" для этого  через  палитру
      самого отображаемого элемента и палитры всех его владельцев.

           См. также: TView::getPalette,  TView::mapColor


      getCommands   static void getCommands(TCommandSet& commands);
      -----------
           Возвращает в commands текущий набор команд.

           См. также:  TView::commandsEnabled,   TView::enableCommands,
      TView::disableCommands, TView::setCommands


      getData       virtual void getData(void *rec);
      -------
           Метод getData должен копировать dataSize байт из  отображае-
      мого объекта в запись данных,  заданную указателем rec.  Механизм
      записей данных обычно используется только в  отображаемых  объек-
      тах,  которые  реализуют элементы управления для диалоговых окон.
      По умолчанию TView::getData ничего не делает.

           См. также: TView::dataSize, TView::setData


      getEvent      virtual void getEvent(TEvent& event);
      --------
           Возвращает очередное  доступное событие в event.  Возвращает
      evNothing, если событие недоступно. По умолчанию данный метод вы-
      зывает getEvent владельца отображаемого объекта.

           См. также:         TView::eventAvail,        TProgram::idle,
      TView::handleEvent, TView::putEvent


      getExtent     TRect getExtent();
      ---------
           Возвращает "протяженность"  прямоугольной области отображае-
      мого объекта.  TRect::a устанавливается в  (0,0),  а  TRect::b  в
      size.

           См. также:   TView::origin,  TView::size, TView::calcBounds,
      TView::changeBounds, TView::setBounds, TView::getBounds


      getHelpCtx    virtual ushort getHelpCtx();
      ----------
           Метод getHelpCtx  должен  возвращать контекст помощи данного
      отображаемого объекта.

           По умолчанию   TView.getHelpCtx   возвращает  значение  поля
      helpCtx или  же  hcDragging,  если  данный  отображаемый объект в
      настоящий момент времени перемещается (см. sfDragging).

           См. также: helpCtx

      getPalette    virtual TPalette& getPalette() const;
      ----------
           Данный метод  должен возвращать строку,  соответствующую па-
      литре данного отображаемого объекта или 0 (пустую  строку),  если
      данный  отображаемый объект не имеет палитры.  getPalette вызыва-
      ется из writeChar и writeStr при преобразовании индексов  палитры
      в физические атрибуты символов.  Возвращаемое по умолчанию значе-
      ние 0 приводит к тому, что преобразование цвета данным отображае-
      мым объектом не производится. getPalette почти всегда переопреде-
      ляется в порождаемых классах.

           См. также: TView::getColor, TView::mapColor,writeXXXX

      getState      Boolean getState(ushort aState);
      --------
           Возвращает значение  True,  если  в  поле state установленно
      состояние, соответствующее заданному в aState.

           См. также: state, TView::setState

      growTo        void growTo(short x, short y);
      ------
           Увеличивает или  уменьшает  отображаемый  объект на заданный
      размер, используя для этого вызов TView::locate.

           См. также: TView::origin,TView::size, TView::locate,
      TView::moveTo










       TVMemMgr                                                BUFFERS.H
      -----------------------------------------------------------------

                                    ╔════════╗
                                    ║TVMemMgr║
                                    ╚════════╝

           Класс TVMemMgr вместе с TBufEntryList и глобальным  операто-
      ром new обеспечивают низкоуровневое управление памятью в програм-
      мах Turbo Vision.  В частности  TVMemMgr  управляет  пулом  безо-
      пасности. Для  большинства  программ  объекты  классов TVMemMgr и
      TVBufListEntry не нуждаются в специальном вмешательстве  програм-
      миста.


                                    Поля

      safetyPool                                       (частный)
      ----------
           static void *safetyPool;

           safetyPool указывает на пул безопасности распределения памя-
      ти. Имеет значение 0, если пул безопасности не поддерживается или
      исчерпан.


      safetyPoolSize                                   (частный)
      --------------
           static size_t safetyPoolSize;

           Размер в  байтах  текущего  пула безопасности.  Это закрытое
      (частное) поле  изменяется  с  помощью  метода  TVMemMgr::resize-
      SafetyPool.  По  умолчанию  размер  пула  надежности определяется
      константой DEFAULT_SAFETY_ POOL_SIZE,  которая определена в заго-
      ловочном файле BUFFERS.H и в настоящее время равна 4096 байт.


      inited                                           (частный)
      ------
           static int inited;

           Индикатор попытки инициализации  пула  надежности.  Исключи-
      тельно для внутреннего использования.


                                   Методы

      constructor   TVMemMgr::TVMemMgr();
      -----------

           Ничего не  делает,  если  пул надежности уже инициализирован
      (т.е.  если  inited   =   1).   В   противном   случае   вызывает
      resizeSafetyPool  для  установки  пула безопасности с размером по
      умолчанию (заданным константой DEFAULT_SAFETY_POOL_SIZE в заголо-
      вочном файле BUFFERS.H с текущим значением 4096 байт). Кроме того
      данный конструктор устанавливает inited в 1.


      allocateDiscardable
      -------------------
              static void allocateDiscardable(void *&adr, size_t sz);

           Исключительно для внутреннего использования.  Пытается выде-
      лить кэш буфер (объект класса TBufListEntry) размером sz.  В слу-
      чае  успеха adr возвращает указатель на выделенный буфер.  В про-
      тивном случае adr устанавливается в 0. TGroup::getBuffer вызывает
      allocateDiscardable с adr установленным на поле TGroup::buffer.

           См. также:    TVMemMgr::freeDiscardable,    оператор    new,
      TGroup::getBuffer


      freeDiscardable static void freeDiscardable( void *block );
      ---------------
           Исключительно для внутреннего использования. Освобождает бу-
      фер, выделенный по адресу block предыдущим  вызовом  allocateDis-
      cardable.  TGroup::freeBuffer  вызывает  freeDiscardable  c block
      установленным на поле TGroup::buffer.

           См. также: TVMemMgr::allocateDiscardable, TGroup::freeBuffer


      resizeSafetyPool
      ----------------
           static void resizeSafetyPool(size_t sz =
                                            DEFAULT_SAFETY_POOL_SIZE );

           Изменяет размер  пула надежности на sz байт.  Предыдущий пул
      надежности, если он существовал, освобождается. inited устанавли-
      вается в 1,  safety Pool инициализируется указателем на новый пул
      безопасности,  а safetyPoolSize устанавливается в sz.  Если аргу-
      мент sz опущен, то предполагается его значение по умолчанию. Если
      sz равно 0, safetyPool и safetyPoolSize устанавливаются в 0.

           См. также: конструктор класса TVMemMgr,
      DEFAULT_SAFETY_POOL_SIZE


      safetyPoolExhausted
      -------------------
           static int safetyPoolExhausted();

           Возвращает 1(True) если пул безопасности инициализирован, но
      его пространство  исчерпано.  В   противном   случае   возвращает
      0(False).   safetyPoolExhausted  вызывается  глобальной  функцией
      lowMemory.

           См. также: lowMemory, оператор new









       TWindow                                                   VIEWS.H
      -----------------------------------------------------------------

                  ┌────────────┐               ┌─────────┐
                  │TWindowInit │               │ TGroup  │
                  └──────┬─────┘               └────┬────┘
                         └────────────┬─────────────┘
                                 ╔════╧════╗
                                 ║ TWindow ║
                                 ╚════╤════╝
                                 ┌────┴────┐
                                 │ TDialog │
                                 └─────────┘

           Объект классаTWindow  -  это группа,  которая обычно владеет
      объектом класса TFrame,  внутренним отображаемым объектом  класса
      TScroller и одним или двумя объектами класса TScrollBar.  Все эти
      связанные между собой подобъекты обеспечивают "внешний вид"  объ-
      ектам TWindow.  Объект  TFrame задает обычную рамку,  размещая на
      ней необязательные заголовок и номер окна, а также функциональные
      символы-пиктограммы (закрытия, распахивания, перемещения). Объек-
      ты TWindow обладают встроенными возможностями  по  перемещению  и
      изменению своих размеров с помощью "мыши" и клавиатуры. Они могут
      быть распахнуты и закрыты отметкой благодаря  нажатию  на  кнопку
      "мыши" в  момент,  когда  ее  указатель  располагается  над соот-
      ветствующей пиктограммой в рамке окна.  Они также "знают" как ра-
      ботать со строками прокрутки и с бегунком прокрутки. Окна с номе-
      рами от 1 до 9 могут выбраны клавишами Alt-n (n от 1 до 9).

           TWindow наследует и от класса TGroup и от виртуального базо-
      вого класса TWindowInit. Последний обеспечивает конструктор и ме-
      тод createFrame для создания и удаления рамок. Аналогичный способ
      порождения используется для классов THistoryWindow и THistInit.


                                    Поля

      flags         uchar flags;
      -----
           Флаг flags содержит комбинацию следующих бит:

                 ┌TWindow.flags┐
            старший бит   младший бит

                ╔═╤═╤═╤═╤═╤═╤═╤═╗
                ╚╤╧═╧═╧╤╧╤╧╤╧╤╧╤╝
                 └──┬──┘ │ │ │ └─ wfMove  = 0x01
                    │    │ │ └─── wfGrow  = 0x02
            Неопределено │ └───── wfClose = 0x04
                         └─────── wfZoom  = 0x08

           Описание флагов окна см.  в разделе "Константы  флагов  окна
      wfXXXX" главы 16.


      frame         TFrame  *frame;
      -----
           frame - это указатель на объект класса TFrame,  связанный  с
      данным окном.

           См. также: TWindow::initFrame


      number        short number;
      ------
           Номер, присвоенный данному окну.  Если TWindow::number лежит
      в диапазоне  1  -  9,  то этот номер будет появляться в заголовке
      рамки, а само окно сможет быть выбранным с помощью  клавиш  Alt-n
      (n от 1 до 9).


      palette       short palette;
      -------
           Определяет, какая   палитра   окна   будет   использоваться:
      wpBlueWindow, wpCyanWindow или wpGrayWindow.  По умолчанию, выби-
      рается палитра wpBlueWindow.

           См. также: TWindow::getPalette, wpXXXX константы


      title         const char *title;
      -----
           Строка символов,  определяющая  (необязательный)  заголовок,
      который изображается в рамке окна.


      zoomRect      TRect zoomRect;
      --------
           Нормальные ("нераспахнутые") границы окна.


                                   Методы

      constractor
      -----------
           TWindow(const TRect&  bounds,  const  char  *aTitle,   short
      aNumber);

           Вызывает конструктор класса TGroup для установки границ, за-
      данных в bounds. Устанавливает state в sfShadow. Устанавливает по
      умолчанию  options в (ofSelectable | ofTopSelect).  Устанавливает
      growMode в gfGrowAll | gfGrowRel. Устанавливает flags в (wfMove |
      wfGrow | wfClose | wfZoom).  Инициализирует поле title указателем
      из aTitle,  а поле number из  aNumber.  Вызывает,  по  умолчанию,
      initFrame, и  если  полученный указатель frame не 0,  то включает
      его в группу данного окна. Наконец, по умолчанию, задает zoomRect
      границы из bounds.


      constructor
      -----------
           TWindow( StreamableInit streamableInit);      (защищенный)

           Каждому потоковому классу необходим "построитель"  для  кор-
      ректного выделения  памяти под его объекты и инициализации указа-
      телей vtable.  Это достигается вызовом данного конструктора с ар-
      гументом типа StreamableInit. Смотрите также главу 8.

           См. также: TFrame::initFrame


      destructor    ~TWindow();
      ----------
           Удаляет заголовок,  а затем уничтожает как само окно,  так и
      все его отображаемые подобъекты,  используя для этого вызов роди-
      тельских деструкторов.


      build         static TStreamable *build();
      -----
           Вызывается для  создания объектов в некоторых ситуациях чте-
      ния из потока.

           См. также: TStreamableClass, ipstream::readData


      close         virtual void close();
      -----
           Вызывает valid(cmClose).  Если возвращается True, то это оз-
      начает, что вызывающее окно стерто.

           См. также: TView:valid


      getPalette    virtual TPalette& getPalette() const;
      ----------
           Возвращает указатель на палитру, заданную индексом палитры в
      поле palette.

           См. также: TWindow::palette


      getTitle      virtual const char *getTitle(short maxSize);
      --------
           Возвращает строку заголовка окна title.

           См. также: TWindow::title


      handleEvent   virtual void handleEvent(TEvent& event);
      -----------
           Вначале вызывает TGroup::handleEvent,  а затем  обрабатывает
      специфические для TWindow события. К ним относятся:

           Следующие события  типа evCommand обрабатываются,  если флаг
      TWindow::flags разрешает эти операции:  cmResize (переместить или
      изменить размер окна, используя функцию TView::drawView), cmClose
      (закрыть окно с  помощью  создания  события  cmCancel)  и  cmZoom
      (распахнуть окно, используя метод TWindow::zoom).

           События типа evKeyDown со значением keyCode равным kbTab или
      kbShiftTab обрабатываются, выбирая следующий или предыдущий выби-
      раемый подобъект (если он существует).

           Событие evBroadcast  со  значением  command равным cmSelect-
      WindowNum, обрабатывается  выбором  указанного  окна,  если  поле
      event.infoInt равно number.

           См. также:  TGroup::handleEvent, константы wfXXXX, TWindow::
      dragView, TWindow::zoom


      initFrame     virtual void initFrame(TRect);
      ---------
           Создает объект  класса TFrame для окна и сохраняет указатель
      на него в поле TWindow::frame. initFrame вызывается конструктором
      TWindow и никогда не должен вызываться непосредственно. initFrame
      может быть переопределен  для  создания  порожденного  от  TFrame
      класса, вместо стандартного TFrame.

           См. также: TWindow::TWindow


      read          virtual void *read( ipstream& is);
      ----
           Читает из входного потока is.

           См. также: классы TStreamable и ipstream


      setState  virtual void setState(ushort aState, Boolean enable);
      --------
           Вначале вызывает TGroup::setState(aState,enable). Затем, ес-
      ли aState равно sfSelected,  активизирует или деактивизирует окно
      и все его подобъекты,  используя вызов setState(sfActive, enable)
      и  вызов  TView::enableCommands  или  TView::disableCommands  для
      cmNext, cmPrev, cmResize, cmClose и cmZoom.

           См. также:     TGroup::setState,      TView::enableCommands,
      TView::disableCommands


      shutDown      virtual void shutDown();
      --------
           Используется внутри  TObject::destroy  для  обеспечения кор-
      ректного уничтожения порожденных и родственных объектов. shutDown
      переопределяется во многих классах, для обеспечения соответствую-
      щего установления полей, при вызове destroy.

           См. также: глава 6 "Разработка надежных программ"


      sizeLimits    virtual void sizeLimits(TPoint& min, TPoint& max);
      ----------
           Переопределяет TView::sizeLimits.   Вначале  вызывает  метод
      TView::sizeLimits(min,max), а затем изменяет min  на  минимальное
      значение размера окна, в настоящее время заданное как (16,6).

           См. также:  TView::sizeLimits


      standardScrollBar
      -----------------
           TScrollBar *standardScrollBar(ushort aOptions);

           Создает, вставляет  и  возвращает указатель на "стандартную"
      строку прокрутки для окна.  "Стандартность" означает,  что полоса
      прокрутки включается в рамку окна,  не закрывая углов или  кнопки
      управляющих пиктограмм.

           Параметр aOptions может быть  либо  равен  sbGorizontal  для
      создания горизонтальной  строки прокрутки внизу окна,  либо иметь
      значение sbVertical для создания вертикальной строки прокрутки  в
      правой   стороне   окна,   либо   может   быть   скомбинирован  с
      sbHandleKeyboard, чтобы разрешить строке прокрутки откликаться на
      клавиши управления курсором и PgUp,  PgDn, а не только на команды
      от "мыши".

           См. также: константы строк прокрутки sbXXXX


      write         virtual void write( opstream& os );
      -----
           Пишет в выходной поток os.

           См. также: классы TStreamableClass, TStreamable и opstream


      zoom          virtual void zoom();
      ----
           Переопределения: используются редко.

           Распахивает вызывающее окно.  Этот метод обычно вызывается в
      ответ на команду cmZoom (переключаемую при выборе "мышью" пиктог-
      раммы распахивания окна).  zoom принимает во внимание относитель-
      ные размеры данного окна и его владельца, и значение zoomRect.

           См. также: cmZoom, zoomRect,TView::locate


                           Дополнительные функции

           Некоторые функции-операторы родственны TWindow,  но не явля-
      ются методами класса TWindow.



                                  Палитра

           Объекты окна  используют  по  умолчанию палитры cpBlueWindow
      (для текстовых окон), cpCyanWindow (для сообщений) и cpGrayWindow
      (для диалоговых окон).

                      1   2   3   4   5   6   7   8
                   ╔═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╗
      cpGraywindow ║ 24│ 25│ 26│ 27│ 28│ 29│ 30│ 31║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpCyanwindow ║ 16│ 17│ 18│ 19│ 20│ 21│ 22│ 23║
                   ╠═══╧═══╧═══╧═══╧═══╧═══╧═══╧═══╣
                   ╠═══╤═══╤═══╤═══╤═══╤═══╤═══╤═══╣
      cpBluewindow ║ 8 │ 9 │ 10│ 11│ 12│ 13│ 14│ 15║
                   ╚═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╧═╤═╝
                     │   │   │   │   │   │   │   │
      Пассивная ─────┘   │   │   │   │   │   │   └── Зарезервировано
      рамка              │   │   │   │   │   │
      Активная рамка ────┘   │   │   │   │   └──── Выделенный текст
                             │   │   │   │         строки прокрутки
      Пиктограмма (символ ───┘   │   │   └──────── Нормальный текст
      управления в рамке)        │   │             элемента прокрутки
      Строки прокрутки ──────────┘   └──────────── Зарезервировано
                                                   для строки прокрутки








       TWindowInit                                               VIEWS.H
      _________________________________________________________________

                      ╔═════════════╗     ┌────────┐
                      ║ TWindowInit ║     │ TGroup │
                      ╚══════╤══════╝     └────┬───┘
                             └───┐    ┌────────┘
                              ┌──┴────┴─┐
                              │ TWindow │
                              └─────────┘

           TWindow наследует от TGroup и виртуального  базового  класса
      TWindowInit. Последний   обеспечивает   конструктор    и    метод
      createFrame  для  создания  и  удаления  рамок.  Подобная техника
      используется для TProgram, THistoryWindow и TDeskTop.


                                   Методы

      constructor
      -----------
           TWindowInit(TFrame *(*cFrame) (TRect bounds));

           Этот конструктор берет в качестве аргумента  адрес  функции,
      обычно    &TWindow::InitFrame.   Конструктор   TWindow   вызывает
      TGroup(bounds) и TWindowInit(&TWindow::initFrame),  для  создания
      оконного объекта и соответствующей рамки.  Последняя включается в
      объект оконной группы.


      createFrame   TFrame *(*createFrame) ( TRect bounds );
      -----------
           Вызывается  конструктором TWindowInit  для создания  объекта
      TFrame c заданными границами и возвращает указатель  на  него.  В
      случае ошибки возвращается нулевой указатель.