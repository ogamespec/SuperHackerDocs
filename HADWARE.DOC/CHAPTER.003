									-31-

   **  Programmer's  Technical	Reference  for	MSDOS  and  the  IBM  PC **
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ Registered User Version ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			 not for public distribution
		 Copyright (c) 1987, 1988, 1989 Dave Williams


			  C H A P T E R    T H R E E


				THE PC ROM BIOS


				C O N T E N T S

Calling the ROM BIOS .................................................. 3**1
Interrupt 10h  Video Services ......................................... 3**2
Interrupt 11h  Equipment Check ........................................ 3**3
Interrupt 12h  Memory Size ............................................ 3**4
Interrupt 13h  Disk Functions ......................................... 3**5
Interrupt 14h  Initialize and Access Serial Port ...................... 3**6
	       FOSSIL Drivers ......................................... 3**7
Interrupt 15h  Cassette I/O ........................................... 3**8
Interrupt 16h  Keyboard I/O ........................................... 3**9
Interrupt 17h  Printer ................................................ 3**10
Interrupt 18h  ROM BASIC .............................................. 3**11
Interrupt 19h  Bootstrap Loader ....................................... 3**12
Interrupt 1Ah  Time of Day ............................................ 3**13
Interrupt 1Bh  Control-Break .......................................... 3**14
Interrupt 1Ch  Timer Tick ............................................. 3**15
Interrupt 1Dh  Vector of Video Initialization Parameters .............. 3**16
Interrupt 1Eh  Vector of Diskette Controller Parameters ............... 3**17
Interrupt 1Fh  Ptr to Graphics Character Extensions (Graphics Set 2) .. 3**18
Interrupt 20h  Terminate Current Program .............................. 3**19



Calling the ROM BIOS .................................................. 3**1

 The BIOS services are invoked by placing the number of the desired function in
register AH, subfunction in AL, setting the other registers to any specific
requirements of the function, and invoking any of ints 10h through int 20h.

 When the interrupt is called, all register and flag values are pushed into the
stack. The interrupt address contains a pointer into an absolute address in the
ROM BIOS chip address space. This location may be further vectored into the
IBMBIO.COM (or equivalent) file or user file.

 The address vector points to a particular BIOS command handler. The handler
pops the register values, compares them to its list of functions, and executes
the function if valid. When the function is complete, it may pass values back
to the command handler. The handler will push the values into the stack and
then return control to the calling program.

 Most functions will return an error code; some return more information.
Details are contained in the listings for the individual functions.

 Register settings listed are the ones used by the BIOS. Some functions will
return with garbage values in unused registers. Do not test for values in
unspecified registers; your program may exhibit odd behavior.


 Three sets of BIOS routines are available: PC BIOS, AT BIOS (also called
CBIOS or "Old compatibility BIOS", and the PS/2 ABIOS "Advanced BIOS".

									-32-


 The Advanced BIOS is contained in PS/2 ROMs. It is primarily intended for OS
use rather than application use. OS/2 can take advantage of ABIOS routines to
reduce RAM use on PS/2 systems. The ABIOS can be replaced by disk and RAM based
ABIOS code if desired. There is a new BIOS Data Area defined in high memory
that occupies one K of RAM.

 The ABIOS can run in protected mode, and is fully reentrant. It supports three
types of function requests - single staged, discrete multistaged, or continuous
multistaged. A single-staged request does its job immediately and returns
control to the caller. A discrete multistaged request may happen in two or more
stages with pauses between the stages. The caller may regain control during the
pauses. A continuous multistaged request starts a staged operation that never
ends. (sometimes called a daemon).

 Unlike the CBIOS which is called with software interrupts, ABIOS is accessed
with FAR calls. ABIOS calls are completely reentrant in both real and
protected modes. To call an ABIOS function, the calling program must pass
pointers to two data structures - a request block and a common data area. The
request block specifies the desired function number and the common data area is
a table that contains pointers to all the ABIOS' other tables and data areas.
The common data area's internal structure contains the function transfer
tables which have the addresses of the BIOS routines.

ABIOS stack frame and calling conventions:
       bytes	    stack contents
	2	common data area pointer (segment/selector only) required
	4	request block pointer - required
	4	function transfer table pointer - furnished by ABIOS or caller
	4	device block pointer - furnished by ABIOS or caller
	4	return address

 In ABIOS Transfer Convention, only the first two items are required. ABIOS
assigns the second two. In Operating System Transfer Convention, the caller
provides the second two. Since the parameters are not removed from the stack
on return to the caller, the operating system may save the function transfer
table and device addresses after they have been furnished by the ABIOS by a
call.

 ABIOS does no interrupt arbitration. It assumes all interrupts are handled by
the caller or the OS and it is called only for service. If more than one
device is sharing a hardware interrupt, the OS must determine which interrupt
is valid for the ABIOS.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 10h	Video Services						3**2  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0040h)	The BIOS Video Services may be found in Chapter 16.

(internal) Coprocessor Error (80286+)
	Generated by the CPU when the -ERROR pin is asserted by the coprocessor
	(usually 80x87, but may be any multimaster CPU or alternate NDP such
	as Weitek, etc.). ATs and clones usually wire the coprocessor to use
	IRQ13, but not all get it right.

									-33-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 11h	Equipment Check 					3**3  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0044h)	Reads the BIOS Data Area and returns two bytes of setup info.
entry	no parameters are required
return	AX	Equipment listing word. Bits are:
		0	number of floppy drives
			0	no drives
			1	bootable (IPL) diskette drive installed
		1	math chip
			0	no math coprocessor (80x87) present
			1	math coprocessor (80x87) present
	 (PS/2) 2	0	mouse not installed
			1	mouse installed
	  (PC)	2,3	system board RAM
			0,0	16k    (PC-0, PC-1)
			0,1	32k
			1,0	48k
			1,1	64k    (PC-2, XT)
			note 1) not commonly used. Set both bits to 1
			     2) both bits always 1 in AT
		4,5	initial video mode
			0,0	no video installed (use with dumb terminal)
			0,1	40x25 color	 (CGA)
			1,0	80x25 color	 (CGA, EGA, PGA, MCGA, VGA)
			1,1	80x25 monochrome (MDA or Hercules, most super-
						  hires mono systems)
		6,7	number of diskette drives (only if bit 0 is 1)
			0,0	1 drives
			0,1	2 drives
			1,0	3 drives
			1,1	4 drives
		8	0	DMA present
			1	no DMA (PCjr, some Tandy 1000s, 1400LT)
		9,A,B	number of RS232 serial ports (0-3)
			0,0,0	none
			0,0,1	1
			0,1,0	2
			0,1,1	3
			1,0,0	4
		C	0	no game I/O attached
			1	game I/O attached (default for PCjr)
		D	serial accessory installation
			0	no serial accessories installed
			1	Convertible - internal modem installed
				or PCjr - serial printer attached
		E,F	number of parallel printers
			0,0	none
			0,1	one   (LPT1, PRN)
			1,0	two   (LPT2)
			1,1	three (LPT3)
			note	Models before PS/2 would allow a fourth
				parallel printer. Remapping of the BIOS in the
				PS/2s does not allow the use of LPT4.

									-34-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 12h	Memory Size						3**4  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0048h)	get system memory
entry	no parameters required
return	AX	number of contiguous 1K RAM blocks availible for DOS
note 1) This is the same value stored in absolute address 04:13h.
     2) For some early PC models, the amount of memory returned by this call is
	determined by the settings of the dip switches on the motherboard and
	may not reflect all the memory that is physically present.
     3) For the PC/AT, the value returned is the amount of functional memory
	found during the power-on self-test, regardless of the memory size
	configuration information stored in CMOS RAM.
     4) The value returned does not reflect any extended memory (above the 1 Mb
	boundary) that may be present on 80286 or 80386 machines.




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 13h	Disk Functions						3**5  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0049h)	The service calls for BIOS disk functions are located in
		Chapter 8.




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 14h	Initialize and Access Serial Port For Int 14		3**6  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0050h)	the following status is defined:

	serial status byte:
	bits	0 delta clear to send
		1 delta data set ready
		2 trailing edge ring detector
		3 delta receive line signal detect
		4 clear to send
		5 data set ready
		6 ring indicator
		7 receive line signal detect

	line status byte:
	bits	0 data ready
		1 overrun error
		2 parity error
		3 framing error
		4 break detect
		5 transmit holding register empty
		6 transmit shift register empty
		7 time out  note: if bit 7 set then other bits are invalid

 All routines have AH=function number and DX=RS232 card number (0 based).
AL=character to send or received character on exit, unless otherwise noted.

									-35-

entry	AH	00h	Initialize And Access Serial Communications Port
			bit pattern: BBBPPSLL
			BBB = baud rate:   110,150,300,600,1200,2400,4800,9600
			PP  = parity:	   01 = odd, 11 = even
			S   = stop bits:   0 = 1, 1 = 2
			LL  = word length: 10 = 7-bits, 11 = 8-bits
	AL	parms for initialization:
		bit pattern:
		0	word length
		1	word length
		2	stop bits
		3	parity
		4	parity
		5	baud rate
		6	baud rate
		7	baud rate
		word length	10	7 bits
				11	8 bits
		stop bits	0	1 stop bit
				1	2 stop bits
		parity		00	none
				01	odd
				11	even
		baud rate	000	110 baud
				001	150 baud
				010	300 baud
				011	600 baud
				100	1200 baud
				101	2400 baud
				110	4800 baud
				111	9600 baud  (4800 on PCjr)
	DX	port number (0=COM1, 1=COM2, etc.)
return	AH	line status
	AL	modem status
note	To initialize the serial port to > 9600 baud on PS/2 machines, see
	fns 04h and 05h.


Function 01h	Send Character in AL to Comm Port
entry	AH	01h
	AL	character
	DX	port number (0 - 3)
return	AH	RS232 status code
		bit	0	data ready
			1	overrun error
			2	parity error
			3	framing error
			4	break detected
			5	transmission buffer register empty
			6	transmission shift register empty
			7	timeout
	AL	modem status
		bit
			0	delta clear-to-send
			1	delta data-set-ready
			2	trailing edge ring detected
			3	change, receive line signal detected
			4	clear-to-send
			5	data-set-ready
			6	ring received
			7	receive line signal detected

									-36-

Function 02h	Wait For A Character From Comm Port DX
entry	AH	02h
	DX	port number (0-3)
return	AL	character received
	AH	error code (see above)(00h for no error)


Function 03h	Fetch the Status of Comm Port DX (0 or 1)
entry	AH	03h
	DX	port (0-3)
return	AH	set bits (01h) indicate comm-line status
		bit	7	timeout
		bit	6	empty transmit shift register
		bit	5	empty transmit holding register
		bit	4	break detected ("long-space")
		bit	3	framing error
		bit	2	parity error
		bit	1	overrun error
		bit	0	data ready
	AL	set bits indicate modem status
		bit	7	received line signal detect
		bit	6	ring indicator
		bit	5	data set ready
		bit	4	clear to send
		bit	3	delta receive line signal detect
		bit	2	trailing edge ring detector
		bit	1	delta data set ready
		bit	0	delta clear to send


Function 04h	Extended Initialize			  (Convertible, PS/2)
entry	AH	04h
	AL	break status
		01h	if break
		00h	if no break
	BH	parity
		00h	no parity
		01h	odd parity
		02h	even parity
		03h	stick parity odd
		04h	stick parity even
	BL	number of stop bits
		00h	one stop bit
		01h	2 stop bits (1« if 5 bit word length)
	CH	word length
		00h	5 bits
		01h	6 bits
		02h	7 bits
		03h	8 bits
	CL	baud rate
		00h	110
		01h	150
		02h	300
		03h	600
		04h	1200
		05h	2400
		06h	4800
		07h	9600
		08h	19200
	DX	comm port (0-3)
return	AH	line control status
	AL	modem status
note	Provides a superset of fn 00h capabilities for PS/2 machines.

									-37-

Function 05h	Extended Communication Port Control	  (Convertible, PS/2)
entry	AH	05h
	AL	00h	read modem control register
		01h	write modem control register
	BL	modem control register
	   bits 0	DTR data terminal ready
		1	RTS request to send
		2	out1
		3	out2
		4	loop
		5,6,7	reserved
	DX	port number (0=COM1, 1=COM2, etc.)
return	AH	port status (see 00h above)
	AL	modem status (see 00h above)
	BL	modem control register (see 01h above)



FOSSIL Drivers ........................................................ 3**7

Interrupt  14h	FOSSIL (Fido/Opus/Seadog Standard Interface Level) drivers
		A FOSSIL is a device driver for handling the IBM PC serial
		communications ports in a standard fashion from an application
		(communications) program. A FOSSIL chains into the int 14h BIOS
		communications vector and replaces many functions with enhanced
		routines that may be easily accessed by an application.

		For all functions, all registers not specifically containing a
		function return value must be preserved across the call.


entry	AH	00h	Set baud rate and parameters
	AL	byte
		bits 7,6,5 baudrate
		000	19200 baud
		001	38400 baud
		010	300 baud
		011	600 baud
		100	1200 baud
		101	2400 baud
		110	4800 baud
		111	9600 baud
		bits 4,3 parity
		00	none
		01	odd
		10	none
		11	even
		bit 2 stop bits
		0	1 stop bit
		1	2 stop bits
		bit 1 char length
		0	5 bits plus value
		other	optional
	DX	port number (NOP if DX=00FFh)
return	AX	status (see fn 03h)
note	Low-order 5 bits are undefined by FOSSIL 1.0 spec.


entry	AH	01h	Transmit character with wait
	AL	ASCII value of character to be sent
	DX	port number (NOP if DX=00FFh)
return	AX	status bits (see function 03h)
note 1) Character is queued for transmission. If there is room in the
	transmitter buffer when this call is made, the character will be stored
	and control returned to caller. If the buffer is full, the driver will
	wait for room. Use this function with caution when flow control is
	enabled.

									-38-

entry	AH	02h	FOSSIL: Receive a character with wait
	DX	port number (0-3) (NOP if DX=00FFh)
return	AH	RS-232 status code (see AH=00h above)
	AL	ASCII value of character received from serial port
note	Will timeout if DSR is not asserted, even if function 03h returns
	data ready.


entry	AH	03h	FOSSIL: Request status
	DX	port number  (NOP if DX=00FFh)
return	AX	status bit mask
		AH	bit 0 set  RDA	   input data is available in buffer
			    1 set  OVRN    input buffer overrun
			    2 N/A
			    3 N/A
			    4 N/A
			    5 set  THRE    room is available in output buffer
			    6 set  TSRE    output buffer is empty
			    7 N/A
		AL	bit 0 N/A
			    1 N/A
			    2 N/A
			    3 set	   this bit is always set
			    4 N/A
			    5 N/A
			    6 N/A
			    7 set  DCD	   carrier detect
note	Bit 3 of AL is always returned set to enable programs to use it as a
	carrier detect bit on hardwired (null modem) links.


entry	AH	04h	Initialize FOSSIL driver
	BX	4F50h			   (optional)
	DX	port number		   (DX=00FFh special)
	ES:CX	pointer to ^C flag address (optional)
return	AX	1954h if successful
	BL	maximum function number supported (excluding 7Eh-0BFh)
	BH	revision of FOSSIL supported
note 1) DTR is raised when FOSSIL inits.
     2) Existing baudrate is preserved.
     3) If BX contains 4F50h, the address specified in ES:CX is that of a ^C
	flag byte in the application program, to be incremented when ^C is
	detected in the keyboard service routines. This is an optional service
	and only need be supported on machines where the keyboard service can't
	(or won't) perform an int 1Bh or int 23h when a control-C is entered.


entry	AH	05h	Deinitialize FOSSIL driver
	DX	port number  (DX=00FFh special)
return	none
note 1) DTR is not affected.
     2) Disengages driver from comm port. Should be done when operations on the
	port are complete.
     3) If DX=00FFh, the initialization that was performed when FOSSIL function
	04h with DX=00FFh should be undone.


entry	AH	06h	FOSSIL: Raise/lower DTR
	AL	DTR state to be set
		00h	lower DTR
		01h	raise DTR
	DX	comm port (NOP if DX=00FFh)
return	none

									-39-

entry	AH	07h	FOSSIL: Return timer tick parameters
return	AH	ticks per second on interrupt number shown in AL
	AL	timer tick interrupt number (not vector!)
	DX	milliseconds per tick (approximate)


entry	AH	08h	FOSSIL: Flush output buffer
	DX	port number (NOP if DX=00FFh)
return	none
note	Waits until all output is done.


entry	AH	09h	FOSSIL: Purge output buffer
	DX	port number (NOP if DX=00FFh)
return	none
note	Returns to caller immediately.


entry	AH	0Ah	FOSSIL: Purge input buffer
	DX	port number (NOP if DX=00FFh)
return	none
note 1) If any flow control restraint has been employed (dropping RTS or
	transmitting XOFF) the port will be "released" by doing the reverse,
	raising RTS or sending XON.
     2) Returns to caller immediately.


entry	AH	0Bh	FOSSIL: Transmit no wait
	AL	ASCII character value to be sent
	DX	port number (NOP if DX=00FFh)
return	AX	0000h	character not accepted
		0001h	character accepted
note	This is exactly the same as the "regular" transmit call except that if
	there is no space available in the output buffer a value of zero is
	returned in AX, if room is available a value 1 (one) is returned.


entry	AH	0Ch	FOSSIL: Nondestructive Read no Wait
	DX	port number (NOP if DX=00FFh)
return	AH	character
		0FFFFh	character not available
note 1) Reads async buffer.
     2) Does not remove keycode from buffer.


entry	AH	0Dh	FOSSIL: Keyboard read no wait
return	AX	IBM keyboard scan code or
		0FFFFh if no keyboard character available
note 1) Use IBM-style function key mapping in the high order byte.
     2) Scan codes for non function keys are not specifically required but may
	be included.
     3) Does not remove keycode from buffer.


entry	AH	0Eh	FOSSIL: Keyboard input with wait
return	AX	IBM keyboard scan code
note	Returns the next character from the keyboard or waits if no character
	is available.

									-40-

entry	AH	0Fh	Enable or Disable flow control
	AL	bit mask describing requested flow control
	   bits 0	XON/XOFF on transmit (watch for XOFF while sending)
		1	CTS/RTS (CTS on transmit/RTS on receive)
		2	reserved
		3	XON/XOFF on receive (send XOFF when buffer near full)
		4-7	not used, FOSSIL spec calls for setting to 1
	DX	port number (NOP if DX=00FFh)
return	none
note 1) Bit 2 is reserved for DSR/DTR,	but is not currently supported in any
	implementation.
     2) TRANSMIT flow control allows the other end to restrain the transmitter
	when you are overrunning it. RECEIVE flow control tells the FOSSIL to
	attempt to do just that if it is being overwhelmed.
     3) Enabling transmit Xon/Xoff will cause the FOSSIL to stop transmitting
	upon receiving an Xoff. The FOSSIL will resume transmitting when an Xon
	is received.
     4) Enabling CTS/RTS will cause the FOSSIL to cease transmitting when CTS
	is lowered. Transmission will resume when CTS is raised. The FOSSIL
	will drop RTS when the receive buffer reaches a predetermined
	percentage full. The FOSSIL will raise RTS when the receive buffer
	empties below the predetermined percentage full. The point(s) at which
	this occurs is left to the individual FOSSIL implementor.
     5) Enabling receive Xon/Xoff will cause the FOSSIL to send a Xoff when the
	receive buffer reaches a pre-determined percentage full. An Xon will be
	sent when the receive buffer empties below the predetermined percentage
	full. The point(s) at which this occurs is left to the individual
	FOSSIL implementor.
     6) Applications using this function should set all bits ON in the high
	nibble of AL as well. There is a compatible (but not identical) FOSSIL
	driver implementation that uses the high nibble as a control mask. If
	your application sets the high nibble to all ones, it will always work,
	regardless of the method used by any given driver.


entry	AH	10h	Extended Ctrl-C/Ctrl-K checking and transmit on/off
	AL	flags bit mask byte (bit set if activated)
	   bits 0	enable/disable Ctrl-C/Ctrl-K checking
		1	disable/enable the transmitter
		2-7	not used
	DX	port number (NOP if DX=00FFh)
return	AX	status byte
		0000h	control-C/K has not been received
		0001h	control-C/K has been received
note	This is used primarily for programs that can't trust XON/XOFF at FOSSIL
	level (such as BBS software).


entry	AH	11h	FOSSIL: Set current cursor location.
	DH	row (line) 0-24
	DL	column	   0-79
return	none
note 1) This function looks exactly like the int 10h, fn 02h on the IBM PC.
	The cursor location is passed in DX: row in DH and column in DL. This
	function treats the screen as a coordinate system whose origin (0,0) is
	the upper left hand corner of the screen.
     2) Row and column start at 0.


entry	AH	12h	FOSSIL: Read current cursor location.
return	DH	row (line)
	DL	column
note 1) Looks exactly like int 10h/fn 03h in the IBM PC BIOS. The current
	cursor location (same coordinate system as function 16h) is passed back
	in DX.
     2) Row and column start at 0.

									-41-

entry	AH	13h	FOSSIL: Single character ANSI write to screen.
	AL	value of character to display
return	none
note	This call might not be reentrant since ANSI processing may be through
	DOS.


entry	AH	14h	FOSSIL: Enable or disable watchdog processing
	AL	00h	to disable watchdog
		01h	to enable watchdog
	DX	port number (NOP if DX=00FFh)
return	none
note 1) This call will cause the FOSSIL to reboot the system if Carrier Detect
	for the specified port drops while watchdog is turned on.
     2) The port need not be active for this function to work.


entry	AH	15h	Write character to screen using BIOS support routines
	AL	ASCII code of character to display
return	none
note 1) This function is reentrant.
     2) ANSI processing may not be assumed.


entry	AH	16h	Insert or Delete a function from the timer tick chain
	AL	00h	to delete a function
		01h	to add a function
	ES:DX	address of function
return	AX	0000h	successful
		0FFFFh	unsuccessful


entry	AH	17h	FOSSIL: Reboot system
	AL	boot type
		00h	cold boot
		01h	warm boot
return	none


entry	AH	18h	FOSSIL: Read block
	CX	maximum number of characters to transfer
	DX	port number (NOP if DX=00FFh)
	ES:DI	pointer to user buffer
return	AX	number of characters transferred
note 1) This function does not wait for more characters to become available if
	the value in CX exceeds the number of characters currently stored.
     2) ES:DI are left unchanged by the call; the count of bytes actually
	transferred will be returned in AX.


entry	AH	19h	FOSSIL: Write block
	CX	maximum number of characters to transfer
	DX	port number  (NOP if DX=00FFh)
	ES:DI	pointer to user buffer
return	AX	number of characters transfered
note	ES and DI are not modified by this call.

									-42-

entry	AH	1Ah	FOSSIL: Break signal begin or end
	AL	00h	stop sending 'break'
		01h	start sending 'break'
	DX	port number  (NOP if DX=00FFh)
return	none
note 1) Resets all transmit flow control restraints such as an XOFF received
	from remote.
     2) Init (fn 04h) or UnInit (fn 05h) will stop an in-progress break.
     3) The application must determine the "length" of the break.


entry	AH	1Bh	FOSSIL: Return information about the driver
	CX	size of user buffer in bytes
	DX	port number  (if DX=00FFh, port data will not be valid)
	ES:DI	pointer to user buffer
return	AX	number of characters transferred
	ES:DI	user buffer structure:
		00h	word	size of structure in bytes
		02h	byte	FOSSIL driver version
		03h	byte	revision level of this specific driver
		04h	dword	FAR pointer to ASCII ID string
		08h	word	size of the input buffer in bytes
		0Ah	word	number of bytes in input buffer
		0Ch	word	size of the output buffer in bytes
		0Eh	word	number of bytes in output buffer
		10h	byte	width of screen in characters
		11h	byte	screen height in characters
		12h	byte	actual baud rate, computer to modem
				(see mask in function 00h
note 1) The baud rate byte contains the bits that fn 00h would use to set the
	port to that speed.
     2) The fields related to a particular port (buffer size, space left in the
	buffer, baud rate) will be undefined if port=0FFh or an invalid port is
	contained in DX.
     3) Additional information will always be passed after these, so that the
	fields will never change with FOSSIL revision changes.


entry	AH	7Eh	FOSSIL: Install an external application function
	AL	code assigned to external application
	ES:DX	pointer to entry point
return	AX	1954h	FOSSIL driver present
	    not 1954h	FOSSIL driver not present
	BH	00h	failed
		01h	successful
	BL	code assigned to application (same as input AL)
note 1) Application codes 80h-0BFh are supported. Codes 80h-83h are reserved.
     2) An error code of BH=00h with AX=1954h should mean that another external
	application has already been installed with the code specified in AL.
     3) Applications are entered via a FAR call and should make a FAR return.


entry	AH	7Fh	FOSSIL: Remove an external application function
	AL	code assigned to external application
	ES:DX	pointer to entry point
return	AX	1954h
	BH	00h	failed
		01h	successful
	BL	code assigned to application (same as input AL)

									-43-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 15h	Cassette I/O						3**8  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0054h)    1) Renamed "System Services" on PS/2 line.
	     2) Issuing int 15h on an XT may cause a system crash.
		On AT and after, interrupts are disabled with CLI when the
		interrupt service routine is called, but most ROM versions do
		not restore interrupts with STI.
	     3) For the original IBM PC, int 15h returns AH=80h and CF set for
		all calls with AH not 0,1, or 2.
	     4) For the PC/XT int 15h returns AH=86h, CF set if called at all.
		(the PC/XT ROM BIOS does not support int 15h)
	     5) For the AT/339, int 15h returns AH=86h, CF set if called with
		an invalid function code.


Function 00h	Turn Cassette Motor On				(PC, PCjr only)
entry	AH	00h
return	CF	set on error
		AH	error code
			00h	no errors
			01h	CRC error
			02h	bad tape signals
				no data transitions (PCjr)
			03h	no data found on tape
				not used (PCjr)
			04h	no data
				no leader (PCjr)
			80h	invalid command
			86h	no cassette present
				not valid in PCjr
note	NOP for systems where cassette not supported.


Function 01h	Turn Cassette Motor Off 			(PC, PCjr only)
entry	AH	01h
return	CF	set on error
	AH	error code (86h)
note	NOP for systems where cassette not supported.


Function 02h	Read Blocks From Cassette			(PC, PCjr only)
entry	AH	02h
	CX	number of bytes to read
	ES:BX	segment:offset + 1 of last byte read
return	CF	set on error
		AH	error code (01h, 02h, 04h, 80h, 86h)
	DX	count of bytes actually read
	ES:BX	pointer past last byte written
note 1) NOP for systems where cassette not supported.
     2) Cassette operations normally read 256 byte blocks.


Function 03h	Write Data Blocks to Cassette			(PC, PCjr only)
entry	AH	03h
	CX	count of bytes to write
	ES:BX	pointer to data buffer
return	CF	set on error
		AH	error code (80h, 86h)
	CX	00h
	ES:BX	pointer to last byte written+1
note 1) NOP for systems where cassette not supported.
     2) The last block is padded to 256 bytes with zeroes if needed.
     3) No errors are returned by this service.

									-44-


Function 0Fh	ESDI Format Unit Periodic Interrupt	     (PS/2 50+)
entry	AH	0Fh
	AL	phase code
		00h	reserved
		01h	surface analysis
		02h	formatting
return	CF	clear	if formatting should continue
		set	if it should terminate
note 1) Called the BIOS on the ESDI Fixed Disk Drive Adapter/A during a format
	or surface analysis operation after each cylinder is completed.
     2) This function call can be captured by a program so that it will be
	notified as each cylinder is formatted or analyzed. The program can
	count interrupts for each phase to determine the current cylinder
	number.
     3) The BIOS default handler for this function returns with CF set.


Function 10h	TopView API Function Calls			(TopView)
entry	AH	00h	PAUSE	Give Up CPU Time
			return	00h	after other processes run
		01h	GETMEM	allocate "system" memory
			BX	number of bytes to allocate
			return	ES:DI	pointer to a block of memory
		02h	PUTMEM	deallocate "system" memory
			ES:DI	pointer to previously allocated block
			return	block freed
		03h	PRINTC	display character/attribute on screen
			BH	attribute
			BL	character
			DX	segment of object handle for window
			note	BX=0 does not display anything, it only
				positions the hardware cursor.
		04h-09h unknown
		10h	unknown
			AL	04h thru 12h
			return	TopView - unimplemented in DV 2.0x
				pops up "Programming error" window in DV 2.0x
		11h	unknown
		12h	unknown
		13h	GETBIT	define a 2nd-level interrupt handler
			ES:DI	pointer to FAR service routine
			return	BX	bit mask indicating which bit was
					allocated
					0 if no more bits available
		14h	FREEBIT undefine a 2nd-level interrupt handler
			BX	bit mask from int 15/fn1013h
		15h	SETBIT	schedule one or more 2nd-level interrupts
			BX	bit mask for interrupts to post
			return	indicated routines will be called at next ???
		16h	ISOBJ	verify object handle
			ES:DI	possible object handle
			return	 BX	-1 if ES:DI is a valid object handle
					 0 if ES:DI is not
		17h	TopView - unimplemented in DV 2.00
			return	pops up "Programming Error" window in DV 2.00
		18h	LOCATE	Find Window at a Given Screen Location
			BH	column
			BL	row
			ES	segment of object handle for ?
				(0 = use default)
			return	ES	segment of object handle for window
					which is visible at the indicated
					position

									-45-

		19h	SOUND	Make Tone
			BX	frequency in Hertz
			CX	duration in clock ticks (18.2 ticks/sec)
			return	immediately, tone continues to completion
			note 1) If another tone is already playing, the new tone
				does not start until completion of the previous
				one. In DV 2.00, it is possible to enqueue
				about 32 tones before the process is blocked
				until a note completes.
			     2) In DV 2.00, the lowest tone allowed is 20 Hz.
		1Ah	OSTACK	Switch to Task's Internal Stack
			return	stack switched
		1Bh	BEGINC	Begin Critical Region
			return	task-switching temporarily disabled
			note	Will not task-switch until End Critical Region
				(AH=101Ch) is called.
		1Ch	ENDC	End Critical Region
			return	task-switching enabled
		1Dh	STOP	STOP TASK
			ES	segment of object handle for task to be stopped
				(= handle of main window for that task)
			return	indicated task will no longer get CPU time
			note	At least in DV 2.00, this function is ignored
				unless the indicated task is the current task.
		1Eh	START	Start Task
			ES	segment of object handle for task to be started
				(= handle of main window for that task)
			return	Indicated task is started up again
		1Fh	DISPEROR Pop-Up Error Window
			BX	bit fields:
				0-12	number of characters to display
				13,14	which mouse button may be pressed to
					remove window
					00	either
					01	left
					10	right
					11	either
				15	beep if 1
			CH	width of error window (0 = default)
			CL	height of error window (0 = default)
			DS:DI	pointer to text of message
			DX	segment of object handle
			return	BX	status:
					1	left button pressed
					2	right button pressed
					27	ESC key pressed
			note	Window remains on-screen until ESC or indicated
				mouse button is pressed.
		20h	TopView - unimplemented in DV 2.0x
			return	pops up "Programming Error" window in DV 2.0x
		21h	PGMINT	Interrupt Another Task (TopView)
			BX	segment of object handle for task to interrupt
			DX:CX	address of FAR routine to jump to next time
				task is run
			return	nothing?
			note	The current ES, DS, SI, DI, and BP are passed
				to the FAR routine.
		22h	GETVER	Get Version
			BX	00h
			return	BX	nonzero, TopView or compatible loaded
				BH	minor version
				BL	major version
			notes	TaskView v1.1C returns BX = 0001h
				DESQview  v2.0 returns BX = 0A01h

									-46-

		23h	POSWIN	Position Window
			BX	segment of object handle for parent window
				within which to position the window (0 = full
				screen)
			CH	# columns to offset from position in DL
			CL	# rows to offset from position in DL
			DL	bit flags
				0,1	horizontal position
					00	current
					01	center
					10	left
					11	right
				2,3	vertical position
					00	current
					01	center
					10	top
					11	bottom
				4	don't redraw screen if set
				5-7	not used
			ES	segment of object handle for window to be
				positioned
			return	nothing
		24h	GETBUF	Get Virtual Screen Information
			BX	segment of object handle for window (0=default)
			return	CX	size of virtual screen in bytes
				DL	0 or 1, unknown
				ES:DI	address of virtual screen
		25h	USTACK	Switch Back to User's Stack
			return	stack switched back
			note	Call only after int 15h, fn101Ah.
		26h-2Ah DesQview (TopView?) - unimplemented in DV 2.0x
			return	pops up "Programming Error" window in DV 2.0x
		2Bh	POSTTASK  Awaken Task	    DesQview 2.0 (TopView?)
			BX	segment of object handle for task
			return	nothing
		2Ch	Start New Application in New Process
			DesQview 2.0 (TopView?)
			ES:DI	pointer to contents of .PIF/.DVP file
			BX	size of .PIF/.DVP info
			return	BX	segment of object handle for new task
					00h	if error
		2Dh	Keyboard Mouse Control	     DesQview 2.0+
			BL	subfunction
				00h	determine whether using keyboard mouse
				01h	turn keyboard mouse on
				02h	turn keyboard mouse off
			return	(calling BL was 00h)
				BL	0	using real mouse
					1	using keyboard mouse


Function 11h	Topview commands
entry	AH	11h
	AL	various
note	In DesQview 2.0x, these function calls are identical to AH=0DEh, so
	see those below.


Function 20h	PRINT.COM  (DOS internal)	 (AT, XT-286, PS/2 50+)
entry	AH	20h
	AL	subfunction
		00h	unknown (PRINT)
		01h	unknown (PRINT)
		10h	sets up SysReq routine on AT, XT/286, PS/2
		11h	completion of SysReq routine (software only)
note 1) AL=0 or 1 sets or resets some flags which affect what PRINT does when
	it tries to access the disk.

									-47-


Function 21h	Read Power-On Self Test (POST) Error Log	   (PS/2 50+)
entry	AH	21h
	AL	00h	read POST log
		01h	write POST log
			BH	device ID
			BL	device error code
return	CF	set on error
	AH	status
		00h	successful read
			BX	number of POST error codes stored
			ES:DI	pointer to error log
		01h	list full
		80h	invalid command
		86h	function unsupported
note	The log is a series of words, the first byte of which identifies the
	error code and the second is the device ID.


Function 40h	Read/Modify Profiles				(Convertible)
entry	AH	40h
	AL	00h	read system profile in CX,BX
		01h	write system profile from CX, BX
		02h	read internal modem profile in BX
		03h	write internal modem profile from BX
	BX	profile info
return	BX	internal modem profile (from 02h)
	CX,BX	system profile (from 00h)


Function 41h	Wait On External Event				(Convertible)
entry	AH	41h
	AL	condition type
	   bits 0-2	condition to wait for
			0,0,0	any external event
			0,0,1	compare and return if equal
			0,1,0	compare and return if not equal
			0,1,1	test and return if not zero
			1,0,0	test and return if zero
		3	reserved
		4	0	user byte
			1	port address
		5-7	reserved
	BH	condition compare or mask value
		condition codes:
		00h	any external event
		01h	compare and return if equal
		02h	compare and return if not equal
		03h	test and return if not zero
		04h	test and return if zero
	BL	timeout value times 55 milliseconds
		00h	if no time limit
	DX	I/O port address (if AL bit 4=1)
	ES:DI	pointer to user byte (if AL bit 4=0)


Function 42h	Request System Power Off			(Convertible)
entry	AH	42h
	AL	00h	to use system profile
		01h	to force suspend regardless of profile
return	unknown

									-48-


Function 43h	Read System Status				(Convertible)
entry	AH	43h
return	AL	status byte
	    bit 0	LCD detached
		1	reserved
		2	RS232/parallel powered on
		3	internal modem powered on
		4	power activated by alarm
		5	bad time
		6	external power in use
		7	battery low


Function 44h	(De)activate Internal Modem Power		(Convertible)
entry	AH	44h
	AL	00h	 to power off
		01h	 to power on
return	unknown


Function 4Fh	OS Hook - Keyboard Intercept	      (except PC, PCjr, and XT)
entry	AH	4Fh
	AL	scan code, CF set
return	AL	scan code
	CF	set	processing desired
		clear	scan code should not be used
note 1) Called by int 9 handler for each keystroke to translate scan codes.
     2) An OS or a TSR can capture this function to filter the raw keyboard
	data stream. The new handler can substitute a new scan code, return the
	same scan code, or return the carry flag clear causing the keystroke to
	be discarded. The BIOS default routine simply returns the scan code
	unchanged.
     3) A program can call int 15h/fn0C0h to determine whether the host
	machine's BIOS supports keyboard intercept.


Function 52h	MicroSoft RAM-Resident Software Specification 1.0
		This standard was proposed by MicroSoft in 1986 as a common
		interface for TSR programs. It appears to have been largely
		unknown or disregarded.

Function 0: Get Program Information by Name
entry	DS:BX	The Program ID of the memory-resident program to look for
return	AL	0FFh	if the program we are looking for is installed
		00h	if it is not installed
	CX	The number of this program. The first program installed is
		number 0, with the second program being number 1, etc. By using
		a dynamic numbering system, we avoid conflicts between programs
		that might otherwise choose the same ID. We also provide a good
		way to scan all the resident programs using function 1.
	ES:DX	pointer to the Program ID Record (PIDR)
note	This function tests to see if a program is memory resident and returns
	a pointer to its program information if it is resident. To use this
	function, set DS:BX to point to the program ID. Each installed program
	will check to see if this program ID agrees with its own internal
	program ID.

									-49-


Function 1: Get Program Information by Number
entry	CX	Number of the program we want the information for

return	AL	0FFh	if the program we are looking for is installed
		00h	if it is not installed
	ES:DX	pointer to the Program ID Record (PIDR)
note	This function returns exactly the same information as function 0. The
	only difference is how we identify the program we want, which is
	determined by its position in the interrupt chain; program 0 is the
	last program in the chain, and the first program in the chain (usually
	the most recently installed) has the highest number.

Function 2: Activate Program
entry	CX	The number of the program we want to activate
	DS:BX	Activation Record. This record will give program information on
		how and what it should activate within the program
return	none
note	This function activates one of the installed programs. It is useful
	if you want to control many desk accessories with a single control
	panel like the one used in SideKick. You can also use it with a
	program like ProKey to run a named macro under program control, or
	with SideKick to bring up one of the desk accessories from within a
	program or batch file.

Function 3: Deactivate Program
entry	CX	The number of the program we want to deactivate
	DS:BX	Deactivation Record. This record will give program information
		on how and what it should deactivate within the program
return	none
note	This function is the opposite of function 2 (activate program).

Function 4: Enable Program
entry	CX	The number of the program we want to enable
	DS:BX	Enable mask record. This mask describes what features we want
		to enable. A null record enables all the features.
return	none
note	This function is the opposite of function 5 (disable program).

Function 5: Disable Program
entry	CX	The number of the program we want to disable
	DS:BX	Disable mask record.  This mask describes what features we want
		to disable. A null record disables all the features.
return	none
note	Sometimes it becomes necessary to disable a program to prevent it from
	conflicting with another program, this function is designed to do that.
	This function is the opposite of function 4 (Enable Program).


Function 70h	EEROM handler				     (Tandy 1000HX)
entry	AH	00h	read from EEROM
		BL	00h
		01h	write to EEROM
		BL	word number to write (0-15)
		DX	word value to write
return	DX	(AH=00h) word value
	CF	set on error (system is not a Tandy 1000 HX)

									-50-


Function 80h	OS Hook - Device Open			     (AT, XT/286, PS/2)
entry	AH	80h
	BX	device ID
	CX	process ID
return	CF	set on error
	AH	status
note 1) Acquires ownership of a logical device for a process.
     2) This call, along with fns 81h and 82h, defines a simple protocol that
	can be used to arbitrate usage of devices by multiple processes. A
	multitasking program manager would be expected to capture int 15h and
	provide the appropriate service.
     3) The default BIOS routine for this function simply returns with CF clear
	and AH=00h.


Function 81h	OS Hook - Device Close			     (AT, XT/286, PS/2)
entry	AH	81h
	BX	device ID
	CX	process ID
return	CF	set on error
	AH	status
note 1) Releases ownership of a logical device for a process.
     2) A multitasking program manager would be expected to capture int 15h and
	provide the appropriate service.
     3) The BIOS default routine for this function simply returns with the CF
	clear and AH=00h.


Function 82h	Program Termination			     (AT, XT/286, PS/2)
	AH	82h
	BX	device ID
return	CF	set on error
	AH	status
note 1) Closes all logical devices opened with function 80h.
     2) A multitasking program manager would be expected to capture int 15h and
	provide the appropriate service.
     3) The BIOS default routine for this function simply returns with CF clear
	and AH=00h.


Function 83h	Event Wait		   (AT, XT/286, Convertible, PS/2 50+)
entry	AH	83h
	AL	00h	to set interval
		01h	to cancel
	CX:DX	number of microseconds to wait (granularity is 976 microseconds)
	ES:BX	pointer to semaphore flag (bit 7 is set when interval expires)
		(pointer is to caller's memory) (some sources list bit 15 set)
return	CF	set (1) if function already busy
note 1) Requests setting of a semaphore after a specified interval or cancels a
	previous request.
     2) The calling program is responsible for clearing the semaphore before
	requesting this function.
     3) The actual duration of an event wait is always an integral multiple of
	976 microseconds. The CMOS date/clock chip interrupts are used to
	implement this function.
     4) Use of this function allows programmed, hardware-independent delays at
	a finer resolution than can be obtained through use of the MS-DOS Get
	Time function (int 21h/fn 2Ch) which returns time in hundredths of a
	second.
     5) CX:DX is a four-byte integer.

									-51-


Function 84h	Read Joystick Input Settings		     (AT, XT/286, PS/2)
entry	AH	84h
	DX	00h	to read the current switch settings  (return in AL)
		01h	to read the resistive inputs
return	CF	set on error
	(fn 00h)
	AL	switch settings (bits 7-4)
	(fn 01h)
	AX	stick A (X) value
	BX	stick A (Y) value
	CX	stick B (X) value
	DX	stick B (Y) value
note 1) An error is returned if DX does not contain a valid subfunction number.
     2) If no game adapter is installed, all returned values are 00h.
     3) Using a 250K Ohm joystick, the potentiometer values usually lie within
	the range 0-416 (0000h-01A0h).


Function 85h	System Request (SysReq) Key Pressed	   (except PC, PCjr, XT)
entry	AH	85h
	AL	00h	 key pressed
		01h	 key released
return	CF	set on error
	AH	error code
note 1) Called by BIOS keyboard decode routine when the SysReq key is detected.
     2) The BIOS handler for this call is a dummy routine that always returns a
	success status unless called with an invalid subfunction number in AL.
     3) A multitasking program manager would be expected to capture int 15h so
	that it can be notified when the user strikes the SysReq key.


Function 86h	Delay				      (except PC, PCjr, XT)
	AH	86h
	CX:DX	4-byte integer, number of microseconds to wait
return	CF	clear	after wait elapses
	CF	set	immediately due to error
note 1) Suspends the calling program for a specified interval in microseconds.
     2) The actual duration of the wait is always an integral multiple of 976
	microseconds.
     3) Use of this function allows programmed, hardware-independent delays at
	a finer resolution than can be obtained through use of the MS-DOS Get
	Time function (int 21h fn 2Ch) which returns time in hundredths of a
	second).


Function 87h	Memory Block Move			(2-3-486 machines only)
	AH	87h
	CX	number of words to move
	ES:SI	pointer to Global Descriptor Table (GDT)
		offset 00h-0Fh	reserved, set to zero
			   00h	null descriptor
			   08h	uninitialized, will be made into GDT descriptor
		       10h-11h	source segment length in bytes
				(2*CX-1 or greater)
		       12h-14h	24-bit linear source address
		       15h	access rights byte (always 93h)
		       16h-17h	reserved, set to zero
		       18h-19h	destination segment length in bytes
				(2*CX-1 or greater)
		       1Ah-1Ch	24-bit linear destination address
		       1Dh	access rights byte (always 93h)
		       1Eh-2Fh	reserved, set to zero
			   20h	uninitialized, used by BIOS
			   28h	uninitialized, will be made into SS descriptor

									-52-


return	CF	set on error
	AH	status
		00h	source copied into destination
		01h	parity error
		02h	exception interrupt error
		03h	address line 20 gating failed
note 1) The GDT table is composed of six 8-byte descriptors to be used by the
	CPU in protected mode. The four descriptors in offsets 00h-0Fh and
	20h-2Fh are filled in by the BIOS before the CPU mode switch.
     2) The addresses used in the descriptor table are linear (physical)
	24-bit addresses in the range 000000h-0FFFFFFh - not segments and
	offsets - with the least significant byte at the lowest address and the
	most significant byte at the highest address.
     3) Interrupts are disabled during this call; use may interfere with the
	operation of comm programs, network drivers, or other software that
	relies on prompt servicing of hardware interrupts.
     4) This call is not valid in the OS/2 Compatibility Box.
     5) This call will move a memory block from any real or protected mode
	address to any other real or protected mode address.


Function 88h	Get Extended Memory Size		   (AT, XT/286, PS/2)
entry	AH	88h
return	AX	number of contiguous 1K blocks of extended memory starting at
		address 1024k
note	This call will not work in the OS/2 Compatibility Box.


Function 89h	Switch Processor to Protected Mode	      (AT, XT/286, PS/2)
entry	AH	89h
	BH	interrupt number for IRQ0, written to ICW2 of 8259 PIC #1
		(must be evenly divisible by 8, determines IRQ0-IRQ7)
	BL	interrupt number for IRQ8, written to ICW2 of 8259 PIC #2
		(must be evenly divisible by 8, determines IRQ8-IRQ15)
	ES:SI	pointer to 8-entry Global Descriptor Table for protected mode:
		offset	00h	null descriptor, initialized to zero
			08h	GDT descriptor
			10h	IDT (Interrupt Descriptor Table) descriptor
			18h	DS, user's data segment
			20h	ES, user's extra segment
			28h	SS, user's stack segment
			30h	CS, user's code segment
			38h	uninitialized, used to build descriptor for
				BIOS code segment
return	CF	set on error
		AH	0FFh  error enabling address line 20
	CF	clear	function successful (CPU is in protected mode)
		AH	00h
		CS	user-defined selector
		DS	user-defined selector
		ES	user-defined selector
		SS	user-defined selector
note	The user must initialize the first seven descriptors; the eighth is
	filled in by the BIOS to provide addressability for its own execution.
	The calling program may modify and use the eighth descriptor for any
	purpose after return from this function call.

									-53-


Function 90h	Device Busy Loop			 (except PC, PCjr, XT)
entry	AH	90h
	AL	predefined device type code:
		00h	disk					 (may timeout)
		01h	diskette				 (may timeout)
		02h	keyboard				 (no timeout)
		03h	PS/2 pointing device			 (may timeout)
		80h	network
								 (no timeout)
		0FCh	hard disk reset (PS/2)			 (may timeout)
		0FDh	diskette motor start			 (may timeout)
		0FEh	printer 				 (may timeout)
	ES:BX	pointer to request block for type codes 80h through 0FFh
		(for network adapters ES:BX is a pointer to network control
		block)
return	CF	1 (set) if wait time satisfied
		0 (clear) if driver must perform wait
note 1) Used by NETBIOS.
     2) Generic type codes are allocated as follows:
	00h-7Fh   non-reentrant devices; OS must arbitrate access
		  serially reusable devices
	80h-0BFh  reentrant devices; ES:BX points to a unique control block
	0C0h-0FFh wait-only calls, no complementary POST int 15/fn 91h call
     3) Invoked by the BIOS disk, printer, network, and keyboard handlers prior
	to performing a programmed wait for I/O completion.
     4) A multitasking program manager would be expected to capture int 15h/
	fn 90h so that it can dispatch other tasks while I/O is in progress.
     5) The default BIOS routine for this function simply returns with the CF
	clear and AH=00h.


Function 91h	Interrupt Completed			(AT, XT/286, PS/2 50+)
entry	AH	91h
	AL	type code (see AH=90h above)
		00h-7Fh  serially reusable devices
		80h-0BFh reentrant devices
	ES:BX	pointer to request block for type codes 80h through 0BFh
return	AH	 00h
note 1) Used by NETBIOS.
     2) Invoked by the BIOS disk network, and keyboard handlers to signal that
	I/O is complete and/or the device is ready.
     3) Predefined device types that may use Device POST are:
	00H  disk		    (may timeout)
	01H  floppy disk	    (may timeout)
	02H  keyboard		    (no timeout)
	03H  PS/2 pointing device   (may timeout)
	80H  network		    (no timeout)
     4) The BIOS printer routine does not invoke this function because printer
	output is not interrupt driven.
     5) A multitasking program manager would be expected to capture int 15h/
	fn 91h so that it can be notified when I/O is completed and awaken the
	requesting task.
     6) The default BIOS routine for this function simply returns with the CF
	flag clear and AH=00h.

									-54-


Function 0C0h	Get System Configuration      (XT after 1/10/86, PC Convertible,
					       XT/286, AT, PS/2)
entry	AH	0C0h
return	CF	set	if BIOS doesn't support call
	ES:BX	pointer to ROM system descriptor table
	  bytes 00h-01h number of bytes in the following table (norm. 16 bytes)
		02h	system ID byte; see Chapter 2 for interpretation
		03h	secondary ID distingushes between AT and XT/286, etc.
		04h	BIOS revision level, 0 for 1st release, 1 for 2nd, etc.
		05h	feature information byte
		   bits 7	DMA channel 3 used by hard disk BIOS
			6	second 8259 installed (cascaded IRQ2)
			5	realtime clock installed
			4	kbd intrcpt:int 15h, fn 04h called upon int 09h
			3	wait for external event supported (int 15fn41)
				 used on Convertible; reserved on PS/2 systems
			2	extended BIOS area allocated at 640k
			1	bus is Micro Channel instead of PC
			0	reserved
		06h	unknown (set to 0) (reserved by IBM)
		07h	unknown (set to 0) (reserved by IBM)
		08h	unknown (set to 0)
		09h	unknown (set to 0) (Award copyright here)
note 1) Int 15h is also used for the Multitask Hook on PS/2 machines. No
	register settings availible yet.
     2) The 1/10/86 XT BIOS returns an incorrect value for the feature byte.


Function 0C1h	Return Extended BIOS Data Area Segment Address	       (PS/2)
entry	AH	0C1h
return	CF	set on error
	ES	segment of XBIOS data area
note 1) The XBIOS Data Area is allocated at the high end of conventional memory
	during the POST (Power-On-Self-Test) sequence.
     2) The word at 0040:0013h (memory size) is updated to reflect the reduced
	amount of memory available for DOS and application programs.
     3) The 1st byte in the XBIOS Data Area is initialized to its length in K.
     4) A program can determine whether the XBIOS Data Area exists by using
	int 15h/fn 0C0h.


Function 0C2h	Pointing Device BIOS Interface	    (DesQview 2.x)    (PS/2)
entry	AH	0C2h
	AL	00h	enable/disable pointing device
			BH	00h	disable
				01h	enable
		01h	reset pointing device
			 Resets the system's mouse or other pointing device,
			sets the sample rate, resolution, and other
			characteristics to their default values.
			return	BH	device ID (0=first)
			note 1) After a reset operation, the state of the
				 pointing device is as follows:
				 disabled;
				 sample rate at 100 reports per second;
				 resolution at 4 counts per millimeter;
				 scaling at 1 to 1.
			     2) The data package size is unchanged by this fn.
			     3) Apps can use the fn 0C2h subfunctions to
				initialize the pointing device to other parms,
				then enable the device with fn 00h.
			     4) BL is altered on return.

									-55-


		02h	set sampling rate
			BH	00h	10/second
				01h	20/second
				02h	40/second
				03h	60/second
				04h	80/second
				05h	100/second  (default)
				06h	200/second
		03h	set pointing device resolution
			BH	00h	one count per mm
				01h	two counts per mm
				02h	four counts per mm  (default)
				03h	eight counts per mm
		04h	get pointing device type
			return	BH	ID code for the mouse or other pointing
					device.
		05h	initialize pointing device interface
			 Sets the data package size for the system's mouse or
			other pointing device, and initializes the resolution,
			sampling rate, and scaling to their default values.
			BH	data package size (1 - 8 bytes)
			note	After this operation, the state of the pointing
				device is as follows:
				a) disabled;
				b) sample rate at 100 reports per second;
				c) resolution at 4 counts per millimeter;
				d) scaling set at 1 to 1.
		06h	get status or set scaling factor
			 Returns the current status of the system's mouse or
			other pointing device or sets the device's scaling
			factor.
			BH	00h	return device status
				return	BL	status byte
				  bits	0	set if right button pressed
					1	reserved
					2	set if left button pressed
					3	reserved
					4	0	1:1 scaling
						1	2:1 scaling
					5	0	device disabled
						1	device enabled
					6	0	stream mode
						1	remote mode
					7	reserved
					CL	resolution
						00h	1 count per millimeter
						01h	2 counts per millimeter
						02h	4 counts per millimeter
						03h	8 counts per millimeter
					DL	sample rate (hex count)
						0Ah	10 reports per second
						14h	20 reports per second
						28h	40 reports per second
						3Ch	60 reports per second
						50h	80 reports per second
						64h	100 reports per second
						0C8h	200 reports per second
				01h	set scaling at 1:1
				02h	set scaling at 2:1
		07h	set pointing device handler address
			 Notifies BIOS pointing device driver of the address
			for a routine to be called each time pointing device
			data is available.
			ES:BX	address user device handler
			return	AL	00h

									-56-


return	CF	set on error
	AH	status
		00h	successful
		01h	invalid function
		02h	invalid input
		03h	interface error
		04h	need to resend
		05h	no device handler installed
note 1) The values in BH for those functions that take it as input are stored
	in different locations for each subfunction.
     2) The user's handler for pointing device data is entered via a far call
	with four parameters on the stack:
	SS:SP+0Ah    status
	SS:SP+08h    x coordinate
	SS:SP+06h    y coordinate
	SS:SP+04h    z coordinate (always 0)
	 The handler must exit via a far return without removing the parameters
	from the stack.
     3) The status parameter word passed to the user's handler is interpreted
	as follows:
	bits	0	left button pressed
		1	right button pressed
		2-3	reserved
		4	sign of x data is negative
		5	sign of y data is negative
		6	x data has overflowed
		7	y data has overflowed
		8-0Fh	reserved


Function 0C3h	Enable/Disable Watchdog Timeout 		(PS/2 50+)
entry	AH	0C3h
	AL	00h	disable
		01h	enable
			BX	timer counter
return	CF	set on error
note 1) The watchdog timer generates an NMI.
     2) This would be subject to protection with a real OS so temporary masters
	would not be able to seize the bus forever.


Function 0C4h	Programmable Option Select			(PS/2 50+)
entry	AH	04Ch
	AL	00h	return base POS register address
		01h	enable slot
			BL	slot number
		02h	enable adapter
return	CF	set on error
	DX	base POS register address (if function 00h)
note 1) Returns the base Programmable Option Select register address, enables
	a slot for setup, or enables an adapter.
     2) Valid on machines with Micro Channel Architecture (MCA) bus only.
     3) After a slot is enabled with fn 01h, specific information can be
	obtained for the adapter in that slot by performing port input
	operations:
	Port	Function
	100h	MCA ID (low byte)
	101h	MCA ID (high byte)
	102h	Option Select Byte 1
	    bit 0	0	if disabled
			1	if enabled
	103h	Option Select Byte 2
	104h	Option Select Byte 3
	105h	Option Select Byte 4
		bits 6-7 are channel check indicators
	106h	Subaddress Extension (low byte)
	107h	Subaddress Extension (high byte)

									-57-

Function 0DEh	DesQview Services			      (DesQview)
entry	AH	0DEh
	AL	00h	Get Program Name
			return	AX	offset into DESQVIEW.DVO of current
					program's record:
					byte	length of name
				      n bytes	name
				      2 bytes	keys to invoke program (second
						= 00h if only one key used)
					word	? (normally 0)
					byte	end flag: 00h for all but last
						entry, which is 0FFh
		01h	Update "Open Window" Menu
			return	none
			note	Reads DESQVIEW.DVO, disables Open menu if file
				not in current directory
		02h	unimplemented in DV 2.0x
			return	nothing (NOP in DV 2.0x)
		03h	unimplemented in DV 2.0x
			return	nothing (NOP in DV 2.0x)
		04h	Get Available Common Memory
			return	BX	bytes of common memory available
				CX	largest block available
				DX	total common memory in bytes
		05h	Get Available Conventional Memory
			return	BX	K of memory available
				CX	largest block available
				DX	total conventional memory in K
		06h	Get Available Expanded Memory
			return	BX	K of expanded memory available
				CX	largest block available
				DX	total expanded memory in K
		07h	APPNUM	Get Current Program's Number
			return	AX	number of program as it appears on the
					"Switch Windows" menu
		08h	GET (unknown)
			return	AX	00h	unknown
					01h	unknown
		09h	unimplemented in DV 2.00
			return	nothing (NOP in DV 2.00)
		0Ah	DBGPOKE Display Character on Status Line      (DV 2.0+)
			BL	character
			return	character displayed, next call will display in
				next position (which wraps back to the start of
				the line if off the right edge of screen)
			note 1) Displays character on bottom line of *physical*
				screen, regardless of current size of window
				(even entirely hidden)
			     2) Does not know about graphics display modes,
				just pokes the characters into display memory
		0Bh	APILEVEL Define Minimum API Level Required    (DV 2.0+)
			BL	API level. A value higher than 02h pops up "You
				need a newer version" error window in DV 2.00.
			BH	unknown
			return	AX	maximum API level?
		0Ch	GETMEM	Allocate "System" Memory	      (DV 2.0+)
			BX	number of bytes
			return	ES:DI	pointer to allocated block
		0Dh	PUTMEM	Deallocate "System" Memory	      (DV 2.0+)
			ES:DI	pointer to previously allocated block
			return	nothing
		0Eh	Find Mailbox by Name			      (DV 2.0+)
			ES:DI	pointer to name to find
			CX	length of name
			return	BX	00h	not found
					01h	found
				DS:SI	object handle

									-58-


		0Fh	Enable DesQview Extensions		      (DV 2.0+)
			return	AX and BX destroyed (seems to be bug, weren't
				saved & restored)
			note 1) Sends a manager stream with opcodes 0AEh, 0BDh,
				and 0BFh to task's window
			     2) Enables an additional mouse mode
		10h	PUSHKEY  Put Key Into Keyboard Input Stream   (DV 2.0+)
			BH	scan code
			BL	character
			return	BX	unknown (sometimes, but not always,
					same as BX passed in)
			note	A later read will get the keystroke as if it
				had been typed by the user
		11h	Enable/Disable Auto Justification of Window   (DV 2.0+)
			BL	00h	viewport will not move automatically
				nonzero viewport will move to keep cursor
					visible
			return	none
		12h	unknown 				      (DV 2.0+)
			BX	00h	clear something?
				nonzero set something?
			return	none


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 16h	Keyboard I/O						3**9  ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0058h)	Access the keyboard. Scancodes are found in Appendix 1. ASCII
		codes are found in Appendix 2.

		IBM's original keyboard layout is referred to as the 84-key
		or "old style". It has the function keys on the left and an
		embedded cursor/numeric keypad on the right. The 101-key "new
		style" or "enhanced" keyboard (such as used on the PS/2s) adds
		several keys. The early BIOS will not detect the new scancodes
		and the new BIOS for some reason added new function calls for
		this purpose instead of enhancing the old ones. This causes
		some hassle when writing programs which need to support both
		keyboards fully. Most programs limit themselves to the 84-key
		functions in the interest of backward compatibility.


Function  00h	Get Keyboard Input - read the next character in keyboard buffer,
		if no key ready, wait for one.
entry	AH	00h
return	AH	scan code
	AL	ASCII character
note 1) Removes keystroke from buffer (destructive read).
     2) Does not work with the extra keys on the 101-key "enhanced" keyboard.


Function  01h	Check Keystroke Buffer - Do Not Clear
entry	AH	01h
return	ZF	0 (clear) if character in buffer
		1 (set)   if no character in buffer
	AH	scan code of character (if ZF=0)
	AL	ASCII character if applicable
note 1) Keystroke is not removed from buffer. The same character and scan code
	will be returned by the next call to Int 16h/fn 00h.
     2) This call flushes the 101-key codes from the buffer if they precede
	an 84-key code.

									-59-

Function  02h	Shift Status - fetch bit flags indicating shift status
entry	AH	02h
return	AL	status byte (same as [0040:0017])
	   bits 7	Insert on
		6	CapsLock on
		5	NumLock on
		4	ScrollLock on
		3	Alt key down
		2	Control key down
		1	Left shift (left caps-shift key) down
		0	Right shift (right caps-shift key) down
note	The Keyboard Flags Byte is stored in the BIOS Data Area at 0000:0417h.


Function 03h	Keyboard - Set Repeat Rate	      (PCjr, AT, XT/286, PS/2)
entry	AH	03h
	AL	00h	reset typematic defaults		     (PCjr)
		01h	increase initial delay			     (PCjr)
		02h	decrease repeat rate by 1/2		     (PCjr)
		03h	increase both delays by 1/2		     (PCjr)
		04h	turn off typematic			     (PCjr)
		05h	set typematic rate			     (AT, PS/2)
	BH	00h-03h for delays of 250ms, 500ms, 750ms, or 1 second
			0,0	250ms
			0,1	500ms
			1,0	750ms
			1,1	1 second
	BL	00h-1Fh for typematic rates of 30cps down to 2cps
			00000 30     01011 10.9   10101 4.5
			00001 26.7   01100 10	  10110 4.3
			00010 24     01101 9.2	  10111 4
			00011 21.8   01110 8.6	  11000 3.7
			00100 20     01111 8	  11001 3.3
			00101 18.5   10000 7.5	  11010 3
			00110 17.1   10001 6.7	  11011 2.7
			00111 16     10010 6	  11100 2.5
			01000 15     10011 5.5	  11101 2.3
			01001 13.3   10011 5.5	  11110 2.1
			01010 12     10100 5	  11111 2
return	nothing
note 1) Subfunction 05h is available on ATs with ROM BIOS dated 11/15/85 and
	later, the XT/286, and the PS/2.
     2) Subfunction 0 (Return to Default Keyboard State) restores the keyboard
	to its original state. The original state at power-on is typematic on,
	normal initial delay and normal typematic rate.
     3) Subfunction 1 (Increase Initial Delay) increases the delay between the
	first character typed and the burst of typematic characters.
     4) For Subfunctions 0 through 4, each time the typematic rate is changed,
	all previous states are removed.


Function 04h	Keyboard Click Toggle		      (PCjr and Convertible)
entry	AH	04h
	AL	00h	for click off
		01h	for click on
return	nothing


Function 05h	Load Keyboard Buffer		(AT or PS/2 with enhanced kbd)
entry	AH	05h
	CH	scan code
	CL	ASCII character
return	CF	set on error
	AL	00h	success
		01h	if buffer full
note	Places a character and scan code at the end of the keyboard type-ahead
	buffer.

									-60-


Function 06h	Keyboard Buffer Write		     (Fansi-Console to 2.00)
entry	AH	06h
	BX	extended key value to place in typeahead buffer
return	unknown
note	This call may be dropped since it now duplicates function 05h.


Function 07h	Change Shift Key Status 	     (Fansi-Console to 2.00)
entry	AH	07h
	AL	shift key status value
return	unknown
note	Status byte is same as function 02h.


Function 10h	Get Enhanced Keystroke And Read      (F11, F12 Enhanced Keyb'd)
		(XT/286, PS/2, AT with "Enhanced" keyboard)
entry	AH	10h
return	AH	scan code
	AL	ASCII character if applicable
note 1) Reads a character and scan code from the keyboard type-ahead buffer.
     2) Use this function for the enhanced keyboard instead of Int 16h fn 00h.
	It allows applications to obtain the scan codes for the additional F11,
	F12, and cursor control keys.
     3) This is the enhanced version of function 00h.


Function 11h	Check Enhanced Keystroke	 (F11-F12 on enhanced keyboard)
		(XT/286, PS/2, AT with "Enhanced" keyboard)
entry	AH	11h
return	ZF	0	(clear) if key pressed
			AH	scan code
			AL	ASCII character if applicable
		1	if buffer is empty
note 1) Keystroke is not removed from buffer. The same char and scan code will
	be returned by the next call to Int 16h/fn 10h.
     2) Use this function for the enhanced keyboard instead of Int 16h/fn 00h.
	It allows applications to test for the additional F11, F12, and cursor
	control keys.


Function 12h	Extended Get Shift Status	  (F11, F12 Enhanced keyboard)
entry	AH	12h
return	AX	status word
		AL bit	0	right Shift key depressed
			1	left Shift key depressed
			2	Control key depressed
			3	Alt key depressed
			4	ScrollLock state active
			5	NumLock state active
			6	CapsLock state active
			7	insert state is active
		AH bit	0	left Control key pressed
			1	left Alt key depressed
			2	right Control key pressed
			3	right Alt key depressed
			4	Scroll Lock key depressed
			5	NumLock key depressed
			6	CapsLock key depressed
			7	SysReq key depressed
note	Use this function for the enhanced keyboard instead of int 16h/fn 02h.

									-61-

Function  75h	Set Tick Count for Scanning	  (pcAnywhere 2.00)
entry	AH	75h
	AL	tick count
return	none
note 1) Sets count of 55ms timer ticks between checks for new screen changes.
     2) pcAnywhere is a program that allows operation of a remote machine
	over a serial link.

Function  76h	Set Error Checking Mode 	  (pcAnywhere 2.00)
entry	AH	76h
	AL	error checking type
		00h	none
		01h	fast
		02h	slow
return	none

Function  77h	reserved			  (pcAnywhere 2.00)
pcAnywhere API - reserved

Function  78h	Log Off 			  (pcAnywhere 2.00)
entry	AL	00h	wait for another call
		01h	exit but remain TSR
		02h	automatic mode - watches DTR
return	none

Function  79h	Installation Check		  (pcAnywhere 2.00)
entry	AH	79h
	AL	00h	installation check
return	AX	0FFFFh	resident and active
		0FFFEh	resident but not active
		0FFFDh	resident TSR
		0FFFCh	automatic mode
		any other value - not resident

Function  7Ah	Cancel pcAnywhere Session	  (pcAnywhere 2.00)
entry	AH	7Ah
return	none
note	Leaves pcAnywhere resident but unable to answer another call.

Function  7Bh	Enable/Disable Operation	  (pcAnywhere 2.00)
entry	AH	7Bh
	AL	state
		00h	disabled
		01h	enabled
return	none
note	Remote screen is automatically refreshed when session is enabled.

Function  7Ch	Get Port Configuration		  (pcAnywhere 2.00)
entry	AH	7Ch
return	AH	port number in binary (0-15)
	AL	baud rate
		00h	50
		01h	75
		02h	110
		03h	134.5
		04h	150
		05h	300
		06h	600
		07h	1200
		08h	1800
		09h	2000
		0Ah	2400
		0Bh	4800
		0Ch	7200
		0Dh	9600
		0Fh	19,200

									-62-
Function  7Dh	Get/Set Terminal Parameters	  (pcAnywhere 2.00)
entry	AH	7Dh
	AL	00h	set parameters
		01h	get parameters
		02h	get configuration header and terminal parameters
	CX:DS	address of Terminal Parameter Block
return	AL	00h	nothing
		01h	current Terminal Parameter Block in CX:DS
		02h	configuration header and Terminal Parameter Block
			in CX:DS
note	Terminal Parameter Block format:   (1152 bytes) (decimal)
	384 bytes  CRT Control Information
		bytes	function
		1-8	cursor up
	       9-16	cursor down
	      17-24	cursor left
	      25-32	cursor right
	      33-40	cursor home
	      41-48	clear screen
	      49-56	clear to end of line
	      57-64	clear to end of page
	      65-72	insert line
	      73-80	delete line
	      81-88	insert character
	      89-96	delete character
	     97-104	cursor position lead in
	    105-112	between row and column
	    113-120	after cursor position
	    121-128	CRT initialization
	256 bytes  Character Translation Table
		translates ASCII characters from host. Normally changes IBM
		graphics characters to other displayable symbols
	512 bytes  keyboard sequences
	    641-644	cursor up
	    645-648	cursor down
	    649-652	cursor left
	    653-656	cursor right
	    657-660	home
	    661-664	end
	    665-668	PgUp
	    669-672	PgDn
	    673-676	insert
	    677-680	delete
	    681-684	control-home
	    685-688	control-end
	    689-692	control-PgUp
	    693-696	control-PgDn
	    697-700	escape
	    701-740	F1...F10
	    741-780	sF1...sF10
	    781-820	^F1...^F10
	    821-860	aF1...aF10
	    861-964	alt A-Z
	   965-1004	alt 0-9
	  1005-1008	alt =
	  1009-1012	alt -
	  1013-1016	print screen
	  1017-1020	ctrl-left arrow
	  1021-1024	ctrl-right arrow
	  1025-1120	reserved
	  1121-1124	begin conv. mode
	  1125-1128	remote printing off
	  1129-1132	remote printing on
	  1133-1136	backspace
	  1137-1140	refresh screen
	  1141-1144	send next code
	  1145-1148	display top 24 lines
	  1149-1152	display bottom 24 lines

									-63-


Function  7Eh	Serial I/O Through pcAnywhere Port   (pcAnywhere 2.00)
entry	AH	7Eh
	AL	I/O function
		01h	get port input status
		02h	get port input character
		03h	output character
		04h	hang up phone
	CX	ASCII character to output (fn 03h)
return	(if AL=01h)
	AX	00h	no character ready
		01h	character is available
	(if AL=02h)
	AL	ASCII code received


Function  7Fh	Set Keyboard/Screen Mode	    (pcAnywhere 2.00)
entry	AH	7Fh
	AL	parameters
		00h	enable remote keyboard only  |
		01h	enable host keyboard only    |	keyboard group
		02h	enable both keyboards	     |

		08h	display top 24 lines	     |	screen group
		09h	display bottom 24 lines      |

		10h	Hayes modem		     |
		11h	other modems		     |	modem group
		12h	direct connect		     |


Function 0EDh	Borland Turbo Lightning API  (partial)
entry	AH	0EDh
	BH	0EDh
	BL	function
		00h	installation check
		02h	pointer to Lightning internal data structure lobyte
		03h	pointer to Lightning internal data structure hibyte
		04h	load auxiliary dictionary
		06h	autoproof mode
		0Fh	get number of substitutions (segment)
	DS:DI	pointer to string to be processed
return	AX	error code (unknown)


Function 0F0h	Set CPU speed					  (Compaq 386)
entry	AH	0F0h	set speed
	AL	speed
		00h	equivalent to 6 mHz 80286 (COMMON)
		01h	equivalent to 8 mHz 80286 (FAST)
		02h	full 16 mHz (HIGH)
		03h	toggles between 8 mHz-equivalent and speed set by
			system board switch (AUTO or HIGH)
		04h-07h unknown
		08h	full 16 mHz except 8 mHz-equivalent during floppy disk
			access
		09h	specify speed directly
			CX	speed value, 1 (slowest) to 50 (full), 3 ~=8088
return	none?
note 1) Used by Compaq DOS MODE command.

									-64-


Function 0F1h	Read Current CPU Speed				  (Compaq 386)
entry	AH	0F1h
return	AL	speed code (see function 0F0h above)
		if AL=09h, CX=speed code


Function 0F2h	Determine Attached Keyboard Type		  (Compaq 386)
entry	AH	0F2h
return	AL	type
		00h	if 11-bit AT keyboard is in use
		01h	if 9-bit PC keyboard is in use


Function 0FFh	PC-Tools API
entry	AH	0FFh
other parameters unknown
note	PC-Tools is a Swiss-army-knife software package with an editor, DOS
	shell, cache, disk optimizer, and several other functions from Central
	Point Software.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 17h	Printer 						3**10 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:005Ch)	access the parallel printer(s)
		AH is changed. All other registers left alone.

Function  00h	Print Character/send AL to printer DX (0, 1, or 2)
entry	AH	00h
	AL	ASCII character code
	DX	printer to be used
		00h	PRN or LPT1
		01h	LPT2
		02h	LPT3
return	AH	status byte
	   bits 0	time out
		1	unused
		2	unused
		3	I/O error
		4	printer selected
		5	out of paper
		6	acknowledge
		7	not busy


Function 01h	Initialize Printer - set init line low, send 0Ch to printer DX
entry	AH	01h
	DX	printer port to be initialized (0,1,2)
return	status as below

									-65-


Function  02h	Printer Status - read status of printer DX into AH
entry	AH	02h
	DX	printer port to be used (0,1,2)
return	AH	status byte
	   bits 7	0	busy/paused: the printer cannot immediately
				take more data because it is in the middle of
				accepting a character, printing a line, is
				offline, or it is in error status.
			1	ready
		6   ACKnowledge line toggled: reflects the state of the ACK
		    line on the printer port at the moment the status was read.
		    ACK is a strobe: it goes low for a very short time (12
		    microseconds on an Epson) when the printer is ready for
		    another character. As far as printer status is concerned,
		    this is useless; it's only useful for something like an
		    interrupt-driven interface. Most of the time, you'll see
		    ACK high (bit 6 on), but occasionally, if you check status
		    just after sending a character, you might see it low.
		    ACK is low when the printer is powered off.
		5   out-of-paper line toggled
		4   printer selected: printer is selected/ready/online. There
		    is usually a button on the printer to control this.
		3   I/O error: offline, out of paper or other error condition
		    such as out of ribbon.
		2   unused
		1   unused
		0   timeout error: printer failed to send ACK and drop busy
		    after being sent a character.
note 1) You can expect to see these states in a properly functioning printer:
	Normal		      Offline		     Power off
	======		      =======		     =========
	not busy/paused       busy/paused	     busy/paused
	not out of paper      not out of paper	     not out of paper
	selected/online       not selected/online    not selected/online
	not I/O error	      I/O error (usually)    I/O error
	not timeout error     not timeout error      not timeout error
     2) Not all printers return the status codes properly. That's OK, not all
	clone BIOS do it right either. If your program depends on the return
	codes, you might want to make the code easily patched or configured
	for nonstandard hardware.




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 18h	ROM BASIC						3**11 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0060h)	Execute ROM BASIC at address 0F600h:0000h
entry	no parameters used
return	jumps into ROM BASIC on IBM systems
note 1) Often reboots a compatible.
     2) Used by Turbo C 1.5. 2.0 and later do not use it.
     3) On IBM systems, this interrupt is called if disk boot failure occurs.
     4) Video interrupt on DEC Rainbow.
     5) Digital Research's ROM-based implementation of DR-DOS uses int 18h as
	the initial entry vector into the operating system code. Note that
	some clone BIOSes may not properly implement int 18h in the ROM and
	use of DR-DOS ROMs may not always work.

									-66-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 19h	Bootstrap Loader / Extended Memory VDISK ID		3**12 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0064h)
entry	no parameters used
return	none
note 1) Reads track 0, sector 1 into address 0000h:7C00h, then transfers
	control to that address. If no diskette drive available, transfers to
	ROM-BASIC via int 18h or displays loader error message.
     2) Causes reboot of disk system if invoked while running. (no memory test
	performed).
     3) If location 0000:0472h does not contain the value 1234h, a memory test
	(POST) will be performed before reading the boot sector.
     4) VDISK from DOS 3.0+ traps this vector to determine when the CPU has
	shifted from protected mode to real mode. A detailed discussion can
	be found by Ray Duncan in PC Magazine, May 30, 1989.
     5) Reportedly, some versions of DOS 2.x and all versions of DOS 3.x+
	intercept int 19h in order to restore some interrupt vectors DOS takes
	over, in order to put the machine back to a cleaner state for the
	reboot, since the POST will not be run on the int 19h. These vectors
	are reported to be: 02h, 08h, 09h, 0Ah, 0Bh, 0Ch, 0Dh, 0Eh, 70h, 72h,
	73h, 74h, 75h, 76h, and 77h. After restoring these, it restores the
	original int 19h vector and calls int 19h.
     6) The system checks for installed ROMs by searching memory from 0C000h to
	the beginning of the BIOS, in 2k chunks. ROM memory is identified if it
	starts with the word 0AA55h. It is followed a one byte field length of
	the ROM (divided by 512). If ROM is found, the BIOS will call the ROM
	at an offset of 3 from the beginning. This feature was not supported in
	the earliest PC machines. The last task turns control over to the
	bootstrap loader (assuming the floppy controller is operational).



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Ah	Time of Day						3**13 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0068h)    1) Accesses the PC internal clock.
	     2) This interrupt is not supported on some machines, such as
		the HP150 PC.
	     3) Some "turbo" BIOSes run the clock slower than normal in order
		to throw off benchmark software, which usually uses int 1Ah
		for timekeeping.


Function 00h	Read System Timer Tick Counter		       (except PC)
entry	AH	00h
return	AL	00h	if clock was read or written (via AH=0,1) within the
			current 24-hour period.
		<>0	midnight was passed since last read
	CX:DX	32-bit tick count (high 16 bits in CX)
note 1) The returned value is the cumulative number of clock ticks since
	midnight. There are 18.2 clock ticks per second, or one every 54.92ms.
	When the counter reaches 1,573,040, it is cleared to zero, and the
	rollover flag is set.
     2) The rollover flag is cleared by this function call, so the flag will
	only be returned nonzero once per day.
     3) Int 1Ah/fn 01h can be used to set the counter to an arbitrary 32 bit
	value.

									-67-


Function 01h	Set Clock Tick Counter Value			(except PC)
entry	AH	01h
	CX:DX	32-bit high word/low word count of timer ticks
return	none
note 1) The clock ticks are incremented by timer interrupt at 18.2065 times
	per second or 54.9254 milliseconds/count. Therefore:
		counts per second   18	    (12h)
		counts per minute   1092    (444h)
		counts per hour     65543   (10011h)
		counts per day	    1573040 (1800B0h)
     2) The counter is zeroed when system is rebooted.
     3) Stores a 32-bit value in the clock tick counter.
     4) The rollover flag is cleared by this call.


Function 02h	Read Real Time Clock Time			(AT and after)
entry	AH	02h
return	CH	hours in BCD
	CL	minutes in BCD
	DH	seconds in BCD
	DL	00h	standard time
		01h	daylight savings time
	CF	0	if clock running
		1	if clock not operating
note	Reads the current time from the CMOS time/date chip.


Function 03h	Set Real Time Clock Time			(AT and after)
entry	AH	03h
	CH	hours in BCD
	CL	minutes in BCD
	DH	seconds in BCD
	DL	0 (clear) if standard time
		1 (set)   if daylight savings time option
return	none
note	Sets the time in the CMOS time/date chip.


Function 04h	Read Real Time Clock Date			(AT and after)
entry	AH	04h
return	CH	century in BCD (19 or 20)
	CL	year in BCD
	DH	month in BCD
	DL	day in BCD
	CF	0 (clear) if clock is running
		1 (set)   if clock is not operating
note	Reads the current date from the CMOS time/date chip.


Function 05h	Set Real Time Clock Date			(AT and after)
entry	AH	05h
	CH	century in BCD (19 or 20)
	CL	year in BCD
	DH	month in BCD
	DL	day in BCD
return	none
note	Sets the date in the CMOS time/date chip.

									-68-


Function 06h	Set Real Time Clock Alarm			(AT and after)
entry	AH	06h
	CH	hours in BCD
	CL	minutes in BCD
	DH	seconds in BCD
return	CF	set if alarm already set or clock inoperable
note 1) Sets alarm in the CMOS date/time chip. Int 4Ah occurs at specified
	alarm time every 24hrs until reset with Int 1Ah/fn 07h.
     2) A side effect of this function is that the clock chip's interrupt
	level (IRQ8) is enabled.
     3) Only one alarm may be active at any given time.
     4) The program using this function must place the address of its interrupt
	handler for the alarm in the vector for Int 4Ah.


Function 07h	Reset Real Time Clock Alarm			(AT and after)
entry	AH	07h
return	none
note 1) Cancels any pending alarm request on the CMOS date/time chip.
     2) This function does not disable the clock chip's interrupt level (IRQ8).


Function 08h	Set Real Time Clock Activated Power On Mode	(Convertible)
entry	AH	08h
	CH	hours in BCD
	CL	minutes in BCD
	DH	seconds in BCD


Function 09h	Read Real Time Clock Alarm Time and Status
						(Convertible and PS/2 Model 30)
entry	AH	09h
return	CH	hours in BCD
	CL	minutes in BCD
	DH	seconds in BCD
	DL	alarm status:
		00h	if alarm not enabled
		01h	if alarm enabled but will not power up system
		02h	if alarm will power up system


Function 0Ah	Read System-Timer Day Counter			       (PS/2)
entry	AH	0Ah
return	CF	set on error
	CX	count of days since Jan 1,1980
note	Returns the contents of the system's day counter.


Function 0Bh	Set System-Timer Day Counter			       (PS/2)
entry	AH	0Bh
	CX	count of days since Jan 1,1980
return	CF	set on error
note	Stores an arbitrary value in the system's day counter.


Function 80h	Set Up Sound Multiplexor		(PCjr) (Tandy 1000?)
entry	AH	80h
	AL	sound source
		00h	source is 8253 timer chip, channel 2
		01h	source is cassette input
		02h	source is I/O channel "audio in" line
		03h	source is TI sound generator chip
return	none
note	Sets up the source for tones that will appear on the PCjr's Audio Out
	bus line or RF modulator.

									-69-


Function 1Ah	Read Time and Date				   (AT&T 6300)
entry	AH	0FEh
return	BX	days count (1=Jan 1, 1984)
	CH	hours
	CL	minutes
	DH	seconds
	DL	hundredths
note	Day count in BX is unique to AT&T/Olivetti computers.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Bh	Control-Break						3**14 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:006Ch)	This interrupt is called when the keyboard handler of the IBM
		machines detects Ctrl and Break pressed at the same time. DOS
		normally point this interrupt at its own Ctrl-Break handler.

note 1) If the break occurred while processing an interrupt, one or more
	end of interrupt commands must be send to the 8259 Programmable
	Interrupt Controller.
     2) All I/O devices should be reset in case an operation was underway at
	the time.
     3) It is normally pointed to an IRET during system initialization so that
	it does nothing, but some programs change it to return a Ctrl-C scan
	code and thus invoke int 23h.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Ch	Timer Tick						3**15 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0070h)
note 1) Taken 18.2065 times per second by the int 08h interrupt.
     2) Normally vectors to dummy IRET unless PRINT.COM has been installed.
     3) If an application moves the interrupt pointer, it is the responsibility
	of that application to save and restore all registers that may be
	modified.
     4) returns values at absolute address 40:6x (BIOS Data Area); number of
	ticks since midnight
	40:6C	word	timer counter high word
	40:6E	word	timer counter low word

									-70-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Dh	Vector of Video Initialization Parameters		3**16 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0074h)	This doubleword address points to 3 sets of 16-bytes containing
		data to initialize for video modes for video modes 0 & 1 (40
		column), 2 & 3 (80 column), and 4, 5 & 6 (graphics) on the
		Motorola 6845 CRT controller chip.
 6845 registers:
	R0	horizontal total		(horizontal sync in characters)
	R1	horizontal displayed			  (characters per line)
	R2	horizontal sync position	   (move display left or right)
	R3	sync width	   (vertical and horizontal pulse: 4-bits each)
	R4	vertical total				(total character lines)
	R5	vertical adjust 	       (adjust for 50 or 60 Hz refresh)
	R6	vertical displayed		     (lines of chars displayed)
	R7	vertical sync position		     (lines shifted up or down)
	R8	interlace (bits 4 and 5) and skew (bits 6 and 7)
	R9	max scan line addr		 (scan lines per character row)
	R10	cursor start			 (starting scan line of cursor)
	R11	cursor stop			   (ending scan line of cursor)
	R12	video memory start address high byte		       (6 bits)
	R13	video memory start address low byte		       (8 bits)
	R14	cursor address high byte			       (6 bits)
	R15	cursor address low byte 			       (8 bits)

 6845 Video Init Tables:
	table for modes 0 and 1   \
	table for modes 2 and 3    \ each table is 16 bytes long and
	table for modes 4,5, and 6 / contains values for 6845 registers
	table for mode 7	  /
      4 words	size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
      8 bytes	number of columns in each mode
      8 bytes	video controller mode byte for each mode
note 1) There are 4 separate tables, and all 4 must be initialized if all
	video modes will be used.
     2) The power-on initialization code of the computer points this vector
	to the ROM BIOS video routines.
     3) IBM recommends that if this table needs to be modified, it should be
	copied into RAM and only the nescessary changes made.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Eh	Vector of Diskette Controller Parameters		3**17 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0078h)	Dword address points to data base table that is used by BIOS.
		Default location is at 0F000:0EFC7h. 11-byte table format:
	  bytes:
		00h	4-bit step rate, 4-bit head unload time
		01h	7-bit head load time, 1-bit DMA flag
		02h	54.9254 ms ticks - delay til motor off (36-38 typical)
		03h	sector size:
			00h	128 bytes
			01h	256 bytes
			02h	512 bytes
			03h	1024 bytes
		04h	last sector on track		      (8 or 9 typical)
		05h	inter-sector gap on read/write		  (42 typical)
		06h	data length for DMA transfers		(0FFh typical)
		07h	gap length between sectors for format	  (80 typical)
		08h	sector fill byte for format		(0F6h typical)
		09h	head settle time (in milliseconds)  (15 to 25 typical)
			DOS 1.0   0
			DOS 1.10  0
			DOS 2.10  15
			DOS 3.1   1
		0Ah	motor start time (in 1/8 sec intervals)  (2-4 typical)
			DOS 2.10  2

									-71-


note 1) This vector is pointed to the ROM BIOS diskette tables on system
	initialization
     2) IBM recommends that if this table needs to be modified, it should be
	copied into RAM and only the nescessary changes made.
     3) Some versions of DOS 3.2 may contain a bug. DOS 3.2 assumes that the
	dword at 0070:0F37 contains the address of the diskette parameter
	block and changes values in that block. The location does contain a
	copy of the value at 0:78 (int 1Eh, DISK_POINTER) if DOS is booted from
	diskette, but when booted from the hard disk, the location contains
	0:0. This leads to strange things, especially when running under a
	debugger since DOS overwrites parts of the interrupt vectors for
	interrupts 1 to 3. The solution to the problem is to either upgrade
	to DOS 3.3 or to copy the disk parameter vector to 70:F37 before
	running or at the start of your program.





ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 1Fh	Ptr to Graphics Character Extensions (Graphics Set 2)	3**18 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:007Ch)	This is the pointer to data used by the ROM video routines to
		display characters above ASCII 127 while in CGA medium and high
		res graphics modes.

note 1) Doubleword address points to 1K table composed of 28 8-byte character
	definition bit-patterns. First byte of each entry is top row, last byte
	is bottom row.
     2) The first 128 character patterns are located in system ROM.
     3) This vector is set to 000:0 at system initialization.
     4) Used by DOS' external GRAFTABL command.

