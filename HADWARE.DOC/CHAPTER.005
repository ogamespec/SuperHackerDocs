									-131-

   **  Programmer's  Technical	Reference  for	MSDOS  and  the  IBM  PC **
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ´ Registered User Version ÃÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
			 not for public distribution
		 Copyright (c) 1987, 1988, 1989 Dave Williams


			    C H A P T E R   F I V E


			  Interrupts 22h Through 86h


				C O N T E N T S

Interrupt 22h	Terminate Address ..................................... 5**1
Interrupt 23h	Ctrl-Break Exit Address ............................... 5**2
Interrupt 24h	Critical Error Handler ................................ 5**3
Interrupt 25h	Absolute Disk Read .................................... 5**4
Interrupt 26h	Absolute Disk Write ................................... 5**5
Interrupt 27h	Terminate And Stay Resident ........................... 5**6
Interrupt 28h	DOS Idle Interrupt .................................... 5**7
Interrupt 29h	Fast Screen Write ..................................... 5**8
Interrupt 2Ah	Microsoft Networks - Session Layer Interrupt .......... 5**9
Interrupt 2Bh	Unknown ............................................... 5**10
Interrupt 2Ch	Unknown ............................................... 5**11
Interrupt 2Dh	Unknown ............................................... 5**12
Interrupt 2Eh	Alternate EXEC (DOS 2.0+) ............................. 5**13
Interrupt 2Fh	Multiplex Interrupt ................................... 5**14
Interrupt 30h	FAR jump instruction for CP/M-style calls ............. 5**15
Interrupt 31h	Unknown ............................................... 5**16
Interrupt 32h	Unknown ............................................... 5**17
Interrupt 33h	Used by Microsoft Mouse Driver Function Calls ......... 5**18
Interrupt 34h	Turbo C/Microsoft languages - Floating Point emulation	5**19
Interrupt 35h	Turbo C/Microsoft languages - Floating Point emulation	5**20
Interrupt 36h	Turbo C/Microsoft languages - Floating Point emulation	5**21
Interrupt 37h	Turbo C/Microsoft languages - Floating Point emulation	5**22
Interrupt 38h	Turbo C/Microsoft languages - Floating Point emulation	5**23
Interrupt 39h	Turbo C/Microsoft languages - Floating Point emulation	5**24
Interrupt 3Ah	Turbo C/Microsoft languages - Floating Point emulation	5**25
Interrupt 3Bh	Turbo C/Microsoft languages - Floating Point emulation	5**26
Interrupt 3Ch	Turbo C/Microsoft languages - Floating Point emulation	5**27
Interrupt 3Dh	Turbo C/Microsoft languages - Floating Point emulation	5**28
Interrupt 3Eh	Turbo C/Microsoft languages - Floating Point emulation	5**29
Interrupt 3Fh	Overlay manager interrupt (Microsoft LINK.EXE) ........ 5**30
Interrupt 40h	Hard Disk BIOS ........................................ 5**31
Interrupt 41h	Hard Disk Parameters .................................. 5**32
Interrupt 42h	Pointer to screen BIOS entry .......................... 5**33
Interrupt 43h	Pointer to EGA graphics character table ............... 5**34
Interrupt 44h	Pointer to graphics character table ................... 5**35
Interrupt 45h	Reserved by IBM  (not initialized) .................... 5**36
Interrupt 46h	Pointer to second hard disk parameter block ........... 5**37
Interrupt 47h	Reserved by IBM  (not initialized) .................... 5**38
Interrupt 48h	Cordless Keyboard Translation ......................... 5**39
Interrupt 49h	Non-keyboard Scan Code Translation Table Address (PCjr) 5**40
Interrupt 4Ah	Real-Time Clock Alarm (Convertible, PS/2) ............. 5**41
Interrupt 4Bh	Reserved by IBM  (not initialized) .................... 5**42
Interrupt 4Ch	Reserved by IBM  (not initialized) .................... 5**43
Interrupt 4Dh	Reserved by IBM  (not initialized) .................... 5**44
Interrupt 4Eh	Reserved by IBM  (not initialized) .................... 5**45
Interrupt 4Fh	Reserved by IBM  (not initialized) .................... 5**46
Interrupt 50-57 IRQ0-IRQ7 Relocation .................................. 5**47
Interrupt 58h	Reserved by IBM  (not initialized) .................... 5**48
Interrupt 59h	Reserved by IBM  (not initialized) .................... 5**49
Interrupt 5Ah	Reserved by IBM  (not initialized)  ................... 5**50

									-132-

Interrupt 5Bh	Reserved by IBM  (not initialized) .................... 5**51
Interrupt 5Ah	Cluster Adapter BIOS entry address .................... 5**52
Interrupt 5Bh	Reserved by IBM  (not initialized) .................... 5**53
Interrupt 5Ch	NETBIOS interface entry port, TOPS .................... 5**54
Interrupt 5Dh	Reserved by IBM  (not initialized) .................... 5**55
Interrupt 5Eh	Reserved by IBM  (not initialized) .................... 5**56
Interrupt 5Fh	Reserved by IBM  (not initialized) .................... 5**57
Interrupt 60h-67h  User Program Interrupts ............................ 5**58
Interrupt 68h	Not Used  (not initialized) ........................... 5**59
Interrupt 69h	Not Used  (not initialized) ........................... 5**60
Interrupt 6Ah	Not Used  (not initialized) ........................... 5**61
Interrupt 6Bh	Not Used  (not initialized) ........................... 5**62
Interrupt 6Ch	System Resume Vector (Convertible) .................... 5**63
Interrupt 6Dh	Not Used  (not initialized) ........................... 5**64
Interrupt 6Eh	Not Used  (not initialized) ........................... 5**65



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 22h	 Terminate Address ..................................... 5**1 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0088h)
 This interrupt transfers control to the far (dword) address at this interrupt
location when an application program terminates. The default address for this
interrupt is 0:0088h through 0:008Bh. This address is copied into the program's
Program Segment Prefix at bytes 0Ah through 0Dh at the time the segment is
created and is restored from the PSP when the program terminates. The calling
program is normally COMMAND.COM or an application. Do not issue this interrupt
directly, as the EXEC function call does this for you. If an application
spawns a child process, it must set the Terminate Address prior to issuing the
EXEC function call, otherwise when the second program terminated it would
return to the calling program's Terminate Address rather than its own. This
address may be set with int 21, function 25h.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 23h	 Ctrl-Break Exit Address ............................... 5**2 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:008Ch)
 If the user enters a Ctrl-Break during STDIN, STDOUT, STDPRN, or STDAUX, int
23h is executed. If BREAK is on, int 23h is checked on MOST function calls
(notably 06h). If the user written Ctrl-Break routine saves all registers, it
may end with a return-from-interrupt instruction (IRET) to continue program
execution. If the user-written interrupt program returns with a long return, the
carry flag is used to determine whether the program will be aborted. If the
carry flag is set, the program is aborted, otherwise execution continues (as
with a return by IRET). If the user-written Ctrl-Break interrupt uses function
calls 09h or 0Ah, (Display String or Buffered Keyboard Input) then a three-byte
string of 03h-0Dh-0Ah (ETX/CR/LF) is sent to STDOUT. If execution is continued
with an IRET, I/O continues from the start of the line. When the interrupt
occurs, all registers are set to the value they had when the original function
call to DOS was made.

 There are no restrictions on what the Ctrl-Break handler is allowed to do,
including DOS function calls, as long as the registers are unchanged if an IRET
is used.

 If the program creates a new segment and loads a second program which itself
changes the Ctrl-Break address, the termination of the second program and
return to the first causes the Ctrl-Break address to be restored from the PSP
to the value it had before execution of the second program.

									-133-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 24h	 Critical Error Handler ................................ 5**3 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0090h)

 When an unrecoverable I/O error occurs, control is transferred to an error
handler in the resident part of COMMAND.COM with an int 24h. This may be the
standard DOS error handler (Abort, Retry, Ignore, Fail?) or a user-written
routine.

 On entry to the error handler, AH will have its bit 7=0 (high order bit)
if the error was a disk error (probably the most common error), bit 7=1 if not.

 BP:SI contains the address of a Device Header Control Block from which
additional information can be retrieved (see below). The register is set up
for a retry operation and an error code is in the lower half of the DI register
with the upper half undefined.

 DOS places the following items on the user stack. The stack contains the
following from top to bottom:

	IP   ³	 DOS registers from the issuing int 24h
	CS   ³
      flags  ³
      ÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	AX   ³	 user registers at time of original int 21h request
	BX   ³
	CX   ³
	SI   ³
	DI   ³
	BP   ³
	DS   ³
	ES   ³
      ÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
	IP   ³	 original int 21h from the user to DOS
	CS   ³
      flags  ³

 To reroute the critical error handler to a user-written critical error handler,
the following should be done:

Before an int 24h occurs:
1) The user application initialization code should save the int 24h vector and
   replace the vector with one pointing to the user error routine.

When the int 24h occurs:
2) When the user error routine received control it should push the flag
   registers onto the stack and execute a far call to the original int 24h
   vector saved in step 1.
3) DOS gives the appropriate prompt, and waits for user input (Abort, Retry,
   Ignore, Fail). After the user input, DOS returns control to the user error
   routine instruction following the far call.
4) The user error routine can now do any tasks necessary. To return to the
   original application at the point the error occurred, the error routine needs
   to execute an IRET instruction. Otherwise, the user error routine should
   remove the IP, CS, and flag registers from the stack. Control can then be
   passed to the desired routine.

									-134-

 Int 24h provides the following values in registers on entry to the interrupt
handler:

entry	AH	status byte (bits)
		7	0	disk I/O hard error
			1	other error - if block device, bad FAT
				- if char device, code in DI
		6	unused
		5	0	if IGNORE is not allowed
			1	if IGNORE is allowed
		4	0	if RETRY  is not allowed
			1	if RETRY  is allowed
		3	0	if FAIL   is not allowed
			1	if FAIL   is allowed
		2 \	disk area of error  00 = DOS area  01 = FAT
		1 /			    10 = root dir  11 = data area
		0	0	if read operation
			1	if write operation
	AL	drive number if AH bit 7 = 1, otherwise undefined
		If it is a hard error on disk (AH bit 7=0), register AL
		contains the failing drive number (0=A:, 1=B:, etc.).
	BP:SI	address of a Device Header Control Block for which error
		occurred. Block device if high bit of BP:SI+4 = 1
	DI	(low byte) error code (note: high byte is undefined)
	       error code		  description
		00h		attempt to write on write-protected diskette
		01h		unknown unit
		02h		drive not ready
		03h		unknown command
		04h		data error (bad CRC)
		05h		bad request structure length
		06h		seek error
		07h		unknown media type
		08h		sector not found
		09h		printer out of paper
		0Ah		write fault
		0Bh		read fault
		0Ch		general failure
		0Fh		invalid disk change	 (DOS 3.0+)
		10h		FCB unavailable 	 (DOS 3.0+)
		11h		sharing buffer overflow  (DOS 3.0+)

	note: Only codes 00h through 0Ch are defined in DR-DOS 3.32.

The handler must return this information:

 The registers are set such that if an IRET is executed, DOS responds according
to (AL) as follows:
AL	00h	IGNORE the error
	01h	RETRY the operation
	02h	ABORT via int 22h (jump to terminate address)
	03h	FAIL the system call that is in progress (DOS 3.0+)
note 1) Be careful when choosing to ignore a response because this causes DOS
	to think that an operation has completed successfully when it may not
	have.
     2) If the error was a character device, the contents of AL are invalid.


Other Errors

 If AH bit 7=1, the error occurred on a character device, or was the result of
a bad memory image of the FAT. The device header passed in BP:SI can be examined
to determine which case exists. If the attribute byte high-order bit indicates
a block device, then the error was a bad FAT. Otherwise, the error is on a
character device.

									-135-

 If a character device is involved, the contents of AL are unpredictable, and
the error code is in DI as above.

note 1) Before giving this routine control for disk errors, DOS performs several
	retries. The number of retries varies according to the DOS version.
     2) For disk errors, this exit is taken only for errors occurring during an
	int 21h function call. It is not used for errors during an int 25h or
	26h.
     3) This routine is entered in a disabled state.
     4) All registers must be preserved.
     5) This interrupt handler should refrain from using DOS function calls. If
	necessary, it may use calls 01h through 12h. Use of any other call
	destroys the DOS stack and leaves DOS in an unpredictable state.
     6) The interrupt handler must not change the contents of the device header.
     7) If the interrupt handler handles errors itself rather than returning to
	DOS, it should restore the application program's registers from the
	stack, remove all but the last three words on the stack, then issue an
	IRET. This will return to the program immediately after the int 21h
	that experienced the error. Note that if this is done DOS will be in an
	unstable state until a function call higher than 12h is issued,
	therefore not recommended.
     8) For DOS 3.x+, IGNORE requests (AL=0) are converted to FAIL for critical
	errors that occur on FAT or DIR sectors.
     9) For DOS 3.10 up, IGNORE requests (AL=0) are converted to FAIL requests
	for network critical errors (50-79).
    10) The device header pointed to by BP:SI is as follows:
       dword	pointer to next device (0FFFFh if last device)
	word	attributes:
		bit	15	1	if character device.
					If bit 15 is 1:
					bit 0 = 1 if current standard input
					bit 1 = 1 if current standard output
					bit 2 = 1 if current NULL device
					bit 3 = 1 if current CLOCK device
				0	if block device.
		bit	14	is the IOCTL bit
	word	pointer to device driver strategy entry point
	word	pointer to device driver interrupt entry point
      8 bytes	character device named field for block devices. The first byte
		is the number of units.
    11) To tell if the error occurred on a block or character device, look at
	bit 15 in the attribute field (WORD at BP:SI+4).
    12) If the name of the character device is desired, look at the eight bytes
	starting at BP:SI+10.


Handling of Invalid Responses (DOS 3.0+)

     A) If IGNORE (AL=0) is specified by the user and IGNORE is not allowed
	(bit 5=0), make the response FAIL (AL=3).
     B) If RETRY (AL=1) is specified by the user and RETRY is not allowed
	(bit 4=0), make the response FAIL (AL=3).
     C) If FAIL (AL=3) is specified by the user and FAIL is not allowed
	(bit 3=0), make the response ABORT. (AL=2)

									-136-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 25h	 Absolute Disk Read .................................... 5**4 ³
³Interrupt 26h	 Absolute Disk Write ................................... 5**5 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0094h, 0:0098h)

  These transfer control directly to the disk device driver. On return, the
original flags are still on the stack (put there by the INT instruction). This
is necessary because return information is passed back in the current flags.
All registers except the segment registers are destroyed by these calls.

  The number of sectors specified is transferred between the given drive and the
transfer address. Logical sector numbers are obtained by numbering each sector
sequentially starting from track 0, head 0, sector 1 (logical sector 0) and
continuing along the same head, then to the next head until the last sector on
the last head of the track is counted.	Thus, logical sector 1 is track 0, head
0, sector 2; logical sector 2 is track 0, head 0, sector 3; and so on. Numbering
then continues wih sector 1 on head 0 of the next track. Note that although the
sectors are sequentially numbered (for example, sectors 2 and 3 on track 0 in
the example above), they may not be physically adjacent on disk, due to
interleaving. Note that the mapping is different from that used by DOS 1.10 for
double-sided diskettes.

 The request is as follows:

int 25 for Absolute Disk Read,		  | except Compaq DOS 3.31 or DOS 4.0+
int 26 for Absolute Disk Write		  | over-32Mb partitions
entry	AL	drive number (0=A:, 1=B:, etc)
	CX	number of sectors to read (int 25h) or write (int 26h)
	DS:BX	segment/offset of disk transfer address buffer (DTA)
	DX	first relative sector to read - beginning logical sector number
return	CF	set if error
	AL	error code issued to int 24h in low half of DI
	AH	01h	bad command
		02h	bad address mark
		03h	write-protected disk
		04h	requested sector not found
		08h	DMA failure
		10h	data error (bad CRC)
		20h	controller failed
		40h	seek operation failed
		80h	attachment failed to respond
note 1) DOS returns with a far ret which leave the original flags on the stack.
	Be sure to pop the stack to prevent uncontrolled growth.
     2) Ints 25 and 26 will try rereading a disk if they get an error the first
	time.

 To address partition sizes greater than 32Mb an extended format is provided
in Compaq DOS 3.31, DOS 4.0, and DR-DOS. This format passes a 32-bit address
value by means of a parameter block. The extended format may be used to
address disks smaller than 32Mb as well as larger.

 The request is as follows:

int 25 for Absolute Disk Read,		  | Compaq DOS 3.31 or DOS 4.0+
int 26 for Absolute Disk Write		  | over-32Mb partitions
entry	AL	drive number (0=A:, 1=B:, etc)
	CX	0FFFFh
	DS:BX	address of parameter block. Block format:
	       dword	sector number
		word	number of sectors to read
	       dword	FAR pointer to buffer

									-137-

return	CF	set if error
	AL	error code issued to int 24h in low half of DI
	AH	01h	bad command
		02h	bad address mark
		03h	write-protected disk
		04h	requested sector not found
		08h	DMA failure
		10h	data error (bad CRC)
		20h	controller failed
		40h	seek operation failed
		80h	attachment failed to respond
note 1) DOS returns with a far ret which leave the original flags on the stack.
	Be sure to pop the stack to prevent uncontrolled growth.
     2) Partition is potentially >32M (and requires this form of the call) if
	bit 1 of device attribute word in device driver is set.
     3) In the IBM OS/2 Tech Ref Volume 1, page 7-33, under "DOS Environment
	Software Interrupt Support", it lists:
	25h  direct read       supported
	26h  direct write      an error is returned on requests for
			       non-removable media




ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 27h	 Terminate And Stay Resident ........................... 5**6 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:009Ch)	(obsolete)
 This vector is used by programs that are to remain resident when COMMAND.COM
regains control.

 After initializing itself, the program must set DX to its last address plus
one relative to the program's initial DS or ES value (the offset at which other
programs can be loaded), then execute interrupt 27h. DOS then considers the
program as an extension of itself, so the program is not overlaid when other
programs are executed. This is useful for loading programs such as utilities
and interrupt handlers that must remain resident.

entry	CS	current program segment
	DX	last program byte + 1
return	none
note 1) This interrupt must not be used by .EXE programs that are loaded into
	the high end of memory.
     2) This interrupt restores the interrupt 22h, 23h, and 24h vectors in the
	same manner as interrupt 20h. Therefore, it cannot be used to install
	permanently resident Ctrl-Break or critical error handler routines.
     3) The maximum size of memory that can be made resident by this method is
	64K.
     4) Memory can be more efficiently used if the block containing a copy of
	the environment is deallocated before terminating. This can be done by
	loading ES with the segment contained in 2Ch of the PSP, and issuing
	function call 49h (Free Allocated Memory).
     5) DOS function call 4Ch allows a program to pass a completion code to DOS,
	which can be interpreted with processing (see function call 31h).
     6) Terminate and stay resident programs do not close files.
     7) Int 21, function 31h is the preferred method to cause a program to
	remain resident because this allows return information to be passed and
	allows a program larger than 64K to remain resident.
     8) It is possible to make an EXE program resident with this call by
	putting a 27h in the second byte of the PSP and terminating with a
	RET FAR.
     9) Programs terminating with int 27h do not close files on exit. Your
	program must explicitly close any opened files before going resident.

									-138-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 28h	 (not documented by Microsoft) ......................... 5**7 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	DOS Idle Interrupt

 Int 28h has been provided by DOS since release 2.0. The int 28h process is
similar to the "Timer Tick" process provided by BIOS via int 1Ch in that it is
an "outbound" (from DOS) call which an application can "hook onto" to get
service at a particular entry point. DOS normally only issues int 28h when it
recieves a function call (int 21h) from a foreground application with an
argument in the range of 0 thru 12 (0Ch) in the AH register, or when it is
idling waiting for keyboard input. In effect, when DOS issues int 28h, it is
saying to the background task "I'm not doing anything hot right now, if you can
use the time, go ahead." This means that a foreground application which doesn't
do many low-number DOS functions can preempt CPU time easily.

 When int 28h is being issued it is usually safe to do DOS calls. You won't get
int 28hs if a program is running that doesn't do its keyboard input through
DOS. You should rely on the timer interrupt for these. It is used primarily by
the PRINT.COM routines, but any number of other routines can be chained to it
by saving the original vector and calling it with a FAR call (or just JMPing to
it) at the end of the new routine.

 Int 28h is not called at all when any non-trivial foreground task is running.
As soon as a foreground program has a file open, int 28h no longer gets called.
Could make a good driver for for a background program that works as long as
there is nothing else going on in the machine.

 DOS uses 3 separate internal stacks: one for calls 01h through 0Ch; another
for calls 0Dh and above; and a third for calls 01h through 0Ch when a Critical
Error is in progress. When int 28h is called, any calls above 0Ch can be
executed without destroying the internal stack used by DOS at the time.

 The byte which is pushed on the stack before an int 28h just indicates which
stack area is being used by the current int 21h call. In DOS 3.1, the code
sequence that calls int 28h looks like this:

	PUSH	SS:[0304]
	INT	28
	POP	SS:[0304]

 The low-order byte of the word pushed contains 1 if the int 21h call currently
in progress is for services 1 through 0Ch, and 0 for service 0 and for 0Dh and
up. Assuming that the last DOS call was not a reentrant one, this tells you
which set of DOS services should be safe to call.

entry	no parameters availible
return	none
note 1) The int 28h handler may invoke any int 21h function except functions
	00h through 0Ch (and 50h/51h under DOS 2.x unless DOS CritErr flag is
	set).
     2) Apparently int 28h is also called during screen writes.
     3) Until some program installs its own routine, this interrupt vector
	simply points to an IRET opcode.
     4) Supported in OS/2 1.0's DOS Compatibility Box.
     5) It is possible, if you are careful, to enhance the background priority
	by providing more int 28h calls than DOS normally would issue.
     6) If the InDOS flag is zero on int 28h, then it was called by someone
	other than DOS, and the word on the stack should NOT be examined.

									-139-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 29h	 (not documented by Microsoft) ......................... 5**8 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	Internal - Quick Screen Output

 This method is extremely fast (much faster than DOS 21h subfunctions 2 and 9,
for example), and it is portable, even to "non-compatible" MS-DOS computers.

entry	AL	ASCII value for character to output to screen
return	unknown
note 1) Documented by Digital Equipment's DOS Reference as provided with the
	DEC Rainbow. Also documented by Digital Research in the DR-DOS manual.
     2) If ANSI.SYS is installed, character output is filtered through it.
     3) Works on the IBM PC and compatibles, Wang PC, HP-150 and Vectra, DEC
	Rainbow, NEC APC, Texas Instruments PC and others.
     4) This interrupt is called from the DOS's output routines if output is
	going to a device rather than a file, and the device driver's attribute
	word has bit 3 (04h) set to "1".
     5) This call has been tested with MSDOS 2.11, PCDOS 2.1, PCDOS 3.1, PCDOS
	3.2, PCDOS 3.3, PCDOS 4.01, and Compaq DOS 3.31.
     6) Used in IBMBIO.COM as a vector to int 10, function 0Eh (write TTY)
	followed by an IRET.
     7) Most of the fast ANSI device drivers use this interrupt - ZANSI.SYS,
	NANSI.SYS, and PCMag's ANSI.COM.
     8) When using int 29h to output characters the ASCII 7 (BELL) will
	suppress character output while the bell is sounding.
     9) When device drivers (or the SYSINIT module which loads the drivers)
	need to do console output, they use int 29h, to call the console device
	driver directly. For example, messages telling you about errors in your
	CONFIG.SYS file are printed using this service.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Ah	 Microsoft Networks - Session Layer Interrupt .......... 5**9 ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   1)	(not documented by Microsoft)
	   2)	 LANtastic NetBIOS interface
	   3)	 NetBIOS alternate interface. The alternate interface (2Ah) was
		 originally designed as a "higher" level interface to network
		 communications rather than the "low" level interface (5Ch)
		 provided by the NETBIOS. The 2Ah interface, however, does not
		 support any higher level functions than does the 5Ch interface
		 and therefore has not become a defacto standard as has the 5Ch
		 interface.

entry	AH	00h	Check for int 2Ah Network BIOS Installation
			return	AH	nonzero if installed
		01h	Execute NETBIOS Request (no error retry)
			ES:BX	pointer to NCB

									-140-

returnS:	AL	NETBIOS error code
		AH	0 if no error
			1 if error
		02h	Set Net Printer Mode
		03h	Get Shared-Device Status (Check Direct I/O)
			AL	00h
			DS:SI	pointer to ASCIIZ disk device name
			return	CF	0	if allowed
		04h	Execute NETBIOS (retry available)
			AL	00h	for error retry
				01h	for no retry
			ES:BX	pointer to network control block
			return	AX	0000h	for no error
				AH	01h	if error
				AL	error code (unknown)
			note	Error codes that are automatically retried are:
				09h	no sessions resources
				12h	no listen
				21h	interface busy
		05h	Get Network Resource Information
			AL	00h
			return	AX	reserved
				BX	# of network names (16 - names in use)
				CX	number of available NCB commands
				DX	number of sessions (max - pending)
		06h	Network Print-Stream Control
			note	NETBIOS 1.10
		(LANtastic)
			AL	01h	Set spooled output to combined mode
				return	none
				02h	Set spooled output in separate mode
				return	none
				note	Printer output is not combined when
					multiple programs are run or when the
					printer is opened or closed. This cmd.
					implicitly starts a new print job.
				03h	Flush printer output
				return	none
				note	Printer output is flushed and a new
					print job is started. If no output
					exists to be flushed then this function
					has no affect.
		07h-19h unknown
		20h	unknown
			note	AL=01h intercepted by DESQview 2.0.
		80h	Begin DOS Critical Section
			AL	1 to 6
		81h	End DOS Critical Section
			AL	1 to 6
		82h	Server Hook
			stack	AX from call to int 21h
			return	stack unchanged
			note	Called by the int 21h function dispatcher
				in DOS 3.10+ for function 0 and functions
				greater than 0Ch except 59h.
		84h	Keyboard Busy Loop
			note	Same functionality as DOS's int 28h?
		87h	Used by DOS PRINT to mark Critical Regions:
			AL	00h	Begin Critical Region
				01h	End Critical Region
			return	CF	1	region already active

									-141-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Bh	 (not documented by Microsoft) ......................... 5**10³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Ch	 (not documented by Microsoft) ......................... 5**11³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Dh	 (not documented by Microsoft) ......................... 5**12³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	Unknown - Internal Routine for DOS (IRET)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Eh	 (undocumented by Microsoft)  (DOS 2.0+) ............... 5**13³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	   *	Internal Routine for DOS  (Alternate EXEC)

  This interrupt passes a command line addressed by DS:SI to COMMAND.COM. The
command line must be formatted just like the unformatted parameter area of a
Program Segment Prefix. That is, the first byte must be a count of characters,
and the second and subsequent bytes must be a command line with parameters,
terminated by a carriage return character.

  When executed, int 2Eh will reload the transient part of the command
interpreter if it is not currently in memory. If called from a program that
was called from a batch file, it will abort the batch file. If executed from a
program which has been spawned by the EXEC function, it will abort the whole
chain and probably lock up the computer. Int 2Eh also destroys all registers
including the stack pointer.

  Int 2Eh is called from the transient portion of the program to reset the DOS
PSP pointers using the above Functions #81 & #80, and then reenters the
resident program.

  When called with a valid command line, the command will be carried out by
COMMAND.COM just as though you had typed it in at the DOS prompt. Note that the
count does not include the carriage return. This is an elegant way to perform a
SET from an application program against the master environment block for
example.

entry	DS:SI	pointer to an ASCIIZ command line in the form:
			count byte
			ASCII string
			carriage return
			null byte
note 1) Destroys all registers including stack pointer.
     2) Seems to work OK in both DOS 2.x and 3.x.
     3) It is reportedly not used by DOS.
     4) As far as known, int 2Eh is not used by DOS 3.1, although it was called
	by COMMAND.COM of PCDOS 3.0, so it appears to be in 3.1 only for the
	sake of compatibility.

									-142-


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 2Fh	 Multiplex Interrupt ................................... 5**14³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

 Interrupt 2Fh is the multiplex interrupt. A general interface is defined
between two processes. It is up to the specific application using interrupt
2Fh to define specific functions and parameters.

 This interrupt is becoming more commonly used as the availible interrupt 21
functions are getting to be in short supply. Int 2Fh doesn't require any
support from DOS itself for it to be used in application programs. It's not
handled by DOS, but by the programs themselves.

 Every multiplex interrupt handler is assigned a specific multiplex number.
The multiplex number is specified in the AH register; the AH value tells which
program your request is directed toward. The specific function that the handler
is to perform is placed in the AL register. Other parameters are places in the
other registers as needed. The handlers are chained into the 2Fh interrupt
vector and the multiplex number is checked to see if any other application is
using the same multiplex number. There is no predefined method for assigning a
multiplex number to a handler. You must just pick one. To avoid a conflict if
two applications choose the same multiplex number, the multiplex numbers used by
an application should be patchable. In order to check for a previous
installation of the current application, you can search memory for a unique
string included in your program. If the value you wanted in AH is taken but
you don't find the string, then another application has grabbed that location.

 Int 2Fh was not documented under DOS 2.x. There is no reason not to use int 2Fh
as the multiplex interrupt in DOS 2.x. The only problem is that DOS 2.x does not
initialize the int 2Fh vector, so when you try to chain to it like you are
supposed to, it will crash. If your program checks the vector for being zero
and initializes it itself or doesn't chain in that case, it will work for you
n 2.x just the same as 3.x.

 DOS 3.2 itself contains some int 2Fh handlers - it uses values of 08h, 13h,
and 0F8h. There may be more. NLSFUNC from DOS 3.3 up uses part of int 2Fh and
so does GRAFTABL.

 For int 2Fh calls, register AH identifies which program is to handle the
interrupt. AH values 00h-7Fh are reserved for DOS, not that anyone cares much.
Values 0C0h-0FFh are reserved for applications. Register AL contains the
subfunction code if used.

 IBM has reported that PC-DOS 4.0 will sometimes hang when substituting int
2Fh for int 67h for network calls.


Function   00h	unknown
	   Reportedly somehow used by PRINT.COM in DOS 3.3+.


Function   01h	PRINT.COM
	   PC-DOS 3.3's PRINT.COM hooks the following interrupt vectors:
		05h	PrintScreen Interrupt
		13h	BIOS Disk Interrupt
		14h	BIOS Serial Communications Interrupt
		15h	BIOS "System Services" Interrupt
		17h	BIOS Printer Interrupt
		19h	Bootstrap Loader Interrupt
		1Ch	Timer Tick
		23h	Control-C Terminate Address
		24h	Critical Error Handler Address
		28h	DOS Idle Interrupt (undocumented)
		2Fh	Multiplex Interrupt

									-143-

entry	AH	01h
		AL	00h	PRINT  Get Installed State
			This call must be defined by all int 2Fh handlers. It
			is used by the caller of the handler to determine if
			the handler is present. On entry, AL=0. On return, AL
			contains the installed state as follows:
		return	AL	0FFh	installed
				01h	not installed, not OK to install
				00h	not installed, OK to install

			01h	PRINT  Submit File
			DS:DX	pointer to submit packet
				format	byte	level
					dword	pointer to ASCIIZ filename
		return	CF	set if error
				AX	error code
		note 1) A submit packet contains the level (BYTE) and a pointer
			to the ASCIIZ string (DWORD in offset:segment form).
			The ASCIIZ string must contain the drive, path, and
			filename of the file you want to print. The filename
			cannot contain global filename characters.
		return	CF	set if error
				AX	error code

			02h	PRINT Cancel File
			On entry, AL=2 and DS:DX points to the ASCIIZ string for
			the print file you want to cancel. Global filename
			characters are allowed in the filename.
		DS:DX	pointer to ASCIIZ file name to cancel (wildcards OK)
		return	CF	set if error
				AX	error code

			03h	PRINT Remove All Files
		return	CF	set if error
				AX	error code

			04h	PRINT Hold Queue/Get Status
			This call holds the jobs in the print queue so that you
			can scan the queue. Issuing any other code releases the
			jobs. On entry, AL=4. On return, DX contains the error
			count. DS:SI points to the print queue. The print queue
			consists of a series of filename entries. Each entry is
			64 bytes long. The first entry in the queue is the file
			currently being printed. The end of the queue is marked
			by the entry having a null as the first character.
	       return	DX	error count
			DS:SI	pointer to print queue (null-string terminated
				list of 64-byte ASCIIZ filenames)
			CF	set if error
				AX	error code
					01h	function invalid
					02h	file not found
					03h	path not found
					04h	too many open files
					05h	access denied
					08h	queue full
					09h	spooler busy
					0Ch	name too long
					0Fh	drive invalid

			05h	PRINT restart queue
		return	CF	set if error
				AX	error code
			06h	unknown - may be used in DOS 3.3+ PRINT

									-144-


Function  02h	PC LAN Program
entry	AH	02h
other parameters unknown


Function   05h	DOS 3.0+ Critical Error Handler
entry	AH	05h
	AL	00h	Installation Check
		return	AL	00h	not installed, OK to install
				01h	not installed, not OK to install
				0FFh	installed
		note	This set of functions allows a user program to
			partially or completely override the default
			critical error handler in COMMAND.COM.
	AL	xxh	Handle Error - nonzero error code in AL
			(xxh indicates nonzero extended error code)
		return	CF	clear
			ES:DI	pointer to ASCIIZ error message
			AL	(?)
			CF	set	use default error handler
for LANtastic LANOS:
entry	AH	05h
	AL	00h	for installation check
		#	for error code (in pre DOS 4.00)
		1 or 2	for error code in DOS 4.00
	BX	in	Error code
return	CF	clear	if error code converted to text
		set	if error code can't be converted
	ES:DI	pointer to ASCIIZ text buffer containing error text. This is a
		read-only text buffer and you must not alter the text in this
		buffer.


Function   06h	ASSIGN
entry	AH	06h
	AL	00h	Installation Check
		01h	Get Memory Segment
return (AH=00h) AH	nonzero if ASSIGN is installed
       (AH=01h) ES	segment of ASSIGN work area


Function   08h	DRIVER.SYS
entry	AH	08h
	AL	00h	Installation Check
		return	AL	00h	not installed, OK to install
				01h	not installed, not OK to install
				0FFh	installed
		01h	unknown
		note	Moves down list of drivers?, copying and modifying word
			at offset 29h.
other parameters unknown


Function   10h	SHARE
entry	AH	10h
	AL	00h	Installation Check
return	AL	00h	not installed, OK to install
		01h	not installed, not OK to install
		0FFh	installed

									-145-


Function   11h	Multiplex - Network Redirection
entry	AH	11h
	AL	00h	Installation Check
			return	AL	00h    not installed, OK to install
					01h    not installed, not OK to install
					0FFh   installed
		01h-05h unknown
		06h	Close Remote File
		07h-09h unknown
		0Ah	unknown
			stack	word	(?)
			return	CF	set on error
		0Bh	unknown
			stack	word	(?)
			return	CF	set on error (?)
		0Ch	unknown
		0Dh	unknown
		0Eh	Do Redirection
			stack	word	function to execute
			return	CF	set on error
		0Fh	Printer Setup
			stack	word	function?
		10h	unknown
		11h	Rename File?
		12h-16h unknown
		17h	unknown
			stack	word	(?)
			return	(?)
		18h	unknown
			stack	word	(?)
			return	(?)
		19h-1Dh unknown
		1Eh	Do Redirection
			stack	word	function to execute
			return	CF	set on error
		1Fh	Printer Setup
			stack	word	function (?)
			return	CF	set on error (?)
		20h-25h unknown
			stack	word	(?)
		26h	unknown


Function   12h	Multiplex, DOS 3.x Internal Services
entry	AH	12h
	AL	00h	Installation Check
			return	AL	0FFh	for compatibility with other
						int 2Fh functions
		01h	Close File (?)
			stack	word value - unknown
			return	BX	unknown
				CX	unknown
				ES:DI	pointer to unknown value
			note	Can be called only from within DOS.
		02h	Get Interrupt Address
			stack	word	vector number
			return	ES:BX	pointer to interrupt vector
				stack	unchanged
		03h	Get DOS Data Segment
			return	DS	segment of IBMDOS.COM file
		04h	Normalize Path Separator
			stack	word	character to normalize
			return	AL	normalized character (forward slash
					turned to backslash)
				stack	unchanged

									-146-

		05h	Output Character
			stack	word	character to output
			return	stack	unchanged
			note	Can be called only from within DOS.
		06h	Invoke Critical Error Handler
			return	AL	0-3 for Abort, Retry, Ignore, Fail
			note	Can be called only from within DOS.
		07h	Move Disk Buffer (?)
			DS:DI	pointer to disk buffer
			return	buffer moved to end of buffer list
			note	Can be called only from within DOS.
		08h	Decrement Word
			ES:DI	pointer to word to decrement
			return	AX	new value of word
			note	Word pointed to by ES:DI decremented,
				skipping zero.
		09h	unknown
			DS:DI	pointer to disk buffer(?)
			return	(?)
			note	Can be called only from within DOS.
		0Ah	unknown
			note	Can be called only from within DOS.
		0Bh	unknown
			ES:DI	pointer to system file table entry (?)
			return	AX	(?)
			note	Can be called only from within DOS.
		0Ch	unknown
			note	Can be called only from within DOS.
		0Dh	Get Date and Time
			return	AX	current date in packed format
				DX	current time in packed format
			note	Can be called only from within DOS.
		0Eh	Do Something to All Disk Buffers (?)
			return	DS:DI	pointer to first disk buffer
			note	Can be called only from within DOS.
		0Fh	unknown
			DS:DI	pointer to (?)
			return	DS:DI pointer to (?)
			note 1) Can be called only from within DOS.
			     2) Calls on function 1207h (Move Disk Buffer).
		10h	Find Dirty Buffer
			DS:DI	pointer to first disk buffer
			return	DS:DI	pointer to first disk buffer which has
					clean flag clear
				ZF	clear	if found
					set	if not found
		11h	Normalize ASCIIZ Filename
			DS:SI	pointer to ASCIIZ filename to normalize
			ES:DI	pointer to buffer for normalized filename
			return	destination buffer filled with uppercase
				filename, with slashes turned to backslashes
		12h	Get Length of ASCIIZ String
			ES:DI	pointer to ASCIIZ string
			return	CX	length of string
		13h	Uppercase Character
			stack	word	character to convert to uppercase
			return	AL	uppercase character
				stack	unchanged
		14h	Compare FAR Pointers
			DS:SI	first pointer
			ES:DI	second pointer
			return	ZF	set if pointers are equal
				ZF	clear if not equal

									-147-

		15h	unknown
			DS:DI	pointer to disk buffer
			stack	word	(?)
			return	stack unchanged
			note	Can be called only from within DOS.
		16h	Get Address of System FCB
			BX	system file table entry number
			return	ES:DI pointer to system file table entry
		17h	Set Default Drive (?)
			stack	word	drive (0=A:, 1=B:, etc)
			return	DS:SI	pointer to drive data block for
					specified drive
				stack	unchanged
			note	Can be called only from within DOS.
		18h	Get Something Caller's Registers
			return	DS:SI	pointer to saved caller's AX, BX, CX,
					DX, SI, DI, BP, DS, ES (on stack)
			note	Only valid while within DOS.
		19h	unknown
			stack	word	drive (0=default, 1=A:, etc)
			return	(?)
				stack	unchanged
			note 1) Can be called only from within DOS.
			     2) Calls function 1217h (Set Default Drive).
		1Ah	Get File's Drive
			DS:SI	pointer to filename
			return	AL	drive
					(0=default, 1=A:, etc, 0FFh=invalid)
		1Bh	Set Something (?)
			CL	unknown
			return	AL	(?)
			note	Can be called only from within DOS.
		1Ch	Checksum Memory
			DS:SI	pointer to start of memory to checksum
			CX	number of bytes
			DX	initial checksum
			return	DX	checksum
			note 1) Can be called only from within DOS.
			     2) Used to determine when transient portion of
				COMMAND.COM has been overlaid by application.
		1Dh	unknown
		1Eh	Compare Filenames
			DS:SI	pointer to first ASCIIZ filename
			ES:DI	pointer to second ASCIIZ filename
			return	ZF	set	if filenames equivalent
					clear	if not
			note	Used by COPY command.
		1Fh	Build Drive Info Block
			stack	word	drive letter
			return	ES:DI pointer to drive info block
				      (will be overwritten by next call)
				stack unchanged
			note	Can be called only from within DOS.
		20h	Get System File Table Number
			BX	file handle
			return	CF	set on error, error code in AL
					AL	06h (invalid file handle)
				CF	clear if successful
					byte ES:[DI]	system file table entry
							number for file handle
		21h	unknown
			DS:SI	pointer to (?)
			return	(?)
			note	Can be called only from within DOS.

									-148-

		22h	unknown
			SS:SI	pointer to (?)
			return	nothing(?)
			note	Can be called only from within DOS.
		23h	Check if Character Device (?)
			return	DS:SI	pointer to device driver with
					same name as (?)
			note	Can be called only from within DOS.
		24h	Delay
			return	after delay of (?) ms
			note	Can be called only from within DOS.
		25h	Get Length of ASCIIZ String
			DS:SI	pointer to ASCIIZ string
			return	CX	length of string
		26h	unknown
			note	Can be called only from within DOS.
		27h	Get System File Table For a File	    (DOS 3.3+)
			BX	file handle
			return	AL	06h	invalid file handle
			note	Can be called only from within DOS.
		28h	unknown
			note	Can be called only from within DOS.
		29h	Get System File Table Entry For File	    (DOS 3.3+)
			BX	file handle
			return	ES:DI	pointer to system file table entry for
					file (see int 21h/52h)
			note	Can be called only from within DOS.
		2Ah	Set (something) 			    (DOS 3.3+)
			DS:SI	pointer to FAR procedure for (?)
			return	CF	set	if pointer already set
		2Bh	unknown 				    (DOS 3.3+)
			DS:SI	pointer to something
			stack	word (unknown)
			return	registers unknown
				stack	unchanged
			note	Can be called only from within DOS.
		2Ch	Get Device Chain			    (DOS 3.3+)
			return	BX:AX	pointer to header of second device
					driver (NUL is first) in driver chain
		2Dh	unknown 				    (DOS 3.3+)


Function   13h	unknown - reportedly used by DOS 3.3
entry	AH	13h
	DS:DX	pointer to (?)
	ES:BX	pointer to (?)
return	DS:DX	from previous invocation of this function
	ES:BX	from previous invocation of this function
other parameters unknown


Function   14h	NLSFUNC.COM
entry	AH	14h
	AL	00h	installation check
		return	AL	00h	not installed, OK to install
				01h	not installed, not OK
				0FFh	installed
		01h	unknown
		note	Calls int 2Fh/1227h under certain circumstances.
		02h	unknown
		note	Calls int 2Fh/1227h under certain circumstances.
		03h	unknown
		note	In DOS 3.3, appears to be identical to subfunction 01h.
other parameters unknown

									-149-

Function   15h	CD-ROM extensions
		Microsoft CD-ROM driver versions 1.0 through 2.0 will work
		only up to DOS 3.31. DOS 4.0 and up require 2.1 drivers.

entry	AH	15h	CD-ROM services
	AL	subfunctions
		00h	Get Number of CD-ROM Drives (Installation Check)
		BX	00h
		return	BX	number of CD-ROM drive letters used
				0	MSCDEX not installed
				CX	starting drive letter (0=A:, 1=B:, etc)
		note	This installation check DOES NOT follow the format used
			by other software.

		01h	Get Drive Device List
		ES:BX	pointer to buffer to hold drive letter list
			(5 bytes per drive letter)
		return	buffer filled, for each drive letter:
			byte	subunit number in driver
			dword	address of device driver header

		02h	Get Copyright File Name
		CX	drive number (0=A:)
		ES:BX	pointer to 38-byte buffer for name of copyright file
		return	CF	set if drive is not a CD-ROM drive
			AX	error code  (15h)

		03h	Get Abstract File Name
		ES:BX	pointer to 38-byte buffer for name of abstract file
		CX	drive number (0=A:)
		return	CF	set if drive is not a CD-ROM drive
			AX	error code  (15h)

		04h	Get Bibliographic Doc File Name
		CX	drive number (0=A:)
		ES:BX	pointer to 38-byte buffer for name of bibliographic
			documentation file
		return	CF	set if drive is not a CD-ROM drive
			AX	error code  (15h)

		05h	Read VTOC (Volume Table of Contents)
		CX	drive number (0=A:)
		DX	sector index (0=first volume descriptor, 1=second,...)
		ES:BX	pointer to 2048-byte buffer
		return	CF	set on error
				AX	error code (15h, 21h)
			CF	clear if successful
				AX	volume descriptor type
				       (1=standard, 0FFh=terminator, 00h=other)

		06h	Turn Debugging On
		BX	debugging function to enable
		note	Reserved for development.

		07h	Turn Debugging Off
		BX	debugging function to disable
		note	Reserved for development.

		08h	Absolute Disk Read
		CX	drive number (0=A:)
		DX	number of sectors to read
		ES:BX	pointer to buffer
		SI:DI	starting sector number
		return	CF	set on error
			AL	error code  (15h, 21h)

									-150-

		09h	Absolute Disk Write
		CX	drive number (0=A:)
		DX	number of sectors to write
		ES:BX	pointer to buffer
		SI:DI	starting sector number
		note	Corresponds to int 26h and is currently reserved and
			nonfunctional.

		0Ah	Reserved by Microsoft

		0Bh	CD-ROM 2.00 - Drive Check
		CX	drive number (0=A:)
		return	BX	0ADADh if MSCDEX.EXE installed
			AX	0	if drive not supported
				<> 0	if supported

		0Ch	CD-ROM 2.00 - Get MSCDEX.EXE Version
		return	BH	major version
			BL	minor version
		note	MSCDEX.EXE versions prior to 1.02 return BX=0.

		0Dh	CD-ROM 2.00 - Get CD-ROM Drive Letters
		ES:BX	pointer to buffer for drive letter list
			(1 byte per drive)
		return	Buffer filled with drive numbers (0=A:). Each byte
			corresponds to the drive in the same position for
			function 1501h.

		0Eh	CDROM 2.00 - Get/Set Volume Descriptor Preference
		BX	subfunction
			00h	Get Preference
			DX	00h
			return	DX	preference settings
			01h	Set Preference
			DH	volume descriptor preference
				1	primary volume descriptor
				2	supplementary volume descriptor
			DL	supplementary volume descriptor preference
				1	shift-Kanji
			CX	drive number (0=A:)
			return	CF	set on error
				AX	error code  (01h, 15h)

		0Fh	CD-ROM 2.00 - Get Directory Entry
		CX	drive number (0=A:)
		ES:BX	pointer to ASCIIZ pathname
		SI:DI	pointer to 255-byte buffer for directory entry
		return	CF	set on error
			AX	error code
			CF	clear if succesful
			AX	disk format (0=High Sierra, 1=ISO 9660)
		note	Directory entry format:
			byte	length of directory entry
			byte	length of XAR in LBN's
			dword	LBN of data, Intel (little-Indian) format
			dword	LBN of data, Motorola (big-Indian) format
			dword	length of file, Intel format
			dword	length of file, Motorola format
	       ---High Sierra---
		      6 bytes	date and time
			byte	bit flags
			byte	reserved

									-151-

	       ---ISO 9660---
		      7 bytes	data and time
			byte	bit flags
	       ---both formats---
			byte	interleave size
			byte	interleave skip factor
			word	volume set sequence number, Intel format
			word	volume set sequence number, Motorola format
			byte	length of file name
		      n bytes	file name
			byte	(optional) padding if filename is odd length
		      n bytes	system data

		Error codes:
			01h	invalid function
			15h	invalid drive
			21h	not ready


Function   43h	Microsoft Extended Memory Specification (XMS)
		The XMS version 2.00 for MS-DOS allows DOS programs to utilize
		additional memory found in 80286 and 80386 machines. With some
		restrictions, XMS adds about 64K to the 640K which DOS programs
		can access directly. XMS also provides DOS programs with a
		standard method of storing data in extended memory.
entry	AH	XMS (extended memory) services
		Perform a FAR call to the driver entry point with AH set to the
		function code
		00h	Get XMS Version Number
			return	AX	16 bit BCD version number (AX=0285h
					would be XMS version 2.85)
				BX	driver internal revision number
				DX	0000h	HMA does not exist
					0001h	HMA exists
			note 1) No error codes are returned from this function.
			     2) DX indicates the presence of HMA, not its
				availibility.
		01h	Request High Memory Area (1M to 1M + 64K)
			DX	HMA memory request in bytes (for TSR or
				device drivers)
				0FFFFh if application program
			return	AX	0000h	failure
					0001h	success
				BL	error code (80h, 81h, 90h, 91h, 92h)
		02h	Release High Memory Area
			return	AX	0000h	failure
					0001h	success
				BL     error code (80h, 81h, 90h, 93h)
		03h	Global Enable A20
			return	AX	0000h	failure
					0001h	success
				BL	error code (80h, 81h, 82h)
			note 1) Should only be used by programs which have
				control of the HMA. The A20 line should be
				turned off via Function 04h (Global Disable
				A20) before a program releases control of the
				system.
		04h	Global Disable A20
			return	AX	0000h	failure
					0001h	success
				BL	error code (80h, 82h, 94h)
			note 1) This function attempts to disable the A20 line.
				It should only be used by programs which have
				control of the HMA.
			     2) The A20 line should be disabled before a
				program releases control of the system.

									-152-

		05h	Local Enable A20
			return	AX	0000h	failure
					0001h	A20 is enabled
				BL	error code (80h, 81h, 82h)
			note 1) This function attempts to enable the A20 line.
				It should only be used by programs which need
				direct access to extended memory. Programs
				which use this function should call Function 06h
				(Local Disable A20) before releasing control of
				the system.
		06h	Local disable A20
			return	AX	0000h	failure
					0001h	success
				BL	error code (80h, 81h, 82h, 94h)
			note	This function cancels a previous call to Fn 05h
				(Local Enable A20). It should only be used by
				programs which need direct access to extended
				memory. Previous calls to Fn 05h must be
				canceled before releasing control of the system.
		07h	Query A20
			return	AX	0000h	failure
					0001h	success (A20 line is physically
						enabled)
				BL	error code (00h, 80h, 81h)
		08h	Query Free Extended Memory
			return	AX	size of largest free extended memory
					block in K
				BL	error code (80h, 81h, 0A0h)
				DX	total free extended memory in K
			note	The 64K HMA is not included in the returned
				value even if it is not in use.
		09h	Allocate Extended Memory Block
			DX	Amount of extended memory being requested in
				K-bytes
			return	AX	0000h	failure
					BL	error code (80h 81h A0h A1h)
					0001h	success
				DX	16 bit handle for memory block
		0Ah	Free Extended Memory Block
			DX	handle of block to free
			return	AX	0000h	failure
					BL	error code (80h, 81h, 0A2h,
							    0ABh)
					0001h	success
	       0Bh	Move Extended Memory Block
			DS:SI pointer to EMM structure
				4 bytes number of bytes to move
				2 bytes source handle
				4 bytes offset into source block
				2 bytes destination handle
				4 bytes offset into destination block
			return	AX	0000h	failure
					BL	error code (80h, 81h, 82h, 0A3h,
						0A4h, 0A5h, 0A6h, 0A7h, 0A8h,
						0A9h)
					0001h	success
		0Ch	Lock Extended Memory Block
			DX	XMS handle of block to lock
			return	AX	0000h	failure
					BL	error code (80h, 81h, 0A2h,
						0ACh, 0ADh)
					0001h	block is successfully locked
				DX:BX	32-bit linear address of locked block

									-153-

		0Dh	Unlock Extended Memory Block
			DX	XMS handle of block to unlock
			return	AX	0000h	failure
					BL	error code (80h, 81h, 0A2h,
						0AAh)
					0001h	success
		0Eh	Get EMB Handle Information
			DX	handle for which to get info
			return	AX	0000h	failure
					BL	error code (80h, 81h, 0A2h)
					0001h	success
					BH	block's lock count
					BL	number of free handles left
					DX	block size in K
			note	To get the block's base address, use Fn 0Ch
				(Lock Extended Memory Block).
		0Fh	Reallocate Extended Memory Block
			BX	New size for the extended memory block in K
			DX	Unlocked extended memory block handle to
				reallocate
			return	AX	0000h	failure
					BL	error code (80h, 81h, 0A0h,
						0A1h, 0A2h, 0ABh)
					0001h	success
		10h	Request Upper Memory Block (nonEMS memory above 640K)
			DX	Size of requested memory block in paragraphs
			return	AX	0000h	failure
					BL	error code (80h, 0B0h, 0B1h)
					DX	size of largest available block
						in paragraphs
					0001h	success
					BX	segment address of UMB
					DX	actual block size in paragraphs
			note 1) UMBs are paragraph aligned.
			     2) To determine the size of the largest available
				UMB, attempt to allocate one with a size of
				0FFFFh.
		11h	Release Upper Memory Block
			DX	segment address of UMB to release
			return	AX	0000h	failure
					BL	error code (80h, 0B2h)
					0001h	success

note 1) UMBs cannot occupy memory addresses that can be banked by EMS 4.0.
	EMS 4.0 takes precedence over UMBs for physically addressable memory.
     2) Programs should make sure that at least 256 bytes of stack space is
	available before calling XMS API functions.
     3) On many machines, toggling the A20 line is a relatively slow operation.
     4) Error codes:
	80h	Function not implemented
	81h	VDISK was detected
	82h	An A20 error occurred
	8Eh	A general driver error
	8Fh	Unrecoverable driver error
	90h	HMA does not exist
	91h	HMA is already in use
	92h	DX is less than the /HMAMIN= parameter
	93h	HMA is not allocated
	0A0h	All extended memory is allocated
	0A1h	All available extended memory handles are allocated
	0A2h	Invalid handle
	0A3h	Source handle is invalid
	0A4h	Source offset is invalid
	0A5h	Destination handle is invalid

									-154-

	0A6h	Destination offset is invalid
	0A7h	Length is invalid
	0A8h	Move has an invalid overlap
	0A9h	Parity error occurred
	0AAh	Block is not locked
	0ABh	Block is locked
	0ACh	Block lock count overflowed
	0ADh	Lock failed
	0B0h	Only a smaller UMB is available
	0B1h	No UMB's are available
	0B2h	UMB segment number is invalid




Function  64h	SCRNSAV2
entry	AH	64h
	AL	00h	installation check
return	AL	00h	not installed
		0FFh	installed
note	SCRNSAV2.COM is a screen blanker for PS/2s with VGA by Alan Ballard.


Function  7Ah	Novell NetWare
entry	AH	7Ah
	AL	00h	installation check
return	AL	00h	not installed
		0FFh	installed
	ES:DI	pointer to FAR entry point for routines otherwise accessed
		through int 21h
note 1) Returns address of entry point for IPX and SPX.
     2) Parameters are listed in Chapter 13.


Function  87h	APPEND
entry	AH	87h
	AL	00h	APPEND installation check
		return	AH <> 0 if installed
		01h	APPEND - unknown
		02h	APPEND - version check
return	unknown


Function  88h	Microsoft Networks
entry	AH	88h
	AL	00h	network program installation check
		return	AH <> 0 if installed
			BX	installed component flags (test in this order!)
			   bits 2	messenger
				3	redirector
				6	server
				7	receiver
				other bits not used, do not test
		01h	unknown
		02h	unknown
		03h	get current POST address
			return	ES:BX	POST address
		04h	set new POST address
			ES:BX	new POST address
		09h	network version check

									-155-

Function  89h	WHOA!		(slows system down for games)
entry	AH	89h
	AL	00h	installation check
		return	AL	00h	not installed
				0FFh	installed
		01h	uninstall
		return	AL	0FDh	successful
				0FEh	error
		02h	set delay count
		BX = delay count (larger values slow system down more)
		return	AL	0FDh	successful
				0FEh	error
note	WHOA!.COM is copyright COMPUTE! Publications and Brad Crandall.


Function  0AAh	VIDCLOCK.COM
entry	AH	0AAh
	AL	00h	installation check
return	AL	00h	not installed
		0FFh	installed
note	VIDCLOCK.COM is a memory-resident clock by Thomas G. Hanlin III.


Function  0ADh	DISPLAY.SYS and KEYB.COM			(DOS 3.3+)
entry	AH	0B0h
other parameters unknown


Function  0AEh	DOS Installable Command 			(DOS 3.3+)
entry	AH	0AEh
	AL	00h	installation check
		DX	0FFFFh
		DS:BX	pointer to command line
		return	AL	00h	execute command normally
				0FFh	command is TSR extension to COMMAND
		01h	execute installed command
		DX	0FFFFh
		DS:SI	pointer to ?
		return	DS:SI	unknown
note 1) This apparently provides a mechanism for TSRs to install permanent
	extensions to COMMAND.COM. It seems that COMMAND.COM makes this call
	before executing the current command line, and does not execute the
	command itself if the return is 0FFh.
     2) Fn 01h apparently requests execution of a previous command which a call
	to fn 01h indicated was resident.
     3) Format of command line:
	offset	size	description
	00h	byte	max length of command line?
	01h	byte	count of bytes to follow
	03h   n bytes	command line text, terminated by 0Dh


Function  0B0h	GRAFTABL.COM or DISPLAY.SYS
entry	AH	0B0h
other parameters unknown


Function  0B7h	APPEND
entry	AH	0B7h
	AL	00h	installation check
		return	AH	nonzero if installed
		11h	retrieve full ASCIIZ pathname
return	unknown

									-156-

note 1) (4.0+) The full path name can be retrieved by doing a int 2Fh fn 0B711h
	before an open (int 21h 3Dh or 6Ch). The full path is put in your
	ASCIIZ string when you do the open, so be sure it is long enough.
     2) The APPEND command apparently covers parts of int 21h/6Ch even though
	Microsoft's 4.01 User's Reference says it covers only 0Fh, 23h, 2Dh,
	11h, 4Eh & 4Bh, some of those do require special switches. For 6Ch, it
	may be a function of the DX register. If DX=xx1x it looks only in the
	current directory, if DX=xx0x it will search the full append path. DX
	is called the open flag and gives what action to take if the file exits
	or does not exist.


Function  0B8h	Network
entry	AH	0B8h
	AL	00h	installation check
		return	AH	00h	not installed
				nonzero installed
			BX	installed component flags (test in this order)
			   bits 2	messenger
				3	redirector
				6	server
				7	receiver
(LANtastic)	return	AL	00h	neither redirector or server installed
				0FFh	redirector or server installed
			BL	bits indicating which software is installed
			       (both will be set when both software is running)
				01000000b	server is installed
				00001000b	redirector is installed
		01h	unknown
		02h	unknown
		03h	get current POST address
		return	ES:BX	POST address
		04h	set new POST address
			ES:BX	new POST address
		05h	unknown
		06h	unknown
		07h	unknown
		08h	unknown
		09h	version check (note 1)
other parameters unknown
note 1) for Lantastic LANOS:
	return	AH	major version number
		AL	minor version number
	The version numbers are returned as decimal numbers. For example,
	version 2.52 would be:
		AH	2
		AL	52 decimal or 34 hex


Function  0BBh	Network Functions
entry	AH	0BBh
	AL	00h	net command installation check
		01h, 02h unknown
		03h	get server POST address
		04h	set server POST address


Function  0BFh	REDIRIFS.EXE
entry	AH	0BFh
other parameters unknown

									-157-

Function 0D44Dh 4DOS Command Interpreter  (COMMAND.COM replacement)
entry	AX	0D44Dh	4DOS installation check
	BX	00h
return	If 4DOS is present in memory the following values will be returned:
	AX	44DDh
	BH	minor 4DOS version number
	BL	major 4DOS version number
		(same format as DOS int 21h/fn 30)
	CX	4DOS PSP segment address
	DL	4DOS shell number (0 for the first shell, 1 for the second,
		etc.; incremented each time a new copy of 4DOS is loaded over a
		root copy, either in a different multitasker window or via
		nested shells)
note 1) If you issue this call with BX <> 0 you will invoke some other function
	of 4DOS's low-memory server, and probably hang the system.
     2) This function is available in swapping mode ONLY. Also note that this
	tells you if 4DOS is loaded in memory somewhere - but not whether it is
	the parent process of your program. For example if there is a root 4DOS
	shell and a secondary copy of COMMAND.COM this function will still work.
	However you can determine if 4DOS is your parent process by comparing
	the value returned in the CX register with the PSP chain pointer at
	location 16 in your own PSP.


Function  0E3h	AnarKey    (keyboard command stack and alias program)
entry	AH	0E3h
	AL	00h	installation check
return	AL	00h	not installed
		0FFh	installed
notes  0E3h is the default function number, but can be set to any value from
       0C0h to 0FFh.


Function  0F7h	AUTOPARK.COM  (PD TSR hard disk parking utility)
entry	AH	0F7h
	AL	00h	installation check
		return	AL	00h	not installed
				0FFh	installed
	01h	set parking delay
		BX:CX	32 bit count of 55ms timer ticks
note	AUTOPARK is a TSR HD parker by Alan D. Jones.


Function	Intel Communicating Applications Standard (CAS 1.01A)
entry	AH		(default; CAS multiplex number can be user-adjusted)
	AL	00h	Get Installed State
			return	AL	00h	not installed
					01h	not installed, not OK to install
					0FFh	installed
			note	No errors are returned.
		01h	Submit a Task
			DS:DX	ptr to ASCIIZ path and name of Task Control File
			return	AX	positive event handle or neg. error code
			note	Files associated with a task must stay in
				existence until the task is complete or an
				error will result.
		02h	Abort the Current Event
			return	AX	event handle of aborted event or
					negative error code
			note	Terminating an event is not instantaneous. It
				might take up to 30 seconds.
		03h	reserved
		04h	reserved

									-158-
		05h	Find First Entry in Queue
			CX	Status of the event you are seeking. This value
				is compared with the field at offset 2 of the
				Control File
				0 - event has successfully completed
				1 - event is waiting to be processed
				2 - number has been dialed
				3 - connection has been made (sending)
				4 - connection has been made (receiving)
				5 - event was aborted
			       -1 - chooses an event without regard to status
				    This value will probably be used most often
				Other negative values match error codes in
				Control File.
			DH	direction:
				0 - Search forward chronologically (from the
				    first to the last occurring event)
				1 - Search backward chronologically (from the
				    last to the first occurring event)
			DL	queue to search:
				0 - Find first control file in Task Queue
				1 - Find first control file in Receive Queue
				2 - Find first control file in Log Queue
			return	AX	0, if successful, or negative error code
				BX	event handle for this file
		06h	Find Next Entry in Queue
			DL	queue to search:
				0 - Find next control file in Task Queue
				1 - Find next control file in Receive Queue
				2 - Find next control file in Log Queue
			return	AX	0, if successful, or negative error code
				BX	event handle for this file
		07h	Open a File
			BX	event handle
			CX	receive file number
				0 - the Receive Control File
				1 - first received file
				2 - second received file
				3 - third received file
				n - nth received file
			DL	queue:
				0 - open control file in Task Queue
				1 - open control file in Receive Queue or the
				    received data
		 file specified in the CX register.
				2 - Open control file in Log Queue.
			return	AX	0 if successful, or negative error code
				BX	DOS file handle for the requested file
		08h	Delete a File
			BX	event handle
			CX	receive file number
				0 - delete all files associated with a specific
				    Receive Control File (including the RCF)
				1 - delete first received file associated with
				    the event handle
				2 - delete the second received file associated
				    with the event handle.
				n - delete the nth received file associated with
				    the event handle
			DL	queue:
				0 - delete control file in Task Queue
				1 - delete a file or files associated with an
				    event in the Receive Queue.
				2 - delete control file in Log Queue
				    note   It is strongly recommended that this
				    function NOT be used to delete individual
				    Log Control Files to maintain the integrity
				    of the log.

									-159-

			return	AX	0 if successful, or negative error code
		09h	Delete All Files (in a queue)
			DL	queue:
				0 - delete all control files in the Task Queue
				1 - delete all control files in the Receive
				    Queue and all received files
				2 - delete all control files in the Log Queue
			return	AX	0 if successful or negative error code
		0Ah	Get Event Date
			BX	event handle of event whose date you want to get
			DL	queue:
				0 - task queue
				1 - receive queue
				2 - log queue
			return	AX	0 if successful or negative error code
				CX	year  (1980-2099)
				DH	month (1-12)
				DL	day   (1-31)
		0Bh	Set Task Date
			BX	event handle
			CX	year  (1980-2099)
			DH	month (1-12)
			DL	day   (1-31)
			return	AX	0 if successful or negative error code
		0CH	Get Event Time
			BX	event handle
			DL	queue:
				0 - task queue
				1 - receive queue
				2 - log queue
			return	AX	0 if successful or negative error code
				CH	hour	(0-23)
				CL	minutes (0-59)
				DH	seconds (0-59)
				DL	0
		0DH	Set Task Time
			BX	event handle
			CH	hour	(0-23)
			CL	minutes (0-59)
			DH	seconds (0-59)
			DL	unused
			return	AX	0 if successful or negative error code
		0EH	Get External Data Block
			DS:DX points to a 256-byte EDB area
			return	AX	0 if successful or negative error code
			note	EDB area is filled with the External Data Block
				block format: (values in decimal)
			      Offset Length	   Description
				 0    1    CAS major version number
				 1    1    CAS minor version number
				 2    68   ASCIIZ path to directory containing
					   Resident Manager and CAS software.
					   The path must end with a backslash
				 70   13   ASCIIZ name of current phonebook
					   (the CAS subdirectory is assumed)
				 83   13   AZCIIZ name of current logo file
					   (the CAS subdirectory is assumed)
				 96   32   ASCIIZ default sender name
				 128  21   ASCIIZ CSID (CCITT fax device ID)
				 149  107  Reserved

									-160-

		0Fh	Get/Set Autoreceive State
			DL	function code:
				0 - get current autoreceive state
				1 - set current state to value in DH
				DH	# rings before answer or 0 to disable
			return	AX	current state or negative error code
					0 - Autoreceive disabled
					positive # - # rings before hdw answers
		10h	Get Current Event Status
			DS:DX	pointer to a 444 byte status area
			return	AX	0 if successful or negative error code
				BX	number of the current event (AX=0)
		11h	Get Queue Status
			DL	queue:
				0 - find status of Task Queue
				1 - find status of Receive Queue
				2 - find status of Log Queue
			return	AX	# changes to queue since Resident
					Manager started or negative error code
					If changes exceeds 7FFFH, the count
					begins again at 0.
				BX	current # of Control Files in queue
				CX	current # of received files
		12h	Get Hardware Status
			DS:DX	pointer to a 128-byte status area
			return	AX	0 if successful, negative if not
			DS:DX	pointer to filled 128-byte status area
		13h	Run Diagnostics
			DL	Mode
				0 - report progress of diagnostics
				1 - start running diagnostics
			return	if DL=1, AX=0 or a negative error code.
				if DL=0, AX=40h or positive number indicating
					 diagnostics passed. A negative value
					 indicates failure and containes the
					 error code
		14h	Move Received File
			BX	event handle
			CX	receive file number
				(must be nonzero to specify a received file)
				1 - first received file
				2 - second received file
				3 - third received file
				n - nth received file
			DS:DX	pointer to new ASCIIZ pathname and filename.
				This file must not exist already
			return	AX	0 if successful or negative error code
			note	The path to the new directory must exist.
				This function cannot create directories.
		15h	Submit a Single File to Send
			DS:DX	pointer to variable-length data area
			return	AX	positive event handle or neg. error code
			note 1) variable-length data area format:
			     Offset Length    Description
				0    1	  Transfer type:
					  0 - 200x200 dpi, facsimile mode
					  1 - 100x200 dpi, facsimile mode
					  2 - file transfer mode
					  3-127 - Reserved.
				1    1	  Text size (if ASCII file, fax mode)
					  0 - 80-column
					  1 - 132-column
					  2-127 - reserved
				2    2	  time to send, in DOS file time format

									-161-

				4    2	  date to send, in DOS file time format
					  note: Setting both the time and date
					  fields to 0 schedules the file to be
					  sent immediately
				6    32   ASCIIZ Destination Name  (To: field)
				38   80   ASCIIZ pathname of the file to send
				118  47   ASCIIZ phone number to call
				165  64   ASCIIZ application-specific tag field
				229  1	  reserved; set to zero
				230  1	  cover page flag:
					  0 - don't send cover page
					  1 - send cover page
					  2-127 - Reserved
				231  23   reserved; set to zero
				254  var  ASCIIZ cover text (if offset 230=1)
			     2) The individual fields have the same meaning as
				in a Task Control File
			     3) You must set all fields, except for the Appli-
				cation-Specific Tag field, before calling this
				function. However, you can set the Destination
				Name and Cover Text fields to an empty string
		16h-80h Reserved by Intel for future expansion



DOS 2Fh functions 01h (PRINT), 02h (ASSIGN), 10h (SHARE):
return	AX	Error
		Codes	    Description
		01h	invalid function number
		02h	file not found
		03h	path not found
		04h	too many open files
		05h	access denied
		06h	invalid handle
		08h	queue full
		09h	busy
		0Ch	name too long
		0Fh	invalid drive was specified
	CF	clear (0) if OK
		set   (1) if error - error returned in AX
note 1) The multiplex numbers AH=0h through AH=7Fh are reserved for DOS.
	Applications should use multiplex numbers 80h through 0FFh.
     2) When in the chain for int 2Fh, if your code calls DOS or if you execute
	with interrupts enabled, your code must be reentrant/recursive.
     3) Important! In versions of DOS prior to 3.0, the int 2Fh vector was
	initialized to zero rather than being pointed into the DOS service area.
	You must initialize this vector manually under DOS 2.x.

									-162-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³ Miscellaneous Interrupts - in numeric order				      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 30h	 FAR jump instruction for CP/M-style calls ............. 5**15³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note	The CALL 5 entry point does a FAR jump to here	(not a vector!)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 31h	 Unknown ............................................... 5**16³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 32h	 Unknown ............................................... 5**17³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 33h	 Used by Microsoft Mouse Driver Function Calls ......... 5**18³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		See Chapter 14.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 34h	 Turbo C/Microsoft languages - Floating Point emulation  5**19³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0D8h


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 35h	 Turbo C/Microsoft languages - Floating Point emulation  5**20³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0D9h


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 36h	 Turbo C/Microsoft languages - Floating Point emulation  5**21³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DAh

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 37h	 Turbo C/Microsoft languages - Floating Point emulation  5**22³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DBh

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 38h	 Turbo C/Microsoft languages - Floating Point emulation  5**23³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DCh

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 39h	 Turbo C/Microsoft languages - Floating Point emulation  5**24³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DDh

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Ah	 Turbo C/Microsoft languages - Floating Point emulation  5**25³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DEh

									-163-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Bh	 Turbo C/Microsoft languages - Floating Point emulation  5**26³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates opcode 0DFh

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Ch	 Turbo C/Microsoft languages - Floating Point emulation  5**27³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates instructions with an ES segment
		override.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Dh	 Turbo C/Microsoft languages - Floating Point emulation  5**28³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		This interrupt emulates a standalone FWAIT instruction

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Eh	 Turbo C/Microsoft languages - Floating Point emulation  5**29³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Unknown

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 3Fh	 Overlay Manager Interrupt (Microsoft LINK.EXE) ........ 5**30³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Default overlay interrupt; may be changed with LINK command
		line switch.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 40h	 Hard Disk BIOS ........................................ 5**31³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Pointer to disk BIOS entry when a hard disk controller is
		installed. The BIOS routines use int 30h to revector the
		diskette handler (original int 13h) here so int 40 may be used
		for hard disk control.
	note 1) Keyboard interrupt for DEC Rainbow.

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 41h	 Hard Disk Parameters .................................. 5**32³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Pointer to first Hard Disk Parameter Block, normally located
		in the controller card's ROM. This table may be copied to RAM
		and changed, and this pointer revectored to the new table.
note 1) XT, AT,XT/2, XT/286, PS/2 except ESDI disks
     2) format of parameter table is:
	word	cylinders
	byte	heads
	word	starting reduced write current cylinder (XT only, 0 for others)
	word	starting write pre-comp cylinder
	byte	maximum ECC burst length
	byte	control byte
	   bits 0-2	drive option (XT only, 0 for others)
		3	set if more than 8 heads
		4	always 0
		5	set if manufacturer's defect map on max cylinder+1
		6	disable ECC retries
		7	disable access retries
	byte	standard timeout (XT only, 0 for others)
	byte	formatting timeout (XT only, 0 for others)
	byte	timeout for checking drive (XT only, 0 for others)
	word	landing zone	(AT, PS/2)
	byte	sectors/track	(AT, PS/2)
	byte	0  (zeroes)
     3) normally vectored to ROM table when system is initialized.

									-164-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 42h	 Pointer to screen BIOS entry .......................... 5**33³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		EGA, VGA, PS/2
		Relocated (by EGA, etc.) video handler (original int 10h).
		Revectors int 10 (BIOS video) calls to EGA BIOS.
		Also used by Zenith Z-100.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 43h	 Pointer to EGA Graphics Character Table ............... 5**34³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		The POST initializes this vector pointing to the default table
		located in the EGA ROM BIOS. (PC-2 and up). Not initialized if
		EGA not present.
		 This vector was referred to (mistakenly) as the Video
		Parameters table in the original EGA BIOS listings.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 44h	 Pointer to graphics character table ................... 5**35³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0110h)	This table contains the dot patterns for the first 128
		characters in video modes 4,5, and 6, and all 256 characters
		in all additional graphics modes. Not initialized if EGA not
		present.
note 1) EGA/VGA/CONV/PS - EGA/PCjr fonts, characters 00h to 7Fh.
     2) Novell NetWare - High-Level Language API.
     3) This interrupt is not used by some EGA cards.
     4) Also used by Zenith Z-100.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 45h	 Reserved by IBM  (not initialized) .................... 5**36³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		also used by Zenith Z-100


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 46h	 Pointer to second hard disk parameter block ........... 5**37³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AT, XT/286, PS/2
		(see int 41h) (except ESDI hard disks) (not initialized unless
		specific user software calls for it)
		also used by Zenith Z-100


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 47h	 Reserved by IBM  (not initialized) .................... 5**38³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 48h	 Cordless Keyboard Translation ......................... 5**39³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0120h)	This vector points to code to translate the cordless keyboard
		scancodes into normal 83-key values. The translated scancodes
		are then passed to int 9. (not initialized on PC or AT)
		(PCjr, XT [never delivered])

									-165-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 49h	 Non-keyboard Scan Code Translation Table Address (PCjr) 5**40³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
(0:0124h)	PCjr translate table, TI Pro video

	    1)	This interrupt is used for operation of non-keyboard devices
		on the PCjr, such as the Keytronic Numeric Keypad.
		This interrupt has the address of a table used to translate
		non-keyboard scancodes (greater than 85 excepting 255). This
		interrupt can be revectored by a user application. IBM
		recommends that the default table be stored at the beginning
		of an application that required revectoring this interrupt,
		and that the default table be restored when the application
		terminates. (not initialized on PC or AT)

		The PCjr BIOS can interpret scancodes other than those
		generated by the keyboard to allow for expansion. The keyboard
		generates scancodes from 01h to 055h, including 0FFh. Any
		scancodes above 55h (56h through 7Eh for make codes and 0D6h
		through 0FEh for break codes) are processed in the following
		manner:
		1) if the incoming make code falls within the range of the
		   translate table whose address is pointed to by int 49h, it
		   is translated into the corresponding scancode. Any incoming
		   break codes above 0D5h are ignored.
		2) if the new translated scancode is less than 56h, it is
		   processed by the BIOS as a keyboard scancode and the same
		   data is placed in the BIOS keyboard buffer.
		3) if the translated scancode is higher than 55h or the
		   incoming scancode is outside the range of the translate
		   table, 40h is added creating a new extended scancode. The
		   extended scancode is placed in the BIOS keyboard buffer with
		   the character code of 00h (NUL). This utilitizes the range
		   of 96h through 0BEh for scancodes 56h through 7Eh.

		The default translate-table maps scancodes 56h through 6Ah to
		existing keyboard values. Codes 6Bh theough 0BEh are mapped (by
		adding 40h) to extended codes 0ABh through 0FEh since they are
		outside the range of the default translate table.

		The format of the translate table is:
		0	length - the number of nonkeyboard scancodes that are
			mapped within the table (from 1 to n).
		1 to n	word  high byte 00h (NUL) byte scancode with low order
			byte representing the scancode mapped values relative
			to their input values within the range of 56h through
			7Eh.

		With this layout, all keyboard scancodes can be intercepted
		through int 9h and and nonkeyboard scancodes can be intercepted
		through int 48h.

	    2)	On the TI Professional, this interrupt is used for some video
		services.
		entry	AH	17h	Get Display Offset
		return	ES:DI	segment/offset of current display buffer
		note	The TI Pro has only 2048 bytes of character RAM, but it
			is followed by another 2048 bytes of "phantom" RAM
			(i.e. the same 2048 bytes are available at two
			different addresses) so that wraparound checks need not
			be made when writing to the screen. The attribute RAM
			is "shadowed" behind the character RAM through the
			attribute register.

									-166-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Ah	 Real-Time Clock Alarm (Convertible, PS/2) ............. 5**41³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		(not initialized on PC or AT)
		Invoked by BIOS when real-time clock alarm occurs.
		Used by TI Professional PC for keyboard DSR interface
		  (keyboard BIOS interrupt)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Bh	 Reserved by IBM  (not initialized) .................... 5**42³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Ch	 Reserved by IBM  (not initialized) .................... 5**43³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Dh	 Reserved by IBM  (not initialized) .................... 5**44³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Eh	 Reserved by IBM  (not initialized) .................... 5**45³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Used instead of int 13h for disk I/O on TI Professional PC


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 4Fh	 Reserved by IBM  (not initialized) .................... 5**46³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 50-57 IRQ0-IRQ7 Relocation .................................. 5**47³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IRQ0-IRQ7 relocated by DesQview
		(normally not initialized)
		IRQ0-IRQ7 relocated by IBM 3278 Emulation Control Program


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 58h	 Reserved by IBM  (not initialized) .................... 5**48³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 59h	 Reserved by IBM  (not initialized) .................... 5**49³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	GSS Computer Graphics Interface (GSS*CGI)
entry	DS:DX	Pointer to block of 5 array pointers
return	CF	0
	AX	return code
	CF	1
	AX	error code
note 1) Int 59h is the means by which GSS*CGI language bindings communicate
	with GSS*CGI device drivers and the GSS*CGI device driver controller.
     2) Also used by the IBM Graphic Development Toolkit.

									-167-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ah	 Reserved by IBM  (not initialized)  ................... 5**50³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		IBM Cluster Adapter BIOS entry address


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Bh	 Reserved by IBM  (not initialized) .................... 5**51³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Used by IBM Cluster Adapter


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ah	 Cluster Adapter BIOS entry address .................... 5**52³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		(normally not initialized)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Bh	 Reserved by IBM  (not initialized) .................... 5**53³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Used by cluster adapter?


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Ch	 NETBIOS interface entry port, TOPS .................... 5**54³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		See Chapter 13 for information on network programming.
	note 1) The Texas Instruments Professional PC (Ti Pro) uses 5Ch for
		the Pause key on the keyboard. The TI BIOS allows any user
		routine to execute from the Pause interrupt as long as it
		eventually returns.
	     2) Used by Windows/386 by Virtual Machine routines.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Dh	 Reserved by IBM  (not initialized) .................... 5**55³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	note 1) The Texas Instruments Professional PC (Ti Pro) uses 5Ch for
		the keyboard services.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Eh	 Reserved by IBM  (not initialized) .................... 5**56³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	note 1) TI Professional PC - Program Break.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 5Fh	 Reserved by IBM  (not initialized) .................... 5**57³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	note 1) TI Professional PC - Keyboard queueing.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 60h-67h  User Program Interrupts ............................ 5**58³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		   (available for general use)
		   Various major programs make standardized use of this group
		   of interrupts. Details of common use follows:

									-168-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 60h	 Network OS Interface					      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      1) Used by 10-Net network.
	      2) Used by FTP Driver - PC/TCP Packet Driver Specification
	      3) See Chapter 13 for network programming calls.
	      4) Used by TOPS netork (TTALK.EXE).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 67h	 Expanded Memory Board Driver Interrupt 		      ³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      1) Used by Lotus-Intel-Microsoft Expanded Memory Specification
		 3.1 and higher. (EMS and LIM)
	      2) Used by Ashton-Tate/Quadram/AST Enhanced Expanded Memory
		 Specification 3.1 and higher. (EEMS)
	      3) Used by Phar Lap/Quarterdeck VCPI v1.0.
	      4) See Chapter 10 for EMS/EEMS programming information.
	      5) The Advance Digital PC Slave board (also marketed by Alloy)
		 contains its own 8mHz 8086, up to 768K of on-card memory and
		 a built-in monochrome monitor adapter, communicating with an
		 RS232 terminal 19.2KBaud. Their operating system is an
		 adaptation of MSDOS 2.11 called RTNX or ATNX. ?TNX uses
		 interrupt 67h for record locking, using an "interrupt 67h
		 semaphore" system in which a data record access must be
		 preceded by a call to int 67h with a string that contains a
		 filename and a record number to lock.
	      6) Some Adaptec hard disk controllers have problems related to
		 their use of int 67h. Supposedly the Adaptec can be made to
		 use a driver instead of ROM. The driver is generated by
		 running the ROM program at C800:5 and this fixes the problem.
		 Apparently this driver is called ADAPTEC.DRV. Check with
		 Adaptec if you suspect a problem.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 68h	 Not Used  (not initialized) ........................... 5**59³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		APPC/PC Network Interface. See Chapter 13.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 69h	 Not Used  (not initialized) ........................... 5**60³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Ah	 Not Used  (not initialized) ........................... 5**61³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Bh	 Not Used  (not initialized) ........................... 5**62³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Ch	 System Resume Vector (Convertible) .................... 5**63³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		(not initialized on PC)
		DOS 3.2 Realtime Clock update

									-169-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Dh	 Not Used  (not initialized) ........................... 5**64³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Paradise VGA - internal usage


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Eh	 Not Used  (not initialized) ........................... 5**65³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 6Fh	 10-Net API............................................. 5**66³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		 See Chapter 13.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 70h	 IRQ 8, Real Time Clock Interrupt (AT, XT/286, PS/2) ... 5**67³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

	 This interrupt services the real-time clock hardware.	The hardware
	 supports 2 modes of operation, an interrupt at a specific 24 hour
	 interval (i.e 9:42 am), or repeatedly every 0.976 ms (1,024 kHz).
	 Both modes can operate at the same time if needed.

	 In the 24 hour alarm mode, the interrupt is vectored here by hardware
	 and interrupt 4Ah is called to alert the application program of the
	 alarm.  Int 4Ah is not handled by the BIOS other than to return, and
	 is normally revectored by a particular application using the alarm.

	 When repeating interrupt mode is active, the 32-bit microsecond
	 counter consisting of timer_clk_low and timer_clk_hi is decremented
	 by 976 us on every interrupt.	When the timer reaches zero, the
	 byte pointed to by the offset @timer_wait_off and and segment
	 @timer_wait_seg is set to 80h (this pointer is set by an application
	 program through int 1Ah function ah=6).



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 71h	 IRQ 9, Redirected to IRQ 8 (AT, XT/286, PS/2) ......... 5**68³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		LAN Adapter 1 (rerouted to int 0Ah [IRQ2] by BIOS)



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 72h	 IRQ 10  (AT, XT/286, PS/2)  Reserved .................. 5**69³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       Hardware servicer (called by hardware 8259-2, IRQ 10).



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 73h	 IRQ 11  (AT, XT/286, PS/2)  Reserved .................. 5**70³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       Hardware servicer (called by hardware 8259-2, IRQ 11).


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 74h	 IRQ 12  Mouse Interrupt (PS/2) ........................ 5**71³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	       Hardware servicer (called by hardware 8259-2, IRQ 12).

									-170-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 75h	 IRQ 13, Coprocessor Error (AT) ........................ 5**72³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		BIOS redirects math coprocessor errors to int 2 (NMI).

		The math co-processor 80287 invokes this interrupt. Int 75h
		calls the non-maskable interrupt int 2 to halt the system
		(80287 is not used if this vector is left pointing here).
		Programs which use the 80287 must re-vector this interrupt to
		use the 80287.



ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 76h	 IRQ 14, Hard Disk Controller (AT, XT/286, PS/2) ....... 5**73³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		(called by hardware 8259-2 IRQ 14)
	       When the hard disk controller has completed its task, it signals
	       completion though hardware activation of int 76h. The status in
	       hdsk_int_flags is set to "done", a value of 0FFh. Int 15/fn91h
	       may also be called to signal the interrupt is done.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 77h	 IRQ 15 (AT, XT/286, PS/2)  Reserved ................... 5**74³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Future servicer (called by hardware 8259-2 IRQ 15)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 78h	 Not Used .............................................. 5**75³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 79h	 Not Used .............................................. 5**76³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Ah	 Reserved .............................................. 5**77³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	      1) Novell NetWare - Low-Level API.
	      2) AutoCAD Device Interface.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Bh-7Eh  Not Used by IBM .................................... 5**78³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

									-171-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Ch	 REXX-PC API ........................................... 5**79³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	IBM REXX-PC macro language
entry	AX	0000h	Initialize
	DS:SI	pointer to null terminated name of program to be executed
	EB:BX	pointer to null terminated argument string to be passed to the
		program
	DX:DI	pointer to an environment control block in the format:
		dword	offset in segment to signature string
			The segment is that contained in DX and the signature
			is the uppercase ASCIIZ string "REXX".
		dword	offset in DX to environment name ASCIIZ string
			note: The environment name will be truncated if longer
			      than 32 characters.
		dword	offset in DX to the file extension ASCIIZ string
		dword	path search - word value of 0 or non-zero.
			This controls the searching of the path for commands
			that might be REXX programs. 0 means no search made,
			non-zero means search first.
		dword	x'AAAA'
			This is a signature that allows REXXPC88 to call your
			own defined routine when a command expression needs
			to be processed.
		DD	Segment:offset (standard INTEL format) of environment
			work buffer, the first double word of the buffer MUST
			be the entry point address of the environment service
			routine to be called.  The rest of the buffer may be
			used in any way you choose and will NOT be examined or
			modified by REXXPC88.
return	none
note 1) The only way to tell if the program exists and can be executed is by
	examining a value returned by the program in the next call described
	below. If the program returns an end of program indication and a string
	was expected instead, it means that the program was not found or could
	not be executed for some reason.
     2) All registers except SS and SP are destroyed. The caller must save any
	other registers of interest.


Function 01h Interpret REXX Command
	This call tells REXXPC88 to interpret the REXXPC88 program until a
	value is produced.
entry	AX	0001h
return	DS:DX	points to a result string, terminated by a CR + LF + NULL. The
		final result string (which marks the end of the program)
		consists of nothing but EOF + NULL. REXXPC88 will continue to
		return this "end of program" string until reinitialized via an
		AX=01h call as described above.
note	All registers except SS and SP are destroyed. The caller must save any
	other registers of interest.


Function 02h  Termination
	This call allows resident REXXPC88 extensions to terminate execution of
	a REXXPC88 program, typically after detecting an error.
entry	AX	0002h
	DS:SI	points to null terminated string to be displayed as an error
		message before terminating the REXXPC88 program.
return	none
note	Terminates the REXXPC88 program and returns control to DOS.

									-172-

Function 03h  Load
	This call tells REXXPC88 to look up a program variable and return its
	current value (if any).
entry	AX	0003h
	DS:SI	points to null terminated name of REXXPC88 program variable.
	DS:DX	points to the null terminated string value of the program
		variable. DX is zero if the program variable is currently
		undefined. This string is in REXXPC88's data area and must be
		treated as read-only.
return	none
note 1) All registers except SS and SP are destroyed. The caller must save any
	other registers of interest.


Function 04h  Store
	This call tells REXXPC88 to store a null terminated string as the value
	of a program variable.
entry	AX	0004h
	DS:SI	points to null terminated name of REXXPC88 program variable
	ES:BX	points to null terminated string to be assigned to the variable
return	none
note 1) The string is copied into REXXPC88's data dictionary. If there is
	insufficient storage to store the string, REXXPC88 terminates execution
	of the program with an error message and returns to DOS.
     2) Registers: all registers except SS and SP are destroyed. The caller
	must save any other registers of interest.


Function 05h  User-Written Extensions
entry	AX	 0005h
	SS:BP	 points to a C stack frame containing a two-byte pointer to the
		 null terminated function name, a two-byte integer specifying
		 the number of arguments, and a two-byte pointer to an array
		 of pointers (each two bytes) to the arguments (each argument
		 is a null terminated string).
return	DS:SI	 must point to a null terminated result string. A pointer of
		 NIL (DS = 0, SI = 0) is reserved by REXXPC88 and indicates
		 that "no REXXPC88 extensions answered the function".
note 1) Registers: all registers except SS, SP, and BP are available for use.
     2) Stack: Since the amount of REXXPC88 stack space remaining for growth
	can't be ascertained by the user extension program, the user may wish
	to switch to a local stack if he requires more than about 128 bytes of
	stack growth.


Function 06h Queue
	This call tells REXXPC88 to place data on the data or external interrupt
	queue either FIFO or LIFO.
entry	AX	06h
	BH	00h	Internal data queue accessible via PULL and PARSE PULL
		01h	External interrupt queue accessible via LINEIN(EXQUE)
	BL	00h	Queue data FIFO on selected queue
		01h	Queue data LIFO on selected queue
	DS:SI	points to null terminated string to be queued.
return	AX	0000h	Message queued successfully.
		0001h	No REXXPC88 program running at current time. Message
			not queued.
		0002h	Not enough storage available for message.  Message not
			queued.
		0003h	Either BH (queue number) or BL (FIFO/LIFO flag) out of
			range. Message not queued.
note 1) For the Internal data queue a string may not exceed 127 characters.
     2) For the External int. queue a string may not exceed available storage.
     3) Registers: all registers except SS and SP are destroyed. The caller
	must save any other registers of interest.

									-173-


Function 07h  Check for Loaded Extension
	This call provides a way for a REXXPC88 extension to find out if a copy
	is already loaded, and to exchange information with a resident version.
entry	AX	0007h
	SS:BP	points to a C stack frame containing a two-byte pointer to the
		null terminated name of the REXXPC88 extension.
return	If the extension is already loaded, then DS:SI points to an ASCIIZ
	string '1', and other registers are used as desired by the extension
	to communicate with its non-resident copy. (Generally, this involves
	pointing ES:BX to the resident portion's entry point). If the extension
	is not yet resident, then DS:SI points to an ASCIIZ '0'.
note	Registers: all registers except SS, SP and BP are available for use.


Function 08h Reserved
	This call is reserved for communication between REXXSYS.SYS and
	REXXIBMR.
entry	AX	0008h
return	none


Function 09h Check for REXX Installed
	This call provides external applications a way to determine if REXXIBMR
	is installed.
entry	AX	09h
return	AX	0FFFFh	REXXIBMR is not installed
	AX	0AAAAh	REXXIBMR is installed
note	It is assumed that your application will inspect the value of the 7Ch
	interrupt vector prior to issuing this interrupt. If the vector is
	0000:0000 then REXXIBMR is not installed and this function will cause
	the system to crash.


Function 0Ah  Uninstall resident version of REXX
	This call is used to uninstall a resident version
entry	AX	000Ah
	BX	0AAAAh
return	AX	0000h	Resident version uninstalled
		0001h	Resident version cannot uninstall, as one interrupt
			vector has been modified by some other program in a
			non-conforming manner.
		0FFFFh	The installed resident version does NOT support the
			uninstall request code (i.e., it is pre 0.55 level).

									-174-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 7Fh	 IBM 8514/A Graphics Adapter API ....................... 5**80³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	    1)	59 API functions availible, parameters unknown.
	    2)	Used by second copy of COMMAND set with SHELL=.
	    3)	Not used by COMMAND /C at DOS prompt.
	    4)	The IBM RTIC (Real Time Interface Coprocessor) Multiport (and
		Multiport/2) use int 7Fh as a method of communication between
		the system-unit resident interrupt handler and the RTIC card's
		operating system. There is a convention for using it in which
		register AX contains the signature of the handler that should
		handle the interrupt. Some signatures are:
		    AX = 0200h is a call to the current task dispatcher
			       (from the BTRIEVE application interface).
		    AX = 0101h is a call from an application to the RTIC
			       function request mechanism.
		    AX = 0FEEDh is a call from the ICAINTH.SYS interrupt
			       handler.
	    5) AX = 200h is used to invoke the task dispatcher in the multi-
	       tasking DOS shell MultiLink Advanced.
	    6) There have been mentions of assorted other little-known
	       programs using this interrupt. In view of its use by DOS and
	       the increasingly-popular 8514/A adapter, it would probably be
	       wise to avoid int 7Fh for aftermarket application software.
	    7) Also used by HLLAPI.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 80h-85h  Reserved by BASIC .................................. 5**81³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note	Interrupts 80h through 0ECh are apparently unused and not initialized
	in most clone systems. Not known if GWBASIC or MBASIC use any of these
	interrupts.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 86h	 Int 18 when relocated by NETBIOS ...................... 5**82³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 86h-0F0h  Used by BASIC when BASIC interpreter is running ... 5**83³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0A4h  Right Hand Man API .................................... 5**84³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry	AH	RHM function  (unknown)
return	unknown
note	Right-Hand Man is a shareware TSR desktop utility similar to SideKick.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E0h Digital Research CP/M-86 function calls ............... 5**85³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note	Lotus 123 Release 2 reportedly alters the int 0E0h vector during
	operation and leaves it pointing somewhere in the TPA on exit.
	Perhaps used by the mysterious Lotus add-on program hook?


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E1h PC Cluster Disk Server Information .................... 5**86³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note	This is a pointer to a data table.

									-175-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt  0E2h PC Cluster Program .................................... 5**87³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
note	Interrupt 1Ch is revectored to here.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0E4h  Logitech Modula-2 v2.0   Monitor Entry ................ 5**88³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry	AX	05h	monitor entry
		06h	monitor exit
	BX	priority
return	unknown


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0EFh  GEM interface (Digital Research) ...................... 5**89³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
entry	CX	0473h
	DS:DX	pointer to GEM parameter block
note	no other parameters are known


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F0h  unknown ............................................... 5**90³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
	     1) Used by secondary copy of COMMAND when SHELL= set.
	     2)  Not used by COMMAND /C at DOS prompt.
	     3)  Used by BASIC while in interpreter.


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupts 0F1h-0FFh  (absolute addresses 3C4h-3FFh) .................. 5**91³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		      Location of Interprocess Communications Area


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F8h  Set Shell Interrupt (OEM) ............................. 5**92³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		Set OEM handler for int 21h calls from 0F9h through 0FFh
entry	AH	0F8h
	DS:DX	pointer to handler for Functions 0F9h thru 0FFh
note 1) To reset these calls, pass DS and DX with 0FFFFh. DOS is set up to
	allow ONE handler for all 7 of these calls. Any call to these handlers
	will result in the carry bit being set and AX will contain 1 if they are
	not initialized. The handling routine is passed all registers just as
	the user set them. The OEM handler routine should be exited through an
	IRET.
     2) 10 ms interval timer (Tandy?)


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0F9h  Reserved .............................................. 5**93³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		First of 8 SHELL service codes, reserved for OEM shell (WINDOW);
		use like HP Vectra user interface?


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FAh  USART ready (RS-232C) ................................. 5**94³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ

									-176-

ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FBh  USART RS ready (keyboard) ............................. 5**95³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FCh  Unknown ................................................5**96³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FDh  reserved for user interrupt ........................... 5**97³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FEh  reserved by IBM ....................................... 5**98³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AT/XT286/PS50+ - vector destroyed by return from protected mode


ÚÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
³Interrupt 0FFh  reserved by IBM ....................................... 5**99³
ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
		AT/XT286/PS50+ - vector destroyed by return from protected mode
		Zenith Z-100 (S-100 bus MSDOS) warm boot
