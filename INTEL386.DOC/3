			     - 67 -

			    ЧАСТЬ 3

     ПРОГРАММИРОВАНИЕ С ПОЛНЫМ ИСПОЛЬЗОВАНИЕМ 32 РАЗРЯДОВ:
		   ПРОСТОЙ ЗАЩИЩЕННЫЙ РЕЖИМ
	      ─────────────────────────────────────
   Архитектура 80386 с режимом защиты предохраняет против влияния
ошибок в программах и злонамеренного программирования.Эта  защита
является настолько полной,  что  система,  использующая  средства
защиты	в  полной  мере,  может  быть  более  сложной,	чем   это
необходимо или желательно  для	многих	применений.  Поэтому  эта
часть посвящена      ОСНОВАМ функционирования в 32-битовом режиме
защиты, которые легкораспространяются на все 32-битовые  системы.
Эта    часть	включает    информацию	  о    простой	   модели
пользователь-супервизор  в  режиме  защиты  и  пример	программы
установки  такой  модели  непосредственно   с	момента   запуска
процессора.
   Описываемые ОСНОВЫ обладают довольно  большими  возможностями.
Посмотрим, что	они  могут  выполнить.	Используя  базовый  набор
средств обеспечения защиты, программист может создать  32-битовую
систему с 32-битовой адресацией,  32-битовой  обработкой  данных,
страничной  виртуальной  памятью   и   2-х   уровневой	 системой
приоритетов: пользователя и супервизора.
   Действительно: то что мы называем ОСНОВАМИ  80386  превосходит
всю архитектуру нескольких других 32-битовых процессоров,  и  эти
темы,  сами  по   себе,   содержат   достаточно   материала   для
практической главы по режиму защиты. Вы найдете,  что  эта  глава
полезна практически во всей вашей работе в  32-битовом	режиме	с
80386.
   Следующие темы отложены до последних глав:  виртуальный  режим
8086, аппаратная мультизадачность и встроенные средства отладки в
80386.

			    ГЛАВА 7
	    АДРЕСАЦИЯ ПАМЯТИ В 32-РАЗРЯДНОМ РЕЖИМЕ
		 ─────────────────────────────
Эта глава описывает систему адресации в 32-разрядном  режиме,  то
есть когда  обрабатывается  32-битовое	кодовое  слово	в  режиме
защиты. 32-битовые адресные режимы отражают истинную мощь  80386.
Они обеспечивают гораздо большую общность и мощность средств  для
выполнения программ, чем возможно в 16-разрядном адресном режиме.
Например, любой общий регистр можно использовать  в  32-разрядном
адресном   режиме   и	индексную   компоненту	  адреса    можно
масштабировать через 1, 2, 4, или 8.
   Удобство, полученное  благодаря общности 32-разрядных адресных
форм   сильно	облегчает   разработку	 программ.   Формирование
32-разрядного  адреса  часто  может  происходить  без  увеличения
времени исполнения инструкции. Аппаратные  средства  формирования
адреса - основное достижение  80386  по  сравнению  с  некоторыми
другими  сравнимыми   с   ним	микропроцессорами.   Даже   режим
индексации-масштабирования  не	увеличивает  времени   выполнения
операции. Положительный эффект	от  такого  представления  весьма
ощутим, так как адресация памяти - часть почти	каждой	комманды.
Не принижая сравнительные аспекты других 32 - битных процессоров,
отметим как факт, что микропроцессоры 68020 или 32000 требуют еще
на 15 временных циклов больше  для  представления  более  сложных
адресных комбинаций. За 15 циклов 80386 исполняет, в  среднем,	2
1/2 полных инструкций, включая вычисление адреса.

			     - 68 -
		      32-БИТОВАЯ АДРЕСАЦИЯ
		       ────────────────────
   В 32-битовом режиме с защитой действительный адрес вычисляется
как сумма, максимум, 3-х 32-разрядных адресных	компонент:  базы,
смещения  и  индекса.  Действительный  адрес,  поэтому,  является
32-разрядным.  Общий  процесс  32-разрядной  адресации,   включая
масштабированную индексацию, показан на рис. 7.1.
   32-разрядный адрес  получен	как  смещение  от  базы  текущего
сегмента памяти. Следовательно, в качестве  второго  шага  любого
32-битового   формирования   адреса,   базовый	 адрес	 сегмента
складывается с эффективным адресом, образуя  32-битовый  линейный
адрес.	Базовый  адрес	сегмента   берется   из   дескриптора	-
8-байтового блока  данных,  который  описывает	характеристики	и
расположение каждого сегмента. Дескрипторы рассмотрены в гл. 8.
   32-разрядный режим выполнения операций обеспечивает физическое
		       32
адресное пространство 2   байт, другими словами, 4 Гбайт.  Это	-
прямой	  результат    32-разрядной    адресации,    генерирующей
32-разрядныый линейный адрес.

	    ВВЕДЕНИЕ В ОРГАНИЗАЦИЮ СТРАНИЧНОЙ ПАМЯТИ
	     ────────────────────────────────────────
   В 80386 реализована аппаратная поддержка виртуальной памяти	с
помощью   страничной   адресации.   система   адресации,   котора
вычисляяяет  эффективный  адрес,   не	зависит   от   страничной
адресации.  Страничная	адресация,   если   угодно,   -   процесс
трансляции   предшествующий    вычислению    линейного	  адреса,
предшествующий	доступу  в  память.   32-битовая   адресация   со
страничной организацией иллюстрируется рис. 7.2. Как показано  на
рисунке,  страничная  адресация  затрагиваент  верхние	 20   бит
эффективного  адреса,  которые	должны	быть   заменены   другими
20-битовыми значениями.  Замена,  используя  резидентную  таблицу
страниц,  предстает,  как   функция   оригинального   20-битового
значения. Эта глава знакомит со страничной  адресацией,  так  как
это связано  со  всем  процессом  трансляции  адреса.  Страничная
адресация  подробнее  будет  раз`яснена  в  9  главе.  Эта  глава
фокусируется на 32-разрядном формировании адреса.

		   32-БИТНЫЙ АДРЕСНЫЙ РЕЖИМ
		    ────────────────────────
   Широкий  диапазон   адресных   режимов   допускает	различные
комбинации 32-битных адресных  компонент  в  эффективном  адресе,
используя подмножество допустимых компонент. Более простые режимы
используют одну компоненту, в то время как более сложные - 2  или
более компонент и могут также масштабировать индексную компоненту
масштабным множителем 1, 2, 4, или 8.
   Большинство	  адресных    режимов	 являются    регистровыми
косвенно-адресными.  Кроме   того,   80386   обеспечивает   режим
косвенной адресации; однако, это применяется только к  програмной
адресации. Ниже в этой работе  описаны	и  проиллюстрированы  все
32-битовые адресные режимы.

	      Режим прямой регистровой адресации.
	       ──────────────────────────────────
   Прямой регистровый режим означает, что  операнд  расположен	в
одном из 8 регистров общего назначения, в одном  из  6	регистров
сегмента, или в одном из регистров системы.

			     - 69 -
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────┬───────────┘
						 │
	  31	       15	       0	 │
	  ┌────────────┬───────────────┐	 │
	  │знак - рас- │знак-	       │	 ∙  Сложение по
Смещение: │ ширенное   │расшир.        ├────────Ў+	    32
	  └────────────┴───────────────┘	 │  модулю 2
						 │
	  31				0	 │
	  ┌─────────────────────────────┐	 │
Индексный │				│	 ∙  Сложение по
регистр:  │	     Индекс		├───┬───Ў+	     32
	  └─────────────────────────────┘   °	 │  модулю 2
					    │	 │
					    │	 │
			┌───────────────┐   │	 │
			│ масштабный	│   │	 │
			│ множитель	├───┘	 │	    шаг 1
			└───────────────┘	 │
			 1, 2, 4, или 8 	 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					       /
					      /
					     /
					    /проверка  наруше-
					   /границ сег- ние
					  /		───────Ў
					  мента и прав /  исклю-
					     доступа  / чение
						     /	12 или 13
						    /
						   /
						  / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС =
						 │
						 │  ФИЗИЧЕСКИЙ
						 │  АДРЕС
						 │
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │      Физический адрес	     │
			       └─────────────────────────────┘
    Рис.7.1 Вычисление 32-ух разрядного адреса в защищенном
	    режиме (без страничной адресации).

			     - 70 -
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────────────────┘
	  31	       15	       0	 │
	  ┌────────────┬───────────────┐	 │
	  │знак - рас- │знак-	       │	 ∙  Сложение по
Смещение: │ ширенное   │расшир.        ├────────Ў+	    32
	  └────────────┴───────────────┘	 │  модулю 2
	  31				0	 │
	  ┌─────────────────────────────┐	 │
Индексный │				│	 ∙  Сложение по
регистр:  │	     Индекс		├───┬───Ў+	     32
	  └─────────────────────────────┘   °	 │  модулю 2
					    │	 │
			┌───────────────┐   │	 │
			│ масштабный	│   │	 │
			│ множитель	├───┘	 │	    шаг 1
			└───────────────┘	 │
			 1, 2, 4, или 8 	 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					 /		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 /
						/ нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	    шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС =
						 │
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
				31	  12 11  │	     0
				┌────────────----------------|
				│трансляция │	 │  смещение |
				│ страниц   │	 │ в странице|
				└───────────┴─---│-----------
						 │
						 │  ФИЗИЧЕСКИЙ
						 │  АДРЕС
						 │	  шаг 3
						 │
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │      Физический адрес	     │
			       └─────────────────────────────┘
     Рис.7.2 Вычисление 32-ух разрядного адреса со страничной
	     организацией в защищенном режиме.

			     - 71 -
		   Адресация общим регистром.
		    ─────────────────────────
   Операнд в общем регистре определяется полем R/M.  Используемые
размеры регистра могут быть 8, 16, или 32 бита, в зависимости  от
размеров данных в операнде инструкции.
   Вычисление:		  EA = общрег
   Синтаксис Ассемблера:  genreg
   Регистр:		  рег, r/m
   MOD: 		  00
				  31		 15	7	0
				  ┌──────────────┬──────┬───────┐
Общий регистр:	 общрег ─────────Ў│	      операнд	│	│
				  └──────────────┴──────┴───────┘
					любой общий регистр

		 Адресация регистром сегмента.
		  ────────────────────────────
Операнд в регистре сегмента определен в поле  регистра.  Заметим,
что этот адресный режим не использует байт MOD R/M.  Вместо  него
исиспользуется	поле  инструкции  SREG	которое  загружается  или
запоминается в регистр сегмента.
   Вычисление:		       EA = регсег
   Синтаксис асемблера:        segreg
   регистр:		       SREG
					    15		       0
					    ┌──────────────────┐
Регистр Сегмента: регсег ──────────────────Ў│	  операнд      │
					    └──────────────────┘

	       Режим непосредственной адресации.
		────────────────────────────────
   Непосредственная  адресация	определяется  тем,  что   операнд
включен  в  инструкцию,  как  таковую.	 Режим	 непосредственной
адресации  может  определять  только  операнд-источник,   но   не
операнд-приемник. Непосредственный  операнд  может  быть  байтом,
словом	или  двойным  словом.  Режим  непосредственной	адресации
определяется  не  байтом  MOD  R/M;  вернее,  определенные   коды
операций  полностью  определяют  использование	 непосредственной
адресации  для	операнда-источника.   Инструкция   такого   типа,
поэтому, может включать байт MOD R/M для опрелеления ее операнда-
приемника.

			     - 72 -
   Вычисление:		     EA = # <данные>
   Синтаксис ассемблера:     data
   код операции:	     определенный код операции, полностью
			     определяющий что  операция
			     использует непосредственные данные
			       31		15	7	0
			       ┌────────────────┬───────┬───────┐
расширение операции: ─────────Ў│ знак-расширение│знак - │	│
			       │		│расшир.│	│
			       └────────────────┴───────┴───────┘
					     операнд

	      РЕЖИМ КОСВЕННО-РЕГИСТРОВОЙ АДРЕСАЦИИ
	       ────────────────────────────────────
   Этот режим адресации определяет,  что  операнд  -  в  сегменте
памяти,  и  что  содержание  одного  или   нескольких	регистров
используется  для  вычисления  эффективного  адреса  операнда	в
пределах сегмента. Затем прибавляется базовый адрес сегмента  для
формирования 32- битного линейного адреса операнда.

	     Косвенная адресация базовым регистром.
	      ─────────────────────────────────────
   Любой общий регистр кроме EBP может служить базовым	регистром
операнда памяти.
Вычисление:		    EA = (общрег)
Синтаксис асемблера:	    (genreg)
MOD:			    00
регистр:		    EAX, EBX, ECX, EDX, ESI, EDI, ESP
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────┬───────────┘
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						/
					      /проверка  наруше-
					    /границ сег-  ние
					  /		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
						 │
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │	 Операнд	     │
			       └─────────────────────────────┘

			     - 73 -
		      Косвенная адресация
	   посредством базового регистра и смещения.
	    ────────────────────────────────────────
   Любой   общий   регистр   может   использоваться  как базовый,
содержащий адрес, к которому добавляется 32-битное  смещение, или
8-битное    смещение   со  знако-расширением.	Сумма	формирует
эффективный адрес операнда памяти. Базовый адрес  сегмента  затем
добавляется к 32-битному  линейному адресу операнда.
Вычисление:		    EA = (общрег)
Синтаксис асемблера:	    (genreg)
MOD:			    01,10
регистр:		    EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────────────────┘
	  31	       15	7      0
	  ┌────────────────────────────┐	 │
	  │		       │       │	 ∙  Сложение по
Смещение: │  знак-расширенное  │       ├────────Ў+	    32
	  └────────────────────────────┘	 │  модулю 2
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					/		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │      операнд		     │
			       └─────────────────────────────┘

		Косвенная адресация посредством
		базового и индексного регистров.
		 ───────────────────────────────
   Пару любых  общих  регистров  можно	использовать  в  качестве
базового  и  индексного  регистров,  содержащих  адреса,  которые
складываются  для  формирования  эффективного	адреса	 операнда
памяти. Индексный регистр может быть масштабирован 1, 2,  4,  или
8. Затем прибавляется базовый  адрес  сегмента	для  формирования
32-битного  линейного адреса операнда.

			     - 74 -
Вычисление:		    EA = (общрег) + (общрег * масштаб)
 Синтаксис асемблера:	     (genreg) + (genreg * scale)
 MOD:			     00
Базовый регистр:	     EAX, EBX, ECX, EDX, ESI, EDI, ESP
Индексный регистр:	     EAX, EBX, ECX, EDX, ESI, EDI, EBP
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────────────────┘
	  31				0
	  ┌─────────────────────────────┐	 │
Индексный │ любой общий регистр, кроме	│	 ∙  Сложение по
регистр:  │	   ESP			├───┬───Ў+	     32
	  └─────────────────────────────┘   °	 │  модулю 2
					    │	 │
			┌───────────────┐   │	 │
			│ масштабный	│   │	 │
			│ множитель	├───┘	 │	    шаг 1
			└───────────────┘	 │
			 1, 2, 4, или 8 	 │
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					/		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
						 │
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
адрес в памяти: 	       │	 операнд	     │
			       └─────────────────────────────┘

	   Косвенная индексация посредством базового
	    ─────────────────────────────────────────
	      и индексного регистра со смещением.
	       ──────────────────────────────────
   Пару любых  общих  регистров  можно	использовать  в  качестве
базового и индексного регистров, содежащих адреса, которые  затем
прибавляются к	32-битному   смещению  или  знаковому  расширению
8-битному  смещения. Сумма образует эффективный адрес операнда	в
памяти. Затем прибавляется базовый адрес сегмента для образования
32-битного линейного адреса.

			     - 75 -
Вычисление:		    EA = (общрег) + (общрег * масштаб) +
				  + знак-расширенное(смещение)
 Синтаксис асемблера:	     (общрег) + (общрег) + константа
 MOD:			     01, 10
Базовый регистр:	     EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
Индексный регистр:	     EAX, EBX, ECX, EDX, ESI, EDI, EBP
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │	    База	     │
			       └─────────────────────────────┘
	  31		       7       0	 │
	  ┌────────────────────────────┐	 │
	  │		       │       │	 ∙  Сложение по
Смещение: │  знак-расширенное  │       ├────────Ў+	    32
	  └────────────────────────────┘	 │  модулю 2
						 │
	  31				0	 │
	  ┌─────────────────────────────┐	 │
Индексный │				│	 ∙  Сложение по
регистр:  │	     Индекс		├───┬───Ў+	     32
	  └─────────────────────────────┘   °	 │  модулю 2
					    │	 │
			┌───────────────┐   │	 │
			│ масштабный	│   │	 │
			│ множитель	├───┘	 │	    шаг 1
			└───────────────┘	 │
			 1, 2, 4, или 8 	 │
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					/		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						/ нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
						 │
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
адрес в памяти: 	       │	 операнд	     │
			       └─────────────────────────────┘

			     - 76 -
			   Смещение.
			    ────────
   Зффективный адрес определен как абсолютное 32-битовое смещение
относительно базы сегмента.  Величина  смещения  задана  в  самой
инструкции.
	  31	       15	       0
	  ┌────────────────────────────┐
Смещение: │	смещение	       ├─────────┐
	  └────────────────────────────┘	 │
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
							───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
адрес в памяти: 	       │	 операнд	     │
			       └─────────────────────────────┘

	      Преддекрементная косвенная адресация
	       ────────────────────────────────────
		    с помощью ESP регистра.
		     ──────────────────────
   Для	инструкций  PUSH,  PUSHA,  CALL  и   INTn   регистр   ESP
используется как регистр, содержащий  адрес  операнда  в  памяти.
Перед использованием регистра ESP его содержимое  уменьшается  на
размер поля данных операнда, заносимого в стек.
Вычисление:		    ESP = ESP - длина операнда
			    EA = ESP
Синтаксис асемблера:	    подрузамевается с кодами команд
			     PUSH, PUSHA, CALL, или INT n
базовый регистр:	    ESP

			     - 77 -
			   31		  15		 0
			   ┌─────────────────────────────┐
регистр ESP:──────────────Ў│	указатель стека 	 │
			   └──────────────────────────┬──┘
					     │	      °
					     ∙	      │
размер операнда ───────────────────────────Ў -	      │
					     └───┬────┘
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					/		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │	 Операнд	     │
			       └─────────────────────────────┘

	      Постинкрементная косвенная адресация
	       ────────────────────────────────────
		    с помощью регистра ESP.
		     ──────────────────────
   Для инструкций POP, POPA, RET и IRET регистр ESP  используется
как регистр, содержащий адрес операнда памяти.	После  того   как
регистр ESP использован, его содержимое  увеличивается	на  длину
поля данных операнда, извлеченного из стека.
Вычисление:		    EA = ESP
			    ESP = ESP + размер операнда
Синтаксис асемблера:	    подрузамевается с кодами команд
			     POP, POPA, RET, или IRET
базовый регистр:	    ESP

			     - 78 -
			   31		  15		 0
			   ┌─────────────────────────────┐
регистр ESP:──────────────Ў│	указатель стека 	 │
			   └──────────────────────────┬──┘
					     °	      │
					     │	      │
размер операнда ───────────────────────────Ў +	      │
					     °	      │
					     └───┬────┘
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					/		 ───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Физический адрес:	       │	 Операнд	     │
			       └─────────────────────────────┘

		   РЕЖИМ КОСВЕННОЙ АДРЕСАЦИИ
		    ─────────────────────────
   Косвенные формы инструкций JMP  и  CALL  используют	косвенную
адресацию  памяти.  Режим   косвенной	адресации   памяти   дает
возможность использования удобств регистровых косвенных  режимов,
перечисленных в предыдущем разделе.
   Косвенная адресация для JMP и CALL с  косвенным  обращением	к
памяти в пределах програмного  сегмента  функционирует	следующим
образом:   компоненты	адреса	 складываются	для   образования
32-битного смещения и затем прибавляется базовый  адрес  сегмента
для образования 32-битного линейного адреса. Эта  область  памяти
содержит  32-битный  эффективный  адрес  инструкции-приемника	в
пределах текущего сегмента.
   Косвенная адресация	памяти	для  JMP  или  CALL  с	косвенным
обращением  к  памяти  в  другой  програмный  сегмент  происходит
следующим образом: компоненты адреса складываются для образования
32-битного смещения и затем прибавляется базовый  адрес  сегмента
для образования 32-битного линейного адреса. Эта  область  памяти
содержит    полный    адрес    (32-битный    зффективный    адрес
инструкции-приемника  и  16-битовай  селектор	для   програмного
сегмента-приемника).  Все  48  бит  полного  адреса  загружены	и
использованы для вызова  инструкции-приемника.

			     - 79 -
   Вычисление:		 EA: [(общ.рег.) + (общ.рег. ; масштаб) +
			      + знак-расширение(смещение)]
   Синтаксис Ассемблера: указатель(общ.рег.) + (общ.рег. ;
			  масштаб) + конст.
   Реж.:		 00, 01, 10
   Базовый регистр:	 EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP
   Индексный регистр:	 EAX, EBX, ECX, EDX, ESI, EDI, EBP
			       31	      15	     0
			       ┌─────────────────────────────┐
       Базовый регистр:        │    Любой общий регистр      │
			       └─────────────────┬───────────┘
	  31	       15	       0	 │
	  ┌────────────┬───────────────┐	 │
	  │знак - рас- │знак-	       │	 ∙  Сложение по
Смещение: │ ширенное   │расшир.        ├────────Ў+	    32
	  └────────────┴───────────────┘	 │  модулю 2
						 │
	  31				0	 │
	  ┌─────────────────────────────┐	 │
Индексный │				│	 ∙  Сложение по
регистр:  │Любой общий регистр кроме ESP├───┬───Ў+	     32
	  └─────────────────────────────┘   °	 │  модулю 2
					    │	 │
			┌───────────────┐   │	 │
			│ масштабный	│   │	 │
			│ множитель	├───┘	 │
			└───────────────┘	 │
			 1, 2, 4, или 8 	 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
адрес в памяти: 	       │	 операнд	     │
			       └─────────────────────────────┘
						 │
						 │ ИСПОЛНИТЕЛЬНЫЙ
						 │    АДРЕС
						 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					 /		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
сегмента   │	  База сегмента        ├────────Ў+	    32
	   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Адрес в памяти: 	       │  Косвенный адрес  памяти    │
			       └─────────────────────────────┘

			     - 80 -		 │
						/
					      /
					    /проверка  наруше-
					  /границ сег-	ние
					 /		───────Ў
					  мента и прав /  исклю-
					    доступа  /	чение
						   /  12 или 13
						 / нет нарушений
─	─	 ──	    ─			 │  ─	      ─
					    УКАЗЫВАЕТ НА
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
			       │Смещение для косвенного      │
адрес в памяти: 	       │      адреса памяти	     │
			       └─────────────────┬───────────┘
	   31			       0	 │
Адрес базы ┌───────────────────────────┐	 │
	   │			       │	 ∙  Сложение по
програмного│ База програмного сегмента ├────────Ў+	    32
сегмента   │			       │	 │  модулю 2
	   └───────────────────────────┘	 │
						 │	   шаг 2
						 │
						 │  ЛИНЕЙНЫЙ
						 │  АДРЕС
			       31	      15 ∙	     0
			       ┌─────────────────────────────┐
Адрес команды		       │     команда - приемник      │
			       └─────────────────────────────┘

	    КОДИРОВАНИЕ 32-БИТНОГО АДРЕСНОГО РЕЖИМА
	     ───────────────────────────────────────
   32-битные адресные режимы закодированы в байте MOD R/M и байте
S-I-B (масштаб-индекс-база). Для 32-битной адресации,  в  которой
задействовано либо только смещение,  либо  и  базовый  регистр	и
смещение, требуется для кодирования  только  байт  MOD	R/M.  Для
32-битной адресации, в которой задействован базовый  и	индексный
регистры, для кодирования требуется также байт S-I-B.
   Как операнд-источник, так и операнд-приемник - общие регистры.
Второй операнд, к тому же, может быть как общим регистром, так	и
областью  памяти.  Если  второй  операнд  -  область  памяти,  то
адресный режим определен. Для определения обоих операндов в байте
MOD R/M содержится три поля.

		   Байт кодирования MOD R/M.
		    ────────────────────────
   Байт  MOD R/M следует за  байтом(и)	кода  операци  инструкций
80386, как изображено на рис.7.3. Байт	MOD  R/M  разделен  на	3
поля, как показано на рисунке.	Трехбитное  поле  REG  определяет
регистровый операнд. Двухбитное поле MOD определяет, является  ли
второй операнд также регистровым; если - да, то  трехбитное  поле
R/M  определяет  второй   операнд.   Если,   однако,   поле   MOD
свидетельствует, что операнд в памяти, то поля MOD и R/M, вместе,
указывают адресный режим, которым  нужно  пользоваться.  Наконец,
если поле MOD указывает на операнд в памяти и поле  R/M  содержит
100,  то  следующий  байт  -  S-I-B,  который	указывает   режим
адресации.

			     - 81 -
      Байт 0	     Байт 1
     (кодоп)	    (MOD R/M)
├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
 * * * * * * * *
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		 ┌───┘ ┌─┘ ┌───┘
		  REG  MOD  R/M
		 └───┘ └───────┘
	      Операнд 1 Операнд 2
   Рис.7.3. Двухоперандная инструкция с байтом MOD R/M.

		     Кодирующий байт S-I-B
		      ─────────────────────
   При	кодировании  более  сложных  адресных  форм,  в   которых
используется индексный регистр с масштабированием, за байтом  MOD
R/M  следует  байт   S-I-B   (Масштаб-Индекс-База).   Этот   байт
подразделен на 3 поля. Поля изображены на рис.7.4: масштаб  (SS),
индекс	(INDEX)  и  базу  (BASE).  Поле  SS  содержит  масштабный
множитель 1, 2, 4, или 8 для индексной компоненты. Общий  регистр
(любой регистр кроме ESP)  определен  в  поле  INDEX.  Поле  BASE
указывает на общий регистр (когда не используется смещение  -  то
любой регистр кроме EBP) используемый в качестве базы.
      Байт 0	     Байт 1	     Байт 2
     (кодоп)	    (MOD R/M)	    (S-I-B)
├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
 * * * * * * * *	   1 0 0
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		 ┌───┘ ┌─┘	 ┌─┘ ┌───┘ ┌───┘
		  REG  MOD	 SS  INDEX  BASE
		 └───┘ └───────────────────────┘
	      Операнд 1       Операнд 2
   Рис.7.4. Двухоперандная инструкция с байтоми MOD R/M и -I-B.

	  32-битная таблица кодировки MOD R/M и S-I-B.
	   ───────────────────────────────────────────
   Таблица 7.1. определяет поля MOD R/M и S-I-B, включая  в  себя
все 32-битные режимы адресации памяти.	Заметим,  что  все  общие
регистры   используются   в    32-битных    режимах    адресации.
(Подрузамевается,  что	ESP  использован  для  адресации   памяти
инструкциями PUSH, POP,  PUSHA,  POPA,	CALL  и  INT  n).Смещение
можно определить как 32-битное значение или как 8-битное значение
(знак-расширенное до 32 бит).
       Таблица 7.1 Определение полей REG MOD R/M и S-I-B
		    для 32-битной адресации
─────────────────────────────────────────────────────────────────
      Байт 0	     Байт 1
     (кодоп)	    (MOD R/M)
├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
 * * * * * * * *
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		 ┌───┘ ┌─┘ ┌───┘
		  REG  MOD  R/M
		 └───┘ └───────┘
	      Операнд 1 Операнд 2

			     - 82 -
REG    операнд 1 =	    MOD   R/M	  операнд 2 =
─────────────────────────────────────────────────────────────────
000   регистр EAX/AX/AL     00	  000	 память DS:[EAX]
001   регистр ECX/CX/CL     00	  001	 память DS:[ECX]
010   регистр EDX/DX/DL     00	  010	 память DS:[EDX]
011   регистр EBX/BX/BL     00	  011	 память DS:[EBX]
100   регистр ESP/SP/AH
101   регистр EBP/BP/CH     00	  101	 память DS:[d32]
110   регистр ESI/SI/DH     00	  110	 память DS:[ESI]
111   регистр EDI/DI/BH     00	  111	 память DS:[EDI]
─────────────────────────────────────────────────────────────────
			    01	  000	 память DS:[EAX + d8]
			    01	  001	 память DS:[ECX + d8]
			    01	  010	 память DS:[EDX + d8]
			    01	  011	 память DS:[EBX + d8]
			    01	  101	 память DS:[EBP + d8]
			    01	  110	 память DS:[ESI + d8]
			    01	  111	 память DS:[EDI + d8]
			    ─────────────────────────────────────
			    10	  000	 память DS:[EAX + d32]
			    10	  001	 память DS:[ECX + d32]
			    10	  010	 память DS:[EDX + d32]
			    10	  011	 память DS:[EBX + d32]
			    10	  101	 память DS:[EBP + d32]
			    10	  110	 память DS:[ESI + d32]
			    10	  111	 память DS:[EDI + d32]
			    ─────────────────────────────────────
			    10	  000	 регистр EAX/AX/AL
			    10	  001	 регистр ECX/CX/CL
			    10	  010	 регистр EDX/DX/DL
			    10	  011	 регистр EBX/BX/BL
				  100	 регистр ESP/SP/AH
			    10	  101	 регистр EBP/BP/CH
			    10	  110	 регистр ESI/SI/DH
			    10	  111	 регистр EDI/DI/BH
			   ─────────────────────────────────────

			     - 83 -
      Байт 0	     Байт 1	     Байт 2
     (кодоп)	    (MOD R/M)	    (S-I-B)
├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
 * * * * * * * *	   1 0 0
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
		 ┌───┘ ┌─┘	 ┌─┘ ┌───┘ ┌───┘
		  REG  MOD	 SS  INDEX  BASE
		 └───┘ └───────────────────────┘
	      Операнд 1       Операнд 2
REG  операнд 1 =      MOD SS INDEX BASE операнд 2 =
────────────────────────────────────────────────────────────────────
000 регистр EAX/AX/AL 00  ss  iii   000 память DS:[EAX+(ss*iii)]
001 регистр ECX/CX/CL 00  ss  iii   001 память DS:[ECX+(ss*iii)]
010 регистр EDX/DX/DL 00  ss  iii   010 память DS:[EDX+(ss*iii)]
011 регистр EBX/BX/BL 00  ss  iii   011 память DS:[EBX+(ss*iii)]
100 регистр ESP/SP/AH 00  ss  iii   100 память SS:[ESP+(ss*iii)]
101 регистр EBP/BP/CH 00  ss  iii   101 память DS:[d32+(ss*iii)]
110 регистр ESI/SI/DH 00  ss  iii   110 память DS:[ESI+(ss*iii)]
111 регистр EDI/DI/BH 00  ss  iii   111 память DS:[EDI+(ss*iii)]
───────────────────────────────────────────────────────────────────
		      01  ss  iii   000 память DS:[EAX+(ss*iii)+d8]
		      01  ss  iii   001 память DS:[ECX+(ss*iii)+d8]
		      01  ss  iii   010 память DS:[EDX+(ss*iii)+d8]
		      01  ss  iii   011 память DS:[EBX+(ss*iii)+d8]
			  ss  iii   100 память SS:[ESP+(ss*iii)+d8]
		      01  ss  iii   101 память DS:[EBP+(ss*iii)+d8]
		      01  ss  iii   110 память DS:[ESI+(ss*iii)+d8]
		      01  ss  iii   111 память DS:[EDI+(ss*iii)+d8]
		      ─────────────────────────────────────────────
		      10  ss  iii   000 память DS:[EAX+(ss*iii)+d32]
		      10  ss  iii   001 память DS:[ECX+(ss*iii)+d32]
		      10  ss  iii   010 память DS:[EDX+(ss*iii)+d32]
		      10  ss  iii   011 память DS:[EBX+(ss*iii)+d32]
			  ss  iii   100 память SS:[ESP+(ss*iii)+d32]
		      10  ss  iii   101 память DS:[EBP+(ss*iii)+d32]
		      10  ss  iii   110 память DS:[ESI+(ss*iii)+d32]
		      10  ss  iii   111 память DS:[EDI+(ss*iii)+d32]
		      ──────────────────────────────────────────────
		      11  ──   ──   000 регистр EAX/AX/AL
		      11  ──   ──   001 регистр ECX/CX/CL
		      11  ──   ──   010 регистр EDX/DX/DL
		      11  ──   ──   011 регистр EBX/BX/BL
		      11  ──   ──   100 регистр ESP/SP/AH
		      11  ──   ──   101 регистр EBP/BP/CH
		      11  ──   ──   110 регистр ESI/SI/DH
		      11  ──   ──   111 регистр EDI/DI/BH
┌────────────────┬────┐    │	│     ┌─────┬─────────────────┐
│  масштабный	 │ SS │    │	│     │INDEX│индексный регистр│
│  множитель	 │ ss │    │	│     │ iii │		      │
├────────────────┼────┤    │	│     ├─────┼─────────────────┤
│      х 1	 │ 00 │    │	│     │ 000 │	   EAX	      │
│      х 2	 │ 01 │    │	│     │ 001 │	   ECX	      │
│      х 4	 │ 10 │ў───┘	└────Ў│ 010 │	   EDX	      │
│      х 8	 │ 11 │ 	      │ 011 │	   EBX	      │
└────────────────┴────┘ 	      │ 100 │ без инд.регистра│
				      │ 101 │	   EBP	      │
				      │ 110 │	   ESI	      │
				      │ 111 │	   EDI	      │
				      └─────┴─────────────────┘

			     - 84 -
			   Г Л А В А  8

	БАЗИСНОЕ ИСПОЛЬЗОВАНИЕ ПРИВИЛЕГИРОВАННЫХ УРОВНЕЙ
	 ────────────────────────────────────────────────
		      И СИСТЕМЫ ПРЕРЫВАНИЙ
		       ────────────────────
   В этой главе излагается информация,	которую  нужно	знать  об
архитектуре 80386 в  ЗАЩИЩЕННОМ  режиме  при  проектировании  или
использовании 32-разрядной системы 80386 с двухуровневой  моделью
защиты пользователь/супервизор.
   Она	охватывает  использование  80386  в  32-битном	режиме	с
базисной моделью защиты, использующей только 2 из  4-х	имеющихся
уровней   привиллегированности.   Самый   привилегированный	и
наименьший  уровни  -  использованы  для  простой   двухуровневой
системы.    2	 промежуточных	  уровня      привилегированности
игнорируются.
   Самый  привилегированный   уровень  назначается   операционной
системе. Как  таковой,	он  называется	уровнем  супервизора.  Он
включает в себя код управления системой - программу  супервизора.
Младший уровень доступен для программ пользователя. Этот  уровень
используется  программами,  спроектированными  для  специфических
применений,  таких  как   база	 данных,   компилятор,	текстовый
процессор, или <spreadsheet>. Архитектура в режиме  защиты  80386
защищает уровень супервизора от влияния любых  програмных  ошибок
уровня пользователя, даже  злонамеренных.  Адресное  пространство
назначенное прграммам и данным супервизора, защищено  от  прямого
доступа чтение/запись из программы пользователя.
   Структура прерываний  в  защищенном	режиме	тесно  связана	с
уровнями  привилегированности. Она делает возможным  передачи  из
одного	уровня	привилегированности   в  другой.  Она,	 конечно,
обеспечивает эту функцию для аппаратного прерывания  по  вектору,
но  точно  также  может   управлять   програмными   прерываниями.
Используя програмные прерывания и как механизм вызова,	и  как	в
РС-ориентированных  применениях,  супервизор  содержит	служебные
программы,  необходимые  для   уровня	пользователя.	Служебные
программы, запускаемые операциями програмного  прерывания,  могут
выполнять системные функции, такие как	периферийный  ввод/вывод,
распрелеление памяти и т.д. Програмное	обеспечение  пользователя
имеет простой доступ  к служебным программам вызовом их  командой
прерываня INT n. Кроме того, использование  структуры  прерываний
помогает защищать уровень супервизора ограничением точек входа	в
супервизор только перичисленными в таблице прерываний.
   ЗАМЕЧАНИЕ: вентили вызова, рассмотренные в главе  14  являются
отчасти более мощным механизмом связи  пользователь-ОС,  так  как
они не ограничены количеством и позволяют делать копию параметров
в стек супервизора.

	   ИСПОЛЬЗОВАНИЕ РАЗБИЕНИЯ ПАМЯТИ НА СТРАНИЦЫ
	    ──────────────────────────────────────────
Эта глава  посвящена,  в  основном,  требованиям  к  сегментам	в
простой  32-битной  защищенной	системе.  Следует  заметить,  что
механизм  страничной  памяти   в   таких   ситемах   обеспечивает
необходимую защиту программ и данных супервизора.
   В очень простых защищенных системах механизм страничной памяти
разделяет линейное адресное пространство на область  пользователя
и область супервизора. Каждая страница оперативной  памяти  может
быть  описана  системой  страничной   памяти   и   как	 страница
пользователя,	и как страница супервизора (см. главу 9).

			     - 85 -
   Система страничной памяти может также обеспечивать возможности
по организации виртуальной памяти. Программы  пользователя  могут
частично  размещаться  на  диске,  и  система  страничной  памяти
прозрачна для них (см. часть 9).

	   ИСПОЛЬЗОВАНИЕ 32-РАЗРЯДНЫХ СЕГМЕНТОВ ПАМЯТИ
	    ───────────────────────────────────────────
		 ДЛЯ ПРОСТЫХ ЗАЩИЩЕННЫХ СИСТЕМ
		  ─────────────────────────────
   В ЗАЩИЩЕННОМ режиме сегментам памяти можно назначать атрибуты:
привилегированность,  базовый адрес, размер  и	использование.	В
простой  ЗАЩИЩЕННОЙ  системе  нужно  снабдить  атрибутами  весьма
небольшой набор сегментов, фактически 5. В двухуровневой  системе
защиты	требования  архитектуры  ЗАЩИЩЕННОГО  режима  реализуются
посредством 5 сегментов памяти. Эти 5 сегментов:
   А.  Супервизорный  програмный  сегмент   для  программ  уровня
супервизора.
   Б.  Супервизорный  сегмент	данных	 для   стека   и   данных
супервизора.
   В. Пользовательский програмный  сегмент  для  программ  уровня
пользователя.
   Г.  Пользовательский  сегмент  данных  для  стека   и   данных
пользователя.
   Д. Сегмент  состояния  задачи  для  хранения  указателя  стека
супервизора, когда выполняется программа на уровне пользователя.
   Эти сегменты осуществляют требования ЗАЩИЩЕННОГО режима:
   1.  Для  каждого  установленного  уровня   привилегированности
имеется, по крайней мере, 1 програмный сегмент.  В  нашем  случае
этими  уровнями  оказываются  уровень	супервизора   и   уровень
пользователя, требующие 2 програмных сегмента.
   2.  Для  каждого  установленного  уровня   привилегированности
имеется, по крайней мере, 1  стековый  сегмент.  В  нашем  случае
должны быть созданы 2 сегмента данных для  хранения  стеков.  Эти
одинаковые сегменты можно также использовать для других данных.
   3. Когда процессор выполняет программу на уровне пользователя,
для    хранения     начального	   указателя	 стека	   уровня
привилегированности супервизора нужен сегмент состояния задачи.
Каждый из 4-х  перечисленных  сегментов  следует  об`явить  очень
							 32
большим по величине. Фактически их следует об`явить как 2   байта
(4  Гбайта),  так  чтобы  каждый  охватывал  32-битное	 линейное
адресное пространство, как показано  на  рис.  8.1.  Установление
больших сегментов позволяет  избежать  ограничений  по	адресации
памяти внутри набора  из  4-х  сегментов,  перечисленных  выше	и
исключает  любую   необходимость   для	 программы   пользователя
перегружать  регистры  сегмента  в  процессе  своего  выполнения.
Большое линейное адресное  пространство  сегментов   обеспечивает
"квартиру" - 4-Гбайтную область, в которой исполняется  программа
пользователя.
   Сегмент состояния задачи - специальный сегмент размером  ровно
104 байта, как описано ниже на стр.    .Сегмент состояния  задачи
может быть расположен  в  любом  месте	4-х  Гбайтного	линейного
адресного пространства, как показано на рис.8.1.

			     - 86 -
    ┌──────────────────────────┐
    │┌────────────────────────┐│
    ││┌──────────────────────┐││
    │││ 		     │││   °
    │││ каждый ─ по 4 Гбайт. │││   │ FFFFFFFF
    │││ 		     │││   │	     16
    │││(предел = FFFFFFFF  ) │││   │
    │││ 		 16  │││   │
    │││ 		     │││   │
    │.. 	.	     ..│   │
    │.. 	.	     ..│   │
    │.. 	.	     ..│   │
    │			       │   │
    │││ 		     │││   │ 4-Гбайтное линейное адресное
    │││ 		     │││   │ пространство, доступное для
    │││ сегменты A, B, C, D  │││   │ 32-битных операций
    │││ 		     │││   │
    │││ 		     │││   │
    │││ 		     │││   │
    │││ Каждый имеет базовый │││   │
    │││  адрес 00000000   .  │││   │ 00000000
    │││ 	       16    │││   │	     16
    │││ 		     │││   │
    ││└──────────────────────┘││   ∙
    │└────────────────────────┘│
    └──────────────────────────┘
	  Рис. 8.1  Соразмещение сегментов A, B, C, D
	    для 32-битной простой ЗАЩИЩЕННОЙ системы

      ДЕСКРИПТОРЫ СЕГМЕНТОВ ДЛЯ ПРОСТОЙ ЗАЩИЩЕННОЙ СИСТЕМЫ
       ────────────────────────────────────────────────────
   В режиме REAL (Главы 4 -  6)  дескрипторов  сегментов  нет.	В
режиме REAL у сегментов памяти есть только 1  атрибут  -  базовый
адрес. Отметим, однако, что базовый адрес в режиме REAL  является
прямой функцией значения селектора сегмента,  умноженного  на  16
(сдвинутого  на  4  бита  влево).  Селектор  как  таковой,  таким
образом, полностью описывает сегмент памяти в режиме REAL.
   Однако, в ЗАЩИЩЕННОМ режиме сегменты  памяти  сложнее.  Каждый
обладает несколькими атрибутами: индивидуальным базовым адресом в
32-битном линейном адресном пространстве (не прямо,  как  функция
от значения селектора), индивидуальным размером и индивидуальными
правами доступа. Эти  атрибуты	содержатся  в  специальном   типе
данных, дескрипторе сегмента, распознаваемом 80386  в  ЗАЩИЩЕННОМ
режиме.
   В ЗАЩИЩЕННОМ режиме сегменты описаны перечислением атрибутов в
дескрипторах, по одному дескриптору на сегмент, и  группированием
дескрипторов вместе для образования в памяти резидентной таблицы,
называемой  Таблица  Глобального  Дескриптора  (GDT).	Несколько
дескрипторов и GDT описаны ниже в этой главе. Другие  дескрипторы
и таблицы, не нужные для простой 32-битной системы,  обсуждены	в
Гл.14.

		  Формат дескриптора сегмента.
		   ───────────────────────────
   Каждый дескриптор состоит ровно из  8  байт	-  2-х	32-битных
двойных слова,	однако,  содержит  всю	описательную  информацию,
относящуюся к одному сегменту памяти:  базовый	адрес,	размер	и
права  доступа.   Рис.8.2   изображает	 дескриптор   програмного
сегмента, а Рис.8.3 - дескриптор сегмента данных.  Часть  "а"  на
каждом рисунке изображает весь дескриптор целиком.  В  части  "б"
затушевана информация о базовом адресе; в части "в" -  информация
о границах и в части "г" - информация о правах доступа.

			     - 87 -
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │D │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │C │R │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
    а. Общий вид 32-битного дескриптора програмного сегмента
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │D │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │C │R │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	    б. Информация о базовом адресе сегмента
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │D │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │C │R │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	       в. Информация о границах сегмента
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │D │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │C │R │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	     г. Информация о правах доступа сегмента
  Рис. 8.2 Дескриптор для 32-битного програмного сегмента.

			     - 88 -
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │B │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │0 │E │W │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
      а. Общий вид 32-битного дескриптора сегмента данных
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │B │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │E │W │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	    б. Информация о базовом адресе сегмента
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │B │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │E │W │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	       в. Информация о границах сегмента
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│ база сегмента 31...24 │G │B │O AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │база сегмента 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │1 │1 │E │W │A │ база сегмента 23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │ граница сегмента 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	     г.Информация о правах доступа сегмента
    Рис. 8.3 Дескриптор для 32-битного сегмента данных.

   Ниже приводятся определения дескрипторных полей:
 1. Базовый адрес сегмента - это 32-битное значение, определяющее
    базовый адрес сегмента в линейном адресном пространстве.
 2.  Граница  сегмента	-  это	 20-битное   поле,   определяющее
 наибольшее    смещение в сегменте. Граница может быть выражена в
 байтах или    в страницах (4096 б), что контролируется  битом	G
 дескриптора.

			     - 89 -
 3. G (градуировка) указывает, что граница сегмента задается  или
  в байтах, или в страницах.
 4. D (неполнота) указывает какой сегмент  32-битный  (D=1)  или
 16-битный  (D=0).  Если   D=1,   то   формат	дескриптора   для
 сегменттов программ и данных такой, как показано на рис.  8.2	и
 8.3, соответственно. Если  D=0,  то  формат  дескриптора  такой,
 какой используется 80286  в  ЗАЩИЩЕННОМ  режиме  для  16-битного
 сегмента, как раз`яснено в гл. 14.  16-битный	код  обеспечивает
 32-битный размер операнда данных и 32-битный  размер  адреса  по
 умолчанию (совместимый с 80286 в режиме защиты).
 5.  E	(направление  распространения),  только   для	сегментов
 данных,-    указывет, где  расположен	сегмент  или  в  области
 адресов от    базы сегмента вверх до его границы,  включая  E=0,
 или от    максимального  смещения  до	границы,  не  включая  ее
 (E=1).    Большинство сегментов данных, таких как B и D на  стр.
       имеют в этом бите 0 (вверх). Только для	сегмента  данных,
 использующего для хранения стека данных,  который  растет  вниз,
 по направлению к меньшим адресам можно найти  уместным  иметь	в
 этом бите 1 (вниз).
 6. B (большой) только для сегментов и	  учитывается только если
 сегмент простирается вниз, обозначает	  максимальное смещение в
 сегменте. Максимальное смещение    простирающегося вниз сегмента
 данных может  быть  указано  как     FFFFFFFF	  (B=1)  или  как
					      16
 0000FFFF    (B=0).  B	не  отвечает   за      сегменты   данных,
	 16
 простирающиеся вверх.
 7. Права доступа - это несколько бит, указывающих на разрешенные
    формы    доступа	в     сегмент,	   включая     требование
 привилегированности  уровня и защиту по записи  и  чтению.  Если
 используемый  операнд	внутри	сегмента  использует  запрещенную
 форму доступа, то  80386  вырабатывает  исключительную  ситуацию
 по   общей   защите	(исключительная    ситуация    13)    или
 исключительную ситуацию по стеку (исключительная  ситуация  12),
 если работа со стековым сегментом.
7а. P (представление) указывает, имеется ли сегмент в  физической
 памяти (P=1), или нет (P=0). Этот бит позволяет определять много
 больших  сегментов,  из  которых,  возможно,  только	некоторые
 частично или полностью  могут	быть  одновременно  в  физической
 памяти. Система  страничной  памяти  позволяет  любому  сегменту
 загружаться постранично; даже если P=1 сегменту  не  нужно  быть
 целиком в памяти.
7б.  DPL  (Уровень  привилегированности   дескриптора)	указывает
 уровень привилегированности,  как число 0, 1, 2, или 3 следующим
 образом
  Поле DPL│		    Дескиптор
  ────────┼────────────────────────────────────────────────────
     00   │уровень 0 самый привилегированный (супервизор, ядро)
  ────────┼────────────────────────────────────────────────────
     01   │уровень 1
  ────────┼────────────────────────────────────────────────────
     10   │уровень 2
  ────────┼────────────────────────────────────────────────────
     11   │уровень 3  низший уровень (пользователь)
 DPL текущего  програмного  сегмента  указывает  текущий  уровень
 привилегированности  (CPL)  операции.	Например,  если процессор
 обрабатывает програмный сегмент с DPL 00, то он работает при CPL
 0 - самом привилегированном уровне - уровне супервизора.
7в. A (Доступный) - указывает был ли сегмент доступен (A=1)  или
нет (A=0) с того момента, как этот бит дескриптора  был сброшен в
0. Если в системе происходит обмен  сегментами	между  памятью	и

			     - 90 -
диском,  то  этот  бит	 можно	 использовать	для   определения
использования сегмента. Типовые простые системы обмена страницами
не используют сегментации и этот бит для таких систем интереса не
представляет.
7г. R (доступность для чтения), только для  кодового  сегмента	-
указывает, доступен ли сегмент для чтения (R=1)  или  нет  (R=0).
Програмные сегменты, конечно, всегда выполнимы. Атрибут  R  может
обеспечить сверхбезопасность запрещением програмному  обеспечению
читать из сегмента, использующего префикс отвержения CS (см. стр.
       и таблицу 2.6)
7д.  C	(приспосабливаемость),	только	для  кодового	сегмента,
- указывает изменяется ли CPL, когда  сегмент  вызван  из  уровня
меньшей привилегированности  (C=0) или нет (C=1).  Если  C=1,  то
програмный  сегмент   называется   приспосабливаемым   програмным
сегментом, т.к. значение CPL не изменяется, когда вызывается этот
сегмент. Приспосабливаемые програмные сегменты	очень  употребимы
для  библиотечных  программ,  позволяющих  вызвать  программу  из
программы    пользовательского	  уровня,    но    сохраняя	у
пользовательской   программы   CPL   пользователя.    Особенность
приспособления	-  до  некоторой  степени   абстрактное   понятие
архитектуры в режмиме защиты и в  32-битных  простых  системах	с
защитой  все   програмные   сегменты   -   регулярны,	т.е.   не
приспосабливаемы.
7e. W (доступность для записи), только для  сегментов  данных,	-
указывает доступен ли сегмент данных для  записи  (W=1)  или  нет
(W=0). Сегменты данных,  конечно,  всегда  доступны  для  чтения.
Атрибут  W  может  обеспечивать   сверхбезопасность   запрещением
програмному обеспечению  писать  в  сегмент.  К  применений  этой
специальной особенности  относится  резервирование  сегмента  для
информации о состоянии	и  защите  общедоступных  баз  данных.	В
простой 32-битной защищенной системе сегмент  данных  служит  для
разных целей и, среди прочего, содержит стек; поэтому  он  должен
быть доступным для записи.

	     GDT (Глобальная Таблица Дескриптора).
	      ────────────────────────────────────
   Глобальная таблица дескриптора  содержит  массив  дескрипторов
сегментов. Как показано на рис.  8.4  эта  резидентная	в  памяти
таблица  с  базой   и	границей   внутри   линейного	адресного
пространства в области определенной системным регистром GDTR (см.
стр. 20 и рис. 2.8). GDTR принимает 48-битный операнд,	состоящий
из 32-битной базы и 16-битной границы.	Таким  образом	база  GDT
может  присутствовать  в  любом  адресе  в   пределах	линейного
адресного пространства;  граница  (максимальное  смещение)  может
простираться   до   FFFF,   охватывая	до   8192   дескрипторов,
пронумерованных от 0 до 8191. Дескриптор 0 - базовый адрес в GDT.
   Дескриптор 0, специально определенный как  пустой  дескриптор,
не используется процессором. Он сохранен для заполнения  нулевого
дескриптора 8 байтами 00   .
			16
 GDT может содержать только
   Дескрипторы сегментов программ стр.
   Дескрипторы сегментов данных стр.
   Вентили вызова гл. 14
   Дескрипторы сегментов состояния задач гл. 14
   Вентили задач гл. 14
   Дескрипторы LDT гл. 14

			     - 91 -
   Как показано на рис. 8.5. селектор содержит 3  поля	в  режиме
защиты. Верхние  13  бит  содержат  индекс,  который  выбирает	1
дескриптор из GDT, когда когда бит Индикатора таблиц  (TI)  -  0,
указывающий на GDT. Биты TI и RPL полагают 0-м для простых систем
с защитой, как показано в нижней части рис. 8.5 .
   В режиме защиты загрузка селектора регистр  сегмента  вызывает
доступ 80386 в сегмент n,  описанный  дескриптором  n,	где  n	-
верхние 13 бит селектора.Верхнии 11 бит селектора ведут себя  как
индекс в таблице дескрипторов (GDT, где бит - 0). Все инструкции,
которые пересылают значение в регистр сегмента (CS, SS,  DS,  ES,
FS,  GS)  вызывают  то,  что  80386  автоматически  ссылается	в
дескриптор n, читает дескриптор и  запоминает  содержание  внутри
кэша дескриптора. Внутри имеется по одному кэшу  дескриптора  для
каждого регистра сегмента, как изображено на рис. 8.6 .
		     4-Гбайтное линейное адресное пространство
		    31	 24 23	 16 15	  8 7	  0
		    ┌──────┬───────┬───────┬───────┐
	FFFFFFFF    ├──────┼───────┼───────┼───────┤
		16  ├──────┼───────┼───────┼───────┤
		    ├──────┼───────┼───────┼───────┤
				   .
 линейный адрес 		   .
				   .
 база + граница
		    ├──────┴───────┴───────┼───────┤
	    ┌───────┼─Ў.дескриптор ??????? │	   │ граница
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    │ дескриптор ??│	   │	   │
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    ├──────┼───────┼───────┼───────┤
	    │			   .
	    │			   .
	    │			   .
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    │ дескриптор 1 │	   │	   │
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    ├──────┴───────┴───────┼───────┤
  линейный  │	    │ дескриптор 0 "пустой         │
  адрес     │	    │	    дескриптор"            │
  база	    │	    ├──────┼───────┬───────┼───────┤
  ┌─────────┼───────┼──────┼───────┼───────┼──Ў.   │
  │	    │	    ├──────┼───────┼───────┼───────┤
  │	    │	    │	   │	   │	   │	   │ база
  │	    │	    ├──────┼───────┼───────┼───────┘
  │	    │			   .
  │	    │			   .
  │	    │			   .
  │	    │	    ├──────┼───────┼───────┼───────┤
  │	    │	    ├──────┼───────┼───────┼───────┤ 00000000
  │	    │	    └──────┴───────┴───────┴───────┘	     16
  │	    │	     4-Гбайтное линейное адресное пространство
  │	    └───────────────────────┐
47│			    16 15   │	   0
┌─┴───────────────────────────┬─────────────┐
 32-битный линейный адрес базы 16-битная
	    GDT 	       граница GDT
└─────────────────────────────┴─────────────┘
      cистемный регистр GDTR (в 80386)
	 Рис. 8.4 Регистр GDTR размещает GDT в линейном
		     адресном пространстве.

			     - 92 -
	   Формат селектора в ЗАЩИЩЕННОМ режиме.
	    ────────────────────────────────────
	       формат селектора
 15 14 13 12 11 10  9  8  7  6	5  4  3  2  1  0
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│		 индекс 		TI  RPL │ требуемый уро-
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┼──┘ вень привиле-
   Индекс указывает на соответствующую	     │	  гированности
	 таблицу дескрипторов		     └──Ў
	      │ 				  00 = не влияет
	      │ 				   на возможности
	      │ 				   доступа
	      │ 				  01 = возможности
	      │ 				   доступа ограни-
	      │ 				   чены не выше,
	      │ 				   чем уровень 1
	      │ 				  10 = возможности
	      │ 				   доступа ограни-
	      │ 				   чены не выше,
	      │ 				   чем уровень 2
	      │ 				  11 = возможности
	      │ 				   доступа ограни-
	      │ 				   чены не выше,
	      │ 				   чем уровень 3
	      │ 			 (значения RPL: 01, 10,
	      │ 			  11 - см. главу 14)
	      │
	      └─────Ў Индикатор таблицы
		       0 - Дескриптор индексирован в GDT
		       1 - Дескриптор индексирован в LDT
				 (LDT см. гл. 14)
  формат селектора для простой системы с защитой
 15 14 13 12 11 10  9  8  7  6	5  4  3  2  1  0
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
│		 индекс 		TI  RPL │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
  Рис. 8.5 Селектор в ЗАЩИЩЕННОМ режиме
   Регистры кэш-дескриптора сохраняют копию дескриптора сегмента.
Эта копия использована во всех вычислениях адреса  для	получения
границы сегмента и прав доступа, использованных во время проверки
границ и прав доступа. Помещение регистров кэш-дескриптора в  чип
существенно при реализации. они обеспечивают  мнгновенный  доступ
по всем текущим сегментам.
   Несколько важных деталей можно уяснить из рис. 8.6 .  Заметим,
что кэш дескриптора для CS и SS содержит  CPL,	в  то  время  как
остальные  содержат  DPL.  Это	означает,  что	 DPL   програмных
сегментов устанавливает CPL и, также, что DPL стекового  сегмента
должен всегда соответствовать CPL. Этот факт  критичен	даже  для
простых ЗАЩИЩЕННЫХ систем.

			     - 93 -
Регистры     КЭШ дескриптора сегментов (скрытая копия дескрип-
сегментов	     торов сегментов на чипе)
┌────────┐   ┌──────────────────┬──────────────────┬────────────┐
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  CS	 ├──Ў│	  сегмента	│	 страницах)│G D P CPL C │
│	 │   │			│		   │	R A	│
├────────┤   ├──────────────────┼──────────────────┼────────────┤
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  SS	 ├──Ў│	  сегмента	│	 страницах)│G B P CPL E │
│	 │   │			│		   │	W A	│
├────────┤   ├──────────────────┼──────────────────┼────────────┤
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  DS	 │──Ў│	  сегмента	│	 страницах)│G B P DPL E │
│	 │   │			│		   │	W A	│
├────────┤   ├──────────────────┼──────────────────┼────────────┤
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  ES	 │   │	  сегмента	│	 страницах)│G B P DPL E │
│	 │   │			│		   │	W A	│
├────────┤   ├──────────────────┼──────────────────┼────────────┤
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  FS	 ├──Ў│	  сегмента	│	 страницах)│G B P DPL E │
│	 │   │			│		   │	W A	│
├────────┤   ├──────────────────┼──────────────────┼────────────┤
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│	 │   │базовый адрес	│ (в байтах или    │буты	│
│  GS	 │──Ў│	  сегмента	│	 страницах)│G B P DPL E │
│	 │   │			│		   │	W A	│
└────────┘   └──────────────────┴──────────────────┴────────────┘
Рис. 8.6 Регистры КЭШа дескриптора для всех регистров сегментов.

	      ИСПОЛЬЗОВАНИЕ ПРОГРАМНЫХ ПРЕРЫВАНИЙ
	       ───────────────────────────────────
   В простых защищенных системах пользователь вызывает	программы
супервизора, используя програмные прерывания - инструкции INT n .
Для этой цели зарезервированы номера от 32 до  255.
   Структура  прерываний,  поэтому,-  неотделимая  часть  простой
32-битной  системы  с  защитой.  Это   раз`яснено   в	следующем
параграфе. Затем обсуждено проектирование многоуровневых систем.

	    СТРУКТУРА ПРЕРЫВАНИЙ В ЗАЩИЩЕННОМ РЕЖИМЕ
	     ────────────────────────────────────────
   Структура прерываний  в  режиме  защиты  -  в  высшей  степени
аналогична структуре прерываний в режиме REAL, описанном в  гл.6.
Сходство поразительно во всех отношениях
   1. Как и в режиме REAL, програмные  прерывания  можно  вызвать
      инструкциями   INT   n.	Сигналы   аппаратных   прерываний
      направляются на входные контакты INTR (маскируемые)  и  NMI
      (немаскируемые).	После  получения  прерывания,  управление
      передается программе  обслуживания  с  помощью  резидентной
      таблицы, содержащей соответствующую информацию о векторах.
   2.  Точки  входа   для   супервизорных   программ   прерываний
      содержатся среди вентилей прерываний и  вентилей	системных
      прерываний.  Эти	вентили  -  аналоги  векторов  прерываний
      режима REAL.  Вентили  прерываний  особенно  подходящи  для
      векторных аппаратных прерываний, в  то  время  как  вентили
      системных прерываний - идеальны  для  векторных  програмных
      прерываний.

			     - 94 -
   3.  Вентили	прерываний   и	 вентили   системных   прерываний
      перичислены  вместе  в  резидентном   массиве,   называемом
      Таблицей	Дескрипторов  Прерываний  (IDT).  IDT  -   аналог
      таблицы векторов прерываний, рассмотренной в  режиме  REAL.
      IDT дальше рассмотрена на стр.

		      Вентили прерываний.
		       ──────────────────
   Векторный элемент, специально спроектированный  для	векторных
аппаратных прерываний в режиме защиты - это  вентиль  прерываний.
Как и его аналог в режиме REAL	-  вектор  прерываний  -  вентиль
прерываний содержит  селектор  и  смещение.  Однако,  селектор	и
смещение заключены в  8-байтном  дескриптороподобном  элементе	-
вентиле прерываний.
   Каждый вентиль прерываний содержит ровно 8 байт - 2	32-битных
двойных  слова,  содержащих  полную  информацию  про  направление
передачи   управления	и   защиту   для    одного    прерывания
селектор (который должен быть селектором програмного сегмента)	и
уровень привеллегированности, назначенный этому вентилю. Рис. 8.7
иллюстрирует вентиль прерываний.
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬───
│смещение 31...16 от точки входа в програмный сегмент
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼───
│  │  │селектор прграмного сегмента-приемника│
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
	15 14 13 12 11 10 9  8	7  6  5  4  3  2  1  0
       ┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────┬──┐
       │P   DPL  0  0  1  0  1 │0  0  0 │     не ис-   │      4
					    пользуется
       ┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬──┘
       │смещение 15...0 от точки входа в програмный сегмент   0
       ┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
      Рис. 8.7 Вентиль прерываний для векторных прерываний
		      в ЗАЩИЩЕННОМ режиме.
   Определения полей вентиля прерываний
   1. Селектор	для  програмного  сегмента  -  приемника  именует
      програмный  сегмент,  содержащий	 программу   обслуживания
      прерываний. Этот селектор должен	ссылаться  на  програмный
      сегмент.
   2. Смещение точки входа идентифицирует точку входа в программу
      обслуживания прерывания.
   3. Права доступа указывают  на  разрешенные	формы  доступа	к
      вентилю,	 включая   требования	присутствия   и    уровня
      привилегированности.    Если   использование   вентиля   не
      соответствует   требованиям,    то    80386    вырабатывает
      исключительную ситуацию  по  общей  защите  (исключительную
      ситуацию 13).
  3а.  P  (присутствие)  указывает  доступен   ли   вентиль   для
      использования (P=1) или нет (P=0). Для  успешной	обработки
      по вектору должен присутствовать вентиль.
  3б. DPL (уровень  привилегированности   дескриптора)	указывает
      уровень привилегированности  вентиля. Аппаратное прерывание
      может всегда быть напроавлено по вектору с помощью  вентиля
      прерываний, если он помечен как присутствующий,  независимо
      от DPL  вентиля.	DPL  применяется  только  для  програмных
      прерываний (инструкции INT n, INTO, BOUND и  исключительные
      ситуации).  DPL  указывает на уровень   привилегированности
      вентиля числом 0, 1, 2, или 3 по следующему принципу

			     - 95 -
 Поле DPL│		   Дескриптор
 ────────┼────────────────────────────────────────────────────
    00	 │уровень 0 самый привилегированный (супервизор, ядро)
 ────────┼────────────────────────────────────────────────────
    01	 │уровень 1
 ────────┼────────────────────────────────────────────────────
    10	 │уровень 2
 ────────┼────────────────────────────────────────────────────
    11	 │уровень 3  низший уровень (пользователь)
   Для	програмных   прерываний   или	исключительных	 ситуаций
инструкции, использующие прерывания должны  иметь  СPL по крайней
мере такого же уровня привилегированности,  как  и  DPL  вентиля.
Например,   если   процессор   работает   на	текущем    уровне
привилегированности    3,   то	 програмные   прерывания    могут
использовать только вентили проерываний  с  DPL=3.  Любое  другое
значение DPL вентиля (т.е. 2, 1, или 0) будет указывать на  более
привилегированное   требование	переход  по  вектору  успешно  не
осуществится.  Вместо  этого  будет   выработана   исключительная
ситуация 13 (по общей защите).

       Передача управления с помощью вентиля прерывания.
	────────────────────────────────────────────────
   Когда   управление	передается   в	 программу   обслуживания
прерываний через вентиль прерываний, в стек засылаются 3  двойных
слова копия EFLAG, копия CS с младшим СЛОВОМ 0000   и копия EIP.
						  16
   Флаг IF в EIP затем очищается, исключая дальнейшие  прерывания
до того, как IF  снова не установится программным  образом     IF
обычно устанавливается в начале  программы  обслуживания  Регистр
EIP затем загружается из поля смещения вентиля	прерывания  и  CS
загружается из поля селектора  вентиля	прерываний.  80386  также
читает дескриптор, соответствующий полю селектора.    В  процессе
этой работы он загружает  в  свой  кэш	дескриптора  программного
сегмента  всю  информацию  дескриптора	-  база,границы  и  права
доступа.  80386 продолжает вызывать инструкцию со  смещением  EIP
-1ю инструкцию программы обслуживания.

	       Вентили системных прерываний.
		────────────────────────────
Векторный  элемент,  специально  спроектированный  для	векторных
програмных прерываний в ЗАЩИЩЕННОМ  режиме  -  вентиль	системных
прерываний - очень похож на вентиль прерываний, описанный на стр.
	 . Каждый вентиль системных прерываний состоит из ровно 8
байт - 2-х 32-битных двойных слова, содержащих полную  информацию
о векторе защиты для одного прерывания: селектор (который  должен
быть селектором програмного сегмента), смещение для  точки  входа
програмного сегмента и	уровень  привилегий,   назначенный  этому
вентилю. Рис.  8.8  иллюстрирует  вентиль  системных  прерываний.
Определения для  полей	вентиля  системных  прерываний	идентичны
соответствующим определениям вентиля прерываний.

			     - 96 -
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬───
│смещение 31...16 от точки входа в програмный сегмент
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼───
│  │  │селектор прграмного сегмента-приемника│
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
	15 14 13 12 11 10 9  8	7  6  5  4  3  2  1  0
       ┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────┬──┐
       │P   DPL  0  1  1  1  1 │0  0  0 │     не ис-   │      4
					    пользуется
       ┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬──┘
       │смещение 15...0 от точки входа в програмный сегмент   0
       ┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
      Рис. 8.8 Вентиль системных прерываний для векторных
		прерываний в ЗАЩИЩЕННОМ режиме.

		      Передача управления
		       ───────────────────
	    с помощью вентиля системных прерываний.
	     ──────────────────────────────────────
   Передача  управления  через	 вентиль   системных   прерываний
идентична  процессу  передачи  через   вентиль	 прерываний,   за
исключением того, что флаг IF в EFLAG не очищается. Это сохраняет
восприимчивость 80386 к  маскируемым  аппаратным  прерываниям  на
контакт INTR, что особенно удобно для  програмных  прерываний  по
вектору.

	     IDT (Таблица Дескриптора Прерывания).
	      ────────────────────────────────────
   IDT - это двойник таблицы прерываний по вектору, рассмотренной
в режиме REAL (см. Главу 6). IDT содержит только вентили,  но  не
дискрипторы.  Кроме  вентиля  прерываний,  и  вентиля	системных
прерываний, описанных в этой главе,    может  быть  тип  вентиля,
называемый вентилем задачи. Вентили задач, не  нужные  в  простых
32-битных системах с защитой, рассмотрены в главе 14.
   IDT содержит массив вентилей. Как показано на рис. 8.9, это	-
резидентная таблица со своей  базой  и	границей,  размещенной	в
линейном   адресном   пространстве,   в   области,   определенной
посредством системного регистра IDTR (см. стр.	   и  рис.  2.8).
IDTR принимает 48-битный операнд состоящий из 32-битнычй  базы	и
16-битной границы. Таким образом, база	IDT  может  находится  на
любом адресе в пределах линейного адресного пространства; граница
(максимальное смещение) может достигать 7FF16, охватывая  до  256
вентилей, пронумерованных от 0 до 255.	Вентиль  0  нахобится  по
базовому адресу IDT.
IDT может содержать только
   Вентили прерываний: стр.
   Вентили системных прерываний: стр.
   Вентили задач гл. 14

	       ИСПОЛЬЗОВАНИЕ УРОВНЕЙ ПРИВЕЛЛЕГИЙ
	       ─────────────────────────────────
Очевидно,  что	для  создания  надежных  систем для   програмного
обеспечения  большинства   ответственных   функций,   таких   как
ввод/вывод на диск например, - следует требовать гораздо большего
уровня	привилегированности,   чем  для  програмного  обеспечения
шаблонных  вычислений.	Также  очевидно,  что  некоторые  данные,
содержащие,  к	примеру,  ID-ы	и  ключи  пользователя,   следует
наделять высокими привилегиями. (т.е. сверхсекретные).	В  общем,
связь с супервизором надо контролировать. 80386 проектируется для
обеспечения  необходимой  защиты  путем  использования	механизма
привеллегий.

			     - 97 -
   В режиме защиты возможно до 4-х уровней привилегий.	4  уровня
обеспечивают подходящую грануллированность даже для самых сложных
систем. Однако, планирование минимальной системы делает возможным
использование	2-х   уровней	для   реального    двухуровневого
проектирования	системы  пользователь/супервизор.  В определенных
системах вы  можете  пожелать  использовать  по  крайней  мере	3
уровня,   посвящая   низший   уровень	прикладному   програмному
обеспечению пользователя  и  помещая  супервизор  среди  2-х  или
большего числа более привилегированных уровней.
   Никогда не  оказывается  случаев  использования  более  одного
уровня привилегий.  Вы можете найти  применения,  для  которых	и
один уровень привилегированности  вполне  достаточен.  Вам  может
требоваться  только  голая  скорость  вычислений   80386.   Когда
используется  только  1  уровень  привилегированности,	 в  любом
случае, он  должен  быть  уровня  0  -	самым	привилегированным
уровнем, так чтобы могли выполняться все команды 80386.

		 МЕХАНИЗМ МЕЖУРОВНЕВОЙ ПЕРЕДАЧИ
		  ──────────────────────────────
   Этот    раздел    описывает	  передачи     между	 уровнями
привилегированности.  Они   возникают,	 когда	 80386	 передает
управление   из   одного   програмного	 сегмента    с	  уровнем
привилегированности n  в  другой  програмный  сегмент  с  уровнем
привилегированности m. Такие передачи  легко  завершить  в  одном
направлении и, затем,  -  в  другом  -	отдельными  инструкциями,
такими как CALL (в более высокий уровень привилегированности),	и
RET (назад, в более низкий уровень привилегированности), или  INT
n (в более высокий уровень привилегированности) или IRET  (назад,
в более низкий).  Архитектура  80386  в  ЗАЩИЩЕННОМ  режиме,  как
описано в этой главе, легко выполняет эти передачи.
   Когда управление передается из одного  сегмента  в  другой,	в
регистр програмного сегмента и счетчик команд  80386  загружаются
новые значения. В соответствии с этим, инструкции выполняются  из
другой	 области.   Передача   управления   в	 новый	  уровень
привилегированности расширяет понятие передачи управления еще  на
шаг.
   Межуровневой передаче новый поток  инструкций  и  новый  стек.
Помимо	загрузки  новых  значений  CS  и  EIP,	как  при  обычной
передаче, также загружаются новыми значениями  регистр	стекового
сегмента и указатель стека. Загрузка CS:EIP и SS:EIP  согласована
с каждым уровнем привилегированности,  имеющим	свой  собственный
стек для обеспечения целостности стековой области при пользовании
уровнем супервизора.

	Инструкции INT n, используемые для межуровневой
	 ───────────────────────────────────────────────
	    передачи в простых ЗАЩИЩЕННЫХ системах.
	     ──────────────────────────────────────
   Как показано на рис. 8.10, передачи на более привилегированные
уровни можно осуществлять в  программы	супервизора  инструкциями
INT n. В конце программы инструкцией IRET достигается передача	в
обратную сторону.

			     - 98 -
	      4-Гбайтное линейное адресное пространство
		    31	 24 23	 16 15	  8 7	  0
		    ┌──────┬───────┬───────┬───────┐
	PPPPPPPP    │	   │	   │	   │	   │
		16  ├──────┼───────┼───────┼───────┤
		    │	   │	   │	   │	   │
		    ├──────┼───────┼───────┼───────┤
				   .
 линейный адрес 		   .
 база + граница 		   .
		    ├──────┴───────┴───────┼───────┤
	    ┌───────┼─Ў.вентиль N, N <= 255│	   │ граница
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    │ вентиль N - 1│	   │	   │
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    ├──────┼───────┼───────┼───────┤
	    │			   .
	    │			   .
	    │			   .
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    │ вентиль 1    │	   │	   │
	    │	    ├──────┼───────┼───────┼───────┤
	    │	    │	   │	   │	   │	   │
	    │	    ├──────┼───────┼───────┼───────┤
  линейный  │	    │ вентиль 0    │	   │	   │
  адрес     │	    ├──────┼───────┼───────┼───────┤
  база	    │	    ├──────┼───────┼───────┼───────┤
  ┌─────────┼───────┼──────┼───────┼───────┼──Ў.   │
  │	    │	    ├──────┼───────┼───────┼───────┤
  │	    │	    │	   │	   │	   │	   │ база
  │	    │	    ├──────┼───────┼───────┼───────┤
  │	    │			   .
  │	    │			   .
  │	    │			   .
  │	    │	    ├──────┼───────┼───────┼───────┤
  │	    │	    │	   │	   │	   │	   │ 00000000
  │	    │	    └──────┴───────┴───────┴───────┘	     16
  │	    │	     4-Гбайтное линейное адресное пространство
  │	    └───────────────────────┐
47│			    16 15   │	   0
┌─┴───────────────────────────┬─────────────┐
│32-битный линейный адрес базы│16-битная    │
│	    IDT 	      │граница IDT  │
└─────────────────────────────┴─────────────┘
      cистемный регистр IDTR (в 80386)
	 Рис. 8.4 Регистр IDTR размещает IDT в линейном
		     адресном пространстве.
 Инструкция для   │  Уровень		  │ Инструкция для
 передачи "вверх" │  привилегированности  │ передачи "вниз"
 ─────────────────┼───────────────────────┼───────────────
		  │00 уровень супервизора │
   INT n	  │01			  │   IRET
		  │10			  │
		  │11 уровень пользователя│
	     Рис. 8.10. Межуровневая передача через
	 програмное прерывание и возврат из прерывания.

			     - 99 -
	    Пути к более привилегированным уровням.
	     ──────────────────────────────────────
   Когда  в  качестве  вентиля	n  в  IDT   оказываются   вентиль
прерываний или вентиль системных  прерываний,  инструкция  INT	n
направляет его селектор и смещение через вентиль  в  определенный
приемник. Вентиль системных прерываний,  или  вентиль  прерываний
обеспечивает  передачу	управления  в  специальную  точку  входа,
которая может быть  на	более  высоком,  или  на  том  же  уровне
привилегированности как CPL инструкции INT n.
   Так	или  иначе,  передача  на  точку  входа   разрешается	в
зависимости от сравнения CPL инструкции INT n c  DPL  -  вентиля.
Применяется нормальное правило сравнения.  Если  CPL  по  крайней
мере того же уровня, что и DPL вентиля, то передача управления	с
помощью   вентиля   проходит   успешно.   В   противном    случае
генерируется   исключительная	ситуация    по	  общей    защите
(исключительная  ситуация  13)(см.  главу   16	 для   дальнейшей
информации по исключительным ситуациям в режиме защиты).
   Вентиль очевидно добавляет шаг косвенности к 	 процессу
достижения     программы      на     более     высоком	   уровне
привилегированности.  Однако, посредством этого вентиля  защищает
более привилегированную  программу разрешением доступа	только	в
том случае, если представлен вентиль  и  посредством  определения
точной точки входа в привилегированную программу.

		 Прозрачность для пользователя.
		  ─────────────────────────────
   Перенос  уровня  привилегированности  осуществляется  простыми
инструкциями INT n и IRET. Они прозрачны  для  пользователя,  так
как никаких специальных инструкций не требуется.
   Примечание: инструкции  CALL,  которые  ссылаются  на  вентили
вызова,  также	совершают  перенос   уровня   привилегированности
прозрачным образом. Вентили вызова обсуждены в	гл.  14.  В  этой
системе с защитой мы просто используем команды прерывания.
   Программа  супервизора   знает,   какие   инструкции   INT	n
осуществляют  уровневый  перенос   посредством	 контроллирования
содержания вентиля n, на который ссылается инструкция.	Например,
если  приемник	-  вентиль  k,	 селектор   которого   определяет
програмный сегмент такой  же  привилегированности,  как  CPL,  то
инструкция INT k только передает управление  служебной	программе
(CS:EIP загружаются новыми значениями). Однако, когда  инструкция
INT  q	определяет  вентиль  q,  селектор   которого   определяет
програмный сегмент более высокого уровня привилегированности,  то
имеет  место  автоматический  перенос  уровня  (CS:EIP	и  SS:ESP
загружаются новыми значениями).
   Соответственно, инструкция  IRET  проверяет	содержание  CS	в
стеке супервизора для определения DPL  приемника  возврата.  Если
DPL совпадает с CPL, имеет место  передача  без  переноса  уровня
(CS:EIP загружаются новыми значениями.) Если DPL ниже,	чем  CPL,
то происходит  снижение  уровня.  (CS:EIP  и  SS:ESP  загружаются
новыми значениями).

	       32-БИТНЫЙ СЕГМЕНТ СОСТОЯНИЯ ЗАДАЧИ
		──────────────────────────────────
   Сегмент состояния задачи - TSS первоначально  использовался	в
мультизадачных системах, как  рассмотрено  в  части  5.  В  таких
системах,  где	80386  обеспечивает  аппаратную   поддержку   для
большого количества задач,  32-битный  сегмент	состояния  задачи
создается для каждой 32-битной задачи для сохранения  содержимого
регистров задачи, когда задача	не  активна.  По  этим	причинам,
32-битный  сегмент  состояния  задачи  должен	быть   достаточно

			    - 100 -
большим, чтобы вместить всю необходимую информацию, относящуюся к
одной задаче. Для 32-битной задачи 32-битный TSS должен иметь, по
крайней мере, 104 байта в длину.
	Програмные замечания: Для  простой  32-битной  системы	с
защитой  TSS  служит  только  местом  хранения	указателя   стека
супервизора - SS:ESP. Это - как раз  тот  сегмент,  который  надо
об`являть вместе с дескриптором в GDT,	похожим  образом,  как	2
сегмента данных и 2 програмных сегмента, необходимых для  простой
системы.
   Для простой 32-битной системы с защитой в 32-битном TSS  почти
все нули, поскольку относятся к  полям,  не  нужным  для  простой
системы с защитой. Тем не менее, TSS  должен  иметь,  по  крайней
мере, 104 байта в длину,  как  показано  на  рис.  8.11.  У  него
относятся к делу поля SS и ESP для уровня 0. Эти  2  поля  должны
указывать   на	 начальные   SS:ESP,   используемые   для   стека
супервизора.

			Дескриптор TSS.
			 ──────────────
   32-битный сегмент состояния задачи из рис.  8.11  об`является,
как лежащий в специальном дескрипторе GDT. Такой  дескриптор  TSS
изображен на рис. 8.12. Определения полей, лежащих в  дескрипторе
TSS идентичны определениям в дескрипторе програмного сегмента, за
исключением:
   B (занято), который указывает - занята ли текущая задача (B=1)
или нет (B=0). Для простой системы с защитой этот бит должен быть
установлен в 1. Дальнейшие детали относительно поля B можно найти
в главе 14.
 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16
┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬────────────
│  │ база TSS	31...24 │G │0 │0 AVL│граница сегмента 19...16
├──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┬──┬──┬───
│  │  │  │  │  база TSS 15...0│  │  │  │  │  │
└──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴───
		 15 14 13 12 11 10 9  8  7  6  5  4  3	2  1  0
		┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
		│P │ DPL │0 │1 │0 │W │1 │  │ база TSS	23...16 │
		┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┼──┤
		│  │  │  │  │  │   граница TSS 15...0  │  │  │	│
		┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘
	  Дескриптор сегмента TSS для 32-битного TSS.
	      Рис. 8.12 Дескриптор для 32-битного
		   сегмента состояния задачи.

	      Инициализация TR (Регистра Задачи).
	       ──────────────────────────────────
Наконец, для запуска  32-битного  TSS  нужно  загрузить  селектор
дескриптора TSS в регистр  ЗАЩИЩЕННОГО	режима,  спроектированный
специально для этой цели - Регистр Задачи (TR).
   TR инициализируется загрузкой значения селектора в  регистр	с
помощью комманды LTR. Используемый селектор должен  ссылаться  на
дескриптор   TSS,  такой  как  на  рис.  8.12,	который  содержит
необходимый базовый адрес и информацию о  границе.  Регистр  кэша
дескриптора, связанный с регистром TR сохраняет внутреннюю  копию
дескрипторного поля TSS, как показано  на  рис.  8.13.	Используя
инструкции  LTR  для  загрузки	 дескриптора   LDT,   TSS   можно
расположить в любом месте линейного адресного пространства, и  он
может занимать до 64 К, как изображено на рис. 8.14.

			    - 101 -
31			      16 15				0
┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  100
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  96
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  92
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  88
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  84
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  80
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  76
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  72
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  68
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  64
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  60
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  56
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  52
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  48
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  44
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  40
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  36
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  32
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  28
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  24
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  20
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  16
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  12
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│ │ │ │ │SS для уровня 0│ │ │ │ │  8
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│ │ │ │ │ │ │ │ │ │ │ │ │ESP для уровня 0 │ │ │ │ │ │ │ │ │ │ │ │  4
├─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┼─┤
│0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0│  0
└─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
	 Рис. 8.11 32-битный Сегмент Состояния Задачи (TSS),
	  использующий только SS:ESP для стека супепвизора.

			    - 102 -
Регистр      КЭШ дескриптора сегмента (скрытая копия дескрип-
TR		     тора TSS на чипе)
┌────────┐   ┌──────────────────┬──────────────────┬────────────┐
│	 │   │32-битный линейный│20-битная граница │другие атри-│
│  TR	 ├──Ў│базовый адрес	│ (в байтах или    │буты	│
│	 │   │	  TSS		│	 страницах)│	P DPL B │
└────────┘   └──────────────────┴──────────────────┴────────────┘
	Рис. 8.13 Регистры КЭШа дескриптора для регистра TR.
   Заметим.  что  дескриптор  TSS  находится   в   GDT.   Поэтому
необходимо создать образ GDT и сначала	инциализировать  GDTR.	С
установлением GDT может выполняться инструкция LTR  для  загрузки
TR и посредством этого загружающая TSS.

	16-разрядный ТSS содержит следующую информацию:
   фиксированную часть,описывающую содержимое регистров,дополни-
тельную необязательную зону  памяти  за  фиксированной	частью,но
внутри зоны,обозначенной ограничителем ТSS.
	     32-разрядный ТSS содержит следующую информацию:
фиксированную часть,описывающую содержимое регистров,необязатель-
ную  битовую  карту  разрещенного  ввода/вывода,но  внутри   зоны
обозначенной ТSS
		    4-Гбайтное линейное адресное пространство
		    31	    24 23     16 15	 8 7	    0
		    ┼─────────┼─────────┼─────────┼─────────┼
		    │					    │FFFFFFFFh
		    ├───────────────────────────────────────┤
		    │					    │
		    ├───────────────────────────────────────┤
Линейный адрес: 			.
база+ограничитель   ├───────────────────────────────────────┤
     TSS	┌───┼─────Ў				    │
		│   ├───────────────────────────────────────┤
		│   │					    │
		│   ├───────────────────────────────────────┤
		│   │ Сегмент состояния задачи ТSS рис.4.11 │
		│   ├───────────────────────────────────────┤
		│			.
Линейный адрес: │   ├───────────────────────────────────────┤
база TSS.  ┌────┼───┼────────────────────────────────────Ў  │
	   │	│   ├───────────────────────────────────────┤
	   │	│   │					    │
	   │	│   ├───────────────────────────────────────┤
	   │	│			.
	   │	│			.
	   │	│   ├───────────────────────────────────────┤
	   │	│   │					    │00000000h
	   │	│   └───────────────────────────────────────┘
	   │	│    4-Гбайтное линейное адресное пространство
	   │	│
	   │	└────────────────────────┐
	   └─────────────┐		 │
			 │		 │
			 │		 │
15	  0   31	 │	   0 19  │	 0
├─────────┐   ├──────────┴──────────┼────┴───────┼──────────┐
│   TR	  │   │32-разрядный линейный│20-разрядный│остальные │
│	  │   │ базовый адрес ТSS   │ограничитель│антрибуты │
└─────────┘   └─────────────────────┴────────────┴──────────┘
 регистр TR   Кэш дескриптора сегмента TR (скрытый,хранит на
	      кристалле копию дескриптора LDТ)
Рис.8.14 Кэш дескриптора ТR  определяет  местоположение  простого
	 ТSS в линейном адресном пространстве.

