			     - 29 -
			  ГЛАВА 3

	     Система команд: краткое описание.
	──────────────────────────────────────────────
   Эта глава представляет все  команды	80386;	они  являются
расширением множества команд 8086  и  80286.  Эти  команды  в
сочетании   с	различными   режимами	адресации   80386-го.
предоставляют	пользователю   большую	 гибкость.    Способы
адресации 80386-го описаны в главах 4 и 7.
    Все множество команд доступно  как в 32-битном, так  и  в
16-битном режимах работы 80386. Главное различие при работе в
32-битном и 16-битном режимах состоит просто  в  принятой  по
умолчанию  длиной  операнда   и   размере   адреса,   которые
используются в командах. Этот принятый по  умолчанию  размер,
естественно, совпадает с операционным режимом:	он  равен  32
бита в 32-битном режиме и 16 битов в 16-битном.  Кроме	этого
различия каждая команда ведет себя одинаково в	любом  режиме
работы 80386.
   Команды выполняют следующие виды операций:
Перемещение данных		 Обработка строк
Целочисленной арифметики	 Десятичная арифметика
Булевские (логические)		 Управления программой
Вращение, сдвиг и двойной сдвиг  Управления системой
Манипуляции с битами		 Синхронизации данных
					 сопроцессора

	     Команды: краткое изложение.
     ──────────────────────────────────────────
Внутри этой  главы  некоторые  регистры  идентифицируются  по
имени. Дополнительно используются следующие обозначения:
genreg = любой общий регистр: EAX, EBX, ECX, EDX,  ESI,  EDI,
EBD, ESP(AX, BX, CX, DX, SI, DI, BP, SP - в 16-битном режиме.
segreg = любой сегментный регистр - CS, SS, DS, ES, FS, GS
d = смещение, d8 - смещение на 8 бит
<ea> = исполнительный адрес
<label> = метка программы ассемблера
#<data> = непосредственные данные; целое - литерал
stack = вершина стека, на который указывает SS:ESP
full   ptr   =	  полный    виртуальный    адрес    (селектор
сегмента: смещение)
C = бит переноса в регистре EFLAG; EFLAG бит 0
S = бит знака в регистре EFLAG; EFLAG бит 7
Z = бит нуля в регистре EFLAG; EFLAG бит 6
~ = логическая обратная величина
y = логическое И
x = логическое ИЛИ
s = логическое исключающее ИЛИ

	   Команды перемещения данных
     ────────────────────────────────────────
Команды перемещения данных позволяют перемещать операнды типа
BYTE, WORD, DWORD из памяти в регистр, из регистра в память и
из регистра в  рагистр.  Команды  PUSH,  PUSHA,  POP  и  POPA
допускают  операции  со  стеком,  если	регистр  ESP   неявно
используется  в  качестве  указателя   стека.  Значение этого
регистра   уменьшается	 перед	 каждой   командой   PUSH   и
увеличивается после каждой команды  POP.  Команды  IN  и  OUT
выполняют ввод/вывод на периферию  при	адресации  в  области
ввода/вывода.
   Кроме только что упомянутых команд, команды LCS, LSS, LDS,
LES, LFS, LGS также полезны при  операциях  с  адресами.  Они

			     - 30 -
позволяют загрузить компоненты селектора и  смещения  полного
виртуального адреса соответственно  в  сегментный  регистр  и
общий регистр.
   Далее, LEA (загрузка исполнительного адреса) в  комбинации
с режимом адресации База+Индекс * Шкала  является,  вероятно,
наиболее разносторонней командой  80386-го.  Не  упустите  ее
потенциал: она может быть использована	для  выполнения  всех
нижеизложенных	 функций.   Если   дополнительно   определена
константа, она может быть добавлена к результату, и  все  это
за одну двухтактную команду.
Пример	Синтаксис команды  Функция
LEA	EAX,[EBX]	   переместить значение
LEA	EAX,[EAX+EBX]	   прибавить по позиции
LEA	EAX,[EBX+ECX]	   прибавить и переместить результат
LEA	EAX,[EAX*4]	   умножить по позиции(*2, *4, *8)
LEA	EAX,[EBX*4]	   умножить и переместить результат
					       (*2, *4, *8)
LEA	EAX,[EAX+EAX*4]    умножить и прибавить по позиции
					       (*3, *5, *9)
LEA	EAX,[EAX+EBX*4]    умножить другую величину и сложить
LEA	EAX,[EBX+ECX*4]    умножить, сложить и переместить
					      результат
   Преобразование к большему  размеру  операндов  достигается
использованием команд MOVZX, MOVSX, CBW,  CWDE,  CWD  и  CDQ.
XLAT  предоставляет  возможность  преобразования  символов  с
помощью   трансляционной   таблицы   и	 также	 может	 быть
использована для  перевода  цепочки  символов  из,  например,
ASCII в EBCDIC.
   Региср EFLAG может быть протолкнут по стеку и вытолкнут из
него при использовании команд PUSHF и POPF. Команды CMC, CLC,
STC, CLD и STD изменяют биты  флага  переноса  и  направления
непосредсвенно.
	     Таблица 3.1 Команды перемещения данных
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
		 Общие для данных и адреса
─────────────────────────────────────────────────────────────
MOV	 Переместить <ea>,<ea>	  8,16,32  назначениеўисточн.
	 данные      <ea>,#<data> 8,16,32  назначениеўнепоср.
						      данные
XCHG	 Обмен	     <ea>,<ea>	  8,16,32  назначениеўисточн.
	 данными
PUSH	 Протолкнуть <ea>	  16,32    стекў<ea>
	 данные по   #<data>	  8,16,32  стекў#<data>
	 стеку
POP	 Вытолкнуть  <ea>	  16,32    <ea>ўстек
	 данные из
	 стека
PUSHA	 Протолкнуть		  8,16,32  стекўвсе genreg
	 общ.регистр
	 по стеку

			     - 31 -
       Продолжение таблицы 3.1 Команды перемещения данных
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
POPA	 Вытолкнуть		  8,16,32  все genregўстек
	 общ.регистр
	 из стека
IN	 Ввести      #<байт n>	  8,16,32  EAXў(I/O адрес n)
	 данные с				     [0-255]
	 порта	     [DX]	  8,16,32  EAXў(I/O адрес DX)
	 ввода/вывода				     [0-64K]
OUT	 Вывести     #<байт n>	  8,16,32  (I/O адрес n)ўEAX
	 данные на				 [0-255]
	 порт	     [DX]	  8,16,32  (I/O адрес DX)ўEAX
	 ввода/вывода				  [0-64K]
─────────────────────────────────────────────────────────────
		 Дополнительные для адреса
─────────────────────────────────────────────────────────────
LEA	 Загрузить   genreg,<ea>  16,32    genregў<ea>
	 исполнит.
	 адрес
LDS	 Загрузить   genreg,<ea>  32,48    DS:genregўfull ptr
	 full ptr в
	 DS:genreg
LES	 Загрузить   genreg,<ea>  32,48    ES:genregўfull ptr
	 full ptr в
	 ES:genreg
LFS	 Загрузить   genreg,<ea>  32,48    ES:genregўfull ptr
	 full ptr в
	 ES:genreg
LFS	 Загрузить   genreg,<ea>  32,48    FS:genregўfull ptr
	 full ptr в
	 FS:genreg
LGS	 Загрузить   genreg,<ea>  32,48    GS:genregўfull ptr
	 full ptr в
	 GS:genreg
LSS	 Загрузить   genreg,<ea>  32,48    SS:genregўfull ptr
	 full ptr в
	 SS:genreg
─────────────────────────────────────────────────────────────
		   Команды преобразования
─────────────────────────────────────────────────────────────
MOVZX	 Переместить genreg,<ea>  8,16,32  genregўZeroExt<ea>
	 данные с
	 расширением нуля
MOVSX	 Переместить genreg,<ea>  8,16,32  genregўSignExt<ea>
	 данные с
	 расширением знака

			     - 32 -
       Продолжение таблицы 3.1 Команды перемещения данных
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
CBW	 Преобразовать		  8	   AXўSignExt(AL)
	 байт в слово
CWDE	 Преобразовать WORD	  16	   EAXўSignExt(AX)
	 в расширенное
	 DWORD
CWD	 Преобразовать WORD	  16	   DX:AXўSignExt(AX)
	 в DWORD
CDQ	 Преобразовать DWORD	  32	  EDX:EAXўSignExt(AX)
	 в QUADWORD
XLAT	 Перевести байт     AL	  8	 ALў(EBX+ZeroExt(AL))
	 используя таблицу
	 перевода
─────────────────────────────────────────────────────────────
	  Перемещение и управление регистром EFLAG
─────────────────────────────────────────────────────────────
PUSHFD	 Протолкнуть EFLAG	16,32	 стекўEFLAG
	 по стеку
POPFD	 Вытолкнуть EFLAG	16,32	 EFLAGўстек
	 из стека
LAHF	 Загрузить		8     AHўEFLAG[7,0]
	 EFLAG[7,0]
	 в регистр AH
SAHF	 Записать		8     EFLAG[7,0]ўAH
	 регистр AH
	 в EFLAG[7,0]
CMC	 Дополнить бит		1     EFLAG[0]ўEFLAG[0]
	 флага переноса 		       ;перенос
CLC	 Очистить бит		1     EFLAG[0]ў0 ;перенос
	 флага переноса
CLD	 Очистить бит		1     EFLAG[10]ў0 ;направл.
	 флага направления
STC	 Установить бит 	1     EFLAG[0]ў1 ;перенос
	 флага переноса
STD	 Установить бит 	1     EFLAG[10]ў1 ;направл.
	 флага направления
─────────────────────────────────────────────────────────────

	  Команды целочисленной арифметики
	  ────────────────────────────────
Команды  целочисленной	арифметики  выполняют  арифметические
действия над операндами всех размеров  с  высокой  скоростью,
используя   четыре   функции.	Поддерживается	 знаковая   и
беззнаковая арифметика, и при всех операциях, кроме  деления,
допускаются операнды  непосредственных	данных.  Все  команды
умножения используют алгоритм с ранним выходом для уменьшения

			     - 33 -
времени исполнения команды пропорционально количеству нулей в
старших  разрядах  <ea>.  Команда  CMP	производит   знаковое
сравнение двух операндов,  результат  которого	отражается  в
регистре EFLAG; CMP не изменяет сами  операнды	(см.  таблицу
3.2).

	Булевские (логические) команды.
	──────────────────────────────
Булевские команды AND, OR, XOR, NOT и TEST доступны при любом
размере  операндов.  Во  всех  этих   командах	 могут	 быть
использованы   непосредственные    данные.    Команда	 TEST
осуществляет побитное логическое сложение операнда  с  нулем,
результат которого  отражается	в  регистре  EFLAG;  оператор
остается неизменным (см. таблицу 3.3).

       Команды вращения, сдвига и двойного сдвига
       ──────────────────────────────────────────
Команды вращения, сдвига и двойного сдвига в 80386 доступны с
любым размером операндов. Вычисление сдвига любого числа  (по
модулю 32)  выполняется  так  же  быстро,  как	и  однобитная
операция, за  счет  испольования  встроенного  в  чип  модуля
сдвига. Многобитные сдвиги  допускаются  даже  для  операндов
памяти. Вращения могут	исполняться  с	использованием	флага
переноса (RLC и ROR). Сдвиги могут быть арифметическими  (SAL
и SAR); их удобно использовать для умножения или  деления  на
степени двойки. Сдвиги могут быть также  логическими  (SHL  и
SHR); в них нули сдвигаются с любого конца. Новые  для	80386
команды двойного сдвига (SHLD и SHRD) позволяют  использовать
два 32-битных операнда в одной и той же  операции  сдвига.  С
помощью этих команд можно построить  очень  быстрые  операции
обрабтки полей битов (такие как вставка и перемещение болка),
при этом могут обрабатываться поля произвольной  ширины  (см.
таблицу 3.4).
Таблица 3.2 Команды целочисленой арифметики
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
ADD   Целочисленное  <ea>,<ea>	  8,16,32 назн.ўназн.+источн.
      сложение	     <ea>,#<data> 8,16,32 назн.ўназн.+непоср.
						      данные
		     <ea>,<ea>	  8,16,32 назн.ўназн.+источн.
ADC   Целочисленное				      +C
      сложение с
      флагом пере-   <ea>,#<data> 8,16,32 назн.ўназн.+непоср.
      носа					  данные+C
		     <ea>,<ea>	  8,16,32 назн.ўназн.-источн.
SUB   Целочисленное  <ea>,#<data> 8,16,32 назн.ўназн.-непоср.
      вычитание 				      данные
      Целочисленное  <ea>,<ea>	  8,16,32 назн.ўназн.-источн.
SBB   вычитание с				     +C
      флагом пере-   <ea>,#<data> 8,16,32 назн.ўназн.-непоср.
      носа					  данные-C
INC  Увеличение на 1 <ea>	  8,16,32 назн.ўназн.+1
DEC  Уменьшение на 1 <ea>	  8,16,32 назн.ўназн.-1

			     - 34 -
		    Продолжение таблицы 3.2
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
     Целочисленное   <ea>,<ea>	  8,16,32 назн.ўисточн.
CMP					   [влияет на EFLAG]
     сравнение	     <ea>,#<data> 8,16,32 назн.ўнепоср.данные
					   [влияет на EFLAG]
     Целочисленная   <ea>	  8,16,32 назн.ў0-назн.
NEG  смена знака
     Умножение	     <ea>	  8,16,32 EDX:EAXўEAX*<ea>
MUL  без знака			   [двойная точн. без знака]
IMUL Умножение	     genreg,<ea>  8,16,32 genregўgenreg*<ea>
     со знаком genreg,<ea>,#<data>8,16,32 genregў<ea>*immed
		     <ea>	  8,16,32 EDX:EAXўEAX*<ea>
     Деление без     <ea>
DIV  знака				  8,16,32 EDX:EAXўEAX*<ea>
     Деление со      <ea>
IDIV знаком				  8,16,32 EDX:EAXўEAX*<ea>
─────────────────────────────────────────────────────────────

	   Таблица 3.3 Булевские (логические) команды
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
AND   Булевское И    <ea>,<ea>	  8,16,32 назн.ўназн.yисточн.
		     <ea>,#<data> 8,16,32 назн.ўназн.yнепоср.
						    данные
OR    Булевское ИЛИ  <ea>,<ea>	  8,16,32 назн.ўназн.xисточн.
		     <ea>,#<data> 8,16,32 назн.ўназн.xнепоср.
						    данные
XOR   Булевское ИЛИ  <ea>,<ea>	  8,16,32 назн.ўназн.sисточн.
      исключающее    <ea>,#<data> 8,16,32 назн.ўназн.sнепоср.
						     данные
NOT   Булевское НЕТ  <ea>,<ea>	  8,16,32 назн.ў~источн.
TEST  Булевский тест <ea>,<ea>	  8,16,32 назн.y0FFFFFFFh
      на 0				  [влияет на EFLAG]
─────────────────────────────────────────────────────────────

			     - 35 -
    Таблица 3.4 Команды вращения, сдвига и двойного сдвига.
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
ROL  Вращение	     <ea>,#<data> 8,16,32
     налево	     <ea>,CL	  8,16,32
ROR  Вращение	     <ea>,#<data> 8,16,32
     направо	     <ea>,CL	  8,16,32
RCL  Вращение налево <ea>,#<data> 8,16,32
     через флаг      <ea>,CL	  8,16,32
     переноса
RCR  Вращение направо<ea>,#<data> 8,16,32
     через флаг      <ea>,CL	  8,16,32
     переноса
SHL  Логический      <ea>,#<data> 8,16,32
     сдвиг влево     <ea>,CL	  8,16,32
SHR  Логический      <ea>,#<data> 8,16,32
     сдвиг вправо    <ea>,CL	  8,16,32
SAL   Арифметический <ea>,#<data> 8,16,32
      сдвиг влево    <ea>,CL	  8,16,32
SAR   Арифметический <ea>,#<data> 8,16,32
      сдвиг вправо   <ea>,CL	  8,16,32
SHLD  Двойной	     <ea>,#<data> 8,16,32
      сдвиг влево    <ea>,CL	  8,16,32
SHRD  Двойной сдвиг  <ea>,#<data> 8,16,32
      вправо	     <ea>,CL	  8,16,32
─────────────────────────────────────────────────────────────

	Команды манипуляции битами
	──────────────────────────
С помощью команд BT, BTS,  BTR	и  BTC	может  осуществляться
прямая манипуляция битами. Указатель  выбранного  бита	может
задаваться непосредственной константой или  значением  общего
регистра. Команды сканирования	битов,	BSF  и	BSR,  находят
позицию первого значимого бита,  начиная,  соответственно,  с
младшего и старшего бита.

		   Команды обработки цепочек
		    ─────────────────────────
80386 непосредственно обрабатывает цепочки в  операндах  типа
BYTE, WORD и DWORD. Цепочка может  быть  обработана  в	любом
направлении,  в   зависимости	от   установки	 бита	флага
направления в EFLAG. Цепочки могут перемещаться, сравниваться
и сканироваться  для  нахождения  конкретного  значения;  они
также могут передаваться в область и из области ввода/вывода.
   Когда перед командой стоит индекс повторения,  выполняется
несколько  итераций  основных  функций.  Для  очень   быстрой
обработки повторяющиеся команды работают на полной или	почти
полной ширине шины. Префикс повторения может быть безусловным
(для  окончания  проверяется   только	ECX)   или   условным
(проверяется флаг условия или окончание по ECX).

			     - 36-
   Эти команды используют регистры ESI и EDI  для  ссылки  на
цепочки, являющиеся  операндами.  Перед  выполнением  команды
регистры  должны  содержать  необходимые  значения   адресов,
которые автоматически уменьшаются  или	увеличиваются  (после
выполнения) на размер операнда (в  байтах).  Когда  определен
префикс  повторения,  регистр  ECX  используется  в  качестве
счетчика итераций, позволяя выполнять  команду	до  тех  пор,
пока в ECX не окажется ноль.
    Таблица 3.5 Команды вращения, сдвига и двойного сдвига.
─────────────────────────────────────────────────────────────
Команда  Имя	     Синтаксис	  Размер   Операция
		     операнда	  операнда
─────────────────────────────────────────────────────────────
BT   Тест бита	  <ea>,#<data>	16,32  Cў(<номер бита>назн.)
		  <ea>,genreg	16,32
BTS  Тест и уста- <ea>,#<data>	16,32  Cў(<номер бита>назн.)
     новка бита   <ea>,genreg	16,32  бит назн.ў1
BTR  Тест и сброс <ea>,#<data>	16,32  Cў(<номер бита>назн.)
     бита	  <ea>,genreg	16,32  бит назн.ў0
BTC  Тест и допо- <ea>,#<data>	16,32  Cў(<номер бита>назн.)
     лнение бита  <ea>,genreg	16,32  бит назн.ў~бит назн.
BSF  Сканирование genreg,<ea>	16,32  genregўoffset
     бита вперед    скан. до значимого бита от младш. бита
BSR  Обратное	  genreg,<ea>	16,32  genregўoffset
     сканирование
     бита	    скан. до значимого бита от старш. бита
─────────────────────────────────────────────────────────────

	     Таблица 3.6 Команды обработки цепочек
─────────────────────────────────────────────────────────────
Команда    Имя		Размер	 Операция
			операнда
─────────────────────────────────────────────────────────────
MOVS	  Переместить	8,16,32  (ES:EDI)ў(ESI)
	  цепочку		 ESIўувел.или уменьш. ESI
	  данных		 EDIўувел.или уменьш. EDI
REP MOVS  С повторением 8,16,32  while ECX<>0
	  переместить		 (ES:EDI)ў(ESI)
	  цепочку		 ESIўувел.или уменьш. ESI
	  данных		 EDIўувел.или уменьш. EDI
CMPS	  Сравнить	8,16,32  (ES:EDI)ў(ESI)[устан. флаги]
	  цепочку		 ESIўувел.или уменьш. ESI
	  данных		 EDIўувел.или уменьш. EDI
REPE CMPS Повторяющееся 8,16,32  while ECX<>0 и усл. FALSE
(находит  сравнение		 (ES:EDI)ў(ESI)[устан. флаги]
первую	  цепочки данных	 ESIўувел.или уменьш. ESI
несовп.   при совпадении	 EDIўувел.или уменьш. EDI
порцию данных)			 ECXўECX-1[повтор команды]
─────────────────────────────────────────────────────────────

			     - 37 -
       Продолжение таблицы 3.6 Команды обработки цепочек
─────────────────────────────────────────────────────────────
Команда    Имя		Размер	 Операция
			операнда
─────────────────────────────────────────────────────────────
REPNE CMPS Повторяющееся 8,16,32  while ECX<>0 и усл. FALSE
(находит  сравнение		 (ES:EDI)ў(ESI)[устан. флаги]
первую	  цепочки данных	 ESIўувел.или уменьш. ESI
совп.	  при несовпадении	 EDIўувел.или уменьш. EDI
порцию данных)			 ECXўECX-1[повтор команды]
SCAS	  Сканировать	8,16,32 (ESI)ўAL/AX/EAX[устан. флаги]
	  цепочку		 ESIўувел.или уменьш. ESI
	  данных		 EDIўувел.или уменьш. EDI
REPE SCAS Повторяющееся 8,16,32  while ECX<>0 и усл. FALSE
	  сканирование		(ESI)ўAL/AX/EAX[устан. флаги]
	  цепочки данных	 ESIўувел.или уменьш. ESI
	  до несовп. с		 EDIўувел.или уменьш. EDI
	  AL/AX/EAX		 ECXўECX-1[повтор команды]
REPNE	  Повторяющееся 8,16,32  while ECX<>0 и усл. FALSE
SCAS	  сканирование		(ESI)ўAL/AX/EAX[устан. флаги]
	  цепочки данных	 ESIўувел.или уменьш. ESI
	  до совп. с		 EDIўувел.или уменьш. EDI
	  AL/AX/EAX		 ECXўECX-1[повтор команды]
LODS	  Загрузить	8,16,32  AL/AX/EAXў(ESI)
	  цепочку данных	 ESIўувел.или уменьш. ESI
	  в AL/AX/EAX		 EDIўувел.или уменьш. EDI
─────────────────────────────────────────────────────────────
REP LODS  Повторная загрузка бессмысленна. Не существует
─────────────────────────────────────────────────────────────
STOS	  Записать	8,16,32  (ESI)ўAL/AX/EAX
	  AL/AX/EAX		 ESIўувел.или уменьш. ESI
	  в цепочку данных	 EDIўувел.или уменьш. EDI
REP STOS  Повторять	8,16,32  while ECX<>0 do:
	  запись AL/AX/EAX	 (ESI)ўAL/AX/EAX
	  в цепочку данных	 ESIўувел.или уменьш. ESI
	  (заполнить		 EDIўувел.или уменьш. EDI
	  область памяти)	 ECXўECX-1[повтор команды]
INS	  Ввод данные	8,16,32  (EDI)ўпорт,задаваемый в DX
	  с порта в цепочку	 EDIўувел.или уменьш. EDI
REP INS   Повторяющийся 8,16,32  while ECX<>0 do:
	  ввод данных		 (EDI)ўпорт,задаваемый в DX
	  с порта		 EDIўувел.или уменьш. EDI
	  в цепочку		 ECXўECX-1[повтор команды]
OUTS	  Вывод данных	8,16,32  порт,задаваемый в DXў(ESI)
	  из цепочки		 ESIўувел.или уменьш. ESI
	  на порт
REP OUTS  Повторяющийся 8,16,32  while ECX<>0 do:
	  вывод данных		 порт,задаваемый в DXў(ESI)
	  из цепочки		 ESIўувел.или уменьш. ESI
	  на порт		 ECXўECX-1[повтор команды]
─────────────────────────────────────────────────────────────

			     - 38-
  Команды десятичной арифметики в двоичном коде (BCD команды)
   ──────────────────────────────────────────────────────────
Некоторые   команды   преобразуют   двоичные   операнды    для
упакованной и неупакованной BCD арифметики. Для неупакованного
сложения, вычитания и умножения команды AAA, AAS и AAM	должны
быть использованы после, соответственнно,  операций  сложения,
вычитания и умножения. При неупакованном делении  команда  AAD
должна	быть  использована  непосредственно  перед   операцией
деления.  Аппендикс  B	(Детальное   описание	команд)   дает
подробное описание работы этих BCD команд.
   Для упакованного BCD сложения и BCD вычитания за  операцией
должна следовать, соответственно, команда DAA или DAS.	Детали
можно посмотреть также в Аппендиксе B. Обратите внимание,  что
размер	операндов  этих  команд   приспособлен	 к   16-битным
операциям, поэтому для 32-битных операций на 80386 должны быть
проведены аналогичные преобразования  с  использованием  общих
команд.
	      Таблица 3.7. Команды BCD арифметики.
──────────────────────────────────────────────────────────────
Команда Имя		 Размер    Операция
			 операнда
──────────────────────────────────────────────────────────────
AAA   ASCII выравнивание 16    Выравнивание AL,если необходимо
      после сложения	       Уменьшение AH,если необходимо
AAS   ASCII выравнивание 16    Выравнивание AL,если необходимо
      после вычитания	       Уменьшение AH,если необходимо
AAM   ASCII выравнивание 16    AHўAL/10
      после умножения	       ALўAL MOD 10
AAD   ASCII выравнивание 16    ALў(AH*10)+AL
      перед деление	       ALў0
DAA   Десятичное BCD	  8    если AF=1,то выравнять нижний
      выравнивание после       полубайт регистра AL
      сложения		       если CF=1,то выравнять верхний
			       полубайт регистра AL
DAS   Десятичное BCD	 8     если AF=1,то выравнять нижний
      выравнивание после       полубайт регистра AL
      вычитания 	       если CF=1,то выравнять верхний
			       полубайт регистра AL
──────────────────────────────────────────────────────────────

		 Команды управления программой
		  ─────────────────────────────
Команды  условного  и  безусловного   перехода	 при   желании
позволяют програмные переходы. Команда установить байт условно,
SCC, позволяет подпрограммам эффективно возвращать  логическую
информацию о состоянии. Подпрограммы  и  программы  прерываний
могут быть вызваны, соответственно, командами CALL  и  INT  n.
Команды ENTER и LEAVE дают  удобную  возможность  создавать  и
удалять кадры  стека  и  поддерживают  концепцию  лексического
вложения, как она применяется при вложении процедур  в	языках
высокого уровня, таких как C.

			     - 39 -
	  Таблица 3.8. Команды управления программой.
──────────────────────────────────────────────────────────────
Команда Имя	     Синтакс. Размер	Операция
		     операнда операнда
──────────────────────────────────────────────────────────────
			  Условные
──────────────────────────────────────────────────────────────
JCC    Условный      <label> 8,16,32  если условие истинно, то
       переход			      EIPўEIP+d
       внутри сегмента
SCC    Установить    <ea>    8,16,32  если условие истинно, то
       байт условно		      <ea>ў1, иначе <ea>ў0
JECXZ  Переход по    <label> 8	      если ECX=0, то
       условию			      EIPўEIP+d
       ECX=0
LOOP   Перейти и     <label> 8	      если ECX<>0, то
       уменьшить ECX		       EIPўEIP+d
LOOPE  Перейти по    <label> 8	      ECXўECX-1
      условию			     если ECX<>0 и Z=1, то
       равенства и		      EIPўEIP+d
       уменьшить ECX
LOOPNE Перейти по    <label> 8	      ECXўECX-1
      уловию			     если ECX<>0 и Z=0, то
       неравенства		      EIPўEIP+d
       и уменьшить ECX
──────────────────────────────────────────────────────────────
			 Безусловные
──────────────────────────────────────────────────────────────
JMP    Безусловный   <label> 8,16,32  EIPўEIP+d
       переход	     <label> 48       EIPўfull ptr[31,0]
					  (поле смещения)
				      CSўfull ptr[47,32]
					  (поле селектора)
		     (<ea>)  8,16,32  EIPў(<ea>)
		     (<ea>)  48       EIPў(<ea[31,0]>)
				      (поле смещения full ptr)
				      CSў(<ea[47,32]>)
				      (поле селектора full ptr)

			     - 40 -
     Продолжение таблицы 3.8 Команды управления программой.
──────────────────────────────────────────────────────────────
Команда Имя	     Синтакс. Размер	Операция
		     операнда операнда
──────────────────────────────────────────────────────────────
		    <label> 8,16,32 SPўSP-4;(SP)ўEIP;EIPўEIP+d
CALL  Вызов под-    <label> 48	    SPўSP-4;(SP)ўCS;
      программы 		    SPўSP-4;(SP)ўEIP;
      (или задания)
				      EIPўfull ptr[31,0]
					  (поле смещения)
				      CSўfull ptr[47,32]
					  (поле селектора)
		     (<ea>)  8,16,32  SPўSP-4;(SP)ўEIP;
				      EIPў(<ea>)
		     (<ea>)  48       SPўSP-4;(SP)ўCS;
				      SPўSP-4;(SP)ўEIP;
				      EIPў(<ea[31,0]>)
				      (поле смещения full ptr)
				      CSў(<ea[47,32]>)
				     (поле селектора full ptr)
INT n Команда	   <label>  8	      SPўSP-4;(SP)ўCS;
      прерывания		      SPўSP-4;(SP)ўEIP;
				      EIPў(<ea[31,0]>)
				      (поле смещения full ptr)
				      CSў(<ea[47,32]>)
				     (поле селектора full ptr)
ENTER Создать кадр #<data1>, 8,16 Создать кадр стека c <data1>
      стека для    #<data2>	  байтами динамической памяти
      параметров		  и <data2> указателями стека,
      процедуры 		  скопированными из предыдуще-
				  го кадра стека
LEAVE Выход в процедуру      Освобождает область стека, испо-
      высокого уровня	     льзованную процедурой для своих
			     локальных переменных (совершает
			     действия обратные команде ENTER)
──────────────────────────────────────────────────────────────
			  Возвраты
──────────────────────────────────────────────────────────────
RET   Возврат		    IPў(SP);SPўSP+4;(внутри сегмента)
      подпрограммы	    IPў(SP);SPўSP+4;
			    CSў(SP);SPўSP+4;(между сегм.)
		 #<data> 16 IPў(SP)+immed.data;
			    SPўSP+4;(внутри сегмента)
			    IPў(SP)+immed.data;SPўSP+4;
IRET  Возвращение	    CSў(SP);SPўSP+4;(между сегм.)
      прерывания	    IPў(SP);SPўSP+4;
      (или задания)	    CSў(SP);SPўSP+4;
			 EFLAGў(SP);SPўSP+4;
──────────────────────────────────────────────────────────────

		  Команды управления системой
		   ───────────────────────────
Группа машинных  команд,  часто  используемых  программистами,
контролирует системные аттрибуты. Некоторые команды  позволяют
запомнить и загрузить регистры управления, отладки и  тестовые
регистры. Другие проверяют  аттрибуты  защиты  и  правильности
сообщения, используя биты флага нуля (ZF).

			     - 41 -
	    Таблица 3.9. Команды управления системой
──────────────────────────────────────────────────────────────
Команда Имя	     Синтакс. Размер	Операция
		     операнда операнда
──────────────────────────────────────────────────────────────
MOV    Поместить    CRn,<ea>  32	CRnў<ea>
       данные в     DRn,<ea>  32	DRnў<ea>
       системный    TRn,<ea>  32	TRnў<ea>
       регистр
MOV    Записать     <ea>,CRn  32	<ea>ўCRn
       данные из    <ea>,DRn  32	<ea>ўDRn
       системного   <ea>,TRn  32	<ea>ўTRn
       регистра
LMSW   Загрузить    <ea>      16	CRO[15..0]ў<ea>
       слово
       состояния
       машины
SMSW   Запомнить    <ea>      16	<ea>ўCRO[15..0]
       слово
       состояния
       машины
LIDT   Загрузить    <ea>      48	IDTў<ea>
       таблицу
       регистров
       дескриптора
       прерываний
LGDT   Загрузить    <ea>      48	GDTў<ea>
       таблицу
       регистров
       глобального
       дескриптора
LLDT   Загрузить    <ea>      16	LDTў<ea>
       таблицу
       регистров
       локального
       дескриптора
LTR    Загрузить    <ea>      16	TRў<ea>
       регистр
       задания
LIDT   Загрузить    <ea>      16	IDTў<ea>
       таблицу
       регистров
       дескриптора
       прерываний
SIDT   Запомнить    <ea>      48	<ea>ўIDT
       таблицу
       регистров
       дескриптора
       прерываний
──────────────────────────────────────────────────────────────

			     - 42 -
      Продолжение таблицы 3.9. Команды управления системой
──────────────────────────────────────────────────────────────
Команда Имя	     Синтакс. Размер	Операция
		     операнда операнда
──────────────────────────────────────────────────────────────
SGDT   Запомнить    <ea>      48	<ea>ўGDT
       таблицу
       регистров
       глобального
       дескриптора
SLDT   Запомнить    <ea>      16	<ea>ўLDT
       таблицу
       регистров
       локального
       дескриптора
STR    Запомнить    <ea>      16	<ea>ўTR
       регистр
       задания
──────────────────────────────────────────────────────────────
		 Проверка аттрибутов защиты
──────────────────────────────────────────────────────────────
LAR    Загрузить    genreg,   16,32  genregўправа доступа;
       права	    <ea>	     если верны,то Zў1,иначе
       доступа			     Zў0
LSL    Загрузить    genreg,   16,32  genregўграница сегмента;
       границу	    <ea>	     если верна,то Zў1,иначе
       сегмента 		     Zў0
VERR   Проверить    <ea>      16     если читаем, то Zў1,
       сегмент			     иначе Zў0
       на чтение
VERR   Проверить    <ea>      16     если запис., то Zў1,
       сегмент			     иначе Zў0
       на запись
ARPL   Выравнять    <ea>,     16     выравнять, чтобы RPL в EA
       поле RPL     genreg	     был не меньше, чем RPL в
       селектора		     genreg
──────────────────────────────────────────────────────────────
		     Управление машиной
──────────────────────────────────────────────────────────────
HALT   Остановиться		Стоять, пока не будет получено
       до прерывания		  прерывание
──────────────────────────────────────────────────────────────

	   Команда синхронизации данных сопроцессора
	    ─────────────────────────────────────────
Команда WAIT позволяет синхронизировать данные с математическим
сопроцессором  80287  и  80387.  В  то	 время,   как	данные
пересылаются  между  сопроцессором  и  памятью,  команда  WAIT
вызывает  ожидание   80386-ым	завершения   пересылки	 перед
выполнением   следующей   команды.    Синхронизация    данных,
гарантируемая командой WAIT, необходима только когда и 80386 и
математический	сопроцессор  работают  с  одним  операндом   в
памяти.

			     - 43 -
	Таблица 3.10 Команда синхронизации сопроцессора
──────────────────────────────────────────────────────────────
WAIT Ждать, пока сопроцессор	ждет, пока сигнал BUSY(занят)
      не освободится		не станет неактивным
──────────────────────────────────────────────────────────────
Префиксы команд
Перед командами 80386 могут быть помещены различные префиксные
байты.	Каждый	префиксный  байт,  если  присутствует,	меняет
работу команды, которая непосредственно следует за  ним.  Ниже
приведены пять типов префиксов:
   Размер операнда     меняет размер операнда по сравнению с
		       размером по умолчанию
   Размер адреса       меняет размер адреса по сравнению с
		       размером по умолчанию
   Смена сегмента      меняет выбор сегмента по сравнению с
		       выбором по умолчанию
   Запереть шину       активизирует сигнал шины LOCK#
   (LOCK)	       (по умолчанию "не активен")
   Повторить	       повторить  команду  обработки  цепочек
		       согласно числу итераций в регистре ECX
   Каждый префикс, показанный на рис. 3.1, имеет  единственную
цель. Префикс размера операнда и префикс размера адреса влияют
на размер операнда и размер адреса, как было об`яснено в главе
2.  Префикс  смены  сегмента  изменяет	 выбор	 сегмента   по
умолчанию, как показано  в  таблице  2.6.  Для	выбора	любого
текущего сегмента вместо сегмента по умолчанию	префикс  смены
сегмента доступен для каждого сегментного регистра:CS, SS, DS,
ES, FS и GS, как  показывает  рис.  3.1.  Префикс  LOCK  может
активизировать выходной сигнал 80386, который сообщает	другим
процессорам (если таковые имеются),  что  шина	заперта  и  не
должна прерываться. И наконец,	префикс  повторения  позволяет
выполнить итерации команд обработки цепочек, как было  описано
ранее.
      7 бит	    0 бит
      0│1│1│0│0│1│1│0
Префикс размера операнда: 66 шестнадцатеричное
      0│1│1│0│0│1│1│1
Префикс размера адреса: 67 шестнадцатеричное
      0│0│1│0│1│1│1│0
Префикс смены CS: 2E шестнадцатеричное
      0│0│1│1│0│1│1│0
Префикс смены SS: 36 шестнадцатеричное
      0│0│1│1│1│1│1│0
Префикс смены DS: 3E шестнадцатеричное
      0│0│1│0│0│1│1│0
Префикс смены ES: 26 шестнадцатеричное	Рис.3.1. Префиксы команд.
      0│1│1│0│0│1│0│0
Префикс смены FS: 64 шестнадцатеричное
      0│1│1│0│0│1│0│1
Префикс смены GS: 65 шестнадцатеричное
      1│1│1│1│0│0│0│0
Префикс запирания шины: F0 шестнадцатеричное
      1│1│1│1│0│0│1│0
Префикс повторения: F2 шестнадцатеричное
      1│1│1│1│0│0│1│0
Префикс повторения, если не равно: F2 шестнадцатеричное
      1│1│1│1│0│0│1│1
Префикс повторения, если равно: F3 шестнадцатеричное

			     - 44 -
   Часто  одной  команде  необходимо   предпослать   несколько
префиксов.  Например,  для константы может  использоваться   и
префикс смены сегмента и  префикс  размера  операнда.  Порядок
префиксов различных типов  не  имеет  значения.  Однако,  если
несколько префиксов одного типа (например, несколько префиксов
смены сегмента) предшествуют одной команде, выполняется только
последний. Команды длиной 16 байтов и более (возможные	только
при избытке префиксов) являются иллегальными.
   Префикс  LOCK   может   предшествовать   только   некоторым
командам, а именно тем,  которые  производят  обмен  данных  в
регистрах с памятью и некоторым из  тех,  которые  работают  с
операндами  назначения	памяти.   Конкретно,   формы   команд,
допускающих префикс LOCK, таковы:
XCHG <mem EA>,genreg  ;Обмен памяти с регистром (80286 и
		      ;80386 автоматически запирают эту
		      ;команду)
XCHG genreg,<mem EA>  ;обмен регистра с памятью (80286 и
		      ;80386 автоматически запирают эту
		      ;команду)
ADD  <mem EA>,genreg  ;Сложить с операндом памяти
ADD  <mem EA>,genreg  ;Сложить, используя флаг переноса
SUB  <mem EA>,genreg  ;Вычесть из операнда памяти
SBB  <mem EA>,genreg  ;Вычесть, используя флаг переноса
NEG  <mem EA>	      ;Произвести отрицание операнда памяти
OR   <mem EA>,genreg  ;ИЛИ с операндом памяти
AND  <mem EA>,genreg  ;И с операндом памяти
XOR  <mem EA>,genreg  ;Исключающее ИЛИ с операндом памяти
NOT  <mem EA>	      ;Логическое НЕТ с операндом памяти
BTC  <mem EA>	      ;Дополнить битовый операнд в памяти
BTR  <mem EA>	      ;Сбросить битовый операнд в памяти
BTS  <mem EA>	      ;Установить битовый операнд в памяти
   Если префикс LOCK  помещен  перед  другой  командой	(кроме
вышеперечисленных),определяется иллегальная команда (См. главы
6 и 16 за дальнейшей информацией, касающейся нарушений). Из-за
наличия страничной  поддержки  в  80386,  он  намного  сильнее
ограничивает употребление префикса LOCK, чем 8086 и 80286. Оно
должно	быть  ограничено,  потому  что	в   такой   страничной
организации,  которую  предоставляет  80386,  нет  возможности
гарантировать	выполнение,   например,   успешного   LOCK   в
повторяющейся команде обработки цепочек. Операционная  система
может  быть  вынуждена	вмешаться  для	 обслуживания	ошибки
страницы,  тем	самым  прервав	 предположительно   "запертую"
команду.
   Однако  существует  и  выигрышный  аспект   в   ограничении
употребления префикса LOCK, так как  теперь  это  употребление
может контролироваться. Для 80386  префикс  LOCK  доступен  на
всех приоритетных  уровнях,  в	то  время  как	для  80286  он
доступен только на уровне высшего  приоритета.	Это,  конечно,
значит, что  прикладные  программы  80386  могут  при  желании
использовать префикс LOCK. В качестве типичного  использования
можно привести "запертые" команды  ADD  и  SUB,  полезные  для
вычисления переменных, являющихся семафорами.

			 Формат команд
			  ─────────────
Форматы команд должны  быть  как  можно  более	компактными  и
эффективными; для 80386 самая  короткая  команда  имеет  длину
один байт. К этому байту может	быть  добавлена  информация  о
коде команды и об адресах. Все команды имеют минимум один байт
и максимум пятнадцать байтов длины (включая префиксные байты).

			     - 45 -
В общем случае, команда 80386 (см. рис. 3.2) состоит из байтов
префиксов (по выбору), байтов кода операции (до двух  байтов),
байтов режима адресации (до двух байтов), байтов смещения  (до
четырех байтов), и байтов непосредственных данных (до  четырех
байтов).
младшие адреса памяти			 старшие адреса памяти
	 код	  код
│префикс│	 │	  │mod r/s│s-1-b│  │  │  │  │  │  │  │
	 операции операции
					 смещение	данные
					   (1,2 или 4 байта)
	      Рис. 3.2 Общий формат команды 80386.
   Если команда содержит неопределенные байты  кода  операции,
80386 сигнализирует об исключительной  ситуации  неправильного
кода операции (ситуация 6). Если команда становится длиннее 15
байтов за счет	избытка  префиксов,  сигнализируется  ситуация
общей защиты (ситуация 13). Смотрите главы 6  и  16  за  более
широким охватом исключительных ситуаций процессора.

			   ЧАСТЬ  II
      16-битное программирование: реальный режим 80386
       ────────────────────────────────────────────────
   Благодаря 16-битному реальному режиму в 80386  существующие
для 8086/8088 программы могут идти на 80386 и быстрее, чем это
было возможно ранее. Совместимость реального  режима  очевидно
притягивает   многих   пользователей   8086/8088,   хотя   она
представляет только верхушку айсберга возможностей 80386.
   Цель данной	части  состоит	в  полном  и  точном  описании
реального режима 80386, включая рассмотрение всех  новых  черт
80386,	 касающихся   реального   режима.   Для    тщательного
рассмотрения реального режима 80386 в этой части  представлены
дополнительные	команды,   дополнительные   префиксы   команд,
дополнительные регистры, и даже дополнительные	исключительные
ситуации, которые детектируются 80386-ым.

			   Глава 4
	    Адресация памяти в 16-битных режимах
	     ────────────────────────────────────
   Эта	глава  об`ясняет  адресацию  памяти в  совместимым   с
8086/8088  реальном  режиме  и	в   совместным	 с   8086/8088
виртуальным  8086  режиме.  Так  как   оба   режима   являются
8086/8088-совместимыми,  режимы   адресации,   доступные   при
16-битном  программировании,  идентичны   в   обоих   режимах.
Единственной  разницей	между  реальным  и  виртуальном   8086
режимами  является  доступность  постраничной  организации   в
виртуальном 8086 режиме. Однако, страничная организация обычно
контролируется	32-битной  основной  программой   и   является
прозрачной для 16-битных программ.
   Эта	глава  фокусирует  внимание   на   16-битных   режимах
адресации. В этих режимах исполнительный адрес вычисляется как
сумма трех компонентов 16-битного  адреса:  базы,  смещения  и
индекса. Поэтому исполнительный адрес также является 16-битной
величиной.  Общий  процесс  16-битной  адресации  показан   на
рисунке 4.1, а 16-битной адресации, использующей  постраничную
организацию - на рис. 4.2.

			     - 46 -
   Исполнительный адрес рассматривается как смещение  от  базы
текущего  сегмента  памяти.  Поэтому,  второй  шаг  при  любом
16-битном режиме адресации состоит в прибавлении базы сегмента
к исполнительному адресу. Адрес базы сегмента -  это  значение
селектора, умноженное на 16, или, как показывают  рис.	4.1  и
4.2, значение селектора, сдвинутое на  четыре  позиции	влево.
Таким  образом,  адрес	базы   сегмента   является   20-битной
величиной,  и  линейный  адрес	также	становится   20-битной
величиной.
   16-битные режимы работы обеспечивают пространство  линейных
адресов в 2 в 20 степени байт, другими словами, один  мегабайт
памяти. Это  прямой  результат	16-битных  режимов  адресации,
которые, благодаря  4-битному  сдвигу  адреса  базы  сегмента,
генерирует 20-битный линейный адрес.
   Вожможны  различные	 комбинации   компонентов   16-битного
адреса, использующие подмножества доступных компонент. Простые
режимы используют  только  один  компонент,  а	более  сложные
используют больше.
   Большинство	 режимов   адресации   является   регистровыми
режимами непрямой адресации. Они применимы к адресации	данных
и программ. 80386 представляет также режимы непрямой адресации
памяти, они, однако, применимы только к адресации программ. На
последующих  страницах	 описаны   и   проиллюстрированы   все
16-битные режимы адресации. Обратите внимание, что эти примеры
тщательно демонстрируют модуль	выполняемого  сложения,  чтобы
показать, поддерживается или теряется перенос сложения.
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр	   │		  │  База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──┬───────────┘
					     │
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │расширение	│    ∙	Сложение по
Смещение  │		 │ знака	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
Индексный │		 │		│    ∙	Сложение по
регистр   │		 │   Индекс	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		  Селектор │	│    ∙	Сложение по
сегмента  │00000000000000 сегмента │0000│───Ў+		32
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ЛИНЕЙНЫЙ
					     │ АДРЕС -
					     │
					     │ ФИЗИЧЕСКИЙ
					     │ АДРЕС
			   31		     ∙		 0
			   ┌─────────────────────────────┐
	Физический адрес:  │ Физический адрес		 │
			   └─────────────────────────────┘
Рис. 4.1 Вычисление 16-битного	адреса	(Реальный  режим,  без
страничной организации).

			     - 47 -
	   Введение в страничную организацию памяти.
	    ────────────────────────────────────────
В  виртуальном	8086  режиме   80386   предлагает   встроенную
поддержку   виртуальной    памяти    посредством    страничной
организации. Страничная организация, если она позволена, - это
процесс  перевода,  выполняемый  над  линейным	адресом  перед
доступом  к  памяти.  Шестнадцатибитная   адресация,   включая
страничную  организацию,   проиллюстрирована   на   рис 4.2  и
применена  к  виртуальному  8086  режиму.  В  реальном	режиме
страничная организация не допускается.
   Страничная трансляция преобразует 32-битный линейный  адрес
-  расширенную	форму	20-битного   линейного	 адреса.   Как
показывает рис. 4.2, трансляция  страницы  приводит  к	замене
верхних 20 битов исполнительного адреса  на  другую  20-битную
величину. Смещение является  функцией  оригинальной  20-битной
величины, использующей таблицу страниц -  резидент  в  памяти.
Этот раздел рассматривает страничную организацию, так как  она
связана со всем  процессом  перевода  адреса.  Но  это	просто
введение в страничную организацию,  которая  будет  описана  в
главе 3. Оставшаяся часть этой	главы  описывает  формирование
16-битного адреса.
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр	   │		  │  База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │расширение	│    ∙	Сложение по
Смещение  │		 │ знака	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
Индексный │		 │		│    ∙	Сложение по
регистр   │		 │   Индекс	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		  Селектор │	│    ∙	Сложение по
сегмента  │00000000000000 сегмента │0000│───Ў+		32
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
				  ┌──────────┤ ЛИНЕЙНЫЙ
				  │	     │ АДРЕС
			   31	  ∙	 12 1│1 	 0
			   ┌─────────────────│─ ─ ─ ─ ─ ─┐
			   │Трансляция стра│ │ СМЕЩЕНИЕ  │
      Трансляция страницы: │ницы биты 31-12│ │ СТРАНИЦЫ  │
			   └─────────────────│─ ─ ─ ─ ─ ─┘
				  │	     │
				  │	     │ ФИЗИЧЕСКИЙ
				  │	     │ АДРЕС
			   31	  ∙	     ∙		 0
			   ┌─────────────────────────────┐
	Физический адрес:  │ Физический адрес		 │
			   └─────────────────────────────┘
Рис.  4.2  Вычисление  16-битного  адреса  (Виртуальный   8086
режим, со страничной организацией).

			     - 48 -
		   Прямые регистровые режимы
		    ─────────────────────────
Прямые регистровые режимы требуют, чтобы операнд  находился  в
одном из восьми общих  регистров,  одном  из  шести  об`ектных
регистров или в одном из системных регистров.

	     Прямой режим с общим регистром
	     ──────────────────────────────
Операнд находится в общем регистре, специфицированном  в  поле
R/M. Использованный размер регистра может быть 8,16 и 32 бита,
в зависимости от размера операнда данных команды.
Вычисление:	      EA=genreg
Синтаксис Ассемблера: genreg
MOD:		      00
Регистр:	      reg, r/m
			       31	      15      7      0
			       ┌ ─ ─ ─ ─ ─ ─ ─┬───────┬──────┐
			       │	      │ 	     │
Общий регистр: genreg ─────────┼─────────────Ў│   Операнд    │
			       │	      │ 	     │
			       └ ─ ─ ─ ─ ─ ─ ─┴───────┴──────┘

	    Прямой режим с сегментным режимом
	    ─────────────────────────────────
Операнд находится в  сегментном  регистре,специфицированном  в
поле регистра. Обратите внимание, что этот режим адресации  не
использует байт MOD R/M. Вместо этого он использует поле  SREG
команды, из которого загружаются или  в  который  запоминаются
сегментные регистры.
Вычисление:	      EA=segreg
Синтаксис Ассемблера: segreg
Регистр:	      SREG
					      15	     0
					      ┌──────────────┐
					      │ 	     │
Сегментный регистр: segreg ──────────────────Ў│   Операнд    │
					      │ 	     │
					      └──────────────┘

		    Непосредственные режимы
		     ───────────────────────
Непосредственная   адресация   подразумевает,	что    операнд
содержится в самой команде. Режим  непосредственной  адресации
может специфицировать только операнд источника, но не  операнд
назначения. Непосредственный операнд  может  быть  байтом  или
словом.  Режим	непосредственной  адресации  не   определяется
байтом MOD R/M; вместо	этого  некоторые  коды	команд	неявно
определяют  использование   непосредственной   адресации   для
операнда источника. Те же команды могут однако	включать  байт
MOD R/M для определения операнда назначения.
Вычисление:	      EA=#<data>
Синтаксис Ассемблера: data
Opcode: 	     Некоторые	 коды	 операций    неявно
	   определяют использование непосредственных данных

			     - 49 -
			       31	      15       7     0
			       ┌ ─ ─ ─ ─ ─ ─ ─┬────────┬─────┐
			       │	      │расш.	     │
Расширение команды:   ─────────┼─────────────Ў│знака	     │
			       └ ─ ─ ─ ─ ─ ─ ─┴────────┴─────┘
						  Операнд

		  Непрямые регистровые режимы
		   ───────────────────────────
Эти режимы адресации определяет то, что  операнд  находится  в
сегменте памяти и содержимое одного или  нескольких  регистров
используется  для  вычисления  исполнительного	адреса	внутри
сегмента.  Затем  прибавляется	адрес	базы   сегмента,   что
формирует 20-битный линейный адрес операнда.

	 Непрямой режим с базовым регистром
	 ──────────────────────────────────
Регистры SI,DI,BX или  BP  могут  служить  базовым  регистром,
содержащим адрес операнда памяти.
Вычисление:	      EA=(genreg)
Синтаксис Ассемблера: (genreg)
R/M:		      100,101,110,111
Базовый регистр:      SI,DI,BX,BP
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр:──────────────────Ў   База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
					     │
	  31		 15	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬─────────┬────┐    │
	  │		 │Селектор	│    ∙	Сложение по
сегмента  │00000000000000│сегмента  0000│───Ў+		32
	  │		 │		│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴─────────┴────┘    │
					     │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

	Непрямой режим с базовым регистром и смещением
	──────────────────────────────────────────────
Регистры SI,DI,BX или  BP  могут  служить  базовым  регистром,
содержащим   адрес,   который	прибавляется	к    смещению,
расширенному знаком. Затем прибавляется адрес  сегмента  базы,
что формирует 20-битный линейный адрес операнда.
Вычисление:	      EA=(genreg)
Синтаксис Ассемблера: (genreg)
R/M:		      100,101,110,111
Базовый регистр:      SI,DI,BX,BP

			     - 50 -
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр:──────────────────Ў│  База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │расширение	│    ∙	Сложение по
Смещение  │		 │ знака	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │	ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000├───Ў+		32
	  │		 │	   │	│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

       Непрямой режим с базовым и индексным регистром
       ──────────────────────────────────────────────
Пары регистров	BX+SI,	BX+DI,	BP+SI  и  BP+DI  могут	каждая
служить в качестве базового и  индексного  регистров,  которые
складываются для формирования исполнительного адреса  операнда
памяти. Затем, для формирования 20-битного  линейного  адреса,
добавляется адрес базы сегмента.
Вычисление:	      EA=(genreg)+(genreg)
Синтаксис Ассемблера: (genreg)+(genreg)
R/M:		      000,001,010,011
Базовый регистр:      BX+SI,BX+DI,BP+SI,BP+DI
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр:──────────────────Ў│  База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
Индексный │		 │		│    ∙	Сложение по
регистр   │		 │   Индекс	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  │		 │	   │	│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

			     - 51 -
    Непрямой режим с базовым и индексным режимом и смещением
     ────────────────────────────────────────────────────────
Пары регистров	BX+SI,	BX+DI,	BP+SI  и  BP+DI  могут	каждая
служить в качестве базового и  индексного  регистров,  которые
складываются  со   смещением,	расширенному   знаком.	 Сумма
формирует исполнительный адрес	операнда  памяти.  Затем,  для
формирования 20-битного линейного  адреса,  добавляется  адрес
базы сегмента.
Вычисление:	      EA=(genreg)+(genreg)+Расш(смещение)
Синтаксис Ассемблера: (genreg)+(genreg)+constant
R/M:		      000,001,010,011
Базовый регистр:      BX+SI,BX+DI,BP+SI,BP+DI
			   31		  15		 0
			   ┌── ─ ─ ─ ─ ─ ─┬──────────────┐
			   │		  │		 │
       Базовый регистр:──────────────────Ў│  База	 │
			   │		  │		 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
					     │
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		  расширение │	│    ∙	Сложение по
Смещение  │		   знака     │	├───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
Индексный │				│    ∙	Сложение по
регистр   │		     Индекс	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
					     │
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  │		 │	   │	│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │
					     │ ЛИНЕЙНЫЙ
					     │
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

			    Смещение
			     ────────
Исполнительный адрес  определяется  как  абсолютный  16-битный
сдвиг от базы сегмента. Значение  смещения  задается  в  самой
команде.

			     - 52 -
	  31		 15		0
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
Смещение  │		 │ Смещение	│────┐
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

   Непрямой режим с регистром SP и предварительным уменьшением
   ───────────────────────────────────────────────────────────
Для команд PUSH, PUSHA, CALL и	INT  n,  регистр  SP  содержит
адрес операнда памяти. Перед  использованием  регистра	SP  он
уменьшается на размер операнда данных, который вталкивается  в
стек.
Вычисление:	      SP=SP-размер операнда
		      EA=SP
Синтаксис Ассемблера: Неявный с командами PUSH, PUSHA,
		      CALL и  INT  n
Базовый регистр:      SP
			   31		  15		0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬─────────────┐
Регистр SP:	 ────────────────────────Ў│   База	│
			   └ ─ ─ ─ ─ ─ ─ ─┴─────────────┘
					     │	    °
					     │	    │
					     │	    │
					     ∙	    │
Размер операнда: ──────────────────────────Ў -	    │
					     ├──────┘
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  │		 │	   │	│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

			     - 53 -
    Непрямой режим с регистром SP и последующим увеличением
     ───────────────────────────────────────────────────────
Для команд POP, POPA, RET и IRET  регистр  SP  содержит  адрес
операнда памяти. После использования регистр увеличивается  на
размер операнда данных, который только что  был  вытолкнут  из
стека.
Вычисление:	      EA=SP
		      SP=SP+размер операнда
Синтаксис Ассемблера: Неявный с командами POP, POPA,
		      RET и IRET
Базовый регистр:      SP
		    31		   15		 0
		    ┌ ─ ─ ─ ─ ─ ─ ─┬─────────────┐
Регистр SP:───────────────────────Ў│   База	 │
		    └ ─ ─ ─ ─ ─ ─ ─┴─────────────┘
					 °   │
					 │   │
Размер операнда: ──────────────────────Ў +   │
					 °   │
					 │   │
					 └───┤ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес памяти:		   │	   Операнд		 │
			   └─────────────────────────────┘

		   Непрямые режимы памяти
		   ──────────────────────
Соответствующие формы команд JMP и  CALL  используют  непрямую
адресацию. Режимы непрямой адресации предлагают  всю  гибкость
регистровых непрямых режимов,  которые	описаны  в  предыдущем
разделе.
   Для команд JMP и CALL  внутри  кодового  сегмента  непрямая
адресация памяти работает  следующим  образом:	для  генерации
16-битного смещения суммируются компоненты  адреса,  а	затем,
для    формирования    двадцатибитного	  линейного    адреса,
прибавляется адрес базы сегмента. Этот участок памяти содержит
16-битный  исполнительный  адрес  команды  назначения	внутри
текущего кодового сегмента.
   Для команд JMP и CALL, вызывающих другой  кодовый  сегмент,
непрямая адресация  памяти  работает  следующим  образом:  для
генерации 16-битного смещения суммируются компоненты адреса, а
затем,	 для   формирования   20-битного   линейного   адреса,
прибавляется адрес базы сегмента. Этот участок памяти содержит
полный	 адрес	 (16-битный   исполнительный   адрес   команды
назначения и 16-битный селектор кодового сегмента назначения).
Все 32 бита полного  адреса  загружаются  и  используются  для
выборки программы назначения.

			     - 54 -
Вычисление:	      EA=[(genreg)+(genreg)+Расш(смещение)]
Синтаксис Ассемблера: ptr(genreg)+(genreg)+constant
R/M:		      000,001,010,011,100,101,110,111
Базовый регистр:      BX+SI,BX+DI,BP+SI,BP+DI,SI,DI,BX,BP
			   31		  15		 0
			   ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐
       Базовый регистр:──────────────────Ў│  База	 │
			   └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │расширение	│    ∙	Сложение по
Смещение  │		 │ знака	├───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
	  31		 15		0    │
	  ┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
Индексный │		 │		│    ∙	Сложение по
регистр   │		 │   Индекс	│───Ў+		16
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
					     │
					     │ ИСПОЛНИТЕЛЬНЫЙ
					     │	  АДРЕС
─	─	 ─	   ─	     ─	     │	─	  ─
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000├───Ў+		32
	  │		 │	   │	│    │	модулю 2
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │
					     │	ЛИНЕЙНЫЙ
					     ∙	АДРЕС
			   31		  15		 0
			   ┌─────────────────────────────┐
Непрямой адрес памяти:	   │ Непрямой адрес памяти	 │
			   └─────────────────────────────┘
					     ∙
			   31		  15		 0
			   ┌─────────────────────────────┐
			   │	   Смещение от		 │
Смещение команды:	   │непрямого адреса памяти	 │
			   └─────────────────────────────┘
					     │
				       Указывает на
	  31		  14	  4 3	0    │
Адрес базы┌ ─ ─ ─ ─ ─ ─ ─┬──────────────┐    │
	  │		 │Селектор │	│    ∙	Сложение по
сегмента  │00000000000000│сегмента │0000│───Ў+		32
	  └ ─ ─ ─ ─ ─ ─ ─┴──────────────┘    │	модулю 2
		от непрямого адреса памяти   │
					     │ ЛИНЕЙНЫЙ
					     ∙ АДРЕС
			   31				 0
			   ┌─────────────────────────────┐
Адрес команды:		   │ Адрес назначения команды	 │
			   └─────────────────────────────┘

	    Кодирование режимов 16-битной адресации
	     ───────────────────────────────────────
Большинство команд задают местоположение операнда  байтом  MOD
R/M. Для большинства команд байт MOD R/M полностью  определяет
режим  адресации,  использованный  для	операнда  источника  и
операнда  назначения.  Либо  операнд  источника  либо  операнд
назначения является общим регистром. Второй операнд может быть

			     - 55 -
общим  регистром  или  адресом	памяти.  Если  второй  операнд
является адресом памяти, это определяет режим адресации. Чтобы
определить оба операнда, байт MOD R/M содержит три поля.
		    Байт 0	   Байт 1
		   (кодоп)	  (MOD R/M)
	      ├─┬─┬─┬─┬─┬─┬─┬─┼─┬─┬─┬─┬─┬─┬─┬─┐
	       * * * * * * * *
	      └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
			       ┌───┘ ┌─┘ ┌───┘
				REG  MOD  R/M
			       └───┘ └───────┘
			    Операнд 1 Операнд 2
Рис.4.3. Двухоперандная инструкция с байтом MOD R/M.
   Байт MOD R/M  следует  за  байтом  (байтами)  кода  команды
80386, как показано на рис. 4.3. Байт MOD R/M делится  на  три
поля, показанные на рисунке. Трехбайтное поле  REG  определяет
регистровый операнд. Двубитное поле MOD определяет является ли
второй операнд также регистровым; если является,  то  3-битное
поле R/M определяет другой регистровый операнд. Если, с другой
стороны, поле MOD показывает, что операнд находится в  памяти,
то поля MOD  и	R/M  вместе  определяют  использованный  режим
адресации.
   Таблица  4.1  определяет  поля  MOD	R/M  и	включает   все
16-битные  режимы  адресации  памяти.  Заметьте,  что  в  этих
режимах используются только регистры DX,SI,DI,BP. (Регистр  SP
неявно	 используется	для   адресации    памяти    командами
PUSH,POP,PUSHA,POPA,CALL  и  INT  n).  Когда  режим  адресации
задает только базовый регистр, базой могут  являться  регистры
DX,SI,DI, или BP. Когда специфицированы  базовый  и  индексный
регистры, то такими парами могут быть BX+SI,BX+DI,BP+SI,BP+DI.
Смещение может задаваться как 16-битныя величина или  8-битная
величина (расширенная со знаком до 16 бит).
   Возможны  различные	 комбинации   компонент   адреса   при
использовании байта MOD R/M, как показано в таблице 4.1.
 Таблица 4.1 Определение байта MOD R/M для 16-битной адресации
		       (MOD R/M)
		   ┼─┬─┬─┬─┬─┬─┬─┬─┐
		   ┴─┴─┴─┴─┴─┴─┴─┴─┘
		    ┌───┘ ┌─┘ ┌───┘
		     REG  MOD  R/M
		    └───┘ └───────┘
		 Операнд 1 Операнд 2

			     - 56 -
REG  Операнд 1 =	     MOD  R/M  Операнд 2 =
──────────────────────	     ────────────────────────────
000  регистр EAX/AX/AL	     00   000  память DS:[BX+SI]
001  регистр ECX/CX/CL	     00   000  память DS:[BX+DI]
010  регистр EDX/DX/DL	     00   000  память SS:[BP+SI]
011  регистр EBX/BX/BL	     00   000  память SS:[BX+DI]
100  регистр ESP/SP/AH	     00   000  память DS:[SI]
101  регистр EBP/BX/CH	     00   000  память DS:[DI]
110  регистр ESI/SI/DH	     00   000  память DS:d16
111  регистр EDI/DI/BH	     00   000  память DS:[BX]
──────────────────────	     ────────────────────────────
			     01   000  память DS:[BX+SI+d8]
			     01   000  память DS:[BX+DI+d8]
			     01   000  память SS:[BX+SI+d8]
			     01   000  память SS:[BX+SI+d8]
			     01   000  память DS:[SI+d8]
			     01   000  память DS:[DI+d8]
			     01   000  память DS:[BX+d8]
			     01   000  память DS:[BP+d8]
			     ────────────────────────────
			     01   000  память DS:[BX+SI+d16]
			     01   000  память DS:[BX+DI+d16]
			     01   000  память SS:[BX+SI+d16]
			     01   000  память SS:[BX+SI+d16]
			     01   000  память DS:[SI+d16]
			     01   000  память DS:[DI+d16]
			     01   000  память DS:[BX+d16]
			     01   000  память DS:[BP+d16]
			     ────────────────────────────
			     10   000  регистр EAX/AX/AL
			     10   001  регистр ECX/CX/CL
			     10   010  регистр EDX/DX/DL
			     10   011  регистр EBX/BX/BL
			     10   100  регистр ESP/SP/AH
			     10   101  регистр EBP/BX/CH
			     10   110  регистр ESI/SI/DH
			     10   111  регистр EDI/DI/BH
─────────────────────────────────────────────────────────

			     - 57 -
			    Глава 5
	     Детальное описание 16-битных команд
	      ───────────────────────────────────
   В  этой  главе   обсуждаются   команды   80386,   как   они
используются программистом в реальном режиме.
   В 16-битном реальном режиме	команды  сконструированы  так,
что они функционируют так же, как и на 8086. Доступны  размеры
операндов в 8 бит и  16  бит,  и  16-битные  режимы  адресации
используются  так,  как  это  описано  в  главе  4.  Все   это
поддерживает совместимость с 8086 в 16-битных режимах.
   Однако в эти режимы проникают некоторые новые черты	80386.
Следовательно, строго говоря, реальный	режим  80386  является
более эффективным, чем 8086 или реальный режим 80286. Регистры
отладки  80386	доступны  в  16-битных	режимах,  и  16-битные
утилиты  отладчика  могут   использовать   их	для   создания
дополнительных	возможностей  отладки.	Два  новых  сегментных
регистра,  FS  и  GS,  могут  использоваться   для   повышения
эффективности программ. Доступны операции манипуляции с битами
и операции двойного сдвига, а также регистры теста  страниц  и
управляющие  регистры,	хотя   они   необходимы   только   при
подготовке к вхождению в защищенный режим.

		       Доступность команд
			──────────────────
   В 16-битном реальном режиме 80386 имеет 32  новые  команды,
по сравнению с реальным режимом 80286. В реальном режиме 80386
доступны новые, использующие полное  смещение,	формы  команды
JCC (условный переход) и полная форма команды IMUL  (Умножение
целых со знаком). Таблица 5.1 представляет все эти  дополнения
в реальном режиме и сравнивает их с системой команд 8086.
   Таблица 5.1 особенна интересна при написании программы  для
разных поколений 86. Она  приводит  команды  и	формы  команд,
которые можно использовать для оптимизации программ для  80286
и 80386 в реальном режиме.
   Таблица 5.1 Команды реального режима, недоступные на 8086.
──────────────────────────────────────────────────────────────
Дополнения в   Дополнения в
реальн. режиме реальн. режиме  Описание
80286	       80386
──────────────────────────────────────────────────────────────
BOUND	       BOUND	       проверить границы массива
ENTER	       ENTER	       создать кадр стека
IMUL #<data>   IMUL #<data>    непоср. умножение со знаком
INS	       INS	       ввод цепочки
LEAVE	       LEAVE	       устранить кадр стека
OUTS	       OUTS	       вывод цепочки
POPA	       POPA	       вытолкнуть общие регистры
PUSHA	       PUSHA	       протолкнуть общие регистры
PUSH #<data>   PUSH #<data>    протолкнуть данные
REP INS        REP INS	       повтор ввода цепочки
REP OUTS       REP OUTS        повтор вывода цепочки
shift/rotate   shift/rotate    сдвиг/вращение по непосредств.
by count       by count        счетчику
	       BT	       тест бита
	       BTC	       тест бита и дополнение
	       BTR	       тест бита и сброс
	       BTS	       тест бита и установка
	       IMUL общая      умн. общего регистра со знаком
	       MOV CRn	       перем. в/из регистр управления
	       MOV DRn	       перем. в/из регистра отладки
	       MOV TRn	       перем. в/из регистра теста стр.
	       Jcc full displ  условный перех. - полное смещ.
	       Scc	       установить байт условно
	       SHLD	       двойной сдвиг влево
	       SHRD	       двойной сдвиг вправо

			     - 58 -
──────────────────────────────────────────────────────────────
Дополнения в   Дополнения в
реальн. режиме реальн. режиме  Описание
80286	       80386
──────────────────────────────────────────────────────────────
		 Команды защищенного режима
CLTS	       CLTS	       очистить флаг перкл. задания
    *		   *
LIDT	       LIDT	       загрузить регистр IDTR
SIDT	       SIDT	       запомнить регистр IDTR
    *		   *
LGDT	       LGDT	       загрузить регистр GDTR
SGDT	       SGDT	       запомнить регистр GDTR
    *		   *
LMSW	       LMSW	       загрузить слово сост. машины
SMSW	       SMSW	       запомнить слово сост. машины
──────────────────────────────────────────────────────────────
;
 Эти команды защищенного режима доступны в реальном режиме при
 подготовке инициализации защищенного режима.
   Однако  не  все  команды  80386  (помещенные   в   таблицах
3.1-3.10) доступны в  реальном	режиме	80386.	Девять	команд
защищенного режима, которые не могут  исполняться  в  реальном
режиме, представлены в таблице 5.2.
Таблица 5.2 Команды 80386, недоступные в реальном режиме
──────────────────────────────────────────────────────────────
Мнемониа команды  Описание
──────────────────────────────────────────────────────────────
LTR		  загрузить регистр задания
STR		  запомнить регистр задания
LLDT		  загрузить локальный дескриптор табл. рег.
SLDT		  запомнить локальный дескриптор табл. рег.
ARPL		  настроиться на уровень приоритета
LSL		  загрузить границу сегмента
LAR		  загрузить право доступа
VERR		  проверить право доступа по чтению
VERW		  проверить право доступа по записи
──────────────────────────────────────────────────────────────
   Первые четыре команды недоступны, потому что регистры TR  и
LDTR недоступны и не требуются в реальном режиме, а  последние
пять  недоступны,  потому  что	концепции  уровня  приоритета,
настраиваемой границы  сегмента  (в  реальном  режиме  граница
всегда 64 Кбайт) и  прав  доступа  не  существуют  в  реальном
режиме.

		     Доступность префиксов
		      ─────────────────────
Все  префиксы  80386,  показанные  на  рис.  3.1,  доступны  в
реальном режиме. Префиксы размера операнда и размера адреса, в
частности, могут добавить новые возможноти в  программирование
в реальном режиме, так как они	допускают  32-битные  операнды
данных и 32-битные режимы  адреса.  Эти  префиксы  могут  быть
полезными в программировании в реальном режиме	для  32-битных
операций.
   Префикс размера  операнда  позволяет  легко	манипулировать
32-битными операндами данных. Например, использование префикса
размера операнда позволяет 80386 в реальном  режиме  выполнять
арифметические	 операции   над   32-битными   операндами    и
обрабатывать цепочки по 32 бита за одну операцию.
   Доступный  в  реальном  режиме   префикс   размера	адреса
открывает доступ к 32-битным режимам адресации,  рассмотренным
в   главе   7.	 Например,   он   может    использоваться    в

			     - 59 -
масштабированной индексной адресации. Правильное использование
префикса размера адреса  в  реальном  режиме  требует  большой
осторожности, потому  что  необходимо  избегать  генерирование
больших   исполнительных   адресов.    Исполнительный	 адрес
превышающий  65535  в  реальном  режиме  выходит  за   границу
сегмента, которая в этом режиме  фиксирована  и  равна	65535.
Поэтому для успешного использования префикса размера адреса  в
реальном  режиме  биты	31-16  регистров,  применяющихся   при
адресации, и сумма компонент адреса не должна превышать  65535
(потому  что  в   32-битных   режимах	адресации   компоненты
			32	  16
складываются по модулю 2   ,а не 2   ).
   Подытоживая,   следует   сказать,   что   при    аккуратном
использовании  префиксы  размера  операнда  и	адреса	 могут
расширять  возможности	программ  в   реальном	 режиме.   Для
полностью нового  32-битного  программирования	должен	однако
рассматриваться  защищенный  режим,  так  как  в  этом	режиме
размеры сегмента и пространства линейных адресов много больше,
чем в реальном режиме.

	   Предел размера сегмента в реальном режиме
	    ─────────────────────────────────────────
В реальном режиме максимальный размер сегмента равен 64  Кбайт
или 65536 байт. Поэтому граница сегмента  равна  0FFFFh  (т.е.
64K-1 или 65535 байт) - максимально допустимый байт  смещения.
Этот предел в реальном	режиме	устанавливается  автоматически
для всех сегментов и  поэтому  требует,  чтобы	исполнительный
адрес не превышал 64K-1. В случае многобайтных операндов  этот
предел требует, чтобы весь операнд имел  смещение  не  большее
64K-1. В реальном режиме попытка доступа к операндам,  которые
полностью или  частично  лежат	за  64K-1  пределом  сегмента,
вызовет  нарушение.  Чтобы  избегать   таких   нарушений,   не
позволяйте операндам лежать за границей 64K-1 и  будьте  очень
аккуратны при любом  использовании  префикса  размера  адреса,
т.к. вычисление  32-битного  адреса  может  легко  привести  к
смещению, превышающему границу 64K-1, разрешенную  в  реальном
режиме. Нарушения границы сегмента далее описаны в главе 6.

			   Глава 6
	  Прерывания и исключения в реальном режиме
	   ─────────────────────────────────────────
Эта глава описывает реакцию 80386 на  возникающие  в  реальном
режиме прерывания и  исключения.  Как  и  следует  ожидать,  в
реальном режиме реакция 80386 очень похожа  на	реакцию  8086.
Перед более глубоким погружением в реакции  процессора	опишем
подробно сами события.
   Прерывания  и  исключения  -  похожие  типы	событий.   Оба
приостанавливают текущую операцию 80386 и передают  управление
сервисной программе обработки прерываний или  исключений.  Они
вызывают переход 80386 от текущего потока команд  к  сервисной
программе обработки события.  Различия	между  прерываниями  и
исключениями   возникают   из-за   различных   источников   их
возникновения:	Прерывания  возникают  из-за  важных  внешених
событий, сигналы которых  поступают  на  80386	на  выделенные
контакты; исключения возникают из-за  внутренних  условий  или
проблем, которые детектирует 80386.

			     - 60 -
	     Распознование прерываний и исключений
	      ─────────────────────────────────────
С  точки  зрения   программиста,   прерывания	и   исключения
распознаются на границе команд, то есть они распознаются после
того, как одна команда завершилась и перед тем, как  следующая
команда началась. Это упрощает	жизнь  программиста,  особенно
при взаимодействии с исключениями, так как  он	обходится  без
нюансов временных внутренних  регистров  80386	или  состояний
ожидания.  80386  выполняет  всю   необходимую	 поддержку   и
служебные действия автоматически и обрабатывает  прерывания  и
исключения ровно на границе команд.

			   Прерывания
			    ──────────
Прерывания обеспечивают аппаратный механизм, позволяющий 80386
взаимодействовать  с  внешним	окружением,   которое	обычно
включает  многообразные  внешние  события,  случающиеся  через
непредсказуемые интервалы времени. Наступление такого  события
может быть сигнализировано 80386 по  одному  из  двух  входов:
INTR (маскируемый вход прерываний) или NMI (немаскируемый вход
прерываний).  Эти  два	входных   контакта   80386   посвещены
сигнализации прерываний.
   Вход INTR индицирует  активное  прерывание,	управляемое  с
высокого  уровня.  Этот  сигнал,  который  можно   маскировать
программно, позволяется, когда IА бит EFLAGа установлен в 1, и
не позволяется, когда он установлен в 0.
   Сигнал  NMI	индуцирует  активное  прерывание,   вызываемое
нарастающим   фронтом,	 и   поэтому   не   требующее,	 чтобы
поддерживался высокий уровень на  длительный  период.  NMI  не
маскируется программно:  он  всегда  позволяется.  NMI	обычно
резервируется  для  наиболее   критических   прерываний,   для
прерываний, которые сигнализируют о фатальных условиях,  таких
как сбой питания или некорректируемый сбой памяти.

		      Аппартные прерывания
		       ────────────────────
Внутри систем на 80386 многие периферийные  устройства,  такие
как диски, таймеры, принтеры и другие  важные  приборы,  могут
вызывать   прерывания.	 Такие	 общие	  прерывания	обычно
направляются на вход INTR 80386.  Так  как  вход  INTR	только
один, прерывания от многих приборов логически складываются для
формирования	сигнала INTR от многих приборов. Чтобы достичь
быстрой реакции на прерывание, желательно сразу же  определить
источник прерывания.
   Когда  активизируется  сигнал  INTR,  сразу	же  происходит
идентификация благодаря использованию  специального  цикла,  в
течении которого 80386 читает ряд нижних байтов  шины  данных.
Этот ряд, от 00h до  FFh,  называется  вектором  прерываний  и
обычно поставляется микросхемой контроллера прерываний,  8239A
или  эквивалентной.  Номер  прерывания	указывает   80386   на
конкретный  указатель,	резидентно  находящийся  в  памяти,  -
вектор, с  помощью  которого  80386  выбирает  первую  команду
программы обработки прерываний.
   Когда, однако, активизируется вход NMI, никакой специальный
цикл не выполняется и  вектор  не  читается,  потому  что  NMI
автоматически связывается с номером прерываний 02h. Для  этого
прерывания  вектор  02h  посвящен  обслуживанию   критического
немаскируемого вектора прерываний; при возникновении NMI 80386
передает управление программе обработки прерываний  с  номером
02h.

			     - 61 -
		       Векторы прерываний
			──────────────────
В реальном режиме вектора прерываний являются полными адресами,
в стиле 16-битной адресации: 16-битный	селектор  и  16-битное
смещение, как показано на рис. 6.1  Вектор  прерывания	-  это
адрес  входа  в  программу,   использующуюся   для   обработки
прерываний. Таким образом,  вектор  прерываний	перенаправляет
80386 на программу обработки прерываний.
   Вектор прерываний  также  служат  для  передачи  управления
80386 в случае определения исключения, как  показано  на  стр.
72.

      Вектор прерываний в реальном режиме
      ───────────────────────────────────
(содержит точку входа в программу обработки прерываний)
	15		     0 15		     0
	──────────────────────────────────────────────
	     Селектор		16-битное смещение
	──────────────────────────────────────────────
Рис. 6.1 Вектор прерываний в реальном режиме  является	полным
адресом (full ptr)

		  Таблица векторов прерываний
		   ───────────────────────────
Как  было   упомянуто,	 все   вектора	 прерываний   являются
резидентами в памяти и образуют  массив  векторов,  называемый
таблицей  векторов  прерываний.  Эта  таблица,	находящаяся  с
линейного адреса 0, состоит из 256  векторов,  индексированных
от  вектора  0	до  вектора  255,  что	конечно  соответствует
возможной величине числа векторов  прерываний. Важно:  вектора
аппаратных прерываний должны быть пронумерованы от 32 до  255.
Прерывания от  0  до  31  зарезервированы  для	исключительных
ситуаций, определяемых 80386.  Таким  образом,	прерывание  32
передает управление, используя	вектор	32;  и	так  далее  до
прерывания 255. Таблица векторов прерываний показана  на  рис.
6.2.
31	      16 15	       0
┌───────────────┬──────────────┐
│ Селектор 255	│ Смещение 255 │Вектор 255 по адресу 000007FCh
├───────────────┼──────────────┤
│ Селектор 254	│ Смещение 254 │Вектор 254 по адресу 000007F8h
├───────────────┼──────────────┤
│ Селектор 253	│ Смещение 253 │Вектор 253 по адресу 000007F4h
├───────────────┼──────────────┤
		.	       .
		.	       .
├───────────────┼──────────────┤
│ Селектор 2	│ Смещение 2   │Вектор 2   по адресу 00000008h
├───────────────┼──────────────┤
│ Селектор 1	│ Смещение 1   │Вектор 1   по адресу 00000004h
├───────────────┼──────────────┤
│ Селектор 0	│ Смещение 0   │Вектор 0   по адресу 00000000h
└───────────────┴──────────────┘
Это иллюстрирует  местоположение  и  размер  таблицы  векторов
прерываний в реальном режиме после установки. На  самом  деле,
команда LIDT может быть использована  в  реальном  режиме  для
установки базы таблицы векторов прерываний и ее границы, но  в
этом случае продолжение работы в реальном режиме  создаст  его
нестандартное окружение.
Рис. 6.2 Таблица векторов прерываний в реальном режиме

			     - 62 -
Замечание:  Архитектура  IBM   PC   противоречит   предыдущему
замечанию, т.е.  аппартное  прерывания	не  используют	номера
векторов  от 0 до  32.	BIOS  PC   инициализирует   микросхему
контроллера прерываний 8259А для использования	векторов  8-15
для аппартных прерываний. Потенциально это может  приводить  к
конфликтному   использованию   различных   номеров    векторов
прерываний.
   Таблица  векторов   прерываний   также   используется   для
перенаправления 80386 в  случае  определения  исключения,  как
показано ниже в этой главе.


	      Выполнение программ обработки прерываний
	      ────────────────────────────────────────
Программы обработки прерываний -  это  программы,  выполняемые
при  передаче  управления  80386  согласно  таблице   векторов
прерываний.  Обычно  это  программы,   обслуживающие   прибор,
вызвавший прерывание. Данная программа n, для  прерывания  или
исключения  n,	может  быть  активизирована   аппаратным   или
программным управлением, как показано ниже:
Аппаратное управление. Если маскируемые  прерывания  позволены
(флаг IF=1), происходит активизирование INTR и выборка вектора
n. Когда высокий уровень на входе INTR активизирует  программу
обработки  прерываний  n,  флаг  IF   устанавливается	в   0,
предотвращая дальнейшую активизацию любой  программы  сигналом
INTR до тех пор, пока флаг IF не будет установлен в 1.	Сигнал
NMI активизирует программу обработки прерываний 2,  независимо
от значения флага IF.
   Когда нарастающий фронт  активизирует  программу  обработки
прерываний 2 по сигралу NMI,  флаг  IF	устанавливается  в  0,
предотвращая активизацию любых программ по INTR.  Более  того,
пока не будет выполнена команда IRET (обычно в конце программы
обработки прерываний 2), другой  нарастающий  фронт  не  будет
активизировать эту  программу.	Это  предотвращает  порождение
многочисленных	 вложенных   вызовов	программы    обработки
прерываний 2 при  возникновении  неровного  растущего  фронта.
Однако один растущий фронт NMI запоминается, если он возникает
в  течениии  служебной	 программы   NMI;   затем   он	 снова
активизирует  программу  обработки  прерываний	2  как	только
закончится первый вызов (если быть более точным, как только он
выполнит команду IRET ).
Замечание  по  совместимости:  8086   и   8088	 не   запирают
последующие сигналы NMI после  того,  как  произойдет  первый.
Если по некоторой причине вы захотите, чтобы 80286  или  80386
также воспринимал  последующие	NMI,  выполните  команду  IRET
ранее  в  программе  NMI.  Чтобы  исполнить  IRET  находясь  в
программе обработки NMI, посторойте сначала кадр стека с тремя
командами PUSH, так что IRET "вернется" к  следующей  команде,
как показано ниже:
NMI_ENTRY:  PUSHP
	    PUSH    CS
	    PUSH    NEXT_INSTR	;выталкивает смещение команды,
				;следующей за IRET
	    IRET
NEXT_INSTR			;IRET ВОЗВРАЩАЕТСЯ СЮДА. Будут
				;восприняты NMI, если случатся
	     .			;тело	программы   обработки
	     .			; прерываний NMI
	     .
	    IRET		;

			     - 63 -
Программное управление. Выполняется команда INT  n  независимо
от состояния  флага  IF.  Когда  команда  INT  n  активизирует
программу обработки прерываний n, флаг IF не  устанавливается;
это  позволяет	аппаратным  прерываниям  прерывать   программы
обработки прерываний, вызванных  программно.  Это  необходимое
соглашение поддерживает реакцию 80386 на аппаратные  средства,
окружающие систему.

		   Обработка прерываний
		   ────────────────────
Обработка  прерываний  -  это  действия  80386	 по   передаче
управления программе  обработки  прерываний.  При  активизации
INTR, эти действия  включают  чтение  с  шины  номера  вектора
прерываний, запоминания состояния  текущей  программы,	чтение
соответствующего вектора  прерываний,  и  переход  по  адресу,
находящемуся в векторе прерываний. Если  прерывание  поступает
по NMI или по INTR, в то время,  когда	прерывания  разрешены,
его  обработка	начинается,  как  только  закончится   текущая
команда. При появлении команды	INT  n,  обработка  прерываний
выполняется этой  командой.  Таблица  6.1  излагает  шаги  при
обработке прерываний, возникающей по сигналам INTR и  NMI  или
по команде INT n.
Таблица 6.1 Последовательность обработки прерываний
──────────────────────────────────────────────────────────────
	      Прерывания, вызванные
INTR		    NMI 		INT n
──────────────────────────────────────────────────────────────
1. Получить число
вектора n из контрол-
 лера прерываний, вы-
полнив два специаль-
ных цикла: циклы
"Распознования пре-
рываний"
2.Протолкнуть FLAG  1.Протолкнуть FLAG	1.Протолкнуть FLAG
по стеку	      по стеку		  по стеку
3.Протолкнуть CS    2.Протолкнуть CS	2.Протолкнуть CS
по стеку	      по стеку		  по стеку
4.Протолкнуть IP    3.Протолкнуть IP	3.Протолкнуть IP
по стеку	      по стеку		  по стеку
5.Установить IF     4.Установить IF
в 0		      в 0 и запереть NMI
6.Прочесть вектор   4.Прочесть вектор	3.Прочесть вектор
прерываний n.	      прерываний 2	  прерываний n
Поместить селектор    Поместить селектор  Поместить селектор
в CS и смещение в     в CS и смещение в   в CS и смещение в
IP		      IP		  IP
7.Начать выполнение  5.Начать выполнение4.Начать выполнение
во входной точке       во входной точке   во входной точке
(CS:IP) 	       (CS:IP)		  (CS:IP)
─────────────────────────────────────────────────────────────

			     - 64 -
			   Исключения
			    ──────────
Исключения - это  внутренние  события  процессора.  Исключения
происходят, когда 80386 определяет  проблему,  которая	мешает
выполнению следующей команды. Распознаются несколько категорий
исключений, и каждой присваевается  фиксированное  число  n  в
интервале 0-31. Этот интервал  специально  зарезервирован  под
исключения; прерываниям  не  должны  присваиваться  номера  из
этого интервала.
   В  реальном	 режиме   80386   опознает   несколько	 типов
исключений,  как  показано  ниже.  В   защищенном   режиме   и
виртуальном 8086 режиме  80386	опознает  дополнительные  типы
исключений, описанные в главе 16.
   Для обработки  этих	состояний,  также  как	и  прерываний,
требуются обслуживающие программы. Они называются программами
обработки исключений. Таблица векторов прерываний используется
для передачи управления  этим  программам,  в  зависимости  от
номера n, присвоенного типу случившегося исключения.

			 Распознование
			  ─────────────
Когда команда вызывает исключение,  оно  всегда  распознается.
Нет метода для маскировки исключений, да он  и нежелателен.
   Хотя  исключения  возникают	 и   распознаются   во	 время
выполнения команды, исключения проявляются на границе  команд,
так как состояние 80386 всегда сохраняется  таким,  каким  оно
было до этой команды. Таким образом CS:IP указывает на команду
(включая байты префиксов),  которая  вызвала  исключение.  Это
идеально  для  служебной  программы,  устраняющей  исключения,
потому что она может вернуться	к  программе  просто  выполнив
команду IRET по завершении своей работы.
   80386 в реальном режиме распознает 12 категорий исключений,
те  же,  что  в  реальном  режиме  распознает  80286.  Из   12
исключений, 5 существуют  для  8086,  2  посвящены  сообщениям
сопроцессора  о  численных  ошибках,  одно  для  сообщения   о
неверном  коде	команды,  и  четыре  для  сообщения  различных
нарушений границы сегмента. Краткое изложение дано  в  таблице
6.2.
Таблица 6.2 Назначение векторов исключений в реальном режиме
──┬───────────┬─────────────────────┬────────────────────────┐
N │Имя (и тип)│Описание 	    │	 Детектируется ли    │
  │	      │ 		    │			     │
  │	      │ 		    │в реальном  8086/88?    │
  │	      │ 		    │режиме?		     │
──┼───────────┼─────────────────────┼──────────┼─────────────┤
0 │Ошибка     │Была попытка деления │	да     │Да, однако   │
  │деления    │на 0 командами DIV   │	       │8086 CS:IP   │
  │(ошибка)   │или IDIV 	    │	       │указывают на │
  │	      │ 		    │	       │команду, иду-│
  │	      │ 		    │	       │щую после DIV│
  │	      │ 		    │	       │или IDIV     │
1 │Один шаг   │Если флаг IF в FLAG  │	да     │Да, но 8086  │
  │(ловушка)  │установлен в 1, это  │	       │имеет только │
  │Прерывание │исключение происходит│	       │флаг TF. У   │
  │в регистре │после следующей ко-  │	       │него нет ре- │
  │отладки    │манды. Регистры отла-│	       │гистров от-  │
  │(ловушка   │дки могут определить │	       │ладки	     │
  │или ошибка)│прерывание, что также│	       │	     │
  │	      │вызывает исключение 1│	       │	     │
3 │Код преры- │Однобайтный код пре- │	да     │   да	     │
  │вания      │рывания (CCh) выпол- │	       │	     │
  │(ловушка)  │няется. Процессор вы-│	       │	     │
  │	      │зывает исключение 3  │	       │	     │

			     - 65 -
──┬───────────┬─────────────────────┬────────────────────────┐
N │Имя (и тип)│Описание 	    │	 Детектируется ли    │
  │	      │ 		    │			     │
  │	      │ 		    │в реальном│ 8086/88?    │
  │	      │ 		    │режиме?   │	     │
──┼───────────┼─────────────────────┼──────────┼─────────────┤
4 │INTO       │Если установлен флаг │	да     │   да	     │
  │(ловушка)  │переполнения 0F, про-│	       │	     │
  │	      │цессор вызывает ис-  │	       │	     │
  │	      │ключение 4	    │	       │	     │
  │	      │ 		    │	       │	     │
5 │BOUND      │Если определено нару-│  да      │   да	     │
  │(ловушка)  │шение границ, процес-│	       │	     │
  │	      │сор вызывает исключе-│	       │	     │
  │	      │ние 5		    │	       │	     │
  │	      │ 		    │	       │	     │
6 │Неправильн.│Неприсвоенные коды   │	       │	     │
  │	      │ 		    │	да     │Нет, 8086    │
  │код команды│операций вызывают    │	       │	     │
  │	      │ 		    │	       │рассматривает│
  │(ошибка)   │инициацию 80386	    │	       │	     │
  │	      │ 		    │	       │неправильный │
  │	      │исключения 6	    │	       │	     │
  │	      │ 		    │	       │код как NOP  │
  │	      │ 		    │	       │	     │
7 │Сопроцессор│Код сопроцессора вы- │Да, если  │Нет, чтобы   │
  │недоступен │зывает исключение 7, │флаг EM в │эмулировать  │
  │(ошибка)   │когда сопроцессор    │CRO уста- │сопроцессор в│
  │	      │недоступен. Позволяет│новлен в 0│системе 8086 │
  │	      │эмуляцию команд со-  │	       │код процессо-│
  │	      │процессора если флаг │	       │ра должен    │
  │	      │EM в CRO установлен  │	       │быть заменен │
  │	      │в 0		    │	       │на команды   │
  │	      │ 		    │	       │INT n, кото- │
  │	      │ 		    │	       │рые вызывают │
  │	      │ 		    │	       │обработку    │
  │	      │ 		    │	       │исключения n │
  │	      │ 		    │	       │	     │
8 │Двойная    │Детектируется ошибка │Да, но тре│нет	     │
  │ошибка     │при попытке доступа к│бует нети-│	     │
  │(ошибка)   │программам обработки │пичного ис│	     │
  │	      │прерываний или исклю-│пользован.│	     │
  │	      │чений		    │команды   │	     │
  │	      │ 		    │LIDT для  │	     │
  │	      │ 		    │уменьш.   │	     │
  │	      │ 		    │границы   │	     │
  │	      │ 		    │таблицы   │	     │
  │	      │ 		    │прерываний│	     │
  │	      │ 		    │	       │	     │
9 │Нарушение  │Операнд для сопроцес-│Да, но    │Нет, 8086 по-│
  │границы    │сора частично нахо-  │только ес-│зволяет опе- │
  │операнда   │дится за границей    │ли програ-│рандам пере- │
  │сопроцессора сегмента	    │ммное обе-│ходить за    │
  │(ошибка)   │ 		    │спея. пе- │границу сег- │
  │	      │ 		    │реносит   │мента	     │
  │	      │ 		    │операнд за│	     │
  │	      │ 		    │границу   │	     │
  │	      │ 		    │64K       │	     │

			     - 66 -
──┬───────────┬─────────────────────┬────────────────────────┐
  │Имя (и тип)│Описание 	    │	 Детектируется ли    │
  │	      │ 		    │			     │
  │	      │ 		    │в реальном│ 8086/88?    │
  │	      │ 		    │режиме?   │	     │
──┼───────────┼─────────────────────┼──────────┼─────────────┤
12│Исключение │Операнд сегмента сте-│ то же    │ то же	     │
  │сегмента   │ка (SS) полностью или│	       │	     │
  │стека      │частично находится за│	       │	     │
  │(ошибка)   │границей сегмента.Или│	       │	     │
  │	      │стек не существует.  │	       │	     │
  │	      │Или неверный уровень │	       │	     │
  │	      │привилегий. Или не   │	       │	     │
  │	      │сегмент данных. А так-	       │	     │
  │	      │же некоторые другие  │	       │	     │
  │	      │примеры, изложенные  │	       │	     │
  │	      │в детальном описании │	       │	     │
  │	      │исключения 12	    │	       │	     │
  │	      │ 		    │	       │	     │
13│Исключение │Операнд в CS,SS,ES,FS│ то же    │ то же	     │
  │общей      │GS полностью или час-│	       │	     │
  │защиты в CS│тично лежит за преде-│	       │	     │
  │SS,DS,ES,FS│лами сегмента. Или см│	       │	     │
  │или GS     │предыдущее исключение│	       │	     │
  │(ошибка)   │ 		    │	       │	     │
  │	      │ 		    │	       │	     │
16│Численная  │Активизируется 80386 │Да,если   │Нет, 8087 сиг-
  │ошибка     │ERROR# вход (предпо- │вход 80386│нализирует о │
  │сопроцессораложительно сопроцес- │ERROR# был│численной    │
  │(ошибка)   │сором)		    │активизи- │ошибке сопро-│
  │	      │ 		    │рован     │цессора 8086 │
  │	      │ 		    │80387 вы- │посредством  │
  │	      │ 		    │ходом со- │прерывания   │
  │	      │ 		    │процессора│(обычно через│
  │	      │ 		    │	       │8259А, но в  │
  │	      │ 		    │	       │архитектуре  │
  │	      │ 		    │	       │PC через NMI │
──┴───────────┴─────────────────────┴──────────┴─────────────┘
   Так как 8086 распознает только  пять  категорий  исключений
у 80386  в   реальном	режиме	 могут	 возникать    проблемы
совместимости.	Так  как  исключения,	распознаваемые	 80386
являются расширением исключений  8086,	80386  является  более
различающим, чем его  предшественник.  Для  всех  практических
целей поддерживается  совместимость,  так  как	дополнительные
исключения 9,12 и 13  (нарушения  границы)  вызываются	только
необычными программами 8086 (например, переносом многобайтного
операнда  через  начало  сегмента),   не   присутствующими   в
коммерческих программах. Дополнение исключения 7,  Сопроцессор
недоступен, не является проблемой, потому что техника 8086  по
эмуляции  сопроцессора	также  хорошо	работает   на	80386.
Исключение  16	 происходит   только   когда   сигнал	ERROR#
сопроцессора  соединен	с  входным  контактом  ERROR#	80386;
однако, такое соединение необязательно, и PC, базирующаяся  на
80386  не  активизирует   исключение   16,   так   как	 выход
сопроцессора ERROR# посылается на вход процессора  NMI,  также
как и в PC, базирующихся на 8088.

	      Детали обработки исключений
	      ───────────────────────────
Дополнительная	детальная  информация  о   каждом   исключении
приведена в главе 16.
