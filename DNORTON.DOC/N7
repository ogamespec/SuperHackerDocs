                ГЛАВА 9. ВИДЕОДОСТУП 2 - ГРАФИЧЕСКИЙ РЕЖИМ
                
              После  завершения  обсуждения  основ  видеопредставления 
         информации и собственно текстового  режима  в  предшествующей 
         главе,   перейдем   к   рассмотрению  особенностей  работы  в 
         графическом режиме. 
              Не  следует  удивляться  сложности  предмета   "машинная
         графика". Сама по себе графика - вещь непростая; здесь же она
         осложняется чисто техническими аспектами, такими как цветовые
         палитры,  многочисленные режимы м хранимые образы содержимого
         экрана. Это сложный, многоаспектный вопрос. В  рамках  данной
         главы мы не будем углубляться в детали. Если в Ваши намерения
         входит использование графического режима  IBM/PC  или  просто
         изучение  основ  предмета,  то  следует  продолжать чтение. В
         противном случае, материал настоящей главы может быть опущен.
              Все сказанное ниже распространяется на компьютер IBM/PC,
         а  также  на  все  совместимые  с  ним  компьютеры (последние
         предполагают возможность выполнения произвольной программы, в
         том  числе  и  графической, написанной для IBM/PC). Если речь
         идет о компьютерах, использующих операционную систему MS-DOS,
         то большинство положений нуждается в уточнениях.
              
              9.1. Основы машинной графики

              Существует два основных способа формирования графических 
         изображений на видеомониторе.  Причудливый  мир  компьютерных 
         (экранных)    игр   позволяет   получить   о   них   какое-то 
         представление, оценить их место, роль и возможности. (Ниже об 
         этом   еще  пойдет  речь,  однако  следует  все  это  увидеть 
         собственными глазами.) 
              Эти  способы  основываются  либо  на  векторном, либо на 
         растровом  (точечном,  пиксельном)   принципах   формирования 
         изображений,  далее именуемых просто векторной или пиксельной 
         графикой. Графика IBM/PC -  это  пиксельная  графика;  именно 
         этому виду графики мы уделим основное внимание. 
              (Термин  "вектор",  кстати,  уже  использовался нами при 
         рассмотрении прерываний. Там он обозначал два машинных слова, 
         содержащих адрес программы, выполняющей обработку прерываний; 
         здесь под "вектором" понимается отрезок прямой. И  первая,  и 
         вторая   интерпретация  термина  имеют  чисто  математические 
         параллели, с которыми мы не будем далее соприкасаться.  Здесь 
         нам важно эти термины не смешивать). 
              При построении изображений на экране дисплея  средствами 
         векторной  графики  используются только прямые. В этом случае 
         машинная программа специфицирует две крайние точки прямой,  а 
         собственно дисплей "проводит" между ними прямую. 
              Если взять обычный экран дисплея - будь то телевизионный
         приемник  или  компьютерный терминал - то в случае растрового
         сканирования  электронный   луч,   генерирующий   изображение
         перемещается  по  стандартному  шаблону, образуемому строками
         развертки,  заполняющими  весь  экран.  В   случае   дисплея,
         работающего   на  принципах  векторной  графики,  перемещение
         электронного  луча  осуществляется   по   команде,   рисующей
         заданную  прямую  между  заданными  точками. В рамках системы
         векторного   сканирования,  перемещение   электронного   луча
         осуществляется  по заданной в каждом случае  траектории, а не
         по раз и навсегда установленному шаблону. 
              Векторная    графика    обладает    рядом   существенных 
         преимуществ - ей присущи  высокая  четкость,  и  точность,  а 
         также  сравнительно высокое быстродействие. Все это делает ее 
         эффективной  в  сфере  инженерной  графики,   а   также   при 
         построении  особенно сложных или точных графических дисплеев. 
         Однако векторно-графические  системы  используются  лишь  для 
         вычерчивания  прямых  (или  изображений,  которые  могут быть 
         представлены в виде совокупности коротких отрезков).В  рамках 
         этой  системы  оказывается  невозможным заполнять изображения 
         цветом сложной формы. Это сильно сужает область их  возможных 
         применений. 
              В  основе  растровой или пиксельной графики лежит другой 
         принцип. Экран дисплея  здесь  разделяется  на  прямоугольную 
         сетку,    состоящую   из   множества   мельчайших   элементов 
         изображения, называемых также пикселями  или  пэлами.  Каждый 
         пиксель   обладает   свойством   светимости.   Таким  образом 
         изображение синтезируется из множества отдельных точек. 
              Размеры  пикселей  и  расстояния  между  ними  тщательно 
         рассчитываются таким образом,  чтобы  промежутки  между  ними 
         отсутствовали.  Если  группа  смежных  пикселей  находится  в 
         возбужденном состоянии (т.е. светится), то они воспринимаются 
         глазом  не  как  совокупность отдельных точек, а как сплошной 
         участок. Если бы точки были  достаточно  малы,  то  этот  тип 
         дисплея  мог бы конкурировать с векторным по части четкости и 
         точности,  однако,  у  большинства  растровых  дисплеев  этот 
         показатель оставляет желать лучшего. 
              В  принципе,  любая  система  машинной   графики   может 
         обеспечить  воспроизведение  цвета,  однако, чаще всего, цвет 
         ассоциируется с растровой графикой. Цвет - это веский (но  не 
         единственный)   аргумент   в   пользу   превосходства  систем 
         растровой графики над системами векторной графики в игровой и 
         деловой  сферах.  Способность воспроизводить сплошные, прямо- 
         криволинейные поверхности в цвете  делает  растровую  графику 
         намного  предпочтительней  векторной  (исключение  составляют 
         специальные приложения, например, технические чертежи). 
              И   последний  аспект.  В  отличие  от  систем векторной 
         графики, в  которых  изображение   генерируется   с   помощью 
         последовательности   команд   (каждая   команда  рисует  одну 
         небольшую  прямую), системы   растровой   графики   допускают 
         использование  хранимого  в памяти образа экрана (эти вопросы 
         мы уже рассматривали применительно к  текстовым  образам).  В 
         компьютере  IBM/PC  мы имеем дело именно с сиcтемой растровой 
         (пиксельной)   графики;   управление   процессом   построения 
         изображения   на  экране  дисплея  осуществляется  с  помощью 
         хранимого  образа  экрана.  Все   преимущества   дисплеев   с 
         хранимыми   образами  экрана  распространяются  на  растровый 
         дисплей компьютера IBM/PC - и в первую очередь способность  к 
         считыванию  и  записи  отображаемых данных непосредственно из 
         памяти дисплея. 
              
              9.2. Понятие элемента отображения (пикселя)
              
              По  мере  движения  сканирующего  луча по экрану дисплея
         высвечиваются те  или  иные  пиксели.  (По  крайней  мере  те
         пиксели,  которые  находятся  в  видимой части экрана; дело в
         том, что сканирующий луч выходит  за  пределы  видимой  части
         экрана, в так называемую "закадровую" область. Эта область не
         содержит пиксели, однако, для нее может быть установлен цвет.
         В  языке  Бейсик  для  этого служит параметр границ оператора
         COLOR  (ЦВЕТ);  кроме  того,  одна  из  функций  обслуживания
         BIOS-ПЗУ  может  быть  использована для установки закадрового
         цвета).
              Напомним, что в  текстовом  режиме  экран  персонального
         компьютера  IBM/PC  состоит  из  25  горизонтальных текстовых
         строк;  из  материалов  предшествующей  главы,  связанных   с
         описанием  курсора,  известно  также,  что  на  каждый символ
         цветного    графического    дисплея     приходится     восемь
         горизонтальных   строк   развертки.   Отсюда   следует,   что
         вертикальный размер общего пиксельного поля IBM/PC равен  200
         строкам (8Х25).
              Горизонтальный    размер    пиксельного    поля    может 
         варьироваться.  Этот  размер  зависит   от   объема   памяти, 
         требуемой  для  управления  пикселями,  а  также  от величины 
         пикселя (точки), высвечиваемой на том  или  ином  графическом 
         мониторе. 
              Компьютер  IBM/PC  имеет  два  различных  горизонтальных
         формата  (размера)  пиксельного   поля,   устанавливаемых   в
         зависимости   от  требуемого  размера  (а,  следовательно,  и
         количества)  пикселя(ей). В режиме среднего разрешения ширина
         экрана составляет 320 точек, а в режиме  высокого  разрешения
         - 640  точек. (Компьютер  IBM/PC  допускает также возможность
         работы  в  режиме  низкого  разрешения,  однако,  этот  режим
         практически  не  используется.  В  режиме  низкого разрешения
         поверхность экрана  представляется  в  виде  матрицы  160Х100
         пикселей.    Аппаратура    цветного   графического   адаптера
         поддерживает режим низкого  разрешения,  однако,  программная
         поддержка на уровне BIOS-ПЗУ отсутствует).
              Таким  образом,  графический  режим  среднего разрешения 
         предусматривает наличие 320 точек по горизонтали экрана и 200 
         точек по вертикали, в то время как графический режим высокого 
         разрешения  -  640  точек  по  горизонтали  и  200  точек  по 
         вертикали.  Понятно, что изображение, представленное в режиме 
         высокого разрешения,  способно  воспроизводить  более  мелкие 
         детали  только  на  горизонтали.  Для  большинства приложений 
         качество изображения практически осталось бы неизменным, если
         бы режим высокого разрешения выражался параметрами 320Х400. 
              Каждый пиксель на экране дисплея может находиться либо в 
         активном (светимость), либо в пассивном состоянии;  в  режиме 
         среднего разрешения может быть воспроизведен и цвет. В режиме 
         высокого разрешения цвет не  воспроизводится,  отчасти  из-за 
         особенностей  генерации изображения, отчасти из-за отсутствия 
         дополнительной памяти, необходимой для воспроизведения цвета. 
              Рассмотрим    требования    к    памяти,   предъявляемые
         графическим  режимом  высокого  разрешения.  Если   к   числу
         сведений,  сообщаемых  о  пикселе,  относится  только признак
         активного или пассивного состояния  (наличие  или  отсутствие
         светимости  пикселя)  -  а  именно это и сообщается о пикселе
         -, то  для  управления  пикселем  достаточно   одного   бита,
         принимающего  значение  0 или 1. В режиме высокого разрешения
         имеется 640Х200 (или 128000)  пикселей.  Для  управления  ими
         требуется  128000  бит,  а с учетом того, что байт состоит из
         восьми  битов,  -  16000  байт.  Именно такая память выделена
         цветному графическому адаптеру (округлена до 16К). 
              Режим среднего разрешения требует вдвое  меньшего  числа
         пикселей.  Имея  те же 16К байт памяти мы  можем выделить для
         каждого пикселя два бита. С помощью  двух  битов  могут  быть
         представлены  четыре  различные величины (0, 1, 2, 3); но это
         позволит лишь частично решить проблему воспроизведения  цвета.
              Прежде, чем познакомиться  с  окончательным  разрешением 
         проблемы  воспроизведения цвета в графическом режиме, обратим 
         внимание на одно отличие  в  специфике  использования  памяти 
         дисплея  в  графическом  и  текстовом  режимах. Из предыдущей 
         главы нам известно о наличии двух текстовых режимов  -  80-ти 
         позиционного  и  40-позиционного.  Графика представлена также 
         двумя  режимами:  режимом  среднего  разрешения   и   режимом 
         высокого  разрешения.  В  обоих  случаях  число  отображаемых 
         элементов одного режима вдвое  превышает  число  отображаемых 
         элементов   другого   режима.   Соответственно  изменяются  и 
         требования, предъявляемые к памяти. На  этом  сходство  между 
         ними  заканчивается.  Если  в текстовом режиме дополнительная 
         память  используется  для  увеличения  числа  страниц,  то  в 
         графическом  режиме  дополнительная  память  используется для 
         удвоения объема памяти, отводимой под один пиксель. 
              В связи со спецификой  управления  цветом  в  компьютере
         IBM/PC    возникает    вопрос   о   количестве   одновременно
         используемых цветов.  Цветной  графический  адаптер  и  экран
         видеомонитора  способны  воспроизвести  любой  из шестнадцати
         возможных цветов  для  каждого  пикселя.  Здесь  нет  никаких
         проблем. Проблемы возникают при спецификации цвета.
              Фирма   IBM   могла  пойти  по  пути  создания  цветного
         графического  адаптера,  имеющего   достаточно   памяти   для
         представления  всех  возможных цветов каждого пикселя, однако
         она этого не сделала.  Как  уже  говорилось  выше,  в  режиме
         высокого  разрешения  каждому  пикселю  отводится только один
         бит,  поэтому   в   принципе   в   этом   режиме   невозможно
         воспроизвести  более двух цветов - белого и черного. В режиме
         среднего  разрешения  каждому  пикселю  отводится  два  бита,
         поэтому возможно воспроизведение четырех цветов. 
              Проблема выбора того или  иного  набора,  состоящего  из 
         четырех  цветов,  решена необычно и остроумно. В любой момент 
         времени  активны  только  четыре   цвета,   но   пользователю 
         предоставляется   возможность  установить  любой  из  четырех 
         цветов по своему усмотрению. Остальные три устанавливаются  в 
         рамках  так  называемой палитры. В качестве компенсации фирма 
         IBM предоставляет на выбор две  возможные  палитры  -  первая 
         состоит  из  зеленого, красного и коричневого (на большинстве 
         дисплеев воспроизводится как желтый), а вторая  -  из  циана, 
         малинового и белого. 
              Если все это звучит  недостаточно  убедительно,  давайте
         рассмотрим  этот  вопрос  с другой стороны. При задании цвета
         любого пикселя в режиме  среднего  разрешения  мы  используем
         один из четырех кодов 0, 1, 2, 3. Что стоит за этими числами?
         Ничего  жестко  фиксированного.  Их  смысл   определяется   в
         процессе спецификации используемого цвета. Мы можем закрепить
         за кодом 0 один  из  16  цветов.  Для  кодов  1-3  фирма  IBM
         предлагает  две  стандартные  возможности  (две  палитры),  и
         пользователь  должен  выбрать,   какую   палитру   он   будет
         использовать. Заметим здесь, что пользователь не может влиять
         на составление палитры.
              Давайте  еще  раз  осмыслим  происходящее. Если бы объем 
         памяти был достаточно велик,  то  мы  могли  бы  для  каждого 
         пикселя    использовать   полную   гамму   цветов   (16).   В 
         действительности объем памяти таков, что  в  режиме  высокого 
         разрешения  цветовая  гамма каждого пикселя состоит только из 
         двух цветов, а в  режиме  среднего  разрешения  -  только  из 
         четырех.  Пользователю  могли  бы  быть  предоставлены  более 
         широкие возможности в части выбора  цвета,  однако  по  этому 
         пути разработчики персонального компьютера не пошли. 
              В  режиме   высокого   разрешения   пользователь   лишен
         возможности  выбирать  конкретные цвета (два цвета) по своему
         усмотрению; этими цветами могут быть только черный и белый. В
         режиме   среднего  разрешения  пользователь  имеет  некоторую
         свободу выбора цветовой гаммы. Из четырех  цветов  один  цвет
         устанавливается   пользователем  произвольно.  Остальные  три
         цвета  устанавливаются  в  рамках  одной   из   двух   строго
         фиксированных палитр.
              Таким  образом,  любой  цветной  дисплей  в  графическом
         режиме позволяет использовать четыре цвета, причем три  цвета
         выбираются  из палитры 1 (зеленый, красный, коричневый), либо
         из палитры 2 (циан, малиновый, белый).
              Если  цветной дисплей находится в графическом режиме, то 
         цвет любого пикселя (из  состава  имеющихся  четырех  цветов) 
         можно  применить  путем  изменения  содержимого  двух  битов, 
         описывающих этот пиксель. Существует и  возможность  изменить 
         сразу  цвета  всего  изображения;  для  этого  следует:  либо 
         изменить палитру, либо изменить цвет 0, либо изменить и то  и 
         другое.  В этих случаях собственно  изображение (картинка) не 
         меняется,  изменяется  лишь  ее  цвет(а).  (Для  графического 
         режима  низкого  разрешения  предусмотрено  достаточно битов, 
         чтобы каждый пиксель мог воспроизвести любой из 16  возможных 
         цветов. Режим низкого разрешения может быть вполне реализован 
         на  Вашем  компьютере;  аппаратная  поддержка  этого   режима 
         реализована полностью. Однако программная поддержка на уровне 
         BIOS-ПЗУ полностью отсутствует. Если  функции  программ  BIOS 
         возьмет  на себя программа пользователя, то графический режим 
         низкого разрешения будет функционировать). 
              
              
              9.3. Отображение пикселей на экране
              
              Графический  режим  работы компьютера представляет собой 
         наиболее сложный режим. Если использовать процедуры BIOS-ПЗУ, 
         ориентированные  на обслуживание графического режима (описаны 
         в параграфе 8.9), то декодирование образа экрана  выполняется 
         автоматически. Это одна из причин их широкого использования. 
         В  тех  случаях,  когда необходимо использовать режим прямого
         управления,  следует  детально  ознакомиться   с   материалом
         настоящего параграфа.
              Подобно  обычному  телевизору,  видеомонитор  генерирует 
         изображение за два прохода. На первом проходе электронный луч 
         перемещается  только по четным строкам развертки; после этого 
         (на обратном ходе луча) сканируются все нечетные строки. 
              При  работе  в  текстовом  режиме  это  обстоятельство в 
         расчет   не   принимается,   поскольку   функции   управления 
         формированием   изображения  полностью  выполняет  контроллер 
         видеомонитора.   В   графическом   режиме   эти   особенности 
         необходимо учитывать. 
              Электронные схемы генерации  изображения  в  графическом
         режиме  должны воспринимать поток битов, определяющих пиксели,
         причем воспринимать их в том порядке, в  котором  сканирующий
         луч  перемещается  по  экрану - сначала по четным, а затем по
         нечетным строкам. По этой причине образ экрана хранится не  в
         том виде, который удобен  человеку-оператору  или  программе;
         структура  хранимого образа отвечает потребностям электронных
         схем генерации. На рис.9.1 воспроизводится эта структура.
              
              Для  того,  чтобы  структура  хранимого  образа   экрана 
         соответствовала механизму сканирования экрана, память дисплея 
         организована в виде двух блоков, смещенными друг относительно 
         друга  на  4К.  Первый  блок  содержит  информацию о пикселях 
         четных строк,а второй  блок  -  о  пикселях  нечетных  строк. 
         Рассмотрим  эти  вопросы более подробно (используя в качестве 
         примера графику с высоким разрешением). 
              В начале  области  (блока)  памяти  располагаются  биты, 
         управляющие  процессом  отображения  на экране дисплея первой 
         строки, т.е. строки с номером 0. Строка содержит 640 пикселей 
         (графический  режим  с высоким разрешением), а каждый пиксель 
         требует для индикации своего состояния 1 бит. Таким  образом, 
         для  управления  первой  строкой  требуется  640 битов или 80 
         байтов. Для управления следующей четной  строкой  (строкой  с 
         номером  2)  также  требуется  640 битов или 80 байтов и т.д. 
         Самый первый бит управляет точкой экрана дисплея, находящейся 
         на  пересечении  нулевой  строки  и  нулевого  столбца (0,0), 
         следующий бит управляет точкой (0,1) и т.д. Последней  точкой 
         первой  строки  является  точка  (0,639);  следом за ней идет 
         точка (2,0) и т.д.  В  конце  концов  блок  памяти,  хранящий 
         четные  строки,  оказывается  исчерпанным, и с нового адреса, 
         кратного  1К,  начинается  блок  памяти,  хранящий   нечетные 
         строки. 
              Для графического режима со  средним  разрешением  память
         организована   точно   также,   с   той  лишь  разницей,  что
         горизонтальная координата экрана  состоит  из  320  пикселей,
         причем  каждый пиксель представлен двумя битами, позволяющими
         представить  цветовые  комбинации. Для  представления  строки
         по-прежнему    требуется   80   байтов;   для   представления
         используются два блока памяти: один - для четных, а другой  -
         для нечетных строк.
              Заметим  здесь,  что конечный адрес памяти будет одним и 
         тем же как для режима среднего, так  и  для  режима  высокого 
         разрешения.  Но  в  одном  случае число пикселей вдвое меньше 
         (при  вдвое  большем   количестве   битов,   отведенных   для
         
         представления  каждого  пикселя),  а  в другом  случае  вдвое
         больше  (соответственно,  количество  битов,  отведенных  для 
         представления  пикселя  в  два  раза  меньше).  Такой  подход 
         позволяет сохранить постоянную длину строки для обоих режимов 
         -   640   битов  или  80  байтов.  Программы,  приведенные  в 
         приложении (листинг  9.1),  дают  возможность  пользователям, 
         программирующим   на   Паскале,  эффективно  управлять  любым 
         пикселем.    Эти    программы    осуществляют     необходимые 
         арифметические преобразования, связанные с пересчетом позиции 
         пикселя  на  экране  дисплея   в   адрес   памяти,   хранящей 
         кодированный  образ экрана, избавляя пользователя от рутинной 
         работы по вычислению смещений битов и байтов. 
              Эффективность    этих   процедур   становится   особенно
         очевидной,  когда   требуется   создавать   быстродействующие
         программы генерации изображений. Любая программа, относящаяся
         к указанному классу, должна тем или иным способом  переводить
         пиксели  из  активного  состояния  (состояние  светимости)  в
         пассивное  и  наоборот.  Сделать  это  можно  либо  используя
         функции  обслуживания  BIOS-ПЗУ, описанные в  предыдущей  и в
         последней главах, либо упомянутые Паскаль-процедуры  (листинг
         9.1).  Высокое  быстродействие программ генерации изображений
         предполагает, что тот или  иной  фрагмент  будет  загружен  в
         память  графического  адаптера  сразу  целиком,  а  не  будет
         формироваться побитно.  А  для  этого  необходимо  произвести
         декомпозицию  изображения  на четные и нечетные строки, после
         чего  обеспечить  их  размещение  в  соответствующих   блоках
         памяти.  Указанное  обстоятельство  сильно  усложняет процесс
         быстрой генерации изображений.
              Решение задачи быстрой генерации изображений зависит  от
         потребностей  и  от  принятых компромиссов. Один из возможных
         подходов  состоит  в  разбиении   изображения   на   участки,
         помещаемые  в  один  байт (четыре пикселя для режима среднего
         разрешения и восемь пикселей для режима высокого разрешения).
         Приняв  такую схему, можно осуществлять загрузку фрагментов в
         память графического адаптера побайтно. Такой  метод позволяет
         резко  снизить  вычислительные  затраты,  в противном случае,
         программы должны  выполнять  массу  операций  манипулирования
         битами,   таких,   например,   как  сдвиги,  логические  "И",
         логические "ИЛИ" и т.п. Работа с  байтами  повышает  скорость
         генерации  образа приблизительно в три раза, при условии, что
         собственно образ уже построен.
              Существует  и  другой,  более  грубый  способ  повышения
         скорости   генерации   изображения.   Его   суть   состоит  в
         использовании текстовой графики (псевдографики),  описываемой
         в следующем параграфе.
              
              9.4.   Представление  текста  (символов)  в  графическом
         режиме.
              
              Отображение  символов  на экране дисплея не представляет
         особого труда, даже если  компьютер  работает  в  графическом
         режиме.   Символы   в   этом  случае  представляются  в  виде
         совокупности пикселей,  как  если  бы  это  были  графические
         объекты, подлежащие рисованию (вычерчиванию).
              Для фиксации схемы вычерчивания символов  в  графическом 
         режиме  приняты  специальные  соглашения. Площадь, занимаемая 
         символом,  представляется  в  виде   матрицы   размером   8Х8 
         пикселей.  Принятый  принцип кодирования в принципе очевиден. 
         Для воспроизведения  очертания  (рисунка)  символа  отводится 
         восемь   байтов.  Восемь   битов   каждого   байта  управляют 
         состоянием  восьми  пикселей  одной  строки  рисунка  символа 
         (нумерация  пикселей  ведется  слева направо). Очередной байт 
         описывает очередную строку  (нумерация  строк  осуществляется 
         сверху вниз). 
              На рис.9.2 представлена диаграмма  отображения  символов
         (букв), содержащая  сведения об особенностях взаимодействия с
         таблицей рисования символов. В качестве примера выбрана буква
         "А".
              
              Даже  при  беглом знакомстве с этой диаграммой возникает
         ряд интересных вопросов. Нижняяя  строка  диаграммы  отведена
         под   нижний   выносной   элемент  символа  (литеры),  такой,
         например, как "хвост" прописной буквы "у". Две верхние строки
         отведены  под  заголовок  литеры.  В  качестве литер, имеющих
         заголовок, можно привести строчную букву "ь" (имеется в  виду
         ее  вертикальный  отрезок, используюший область заголовка), а
         также все прописные буквы алфавита (буквы верхнего регистра).
         Вопреки  "здравому  смыслу"  буквы  размещаются  не по центру
         матрицы, а смещаются (выравниваются ) по  ее  левой  границе,
         так  что  два  столбца справа служат для  отделения  символов
         друг от друга.
              При формировании символов в графическом режиме  BIOS-ПЗУ
         осуществляет  поиск  рисунка  (образа)  символа во внутренней
         таблице отображения, а  затем  найденное  табличное  описание
         использует для команд активизации пикселей. На заключительной
         стадии устанавливаются соответствующие биты в памяти  дисплея
         путем  пересылки  четных  и  нечетных строк в соответствующие
         блоки памяти.
              Поскольку в графическом режиме высокого  разрешения цвет
         не  воспроизводится  (воспроизводятся  только  черный и белый
         цвета), то рисунок (образ) символа непосредственно  управляет
         активизацией  пикселя.  В  цветном режиме среднего разрешения
         воспроизводятся цвет  очертания  (рисунок)  и  фоновый  цвет.
         Фоновый  цвет  -  это  цвет, обозначенный кодом 0; этим кодом
         может быть обозначен любой из 16-ти  имеющихся  цветов.  Цвет
         очертания  устанавливается с помощью  кода 3 текущей цветовой
         палитры; для палитры 1 это белый цвет,  а  для  палитры  0  -
         коричневый/желтый.
              Процедуры  манипулирования  символами   BIOS-ПЗУ   могут 
         осуществлять  как  считывание, так и запись символов. Функция 
         обслуживания с кодом 8 является именно  такой  процедурой.  В 
         текстовом  режиме  никаких  проблем  при чтении не возникает, 
         поскольку в  памяти  дисплея  хранится  байт  с  кодом  ASCII 
         требуемого  символа.  В графическом режиме все обстоит не так 
         просто, поскольку байт с кодом ASCII  в  памяти  отсутствует. 
         Вместо  этого  память  содержит группу байтов, представляющих 
         точечный  (пиксельный)  рисунок  символа.  Поэтому  процедура 
         BIOS-ПЗУ  чтения символа осуществляет нетривиальные операции. 
         Она читает пиксели и  сопоставляет  их  с содержимым  таблицы 
         рисунков    (образов)    символов,   выполняя   своего   рода 
         распознавание образа. 
              Таблица  рисунков  (образов)  символов  состоит  из двух 
         частей и представляет для пользователя значительный  интерес. 
         Первая  часть  этой  таблицы хранится в ПЗУ и содержит первые 
         128 символов кода ASCII,  то  есть  все  стандартные  символы 
         алфавита. Вторая часть таблицы содержит рисунки остальных 128 
         символов  (т.е.  символов   CHR$(120)-CHR$(255)).   Поскольку 
         первая  часть  находится  в  ПЗУ  (указатель  на  нее  строго 
         фиксирован), то она  не  может  быть  ни  модифицирована,  ни 
         заменена  на  другую таблицу. Вторая часть таблицы, в отличие 
         от  первой,  ориентирована  на  пользователя;  она  создается 
         пользователем под его потребность. 
              Один  из  векторов  прерывания  (прерывание  с  кодом 31
         (1F(16)),  размещенный   в   таблице   векторов   по   адресу
         124(7С(16))  используется  для  указания  на  эту  таблицу. В
         исходном состоянии таблица отсутствует и вектор  равен  нулю.
         После  создания  нужной таблицы и загрузки ее адреса в вектор
         прерывания любое обращение к BIOS-ПЗУ для  записи  символа  с
         кодом   CHR$(128)-CHR$(255)  приведет  к  воспроизведению  на
         экране этого символа. 
              Такой   подход,   основанный  на  свободном  определении 
         таблицы рисунков 128 символов  является  важной  предпосылкой 
         для быстрого построения наиболее типичных графических образов 
         (несложные  графики,  схемы,   рисунки,   таблицы,   чертежи, 
         диаграммы  и др.). Если требования к изображаемым объектам не 
         слишком  высоки,  то  всегда   можно   определить   ансамбль, 
         состоящий  из  128  шаблонов  (каждый шаблон имеет размер 8Х8 
         пикселей) и генерировать на их основе эти объекты.  Очевидно, 
         что  наиболее  сложные  и  детальные  образы  не  могут  быть 
         построены таким способом. И все-таки ансамбль,  состоящий  из 
         128  предварительно  определенных шаблонов, достаточно велик, 
         чтобы    пользовательские    программы    обладали    высоким 
         быстродействием,   были   просты  и  компактны.  В  сущности, 
         процедуры обслуживания рисунков символов BIOS-ПЗУ  (используя 
         таблицу,  созданную  пользователем)  берут  на  себя основную 
         работу по генерации образов; пользовательские программы  лишь 
         помещают нужные символы в нужные позиции экрана. 
              Описанные  возможности  генерации  графических  символов 
         отнюдь не исключают возможность непосредственного  доступа  к 
         памяти дисплея и управления отдельным пикселем. В графическом 
         режиме пользователь может сочетать обе возможности. Когда это 
         удобно  -  использовать  таблицу  графических  символов,  при 
         необходимости - манипулировать пикселями.  Вполне  допустимо, 
         например,   изменять   любой  пиксель  внутри  любого  образа 
         символа, уже выведенного на экран. 
              Таблица  рисунков символов требует для своего размещения
         1024 байтов памяти: 128 символов Х 8  байтов  (требуемых  для
         каждого символа). В графическом режиме со средним разрешением
         один байт программы  пользователя  может  использоваться  для
         управления   образом,   состоящим   из   64   пикселей,   что
         эквивалентно  восьми  байтам  отображаемой  информации.   При
         соблюдении  определенных  требований такой подход позволяет в
         восемь раз сжать графический образ по отношению к исходному.
              Прежде чем использовать эти возможности, следует оценить
         последствия  ограничений, распространяемых не только на число
         возможных шаблонов, но и на число  воспроизводимых  цветов  в
         режиме  среднего  разрешения.  Число  таких  цветов  не может
         превышать  двух.  Обычный  режим  цветной  графики  позволяет
         использовать  полную  4-х цветную палитру, в то время как при
         использовании возможностей построения изображений  на  основе
         синтеза  символов  количество цветов в палитре уменьшается до
         двух. 
              В  тех  случаях,  когда   таблица   рисунков   символов, 
         формируемая  пользователем,  не  применяется  для  построения 
         изображений  в   графическом   режиме,   можно   использовать 
         специальные  символы  из расширенного набора. Это может найти 
         применение  при  имитации  символов  текстового  режима,  при 
         построении  специальных  шаблонов  или  алфавитов.  Так,  это 
         наиболее  простой  и  эффективный  способ  генерации   других 
         национальных алфавитов - греческого, славянского (кириллица), 
         японского (кана). Символика арабского языка  и  иврита  также 
         вполне  представима, однако, здесь возникают другие сложности 
         -    сложности,    связанные    с    особенностями     письма 
         (справа-налево). 
              
              
              
              Приложение 9.1. Текст программы генерации изображений
                       (Паскаль).
              
              
         module listing_9_1;
         type
          word_bits_type       =  set of 0..15;
         high_res_pixel_type   = (off,on);
         medium_res_pixel_type =(color_0,color_1,color_2,color_3; 
          graphics_screen_type=
            record
              even_pixel : array [0..99,0..39] of word_bits_type;
              filler     : array [1..192] of byte;
              odd_pixel  : array [0..99,0..39] of word_bits_type;
            end;
         var [static]
          graphics_screen_pointer  :  ads of graphics_screen_type;
          general_screen_pointer   :  adsmem;
          row,column               :  integer;
         value
          graphics_screen_pointer.s := #B800;
          graphics_screen_pointer.r := 0;
          general_screen_pointer.s  :=#B800;
          general_screen_pointer.r  :=0;
         {===================================================================}
         
               ТЕКСТ   РАЗОБРАТЬ  НЕЛЬЗЯ
               
               graphics_screen_pointer ^ .odd_pixel [(row-1) div 2,column div 16]
         else
            work_byte :=
             graphics_screen_pointer ^ .even_pixel [row div 2, column div 16];
         work_value := column mod 16;
         
         if color = on then
           work_byte := work_byte + [work_value]
         else 
           work_byte := work_byte - [work_value];
           
         if odd (row) then
           graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 16]
             := work_byte
         else
           graphics_screen_pointer ^ .even_pixel[row div 2, column div 16]
             := work_byte;
         end;
         
         {===========================================================}
         
         procedure set_medium_res_pixel (color : medium_res_pixel_type);
         
           var [static]
             work_byte : word_bits_type;
             work_set0 : set of 0..15;
             work_set1 : set of 0..15;
             
         begin
           
          if odd (row) then
            work_byte :=
           graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 8];
          else
            work_byte :=
           graphics_screen_pointer ^ .even_pixel [row div 2, column div 8];
           
          work_set0 := [(column mod 8) * 2];
          work_set1 := [(column mod 8) * 2 + 1];
          
          if color in [color_2,color_3] then
            work_byte := work_byte + work_set0
          else
            work_byte := work_byte - work_set0;
            
          if color in [color_1,color_3] then
            work_byte := work_byte + work_set1
          else
            work_byte := work_byte - work_set1;
            
          if odd (row) then
            graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 8]
             :=work_byte
          else
            graphics_screen_pointer ^ .even_pixel [row div 2, column div 8]
             := work_byte;
         end;
         
         {===========================================================}
         
         procedure clear_screen_graphics;
           var [static]
             i : word;
           begin
             for i := 0 to 16383 do
               general_screen_pointer ^ [i] := 0;
           end;
           
         {===========================================================}
           
         end.  
                      ГЛАВА 10. КЛАВИАТУРА
                      ____________________
              
              
              Клавиатура - это одно из основных звеньев взаимодействия
         человека и компьютера. В этой главе  мы  подробно  рассмотрим
         работу  клавиатуры  Персонального  компьютера  фирмы  "ИБМ" и
         методы управления этой работой. Клавиатура IBM/PC  имеет  ряд
         интересных особенностей, которые мы сейчас изучим.
              
              
              10.1. Основные принципы функционирования клавиатуры
              
              
              На  мой  взгляд,  один из наиболее впечатляющих моментов
         конструкции  IBM/PC  -  это  способ  работы  с   клавиатурой.
         Выбранный   подход   в   равной  мере  прост  и  элегантен  и
         программистам необходимо знать две вещи, связанные  с  вводом
         информации  от клавиатуры, следующие из этого конструктивного
         подхода.
              На электронном  уровне  клавиатура  IBM/PC  представляет
         собой   небольшой  самостоятельный  компьютер.  Внутри  блока
         клавиатуры размещается  микропроцессор  8048  фирмы  "Интел",
         который  выполняет  задачу  слежения  за  нажатиями  клавиш и
         передачи  их   состояния.   Микропроцессор   8048   выполняет
         различные  функции,  включая самодиагностику (после включения
         питания    компьютера),    проверку    нажатия    клавиш    и
         противодребезговую защиту (что не позволяет воспринимать одну
         нажатую клавишу  как две).
              Микропроцессор 8048 позволяет также буферизовать  до  20
         нажатий  клавиш,  если  центральный  процессор  не  может  их
    ?    принять сразу. Обычно этот буфер совершенно  пуст,  поскольку
         ситуации,    когда    центральный   процессор   не   успевает
         отреагировать на запрос клавиатуры.
              Вы, вероятно, слышали предупреждающий  звуковой  сигнал,
         когда  нажатие Вами клавиш опережало возможности программы по
         их вводу. Это не связано  с  заполнением  буфера  клавиатуры.
         Процедура  ввода  с  клавиатуры  системы  BIOS  в  ПЗУ  имеет
         собственный  буфер  и  звуковой  сигнал  раздается  в  случае
         заполнения  этого буфера. Буфер клавиатуры может содержать 20
         символов, а буфер системы BIOS - только 15. По мере  изучения
         клавиатуры  мы  рассмотрим  как  код нажатой клавиши попадает
         сначала в буфер клавиатуры, затем в буфер BIOS и, наконец,  в
         программу.
              Блок   клавиатуры   не  связывает  с  клавишами  никаких
         конкретных   значений.   Вместо   этого,   блок    клавиатуры
         идентифицирует  по  ее  номеру  или  коду  сканирования.  Все
         клавиши имеют коды сканирования от 1 до  83.  На  рис.  10.1.
         показаны коды, соответствующие всем клавишам.
              При  нажатии  клавиши  блок  клавиатуры  передает ее код
         сканирования   центральному   процессору.    Когда    клавиша
         отпускается, клавиатура снова передает ее код, но увеличенный
         на 128 (или шестнадцатиричное значение  80).  Таким  образом,
         имеются различные коды для нажатия и освобождения клавиш.
              Для   работы   с   клавиатурой   используются   порты  и
         прерывания. Когда выполняется какое-либо действие с  клавишей
         (нажатие или освобождение), процессор клавиатуры обнаруживает
         его и запоминает в своем буфере. Затем, процессор  клавиатуры
         формирует  прерывание  с  номером  9.  В  ответ на прерывание
         служебная  процедура  системы  BIOS  в  ПЗУ   считывает   код
         сканирования  клавиши  из  порта клавиатуры (порт номер 96) и
         затем пересылает в порт  клавиатуры  команду  очистить  буфер
         процессора  клавиатуры.  Если  системный блок не реагирует на
         прерывания клавиатуры, то коды сканирования  накапливаются  в
         буфере  процессора  клавиатуры,  хотя  при  нормальной работе
         этого не должно  происходить.  Специальный  код  сканирования
         255,   шестнадцатиричное  значение  FF,  используется  блоком
         клавиатуры, для сообщения, что его буфер заполнен.  
              Поскольку  информация  о  нажатии  клавиши  поступает  в
         системный блок от клавиатуры  через  порт,  любая  программа,
         имеющая  доступ  к  порту,  может  непосредственно общаться с
         клавиатурой. На практике, однако, это  неприменимо,  так  как
         блок   клавиатуры  вырабатывает  еще  и  прерывания,  которые
         обрабатываются  системой  BIOS  в  ПЗУ.  Однако,  просто   из
         любопытства,  можно  написать небольшую программу на Бейсике,
         читающую порт клавиатуры и сообщающую, что она  там  находит.
         Ниже приведен фрагмент этой программы.
              Поскольку  эта  программа состязается с системой BIOS за
         получение  информации  от  клавиатуры,  ее  работа  несколько
         хаотична.  Но  если  запустить  эту  программу  и нажимать на
         клавиши,  она   все   же   зарегистрирует   несколько   кодов
         сканирования.
              
              100  REM  Программа на Бейсике, пытающаяся считывать
                        коды сканирования клавиатуры
              110  X=INP(96)  'чтение порта клавиатуры
              120  THROW.AWA4$ = INKEY$ 'отбросить любые коды,считан- 
                                         системой BIOS
              130  IF X=0 THEN GOTO110 'если данных нет - продолжать
                                        ожидание
              140  PRINT
              150  PRINT "Код сканирования клавиатуры"; XMOD128;'сооб-
                                                        щить код
              160  IF X > 128 THEN PRINT "клавиша осбождена";
              170  IF X > 129 THEN PRINT "клавиша нажата";
              180  GO TO 110
              
              Клавиатура  IBM/PC  выполняет  еще  и функцию повторения 
         клавиши. Блок  клавиатуры  следит  за  тем,  сколько  времени 
         клавиша  остается  нажатой  и  формиирует  сигнал повторения. 
         Функция повторения  распространяется  на  все  клавиши  блока 
         клавиатуры. 
              Процедуры  системы BIOS в ПЗУ могут распознавать отличие 
         повторных нажатий клавиши от повторения сигнала  удерживаемой 
         в нажатом состоянии клавиши, путем анализа кодов сканирования 
         освобожденной клавиши.  Если  для  одной  и  той  же  клавиши 
         получены  два  кода нажатой клавиши и между ними не было кода 
         освобожденной   клавиши,    значит    клавиша    удерживается 
         процедурами  системы  BIOS  для подавления функции повторения 
         тех клавиш,  которым  она  не  нужна,  таких  как,  например, 
         клавиша смещения (shift). 
              Теперь  Вам  должны быть понятны основы того, как IBM/PC
         работает  с  клавиатурой.  Блок  клавиатуры   сообщает,   что
         происходит  с  клавиатурой:  какие  клавиши нажимаются, какие
         освобождаются и, через определенный промежуток времени, какие
         удерживаются   в   нажатом  состоянии.  Система  BIOS  в  ПЗУ
         интерпретирует получаемую  от  блока  клавиатуры  информацию,
         придавая  ей  определенный  смысл. Таким образом, имеет место
         очень  ясное  и  четкое  разделение  труда.  Блок  клавиатуры
         занимается  физической  стороной, механизмом функционирования
         клавиатуры,  а  программы  системы  BIOS  в  системном  блоке
         выполняют  все  логические операции по интерпретации действий
         клавиатуры.
              Большинство пользователей даже не знает, что  клавиатура
         IBM/PC  передает  сигналы  не  только  о  нажатии,  но  и  об
         освобождении  клавиши,  поскольку  такая  информация   обычно
         скрыта  от  пользователя.  Ее  можно  увидеть,  запустив тест
         клавиатуры из набора диагностических  программ  IBM/PC.  Если
         присмотреться,  можно  заметить,  что  изображение  на экране
         меняется при каждом нажатии, освобождении клавиши  или  когда
         клавиша удерживается в нажатом состоянии достаточно долго для
         того, чтобы начала действовать функция повторения.
              
              10.2. Определение смысла нажатых клавиш
              
              Служебная процедура системы BIOS для  прерывания  9  или
         прерывания  клавиатуры  определяет  смысл  каждого действия с
         клавиатурой. Это включает  слежение  за  состоянием  смещения
         кодов и преобразование нажатий клавиши в их значения, будь то
         буквы алфавита или сигналы  функциональных  клавиш.  Ниже  мы
         будем рассматривать эту функцию подробнее.
              Часть  щадачи обслуживания клавиатуры со стороны системы
         BIOS заключается в слежении за всеми  возможными  состояниями
         смещений.   Состояния   смещений   довольно   часто  вызывают
         путаницу, поскольку клавиатура  обычной  пишущей  машинки,  с
         котокой   большинство  из  нас  начинало  свое  знакомство  с
         клавишами, имеет  всего  одну  клавишу  смещения,  Клавиатуры
         многих  кимпьтеров,  в  том  числе  и  IBM/PC, имеют три типа
         смещений.
              Во-первых, имеются обвчные функции клавиш,  без  всякого
         смещения  (например,  для  получения букв в нижнем регистре).
         Затем имеется  обычное  смещение,  такое  же  как  у  пишущих
         машинок,  которое служит для получения букв верхнего региства
         и, как правило, всех  знаков,  нанесенных  на  верхнюю  часть
         клавиши.  Кроме  того,  имеются  еще   два   вида   смещения,
         изменяющее  смещение ("ALT") и управляющее смещение ("CTRL").
         Эти два специальных  вида  смещения  используются  аналогично
         обычному  смещению  в том смысле, что просто "а" не совсем то
         же самое, что "А" в верхнем регистре, и Ctrl-A и Alt-A  также
         имеют собственные значения. (Некоторые читатели могут считать
         клавишу "ESC" еще одной клавишей смещения. Это связано с тем,
         что  в  некоторых  старых  терминалах  компьютеров,  особенно
         таких,  которые  использовались  подобно  клавишам  смещения.
         Однако, при использовании клавиши "ESC" она не удерживалась в
         нажатом  состоянии,  подобно  клавишам  смещения,  -  сначала
         нажималась  клавиша  "ESC",  а  после  нее  какая-либо другая
         клавиша. Оба этих  нажатия  рассматривались  как  специальная
         последовательность.  Такое  действие нельзя рассматривать как
         операцию смещения. Обычно, клавиша "ESC" подобным  образом  в
         IBM/PC не используется.) 
              Допустимыми  считаются не все сочетания обычных клавиш и
         клавиш смещения. Если ввести одну из недопустимых комбинаций,
         то  система BIOS ее просто проигнорирует, как будто ничего не
         произошло.  Несколько  позже  мы  перечислим  все  допустимые
         комбинации  смещений  клавиш,  чтобы Вы могли воспользоваться
         ими в своих программах.
              На  клавиатуре   IBM/PC   имеется   четыре   специальных
         "переключательных"  клавиши,  которые  действуют  в  качестве
         тумблера "включения-отключения" для определенных функций. Эти
         клавиши  Insert  (вставка),  Caps-Lock (закрапление заглавных
         букв), Num-Lock (закрепление цифровой клавиатуры) и  клавиша,
         которой  практически  не пользуются, Scroll-Lock (закрепление
         "роллинга").  Две  из  этих  клавиш,  Caps-Lock  и  Num-Lock,
         являются   частью   механизма   смещения,  а  оставшиеся  две
         управляют определенными специальными режимами работы.
              Информация о  состоянии  этих  четырех  переключательных
         клавиш  и  том,  удерживается  ли  в  данный момент в нажатом
         состоянии одна из  клавиш  смещения,  хранится  в  специально
         выделенной   для   этих   целей   области  в  нижних  адресах
         оперативной памяти. Вся эта информация хранится в двух байтах
         с  адресами 1047 и 1048 (или 417 и 418 шестнадцатиричных). Во
         время работы IBM/PC,  в  этих  двух  байтах  сохраняются  все
         состояния  смещения  и состояния переключателей. Емтественно,
         что после выключения  компьютера  эти  байты  сбрасываются  в
         нормальное состояние.
              Программа  на  Бэйсике,  листинг которой 10.1 приведен в
         конце этой главы, отображает эти два  байта  и  демонстрирует
         воздействие  на них нажатий клавиш смещения и переключателей.
         Описание смысла отдельных битов приведено ниже.
              Поскольку клавиши смещения действуют  только  в  нажатом
         состоянии,   система   BIOS   следит   за   их   нажатиями  и
         освобождениями и вносит необходимые изменения в интерпретацию
         обычных  клавиш.  Система  BIOS следит за кодами сканирования
         при освобождении только для клавиши  смещения,  так  как  для
         всех остальных клавиш эта функция не имеет смысла.
              Когда  система  BIOS  получает  код сканирования обычной
         клавиши, она проверяет все варианты  смещения  и  преобразует
         этот  код  в соответствующее значение, которое может быть как
         символьным кодом ASCII, так и кодом специального назначения.
              Процедура обслуживания клавиатуры системы BIOS следит не
         только за состояниями смещения. Состояние клавиатуры хранится
         в первых тринадцати битах указанных выше двух байт по  адресу
         1047.  Ниже  приведена таблица значений этих битов, изменения
         которых можно проследить с помощью программы 10.1:
              
         _____________________________________________________________
            Байт  Бит    Смысл             Значение, когда бит равен 1
         _____________________________________________________________
              
              1    1     Insert              состояние активное
              1    2     Caps-Lock           состояние активное
              1    3     Num-Lock            состояние активное
              1    4     Scroll-Lock         состояние активное
              1    5     Alt                 клавиша нажата
              1    6     Ctrl                клавиша нажата
              1    7     смещение слева      клавиша нажата 
              1    8     смещение справа     клавиша нажата
              2    1     Insert              клавиша нажата
              2    2     Caps-Lock           клавиша нажата
              2    3     Num-Lock            клавиша нажата
              2    4     Scroll-Lock         клавиша нажата
              2    5     Состояние захвата   активное состояние
              2    6     (не используется)   (после Ctrl-Num-Lock)
              2    7     (не используется)
              2    8     (не используется)
         ____________________________________________________________
              

              
              В этой таблице нашел отражение ряд интересных  моментов.
         Во-первых, можно отметить параллельность использования первых
         четырех  битов  обоих  байтов  для  клавиш-переключателей.  В
         первом байте  отражается  текущее  состояние  клавиши,  а  во
         втором  байте  указывается  нажатие  соответствуюших  клавиш*
         Во-вторых. обратив внимание на биты, соответствующие  нажатию
         обычных  клавиш  смещения,  расположенные  в правой и в левой
         частях клавиатуры, распознаются по  отдельности.  Для  такого
         разделения  трудно  придумать  разумное применение, но тем не
         менее оно имеет место.
              Кроме того, система BIOS следит за  состоянием  вставки,
         управляемым  переключателем.  Эта функция обычно игнорируется
         программами, которые  используют  клавишу  Iusert,  например,
         текстовыми прогцессорами. Обычно. все программы, использующие
         эту клавишу, сами следят за  режимом  вставки.  Практического
         значени[  это не имеет, но нам показалось любопытным отметить
         и такой факт.
              И, наконец, обратите внимание на бит состояния  захвата,
         который   устанавливается,   когда   процедура   обслуживания
         клавиатуры  системы  BIOS  обнаруживает  комбинацию   клавиши
         Ctrl-NumLock.  Эта  комбинация используется системой BIOS для
         управления состоянием захвата, которое программам  обнаружить
         трудно,  поскольку в этом состоянии программы не выполняются.
         В состоянии захвата система  BIOS  выполняет  короткий  цикл,
         ожидая  нажатия  клавиши,  которое  выводит  систему из этого
         состояния. В этом состоянии распознаются и обслуживаются  все
         прерывания.  Если  прерывание  поступит  от  клавиатуры  (при
         нажатии обычной клавиши), то состояние  захвата  завершается,
         код  нажатой  клавиши отбрасывается и управление возвращается
         той программе, которая выполнялась до установления  состояния
         захвата.   Если   прерывание  имело  другую  природу  (номер,
         прерывание от дисков), то  оно  обслуживается,  но  состояние
         захвата сохраняется пока не будет нажата клавиша.
              Комбинация клавиш Ctrl-NumLock -  это  один  из  четырех
         особых  случаев, отслеживаемых процедурой системы BIOS. Когда
         процедура   обслуживания   клавиатуры   обрабатывает    коды,
         принимаемые  от клавиатуры, она постоянно проверяет появление
         одной из четырех  особых  комбинаций,  которые  обслуживаются
         специальным образом. 
              Фактически,  эти  четыре  комбинации рассматриваются как 
         команды, по которым должно начинаться выполнение определенных 
         служебных  процедур.  Эти  четыре  комбинации:  Ctrl-NumLock, 
         PrtSc, Ctrl-Alt-Del и Ctrl-Break. 
              Как мы уже видели, комбинация Ctrl-NumLock  используется 
         для  приостановки  работы  компьютера. Процедура обслуживания 
         клавиатуры  не  позволяет  компьютеру  продолжать  выполнение 
         любой программы, пока приостановка не будет отменена нажатием 
         клавиши. 
              Команда распечатки экрана или  PrtSc  предназначена  для 
         вывода содержимого экрана на устройство печати. Поскольку эта 
         операция выполняется на  самом  примитивном  уровне,  она  не 
         может  использовать  возможности  ДОС,  такие  как  пересылка 
         сообщения в линию связи вместо устройства  печати.  Процедура 
         распечатки  экрана  доступна  и  Вашим  программам  на уровне 
         прерываний, что будет показано в главе 11. 
              Комбинация   клавиш   Ctrl-Alt-Del   используется    для 
         перезапуска  или  для перезагрузки системы. Когда встречается 
         такая комбинация, процедура обслуживания клавиатуры  передает 
         управление   программе  проверки  системы  и  запуска  работы 
         операционной системы. 
              Эту комбинацию клавиш можно использовать в любой  момент 
         времени  для  перезапуска  системы, если произошло какое-либо 
         отклонение от нормального функционирования. Однако, как можно 
         заметить,  эта  комбинация  действует  не всегда. В некоторых 
         случаях IBM/PC необходимо бывает  выключить,  а  затем  снова 
         включить  и  уже  после  этого пытаться ее перезапустить. Для 
         чего   это   бывает   необходимо?   Комбинация   Ctrl-Alt-Del 
         срабатывает  всегда,  когда  работает  процедура обслуживания 
         клавиатуры. Это условие может оказаться невыполненным в  двух 
         случаях. Первый и наиболее распространенный связан с запретом 
         прерываний.  Из  главы  3  Вам  должно  быть  известно,   что 
         прерывания   запрещаются   машинной   командой   CLI   и   не 
         обслуживаются  пока  не  будет  выдана  команда  STI.  Обычно 
         команда  STI  следует  за  командой  CLI через очень короткий 
         промежуток  времени.  Однако,  если  программа   по   ошибке, 
         оставила   прерывания   запрещенными,   то   нажатие   клавиш 
         Ctrl-Alt-Del не  приведет  ни  к  какому  результату.  Другая 
         причина  нарушения  работы  процедуры обслуживания клавиатуры 
         может быть связана с изменением значения  вектора  прерывания 
         от  клавиатуры.  Если  изменить  ячейки  памяти с 36 по 39, в 
         которых находится  вектор  прерывания  от  клавиатуры,  тогда 
         клавиатура   не   будет  работать,  в  том  числе  и  клавиши 
         Ctrl-Alt-Del.  Естественно,  что  прогармма   запуска   после 
         включения питания восстанавливает все вектора прерываний. 
              Комбинация   Ctrl-Break   предназначена  для  прерывания 
         текущей операции. В отличие  от  остальных  трех  специальных 
         комбинаций  она  может  отрабатываться программно. Прерывание 
         номер 27, шестнадцатиричное значение 1В, зарезервировано  для 
         процедуры,  которая  должна  вызываться  при  нажатии  клавиш 
         Ctrl-Break. Если программа хочет использовать  это  средство, 
         она  должна занести адрес процедуры обслуживания прерывания в 
         ячейки  вектора  прерывания  27  -  ячейку  с  адресом   108, 
         шестнадцатиричное   значение   6С.   Эту   возможность  можно 
         исследовать,  нажимая  клавиши  Ctrl-Break   при   работе   с 
         интерпретатором  БЕЙСИКА или редактором Edlin, поставляемым в 
         составе ДОС. Если программа не устанавливает адрес  процедуры 
         обслуживания   прерывания  в  ячейку  108,  то  система  BIOS 
         совместно с ДОС прерывают выполнение  текущей  программы  или 
         файла пакетной обработки. Управление возвращается ДОС. 
              Поскольку   блок   клавиатуры  сообщает  обо  всем,  что 
         происходит  с  клавишами  и  процедуры  системы  BIOS  в  ПЗУ 
         интерпретируют  любые  действия,  выполняемые  с клавиатурой, 
         Ваша   программа   может   следить   за   всеми   действиями, 
         производимыми   с  клавиатурой.  Программам  редко  требуются 
         какие-либо   сведения   помимо   тех,   которые    сообщаются 
         процедурами  обслуживания  клавиатуры  системы  BIOS  в  ПЗУ, 
         поэтому не обеспечена  специальная  возможность,  позволяющая 
         программе  определить какие в точности действия выполнялись с 
         клавиатурой. 
              Если Вам все-таки  необходимо  более  точно  знать,  что 
         происходит  с  клавиатурой,  Ваши  программы  могут подменить 
         вектор  прерываний  для  клавиатуры,  который  расположен  по 
         адресу   36,   шестнадцатиричное   значение   24.   Если   Вы 
         разрабатываете собственную процедуру обслуживания  прерываний 
         от  клавиатуры,  то  она  может  либо выполнять абсолютно все 
         функции  обслуживания,  либо  служить  пред-процессором   для 
         стандартной   процедуры  системы  BIOS.  Предпроцессор  может 
         извлекать  любую  информацию,  которая  Вам   необходима,   и 
         передавать  управление  стандартной  процедуре для выполнения 
         обычных действий. 
                
                
                10.3.Символьные клавиши
                
              Коды сканирования клавиши преобраззуются системой BIOS в 
         расширенные  коды  ASCII,  состоящие  из  всез  256 возможных 
         байтовых комбинаций, кроме одной (байт с нулевым  значением). 
         В  этот  набор  кодов  входят  обычные символы, набор которых 
         описывается в различных  руководствах  по  IBM/PC.  Эти  коды 
         можно  формировать  либо  с  помощью  нажатия  обычных клавиш 
         (например,  клавиши  А  для  "А"  и  таек  далее)  или  путем 
         использования клавиатуры и клавиши Alt. 
              Для  формирования  кодов  ASCII по второму методу нужно, 
         удерживая клавишу "Alt" в нажатом состоянии, вводить числовое 
         значение  кода  ASCII. Значение должно вводиться в десятичном 
         виде (от 1 до  255)  и  можно  использовать  только  числовые 
         клавиши в правой части клавиатуры (но не числа в верхнем ряду 
         средней части клавиатуры). При  использовании  клавиши  "Alt" 
         процедуры  системы  BIOS  работают  особым образом, поскольку 
         несколько нажатий клавиш должны интерпретироваться  как  один 
         символ.  Пока  нажата  клавиша  "Alt"  можно  нажиматьсколько 
         угодно цифровых клавиш. Когда  клавиша  "Alt"  будет  наконец 
         освобождена,    будет    сформирован   код   символа   ASCII, 
         соответствующий введенному числовому  значению.  Если  ввести 
         слишком  большое  число,  используется его значение по модулю 
         256. Например, если ввести Alt-1000,  то  будет  сгенерирован 
         символ  CHR$(232).  Деление  1000  на  256  дает остаток 232, 
         поэтому и генерируется символ с кодом CHR$(232). 
              Единственное значение в коде ASCII,  которое  невозможно 
         ввести  с  клавиатуры  - это нулевое значение или CHR$(0). На 
         это имеется несколько причин (код 0 определен в системе кодов 
         ASCII  как  пустой  символ,  который  должен игнорироваться), 
         однако, главная  причина  заключается  в  использовании  нуля 
         системой   BIOS   для  указания  на  наличие  второго  набора 
         символов, специальных символов. Хотя некоторые руководства по 
         IBM/PC  указывают,  что  нулевой  код  генерируется  нажатием 
         клавиши Ctrl-2 или с помощью клавиши "Alt", это неверно. Если 
         удерживать  клавишу  "Ctrl"  в  нажатом  состоянии  и  нажать 
         цифровую клавишу "2" будет сформирован  один  из  специальных 
         символов  и этот символ должен интерпретироваться как CHR$(0) 
         из набора кодов  ASCII.  Это  не  совсем  то  же  самое,  что 
         формирование     действительного    кода    ASCII    CHR$(0). 
         Использование  клавиши   "Alt"   тоже   не   даст   желаемого 
         результата,  будете ли Вы нажимать клавиши Alt-0 или пытаться 
         "обмануть"  систему,  вводя  эквиваленты   по   модулю   256, 
         например, Alt-256 или Alt-512. 
              Специальные   символы   используются   для   обозначения 
         специальных  клавиш,  таких  как  "Home",  "End"   и   десять 
         функциональных  клавиш  (фактически,  как  Вы  скоро увидите, 
         имеется сорок функциональных клавиш). 
              Специальные символы позволяют  использовать  специальные
         клавиши,  такие  как  функциональные клавиши, не используя ни
         один из 256 символов расширенного кода ASCII.
              Механизм  кодирования,  который  система  BIOS   в   ПЗУ
         использует для указания, какой символ был введен с клавиатуры
         ( и определение того, обычный это  символ  или  специальный),
         работает  с  двумя  байтами.  Если  первый  из двух байтов не
         нулевой, то введен символ  расширенного  кода  ASCII  и  этот
         символ хранится в первом байте. Есоли же первый байт нулевой,
         то с клавиатуры введен специальный символ и его код  хранится
         во  втором  байте. Здравый смысл подсказывает, что можно было
         бы  использовать  один  бит  второго  байта  для  обычных   и
         специальных  символов.  Это  было  бы  проще  и  позволило бы
         вводить нулевой код ASCII.  
              В то время как в расширенном наборе ASCII 256 кодов (255 
         из них можно ввести с клавиатуры), специальных кодов столько, 
         сколько  требуется  для   выполнения   всех   предусмотренных 
         клавиатурой  IBM/PC  функций.  Например, сорок кодов выделено 
         для функциональных клавиш (десять обычных и еще тридцать  для 
         трех возможных смещений - обычного и с помощью клавиш "Alt" и 
         "Ctrl").  Ниже  приведена   таблица   специальных   кодов   и
         комбинаций  клавиш,  которыми  они вырабатываются. Вы конечно
         заметите  определенную  хаотичность  этих  кодов.   Некоторые
         комбинации  с  клавишей "Alt" разрешены, а другие нет, причем
         без какой-либо видимой причины.  То  же  можно  сказать  и  о
         комбинациях с клавишей "Ctrl".
              
           Значение            Клавиши, с помощью
           специального        которых он формируется
           кода
           ____________        __________________________________
              
              3                Ctrl-2 (что должно соответствовать коду
                               CHR$(0) или ASCII NULL)
              15               обратная табуляция (shift-tab)
             16-25             от Alt-a до Alt-p (верхний ряд букв)
             30-38             от Alt-A до Alt-L (средний ряд букв)
             44-50             от Alt-Z до Alt-M (нижний ряд букв)
             59-68             от F1 до F10 (функциональные клавиши)
              71               клавиша "Home" (курсор в верхний левый 
                               угол экрана)
              72               клавиша "Курсор вверх"
              73               клавиша "PgUp" (страница вверх)
              75               клавиша "Курсор влево"
              77               клавиша "Курсор вправо"
              79               клавиша "End" (конец)
              80               клавиша "Курсор вниз"
              81               клавиша "PgDn" (страница вниз)
              82               клавиша "Ins" (вставка)
              83               клавиша "Del" (удалить)
             84-93             от смещение-F1  до смещение-F10 (функ-
                               циональные клавиши с обычным смещением)
            94-103             от Ctrl-F1 до Ctrl-F10     
            104-113            от Alt-F1 до Alt-F10
              114              Ctrl-PrtSc
              115              Ctrl-Курсор влево
              116              Ctrl-Курсор вправо
              117              Ctrl-End
              118              Ctrl-PgDn
              119              Ctrl-Home
            120-131            от Alt-1 до Alt-= (верхний ряд клавиш)
              132              Ctrl-PgUp
         
              Как Вы могли заметить, эта таблица не слишком регулярна.
         Вы,  наверное,  заметили,  что  имеется  сорок  комбинаций  с
         функциональными  клавишами  -  каждая  из  клавиш  в одном из
         четырех смещенных состояний (обычном, смещенном,  с  клавишей
         "Ctrl" и с клавишей "Alt").
              Имея  в своем распоряжении все эти коды, любая программа
         не будет испытывать недостатка кодов специального назначения.
         Обычно,  для  любой программы хватает функциональных клавиш и
         нескольких клавиш специального назначения, таких как "Home" и
         клавиши   управления   курсором.   Однако,  если  потребуются
         дополнительные клавиши, Вы сможете их найти в этой таблице.
              Доступ  к  этим  специальным  кодам   символов   требует
         изменения  определенных  особых  методов.  В  следующих  двух
         разделах мы рассмотрим как это делается.
              
              
              10.4. Процедура обслуживания клавиатуры в системе BIOS
              
              Рассмотрим  теперь  служебные  процедуры  системы  BIOS,
         позволяющие осуществлять доступ к клавиатуре.
              Процедуры   обслуживания   клавиатуры   в  системе  BIOS
         вызываются с помощью прерывания номер  22,  шестнадцатиричное
         значение  16.  Таких процедур всего три, поскольку не слишком
         много функций можно запросить для клавиатуры.
              Первая процедура, имеющая код  0,  возвращает  очередной
         принятый от блока клавиатуры символ. Эта процедура возвращает
         управление вызввающей программе  только  тогда,  когда  будет
         введен символ, так что программе не приходится проверять, был
         ли  действительно  введен  символ.   Код   обычного   символа
         возвращается  в  регистре  AL,  но  если содержимоое AL равно
         нулю, то в регистре АН находится  код  специального  символа.
         Эти   регистры   соответствуют   первому  и  второму  байтам,
         упоминавшимся  выше,  при  рассмотрении   кодов   специальных
         символов.   Ниже   описана   логика   процесса  распознавания
         получаемых символов:
              
              если AL=0 то
               начало
                 спец_символ:= истина;
                 введенный_символ:= АН
               конец
              иначе
               начало
                 спец_символ:= AL
               конец;
              
              Можно  сделать  ряд  интересных  замечаний,   касающихся
         значений,  возвращаемых  этой процедурой. Если введен обычный
         код АSCII (то есть, AL не равняется нулю), то в  регистре  АН
         содержится  код  сканирования  для  нажатой клавиши. Но, если
         код ASCII был введен с помощью клавиши "Alt", то  в  регистре
         АН  будет  ноль. Этту информацию программа может использовать
         для определения способа вода символа. Некоторые символы  кода
         ASCII встречаются на клавиатуре IBM/PC дважды. 
              
         1000 REM Листинг 10.1 - программа отображения битов
         1010 REM состояния клавиатуры
         1030 GOSUB 2000  'вывод заголовка
         1040 GOSUB 3000  'дополнительная информация
         1050 GOSUB 4000  'отображение битов клавиатуры
         1060 GOSUB 5000  'проверка завершения ввода с клавиатуры
         1070 GOTO 1050
         
         2000 REM Подпрограмма вывода заголовка
         2010 KEY OFF : CLS : WIDTHS 80 : LOCATE  ,,0
         2020 REM
         2030 LOCATE 5,1
         2040 PRINT " Программы для книги 'Персональный компьютер"
         2050 PRINT " фирмы ИБМ', автор Питер Нортон, 1983"
         2060 PRINT
         2070 PRINT "Программа 10-1: Отображение битов состояния"
         2080 PRINT "клавиатуры"
         2999 RETURN
         
         3000 REM Подпрограмма отображения вспомогательной информации
         3010 LOCATE 11,28
         3020 PRINT "Байт 1   Байт 2";
         3030 LOCATE 12,28
         3040 PRINT "12345678 12345678";
         3050 LOCATE 17,10
         3060 PRINT "Чтобы увидеть изменение битов состояния нажмите";
         3065 PRINT "и удерживайте любую из";
         3070 LOCATE 18,15
         3080 PRINT "-- Левую или правую клавишу смещения";
         3090 LOCATE 19,15
         3100 PRINT "--Ctrl,Alt,Num-Lock,Scroll-Lock,Caps-Lock,Ins";
         3110 LOCATE 21,10
         3120 PRINT "(обратите внимание на влияние смещения и"
         3125 PRINT "Num-Lock yf клавишу Ins) ";
         3130 LOCATE 24,10 
         3140 PRINT "Для выхода в ДОС нажмите любую клавишу ввода";
         3999 RETURN
         
         4000 REM Подпрограмма отображения битов состояния клавиатуры
         4010 DEF SEG = &H40
         4020 CONTROL% = PEEK(&H17)
         4030 CHECK% = 128
         4040 FOR I% = 1 TO 8
         4050   LOCATE 14,27 + I%
         4060   IF CONTROL% >= CHECK% THEN COLOR 30,0 ELSE COLOR 7,0
         4070   IF CONTROL% >= CHECK% THEN PRINT "1"; ELSE PRINT "0";
         4080   IF CONTROL% >= CHECK% THEN CONTROL% = CONTROL%-CHECK%
         4090   CHECK% = CHECK / 2
         4100 NEXT I%
         4110 CONTROL% = PEEK(&H18)
         4120 CHECK% = 128
         4130 FOR I% = 1 TO 8
         4140   LOCATE 14,36 + I%
         4150   IF CONTROL% >= CHECK% THEN COLOR 30,0 ELSE COLOR 7,0
         4160   IF CONTROL% >= CHECK% THEN PRINT "1" ELSE PRINT "0"
         4170   IF CONTROL% >= CHECK% THEN CONTROL% = CONTROL%-CHECK%
         4180   CHECK% = CHECK% / 2
         4190 NEXT I%
         4999 RETURN
         
         5000 REM Подпрограмма ожидания завершения работы
         5010 K$ = INKEY$
         5020 IF LEN(K$) = 0 THEN RETURN 'ожидание ввода с клавиатуры
         5030 IF (LEN(K$) = 2) AND (CHR$(82) = MID(K$,2,1)) THEN
         5035 RETURN  'Нажата клавиша Ins
         5040 CLS : LOCATE ,,1
         5999 SYSTEM
         
         9999 REM Конец программы 10-1
         
              ГЛАВА  11.  ДОПОЛНИТЕЛЬНЫЕ  СРЕДСТВА  -  АДАПТЕР  СВЯЗИ,
                                 ДИНАМИК И ПРОЧЕЕ 

              
              
              В  этой  главе  мы  рассмотрим  доплнительные  средства,
         представляемые  IBM/PC, некоторые их низ более сложны, другие
         менее сложны, но все сложности не  таковы  не  таковы,  чтобы
         посвящать  каждому  из  этих  средств  самостоятельную главу.
         Здесь мы рассмотрим устройство  печати,  асинхронный  адаптер
         связи,  интерфейс  накопителя  на  кассетной магнитной ленте,
         динамик и ряд полезных сведений о системе BIOS в ПЗУ.
              
              11.1. Асинхронный адаптер связи
              
              Асинхронный адаптер связи позволяет  IBM/PC  общаться  с
         внешним  миром  с помощью стандартного метода, известного под
         названием RS-232. В персональных компьютерах  адаптер  RS-232
         обычно используется для двух целей.
              Первая  цель  использования RS-232 собственно для связи,
         по телефонным линиям. При этом адаптер RS-232 подключается  к
         модему   (или   модулятору-демодулятору),  который  выполняет
         преобразование  сигналов  компьютера  в  телефонные  сигналы.
         Модем,  в  свою  очередь, подключается к телефонной линии. На
         другом конце линии должен находиться  другой  модем,  который
         может  быть  подключен  к чему-нибудь. Это может быть все что
         угодно, от универсального компьютера до другого персонального
         компьютера  или  какого-либо  простого  устройства, например,
         устройства печати. Это, нужно сказать, и является  нормальным
         использованием адаптера связи.
              Другой  способ  использования  RS-232 значительно проще.
         Некоторые устройства  вывода  разработаны  в  соответствии  с
         протоколом   взаимодействия   RS-232.   Наиболее   часто  это
         относится  к  устройствам   печати,   особенно   посимвольным
         устройствам.   Таким  образом,  адаптер  связи  IBM/PC  может
         использоваться просто  в  качестве  дополнительного  средства
         взаимодействия   с   периферийным  оборудованием,  таким  как
         устройство печати.
              Сделаем небольшое отступление и рассмотрим два  основных
         способа  взаимодействия персональных компьютеров, в том числе
         IBM/PC, с периферийным оборудованием. Эти два способа  кратко
         называют  последовательным  и  параллельным.  Протокол RS-232
         является "последовательным", поскольку данные  передаются  по
         одной  линии  и  биты  данных  посылаются последовательно, по
         одному.   Параллельная   связь   реализует    другую    схему
         взаимодействия,  которая  по  названию  популярных  устройств
         печати фирмы "центроникс",  получила  название  параллельного
         интерфейса  типа  "Центроникс"  или,  для  краткости,  просто
         параллельного  интерфейса.  При  параллельном  взаимодействии
         данные  передаются побайтно и этот интерфейс включает столько
         линий связи, сколько необходимо чтобы передавать все эти биты
         одновременно.
              Параллельный интерфейс приспособлен для непосредственной
         связи компьютера с внешними устройствами,  в  частности,  что
         данные  могут  передаваться  быстрее,  поскольку за один цикл
         передачи  пересылается   сразу   целый   байт.   Параллельный
         интерфейс   типа   "центроникс"   используется   в   качестве
         стандартного адаптера связи с устройством  печати  в  IBM/PC.
         Последовательный  интерфейс  работает  медленнее,  однако, он
         имеет   ряд   специальных   возможностей   для    организации
         взаимодействия с удаленными объектами. Все эти возможности не
         нужны   при   локальном    использовании    последовательного
         интерфейса,  для взаимодействия с устройством печати. Однако,
         это может оказаться удобным способом организации связи  между
         компьютером  и  устройством печати, в частности, еще и потому
         что многие персональные компьютеры предыдущего  поколения  не
         имели параллельного интерфейса.
              Осуществление   связи   с   удаленным   абонентом  может
         оказаться очень сложной задачей, поскольку  может  возникнуть
         множество    различных    неполадок,    требуется    контроль
         многочисленных ошибок и необходимо работать  с  разнообразным
         оборудованием,   подключенным   к  линии.  Однако,  служебные
         процедуры, входящие в систему BIOS  IBM/PC  для  обслуживания
         адаптера RS-232 достаточно просты и удобны в использовании.
              Имеется всего четыре служебных процедуры для связи и все
         они вызываются с  помощью  прерывания  20,  шестнадцатиричное
         значение  14:  регистр  DX  используется  для  указания того,
         какой адаптер связи должен быть использован, если  их  больше
         одного;  нулевое  значение  соответствует первому (и, обычно,
         единственному) адаптеру. Программы 11-101 и 11-102,  входящие
         в  дисковый  пакет,  прилагающийся  к  этой  книге,  содержит
         ассемблерные  интерфейсы   подпрограммы   и   вспомогательные
         программы    на    Паскале,    позволяющие   наиболее   полно
         воспользоваться всеми процедурами связи системы BIOS в ПЗУ.
              Первая  процедура,  с  кодом  0,  устанавливает   четыре
         стандартных   параметра   связи:  скорость  передачи,  способ
         контроля по  паритету,  количество  стоповых  битов  и  длину
         слова.  Эти  параметры  задают различные вариации организации
         связи. IBM/PC может использовать самые различные их сочетания
         и  обычно конкретные значения определяются тем оборудованием,
         которое находится на другом  конце  линии  связи.  Коды  этих
         переменных выбираются из регистра AL следующим образом:
              Первые  три  бита  задают  скорость  передачи  в битах в
         секунду. Восемь  возможных  значений  соответствуют  довольно
         большим  скоростям  передачи,  хотя  персональные  компьютеры
         наиболее часто используют две скорости - 300  и  1200  бит  в
         секунду. Ниже приведены коды и соответствующие им значения:
              
              Код            Скорость передачи (бит в секунду)
              ___            _________________________________
              
              000                 110  
              001                 150
              010                 300 (примерно 30 символов в секунду)
              011                 600
              100                1200 (примерно 120 символов в секунду)
              101                2400
              110                4800
              111                9600
               
              (Издержки  организации  связи  -  необходимость  передачи
         битов  паритета  и  стоповых  битов - увеличивают число битов,
         необходимых для передачи символа.  Поэтому  скорость  передачи
         300  бит в секунду позволяет передавать примерно 30 символов в
         секунду, хотя в коде символа в ASCII всего 7 или 8 бит).
              Следующие два бита определяют способ контроля по паритету:
               
              Код            Способ контроля
              ___            ________________
              
              00                 отсутствует
              01                 контроль по нечетности
              10                 отсутствует
              11                 контроль по четности
              
              Следующий  бит  указывает  чмсло  используемых   стоповых
         битов, являющихся обязательной частью протокола RS-232:
              
              Код            Число стоповых битов
              ___            ____________________
              
               0                       1
               1                       2
              
              Последние    два    бита   параметра   определяют   длину
         используемого слова:
              
              Код            Длина слова
              ___            ___________
              
              10             7 бит (стандартный код ASCII)
              11             8 бит (обычная длина слова для компьютеров)
               
              Как  правило,  выбор всех этих параметров не произволен и
         определяется  характеристиками  системы  или  оборудования,  с
         которыми Вы связываетесь.
              Вторая  процедура  для связи, с кодом 1, используется для
         пересылки одного байта данных. Этот байт загружается в регистр
         AL и сигнал завершения возвращается в регистр AH. Если пердача
         завершилась неудачно,  то  первый  бит  в  регистре  AH  будет
         установлен  в  единицу,  а значение остальных семи бит будет в
         этом случае таким же, какое описано ниже для процедуры с кодом
         3.  Таким  образом, сравнение содержимого регистра AH с числом
         128 позволит определить успешно ли закончилась  передача.  Как
         обычно,  интерфейсная  процедура,  входящая  в прилагающийся к
         этой книге  пакет,  возьмет  на  себя  заботу  обо  всех  этих
         подробностях.
              Третья  процедура  для связи, с кодом 2, используется для
         приема байта из линии связи. Эта процедура ожидает  завершения
         операции  (которое  может заключаться в обнаружении ошибки или
         условия тайм-аута).
              Эта процедура  содержит  одну  из  наиболее  сушественных
         ошибок  в  исходной  версии системы BIOS-ПЗУ; если версия BIOS
         датирована 24.04.1981, то в ней сообщение о тайм-ауте ошибочно
         передается  как  сообщение  об  ошибке  по паритету с данными,
         готовыми для приема. Определить свою версию BIOS Вы  можете  с
         помощью  отладчика  ДОС-DEBUG.  Если  вызвать  DEBUG  и ввести
         команду:
              
              D F000:FFF5 L8 
              
         то будет отображена дата создания версии BIOS. Более  подробно
         ошибки первой версии ситемы BIOS рассмотрены в главе 6.
              Если  операция  приема  закончилась  успешно,  регистр AH
         будет обнулен. В противном случае, единицы будут в первом бите
         регистра   AH  и  в  некоторых  битах  с  4-го  по  7-ой,  как
         описывается ниже.
              Последняя  процедура,  с  кодом   3,   используется   для
         определения полного текущего состояния порта связи (в регистре
         AH) и его  модема  (в  регистре  AL).  Часть  этой  информации
         сообщается  и при выполнении процедур с кодами 1 и 2. Регистры
         AH и AL устанавливаются следующим образом:
              
              Регистр     Бит           Значение
              _______     ___           ________
              
              AH         1-ый      тайм-аут (кроме BIOS версии 24.4.81)
              AH         2-ой      сдвиговый регистр передачи пуст
              AH         3-ий      буферный регистр передачи пуст
              AH         4-ый      обнаружен разрыв связи
              AH         5-ый      ошибка в битах обрамления
              AH         6-ой      ошибка по паритету (BIOS версии 
                                   24.4.81 устанавливается в случае 
                                   тайм-аута)
              AH         7-ой      коллизия
              AH         8-ой      данные готовы (BIOS версии 24.4.81
                                   устанавливается в случае тайм-аута)
              AL         1-ый      есть сигнал в линии
              AL         2-ой      есть вызов
              AL         3-ий      модем готов
              AL         4-ый      сигнал отбоя посылки
              AL         5-ый      есть дельта - огибающая сигнала при
                                   приеме
              AL         6-ой      есть задний фронт сигнала вызова
              AL         7-ой      есть дельта - огибающая модем
              AL         8-ой      сигнал отбоя по дельта-огибающей
              
              Вся приведенная выше информация предназначена  для  того,
         чтобы   позволить   специалисту   по  телекоммуникации  начать
         программировать для IBM/PC.
               
              11.2. Адаптер устройства печати
              
              Система  BIOS-ПЗУ  включает   процедуры   поддержки   для
         параллельного    адаптера    устройства    печати.   (Различия
         параллельных  и  последовательных  адаптеров   рассмотрены   в
         предыдущем   разделе).  Эти  процедуры  проще,  чем  процедуры
         обслуживания связи, поскольку проще  само  устройство  печати.
         Имеется  всего  три  процедуры и используется только шесть бит
         состояния.
              Для  доступа  к   этим   трем   процедурам   используется
         прерывание  23,  шестнадцатиричное  значение  17.  Регистр  DX
         указывается  для   указания   того,   какой   адаптер   должен
         использоваться,  когда  их  больше  чем  один; ноль обозначает
         первый (и обычно единственный)  адаптер.  Программы  11-101  и
         11-102 в дисковом пакете, прилагающемся к этой книге, включают
         интерфейсные  подпрограммы  на  Ассемблере  и  вспомогательные
         процедуры   на   Паскале,   необходимые   для   более  полного
         использования этих служебных процедур системы BIOS. 
              Одна из незначительных ошибок в исходной  версии  системы
         BIOS-ПЗУ  касается  как  раз  обслуживания  устройства печати.
         Когда  команда  перевода  страницы   посылается   стандартному
         устройству  печати  фирмы  "Эпсон",  система  BIOS  отводит на
         выполнение  этой  операции  несколько  меньше   времени,   чем
         фактически  может  потребоваться  устройству. Это происходит в
         тех случаях, когда команда перевода страницы  выдается  вблизи
         верхнего  края  старой  страницы.  Во  всех версиях BIOS после
         24.4.1981 это время увеличено.
              Первая процедура с кодом 0,  используется  для  пересылки
         одного байта устройству печати. Эта процедура очень проста и о
         ней больше нечего сообщить.
              Вторая процедура  с  кодом  1,  используется  для  сброса
         устройства  печати  и определения его состояния. Эта процедура
         может  использоваться  для  перевода   устройства   печати   в
         нормальное   состояние   после   того  как  ему  были  посланы
         какие-нибудь  специальные  коды   управления.   Информация   о
         состоянии   возвращается   в  регистре  AH,причем  биты  имеют
         следующие значения:
              
              Бит             Значение
              ___             ________
              
              1-ый         устройство печати занято
              2-ой         сигнал подтверждения
              3-ий         сигнал отсутствия бумаги
              4-ый         сигнал выборки
              5-ый         сигнал ошибки вывода
              6-ой,7-ой    не используются
              8-ой         сигнал тайм-аута (для BIOS версии 24.4.1981
                           это может оказаться ложная тревога)
              Третья и последняя процедура с кодом 2  используется  для
         чтения битов состояния, описанных выше, без выполнения сброса.
         Эта  процедура  особенно  полезна  для   программ   управления
         устройством печати.  
              Вот  и  все, что нужно былосказать об устройстве печати.
         Это не слишком сложное устройство и,  соответственно,  просты
         процедуры его обслуживания. 
         
              11.3. Интерфейс кассетного накопителя
              
              Очередная  часть ссистемы BIOS-ПЗУ относится к интерфесу
         кассетного накопителя. Он практически никем не используется и
         многие,  включая и меня, не видят других причин включения его
         в состав IBM/PC,  кроме  чисто  коньюктурных  проблем  сбыта.
         (Более подробно этот вопрос рассматрьивается в главе 2).
              Имеется  всего  четыре  простых  служебных процедуры для
         обслуживания кассетного накопителя  :  дл[  чтени[  и  записи
         блоков   данных  и  для  включения  и  выключения  двигателя.
         Отсутствуют команды перемотки кассеты:  эта  операция  должна
         выполняться вручную с пульта управления кассетным накопителем.
              Заметим,   что   имеющиеся  команды  носят  "физический"
         характер, и совсем нет "логических команд, таких как  команда
         поиска  файла.  Команды такого рода относятся скорее к уровню
         операционной системы, чем к уровню системы  BIOS  -  в  конце
         концов,    система    BIOS   должна   обеспечивать   наиболее
         примитивный,  элементарный  уровень  обслуживания,  на   базе
         которого  могут строиться логические процедуры более высокого
         уровня. К сожалению, ДОС совершенно не поддерживает интерфейс
         кассетного накопителя, так что с ним можно работать только из
         Бейсика  или  на  примитивном  уровне   системы   BIOS.   Это
         существенно   ограничивает  возможности  тех,  кто  хотел  бы
         серьезно использовать кассетный  накопитель.
              Для доступа к четырем процедурам обслуживания кассетного
         накопителя   используется  прерывание  21,  шестнадцатиричное
         значение 15. Программы 11-101 и  11-102  в  дисковом  пакете,
         прилагающемся    к    этой   книге,   включают   интерфейсные
         подпрограммы на ассемблере  и  вспомогательные  процедуры  на
         Паскале,  необходимые  для  более  полного использования этих
         служебных процедур системы BIOS.
              Первая  процедура,  с  кодом   0,   включает   двигатель
         кассетного  накопителя.  Эта процедура возвращает уцправление
         немедленно,  не  ожидая  пока  двигатель  раскрутится  -  это
         необходимо учитывать.
              Вторая процедура, скажем 1, выключает двигатель.
              Третья  процедура,  с  кодом  2, используется для чтения
         блоков данных с кассеты. Данные  передаются  блоками  по  256
         байт  и  за один раз можно считывать несколько блоков. Если в
         процессе передачи данных будект обнаружена ошибка,  сообщение
         об этом будет передано в регистре AH.
              
              Код ошибки              Значение
              __________              ________
              
                  1       обнаружена ошибка  циклического  избыточного
                          кода (CRC)
                  2       утрачены   некоторые    реквизиты     данных
                          (использующиеся  для  записи  размещения   и
                          информации о битах) 
                  4       данные не найдены
              
              
              Четвертая процедура, с кодом 3, использщуется для записи
         блоков данных на кассету.
              На  этом  мы  завершаем  изучсение  служебных   процедур
         системы  BIOS-ПЗУ, предназначенных для поддержки периферийных
         устройств, подключаемых к IBM/PC, но этим не исчетпывается ни
         система  BIOS, ни оборудование IBM/PC. В следующем разделе мы
         рассмотрим все остальное. Но  прежде  чем  двигаться  дальше,
         нужно  сообщить  еще  одну подробность, касающуюся интерфейса
         кассетного накопителя.
              Интерфейс кассетного  накопителя  IBM/PC  разрабатывался
         только  для  подключения  кассетного накопителя к IBM/PC и он
         практически не используется ни в одном компьютере.  некоторые
         умные  люди  приспосабливают  этот  интерфейс  для соединени[
         IBM/PC   с   другими   устройствами.   Одно   из    возможных
         использований  -  подключение специализированных контроллеров
         буферированного приема/передачи.
              
              11.4. Дополнительные процедуры системы BIOS
              
              Помимо тех процедур, которые мы уже рассмотрели, система
         BIOS   включает  еще  ряд  интересных  и  полезных  служебных
         процедур. Программы 11-101  и  11-102,  входящие  в  дисковый
         пакет,   прилагаемый  к  этой  книге,  включают  интерфейсные
         подпрограммы на ассемблере  и  вспомогательные  процедуры  на
         Паскале,   позволяющие   наиболее   полно   использовать  эти
         служебные процедуры системы BIOS.
              Первая из  этих  процедур  -  это  процедура  распечатки
         содержимого  экрана.   Она   обычно   вызывается   процедурой
         обслуживания   клавиатуры   системы   BIOS-ПЗУ,   когда    та
         обнаруживает   нажатие  клавиши  "PrtSc".  Распечатка  экрана
         выполняется программой обслуживания прерывания номер 5 и  это
         позволяет  программно  вызывать  ту  же  операцию, запрашивая
         прерывание  номер  5.  Процедура   обслуживания   клавиатуры,
         обнаружив нажатие клавиши "PrtSc", просто вызывает прерывание
         5.
              Пользующиеся интерпретатором Бейсика замечали,  что  при
         работе  с  Бейсиком  клавиша  "PrtSc"  не  действует. Однако,
         имеется простой способ вызова программы распечатки экрана  из
         программ   на   Бзйсике.  Сам  интепретатор  изменяет  способ
         обслуживания клавиатуры и здесь ничего  изменить  нельзя,  но
         можно  просто запросить из программы на Бейсике прерывание 5,
         описанное выше.
              Для  программ   на   Бейсике   необходима   интерфейсная
         процедура   на   машинном  языке,  позволяющая  обратиться  к
         операции распечатки  экрана,  Это  очень  простая  процедура,
         состоящая  всегно  имз  двух команд, занимающих три байта. На
         я[зыке ассемблера эти команды записываются так:
              INT; вызов прерывания номер 5 (распечатка экрана)
                 ; (2-х байтная команда)
              RET;  взврат в программу на Бейсике (1 байт)
              Такую  простую  подпрограмму  можно  просто  записать  в
         память  командами POKE и, поскольку длина ее всего три байта,
         можно использовать числа обычной точности, Следующая короткая
         программа показывает, как это делается:
              
              100  REM  Простая  программа,  позволяющая организовать
              110  REM  вызов операции распечатки экрана из Бейсика
              120  REM  Трехбайтная программа на машинном языке
              125  REM  формируется внутри переменной.
              
              130  HOLD.THE.CODE = 0 'выделяется 4-байтная переменная
              140  REM                обычной точности
              150  PRINT.SCREEN = VARPTR(HOLD.THE.CODE)'  установка
                                                          указателя
              160  REM                на область памяти
              170  POKE PRINT.SCREEN + 0,205 '1-й байт подпрограммы -
              175  REM                команда прерывания (INT)
              180  POKE PRINT.SCREEN + 1,5  '2-й байт - номер преры-
                                      вания 5
              190  POKE PRINT.SCREEN + 2,203 '3-й байт -команда возв-
                                      рата
              200  REM
              210  REM Теперь подпрограмма в машинных кодах
              220  REM храниться в переменной "hold.the.code"
              230  REM и ее адрес храниться в "print.screen"
              240  REM
              250  CALL PRINT.SCREEN
              
              В  этой  простой  программе  строки  120-170  записывают
         подпрограмму  в  машинных  кодах.  Эту  процедуру  достаточно
         выполнить   один  раз.  Оператор  CALL  в  строке  250  может
         выполняться тогда, когда  необходимо  распечатать  содержимое
         экрана.  (Интерфейсные подпрограммы для всех процедур системы
         BIOS и ДОС включены в  дисковый  пакет,  прилагаемый  к  этой
         книге,  но  такой  простой интерфейс, как тот, который описан
         выше, можно оформить непосредственно на  Бейсике.  Для  более
         сложных  процедур  обычно  требуются законченные интерфейсные
         подпрограммы на  ассемблере,  которые  могут  загружаться  из
         Бейсика процедурой BLOAD).
              Следующая  из  дополнительных  процедур  системы  BIOS -
         процедура вывода списка оборудования,  которая  вызывается  с
         помощью  прерывания  номер 17, шестнадцатеричное значение 11.
         При первом включении IBM/PC процедуры запуска и  самопроверки
         проверяют,   какое   оборудование   подключено  к  IBM/PC  (в
         основном,   проверка   сводится    к    считыванию    позиций
         переключателей,  установленных на системной плате IBM/PC; эти
         переключатели  должны  выставляться  определенным  образом  в
         зависимости  от  состава  подключенного  оборудования.  Такой
         метод не слишком точен, поскольку  переключатели  могут  быть
         выставлены неправильно).
              Ваши  программы  могут  выяснить  конфигурацию  системы,
         запрашивая   прерывание   17.   При   выполнении    процедуры
         обслуживания   этого  прерывания  не  производится  ни  новая
         проверка  состава  оборудования,  ни   повторное   считывание
         положений  переключателей.  Происходит  всего  лишь пересылка
         двух байтов, содержащих код конфигурации системы,  вызывающей
         программы в регистрах AH и AL.
              Ниже приведена таблица кодов оборудования:
              
              Регистр       Бит        Значение
              _______       ___        ________
              
                AH          1-2      число адаптеров устройства печати
                                     (от 0 до 3)
                AH           3       не используется
                AH           4       игровой адаптер подключен или нет
                AH         5-7       число адаптеров связи (от 0 до 7)
                AH           8       не используется
                AL         1-2       число   дисководо  в без  единицы
                                     (если установлен 8-ой бит)
                AL         3-4       начальный  видеорежим (см.таблицу
                                     ниже)
                AL         5-6       объем  памяти  на системной плате
                                     (см.таблицу ниже)
                AL           7       не используется
                AL           8       дисководы подключены (если да, см.
                                     1 и 2 биты)
              
              
              Заметим, что число дисководов, задаваемое первыми  двумя
         битами    AL,    копируется   числом,   на   единицу   меньше
         действительного числа,  так  что  значение  00  соответствует
         одному  дисководу,  01  -  двум  и так далее. С помощью такой
         схемы кодирования  указывается  наличие  до  4-х  дисководов.
         Восьмой бит указывает, имеются ли вообще дисководы в системе.
         Если этот бит установлен, то используются бва бита  счетчика.
         Проще  было  бы  использовать  три бита для кодирования числа
         дисководов, что позволило бы задавать числа от 0 до 7.
              Следующая таблица поясняет значения битов для начального
         видеорежима:
              
              Биты                       Значение
              ____      _____________________________________________
              
               00       (не используется)
               01       графический режим, 40   столбцов,  черно-белое
                        изображение 
               10       графический режим, 80   столбцов,   черно-белое
                        изображение 
               11       монохромный режим
              
              
              Следующая  таблица  поясняет  установку  битов  для кода
         объема памяти на системной плате:
              
                          Бит                   Значение
                          ___             ______________________             
              
                          00                     16К
                          01                     32К
                          10                     48К
                          11                     64К
              
              Ваши программы могут  использовать  эту  информацию  для
         настройки своей работы на конфигурацию системы.
              Следующая   процедура   сообщает,   какой  объем  памяти
         подключен к компьютеру. Имеется ввиду объем  рабочей  памяти,
         включающий   объем  памяти  на  системной  плате  (сообщаемый
         предыдущей процедурой) и  дополнительные  платы  памяти.  Для
         ызова  этой процедуры служит прерывание 18, шестнадцатиричное
         значение  12,  а  значение,  возвращаемое  в   регистре   AX,
         равняется  числу  блоков  памяти  размером  1К.  Такой способ
         позволяет определить полный объем памяти в один мегабайт.
              Значение  объема  памяти   не   устанавливается   прямой
         проверкой,  а  берется  из  стандартной  ячейки  памяти.  Это
         позволяет программно изменять объем используемой памяти.
              Одно  из  самых  полезных  средств для работы с IBM/PC с
         большим объемом памяти (например,  512К)  включает  системную
         программу,  которая  использует  часть памяти как некий очень
         быстрый накопитель  на  гибком  диске,  т.е.  так  называемый
         элекронный  диск  .  Такой тип модификации системы может быть
         очень полезен и начинает использоваться все  шире.  Для  того
         чтобы  иметь  возможность  выделения  физической  памяти  для
         какого-нибуть  специфического  использования,  IBM/PC  хранит
         рабочее значение объема доступной памяти в ячейке оперативной
         памяти,  содержимое  которой  можно  изменить.  И  при  любом
         использовании  памяти, например, при ее выделении программам,
         объем памяти всегда сравнивается с этим значением.
              Еще  одна  интересная  особенность  ПЗУ  не  связана   с
         системой BIOS, а относится к способу вызова кассетной системы
         Бейсика, которая также хранится  в  ПЗУ.  Если  значение  18,
         тогда   уравление   компьютером   передается   иетерпретатору
         Бейсика. Следует иметь в виду,  что  такая  операция  уже  не
         позволит  снова  получить  управление  Вашей программе и даже
         операционной системе ДОС.
              Еще одна процедура, которая удаляет Вашу программу и ДОС
         из  системы, - это процедура начальной загрузки, вызывающаяся
         прерыванием 25, шестнадцатиричное значение 19. Эта  процедура
         перезагружает  операционную  систему  с диска, так же как это
         происходит после нажатия клавиши  Ctrl-Alt-Del.  Единственное
         отличие   заключается   в   том,   что  при  нажатии  клавиши
         Ctrl-Alt-Del выполняется диагностика системы,  такая  же  как
         при  включении  питания,  а  при  запросе прерывания 25 сразу
         производится загрузка системы. Это один из самых  радикальных
         способов завершения программы, гарантирующий наличие в памяти
         новой копии операционной системы. 
              Следующая  процедура  -   это   процедура   обслуживания
         таймера.   Она   используется   для  считывания  и  изменения
         внутреннего счетчика таймера. Хотя эту процедуру  и  называют
         процедурой текущих даты/времени, на самом деле это всего лишь
         счетчик прерываний таймера. Счетчик увеличивается на  единицу
         при  каждом прерывании, которое происходит примерно 18-21 раз
         в секунду. Вычисление и обновление времени дня и даты  -  это
         операция ДОС, которая использует результаты счетчика.
              имеется две процедуры обслуживания таймера, вызывающиеся
         по прерыванию 26, шестнадцатиричное значние 1А, одна, с кодом
         0, для считывания показаний таймера, а вторая, с кодом 1, для
         их установки. Значение счетчика таймера хранится в виде  пары
         двухбайтовых  чисел,  использующихся,  фактически,  как  одно
         четырехбайтовое. Эта процедура вносит лишь одно добавление  в
         примитивную  процедуру подсчета частов. Когда это происходит,
         счетчик  сбрасывается  и  факт  запоминается.  При  очередном
         запросе  на считывание значения счетчика передается сообщение
         о том, что таймер сбрасывался. 
              Это позволяет ДОС следить за временем дня и  сменой  дат 
         не  вычисляя  их  постоянно.  Когда ДОС необходимо установить 
         время дня, используется  описанная  процедура  для  получения 
         значения  счетчика  и  по  нему вычисляется время; если будет 
         получено сообщение о сбросе таймера, то ДОС изменит  также  и 
         дату.  Таким образом, ДОС выполняет все эти вычисления только 
         тогда,когда требуется указать  время,  что  упрощает  функции 
         процедуры  обслуживания прерываний от таймера, которая должна 
         выполняться 18 раз в секунду. Если к ДОС будет хотя  бы  один 
         запрос  времени  за  день,  то  проверить  это,  оставив  Ваш 
         компьютер включенным на 24 часа. К концу Вашей проверки время 
         дня будет по прежнему правильным, а дата ошибочной). 
              Если   Вы   будете   сами  считывать  или  устанавливать
         показания таймера с помощью этих процедур системы  BIOS,  это
         может  помешать правильному отсчету времени и даты в ДОС. ДОС
         устанавливает значение счетчика таймера  таким  образом,  как
         будто  он  был  запущен  в  полночь, после чего ДОС полностью
         полагаетс[  на  значение  признака  сброса   таймера.   Любая
         установка или считывание показаний таймера Вашими программами
         естественно окажет влияние на отсчет времени в ДОС. Если Ваши
         программы будут только считывать показания таймера, это может
         привести к перехвату сообщения о сбросе таймера, что  нарушит
         порядок отсчета даты в ДОС.
              Теперь мы рассмотрели все процедуры системы BIOS-ПЗУ.
              Вы  могли  обратить  внимание  на два упущения в составе
         этих процедур. В то время как  все  устройства,  подключаемые
         стандартным   образом,   имеют  поддерживающие  их  служебные
         процедуры,совершенно не поддерживается игровой  адаптер.  Это
         происходит  потому,  что  такая  поддержка просто не нужна. Я
         могу  только  предполагать  почему  это  произошло;  одна  из
         возможных  причин может заключаться в том, что форма "ИБМ" не
         сочла  этот  адаптер  дочтаточно  важной   составной   частью
         системы,  которой  требуется  какая-либо  поддержка на уровне
         системы  BIOS.  Возможно,  также  что  игровой  адаптер   был
         доставлен   к   системе   на  достаточно  поздней  стадии  ее
         разработки и его поддержка не могла быть включена  в  систему
         BIOS, размещенную в ПЗУ.
              Еще  одна  недостающая  часть  системы  BIOS - это набор
         процедур для обслуживанния встроенного динамика.  Почему  они
         не  были  включены  в  систему  -  это  для  меня  загадка. В
         следующем разделе мы рассмотрим работу  динамика  и  то,  как
         извлекать из него звуки под управлением программы.
              
              11.5. Рецензия звука с помощью динамика
              
              К  сожалению,  в системе BIOS нет универсальных процедур
         обслуживания встроенного в IBM/PC динамика.  Хотя  в  системе
         имеются  две  подпрограммы,  позволяющие  извлекать  звуки из
         динамика, но они могут  использоваться  только  внутри  самой
         системы BIOS - это не служебные процедуры общего пользования.
              В  данном  разделе  мы поясним работу динамика и поясним
         основы его использования.Дисковый пакет, прилагающийся к этой
         книге,  содержит служебные подпрограммы на Ассемблере,которые
         обеспечат Вам доступ ко всем возможностям динамика.
              Любой    громкоговоритель    -     будь     то     часть
         высоко-качественной системы воспроизведения звука, телефонный
         динамик или динамик  IBM/PC  -  работает  за  счет  получения
         последовательности  электрических импульсов, которые вызывают
         отклонение диафрагмы динамика, вызывающее колебания  воздуха,
         образующие  звук.  В  обычном  динамике, поступающие импульсы
         имеют различную мощность (громкость) и длительность  (частоту
         или   высоту  тона).  Простой  динамик  IBM/PC  не  позволяет
         регулировать   громкость    и    звук    образуется    просто
         последовательностью  электрических  импульсов. Ток к динамику
         подается  и   отключается   в   режиме   простого   двоичного
         управления.   Частота   импульсов  тока  определяет  звуковую
         частоту,  вырабатываемую  динамиком.   Например,   если   ток
         включается  и  выключается  300  раз  в  секунду,  то динамик
         генерирует звук частотой 300 герц.
              Схемы управления динамиком очень интересно  организованы
         и  обеспечивают  два  способа  формирования  звука. Импульсы,
         посылаемые  динамику,  управляются  комбинацией  программного
         сигнала  и программируемого таймера. Два способа формирования
         звука определяются тем, используется таймер или нет.
              Сначала   рассмотрим   как    формируется    звук    без
         использования   таймера.   Чтобы  заставить  динамик  звучать
         программа должна задавать импульсы нужной частоты  в  течение
         нужного   времени.   Хотя   это  делается  на  ассемблере,  я
         использовал   Паскале-подобные   конструкции    просто    для
         иллюстрации логики этой операции. Предположим, что необходимо
         воспроизвести  звук  с  частотой  300  герц,  который  должен
         звучать половину секунды. Вот что необходимо сделать:
              повторить  150  раз  { то есть, 1/2 секунды, при частоте
         300 Гц }
              начало
              импульс отключения динамика
              задержка на 1/600 секунды {половина цикла}
              {задержка  времени  выполняется  с   помощью   холостого
         цикла, повторяющегося нужное число раз}
              импульс включения динамика
              задержка еще на 1/600 секунды {вторая половина цикла}
              конец;
              Если  Вы  внимательно  изучите  программу  на ассемблере
         BEEP/WARBLE, приведенную в виде листинга 3.2. в главе  3,  Вы
         заметите, что она работает именно таким образом.
              Это очень хороший способ воспроизведения звука, но он не
         позволяет программе ничего  делать,  кроме  генерации  звука.
         Фактически,  эта  маленькая  программа использует весь ресурс
         микропроцессора 8088, не делая ничего кроме подсчета  времени
         и  формирования  импульсов для динамика. Для этого есть более
         совершенный способ, использующий таймер.
              Одна  из  скрытых  возможностей  IBM/PC  -  это  наличие
         программируемого  таймера. Он не измеряет никаких промежутков
         времени, а только подсчитывает импульсы  основного  тактового
         генератора   системы.   Для  этого  таймера  задается  число,
         называемое коэффициентом деления (или просто делителем), и он
         подсчитывает   число   импульсов   тактового   генератора   и
         сравнивает это число с делителем. Когда эти числа сравняются,
         таймер выдает сигнал и снова начинает подсчет с нуля.
              Системный   тактовый   генератор   работает  на  чистоте
         1,19мГц.  Так  что  если  таймер  запрограммирован  на  10000
         импульсов,  он  будет  выдавать  сигналы  примерно  100 раз в
         секунду. Можно добиться любой  частоты  импульсов  на  выходе
         таймера,  подбирая  соответствующий  делитель. После загрузки
         делителя  схемы   динамика   запускаются   для   работы   под
         управлением  таймера,  после  чего  выходные  сигналы таймера
         будут управлять  частотой  формируемого  звука,  а  компьютер
         может выполнять любую другую работу.
              Такой    способ    управления    динамиком     позволяет
         программам  работать,  пока динамик воспроизводит звук. Таким
         образом  организована  работа  одной  из  процедур   Бейсика,
         фоновая   музыка   или   MB.   Небходимо  заметить,  что  при
         формировании звука с помощью таймера, он  продолжает  звучать
         до  тех  пор,  пока  он не будет отключен той же программой ,
         которая его запустила.
              Листинг 3.2. может  использоваться  в  качестве  примера
         формирования  звуков  без использования таймера. Программа на
         ассемблере, представленная листингом  11.1.,  показывает  как
         запустить звучание динамика с помощью таймера. 
         
         
         
              Приложение 11.1. Текст программы генерации звука с 
         использованием таймера (Ассемблер).
         
         
         a440seg segment 'code'
         
               assume cs:a440seg
               
         a440  proc   far
         
               mov    al,0b6h
               out    67,al
               
               mov    ax,2711
               out    66,al
               mov    al,ah
               out    66,al
               
               in     al,97
               or     al,03
               out    97,al
               
               int    20h
               
         a440  endp
         
         a440seg  ends

               end
         
              
              
           
                

              
