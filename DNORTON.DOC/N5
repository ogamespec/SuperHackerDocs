             
         
                       Глава 6. ВЫБОРКА ИЗ ПЗУ
              
              
              Программы,   размещаемые   в   пассивном    запоминающем 
         устройстве (ПЗУ ) компьютера IBM/PC, определяют эффективность 
         работы персонального компьютера в целом. В  данной  главе  мы 
         излагаем  самые общие сведения, касающиеся ПЗУ. Мы рассмотрим 
         назначение   ПЗУ,   специфику   анализа    и    декодирования 
         (реконструкции) хранящейся там информации и, наконец, сравним 
         между собой две первые версии ПЗУ компьютера IBM/PC. Все  эти 
         материалы являются базой для последующих пяти глав, в которых 
         функциональные  возможности  IBM/PC   рассматриваются   более 
         детально. 
              Здесь  важно  иметь в виду три аспекта. Все о чем пойдет 
         речь в данной главе в полной мере относится только  к  IBM/PC 
         и,  вообще  говоря,  не  распространяется  на  все  семейство 
         компьютеров, работающих под управлением MS-DOS. Для остальных 
         компьютеров  семейства  PC эти сведения следует рассматривать 
         применительно  к  конкретному  компьютеру  (поскольку  каждой 
         модели  присущи  свои особенности). Тем не менее, имеются все 
         основания  считать,  что  прерывания   или   вызовы   функции 
         обслуживания  для большинства компьютеров совпадают. Поэтому, 
         несмотря   на   возможное    изменение    адресов    программ 
         обслуживания,  находящихся  в  ПЗУ  компьютера  той  или иной 
         модели материалы настоящей и последующих пяти глав  сохраняют 
         свою актуальность. 
              
              
               6.1. Организация ПЗУ и его использование
              
              
              Программы,   хранящиеся   в   ПЗУ,   представляют  собой 
         чрезвычайно  важную  компоненту  IBM/PC,  поскольку  являются 
         основой  управляющей  программы,  делающей  ПЭВМ  эффективным 
         инструментом обработки данных. Сам факт их размещения  в  ПЗУ 
         превращает эти программы в стабильный и надежный инструмент - 
         они не могут быть стерты  или  уничтожены.  Кроме  того,  они 
         доступны   для   любой   программы,  выполняемой  на  IBM/PC, 
         независимо от специфики используемой операционной системы. 
              Большинство программ обслуживания,  размещаемых  в  ПЗУ, 
         допускают  перемещение. Эти программы написаны таким образом, 
         что   при   необходимости   их   можно   легко   переместить, 
         соответственно   перестроив   обращение   к   ним.  Специфика 
         обращения к программам ПЗУ состоит в том, что их  активизация 
         производится всегда через систему прерываний. Изменив таблицу 
         векторов прерываний, можно легко изменить точку  входа  в  ту 
         или    иную   программу   обслуживания.   Эти   вопросы   уже 
         рассматривались нами при изучении материала главы 3. 
              Как уже говорилось выше,  все  пространство  памяти  ПЗУ 
         компьютера IBM/PC делится на три части, под которые отводятся 
         старшие адреса миллионного пространства памяти. 
              Самые  старшие  адреса  памяти,  соответствующие  началу 
         параграфа  сегмента  с адресом FE20/16, и охватывающие 8Кбайт 
         до конца памяти  отводятся  под  BIOS,  или  Базовую  Систему 
         Ввода-Вывода.Базовая  Система  Ввода-Вывода  (BIOS) выполняет 
         все операции по обслуживанию периферийных  устройств  IBM/PC, 
         таких  как дисплеи или накопители на гибких магнитных дисках. 
         Все    программы    операционой    системы,    обеспечивающие 
         функционирование  ПЭВМ  ориентируются  на использование BIOS. 
         Область памяти  ПЗУ,  содержащая  BIOS,  представляет  особый 
         интерес  для  тех,  кто  хотел  бы в полной мере использовать 
         возможности  IBM/PC.  В  последующих  пяти  главах  по   мере 
         рассмотрения  конкретных  функций  IBM/PC  мы  будем детально 
         обсуждать  служебные   обращения   к   BIOS,   обеспечивающие 
         реализацию этих функций. 
              Справочное   руководство  по  техническому  обслуживанию 
         персонального компьютера содержит полный текст первой  версии 
         BIOS;  при  этом  комментарии хорошо поясняют, что делается и 
         как делается; вопрос, почему  это  делается,  раскрыт  слабо. 
         Если  Вы  имеете  навыки  интерпретации  листингов  на  языке 
         ассемблера, то при изучении листинга BIOS Вы получите  ответы 
         на любые вопросы о принципах функционирования ПЭВМ. 
              Вторая    часть    ПЗУ,    соответствует   параграфу   с 
         шестнадцатеричным адресом F600 и занимает  32  Кбайт  памяти. 
         Она  содержит (хранит) программы интерпретатора языка Бэйсик. 
         В ПЗУ хранится ядро интерпретатора языка Бэйсик  для  IBM/PC. 
         Все  кассетные  версии языка Бэйсик соответствуют Бэйсик-ПЗУ; 
         основные функциональные возможности дисковой версии  Бэйсика, 
         а  также расширенный Бэйсик (BASICA) фактически реализованы в 
         ПЗУ. Практически все, что делают две  указанные  выше  версии 
         Бэйсика  -  это расширение версии Бэйсик-ПЗУ. Соответственно, 
         Бэйсик-ПЗУ -  это  полная  версия  языка  Бэйсик,  содержащая 
         основные программы, требуемые для дисковых версий. 
              С  появлением  в  справочном руководстве по техническому 
         обслуживанию текста программ BIOS не  имет  смысла  приводить 
         текст  программ  Бэйсик-ПЗУ;  однако  в ряде случаев мы будем 
         использовать фрагменты этой программы для иллюстрации методов 
         исследования содержимого ПЗУ. 
              Сама   по   себе  область  ПЗУ,  содержащая  Бэйсик,  не 
         представляет особого  интереса,  однако  коль  скоро  в  этой 
         области расположено множество полезных программ, то почему бы 
         ими не воспользоваться в своей собственной разработке?  Поиск 
         и  декодирование  нужных  фрагментов Бэйсика с последующим их 
         тщательным  документированием   представляет   собой   весьма 
         трудоемкую задачу, нами в данной работе не решаемую. 
              Подпрограмма    или    функция    Бэйсика   может   быть 
         непосредственно активизирована из  программы  пользователя  с 
         помощью   механизма   прерываний.  В  главе  11  эти  вопросы 
         рассматриваются с необходимой полнотой. 
              Третий   и   последний   участок   ПЗУ   нами  здесь  не 
         рассматривается. Фирма IBM оставляет за собой право расширять 
         состав  программ  ПЗУ;  пользователи также могут встраивать в 
         ПЗУ свои программы,  расширяя  таким  образом  функциональные 
         возможности IBM/PC. Дополнительные программы можно включать в 
         любое место миллионного адресного пространства, однако  блок, 
         начинающийся  с  шестнадчатиричного  адреса  параграфа F400 и 
         занимающий 8Кбайт, вплотную  прилегающий  к  участку  памяти, 
         отведенного под Бэйсик специально выделен для таких программ. 
         Если  требуется  свыше  8Кбайт  памяти,  то  программу  можно 
         сместить  в  область  памяти с более низкими адресами. Именно 
         посредством включения в ПЗУ специализированных программ можно 
         превратить  IBM/PC в спкциализированный компьютер. Прежде чем 
         приступить к более глубокому изучению BIOS мы подемонстрируем 
         (в   двух   последующих   параграфах)   способы  исследования 
         содержимого ПЗУ. 
              
              
              6.2. Анализ содержимого ПЗУ средствами программы DEBUG 
              
              
              В  данной  главе  мы  рассмотрим   особенности   анализа 
         программ  и  данных,  размещаемых  в ПЗУ. Несмотря на то, что 
         предлагаемая  методика  ориентируется  главным   образом   на 
         программы,  расположенные  в  ПЗУ,  она  может использоваться 
         также и в случае программ,  хранящихся  на  дискете.  Поэтому 
         все, о чем пойдет здесь речь применимо как к компонентам DOS, 
         расположенным на дискете, так и  к  компонентам,  входящим  в 
         состав других программ. 
              Доступ  к  любому  фрагменту  ПЗУ может быть осуществлен 
         также  средствами  Бэйсика  или  Паскаля.  Методы   адресации 
         объектов  памяти,  рассмотренные в главе 3, позволяют работая 
         на Бэйсике или Паскале, обратиться  к  любой  ячейке  памяти. 
         Ниже  приводится  пример  программы  на Бэйсике, отображающий 
         содержимое ПЗУ. 
              
         100 REM     отображение фрагмента ПЗУ в шестн. формате     
         110 PARAGRAPH=&HF600
         120 DEF SEG=PARAGRAPH
         130 PRINT
         140 PRINT "Отображение содержимого параграфа",HEX$(PARAGRAPH)
         150 PRINT
         160 PRINT "Десятичное       Шестнадцатеричное"
         170 PRINT "Смещение   Смещение   Содержимое ПЗУ";
         180 OFFSET%=0
         190   FOR LINES%=1 TO 16
         200     PRINT
         210     PRINT OFFSET%, HEX$(OFFSET%)   
              
              Хотя  приведенная  программа  позволяет  нам  судить   о 
         содержимом  ПЗУ,  смысл даных остается "за кадром". Мы, таким 
         образом, подошли к очень важному и необходимому  инструменту, 
         поставленному в составе DOS - программе DEBUG. 
              Программа DEBUG позволяет осуществлять три вида действий
         вотношении содержимого  ПЗУ:  выборку  произвольного  участка
         памяти  и  отображать  ее  содержимое  в  двух  форматах:
              1)шестнадцатеричный / ASCII.      
              2)формат не связанный с деассемблированием.
              Программа   DEBUG  может  быть  также  использована  для 
         исследования программ, хранящихся  на  дискете.  В  последнем 
         случае, правда, представляется более эффективным использовать 
         программу Disklook,  записанную  на  дискету,  прилагаемую  к 
         данной  книге или программу SecMod входящую в состав программ 
         Norton Utility. Прежде чем двигаться  дальше,  поясним  смысл 
         термина "деассемблирование". 
              Программы,  представленные  на  языке  машинных  команд, 
         чрезвычайно  сложны  для  восприятия человеком. Даже в случае 
         компьютеров, имеющих  сравнительно  простой  формат  машинных 
         команд, этот язык весьма сложен для понимания. Микропроцессор 
         8088 регламенитрует очень сложную  структуру  языка  машинной 
         команды.  Это  положение  справедливо в отношении большинства 
         микропроцессоров - их проектировщики жертвуют  простотой  для 
         достижения  максимальной  производительности  и  компактности 
         кода.  Вследствие  этого,  требуется  приложить  значительные 
         усилия для просмотра и понимания листинга, представленного на 
         языке машинных команд в шестнадцатеричном коде. 
              Процесс  деассемблирования, реализуемый программой DEBUG, 
         значительно облегчает поцедуру интерпретации машинного языка. 
         Деассемблирование - это  процесс  трансляции или преобразования 
         инструкций  машинного  языка,  представленных  в   абсолютном 
         шестнадцатеричном   виде   в   символическую   нотацию  языка 
         ассемблера. Так, например, на языке ассемблера можно записать 
         INC   AX  (увеличить  содержимое  регистра  AX  на  единицу); 
         ассемблер переведет эту конструкцию  в  команду  на  машинном 
         языке  с  кодом  40/16.  Функция  деассемблера состоит в том, 
         чтобы привести команду машинного языка с кодом 40/16  обратно 
         к виду INC AX. 
              Шестнадцатеричный  код  40 сравнительно легко может быть 
         преобразован и вручную,  при  наличии  таблицы  кодов  команд 
         микропроцессора  8088.  С большинством кодов остальных команд 
         дело обстоит не так просто, поскольку в  ряде  случаев  смысл 
         команды  изменяется  в  зависимости  от  значения  кокнретных 
         битов. В случае использования команды  DEBUG  все  запутанные 
         случаи   декодирования   преодолеваются   в  режимах  команды 
         деассемблирования. 
              Несмотря   на   то,   что  деассемблер  может  выполнить 
         преобразование  команд  машинного  языка  к   более   удобным 
         командам  языка  ассемблера,  целый  ряд  весьма существенных 
         компонентов  программы,  написанной   на   языке   ассемблера 
         реконструкции  не  поддается.  Так,  очевидно,  не могут быть 
         восстановлены весьма полезные комментарии программиста. Кроме 
         того,  не  представляется возможным восстановить оригинальные 
         символические имена адресов памяти. 
              Таким образом, вместо оригинальной авторской конструкции 
         типа 
              IMP FINISH; выполнено, перейти к завершающей процедуре
              
         деассемблер сгенерирует строку вида
                             IMP  OE6C
              Пользователь видит перед собой команду перехода,  однако 
         ее смысл остается для него неясным. 
              Деассемблер,   безусловно,   не  в  состоянии  полностью 
         заменить программиста, особенно, в том, что  касается  смысла 
         деассемблируемой   программы.   Но  он  существенно  упрощает 
         задачу,  когда  предъявляет  пользователю  команду,  а  также 
         помогает   отличить  область  памяти,  содержащую  данные  от 
         области памяти, содержащую команды. 
              Для иллюстрации особенностей исследования  программ  ПЗУ 
         возьмем  программу Бэйсика и используем ее в качестве объекта 
         приложения программы DEBUG. Все дополнительные сведения будут 
         сообщены  ниже, либо проясняться в ходе рассмотрения примера. 
         Для детального изучения программы DEBUG - следует внимательно 
         прочесть  сответствующие  разделы руководства по операционной 
         системе; этот материал  не  прост  для  усвоения,  однако  он 
         содержит многие важные технические детали. 
              Для пользователей, не работавших с программой (командой) 
         DEBUG,  сообщим  некоторые  дополнительные  сведения. Подобно 
         остальным командам, эта команда запускается путем  набора  на 
         клавиатуре ее имени. В процессе ее выполнения запосам на ввод 
         исполнительных операторов предшествуют лишь  "тире":  обычный 
         запрос  операционной  системы  (символ  "А") в этом случае не 
         используется. 
              Большинство  действий с программой DEBUG отображаются на 
         экране дисплея, однако  может  возникнуть  потребность  в  их 
         распечатке для последующей работы. Собственно программа DEBUG 
         не выводит результаты своей работы на принтер. 
              В этой связи, однако, следует напомнить, что  существует 
         два способа получить твердую копию. Первый способ заключается 
         в использовании для копирования текущего кадра клавиши  PrtSc 
         (Печатать    содержимое   экрана);   второй   -   состоит   в 
         использовании    принтера    для    эхо-отображения     путем 
         одновременного нажатия клавиш Ctrl и PrtSc. 
              Итак,  мы  приняли  решение об исследовании участка ПЗУ, 
         содержащего Бэйсик; нам также известно, что адрес начала этой 
         программы соответствует шестнадцатеричному адресу F600. Можно 
         запускать программу DEBUG  и  приступать  к  непосредственной 
         работе с этой программой. 
              Предположим  теперь,  что  адрес  объекта  наших поисков 
         (F600) нам неизвестен. В этом случае поиск  может  вестись  в 
         двух  направлениях.  Первое  -  это  методичное использование 
         операции D (означающее "дамп" или "отображение") до тех  пор, 
         пока  не  появится  что-нибудь  интересное.  Второе  -  более 
         эффективное направление - состоит  в  предъявлении  программе 
         DEBUG  образца  объекта,  который,  по  нашему  мнению должен 
         находиться в памяти. 
              В  качестве  образца объекта поиска выберем сообщение об 
         ошибке,  выдаваемое   Бэйсиком:   "Illegal   Function   call" 
         (Неверный  вызов  функции).  На  рис  6.1  показана процедура 
         запуска программы DEBUG и  оператор  поиска  указанного  выше 
         сообщения  программы Бэйсик. Предположим, для определенности, 
         что в качестве начального адреса просмотра (поиска) программе 
         DEBUG  был передан адрес параграфа F000 (лежащий немного ниже 
         адреса   начала   Бэйсика),   а    также    размер    (длина) 
         просматриваемого  учестка  (L)  равный  65535 байтам (`FFFF'в 
         шестнадцатеричной   системе   счисления).   Программа   DEBUG 
         сообщает,  что  интересующий нас текстовой объект найден. Это 
         сообщение формируется в форме сегментированного адреса  F000: 
         63F4,  означающего,  что  относительно параграфа F000 берется 
         шестнадцатеричное  смещение  63F4.  Выполнив   действия   над 
         адресами, мы получим полный 20-байтовый адрес. 
         
                              F000
                           +
                               63F4
                           _____________
                              F63F4
              
                     A  >   DEBUG
              
                     -  S F000 : 0000  L  FFFF  "Illegal Function call"
              
                     F000 : 63F4
              
              Рис. 6.1. Запуск программы DEBUG и поиск сообщения
              
              
              Значение  адреса  искомого  текстового  объкта говорит о 
         том,  что  найденное  сообщение   расположено   недалеко   от 
         начального    параграфа   размещения   Бэйсика   F600.   Если 
         представить 20-ти  битовый  адрес  F63F4  в  сегментированном 
         виде, используя в качестве базы параграф F600, то будем иметь 
         адрес F600:03F4. Таким  образом,  относительное  смещение  от 
         начала Бэйсика составляет только 3F4/16 или 1012/16 байтов. 
              Вводя  команду D F600 : 03E0 (вывод на экран содержимого 
         области памяти, начиная  с  адреса  -  т.е.  области  памяти, 
         начинающейся   несколько   раньше   найденного   сообщения  - 
         относительно базового адреса параграфа F600) можно отобразить 
         содержимое   близлежащего  пространства  памяти,  включающего 
         область найденного сообщения.  На  рисунке  6.2.  представлен 
         результат выполнения этой команды. Программа DEBUG выводит на 
         устройство отображения -  в  шестнадцатеричном  и  символьном 
         (ASCII)  форматах - содержимое участка памяти длиной 80 байт, 
         причем этот участок памяти содержит  искомое  сообщение.  Нам 
         таким  образом  представлено искомое сообщение, а также целый 
         ряд других сообщений об ошибках Бэйсика, т.е. именно то,  что 
         -  как  предполагалось - должно находиться где-то поблизости. 
         При необходимости с помощью программы DEBUG можно  продолжить 
         отображение  на экране последующих участков памяти; для этого 
         следует ввести команду D, не указывая адреса начала ячейки. 
              
              Рисунок 6.2. иллюстрирует  ряд  возможных  особенностей, 
         которые  следует иметь в виду, используя команду "D" в рамках 
         программы DEBUG. Одна из этих особенностей состоит в том, что 
         в   левую  часть  поля  вывода  помещается  шестнадцатеричная 
         информация, а в правую -  информация  в  коде  ASCII.  Вторая 
         особенность  заключается  в  том,  что  кодовая комбинация не 
         имеющая символьного представления в коде ASCII изображается в 
         правой   части   поля  вывода  с  помощью  точки.  Отсюда,  в 
         частности,  вытекает  важное  следствие:  для   того,   чтобы 
         использовать    эхо-печать   программа   DEBUG   контролирует 
         поступающие  на  ее  вход  кодовые  комбинации,  не   имеющие 
         представления   в  коде  ASCII;  эти  комбинации  могут  быть 
         восприняты принтером в качестве управляющего кода. Вследствие 
         этого,  нельзя  расчитывать,  что  правая  часть  поля вывода 
         (информация в коде ASCII) будет давать  объективную  картину. 
         Все,   что   может  быть  приведено  к  стандартным  печатным 
         символам, или является печатным символом (со старшим битом  в 
         единичном  состоянии)  будет  отпечатано, все остальное будет 
         преобразовано в точки.(Здесь уместно заметить, что  программа 
         DiskLook,  входящая  в состав пакета программ, записанного на 
         дискету, прилагаемую к настоящей книге, отображает в точности 
         все  шестнадцатеричные  коды  и коды ASCII, поскольку выводит 
         информацию только на экран и не использует эхо-печать). 
              До  сих пор мы рассматривали способы отображения данных, 
         или поиска априори  известных  данных,  хранящихся  в  ПЗУ  с 
         помощью  программы  DEBUG.  Ниже  мы будем решать существенно 
         более   сложную   задачу   -   задачу   деассемблирования   и 
         интерпретации программного кода на машинном языке. 
              
              
              6.3. Анализ содержимого ПЗУ - метод деассемблирования
              
                
              Наш  следующий  шаг  в   решении   задачи   исследования 
         содержимого  ПЗУ  и  использования  программы DEBUG состоит в 
         знакомстве  с   особенностями   процесса   деассемблирования. 
         Команда  "U" программы DEBUG - означает "деассемблирование" - 
         осущеcтвляет  преобразование  произвольных  кодов  памяти   в 
         мнемонические  коды  языка ассемблера. Деассемблер реализует: 
         перевод абсолютных шестнадцатеричных кодов программ,  в  коды 
         команд на языке ассемблера (например: AX или DS). Деассемблер 
         не делает две вещи. 
              Первое. Деассемблер не интерпретирует смысл программы  и 
         не  обучает пользователя. Для понимания листинга, выдаваемого 
         деассемблером, необходимо либо знать  язык  ассемблера,  либо 
         иметь   желание   покопаться   в  справочном  руководстве  и, 
         установив смысл мнемонических обозначений, постараться понять 
         суть  дела.  (Для этой цели могут быть использованы следующие 
         источники:  "Руководство  по  языку  ассемблера  фирмы  IBM", 
         справочники  по  системе  команд  микропроцессора  8086/8088, 
         такие как "Учебное пособие по микропроцессору  8086"  С.Морса 
         или "Описание микропроцессора 8086" Ректора и Алекси). 
              Для   понимания   программы  на  языке  ассемблера  (или 
         программы, приведенной к  языку  ассемблера),  знания  одного 
         языка   Ассемблер   недостаточно,   необходимо   также  иметь 
         некоторое   представление   о    функциональной    ориентации 
         программы. 
              Постижение  пограммы  представляет  собой  занимательное 
         умственое упражнение, своего рода  головоломку.  Со  временем 
         эта  процедура  становится все проще и проще, отчасти потому, 
         что времени на поиск смыслового описания команды  уходит  все 
         меньше  и  меньше,  а  отчасти потому, что усваиваются приемы 
         программирования на ассемблере и  способы  достижения  целей. 
         Далее мы остановимся на этих вопросах более подробно. 
              Второе, что не под силу  программе  деассемблера  -  это 
         установка  так называемой абсолютной синхронизации. Известно, 
         что  команды  машинного  языка  для   микропроцессора   INTEL 
         8086/8088 имеют переменную длину - от одного до шести байтов. 
         После  того  как  деассемблеру  сообщена  конкретная  позиция 
         памяти  он  приступает  к процедуре прямого декодирования, не 
         отличая кодов команд от данных. Достаточно ошибиться в выборе 
         исходной  позиции  памяти  (например,  попасть  не на границу 
         между командами или в область данных)  и  результат  окажется 
         неверным. 
              Если  начальная точка набора команд известна, то никаких 
         проблем  не  возникает.   Если   какие-либо   предварительные 
         сведения   отсутствуют,   то   следует  провести  необходимое 
         исследование. Первое, что необходимо сделать  -  это  выбрать 
         исходную   точку   в   наборе  команд  и  запустить  операцию 
         деассемблирования. После этого  следует  предпринять  попытку 
         интерпретировать    результат   работы   деассемблера.   Если 
         осмысленные программные участки отсутствуют (ниже мы приводим 
         некоторые  соображения  по их выявлению),то следует повторить 
         процедуру, сместив начальную точку на один, два или три байта 
         по  отношению к предыдущей попытке. Мы таким образом пытаемся 
         отыскать точку синхронизации,  расположенную  на  стыке  двух 
         команд, после чего может быть восстановлен оригинальный набор 
         команд.  Если  очередная  попытка  закончилась  неудачно,  то 
         следует попробовать еще раз. 
              Поскольку большинство команд имеют длину  один  или  два
         байта,  то точку синхронизации отыскать как правило несложно.
         Кроме    того,    необходимо    учитывать,    что    процессу
         деассемблирования присущ элемент самосинхронизации. Даже если
         в качестве  начальной  точки  для  деассемблирования  выбрана
         точка,  расположенная внутри команды, то часто случается, что
         процесс деассемблирования при обработке  последуюющих  команд
         самопроизвольно попадает в нужную точку. После этого все идет
         гладко, по крайней мере  в  сторону  увеличения  адресов.  (В
         обратную сторону это приходится делать вручную).
              Выполняя    деассемблирование    программы    необходимо 
         внимательно следить за  данными  (это  нечто  противоположное 
         командам),   которые  деассемблер  превращает  в  причудливые 
         ассемблерные конструкции. Основной и наиболее быстрый  способ 
         обнаружения  данных  состоит в использовании команды "D", для 
         представления информации  в  шестнадцатеричном  коде  и  коде 
         ASCII.  Здесь  в  первую очередь следует обращать внимание на 
         самые   очевидные   вещи    -    содержательно    осмысленную 
         последовательность  символов  ASCII (фразы), такую, например, 
         как "неверный вызов функции". После этого можно приступать  к 
         выявлению более тонких признаков данных. 
              В обычных программах (т.е. в программах, размещаемых вне 
         ПЗУ) наличие  полей,  заполненных  шестнадцатеричными  нулями 
         является  признаком  рабочей  области  данных,  то есть такой 
         области,  которая  будет  использоваться  в  ходе  выполнения 
         программы;  в  процессе деассемблирования данные этой области 
         неактуальны. ПЗУ не может использоваться для хранения рабочих 
         данных,  поскольку  запись  в  эту  память  невозможна. Таким 
         образом, наличие полей, состоящих из шестнадцатеричных  нулей 
         нетипично для ПЗУ-программ. 
              Признаком  возможного  наличия данных являются байты или 
         двухбайтовые слова,  для  которых  второй  или  старший  байт 
         содержит 0 или F. Дело в том, что значительное число констант 
         программ  являются  малыми  числами,   положительными   (т.е. 
         начинающихся  с  0), либо отрицательными (т.е. начинающихся с 
         F).  Если   будет   обнаружена   последовательность   байтов, 
         удовлетворяющая  этим  требованиям,  то  весьма вероятно, что 
         найдена область памяти, используемая для хранения одного  или 
         двухбайтовых  чисел.  Эта  часть программы не может содержать 
         команды. 
              Пытаясь  осмыслить   структуру   листинга,   выдаваемого 
         деассемблером,  необходимо  иметь в виду следующие положения. 
         Обычные  программы,  прошедшие  этап  редактирования  связей, 
         будут хранить команды в одном месте, а данные в другом. Такой 
         подход является элементом  хорошего  стиля  программирования; 
         именно  так  работает  редактор  связей дисковой операционной 
         системы.  Описанный  принцип  характерен  для  программ  всех 
         типов,  однако  для программ типа EXE он справедлив в большей 
         степени  чем  для  программ  типа  COM.  С  другой   стороны, 
         ПЗУ-программы,  подобные  тем,  которые  рассматривались нами 
         выше,  часто   разрабатываются   вне   концепций   технологии 
         программирования.  Данные  в  этих программах могут следовать 
         вперемешку с командами. 
              Если  предположительно  обнаружен  участок  программы, в
         котором  вслед  за  командами  следуют  некоторые  данные, то
         существует по крайней мере один достоверный  способ  отличить
         конец  последовательности  команд  от  расположенных вслед за
         ними  данными,  и  таким   образом   избежать   необходимости
         рассматривать   недостоверный   протокол   деассемблирования.
         Последняя  команда  фактического  участка  программы   должна
         представлять собой ту или иную разновидность команды перехода
         или  ветвления.  Команды  ветвления  включают  любые  команды
         переходов,   кроме  команд  условных  переходов.  В  качестве
         общеупотребительной  команды  завершения  программы   принято
         использовать  команду  возврата  (RET)  (возврат из вызванной
         ранее подпрограммы).
              Могут использоваться также и команды CALL (Вызов) и  INT
         (Прерывание);   хотя  их  использование  в  качестве  команды
         завершения последовательности команд  встречается  достаточно
         редко.
              Существует ряд особенностей, на которые следует обращать
         внимание  при  решении  вопроса  подлинности   предъявленного
         участка  программы  после  его  деассемблирования.  В  первую
         очередь следует обратить внимание на  используемые  регистры.
         Если  операции  реализуются  на  регистрах,  используемых как
         правило для выполнения арифметических операций  (AX  или  AL,
         AH;BX  или  BL, BH; CX или CL, CH; DX или DL, DH), но никакие
         действия в отношении результата не  предпринимаются,  то  это
         вызывает  подозрение.  Здесь следует быть более внимательным.
         Один  из  результатов  выполнения   арифметических   операций
         состоит  в  установке  флагов  -  следовательно,  естественно
         ожидать наличие команд условных переходов по состоянию флага,
         таких   как  JNC  (команда  перехода  по  условию  отсутствия
         установленных битов флага).
              Рассмотрим аспект некорректности использования регистров
         в   реконструируемой   программе.   Программы  не  используют
         регистры   некоторым   хаотичным   образом   -   им   присуща
         определенная  дисциплина.  Поэтому весьма непривычно, скажем,
         видеть загрузку или  непосредственную  ссылку  на  сегментные
         регистры  -  особенно  сегментный  регистр  программы  (CS) и
         сегментный  регистр  стека  памяти  (SS).  Загрузка  сегмента
         регистра  данных  (DS)  более  вероятна, но также встречается
         редко. С другой стороны,  дополнительный  сегментный  регистр
         (ES)  практически постоянно используется программами, поэтому
         его загрузка - дело обычное. Если загрузка регистра CS или SS
         все-таки обнаружена, то это должно быть сделано в программной
         секции,  формирующей   операционную   структуру   выполняемой
         программы;  в  этом случае вероятнее всего, что в одном месте
         будет произведена загрузка нескольких сегментных регистров, в
         частности, CS, SS и DS.
              Попытка    реконструировать   программу   по   листингу,
         выданному деассемблером или даже просто попытка  убедиться  в
         подлинности  предъявленного набора команд, представляет собой
         захватывающее умственное  упражнение.  Для  этого,кстати,  не
         требуется  специальная  подготовка.  Как  правило, достаточно
         бывает просто здравого смысла. Усвоив все наши рекомендации и
         приобретя    некоторые    практические    навыки,   Вы,   при
         необходимости,  сможете  все  это  проделать.   В   следующем
         параграфе мы выполним декодирование (реконструкцию) программы
         Бэйсик-ПЗУ; читатель, таким образом, получит представление  о
         том,  как  это  делается  и  убедится в том, что это не очень
         сложно.
              
              
              6.4.    Анализ    содержимого   ПЗУ   -   реконструкция
         интерпретатора
                
              
              В качестве примера попробуем  деассемблировать  фрагмент 
         Бэйсик-ПЗУ.  Начнем  с  исходного параграфа, т.е. параграфа с 
         адресом  F600(16).  На  рисунке  6.3  представлен   результат 
         деассемблирования  первых 32 байтов. Шестнадцатеричные нули в 
         конце  фрагмента  программы  (преобразованы  деассемблером  в 
         команды   ADD   (Сложить))  представляют  собой  данные.  Они 
         "хорошо" иллюстрируют высказанное ранее положение о том,  что 
         нулевые   данные   нетипичны  для  ПЗУ-программ.  Команда  DB 
         (определить байт), предшествующая полю нулей,  появилась  как 
         реакция  деассемблера на кодовую комбинацию, которая не может 
         быть преобразована  в  команду  ассемблера  (такая  ситуация, 
         благодаря   широкому   набору  команд,  встречается  довольно 
         редко). Итак, являются ли все  данные,  которым  предшествует 
         команда   безусловного   перехода   собственно   осмысленными 
         командами? Предварительный ответ на этот  вопрос  может  быть 
         положительным,    поскольку    для    завершения   выполнения 
         подпрограммы используется команда возврата  (RET).  Пока  все 
         идет хорошо. 
              Можно ли приписать какие-то осмысленные действия  первым
         пяти   командам  деассемблированной  программы?  Эти  команды
         выглядят несколько странно, поскольку  начинаются  с  команды
         безусловного  перехода  (JMP).  Большинство программ, однако,
         первым  делом  выполняют  ряд  действий  настроечного  плана,
         обращаясь для этого посредством команд вызова подпрограмм или
         переходов, к нужным процедурам.  Таким  образом,  безусловный
         переход  в  начале  программы  -  каким  бы причудливым он не
         казался - не такая уж бессмыслица. Следующие четыре команды -
         две  пары  обращения к подпрограммам с последующими командами
         возврата в процедуру не  особенно  понятны,  но,  по  крайней
         мере,  не противоречат друг другу и могут в какой-то  степени
         служить признаком наличия последовательности  команд.  Можно,
         следовательно, сделать предположение о том, что мы имеем дело
         с реальной последовательностью команд.
              Из  того,  чем  мы  располагаем  -  даже при том, что на 
         рисунке 6.3 представлена реальная последовательность команд - 
         вряд  ли  можно  извлечь  какую-то пользу. Только пять команд 
         почти ничего не совершающих. 
              И   все-таки  есть  ряд  интересных  моментов.  Если  это
         действительно реальная последовательность, то нам названы три
         адреса,  где могут оказаться вещи более интересные. Речь идет
         об адресе в  команде  перехода  и  адресах  двух  последующих
         каманд  обращения к процедуре. Следует ли нам пойти по адресу
         перехода?  Деассемблер  дает  нам  этот  адрес  (относительно
         начала нашей программы, т.е. адреса F600/16) - FE92/16.
              Выполним  деассемблирование  небольшого  участка памяти,
         начинающегося с этого адреса (результат приведен на рис 6.4.)
              
              
              
              -U F600:0000
              F600:0000 E98F7E          JMP          7E92
              F600:0003 E8A76B          CALL         6BAD
              F600:0006 CB              RET          L
              F600:0007 E80265          CALL         650C
              F600:000A CB              RET          L
              F600:000B C1              DB           C1
              F600:000C 0000            ADD          [BX+SI],AL
              F600:000E 0000            ADD          [BX+SI],AL
              F600:0010 0000            ADD          [BX+SI],AL
              F600:0012 0000            ADD          [BX+SI],AL
              F600:0014 0000            ADD          [BX+SI],AL
              F600:0016 0000            ADD          [BX+SI],AL
              F600:0018 0000            ADD          [BX+SI],AL
              F600:001A 0000            ADD          [BX+SI],AL
              F600:001C 0000            ADD          [BX+SI],AL
              F600:001E 0000            ADD          [BX+SI],AL
              
              
              
              Рис. 6.3. Деассемблирование начального участка Бэйсика
              
              Похоже,  мы  попали  в  точку.  Во-первых,  перед   нами
         совокупность    осмысленных    команд,   не   содержащая   ни
         последовательностей  операторов  DB,  ни  последовательностей
         операторов   ADD.Во-вторых,  эти  команды  весьма  напоминают
         команды  настройки.Об этом говорит прежде всего команда  CLI,
         (CLI (Clear interrupt flag) - очистка флага прерывания). 
              Прерывание    в    микропроцессоре    INTEL    8086/8088
         воспринимается по завершении  выполнения  некоторой  команды.
         Немаскируемое   прерывание   в   общем  случае  обслуживается
         непосредственно после выполнения текущей команды.  Прерывание
         по вектору воспринимается только тогда, когда разряд IF (флаг
         прерывания) в регистре FLAGS имеет значение,  равное  1.  Для
         того,   чтобы   микропроцессор   8086  воспринял  прерывание,
         необходимо выполнение следующих трех условий:
              1) разряд  IF  регистра  FLAGS  должен  иметь  значение,
         равное 1 (для прерываний по вектору);
              2)  разряд разрешения прерываний в интерфейсе устройства
         должен находиться в состоянии "Прерывание разрешено";
              3) интерфейс  должен  зафиксировать  некоторое  событие,
         вызывающее   прерывание   (например,  поступление  символа  с
         клавиатуры,  готовность  к   выводу   символа   на   дисплей,
         завершение   передачи   блока   данных   с   диска   и  т.п.)
         (Прим.перев.)).
   ?     которая,  как  мы  видели в главе 3 используется как средство
         блокировки прерываний; таким образом  вся  последовательность
         выполнения расположенных ниже команды прервана быть не может.
         Именно  такая  последовательномть   команд   характерна   для
         начальных   аргументов   ответственных   программ,  поскольку
         значения  сегментных  регистров  целесообразно  устанавливать
         одновременно с обработкой прерываний.
              Ниже  производятся  как  раз  те  действия, о которых мы
         говорили выше, а именно:  загрузка  сегментных  регистров.  С
         помощью   четырех   команд  MOV  (команды  пересылки  данных)
         осуществляется загрузка трех сегментных регистров из четырех:
         DS,  ES  и  SS. Загрузка этих регистров осуществляется весьма
         редко, поэтому естественно это  сделать  один  раз  в  начале
         программы.  (Сегментный  регистр программы CS к этому моменту
         уже загружен ( F600 : 0000, рис. 6.3.).
              Вслед за  группой,  состоящей  из  четырех  команд  MOV, 
         осуществляющих  загрузку  сегментных  регистров,  следует две 
         команды, выполняющие одну логическую операцию. Первая команда 
         -  это  команда "исключающего ИЛИ" XOR - заносит в регистр AL 
         значение   "нуль"   (поскольку   в   результате    применения 
         "исключающего  ИЛИ"  к  эквивалентным данным образуется новая 
         величина),  а  вторая  команда  заносит   эту   величину   по 
         конкретному адресу. 
              Программа  не  содержит  никаких  сведений  относительно 
         содержательной интепретации  этих  операций,  но  это  вполне
         осмысленное сочетание команд, выполняющих конкретную функцию.    
              Если  бы  мы  располагали  более  полной  информацией об 
         особенностях  работы  Бэйсика,  то  нам,  вероятно,  было  бы 
         известно,  что  нулевая  величина,  пересылаемая  в  память с 
         помощью двух двух последовательных команд представляет  собой 
         переключатель   предохраняющий   защищенные   программы.  При 
         загрузке защищенных программ,  написанных  на  языке  Бэйсик, 
         этот  переключатель  устанавливается  с  целью предотвращения 
         выдачи их  на  печать.  Это,  однако,  никак  не  следует  из 
         представленного листинга. 
              Первые  семь  команд рассматриваемого участка программы,
         таким образом,  выглядят  вполне  осмысленно.  Они  реализуют
         рациональные   и   согласованные   между   собой  действия  и
         естественным образом распадаются на два  класса:  команды  со
         2-й по 5-ю реализуют одну логическую операцию, а с 6-й по 7-ю
         -  другую.  Пред'явленные  команды  отвечают  всем  критериям
         реального участка программы.
              
              
              -U F600:7E92
              F600:7E93 8A6000             CLI
              F600:7E93 8A6000             MOV       DX,0060
              F600:7E96 8EDA               MOV       DS,DX
              F600:7E98 8EC2               MOV       ES,DX 
              F600:7E9A 8ED2               MOV       SS,DX
              F600:7E9C 32CO               XOR       AL,AL
              F600:7E9E A26404             MOV       [0464],AL
              F600:7EA1 B591               MOV       CH,91
              F600:7EA3 BB0000             MOV       BX,0000
              F600:7EA6 BA9A06             MOV       DX,069A
              F600:7EA9 BBF2               MOV       SI,DX
              F600:7EAB 2E                 SEG       CG
              F600:7EAC AC                 LODSB
              F600:7EAD 8807               MOV       [BX],AL
              F600:7EAF 43                 INC       BX
              F600:7EBO 42                 INC       DX
              F600:7EB1 FECD               DEC       CH
         
              
         
              Рис. 6.4. Второй фрагмент реконструированного Бэйсика
              
              Мы в какой-то мере достигли относительной цели: поиск  и
         выявление некоторого программного кода, а также некоторое его
         осмысление. Это нам вполне удалось. Можно было  бы  выполнить
         декодирование  всего  Бэйсика, либо наиболее существенных его
         участков. Однако мы уже получили представление о том, как это
         удается и убедились, что это вполне возможно.
              
              
              6.5. Две версии BIOS'а
              
              
              То, что для IBM/PC  используется  по  крайней  мере  две
         различные  версии BIOS не является широко известным фактом. В
         настоящем параграфе мы кратко рассмотрим имеющиеся между нами
         различия и оценим их применительно к своим нуждам.
              В  состав  пакета  программ,  записанного  на  дискету и
         прилагаемого  к  настоящей  книге,   входят   две   программы
         копирующие и анализирующие программы BIOS.
              Именно  с  помощью этих программ впервые было обнаружено
         наличие модифицированных версий ПЗУ компьютеров, факт,который
         открыто  не  признавался  фирмой IBM. С помощью этих программ
         можно проверить свою систему  и  сопоставить  свою  версию  с
         другими.
              Из  всех  программ,  используемых  для Вашего компьютера
         IBM/PC, наиболее совершенными (не содержащими ошибок)  должны
         быть  программы,  предназначенные для размещения в ПЗУ. Если,
         например, будет выявлена ошибка в какой-либо версии  DOS  или
         VisiCalc,  то  ее  можно  устранить  путем простой перезаписи
         дискеты. С  программами,  записанными  в  ПЗУ,  дело  обстоит
         гораздо  сложнее.  Их  можно  записывать  только путем замены
         корпусов микросхем памяти,  расположенных  на  главной  плате
         компьютера  IBM/PC;  эта  операция  не может быть произведена
         силами обычного пользователя. Наличие ошибок в программах ПЗУ
         представляет собой серьезную проблему для фирмы IBM.
              Сама мысль о том, что  можно  сделать  что-либо стоящее, 
         не  совершив  при  этом  ни  единой  ошибки,   представляется
         фантастической и программы ПЗУ в этом смысле не исключение. С
         момента  появления  компьютеров  IBM/PC,  фирма   IBM   сочла
         необходимым внести ряд изменений в программы ПЗУ (речь идет о
         серьезных ошибках), что обусловило появление двух версий ПЗУ.
         У пользователя может возникнуть вопрос, какой версией оснащен
         его компьютер и чем эта версия отличается от другой версии.
              В  самом  конце  программы  BIOS  фирма  IBM   поместила
         временную  отметку, так называемый маркер версии. Этот маркер
         практически  соответствует   дате   официального   завершения
         разработки  программ ПЗУ. Для его отображения на экране можно
         воспользоваться программой DEBUG.  После  загрузки  программы
         DEBUG введите команду D F000:FFF5  L 8.
              На    экране    вашего   компьютера   будет   отображена
         последовательность  символов,  обозначающая  маркер   версии:
         04/24/81. Маркер второй версии имеет вид 10/19/81. Если будет
         обнаружен маркер версии,  отличной  от этих  двух, это  будет
         означать,  что  Вы располагаете версией BIOS-ПЗУ, отличной от
         указанных выше.
              В приложении 6.1 приведен текст  программы,  проверяющей
         маркер  версии  BIOS-ПЗУ,  и, в  зависимости  от его значения,
         выполняющей те или иные  действия.  Аналогичные  действия  на
         БэйсикЕ можно представить следующим образом:
              
              10 REM    вывод на дисплей маркера версии ПЗУ
              20 REM    программа отображает маркер, не анализируя его
              30 REM    и не настраивается на версию ПЗУ
              40 PRINT
              50 DEF SEG=&HFFFF
              60 PRINT "Маркер версии ПЗУ;
              70 FOR OFFSET=5 то 12
              80 PRINT CHR$(PEEK(OFFSET));
              90 NEXT OFFSET
              
              Если Ваш компьютер приобретен позже октября 1981, то это
         еще не означает, что он снабжен последней  версией  BIOS-ПЗУ.
         Проверка  компьютеров,  выпущенных  через  год после выпуска
         второй  версии  BIOS,  показывает,  что  новый,  только   что
         собранный компьютер, может иметь первую версию BIOS-ПЗУ.
              Вы,  вероятно,  помните,  что  ПЗУ  IBM/PC  содержит две
         составляющие:   Бэйсик-ПЗУ и BIOS-ПЗУ.   Первое,   что   было
         обнаружено   с   помощью   разработанной  автором  программы,
         анализа содержимого  ПЗУ,   это   отсутствие  различий  между
         первой и второй версиями Бэйсик-ПЗУ.
              Все  ошибки,  обнаруженные  в  БейсикЕ,  были  устранены 
         только  за  счет  дисковых  версий  БейсикА.   Важно,   чтобы 
         Бэйсик-ПЗУ   оставался   неизменным,   поскольку   это  может 
         отразиться на особенностях выполнения широко распространенных 
         программ,  написанных  на БэйсикЕ, и никем не поддерживаемых. 
         Возможна ситуация, когда одни и те же Бейсик-программы  будут 
         по   разному  работать  на  различных  машинах  только  из-за 
         различия в версиях ПЗУ. 
              Придерживаясь   мнения   на   корректировку  исправления
         Бэйсик-программ  дискетной  версии,  фирма   IBM   обеспечила
         пользователю  возможность отслеживать все изменения, вносимые
         в язык. Если каккая-нибуть программа написана  в  расчете  на
         оригинальный  Бэйсик,  то  следует  лишь установить дискету с
         этой версией БэйсикА.  Для  новых  версий  БэйсикА  программа
         может  имитировать  модификацию  содержимого  ПЗУ  с  помощью
         методики, описанной в главе 3 при осуждении прерываний.
              Все  изменения,  внесенные в ПЗУ, касались BIOS; ниже мы 
         перечислим их и Вы сможете оценить степень их важности.  Если 
         вы располагаете первой редакцией "Руководства по техническому 
         обслуживанию IBM/PC", то можете убедиться в  том,  что  текст 
         BIOS-ПЗУ,  приведенный  в  приложении А, соответствует первой 
              версии ПЗУ, о чем свидетельствует также маркер версии на 
         последней  странице:  04/24/81.  Вслед  за  текстом  BIOS-ПЗУ 
         приведены   некоторые   замечания.  Первое,  третье  и  пятое 
         замечания касаются  некоторых  ошибок,  найденных  в  BIOS  и 
         исправленных во второй его версии. 
              Первые три изменения,  внесенные  в  BIOS-ПЗУ,  касаются
         программ  самотестирования, автоматически запускающихся после
         включения  питания  на  IBM/PC.   Эти   программы   выполняют
         четырнадцать  различных тестовых проверок правильности работы
         оборудования, прежде  чем  пользователь  натворит  "дел"   на
         неисправном компьютере.
              Тест  номер  три  (  входящий  в  состав  этих программ) 
         осуществляет проверку  правильности  работы  функции  таймера 
         котроллера  памяти.  Два  исправления  из  трех,  внесенных в 
         тестовые   программы,   касаются   этой   процедуры.   (Здесь 
         представляется  уместным  показать,  что  программы, подобные 
         BIOS, работающие непосредственно с аппаратурой, отличаются от 
         обычных   программ.  Корректность  функционирования  программ 
         тестирования устройств, а также программы BIOS часто  зависит 
         оттонкостей    функцмонирования   контролируемых   устройств. 
         Временные характеристики управляющих  сигналов,  а  также  их 
         взаимная согласованность могут оказывать решающее воздействие 
         на факт успешного завершения  этих  программ.  В  целом  ряде 
         случаев  отладка  таких программ производится опытным путем - 
         одного логического анализа бывает недостаточно.  Вот  почему, 
         говоря  об  изменениях,  внесенных в тестовые программы, я не 
         смог сказать ничего определенного о смысле этих изменений). 
              Одно  из  изменений, внесенных в программы тестирования,
         затрагивает сразу три программы. Цель изменения:  обеспечение
         безусловного обновления операций таймера до момента обработки
         управляющего прерывания видеомонитора. В первой версии  этого
         не делалось.
              Не  следует  огорчаться,  если  Вам  непонятно значение
         введенных изменений - они практически никак не сказываются на
         работоспособности    правильно    функционирующей    системы.
         Остальные изменения (описываются ниже) представляют  для  Вас
         большой интерес.
              Одно  из внесенных изменений представляет интерес прежде
         всего для тех, кто использует  коммуникационный  адаптер.  На
         программы  ПЗУ, обслуживающие коммуникационный адаптер, среди
         прочих,  возлагаются  также  функции  оповещения   в   случае
         отсутствия  на линии связи сигнала отклика. Если по истечении
         определенного промежутка времени такой сигнал не появился, то
         коммуникационные    программы    ПЗУ   вырабатывают   признак
         "тайм-аут". /Тайм-аут - интервал времени, когда одна  сторона
         принимает определенные меры, если в течение заданного времени
         она не получит ответа от  другой  стороны  (Прим.перев.)/.  К
         сожалению,  в  результате  обычной  опечатки программы ПЗУ не
         вырабатывают  признак  "тайм-аут".  Ошибка   возникла   из-за
         различий в представлении десятичных и шестнадцатеричных чисел
         при  записи  шестнадцатеричного  числа  80Н  символ  "Н"  был
         потерян   и   число   воспринялось   как   десятичное   (т.е.
         шестнадцатеричное 50).  В  программе  это  число  (константа)
         используется  для  установки в единичное состояние конкретных
         битов; таким образом, вместо установки в единичное  состояние
         одного  бита-признака  состояние  "тайм-аут" были установлены
         два  других  бита-признака   "готовности   данных"   (условие
         обратное  "тайм-аут")  и "ошибка четности" (свидетельствует о
         возможной ошибке в данных).
              Следствием этой ошибки является возможность неправильной
         работы коммуникационной программы. Если она запрограммирована
         без учета ошибки BIOS-ПЗУ, то отсутствие ответа в  телефонной
         линии  будет восприниматься как ошибка четности данных (таким
         образом нарушается объективность диагностики).
              Следующая  ошибка,   обнаруженная   во   второй   версии
         BIOS-ПЗУ,   относилась  к  программам  управления  принтером.
         Проблема, как и прежде, заключалачь в тестированипи состояния
         "тайм-аут".  При  выполнении какой-либо работы для компьютера
         принтер может находиться  в  состоянии  "устройство  занято";
         возможен  также  такой  режим  работы,  когда  принтер сигнал
         ответа  не  вырабатывает.  Управляющая   программа   BIOS-ПЗУ
         тестирует  эти  режимы,  ожидая  некоторое  время поступления
         сигнала ответа. К сожалению, это время было выбрано без учета
         наиболее   длительной   операции,   выполняемой  принтером  -
         протяжки бумаги на интервал, равный одной одной  странице.  В
         первой   редакции   BIOS-ПЗУ   это  время  было  явно  меньше
         требуемого, поэтому  в  новой  версии  до  момента  появления
         признака "тайм-аут" проходит вдвое большее время.
              Вслед  за  принтером  изменения  затронули  и  программы 
         поддержки  накопителя  на  магнитной  ленте  кассетного типа. 
         Здесь была изменена последовательность выполнения  нескольких 
         команд,   что   привело   к  небольшому  изменению  временных 
         характеристик процесса считывания данных. Поскольку в составе 
         IBM/PC  накопитель  кассетного типа используется весьма редко 
         (т.е. последствия ошибки  незначительны),  то  это  изменение 
         относится к разряду несущественных. 
              Последнее  изменение  представляет   интерес   для   тех
         пользователей  IBM/PC, которые используют цветной графический
         адаптер.  Не  всем  известно,  что  при  работе   с   цветным
         графическим  адаптером  в  графическом  режиме  (в отличие от
         работы в текстовом  режиме)  символы  выводятся  на  экран  в
         режиме  рисования,  подобно  тому  как  выводится изображение
         любого другого  объекта  графической  природы.  (Эти  вопросы
         подробно  рассматриваются  в главе 9, посвященной отображению
         графических  объектов).  В  ПЗУ   предусмотрена   специальная
         таблица,  содержащая графические образы символов ASCII с тем,
         чтобы их можно было вывести как элементы алфавита.
              При работе цветного графического  монитора  в  текстовом
         режиме  отображаемые символы генерируются цветным графическим
         адаптером схемно; в графическом же режиме символы рисуются на
         экране  управляющей  программой  ПЗУ,  использующей табличные
         образы. Один  из  этих  образов  в  первой  версии  BIOS  был
         закодирован с ошибкой, а именно: символ СНR$(4), обозначающий
         сокровища на колодах для игральных  карт,  имел  одну  лишнюю
         точку снизу. Во второй версии BIOS-ПЗУ эта ошибка устранена.
              Ни  одна  из  перечисленных  выше  ошибок не относится к
         разряду катастрофических. Наиболее значимая из них влечет  за
         собой   неправильное  формирование  признака  "тайм-аут"  при
         работе  с  асинхронной  линией  связи  ,  то  есть  ошибочное
         описание   ситуации,   а   не   ошибочные   действия.  Редкий
         пользователь IBM/PC cумеет ее распознать, даже, если знает  в
         чем дело. 
              Знать о всех изменениях имеет смысл постольку, поскольку
         нельзя быть уверенныт в  том,  что  изменения,  затрагивающие
         особенности  работы  машинных программ (даже в незначительной
         степени) всегда должным  образом  документируются  и  открыто
         публикуются.   Здесь   важен   прецедент,   дающий  основание
         беспокоиться, что более важные и существенные изменения могут
         быть осуществлены без ведома пользователей.
              
              
              6.6. Механизм выборки информации из ПЗУ
              
              
              В данном параграфе мы обобщим все аспекты,  связанные  с 
         активизацией   служебных   программ   BIOS-ПЗУ.   Любой   вид 
         обслуживания обеспечивается  через  механизм  прерываний;  по 
         причинам,  котрорые  мы  подробно  рассматривали  в  главе 3, 
         прерывания позволяют  запускать  (выполнять)  программы,  без 
         предварительных    сведений    о   их   местоположении(   при 
         необходимости можно осуществлять перемещение этих программ). 
              Ниже  приведена  таблица  прерываний,  используемых  для
         активизации программ BIOS-ПЗУ, а также  программ,  имеющих  к
         ним непосредственное отношение.
         ____________________________________________________________
                
              
              Номер        Шестнадцатиричный        Назначение
                                  код
         ____________________________________________________________ 
              
                5                  5               Операция     печати
                                                   содержимого  экрана 
               16                 10               Операции  ввода/вы-
                                                   вода на экран дисп-
                                                   лея
               17                 11               Контроль оборудова-
                                                   ния;   используется 
                                                   для     определения
                                                   подключенного  обо-
                                                   оборудования
               18                 12               Проверка памяти;ис-
                                                   пользуется  для оп-
                                                   ределения    объема  
                                                   памяти
               19                 13               Операции  ввода/вы-
                                                   вода с  накопителей
                                                   на дискете; различ-
                                                   ные  операции с на- 
                                                   копителем на диске-
                                                   те;  различные опе-
                                                   рации    с дискетой
              20                  14               Ввод/вывод      для
                                                   RS-232;  операции с
                                                   асинхронным  комму-
                                                   никационным адапте-
                                                   ром
              21                  15               Ввод/вывод  для на-
                                                   копителя   на  маг-
                                                   нитной  ленте  кас-
                                                   сетного типа
              22                  16               Ввод/вывод  с  кла-
                                                   виатуры
              23                  17               Ввод/вывод      для
                                                   принтера        
              24                  18               Загрузка  кассетной
                                                   версии Бэйсика
              25                  19               Перегрузка  системы
              26                  1А               Функции даты и вре-
                                                   мени

         ____________________________________________________________

                
              Полный список программ обслуживания значитель шире.  При
         необходимости  каждой  отдельной  функции обслуживания мог бы
         быть присвоен свой собственный номер прерывания или  наоборот
         -   все   функции   могли  бы  быть  обозначены  одним  кодом
         прерывания, образуя своего рода управляющиее прерывание.
              Более продуктивным, однако, представляется подход, когда
         с  каждым  прерыванием  связывают один функциональный разрез,
         обеспечивая таким образом их  логическую  группировку.  Такой
         путь  ведет  к  управляемому  числу  отдельных  прерываний  с
         обоснованным разделением функций обслуживания.
              Несмотря  на  то,  что  потребности  в  каждой   функции
         различны,  существуют  некоторые общие положения относительно
         особенностей перемещения данных между точкой вызова функции и
         собственно   функций.   Если   Вы   используете  интерфейсные
         программы, поставляемые на дискете в  качестве  дополнения  к
         данной  книге,  у  Вас  не  будет  возможности ознакомиться с
         деталями реализации каждой функции. Знать  как  они  работают
         между тем весьма полезно. 
              За   исключением   отдельных  случаев  в  рамках  одного
         прерывания  реализуются  несколько  функций.   Для   передачи
         номера, обозначающего субфункцию используется регистр AH. Для
         передачи  параметров  в   обоих   направлениях   используются
         регистры,   причем   система   стремится   к   их  экономному
         использованию. Программы обслуживания обеспечивают сохранение
         всех  регистров,  не  используемых  для  передачи параметров;
         вызывающая программа таким образом  не  должна  заботиться  о
         сохранении  величин,  находящихся в различных регистрах. Если
         требуется выделить область памяти для данных,  например,  для
         буфера  данных  считываемых  с  дискеты  или  кассеты, то для
         представления сегментированных адресов используются  регистры
         ES и BX.
              Регистры  AH,  AX  мспользуются  для передачи программам
         обслуживания кода возврата  или  результирующего  сигнала.  В
         некоторых  случаях  для  индикации  ошибки  используется флаг
         переноса  CF,  однако  как  правило  флаги  не  используются.
         Регистры  общего  назначения  AX  ... DX следует использовать
         экономно по  мере  необходимости,  придерживаясь  алфавитного
         порядка. 
         
              В  последующих  пяти  главах  мы детально рассмотрим все
         перечисленные выше типы прерываний  и  особенности  работы  с
         регистрами.
              
              
              6.7. Описание специальных прерываний
              
              
              Как  уже  упоминалось  в  главе  3, три строки в таблице 
         векторов прерываний используются не по прямому назначению для 
         хранения  адресов  программ  обслуживания  прерываний , а для 
         хранения  адресов  базовых  таблиц  системы  (поскольку   эти 
         таблицы  размещаются  в ПЗУ). Ниже мы поясним назначение этих 
         таблиц. 
              Первая  таблица  (с  кодом  фиктивного  прерывания   29)
         содержит    адрес    таблицы    инициализации   видеодисплея,
         используемой  для  контроля  управляющих  кодов  для  экранов
         дисплеев.  Таблица  размещается  в ПЗУ по адресу F000: F0A4 и
         включает три подтаблицы с видеопараметрами. Каждая подтаблица
         имеет  четыре  строки  по  одной  строке на каждый из четырех
         режимов  отображения:  монохромный,  40-столбцовый   цветной,
         текстовой, 80-столбцовый цветной, текстовой и оба графических
         режима. Одна из подтаблиц фиксирует размер  в  байтах  буфера
         дисплея,  соответствующего  текущему  режиму.  (Подробно  эти
         вопросы рассматриваются в главе 8 и 9).
              Еще одна подтаблица фиксирует ширину  граф,  учитываемую
         при   автоматическом  переходе  от  одной  строки  в  другую.
         Практическая польза от  модификации  этой  таблицы  близка  к
         нулю, поэтому в дальнейшем она рассматривается не будет.
              Адрес   второй  таблицы  (соответствует  прерыванию  30)
         указывает на таблицу параметров дискет. Эта таблица  содержит
         данные,  предназначенные  для  контроля  временных параметров
         различных   операций,   выполняемых   с   дискетой.   Таблица
         расположена  в  ПЗУ  по  аресу  F000  :  EFC7. Сразу же после
         выпуска компьютера IBM/PC стало ясно, что некоторые временные
         характеристики, внесенные в эту таблицу весьма приблизительны
         и  являются  причиной  слишком  медленной  работы   дискового
         накопителя.  Среди  многочисленных изменений, внесенных в DOS
         версии  1.10  были  данные,  снижающие  время   обращения   к
         дисковому  накопителю. Здесь использовался классический метод
         - в  процессе  самонастройки  дисковая  операционная  система
         создавала новую версию таблицы в обычной памяти и заменяла ее
         адрес в векторе,инициализируцемой по прерыванию 30. Поскольку
         при выполнении любой операции с диском производится обращение
         к этой таблице, то  после  замены  адреса  вектора,  активной
         становилась  новая   таблица. В главе 7 (посвященной описанию
         дискового накопителя) мы рассмотрим детали, связанные с  этой
         таблицей и укажем внесенные изменения.
              Адрес   третьей   таблицы,   получаемой   по  фиктивному
         прерыванию 31, указывает на  область  генератора  графических
         символов,  используемых  при формировании на дисплее символов
         CH$(128),  ...,  CHR$(255)  в  любом  из   двух   графических
         режимов.   Стандартной   таблицы   этого   типа  попросту  не
         существует. Если две предыдущие таблицы  всегда  находятся  в
         ПЗУ,  то  данная  таблица в ПЗУ отсутствует. А коль скоро это
         так, то вектор прерывания будет  содержать  нулевое  значение
         (является  признаком  отсутствия  таблицы)  до  тех пор, пока
         программа  не   построит   такую   таблицу   и   не   занесет
         соответствующий  адрес  в  вектор  прерывания.  При  изучении
         графического  режима  работы  (глава  9)   мы   увидим,   что
         существует  много  интересных  вещей,  связанных  с  таблицей
         генерации символов.
              Все эти общие положения,  касающиеся  ПЗУ,  образуют  ту
         основу,  опираясь  на  которую  мы  перейдем  к  рассмотрению
         широких возможностей отдельных узлов IBM/PC. Этому  посвящены
         пять   следующих   глав.   Начнем   с  дисковых  накопителей,
         рассматривая их до того  как  программа  построит  таблицу  и
         поместит   адрес   этой   таблицы  в  соответствующий  вектор
         прерываний.
         
    
              Приложение 6.1. Текст программы проверки метки
         версии ПЗУ (Паскаль).
         
         
         module Listing_6_1;
         
         
         type
         
           string8       = string(8);
           bios_ptr_type = ads of string8;
           
           
         var
         
         bios_date    : bios_ptr_type;
         
         
         procedure check_rom_bios_date;
         
           begin
           
             bios_date.s :=#F000;
             bios_date.r :=#FFF5;
             
             if bios_date^='04/24/81' then
               begin
               
               end
             else
               begin
               
               end;
               
           end;  

         end.
                        ГЛАВА 7. ДОСТУП К ДИСКЕТАМ  
                        __________________________
              
              С   этой   главы   начинается   подробное  по-элементное
         рассмотрение возможностей IBM/PC - начиная с  дисководов  для
         гибких  магнитных  дисков. Изложение материала этой и четырех
         последующих  глав  будет  следовать   организации   служебных
         процедур  системы  BIOS  в  ПЗУ.  Однако,  наше  изложение не
         ограничивается   только   описанием   возможностей,   которые
         предоставляются  системой  BIOS.  Для  каждой из возможностей
         будет рассматриваться вся  техническая  информация,  полезная
         или   интересная   любому,   кто   хочет  понять  особенности
         реализации этой возможности и особенности ее использования.
              Если  обратиться  к  трем  уже  упоминавшимся   областям
         интересов,  то следует отметить, что вся информация полностью
         относится только к IBM/PC. Что касается совместимых с  IBM/PC
         компьютеров,  можно  ожидать,  что  большая  часть информации
         применима  и  к  ним  тоже,  но  степень  применимости  будет
         зависеть   от  того,  насколько  точно  конкретный  компьютер
         копирует IBM/PC; для всех компьютеров, которые  рекламируются
         как совместимые по системе BIOS , данная информация полностью
         применима. Для  семейства   компьютеров,    работающих    под
         управлением  операционной  системы MS-DOS, приведенная в этих
         главах информация будет типичной с точки зрения возможностей,
         которые  должен  предоставлять  любой  компьютер,  но  нельзя
         рассчитывать, что все детали полностью совпадут.
          
              7.1. ТРИ УРОВНЯ ДОСТУПА К ДИСКЕТЕ
              
              Имеются три способа, позволяющие осуществлять  доступ  к
         данным,  хранящимся  на  дискете,  -  из  программы  на языке
         программирования высокого уровня  (такого,  как  Паскаль  или
         БЕЙСИК),   посредством   вызова  функции  ДОС  и  посредством
         обращения к служебной процедуре системы BIOS в ПЗУ.  Все  эти
         способы  образуют трехуровневую иерархию, в которой служебные
         процедуры системы BIOS образуют нижний, наиболее  примитивный
         уровень.  Уровень  функций  ДОС  строится на основе служебных
         процедур  системы  BIOS.  Уровень   языков   программирования
         является  верхним  уровнем и строится на основе функций ДОС и
         служебных процедур системы BIOS.
              Может существовать  еще  один,  более  высокий  уровень,
         обеспечиваемый  системой  управления  базами  данных того или
         иного типа.
              Операции  ввода/вывода  с  дискетой  на  уровне   языков
         программирования  обычно  удовлетворяют  все  потребности  по
         манипулированию  данными,  хранящимися  на  дискете.  В   тех
         случаях, когда этого оказывается недостаточно, не хватает как
         раз не "атомарных" функций низкого уровня, а  процедур  более
         высокого уровня, прредоставляемых только системами управления
         базами данных. Однако, иногда требуется доступ к  дискете  на
         более  низком уровне, например, для прямого чтения или записи
         секторов дискеты. Для выполнения  таких  операций  необходимо
         обращаться  к двум другим уровням ввода/вывода с дискетой - к
         уровням ДОС И BIOS.
              В главе 4 мы уже рассмотрели  доступ  ко  всем  функциям
         ДОС,  включая  и  функции  ввода/вывода  с  дискетой. Одно из
         главных  достоинств  функций  ввода/вывода  на   уровне   ДОС
         заключается,  как  Вы  могли  уже  заметить изучая главу 4, в
         ширине  диапазона  их  возможностей.  Функции  ДОС  позволяют
         выполнять  как  операции  довольно высокого уровня (например,
         поиск в справочнике файлов по родовым именам), так и операции
         среднего  уровня  (чтение и запись логических записей) и даже
         операции  низкого  уровня  (чтение  и  запись   секторов   по
         абсолютному номеру).
              Широкие   возможности   уровня  функций  ДОС  делают  их
         особенно   привлекательными    для    использования.    Языки
         программирования,  такие  как  Паскаль, обычно организуют все
         свои средства ввода/вывода с помощью  функций  ДОС.  Если  Вы
         хотите    освободиться    от    ограничений,    накладываемых
         организацией  системы  ввода/вывода  выбранного  Вами   языка
         программирования,    я    советую   обратиться   к   функциям
         ввода/вывода ДОС.
              Если главная причина обращения к  специальным  операциям
         ввода/вывода  связана  с  необходимостью  чтения  или  записи
         секторов дискеты, то лучше воспользоваться функциями ДОС, чем
         процедурами   BIOS.   Это   связано   только   с   тем,   что
         дополнительный сервис, предоставляемый функциями ДОС, избавит
         Вас   от   необходимости   заботиться  о  таких  деталях  как
         повторение попытки выполнения операции в  случае  ошибки  или
         выдержки   времени,   необходимого   для   разгона  двигателя
         дисковода. Тем  не  менее,  Вам  может  потребоваться  прямой
         доступ  к процедурам уровня BIOS, например, если нужно обойти
         процедуры  обнаружения  ошибок  ДОС или когда нужно выполнить
         операцию, которая не  выполняется  средствами  ДОС.  По  этой
         причине  ниже  приводится описание служебных процедур системы
         BIOS в ПЗУ, предназначеннных для работы с дискетами.
         
         
              7.2.  Служебные  процедуры  обслуживания  дискет системы
                    BIOS в ПЗУ.
              
              Для обслуживания дисководов в системе BIOS имеется шесть
         процедур.  Доступ ко всем осуществляется с помощью прерывания
         номер 19 (шестнадцатиричное значение 13). В этом  разделе  мы
         рассмотрим  каждую  из  них  и  увидим  некоторые  примеры их
         использования. Программы 7.101 и 7.102, включенные в дисковый
         пакет  прилагающийся  к  этой книге, обеспечивают необходимые
         ассемблерные подпрограммы для доступа к этим процедурам BIOS,
         а  также  определения и вспомогательные программы на Паскале,
         облегчающие использование ассемблерных подпрограмм. 
              Первая   служебная   процедура,  которая  имеет  код  0,
         сбрасывает дисковую  подсистему  в  исходное  состояние.  Эта
         процедура   может  использоваться  для  восстановления  после
         различных ошибок и сбоев. Эта  операция  аналогична  операции
         сброса  в ДОС (вызов функции номер 13), но она выполняется на
         более ниэком  уровне  системы  BIOS.  Операция  сброса  диска
         посылает   команду   контроллеру  дисков,  приводящую  его  в
         исходное состояние. Заметим, что здесь не  выполняются  такие
         действия  как  установление  дисковода,  выбираемого  ДОС  по
         умолчанию, - для этого должна выполняться операция сброса  на
         уровне ДОС.
              Наиболее  очевидное  использование  операции  сброса - в
         процедуре  восстановления  после  ошибки.   Часто   наилучшим
         способом  действий  программы  в  случае  ошибки  операций  с
         дискетой  является  быстрое  прекращение  всех  действий,   с
         предоставлением   возможности   разбираться   в   происшедшем
         пользователю компьютера. В конце концов, большинство дисковых
         ошибок  связаны  с  причинами,  которые  невозможно устранить
         программно, например, с механическими  повреждениями  дискеты
         или  неправильной  работой  механики  дисковода. Однако, Ваша
         программа должна использовать все имеющиеся  возможности  для
         восстановления  после  ошибки  и процедура сброса может стать
         важной составной частью такой программы восстановления.
                Вторая  служебная  процедура,  с  кодом  1, позволяет 
           прочитать код  состояния  дисковой  подсистемы.  Состояние 
           изменяется любой дисковой операцией, так что эта процедура 
           отражает последнюю выполненную операцию  с  дискетой.  Эту 
           процедуру   можно   использовать   для  слежения  за  теми 
           операциями ввода/вывода, которыми Вы не  можете  управлять 
           непосредственно.   Например,   если   выполняется  обычная 
           операция ввода/вывода на уровне языка  высокого  уровня  и 
           получено сообщение об ошибке, вызов этой процедуры поможет 
           лучше понять, что произошло, в  чем  состоит  ошибка,  так 
           чтобы программа могла выполнить необходимые корректирующие 
           действия. Ниже приведены  коды  состояний,  которые  могут 
           возвращаться,  сами  по  себе  или в некоторой комбинации, 
           этой процедурой. 
              
         КОД   ШЕСТНАДЦАТИ-           СМЫСЛ
               РИЧНОЕ ЗНА-
               ЧЕНИЕ
         ___   _____________       ___________________________________
              
          1      01                  Была выдана неправильная команда
          2      02                  Не найден адресный маркер (исполь-
                                     зуемый для обнаружения сектора)
          3      03                  Была запрошена операция записи
                                     для дискеты, защищенной от записи
          4      04                  Запрашиваемый сектор не найден
          8      08                  Неправильный адрес при операции
                                     прямого доступа к памяти (ПДП)
          9      09                  При ПДП перейдена граница 64К па-
                                     мяти
         16      10                  Ошибка чтения данных, обнаружен-
                                     ная при проверке циклического из-
                                     быточного кода
         32      20                  Ошибка контроллера гибких дисков
         64      40                  Ошибка поиска указанной дорожки
         128     80                  Тайм-аут: ответ от дисковода не
                                     получен в положенное время
              
              
              Третья и четвертая процедуры, с кодами 2 и 3,  считывают
         и  записывают  один  или  несколько  секторов (объединяемых в
         блок) на одной дорожке. Я советую использовать  эквивалентные
         функции  ДОС,  что избавит  Вас  от  необходимости  проверять
         возникновение  ошибок  или  повторять  выполнение   операций.
         Заметим что эти две операции, а также соответствующие функции
         ДОС позволяют считывать или записывать одновременно несколько
         секторов.  Если  Вам  необходимо выполнить очень быстрый ввод
         или вывод данных, эти операции  позволяют переслать вплоть до
         целой   дорожки  данных  за  время  одного  оборота  дискеты.
         Чтение/запись секторов  по  одному  требуют  затраты  времени
         одного оборота на каждый сектор.
              Впрочем чтение/запись нескольких секторов имеет и свои
         недостатки.  Один  из  таких  недостатков   -   необходимость
         организации  большого  буфера, размером до 4К байт при чтении
         целой дорожки. Если можно работать с данными в том  же  месте
         памяти,  куда  они  считываются  или откуда они записываются,
         такой недостаток не будет  существенным,  но  если  требуется
         выделить  отдельную  буферную  область для работы с дискетой,
         тогда  чтение  или  запись   нескольких   секторов   увеличат
         требования  к  памяти, занимаемой Вашей программой. Имеются и
         другие недостатки, например, если происходит  ошибка,  то  ее
         обнаружение   и  восстановление  после  нее  могут  оказаться
         значительно сложнее, поскольку трудно установить на каком  из
         секторов произошла ошибка. Эта сложность несколько меньше при
         использовании служебных процедур BIOS,  поскольку  они  ведут
         подсчет   числа   переданных  секторов,  который  может  быть
         проанализирован программой; функции ДОС не обеспечивают такой
         возможности.    Проблема   ошибки   в   процессе   выполнения
         многосекторной операции не слишком существенна при чтении, но
         при  записи она может весьма осложнить задачу восстановления,
         если программа не может определить сколько секторов уже  было
         записано.
              Пятая  служебная  процедура, с кодом 4, используется для
         верификации данных после  операции  чтения  или  записи.  Она
         повторно    считывает   сектора,   используя   для   проверки
         циклические избыточные коды. Эта  процедура  используется  по
         ключу  "/V" в  команде  ДОС  COPY.  Верификацией  не  следует
         злоупотреблять  и  на  то  есть  все  основания.   Во-первых,
         операции   с   дискетами   достаточно   надежны.   Во-вторых,
         практически все ошибки при пересылке данных обнаруживаются  и
         сообщения  о  них передаются программам; очень редко операция
         чтения или записи завершается  успешно,  а  данные  при  этом
         как-то  искажаются.  Однако,  когда  гарантия  безошибочности
         действительно важна, необходимо выполнять  верификацию  после
         пересылки   данных.   Эта  операция,  помимо  всего  прочего,
         значительно  увеличивает  время  выполнения   операции.   Для
         верификации  чтения  или записи сектора эту процедуру следует
         вызывать сразу же после завершения операции пересылки.
              Шестая,  и  последняя,  операция, с  кодом  6,  особенно
         интересна.   Эта   процедура   форматирует  дорожку  дискеты,
         записывая адресные маркеры секторов и заполняя сегмент данных
         каждого  сектора  стандартным  шестнадцатиричным значением F6
         или  CHR$(246).  Должны  указываться  отдельно  для   каждого
         сектора  такие  спецификации  как  дорожка,  сторона  и номер
         сектора, а  также  код,  задающий  длину  сектора.  Поскольку
         размер   каждого  сектора  может  быть  задан  независимо  от
         остальных,  можно  сформатировать   дорожку   с   одним   или
         несколькими  секторами  нестандартного размера - что является
         обычным  средством  для  защиты  от   копирования.   Обычными
         средствами  ДОС  нельзя  прочитать  сектор,  размер  которого
         отличается от стандартного 512-байтного, поэтому многие схемы
         защиты  от  копирования  пользуются именно такими средствами.
         Более  подробно  мы  рассмотрим  это  в  следующем   разделе,
         посвященном параметрам, управляющим операциями с дискетой.
              Форматировать нужно  целую  дорожку  сразу  -  поскольку 
         промежутки между секторами и адресные маркеры взаимозависимы. 
         Однако, если необходимо переформатировать всего один  сектор, 
         способ  для  этого все же есть. Например, если нужно изменить 
         формат последнего  сектора  на  дорожке,  сохранив  данные  в 
         первых  семи  секторах, поступите так: напишите программу для
         чтения  первых  семи  секторов,  затем  переформатируйте  всю
         дорожку  и  перезапишите  данные.  Такая  процедура  позволит
         защитить от копирования уже существующие данные, хотя  внешне
         вроде бы ничего не изменяется.
              Для  форматирования всех секторов на дорожке должны быть
         заданы следующие параметры, каждый в виде однобайтного числа: 
              
              1 - номер дорожки (от 0 до 39)
              2 - сторона (0 или 1; для односторонних дискет всегда 0)
              3 - номер сектора (начиная с 1; сектор 0 означает
                  управляющую информацию)
              4 - код длины (0=128 байт, 1=256 байт, 2=512 байт
                  [стандартное], 3=1024)
              
              Поскольку каждый сектор  имеет  собственный  код  длины,
         включить сектор нестандартной длины в дорожку не представляет
         особого  труда  (либо  создать  целую  дорожку  из   секторов
         нестандартной длины для ДОС).
              Если  для  форматирования дорожки используется процедура
         уровня BIOS, следите за правильным указанием всех параметров.
              
              
              7.3. Параметры дискеты и защита от копирования
              
              
              Работа дисковода для гибких дисков частично  управляется
         таблицей,  известной  как  база дисков или таблица параметров
         дискеты (терминология фирмы "ИБМ" пока не устоялась)
              База дисков -  это  таблица,  состоящая  из  одиннадцати
         байт, которая содержит ряд параметров, необходимых для работы
         дисководов,  включая  и  определенную  информацию  о  формате
         дискет. В листинге 7.1 можно найти определение  этой таблицы,
         комментарии к которому описывают назначение каждого байта. 
              Как  упоминалось  в  главе  6,  один вектор прерывания,-
         номер 29, хранящийся в ячейке с  адресом  120,-  используется
         для  указания  местонахождения  этой таблицы. Исходная версия
         этой таблицы, использовавшаяся версией ДОС 1.00, находилась в
         ПЗУ  вместе  с  системой  BIOS,  и  поэтому ее можно видеть в
         листинге BIOS, приведенном в "Техническом руководстве".
              Начиная с версии ДОС  1.10  вместо  этой  таблицы  стала
         использоваться  таблица,  размещаемая  в  оперативной памяти.
         Такое изменение, кстати,  дает  нам  одно  преимущество.  Это
         позволяет  экспериментировать  со  значениями  в  таблице, не
         прибегая к различным ухищрениям для подмены  таблицы  в  ПЗУ.
         Любая  программа  может установить собственную базу диска, но
         вот создать ее таким образом, чтобы  эта  таблица  продолжала
         использоваться  после  окончания  программы, довольно сложно.
         Для достижения это цели необходимо зарезервировать  небольшую
         область  памяти  так, чтобы ДОС не использовала ее. Однако, с
         тех  пор  как  ДОС  стала  размещать  таблицу  базы  диска  в
         оперативной памяти, во всех этих приемах нет необходимости.
              По  сравнению  с  версией ДОС 1.00 в версии 1.10 сделано
         всего два изменения в таблице базы диска,  но  они  позволили
         значительно    увеличить   скорость   использования   дискет.
         Во-первых, они на 25% уменьшили время,  выделенное  дисководу
         для  перемещения  головки  с  дорожки  на  дорожку. Это время
         получило  название  "время шага" (SRT). В   версии   таблицы,
         размещаемой  в ПЗУ, которая использовалась в ДОС версии 1.00,
         время  шага  равнялось  8  миллисекундам.   Новое   значение,
         использующееся начиная с ДОС 1.10, равняется 6 миллисекундам.
              Этот  параметр  в  таблице занимает первый полубайт. Его
         исходное значение было 12 (шестнадцатиричное значение  C),  а
         новое  значение  13 (шестнадцатиричное значение D). Я сначала
         предположил, что такое изменение значения означает увеличение
         времени   шага,   однако   Роберт  Бэттен  сообщил  мне,  что
         используется инверсное  значение  этого  параметра,  так  что
         большее   значение   означает   меньшее   время  шага.  Время
         шага управляется приращениями  по  2  миллисекунды,  так  что
         изменение  времени  шага  с  12 на 13 в таблице соответствует
         уменьшению действительного времени с 8 до 6 миллисекунд.
              Второе изменение  резко  увеличило  скорость  доступа  к
         дискете.   "Время  установления  головки",  то  есть,  пауза,
         необходимая  для  стабилизации  головок  чтения/записи,  была
         уменьшена с 25 миллисекунд до нуля. Первоначально фирма "ИБМ"
         чересчур   предубежденно    относилась    к    быстродействию
         дисководов,  так  что за счет ликвидации времени установления
         удалось добиться сразу  большого  увеличения  быстродействия.
         Большую   часть  параметров  этой  таблицы  изменять  нельзя,
         однако, некоторые из них  предоставляют  широкие  возможности
         для  экспериментаторов.  В  девятом  байте хранится значение,
         которое    используется    операцией    форматирования    для
         инициализации  секторов  дискеты. Стандартное значение F6, но
         Вы можете его изменить. Некоторые программы проверяют наличие
         кода  F6, чтобы найти неиспользовавшиеся сектора, так что это
         значение вряд ли разумно изменять, если для этого нет  веских
         оснований. Такое изменение целесообразно применять для защиты
         от копирования.
              Еще  один интересный параметр - это байт размера сектора. 
         Он определяет размер сектора, который должен  считываться  или 
         записываться.  Это  позволяет  работать  с  секторами,  размер 
         которых отличается от стандартного 512-байтного формата ДОС. В 
         других   операционных  системах  могут  использоваться  другие 
         размеры секторов за  счет  изменения  этого  байта.  Изменение 
         этого  значения является наиболее простым способом организации 
         защиты записи. Для формирования сектора с  размером,  отличным 
         от  512  байт,  необходимо  использовать  служебную  процедуру 
         форматирования, описанную в  предыдущем  разделе.  В  процессе 
         форматирования  размер  каждого сектора определяется отдельно. 
         Однако, чтобы в дальнейшем Ваши  программы  могли  читать  или 
         записывать    нестандартные   сектора,   необходимо   изменять 
         указатель размера сектора в таблице базы диска. 
              Этот параметр может принимать одно из следующих значений:
              
              Значение         Размер сектора в байтах
              ________         _______________________
              
                  0                 128
                  1                 256
                  2                 512 (стандартный для ДОС)
                  3                1024
              
              Листинг  программы  7.1  демонстрирует (на Паскале), как
         осуществляется доступ к таблице базы диска и  как  изменяются
         ее  параметры.  То  же  самое  можно сделать на БЕЙСИКе, хотя
         здесь требуется побайтное извлечение адресных значений.  Ниже
         приведена   программа   на   БЕЙСИКе,   которая   находит   и
         распечатывает таблицу базы диска.
              
              100  REM  Программа на БЕЙСИКе для поиска и распечатки
                        таблицы базы диска
              110  REM
              120  REM  Сначала необходимо установить указатель вектора
                        прерываний
              130  REM
              140  DEF  SEG=0    'начало памяти
              150  OFFSET1=30*4  'смещение до вектора прерывания
              160  REM
              170  REM  Далее нужно определить смещение адреса вектора
              180  REM
              190  OFFSET2=PEEK(OFFSET1)+256*PEEK(OFFSET1+1)
              200  REM
              210  REM  Теперь нужно определить сегментную часть 
                        адреса вектора
              220  REM
              230  DEFSEG=PEEK(OFFSET1+2)+256*PEEK(OFFSET1+3)
              240  REM
              250  REM  Теперь можно начинать просмотр таблицы
              260  REM
              270  PRINT "Ниже следуют данные талицы базы диска в
                          шестнадцатиричном виде"
              280  FOR I=0 TO 10
              290    PRINT " ";
              300    IF PEEK(OFFSET2+1)=16 THEN PRINT"0"; 'добавмть
                                     ноль для четности
              310    PRINT HEX$(PEEK(OFFSET2+1));
              320  NEXT I
              330  PRINT:PRINT
              
              
              Если  Вам  нужны средства для защиты от копирования, мы
         предоставляем их Вам в двух формах.
              Программы  7.103  и   7.104,   имеющиеся   на   дискете,
         прилагаемой   к   этой   книге,  предоставляют  процедуры  на
         ассемблере и на Паскале, которые позволят организовать защиту
         записи  и приспособить ее к Вашей схеме защиты. Кроме того, в
         пакет входит готовая программа защиты, которую можно вызывать
         как на БЕЙСИКе, так и на Паскале. 
              

         {  Листинг  7.1  -- процедуры на Паскале для доступа к пара-}
         {  метрам "базы диска"                                      }
                
         { Этот фрагмент программы демонстрирует возможность доступа }
         { к "базе диска" или таблице управления дискетами. Этот     }
         { листинг разрабатывался для обеспечения наиболее легкой    }
         { настройки на конкретные нужды пользователей перед его ис- }
         { пользованием.                                             }
         
         module Листинг 7.1;
         
         type
         
         disk_base_type = array [1..11] of byte;

         { Ниже кратко описаны все 11 байт таблицы : }
         
         { 1 : время шага; время вывода головки }
         { 2 : время ввода головки; режим ПДП }
         { 3 : время ожидания отключения двигателя }
         { 4 : длина сектора в байтах: 0=128,1=256,2=512,3=1024 }
         { 5 : конец дорожки (номер последнего сектора) }
         { 6 : длина межсекторного промежутка }
         { 7 : длина сегмента данных (когда не задана длина сектора) }
         { 8 : длина промежутка для форматирования  }
         { 9 : байт заполнитель для форматирования  }
         { 10: время установления головки           }
         { 11: время запуска двигателя              }
                
         var
         
          disk_base          : disk_base_type;
          disk_base_pointer  : ads of disk_base_type; {сегментированный
                                                      адрес}
          vector_pointrer    : ads of adsmem; {сегментированный адрес}
         
         procedure disk_base_access;
           begin
         {сначала указатель устанавливается на вектор прерывания базы}
         { диска}
             vector_pointer.s := 0; {раздел сегмента 0, начало памяти}
             vector_pointer.r := 30 * 4; {смещение для вектора 30}
         
         {далее считывается вектор, чтобы установить местоположение}
         { таблицы}
         
             disk_base_pointer := vector_pointer ^;
         {указатель базы диска ("disk_base_pointer") теперь содержит }
         {сегментированный адрес, на который указывал указатель век- }
         {тора ("vector_pointer") -- это означает, что указатель базы}
         {диска теперь укаазывает на адрес фактического местонахожде-}
         {ния таблицы                                                }
         
         {Теперь будет выполняться проверка того. находится ли таблица}
         {в оперативной памяти. Это можно установить попытавшись из-  }
         {менить значение в таблице и затем проверив, изменилось ли   }
         {оно на самом деле. Вместо этого мы просто проверим, в каких }
         {адресах памяти располагается таблица.                       }
         
             if disk_base_pointer.s >= #F000 then
               begin
         {адрес слишком велик - таблица в ПЗУ и изменить ее не удастся}
               end
             else
               begin
         {все в порядке - таблица наверняка в ОЗУ}
               end;
         
         {Теперь скопируем таблицу в свой буфер }
           disk_base := disk_base_pointer ^;
         {База диска теперь содержит копию данных таблицы, на которую}
         {указывал сегментированный адрес в указателе базы диска }

         {Далее, изменим размер на 1024 байта и байт-заполнитель для}
         {форматирования на АА. Эти изменения мы выполняем в своей  }
         {копии, которую затем переносим в реальную таблицу. Впрочем,}
         {то же самое изменение можно было бы выполнить и непосред-  } 
         {ственно в самой таблице.}
           
           disk_base [4] := 3; {установить размер сектора 1024 }
           disk_base [9] := #AA {шестнадцатиричное значение AA }
                              {или десятичное 170 выбрано произвольно}
         
           disk_base_pointer ^ := disk_base; {возвратить таблицу на } 
                                             {место}
           end;
         end.  {конец модуля listing_7_1 }
         
