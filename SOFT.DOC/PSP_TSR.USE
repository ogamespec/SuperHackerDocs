						Панков Ю.И.

	      Использование PSP в TSR программах.
	      ═══════════════════════════════════

  PSP (Program SegmentPrefix) - префикс программного сегмента.
  TSR (Terminate and Stay Resident) - завершить и остаться ре-
      зидентом.
  MCB (Memory Control Block) - блок управления памятью.

     Рассматривается вопрос  использования PSP TSR программами.
     Что побудило  меня написать данную статью?  Не так давно я
прочел статью "группы программистов 2В" Вернера В.А. и Серегина
В.В.: "Способ создания TSR программ без PSP". Из которой следу-
ет, что все авторские права по использованию PSP в TSR програм-
мах принадлежат "группе 2В".  Я использую PSP в своих TSR прог-
раммах вот уже 2 года.	"Группой  2В"  разработан  оригинальный
алгоритм использования PSP :
     - освобождается ENVIROMENT и корректируется размер памяти,
       занимаемой  программой;	при этом DOS  строит новый блок
       MCB сразу за концом будующей TSR программы;
     - в теле самой программы,	сразу  за  MCB	средствами  DOS
       строится новый PSP у которого корректируется адрес роди-
       тельского PSP (копируется со старого);
     - новый PSP указывается DOS в качестве текущего;
     - корректируется указатель на собственника памяти	в новом
       MCB на сегментный адрес нового PSP;
     - резидентная часть программы пересылается по адресу  сег-
       мента старого PSP со смещением 0;
     - далее  программа завершается обычным образом  по функции
       DOS 04ch или по INT 20h.
     Мною разработан иной алгоритм использования PSP TSR  прог-
раммами, который был  успешно  использован при разработке рези-
дентных программ  -  драйверов:  PU_KBG,   PU_KBGM,   PU_DISKM,
PU_VEGAM, PU_TIMEM, PU_INPRN  и многих других.

				2

		     1. Основные понятия.
		      ───────────────────
     1.1. Формат префикса программного сегмента.

     PSP размером  256 байт строится DOS при запуске программы,
всегда предшествует ей и имеет следующий формат:

PSP?	    Struc
PSP_int_20  db	  0cdh,020h  ;00h - INT 20 для завершения
;				    программы
PSP_top     dw	  ?	     ;02h - N 1 свободного параграфа.
PSP_rsv1    db	  6  dup(?)  ;04h - Р е з е р в
; Адрес завершения программы - копия вектора 22h:
PSP_tm_ip   dw	  ?	     ;0ah
PSP_tm_cs   dw	  ?	     ;0ch
; Адрес выхода по Ctrl-Break - копия вектора 23h:
PSP_cb_ip   dw	  ?	     ;0eh
PSP_cb_cs   dw	  ?	     ;10h
; Адрес выхода по фатальной ошибке - копия вектора 24h:
PSP_er_ip   dw	  ?	     ;12h
PSP_er_cs   dw	  ?	     ;14h
; Сегментный адрес родительского PSP
PSP_ow_cs   dw	  ?	     ;16h
; File Handle Table - 20 индексов для системной табл. файлов
PSP_fht     db	  20 dup(?)  ;18h - File Handle Table
; Сегментный адрес среды процесса (ENVIROMENT)
PSP_env     dw	  ?	     ;2сh
PSP_rsv2    db	  34 dup(?)  ;2eh - Р е з е р в
PSP_dos     db	  0cdh,021h  ;50h - INT 21 - обр. к ф. DOS
PSP_rsv3    db	  3 dup(?)   ;52h -  Р е з е р в
PSP_efcb1   db	  7  dup(?)  ;55h - расширение FCB1
PSP_fcb1    db	  16 dup(?)  ;5ch - Не открытый FCB1
PSP_fcb2    db	  16 dup(?)  ;6ch - Не открытый FCB2
PSP_rsv4    db	  4  dup(?)  ;7ch - Р е з е р в
; Область DTA по умолчанию и:
PSP_lparm   db	  ?	     ;80h - Длина поля параметров
PSP_parm    db	  127 dup(?) ;81h - Поле параметров
PSP?	    Ends

	     1.2. Формат блока управления памятью.

     MCB размером 16 байт строится DOS,  описывает каждый расп-
ределенный участок памяти,  всегда  предшествует  PSP;	сегмент
владелца  такого  MCB всегда указывает на PSP.	Все блоки MCB в
памяти образуют односвязанный список, начало которого можно оп-
ределить 52h функцией DOS. MCB имеет следующий формат:

MCB?	    Struc
; Тип блока -		      "M" (4dh) - промежуточный
MCB_type    db	  ?	     ;"Z" (4ah) - конечный
; Сегмент владельца блока (0 - свободный блок - владелец DOS):
MCB_own_cs  dw	  ?	     ;01h - CS
MCB_Lp	    dw	  ?	     ;03h - длина блока в параграфах
MCB_rsv1    db	  3 dup (?)  ;05h - Р е з е р в
MCB_rsv2    db	  8 dup (?)  ;08h - Р е з е р в
;				    (иногда имя хозяина)
MCB?	    Ends

				3

	   1.3. План памяти при загрузке программы.

	 ┌─────────────┐
	 │     MCB     │	  PSP родителя
	 │01h ─────────┼────┐	  ^
	 │	       │    │	  │
	 ├─────────────┤    │	  │
	 │     PSP     │<───┘	  │
	 │	       │	  │
	 │16h ─────────┼──────────┘
	 │	       │
	 │2ch ─────────┼────>┌────────────┐
	 │	       │     │ ENVIROMENT │
	 │	       │     └────────────┘
	 ├─────────────┤
	 │	       │
	 │     PGM     │
	 └─────────────┘
			     Рис.1

	     2. Использование PSP TSR программами.
	     ─────────────────────────────────────
     План фрагмента памяти после загрузки программы в оператив-
ную память изображен на рис.1.
     Если TSR	прямо	или   косвенно	не  использует	область
ENVIROMENT, то ее надо освободить.
     TSR программы, использующие весь PSP называют TSR програм-
мами без PSP.  Ниже дается алгоритм построения программ без PSP
( или  с частичным его использованием),  разработанный автором.
Сущность его состоит в перемещении программы в область PSP ПОС-
ЛЕ ЗАВЕРШЕНИЯ 31h функции DOS или INT 27h.
     Хорошо известный у нас в стране драйвер  "800"  использует
только нижнюю половину PSP.

 2.1. Алгоритм инициализации TSR программ с использованием PSP.

     1. Определить  конец резидентной части программы (EndRes),
	выровненный на граниу параграфа.
     2. Запомнить 16 байт резидентной части программы по смеще-
	нию EndRes-Delta в специально отведенном буфере, где:
	Delta - величина перемещения программы (кратна 16)
		Для TSR без PSP Delta=100h
	В эту область DOS расположит последний MCB  блок  после
	резидентного завершения программы (Рис.2).
     3. Освободить блок среды, если это необходимо.
     4. Переопределить	указатель  выхода PSP_tm (смещение 0ah)
	указателем на программу-аппендикс выхода в DOS (п.2.2).
     5. Вычислить  длину резидентной части программы в парагра-
	фах с учетом перемещения в PSP:
		   LTSR=(EndRes-Delta)/16
	Запомнить, как минимум, регистры SS и SP .
     6. Завершить программу по функции DOS 31h или INT 27h.

				4

      2.2. Алгоритм программы-аппендикса выхода в DOS.

     1. Восстановить, как минимум, регистры SS и SP.
     2. Переместить резидентную часть программы в PSP.
     3. Восстановить   16   байт    программы	 по    смещению
	EndRes-2*Delta от нового начала программы из буфера.
     4. Установить требуемые вектора прерываний, если это необ-
	ходимо. При  установке	 векторов   необходимо	 учесть
	новое значения сегмента TSR = CS-Delta/16.
     5. Осуществить длинный переход по вектору 22h.

	2.3. План памяти на входе программы-аппендикса
		  выхода в DOS	(Delta=100h).

	 ╔═══════╗		      LTSR - длина резидентной
	 ║  MCB  ║			     части программы в
	 ╠═══════╣───────────── 	     байтах кратная па-
	 │  PSP  │	    ^		     раграфу.
	 ╠═══════╣─────     │
	 ║	 ║   ^	    │	      LMSB - длина блока памяти
      ───╫─ ─ ─ ─╢   │	    │		     в параграфах.
       | ║ Save  ║   │ LTSR │
  100h │ ║─ ─ ─ ─║   │	    │ LMCB    Save - область  распреде-
       | ║	 ║   |	    │		     ления нового MCB.
 EndRes──╫	 ╫─────     │
	 │─ ─ ─ ─│	    │	    Buffer - область сохранения
	 │ Buffer│	    │		     области Save.
	 │─ ─ ─ ─│	    │
	 │	 │	    |
	 └───────┴──────────────

			     Рис.2

	2.5. План памяти на выходе программы-аппендикса
		  выхода в DOS (Delta=100h).

	 ╔═══════╗
	 ║  MCB  ║
      ───╠═══════╣		   EndRes1 - смещение конца пе-
       | ║	 ║			     ремещенной     TSR
  LMCB │ ║	 ║			     программы.
       │ ║─ ─ ─ ─║─── EndRes1-200h
  LTSR │ ║ Save1 ║
       | ║─ ─ ─ ─║		     LMCB1 - длина нового блока
      ───╠═══════╣─── EndRes1		     памяти в парагр.
	 │  MCB1 │
	 ├───────┤───── 	     Save1 - восстановленная
	 │	 │   |			     область прогр.
	 │	 │   │
	 │─ ─ ─ ─│   │ LMCB1	    Buffer - область сохранения
	 │ Buffer│   │			     области Save.
	 │─ ─ ─ ─│   │
	 │	 │   |
	 └───────┘─────

			     Рис.3

				5

		   3. Реализация алгоритма.
		   ────────────────────────
     Реализован только для  COM  программ  одной  макрокомандой
EXir0? и одним обЪектным модулем PU_Exir0.  Макрокоманда Exir0?
осуществляет построение блока управления завершением TSR  прог-
раммы и вызов модуля PU_Exir0, реализующего вышеуказанный алго-
ритм.

		3.1 Формат макрокоманды Exir0?.

     Exir0?  TPSP,EndRes,VList,Keep,UCall	 где:

     TPSP - длина в параграфах неизменяемой части PSP - опреде-
	    ляет  адрес  начала перемещенной TSR программы. Для
	    TSR программ без PSP  TPSP=0.
   EndRes - смещение конца резидентной части  программы (вырав-
	    нивание на параграф не обязательно).
    VList - список устанавливаемых векторов в формате:

	    <<N1,Off1>,<N2,Off2>,...>	  где:

	     N1, N2,	 ... - номера векторов
	     Off1, Off2, ... - смещения программ-обработчиков
			       прерываний
     Keep - =Y / N - предписывает  освободить / не  освобождать
	    блок среды (ENVIROMENT).
    UCall - адрес подпрограммы	дополнителной  обработки. UCall
	    необходим, если кроме установки векторов, необходи-
	    мо выполнить некоторые дополнительные операции  пе-
	    ред выходом в DOS.

     Таким образом процесс создания TSR программы, использующей
PSP или ее часть сводится к выдаче макрокоманды Exir0?	с необ-
ходимыми операндами в исходном тексте программы.

    3.2 пример построения фрагментов TSR программы без PSP.

	 page  88,132	     ;Размер страницы
;
; Программа пример построения TSR программы без PSP
; Программист: Панков Ю.И.
;
; Дата создания:   4. 3.91
; Дата редакции и N версии:
DAT_@@@ equ    <04.03.91>
VER_@@@ equ    <V 1.0>
;
Nam_@@@ equ    <"PU_PSPRS">
name	PU_PSPRS
;
out? <.   ╔═════════════════╗>
out? <.   ║ P U _ P S P R S ║>
out? <.   ║		    ║>
out? <.   ║ >,%VER_@@@,<  >,%DAT_@@@,< ║>
out? <.   ╚═════════════════╝>
;

				6

;  Подключение сервиса
	include MACRO_00.INC	;общего назначения
	include MACRO_IO.INC	;функции BIOS
	include MACRO_01.INC	;дополнительные
	include MACROTBL.INC	;генерация таблиц
	include MACRODOS.INC	;функции DOS
	include MACROKBD.INC	;функции BIOS
;  Управление листингом МАКРО
;	.lall		;Полный
;	.xall		;Не полный
	.sall		;без pаcшиpений макpо
;
	.model	small
	.code		;начало кодового сегм. _Text
	assume	ds:_text
	org	100h	;для COM программ
Start:	jmp	Start1
	even
;
;    Обработчик прерываний клавиатуры
;  ═════════════════════════════════════
I9h:
;┌─────────────────────────────────────────┐
;│ Исходный текст программы-обработчика    │
;│ прерываний от клавиатуры		   │
;└─────────────────────────────────────────┘
;
; Выход по старому вектору 9h:
Bios9h:
db	0eah		;jmp far
Dword?	Old9h		;содержимое старого 9h
;
;    Конец резидентной части программы
;  ═════════════════════════════════════
EndRes equ	$
;
;Запуск программы
Start1:
       cld
; Запоминание старого вектора 9h в Old9h (сохранить es):
       GetInt? 9,OldKB,es
;┌─────────────────────────────────────────┐
;│ Тело программы инициализации обработчика│
;│	    прерываний 9h		   │
;└─────────────────────────────────────────┘
; Завершение резидентной программы без PSP:
; 1. Освободить Enviroment (Keep=N)
; 2. Переместить резидентную часть программы в PSP
; 3. Установить вектор 9h
; 4. Дополнительно выполнить подпрограмму SetDrv
; 5. Остаться резидентом
Exir0? 0,EndRes,<<9,I9h>>,N,SetDrv

				7
;
; Программа дополнительной обработки
; на входе: ds=es=cs
Block?	SetDrv
;┌─────────────────────────────────────────┐
;│ Исходный текст программы дополнительной │
;│	    обработки			   │
;└─────────────────────────────────────────┘
Bend?	SetDrv
	END	 Start
					   4.03.91. Панков Ю.И.
