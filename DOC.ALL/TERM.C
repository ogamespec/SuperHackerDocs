/***********************************************************************
*       Файл TERM.C
*
*	Эмулятор терминала
*
* Вызов:
*       term [Порт [Скорость [Четность [Слово [Стоп]]]]]
*       Порт            - номер порта. По умолчанию 1.
*       Скорость        - Число от 50 до 115200. По умолчанию 2400
*       Четность        - Один из символов N, O, E, M или S где
*                               N - Нет контроля (NONE)
*                               O - Сумма битов нечетная (ODD)
*                               E - Сумма битов четная (EVEN)
*                               M - Бит 7 всегда 1 (MARK)
*                               S - Бит 7 всегда 0 (SPACE)
*			  По умолчанию контроль по четности отсутствует.
*       Слово   - число информационных бит в байте. По умолчанию 8.
*       Стоп    - число стоповых бит, 1 или 2. По умолчанию 1.
*
*       Компилятор Microsoft C 5.1
*/

#include <conio.h>      /* для работы с консолью            */
#include <graph.h>      /* прототипы графических функций    */
#include <stdlib.h>     /* Стандартные функции              */
#include <dos.h>        /* Определения FP_OFF и FP_SEG      */

#define USAGE   "term [Порт [Скорость [Четность [Слово [Стоп]]]]]"

/*  Смещения регистров относительно базы		    */
#define LCR	3	/* Регистр управления линией	    */
#define MCR	4	/* Регистр управления модемом	    */
#define IER	1	/* Регистр идентификации прерываний */
#define LSR	5	/* Регистр статуса линии	    */

/*  Маски для установки битов в регистрах                           */
#define GPO2    8       /* Сигнал разрешения аппаратных прерываний  */
#define R_INT   1       /* Прерывание по приходу байта              */

/* Константы относящиеся к контролеру прерываний 8259       */
#define IMR     0x21    /* Адрес регистра масок прерываний  */
#define ICR     0x20    /* Адрес регистра команд            */
#define IRQ3	0xF7	/* Маска для разрешения прерывания от COM2  */
#define IRQ4	0xEF	/* Маска для разрешения прерываний от COM1  */
#define EOI3    0x63    /* Сигнал об окончании обработки прерывания от COM2 */
#define EOI4    0x64    /* Сигнал об окончании обработки прерывания от COM1 */

int eoi;     /* Сигнал об окончании обработки прерывания */

/*  Маски для установки битов в регистре управления модемом     */
#define DTR     1       /* Сигнал готовности терминала          */
#define RTS     2       /* Сигнал запроса на передачу           */

#define TRRDY	0x20	/* Маска для определения готовности порта к передаче
			   байта    */

/* Глобальные переменные    */
int p_base;     /*  Базовый адрес последовательного порта   */
void (interrupt far *oldvect)(); /* Старый вектор прерывания 0xB/0xC */

#define BSIZE	4096		    /* Размер кольцевого буфера      */
unsigned char buf[BSIZE];    /* Кольцевой буфер 		     */
unsigned char *inptr = buf;  /* Указатель на первое свободное место  */
unsigned char *outptr = buf; /* Указатель на первый считываемый байт */

#define ESC	0x1B	    /* ASCII код символа Esc	*/

/* Прототипы функций    */
void interrupt far i_handler(void);
int portbase(short);
void setparm(long, char, int, int);
void porton(short);
void portoff(short);
int portin(unsigned char *);
int portout(unsigned char);

void main(int argc, char *argv[])
{
short port = 1;     /* Номер используемого порта	    */
long speed = 2400;  /* Скорость передачи		    */
char parity = 'N';  /* Контроль по четности		    */
short word = 8;     /* Число информационных битов	    */
short stop = 1;     /* Число стоповых битов		    */
unsigned char ch;   /* Рабочая переменная. Одиночный символ */

/* Разбор аргументов командной строки   */
if (argc > 6) {
	cprintf("\a%s\r\n",USAGE);
	exit(1);
	}

switch (argc) {
	case 6:     /* Число стоповых битов         */
		stop = atoi(argv[5]);
	case 5:     /* Число информационных битов   */
		word = atoi(argv[4]);
	case 4:     /* Контроль по четности         */
		parity = (char)toupper(*argv[3]);
	case 3:     /* Скорость передачи            */
		speed = atol(argv[2]);
	case 2:     /* Номер используемого порта    */
		port = atoi(argv[1]);
	}

/* Анализ параметров работы     */
if ((port < 1) || (port > 4)) {
	cprintf("\aНеправильный номер порта! '%d'\r\n%s",port,USAGE);
	exit(1);
	}

if ((speed < 50) || (speed > 115200)) {
	cprintf("\aНеправильно задана скорость! '%ld'\r\n%s",speed,USAGE);
	exit(1);
	}

if ((word > 8) || (word < 5)) {
	cprintf("\aНеправильно задан размер слова! '%d'\r\n%s",word,USAGE);
	exit(1);
	}

if ((parity != 'N') && (parity != 'O') && (parity != 'M') &&
		(parity != 'S') && (parity != 'E')) {
	cprintf("\aНеправильно задана четность! '%c'\r\n%s",parity,USAGE);
	exit(1);
	}

if ((stop > 2) || (stop < 1)) {
	cprintf("\aНеправильно задано число стоповых битов! '%d'\r\n%s",stop,USAGE);
	exit(1);
	}

/*  Определение базового адреса последовательного порта */
if (portbase(port) == -1) {
	cprintf("\aПорт COM%d отсутсвует на Вашей машине!",port);
	exit(1);
	}

/* Установка параметров обмена  */
setparm(speed, parity, word, stop);

/* Подготовка порта к работе    */
porton(port);

cprintf("\r\nПорт %d  Скорость %ld\r\nДля выхода нажмите Esc\r\n\n\n");

/*** Основной цикл  ***/
while (1) {
    if (portin(&ch) > -1)   /* Есть данные в буфере? */
	putch(ch);	    /*	Отобразим на экране  */

    if (kbhit())		    /* Было нажатие клавиш?	*/
	if ((ch = (unsigned char)getch()) != ESC)   /* Да. Конец работы? */
	    portout(ch);	     /* Нет. Посылаем в линию	 */
	else break;		    /* Да. Конец		*/
    }

/* Вернем порт в обычное состояние   */
portoff(port);
exit(0);
}

/*************************************************************************
*       Функция portbase выбирает базовый адрес заданного порта из
*   таблицы глобальных переменных BIOS и устанавливает глобальную
*   переменную p_base.
*
*   Возвращает значение p_base или -1 при отсутствии порта в машине
*/
int portbase(short pnum)
{
int far *biosdata;      /* Указатель в BIOS Data Area   */

FP_SEG(biosdata) = 0x40;    /* Сегмент 40H  */
FP_OFF(biosdata) = 0;       /* Смещение 0   */

p_base = *(biosdata + pnum - 1);    /* Берем адрес  */

if (!p_base)            /* 0 означает отсутствие порта  */
	return -1;      /* сигнал об ошибке             */

return p_base;
}

/*************************************************************************
*       Функция setparm устанавливает параметры обмена: скорость,
*   вид контроля по четности, число битов данных и число стоповых битов.
*/
void setparm(long baud, char parity, int word, int stop)
{
register unsigned divisor;   /* Делитель частоты для установки скорости        */
register unsigned char parm; /* Байт параметров для регистра управления линией */

if (!p_base)    /* 0 означает то, что базовый адрес */
	return;     /* порта не установлен              */

parm = (unsigned char)inp(p_base + LCR);    /* Чтение текущих параметров линии  */

/* Установка скорости обмена            */
/* Делитель = 1.8432 МГц / (baud * 16)  */
divisor = (unsigned)(115200L / baud);

outp(p_base + LCR, parm | 0x80);    /* Подготовка порта к установке
										скорости. Бит 7 в 1         */
outp(p_base + 1, divisor >> 8); /* Старший байт делителя    */
outp(p_base, divisor & 0xFF);   /* Младший байт делителя    */

/* Подготовка байта параметров для регистра управления линией   */
/* Четность */
parm &= 7;          /* По умолчанию NONE    */
switch (parity) {
	case 'S':               /* SPACE    */
	case 's':
		parm |= (7 << 3);
		break;
	case 'M':               /* MARK     */
	case 'm':
		parm |= (5 << 3);
		break;
	case 'E':               /* EVEN     */
	case 'e':
		parm |= (3 << 3);
		break;
	case 'O':               /* ODD      */
	case 'o':
		parm |= (1 << 3);
		break;
	}

/* Установка числа битов данных и числа стоповых битов  */
parm |= (((stop - 1) << 2) | (word - 5));

/* Установка параметров линии и переключение порта в рабочий режим  */
outp(p_base + LCR, parm);
}

/*************************************************************************
*       Функция porton переводит порт в рабочий режим.
*   Подменяет вектор прерывания, разрешает прерывания от порта и
*   выставляет сигналы готовности терминала и запроса на передачу.
*/
void porton(short pnum)
{
register unsigned i_num;    /* Номер прерывания     */
register int c;             /* Рабочая переменная   */

if ((pnum == 2) || (pnum == 4)) /* Определение номера прерывания    */
	i_num = 0xB;
else i_num = 0xC;

oldvect = _dos_getvect(i_num);  /* Сохраним текущий вектор прерывания    */
_dos_setvect(i_num, i_handler); /* Заменим обработчик прерывания на свой */

/* Разрешим прерывания от порта */
c = inp(p_base + MCR) | GPO2 | DTR | RTS;   /* Разрешение прерывания от
					       схем RS-232 и установка
					       сигналов DTR и RTS	*/
outp(p_base + MCR, c);

outp(p_base + IER, R_INT);      /* Прерывания только по приходу байта   */

/* Програмирование контроллера 8259 */
c = inp(IMR);
if ((pnum == 2) || (pnum == 4))
	{
	c &= IRQ3;      /* Разрешение прерывания от COM2                    */
	eoi = EOI3;     /* Сигнал об окончании обработки прерывания от COM2 */
	}
else {
	c &= IRQ4;      /* Разрешение прерывания от COM1                    */
	eoi = EOI4;     /* Сигнал об окончании обработки прерывания от COM1 */
	}
outp(IMR, c);
}

/*************************************************************************
*       Функция portoff переводит порт в из рабочего режима в обычное
*   состояние для MS-DOS (обратная к porton).
*   Запрещает прерывания от порта, востанавливает обработчик прерываний
*   и маскирует сигналы MCR.
*/
void portoff(short pnum)
{
register unsigned i_num;    /* Номер прерывания     */
register int c;     /* Рабочая переменная   */

/* Запрещаем прерывания от порта    */
/* Програмирование контроллера 8259 */
c = inp(IMR);
if ((pnum == 2) || (pnum == 4))
	c |= ~IRQ3;     /* Запрещение прерываний от COM2 */
else c |= ~IRQ4;	/* Запрещение прерываний от COM1 */
outp(IMR, c);

outp(p_base + IER, 0);      /* Запрещение всех типов прерываний */

outp(p_base + MCR, 0);      /* Маскируем все сигналы            */

if ((pnum == 2) || (pnum == 4)) /* Определение номера прерывания    */
	i_num = 0xB;
else i_num = 0xC;

_dos_setvect(i_num, oldvect);   /* Восстановим обработчик прерывания */
}

/*************************************************************************
*       Функция i_handler является обработчиком прерываний от порта.
*   Функция получает управление при возникновении прерывания. Она
*   забирает байт из порта и кладет его в буфер. Буфер кольцевой - т.е.
*   при заполнении он начинает заполняться сначала.
*/
void interrupt far i_handler(void)
{
*inptr = (unsigned char)inp(p_base);   /* Считаем байт */

if (++inptr >= &buf[BSIZE])     /* Проверка выхода за границу буфера    */
	inptr = buf;		/* Если да, то начнем сначала		*/

outp(ICR, eoi);
}

/*************************************************************************
* Функция portin выбирает один байт из кольцевого буфера. Если буфер пуст,
* то возвращается -1
*/
int portin(unsigned char *ch)
{
int rc = 0;   /* Код завершения */

if (inptr != outptr) {		/* Есть в буфере данные?    */
    *ch = *outptr & 0x7F;	/* Да. Берем ASCII символ   */
    if (++outptr >= &buf[BSIZE])    /* Проверка выхода за границу буфера */
	outptr = buf;		    /* Если да, то начнем сначала	 */
    }
else rc = -1;

return rc;
}

/*************************************************************************
* Функция portout посылает байт ch в линию. Возвращает 0 при нормальном
* завершении. При ошибке возвращается -1
*/
int portout(unsigned char ch)
{
register int tm = -32000;      /* Счетчик для организации таймаута */

while ((inp(p_base + LSR) & TRRDY) == 0)  /* Пока порт не готов к передаче */
    if (tm++ > 0)
	return -1;	/* Ошибка. Выход по таймауту	*/

outp(p_base, ch);	/* Вывод символа */
return 0;
}
