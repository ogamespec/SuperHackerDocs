
Структура базы данных (типа .DBF)

     Файл базы данных состоит из записи заголовка и записей
с данными. В записи заголовка определяется структура базы
данных и содержится вся другая информация, относящаяся к
базе данных. В файле она начинается с нулевой позиции.
     Записи с данными* следуют за заголовком (байты
располагаются последовательно) и включают в себя фактическое
содержимое полей. Длина записи (в байтах) определяется
суммированием указанных длин всех полей. Числа в данном
файле размещаются в обратном порядке.

 ════════════════════════════════════════════════════════════
 ║         Запись заголовка в файле с данными               ║
 ║----------------------------------------------------------║
 ║ Байты :              Описание                            ║
 ║══════════════════════════════════════════════════════════║
 ║ 00    :Типы файлов с данными:                            ║
 ║       : FoxBASE+/dBASE III +, без memo - 0х03            ║
 ║       : FoxBASE+/dBASE III +, с memo - 0х83              ║
 ║       : FoxPro/dBASE IV, без memo - 0х03                 ║
 ║       : FoxPro с memo - 0хF5                             ║
 ║       : dBASE IV с memo - 0x8B                           ║
 ║----------------------------------------------------------║
 ║ 01-03 :Последнее изменение (ГГММДД)                      ║
 ║----------------------------------------------------------║
 ║ 04-07 :Число записей в файле                             ║
 ║----------------------------------------------------------║
 ║ 08-09 :Положение первой записи с данными                 ║
 ║----------------------------------------------------------║
 ║ 10-11 :Длина одной записи с данными (включая признак     ║
 ║       :удаления)                                         ║
 ║----------------------------------------------------------║
 ║ 12-27 :Зарезервированы                                   ║
 ║----------------------------------------------------------║
 ║ 28    :1-есть структ.составной инд.файл (типа .CDX),0-нет║
 ║----------------------------------------------------------║
 ║ 29-31 :Зарезервированы                                   ║
 ║----------------------------------------------------------║
 ║ 32-n  :Подзаписи полей**                                 ║
 ║----------------------------------------------------------║
 ║  n+1  :Признак завершения записи заголовка (0х01)        ║
 ════════════════════════════════════════════════════════════
 ════════════════════════════════════════════════════════════
 ║                    Подзаписи полей                       ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-10 :Название поля (максимально - 10 символов, если    ║
 ║       :меньше 10, то дополняется пустым символом (0х00)) ║
 ║----------------------------------------------------------║
 ║ 11    :Тип данных:                                       ║
 ║       : C - символьное;                                  ║
 ║       : N - числовое;                                    ║
 ║       : L - логическое;                                  ║
 ║       : M - типа memo;                                   ║
 ║       : D - дата;                                        ║
 ║       : F - с плавающей точкой;                          ║
 ║       : P - шаблон.                                      ║
 ║----------------------------------------------------------║
 ║ 12-15 :Расположение поля внутри записи                   ║
 ║----------------------------------------------------------║
 ║ 16    :Длина поля (в байтах)                             ║
 ║----------------------------------------------------------║
 ║ 18-32 :Зарезервированы                                   ║
 ════════════════════════════════════════════════════════════

     Примечания по структуре файла с данными.
     * Данные в файле с данными начинаются с позиции,
     указываемой в записи заголовка в байтах 08-09. Записи с
     данными начинаются с байта, содержащего признак
     удаления. Если в этот байт занесен пробел в коде ASCII
     (0х20), то запись не удалялась; если же в первом байте
     - звездочка (0х2A), то запись удалена. За признаком
     удаления следуют данные из полей, названия которых
     находятся в подзаписях полей.
     ** Количество полей определяет число подзаписей полей.
     В базе данных для каждого поля существует одна
     подзапись поля.
     *** Ограничения по количеству знаков в записи,
     максимальному числу полей и т.д. смотрите в данном
     приложении в таблице "Системные возможности".

Структура файла типа memo (.FPT)

     Файл типа memo содержит одну запись заголовка и
произвольное число блочных структур. В записи заголовка
располагается указатель на следующий свободный блок и размер
блока в байтах. Размер устанавливается командой SET
BLOCKSIZE при создании файла. Запись заголовка начинается с
нулевой позиции файла и занимает 512 байтов.
     За записью заголовка следуют блоки, в которых
содержатся заголовок блока и текст memo. В файл базы данных
включены номера блоков, которые используются для ссылки на
блоки memo. Расположение блока в файле типа memo
определяется умножением номера блока на размер блока
(находящийся в записи заголовка файла типа memo). Все блоки
memo начинаются с четных адресов границ блоков. Блок memo
может занимать более, чем один последовательный блок.

 ════════════════════════════════════════════════════════════
 ║              Запись заголовка файла типа memo            ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-03 :Расположение следующего свободного блока*         ║
 ║----------------------------------------------------------║
 ║ 04-05 :Не используются                                   ║
 ║----------------------------------------------------------║
 ║ 06-07 :Размер блока (число байтов в блоке)               ║
 ║----------------------------------------------------------║
 ║ 08-511:Не используются                                   ║
 ║══════════════════════════════════════════════════════════║
 ║          Заголовок блока memo и текст memo               ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-03 :Сигнатура блока* (указывает тип данных в блоке):  ║
 ║       : а. 0 - шаблон (поле типа шаблон);                ║
 ║       : б. 1 - текст (поле типа memo)                    ║
 ║----------------------------------------------------------║
 ║ 04-07 :Длина* memo (в байтах)                            ║
 ║----------------------------------------------------------║
 ║ 08-n  :Текст memo (n=длина)                              ║
 ════════════════════════════════════════════════════════════

Структура файла memo в системе FoxBASE+ (типа .DBT)

     Файлы memo в системе FoxBASE+ не обладают
многосторонностью файлов memo системы FoxPro. В них могут
содержаться только текстовые данные в коде ASCII.
     В данный файл записи выводятся блоками, каждый размером
512 байтов. В блок, начинающийся с нулевой позиции файла,
включен номер блока, соответствующий первой свободной
позиции в файле. Этот номер блока хранится в первых двух
байтах в обратном порядке (формат Intel 8086). Для того,
чтобы найти адрес первого свободного блока, надо размер
одного блока (512 байтов) умножить на номер блока.
     Блоки, которые следуют за первым блоком, содержат текст
полей memo из связанной базы данных. В поле memo в файле
базы данных содержится номер блока в файле типа memo,
который содержит настоящий текст. Все блоки memo начинаются
с адресов, границы которых кратны 512 байтам.

Структура индексного файла (.IDX)

     В индексных файлах располагается одна запись заголовка
и одна или больше записей вершин. В записи заголовка
находится информация о корневой вершине, текущем размере
файла, длине ключа, особенностях индекса и сигнатура, а
также представление ключа* в коде ASCII, которое можно
вывести на печать, и выражения FOR. Запись заголовка
начинается с нулевой позиции файла.
     Во всех других записях вершин содержится атрибут,
количество существующих ключей и указатели на вершины,
располагающиеся слева и справа (на том же уровне) от данной
вершины. Помимо этого, в них находится группа символов,
представляющая значение ключа, и либо указатель на вершину
нижнего уровня, либо подлинный номер записи в базе данных.
Размер каждой записи, которая выведена в файл, равен 512
байтам.
     В приведенных ниже таблицах показан пример
упорядоченной структуры дерева.

 ════════════════════════════════════════════════════════════
 ║              Запись заголовка индексного файла           ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-03 :Указатель на корневую вершину                     ║
 ║----------------------------------------------------------║
 ║ 04-07 :Указатель на свободную в списке вершину (-1, если ║
 ║       :таковая отсутствует)                              ║
 ║----------------------------------------------------------║
 ║ 08-11 :Указатель на конец файла (размер файла)           ║
 ║----------------------------------------------------------║
 ║ 12-13 :Длина ключа                                       ║
 ║----------------------------------------------------------║
 ║ 14    :Особенности индекса (любое из нижеследующих       ║
 ║       :числовых значений либо их сумма):                 ║
 ║       : а. 1 - уникальный индекс;                        ║
 ║       : б. 8 - индекс имеет дополнительный оператор FOR. ║
 ║----------------------------------------------------------║
 ║ 15    :Сигнатура индекса(для использования в будущем)    ║
 ║----------------------------------------------------------║
 ║ 16-235:Ключевое выражение (не компилируется; до 220      ║
 ║       :символов)*,***                                    ║
 ║----------------------------------------------------------║
 ║236-455:Выражение FOR (не компилируется; до 220 символов, ║
 ║       :оканчивающееся пустым символом)                   ║
 ║----------------------------------------------------------║
 ║456-511:Не используются                                   ║
 ════════════════════════════════════════════════════════════
 ════════════════════════════════════════════════════════════
 ║              Запись вершины индекса                      ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-01 :Атрибуты вершины (любое из нижеследующих          ║
 ║       :числовых значений либо их сумма):                 ║
 ║       : а. 0 - вершина индекса;                          ║
 ║       : б. 1 - корневая вершина;                         ║
 ║       : в. 2 - лист.                                     ║
 ║----------------------------------------------------------║
 ║ 02-03 :Количество существующих ключей (0, 1 или больше)  ║
 ║----------------------------------------------------------║
 ║ 04-07 :Указатель на вершину, расположенную               ║
 ║       :непосредственно слева от данной вершины (на том   ║
 ║       :же уровне; -1, если отсутствует)                  ║
 ║----------------------------------------------------------║
 ║ 08-11 :Указатель на вершину, расположенную               ║
 ║       :непосредственно справа от данной вершины (на том  ║
 ║       :же уровне; -1, если отсутствует)                  ║
 ║----------------------------------------------------------║
 ║ 12-511:До 500 символов, включающих в себя значение ключа ║
 ║       :для длины ключа с четырехбайтовым                 ║
 ║       :шестнадцатиричным числом (хранящемся в обычном    ║
 ║       :формате слева направо):                           ║
 ║       : Если вершина является листом (атрибут = 02 или   ║
 ║       : 03), тогда четыре байта содержат подлинный номер ║
 ║       : номер в базе данных в шестнадцатиричном формате -║
 ║       : иначе 4 байта содержат внутрииндексный           ║
 ║       : указатель.**                                     ║
 ════════════════════════════════════════════════════════════

     Примечания по структуре индексного файла.
     * Тип ключа не запоминается в индексе. Он должен
     определяться индексным выражением.
     ** В вершине-листе все, что отлично от символьных
     строк, числа, используемые в качестве значений ключей и
     четырехбайтовые номера представляются в байтах, порядок
     которых изменен на противоположный (в формате Intel
     8086).
     *** Если числа используются в качестве ключей, то они
     подвергаются специальной обработке. Они
     преобразовываются согласно нижеследующему способу таким
     образом, чтобы их можно было отсортировать с помощью
     такой же схемы упорядочения в коде ASCII, что и
     символы:
     а. Преобразовать число в формат с плавающей точкой
     IEEE.
     б. Изменить на противоположный порядок байтов с
     порядка Intel на порядок слева направо.
     в. Если число отрицательное, взять логическое
     дополнение числа (изменить на противоположные все 64
     бита, 1 на 0 и 0 на 1), иначе инвертировать только
     самый левый бит.

Пример упорядоченной структуры дерева

     Поиск ключа в приведенной ниже структуре потребует
просмотра единственного пути между корневой вершиной и
листом. Вершины на самом нижнем уровне являются
вершинами-листьями. Так как ключи отсортированы, то все
ключи в поддереве меньше либо равны родительской вершине.

                   Корневая вершина
                          :
                    --------------
                    :  :      :  :
   Указатель на --- :-1:  F,H :-1: --- Указатель на
   левую вершину    :  :      :  :     правую вершину
                    --------------
                         :  :
                  .......:  :......
                 :                 :
                 v                 v
          --------------    --------------
          :  :      :  ---->:  :      :  :
          :-1:  C,F :  :    :  :   H  :-1: --- Индексная
          :  :      :  :<----  :      :  :     вершина
          --------------    --------------
               :  :               :  :
        .......:  :......  .......:  :......
       :                 ::                 :
       v                 vv                 v
 --------------    --------------     --------------
 :  :      :  ----->:  :      :  ---->:  :      :  :
 :-1:A,B,C :  :     :  :D,E,F :  :    :  :  G,H :-1:
 :  :      :  :<-----  :      :  :<----  :      :  :
 --------------     --------------    --------------
        :                  :               :
        :..................:...............:
                           :
                   Вершины-листья

     На приведенном выше рисунке в качестве значений ключей
используются буквы. Обычно каждый ключ имеет четырехбайтовый
шестнадцатиричный номер. Номера, соответствующие ключам в
листьях, - это подлинные номера базы данных, все ключи в
других вершинах - это внутрииндексные указатели, им
соответствующие.
     Байты 12-511 в записях индексных вершин могли бы
выглядеть следующим образом:

         Длина ключа (в байтах)     4 байта
                    :                  :
             .......:........ .........:.........
             :              : :                 :
                             .....................
              Значение ключа : шестнадцатиричный :
 Байт 12 --->:               :      номер        :
 записи      :...............:...................:
                             .....................
              Значение ключа : шестнадцатиричный :
             :               :      номер        :
             :...............:...................:
                             .....................
              Значение ключа : шестнадцатиричный :
             :               :      номер        :
             :...............:...................:
     Комбинация из значения ключа и шестнадцатиричного
номера будет заноситься в байты 12-511 n раз, где n - число
существующих ключей.

Структура компактного индексного файла (типа .IDX)

 ════════════════════════════════════════════════════════════
 ║      Запись заголовка компактного индексного файла       ║
 ║----------------------------------------------------------║
 ║ Байты  :                Описание                         ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-03  :Указатель на корневую вершину                    ║
 ║----------------------------------------------------------║
 ║ 04-07  :Указатель на свободную в списке вершину (-1,     ║
 ║        :если таковая отсутствует)                        ║
 ║----------------------------------------------------------║
 ║ 08-11  :Резервируются для внутреннего использования      ║
 ║----------------------------------------------------------║
 ║ 12-13  :Длина ключа                                      ║
 ║----------------------------------------------------------║
 ║ 14     :Особенности индекса (любое из нижеследующих      ║
 ║        :значений либо их сумма):                         ║
 ║        : а. 1 - уникальный индекс;                       ║
 ║        : б. 8 - индекс имеет дополнительный оператор     ║
 ║        :        FOR;                                     ║
 ║        : в. 32 - формат компактного индекса;             ║
 ║        : г. 64 - заголовок составного индекса.           ║
 ║----------------------------------------------------------║
 ║ 15     :Сигнатура индекса                                ║
 ║----------------------------------------------------------║
 ║ 16-19  :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║ 20-23  :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║ 24-27  :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║ 28-31  :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║ 32-35  :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║ 36-501 :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║502-503 :По возрастанию или убыванию:                     ║
 ║        : а. 0=возрастание;                               ║
 ║        : б. 1=убывание.                                  ║
 ║----------------------------------------------------------║
 ║504-505 :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║506-507 :Длина пула выражения FOR*                        ║
 ║----------------------------------------------------------║
 ║508-509 :Зарезервированы для внутреннего использования    ║
 ║----------------------------------------------------------║
 ║510-511 :Длина пула выражения FOR*                        ║
 ║----------------------------------------------------------║
 ║510-1023:Пул выражения ключа (не компилируется)           ║
 ════════════════════════════════════════════════════════════
     * В этой информации отслеживается область, используемая
в пуле выражения ключа.

 ════════════════════════════════════════════════════════════
 ║      Запись внутренней вершины для компактного индекса   ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-01 :Атрибуты вершины (любое из нижеследующих числовых ║
 ║       :значений либо их сумма):                          ║
 ║       : а. 0 - индексная вершина;                        ║
 ║       : б. 1 - корневая вершина;                         ║
 ║       : в. 2 - вершина-лист.                             ║
 ║----------------------------------------------------------║
 ║ 02-03 :Число существующих ключей (0, 1 или больше)       ║
 ║----------------------------------------------------------║
 ║ 04-07 :Указатель на вершину, расположенную               ║
 ║       :непосредственно слева от данной вершины (на том   ║
 ║       :же уровне; -1 - если отсутствует)                 ║
 ║----------------------------------------------------------║
 ║ 08-11 :Указатель на вершину, расположенную               ║
 ║       :непосредственно справа от данной вершины (на том  ║
 ║       :же уровне; -1 - если отсутствует)                 ║
 ║----------------------------------------------------------║
 ║ 12-511:До 500 символов, включающих в себя значение ключа ║
 ║       :для длины ключа с четырехбайтовым                 ║
 ║       :шестнадцатиричным числом (хранящемся в обычном    ║
 ║       :формате слева направо):                           ║
 ║       : Эта вершина всегда содержит ключ индекса, номер  ║
 ║       : записи и внутрииндексный указатель.**            ║
 ║       :Комбинация из значения ключа и четырехбайтового   ║
 ║       :шестнадцатиричного числа будет повторена столько  ║
 ║       :раз, количество которых задается в байтах 02-03.  ║
 ════════════════════════════════════════════════════════════
 ════════════════════════════════════════════════════════════
 ║       Запись внешней вершины для компактного индекса     ║
 ║----------------------------------------------------------║
 ║ Байты :                Описание                          ║
 ║══════════════════════════════════════════════════════════║
 ║ 00-01 :Атрибуты вершины (любое из нижеследующих числовых ║
 ║       :значений либо их сумма):                          ║
 ║       : а. 0 - индексная вершина;                        ║
 ║       : б. 1 - корневая вершина;                         ║
 ║       : в. 2 - вершина-лист.                             ║
 ║----------------------------------------------------------║
 ║ 02-03 :Число существующих ключей (0, 1 или больше)       ║
 ║----------------------------------------------------------║
 ║ 04-07 :Указатель на вершину, расположенную               ║
 ║       :непосредственно слева от данной вершины (на том   ║
 ║       :же уровне; -1 - если отсутствует)                 ║
 ║----------------------------------------------------------║
 ║ 08-11 :Указатель на вершину, расположенную               ║
 ║       :непосредственно справа от данной вершины (на том  ║
 ║       :же уровне; -1 - если отсутствует)                 ║
 ║----------------------------------------------------------║
 ║ 12-13 :Свободное для распределения пространство в        ║
 ║       :вершине                                           ║
 ║----------------------------------------------------------║
 ║ 14-17 :Маска номера записи                               ║
 ║----------------------------------------------------------║
 ║ 18    :Маска запасного байтового счетчика                ║
 ║----------------------------------------------------------║
 ║ 19    :Маска хвостового байтового счетчика               ║
 ║----------------------------------------------------------║
 ║ 20    :Количество битов, используемых для номера записи  ║
 ║----------------------------------------------------------║
 ║ 21    :Количество битов, используемых для запасного      ║
 ║       :счетчика                                          ║
 ║----------------------------------------------------------║
 ║ 22    :Количество битов, используемых для хвостового     ║
 ║       :счетчика                                          ║
 ║----------------------------------------------------------║
 ║ 23    :Количество байтов, содержащих номер записи,       ║
 ║       :запасной счетчик и хвостовой счетчик              ║
 ║----------------------------------------------------------║
 ║ 24-511:Ключи индексов и информация**                     ║
 ════════════════════════════════════════════════════════════
     ** Каждый элемент состоит из номера записи, запасного
байтового счетчика и хвостового байтового счетчика, все в
сжатом виде. Текст ключа помещается в логический конец
вершины, обрабатывается он в обратном направлении, что
позволяет находить элементы предшествующих ключей.

Структура составного индексного файла (типа .CDX)

     Все составные индексы являются компактными.
     Для того, чтобы отслеживать в файле типа .CDX все теги,
применяется единая файловая структура. Эта структура
идентична структуре компактного индексного файла за одним
исключением - вершины-листья на самом нижнем уровне данной
структуры ссылаются на один из тегов в составном индексе.
     Все теги в индексе имеют свою собственную завершенную
структуру, которая тождественна структуре компактного
индекса для файла .IDX.


Системные возможности

 ════════════════════════════════════════════════════════════
 ║                  Системные возможности                   ║
 ║══════════════════════════════════════════════════════════║
 ║                                     : FoxPro  : Усоверш. ║
 ║                                     :         :  FoxPo   ║
 ║══════════════════════════════════════════════════════════║
 ║                  Файлы индексные и баз данных            ║
 ║══════════════════════════════════════════════════════════║
 ║Максимальное число записей в файле  :          :          ║
 ║базы данных                         :1миллиард*: 1миллирд*║
 ║Максимальное число символов в записи:      4000:      4000║
 ║Максимальное число полей в записи   :       255:       255║
 ║Максимальное число одновременно     :          :          ║
 ║открытых баз данных                 :        25:        25║
 ║Максимальное число символов в       :          :          ║
 ║поле базы данных                    :       254:       254║
 ║Максимальное число символов в       :          :          ║
 ║индексном ключе (.IDX)              :       100:       100║
 ║Максимальное число символов в       :          :          ║
 ║индексном ключе (.CDX)              :       254:       254║
 ║Максимальное число открытых         :без огра- :без огра- ║
 ║индексных файлов в базе данных      :ничения** :ничения** ║
 ║Максимальное число открытых         :без огра- :без огра- ║
 ║индексов во всех рабочих областях   :ничения** :ничения** ║
 ║══════════════════════════════════════════════════════════║
 ║                    Характеристики полей                  ║
 ║══════════════════════════════════════════════════════════║
 ║Максимальный размер символьных полей:       254:       254║
 ║Максимальный размер числовых (и с   :          :          ║
 ║плавающей точкой) полей             :        20:        20║
 ║Максимальное число символов в       :          :          ║
 ║названиях полей                     :        10:        10║
 ║Точность цифр при числовых          :          :          ║
 ║вычислениях                         :        16:        16║
 ║══════════════════════════════════════════════════════════║{
{ If this code is used commercially, please send a few bucks to      }
{ Bill Himmelstoss, PO BOX 23246, Jacksonville, FL  32241-3246,      }
{ Otherwise, it's freely distributable.                              }

unit DBF;

interface

uses
  Objects,
  OString;

type
  TYMDDate = record
    Year,
    Month,
    Day: Byte;
  end;

  PDatabase = ^TDatabase;
  TDatabase = object(TObject)
    DatabaseType: Byte;
    LastUpdate: TYMDDate;
    NumRecords: Longint;
    FirstRecordPos: Word;
    RecordLength: Word;

    S: TDosStream;
    Pathname: TOString;
    Modified: Boolean;
    Fields: TCollection;

    constructor Init(APathname: TOString);
    constructor InitCreate(APathname: TOString; AFields: PCollection);
    destructor Done; virtual;
    procedure RefreshHeader;
    procedure UpdateHeader;
    function GetRecord(RecordNum: Longint): Pointer;
    procedure PutRecord(RecordNum: Longint; Rec: Pointer);
    procedure Append(Rec: Pointer);
    procedure Zap;
    procedure RefreshFields;
  end;

  PFieldDef = ^TFieldDef;
  TFieldDef = object(TObject)
    Name: TOString;
    DataType: Char;
    Displacement: Longint;
    Length: Byte;
    Decimal: Byte;

    constructor Init(
      AName: String;
      ADataType: Char;
      ALength,
      ADecimal: Byte);
    destructor Done; virtual;
    constructor Load(var S: TStream);
    procedure Store(var S: TStream);
  end;

implementation

uses
  WinDos;

constructor TDatabase.Init(APathname: TOString); begin
  inherited Init;
  Pathname.InitText(APathname);
  S.Init(Pathname.CString, stOpen);
  if S.Status <> stOk then Fail;
  Fields.Init(5, 5);
  RefreshHeader;
end;

constructor TDatabase.InitCreate(APathname: TOString; AFields: PCollection);
const
  Terminator: Byte = $0D;
var
  Year, Month, Day, Dummy: Word;

  procedure CopyField(Item: PFieldDef); far;
  begin
    Fields.Insert(Item);
  end;

  procedure WriteFieldSubrecord(Item: PFieldDef); far;
  begin
    Item^.Store(S);
    Inc(RecordLength, Item^.Length);
  end;

begin
  inherited Init;

  DatabaseType := $03;
  GetDate(Year, Month, Day, Dummy);
  LastUpdate.Year := Year - 1900;
  LastUpdate.Month := Month;
  LastUpdate.Day := Day;
  NumRecords := 0;
  RecordLength := 0;

  Pathname.InitText(APathname);
  S.Init(Pathname.CString, stCreate);
  if S.Status <> stOk then Fail;
  UpdateHeader;

  S.Seek(32); { beginning of field subrecords }
  Fields.Init(AFields^.Count, 5);
  AFields^.ForEach(@CopyField);
  Fields.ForEach(@WriteFieldSubrecord);

  S.Write(Terminator, SizeOf(Terminator));
  Modified := true;
  FirstRecordPos := S.GetPos;
  UpdateHeader;
end;

destructor TDatabase.Done;
begin
  if Modified then UpdateHeader;
  Pathname.Done;
  S.Done;
  Fields.Done;
  inherited Done;
end;

procedure TDatabase.RefreshHeader;
var
  OldPos: Longint;
begin
  OldPos := S.GetPos;
  S.Seek(0);
  S.Read(DatabaseType, SizeOf(DatabaseType));
  S.Read(LastUpdate, SizeOf(LastUpdate));
  S.Read(NumRecords, SizeOf(NumRecords));
  S.Read(FirstRecordPos, SizeOf(FirstRecordPos));
  S.Read(RecordLength, SizeOf(RecordLength));
  S.Seek(OldPos);
  RefreshFields;
end;

procedure TDatabase.UpdateHeader;
var
  OldPos: Longint;
  Reserved: array[12..31] of Char;
begin
  OldPos := S.GetPos;
  S.Seek(0);
  S.Write(DatabaseType, SizeOf(DatabaseType));
  S.Write(LastUpdate, SizeOf(LastUpdate));
  S.Write(NumRecords, SizeOf(NumRecords));
  S.Write(FirstRecordPos, SizeOf(FirstRecordPos));
  S.Write(RecordLength, SizeOf(RecordLength));
  FillChar(Reserved, SizeOf(Reserved), #0);
  S.Write(Reserved, SizeOf(Reserved));
  S.Seek(OldPos);
end;

function TDatabase.GetRecord(RecordNum: Longint): Pointer; var
  Temp: Pointer;
  Pos: Longint;
begin
  Temp := NIL;
  GetMem(Temp, RecordLength);
  if Temp <> NIL then
  begin
    Pos := FirstRecordPos + ((RecordNum - 1) * RecordLength);
    if S.GetPos <> Pos then
      S.Seek(Pos);
    S.Read(Temp^, RecordLength);
  end;
  GetRecord := Temp;
end;

procedure TDatabase.Append(Rec: Pointer); begin
  if Assigned(Rec) then
  begin
    Modified := true;
    Inc(NumRecords);
    PutRecord(NumRecords, Rec);
  end;
end;

procedure TDatabase.PutRecord(RecordNum: Longint; Rec: Pointer); var
  Pos: Longint;
begin
  if Assigned(Rec) and (RecordNum <= NumRecords) then
  begin
    Pos := FirstRecordPos + ((RecordNum - 1) * RecordLength);
    if S.GetPos <> Pos then
      S.Seek(Pos);
    S.Write(Rec^, RecordLength);
  end;
end;

procedure TDatabase.Zap;
var
  T: TDosStream;
  Temp, D, N, E: TOString;
  F: File;
begin
  D.Init(fsDirectory);
  N.Init(fsFilename);
  E.Init(fsExtension);
  FileSplit(Pathname.CString, D.CString, N.CString, E.CString);
  D.RecalcLength;
  N.RecalcLength;
  E.RecalcLength;
  Temp.InitText(D);
  Temp.Append(N);
  Temp.AppendP('.TMP');
  D.Done;
  N.Done;
  E.Done;

  T.Init(Temp.CString, stCreate);
  S.Seek(0);
  T.CopyFrom(S, FirstRecordPos - 1);
  T.Done;
  S.Done;
  Assign(F, Pathname.CString);
  Erase(F);
  Assign(F, Temp.CString);
  Rename(F, Pathname.CString);
  S.Init(Pathname.CString, stOpen);
  NumRecords := 0;
  Modified := false;
  UpdateHeader;
end;

procedure TDatabase.RefreshFields;
var
  Terminator: Byte;
  HoldPos: Longint;
  FieldDef: PFieldDef;
begin
  S.Seek(32); { beginning of Field subrecords }

  repeat
    HoldPos := S.GetPos;
    S.Read(Terminator, SizeOf(Terminator));
    if Terminator <> $0D then
    begin
      S.Seek(HoldPos);
      FieldDef := New(PFieldDef, Load(S));
      Fields.Insert(FieldDef);
    end;
  until Terminator = $0D;
end;

constructor TFieldDef.Init(
  AName: String;
  ADataType: Char;
  ALength,
  ADecimal: Byte);
begin
  inherited Init;
  Name.InitTextP(AName);
  DataType := ADataType;
  Length := ALength;
  Decimal := ADecimal;
  Displacement := 0;
end;

destructor TFieldDef.Done;
begin
  Name.Done;
  inherited Done;
end;

constructor TFieldDef.Load(var S: TStream); var
  AName: array[1..11] of Char;
  Reserved: array[18..31] of Char;
begin
  S.Read(AName, SizeOf(AName));
  Name.Init(SizeOf(AName));
  Name.SetText_(@AName[1], 11);
  S.Read(DataType, SizeOf(DataType));
  S.Read(Displacement, Sizeof(Displacement));
  S.Read(Length, SizeOf(Length));
  S.Read(Decimal, SizeOf(Decimal));
  S.Read(Reserved, SizeOf(Reserved));
end;

procedure TFieldDef.Store(var S: TStream); var
  Reserved: array[18..31] of Char;
begin
  S.Write(Name.CString^, 11);
  S.Write(DataType, SizeOf(DataType));
  S.Write(Displacement, Sizeof(Displacement));
  S.Write(Length, SizeOf(Length));
  S.Write(Decimal, SizeOf(Decimal));
  FillChar(Reserved, SizeOf(Reserved), #0);
  S.Write(Reserved, SizeOf(Reserved));
end;

end.





program DbfTest;

uses
  dbf, wincrt, ostring, objects, strings;

type
  PDbfTest = ^TDbfTest;
  TDbfTest = record
    Deleted: Char; { ' '=no, '*'=yes }
    AcctNo: array[1..16] of Char;
    Chunk: array[1..8] of Char;
    Baskard: array[1..5] of Char;
    Extra: array[1..8] of Char;
    Sandwich: array[1..25] of Char;
  end;

var
  rec: PDbfTest;
  database: tdatabase;
  pathname: tostring;
  temp: string;
  fields: tcollection;

  procedure DoShow;

    procedure show(item: pfielddef); far;
    begin
      writeln(
        item^.name.cstring:15, ' ',
        item^.datatype, ' ',
        item^.length:10, ' ',
        item^.decimal:10, ' ');
    end;

  begin
    database.fields.foreach(@show);
  end;


begin
  InitWinCrt;

  fields.init(5, 0);
  fields.insert(new(pfielddef, init('ACCTNO',   'C', 16, 0)));
  fields.insert(new(pfielddef, init('CHUNK',    'N',  8, 2)));
  fields.insert(new(pfielddef, init('BASKARD',  'C',  5, 0)));
  fields.insert(new(pfielddef, init('EXTRA',    'D',  8, 0)));
  fields.insert(new(pfielddef, init('SANDWICH', 'C', 25, 0)));
  pathname.inittextp('c:\dbftest.dbf');
  database.initcreate(pathname, @fields);
  pathname.done;
  DoShow;

  New(Rec);
  with Rec^ do
  begin
    Acctno   := '1313558000001005'; { <-will self-check, but not valid }
    Chunk    := '   10.00';
    Baskard  := 'ABCDE';
    Extra    := '19931125';
    Sandwich := 'Turkey Leftovers         ';
  end;
  database.append(rec);
  dispose(rec);

  rec := database.getrecord(1);
  writeln(rec^.acctno, ' ', rec^.Sandwich);
  dispose(rec);

  database.done;
end.
