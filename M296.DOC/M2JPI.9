
         ReadFirstEntry("a:*.mod",FileAttr{},e)

         Данный вызов будет искать все файлы с расширением "mod" в корневом каталоге устройства
    a:, а в переменной "e" будет возвращено первое имя файла (если функция завершится успешно).

                           ReadNextEntry
                           -------------

         PROCEDURE ReadNextEntry(VAR D: DirEntry) : BOOLEAN;

         Данная процедура  работает совместно с ReadFirstEntry.  Она принимает на входе в пере-
    менной  D  элемент  каталога,  который  был   возвращен   предыдущими   вызовами   процедур
    ReadFirstEntry или ReadNextEntry, ищет следующий элемент, соответствующий заданной специфи-
    кации (DirName).


                             МОДУЛЬ IO
                             =========

         В настоящем разделе описывается библиотека экранного ввода/вывода. Процедуры ввода/вы-
    вода,  содержащиеся  в ней,  отличаются от процедур из модуля FIO тем,  что они работают со
    стандартными устройствами ввода/вывода (клавиатурой и экраном).  Экранный ввод/вывод  может
    быть  осуществлен  и процедурами модуля FIO,  если в них использовать стандартные указатели
    файлов (file handles) (см. МОДУЛЬ FIO).


                    ГЛОБАЛЬНЫЕ ПЕРЕМЕННЫЕ В IO
                    ==========================

         Приведенные ниже переменные управляют работой процедур ввода/вывода.  Назначение пере-
    менных OK, Eng, Separators, ChopOff совпадает с назначением аналогичных переменных из моду-
    ля FIO.

         CONST
           MaxRdLength = 256;
         TYPE
           WrStrType = PROCEDURE (ARRAY OF CHAR);
           RdStrType = PROCEDURE (VAR ARRAY OF CHAR);
           CHARSET   = SET OF CHAR;
         VAR
           RdLnOnWr :  BOOLEAN;  (* Очистка буферированного ввода
                                  после записи *)
           Prompt   :  BOOLEAN;  (* Выдача подсказки '?' при чте-
                                  нии из пустой строки *)
           WrStrRedirect  :  WrStrType;
           RdStrRedirect  :  RdStrType;
           Separators  :  CHARSET;
           OK          :  BOOLEAN;
           ChopOff     :  BOOLEAN;
           Eng         :  BOOLEAN;  (* Нотация проектирования *)

         Все форматированные процедуры ввода/вывода используют для выполнения своих функций од-
    ну из процедурных переменных:  WrStrRedirect или RdStrRedirect. Переназначение ввода/вывода
    может быть выполнено  заменой  WrStrRedirect  и  RdStrRedirect  вашими  процедурами  "write
    string" (писать строку) и "read string" (читать строку).

                       ФОРМАТИРОВАННЫЙ ВЫВОД
                       =====================

         Процедура вывода определена для всех простых типов в JPI Modula-2.

                          Wr'простой-тип'
                          --------------

                  Процедуры вывода простых типов.

         PROCEDURE WrChar   (V : CHAR);
         PROCEDURE WrBool   (V : BOOLEAN;   Length : INTEGER);
         PROCEDURE WrShtInt (V : SHORTINT;  Length : INTEGER);
         PROCEDURE WrInt    (V : INTEGER;   Length : INTEGER);
         PROCEDURE WrLngInt (V : LONGINT;   Length : INTEGER);
         PROCEDURE WrShtCard(V : SHORTCARD; Length : INTEGER);
         PROCEDURE WrCard   (V : CARDINAL;  Length : INTEGER);
         PROCEDURE WrLngCard(V : LONGCARD;  Length : INTEGER);
         PROCEDURE WrShtHex (V : SHORTCARD; Length : INTEGER);
         PROCEDURE WrHex    (V : CARDINAL;  Length : INTEGER);
         PROCEDURE WrLngHex (V : LONGCARD;  Length : INTEGER);
         PROCEDURE WrReal   (V : REAL;      Precision : CARDINAL;
                                            Length : INTEGER);
         PROCEDURE WrLngReal(V : LONGREAL;  Precision : CARDINAL;
                                            Length : INTEGER);

         Эти процедуры  выдают  значение  переменной V (данного типа) на стандартное устройство
    вывода.  Все процедуры (кроме WrChar) имеют также параметр Length,  являющийся шириной поля
    форматированных данных. Если Length имеет отрицательное значение, то форматированное данное
    выравнивается на левую границу, в противном случае - на правую.
         Все процедуры  (кроме WrChar и WrBool) вызывают подходящую процедуру преобразования из
    модуля Str,  осуществляющую перевод в строковое представление значения V; полученная строка
    затем выводится при помощи WrStrAdj.
         Процедуры WrReal и WrLngReal содержат параметр  Precision,  используемый  в  процедуре
    RealToStr. Глобальная переменная Eng определяет форму вывода значения действительных чисел.
         Значения типа CARDINAL могут быть выведены  в  шестнадцатеричном  формате  процедурами
    WrShtHex, WrHex, WrLngHex.

                               WrStr
                               -----

         PROCERURE WrStr(S: ARRAY OF CHAR);

         Выводит строку  S  на экран.

                              WrStrAdj
                              --------

         PROCEDURE WrStrAdj(S: ARRAY OF CHAR; Length: INTEGER);

         Выводит строку  S  на экран,  используя функцию ABS(Length) для получения ширины поля.
    Если ABS(Length) меньше Str.Length(s) и глобальная переменная ChopOff=TRUE, то вместо S вы-
    дается  последовательность из '?'.  Знак Length определяет,  будет ли S выровнено влево (-)
    или вправо (+).

                             WrCharRep
                             ---------

         PROCEDURE WrCharRep(V: CHAR; Count: CARDINAL);

         Выдает символ V на экран Count раз.

                                WrLn
                                ----

         PROCEDURE WrLn;

         Выдает новую строку (CHR(13), CHR(10)) на экран.


                       ФОРМАТИРОВАННЫЙ ВВОД
                       ====================

         Процедура чтения определена для всех простых типов в JPI Modula-2.

                          Rd'простой тип'
                          ---------------

         PROCEDURE RdChar()    : CHAR;
         PROCEDURE RdBool()    : BOOLEAN;
         PROCEDURE RdShtInt()  : SHORTINT;
         PROCEDURE RdInt()     : INTEGER;
         PROCEDURE RdLngInt()  : LONGINT;
         PROCEDURE RdShtCard() : SHORTCARD;
         PROCEDURE RdCard()    : CARDINAL;
         PROCEDURE RdLngCard() : LONGCARD;
         PROCEDURE RdShtHex()  : SHORTCARD;
         PROCEDURE RdHex()     : CARDINAL;
         PROCEDURE RdLngHex()  : LONGCARD;
         PROCEDURE RdReal()    : REAL;
         PROCEDURE RdLngReal() : LONGREAL;


         Процедуры чтения простых типов читают со  стандартного  ввода  и  возвращают  значение
    "простого-типа", как указано в определениях выше.
         Все процедуры (кроме RdChar) вызывают RdItem, чтобы получить последовательность симво-
    лов,  ограниченных  символами,  определенными  в  глобальной  переменной типа "множество" -
    Separators.  Полученная строка затем преобразуется в значение при помощи одной из  процедур
    преобразования из модуля Str.
         Процедуры RdShtHex, RdHex и RdLngHex читают числа типа CARDINAL в 16-ричном формате.
         Процедура RdBool  возвращает  TRUE,  если  читается строка 'TRUE';  в противном случае
    возвращается 'FALSE'.
         Синтаксис для допустимых значений типа REAL приведен в ГЛАВЕ 6.
         Глобальная переменная ОК устанавливается в 'FALSE',  если значение требуемого типа  не
    может быть считано.

                               RdItem
                               ------

         PROCEDURE RdItem(VAR V : ARRAY OF CHAR);

         RdItem читает строку со стандартного ввода;  строка ограничивается символами, содержа-
    щимися в глобальной переменной-множестве Separators. Строка возвращается в переменной V.

                                RdLn
                                ----

         PROCEDURE RdLn;

         Сбрасывает остаток ввода в текущей входной строке.

                              EndOfRd
                              -------

         PROCEDURE EndOfRd(Skip : BOOLEAN) : BOOLEAN;

         Если Skip=TRUE,  то последовательность символов,  где каждый символ принадлежит к мно-
    жеству Separators, опускается из входной строки. EndOfRd затем возвращает TRUE, если счита-
    ны все символы в текущей входной строке.


                      БАЗОВЫЕ ПРОЦЕДУРЫ ВВОДА
                      =======================

                             KeyPressed
                             ----------

         PROCEDURE KeyPressed() : BOOLEAN;

         Возвращает TRUE,  если со стандартного ввода получен символ. Процедура недействительна
    для буферированного ввода.




                            RdCharDirect
                            ------------
         PROCEDURE RdCharDirect() : CHAR;

         Возвращает символ со стандартного ввода. Если нет доступных символов, то ожидает любо-
    го. Буферизация не производится, и на экран не выдается эхо символов.


                           ПЕРЕНАЗНАЧЕНИЕ
                           ==============

                           RedirectInput
                           -------------

         PROCEDURE RedirectInput(FileName : ARRAY OF CHAR);

         Закрывает текущий входной поток и открывает новый входной поток,  специфицированный  в
    FileName.  Если  этот поток позднее закрывается,  то ввод будет восстановлен на стандартный
    ввод (даже если входной поток был переназначен на файл в командной строке).

                           RedirectOutput
                           --------------

         PROCEDURE RedirectOutput(FileName : ARRAY OF CHAR);

         Закрывает текущий  открытый  поток  и  открывает  новый  выходной  поток,  заданный  в
    FileName.  Если этот поток затем будет закрыт,  то вывод будет восстановлен на  стандартный
    вывод (даже если поток вывода был переназначен на файл в командной строке).


                            МОДУЛЬ Graph
                            ============

         Модуль Graph  реализует  базовую графику (функционирует только на IBM PC и совместимых
    компьютерах).  В графическом режиме экран представляется 320x200 точками, где верхний левый
    угол имеет координаты 0,0. Координаты X идут вправо от 0 до 319, а Y координаты - вниз от 0
    до 199. Любая попытка осуществить вывод за пределы этих координат игнорируется.


                             Константы
                             ---------

         CONST
           Width = 320;   (* Значения X:  0..Width-1 *)
           Depth = 200;   (* Значения Y:  0..Depth-1 *)
           NumColor = 4;  (* Цвета:  0..NumColor-1 *)

         Цвета обозначаются  следующим  образом:  черный (black)=0;  голубой (blue)=1;  красный
    (red)=2 и белый (white)=4. Функции заполнения заполняют область точками двух альтернативных
    цветов, которые кодируются как
                     Цвет1+NumColor*Цвет2,
    т.е., если вы хотите заполнить область голубым цветом, то цвет заполнения будет:
                     1+NumColor*1=5.


                       ГРАФИЧЕСКИЕ ПРОЦЕДУРЫ
                       =====================

                             GraphMode
                             ---------

         PROCEDURE GraphMode;

         Устанавливает графический режим 320x200 точек.

                              TextMode
                              --------

         PROCEDURE TextMode;

         Возврат в текстовый режим.

                                Plot
                                ----

         PROCEDURE Plot(x,y: CARDINAL; Color: CARDINAL);

         Устанавливает точку в координатах X,Y в цвет, заданный Color.

                               Point
                               -----

         PROCEDURE Point(x,y: CARDINAL) : CARDINAL;

         Возвращает цвет точки с координатами x,y.

                                Line
                                ----

         PROCEDURE Line(x1,y1,x2,y2: CARDINAL; Color: CARDINAL);

         Рисует линию  между  координатами x1,y1 и x2,y2 цветом,
    заданным в Color.

                               Circle
                               ------

         PROCEDURE Circle(x0,y0,r: CARDINAL; c: CARDINAL);

         Рисует окружность с центром в х0,y0 и радиусом r с цветом с.

                                Disc
                                ----

         PROCEDURE Disc(x0,y0,r: CARDINAL; FillColor: CARDINAL);

         Изображает заполненную окружность с центром в x0,y0 и радиусом r.  Цвет круга задается
    в FillColor.  Следует отметить, что цвет заполнения - это комбинация из двух цветов, вычис-
    ляемая как Цвет1+NumColor*Цвет2.

                              Polygon
                              -------

         PROCEDURE Polygon(n         : CARDINAL;
                           px,py     : CARDINAL;
                           FillCo;or : CARDINAL);

         Рисует заполненный многоугольник с n узлами. Массивы px и py задают углы многоугольни-
    ка (px[0],py[0] - первый угол, px[1],py[1] - второй угол и т.д.). FillColor - это цвет мно-
    гоугольника.
         Пример:
         TYPE Coordinate = ARRAY [0..2] OF CARDINAL;
         VAR Xs,Ys : Coordinate;
         Xs := Coordinate(160,80,240);
         Ys := Coordinate(25,175,175);
         Polygon(3,Xs,Ys,5);

         Такой вызов рисует голубой треугольник.

                               HLine
                               -----

         PROCEDURE HLine(x,y,x2: CARDINAL; FillColor: CARDINAL);

         Рисует горизонтальную линию в вертикальной координате, заданной параметром y. Парамет-
    ры x и x2 соответственно задают позиции начала и конца линии.  Цвет линии задается парамет-
    ром FillColor.


                           МОДУЛЬ Window
                           =============

         Данный раздел описывает мощный модуль управления окнами,  поставляемый с JPI Modula-2.
    Модуль  Window позволяет вам отображать различные виртуальные экраны-окна на физическом эк-
    ране.  Созданное множество окон обрабатывается подобно стеку.  В модуле поддерживается  два
    вида окон - "нормальные" и "многоцветные".
         Пример программирования окон (windemo.mod) находится на дискетах,  поставляемых вместе
    с вашим компилятором. Желательно, чтобы вы просмотрели текст перед запуском программы. Сре-
    да разработки,  поставляемая с JPI Modula-2,  -  это  другой  пример  использования  модуля
    Window.


                       КОНСТАНТЫ И ТИПЫ ОКОН
                       =====================

         CONST
           ScreenWidth = 80;
           ScreenDepth = 25;
         TYPE
           WinType = POINTER TO WinDescriptor; (* внутренний *)

           RelCoord = CARDINAL;
           AbsCoord = CARDINAL;
           Color = (Black,    Blue,        Green,      Cyan,
                    Red,      Magenta,     Brown,      LightGray,
                    DarkGray, LightBlue,   LightGreen, LightCyan,
                    LightRed, LightMagenta,Yellow,     White   );
           FrameStr = ARRAY[0..8] OF CHAR;   (* Символы рамки *)
                                             (*  0   1    2   *)
                                             (*  3        4   *)
                                             (*  5   6    7   *)
           TitleStr = ARRAY[0..ScreenWidth-1] OF CHAR;
           WinDef   = RECORD
                        X1,Y1,
                        X2,Y2       : AbsCoord;
                     (* Внешние (абсолютные) координаты
                        противоположных углов. *)

                        Foreground,
                        Background  : Color;
                    (* Не используется, если окно типа
                       "многоцветное" (Palette). *)

                        CursorOn  : BOOLEAN;
                    (* Если курсор - активный, то TRUE. *)

                        WrapOn  : BOOLEAN;
                    (* Если TRUE,  то разрешен циклический
                       переход при достижении конца строки
                       (граница окна). *)

                        Hidden  : BOOLEAN;
                     (* Если TRUE, то окно невидимо. *)

                        FrameOn  : BOOLEAN;
                     (* Если TRUE, то окно с рамкой. *)

                        FrameDef  : FrameStr;
                     (* Используется только для окна с рамкой. *)

                        FrameFore,
                        FrameBack  : Color;
                     (* Используется только, если окно с рамкой
                        и окно не многоцветное. *)

                      END;
           TitleMode = (NoTitle,
                        LeftUpperTitle,CenterUpperTitle,
                        RightUpperTitle,
                        LeftLowerTitle,CenterLowerTitle,
                        RightLowerTitle);
         CONST
           SingleFrame   = FrameStr('┌─┐││└─┘') ;
           DoubleFrame   = FrameStr('╔═╗║║╚═╝') ;
           FullScreenDef= WinDef(0,0,ScreenWidth-1,ScreenDepth-1,
                               White,Black,TRUE,TRUE,FALSE,FALSE,
                               '      ',Black,Black );

         VAR
           FullScreen  : WinType;

         Окно определяется типом WinDef,  и переменная этого типа используется для создания ок-
    на.  Параметры X1,  Y1 в WinDef - это координаты верхнего левого угла,  а X2,  Y2 - нижнего
    правого  угла окна.  Если параметр Hidden (скрытый) - TRUE,  то окно не будет отображаться,
    пока не будет вызвана процедура PutOnTop.  Параметр FrameOn специфицируется (устанавливает-
    ся) в TRUE, если окно имеет рамку.
         Рамка описывается типом FrameStr - массивом из 9 символов,  в котором элемент 0 задает
    символ левого верхнего угла,  элемент 1 - символ верхней линии и т.д., как указано в приве-
    денном  выше  описании.  Две  определенные  стандартные   рамки   объявляются   константами
    SingleFrame и DoubleFrame.
         Окно создается процедурой Open,  которая возвращает значение обработчика типа WinType.
    Все  последующие обращения к этому окну производятся посредством этого обработчика. WinType
    - это указатель на внутренний описатель окна, который считается локальным для модуля Window
    (его описание может быть найдено в файле window.def).
         Система управления окнами манипулирует с двумя различными видами координат - координа-
    тами относительно окна (RelCoord) и координатами относительно экрана (AbsCoord). Координаты
    (0,0) - это координаты верхнего левого угла окна,  если используются  AbsCoord;  координаты
    (1,1) - это координаты верхнего левого угла окна, если используются RelCoord.
         Вывод в окна осуществляется при помощи процедур вывода из модуля IO (Модуль Window пе-
    реназначает WrStrRedirect, см. MODULE IO).


                         УПРАВЛЕНИЕ ОКНАМИ
                         =================

                                Open
                                ----

         PROCEDURE Open(WD: WinDef) : WinType;

         Получив описатель окна WD,  Open создает новое окно, очищает его и помещает его поверх
    всех существующих окон.  Любой последующий вывод затем будет производиться в это окно. Open
    возвращает обработчик, который будет использоваться в дальнейших операциях с окнами.

                              SetTitle
                              --------

         PROCEDURE SetTitle( W     : WinType;
                             Title : ARRAY OF CHAR;
                             Mode  : TitleMode);

         Изменяет заголовок окна в рамке в окне W. Mode задает позицию заголовка.

                              SetFrame
                              --------

         PROCEDURE SetFrame( W     : WinType;
                             Frame : FrameStr;
                             Fore, Back: Color);

         Изменяет окружающую окно W рамку,  отображая вновь все заголовки, если они существуют.
    Параметр Frame описывает новую рамку, Fore и Back задают цвета рамки.

                                Use
                                ---

         PROCEDURE Use(W : WinType);

         Переключает весь последовательный вывод (текущего процесса) на окно W. W не обязатель-
    но должно находиться на экране.

                              PutOnTop
                              --------

         PROCEDURE PutOnTop(W: WinType);

         Помещает окно W в вершину стека окон,  делая его полностью видимым.  Весь вывод  будет
    производиться в это окно (за исключением вывода, переназначенного посредством Use).

                             PutBeneath
                             ----------

         PROCEDURE PutBeneath(W : WinType; WA : WinType);

         Помещает окно W под окно WA в стеке окон.

                                Hide
                                ----

         PROCEDURE Hide(W : WinType);

         Удаляет окно  W  с экрана и из стека окон.  При этом содержимое окна сохраняется и оно
    может быть перевыведено позже,  если это потребуется. Все окна, покрытые W, станут открыты-
    ми.

                               Change
                               ------

         PROCEDURE Change(W : WinType; X1,Y1,X2,Y2: AbsCoord);

         Изменяет размер и/или позицию окна W в соответствии с новыми  координатами. Содержимое
    окна будет перемещено вместе с ним.  Если окно расширяется, то текст дополняется пробелами;
    если сужается, то текст усекается.

                               Close
                               -----

         PROCEDURE Close(VAR W : WinType);

         Удаляет окно W с экрана, стирает описатель окна и возвращает все буферы, предваритель-
    но назначенные для W.  В завершение W устанавливается в NIL, чтобы предотвратить дальнейшее
    использование.

                                Used
                                ----

         PROCEDURE Used() : WinType;

         Возвращает текущее окно вывода, используемое текущим процессом. Если ни одного окна не
    назначено процедурой Use, то возвращается верхнее окно.

                                Top
                                ---

         PROCEDURE Top() : WinType;

         Возвращает текущее верхнее окно.

                                Info
                                ----

         PROCEDURE Info(W : WinType; VAR WD : WinDef);

         Получая обработчик W, процедура Info возвращает описатель окна в WD.


                        ОБРАБОТКА КООРДИНАТ
                        ===================

                             ObscuredAt
                             ----------
         PROCEDURE ObscuredAt(W  :  WinType;  X,Y :  RelCoord) :
                                                       BOOLEAN);

         Возвращает TRUE, если окно W скрыто в позиции, заданной в X и Y.

                                 At
                                 --

         PROCEDURE At(X,Y : AbsCoord) : WinType;

         Возвращает указатель (обработчик) окна,  выданного в абсолютной позиции X и Y.  Если в
    данной позиции нет видимых окон, то возвращается NIL.

                               GotoXY
                               ------

         PROCEDURE GotoXY(X,Y : RelCoord);

         Устанавливает текущей позицию X,Y в текущем используемом окне. Если X или Y выходят за
    границы рамки окна, то они обрезаются.

                               WhereX
                               ------

         PROCEDURE WhereX() : RelCoord;

         Возвращает X координату курсора в текущем используемом окне.

                               WhereY
                               ------

         PROCEDURE WhereY() : RelCoord;

         Возвращает Y координату курсора в текущем используемом окне.

                           ConvertCoords
                           -------------

         PROCEDURE ConvertCoords( W         : WinType;
                                  X,Y       : RelCoord;
                                  VAR X0,Y0 : AbsCoord);

         Преобразует относительные  координаты  X,Y  в окне W в абсолютные экранные координаты.
    Результат возвращается в X0,Y0.


                      ПРОЦЕДУРЫ ВЫВОДА В ОКНА
                      =======================

         Вывод в окна производится посредством процедур вывода из модуля IO.  Приведенные  ниже
    процедуры расширяют возможности вывода в окна.




                              InsLine
                              -------

         PROCEDURE InsLine;

         Вставляет пустую строку в текущей позиции курсора; лежащая ниже часть экрана сдвигает-
    ся вниз.

                              DelLine
                              -------

         PROCEDURE DelLine;

         Удаляет строку в текущей позиции курсора, прокручивая лежащую ниже часть экрана вверх.

                               ClrEol
                               ------

         PROCEDURE ClrEol;

         Очистка от текущей позиции курсора до конца строки.

                             TextColor
                             ---------

         PROCEDURE TextColor(c: Color);

         Устанавливает цвет текста в текущем окне в значение, заданное c.

                           TextBackground
                           --------------

         PROCEDURE TextBackground(c: Color);

         Устанавливает цвет фона текста в текущем окне в значение, заданное c.

                            DirectWrite
                            -----------

         PROCEDURE DirectWrite(X,Y : RelCoord; (* Координаты на-
                                                  чала *)
                               A   : ADDRESS;  (* Адрес массива
                                                  символов *)
                               Len : CARDINAL; (* Длина выводи-
                                               мого сообщения *)

         Выводит строку A прямо в текущее окно в позицию, заданную X и Y. Len - это длина выво-
    димого сообщения. Специальные символы (управляющие) или циклический переход по концу строки
    не контролируются.



                              SetWrap
                              -------

         PROCEDURE SetWrap(on: BOOLEAN);

         Разрешает/запрещает автоматический циклический переход (в соответствии с on) при выхо-
    де выводом за правую границу текущего окна.

                               Clear
                               -----

         PROCEDURE Clear;

         Очищает текущее окно.

                              CursorOn
                              --------

         PROCEDURE CursorOn;

         Включает курсор в текущем окне. Следует иметь в виду, что курсор видим только, если он
    включен, и окно находится на вершине стека.

                             CursorOff
                             ---------

         PROCEDURE CursorOff;

         Делает курсор невидимым в текущем окне.


                 ПОДДЕРЖКА МУЛЬТИПРОЦЕССНОГО РЕЖИМА
                 ==================================

         По умолчанию считается,  что модуль Window вызывается только одним процессом.  Если же
    этот  модуль  используется  более,  чем  одним  процессом,  то  следует  вызвать  процедуру
    SetProcessLocks, что гарантирует корректное выполнение операций с окнами.

                           SetProcessLocks
                           ---------------

         PROCEDURE SetProcessLocks(LockProc, UnlockProc : PROC);

         Включает запирание  процессов  в оконной системе.  LockProc и UnlockProc специфицируют
    процедуры запирания и отпирания.  Процедура также сообщает модулю работы с окнами,  что ис-
    пользуются параллельные процессы.  Если используется модуль PROCESS, то в качестве LockProc
    и UnlockProc могут быть использованы процедуры Lock и Unlock.




                           ОКНА - ПАЛИТРЫ
                           ==============

         Окна специального типа - многоцветные окна - позволяют вам использовать различные  на-
    боры цветов в них и динамически изменять эти наборы.

                      Константы и типы палитр
                      -----------------------

         CONST
           PaletteSize = 10;
           PaletteMax  = PaletteSize-1;
           NormalPaletteColor = 0;
       (* См. процедуру PaletteOpen. *)
           FramePaletteColor = 1;
         TYPE
           PaletteRange = SHORTCARD [0..PaletteMax];
           PaletteColorDef = RECORD Fore.Back : Color END;
           PaletteDef = ARRAY PaletteRange OF PaletteColorDef;

         Палитра (типа  PaletteDef) - это 0..PaletteMax элементов,  представляющих собой наборы
    цветов типа PaletteColorDef. Каждый набор цвета определяет цвета переднего плана и фона.

                            PaletteOpen
                            -----------

         PROCEDURE PaletteOpen(WD :  WinDef;
                               Pal : PaletteDef ) :  WinType;

         Создает новое многоцветовое окно в соответствии с WD и Pal.  Окно создается с цветами,
    заданными   элементом   Pal[NormalPaletteColor],   а   рамка   -  с  цветами,  заданными  в
    Pal[FramePaletteColor].  В конце окно помещается для обзора поверх всех существующих  окон.
    Текущий цвет палитры задается в NormalPaletteColor.

                             SetPalette
                             ----------

         PROCEDURE SetPalette(W : WinType; Pal : PaletteDef);

         Изменяет палитру указанного окна W на Pal, переотображая изменение цвета.

                            PaletteColor
                            ------------

         PROCEDURE PaletteColor() : PaletteRange;

         Возвращает номер текущего набора цветов палитры текущего окна.

                          SetPaletteColor
                          ---------------

         PROCEDURE SetPaletteColor(pc: PaletteRange);

         Устанавливает текущим набором цветов палитры для текущего окна набор,  заданный в  рс.
    После этого вывод будет производиться цветами, заданными в рс.

                          PaletteColorUsed
                          ----------------

         PROCEDURE PaletteColorUsed(W     :     WinType;
                       pc : PaletteRange) : BOOLEAN;

         Возвращает TRUE, если набор цветов, заданный в рс, включен в палитру окна W.


                          МОДУЛЬ FloatExc
                          ===============

         Этот модуль  содержит процедуры работы с плавающей запятой.  Если обнаруживается,  что
    нет процессора 8087, то выполнение программы прекращается (с вызовом FatalError) и выдается
    сообщение в следующей форме:

         [AAAAA-OOOOO] Float Error : 'message'

         Адрес ААААА  - это абсолютный адрес в 16-ричном представлении.  OOOO - это смещение от
    начала программы; т.о., процедуру в случае ошибки можно найти по файлу распределения памяти
    (map-file);  сначала  вы  приводите OOOO к виду ssss:оооо,  затем находите старшее значение
    cегмента SSSS в map-файле, которое меньше, чем ssss; теперь вычтите ssss из SSSS, чтобы по-
    лучить dddd. Разница сегментов dddd преобразуется в смещение ffff (умножением на 16). Иско-
    мый адрес в карте распределения памяти будет: SSSS:ffff+oooo.


                          СПИСОК ПРОЦЕДУР
                          ===============

                      EnableExceptionHandling
                      -----------------------

         PROCEDURE EnableExceptionHandling;

         Разрешает обработку 8087-процессора.

                      DisableExceptionHandling
                      ------------------------

         PROCEDURE DisableExceptionHandling;

         Отменяет обработку 8087-процессора.
