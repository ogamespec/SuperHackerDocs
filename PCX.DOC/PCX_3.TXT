
     
     
     
     
                П А К Е Т   Р А З Р А Б О Т Ч И К А
      
                         ГРАФИЧЕСКИХ ПРОГРАММ
      
                                P C X
                         ********************
      
      
                        PCX Programmer's Toolkit
      
                       
      
                 ЧАСТЬ 3. ИНТЕРФЕЙС ПРОГРАММИРОВАНИЯ
                 ===================================
      
                      ГЛАВА  4. ИНТЕРФЕЙС  PCX
                      ------------------------
      
                              О Б З О Р
                                                                   
      
      
      Настоящий раздел рассказывает о среде пакета PCX. В нем объяс-
 няются имена и используемые правила поименования, необходимые вклю-
 ченные файлы (include  files) и определения структур. Данный раздел
 также имеет специальное справочное руководство для быстрого  нахож-
 дения функций "Быстрый справочник по функциям".Полный список команд
 компиляции дан в Главе 2  "Быстрое начало".
      
      Пакет содержит всеобъемлющий набор  интерфейсов  компиляторов,
 который охватывает шесть языков:
      
      - Ассемблер
      - Си
      - Паскаль
      - Бейсик
      - Фортран
      - Клиппер
      
      Если  Ваша  программа использует один из этих языков, то пакет
 обеспечит Вас интерфейсом компилятора. Одной из основных задач  при
 создании  пакета  было обеспечить совместимость и согласованность с
 языками и компиляторами. Эта цель была достигнута. Теперь, если  Вы
 изменяете  компиляторы  или языки, - Вы просто изменяете библиотеки
 пакета. Пакет поддерживает следующие компиляторы:
      
      - Microsoft Assembler 5.0, 5,1
      
      - Turbo Assembler 1.0
      
      - Microsoft C 5.0, 5.1
      
      - Quick C 1.x, 2.0
      
      - Turbo C 1.x, 2.0
      
      - Lattice C 3.2x, 3.3x
      
      - Microsoft Pascal 4.0
      
      - Turbo Pascal 4.0, 5.0
      
      - Microsoft Basic 6.0
      
      - QuickBasic 4.0, 4.5
      
      - Microsoft Fortran 4.1
      
      - Clipper Summer '87
      
      
      Покупать пакет для каждого языка нет необходимости- все библи-
 отеки в Вашем распоряжении. Кроме того, Вы можете получить исходный
 код для самостоятельной его отладки. Отметьте, что пакет  поддержи-
 вает самые последние версии всех компиляторов.
      
      Ограничения
      ---------------------------------
      
      В  некоторых  режимах  функции показа буфера и файла округляют
 координату X. Это обусловлено трудностями,  связаными  с  границами
 байт.  Ради  увеличения  скорости (но за счет некоторого уменьшения
 гибкости) левый край изображения автоматически соединяется на  гра-
 нице байт. Это означает, что в некоторых режимах при показе изобра-
 жения оно может быть сдвинуто влево на несколько точек, а при  сох-
 ранении изображения могут сохраняться несколько лишних точек.
      
      Это   ограничение   не   затрагивает   функции  pcxGetImage  и
 pcxPutImage. Изображения могут точно помещаться на границы точек, и
 могут производиться логические операции, например AND, OR или XOR.
      
      Кроме того, подпрограммы pcxVirtualDisplay и  pcxVirtualScroll
 поместят левый и правый края окна дисплея на границы байт.
      
      ПРИМЕЧАНИЕ:   Никогда не определяйте окно, большее чем
                    виртуальное изображение !
      
      
      Права на использование пакета
      ---------------------------------
                                   
      Как  указано в Лицензионном соглашении, Вы можете беспрепятст-
 венно использовать программы пакета -  если  только  Вы  соблюдаете
 следующие важнейшие правила:
      
      - Копировать утилиты PCX нельзя - они не включены в
        Лицензионное соглашение.
      
      - Функции пакета должны быть встроены в Вашу программу и к ним
        не должно быть доступа вне программы.
      
      - Воспроизводить функции пакета в библиотеке нельзя.
      
                             
      
                             СРЕДА ПАКЕТА
                             ************
      
      
      Использовать  пакет очень легко. Для сообщения того, какой тип
 и режим дисплея будет использован,  требуется  вызов  только  одной
 функции. Эта функция - pcxSetDisplay. Для изменения информации  па-
 кета  о  дисплее,  снова вызовите данную функцию. Заметьте, что эта
 функция НЕ УСТАНАВЛИВАЕТ фактический режим, а только лишь  устанав-
 ливает  внутренние  параметры  пакета. Режим может быть изменен при
 помощи функции pcxSetMode, или же посредством вызова любой  функции
 установки режима BIOS.
      
      Когда  режим  установлен,  все функции пакета будут работать с
 выбранным дисплеем и режимом. Это позволяет Вам обновлять программу
 для  болле  высокого  разрешения  путем  изменения  вызова  функции
 pcxSetDisplay  -  все  остальные  функции будут продолжать работать
 должным образом. Заметьте, что могут быть  использованы   различные
 изображения, но большая часть программы остается неизменной.
      
      Правила поименования
      ---------------------------------
                          
      Все  команды пакета имеют префикс pcx, чтобы избежать путаницы
 с программами пользователя или компилятора. Кроме  того,  программы
 имеют   следующую  схему  поименования:  pcx  [из]  [в].  Например,
 pcxBufferDisplay означает pcx [из] Buffer [в] Display и передвигает
 данные ИЗ буфера В дисплей.
      
      Мы поддерживаем и сохраняем  константы  пакета  в  большинстве
 языков и компиляторов, за исключением Клиппера, который ограничива-
 ет длину имени переменной и функции до 10 символов.  Поэтому  имена
 программ  Clipper  сокращены. Например, pcxBufferDisplay становится
 pcxBD, а pcxDisplayBuffer становится pcxDB.
      
      Последнее  замечание  касается  Lattice C. Пакет предполагает,
 что все данные являются данными типа far (дальние). Обычно, это об-
 рабатывается компилятором и определениями функций - но не в Lattice
 C. Это означает, что константы строк должны быть опрелены как far в
 моделях S и P. Для показа из файла, укажите:
      
      pcxFileDisplay(far "pcxTest.PCX",0,0,0);
      
      Альтернативный способ заключается в определении переменной как
 char far filename[] = "pcxTest.PCX"; а затем в использовании  имени
 переменной при вызове пакета.
      
      Коды ошибок
      ---------------------------------
                 
      Так как все программы пакета являются функциями, все они возв-
 ращают коды ошибок, если происходят ошибки. Для того,  чтобы  отли-
 чать  коды  ошибок от величин нормального возврата, все коды ошибок
 сделаны отрицательными. В целом,  функция  возвратит  код  возврата
 pcxSUCCESS, если все нормально. Для таких функций Вы можете провес-
 ти  явную  проверку кода успешного завершения перед тем как продол-
 жить работу. Например:
      
      retcode = pcxFileDisplay(...
      if(retcode = pcxSUCCESS)...
      
      Для тех случаев, когда ожидается явный возврат, например, воз-
 врат количества байт, использованных в буфере:
      
      retcode = pcxFileBuffer(...
      if(retcode > 0)...
      
      В любом случае коды ошибок можно в дальнейшем запрашивать  для
 определения типа ошибки. Сообщения об ошибках могут быть либо пока-
 заны пользователю, либо обрабатываться внутри системы. В Приложении
 содержится  полный  список  допустимых  констант ошибок для каждого
 языка.
      
      ПРИМЕЧАНИЕ:  Константы Clipper сокращены вследствие
                   общего ограничения длины в Clipper
                   до 10 символов.
      
      Строки
      ---------------------------------
            
      Для интерфейсов Microsoft Pascal и  Microsoft  Fortran,  пакет
 требует,  чтобы строки были в формате, совместимом с С, так как эти
 интерфейсы фактически компонуются с библиотекой С большой модели.
      
      Для Microsoft Pascal строка содержит символ NULL:
      
      pcximage = 'pcxTest.PCX'*chr(0)
      
      Для Microsoft Fortran строка содержит идентификатор 'C':
      
      DATA pcximage/'pcxTest.PCX'C/
      
      Все прочие интерфейсы не требуют специальной обработки строк.
      
      Буферы
      ---------------------------------
            
      Пакет может загружать, сохранять и показывать  изображения  из
 буферов памяти. В языке подобном C, понятие буфера очень знакомо. В
 других  языках  бывает  трудно определить буфер или получить к нему
 доступ. Для того, чтобы определить буфер емкостью 5000 байт в  каж-
 дом языке:
      
      C              char buffer[5000];
      Pascal         buffer : array[0..4999] of byte;
      MS Pascal      buffer : array[1..5000] of byte;
      Basic          DIM buffer%(5000/2)
      MS Fortran     CHARACTER buffer(5000)
      Clipper        buffer = SPACE(5000)
      
      Отметьте,  что  в  Бейсике Вы определяете буфер, вдвое меньший
 максимального буфера, передаваемого пакету. НИКОГДА не  определяйте
 буфер Бейсика как строку. Другие языки проще - они используют опре-
 деления символа или байта для описания буфера.
      
      ПРИМЕЧАНИЕ:  Для Lattice C, буфер определяется как char far.
      
      В Microsoft Pascal буфер представляет собой просто массив. Од-
 нако, для буферов больше 32 кбайт, Вы должны определить массив типа
 word  и  размеры  наполовину  меньшие требуемых. Вы должны передать
 фактический размер буфера программам пакета (то есть ВСЕГДА переда-
 вать количество БАЙТ). В Microsoft Fortran размер буфера может быть
 до 64 кбайт без всяких ограничений.
      
      Для указания на каждый из приводимых выше буферов  при  вызове
 программ пакета, Вам следует использовать следующие операторы прог-
 раммы (в качестве примера):
      
      C               pcxBufferDisplay(буфер,...
      Pascal          pcxBufferDisplay(@буфер,...
      MS Pascal       pcxBufferDisplay(ADS буфер,...
      Basic           pcxBufferDisplay%(буфер%(0),...
      MS Fortran      pcxBufferDisplay(буфер,...
      Clipper         pcxBD(буфер,...
      
      Для Си,Фортрана и Клиппера, просто используйте имя буфера. Для
 Паскаля используйте оператор адреса @ для Turbo, и оператор ADS для
 Microsoft для указания на буфер. Наконец, для Бейсика, явно укажите
 начало буфера - пакет автоматически определит этот параметр как ад-
 рес. Изучите также фрагменты программ, которые даются вместе с опи-
 санием каждой функции в справочном разделе.
      
      Виртуальные буферы
      ---------------------------------
      
      Иногда  большое  изображение  не  может  быть  показано сразу,
 вследствие недостаточного объема доступной памяти  или  ограничений
 разрешающей  способности видео-платы. Чтобы можно было быстро пано-
 рамировать и прокручивать большие изображения, в памяти может  быть
 создан  виртуальный буфер. Изображение полностью загружается в вир-
 туальный буфер.  Показываемое  изображение  будет  поднабором,  или
 чатью, виртуального буфера.
      
      Виртуальные  буферы  могут  быть  созданы  при  помощи функции
 pcxCreateVirtual, которая использует данные,  доступные  вне  Вашей
 программы.  Следовательно, программа малой модели также могут опре-
 делять большие виртуальные буферы. На  буфер  указывает  переменная
 vptr, возвращаемая функцией.
      
      Ниже  даны  рекомендации по правильному управлению виртуальным
 буфером.
      
      - Проверьте объем свободной памяти при помощи функции
        pcxVirtualFree.
      
      - Прочитайте заголовок изображения посредством функции
        pcxGetFileHeader.
      
      - Вычислите ширину и глубину изображения из заголовка при
        помощи (x2-x1 + 1) и (y2-y1 + 1), соответственно.
      
      - Прочитайте тип изображения при помощи функции
        pcxGetFileType.
      
      - Вычислите требуемый размер виртуального буфера при помощи
        функции pcxVirtualSize и сравните его с объемом свободной
        памяти.
      
      - Если в памяти есть достаточно места для буфера, создайте
        буфер при помощи функции pcxCreateVirtual, используя
        вышеуказанный тип, ширину и глубину изображения.
      
      - Загрузите файл при помощи функции pcxFileVirtual.
      
      - Теперь покажите его функцией pcxVirtualDisplay или функцией
        pcxVirtualScroll. При прокрутке передайте фактическую ширину
        и глубину изображения (подсчитанные выше). НИКОГДА НЕ
        ОПРЕДЕЛЯЙТЕ ОКНО БОЛЬШЕЕ ЧЕМ РАЗМЕР ИЗОБРАЖЕНИЯ.
      
      - Если Вы не собираетесь снова показывать изображение, и не
        собираетесь использовать созланный буфер, вызовите функцию
        pcxDestroyVirtual для освобождения памяти.
      
      Для некоторых компиляторов, Вам  потребуется  увеличить  объем
 памяти,  доступной  для  создания  виртуальных буферов. Например, в
 Turbo Pascal и Turbo C, Вы можете использовать директиву компилято-
 ра $M (или установить эту опцию из меню "Опции  компилятора").  Для
 Basic и QuickBasic, используйте функцию SETMEM. Для других компиля-
 торов,  дополнительные изменения обычно не нужны, хотя дополнитель-
 ная память может быть  освобождена  при  помощи  программы  EXEMOD,
 включенной в большинство компиляторов Microsoft. Детальная информа-
 ция по этому вопросу содержится в документации по компиляторам.
      
      Структуры
      ---------------------------------
               
      Пакет имеет минимальное число определений структур. Одна такая
 структура определяет формат заголовка PCX. Эта структура дает поль-
 зователям  прямой  доступ  к переменным в файле изображений PCX или
 буфере. В большинстве случаев, менять эту информацию нельзя. Но для
 информации  о  палитре  это  необхдимо, и, кроме того, пользователи
 также могут иметь доступ только чтения и к некоторым другим данным.
      
      Во всех  языках, кроме Clipper, структура заголовка  определя-
 ется подобно любой другой структуре, образом, присущим данному язы-
 ку. Заголовок определяется в файлах заголовка пакета. Информация по
 его структуре  для различных языков дана в Приложении.
      
      Доступ к структурным определениям в разных языках производится
 по-разному. В справочнике по функциям есть пример на  каждом  языке
 для  каждой  определенной  функции. В целом, приводимый ниже пример
 операторов программы иллюстрирует способ доступа к структуре  заго-
 ловка PCX.
      
     С             pcxGetBufferHeader(...,&заголовок...
     Pascal        pcxGetBufferHeader(...,@заголовок...
     MS Pascal     pcxGetBufferHeader(...,ADS заголовок...
     MS Basic      pcxGetBufferHeader(...,заголовок...
     MS Fortran    pcxGetBufferHeader(...,manuf...
      
      Во избежании путаницы другие параметры опущены. Заметьте,  что
 Clipper  не имеет прямого интерфейса в параметры заголовка. В Форт-
 ране нет типов структур и записей, поэтому параметры заголовка  ад-
 ресуются через блок COMMON. Этот блок определен для Вас во включен-
 ном файле (include file) pcxLib.FOR, но Вы можете  определить  свой
 собственный  блок. Передайте пакету местонахождение первой перемен-
 ной блока.
      
      Скелет кода
      ---------------------------------
                 
      Иногда  бывает  полезно увидеть общую схему или "скелет" кода.
 Вот простейший скелет кода пакета PCX:
      
      pcxSetDisplay(pcx_???)
      pcxSetMode(pcxGRAPHICS)
      ...выполнить графику
           как pcxFileDisplay()...
      pcxSetMode(pcxTEXT)
      
      Большинство подпрограмм и программ соблюдают этот формат.  Для
 более детального исследования реальных прикладных программ просмот-
 рите или распечатайте образцы программ, содержащиеся  в  пакете  на
 диске  с  примерами. Полные команды для компиляции примеров по всем
 поддерживаемым компиляторам находятся к  комментариях  к  исходному
 коду.  Дополнительная информация имеется также в главе "Быстрое на-
 чало".
      
      
               ДОБАВЛЕНИЕ ПАКЕТА К ВАШИМ ПРОГРАММАМ
               ************************************
      
      
      Для каждого поддерживаемого языка,пакет имеет включенный  файл
 (include  file)  с именем pcxLib - не путайте его с сервисной прог-
 раммой pcxLib.EXE: включенный файл является  текстовым!  Этот  файл
 определяет  все доступные в пакете программы и параметры, константы
 и структуры, которые облегчают использование  пакета.  Откомпилиро-
 вать программу без  включения файла пакета обычно не представляется
 возможным, если только Вы не отрезаете от него части и не добавляе-
 те их в свою программу.
      
      С
      ---------------------------------
       
      Чтобы  сделать проограммы пакета доступными Вашей программе С,
 Вы должны включить файл заголовка pcxLib.H. Вы должны  сделать  это
 в верхней части своей программы при помощи следующего оператора:
      
      #include "pcxLib.H"
     
      
      Quick C
      ---------------------------------
             
      Версии  1.х  Quick  C  поддерживают  только одну модель памяти
 (среднюю) и библиотеки Quick Libraries. Для этих  версий  Quick  C,
 как и прежде имеются "быстрые" библиотеки. Однако, версия 2.0 Quick
 C  не поддерживает Quick Libraries, а поддерживает все модели памя-
 ти. Используйте соответсвующую библиотеку С для своей модели памяти
 (PCX_CS, PCX_CM или PCX_CL).
     
     
      Turbo Pascal
      ---------------------------------
                  
      Форматы модуля для версий Turbo Pascal 4.0 и 5.0  несовместимы
 друг с другом, поэтому  пакет имеет свои форматы для каждой версии.
 Они  поименованы  как  PCX_TP40.TPU и PCX_TP50.TPU, соответственно.
 Просто выберите подходящий Вашей версии компилятора модуль, и поме-
 тите  его  в  свой  каталог  модулей.   Переименуйте   модуль   как
 PCX_TP.TPU.  Как и прежде, включите в свою программу следующий опе-
 ратор:
      
      uses pcx_tp;
     
     
      Pascal
      ---------------------------------
            
      Для  Microsoft  Pascal,  используйте включенный (include) файл
 Паскаля.  Затем, после спецификации программы, добавьте строку uses
 pcxLib;, чтобы сделать программы доступными. Например:
      
      {$include: 'pcxLib.PAS'}
      Program pcxTest;
      uses pcxLib;
     
      
      Basic
      ---------------------------------
           
      Для QuickBasik 4.5 и Microsoft Basic 6.0 используйте директиву
 INCLUDE. Это заставляет  QuickBasic  включить  определения  пакета,
 когда он компилирует Вашу программу. В верхней части программы вве-
 дите следующее:
      
      '$INCLUDE: 'pcxlib.bas'
     
     
      Fortran
      ---------------------------------
             
      Как и для других интерфейсов, включите файл заголовка:
      
      $INCLUDE: 'pcxLib.FOR'
      
      и параметры и функции пакета будут автоматически определены.
     
     
      Clipper
      ---------------------------------
             
      Интерфейс  Clipper  немного отлдичается от других интерфейсов.
 Вам также нужно включить файл пакета, но нужно еще и  СДЕЛАТЬ  его.
 Это гарантирует, что всем константам будут присвоены  относительные
 величины. Поместите в верхнюю часть своей программы Clipper следую-
 щие две строки:
      
      SET PROCEDURE TO pcxlib
      DO pcxInit
      
      Теперь  Вам  не  надо  определять никакие программы пакета как
 внешние (EXTERNAL), и Вы можете  свободно  использовать  константы.
 Будьте осторожны при очистке переменных памяти - Вам может потребо-
 ваться выполнить процедуру pcxInit заново.
      
      Вот пример командной строки компоновщика PLINK86:
      
      Plink86 FI pcxtest, pcx_clip LIB clipper,extend, pcx_cl
      
      Вызывайте  процедуру  pcxInit только один раз - в начале Вашей
 программы.
      
      
              ОПТИМИЗАЦИЯ  ЭФФЕКТИВНОСТИ РАБОТЫ ПАКЕТА
              ****************************************
      
      
      Эффективность работы пакета может быть  увеличена  несколькими
 способами  -  путем операций над файлами, установками палитры и ис-
 пользуя подходящий режим дисплея.
      
      Ускорение доступа к файлу
      ---------------------------------
                               
      Для   ускорения   доступа   к   файлу,   используйте   функцию
 pcxSetBuffer  для размещения большего буфера пакета. Этот буфер ис-
 пользуется для операций показа файла, функций печати  и  для  любых
 других функций, которым необходим промежуточный буфер. Как правило,
 размер  этого  буфера только 1000 байт. Это означает, что для файла
 изображения размером 30 кбайт, пакету придется произвести доступ  к
 файлу  30  раз  во  время  операции  показа.  Использование функции
 pcxSetBuffer для установки буфера пакета емкостью 35 кбайт сократит
 число доступов до одного. Это значительно ускорит  операции  показа
 файлов.
      
      Еще более быстрый показ
      ---------------------------------
                             
      Для  максимально быстрого показа изображения, используйте вир-
 туальные (Virtual) функции. Загрузите изображение в виртуальный бу-
 фер, а затем покажите его. Скорость показа изображения возрастет  в
 5 - 10 раз.
      
      Пропуск установок палитры
      ---------------------------------
                               
      Во многих случаях, можно вообще не работать с установками  па-
 литры.  Это справедливо, если Вы главным образом создаете изображе-
 ния в любой из программ Paintbrush, используя палитру по  умолчанию
 (за  исключением  256-цветных режимов). Если Вы не уверены, исполь-
 зуйте утилиту pcxShow и опцию  /C  (цветовая  палитра)  для  показа
 изображения.  Если  изображение выглядит также, как если бы палитра
 была установлена, Вы можете пропустить установку  палитры  в  своей
 программе.  Это освобождает Вас от работы с буферами палитры, коди-
 рования, декодирования и т.п.
      
      Режимы дисплея
      ---------------------------------
                    
      При создании черно-белых изображений лучше всего  использовать
 черно-белый режим. В противном случае, черно-белое изображение дол-
 жно быть сохранено как цветное изображение, что увеличивает требуе-
 мый  размер  файла  до четырех раз. Однако, черно-белые изображения
 МОГУТ быть показаны в цветных режимах  -  это  не  создаст  никаких
 проблем и не снизит скорости.
      
      
                     ИСПОЛЬЗОВАНИЕ ПАКЕТА С
               ДРУГИМИ ГРАФИЧЕСКИМИ БИБЛИОТЕКАМИ
               *********************************
      
      
      Пакет может быть легко объединен с другими графическими библи-
 отеками,  например  библиотеками, имеющимися для Microsoft C, Quick
 C, Lattice C, Turbo C, Turbo Pascal, Basic и QuickBasic.
      
      Функция pcxSetDisplay НЕ ИЗМЕНЯЕТ среду работы Вашей  програм-
 мы, она должна быть полностью прозрачна (скрыта) для Вашей програм-
 мы. Она может быть вызвана в любое время для включения типа дисплея
 пакета, но она не изменяет режим дисплея.
      
      Другие графические библиотеки объединяют инициализацию с функ-
 цией  установки  режима.  В подобных случаях, установите тип пакета
 при помощи функции pcxSetDisplay, а  затем  инициализируйте  другие
 графические библиотеки до совместимого типа.
      
      Для библиотеки Microsoft GRAPHICS.LIB (пример на C):
      
      retcode = pcxSetDisplay(pcxEGA_10);
      _setvideomode(_ERESCOLOR);
      
      Для библиотеки Borland BGI (пример на Паскале):
      
      retcode := pcxSetDisplay(pcxEGA_10);
      GraphDriver := EGA;
      GraphMode := EGAHi;
      InitGraph(GraphDriver, GraphMode, 'C:\DRIVERS');
      
      
                   ВНУТРЕННЕЕ УСТРОЙСТВО ПАКЕТА
                   ****************************
      
      В  этом  разделе описывается внутреннее устройство и структуры
 данных пакета, что может быть интересно для  некоторых  программис-
 тов.  Пропустите этот раздел, если Вы не интересуетесь подобной ин-
 формацией.
      
      Дальние вызовы (far)
      ---------------------------------
                         
      Все функции и указатели пакета являются FAR; это означает, что
 требуется как сегмент, так и смещение. Это необходимо даже для биб-
 лиотек малой модели. Это облегчает способ, которым пакет  осуществ-
 ляет доступ к параметрам на стеке. Данный тип вызова обычно обраба-
 тывается  компилятором автоматически, на основании макетов функции,
 имеющихся в заголовке и включенных файлах (include files). В  боль-
 шинстве  случаев Вы можете не учитывать этого, но следует иметь это
 в виду при изменении любых функций пакета.
      
      Типы дисплея
      ---------------------------------
                  
      Пакет использует тип  дисплея для индексирования во внутренней
 таблице, которая  определяет этот тип. Структура этой таблицы опре-
 делена  как  PCXDINFO, и Вы можете получить доступ к ней при помощи
 функции  pcxGetDisplayInfo. Эта информация используется при опреде-
 лении смещений показа, в функциях показа и сохранения, установке  и
 чтении палитр, в делании вырезок и т.п.
      
      Буферы
      ---------------------------------
      
      Пакет  хранит  в  памяти сжатые изображения PCX, что означает:
 файл полностью считывается в буфер без  каких-либо  преобразований.
 Вы можете использовать любой выбранный Вами способ для чтения файла
 изображений PCX в буфер, так как процедура pcxFileBuffer не  делает
 никаких преобразований.
      
      Однако,  в целях обеспечения совместимости с будущими версиями
 пакета, используйте процедуру pcxFileBuffer как можнро больше.  Это
 позволяет производить скрытые изменения во внутреннем формате буфе-
 ра.
      
      Библиотеки изображений
      ---------------------------------
                            
      Пакет определяет структуры, используемые для построения библи-
 отек изображений. В начале каждой библиотеки имеется заголовок биб-
 лиотеки.  Этот заголовок содержит параметры идентификации, имя тома
 и т.п. Затем, перед каждым  изображением  идет  структура  каталога
 библиотеки.  Эта  структура  содержит  поле  синхронизации   (synch
 field),  имя файла и размер, дату и время файла, примечание к изоб-
 ражению и  другую  информацию.
      
      Процедура  для  поиска в библиотеке состоит из нескольких эта-
 пов.  Сначала  прочитайте  заголовок библиотеки. Удостоверьтесь,что
 это библиотека, посредством проверки идентификационного номера  для
 "pcxLib".  Затем прочитайте заголовок первого изображения. Сравните
 имя файла с искомым - если они не совпадают, перейдите к  заголовку
 следующего  изображения  посредством  использования  поля filesize.
 Прочитайте заголовок изображения, и проверьте, чтобы поле синхрони-
 зации (synch field) содержало величину pcxSYNC. Повторите процесс.
      
      Для того, чтобы добавить изображения в файл библиотеки, просто
 заполните информацией заголовок и добавьте заголовок и  изображение
 в конец файла библиотеки. Для стирания изображения, удалите изобра-
 жение  и  заголовок.  Удаление изображения обычно означает, что Вам
 необходимо создать другой файл и скопировать все остающиеся изобра-
 жения в новую библиотеку. Это называется "упаковкой".
      
      Виртуальные буферы
      ---------------------------------
                        
      Для    тех   программистов,   кто   хочет   "обойти"   функцию
 pcxCreateVirtual и разместить виртуальные буферы другими способами,
 следующие ниже параграфы дают объяснение внутренней  логики  вирту-
 ального буфера. Большинство пользователей могут пропустить эти объ-
 яснения.
      
      Пакет  может автоматически различать, когда переданый ему ука-
 затель является обычным, а когда виртуальным буфером. Это осуществ-
 ляется, так как переменная vptr содержит фактический указатель  па-
 мяти,  когда  буфер  является обычной памятью (CMM); эта переменная
 содержит указатель EMM (расширенной памяти), когда  буфер  является
 расширенной памятью (EMM). Сегмент указателя равен 0, когда запоми-
 нается  (хранится)  указатель EMM, этот сегмент принимает ненулевую
 величину, когда имеется указатель  CMM.  Это  означает,  что  буфер
 обычной  памяти  НЕ  МОЖЕТ быть определен в первых 64 кбайт пвамяти
 DOS (то есть сегмент = 0), но в действительности  это  не  является
 ограничением (если только Вы не хотите переписать DOS!)
      
      Если  Вы размещаете виртуальный буфер средствами, отличными от
 средств функции pcxCreateVirtual, Вы должны хранить адрес виртуаль-
 ного буфера в переменной vptr. Например:
      
 C               vptr = &buffer;
 Pascal          vptr = @buffer;
 MS Pascal       vptr = ADSbuffer;
 MS Basic        vptr = varseg(buffer%(0))+varptr(Buffer%(0))*65536
 MS Fortran      vptr = LOCFAR(buffer)
      
      В отличие от обычных буферов, буферы расширенной памяти ДОЛЖНЫ
 БЫТЬ размещены при помощи функции pcxCreateVirtual.
      
                  
      
                       ТРАНСЛЯЦИЯ ИСХОДНОГО КОДА
                       *************************
      
      
      Один и тот же исходный код на  языке  ассемблера  используется
 для всех интерфейсов компиляторов и языков. Все специфические взаи-
 модействия  (интерфейсы) компиляторов выполнены макросами, на осно-
 вании определений (DEFINES), сделанных при трансляции кода. Эти оп-
 ределения  затем  обрабатывают  определения  сегментов,  требования
 входного  и  выходного  кода, форматирование строк, коды возврата и
 т.п.
      
      На первый взгляд может показаться, что исходный  код,  который
 поддерживает 12 компиляторов, 6 различных языков и 3 модели памяти,
 представляет  нечто кошмарное. В действительности, код очень прост,
 и макросы не вложены до n-ого уровня. Если у Вас есть исходный код,
 Вы увидите, что прочитать и понять его очень несложно.
      
      Утилита pcxMake
      ---------------------------------
             
      В пакете имеется командный файл, который устанавливает требуе-
 мые определения для трансляции библиотеки для любого интерфейса па-
 кета. Этот файл называется pcxMake, и, подобно другим утилитам  па-
 кета,  ввод этого имени файла без параметров вызовет экран подсказ-
 ки.
      
      Фокус с трансляцией исходного кода при помощи утилиты  pcxMake
 заключается  в  том,  что необходимо правильно установить структуру
 каталога. Она построена так, что генерируемые объектные модули  по-
 мещаются в отдельный каталог. Таким образом, без смешения объектно-
 го кода могут быть поддержаны несколько интерфейсов. Например, если
 текущим каталогом является ASM, малая модель памяти Microsoft c бу-
 дет перестроена в каталоге ASM\CS. Поместите все исходные файлы па-
 кета в каталог ASM, и библиотеку PCX_CS.LIB - в каталог ASM\CS.  В
 каталоге ASM наберите pcxMakeS для трансляции библиотеки. Каталоги,
 которые требуются для каждого языка, такие же, что и имя  библиоте-
 ки: QB для PCX_QB.LIB и так далее.
      
      Мы  рекомендуем  Вам произвести трансляцию исходного кода один
 раз, перед тем, как будут  сделаны  любые  модификации.  Когда  это
 удасться  сделать,  скомпонуйте  и  используйте  новую библиотеку с
 программой, которая, как Вы знаете, работает с оригинальной (перво-
 начальной) библиотекой.
      
      Затем все остальное будет зависеть от Вас.
            
      
      
              * * * * * * * * * * * * * * * * * * * * * *
      
      
      
                   БЫСТРЫЙ СПРАВОЧНИК ПО ФУНКЦИЯМ
                   ==============================
      
                      1. АЛФАВИТНЫЙ СПРАВОЧНИК
                      ------------------------
      
      
 pcxBeginPaletteGrab  Начинает захват или управление палитрой EGA,
                      для дальнейшего сохранения палитры
      
 pcxBufferDisplay     Показывает изображение из буфера
      
 pcxBufferFile        Сохраняет буфер изображения в файл
    
 pcxBufferPrint       Печатает буфер изображения PCX
      
 pcxBufferText        Загружает текстовой экран обратно в дисплей
      
 pcxBufferVirtual     Расширяет изображение PCX в виртуальный буфер
      
 pcxCreateVirtual     Создает виртуальный буфер
      
 pcxDecodePalette     Декодирует палитру PCX в палитру BIOS
      
 pcxDestroyVirtual    Уничтожает созданный виртуальный буфер
      
 pcxDisplayBuffer     Сохраняет  дисплей в буфер изображения
      
 pcxDisplayFile       Сохраняет дисплей в файл PCX
      
 pcxDisplayPrint      Печатает дисплей на принтере, указанном
                      pcxSetPrinter
      
 pcxEMInstalled       Проверяет, если ли расширенная память EMS
      
 pcxEncodePalette     Кодирует палитру BIOS в палитру PCX
      
 pcxEndPaletteGrab    Заканчивает управление палитрой EGA, после
                      функции pcxBeginPaletteGrab
      
 pcxFileBuffer        Загружает файл PCX в буфер изображения
      
 pcxFileDisplay       Загружает файл PCX непосредственно в дисплей
      
 pcxFilePrint         Печатает фал изображения PCX
      
 pcxFileVirtual       Расширяет файл PCX в витруальный буфер
      
 pcxGetBufferHeader   Читает заголовок PCX из буфера изображения
      
 pcxGetBufferPalette  Читает палитру из буфера изображения
      
 pcxGetBufferType     Читает тип дисплея буфера изображения
      
 pcxGetDisplay        Читает текущий тип дисплея, установленный
                      ранее при помощи функции pcxSetDisplay
      
 pcxGetDisplayInfo    Читает информацию по типу дисплея
      
 pcxGetDisplayPalette Читает текущую палитру дисплея
                      
 pcxGetFileHeader     Читает заголовок PCX из файла PCX
      
 pcxGetFilePalette    Читает палитру из файла PCX
      
 pcxGetFileType       Читает тип дисплея файла PCX
      
 pcxGetImage          Читает изображение из точного адеса и
                      использует логические операции
      
 pcxGetLibHeader      Читает заголовок PCX из файла PCX в
                      библиотеке изображений
      
 pcxGetLibPalette     Читает палитру из файла PCX в библиотеке
                      изображений
      
 pcxGetLibType        Читает тип дисплея файла PCX в библиотеке
                      изображений
      
 pcxGetPage           Читает текущую страницу дисплея
      
 pcxGetVersion        Читает текущую версию пакета PCX
      
 pcxLibBuffer         Загружает файл PCX из библиотеки изображений
                      в буфер изображения
      
 pcxLibDisplay        Загружает файл PCX из бмиблиотеки изображений
                      в дисплей
      
 pcxLibPrint          Печатает изображение библиотеки PCX
      
 pcxLibSearch         Ищет данное изображение в библиотеке
      
 pcxLibVirtual        Расширяет изображение библиотеки PCX в
                      виртуальный буфер
      
 pcxmodeCheck         Включает и выключает проверку режима в
                      программах пакета
      
 pcxPutImage          Выводит изображение по точному адресу и
                      использует логические операции
      
 pcxQueryChipset      Запрашивает текущий набор чипов VGA
      
 pcxSetBuffer         Устанавливает внутрений буфер изображения
                      пакета как больший, определенный пользователем
                      буфер
      
 pcxSetBufferHeader   Устанавливает новый заголовок PCX для буфера
                      изображения
      
 pcxSetBufferPalette  Устанавливает новую палитру для буфера
                       зображения
      
 pcxSetDisplay        Устанавливает тип дисплея для всех будущих
                      версий пакета (должна быть вызвана по крайней
                      мере один раз)
      
 pcxSetDisplayType    Устанавливает новую палитру для дисплея
      
 pcxSetFileHeader     Устанавливает новый заголовок PCX
                      для файла PCX
      
 pcxSetFilePalette    Устанавливает новую палитру для файла PCX
      
 pcxSetHerc           Конфигурирует адаптер "Геркулес"
      
 pcxSetMode           Изменяет режим дисплея на текстовой (TEXT)
                      или графический (GRAPHICS)
      
 pcxSetPage           Устанавливает текущую страницу дисплея
      
 pcxSetPrinter        Устанавливает и конфигурирует текущее
                      устройство печати
      
 pcxTextBuffer        Сохраняет текстовой экран в буфер
      
 pcxVerifyBuffer      Проверяет, является ли буфер настоящим
                      буфером изображения PCX
      
 pcxVerifyFile        Проверяет, является ли файл настоящим
                      файлом PCX
      
 pcxVideoInfo         Читает информацию по текущей видео-аппаратуре
      
 pcxVirtualDisplay    Загружает фиртуальный буфер в дисплей
      
 pcxVirtualPrint      Печатает виртуальный буфер на принтере,
                      указанном функцией pcxSetPrinter
      
 pcxVirtualScroll     Показывает виртуальный буфер и разрешает
                      прокрутку
      
 pcxVirtualSize       Подсчитывает объем памяти, необходимый для
                      виртуального изображения
                     
                  
      
      
                   2. СПРАВОЧНИК ПО ГРУППАМ ФУНКЦИЙ
                   --------------------------------
      
      
      Буферы
      =================================
                                       
 pcxDisplayBuffer     Сохраняет  дисплей в буфер изображения
      
 pcxFileBuffer        Загружает файл PCX в буфер изображения
      
 pcxGetBufferType     Читает тип дисплея буфера изображения
      
 pcxLibBuffer         Загружает файл PCX из библиотеки изображений
                      в буфер изображения
      
 pcxVerifyBuffer      Проверяет, является ли буфер настоящим
                      буфером изображения PCX
      
      
      Файлы
      =================================
      
 pcxBufferFile        Сохраняет буфер изображения в файл
      
 pcxDisplayFile       Сохраняет дисплей в файл PCX
      
 pcxGetFileType       Читает тип дисплея файла PCX
      
 pcxVerifyFile        Проверяет, является ли файл настоящим
                      файлом PCX
      
      
      
      Дисплей
      =================================
             
 pcxBufferDisplay     Показывает изображение из буфера
      
 pcxFileDisplay       Загружает файл PCX непосредственно в дисплей
      
 pcxGetDisplay        Читает текущий тип дисплея, установленный
                      ранее при помощи функции pcxSetDisplay
      
 pcxGetDisplayInfo    Читает информацию по типу дисплея
      
 pcxGetImage          Читает изображение из точного адеса и
                      использует логические операции
      
 pcxLibDisplay        Загружает файл PCX из бмиблиотеки изображений
                      в дисплей
      
 pcxPutImage          Выводит изображение по точному адресу и
                      использует логические операции
      
 pcxVirtualDisplay    Загружает фиртуальный буфер в дисплей
      
 pcxVirtualScroll     Показывает виртуальный буфер и разрешает
                      прокрутку
      
      
      
      Виртуальные экраны
      =================================
      
                        
 pcxBufferVirtual     Расширяет изображение PCX в виртуальный буфер
      
 pcxCreateVirtual     Создает виртуальный буфер
      
 pcxDestroyVirtual    Уничтожает созданный виртуальный буфер
      
 pcxFileVirtual       Расширяет файл PCX в витруальный буфер
      
 pcxLibVirtual        Расширяет изображение библиотеки PCX в
                      виртуальный буфер
      
 pcxVirtualSize       Подсчитывает объем памяти, необходимый для
                      виртуального изображения
      
      
      
      Текстовые экраны
      =================================
               
      
 pcxBufferText        Загружает текстовой экран обратно в дисплей
      
 pcxTextBuffer        Сохраняет текстовой экран в буфер
      
      
      
      Печать
      =================================
            
      
 pcxBufferPrint       Печатает буфер изображения PCX
      
 pcxDisplayPrint      Печатает дисплей на принтере, указанном
                      pcxSetPrinter
      
 pcxFilePrint         Печатает фал изображения PCX
      
 pcxLibPrint          Печатает изображение библиотеки PCX
      
 pcxSetPrinter        Устанавливает и конфигурирует текущее
                      устройство печати
      
 pcxVirtualPrint      Печатает виртуальный буфер на принтере,
                      указанном функцией pcxSetPrinter
      
      
      
      Палитры
      =================================
      
      
 pcxBeginPaletteGrab  Начинает захват или управление палитрой EGA,
                      для дальнейшего сохранения палитры
      
 pcxDecodePalette     Декодирует палитру PCX в палитру BIOS
      
 pcxEncodePalette     Кодирует палитру BIOS в палитру PCX
      
 pcxEndPaletteGrab    Заканчивает управление палитрой EGA, после
                      функции pcxBeginPaletteGrab
      
 pcxGetBufferPalette  Читает палитру из буфера изображения
      
 pcxGetDisplayPalette Читает текущую палитру дисплея
                      
 pcxGetFilePalette    Читает палитру из файла PCX
 
 pcxGetLibPalette     Читает палитру из файла PCX в библиотеке
                      изображений
      
 pcxSetBufferPalette  Устанавливает новую палитру для буфера
                      изображения
      
 pcxSetDisplayType    Устанавливает новую палитру для дисплея
      
 pcxSetFilePalette    Устанавливает новую палитру для файла PCX
      
      
      
      Заголовки
      =================================
               
      
 pcxGetBufferHeader   Читает заголовок PCX из буфера изображения
      
 pcxGetFileHeader     Читает заголовок PCX из файла PCX
      
 pcxGetLibHeader      Читает заголовок PCX из файла PCX в
                      библиотеке изображений
      
 pcxSetBufferHeader   Устанавливает новый заголовок PCX для буфера
                      изображения
      
 pcxSetFileHeader     Устанавливает новый заголовок PCX
                      для файла PCX
      
      
      
      
      Видео
      =================================
           
      
 pcxGetPage           Читает текущую страницу дисплея
      
 pcxQueryChipset      Запрашивает текущий набор чипов VGA
      
 pcxSetHerc           Конфигурирует адаптер "Геркулес"
      
 pcxSetMode           Изменяет режим дисплея на текстовой (TEXT)
                      или графический (GRAPHICS)
      
 pcxSetPage           Устанавливает текущую страницу дисплея
      
 pcxVideoInfo         Читает информацию по текущей видео-аппаратуре
      
      
      
      
      Смешанные функции
      =================================
                       
      
 pcxEMInstalled       Проверяет, если ли расширенная память EMS
      
 pcxGetLibType        Читает тип дисплея файла PCX в библиотеке
                      изображений
      
 pcxGetVersion        Читает текущую версию пакета PCX
      
 pcxLibSearch         Ищет данное изображение в библиотеке
      
 pcxmodeCheck         Включает и выключает проверку режима в
                      программах пакета
      
 pcxSetBuffer         Устанавливает внутрений буфер изображения
                      пакета как больший, определенный пользователем
                      буфер
      
 pcxSetDisplay        Устанавливает тип дисплея для всех будущих
                      версий пакета (должна быть вызвана по крайней
                      мере один раз)
      
      
      
      
              * * * * * * * * * * * * * * * * * * * * * *
      
      
      
      
               ГЛАВА  5. СПРАВОЧНИК ПО ФУНКЦИЯМ  PCX
               -------------------------------------
      
     
                            О Б З О Р
      
      
      
      Данная глава представляет собой справочник по функциям пакета.
 Программы пакета описываются в алфавитном порядке. Описание функции
 состоит из следующих подразделов:
      
      - Синтаксис
      - Описание
      - Величина возврата
      - Соответствующие функции
      - Примеры
      
      Первый подраздел "Синаксис" дает точный синтаксис функции  для
 каждого  языка,  который поддерживается пакетом. Заметьте, что син-
 таксис дается в форме, присущей каждому языку.
      
      Подраздел "Описание" объясняет назначение программы.
      
      Следующий подраздел - "Величина возврата" - представляет вели-
 чину возврата для каждой функции; в большинстве случаев  это  целое
 число - если все нормально, или код ошибки - если произошла ошибка.
 В пакете НЕТ процедур, - одни только ФУНКЦИИ, так как все программы
 возвращают величину.
      
      Подраздел  "Соответствующие функции" описывает не только похо-
 жие функции, но и другие  функции,  используемые  вместе  с  данной
 программой.
      
      Последний  подраздел  - "Примеры" - иллюстрирует использование
 программы во фрагменте реального кода для  каждого  языка,  который
 поддерживается пакетом.
      
      
     
     
      
                        КОНЕЦ   ТРЕТЬЕЙ   ЧАСТИ
      
                                                                                
  
                        
      
      
      
                     
      
       
