 
     =================================================================








                              Ал. Стивенс


                  "ТЕХНИКА ПРОГРАММИРОВАНИЯ НА ТУРБО СИ"










     =================================================================





Предисловие.....................................................  10
Обзор разделов..................................................  15
ГЛАВА 1.........................................................  19
 Интерактивное программное обеспечение, управляющее изображением. 19
ГЛАВА 2.........................................................  32
 Язык Cи........................................................  32
 Краткая история языка Си.......................................  33
 Особенности языка Си...........................................  37

                             - 2 -
 Достоинства языка Си...........................................  40
 Одобрение языка Си.............................................  43
 Рекомендуемая литература по Си ................................  43
ГЛАВА 3 ........................................................  46
 Компилятор Турбо Си ...........................................  46
 Два Турбо Си ..................................................  49
 Настройка интегрированной среды ...............................  51
 Редактор Турбо Си .............................................  53
 Компоновщик Турбо Си ..........................................  55
 Утилита построителя задач (Make) в Турбо Си ...................  56
 Обнаружение ошибок при компиляции и компоновке ................  58
 Программные средства низкого уровня ...........................  58
 Начальная установка ...........................................  61
 Модели памяти .................................................  62
 Библиотека исходных модулей ...................................  63
 Заключение ....................................................  63
ГЛАВА 4 ........................................................  64
 Функции общего назначения .....................................  64
 Исходные модули функций общего назначения .....................  72
 Заключение.....................................................  83
ГЛАВА 5 ........................................................  84
 Экранные окна .................................................  84
 Экранное окно .................................................  85
 Архитектура видеопамяти .......................................  94
 "Снег" и обратный ход луча развертки .......................... 101
 Заключение .................................................... 110
ГЛАВА 6 ........................................................ 111
 Библиотека оконных функций .................................... 111
 Стековые окна ................................................. 113
 Слоеные окна .................................................. 113
 Оконные функции ............................................... 120
 Листинги оконных функций ...................................... 134
 Описание программы: twindow.h ................................. 144
 Описание программы: twindow.c ................................. 175
 Примеры окон .................................................. 185
 Перемещение  окна ............................................. 185
 Подъем и опускание окон ....................................... 192

                             - 3 -
 Назначение заголовков и изменение цветов окна ................. 196
 Сравнение стековых и слоеных окон ............................. 203
 Перемещение, подъем, скрытие окон, меню, изменение интенсив. .. 208
 Резюме ........................................................ 223
ГЛАВА 7 ........................................................ 224
 Контекстно-управляемые окна подсказки ......................... 224
 Программирование окон подсказки ............................... 228
 Текстовый файл окна подсказки ................................. 233
 Функции подсказки ............................................. 239
 Изменение функциональной клавиши подсказки .................... 240
 Изменение функции подсказки ................................... 241
 Выключение подсказки .......................................... 242
 Исходный листинг: thelp.c ..................................... 242
 Описание программы: thelp.c ................................... 248
 Пример контекстно-управляемой подсказки ....................... 251
 Резюме ........................................................ 256
ГЛАВА 8 ........................................................ 257
 Иcпользование данных в окнах .................................. 257
 Шаблон ввода данных ........................................... 259
 Поле ввода данных ............................................. 260
 Позиция ....................................................... 260
 Атрибуты ...................................................... 261
 Буфер ......................................................... 262
 Проверка допустимости значений ................................ 262
 Help-информация ............................................... 263
 Маска вводимых данных ......................................... 264
 Приглашения к вводу в поле (Prompts) .......................... 265
 Ввод данных ................................................... 265
 Функции сбора данных .......................................... 266
 Исходный текст: entry.c ....................................... 280
 Описание программы: entry.c ................................... 299
 Пример: Ввод данных в определенном порядке .................... 307
 Резюме ........................................................ 320
ГЛАВА 9 ........................................................ 321
 Оконный текстовый редактор .................................... 321
 Команды тестового редактора ................................... 324
 Управление курсором ........................................... 326

                             - 4 -
 Постраничная работа ........................................... 327
 Команды работы с блоками текста ............................... 328
 Команды редактирования ........................................ 330
 Функция, реализующая текстовый редактор ....................... 331
 Исходный листинг: editor.c .................................... 332
 Описание программы: editor.c .................................. 366
 Пример: Использование редактора ............................... 378
 Резюме ........................................................ 385
ГЛАВА 10 ....................................................... 386
 Оконные меню .................................................. 386
 Меню .......................................................... 387
 Процесс, образующий оконное меню .............................. 391
 Функции поддержки меню ........................................ 393
 Исходный листинг: tmenu.c ..................................... 397
 Описание программы: tmenu.c ................................... 403
 Пример оконного меню .......................................... 406
 Резюме ........................................................ 414
ГЛАВА 11 ....................................................... 416
 Резидентные программы ......................................... 417
 Прерывания .................................................... 422
 Векторы прерывания ............................................ 423
 Аппаратные прерывания ......................................... 424
 Программные прерывания ........................................ 425
 ДОС - однозадачная операционная система ....................... 425
 TSR-программы ................................................. 431
 Программы обработки прерываний ................................ 433
 Резидентные утилиты ........................................... 434
 Что может быть резидентным .................................... 435
 Построение TSR-программ ....................................... 440
 Превращение программы в резидентную ........................... 440
 Резидентна ли уже программа? .................................. 441
 Захват прерывания ............................................. 444
 Величина TSR-программы ........................................ 446
 Переключение контекстов ....................................... 452
 Стек .......................................................... 453
 Program Segment Prefix (PSP) .................................. 455
 Дисковый буфер ................................................ 471

                             - 5 -
 Прерывание от клавиатуры (9) .................................. 472
 Прерывание от таймера ......................................... 474
 Проблема реентерабельности ДОС ................................ 475
 Два стека ДОС ................................................. 476
 Системный флажок занятости (0х34) ............................. 478
 Прерывание DOSOK .............................................. 479
 Дисковое прерывание ROM-BIOS.(0х13) ........................... 481
 Прерывание ctrl-Break в ДОС (0x23) ............................ 484
 Выполнение TSR-программы ...................................... 485
 Завершение TSR-программы ...................................... 486
 Приостановка и возобновление выполнения TSR-программы ......... 490
 Выводы ........................................................ 491
 Построение резидентных программ ............................... 492
 Пример TSR-программы - "часы" ................................. 493
 Превращение программы в резидентную ........................... 493
 Прерывание по делению на ноль ................................. 494
 Выполнение обработчика прерываний от таймера .................. 497
 Связ─вание старого вектора прерывания по таймеру .............. 498
 Сохранение и переключение контекста стека ..................... 498
 Вычисление времени ............................................ 499
 Программы TSR-драйвера ........................................ 504
 Действия трех программных модулей ............................. 506
 Размер TSR-программы .......................................... 507
 Присвоение "горячего ключа" ................................... 508
 Сигнатура TSR-программы ....................................... 511
 Коммуникационные прерывания ................................... 513
 Подготовка к резидентности .................................... 516
 Обработчик обращения к диску .................................. 517
 Обработчик критических ситуаций ............................... 520
 Обработчик клавиатуры ......................................... 521
 Обработчик таймера ............................................ 522
 Обработчик DOSOK .............................................. 522
 Выполнение TSR-программы ...................................... 523
 Удаление TSR-программы ........................................ 524
 Блоки памяти и управляющие блоки памяти ....................... 526
 Исходные тексты: popup.c, resident.c .......................... 527
 TSR-программа - приложение .................................... 547

                             - 6 -
 Проверка TSR-программ ......................................... 549
 Выводы ........................................................ 552
ЭПИЛОГ.......................................................... 553



                             Предисловие
     -----------------------------------------------------------------

          Поскольку   вы  читаете   данную  книгу,   то,  вероятно, вы
     программируете  на  языке  Си  и  уже  приобрели  или собираетесь
     приобрести компилятор Турбо Си для  своей IBM PC.   При чтении от
     вас потребуется довольно хорошее знание языка Си,  а  также DOS -
     операционной системы  персональных ЭВМ (ПЭВМ) линии IBM PC - и ее
     функций.  Знание  языка ассемблера процессора 8086  и архитектуры
     IBM  PC  желательно,  но  не  обязательно.   В  книге  содержится
     множество исходных модулей  функций на языке  Си, которые помогут
     писать  программы,  работающие  с  окнами,  а  также  делать ваши
     программы резидентными в памяти.

          Программы,  работающие  с  окнами,  и  резидентные  в памяти
     программные  утилиты   составляют  в   настоящее  время  основное
     направление в программировании  для  IBM  PC.   По  своей природе
     персональная  ЭВМ является  настольной интерактивной (диалоговой)
     системой,  которая предоставляет   пользователю  доступ  к набору
     интерактивных  программ.    Аппаратура   и  операционная  система
     обеспечивают  возможность  разработки  программ,    работающих  с
     окнами и меню,  которые появляются на экране  по нажатию клавиши.
     Большинство пакетов программ,  пользующихся   в   настоящее время
     наибольшим  спросом у пользователей,   применяют хотя бы  одно из
     этих средств.  В данной книге разбираются  основы работы с ними и
     содержатся  исходные  тексты  функций на  языке  Си,  позволяющие
     использовать  эти средства   в   ваших программах.  Прочитав  эту
     книгу   и   разобрав содержащиеся в ней программы, а также освоив
     компилятор  Турбо Си  и основы  программирования на языке  Си, вы
     будете   готовы   создавать   резидентные   программные  утилиты,
     использующие окна для организации пользовательского интерфейса.

                             - 7 -

          Эта книга  содержит  сведения  о языках программирования,  о
     развитии программного обеспечения,  а также примеры использования
     языков    программирования    для     написания    интерактивных,
     экранно-ориентированных программ для ЭВМ.  Не следует думать, что
     перед вами очередная книга об IBM PC,  но образ этой персональной
     ЭВМ  постоянно  присутствует  здесь.   Если   прежде  акроним  РС
     обозначал определенную ЭВМ,  то теперь он  обозначает архитектуру
     ЭВМ,   которая  была  создана   промышленным  гигантом   и  стала
     общепризнанной.  РС в данной книге не является объектом изучения,

          В данной книге вы столкнетесь с программами,  написанными на
     языке  Си.   Это  замечательный  язык,  и  хотя  некоторым  он не
     нравится, но все же большинство программистов его любят. На Си вы
     можете создавать программы, которые делают все, что вы пожелаете.
     Нет другого  такого  языка,  который  бы  так  же  стимулировал к
     программированию.   Создается  впечатление,  что  остальные языки
     программирования   воздвигают   искусственные   препятствия   для
     творчества,  а  Си  -  нет.  Использование  этого языка позволяет
     сократить затраты времени на  создание  работающих  программ.  Си
     позволяет программировать быстро,  эффективно и предсказуемо. Еще
     одно  преимущество  Си  заключается  в  том,   что  он  позволяет
     использовать  все  возможности   вашей  ЭВМ.   Этот  язык  создан
     программистом для использования другими  программистами,   чего о
     других   языках   программирования   сказать  нельзя ............
     .................................................................
     .................................................................
     ...создан таким,  чтобы менеджеры могли разбираться  в написанных
     этом  языке программах;  Бэйсик был  создан  для непрограммистов;
     Фортран   -  для  научных  работников;   Ада  вообще  был  создан
     прямо-таки   правительственным  комитетом;    Пайлот  создан  для
     учителей;  Паскаль - для студентов;  Лого - для детей;  АПЛ - для
     марсиан;  Форт, Лисп и Пролог - специализированные языки. Один Си
     - это язык для программистов.

          Турбо Си,  о  котором идет  речь в этой книге,  - это пакет,
     который создает программную среду для  программирования на  языке

                             - 8 -
     Си и  является первым из компиляторов Си нового поколения.  Турбо
     Си содержит  редактор  с  возможностью  установки  его параметров
     пользователем,  построитель задач,  ориентированный на реализацию
     программного  проекта,   "быстрый"  компоновщик,  а  также  самый
     "быстрый"  компилятор   Си   для   РС,   которые   "погружены"  в
     интегрированную, оконно-ориентированную программную среду.  Турбо
     Си также предоставляет  возможность  работы с библиотекой функций
     и  расширениями  языка  Си,   что  обеспечивается  использованием
     вспомогательных   программ   обработки   прерываний    и   других
     резидентных  в  памяти  программ.  Такое  использование  законно,
     поскольку    Borland    International  -  создатель  Турбо  Си  -
     является  также основным  производителем  резидентных программных
     утилит.

          В этой книге содержатся исходные тексты функций,  которые вы
     можете  использовать  в  своих  программах,  работающих  в режиме
     интерактивного  взаимодействия   с  пользователем.  Использование
     этих функций  улучшит  пользовательский интерфейс ваших программ.
     Они  обеспечивают  возможности  работы  с  окнами,   меню,  ввода
     данных   по  установленному  шаблону,    оконного  редактирования
     текста,    а   также  создания   резидентных  программ,   которые
     вызываются нажатием определенных клавиш.

          Кроме  описания   этих   функций  в  книге  излагаются также
     аппаратные  и  программные  принципы,   которые  лежат  в  основе
     создания программ,  управляющих выводом изображений и резидентных
     программ.    Подробно    рассматриваются    система   прерываний,
     видеопамять,   а  также  внутренняя   организация  DOS,   включая
     множество  функций  DOS,   использование  которых  необходимо при
     создании резидентных программ,  но  по  которым  нет документации
     или,   наоборот,   которые    распространяются  разработчиками  и
     поставщиками DOS.


               Обзор разделов
     ------------------------------------------------------------------


                             - 9 -
          Глава     1     знакомит     с    концепцией  интерактивных,
     экранно-ориентированных    программных    систем,    в    которых
     организация  обмена  с  пользователем   так  же   важна,   как  и
     прикладное назначение программы.
          Глава 2 содержит основные сведения о языке Си.
          Глава 3 описывает  компилятор Турбо Си и его интегрированную
     среду.
          Глава 4  знакомит  с  первой  группой функций,  использующих
     особенности аппаратной архитектуры РС.
          Глава 5   объясняет  основные  принципы   работы  с  окнами,
     содержит общие сведения об архитектуре видеосистемы и  знакомит с
     проблемами, возникающими при создании окон в видеопамяти РС.
          Глава 6 представляет  читателю библиотеку функций для работы
     с  окнами.   Эти  функции  могут  применяться  в пользовательских
     программах для отображения различного  рода  информации,  а также
     быть основой   для создания  меню,   редакторов  и  функций ввода
     данных по  формату,  которые разбираются в  последующих разделах.
          Глава 6  содержит   также   несколько   примеров   программ,
     иллюстрирующих  использование  библиотеки  функций  для  работы с
     окнами.
          Глава 7  описывает контекстно-зависимые  информационные окна
     (Help)  и содержит  исходные  тексты  функций,   которые позволят
     реализовать эту возможность.
          Глава  8 знакомит с использованием окон для ввода  данных по
     формату;    управление  вводом  при   этом  осуществляется  путем
     определения набора полей для ввода данных   внутри  определенного
     окна.  Существуют  функции,  которые  позволяют  реализовать  эту
     возможность  в ваших программах.   В качестве  примера приводится
     программа диалогового ввода данных.
          Глава  9    содержит    функцию   редактирования   текстовой
     информации,  использующую  окна.  Описываемая   здесь   программа
     представляет собой текстовый редактор общего назначения для ввода
     и редактирования текстов свободного формата.  Он имеет  множество
     команд,   присущих   большим   системам   текстовой  обработки  и
     обеспечивающих     автоматическое     форматирование      текста,
     автоматический перенос слов, выделение и перемещение фрагментов и
     т.д.  Приводится также  текст  программы  интерактивной  записной

                             - 10 -
     книжки, в которой используется функция редактирования текста.
          Глава  10  знакомит с системами меню и содержит ряд функций,
     позволяющих создавать один из типов меню, который можно встретить
     в  серьезных программах:  строковое меню в заголовке окна,  выбор
     каждого из элементов которого вызывает  возникновение  на  экране
     нового  меню.  Для  иллюстрации  использования  такого  типа меню
     программные   модули  объединены  в   единую  программу,  которая
     позволяет с помощью меню выбрать нужный модуль.
          Глава  11   знакомит   с   основами  реализации  резидентных
     программ.  По  этой  проблеме  дается  исчерпывающая  информация.
     Приводятся  также разъяснения по тем функциям DOS,  по которым не
     поставляется документация:  какие из них  можно  использовать,  а
     каких    следует   избегать   и   почему.   Освещается   проблема
     реентерабельности DOS и способы  ее  решения.  Упоминается  также
     проблема   параллельно   выполняющихся   резидентных   утилит.  В
     заключение   обсуждаются   свойства   "однозадачности"   DOS    и
     объясняется,  почему  не  может  быть  обеспечена надежная защита
     резидентных в памяти программ.
          Глава 12  на примерах демонстрирует,  как можно использовать
     Турбо  Си  для создания  резидентных  программных  утилит. Первый
     пример   представляет  резидентную  в  памяти  утилиту  обработки
     прерываний по таймеру,  которая отображает текущее время в правом
     верхнем  углу  экрана.   Также  приведена  управляющая  программа
     общего назначения,  которая  позволит  Вам разрабатывать утилиты,
     тестировать  их в  качестве нерезидентных программ в  среде Турбо
     Си,   а затем компоновать  их в рабочие  резидентные модули.  Для
     иллюстрации   этого процесса   программа управления окнами и меню
     из главы  10  преобразуется  в  резидентную   программу,  которая
     выполняется при нажатии "горячей клавиши".

          Подводя итог,  можно  сказать,  что  данная  книга  содержит
     разъяснения и исходные тексты программ,  касающиеся двух наиболее
     популярных   свойств   программного   обеспечения   для   РС    -
     использования  окон  и  резидентности  программ.  Пользуясь этими
     инструментами и полными возможностями пакета Турбо Си, вы сможете
     повысить  свою  производительность  в  программировании,  а также
     сделать свои программы более  полезными  и  "дружественными"  для

                             - 11 -
     пользователя.

                                                     Ал. Стивенс
                                                     Сентябрь, 1987
                                                Меррит Айленд, Флорида



                             ГЛАВА 1
                             -------

                 Интерактивное программное обеспечение,
                 управляющее изображением на экране
     ------------------------------------------------------------------

          Большинство программ для PC,  пользующихся в настоящее время
     наибольшим спросом, рассчитаны на интерактивный режим работы, при
     котором  пользователь  обменивается  с  ЭВМ  сообщениями  в  виде
     последовательностей   нажатий клавиш на клавиатуре и  символов на
     экране дисплея. При этом программы вывода сообщений  пользователю
     широко используют  возможности  видеотерминала  РС.  Пользователь
     реагирует  на  это набором на  клавиатуре  соответствующих слов и
     чисел.  Такой способ общения  с ЭВМ стал  естественным для нового
     поколения  пользователей.    Он   подразумевает   развитие  стиля
     отображения   и   ввода информации   в  ЭВМ,   который называется
     "смотреть и чувствовать"  и постоянно используется  и развивается
     программистами.  Французский  язык,  Кобол,  код  Морзе  являются
     средствами общения,  для общения с ЭВМ также  нужен  язык.  Можно
     считать,   что каждая  новая программа является  новым языком или
     диалектом  уже существующего.  И поскольку в  данном  случае язык
     служит для взаимодействия с ЭВМ, то повышение  его  эффективности
     способствует более полному соответствию  намерений пользователя и
     действий ЭВМ.

          Эти языки,  как правило,  не разрабатываются  специально,  а
     возникают сами по себе в процессе создания программы. Программист
     озабочен  обычно  другими  проблемами:  средой  программирования,

                             - 12 -
     структурами   данных,  функциональными  алгоритмами,  интерфейсом
     пользователя.  После завершения разработки программы  программист
     вводит  в  нее  запросы  к  пользователю  и сообщения об ошибках.
     Качество пользовательского интерфейса программы зависит  от  воли
     программиста  и  наличия  программных  средств,  которые помогают
     разрабатывать пользовательский интерфейс.

          Программисты могут    использовать    множество    различных
     технологий  для  организации  обмена  между ПЭВМ и пользователем.
     Каждая из  этих  технологий  имеет  свои  области  применения,  в
     которых  она  более  предпочтительна,  чем  другие.  Но  все  эти
     технологии имеют одну общую цель:  они обеспечивают средства  для
     передачи  пользователю  предназначенной для него информации и для
     ввода информации им.

          Одна из  наиболее  простых  проблем,  с  которой  вы   могли
     сталкиваться в своей практике,  заключается в организации ввода и
     вывода алфавитно-цифровой информации.  Вы можете использовать для
     этой  цели  функции printf и scanf и этим ограничиться.  Если ЭВМ
     включает в свой состав консольный  терминал  с  клавиатурой  типа
     пишущей  машинки,  то  при  этих условиях почти любое программное
     обеспечение   может   считаться   обеспеченным   пользовательским
     интерфейсом.  Эта  технология была применима по той причине,  что
     ЭВМ  работали  под  управлением  операторов,   а   пользователями
     считались  те,  кто  записывал  данные на программных бланках,  а
     затем  читал  распечатки.  Теперь  же   ПЭВМ   стоит   на   столе
     пользователя,   поэтому   для   их   эффективного  взаимодействия
     пользовательский интерфейс должен быть более сложным,  чем ранее.
     Поскольку    сегодняшний    пользователь    ЭВМ    обычно   имеет
     профессиональные интересы,  выходящие за рамки  программирования,
     то  пользовательский интерфейс должен стимулировать эти интересы,
     а не сдерживать их.

          В интерактивной  системе  в  определенные  моменты   времени
     программа  выводит  пользователю  необходимую  ему  информацию  и
     запрашивает    информацию    у    пользователя    путем    выдачи
     соответствующей  подсказки.  Затем  программа должна находиться в

                             - 13 -
     состоянии ожидания,  пока пользователь не введет всю  необходимую
     информацию.  Если  программа  способна проверять на достоверность
     введенную информацию,  то после ввода  данных  пользователем  она
     может  либо продолжить свое выполнение,  либо выдать сообщение об
     ошибке и ожидать ввода новых значений данных.  Если  пользователь
     не  понимает,  что  от  него  требуется,  то он может запросить у
     программы  справочную  информацию.  Умная  программа  располагает
     множеством  полезных  сообщений,  которые  выдаются пользователю,
     если он запрашивает справочную информацию,  и разъясняют ему, что
     от него требуется.

          Форматы ввода   данных   могут  быть  различными,  поскольку
     существует много различных  классов  данных.  Эти  классы  данных
     могут  быть  в  общем случае разбиты на две категории:  команды и
     значения данных.

          Команда может быть простой,  как, например, нажатие одной из
     функциональных клавиш,  которая в  системах  текстовой  обработки
     обозначает   переход  к  новому  параграфу.   Команда  может быть
     сложной,  как,  например, загадочный набор букв, цифр и символов,
     что  характерно  для  многих  команд  MS-DOS.  Некоторые  команды
     запрашиваются  программой,   как,   например,  ввод ответов "Y" и
     "N",   когда ПЭВМ  переспрашивает,   действительно  ли  вы хотите
     того,   что  вы  от  нее  требуете.  Другие  команды  вводятся по
     инициативе  пользователя,  когда,  например,  вы  просите систему
     текстовой   обработки   сохранить  документ   в  дисковом  файле.
     Программа на ПЭВМ   не   ожидает  ввода именно этой команды,  но,
     тем не менее, принимает ее и выполняет то,  что от нее требуется.
     Иногда  программа может выводить  перечень  допустимых команд, из
     которого вы можете выбрать любую. Этот перечень называется меню.

          Значения данных в свою очередь можно разделить  на  элементы
     данных и текстовую информацию.  Элементами данных являются данные
     определенного формата и назначения. Это, например, значения даты,
     имена,  адреса,  числовые значения, размер одежды, оттенки цвета.
     Проверка достоверности вводимых данных для определенного элемента
     данных может быть произведена по соответствию их формата, длины и

                             - 14 -
     значения   этому  элементу  данных.   В  противоположность  этому
     текстовая информация  не  имеет определенного  формата,   длины и
     значения.  Системы  баз  данных  обычно  манипулируют  элементами
     данных,     а   системы    обработки   текстовой   информации   -
     соответственно текстовой информацией.

          Интерактивная система   должна   обладать   пользовательским
     интерфейсом,  который облегчает использование клавиатуры и экрана
     для  ввода  данных различного типа,  которые затем обрабатываются
     программой.  IBM  PC  имеет  такую  архитектуру  видеосистемы   и
     клавиатуры,   которая   обеспечивает   возможности  для  создания
     пользовательских интерфейсов различного типа, что уже реализовано
     во многих пакетах программ для IBM PC.

          Есть различные     способы    отображения    меню,    выдачи
     информационных сообщений, сообщений об ошибках и запросов на ввод
     данных.   Также  существуют  различные  способы  ввода  текстовой
     информации и значений данных,  поступающих от  пользователя.  При
     разработке языка взаимодействия с пользователем программист может
     выбирать   из   существующего   разнообразия   способов.    Выбор
     инструментальных  программных  средств будет оказывать влияние на
     конечный  программный  продукт.  Использование   инструментальных
     программных    средств,   обеспечивающих   эффективный   ввод   и
     отображение данных,  позволяет создавать эффективные  программные
     системы.

          Одним из  наиболее  популярных  в  настоящее  время способов
     организации взаимодействия  с  пользователем  является  работа  с
     окнами.  Окном называется,  как правило, прямоугольная область на
     экране  дисплея  с  видимой  границей,  изображение   в   которой
     формируется   независимо   от   остальной   части   экрана.  Окна
     используются для всех типов взаимодействия с  пользователем:  для
     отображения  меню,  в качестве областей для ввода значений данных
     или текстовой  информации,  для  вывода  сообщений  и  справочной
     информации по требованию пользователя.

          Другим важным  свойством  интерактивных систем,  существенно

                             - 15 -
     определяющим их качество,  является обеспечение для  пользователя
     возможности  быстро  переходить  от  одной  задачи  к  другой без
     утомительных  выходов в операционную  систему.  В интегрированной
     программной системе такого рода  переходы зачастую обеспечиваются
     операционной средой,   в которой исполняется  программа.  Однако,
     при увеличении  числа независимых задач,   для которых необходимо
     обеспечить  в  асинхронном  режиме  быстрый  переход   от   одной
     задачи   к другой,  возможности однозадачной операционной системы
     DOS для IBM PC могут быть превышены.  Для обеспечения возможности
     переключениязадач    в    этом    случае   должны  использоваться
     резидентные  в памятипрограммы.   Эти  программы  не обеспечивают
     настоящего  мультизадачного   режима,   но  позволяют  установить
     удобный для  пользователя режим использования  некоторых утилит в
     командной среде DOS.

          Программы из  этой  книги  образуют  библиотеку  программных
     инструментальных средств, использующих окна для ввода текстовых и
     числовых  данных,  выдачи  справочной  информации  пользователю и
     организации меню.  Эти программы могут быть сделаны резидентными.
     Программные модули библиотеки написаны для компилятора Турбо Си и
     предназначены для использования  программами,  также  написанными
     для  Турбо  Си.  Для  того  чтобы  использовать программы из этой
     книги,  вы должны  иметь  общее  представление  о  DOS  и  о  тех
     средствах,   которые  она  предоставляет  программисту.  В  книге
     разбираются вопросы внутренней организации DOS, а также некоторые
     из ее функций, обеспечивающие резидентность программ и по которым
     нет документации. Отличным справочным руководством по программным
     средствам  DOS  и  ROM-BIOS  является книга "Advanced MS-DOS" Рэя
     Дункана (Microsoft Press,  1986). Данная же книга содержит только
     сведения,   необходимые   для   изложения   вопросов,  касающихся
     предлагаемой   программистам   библиотеки.   Дункан   с   иронией
     представляет  свою  книгу,  как  нечто облегченное,  но вы должны
     отнестись к ней со всей серьезностью.

           Программное обеспечение   из   этой   книги   может    быть
     представлено в виде шести уровней,  как на рисунке 1.1. Уровни на
     диаграмме располагаются сверху вниз, но изложение материала будет

                             - 16 -
     соответствовать движению от нижних уровней к верхним.


                      ┌───────────────────┐
                      │                   │
      Уровень 1       │  TSR - драйвер    │
                      │                   │
                      └─────────┬─────────┘
                                │
                                │
                      ┌─────────┴──────────┐
      Уровень 2       │                    │
                      │  Загрузочный       │
                      │           модуль   │
                      │                    │
                      └─────────┬──────────┘
                                │
      Уровень 3                 │
           ┌──────────────┬───┬─┴─┬───┬────┬───┐
           │              │   │   │   │    │   │
         ┌─┴────────────┐ │   │   │   │    │   │
         │              │ │   │   │   │    │   │
         │  NOTEPAD     │ │   │   │   │    │   │
         │   ┌──────────┴─┴─┐ │   │   │    │   │
         └─┬─┤              │ │   │   │    │   │
           │ │ TEST MOVE    │ │   │   │    │   │
           │ │   ┌──────────┴─┴─┐ │   │    │   │
           │ └─┬─┤              │ │   │    │   │
           │   │ │ PROMOTE      │ │   │    │   │
           │   │ │   ┌──────────┴─┴─┐ │    │   │
           │   │ └─┬─┤              │ │    │   │
           │   │   │ │ FAST TEST    │ │    │   │
           │   │   │ │   ┌──────────┴─┴─┐  │   │
           │   │   │ └─┬─┤              │  │   │
           │   │   │   │ │ SAYINGS      │  │   │
           │   │   │   │ │   ┌──────────┴──┴┐  │
           │   │   │   │ └─┬─┤              │  │

                             - 17 -
           │   │   │   │   │ │ POETRY       │  │
           │   │   │   │   │ │   ┌──────────┴──┴─┐
           │   │   │   │   │ └─┬─┤               │
           │   │   │   │   │   │ │ ORDENT        │
           │   │   │   │   │   │ │               │
           │   │   │   │   │   │ └─────────────┬─┘
           └───┴───┴───┴───┴───┴──────┬────────┘
                                      │
      Уровень 4 ┌──────────────┬──────┴──────┬──────────────┐
           ┌────┴──────┐ ┌─────┴─────┐ ┌─────┴──────┐ ┌─────┴────┐
           │           │ │           │ │            │ │          │
           │ Справочнику │ Редактор  │ │   Меню     │ │   Ввод   │
           │           │ │           │ │            │ │          │
           └────┬──────┘ └─────┬─────┘ └──────┬─────┘ └─────┬────┘
                └──────────────┴───┬──────────┴─────────────┘
                                   │
                      ┌────────────┴────────────┐
      Уровень 5       │                         │
                      │  Функции  управления    │
                      │        окнами           │
                      │                         │
                      └────────────┬────────────┘
                                   │
                      ┌────────────┴─────────────┐
      Уровень 6       │  Функции  управления     │
                      │       аппаратурой        │
                      │         IBM PC           │
                      └──────────────────────────┘


               Рисунок 1.1. Уровни программного обеспечения.


          Уровень 6 представляет библиотеку  функций  нижнего  уровня,
     которые управляют определенными действиями IBM PC.

          Уровень 5  представляет  библиотеку  функций  для  работы  с

                             - 18 -
     окнами,  которые управляют размещением,  отображением на экране и
     сохранением в памяти экранных окон.

          Уровень 4  объединяет  функции,  которые используют окна для
     конкретных      применений.       Эти      функции      управляют
     контекстно-чувствительными  окнами  со   справочной  информацией,
     окнами редактирования текста,  системами меню и окнами  для ввода
     данных по формату.

          Уровень 3 соответствует прикладным программам  и представлен
     здесь   примерами  программ,  иллюстрирующих применение библиотек
     нижнего уровня.

          Уровень 2 представляет собой управляющую  программу, которая
     связывает   прикладные  программы  предыдущего  уровня  в  единую
     программу,  управляемую  с  помощью  меню.  Эта  программа  может
     работать  как автономно,  так и в качестве резидентной утилиты на
     последующем уровне программного обеспечения.

          Уровень  1  представляет  драйвер  TSR,   который  строит из
     транзитных  модулей  программы,   остающиеся  резидентными  после
     завершения выполнения.   В  данном  примере  он  используется для
     объединения   программ предыдущих  уровней  в  единую резидентную
     утилиту.

          Перед  тем   как  погрузиться   в  глубины  программирования
     модулей,   резидентных в памяти и работающих с окнами,  возможно,
     вам захочется почитать что-нибудь по языку Си.    Вы можете найти
     интересующие  вас сведения  в  данной  книге.  Раздел  2 содержит
     краткое изложение истории языка Си и  попытку объяснения,  почему
     же  программисты  так  любят  этот  язык.   Раздел  3  продолжает
     рассмотрение компилятора  Турбо  Си,  выбранного  для  изучения в
     данной книге.



                              ГЛАВА  2

                             - 19 -
                              --------

                              Язык Cи
     -----------------------------------------------------------------

          Любая книга  по  Си  превозносит  этот  язык  и рассказывает
     историю его создания.  Настоящий раздел следует этой традиции:  в
     нем   приводится  краткая  хронология  создания  Си,  описываются
     фундаментальные особенности языка,  рассказывается о достоинствах
     Си  как  инструмента  программирования,  а  также предпринимается
     попытка объяснить,  почему же он завоевал такое широкое признание
     среди программистов. В конце раздела содержится список справочных
     материалов для изучения языка Си.



                Краткая история языка Си
     -----------------------------------------------------------------

          Язык Си  был  создан  в  начале  70-х  годов Дэннисом Ритчи,
     который  работал  в   компании   Bell   Telephone   Laboratories.
     Родословная  языка Си берет свое начало от языка Алгол и включает
     в себя Паскаль и ПЛ/I.

          Си был  разработан  как язык для программирования в новой по
     тем временам операционной системе Unix.  ОС Unix была написана на
     языке  ассемблера для ЭВМ PDP-7 и перенесена затем на PDP-11.  На
     язык Си оказал значительное влияние его предшественник,  язык Би,
     созданный  Кэном  Томпсоном,   который  в  свою  очередь является
     последователем языка  BCPL.   Язык  ВСРL  был  создан  в  1969 г.
     Мартином  Ричардсом   в   рамках  проекта  "Комбинированный  язык
     программирования"  в Кэмбриджском университете в Лондоне.  Вскоре
     Unix  была переписана   на   языке   Си,  и  в 1974 - 75 годах OC
     Unix   фирмы   Bell  Laboratories  стала    первым   коммерческим
     продуктом,   реализующим идею  о том,   что  операционная система
     может быть успешно написана  на языке высокого уровня,  если этот
     язык является достаточно мощным и гибким.

                             - 20 -

          В 1978  г.  Брайан  Керниган  и  Дэннис Ритчи написали книгу
     "Язык  программирования  Си"  (издательство  Prentice-Hаll).  Эта
     работа, которая в своем кругу называлась "белой книгой" и "K & R"
     в остальном мире,  стала стандартом описания языка  Си. На момент
     создания   "K  &  R"  существовали компиляторы языка  Си  для ЭВМ
     PDP-11,  Interdata 8/32,  Honeywell 6000 и IBM 370.  В дальнейшем
     этот список был продолжен.

          В конце  70-х  начали появляться трансляторы Си для микроЭВМ
     на процессорах 8080  и Z80  с  операционной  системой СР/M. Скотт
     Газери   и Джим  Гибсон  разработали и пустили  в  продажу Тiny-C
     ("Крошечный  Си")  -  интерпретатор,  основанный  на подмножестве
     языка Си.  Его  интерактивная среда программирования очень похожа
     на ту,  что  имеет чрезвычайно популярный  транслятор Basic фирмы
     Microsoft.  В 1980  г.   Рон Кэйн создал  свой компилятор Small-C
     ("Малый Си")  для  ОС  СР/М  и  микропроцессора  8080. Компилятор
     Small-C,  основанный  на  подмножестве  языка Си,  был написан на
     самом Small-C.  Проблема  курицы  и яйца была решена,  когда Кэйн
     создал первую версию компилятора на основе интерпретатора Тiny-C.
     Затем Small-C методом раскрутки создал  самого  себя,  когда Кэйн
     вместе с  другими,  используя ранние  версии компилятора,  сделал

     более совершенный компилятор. Small-C компилирует исходный модуль
     на  языке  Си  в  модуль  на  языке  ассемблера  процессора 8080.
     Следует  отметить,  что  Кэйн  предоставил свой  компилятор и его
     исходный текст в общественную собственность.

          Примерно в  это  же  время  Лео   Золман   представил   свой
     компилятор BDS-C для СР/М, также основанный на подмножестве языка
     Си.  Достоинствами этого  компилятора  были  высокая  скорость  и
     возможность  совместной компоновки перемещаемых объектных модулей
     в загрузочном модуле.

          Вскоре после BDS-C были созданы компиляторы, предназначенные
     для  СР/М  и основанные на полном  множестве языка Си.   Это дало
     импульс   развитию   программирования на Си для микроЭВМ.  В 1981

                             - 21 -
     г.,  в связи с созданием  IBM  PC,  в  мире  микроЭВМ  был сделан
     значительный скачок вперед.

          После появления IBM PC стали появляться и компиляторы Си для
     этой   ПЭВМ.    Некоторые   компиляторы   были   получены   путем
     преобразования соответствующих компиляторов для  процессора 8080,
     другие  были  разработаны специально  для  IBM  PC.   В настоящее
     время    на    рынке  представлены  по  меньшей  мере  семнадцать
     компиляторов языка Си для IBM PC.

          В   1983 г.   Американский    Институт   Стандартов   (ANSI)
     сформировал   Технический   Комитет   X3J11,    устав    которого
     предусматривает создание стандарта языка Си. Стандартизация будет
     распространяться не только на язык,  но и  на  программную  среду
     компилятора,  а также на библиотеку стандартных функций. В работе
     комитета участвуют  представители  основных  фирм  -  поставщиков
     компиляторов Си,  в том числе и для IBM PC, а также многие другие
     светила из мира программирования на  языке  Си.  Усилия  комитета
     X3J11    привлекли    внимание   средств   массовой   информации.
     Предлагаемый  стандарт  был  опубликован,  для  того  чтобы   все
     заинтересованные  стороны  могли ознакомиться с ним и внести свои
     предложения.    (Сомнительно,    что    выдающийся    программист
     заинтересуется  языком,  который  создан комитетом,  но,  видимо,
     комитет  делает  хорошее  дело,  совершенствуя  язык,   созданный
     выдающимся программистом).

          Поскольку большинство  поставщиков  компиляторов  для IBM PC
     участвуют в работе комитета X3J11,  то разрабатываемые ими  новые
     версии  компиляторов  будут в рамках этого стандарта.  (Турбо Си,
     один   из  последних   компиляторов  для   IBM  PC,   подчиняется
     большинству требований стандарта на язык и библиотеку).



                Особенности языка Си
     -----------------------------------------------------------------


                             - 22 -
          В данной  книге не ставится цель научить вас программировать
     на  языке Си,  но  она  может  быть  полезной  для  понимания тех
     особенностей  Си,   которые заставляют столь многих программистов
     остановить свой выбор именно на этом языке.

          Си является   языком   функций,   типов  данных,  операторов
     присваивания   и   управления   последовательностью   вычислений.
     Программируя  на  Си,  вы  осуществляете обращение к функциям,  и
     большинство  функций  возвращают  некоторые  значения.  Значение,
     возвращаемое функцией, будь то значение переменной или константа,
     может использоваться в операторе присваивания,  который  изменяет
     значение  другой  переменной.  Дополненный операторами управления
     последовательностью  вычислений  (while,  for,  do,  switch),  Си
     превращается  в  язык  высокого  уровня,  способствующий хорошему
     стилю программирования.

          Си имеет небольшой набор типов данных:  целые числа, числа с
     плавающей запятой, битовые поля и перечислимый тип. В языке Си вы
     можете описать переменную типа указатель,  который связывается  с
     объектом, принадлежащим к любому типу данных. Адресная арифметика
     языка Си является чувствительной к типу данных  того  объекта,  с
     которым связан используемый указатель.  Разрешены также указатели
     к  функциям.   Вы  можете  расширить  список  типов  данных путем
     создания   структур  с иерархической зависимостью входящих в него
     типов  данных.   Каждый  тип  данных  может  принадлежать  либо к
     основному  типу,   либо  к  ранее  описанному  структурному типу.
     Объединения  напоминают структуры,   но определяют различные виды
     иерархических   зависимостей,   в  которых  данные  разных  типов
     располагаются в памяти.

          Допустимо описание  массивов данных различных типов, включая
     структуры и объединения. Массивы могут быть многомерными.

          Функции Си являются рекурсивными по  умолчанию.  Вы  можете,
     правда,  создать  функцию,  которая не будет рекурсивной,  но сам
     язык по  своей  природе  стремится  поддерживать  рекурсивность и
     требует минимальных усилий при программировании рекурсий.

                             - 23 -

          Программа функции на языке Си разбивается на блоки, в каждом
     из  которых  могут  быть  определены  свои  собственные локальные
     переменные.  Блоки  могут выбираться для исполнения по результату
     выполнения      оператора      управления     последовательностью
     вычислений. Блоки могут быть вложенными друг в друга.

          Переменные и  функции  могут быть глобальными для программы,
     глобальными для исходного модуля  или  локальными  для  блока,  в
     котором они описаны.   Локальные  переменные  могут  быть описаны
     таким образом,  что они будут сохранять  свои  значения  при всех
     обращениях   внутри   данного блока (статические переменные)  или
     же  будут восприниматься  как новые объекты при  каждом обращении
     (автоматические переменные).

          Си позволяет  создавать программу в виде нескольких исходных
     модулей,  которые будут транслироваться независимо.  Перемещаемые
     объектные модули, соответствующие исходным модулям, компонуются в
     единый загрузочный модуль.  Эта особенность позволяет компилятору
     поддерживать    объектные   библиотеки  многократно  используемых
     функций  и создавать  большие  программы  из  множества небольших
     исходных модулей.

          В языке Си  нет  операторов  ввода/вывода,  весь  ввод/вывод
     выполняется с помощью функций.  Вследствие этой особенности языка
     Си  разработана  стандартная  библиотека  функций.  Существование
     этого  стандарта и составляет главную привлекательность языка Си,
     ибо делает программы на Си переносимыми.



                Достоинства языка Си
     -----------------------------------------------------------------

          Переносимость программ,  написанных на Си, является наиболее
     разрекламированным преимуществом  этого  языка.  Если  вы  пишете
     программу  на  Си  и  избегаете  при этом использовать расширения

                             - 24 -
     библиотеки,   зависящие   от   конкретного    компилятора,    или
     машинно-зависимые   операции,  то  вы  получаете  неплохие  шансы
     (значительно большие,  чем при любом другом  языке)  на  успешный
     перенос  вашей  программы  в  другую программно-аппаратную среду,
     включая смену компилятора, операционной системы и ЭВМ.

          Приведенные в  данной  книге  программы  не  претендуют   на
     переносимость. Библиотека функций для работы с окнами привязана к
     архитектуре видеопамяти IBM PC,  а функции резидентных  в  памяти
     утилит   используют  систему  прерываний  IBM  PC,  специфические
     особенности DOS и библиотеку  расширений  компилятора  Турбо  Си,
     которая   облегчает  разработку  программ  обработки  прерываний.
     Некоторые  функции  включают   небольшие   фрагменты   на   языке
     ассемблера.

          Расширяемость языков программирования означает существование
     потенциальной возможности внести добавления в язык.  Си рассчитан
     на  расширение  по  своему  замыслу,   поскольку  содержит  очень
     небольшое   число   операторов.   Следует помнить,   что сам язык
     позволяет  немногим  более,  чем изменять  значения  переменных и
     управлять последовательностью выполнения программы.  Самое важное
     в программах на Си заключено в функциях,   а язык сам  по себе не
     имеет  другие внутренние функции, кроме основной функции (функции
     main).   Первая  группа  расширений   языка   Си   размещается  в
     стандартной   библиотеке,    другие    нестандартные   расширения
     поддерживает конкретный  компилятор  и,   наконец,  третья группа
     расширений содержится  в   дополнительных  библиотеках функций Си
     (как это описано в  данной  книге).  Последняя  группа расширений
     разрабатывается   самим программистом,  который создает программы
     для многократного использования.

          Кроме своей   функциональной   расширяемости,  Си  позволяет
     расширять  стандартный  набор  типов  данных  путем   определения
     структур, объединений и использования операторов typedef.

          Программистам особенно    нравится    краткость   выражений,
     которыми в Си кодируются алгоритмы.  Большинство операторов, будь

                             - 25 -
     то   операторы  присваивания,  условные  операторы,  обращения  к
     функциям   или    выражения,    кроме    операторов    управления
     последовательностью  выполнения  программы,  возвращают некоторые
     значения.  Использование   этой   особенности   языка   позволяет
     представлять выражения в краткой форме.

          Си обеспечивает  формирование  эффективного  машинного  кода
     программы,  что достигается привязкой языков  программирования  к
     структуре  памяти и регистровой архитектуре ЭВМ,  для которых они
     создаются.    Си  часто  характеризуется  как   переносимый  язык
     ассемблера   высокого   уровня.   Сама  природа  языка  позволяет
     компилятору  генерировать  эффективный  оптимизированный машинный
     код.


          Брайан В.,  Керниган, Ритчи Деннис М.. Язык программирования
     Си. - Prentiсe-Hall, 1978.

          Плам Томас.     Стандарты     и     руководящие     принципы
     программирования на Си. - Plum-Hall, 1982.

          Плам Томас. Изучение программирования  на  Си. -  Pluм Hall,
     1983.

          Кочан Стефен  Г.  Программирование  на  Си.  -  Hayden  Book
     Cомpany, 1983.

          Пардам Джек.  Руководство по программированию на Си.  -  Que
     Corporation, 1983.

          Харбисон Самюэл,  Стил  Гай  Л.  Си:  справочное пособие.  -
     Jr.Таrtan Laboratories, 1984.

          Хоган Том.  Руководство   для   программистов   по   Си.   -
     Brady,1984.

          Хант Вильям  Джеймс. Набор инструментальных средств на Си. -

                             - 26 -
     Аddison-Wеsly, 1985.

          Плам Томас. Структуры данных в Си. - Plum Hall, 1985.

          Компилятор МIX C. - Mix Software, Inc, 1985.
          (Этот  материал продается вместе с  компилятором и отдельной
     книгой.   Независимо   от того,   используете  вы  компилятор или
     нет,   руководство и  справочное  пособие  по  Си  будут  для вас
     полезны).

          Газери Скотт Б. Изучение Си и Тiny-C. - Таb Books, 1985.

          Рэдклифф Роберт А.,  Рааб Томас Д.  Утилиты обработки данных
     на Си. - Sybex, 1986.

          Стивенс Ал.  Разработка  инструментальных  средств на Си для
     IBM PC. - Brady, 1986.

          Пособие по инструментальным средствам  Си  доктора  Добса. -
     Brady, 1986.

          Стивенс Ал. Разработка баз  данных на Си. - МIS:Press,1987.

          Джонсон Нельсон.    Усовершенствованная   графика   на   Си:
     программирование и методы. - Оsborne McGrow-Hill, 1987.

          "Наставник по  Си"  дискеты  #577  и #578 библиотеки PC-SIG
     (Этот пакет программ представляет собой  обучающую  интерактивную
     систему,   содержащую  текстовую информацию  и  примеры программ,
     которые вы можете транслировать с помощью своего транслятора).



                             ГЛАВА 3
                             -------



                             - 27 -
                        Компилятор Турбо Си
     -----------------------------------------------------------------

          В декабре 1986 г.  небольшая компания под  названием  Wigard
     Software   Systems,   Inc.   объявила о своем  переезде из гopoда
     Армингтон,   штат   Массачусетс,   в  город  Монте  Серено,  штат
     Калифорния.  Эта   компания  создала и начала продажу компилятора
     Си стоимостью 450 долларов под названием Wizard C.

          Wizard C был компилятором,  заслуживающим  уважения,  всегда
     получающим хорошие отзывы в обзорах и даже названный,  по крайней
     мере  одним  из  обозревателей,  "лучшим"  компилятором  Си.  Его
     достоинства   заключались   в    высокой   скорости   компиляции,
     эффективной    оптимизации   получаемого    кода,    соответствии
     предложениям   стандарта АNSI  и большом числе  расширений языка,
     позволяющих разрабатывать  программы  обработки  прерываний.  Эти
     расширения  заключали в   себе  функцию   прерывания специального
     типа,   возможность встраивания в  тело  программы  фрагментов на
     языке   ассемблера,  псевдопеременные,  с   помощью   которых  из
     языка Си выполняется доступ к регистрам микропроцессора.

          В феврале   1987   г.   фирма   Borland   International   из
     Скоттс-Веллей,  штат Калифорния,  объявила о создании компилятора
     Турбо Си,  который ожидался с  нетерпением  после  появления  его
     предшественника,   очень   удачного   компилятора   ТурбоПаскаль.
     Объявление содержало оценку эффективности, заверенную несколькими
     экспертами.  Они  утверждали,  что  скорость  компиляции Турбо Си
     будет достигать 7000  строк  в  минуту,  что  превышало  скорость
     самого  быстрого на то время компилятора Си.  По мнению экспертов
     было  достигнуто  предельное  значение   производительности   для
     компиляторов  Си  и  не ожидалось появление компилятора,  который
     превзошел бы это значение.

          В том  же месяце Wizard сделала своe последнee объявление. В
     мае 1987 г. появилась версия 1.0 Турбо Си (совместно с T-shirts).
     Перчатка была брошена и соревнование объявлено.  Турбо Си подавил
     всех своими характеристиками.

                             - 28 -

          На самом деле фирма Вorland  International  приобрела  фирму
     Wigard Systems для того,  чтобы создать Турбо Си.  Промышленность
     делала  предположения  о  том,   когда  Borland  выйдет  на рынок
     компиляторов   Си,   после   того,   как она уже представила свои
     изделия:  Турбо-Паскаль,   а  вслед  за  ним   очень   популярный
     Турбо-Бейсик.  Вместо того,   чтобы предпринимать большие усилия,
     начиная с нуля, фирма Borland приняла мудрое решение:  она купила
     лучший компилятор   Си   и сконцентрировала усилия на том,  чтобы
     сделать его еще лучше.

          На момент анонсирования фирмой Borland своего компилятора на
     рынке было представлено 17 компиляторов Си для IBM  PC. Несколько
     человек решили,  что миру нужен еще один. Таковы краткие сведения
     о фирме Borland International Филиппа Кана,  которые тем не менее
     приковывают    внимание    и   захватывают   воображение.   После
     опубликования информации о Турбо Си многие  сомневались, немногие
     имели   представление   о   нем,   но  все  жаждали  увидеть  его
     собственными  глазами.  Мир  Си  готов  был  принять   еще   один
     компилятор,  при  условии,  что он поступит от Вorland.  Само это
     состояние ожидания имело очень большое  значение.  Фирма  Borland
     начала  дело не для того,  чтобы создать очередной компилятор Си;
     Borland поставила целью изменить представления о том,  как должна
     выглядеть  программная среда для разработки программ на языке Си.



                Два Турбо Си
     -----------------------------------------------------------------

          Турбо Си обозначает два программных изделия: пакет программ,
     обеспечивающий выполнение последовательности команд в стиле Unix:
     make/compiler/linker,  и  интегрированную  программную  среду для
     разработки программ.

          Пакет программ  содержит  утилиту  make,  компилятор  tcc  и
     настраиваемый компоновщик.  Последующие версии  несомненно  будут

                             - 29 -
     включать  объектную  библиотеку.  Компилятор,  входящий  в пакет,
     похож на большинство  других  компиляторов  Си  для  IBM  PC,  но
     является  более  быстрым.  Программисты,  которые предпочтут этот
     пакет Турбо  Си,  найдут  все,  что  им  нужно,  включая  удобный
     редактор.  Поскольку вы приобрели эту книгу, то, вероятно, вы уже
     имеете или собираетесь приобрести Турбо Си.  Все,  что Вам  нужно
     знать  по  этому пакету,  содержится в руководстве пользователя и
     справочном руководстве.

          Интегрированная программная   среда    представляет    собой
     программу  под названием tc,  которая объединяет в себе текстовый
     редактор,  ориентированный на создание текстов программ на  языке
     Си, построитель задач, ориентированный на реализацию программного
     проекта,  и утилиты исполнения программ.  В  будущем  планируется
     включение  символьного  отладчика.  Наличие интегрированной среды
     выделяет Турбо Си среди конкурентов (также,  как и ее  безусловно
     блестящая реализация).

          Интегрированную среду  можно  считать витриной Турбо Си.  Ее
     большим  достоинством  является  достигнутый  уровень  интеграции
     между  редактором,   компилятором  и  компоновщиком.  Находясь  в
     интегрированной среде, программист может редактировать программу,
     транслировать    ее,   компоновать   ее   с   другими   исходными
     модулями  и  библиотеками  и  запускать  на  выполнение.   Данное
     качество является основным для нового поколения  компиляторов Си.
     Это  похоже  на  то,  чего фирма  Borland  достигла  тремя годами
     раньше    на   компиляторе  Турбо-Паскаль,   но   чего   не  было
     достигнуто до этого времени на  компиляторе Си.   Ожидается,  что
     основные  конкуренты  в   ближайшем  будущем  достигнут подобного
     уровня.



                Настройка интегрированной среды
     -----------------------------------------------------------------

          Вы имеете  возможность  настроить  интегрированную среду,  в

                             - 30 -
     которой все, от цвета изображения на экране до уровня контроля за
     ошибками,  может быть установлено по вашему требованию. Некоторые
     установки производятся при выполнении программы TCINST,  другие -
     путем  использования  меню,  создаваемых  интерактивной  системой
     ввода интегрированной среды и возникающих в верхней части экрана.
     Ниже   приводится   список  параметров,  значения  которых  могут
     устанавливаться по требованию заказчика:

      - модель памяти: крошечная, малая, средняя, компактная, большая,
        огромная;
      - соглашение о вызываемых функциях: Си или Паскаль;
      - микропроцессор: 8088/8086 или 80186/80286;
      - плавающая арифметика: отсутствует, сопроцессор или эмуляция;
      - уровень оптимизации;
      - уровень контроля за ошибками.

          Вы можете выбирать и  большее  число  параметров  Турбо  Си.
     Турбо  Си  способен  осуществлять  строгий контроль за ошибками и
     подозрительными местами в программе  и  выдавать  предупреждающие
     сообщения.   Вы   можете   использовать   Устанавочное  Меню  для
     подавления  предупреждающих  сообщений.  Вы   можете   установить
     необходимость  соответствия  жестким  требованиям  ANSI или менее
     жестким требованиям стандарта,  изложенного в книге " K & R".  Вы
     можете  потребовать  выдачи  предупреждающего сообщения при любом
     несоответствии описания функции и прототипа или  можете разрешить
     неявное  описание функции и определение случайных параметров, как
     это делается в так называемых K & R-компиляторах.

          Возможно, вам  захочется  изменить  цвета   изображений   на
     экране.  Вы можете выбрать один из трех цветовых наборов, включая
     цветовой набор  по  умолчанию  (слишком  ярок),  бирюзовый  набор
     (неприятен) или малиновый набор (просто ужасен). Не отчаивайтесь,
     программа TCINST позволит выбрать  цвет  и  яркость  для  каждого
     отдельно  определяемого компонента интегрированной среды. Следует
     помнить,  что в данном обзоре имеются  в  виду  цветовые  наборы,
     формируемые   системой  СGA.  Вполне  возможно,  что  они  вам  и
     нравятся.

                             - 31 -



                Редактор Турбо Си
     -----------------------------------------------------------------

          В первом приближении редактор Турбо  Си  похож  на  редактор
     системы  WordStar,  работающий в режиме,  альтернативном к режиму
     "документ".  Архитектура этого редактора  характерна  для  многих
     других  программных  изделий Borland,  включая программу Sidekick
     Notepad и редактор  Турбо-Паскаля.   Eсли  вы  умеете  работать с
     редактором Турбо-Паскаля,  то  вы умеете работать  и с редактором
     Турбо  Си.  Однако в случае  приобретения  именно этого редактора
     пользователи      получат     некоторые    преимущества.    Путем
     использования программы TCINST вы можете изменить размер окна  по
     умолчанию     и   назначение    клавиш   команд   редактирования.
     Программисты,   которые  раньше  работали  с  другим  редактором,
     оценят   предоставляемую   им редактором   Турбо  Си  возможность
     работы с  двумя  наборами  команд  редактирования,  что позволяет
     избежать  многих  затруднений.   Диапазон   изменения  параметров
     редактора  ограничен:    определенные  функциональные  клавиши  и
     комбинации различных клавиш с  клавишей  АLT зарезервированы  под
     "горячие клавиши"  и  не  могут  быть  задействованы  под команды
     редактирования.

          Редактор Турбо Си не такой мощный, как некоторые специальные
     программы  редактирования,  но  вполне  отвечает  требованиям  не
     слишком  больших   задач   по  редактированию.    Редактор  имеет
     неизменяемое   значение   интервала   для    клавиши   табуляции,
     соответствующее  восьми символьным промежуткам.  Это неудобно при
     работе с исходными  текстами  программ,  представленных  в данной
     книге,  так  как  их  интервалы  табуляции  соответствуют четырем
     символьным    промежуткам,   что  обусловлено  ограничениями  при
     печати.  Borland  поставляет  программу   PATCH.COM  и  несколько
     примеров    "заплат"   на   программы Compuserve  и BIX.  Один из
     этих  примеров  позволяет   вам   поставить  "заплату",   которая
     устанавливает   интервал    табуляции    на    четыре  символьных

                             - 32 -
     промежутка,   в   результате   чего   редактор  становится  очень
     удобным  для  программ  из  этой  книги.   Возможность  изменения
     интервала  табуляции,  вероятно,  будет предусмотрена в следующей
     реализации Турбо Си.



                Компоновщик Турбо Си
     -----------------------------------------------------------------

          Турбо Си  имеет  свой   собственный   компоновщик,   который
     называется   TLINK.   Компоновщик   используется  для  связывания
     различных объектных модулей, каждый из которых может быть получен
     путем  трансляции  с  языков  Си,  ассемблера  и  других в единый
     загрузочный  модуль.  Объектные  файлы,  формируемые  Турбо   Си,
     соответствуют  стандарту  программы  LINK DOS,  поэтому они могут
     быть скомпонованы с объектными библиотеками  для  других  языков,
     включая  ассемблер.  Основной причиной использования компоновщика
     TLINK является его скорость, поскольку TLINK работает значительно
     быстрее, чем компоновщик LINK DOS.



                Утилита построителя задач (Make) в Турбо Си
     -----------------------------------------------------------------

          Компилятор Турбо  Си имеет утилиту Make,  характерную для ОС
     Unix и других компиляторов Си для IBM PC.  Интегрированная  Среда
     дает уникальную  возможность  связывать  при  разработке программ
     исходные и объектные модули  с  соответствующими  им загрузочными
     модулями.   В  этом  отношении  утилита  Make  Турбо  Си является
     традиционной.    Однако    утилита   Make   Турбо   Си   является
     частью  интегрированной среды  и  использует  файл сопровождения,
     называемый "файлом  проекта",   который является более легким для
     чтения и понимания, чем у командной утилиты MAKE. В файле проекта
     перечисляются исходные модули,  составляющие программу, по одному
     в каждой  строке.  Справа от  имени каждого модуля  можно указать

                             - 33 -
     другие файлы (например,  заголовки),  с которыми связаны исходные
     модули.   Эти файлы   заключаются   в скобки и отделяются друг от
     друга запятыми. Ниже приводится пример записи файла проекта:

              myprogram (keys.h, twindow.h)

          Если версия  модуля   myprogram.c   старше   версии   модуля
     myprogram.obj   либо  версии  модулей  key.h или twindow.h старше
     версии модуля myprogram.c,  то модуль myprogram.c транслируется в
     модуль  myprogram.obj.  Если  версия  модуля myprogram.obj старше
     версии модуля myprogram.exe,  то модуль myprogram.obj компонуется
     с  соответствующими  (зависящими  от   модели  памяти)  начальным
     объектным  файлом  и   исполняющей   библиотекой.   Использование
     проектной утилиты Make становится насущно  необходимым, когда при
     формировании  загрузочного  модуля   используются  многочисленные
     исходные  модули на Си, зависящие от различных файлов заголовков.

          Вы можете указывать объектные файлы и объектные библиотеки в
     проектном  файле  MAKE.   Интегрированная  cреда  будет  включать
     объектные файлы без  попытки  их  компиляции  и  будет отыскивать
     соответствующие  библиотечные  модули   для   разрешения  вызовов
     внешних  функций.



                Обнаружение ошибок при компиляции и компоновке
     -----------------------------------------------------------------

          При построении  задачи  в  интегрированной  среде  Турбо  Си
     производится запись всех сообщений об ошибках  и предупреждениях.
     После   завершения  построения  задачи  сообщения  об  ошибках  и
     предупреждениях выводятся в одно окно,  в то время,  как исходный
     текст программы отображается в другом окне. Вы имеете возможность
     перемещаться по файлу  с  исходным  текстом  программы  вперед  и
     назад, от одной ошибки к другой. Интегрированная среда отображает
     каждое сообщение об ошибке и устанавливает  курсор  в  строке,  в
     которой  ошибка  была  обнаружена.  Вы можете внести исправления,

                             - 34 -
     какие считаете нужными,  и  снова  запустить  процесс  построения
     задачи.  Программа обнаружения ошибок следит за тем, удаляете или
     добавляете вы строки в исходном модуле, и соответствующим образом
     корректирует положение курсора.


                Программные средства низкого уровня
     -----------------------------------------------------------------

          Турбо Си  включает  несколько  расширений   языка   Си,   не
     обладающих  свойством  мобильности,  доставшиеся  в наследство от
     Wizard, но которые являются весьма существенными для программного
     обеспечения,  представленного  в  данной  книге.  Эти  расширения
     содержат программы обработки прерываний и других операций низкого
     уровня.

          Расширения языка   включают  функцию  типа  прерывание,  при
     вызове которой производится сохранение регистров  процессора 8086
     и  установка регистра сегмента данных на значение сегмента данных
     для  функции  прерывания.  Перед  тем,  как  функция   возвращает
     управление    вызывающей    программе,    содержимое    регистров
     восстанавливается.  Возврат осуществляется с помощью команды IRET
     процессора 8086, которая используется для возврата из прерываний.

          При включении  в  программу  на  Си фрагментов на ассемблере
     используется ключевое слово asm.  Все,  что следует  после  этого
     ключевого   слова,   поступает   непосредственно   на   обработку
     транслятором с ассемблера  фирмы  Microsoft,  который  вы  должны
     иметь,   чтобы   использовать   данную   возможность.  Включаемые
     ассемблерные фрагменты могут  использовать  имена  переменных  из
     программы  на  Си.  Эта  возможность  позволит  писать функции на
     ассемблере,  которые не будут  зависеть  от  используемой  модели
     памяти.  Программы  без  ассемблерных  фрагментов не подвергаются
     обработке транслятором с  ассемблера,  а  только  компилятором  с
     языка   Си.   Программа   с   ассемблерными   фрагментами  должна
     компилироваться обязательно командным компилятором tcc, поскольку
     компилятор  tc  интегрированной  среды не допускает использования

                             - 35 -
     ассемблерных  фрагментов.  Фирма  Воrland  планирует  убрать  это
     ограничение в последующих реализациях.

          Несколько ключевых     слов    используется    в    качестве
     псевдопеременных для осуществления  непосредственного  доступа  к
     регистрам ЭВМ. Если вам известно, что содержат регистры и как это
     можно  использовать,  то  вы  можете  оптимизировать   выполнение
     некоторых  операций.  Будьте  внимательны при использовании этого
     средства.  Наилучшим  подходом   является   трансляция   исходной
     программы   на   Си  в  модуль  на  ассемблере  (что  достигается
     использованием ключа -S в командной строке  компилятора  tcc),  а
     затем  внесение  изменений  в полученный модуль.  При переходе на
     следующие  версии  Турбо  Си  вы  должны  проверить   возможность
     использования  каждого  из  описанных средств.  Нет уверенности в
     том,  что Borland не изменит способ доступа к  регистрам,  и  это
     изменение может сделать ваши программы неработоспособными.



                Начальная установка
     -----------------------------------------------------------------

          Самым слабым местом документации по Турбо Си является раздел
     по  начальной установке.   Есть ряд  фактов,  которые обязательно
     необходимо  знать,    а  структура  руководства  такова,  что  не
     позволяет легко найти нужную информацию.

          И командный компилятор,  и интегрированная среда  используют
     специальные файлы, в которых пользователь описывает требуемую ему
     конфигурацию.  Каждому из компиляторов соответствует  свой  файл.
     Руководство    дает  подробные  инструкции  по  подготовке  файла
     конфигурации   TURBOC.CFG  для  командного   компилятора  и  явно
     недостаточную   информацию  по файлу конфигурации TCCONFIG.TC для
     интегрированной  среды.   После того,  как вы произвели начальные
     установки в интегрированной  среде,  вы  должны запустить процесс
     инсталляции  еще  раз   и  установить   значения  параметров   по
     умолчанию,   включая  путь  доступа,   по которому  компилятор tc

                             - 36 -
     будет искать библиотеки,  стартовую программу, включаемые файлы и
     себя самого.

          Эти параметры    могут    быть    установлены    также    из
     интегрированной  среды  путем  выбора  меню Options (Параметров).
     После установки всех параметров такими, как вы хотели, выберите в
     меню  строку  "Запомнить",  завершая  тем  самым  создание  файла
     TCCONFIG.TC.



                Модели памяти
     -----------------------------------------------------------------

          Турбо Си   поддерживает  шесть  моделей  памяти:  крошечную,
     малую,  среднюю,  компактную,  большую  и  огромную.  Руководство
     пользователя   содержит  раздел,  посвященный  моделям  памяти  и
     разъясняющий сегментную организацию памяти для процессора  8086 и
     ее проявления в различных моделях памяти.  Советуем вам прочитать
     и  осмыслить  этот  раздел,   поскольку   понимание   архитектуры
     процессора    8086   позволит   использовать   и   модифицировать
     резидентные в памяти программные утилиты, представленные в данной
     книге.



                Библиотека исходных модулей
     -----------------------------------------------------------------

          Турбо Си  поставляется   без   исходных   текстов   программ
     библиотеки  функций  исполняющей системы.  Но каждый пользователь
     Турбо Си может купить лицензию на использование исходных текстов,
     которые в этом случае поставляются ему фирмой Borland.



                Заключение

                             - 37 -
     -----------------------------------------------------------------

          Раздел 4 начинает  описание  библиотеки  функций  Турбо  Си.
     После  прочтения  этого и последующих разделов вы получите в свое
     распоряжение инструментальные программные  средства,  необходимые
     для  создания  вашими программами всплывающих окон и последующего
     преобразования этих программ в резидентные утилиты.  На настоящий
     момент  нет  другого  компилятора,  который  поддерживал  бы  эти
     средства на таком же уровне, что и Турбо Си.



                             ГЛАВА 4
                             -------


                     Функции общего назначения
     -----------------------------------------------------------------

          Эта книга посвящена программному  обеспечению,  и  следующие
     разделы  содержат  набор  инструментальных  программных  средств,
     которые могут  быть использованы при создании  прикладных систем.
     Эти   инструментальные     средства   написаны   на   языке   Си,
     транслируются с помощью компилятора Турбо  Си  и  готовы  к тому,
     чтобы  быть  включенными  в  ваши  программы.  Эти  функции могут
     рассматриваться как расширения языка Си,  если будут присоединены
     к  и  без  того  достаточно  обширной    библиотеке   стандартных
     расширений Турбо Си.   Настоящий раздел описывает функции первого
     уровня,  которые  необходимо включать в  программы,  использующие
     эти библиотеки.  Представленные в данном разделе функции являются
     функциями  общего  назначения,    выполняющими  операции  низкого
     уровня  (специфическими  для  аппаратуры  IBM  PC)  по управлению
     дисплеем и клавиатурой.

          Вы можете  посчитать  недостаточно  обоснованным  применение
     некоторых из этих функций в своих  программах.  Назначением  этих
     функций  является  поддержка  функций библиотеки высокого уровня,

                             - 38 -
     также рассматриваемых в этой книге.  В этом смысле они полезны, и
     вы  можете найти для них применение.  Кроме того,  глубина вашего
     понимания функций,  представленных в книге, зависит от осмысления
     вами  всех  функций,  в  том  числе  и тех,  которые вы не будете
     использовать в своих программах.

          При чтении описаний этих функций обращайтесь к  листингу 4.1
     программы ibmpc.c, который приводится после описаний.


               void clear_screen()
               -------------------

          Эта функция очищает экран и  устанавливает  курсор  в  левый
     верхний  угол.  Экран  заполняется символами пробела,  и атрибуты
     символов извлекаются из символьной переменной attrib, описанной в
     программе  ibmpc.c.  Значение  этого атрибута соответствует байту
     атрибута в видеопамяти,  сопутствующему каждому байту  ASCII-кода
     при  записи символа в видеопамять.  Более подробная информация по
     этому вопросу содержится в разделе 5. Переменная attrib принимает
     значение,  которое соответствует установке черного цвета для фона
     символа и белого цвета для самого символа. Если вы желаете другое
     значение  атрибута,  то  должны изменить значение этой переменной
     перед вызовом функции clear_screen.


               int vmode()
               -----------

          Эта функция   возвращает   код   текущего   режима   системы
     формирования изображения.  Она  прeжде  всего  предназначена  для
     определения   того,  как  программе  интерпретировать  содержимое
     видеопамяти:  как содержимое видеопамяти в монохромном режиме или
     в  алфавитно-цифровом  режиме  для Цветного Графического Адаптера
     (CGA) и для Усовершенствованного Графического Адаптера (EGA). Эти
     устройства  более  подробно рассматриваются в разделе 5.  Функция
     vmode возвращает код  7,  если  IBM  PC  работает  в  монохромном

                             - 39 -
     режиме. Любое другое значение обозначает алфавитно-цифровой режим
     для контроллеров CGA и EGA.


               void cursor(int x,int y)
               ------------------------

          Эта функция  устанавливает  курсор  в  позицию  на   экране,
     определяемую  координатами X и Y.  Координаты (0,0) соответствуют
     левому верхнему углу экрана.  Значение координаты X изменяется  в
     диапазоне от 0 до 79, а координаты Y - в диапазоне от 0 до 24.


               void curr_cursor(int *x, int *y)
               --------------------------------

          Эта функция считывает текущее положение курсора и записывает
     значения координат X и Y в адреса памяти,  определяемые с помощью
     указателей перед обращением к функции.


               int set_cursor_type(int t)
               --------------------------

          Эта функция    устанавливает    текущий    размер   курсора,
     интерпретируемый программами  из  этой  книги  как  тип  курсора.
     Размер обозначается целочисленной переменной,  которая содержит в
     старшем байте номер начальной растровой линии курсора и в младшем
     байте - номер конечной растровой линии курсора.

          Редактор текстов и программа ввода данных,  представленные в
     следующих  разделах,  используют  возможность  изменения  размера
     курсора  для  обозначения  того,   какой  из  режимов установлен:
     Вставки или Замены.  Курсор прямоугольной  формы  обозначает, что
     установлен   режим    Вставки,    он    определяется    значением
     переменной,     равным  0x0106.    При    этом   курсор  занимает
     растровые линии с 1 по 6 того знакоместа, в котором он находится.

                             - 40 -
     Курсор в виде  знака подчеркивания   обозначает   режим  Замены и
     определяется  значением  переменной,   равным  0x0607.  При  этом
     курсор занимает растровые линии 6 и 7 знакоместа.


               int get_char()
               --------------

          Эта функция  является  очень  важной,  так   как   выполняет
     несколько крайне необходимых действий в вызывающих ее программах.
     get_char  принимает  поступающий  от  клавиатуры   символ   путем
     использования  программ  ROM-BIOS  IBM PC.  Ее главное назначение
     состоит в приеме одиночного символа от клавиатуры  без  эха,  без
     преобразования  и без обращения к функциям DOS.  Кроме того,  она
     выполняет следующие дополнительные функции.

          В то время, как система ожидает нажатия клавиши, функция get
     _char  вызывает  программные  прерывания  по  вектору  0x28,  так
     называемые прерывания DOSOK.  Это прерывание и его  значение  для
     создания  резидентных  утилит  более  подробно  рассматриваются в
     разделе 11.

          Когда вы  нажимаете   функциональную   клавишу,   ROM   BIOS
     возвращает  двубайтный код.  Первый байт имеет нулевое значение и
     обозначает,  что  следующий  за  ним  код  символа  соответствует
     функциональной клавише. Этот второй байт содержит 7-битный ASCII-
     код,  который  является  уникальным  для  каждой   функциональной
     клавиши.  Eсли  не  учитывать первый нулевой байт,  то реакция на
     нажатие  функциональных  клавиш  сходна  с  реакцией  на  нажатие
     клавиш,  соответствующих  ASCII-символам,  в  частности,  буквам.
     Функция  get_char  преобразует   двубайтную   последовательность,
     возвращаемую  ROM-BIOS в ответ на нажатие функциональной клавиши,
     в 8-битный код,  позволяющий отличать функциональные  клавиши  от
     нефункциональных.  Функция  осуществляет это преобразование путем
     установки старшего разряда в байте,  содержащем АSCII-код символа
     и  следующем  за  нулевым  байтом.  Формируемые коды описыватся в
     исходном файле keys.h как глобальные символы (см. листинг 4.2).

                             - 41 -

          Функция get_char  oжидает  нажатия  функциональной  клавиши,
     обозначенной Help.  Код,  соответствующий функциональной  клавише
     Help,  присвоен  целочисленной  глобальной переменной,  названной
     helpkey.  Первоначально  этой  переменной  присваивается  нулевое
     значение,   но   программные  средства,  которые работают с окном
     Help,  предназначенным для отображения   справочной  информациии,
     будут  присваивать  этой   переменной  значение,  соответствующее
     функциональной  клавише.  При нажатии функциональной клавиши Help
     функция  get_char   проверяет   значение   глобального  указателя
     функций,  названного  helpfunc.  Если  указатель  имеет ненулевое
     значение,  то функция get_char   вызывает   адресуемую  с помощью
     указателя helpfunc функцию выдачи справочной информации.


             void vpoke(unsigned vseg,unsigned adr,unsigned  chr) int
             vpeek (unsigned vseg,unsigned adr)
             --------------------------------------------------------

          Эти две функции считывают из  видеопамяти  коды  символов  и
     атрибуты символов и записывают их в видеопамять.  Для того, чтобы
     использовать эти функции,  вы должны  разобраться  в  организации
     видеопамяти IBM PC, а также принципах формирования изображения. В
     тело функций vpoke и vpeek включены фрагменты на  ассемблере. Для
     того,   чтобы   оттранслировать  эти  функции,  вы  должны  иметь
     программу  Macro  Assembler  (MASM)  фирмы  Microsoft,  поскольку
     именно  она  используется  в Турбо Си для трансляции ассемблерных
     фрагментов. Включение ассемблерных фрагментов необходимо только в
     том случае,  если ваши программы работают в системах, использущих
     Цветной Графический Адаптер (CGA) или совместимый с  ним адаптер.
     Смысл  этого требования разъясняется в разделе 5.  Если у вас нет
     контроллера CGA или если  вы  хотите  работать  с  функциями,  не
     используя  ассемблер,  то удалите эти функции из исходного модуля
     ibmpc.c и вставьте  в  файл  twindow.h  из  раздела  6  следующие
     операторы:

            #define vpoke(vseg,adr,chr) poke(vseg,adr,chr)

                             - 42 -
            #define vpeek(vseg,adr) peek(vseg,adr)

          Эти макроопределения заменят функции vpoke и vpeek и избавят
     от необходимости использования макроассемблера для функций работы
     с окнами из этой книги.



             Исходные модули функций общего назначения
     -----------------------------------------------------------------

          Листинг 4.1  представляет  собой  исходный  текст  программы
     ibmpc.c,  которая содержит функции,  описанные в данном  разделе.
     Вследствие  того,  что  функции включают фрагменты на ассемблере,
     программу лучше транслировать с  помощью  командного  компилятора
     tcc, а не компилятора tc Интегрированной Среды.

            Чтобы  оттранслировать   файл  ibmpc.c,  введите следующую
     команду (не набирая промптер С>):

          С>tcc -c ibmpc


                      Листинг 4.1: ibmpc.c

     /* ibmpc.c */
     /*  Функции  нижнего уровня,   обращающиеся к  BIOS и  аппаратным
     средствам  РС  */

     #pragma  inline #include <dos.h> static union REGS rg;

     /* позиция курсора */

     void cursor(int x,int y) {
        rg.x.ax = 0x0200;
        rg.x.bx = 0;
        rg.x.dx = ((y << 8) & 0xff00) + x;

                             - 43 -
        int86( 16, &rg, &rg);
     }

     /* возвратить позицию курсора */

     void curr_cursor( int *x, int *y )
     {
        rg.x.ax = 0x0300;
        rg.x.bx = 0;
        int86( 16, &rg, &rg );
        *x = rg.h.dl;
        *y = rg.h.dh;
     }

     /* установить тип курсора */

     void set_cursor_type( int t )
     {
        rg.x.ax = 0x0100;
        rg.x.bx = 0;
        rg.x.cx = t;
        int86( 16, &rg, &rg );
     }
     char attrib = 7;

     /* очистить экран */

     void clear_screen()
     {
        cursor(0, 0);
        rg.h.al = ' ';
        rg.h.ah = 9;
        rg.x.bx = attrib;
        rg.x.cx = 2000;
        int86( 16, &rg, &rg );
     }


                             - 44 -
     /* возвратить режим работы видеоконтроллера*/

     int vmode()
     {
        rg.h.ah = 15;
        int86( 16, &rg, &rg);
        return rg.h.al;
     }

     /* проверить клавишу Scroll Lock */

     int scroll_lock()
     {
        rg.x.ax = 0x0200;
        int86( 0x16, &rg, &rg);
        return rg.h.al & 0x10;
     }
     void (* helpfunc)();
     int helpkey = 0;
     int helping = 0;

     /* принять символ от клавиатуры */

     int get_char()
     {
        int c;
        while (1)   {
            rg.h.ah = 1;
            int86(0x16, &rg, &rg);
            if (rg.x.flags & 0x40)  {
        int86(0x28, &rg, &rg);
        continue;
            }
            rg.h.ah = 0;
            int86(0x16, &rg, &rg);
            if (rg.h.al == 0)
        c = rg.h.ah | 128;

                             - 45 -
            else
        c = rg.h.al;
            if (c == helpkey && helpfunc)   {
        if (!helping)   {
            helping = 1;
            (*helpfunc)();
            helping = 0;
            continue;
        }
            }
            break;
        }
         return c;
     }

     /* занести код символа и его атрибуты в видеопамять */

     void vroke(unsigned vseg, unsigned adr, unsigned chr)
     {
         if (vseg == 45056)     /* монохромный режим */
     poke(vseg, adr, chr);
         else    {
     _DI = adr; /* смещение до адреса символа в видеопамяти */
     _ES = vseg; /* адрес сегмента видеопамяти */
     asm cld;
     _BX = chr; /* атрибуты и код символа */
     _DX = 986; /* состояние видеопорта */

     /* ждать начала обратного хода луча*/

     do
         asm in al,dx;
     while (_AL & 1);

     /* ждать завершения обратного хода луча */

     do

                             - 46 -
         asm in al,dx;
     while (!(_AL & 1));
     _AL = _BL;
     asm stosb;    /* запомнить символ */

     /* ждать начала обратного хода луча */

     do
         asm in al,dx;
     while (_AL & 1);

     /* ждать завершения обратнога хода луча */

     do
         asm in al,dx;
     while (!(_AL & 1));
     _AL = _BL;
     asm stosb;     /* запомнить атрибуты */
          }
     }

     /* считать код символа и его атрибуты из видеопамяти */

     int vpeek(unsigned vseg, unsigned adr)
     {
         int ch, at;
         if (vseg == 45056)   /* монохромный режим */
     return peek(vseg, adr);
         asm push ds;
         _DX = 986;    /* состояние видеопорта */
         _DS = vseg;   /* адрес сегмента видеопамяти */
         _SI = adr;/* смещение до адреса символа в видеопамяти */
         asm cld;

         /* ждать начала обратного хода луча */

         do

                             - 47 -
     asm in al,dx;
         while (_AL & 1);

         /* ждать завершения обратного хода луча */

         do
            asm in al,dx;
         while (!(_AL & 1));
         asm lodsb;     /* считать символ */
         _BL = _AL;

         /* ждать начала обратного хода луча */

         do
     asm in al,dx;
         while (_AL & 1);

         /* ждать завершения обратного хода луча */

         do
     asm in al,dx;
         while (!(_AL & 1));
         asm lodsb;     /* считать атрибут */
         _BH = _AL;
         _AX = _BX;
         asm pop ds;
         return _AX;
     }

     /* keys.h */

     #define HT          9
     #define RUBOUT      8
     #define BELL        7
     #define ESC        27
     #define SHIFT_HT  143
     #define CTRL_T     20

                             - 48 -
     #define CTRL_B      2
     #define CTRL_D      4
     #define ALT_D     160

     #define F1   187
     #define F2   188
     #define F3   189
     #define F4   190
     #define F5   191
     #define F6   192
     #define F7   193
     #define F8   194
     #define F9   195
     #define F10  196

     #define HOME   199
     #define UP     200
     #define PGUP   201
     #define BS     203
     #define FWD    205
     #define END    207
     #define DN     208
     #define PGDN   209
     #define INS    210
     #define DEL    211

     #define CTRL_HOME   247
     #define CTRL_BS     243
     #define CTRL_FWD    244
     #define CTRL_END    245



                Заключение
     -----------------------------------------------------------------

          На основе  представленных  выше  функций  нижнего  уровня  в

                             - 49 -
     разделе  5  будет  развиваться  и  объясняться концепция экранных
     окон,  которая составляет следующий,  более  высокий,  уровень  в
     многоуровневом наборе функций, описываемых в данной книге.



                             Раздел 5
     -----------------------------------------------------------------

                           Экранные окна
     -----------------------------------------------------------------


         Этот раздел посвящен вопросу о том,  что  собой  представляют
     экранные  окна  и как с ними работать.  Раздел 6 разъясняет,  как
     можно использовать окна в ваших программах,  создаваемых в  среде
     Турбо  Си,  а также содержит полную библиотеку функций управления
     окнами.  Следующие  разделы   содержат   расширенную   библиотеку
     функций,  поддерживающих работу с окнами для специфических целей,
     как,  например,  для контекстно-чувствительного вывода справочной
     информации,  редактирования текста, ввода данных и создания меню.

          После того,  как вы прочитали об экранных окнах, способах их
     создания  и   применения,    постарайтесь  вспомнить  программные
     системы,   которые   используют   подобные  средства.   Подумайте
     также и о том,   какую пользу могли бы принести  эти средства для
     тех  программных проектов,  в которых вы принимали участие. Затем
     попытайтесь найти в этих функциях недостатки,  устранение которых
     позволит   сделать функции более подходящими для вашей работы.  В
     любой программе вы  почти всегда можете отыскать  эти недостатки.
     В данном случае вы имеете большое  преимущество:  исходные тексты
     функций  предоставлены,  вы  можете  модифицировать  их по своему
     усмотрению.



                Экранное окно

                             - 50 -
     -----------------------------------------------------------------

          Окном называется    область    экрана    дисплея,    которая
     используется  для  определенных  целей.  Окно  обычно имеет форму
     прямоугольника или квадрата,  а его границей  служат  символы  из
     набора   графических   символов.  Использование  окон  становится
     наиболее   популярным    способом    представления    информации,
     предназначенной  для  восприятия пользователем ПЭВМ.  Этот способ
     позволяет  на   ограниченном   пространстве   экрана   отображать
     информацию,    передаваемую   множеством   задач,   выполняющихся
     асинхронно.

          Поскольку отображаемые  на  экране изображения формируются в
     видеопамяти с прямым доступом процессора (так  называемый  способ
     формирования   изображения путем  управления  содержимым памяти),
     то  окна  на  экране  создаются мгновенно,   возникая  как  бы из
     ничего,   и так же  мгновенно   исчезают.  Использование  окон  в
     программах  позволяет  очень  удобно  отображать  различного рода
     информацию.    Окна  появляются    и  сменяют  друг  друга:   они
     появляются  на экране,   когда это необходимо,   и исчезают после
     того,   как информация,   которую они  содержат,  становится  вам
     ненужной.   Программа  может  отображать  столько  окон,  сколько
     нужно программисту.  Окна могут иметь различные размеры,  цвета и
     форматы.  Вы можете разместить окно в любом месте экрана, где это
     необходимо.  Если окно становится ненужным,  то вы можете удалить
     его,   и окно исчезнет,  а на его месте будет то, что было до его
     появления.

          Каждый, кто занимался проблемами автоматизации  в  последние
     годы,  обязательно  сталкивался  с  окнами.  ПЭВМ  IBM  PC сейчас
     встречаются везде,  в любой сфере общественной и деловой жизни. И
     почти  на каждой из  них работает  вездесущая программа Sidekick,
     включающая калькулятор,  календарь и средства вызова  абонента  в
     сети.  Каждый   из  этих компонентов отображает свою информацию с
     помощью  окон,    которые  по  мере  необходимости  появляются  и
     исчезают на экране, не разрушая того изображения, которое было до
     их  появления.  Волшебники  в  области  разработки   программного

                             - 51 -
     обеспечения  и  ее сбыта  из фирмы Bоrland International (это они
     дали Вам Турбо Си)  внедрили окна во всеобщую  практику.  Если вы
     никогда   не  видели окон,  то отложите книгу в сторону,  найдите
     IBM PC и нажмите одновременно клавиши <Alt>  и <Ctrl>. Если вы не
     увидите после этого  красно-бело-зелено-голубого  окна  на экране
     (или зеленого и черного для монохромного экрана),   то спросите у
     владельца машины,  почему у него не работает  программа Sidekick.
     Если же окно небольшого размера все-таки появится,  начните с ним
     игру. Сделав выбор в меню,  содержащемся в первом окне, вы можете
     создать другое окно.  Вы можете перемещать окна,  нажимая клавишу
     со стрелкой.   Вы можете удалять окна,  нажимая клавишу <Esc>. Вы
     можете  вызвать  на  экран  справочную  информацию  по  работе  с
     программой, нажав клавишу <F1>.

          Из этого  раздела  вы  узнаете,  как работать с окнами,  как
     накладывать их друг на друга,  как перемещать их по экрану и  как
     их  использовать  в  своих программах,  разрабатываемых с помощью
     Турбо Си.  Окна используются для отображения меню, информационных
     и предупреждающих сообщений,  текстовых файлов, шаблона для ввода
     данных  и  контекстно-чувствительных  информационных   сообщений.
     Программные  системы  могут  использовать  окна  для  отображения
     информации независимо от содержания других окон и размера области
     пространства экрана,  занимаемой другими окнами.  Благодаря этому
     можно обозревать на экране несколько окон,  даже если  каждое  из
     них занимает больше половины экрана, потому что окна могут как бы
     "всплывать" друг над другом.

          Свойство всплывания окон  часто  объясняют  путем  сравнения
     экрана  дисплея  с поверхностью стола.  Допустим,  на вашем столе
     лежит множество документов,  но в каждый момент времени вы можете
     работать  только с одним из этих документов,  возможно,  наиболее
     важным для вас.  То, что можно делать с бумагами, можно выполнять
     и  на  экране  дисплея.  Если первоначально изображение на экране
     содержит только одно окно,  как  это  показано  на  рис.  5.1,  и
     программе  необходимо создать второе окно,  не уничтожая при этом
     первого,  то в результате получится изображение, как на рис. 5.2.
     Если затем второе окно становится ненужным,  то оно уничтожается,

                             - 52 -
     и изображение снова будет соответствовать рис. 5.1.


     ┌───────────────────────────────────────────────────────────┐
     │                                                           │
     │                                                           │
     │                                                           │
     │                                                           │
     │ ┌──────────────────────────┐                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │        Окно  A           │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ │                          │                              │
     │ └──────────────────────────┘                              │
     │                                                           │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

                Рис. 5.1  Экранное окно



     ┌───────────────────────────────────────────────────────────┐
     │             ┌────────────────────────────┐                │
     │             │                            │                │
     │             │                            │                │
     │             │                            │                │
     │             │                            │                │
     │ ┌───────────┤                            │                │
     │ │           │          Окно  B           │                │
     │ │           │                            │                │
     │ │           │                            │                │

                             - 53 -
     │ │           │                            │                │
     │ │        Окн│                            │                │
     │ │           │                            │                │
     │ │           │                            │                │
     │ │           └──────────────┬─────────────┘                │
     │ │                          │                              │
     │ └──────────────────────────┘                              │
     │                                                           │
     │                                                           │
     └───────────────────────────────────────────────────────────┘

                Рис. 5.2  Наложение окон
