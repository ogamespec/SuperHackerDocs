ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SECTION 3  IBM ROM BIOS AND MOUSE FUNCTIONS REFERENCE
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Notes to the Reader

  In the headers for ROM BIOS video driver (Int 10H) function calls, the
  following icons are used:

  [MDA]                    Monochrome Display Adapter
  [CGA]                    Color/Graphics Adapter
  [PCjr]                   PCjr system board video controller
  [EGA]                    Enhanced Graphics Adapter
  [MCGA]                   Multi-Color Graphics Array (PS/2 Models 25 & 30)
  [VGA]                    Video Graphics Array (PS/2 Models 50 and above)

  In the remainder of this section, the following icons are used:

  [PC]                     Original IBM PC, PC/XT, and PCjr, unless
                           otherwise noted.
  [AT]                     PC/AT and PC/XT-286, unless otherwise noted.
  [PS/2]                   All PS/2 models (including Models 25 and 30),
                           unless otherwise noted.

  ROM BIOS functions that are unique to the PC Convertible have been
  omitted.

  Some functions are supported only in very late revisions of a particular
  machine's ROM BIOS (such as Int 1AH Functions 00H and 01H on the PC/XT).
  In general, such functions are not given an icon for that machine since a
  program could not safely assume that they were available based on the
  machine ID byte(s).


Summary of ROM BIOS and Mouse Function Calls


  Int    Function     Subfunction   Name
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  10H                               Video Driver
  10H    00H                       Set Video Mode
  10H    01H                       Set Cursor Type
  10H    02H                       Set Cursor Position
  10H    03H                       Get Cursor Position
  10H    04H                       Get Light Pen Position
  10H    05H                       Set Display Page
  10H    06H                       Initialize or Scroll Window Up
  10H    07H                       Initialize or Scroll Window Down
  10H    08H                       Read Character and Attribute at Cursor
  10H    09H                       Write Character and Attribute at Cursor
  10H    0AH (10)                  Write Character at Cursor
  10H    0BH (11)                  Set Palette, Background, or Border
  10H    0CH (12)                  Write Graphics Pixel
  10H    0DH (13)                  Read Graphics Pixel
  10H    0EH (14)                  Write Character in Teletype Mode
  10H    0FH (15)                  Get Video Mode
  10H    10H (16)     00H          Set Palette Register
  10H    10H (16)     01H          Set Border Color
  10H    10H (16)     02H          Set Palette and Border
  10H    10H (16)     03H          Toggle Blink/Intensity Bit
  10H    10H (16)     07H          Get Palette Register
  10H    10H (16)     08H          Get Border Color
  10H    10H (16)     09H          Get Palette and Border
  10H    10H (16)     10H (16)     Set Color Register
  10H    10H (16)     12H (18)     Set Block of Color Registers
  10H    10H (16)     13H (19)     Set Color Page State
  10H    10H (16)     15H (21)     Get Color Register
  10H    10H (16)     17H (23)     Get Block of Color Registers
  10H    10H (16)     1AH (26)     Get Color Page State
  10H    10H (16)     1BH (27)     Set Gray-Scale Values
  10H    11H (17)     00H          Load User Font
  10H    11H (17)     01H          Load ROM 8-by-14 Font
  10H    11H (17)     02H          Load ROM 8-by-8 Font
  10H    11H (17)     03H          Set Block Specifier
  10H    11H (17)     04H          Load ROM 8-by-16 Font
  10H    11H (17)     10H (16)     Load User Font, Reprogram Controller
  10H    11H (17)     11H (17)     Load ROM 8-by-14 Font, Reprogram
                                    Controller
  10H    11H (17)     12H (18)     Load ROM 8-by-8 Font, Reprogram
                                    Controller
  10H    11H (17)     14H (20)     Load ROM 8-by-16 Font, Reprogram
                                    Controller
  10H    11H (17)     20H (32)     Set Int 1FH Pointer
  10H    11H (17)     21H (33)     Set Int 43H for User's Font
  10H    11H (17)     22H (34)     Set Int 43H for ROM 8-by-14 Font
  10H    11H (17)     23H (35)     Set Int 43H for ROM 8-by-8 Font
  10H    11H (17)     24H (36)     Set Int 43H for Rom 8-by-16 Font
  10H    11H (17)     30H (48)     Get Font Information
  10H    12H (18)     10H (16)     Get Configuration Information
  10H    12H (18)     20H (32)     Select Alternate PrintScreen
  10H    12H (18)     30H (48)     Set Scan Lines
  10H    12H (18)     31H (49)     Enable/Disable Palette Loading
  10H    12H (18)     32H (50)     Enable/Disable Video
  10H    12H (18)     33H (51)     Enable/Disable Gray-Scale Summing
  10H    12H (18)     34H (52)     Enable/Disable Cursor Emulation
  10H    12H (18)     35H (53)     Switch Active Display
  10H    12H (18)     36H (54)     Enable/Disable Screen Refresh
  10H    13H (19)                   Write String in Teletype Mode
  10H    1AH (26)                  Get or Set Display Combination Code
  10H    1BH (27)                  Get Functionality/State Information
  10H    1CH (28)                  Save or Restore Video State
  11H                              Get Equipment Configuration
  12H                              Get Conventional Memory Size
  13H                               Disk Driver
  13H    00H                       Reset Disk System
  13H    01H                       Get Disk System Status
  13H    02H                       Read Sector
  13H    03H                       Write Sector
  13H    04H                       Verify Sector
  13H    05H                       Format Track
  13H    06H                       Format Bad Track
  13H    07H                       Format Drive
  13H    08H                       Get Drive Parameters
  13H    09H                       Initialize Fixed Disk Characteristics
  13H    0AH (10)                  Read Sector Long
  13H    0BH (11)                  Write Sector Long
  13H    0CH (12)                  Seek
  13H    0DH (13)                  Reset Fixed Disk System
  13H    0EH (14)                  Read Sector Buffer
  13H    0FH (15)                  Write Sector Buffer
  13H    10H (16)                  Get Drive Status
  13H    11H (17)                  Recalibrate Drive
  13H    12H (18)                  Controller RAM Diagnostic
  13H    13H (19)                  Controller Drive Diagnostic
  13H    14H (20)                  Controller Internal Diagnostic
  13H    15H (21)                  Get Disk Type
  13H    16H (22)                  Get Disk Change Status
  13H    17H (23)                  Set Disk Type
  13H    18H (24)                  Set Media Type for Format
  13H    19H (25)                  Park Heads
  13H    1AH (26)                  Format ESDI Drive
  14H                               Serial Communications Port Driver
  14H    00H                       Initialize Communications Port
  14H    01H                       Write Character to Communications Port
  14H    02H                       Read Character from Communications Port
  14H    03H                       Get Communications Port Status
  14H    04H                       Extended Initialize Communications Port
  14H    05H                       Extended Communications Port Control
  15H                               I/O Subsystem Extensions
  15H    00H                       Turn On Cassette Motor
  15H    01H                       Turn Off Cassette Motor
  15H    02H                       Read Cassette
  15H    03H                       Write Cassette
  15H    0FH (15)                  Format ESDI Drive Periodic Interrupt
  15H    21H (33)     00H          Read POST Error Log
  15H    21H (33)     01H          Write POST Error Log
  15H    4FH (79)                  Keyboard Intercept
  15H    80H (128)                 Device Open
  15H    81H (129)                 Device Close
  15H    82H (130)                 Process Termination
  15H    83H (131)                 Event Wait
  15H    84H (132)                 Read Joystick
  15H    85H (133)                 SysReq Key
  15H    86H (134)                 Delay
  15H    87H (135)                 Move Extended Memory Block
  15H    88H (136)                 Get Extended Memory Size
  15H    89H (137)                 Enter Protected Mode
  15H    90H (144)                 Device Wait
  15H    91H (145)                 Device Post
  15H    C0H (192)                 Get System Environment
  15H    C1H (193)                 Get Address of Extended BIOS Data Area
  15H    C2H (194)    00H          Enable/Disable Pointing Device
  15H    C2H (194)    01H          Reset Pointing Device
  15H    C2H (194)    02H          Set Sample Rate
  15H    C2H (194)    03H          Set Resolution
  15H    C2H (194)    04H          Get Pointing Device Type
  15H    C2H (194)    05H          Initialize Pointing Device Interface
  15H    C2H (194)    06H          Set Scaling or Get Status
  15H    C2H (194)    07H          Set Pointing Device Handler Address
  15H    C3H (195)                 Set Watchdog Time-Out
  15H    C4H (196)                 Programmable Option Select
  16H                               Keyboard Driver
  16H    00H                       Read Character from Keyboard
  16H    01H                       Get Keyboard Status
  16H    02H                       Get Keyboard Flags
  16H    03H                       Set Repeat Rate
  16H    04H                       Set Keyclick
  16H    05H                       Push Character and Scan Code
  16H    10H (16)                  Read Character from Enhanced Keyboard
  16H    11H (17)                  Get Enhanced Keyboard Status
  16H    12H (18)                  Get Enhanced Keyboard Flags
  17H                               Parallel Port Printer Driver
  17H    00H                       Write Character to Printer
  17H    01H                       Initialize Printer Port
  17H    02H                       Get Printer Status
  18H                              ROM BASIC
  19H                              Reboot System
  1AH                               Real-time (CMOS) Clock Driver
  1AH    00H                       Get Tick Count
  1AH    01H                       Set Tick Count
  1AH    02H                       Get Time
  1AH    03H                       Set Time
  1AH    04H                       Get Date
  1AH    05H                       Set Date
  1AH    06H                       Set Alarm
  1AH    07H                       Reset Alarm
  1AH    0AH (10)                  Get Day Count
  1AH    0BH (11)                  Set Day Count
  1AH    80H (128)                 Set Sound Source
  33H                              Microsoft Mouse Driver
  33H    00H                       Reset Mouse and Get Status
  33H    01H                       Show Mouse Pointer
  33H    02H                       Hide Mouse Pointer
  33H    03H                       Get Mouse Position and Button Status
  33H    04H                       Set Mouse Pointer Position
  33H    05H                       Get Button Press Information
  33H    06H                       Get Button Release Information
  33H    07H                       Set Horizontal Limits for Pointer
  33H    08H                       Set Vertical Limits for Pointer
  33H    09H                       Set Graphics Pointer Shape
  33H    0AH (10)                  Set Text Pointer Type
  33H    0BH (11)                  Read Mouse Motion Counters
  33H    0CH (12)                  Set User-defined Mouse Event Handler
  33H    0DH (13)                  Turn On Light Pen Emulation
  33H    0EH (14)                  Turn Off Light Pen Emulation
  33H    0FH (15)                  Set Mickeys to Pixels Ratio
  33H    10H (16)                  Set Mouse Pointer Exclusion Area
  33H    13H (19)                  Set Double Speed Threshold
  33H    14H (20)                  Swap User-defined Mouse Event Handlers
  33H    15H (21)                  Get Mouse Save State Buffer Size
  33H    16H (22)                  Save Mouse Driver State
  33H    17H (23)                  Restore Mouse Driver State
  33H    18H (24)                  Set Alternate Mouse Event Handler
  33H    19H (25)                  Get Address of Alternate Mouse Event
                                    Handler
  33H    1AH (26)                  Set Mouse Sensitivity
  33H    1BH (27)                  Get Mouse Sensitivity
  33H    1CH (28)                  Set Mouse Interrupt Rate
  33H    1DH (29)                  Select Pointer Page
  33H    1EH (30)                  Get Pointer Page
  33H    1FH (31)                  Disable Mouse Driver
  33H    20H (32)                  Enable Mouse Driver
  33H    21H (33)                  Reset Mouse Driver
  33H    22H (34)                  Set Language for Mouse Driver Messages
  33H    23H (35)                  Get Language Number
  33H    24H (36)                  Get Mouse Information
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 00H
Set video mode
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the current video display mode. Also selects the active video
  controller, if more than one video controller is present.

Call with:

  AH            = 00H
  AL            = video mode (see Notes)

Returns:

  Nothing

Notes:

  ş The video modes applicable to the various IBM machine models and video
    adapters are as follows:


  Mode  Resolution  Colors   Text/       MDA   CGA   PCjr EGA   MCGA  VGA
                             graphics
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  00H   40-by-25     16      text              *     *    *     *     *
        color burst
        off
  01H   40-by-25     16      text              *     *    *     *     *
  02H   80-by-25     16      text              *     *    *     *     *
        color burst
        off
  03H   80-by-25     16      text              *     *    *     *     *
  04H   320-by-200    4      graphics          *     *    *     *     *
  05H   320-by-200    4      graphics          *     *    *     *     *
        color burst
        off
  06H   640-by-200    2      graphics          *     *    *     *     *
  07H   80-by-25      2
Monochrome monitor only.
     text        *                *           *
  08H   160-by-200   16      graphics                *
  09H   320-by-200   16      graphics                *
  0AH   640-by-200    4      graphics                *
  0BH   reserved
  0CH   reserved
  0DH   320-by-200   16      graphics                     *           *
  0EH   640-by-200   16      graphics                     *           *
  0FH   640-by-350    2
Monochrome monitor only.
     graphics                     *           *
  10H   640-by-350    4      graphics                     *
EGA with 64 KB of RAM.

  10H   640-by-350   16      graphics                     *
EGA with 128 KB or more of RAM.
          *
  11H   640-by-480    2      graphics                           *     *
  12H   640-by-480   16      graphics                                 *
  13H   320-by-200  256      graphics                           *     *
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


  ş The presence or absence of color burst is only significant when a
    composite monitor is being used. For RGB monitors, there is no
    functional difference between modes 00H and 01H or modes 02H and 03H. On
    the CGA, two palettes are available in mode 04H and one in mode 05H.

  ş On the PC/AT, PCjr, and PS/2, if bit 7 of AL is set, the display buffer
    is not cleared when a new mode is selected. On the PC or PC/XT, this
    capability is available only when an EGA or VGA (which have their own
    ROM BIOS) is installed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 01H
Set cursor type
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the starting and ending lines for the blinking hardware cursor in
  text display modes.

Call with:

  AH                 = 01H
  CH bits 0Ä4        = starting line for cursor
  CL bits 0Ä4        = ending line for cursor

Returns:

  Nothing

Notes:

  ş In text display modes, the video hardware causes the cursor to blink,
    and the blink cannot be disabled. In graphics modes, the hardware cursor
    is not available.

  ş The default values set by the ROM BIOS are:

    Display                        Start     End
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    monochrome mode 07H            11        12
    text modes 00HÄ03H              6         7
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş On the EGA, MCGA, and VGA in text modes 00HÄ03H, the ROM BIOS accepts
    cursor start and end values as though the character cell were 8 by 8 and
    remaps the values as appropriate for the true character cell dimensions.
    This mapping is called cursor emulation.

  ş You can turn off the cursor in several ways. On the MDA, CGA, and VGA,
    setting register CH = 20H causes the cursor to disappear. Techniques
    that involve setting illegal starting and ending lines for the current
    display mode are unreliable. An alternative is to position the cursor to
    a nondisplayable address, such as (x,y)=(0,25).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 02H
Set cursor position
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Positions the cursor on the display, using text coordinates.

Call with:

  AH            = 02H
  BH            = page
  DH            = row (y coordinate)
  DL            = column (x coordinate)

Returns:

  Nothing

Notes:

  ş A separate cursor is maintained for each display page, and each can be
    set independently with this function regardless of the currently active
    page. The number of available display pages depends on the video adapter
    and current display mode. See Int 10H Function 05H.

  ş Text coordinates (x,y)=(0,0) are the upper left corner of the screen.

  ş The maximum value for each text coordinate depends on the video adapter
    and current display mode, as follows:

    Mode                    Maximum x               Maximum y
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H                     39                      24
    01H                     39                      24
    02H                     79                      24
    03H                     79                      24
    04H                     39                      24
    05H                     39                      24
    06H                     79                      24
    07H                     79                      24
    08H                     19                      24
    09H                     39                      24
    0AH                     79                      24
    0BH                     reserved
    0CH                     reserved
    0DH                     39                      24
    0EH                     79                      24
    0FH                     79                      24
    10H                     79                      24
    11H                     79                      29
    12H                     79                      29
    13H                     39                      24
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 03H
Get cursor position
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the current position of the cursor on the display, in text
  coordinates.

Call with:

  AH            = 03H
  BH            = page

Returns:

  CH            = starting line for cursor
  CL            = ending line for cursor
  DH            = row (y coordinate)
  DL            = column (x coordinate)

Note:

  ş A separate cursor is maintained for each display page, and each can be
    inspected independently with this function regardless of the currently
    active page. The number of available display pages depends on the video
    adapter and current display mode. See Int 10H Function 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [CGA] [PCjr] [EGA]
Function 04H
Get light pen position
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the current status and position of the light pen.

Call with:

  AH            = 04H

Returns:

  AH            = 00H       if light pen not down/not triggered
                  01H       if light pen down/triggered
  BX            = pixel column (graphics x coordinate)
  CH            = pixel row (graphics y coordinate, modes 04HÄ06H)
  CX            = pixel row (graphics y coordinate, modes 0DHÄ13H)
  DH            = character row (text y coordinate)
  DL            = character column (text x coordinate)

Notes:

  ş The range of text and graphics coordinates returned by this function
    depends on the current display mode.

  ş On the CGA, the graphics coordinates returned by this function are not
    continuous. The y coordinate is always a multiple of two; the x
    coordinate is either a multiple of four (for 320-by-200 graphics modes)
    or a multiple of eight (for 640-by-200 graphics modes).

  ş Careful selection of background and foreground colors is necessary to
    obtain maximum sensitivity from the light pen across the full screen
    width.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                      [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 05H
Set display page
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the active display page for the video display.

Call with:

  For CGA, EGA, MCGA, VGA

  AH            = 05H
  AL            = page

                  0Ä7       for modes 00H and 01H (CGA, EGA, MCGA, VGA)
                  0Ä3       for modes 02H and 03H (CGA)
                  0Ä7       for modes 02H and 03H (EGA, MCGA, VGA)
                  0Ä7       for mode 07H (EGA, VGA)
                  0Ä7       for mode 0DH (EGA, VGA)
                  0Ä3       for mode 0EH (EGA, VGA)
                  0Ä1       for mode 0FH (EGA, VGA)
                  0Ä1       for mode 10H (EGA, VGA)

  For PCjr only

  AH            = 05H
  AL            = subfunction
                  80H = read CRT/CPU page registers
                  81H = set CPU page register
                  82H = set CRT page register
                  83H = set both CPU and CRT page registers
  BH            = CRT page (Subfunctions 82H and 83H)
  BL            = CPU page (Subfunctions 81H and 83H)

Returns:

  If CGA, EGA, MCGA, or VGA adapter

  Nothing

  If PCjr and if function called with AL = 80HÄ83H

  BH            = CRT page register
  BL            = CPU page register

Notes:

  ş Video mode and adapter combinations not listed above support one display
    page (for example, a Monochrome Adapter in mode 7).

  ş Switching between pages does not affect their contents. In addition,
    text can be written to any video page with Int 10H Functions 02H, 09H,
    and 0AH, regardless of the page currently being displayed.

  ş On the PCjr, the CPU page determines the part of the physical memory
    region 00000HÄ1FFFFH that will be hardware mapped onto 16 KB of memory
    beginning at segment B800H. The CRT page determines the starting address
    of the physical memory used by the video controller to refresh the
    display. Smooth animation effects can be achieved by manipulation of
    these registers. Programs that write directly to the B800H segment can
    reach only the first 16 KB of the video refresh buffer. Programs
    requiring direct access to the entire 32 KB buffer in modes 09H and 0AH
    can obtain the current CRT page from the ROM BIOS variable PAGDAT at
    0040:008AH.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 06H
Initialize or scroll window up
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes a specified window of the display to ASCII blank characters
  with a given attribute or scrolls up the contents of a window by a
  specified number of lines.

Call with:

  AH            = 06H
  AL            = number of lines to scroll (if zero, entire window is
                  blanked)
  BH            = attribute to be used for blanked area
  CH            = y coordinate, upper left corner of window
  CL            = x coordinate, upper left corner of window
  DH            = y coordinate, lower right corner of window
  DL            = x coordinate, lower right corner of window

Returns:

  Nothing

Notes:

  ş In video modes that support multiple pages, this function affects only
    the page currently being displayed.

  ş If AL contains a value other than 00H, the area within the specified
    window is scrolled up by the requested number of lines. Text that is
    scrolled beyond the top of the window is lost. The new lines that appear
    at the bottom of the window are filled with ASCII blanks carrying the
    attribute specified by register BH.

  ş To scroll down the contents of a window, see Int 10H Function 07H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 07H
Initialize or scroll window down
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes a specified window of the display to ASCII blank characters
  with a given attribute, or scrolls down the contents of a window by a
  specified number of lines.

Call with:

  AH            = 07H
  AL            = number of lines to scroll (if zero, entire window is
                  blanked)
  BH            = attribute to be used for blanked area
  CH            = y coordinate, upper left corner of window
  CL            = x coordinate, upper left corner of window
  DH            = y coordinate, lower right corner of window
  DL            = x coordinate, lower right corner of window

Returns:

  Nothing

Notes:

  ş In video modes that support multiple pages, this function affects only
    the page currently being displayed.

  ş If AL contains a value other than 00H, the area within the specified
    window is scrolled down by the requested number of lines. Text that is
    scrolled beyond the bottom of the window is lost. The new lines that
    appear at the top of the window are filled with ASCII blanks carrying
    the attribute specified by register BH.

  ş To scroll up the contents of a window, see Int 10H Function 06H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 08H
Read character and attribute at cursor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the ASCII character and its attribute at the current cursor
  position for the specified display page.

Call with:

  AH            = 08H
  BH            = page

Returns:

  AH            = attribute
  AL            = character

Note:

  ş In video modes that support multiple pages, characters and their
    attributes may be read from any page, regardless of the page currently
    being displayed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 09H
Write character and attribute at cursor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes an ASCII character and its attribute to the display at the current
  cursor position.

Call with:

  AH            = 09H
  AL            = character
  BH            = page
  BL            = attribute (text modes) or color (graphics modes)
  CX            = count of characters to write (replication factor)

Returns:

  Nothing

Notes:

  ş In graphics modes, the replication factor in CX produces a valid result
    only for the current row. If more characters are written than there are
    remaining columns in the current row, the result is unpredictable.

  ş All values of AL result in some sort of display; control characters,
    including bell, backspace, carriage return, and line feed, are not
    recognized as special characters and do not affect the cursor position.

  ş After a character is written, the cursor must be moved explicitly with
    Int 10H Function 02H to the next position.

  ş To write a character without changing the attribute at the current
    cursor position, use Int 10H Function 0AH.

  ş If this function is used to write characters in graphics mode and bit 7
    of BL is set (1), the character will be exclusive-OR'd (XOR) with the
    current display contents. This feature can be used to write characters
    and then "erase" them.

  ş For the CGA and PCjr in graphics modes 04HÄ06H, the bit patterns for
    character codes 80HÄFFH are obtained from a table whose address is
    stored in the vector for Int 1FH. On the PCjr, the address of the table
    for character codes 00HÄ7FH is stored in the vector for Int 44H.
    Alternative character sets may be installed by loading them into memory
    and updating this vector.

  ş For the EGA, MCGA, and VGA in graphics modes, the address of the
    character definition table is stored in the vector for Int 43H. See Int
    10H Function 11H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0AH (10)
Write character at cursor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes an ASCII character to the display at the current cursor position.
  The character receives the attribute of the previous character displayed
  at the same position.

Call with:

  AH            = 0AH
  AL            = character
  BH            = page
  BL            = color (graphics modes, PCjr only)
  CX            = count of characters to write (replication factor)

Returns:

  Nothing

Notes:

  ş In graphics modes, the replication factor in CX produces a valid result
    only for the current row. If more characters are written than there are
    remaining columns in the current row, the result is unpredictable.

  ş All values of AL result in some sort of display; control characters,
    including bell, backspace, carriage return, and line feed, are not
    recognized as special characters and do not affect the cursor position.

  ş After a character is written, the cursor must be moved explicitly with
    Int 10H Function 02H to the next position.

  ş To write a character and attribute at the current cursor position, use
    Int 10H Function 09H.

  ş If this function is used to write characters in graphics mode and bit 7
    of BL is set (1), the character will be exclusive-OR'd (XOR) with the
    current display contents. This feature can be used to write characters
    and then "erase" them.

  ş For the CGA and PCjr in graphics modes 04HÄ06H, the bit patterns for
    character codes 80HÄFFH are obtained from a table whose address is
    stored in the vector for Int 1FH. On the PCjr, the address of the table
    for character codes 00HÄ7FH is stored in the vector for Int 44H.
    Alternative character sets may be installed by loading them into memory
    and updating this vector.

  ş For the EGA, MCGA, and VGA in graphics modes, the address of the
    character definition table is stored in the vector for Int 43H. See Int
    10H Function 11H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                      [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0BH (11)
Set palette, background, or border
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects a palette, background, or border color.

Call with:

  To set the background color and border color for graphics modes or the
  border color for text modes

  AH            = 0BH
  BH            = 00H
  BL            = color

  To select the palette (320-by-200 4-color graphics modes)

  AH            = 0BH
  BH            = 01H
  BL            = palette (see Notes)

Returns:

  Nothing

Notes:

  ş In text modes, this function selects only the border color. The
    background color of each individual character is controlled by the upper
    4 bits of that character's attribute byte.

  ş On the CGA and EGA, this function is valid for palette selection only in
    320-by-200 4-color graphics modes.

  ş In 320-by-200 4-color graphics modes, if register BH = 01H, the
    following palettes may be selected:

    Palette           Pixel value       Color
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0                 0                 same as background
                      1                 green
                      2                 red
                      3                 brown or yellow
    1                 0                 same as background
                      1                 cyan
                      2                 magenta
                      3                 white
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş On the CGA in 640-by-200 2-color graphics mode, the background color
    selected with this function actually controls the display color for
    nonzero pixels; zero pixels are always displayed as black.

  ş On the PCjr in 640-by-200 2-color graphics mode, if BH = 00H and bit 0
    of register BL is cleared, pixel value 1 is displayed as white; if bit 0
    is set, pixel value 1 is displayed as black.

  ş See also Int 10H Function 10H, which is used for palette programming on
    the PCjr, EGA, MCGA, and VGA.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                      [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0CH (12)
Write graphics pixel
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Draws a point on the display at the specified graphics coordinates.

Call with:

  AH            = 0CH
  AL            = pixel value
  BH            = page
  CX            = column (graphics x coordinate)
  DX            = row (graphics y coordinate)

Returns:

  Nothing

Notes:

  ş The range of valid pixel values and (x,y) coordinates depends on the
    current video mode.

  ş If bit 7 of AL is set, the new pixel value will be exclusive-OR'd (XOR)
    with the current contents of the pixel.

  ş Register BH is ignored for display modes that support only one page.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                      [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0DH (13)
Read graphics pixel
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the current value of the pixel on the display at the specified
  graphics coordinates.

Call with:

  AH            = 0DH
  BH            = page
  CX            = column (graphics x coordinate)
  DX            = row (graphics y coordinate)

Returns:

  AL            = pixel value

Notes:

  ş The range of valid (x,y) coordinates and possible pixel values depends
    on the current video mode.

  ş Register BH is ignored for display modes that support only one page.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0EH (14)
Write character in teletype mode
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes an ASCII character to the display at the current cursor position,
  using the specified color (if in graphics modes), and then increments the
  cursor position appropriately.

Call with:

  AH            = 0EH
  AL            = character
  BH            = page
  BL            = foreground color (graphics modes)

Returns:

  Nothing

Notes:

  ş The special ASCII codes for bell (07H), backspace (08H), carriage return
    (0DH), and line feed (0AH) are recognized, and the appropriate action is
    taken. All other characters are written to the display (even if they are
    control characters), and the cursor is moved to the next position.

  ş In video modes that support multiple pages, characters can be written to
    any page, regardless of the page currently being displayed.

  ş Line wrapping and scrolling are provided. If the cursor is at the end of
    a line, it is moved to the beginning of the next line. If the cursor
    reaches the end of the last line on the screen, the screen is scrolled
    up by one line and the cursor is placed at the beginning of a new blank
    line. The attribute for the entire new line is taken from the last
    character that was written on the preceding line.

  ş The default MS-DOS console driver (CON) uses this function to write text
    to the screen. You cannot use this function to specify the attribute of
    a character. One method of writing a character to the screen with a
    specific attribute is to first write an ASCII blank (20H) with the
    desired attribute at the current cursor location using Int 10H Function
    09H and then write the actual character with Int 10H Function 0EH.
    This technique, although somewhat clumsy, does not require the program
    to explicitly handle line wrapping and scrolling.

  ş See also Int 10H Function 13H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 0FH (15)
Get video mode
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the current display mode of the active video controller.

Call with:

  AH            = 0FH

Returns:

  AH            = number of character columns on screen
  AL            = display mode (see Int 10H Function 00H)
  BH            = active display page

Note:

  ş This function can be called to obtain the screen width before clearing
    the screen with Int 10H Functions 06H or 07H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                            [PCjr] [EGA] [MCGA] [VGA]
Function 10H (16) Subfunction 00H
Set palette register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the correspondence of a palette register to a displayable color.

Call with:

  On the PCjr, EGA, or VGA

  AH            = 10H
  AL            = 00H
  BH            = color value
  BL            = palette register (00Ä0FH)

  On the MCGA

  AH            = 10H
  AL            = 00H
  BX            = 0712H

Returns:

  Nothing

Note:

  ş On the MCGA, this function can only be called with BX = 0712H and
    selects a color register set with eight consistent colors.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [PCjr] [EGA] [VGA]
Function 10H (16) Subfunction 01H
Set border color
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Controls the color of the screen border (overscan).

Call with:

  AH            = 10H
  AL            = 01H
  BH            = color value

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [PCjr] [EGA] [VGA]
Function 10H (16) Subfunction 02H
Set palette and border
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets all palette registers and the border color (overscan) in one
  operation.

Call with:

  AH            = 10H
  AL            = 02H
  ES:DX         = segment:offset of color list

Returns:

  Nothing

Notes:

  ş The color list is 17 bytes long. The first 16 bytes are the color values
    to be loaded into palette registers 0Ä15, and the last byte is stored in
    the border color register.

  ş In 16-color graphics modes, the following default palette is set up:

    Pixel value                         Color
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    01H                                 blue
    02H                                 green
    03H                                 cyan
    04H                                 red
    05H                                 magenta
    06H                                 brown
    07H                                 white
    08H                                 gray
    09H                                 light blue
    0AH                                 light green
    0BH                                 light cyan
    0CH                                 light red
    0DH                                 light magenta
    0EH                                 yellow
    0FH                                 intense white
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                            [PCjr] [EGA] [MCGA] [VGA]
Function 10H (16) Subfunction 03H
Toggle blink/intensity bit
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Determines whether the most significant bit of a character attribute will
  select blinking or intensified display.

Call with:

  AH            = 10H
  AL            = 03H
  BL            = blink/intensity toggle
                  0 = enable intensity
                  1 = enable blinking

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 10H (16) Subfunction 07H
Get palette register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the color associated with the specified palette register.

Call with:

  AH            = 10H
  AL            = 07H
  BL            = palette register

Returns:

  BH            = color


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 10H (16) Subfunction 08H
Get border color
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current border color (overscan).

Call with:

  AH            = 10H
  AL            = 08H

Returns:

  BH            = color


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 10H (16) Subfunction 09H
Get palette and border
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Gets the contents of all palette registers and the border color (overscan)
  in one operation.

Call with:

  AH            = 10H
  AL            = 09H
  ES:DX         = segment:offset of 17-byte buffer

Returns:

  ES:DX         = segment:offset of buffer

  and buffer contains palette values in bytes 00HÄ0FH and border color in
  byte 10H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 10H (16) Subfunction 10H (16)
Set color register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Programs an individual color register with a red-green-blue (RGB)
  combination.

Call with:

  AH            = 10H
  AL            = 10H
  BX            = color register
  CH            = green value
  CL            = blue value
  DH            = red value

Returns:

  Nothing

Note:

  ş If gray-scale summing is enabled, the weighted gray-scale value is
    calculated as described under Int 10H Function 10H Subfunction 1BH and
    is stored into all three components of the color register. See also Int
    10H Function 12H Subfunction 33H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 10H (16) Subfunction 12H (18)
Set block of color registers
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Programs a group of consecutive color registers in one operation.

Call with:

  AH            = 10H
  AL            = 12H
  BX            = first color register
  CX            = number of color registers
  ES:DX         = segment:offset of color table

Returns:

  Nothing

Notes:

  ş The table consists of a series of 3-byte entries, one entry per color
    register to be programmed. The bytes of an individual entry specify the
    red, green, and blue values (in that order) for the associated color
    register.

  ş If gray-scale summing is enabled, the weighted gray-scale value for each
    register is calculated as described under Int 10H Function 10H
    Subfunction 1BH and is stored into all three components of the color
    register. See also Int 10H Function 12H Subfunction 33H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 10H (16) Subfunction 13H (19)
Set color page state
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the paging mode for the color registers, or selects an individual
  page of color registers.

Call with:

  To select the paging mode

  AH            = 10H
  AL            = 13H
  BH            = paging mode
                  00H       for 4 pages of 64 registers
                  01H       for 16 pages of 16 registers

  BL            = 00H

  To select a color register page

  AH            = 10H
  AL            = 13H
  BH            = page
  BL            = 01H

Returns:

  Nothing

Note:

  ş This function is not valid in mode 13H (320-by-200 256-color graphics).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 10H (16) Subfunction 15H (21)
Get color register
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the contents of a color register as its red, green, and blue
  components.

Call with:

  AH            = 10H
  AL            = 15H
  BX            = color register

Returns:

  CH            = green value
  CL            = blue value
  DH            = red value


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 10H (16) Subfunction 17H (23)
Get block of color registers
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allows the red, green, and blue components associated with each of a set
  of color registers to be read in one operation.

Call with:

  AH            = 10H
  AL            = 17H
  BX            = first color register
  CX            = number of color registers
  ES:DX         = segment:offset of buffer to receive color list

Returns:

  ES:DX         = segment:offset of buffer and buffer contains color list

Note:

  ş The color list returned in the caller's buffer consists of a series of
    3-byte entries corresponding to the color registers. Each 3-byte entry
    contains the register's red, green, and blue components in that order.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 10H (16) Subfunction 1AH (26)
Get color page state
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the color register paging mode and current color page.

Call with:

  AH            = 10H
  AL            = 1AH

Returns:

  BH            = color page
  BL            = paging mode
                  00H       if 4 pages of 64 registers
                  01H       if 16 pages of 16 registers

Note:

  ş See Int 10H Function 10H Subfunction 13H, which allows selection of the
    paging mode or current color page.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 10H (16) Subfunction 1BH (27)
Set gray-scale values
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transforms the red, green, and blue values of one or more color registers
  into the gray-scale equivalents.

Call with:

  AH            = 10H
  AL            = 1BH
  BX            = first color register
  CX            = number of color registers

Returns:

  Nothing

Note:

  ş For each color register, the weighted sum of its red, green, and blue
    values is calculated (30% red + 59% green + 11% blue) and written back
    into all three components of the color register. The original red,
    green, and blue values are lost.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunctions 00H and 10H (16)
Load user font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Loads the user's font (character definition) table into the specified
  block of character generator RAM.

Call with:

  AH            = 11H
  AL            = 00H or 10H (see Notes)
  BH            = points (bytes per character)
  BL            = block
  CX            = number of characters defined by table
  DX            = first character code in table
  ES:BP         = segment:offset of font table

Returns:

  Nothing

Notes:

  ş This function provides font selection in text (alphanumeric) display
    modes. For font selection in graphics (all-points-addressable) modes,
    see Int 10H Function 11H Subfunctions 20HÄ24H.

  ş If AL = 10H, page 0 must be active. The points (bytes per character),
    rows, and length of the refresh buffer are recalculated. The controller
    is reprogrammed with the maximum scan line (points - 1), cursor start
    (points - 2), cursor end (points - 1), vertical display end
    ((rows*points) - 1), and underline location (points - 1, mode 7 only).

    If Subfunction 10H is called at any time other than immediately after a
    mode set, the results are unpredictable.

  ş On the MCGA, a Subfunction 00H call should be followed by a Subfunction
    03H call so that the ROM BIOS will load the font into the character
    generator's internal font pages.

  ş Subfunction 10H is reserved on the MCGA. If it is called, Subfunction
    00H is executed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                          [EGA] [VGA]
Function 11H (17) Subfunctions 01H and 11H (17)
Load ROM 8-by-14 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Loads the ROM BIOS default 8-by-14 font table into the specified block of
  character generator RAM.

Call with:

  AH            = 11H
  AL            = 01H or 11H (see Notes)
  BL            = block

Returns:

  Nothing

Notes:

  ş This function provides font selection in text (alphanumeric) display
    modes. For font selection in graphics (all-points-addressable) modes,
    see Int 10H Function 11H Subfunctions 20HÄ24H.

  ş If AL = 11H, page 0 must be active. The points (bytes per character),
    rows, and length of the refresh buffer are recalculated. The controller
    is reprogrammed with the maximum scan line (points - 1), cursor start
    (points - 2), cursor end (points - 1), vertical display end
    ((rows*points) - 1), and underline location (points - 1, mode 7 only).

    If Subfunction 11H is called at any time other than immediately after a
    mode set, the results are unpredictable.

  ş Subfunctions 01H and 11H are reserved on the MCGA. If either is called,
    Subfunction 04H is executed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunctions 02H and 12H (18)
Load ROM 8-by-8 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Loads the ROM BIOS default 8-by-8 font table into the specified block of
  character generator RAM.

Call with:

  AH            = 11H
  AL            = 02H or 12H (see Notes)
  BL            = block

Returns:

  Nothing

Notes:

  ş This function provides font selection in text (alphanumeric) display
    modes. For font selection in graphics (all-points-addressable) modes,
    see Int 10H Function 11H Subfunctions 20HÄ24H.

  ş If AL = 12H, page 0 must be active. The points (bytes per character),
    rows, and length of the refresh buffer are recalculated. The controller
    is reprogrammed with the maximum scan line (points - 1), cursor start
    (points - 2), cursor end (points - 1), vertical display end
    ((rows*points) - 1), and underline location (points - 1, mode 7 only).

    If Subfunction 12H is called at any time other than immediately after a
    mode set, the results are unpredictable.

  ş On the MCGA, a Subfunction 02H call should be followed by a Subfunction
    03H call, so that the ROM BIOS will load the font into the character
    generator's internal font pages.

  ş Subfunction 12H is reserved on the MCGA. If it is called, Subfunction
    02H is executed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 03H
Set block specifier
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Determines the character blocks selected by bit 3 of character attribute
  bytes in alphanumeric (text) display modes.

Call with:

  AH            = 11H
  AL            = 03H
  BL            = character generator block select code (see Notes)

Returns:

  Nothing

Notes:

  ş On the EGA and MCGA, the bits of BL are used as follows:

    Bits      Significance
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0Ä1       character block selected by attribute bytes with bit 3 = 0
    2Ä3       character block selected by attribute bytes with bit 3 = 1
    4Ä7       not used (should be 0)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş On the VGA, the bits of BL are used as follows:

    Bits      Significance
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0,1,4     character block selected by attribute bytes with bit 3 = 0
    2,3,5     character block selected by attribute bytes with bit 3 = 1
    6Ä7       not used (should be 0)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş When using a 256-character set, both fields of BL should select the same
    character block. In such cases, character attribute bit 3 controls the
    foreground intensity. When using 512-character sets, the fields of BL
    designate the blocks holding each half of the character set, and bit 3
    of the character attribute selects the upper or lower half of the
    character set.

  ş When using a 512-character set, a call to Int 10H Function 10H
    Subfunction 00H with BX = 0712H is recommended to set the color planes
    to eight consistent colors.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 11H (17) Subfunctions 04H and 14H (20)
Load ROM 8-by-16 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Loads the ROM BIOS default 8-by-16 font table into the specified block of
  character generator RAM.

Call with:

  AH            = 11H
  AL            = 04H or 14H (see Notes)
  BL            = block

Returns:

  Nothing

Notes:

  ş This function provides font selection in text (alphanumeric) display
    modes. For font selection in graphics (all-points-addressable) modes,
    see Int 10H Function 11H Subfunctions 20HÄ24H.

  ş If AL = 14H, page 0 must be active. The points (bytes per character),
    rows, and length of the refresh buffer are recalculated. The controller
    is reprogrammed with the maximum scan line (points - 1), cursor start
    (points - 2), cursor end (points - 1), vertical display end (rows*points
    - 1 for 350- and 400-line modes, or rows *points *2 - 1 for 200-line
    modes), and underline location (points - 1, mode 7 only).

    If Subfunction 14H is called at any time other than immediately after a
    mode set, the results are unpredictable.

  ş On the MCGA, a Subfunction 04H call should be followed by a Subfunction
    03H call so that the ROM BIOS will load the font into the character
    generator's internal font pages.

  ş Subfunction 14H is reserved on the MCGA. If it is called, Subfunction
    04H is executed.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 20H (32)
Set Int 1FH font pointer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the Int 1FH pointer to the user's font table. This table is used for
  character codes 80HÄFFH in graphics modes 04HÄ06H.

Call with:

  AH            = 11H
  AL            = 20H
  ES:BP         = segment:offset of font table

Returns:

  Nothing

Notes:

  ş This function provides font selection in graphics
    (all-points-addressable) display modes. For font selection in text
    (alphanumeric) modes, see Int 10H Function 11H Subfunctions 00HÄ14H.

  ş If this subfunction is called at any time other than immediately after a
    mode set, the results are unpredictable.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 21H (33)
Set Int 43H for user's font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the vector for Int 43H to point to the user's font table and updates
  the video ROM BIOS data area. The video controller is not reprogrammed.

Call with:

  AH            = 11H
  AL            = 21H
  BL            = character rows specifier

                  00H             if user specified (see register DL)
                  01H           = 14 (0EH) rows
                  02H           = 25 (19H) rows
                  03H           = 43 (2BH) rows

  CX            = points (bytes per character)
  DL            = character rows per screen (if BL = 00H)
  ES:BP         = segment:offset of user font table

Returns:

  Nothing

Notes:

  ş This function provides font selection in graphics
    (all-points-addressable) display modes. For font selection in text
    (alphanumeric) modes, see Int 10H Function 11H Subfunctions 00HÄ14H.

  ş If this subfunction is called at any time other than immediately after a
    mode set, the results are unpredictable.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 22H (34)
Set Int 43H for ROM 8-by-14 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the vector for Int 43H to point to the ROM BIOS default 8-by-14 font
  and updates the video ROM BIOS data area. The video controller is not
  reprogrammed.

Call with:

  AH            = 11H
  AL            = 22H
  BL            = character rows specifier

                  00H             if user specified (see register DL)
                  01H           = 14 (0EH) rows
                  02H           = 25 (19H) rows
                  03H           = 43 (2BH) rows

  DL            = character rows per screen (if BL = 00H)

Returns:

  Nothing

Notes:

  ş This function provides font selection in graphics
    (all-points-addressable) display modes. For font selection in text
    (alphanumeric) modes, see Int 10H Function 11H Subfunctions 00HÄ14H.

  ş If this subfunction is called at any time other than immediately after a
    mode set, the results are unpredictable.

  ş When this subfunction is called on the MCGA, Subfunction 24H is
    substituted.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 23H (35)
Set Int 43H for ROM 8-by-8 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the vector for Int 43H to point to the ROM BIOS default 8-by-8 font
  and updates the video ROM BIOS data area. The video controller is not
  reprogrammed.

Call with:

  AH            = 11H
  AL            = 23H
  BL            = character rows specifier

                  00H             if user specified (see register DL)
                  01H           = 14 (0EH) rows
                  02H           = 25 (19H) rows
                  03H           = 43 (2BH) rows

  DL            = character rows per screen (if BL = 00H)

Returns:

  Nothing

Notes:

  ş This function provides font selection in graphics
    (all-points-addressable) display modes. For font selection in text
    (alphanumeric) modes, see Int 10H Function 11H Subfunctions 00HÄ14H.

  ş If this subfunction is called at any time other than immediately after a
    mode set, the results are unpredictable.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 11H (17) Subfunction 24H (36)
Set Int 43H for ROM 8-by-16 font
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the vector for Int 43H to point to the ROM BIOS default 8-by-16 font
  and updates the video ROM BIOS data area. The video controller is not
  reprogrammed.

Call with:

  AH            = 11H
  AL            = 24H
  BL            = row specifier

                  00H             if user specified (see register DL)
                  01H           = 14 (0EH) rows
                  02H           = 25 (19H) rows
                  03H           = 43 (2BH) rows

  DL            = character rows per screen (if BL = 00H)

Returns:

  Nothing

Notes:

  ş This function provides font selection in graphics
    (all-points-addressable) display modes. For font selection in text
    (alphanumeric) modes, see Int 10H Function 11H Subfunctions 00HÄ14H.

  ş If this subfunction is called at any time other than immediately after a
    mode set, the results are unpredictable.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                   [EGA] [MCGA] [VGA]
Function 11H (17) Subfunction 30H (48)
Get font information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a pointer to the character definition table for a font and the
  points (bytes per character) and rows for that font.

Call with:

  AH            = 11H
  AL            = 30H
  BH            = font code
                  00H = current Int 1FH contents
                  01H = current Int 43H contents
                  02H = ROM 8-by-14 font (EGA, VGA only)
                  03H = ROM 8-by-8 font (characters 00HÄ7FH)
                  04H = ROM 8-by-8 font (characters 80HÄFFH)
                  05H = ROM alternate 9-by-14 font (EGA, VGA only)
                  06H = ROM 8-by-16 font (MCGA, VGA only)
                  07H = ROM alternate 9-by-16 font (VGA only)

Returns:

  CX            = points (bytes per character)
  DL            = rows (character rows on screen - 1)
  ES:BP         = segment:offset of font table


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                          [EGA] [VGA]
Function 12H (18) Subfunction 10H (16)
Get configuration information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains configuration information for the active video subsystem.

Call with:

  AH            = 12H
  BL            = 10H

Returns:

  BH            = display type

                  0         if color display
                  1         if monochrome display

  BL            = memory installed on EGA board

                  00H       if 64 KB
                  01H       if 128 KB
                  02H       if 192 KB
                  03H       if 256 KB

  CH            = feature bits (see Notes)
  CL            = switch setting (see Notes)

Notes:

  ş The feature bits are set from Input Status register 0 in response to an
    output on the specified Feature Control register bits:

    Feature                 Feature control         Input status
    bit(s)                  output bit              bit
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0                       0                       5
    1                       0                       6
    2                       1                       5
    3                       1                       6
    4Ä7                     not used
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş The bits in the switch settings byte indicate the state of the EGA's
    configuration DIP switch (1 = off, 0 = on).

    Bit(s)    Significance
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0         configuration switch 1
    1         configuration switch 2
    2         configuration switch 3
    3         configuration switch 4
    4Ä7       not used
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                          [EGA] [VGA]
Function 12H (18) Subfunction 20H (32)
Select alternate printscreen
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects an alternate print-screen routine for the EGA and VGA that works
  properly if the screen length is not 25 lines. The ROM BIOS default
  print-screen routine always prints 25 lines.

Call with:

  AH            = 12H
  BL            = 20H

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 12H (18) Subfunction 30H (48)
Set scan lines
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the number of scan lines for alphanumeric modes. The selected
  value takes effect the next time Int 10H Function 00H is called to select
  the display mode.

Call with:

  AH            = 12H
  AL            = scan line code
                  00H = 200 scan lines
                  01H = 350 scan lines
                  02H = 400 scan lines
  BL            = 30H

Returns:

  If the VGA is active

  AL            = 12H

  If the VGA is not active

  AL            = 00H


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 12H (18) Subfunction 31H (49)
Enable/disable default palette loading
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables loading of a default palette when a video display mode
  is selected.

Call with:

  AH            = 12H
  AL            = 00H to enable default palette loading
                  01H to disable default palette loading
  BL            = 31H

Returns:

  If function supported

  AL            = 12H


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 12H (18) Subfunction 32H (50)
Enable/disable video
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables CPU access to the video adapter's I/O ports and video
  refresh buffer.

Call with:

  AH            = 12H
  AL            = 00H to enable access
                  01H to disable access
  BL            = 32H

Returns:

  If function supported

  AL            = 12H


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 12H (18) Subfunction 33H (51)
Enable/disable gray-scale summing
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables gray-scale summing for the currently active display.

Call with:

  AH            = 12H
  AL            = 00H to enable gray-scale summing
                  01H to disable gray-scale summing
  BL            = 33H

Returns:

  If function supported

  AL            = 12H

Note:

  ş When enabled, gray-scale summing occurs during display mode selection,
    palette programming, and color register loading.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 12H (18) Subfunction 34H (52)
Enable/disable cursor emulation
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables cursor emulation for the currently active display.
  When cursor emulation is enabled, the ROM BIOS automatically remaps Int
  10H Function 01H cursor starting and ending lines for the current
  character cell dimensions.

Call with:

  AH            = 12H
  AL            = 00H to enable cursor emulation
                  01H to disable cursor emulation
  BL            = 34H

Returns:

  If function supported

  AL            = 12H


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                         [MCGA] [VGA]
Function 12H (18) Subfunction 35H (53)
Switch active display
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allows selection of one of two video adapters in the system when memory
  usage or port addresses conflict between the two adapters.

Call with:

  AH            = 12H
  AL            = switching function

                  00H       to disable initial video adapter
                  01H       to enable system board video adapter
                  02H       to disable active video adapter
                  03H       to enable inactive video adapter

  BL            = 35H
  ES:DX         = segment:offset of 128-byte buffer (if AL = 00H, 02H, or
                  03H)

Returns:

  If function supported

  AL            = 12H

  and, if called with AL = 00H or 02H

  Video adapter state information saved in caller's buffer

  or, if called with AL = 03H

  Video adapter state restored from information in caller's buffer

Notes:

  ş This subfunction cannot be used unless both video adapters have a
    disable capability (Int 10H Function 12H Subfunction 32H).

  ş If there is no conflict between the system board video and the adapter
    board video in memory or port usage, both video controllers can be
    active simultaneously and this subfunction is not required.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                                [VGA]
Function 12H (18) Subfunction 36H (54)
Enable/disable screen refresh
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables the video refresh for the currently active display.

Call with:

  AH            = 12H
  AL            = 00H to enable refresh
                  01H to disable refresh
  BL            = 36H

Returns:

  If function supported

  AL            = 12H


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]
Function 13H (19)
Write string in teletype mode
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transfers a string to the video buffer for the currently active display,
  starting at the specified position.

Call with:

  AH            = 13H
  AL            = write mode

                  0         attribute in BL; string contains character codes
                            only; and cursor position is not updated after
                            write
                  1         attribute in BL;
                            string contains character codes only; and cursor
                            position is updated after write
                  2         string contains alternating character codes and
                            attribute bytes; and cursor position is not
                            updated after write
                  3         string contains alternating character codes and
                            attribute bytes; and cursor position is updated
                            after write

  BH            = page
  BL            = attribute, if AL = 00H or 01H
  CX            = length of character string
  DH            = y coordinate (row)
  DL            = x coordinate (column)
  ES:BP         = segment:offset of string

Returns:

  Nothing

Notes:

  ş This function is not available on the original IBM PC or PC/XT unless an
    EGA video adapter (which contains its own ROM BIOS) is installed.

  ş This function may be thought of as an extension to Int 10H Function
    0EH. The control characters bell (07H), backspace (08H), line feed
    (0AH), and carriage return (0DH) are recognized and handled
    appropriately.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                               [PS/2]
Function 1AH (26)
Get or set display combination code
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a code describing the installed display adapter(s) or updates the
  ROM BIOS's variable describing the installed adapter(s).

Call with:

  AH            = 1AH
  AL            = subfunction
                  00H = get display combination code
                  01H = set display combination code
  BH            = inactive display code (if AL = 01H)
  BL            = active display code (if AL = 01H)

Returns:

  If function supported

  AL            = 1AH

  and, if called with AL = 00H

  BH            = inactive display code
  BL            = active display code

Note:

  ş The display codes are interpreted as follows:

    Code(s)   Video subsystem type
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H       no display
    01H       MDA with 5151 monitor
    02H       CGA with 5153 or 5154 monitor
    03H       reserved
    04H       EGA with 5153 or 5154 monitor
    05H       EGA with 5151 monitor
    06H       PGA with 5175 monitor
    07H       VGA with analog monochrome monitor
    08H       VGA with analog color monitor
    09H       reserved
    0AH       MCGA with digital color monitor
    0BH       MCGA with analog monochrome monitor
    0CH       MCGA with analog color monitor
    0DHÄFEH   reserved
    FFH       unknown
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                               [PS/2]
Function 1BH (27)
Get functionality/state information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains information about the current display mode as well as a pointer to
  a table describing the characteristics and capabilities of the video
  adapter and monitor.

Call with:

  AH            = 1BH
  BX            = implementation type (always 00H)
  ES:DI         = segment:offset of 64-byte buffer

Returns:

  If function supported

  AL            = 1BH

  and information placed in caller's buffer (see Notes)

Notes:

  ş The caller's buffer is filled in with information that depends on the
    current video display mode:


    Byte(s)   Contents
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00HÄ03H   pointer to functionality information (see next Note)
    04H       current video mode
    05HÄ06H   number of character columns
    07HÄ08H   length of video refresh buffer (bytes)
    09HÄ0AH   starting address in buffer of upper left corner of display
    0BHÄ1AH   cursor position for video pages 0Ä7 as eight 2-byte entries;
              first byte of each pair is y coordinate, second byte is x
              coordinate
    1BH       cursor starting line
    1CH       cursor ending line
    1DH       active display page
    1EHÄ1FH   adapter base port address (3BXH monochrome, 3DXH color)
    20H       current setting of register 3B8H or 3D8H
    21H       current setting of register 3B9H or 3D9H
    22H       number of character rows
    23HÄ24H   character height in scan lines
    25H       active display code (see Int 10H Function 1AH)
    26H       inactive display code (see Int 10H Function 1AH)
    27HÄ28H   number of displayable colors (0 for monochrome)
    29H       number of display pages
    2AH       number of scan lines
              00H                = 200 scan lines
              01H                = 350 scan lines
              02H                = 400 scan lines
              03H                = 480 scan lines
              04HÄFFH            = reserved
    2BH       primary character block (see Int 10H Function 11H Subfunction
              03H)
    2CH       secondary character block
    2DH       miscellaneous state information

              Bit(s)     Significance
              0                  = 1 if all modes on all displays active
                                   (always 0 on MCGA)
              1                  = 1 if gray-scale summing active
              2                  = 1 if monochrome display attached
              3                  = 1 if mode set default palette loading
                                   disabled
              4                  = 1 if cursor emulation active (always 0 on
                                   MCGA)
              5                  = state of I/B toggle (0 = intensity, 1 =
                                   blink)
              6Ä7                = reserved

    2EHÄ30H   reserved
    31H       video memory available
              00H                = 64 KB
              01H                = 128 KB
              02H                = 192 KB
              03H                = 256 KB
    32H       save pointer state information

              Bit(s)     Significance
              0                  = 1 if 512-character set active
              1                  = 1 if dynamic save area active
              2                  = 1 if alpha font override active
              3                  = 1 if graphics font override active
              4                  = 1 if palette override active
              5                  = 1 if display combination code (DCC)
                                   extension active
              6Ä7                = reserved

    33HÄ3FH   reserved
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


  ş Bytes 0Ä3 of the caller's buffer contain a DWORD pointer (offset in
    lower word, segment in upper word) to the following information about
    the display adapter and monitor:


    Byte(s)   Contents
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H       video modes supported

              Bit        Significance
              0                  = 1 if mode 00H supported
              1                  = 1 if mode 01H supported
              2                  = 1 if mode 02H supported
              3                  = 1 if mode 03H supported
              4                  = 1 if mode 04H supported
              5                  = 1 if mode 05H supported
              6                  = 1 if mode 06H supported
              7                  = 1 if mode 07H supported

    01H       video modes supported

              Bit        Significance
              0                  = 1 if mode 08H supported
              1                  = 1 if mode 09H supported
              2                  = 1 if mode 0AH supported
              3                  = 1 if mode 0BH supported
              4                  = 1 if mode 0CH supported
              5                  = 1 if mode 0DH supported
              6                  = 1 if mode 0EH supported
              7                  = 1 if mode 0FH supported

    02H       video modes supported

              Bit(s)     Significance
              0                  = 1 if mode 10H supported
              1                  = 1 if mode 11H supported
              2                  = 1 if mode 12H supported
              3                  = 1 if mode 13H supported
              4Ä7                = reserved

    03HÄ06H   reserved
    07H       scan lines available in text modes

              Bit(s)     Significance
              0                  = 1 if 200 scan lines
              1                  = 1 if 350 scan lines
              2                  = 1 if 400 scan lines
              3Ä7                = reserved

    08H       character blocks available in text modes (see Int 10H Function
              11H)
    09H       maximum number of active character blocks in text modes
    0AH       miscellaneous BIOS capabilities

              Bit        Significance
              0                  = 1 if all modes active on all displays
                                   (always 0 for MCGA)
              1                  = 1 if gray-scale summing available
              2                  = 1 if character font loading available
              3                  = 1 if mode set default palette loading
                                   available
              4                  = 1 if cursor emulation available
              5                  = 1 if EGA (64-color) palette available
              6                  = 1 if color register loading available
              7                  = 1 if color register paging mode select
                                   available

    0BH       miscellaneous BIOS capabilities

              Bit(s)     Significance
              0                  = 1 if light pen available
              1                  = 1 if save/restore video state available
                                   (always 0 on MCGA)
              2                  = 1 if background intensity/blinking
                                   control available
              3                  = 1 if get/set display combination code
                                   available
              4Ä7                = reserved

    0CHÄ0DH   reserved
    0EH       save area capabilities

              Bit(s)     Significance
              0                  = 1 if supports 512-character sets
              1                  = 1 if dynamic save area available
              2                  = 1 if alpha font override available
              3                  = 1 if graphics font override available
              4                  = 1 if palette override available
              5                  = 1 if display combination code extension
                                   available
              6Ä7                = reserved

    0FH       reserved
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 10H                                                               [PS/2]
Function 1CH (28)
Save or restore video state
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves or restores the digital-to-analog converter (DAC) state and color
  registers, ROM BIOS video driver data area, or video hardware state.

Call with:

  AH            = 1CH
  AL            = subfunction

                  00H       to get state buffer size
                  01H       to save state
                  02H       to restore state

  CX            = requested states

                  Bit(s)    Significance (if set)
                  0         save/restore video hardware state
                  1         save/restore video BIOS data area
                  2         save/restore video DAC state and color registers
                  3Ä15      reserved

  ES:BX         = segment:offset of buffer

Returns:

  If function supported

  AL            = 1CH

  and, if called with AL = 00H

  BX            = buffer block count (64 bytes per block)

  or, if called with AL = 01H

  State information placed in caller's buffer

  or, if called with AL = 02H

  Requested state restored according to contents of caller's buffer

Notes:

  ş Subfunction 00H is used to determine the size of buffer that will be
    necessary to contain the specified state information. The caller must
    supply the buffer.

  ş The current video state is altered during a save state operation (AL =
    01H). If the requesting program needs to continue in the same video
    state, it can follow the save state request with an immediate call to
    restore the video state.

  ş This function is supported on the VGA only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 11H                                                     [PC] [AT] [PS/2]
Get equipment configuration
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the equipment list code word from the ROM BIOS.

Call with:

  Nothing

Returns:

  AX            = equipment list code word

                  Bit(s)          Significance
                  0               = 1 if floppy disk drive(s) installed
                  1               = 1 if math coprocessor installed
                  2               = 1 if pointing device installed (PS/2)

                  2Ä3               system board ram size (PC, see Note)

                                    00            = 16 KB
                                    01            = 32 KB
                                    10            = 48 KB
                                    11            = 64 KB

                  4Ä5               initial video mode

                                    00            reserved
                                    01            40-by-25 color text
                                    10            80-by-25 color text
                                    11            80-by-25 monochrome

                  6Ä7               number of floppy disk drives (if bit 0 =
                                    1)

                                    00            = 1
                                    01            = 2
                                    10            = 3
                                    11            = 4

                  8                 reserved
                  9Ä11              number of RS-232 ports installed

                  12              = 1 if game adapter installed
                  13              = 1 if internal modem installed (PC and XT
                                  only)
                                  = 1 if serial printer attached (PCjr)

                  14Ä15             number of printers installed

Note:

  ş Bits 2Ä3 of the returned value are used only in the ROM BIOS for the
    original IBM PC with the 64 KB system board and on the PCjr.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 12H                                                     [PC] [AT] [PS/2]
Get conventional memory size
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the amount of conventional memory available for use by MS-DOS and
  application programs.

Call with:

  Nothing

Returns:

  AX            = memory size (in KB)

Notes:

  ş On some early PC models, the amount of memory returned by this function
    is controlled by the settings of the dip switches on the system board
    and may not reflect all the memory that is physically present.

  ş On the PC/AT, the value returned is the amount of functional memory
    found during the power-on self-test, regardless of the memory size
    configuration information stored in CMOS RAM.

  ş The value returned does not reflect any extended memory (above the 1 MB
    boundary) that may be installed on 80286 or 80386 machines such as the
    PC/AT or PS/2 (Models 50 and above).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 00H
Reset disk system
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Resets the disk controller, recalibrates its attached drives (the
  read/write arm is moved to cylinder 0), and prepares for disk I/O.

Call with:

  AH            = 00H
  DL            = drive
                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function should be called after a failed floppy disk Read, Write,
    Verify, or Format request before retrying the operation.

  ş If called with DL >= 80H (i.e., selecting a fixed disk drive), the
    floppy disk controller and then the fixed disk controller are reset. See
    also Int 13H Function 0DH, which allows the fixed disk controller to be
    reset without affecting the floppy disk controller.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 01H
Get disk system status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the status of the most recent disk operation.

Call with:

  AH            = 01H
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

Returns:

  AH            = 00H
  AL            = status of previous disk operation

                  00H       no error
                  01H       invalid command
                  02H       address mark not found
                  03H       disk write-protected (F)
                  04H       sector not found
                  05H       reset failed (H)
                  06H       floppy disk removed (F)
                  07H       bad parameter table (H)
                  08H       DMA overrun (F)
                  09H       DMA crossed 64 KB boundary
                  0AH       bad sector flag (H)
                  0BH       bad track flag (H)
                  0CH       media type not found (F)
                  0DH       invalid number of sectors on format (H)
                  0EH       control data address mark detected (H)
                  0FH       DMA arbitration level out of range (H)
                  10H       uncorrectable CRC
Cyclic Redundancy Check code
 or ECC
Error Checking and Correcting code
 data error
                  11H       ECC corrected data error (H)
                  20H       controller failed
                  40H       seek failed
                  80H       disk timed-out (failed to respond)
                  AAH       drive not ready (H)
                  BBH       undefined error (H)
                  CCH       write fault (H)
                  E0H       status register error (H)
                  FFH       sense operation failed (H)

                  H = fixed disk only, F = floppy disk only

Note:

  ş On fixed disks, error code 11H (ECC data error) indicates that a
    recoverable error was detected during a preceding Read Sector (Int 13H
    Function 02H) function.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 02H
Read sector
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads one or more sectors from disk into memory.

Call with:

  AH            = 02H
  AL            = number of sectors
  CH            = cylinder
  CL            = sector
  DH            = head
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  AL            = number of sectors transferred

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş On fixed disks, the upper 2 bits of the 10-bit cylinder number are
    placed in the upper 2 bits of register CL.

  ş On fixed disks, error code 11H indicates that a read error occurred that
    was corrected by the ECC algorithm; in this event, register AL contains
    the burst length. The data returned is probably good, although there is
    a small chance that the data was not corrected properly. If a
    multi-sector transfer was requested, the operation was terminated after
    the sector containing the read error.

  ş On floppy disk drives, an error may result from the drive motor being
    off at the time of the request. The ROM BIOS does not automatically wait
    for the drive to come up to speed before attempting the read operation.
    The requesting program should reset the floppy disk system (Int 13H
    Function 00H) and retry the operation three times before assuming that
    the error results from some other cause.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 03H
Write sector
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes one or more sectors from memory to disk.

Call with:

  AH            = 03H
  AL            = number of sectors
  CH            = cylinder
  CL            = sector
  DH            = head
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  AL            = number of sectors transferred

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş On fixed disks, the upper 2 bits of the 10-bit cylinder number are
    placed in the upper 2 bits of register CL.

  ş On floppy disk drives, an error may result from the drive motor being
    off at the time of the request. The ROM BIOS does not automatically wait
    for the drive to come up to speed before attempting the write operation.
    The requesting program should reset the floppy disk system (Int 13H
    Function 00H) and retry the operation three times before assuming that
    the error results from some other cause.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 04H
Verify sector
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Verifies the address fields of one or more sectors. No data is transferred
  to or from memory by this operation.

Call with:

  AH            = 04H
  AL            = number of sectors
  CH            = cylinder
  CL            = sector
  DH            = head
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  AL            = number of sectors verified

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş On PCs, PC/XTs, and PC/ATs with ROM BIOS dated earlier than 11/15/85,
    ES:BX should point to a valid buffer.

  ş On fixed disks, the upper 2 bits of the 10-bit cylinder number are
    placed in the upper 2 bits of register CL.

  ş This function can be used to test whether a readable media is in a
    floppy disk drive. An error may result from the drive motor being off at
    the time of the request, because the ROM BIOS does not automatically
    wait for the drive to come up to speed before attempting the verify
    operation. The requesting program should reset the floppy disk system
    (Int 13H Function 00H) and retry the operation three times before
    assuming that a readable floppy disk is not present.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 05H
Format track
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes disk sector and track address fields on the specified track.

Call with:

  AH            = 05H
  AL            = interleave (PC/XT fixed disks)
  CH            = cylinder
  DH            = head
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk
  ES:BX         = segment:offset of address field list (except PC/XT fixed
                  disk, see Note)

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş On floppy disks, the address field list consists of a series of 4-byte
    entries, one entry per sector, in the following format:

    Byte(s)     Contents
    0           cylinder
    1           head
    2           sector
    3           sector-size code

                00H         if 128 bytes per sector
                01H         if 256 bytes per sector
                02H         if 512 bytes per sector (standard)
                03H         if 1024 bytes per sector

  ş On floppy disks, the number of sectors per track is taken from the BIOS
    floppy disk parameter table whose address is stored in the vector for
    Int 1EH.

  ş When this function is used for floppy disks on the PC/AT or PS/2, it
    should be preceded by a call to Int 13H Function 17H to select the type
    of medium to be formatted.

  ş On fixed disks, the upper 2 bits of the 10-bit cylinder number are
    placed in the upper 2 bits of register CL.

  ş On PC/XT-286, PC/AT, and PS/2 fixed disks, ES:BX points to a 512-byte
    buffer containing byte pairs for each physical disk sector, as follows:

    Byte(s)     Contents
    0           00H for good sector
                80H for bad sector
    1           sector number

    For example, to format a track with 17 sectors and an interleave of two,
    ES:BX would point to the following 34-byte array at the beginning of a
    512-byte buffer:

    db      00h,01h,00h,0ah,00h,02h,00h,0bh,00h,03h,00h,0ch
    db      00h,04h,00h,0dh,00h,05h,00h,0eh,00h,06h,00h,0fh
    db      00h,07h,00h,10h,00h,08h,00h,11h,00h,09h


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 06H
Format bad track
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes a track, writing disk address fields and data sectors and
  setting bad sector flags.

Call with:

  AH            = 06H
  AL            = interleave
  CH            = cylinder
  DH            = head
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is defined for PC/XT fixed disk drives only.

  ş For additional information, see Notes for Int 13H Function 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 07H
Format drive
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Formats the entire drive, writing disk address fields and data sectors,
  starting at the specified cylinder.

Call with:

  AH            = 07H
  AL            = interleave
  CH            = cylinder
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is defined for PC/XT fixed disk drives only.

  ş For additional information, see Notes for Int 13H Function 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 08H
Get drive parameters
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns various parameters for the specified drive.

Call with:

  AH            = 08H
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  BL            = drive type (PC/AT and PS/2 floppy disks)

                  01H       if 360 KB, 40 track, 5.25"
                  02H       if 1.2 MB, 80 track, 5.25"
                  03H       if 720 KB, 80 track, 3.5"
                  04H       if 1.44 MB, 80 track, 3.5"
  CH            = low 8 bits of maximum cylinder number

  CL            = bits 6Ä7  high-order 2 bits of maximum cylinder number
                  bits 0Ä5  maximum sector number

  DH            = maximum head number
  DL            = number of drives
  ES:DI         = segment:offset of disk drive parameter table

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş On the PC and PC/XT, this function is supported on fixed disks only.

  ş The value returned in register DL reflects the true number of physical
    drives attached to the adapter for the requested drive.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 09H
Initialize fixed disk characteristics
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes the fixed disk controller for subsequent I/O operations, using
  the values found in the ROM BIOS disk parameter block(s).

Call with:

  AH            = 09H
  DL            = drive

                  80HÄFFH   fixed disk

  and, on the PC/XT
  Vector for Int 41H must point to disk parameter block

  or, on the PC/AT and PS/2
  Vector for Int 41H must point to disk parameter block for drive 0
  Vector for Int 46H must point to disk parameter block for drive 1

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is supported on fixed disks only.

  ş For PC and PC/XT fixed disks, the parameter block format is as follows:

    Byte(s)           Contents
    00HÄ01H           maximum number of cylinders
    02H               maximum number of heads
    03HÄ04H           starting reduced write current cylinder
    05HÄ06H           starting write precompensation cylinder
    07H               maximum ECC burst length
    08H               drive options

                      Bit(s)            Significance (if set)
                      0Ä2               drive option
                      3Ä5               reserved (0)
                      6                 disable ECC retries
                      7                 disable disk-access retries

    09H               standard time-out value
    0AH               time-out value for format drive
    0BH               time-out value for check drive
    0CHÄ0FH           reserved

  ş For PC/AT and PS/2 fixed disks, the parameter block format is as
    follows:

    Byte(s)           Contents
    00HÄ01H           maximum number of cylinders
    02H               maximum number of heads
    03HÄ04H           reserved
    05HÄ06H           starting write precompensation cylinder
    07H               maximum ECC burst length
    08H               drive options

                      Bit(s)            Significance (if set)
                      0Ä2               not used
                      3                 more than 8 heads
                      4                 not used
                      5                 manufacturer's defect map present at
                                        maximum
                                        cylinder + 1
                      6Ä7               nonzero (10, 01, or 11) if retries
                                        disabled

    09HÄ0BH           reserved
    0CHÄ0DH           landing zone cylinder
    0EH               sectors per track
    0FH               reserved


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 0AH (10)
Read sector long
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads a sector or sectors from disk into memory, along with a 4-byte ECC
  code for each sector.

Call with:

  AH            = 0AH
  AL            = number of sectors
  CH            = cylinder
  CL            = sector (see Notes)
  DH            = head
  DL            = drive

                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  AL            = number of sectors transferred

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is supported on fixed disks only.

  ş The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
    bits of register CL.

  ş Unlike the normal Read Sector function (Int 13H Function 02H), ECC
    errors are not automatically corrected. Multisector transfers are
    terminated after any sector with a read error.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 0BH (11)
Write sector long
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes a sector or sectors from memory to disk. Each sector's worth of
  data must be followed by its 4-byte ECC code.

Call with:

  AH            = 0BH
  AL            = number of sectors
  CH            = cylinder
  CL            = sector (see Notes)
  DH            = head
  DL            = drive

                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of buffer
Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  AL            = number of sectors transferred

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is supported on fixed disks only.

  ş The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
    bits of register CL.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 0CH (12)
Seek
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Positions the disk read/write heads to the specified cylinder, but does
  not transfer any data.

Call with:

  AH            = 0CH
  CH            = lower 8 bits of cylinder
  CL            = upper 2 bits of cylinder in bits 6Ä7
  DH            = head
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is supported on fixed disks only.

  ş The upper 2 bits of the 10-bit cylinder number are placed in the upper 2
    bits of register CL.

  ş The Read Sector, Read Sector Long, Write Sector, and Write Sector Long
    functions include an implied seek operation and need not be preceded by
    an explicit call to this function.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 0DH (13)
Reset fixed disk system
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Resets the fixed disk controller, recalibrates attached drives (moves the
  read/write arm to cylinder 0), and prepares for subsequent disk I/O.

Call with:

  AH            = 0DH
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on fixed disks only. It differs from Int 13H
    Function 00H in that the floppy disk controller is not reset.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 0EH (14)
Read sector buffer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transfers the contents of the fixed disk adapter's internal sector buffer
  to system memory. No data is read from the physical disk drive.

Call with:

  AH            = 0EH
  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported by the PC/XT's fixed disk adapter only. It is
    not defined for fixed disk adapters on the PC/AT or PS/2.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 0FH (15)
Write sector buffer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transfers data from system memory to the fixed disk adapter's internal
  sector buffer. No data is written to the physical disk drive.

Call with:

  AH            = 0FH
  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is supported by the PC/XT's fixed disk adapter only. It is
    not defined for fixed disk adapters on the PC/AT or PS/2.

  ş This function should be called to initialize the contents of the sector
    buffer before formatting the drive with Int 13H Function 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 10H (16)
Get drive status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Tests whether the specified fixed disk drive is operational and returns
  the drive's status.

Call with:

  AH            = 10H
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 11H (17)
Recalibrate drive
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Causes the fixed disk adapter to recalibrate itself for the specified
  drive, positioning the read/write arm to cylinder 0, and returns the
  drive's status.

Call with:

  AH            = 11H
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 12H (18)
Controller RAM diagnostic
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Causes the fixed disk adapter to carry out a built-in diagnostic test on
  its internal sector buffer, indicating whether the test was passed by the
  returned status.

Call with:

  AH            = 12H

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on PC/XT fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                                 [PC]
Function 13H (19)
Controller drive diagnostic
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Causes the fixed disk adapter to run internal diagnostic tests of the
  attached drive, indicating whether the test was passed by the returned
  status.

Call with:

  AH            = 13H

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on PC/XT fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                     [PC] [AT] [PS/2]
Function 14H (20)
Controller internal diagnostic
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Causes the fixed disk adapter to carry out a built-in diagnostic
  self-test, indicating whether the test was passed by the returned status.

Call with:

  AH            = 14H

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is supported on fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                          [AT] [PS/2]
Function 15H (21)
Get disk type
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a code indicating the type of floppy or fixed disk referenced by
  the specified drive code.

Call with:

  AH            = 15H
  DL            = drive

                  00HÄ7FH   floppy disk
                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = drive type code

                  00H       if no drive present
                  01H       if floppy disk drive without change-line support
                  02H       if floppy disk drive with change-line support
                  03H       if fixed disk

  and, if fixed disk (AH = 03H)

  CX:DX         = number of 512-byte sectors

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is not supported on the PC or PC/XT.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                          [AT] [PS/2]
Function 16H (22)
Get disk change status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the status of the change line, indicating whether the disk in the
  drive may have been replaced since the last disk access.

Call with:

  AH            = 16H
  DL            = drive
                  00HÄ7FH   floppy disk

Returns:

  If change line inactive (disk has not been changed)

  Carry flag    = clear
  AH            = 00H

  If change line active (disk may have been changed)

  Carry flag    = set
  AH            = 06H

Notes:

  ş If this function returns with the carry flag set, the disk has not
    necessarily been changed; the change line can be activated by simply
    unlocking and locking the disk drive door without removing the floppy
    disk.

  ş This function is not supported for floppy disks on the PC or PC/XT.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                          [AT] [PS/2]
Function 17H (23)
Set disk type
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects a floppy disk type for the specified drive.

Call with:

  AH            = 17H
  AL            = floppy disk type code

                  00H       not used
                  01H       320/360 KB floppy disk in 360 KB drive
                  02H       320/360 KB floppy disk in 1.2 MB drive
                  03H       1.2 MB floppy disk in 1.2 MB drive
                  04H       720 KB floppy disk in 720 KB drive
  SL            = drive

                  00HÄ7FH   floppy disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This function is not supported for floppy disks on the PC or PC/XT.

  ş If the change line is active for the specified drive, it is reset. The
    ROM BIOS then sets the data rate for the specified drive and media type.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                          [AT] [PS/2]
Function 18H (24)
Set media type for format
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects media characteristics for the specified drive.

Call with:

  AH            = 18H
  CH            = number of cylinders
  CL            = sectors per track
  DL            = drive

                  00HÄ7FH   floppy disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  ES:DI         = segment:offset of disk parameter table for media type

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş A floppy disk must be present in the drive.

  ş This function should be called prior to formatting a disk with Int 13H
    Function 05H so that the ROM BIOS can set the correct data rate for the
    media.

  ş If the change line is active for the specified drive, it is reset.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                               [PS/2]
Function 19H (25)
Park heads
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Moves the read/write arm to a track that is not used for data storage, so
  that data will not be damaged when the drive is turned off.

Call with:

  AH            = 19H
  DL            = drive

                  80HÄFFH   fixed disk

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Note:

  ş This function is defined for PS/2 fixed disks only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 13H                                                               [PS/2]
Function 1AH (26)
Format ESDI drive
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes disk sector and track address fields on a drive attached to
  the ESDI Fixed Disk Drive Adapter/A.

Call with:

  AH            = 1AH
  AL            = relative block address (RBA) defect table count

                  0         if no RBA table
                  >0        if RBA table used

  CL            = format modifier bits

                  Bit(s)    Significance (if set)
                  0         ignore primary defect map
                  1         ignore secondary defect map
                  2         update secondary defect map (see Notes)
                  3         perform extended surface analysis
                  4         generate periodic interrupt (see Notes)
                  5Ä7       reserved (must be 0)
  DL            = drive

                  80HÄFFH   fixed disk

  ES:BX         = segment:offset of RBA table

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 13H Function 01H)

Notes:

  ş This operation is sometimes called a "low level format" and prepares the
    disk for physical read/write operations at the sector level. The drive
    must be subsequently partitioned with the FDISK command and then given a
    "high level format" with the FORMAT command to install a file system.

  ş If bit 4 of register CL is set, Int 15H is called with AH = 0FH and AL
    = phase code after each cylinder is formatted or analyzed. The phase
    code is defined as:

    0 = reserved
    1 = surface analysis
    2 = formatting

    See also Int 15H Function 0FH.

  ş If bit 2 of register CL is set, the drive's secondary defect map is
    updated to reflect errors found during surface analysis. If both bit 2
    and bit 1 are set, the secondary defect map is replaced.

  ş For an extended surface analysis, the disk should first be formatted by
    calling this function with bit 3 cleared, then analyzed by calling this
    function with bit 3 set.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                     [PC] [AT] [PS/2]
Function 00H
Initialize communications port
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes a serial communications port to a desired baud rate, parity,
  word length, and number of stop bits.

Call with:

  AH            = 00H
  AL            = initialization parameter (see Notes)
  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  AH            = port status

                  Bit       Significance (if set)
                  0         receive data ready
                  1         overrun error detected
                  2         parity error detected
                  3         framing error detected
                  4         break detected
                  5         transmit holding register empty
                  6         transmit shift register empty
                  7         timed-out

  AL            = modem status

                  Bit       Significance (if set)
                  0         change in clear-to-send status
                  1         change in data-set-ready status
                  2         trailing edge ring indicator
                  3         change in receive line signal detect
                  4         clear-to-send
                  5         data-set-ready
                  6         ring indicator
                  7         receive line signal detect

Notes:

  ş The initialization parameter byte is defined as follows:

    7 6 5             4 3               2                 1 0
    Baud rate         Parity            Stop bits         Word length
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    000 = 110         X0 = none         0 = 1 bit         10 = 7 bits
    001 = 150         01 = odd          1 = 2 bits        11 = 8 bits
    010 = 300         11 = even
    011 = 600
    100 = 1200
    101 = 2400
    110 = 4800
    111 = 9600
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş To initialize the serial port for data rates greater than 9600 baud on
    PS/2 machines, see Int 14H Functions 04H and 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                     [PC] [AT] [PS/2]
Function 01H
Write character to communications port
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes a character to the specified serial communications port, returning
  the current status of the port.

Call with:

  AH            = 01H
  AL            = character
  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  If function successful

  AH bit 7      = 0
  AH bits       = port status
  0Ä6
                  Bit       Significance (if set)
                  0         receive data ready
                  1         overrun error detected
                  2         parity error detected
                  3         framing error detected
                  4         break detected
                  5         transmit holding register empty
                  6         transmit shift register empty

  AL            = character (unchanged)

  If function unsuccessful (timed-out)

  AH bit 7      = 1
  AL            = character (unchanged)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                     [PC] [AT] [PS/2]
Function 02H
Read character from communications port
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads a character from the specified serial communications port, also
  returning the port's status.

Call with:

  AH            = 02H
  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  If function successful

  AH bit 7      = 0
  AH bits 0Ä6   = status

                  Bit       Significance (if set)
                  1         overrun error detected
                  2         parity error detected
                  3         framing error detected
                  4         break detected

  AL            = character

  If function unsuccessful (timed-out)

  AH bit 7      = 1


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                     [PC] [AT] [PS/2]
Function 03H
Get communications port status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the status of the specified serial communications port.

Call with:

  AH            = 03H
  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  AH            = port status (see Int 14H Function 00H)
  AL            = modem status (see Int 14H Function 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                               [PS/2]
Function 04H
Extended initialize communications port
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes a serial communications port to a desired baud rate, parity,
  word length, and number of stop bits. Provides a superset of Int 14H
  Function 00H capabilities for PS/2 machines.

Call with:

  AH            = 04H
  AL            = break flag

                  00H       no break
                  01H       break

  BH            = parity

                  00H       none
                  01H       odd
                  02H       even
                  03H       stick parity odd
                  04H       stick parity even

  BL            = stop bits

                  00H       1 stop bit
                  01H       2 stop bits if word length = 6Ä8 bits
                  01H       1.5 stop bits if word length = 5 bits

  CH            = word length

                  00H       5 bits
                  01H       6 bits
                  02H       7 bits
                  03H       8 bits

  CL            = baud rate

                  00H       110 baud
                  01H       150 baud
                  02H       300 baud
                  03H       600 baud
                  04H       1200 baud
                  05H       2400 baud
                  06H       4800 baud
                  07H       9600 baud
                  08H       19,200 baud

  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  AH            = port status (see Int 14H Function 00H)
  AL            = modem status (see Int 14H Function 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 14H                                                               [PS/2]
Function 05H
Extended communications port control
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads or sets the modem control register (MCR) for the specified serial
  communications port.

Call with:

  AH            = 05H
  AL            = subfunction

                  00H       to read modem control register
                  01H       to write modem control register

  BL            = modem control register contents (if AL = 01H)

                  Bit(s)    Significance
                  0         data-terminal ready
                  1         request-to-send
                  2         Out1
                  3         Out2
                  4         loop (for testing)
                  5Ä7       reserved

  DX            = communications port number (0 = COM1, 1 = COM2, etc.)

Returns:

  If called with AL = 00H

  BL            = modem control register contents (see above)

  If called with AL = 01H

  AH            = port status (see Int 14H Function 00H)
  AL            = modem status (see Int 14H Function 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                                 [PC]
Function 00H
Turn on cassette motor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Turns on the motor of the cassette tape drive.

Call with:

  AH            = 00H

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set

  AH            = status

                  86H       if cassette not present

Note:

  ş This function is available only on the PC and the PCjr. It is not
    supported on the PC/XT and all subsequent models.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                                 [PC]
Function 01H
Turn off cassette motor
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Turns off the motor of the cassette tape drive.

Call with:

  AH            = 01H

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  86H       if cassette not present

Note:

  ş This function is available only on the PC and the PCjr. It is not
    supported on the PC/XT and all subsequent models.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                                 [PC]
Function 02H
Read cassette
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads one or more 256-byte blocks of data from the cassette tape drive to
  memory.

Call with:

  AH            = 02H
  CX            = number of bytes to read
  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear
  DX            = number of bytes actually read
  ES:BX         = segment:offset + 1 of last byte read

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  01H       if CRC error
                  02H       if bit signals scrambled
                  04H       if no data found
                  80H       if invalid command
                  86H       if cassette not present

Note:

  ş This function is available only on the PC and on the PCjr. It is not
    supported on the PC/XT and all subsequent models.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                                 [PC]
Function 03H
Write cassette
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Writes one or more 256-byte blocks of data from memory to the cassette
  tape drive.

Call with:

  AH            = 03H
  CX            = number of bytes to write
  ES:BX         = segment:offset of buffer

Returns:

  If function successful

  Carry flag    = clear
  CX            = 00H
  ES:BX         = segment:offset + 1 of last byte written

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  80H       if invalid command
                  86H       if cassette not present

Note:

  ş This function is available only on the PC and on the PCjr. It is not
    supported on the PC/XT and all subsequent models.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function 0FH (15)
Format ESDI drive periodic interrupt
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Invoked by the ROM BIOS on the ESDI Fixed Disk Drive Adapter/A during a
  format or surface analysis operation after each cylinder is completed.

Call with:

  AH            = 0FH
  AL            = phase code
                  0 = reserved
                  1 = surface analysis
                  2 = formatting

Returns:

  If formatting or analysis should continue

  Carry flag    = clear

  If formatting or analysis should be terminated

  Carry flag    = set

Notes:

  ş This function call can be captured by a program so that it will be
    notified as each cylinder is formatted or analyzed. The program can
    count interrupts for each phase to determine the current cylinder
    number.

  ş The default ROM BIOS handler for this function returns with the carry
    flag set.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function 21H (33) Subfunction 00H
Read POST error log
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns error information that was accumulated during the most recent
  power-on self-test (POST).

Call with:

  AH            = 21H
  AL            = 00H

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  BX            = number of POST error codes stored
  ES:DI         = segment:offset of POST error log

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  80H =     invalid command
                  86H =     function not supported

Notes:

  ş The error log consists of single-word entries. The first byte of an
    entry is the device error code, and the second is the device identifier.

  ş This function is not available on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function 21H (33) Subfunction 01H
Write POST error log
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Adds an entry to the power-on self-test (POST) error log.

Call with:

  AH            = 21H
  AL            = 01H
  BH            = device identifier
  BL            = device error code

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  01H =     error list full
                  80H =     invalid command
                  86H =     function not supported

Note:

  ş This function is not available on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function 4FH (79)
Keyboard intercept
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Invoked for each keystroke by the ROM BIOS's Int 09H keyboard interrupt
  handler.

Call with:

  AH            = 4FH
  AL            = scan code

Returns:

  If scan code consumed

  Carry flag    = clear

  If scan code not consumed

  Carry flag    = set
  AL            = unchanged or new scan code

Notes:

  ş An operating system or a resident utility can capture this function to
    filter the raw keyboard data stream. The new handler can substitute a
    new scan code, return the same scan code, or return the carry flag clear
    causing the keystroke to be discarded. The default ROM BIOS routine
    simply returns the scan code unchanged.

  ş A program can call Int 15H Function C0H to determine whether the host
    machine's ROM BIOS supports this keyboard intercept.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 80H (128)
Device open
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Acquires ownership of a logical device for a process.

Call with:

  AH            = 80H
  BX            = device ID
  CX            = process ID

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

Note:

  ş This function call, along with Int 15H Functions 81H and 82H, defines
    a simple protocol that can be used to arbitrate usage of devices by
    multiple processes. A multitasking program manager would be expected to
    capture Int 15H and provide the appropriate service. The default BIOS
    routine for this function simply returns with the carry flag clear and
    AH = 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 81H (129)
Device close
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Releases ownership of a logical device for a process.

Call with:

  AH            = 81H
  BX            = device ID
  CX            = process ID

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

Note:

  ş A multitasking program manager would be expected to capture Int 15H and
    provide the appropriate service. The default BIOS routine for this
    function simply returns with the carry flag clear and AH = 00H. See also
    Int 15H Functions 80H and 82H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 82H (130)
Process termination
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Releases ownership of all logical devices for a process that is about to
  terminate.

Call with:

  AH            = 82H
  BX            = process ID

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

Note:

  ş A multitasking program manager would be expected to capture Int 15H and
    provide the appropriate service. The default BIOS routine for this
    function simply returns with the carry flag clear and AH = 00H. See also
    Int 15H Functions 80H and 81H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 83H (131)
Event wait
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Requests setting of a semaphore after a specified interval or cancels a
  previous request.

Call with:

  If requesting event wait

  AH            = 83H
  AL            = 00H
  CX:DX         = microseconds
  ES:BX         = segment:offset of semaphore byte

  If canceling event wait

  AH            = 83H
  AL            = 01H

Returns:

  If called with AL = 00H, and function successful

  Carry flag    = clear

  If called with AL = 00H, and function unsuccessful (Event Wait already
  active)

  Carry flag    = set

  If called with AL = 01H

  Nothing

Notes:

  ş The function call returns immediately. If the function is successful,
    bit 7 of the semaphore byte is set when the specified interval has
    elapsed. The calling program is responsible for clearing the semaphore
    before requesting this function.

  ş The actual duration of an event wait is always an integral multiple of
    976 microseconds. The CMOS date/clock chip interrupts are used to
    implement this function.

  ş Use of this function allows programmed, hardware-independent delays at a
    finer resolution than can be obtained through use of the MS-DOS Get Time
    function (Int 21H Function 2CH, which returns time in hundredths of a
    second).

  ş See also Int 15H Function 86H, which suspends the calling program for
    the specified interval in milliseconds.

  ş This function is not supported on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 84H (132)
Read joystick
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the joystick switch settings and potentiometer values.

Call with:

  AH            = 84H
  DX            = subfunction

                  00H       to read switch settings
                  01H       to read resistive inputs

Returns:

  If function successful

  Carry flag    = clear

  and, if called with DX = 00H

  AL            = switch settings (bits 4Ä7)

  or, if called with DX = 01H

  AX            = A(x) value
  BX            = A(y) value
  CX            = B(x) value
  DX            = B(y) value

  If function unsuccessful

  Carry flag    = set

Notes:

  ş An error condition is returned if DX does not contain a valid
    subfunction number.

  ş If no game adapter is installed, AL is returned as 00H for Subfunction
    00H (i.e., all switches open); AX, BX, CX, and DX are returned
    containing 00H for Subfunction 01H.

  ş Using a 250 KOhm joystick, the potentiometer values usually lie within
    the srange 0Ä416 (0000Ä01A0H).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 85H (133)
SysReq key
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Invoked by the ROM BIOS keyboard driver when the SysReq key is detected.

Call with:

  AH            = 85H
  AL            = key status

                  00H       if key make (depression)
                  01H       if key break (release)

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

Note:

  ş The ROM BIOS handler for this function call is a dummy routine that
    always returns a success status unless called with an invalid
    subfunction number in AL. A multitasking program manager would be
    expected to capture Int 15H so that it can be notified when the user
    strikes the SysReq key.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 86H (134)
Delay
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Suspends the calling program for a specified interval in microseconds.

Call with:

  AH            = 86H
  CX:DX         = microseconds to wait

Returns:

  If function successful (wait was performed)

  Carry flag    = clear

  If function unsuccessful (wait was not performed)

  Carry flag    = set

Notes:

  ş The actual duration of the wait is always an integral multiple of 976
    microseconds.

  ş Use of this function allows programmed, hardware-independent delays at a
    finer resolution than can be obtained through use of the MS-DOS Get Time
    function (Int 21H Function 2CH, which returns time in hundredths of a
    second).

  ş See also Int 15H Function 83H, which triggers a semaphore after a
    specified interval but does not suspend the calling program.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 87H (135)
Move extended memory block
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transfers data between conventional memory and extended memory.

Call with:

  AH            = 87H
  CX            = number of words to move
  ES:SI         = segment:offset of Global Descriptor Table (see Notes)

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  01H       if RAM parity error
                  02H       if exception interrupt error
                  03H       if gate address line 20 failed

Notes:

  ş Conventional memory lies at addresses below the 640 KB boundary, and is
    used for the execution of MS-DOS and its application programs. Extended
    memory lies at addresses above 1 MB, and can only be accessed by an
    80286 or 80386 CPU running in protected mode. As much as 15 MB of
    extended memory can be installed in an IBM PC/AT or compatible.

  ş The Global Descriptor Table (GDT) used by this function must be set up
    as follows:

    Byte(s)     Contents
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00HÄ0FH     reserved (should be 0)
    10HÄ11H     segment length in bytes (2*CX - 1 or greater)
    12HÄ14H     24-bit source address
    15H         access rights byte (always 93H)
    16HÄ17H     reserved (should be 0)
    18HÄ19H     segment length in bytes (2*CX - 1 or greater)
    1AHÄ1CH     24-bit destination address
    1DH         access rights byte (always 93H)
    1EHÄ2FH     reserved (should be 0)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    The table is composed of six 8-byte descriptors to be used by the CPU in
    protected mode. The four descriptors in offsets 00HÄ0FH and 20HÄ2FH are
    filled in by the ROM BIOS before the CPU mode switch.

  ş The addresses used in the descriptor table are linear (physical) 24-bit
    addresses in the range 000000HÄFFFFFFHÄÄnot segments and offsetsÄÄwith
    the least significant byte at the lowest address and the most
    significant byte at the highest address.

  ş The block move is performed with interrupts disabled; thus, use of this
    function may interfere with the operation of communications programs,
    network drivers, or other software that relies on prompt servicing of
    hardware interrupts.

  ş Programs and drivers that access extended memory with this function
    cannot be executed in the Compatibility Environment of OS/2.

  ş This function is not supported on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 88H (136)
Get extended memory size
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the amount of extended memory installed in the system.

Call with:

  AH            = 88H

Returns:

  AX            = amount of extended memory (in KB)

Notes:

  ş Extended memory is memory at addresses above 1 MB, which can only be
    accessed by an 80286 or 80386 CPU running in protected mode. Because
    MS-DOS is a real-mode operating system, extended memory can be used for
    storage of volatile data but cannot be used for execution of programs.

  ş Programs and drivers that use this function cannot be executed in the
    Compatibility Environment of OS/2.

  ş This function is not supported on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 89H (137)
Enter protected mode
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Switches the CPU from real mode into protected mode.

Call with:

  AH            = 89H
  BH            = interrupt number for IRQ0, written to ICW2 of 8259 PIC #1
                  (must be evenly divisible by 8, determines IRQ0ÄIRQ7)
  BL            = interrupt number for IRQ8, written to ICW2 of 8259 PIC #2
                  (must be evenly divisible by 8, determines IRQ8ÄIRQ15)
  ES:SI         = segment:offset of Global Descriptor Table (GDT)

Returns:

  If function successful (CPU is in protected mode)

  Carry flag    = clear
  AH            = 00H
  CS            = user-defined selector
  DS            = user-defined selector
  ES            = user-defined selector
  SS            = user-defined selector

  If function unsuccessful (CPU is in real mode)

  Carry flag    = set
  AH            = FFH

Notes:

  ş The Global Descriptor Table must contain eight descriptors set up as
    follows:

    Offset      Descriptor usage
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H         dummy descriptor (initialized to 0)
    08H         Global Descriptor Table (GDT)
    10H         Interrupt Descriptor Table (IDT)
    18H         user's data segment (DS)
    20H         user's extra segment (ES)
    28H         user's stack segment (SS)
    30H         user's code segment (CS)
    38H         BIOS code segment
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    The user must initialize the first seven descriptors; the eighth is
    filled in by the ROM BIOS to provide addressability for its own
    execution. The calling program may modify and use the eighth descriptor
    for any purpose after return from this function call.

  ş This function is not supported on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 90H (144)
Device wait
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Invoked by the ROM BIOS fixed disk, floppy disk, printer, network, and
  keyboard drivers prior to performing a programmed wait for I/O completion.

Call with:

  AH            = 90H
  AL            = device type

                  00HÄ7FH   serially reusable devices
                  80HÄBFH   reentrant devices
                  C0HÄFFH   wait-only calls, no corresponding Post function

  ES:BX         = segment:offset of request block for device types 80HÄFFH

Returns:

  If no wait (driver must perform its own time-out)

  Carry flag    = clear
  AH            = 00H

  If wait was performed

  Carry flag    = set

Notes:

  ş Predefined device types are:

    00H         disk (may time-out)
    01H         floppy disk (may time-out)
    02H         keyboard (no time-out)
    03H         pointing device (PS/2, may time-out)
    80H         network (no time-out)
    FCH         fixed disk reset (PS/2, may time-out)
    FDH         floppy disk drive motor start (may time-out)
    FEH         printer (may time-out)

  ş For network adapters, ES:BX points to a network control block (NCB).

  ş A multitasking program manager would be expected to capture Int 15H
    Function 90H so that it can dispatch other tasks while I/O is in
    progress. The default BIOS routine for this function simply returns with
    the carry flag clear and AH = 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function 91H (145)
Device post
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Invoked by the ROM BIOS fixed disk, floppy disk, network, and keyboard
  drivers to signal that I/O is complete and/or the device is ready.

Call with:

  AH            = 91H
  AL            = device type

                  00HÄ7FH   serially reusable devices
                  80HÄBFH   reentrant devices

  ES:BX         = segment:offset of request block for device types 80HÄBFH

Returns:

  AH            = 00H

Notes:

  ş Predefined device types that may use Device Post are:

    00H         disk (may time-out)
    01H         floppy disk (may time-out)
    02H         keyboard (no time-out)
    03H         pointing device (PS/2, may time-out)
    80H         network (no time-out)

  ş The ROM BIOS printer routine does not invoke this function because
    printer output is not interrupt driven.

  ş A multitasking program manager would be expected to capture Int 15H
    Function 91H so that it can be notified when I/O is completed and
    awaken the requesting task. The default BIOS routine for this function
    simply returns with the carry flag clear and AH = 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                          [AT] [PS/2]
Function C0H (192)
Get system environment
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a pointer to a table containing various information about the
  system configuration.

Call with:

  AH            = C0H

Returns:

  ES:BX         = segment:offset of configuration table (see Notes)

Notes:

  ş The format of the system configuration table is as follows:

    Byte(s)   Contents
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00HÄ01H   length of table in bytes
    02H       system model (see following Note)
    03H       system submodel (see following Note)
    04H       BIOS revision level
    05H       configuration flags

              Bit                  Significance (if set)
              0                    reserved
              1                    Micro Channel implemented
              2                    extended BIOS data area allocated
              3                    Wait for External Event is available
              4                    keyboard intercept (Int 15H Function
                                   4FH) available
              5                    real-time clock available
              6                    slave 8259 present (cascaded IRQ2)
              7                    DMA channel 3 used
    06HÄ09H   reserved
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş The system model and type bytes are assigned as follows:

    Machine              Model byte          Submodel byte
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    PC                   FFH
    PC/XT                FEH
    PC/XT                FBH                 00H or 01H
    PCjr                 FDH
    PC/AT                FCH                 00H or 01H
    PC/XT-286            FCH                 02H
    PC Convertible       F9H
    PS/2 Model 30        FAH                 00H
    PS/2 Model 50        FCH                 04H
    PS/2 Model 60        FCH                 05H
    PS/2 Model 70        F8H                 04H or 09H
    PS/2 Model 80        F8H                 00H or 01H
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C1H (193)
Get address of extended BIOS data area
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the segment address of the base of the extended BIOS data area.

Call with:

  AH            = C1H

Returns:

  If function successful

  Carry flag    = clear
  ES            = segment of extended BIOS data area

  If function unsuccessful

  Carry flag    = set

Notes:

  ş The extended BIOS data area is allocated at the high end of conventional
    memory during the POST (Power-On-Self-Test) sequence. The word at
    0040:0013H (memory size) is updated to reflect the reduced amount of
    memory available for MS-DOS and application programs. The first byte in
    the extended BIOS data area is initialized to its length in KB.

  ş A program can determine whether the extended BIOS data area exists with
    Int 15H Function C0H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 00H
Enable/disable pointing device
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables the system's mouse or other pointing device.

Call with:

  AH            = C2H
  AL            = 00H
  BH            = enable/disable flag

                  00H =     disable
                  01H =     enable

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status

                  01H       if invalid function call
                  02H       if invalid input
                  03H       if interface error
                  04H       if resend
                  05H       if no far call installed


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 01H
Reset pointing device
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Resets the system's mouse or other pointing device, setting the sample
  rate, resolution, and other characteristics to their default values.

Call with:

  AH            = C2H
  AL            = 01H

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  BH            = device ID

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)

Notes:

  ş After a reset operation, the state of the pointing device is as follows:

    ù disabled;

    ù sample rate at 100 reports per second;

    ù resolution at 4 counts per millimeter;

    ù and scaling at 1 to 1.

  The data package size is unchanged by this function.

  ş The application can use the other Int 15H Function C2H subfunctions to
    initialize the pointing device to other sample rates, resolution, and
    scaling, and then enable the device with Int 15H Function C2H
    Subfunction 00H.

  ş See also Int 15H Function C2H Subfunction 05H, which incidentally
    resets the pointing device in a similar manner.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 02H
Set sample rate
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the sampling rate of the system's mouse or other pointing device.

Call with:

  AH            = C2H
  AL            = 02H
  BH            = sample rate value

                  00H =     10 reports per second
                  01H =     20 reports per second
                  02H =     40 reports per second
                  03H =     60 reports per second
                  04H =     80 reports per second
                  05H =     100 reports per second
                  06H =     200 reports per second

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)

Note:

  ş The default sample rate is 100 reports per second after a reset
    operation (Int 15H Function C2H Subfunction 01H).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 03H
Set resolution
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the resolution of the system's mouse or other pointing device.

Call with:

  AH            = C2H
  AL            = 03H
  BH            = resolution value

                  00H =     1 count per millimeter
                  01H =     2 counts per millimeter
                  02H =     4 counts per millimeter
                  03H =     8 counts per millimeter

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)

Note:

  ş The default resolution is 4 counts per millimeter after a reset
    operation (Int 15H Function C2H Subfunction 01H).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 04H
Get pointing device type
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the identification code for the system's mouse or other pointing
  device.

Call with:

  AH            = C2H
  AL            = 04H

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H
  BH            = device ID

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 05H
Initialize pointing device interface
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the data package size for the system's mouse or other pointing
  device, and initializes the resolution, sampling rate, and scaling to
  their default values.

Call with:

  AH            = C2H
  AL            = 05H
  BH            = data package size in bytes (1Ä8)

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)

Note:

  ş After this operation, the state of the pointing device is as follows:

    ù disabled;

    ù sample rate at 100 reports per second;

    ù resolution at 4 counts per millimeter;

    ù and scaling at 1 to 1.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 06H
Set scaling or get status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current status of the system's mouse or other pointing device
  or sets the device's scaling factor.

Call with:

  AH            = C2H
  AL            = 06H
  BH            = extended command

                  00H =     return device status
                  01H =     set scaling at 1:1
                  02H =     set scaling at 2:1

Returns:

  If function successful

  Carry flag    = clear
  AH            = 00H

  and, if called with BH = 00H

  BL            = status byte

                  Bit       Significance
                  0 =       1 if right button pressed
                  1 =       reserved
                  2 =       1 if left button pressed
                  3 =       reserved
                  4 =       0 if 1:1 scaling
                            1 if 2:1 scaling
                  5 =       0 if device disabled
                            1 if device enabled
                  6 =       0 if stream mode
                            1 if remote mode
                  7 =       reserved

  CL            = resolution

                  00H =     1 count per millimeter
                  01H =     2 counts per millimeter
                  02H =     4 counts per millimeter
                  03H =     8 counts per millimeter

  DL            = sample rate

                  0AH =     10 reports per second
                  14H =     20 reports per second
                  28H =     40 reports per second
                  3CH =     60 reports per second
                  50H =     80 reports per second
                  64H =     100 reports per second
                  C8H =     200 reports per second

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C2H (194) Subfunction 07H
Set pointing device handler address
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Notifies the ROM BIOS pointing device driver of the address for a routine
  to be called each time pointing device data is available.

Call with:

  AH            = C2H
  AL            = 07H
  ES:BX         = segment:offset of user routine

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set
  AH            = status (see Int 15H Function C2H Subfunction 00H)

Notes:

  ş The user's handler for pointing device data is entered via a far call
    with four parameters on the stack:

    SS:SP+0AH   status
    SS:SP+08H   x coordinate
    SS:SP+06H   y coordinate
    SS:SP+04H   z coordinate (always 0)

    The handler must exit via a far return without removing the parameters
    from the stack.

  ş The status parameter passed to the user's handler is interpreted as
    follows:

    Bit(s)      Significance (if set)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0           left button pressed
    1           right button pressed
    2Ä3         reserved
    4           sign of x data is negative
    5           sign of y data is negative
    6           x data has overflowed
    7           y data has overflowed
    8Ä15        reserved
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C3H (195)
Set watchdog time-out
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables or disables a watchdog timer.

Call with:

  AH            = C3H
  AL            = subfunction

                  00H       to disable watchdog time-out
                  01H       to enable watchdog time-out

  BX            = watchdog timer counter (if AL = 01H)

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set

Notes:

  ş The watchdog timer generates an NMI interrupt.

  ş This function is not available on the PS/2 Models 25 and 30.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 15H                                                               [PS/2]
Function C4H (196)
Programmable option select
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the base Programmable Option Select register address, enables a
  slot for setup, or enables an adapter.

Call with:

  AH            = C4H
  AL            = subfunction

                  00H       to return base POS adapter register address
                  01H       to enable slot
                  02H       to enable adapter

  BL            = slot number (if AL = 01H)

Returns:

  If function successful

  Carry flag    = clear

  and, if called with AL = 00H

  DX            = base POS adapter register address

  If function unsuccessful

  Carry flag    = set

Notes:

  ş This function is available only on machines using the Micro Channel
    Architecture (MCA) bus.

  ş After a slot is enabled with Subfunction 01H, specific information can
    be obtained for the adapter in that slot by performing port input
    operations:

    Port        Function
    100H        MCA ID (low byte)
    101H        MCA ID (high byte)
    102H        Option Select Byte 1
                bit 0 = 1 if enabled, = 0 if disabled
    103H        Option Select Byte 2
    104H        Option Select Byte 3
    105H        Option Select Byte 4
                bits 6Ä7 = channel check indicators
    106H        Subaddress Extension (low byte)
    107H        Subaddress Extension (high byte)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                     [PC] [AT] [PS/2]
Function 00H
Read character from keyboard
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads a character from the keyboard, also returning the keyboard scan
  code.

Call with:

  AH            = 00H

Returns:

  AH            = keyboard scan code
  AL            = ASCII character


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                     [PC] [AT] [PS/2]
Function 01H
Get keyboard status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Determines whether a character is ready for input, returning a flag and
  also the character itself, if one is waiting.

Call with:

  AH            = 01H

Returns:

  If key waiting to be input

  Zero flag     = clear
  AH            = keyboard scan code
  AL         
  = character

  If no key waiting

  Zero flag     = set

Note:

  ş The character returned by this function when the zero flag is clear is
    not removed from the type-ahead buffer. The same character and scan code
    will be returned by the next call to Int 16H Function 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                     [PC] [AT] [PS/2]
Function 02H
Get keyboard flags
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the ROM BIOS flags byte that describes the state of the various
  keyboard toggles and shift keys.

Call with:

  AH            = 02H

Returns:

  AL            = flags
                  Bit       Significance (if set)
                  0         right Shift key is down
                  1         left Shift key is down
                  2         Ctrl key is down
                  3         Alt key is down
                  4         Scroll Lock on
                  5         Num Lock on
                  6         Caps Lock on
                  7         Insert on

Note:

  ş The keyboard flags byte is stored in the ROM BIOS data area at
    0000:0417H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                     [PC] [AT] [PS/2]
Function 03H
Set repeat rate
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the ROM BIOS key repeat ("typematic") rate and delay.

Call with:

  On the PC/AT and PS/2

  AH            = 03H
  AL            = 05H
  BH            = repeat delay (see Notes)
  BL            = repeat rate (see Notes)

  On the PCjr

  AH            = 03H
  AL            = subfunction

                  00H       to restore default rate and delay
                  01H       to increase initial delay
                  02H       to decrease repeat rate by one-half
                  03H       to increase delay and decrease repeat rate by
                            one-half
                  04H       to turn off keyboard repeat

Returns:

  Nothing

Notes:

  ş Subfunctions 00HÄ04H are available on the PCjr but are not supported by
    the PC or PC/XT ROM BIOS. Subfunction 05H is available on PC/ATs with
    ROM BIOS's dated 11/15/85 and later, and on the PS/2.

  ş On the PC/AT and PS/2, the value in BH controls the amount of delay
    before the first repeat key is generated. The delay is always a multiple
    of 250 milliseconds:

    Value       Delay (msec.)
    00H         250
    01H         500
    02H         750
    03H         1000

  ş On the PC/AT and PS/2, the value for the repeat rate in characters per
    second can be chosen from the following table:

    Value       Repeat rate (characters per second)
    00H         30.0
    01H         26.7
    02H         24.0
    03H         21.8
    04H         20.0
    05H         18.5
    06H         17.1
    07H         16.0
    08H         15.0
    09H         13.3
    0AH         12.0
    0BH         10.9
    0CH         10.0
    0DH          9.2
    0EH          8.6
    0FH          8.0
    10H          7.5
    11H          6.7
    12H          6.0
    13H          5.5
    14H          5.0
    15H          4.6
    16H          4.3
    17H          4.0
    18H          3.7
    19H          3.3
    1AH          3.0
    1BH          2.7
    1CH          2.5
    1DH          2.3
    1EH          2.1
    1FH          2.0


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                                 [PC]
Function 04H
Set keyclick
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Turns the keyboard click on or off.

Call with:

  AH            = 04H
  AL            = subfunction

                  00H       to turn off keyboard click
                  01H       to turn on keyboard click

Returns:

  Nothing

Note:

  ş This function is supported by the PCjr BIOS only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                          [AT] [PS/2]
Function 05H
Push character and scan code
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Places a character and scan code in the keyboard type-ahead buffer.

Call with:

  AH            = 05H
  CH            = scan code
  CL            = character

Returns:

  If function successful

  Carry flag    = clear
  AL            = 00H

  If function unsuccessful (type-ahead buffer is full)

  Carry flag    = set
  AL            = 01H

Note:

  ş This function can be used by keyboard enhancers and other utilities to
    interpolate keys into the data stream seen by application programs.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                          [AT] [PS/2]
Function 10H (16)
Read character from enhanced keyboard
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads a character and scan code from the keyboard type-ahead buffer.

Call with:

  AH            = 10H

Returns:

  AH            = keyboard scan code
  AL            = ASCII character

Note:

  ş Use this function for the enhanced keyboard instead of Int 16H Function
    00H. It allows applications to obtain the scan codes for the additional
    F11, F12, and cursor control keys.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                          [AT] [PS/2]
Function 11H (17)
Get enhanced keyboard status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Determines whether a character is ready for input, returning a flag and
  also the character itself, if one is waiting.

Call with:

  AH            = 11H

Returns:

  If key waiting to be input

  Zero flag     = clear
  AH            = keyboard scan code
  AL            = character

  If no key waiting

  Zero flag     = set

Notes:

  ş Use this function for the enhanced keyboard instead of Int 16H Function
    00H. It allows applications to test for the additional F11, F12, and
    cursor control keys.

  ş The character returned by this function when the zero flag is clear is
    not removed from the type-ahead buffer. The same character and scan code
    will be returned by the next call to Int 16H Function 10H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 16H                                                          [AT] [PS/2]
Function 12H (18)
Get enhanced keyboard flags
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the status of various enhanced keyboard special keys and keyboard
  driver states.

Call with:

  AH            = 12H

Returns:

  AX            = flags

                  Bit       Significance (if set)
                  0         right Shift key is down
                  1         left Shift key is down
                  2         either Ctrl key is down
                  3         either Alt key is down
                  4         Scroll Lock toggle is on
                  5         Num Lock toggle is on
                  6         Caps Lock toggle is on
                  7         Insert toggle is on
                  8         left Ctrl key is down
                  9         left Alt key is down
                  10        right Ctrl key is down
                  11        right Alt key is down
                  12        Scroll key is down
                  13        Num Lock key is down
                  14        Caps Lock key is down
                  15        SysReq key is down

Note:

  ş Use this function for the enhanced keyboard instead of Int 16H Function
    02H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 17H                                                     [PC] [AT] [PS/2]
Function 00H
Write character to printer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sends a character to the specified parallel printer interface port and
  returns the current status of the port.

Call with:

  AH            = 00H
  AL            = character
  DX            = printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)

Returns:

  AH            = status

                  Bit       Significance (if set)
                  0         printer timed-out
                  1         unused
                  2         unused
                  3         I/O error
                  4         printer selected
                  5         out of paper
                  6         printer acknowledge
                  7         printer not busy


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 17H                                                     [PC] [AT] [PS/2]
Function 01H
Initialize printer port
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes the specified parallel printer interface port and returns its
  status.

Call with:

  AH            = 01H
  DX            = printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)

Returns:

  AH            = status (see Int 17H Function 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 17H                                                     [PC] [AT] [PS/2]
Function 02H
Get printer status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current status of the specified parallel printer interface
  port.

Call with:

  AH            = 02H
  DX            = printer number (0 = LPT1, 1 = LPT2, 2 = LPT3)

Returns:

  AH            = status (see Int 17H Function 00H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 18H                                                     [PC] [AT] [PS/2]
ROM BASIC
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Transfers control to ROM BASIC.

Call with:

  Nothing

Returns:

  Nothing

Note:

  ş This function is invoked when the system is turned on or restarted if
    attempts to read a boot sector from the fixed disk or floppy disk drives
    are unsuccessful.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 19H                                                     [PC] [AT] [PS/2]
Reboot system
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reboots the operating system from the floppy disk or fixed disk drive.

Call with:

  Nothing

Returns:

  Nothing

Notes:

  ş The bootstrap routine reads Sector 1, Track 0 into memory at location
    0000:7C00H and transfers control to the same address. If attempts to
    read a boot sector from the floppy disk or fixed disk are unsuccessful,
    control is transferred to ROM BASIC by execution of an Int 18H.

  ş If location 0000:0472H does not contain the value 1234H, a memory test
    will be performed before reading the boot sector.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 00H
Get tick count
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the contents of the clock tick counter.

Call with:

  AH            = 00H

Returns:

  AL            = rolled-over flag

                  00H       if midnight not passed since last read
                  <>00H     if midnight was passed since last read

  CX:DX         = tick count (high 16 bits in CX)

Notes:

  ş This function is supported by the PC/XT and PCjr ROM BIOS, but is not
    present in the ROM BIOS for the original PC.

  ş The returned value is the cumulative number of clock ticks since
    midnight. There are 18.2 clock ticks per second. When the counter
    reaches 1,573,040, it is cleared to zero, and the rolled-over flag is
    set.

  ş The rolled-over flag is cleared by this function call, so the flag will
    only be returned nonzero once per day.

  ş Int 1AH Function 01H can be used to set the clock tick counter to an
    arbitrary 32-bit value.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 01H
Set tick count
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Stores a 32-bit value in the clock tick counter.

Call with:

  AH            = 01H
  CX:DX         = tick count (high 16 bits in CX)

Returns:

  Nothing

Notes:

  ş This function is supported by the PC/XT and PCjr ROM BIOS, but is not
    present in the ROM BIOS for the original PC.

  ş Int 1AH Function 00H is used to read the value of the clock tick
    counter.

  ş The rolled-over flag is cleared by this function call.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 02H
Get time
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads the current time from the CMOS time/date chip.

Call with:

  AH            = 02H

Returns:

  CH            = hours in binary coded decimal (BCD)
  CL            = minutes in BCD
  DH            = seconds in BCD
  DL            = daylight-saving-time code

                  00H       if standard time
                  01H       if daylight saving time

  and, if clock running

  Carry flag    = clear

  or, if clock stopped

  Carry flag    = set


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 03H
Set time
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the time in the CMOS time/date chip.

Call with:

  AH            = 03H
  CH            = hours in binary coded decimal (BCD)
  CL            = minutes in BCD
  DH            = seconds in BCD
  DL            = daylight-saving-time code

                  00H       if standard time
                  01H       if daylight saving time

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 04H
Get date
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Reads the current date from the CMOS time/date chip.

Call with:

  AH            = 04H

Returns:

  CH            = century (19 or 20) in binary coded decimal (BCD)
  CL            = year in BCD
  DH            = month in BCD
  DL            = day in BCD

  and, if clock running

  Carry flag    = clear

  or, if clock stopped

  Carry flag    = set


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 05H
Set date
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the date in the CMOS time/date chip.

Call with:

  AH            = 05H
  CH            = century (19 or 20) in binary coded decimal (BCD)
  CL            = year in BCD
  DH            = month in BCD
  DL            = day in BCD

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 06H
Set alarm
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets an alarm in the CMOS date/time chip.

Call with:

  AH            = 06H
  CH            = hours in binary coded decimal (BCD)
  CL            = minutes in BCD
  DH            = seconds in BCD

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful (alarm already set, or clock stopped)

  Carry flag    = set

Notes:

  ş A side effect of this function is that the clock chip's interrupt level
    (IRQ8) is enabled.

  ş Only one alarm may be active at any given time. The alarm occurs every
    24 hours at the specified time until it is reset with Int 1AH Function
    07H.

  ş The program using this function must place the address of its interrupt
    handler for the alarm in the vector for Int 4AH.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                          [AT] [PS/2]
Function 07H
Reset alarm
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Cancels any pending alarm request on the CMOS date/time chip.

Call with:

  AH            = 07H

Returns:

  Nothing

Note:

  ş This function does not disable the clock chip's interrupt level (IRQ8).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                               [PS/2]
Function 0AH (10)
Get day count
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the contents of the system's day counter.

Call with:

  AH            = 0AH

Returns:

  If function successful

  Carry flag    = clear
  CX            = count of days since January 1, 1980

  If function unsuccessful

  Carry flag    = set


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                               [PS/2]
Function 0BH (11)
Set day count
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Stores an arbitrary value in the system's day counter.

Call with:

  AH            = 0BH
  CX            = count of days since January 1, 1980

Returns:

  If function successful

  Carry flag    = clear

  If function unsuccessful

  Carry flag    = set


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 1AH                                                                 [PC]
Function 80H (128)
Set sound source
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets up the source for tones that will appear on the PCjr's "Audio Out" or
  RF modulator.

Call with:

  AH            = 80H
  AL            = sound source

                  00H       if 8253 programmable timer, channel 2
                  01H       if cassette input
                  02H       if "Audio In" line on I/O channel
                  03H       if sound generator chip

Returns:

  Nothing

Note:

  ş This function is supported on the PCjr only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Microsoft Mouse driver
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  The Microsoft Mouse driver makes its functions available to application
  programs via Int 33H. These functions have become a de facto standard for
  pointer device drivers of all varieties. Unlike the other function calls
  described in this section, the Microsoft Mouse driver is not part of the
  ROM BIOS but is loaded by a DEVICE= directive in the CONFIG.SYS file. All
  mouse-function information applies to the Microsoft Mouse driver version
  6. Earlier versions of the driver may not support all of these functions.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 00H
Reset mouse and get status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Initializes the mouse driver and returns the driver status. If the mouse
  pointer was previously visible, it is removed from the screen, and any
  previously installed user handlers for mouse events are disabled.

Call with:

  AX            = 0000H

Returns:

  If mouse support is available

  AX            = FFFFH
  BX            = number of mouse buttons

  If mouse support is not available

  AX            = 0000H

Note:

  ş After a call to this function, the mouse driver is initialized to the
    following state:

    ù Mouse pointer at screen center (see Int 33H Functions 03H and 04H)

    ù Display page for mouse pointer set to zero (see Int 33H Functions
      1DH and 1EH)

    ù Mouse pointer hidden (see Int 33H Functions 01H, 02H, and 10H)

    ù Mouse pointer set to default arrow shape in graphics modes, or reverse
      block in text modes (see Int 33H Functions 09H and 0AH)

    ù User mouse event handler disabled (see Int 33H Functions 0CH and
      14H)

    ù Light pen emulation enabled (see Int 33H Functions 0DH and 0EH)

    ù Horizontal mickeys to pixels ratio at 8 to 8, vertical ratio at 16 to
      8 (see Int 33H Function 0FH)

    ù Double speed threshold set to 64 mickeys/second (see Int 33H Function
      19H)

    ù Minimum and maximum horizontal and vertical pointer position limits
      set to include the entire screen in the current display mode (see Int
      33H Functions 07H and 08H)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 01H
Show mouse pointer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Displays the mouse pointer, and cancels any mouse pointer exclusion area
  previously defined with Int 33H Function 10H.

Call with:

  AX            = 0001H

Returns:

  Nothing

Note:

  ş A counter is maintained which is decremented by calls to Int 33H
    Function 02H (Hide Mouse Pointer) and incremented (if nonzero) by this
    function. When the counter is zero or becomes zero, the mouse pointer is
    displayed. When the mouse driver is reset with Int 33H Function 00H,
    the counter is forced to -1.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 02H
Hide mouse pointer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Removes the mouse pointer from the display. The driver continues to track
  the mouse position.

Call with:

  AX            = 0002H

Returns:

  Nothing

Note:

  ş A counter is maintained which is decremented by calls to this function
    and incremented (if nonzero) by Int 33H Function 01H (Show Mouse
    Pointer). When the counter is zero, the mouse pointer is displayed. When
    the mouse driver is reset with Int 33H Function 00H, the counter is
    forced to -1.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 03H
Get mouse position and button status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current mouse button status and pointer position.

Call with:

  AX            = 0003H

Returns:

  BX            = mouse button status

                  Bit(s)    Significance (if set)
                  0         left button is down
                  1         right button is down
                  2         center button is down
                  3Ä15      reserved (0)

  CX            = horizontal (X) coordinate
  DX            = vertical (Y) coordinate

Note:

  ş Coordinates are returned in pixels regardless of the current display
    mode. Position (x,y) = (0,0) is the upper left corner of the screen.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 04H
Set mouse pointer position
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the position of the mouse pointer. The pointer is displayed at the
  new position unless it has been hidden with Int 33H Function 02H, or the
  new position lies within an exclusion area defined with Int 33H Function
  10H.

Call with:

  AX            = 0004H
  CX            = horizontal (X) coordinate
  DX            = vertical (Y) coordinate

Returns:

  Nothing

Notes:

  ş Coordinates are specified in pixels regardless of the current display
    mode. Position (x,y) = (0,0) is the upper left corner of the screen.

  ş The position is adjusted if necessary to lie within the horizontal and
    vertical limits specified with a previous call to Int 33H Functions
    07H and 08H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 05H
Get button press information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current status of all mouse buttons, and the number of presses
  and position of the last press for a specified mouse button since the last
  call to this function for that button. The press counter for the button is
  reset to zero.

Call with:

  AX            = 0005H
  BX            = button identifier

                  0 =       left button
                  1 =       right button
                  2 =       center button

Returns:

  AX            = button status

                  Bit(s)    Significance (if set)
                  0         left button is down
                  1         right button is down
                  2         center button is down
                  3Ä15      reserved (0)

  BX            = button press counter
  CX            = horizontal (X) coordinate of last button press
  DX            = vertical (Y) coordinate of last button press


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 06H
Get button release information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current status of all mouse buttons, and the number of
  releases and position of the last release for a specified mouse button
  since the last call to this function for that button. The release counter
  for the button is reset to zero.

Call with:

  AX            = 0006H
  BX            = button identifier

                  0 =       left button
                  1 =       right button
                  2 =       center button

Returns:

  AX            = button status

                  Bit(s)    Significance (if set)
                  0         left button is down
                  1         right button is down
                  2         center button is down
                  3Ä15      reserved (0)

  BX            = button release counter
  CX            = horizontal (X) coordinate of last button release
  DX            = vertical (Y) coordinate of last button release


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 07H
Set horizontal limits for pointer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Limits the mouse pointer display area by assigning minimum and maximum
  horizontal (X) coordinates for the mouse pointer.

Call with:

  AX            = 0007H
  CX            = minimum horizontal (X) coordinate
  DX            = maximum horizontal (X) coordinate

Returns:

  Nothing

Notes:

  ş If the minimum value is greater than the maximum value, the two values
    are swapped.

  ş The mouse pointer will be moved if necessary so that it lies within the
    specified horizontal coordinates.

  ş See also Int 33H Function 10H, which defines an exclusion area for the
    mouse pointer.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 08H
Set vertical limits for pointer
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Limits the mouse pointer display area by assigning minimum and maximum
  vertical (Y) coordinates for the mouse pointer.

Call with:

  AX            = 0008H
  CX            = minimum vertical (Y) coordinate
  DX            = maximum vertical (Y) coordinate

Returns:

  Nothing

Notes:

  ş If the minimum value is greater than the maximum value, the two values
    are swapped.

  ş The mouse pointer will be moved if necessary so that it lies within the
    specified vertical coordinates.

  ş See also Int 33H Function 10H, which defines an exclusion area for the
    mouse pointer.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 09H
Set graphics pointer shape
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Defines the shape, color, and hot spot of the mouse pointer in graphics
  modes.

Call with:

  AX            = 0009H
  BX            = hot spot offset from left
  CX            = hot spot offset from top
  ES:DX         = segment:offset of pointer image buffer

Returns:

  Nothing

Notes:

  ş The pointer image buffer is 64 bytes long. The first 32 bytes contain a
    bit mask which is ANDed with the screen image, and the second 32 bytes
    contain a bit mask which is XORed with the screen image.

  ş The hot spot is relative to the upper left corner of the pointer image,
    and each pixel offset must be in the range -16 through 16. In display
    modes 4 and 5, the horizontal offset must be an even number.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0AH (10)
Set text pointer type
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Defines the shape and attributes of the mouse pointer in text modes.

Call with:

  AX            = 000AH
  BX            = pointer type

                  0 =       software cursor
                  1 =       hardware cursor

  CX            = AND mask value (if BX = 0) or
                  starting line for cursor (if BX = 1)
  DX            = XOR mask value (if BX = 0) or
                  ending line for cursor (if BX = 1)

Returns:

  Nothing

Notes:

  ş If the software text cursor is selected (BX = 0), the masks in CX and DX
    are mapped as follows:

    Bit(s)      Significance
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    0Ä7         character code
    8Ä10        foreground color
    11          intensity
    12Ä14       background color
    15          blink
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    For example, the following values would yield a software mouse cursor
    that inverts the foreground and background colors:

    AX          = 000AH
    BX          = 0000H
    CX          = 77FFH
    DX          = 7700H

  ş When the hardware text cursor is selected (BX = 1), the values in CX and
    DX are the starting and ending scan lines for the blinking cursor
    generated by the video adapter. The maximum scan line which may be used
    depends on the type of adapter and the current display mode.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0BH (11)
Read mouse motion counters
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the net mouse displacement since the last call to this function.
  The returned value is in mickeys; a positive number indicates travel to
  the right or downwards, a negative number indicates travel to the left or
  upwards. One mickey represents approximately 1/200 of an inch of mouse
  movement.

Call with:

  AX            = 000BH

Returns:

  CX            = horizontal (X) mickey count
  DX            = vertical (Y) mickey count


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0CH (12)
Set user-defined mouse event handler
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the address and event mask for an application program's mouse event
  handler. The handler is called by the mouse driver whenever the specified
  mouse events occur.

Call with:

  AX            = 000CH
  CX            = event mask

                  Bit(s)    Significance (if set)
                  0         mouse movement
                  1         left button pressed
                  2         left button released
                  3         right button pressed
                  4         right button released
                  5         center button pressed
                  6         center button released
                  7Ä15      reserved (0)

  ES:DX         = segment:offset of handler

Returns:

  Nothing

Notes:

  ş The user-defined event handler is entered from the mouse driver by a far
    call with registers set up as follows:

    AX             mouse event flags (see event mask)
    BX             button state

                   Bit(s)     Significance (if set)
                   0          left button is down
                   1          right button is down
                   2          center button is down
                   3Ä15       reserved (0)

    CX             horizontal (X) pointer coordinate
    DX             vertical (Y) pointer coordinate
    SI             last raw vertical mickey count
    DI             last raw horizontal mickey count
    DS             mouse driver data segment

  ş If an event does not generate a call to the user-defined handler because
    its bit is not set in the event mask, it is still reported in the event
    flags during calls to the handler for events which are enabled.

  ş Calls to the handler are disabled with Int 33H Function 00H or by
    calling this function with an event mask of zero.

  ş See also Int 33H Functions 14H and 18H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0DH (13)
Turn on light pen emulation
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables light pen emulation by the mouse driver for IBM BASIC. A "pen
  down" condition is created by pressing the left and right mouse buttons
  simultaneously.

Call with:

  AX            = 000DH

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0EH (14)
Turn off light pen emulation
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Disables light pen emulation by the mouse driver for IBM BASIC.

Call with:

  AX            = 000EH

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 0FH (15)
Set mickeys to pixels ratio
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the number of mickeys per 8 pixels for horizontal and vertical mouse
  motion. One mickey represents approximately 1/200 of an inch of mouse
  travel.

Call with:

  AX            = 000FH
  CX            = horizontal mickeys (1Ä32,767, default = 8)
  DX            = vertical mickeys (1Ä32,767, default = 16)

Returns:

  Nothing


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 10H (16)
Set mouse pointer exclusion area
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Defines an exclusion area for the mouse pointer. When the mouse pointer
  lies within the specified area, it is not displayed.

Call with:

  AX            = 0010H
  CX            = upper left X coordinate
  DX            = upper left Y coordinate
  SI            = lower right X coordinate
  DI            = lower right Y coordinate

Returns:

  Nothing

Note:

  ş The exclusion area is replaced by another call to this function or
    cancelled by Int 33H Functions 00H or 01H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 13H (19)
Set double speed threshold
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the threshold speed for doubling pointer motion on the screen. The
  default threshold speed is 64 mickeys/second.

Call with:

  AX            = 0013H
  DX            = threshold speed in mickeys/second

Returns:

  Nothing

Note:

  ş Doubling of pointer motion can be effectively disabled by setting the
    threshold to a very large value (such as 10,000).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 14H (20)
Swap user-defined mouse event handlers
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the address and event mask for an application program's mouse event
  handler and returns the address and event mask for the previous handler.
  The newly installed handler is called by the mouse driver whenever the
  specified mouse events occur.

Call with:

  AX            = 0014H
  CX            = event mask

                  Bit(s)    Significance (if set)
                  0         mouse movement
                  1         left button pressed
                  2         left button released
                  3         right button pressed
                  4         right button released
                  5         center button pressed
                  6         center button released
                  7Ä15      reserved (0)

  ES:DX         = segment:offset of event handler

Returns:

  CX            = previous event mask
  ES:DX         = segment:offset of previous handler

Notes:

  ş The Notes for Int 33H Function 0CH describe the information passed to
    the user-defined event handler. See also Int 33H Function 18H.

  ş Calls to the event handler are disabled with Int 33H Function 00H or by
    setting an event mask of zero.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 15H (21)
Get mouse save state buffer size
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Gets the size of the buffer required to store the current state of the
  mouse driver.

Call with:

  AX            = 0015H

Returns:

  BX            = buffer size (bytes)

Note:

  ş See also Int 33H Functions 16H and 17H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 16H (22)
Save mouse driver state
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves the mouse driver state in a user buffer. The minimum size for the
  buffer must be determined by a previous call to Int 33H Function 15H.

Call with:

  AX            = 0016H
  ES:DX         = segment:offset of buffer

Returns:

  Nothing

Note:

  ş Call this function before executing a child program with Int 21H
    Function 4BH (EXEC), in case the child also uses the mouse. After the
    EXEC call, restore the previous mouse driver state with Int 33H Function
    17H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 17H (23)
Restore mouse driver state
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Restores the mouse driver state from a user buffer.

Call with:

  AX            = 0017H
  ES:DX         = segment:offset of buffer

Returns:

  Nothing

Note:

  ş The mouse driver state must have been previously saved into the same
    buffer with Int 33H Function 16H. The format of the data in the buffer
    is undocumented and subject to change.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 18H (24)
Set alternate mouse event handler
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the address and event mask for a an application program mouse event
  handler. As many as three handlers with distinct event masks can be
  registered with this function. When an event occurs that matches one of
  the masks, the corresponding handler is called by the mouse driver.

Call with:

  AX            = 0018H
  CX            = event mask

                  Bit(s)    Significance (if set)
                  0         mouse movement
                  1         left button pressed
                  2         left button released
                  3         right button pressed
                  4         right button released
                  5         Shift key pressed during button press or release
                  6         Ctrl key pressed during button press or release
                  7         Alt key pressed during button press or release
                  8Ä15      reserved (0)

  ES:DX         = segment:offset of handler

Returns:

  If function successful

  AX            = 0018H

  If function unsuccessful

  AX            = FFFFH

Notes:

  ş When this function is called, at least one of the bits 5, 6, and 7 must
    be set in register CX.

  ş The user-defined event handler is entered from the mouse driver by a far
    call with registers set up as follows:

    AX             mouse event flags (see event mask)
    BX             button state

                   Bit(s)     Significance (if set)
                   0          left button is down
                   1          right button is down
                   2          center button is down
                   3Ä15       reserved (0)

    CX             horizontal (X) pointer coordinate
    DX             vertical (Y) pointer coordinate
    SI             last raw vertical mickey count
    DI             last raw horizontal mickey count
    DS             mouse driver data segment

  ş If an event does not generate a call to the user-defined handler because
    its bit is not set in the event mask, it can still be reported in the
    event flags during calls to the handler for events that are enabled.

  ş Calls to the handler are disabled with Int 33H Function 00H.

  ş See also Int 33H Functions 0CH and 14H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 19H (25)
Get address of alternate mouse event handler
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the address for the mouse event handler matching the specified
  event mask.

Call with:

  AX            = 0019H
  CX            = event mask (see Int 33H Function 18H)

Returns:

  If function successful

  CX            = event mask
  ES:DX         = segment:offset of alternate event handler

  If function unsuccessful (no handler installed or event mask does not
  match any installed handler)

  CX            = 0000H

Note:

  ş Int 33H Function 18H allows as many as three event handlers with
    distinct event masks to be installed. This function can be called to
    search for a handler that matches a specific event, so that it can be
    replaced or disabled.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1AH (26)
Set mouse sensitivity
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the number of mickeys per 8 pixels for horizontal and vertical mouse
  motion and the threshold speed for doubling pointer motion on the screen.
  One mickey represents approximately 1/200 of an inch of mouse travel.

Call with:

  AX            = 001AH
  BX            = horizontal mickeys (1Ä32,767, default = 8)
  CX            = vertical mickeys (1Ä32,767, default = 16)
  DX            = double speed threshold in mickeys/second (default = 64)

Returns:

  Nothing

Note:

  ş See also Int 33H Functions 0FH and 13H, which allow the mickeys to
    pixels ratio and threshold speed to be set separately, and Int 33H
    Function 1BH, which returns the current sensitivity values.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1BH (27)
Get mouse sensitivity
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current mickeys to pixels ratios for vertical and horizontal
  screen movement and the threshold speed for doubling of pointer motion.

Call with:

  AX            = 001BH

Returns:

  BX            = horizontal mickeys (1Ä32,767, default = 8)
  CX            = vertical mickeys (1Ä32,767, default = 16)
  DX            = double speed threshold in mickeys/second (default = 64)

Note:

  ş See also Int 33H Functions 0FH, 13H, and 1AH.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1CH (28)
Set mouse interrupt rate
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the rate at which the mouse driver polls the status of the mouse.
  Faster rates provide better resolution in graphics mode but may degrade
  the performance of application programs.

Call with:

  AX            = 001CH
  BX            = interrupt rate flags

                  Bit(s)    Significance
                  0         no interrupts allowed
                  1         30 interrupts/second
                  2         50 interrupts/second
                  3         100 interrupts/second
                  4         200 interrupts/second
                  5Ä15      reserved (0)

Returns:

  Nothing

Notes:

  ş This function is applicable for the InPort Mouse only.

  ş If more than one bit is set in register BX, the lowest order bit
    prevails.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1DH (29)
Select pointer page
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the display page for the mouse pointer.

Call with:

  AX            = 001DH
  BX            = page

Returns:

  Nothing

Note:

  ş The valid page numbers depend on the current display mode. See Int 10H
    Function 05H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1EH (30)
Get pointer page
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the current display page for the mouse pointer.

Call with:

  AX            = 001EH

Returns:

  BX            = page


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 1FH (31)
Disable mouse driver
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Disables the mouse driver and returns the address of the previous Int 33H
  handler.

Call with:

  AX            = 001FH

Returns:

  If function successful

  AX            = 001FH
  ES:BX         = segment:offset of previous Int 33H handler

  If function unsuccessful

  AX            = FFFFH

Notes:

  ş When this function is called, the mouse driver releases any interrupt
    vectors it has captured other than Int 33H (which may include Int 10H,
    Int 71H, and/or Int 74H). The application program can complete the
    process of logically removing the mouse driver by restoring the original
    contents of the Int 33H vector with Int 21H Function 25H, using the
    address returned by this function in ES:BX.

  ş See also Int 33H Function 20H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 20H (32)
Enable mouse driver
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables the mouse driver and the servicing of mouse interrupts.

Call with:

  AX            = 0020H

Returns:

  Nothing

Note:

  ş See also Int 33H Function 1FH.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 21H (33)
Reset mouse driver
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Resets the mouse driver and returns driver status. If the mouse pointer
  was previously visible, it is removed from the screen, and any previously
  installed user handlers for mouse events are disabled.

Call with:

  AX            = 0021H

Returns:

  If mouse support is available

  AX            = FFFFH
  BX            = number of mouse buttons

  If mouse support is not available

  AX            = 0021H

Note:

  ş This function differs from Int 33H Function 00H in that there is no
    initialization of the mouse hardware.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 22H (34)
Set language for mouse driver messages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects the language that will be used by the mouse driver for prompts and
  error messages.

Call with:

  AX            = 0022H
  BX            = language number

                  0 =       English
                  1 =       French
                  2 =       Dutch
                  3 =       German
                  4 =       Swedish
                  5 =       Finnish
                  6 =       Spanish
                  7 =       Portuguese
                  8 =       Italian

Returns:

  Nothing

Note:

  ş This function is only available in international versions of the
    Microsoft Mouse driver.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 23H (35)
Get language number
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of the language that is used by the mouse driver for
  prompts and error messages.

Call with:

  AX            = 0023H

Returns:

  BX            = language number (see Int 33H Function 22H)

Note:

  ş This function is only available in international versions of the
    Microsoft Mouse driver.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 33H
Function 24H (36)
Get mouse information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the mouse driver version number, mouse type, and the IRQ number of
  the interrupt used by the mouse adapter.

Call with:

  AX            = 0024H

Returns:

  BH            = major version number (6 for version 6.10, etc.)
  BL            = minor version number (0AH for version 6.10, etc.)
  CH            = mouse type

                  1 =       bus mouse
                  2 =       serial mouse
                  3 =       InPort mouse
                  4 =       PS/2 mouse
                  5 =       HP mouse

  CL            = IRQ number

                  0                    = PS/2
                  2, 3, 4, 5, or 7     = IRQ number





ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SECTION 4  LOTUS/INTEL/MICROSOFT EMS FUNCTIONS REFERENCE
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


Notes to the Reader

  The Lotus/Intel/Microsoft Expanded Memory Specification (EMS) defines a
  hardware/software subsystem, compatible with 80x86-based microcomputers
  running MS-DOS, that allows applications to access as much as 32 MB of
  bank-switched random-access memory. The software component, called the
  Expanded Memory Manager (EMM), is installed during system initialization
  by a DEVICE= directive in the CONFIG.SYS file in the root directory on the
  boot disk.

  After ensuring that the EMM is present (see Chapter 11), an application
  program communicates directly with the EMM using software interrupt 67H. A
  particular EMM function is selected by the value in register AH and a
  success or error status is returned in register AH (error codes are listed
  on pages 207Ä209). Other parameters and results are passed or returned in
  registers or buffers.

  An icon in each function heading indicates the EMS version in which that
  function was first supported. You can assume that the function is
  available in all subsequent EMS versions unless explicitly noted
  otherwise.

  Version icons used in the synopsis, parameters, results, or Notes section
  refer to specific minor or major EMS versions, unless they include a +
  sign to indicate a version and all subsequent versions.

  The material in this section has been verified against the Expanded Memory
  Specification version 4.0, dated October 1987, Intel part number
  300275-005. This document can be obtained from Intel Corporation, 5200
  N.E. Elam Young Parkway, Hillsboro, OR 97124.


Summary of EMM Functions


  Function     Subfunction     Description
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  40H (64)                    Get Status
  41H (65)                    Get Page Frame Address
  42H (66)                    Get Number of Pages
  43H (67)                    Allocate Handle and Pages
  44H (68)                    Map Expanded Memory Page
  45H (69)                    Release Handle and Expanded Memory
  46H (70)                    Get Version
  47H (71)                    Save Page Map
  48H (72)                    Restore Page Map
  49H (73)                    Reserved
  4AH (74)                    Reserved
  4BH (75)                    Get Handle Count
  4CH (76)                    Get Handle Pages
  4DH (77)                    Get Pages for All Handles
  4EH (78)     00H            Save Page Map
  4EH (78)     01H            Restore Page Map
  4EH (78)     02H            Save and Restore Page Map
  4EH (78)     03H            Get Size of Page Map Information
  4FH (79)     00H            Save Partial Page Map
  4FH (79)     01H            Restore Partial Page Map
  4FH (79)     02H            Get Size of Partial Page Map Information
  50H (80)     00H            Map Multiple Pages by Number
  50H (80)     01H            Map Multiple Pages by Address
  51H (81)                    Reallocate Pages for Handle
  52H (82)     00H            Get Handle Attribute
  52H (82)     01H            Set Handle Attribute
  52H (82)     02H            Get Attribute Capability
  53H (83)     00H            Get Handle Name
  53H (83)     01H            Set Handle Name
  54H (84)     00H            Get All Handle Names
  54H (84)     01H            Search for Handle Name
  54H (84)     02H            Get Total Handles
  55H (85)     00H            Map Pages by Number and Jump
  55H (85)     01H            Map Pages by Address and Jump
  56H (86)     00H            Map Pages by Number and Call
  56H (86)     01H            Map Pages by Address and Call
  56H (86)     02H            Get Space for Map Page and Call
  57H (87)     00H            Move Memory Region
  57H (87)     01H            Exchange Memory Regions
  58H (88)     00H            Get Addresses of Mappable Pages
  58H (88)     01H            Get Number of Mappable Pages
  59H (89)     00H            Get Hardware Configuration
  59H (89)     01H            Get Number of Raw Pages
  5AH (90)     00H            Allocate Handle and Standard Pages
  5AH (90)     01H            Allocate Handle and Raw Pages
  5BH (91)     00H            Get Alternate Map Registers
  5BH (91)     01H            Set Alternate Map Registers
  5BH (91)     02H            Get Size of Alternate Map Register Save Area
  5BH (91)     03H            Allocate Alternate Map Register Set
  5BH (91)     04H            Deallocate Alternate Map Register Set
  5BH (91)     05H            Allocate DMA Register Set
  5BH (91)     06H            Enable DMA on Alternate Map Register Set
  5BH (91)     07H            Disable DMA on Alternate Map Register Set
  5BH (91)     08H            Deallocate DMA Register Set
  5CH (92)                    Prepare Expanded Memory Manager for Warm Boot
  5DH (93)     00H            Enable EMM Operating-System Functions
  5DH (93)     01H            Disable EMM Operating-System Functions
  5DH (93)     02H            Release Access Key
  ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 40H (64)
Get status
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a status code indicating whether the expanded memory software and
  hardware are present and functional.

Call with:

  AH            = 40H

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş This call should be used only after an application has established that
    the Expanded Memory Manager is in fact present, using one of the
    techniques described in Chapter 11.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 41H (65)
Get page frame address
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the segment address of the page frame used by the Expanded Memory
  Manager.

Call with:

  AH            = 41H

Returns:

  If function successful

  AH            = 00H
  BX            = segment base of page frame

  If function unsuccessful

  AH            = error code

Notes:

  ş The page frame is divided into four 16 KB pages, which are used to map
    logical expanded memory pages into the physical memory space of the CPU.

  ş The application need not have already acquired an EMM handle to use this
    function.

  ş [EMS 4.0] Mapping of expanded memory pages is not necessarily limited to
    the 64 KB page frame. See also Int 67H Function 58H Subfunction 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 42H (66)
Get number of pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the total number of logical expanded memory pages present in the
  system and the number of pages that are not already allocated.

Call with:

  AH            = 42H

Returns:

  If function successful

  AH            = 00H
  BX            = unallocated pages
  DX            = total pages

  If function unsuccessful

  AH            = error code

Notes:

  ş The application need not have already acquired an EMM handle to use this
    function.

  ş [EMS 4.0] See also Int 67H Function 59H Subfunction 01H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 43H (67)
Allocate handle and pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains an EMM handle and allocates logical pages of expanded memory to be
  controlled by that handle.

Call with:

  AH            = 43H
  BX            = number of pages to allocate (must be nonzero)

Returns:

  If function successful

  AH            = 00H
  DX            = EMM handle

  If function unsuccessful

  AH            = error code

Notes:

  ş This is the equivalent of a file open function for the expanded memory
    manager. The handle that is returned is analogous to a file handle and
    owns a certain number of expanded memory pages. The handle must be used
    with every subsequent request to map memory and must be released by a
    close operation before the application terminates.

  ş This function may fail because there are no handles left to allocate or
    because there is an insufficient number of expanded memory pages to
    satisfy the request. In the latter case, Int 67H Function 42H can be
    used to determine the actual number of pages available.

  ş [EMS 4.0] Int 67H Function 51H can be called to change the number of
    pages allocated to an EMM handle.

  ş [EMS 4.0] The pages allocated by this function are always 16 KB for
    compatibility with earlier versions of EMS. See also Int 67H Function
    5AH Subfunctions 00H and 01H.

  ş [EMS 4.0] Handle 0000H is always available for use by the operating
    system, and a prior call to this function is not required. The operating
    system must call Int 67H Function 51H to assign the desired number of
    pages to its reserved handle.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 44H (68)
Map expanded memory page
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Maps one of the logical pages of expanded memory assigned to a handle onto
  a physical memory page that can be accessed by the CPU.

Call with:

  AH            = 44H
  AL            = physical page
  BX            = logical page
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The logical page number is in the range {0...n-1}, where n is the number
    of pages allocated or reallocated to the handle by a previous call to
    Int 67H Function 43H, 51H, or 5AH. Logical pages allocated by Int 67H
    Function 43H or Function 5AH Subfunction 00H are always 16 KB long;
    logical pages allocated by Int 67H Function 5AH Subfunction 01H are
    referred to as raw pages and are not necessarily 16 KB.

  ş [EMS 3] The physical page is in the range 0Ä3 and lies within the EMM
    page frame, whose base address is obtained from Int 67H Function 41H.

  ş [EMS 4.0] A list of the available physical pages and their addresses may
    be obtained from Int 67H Function 58H Subfunction 00H.

  ş [EMS 4.0] If this function is called with BX = -1, the specified
    physical page is unmapped (made inaccessible for reading or writing).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 45H (69)
Release handle and expanded memory
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Deallocates the expanded memory pages assigned to a handle and then
  releases the handle.

Call with:

  AH            = 45H
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş If this function is not called before a program terminates, the EMS
    pages it owned remain unavailable until the system is restarted.
    Programs that use EMS should install their own Ctrl-C handlers and
    critical-error handlers (Ints 23H and 24H) so that they cannot be
    terminated unexpectedly.

  ş [EMS 4.0] When a handle is released, its name is set to all ASCII nulls.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 46H (70)
Get version
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the EMS version supported by the expanded memory manager.

Call with:

  AH            = 46H

Returns:

  If function successful

  AH            = 00H
  AL            = version number

  If function unsuccessful

  AH            = error code

Notes:

  ş The version number is returned in binary code decimal (BCD) format, with
    the integer portion in the upper 4 bits of AL and the fractional portion
    in the lower 4 bits. For example, under an EMM that supports EMS version
    3.2, AL is returned as the value 32H.

  ş Applications should always check the EMM version number to ensure that
    all of the EMM functions they require are available.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 47H (71)
Save page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves the contents of the page-mapping registers on the expanded memory
  hardware, associating those contents with a particular EMM handle.

Call with:

  AH            = 47H
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş This function is used by interrupt handlers or device drivers that must
    access expanded memory. The EMM handle supplied to this function is the
    handle that was assigned to the handler or driver during its own
    initialization sequence, not to the program that was interrupted.

  ş The mapping context is restored by a subsequent call to Int 67H Function
    48H.

  ş [EMS 4.0] This function saves only the mapping state for the 64 KB page
    frame defined in EMS 3. Programs that are written to take advantage of
    the additional capabilities of EMS 4.0 should use Int 67H Function 4EH
    or 4FH in preference to this function.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 48H (72)
Restore page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Restores the contents of the page-mapping registers on the expanded memory
  hardware to the values associated with the specified handle by a previous
  call to Int 67H Function 47H.

Call with:

  AH            = 48H
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş This function is used by interrupt handlers or device drivers that must
    access expanded memory. The EMM handle supplied to this function is the
    handle that was assigned to the handler or driver during its own
    initialization sequence, not to the program that was interrupted.

  ş [EMS 4.0] This function restores only the mapping state for the 64 KB
    page frame defined in EMS 3. Programs that are written to take advantage
    of the additional capabilities of EMS 4.0 should use Int 67H Function
    4EH or 4FH in preference to this function.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 49H (73)
Reserved
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  This function was defined in EMS version 3.0 but is not documented for
  later EMS versions, so it should be avoided in application programs.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 4AH (74)
Reserved
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  This function was defined in EMS version 3.0 but is not documented for
  later EMS versions, so it should be avoided in application programs.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 4BH (75)
Get handle count
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of active expanded memory handles.

Call with:

  AH            = 4BH

Returns:

  If function successful

  AH            = 00H
  BX            = number of active EMM handles

  If function unsuccessful

  AH            = error code

Notes:

  ş If the returned number of EMM handles is zero, the expanded memory
    manager is idle, and none of the expanded memory is in use.

  ş The value returned by this function is not necessarily the same as the
    number of programs using expanded memory because one program may own
    multiple EMM handles.

  ş The number of active EMM handles never exceeds 255.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 4CH (76)
Get handle pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of expanded memory pages allocated to a specific EMM
  handle.

Call with:

  AH            = 4CH
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H
  BX            = number of EMM pages

  If function unsuccessful

  AH            = error code

Notes:

  ş [EMS 3] The total number of pages allocated to a handle never exceeds
    512. A handle never has zero pages allocated to it.

  ş [EMS 4.0] The total number of pages allocated to a handle never exceeds
    2048. A handle may have zero pages of expanded memory.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.0]
Function 4DH (77)
Get pages for all handles
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns an array that contains all the active handles and the number of
  expanded memory pages associated with each handle.

Call with:

  AH            = 4DH
  ES:DI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H
  BX            = number of active EMM handles

  and buffer filled in as described in Notes

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer is filled in with a series of DWORD (32-bit) entries, one per
    active EMM handle. The first word of an entry contains the handle, and
    the second word contains the number of pages allocated to that handle.

  ş The maximum number of active handles is 256 (including the operating
    system handle 0), so a buffer size of 1024 bytes is adequate in all
    cases.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.2]
Function 4EH (78) Subfunction 00H
Save page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves the current page-mapping state of the expanded memory hardware in
  the specified buffer.

Call with:

  AH            = 4EH
  AL            = 00H
  ES:DI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  and buffer filled in with mapping information (see Notes)

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer receives the information necessary to restore the state of
    the mapping registers using Int 67H Function 4EH Subfunction 01H. The
    format of the information may vary.

  ş The size of the buffer required by this function can be determined with
    Int 67H Function 4EH Subfunction 03H.

  ş Unlike Int 67H Function 47H, this function does not require a handle.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.2]
Function 4EH (78) Subfunction 01H
Restore page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Restores the page-mapping state of the expanded memory hardware using the
  information in the specified buffer.

Call with:

  AH            = 4EH
  AL            = 01H
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer contains information necessary to restore the state of the
    mapping registers from a previous call to Int 67H Function 4EH
    Subfunction 00H or 02H. The format of the information may vary.

  ş Unlike Int 67H Function 48H, this function does not require a handle.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.2]
Function 4EH (78) Subfunction 02H
Save and restore page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves the current page-mapping state of the expanded memory hardware in a
  buffer and then sets the mapping state using the information in another
  buffer.

Call with:

  AH            = 4EH
  AL            = 02H
  DS:SI         = segment:offset of buffer containing mapping information
                  (see Notes)
  ES:DI         = segment:offset of buffer to receive mapping information
                  (see Notes)

Returns:

  If function successful

  AH            = 00H

  and buffer pointed to by ES:DI filled in with mapping information (see
  Notes)

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer addressed by DS:SI contains information necessary to restore
    the state of the mapping registers from a previous call to Int 67H
    Function 4EH Subfunction 00H or 02H. The format of the information may
    vary.

  ş The sizes of the buffers required by this function can be determined
    with Int 67H Function 4EH Subfunction 03H.

  ş Unlike Int 67H Functions 47H and 48H, this function does not require a
    handle.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 3.2]
Function 4EH (78) Subfunction 03H
Get size of page map information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the size of the buffer that is required to receive page-mapping
  information using Int 67H Function 4EH Subfunctions 00H and 02H.

Call with:

  AH            = 4EH
  AL            = 03H

Returns:

  If function successful

  AH            = 00H
  AL            = size of buffer (bytes)

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 4FH (79) Subfunction 00H
Save partial page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Saves the state of a subset of the expanded memory page-mapping registers
  in the specified buffer.

Call with:

  AH            = 4FH
  AL            = 00H
  DS:SI         = segment:offset of map list (see Notes)
  ES:DI         = segment:offset of buffer to receive mapping state (see
                  Notes)

Returns:

  If function successful

  AH            = 00H

  and buffer filled in with mapping information (see Notes)

  If function unsuccessful

  AH            = error code

Notes:

  ş The map list contains the number of mappable segments in the first word,
    followed by the segment addresses of the mappable memory regions (one
    segment per word).

  ş To determine the size of the buffer required for the mapping state, use
    Int 67H Function 4FH Subfunction 02H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 4FH (79) Subfunction 01H
Restore partial page map
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Restores the state of a subset of the expanded memory page-mapping
  registers.

Call with:

  AH            = 4FH
  AL            = 01H
  DS:SI         = segment:offset of buffer (see Note)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş The buffer contains mapping information and must have been prepared by a
    previous call to Int 67H Function 4FH Subfunction 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 4FH (79) Subfunction 02H
Get size of partial page map information
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the size of the buffer which will be required to receive partial
  page-mapping information using Int 67H Function 4FH Subfunction 00H.

Call with:

  AH            = 4FH
  AL            = 02H
  BX            = number of pages

Returns:

  If function successful

  AH            = 00H
  AL            = size of array (bytes)

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 50H (80) Subfunction 00H
Map multiple pages by number
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Maps one or more of the logical expanded memory pages assigned to a handle
  onto physical memory pages that can be accessed by the CPU. Physical pages
  are referenced by their numbers.

Call with:

  AH            = 50H
  AL            = 00H
  CX            = number of pages to map
  DX            = EMM handle
  DS:SI         = segment:offset of buffer (see Note)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş The buffer contains a series of DWORD (32-bit) entries that control the
    pages to be mapped. The first word of each entry contains the logical
    expanded memory page number, and the second word contains the physical
    page number to which it should be mapped. If the logical page is -1, the
    physical page is unmapped (made inaccessible for reading or writing).


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 50H (80) Subfunction 01H
Map multiple pages by address
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Maps one or more of the logical expanded memory pages assigned to a handle
  onto physical memory pages that can be accessed by the CPU. Physical pages
  are referenced by their segment addresses.

Call with:

  AH            = 50H
  AL            = 01H
  CX            = number of pages to map
  DX            = EMM handle
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer contains a series of DWORD (32-bit) entries that control the
    pages to be mapped. The first word of each entry contains the logical
    page number, and the second word contains the physical page segment
    address to which it should be mapped. If the logical page is -1, the
    physical page is unmapped (made inaccessible for reading or writing).

  ş The mappable segment addresses may be obtained by calling Int 67H
    Function 58H Subfunction 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 51H (81)
Reallocate pages for handle
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Modifies the number of expanded memory pages allocated to an EMM handle.

Call with:

  AH            = 51H
  BX            = new number of pages
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H
  BX            = logical pages owned by EMM handle

  If function unsuccessful

  AH            = error code

Note:

  ş If the requested number of pages is zero, the handle is still active,
    and pages can be reallocated to the handle at a later time; also, the
    handle must still be released with Int 67H Function 45H before the
    application terminates.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 52H (82) Subfunction 00H
Get handle attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the attribute (volatile or nonvolatile) associated with the
  specified handle. A nonvolatile memory handle and the contents of the
  expanded memory pages that are allocated to it are maintained across a
  warm boot operation (system restart using Ctrl-Alt-Del).

Call with:

  AH            = 52H
  AL            = 00H
  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H
  AL            = attribute

                  0       = volatile
                  1       = nonvolatile

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 52H (82) Subfunction 01H
Set handle attribute
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Sets the attribute (volatile or nonvolatile) associated with the specified
  handle. A nonvolatile memory handle and the contents of the expanded
  memory pages that are allocated to it are maintained across a warm boot
  operation (system restart using Ctrl-Alt-Del).

Call with:

  AH            = 52H
  AL            = 01H
  BL            = attribute

                  0       = volatile
                  1       = nonvolatile

  DX            = EMM handle

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş If the expanded memory hardware cannot support nonvolatile pages, this
    function returns an error.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 52H (82) Subfunction 02H
Get attribute capability
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns a code indicating whether the Expanded Memory Manager and hardware
  can support the nonvolatile attribute for EMM handles.

Call with:

  AH            = 52H
  AL            = 02H

Returns:

  If function successful

  AH            = 00H
  AL            = attribute capability
                  0       = only volatile handles supported
                  1       = volatile and nonvolatile handles supported

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 53H (83) Subfunction 00H
Get handle name
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the 8-character name assigned to a handle.

Call with:

  AH            = 53H
  AL            = 00H
  DX            = EMM handle
  ES:DI         = segment:offset of 8-byte buffer

Returns:

  If function successful

  AH            = 00H

  and name for handle in specified buffer

  If function unsuccessful

  AH            = error code

Note:

  ş A handle's name is initialized to 8 zero bytes when it is allocated or
    deallocated. Another name may be assigned to an active handle with Int
    67H Function 53H Subfunction 01H. The bytes in a handle name need not
    be ASCII characters.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 53H (83) Subfunction 01H
Set handle name
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Assigns a name to an EMM handle.

Call with:

  AH            = 53H
  AL            = 01H
  DX            = EMM handle
  DS:SI         = segment:offset of 8-byte name

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The bytes in a handle name need not be ASCII characters, but the
    sequence of 8 zero bytes is reserved for no name (the default after a
    handle is allocated or deallocated). A handle name should be padded with
    zero bytes, if necessary, to a length of 8 bytes.

  ş A handle may be renamed at any time.

  ş All handle names are initialized to 8 zero bytes when the system is
    turned on. The name of a nonvolatile handle is preserved across a warm
    boot. (See Int 67H Function 52H Subfunctions 00H and 02H.)


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 54H (84) Subfunction 00H
Get all handle names
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the names for all active handles.

Call with:

  AH            = 54H
  AL            = 00H
  ES:DI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H
  AL            = number of active handles

  and buffer filled in with handle-name information (see Notes)

  If function unsuccessful

  AH            = error code

Notes:

  ş The function fills the buffer with a series of 10-byte entries. The
    first 2 bytes of each entry contain an EMM handle, and the next 8 bytes
    contain the name associated with the handle. Handles that have never
    been assigned a name have 8 bytes of 0 as a name.

  ş Because there is a maximum of 255 active handles, the buffer need not be
    longer than 2550 bytes.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 54H (84) Subfunction 01H
Search for handle name
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the EMM handle associated with the specified name.

Call with:

  AH            = 54H
  AL            = 01H
  DS:SI         = segment:offset of 8-byte handle name

Returns:

  If function successful

  AH            = 00H
  DX            = EMM handle

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 54H (84) Subfunction 02H
Get total handles
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the total number of handles that are supported by the Expanded
  Memory Manager, including the operating-system handle (0).

Call with:

  AH            = 54H
  AL            = 02H

Returns:

  If function successful

  AH            = 00H
  BX            = number of handles

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 55H (85) Subfunctions 00H and 01H
Map pages and jump
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Alters the expanded memory mapping context and transfers control to the
  specified address.

Call with:

  AH            = 55H
  AL            = subfunction

                  0       = map using physical page numbers
                  1       = map using physical page segments

  DX            = EMM handle
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer contains map-and-jump entries in the following format:

    Offset        Length         Description
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H           4              far pointer to jump target
    04H           1              number of pages to map before jump
    05H           4              far pointer to map list (see below)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    The map list in turn consists of DWORD (32-bit) entries, one per page.
    The first word of each entry contains the logical page number, and the
    second word contains the physical page number or segment (depending on
    the value in register AL) to which it should be mapped.

  ş A request to map zero pages and jump is not considered an error; the
    effect is a simple far jump.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 56H (86) Subfunctions 00H and 01H
Map pages and call
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Alters the expanded memory mapping context and performs a far call to the
  specified address. When the destination routine executes a far return, the
  EMM again alters the page-mapping context as instructed and then returns
  control to the original caller.

Call with:

  AH            = 56H
  AL            = subfunction

                  0       = map using physical page numbers
                  1       = map using physical page segments

  DX            = EMM handle
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The format of the buffer containing map and call information is:

    Offset        Length         Description
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H           4              far pointer to call target
    04H           1              number of pages to map before call
    05H           4              far pointer to list of pages to map before
                                 call (see below)
    09H           1              number of pages to map before return
    0AH           4              far pointer to list of pages to map before
                                 return (see below)
    0EH           8              reserved (0)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

    Both map lists have the same format and consist of a series of
    double-word entries, one per page. The first word of each entry contains
    the logical page number, and the second word contains the physical page
    number or segment (depending on the value in register AL) to which it
    should be mapped.

  ş A request to map zero pages and call is not an error; the effect is a
    simple far call.

  ş This function uses extra stack space to save information about the
    mapping context; the amount of stack space required can be determined by
    calling Int 67H Function 56H Subfunction 02H.


ÄÄÄÄÄÄÄÄÄÄÄÄ ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 56H (86) Subfunction 02H
Get stack space for map page and call
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of bytes of stack space required by Int 67H Function
  56H Subfunction 00H or 01H.

Call with:

  AH            = 56H
  AL            = 02H

Returns:

  If function successful

  AH            = 00H
  BX            = stack space required (bytes)

  If function unsuccessful

  AH            = error code


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 57H (87) Subfunction 00H
Move memory region
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Copies a memory region from any location in conventional or expanded
  memory to any other location without disturbing the current expanded
  memory mapping context.

Call with:

  AH            = 57H
  AL            = 00H
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The format of the buffer controlling the move operation is:

    Offset        Length         Description
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H           4              region length in bytes
    04H           1              source memory type (0 = conventional, 1 =
                                 expanded)
    05H           2              source memory handle
    07H           2              source memory offset
    09H           2              source memory segment or physical page
                                 number
    0BH           1              destination memory type (0 = conventional,
                                 1 = expanded)
    0CH           2              destination memory handle
    0EH           2              destination memory offset
    10H           2              destination memory segment or physical page
                                 number
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş A length of zero bytes is not an error. The maximum length of a move is
    1 MB. If the length exceeds a single expanded memory page, consecutive
    expanded memory pages (as many as are required) supply or receive the
    data.

  ş If the source and destination addresses overlap, the move will be
    performed in such a way that the destination receives an intact copy of
    the original data, and a nonzero status is returned.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 57H (87) Subfunction 01H
Exchange memory regions
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Exchanges any two memory regions in conventional or expanded memory
  without disturbing the current expanded memory mapping context.

Call with:

  AH            = 57H
  AL            = 01H
  DS:SI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The format of the buffer controlling the exchange operation is the same
    as for Int 67H Function 57H Subfunction 00H.

  ş An exchange of zero bytes is not an error. The maximum length of an
    exchange is 1 MB. If the length exceeds a single expanded memory page,
    consecutive expanded memory pages (as many as are required) supply or
    receive the data.

  ş If the source and destination addresses overlap, the exchange is not
    performed and an error is returned.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 58H (88) Subfunction 00H
Get addresses of mappable pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the segment base address and physical page number for each
  mappable page in the system.

Call with:

  AH            = 58H
  AL            = 00H
  ES:DI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H
  CX            = number of entries in mappable physical page array

  and page number/address information in buffer (see Notes)

  If function unsuccessful

  AH            = error code

Notes:

  ş Upon return from the function, the buffer contains a series of
    double-word entries, one per mappable page. The first word of an entry
    contains the page's segment base address, and the second contains its
    physical page number. The entries are sorted in order of ascending
    segment addresses.

  ş The size of the buffer required can be calculated with the information
    returned by Int 67H Function 58H Subfunction 01H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 58H (88) Subfunction 01H
Get number of mappable pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of mappable physical pages.

Call with:

  AH            = 58H
  AL            = 01H

Returns:

  If function successful

  AH            = 00H
  CX            = number of mappable physical pages

  If function unsuccessful

  AH            = error code

Note:

  ş The information returned by this function can be used to calculate the
    size of the buffer that will be needed by Int 67H Function 58H
    Subfunction 00H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 59H (89) Subfunction 00H
Get hardware configuration
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns information about the configuration of the expanded memory
  hardware.

Call with:

  AH            = 59H
  AL            = 00H
  ES:DI         = segment:offset of buffer (see Notes)

Returns:

  If function successful

  AH            = 00H

  and hardware configuration information in buffer.

  If function unsuccessful

  AH            = error code

Notes:

  ş Upon return from the function, the buffer has been filled in with
    hardware configuration information in the following format:

    Offset        Length         Description
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
    00H           2              size of raw expanded memory pages (in
                                 paragraphs)
    02H           2              number of alternate register sets
    04H           2              size of mapping-context save area (in
                                 bytes)
    06H           2              number of register sets that can be
                                 assigned to DMA channels
    08H           2              DMA operation type (0 = DMA may be used
                                 with alternate register sets; 1 = only one
                                 DMA register set available)
    ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ş The size returned for the mapping-context save area is the same as the
    size returned by Int 67H Function 4EH Subfunction 03H.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 59H (89) Subfunction 01H
Get number of raw pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Obtains the total number of raw expanded memory pages present in the
  system and the number of raw pages that are not already allocated. Raw
  memory pages may have a size other than 16 KB.

Call with:

  AH            = 59H
  AL            = 01H

Returns:

  If function successful

  AH            = 00H
  BX            = unallocated raw pages
  DX            = total raw pages

  If function unsuccessful

  AH            = error code

Note:

  ş If the Expanded Memory Manager supports only pages of standard size, the
    values returned by this function are the same as those returned by Int
    67H Function 42H.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5AH (90) Subfunction 00H
Allocate handle and standard pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allocates an EMM handle and associates standard (16 KB) expanded memory
  pages with that handle.

Call with:

  AH            = 5AH
  AL            = 00H
  BX            = number of standard pages to allocate

Returns:

  If function successful

  AH            = 00H
  DX            = EMM handle

  If function unsuccessful

  AH            = error code

Note:

  ş Unlike Int 67H Function 43H, allocating zero pages with this function
    is not an error.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5AH (90) Subfunction 01H
Allocate handle and raw pages
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allocates a raw EMM handle and associates raw expanded memory pages with
  that handle.

Call with:

  AH            = 5AH
  AL            = 01H
  BX            = number of raw pages to allocate

Returns:

  If function successful

  AH            = 00H
  DX            = handle for raw EMM pages

  If function unsuccessful

  AH            = error code

Notes:

  ş Raw memory pages may have a size other than 16 KB.

  ş Allocation of zero pages is not an error.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 00H
Get alternate map registers
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the number of the active alternate register set or, if no
  alternate set is active, saves the state of the mapping registers into a
  buffer and returns its address.

Call with:

  AH            = 5BH
  AL            = 00H

Returns:

  If function successful and alternate map register set active

  AH            = 00H
  BL            = current active alternate map register set

  If function successful and alternate map register set not active

  AH            = 00H
  BL            = 00H
  ES:DI         = segment:offset of alternate map register save area
                  (if BL = 0)

  If function unsuccessful

  AH            = error code

Notes:

  ş The address of the save area must have been specified in a previous call
    to Int 67H Function 5BH Subfunction 01H, and the save area must have
    been initialized by a previous call to Int 67H Function 4EH Subfunction
    00H. If there was no previous call to Int 67H Function 5BH Subfunction
    01H, the address returned is zero, and the registers are not saved.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 01H
Set alternate map registers
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Selects an alternate map register set or (if alternate sets are not
  supported) restores the mapping context from the specified buffer.

Call with:

  AH            = 5BH
  AL            = 01H
  BL            = alternate register set number or 00H
  ES:DI         = segment:offset of map register context restore area
                  (if BL = 0)

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The buffer address specified in this call is returned by subsequent
    calls to Int 67H Function 5BH Subfunction 00H with BL = 00H.

  ş The save area must have been initialized by a previous call to Int 67H
    Function 4EH Subfunction 00H.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 02H
Get size of alternate map register save area
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Returns the amount of storage needed by Int 67H Function 5BH Subfunctions
  00H and 01H.

Call with:

  AH            = 5BH
  AL            = 02H

Returns:

  If function successful

  AH            = 00H
  DX            = size of buffer (bytes)

  If function unsuccessful

  AH            = error code

Note:

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 03H
Allocate alternate map register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allocates an alternate map register set for use with Int 67H Function 5BH
  Subfunctions 00H and 01H. The contents of the currently active map
  registers are copied into the newly allocated alternate map registers in
  order to provide an initial context when they are selected.

Call with:

  AH            = 5BH
  AL            = 03H

Returns:

  If function successful

  AH            = 00H
  BL            = alternate map register set number or zero, if no alternate
                  sets are available

  If function unsuccessful

  AH            = error code

Note:

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 04H
Deallocate alternate map register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Releases an alternate map register set that was previously allocated with
  Int 67H Function 5BH Subfunction 03H.

Call with:

  AH            = 5BH
  AL            = 04H
  BL            = alternate register set number

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş The current alternate map register set cannot be deallocated.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 05H
Allocate DMA register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Allocates a DMA register set.

Call with:

  AH            = 5BH
  AL            = 05H

Returns:

  If function successful

  AH            = 00H
  BL            = DMA register set number (0 = none available)

  If function unsuccessful

  AH            = error code

Note:

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 06H
Enable DMA on alternate map register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Associates a DMA channel with an alternate map register set.

Call with:

  AH            = 5BH
  AL            = 06H
  BL            = alternate map register set
  DL            = DMA channel number

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş If a DMA channel is not assigned to a specific register set, DMA for
    that channel will be mapped through the current register set.

  ş If zero is specified as the alternate map register set, no special
    action is taken on DMA accesses for the specified DMA channel.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 07H
Disable DMA on alternate map register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Disables DMA accesses for all DMA channels associated with a specific
  alternate map register set.

Call with:

  AH            = 5BH
  AL            = 07H
  BL            = alternate register set number

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5BH (91) Subfunction 08H
Deallocate DMA register set
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Deallocates a DMA register set that was previously allocated with Int 67H
  Function 5BH Subfunction 05H.

Call with:

  AH            = 5BH
  AL            = 08H
  BL            = DMA register set number

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5CH (92)
Prepare Expanded Memory Manager for warm boot
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Prepares the expanded memory hardware for an impending warm boot. This
  function affects the current mapping context, the alternate register set
  in use, and any other expanded memory hardware dependencies that would
  ordinarily be initialized at system boot time.

Call with:

  AH            = 5CH

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Note:

  ş If an application maps expanded memory at addresses below 640 KB, the
    application must trap all possible conditions that might lead to a warm
    boot, so that this function can be called first.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5DH (93) Subfunction 00H
Enable EMM operating-system functions
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Enables the operating-systemÄspecific EMM functions (Int 67H Functions
  59H, 5BH, and 5DH) for calls by any program or device driver. (This is
  the default condition.)

Call with:

  AH            = 5DH
  AL            = 00H
  BX:CX         = access key (if not first call to function)

Returns:

  If function successful

  AH            = 00H
  BX:CX         = access key (if first call to function)

  If function unsuccessful

  AH            = error code

Notes:

  ş An access key is returned in registers BX and CX on the first call to
    Int 67H Function 5DH Subfunction 00H or 01H. The access key is
    required for all subsequent calls to either function.

  ş This function is intended for use by operating systems only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5DH (93) Subfunction 01H
Disable EMM operating-system functions
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Disables the operating-systemÄspecific EMM functions (Int 67H Functions
  59H, 5BH, and 5DH) for calls by application programs and device
  drivers, reserving the use of these functions for the operating system.

Call with:

  AH            = 5DH
  AL            = 01H
  BX:CX         = access key (if not first call to function)

Returns:

  If function successful

  AH            = 00H
  BX:CX         = access key (if first call to function)

  If function unsuccessful

  AH            = error code

Notes:

  ş An access key is returned in registers BX and CX on the first call to
    Int 67H Function 5DH Subfunction 00H or 01H. The access key is
    required for all subsequent calls to either function.

  ş This function is intended for use by operating systems only.


ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Int 67H                                                            [EMS 4.0]
Function 5DH (93) Subfunction 02H
Release access key
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  Releases the access key obtained by a previous call to Int 67H Function
  5DH Subfunction 00H or 01H.

Call with:

  AH            = 5DH
  AL            = 02H
  BX:CX         = access key

Returns:

  If function successful

  AH            = 00H

  If function unsuccessful

  AH            = error code

Notes:

  ş With respect to the operating-systemÄspecific expanded memory functions,
    the EMM is returned to the state it had when the system was initialized.
    A new access key is returned by the next call to Int 67H Function 5DH
    Subfunction 00H or 01H.

  ş This function is intended for use by operating systems only and can be
    disabled by the operating system at any time.



ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
Index

  References to tables and illustrations are in italics.


Special Characters

| 298-99
. 187
.. 187-88
; 60
< 298-99
> 298-99
>> 298-99
 60

A
Absolute disk read 482-84
Absolute disk write 484-85
adapters, video display 86-87
alarm
   reset 592
   set 591-92
align type 38
Allocate alternate map register set (EMS) 641
Allocate DMA register set (EMS) 642
Allocate handle and pages (EMS) 617-18
Allocate handle and raw pages (EMS) 639
Allocate handle and standard pages (EMS) 638-39
Allocate memory block 438-39
ANSI.SYS device driver, screen control 91
   escape sequences used with 92-93
APPEND 490-91
application program interface (API) 320
application programs. See MS-DOS application programs, porting to OS/2;
     MS-DOS application programs, structure of; MS-DOS application programs,
     writing compatible
arena entries 196
arena headers 196, 201
   diagram example 202
ASCII escape code 92-93
ASCII mode 69
   character-device drivers in 261-62
ASCII text files 56
ASCIIZ strings 24, 139, 168
.ASM files 45. See also assembly-language programs
assembly-language programs 37-42
   to access file allocation table 191
   BREAK.ASM 75-78
   CLEAN.ASM 304-9
   DRIVER.ASM 283-91
   DUMP.ASM 152-61
   HELLO.COM example 27-30, 33-36
   program modules 37
   program procedures 41-42
   program segments 38-41
   PROTO.ASM 301-2
   SHELL.ASM program 229-38
   TALK.ASM 113-26
   ZERODIV.ASM 254, 255-58
ASSIGN 489
ASSUME statement 29, 33
attribute byte
   color text display 98
   monochrome text display 97
attribute word, device 264
Auxiliary device (AUX) 12, 106, 298. See also serial port
Auxiliary input 344-45
Auxiliary output 345-46

B
background, set 508-9
BACKUP command 15
.BAT (batch) files 15
Batch files 15
binary mode 69
   character-device drivers in 261-62
   output 93-94
BIOS module 12-13, 17
   get address of extended, 574
BIOS parameter block (BPB) 181, 189
   build 272
   structure 269
bit planes 101
blink/intensity bit, toggle 513
block-device drivers 260, 262
   check for remoteness 423-24
   check removability of 422-23
   generic I/O control of 429-32
   read control data from 418-19
   write control data to 419-20
Boot disk device (block device) 12
boot drive, get 392-93
boot sector, disk 179-82
   map of 180
   partial disassembly of 182
   partial hex dump 181
bootstrap routine 16, 17
border
   get color 514
   get palette and 514
   set 508-9
   set color 512
BREAK.ASM program 75-78
break flag, get or set 392-93
Buffered keyboard input 351-52
Build BIOS Parameter Block (function 02H) 272

C
CALL instructions 41
Cancel device redirection 467-68
cassette motor
   read 561
   turn off 560-61
   turn on 560
   write 562
.C files 45. See also C language
Change sharing retry count 425-26
character blocks, set specifier 520
character-device drivers 260, 261-62
   ASCII vs binary mode 261-62
   generic I/O control 426-29
   read control data from 415-16
   write control data to 416-17
character input/output. See also keyboard input; mouse, input; pointing
     device, input; printer output; serial port
   Int 21H 44H IOCTL (I/O control) 411-43
   Int 21H functions, summary 337-38 (table)
   processing typical I/O request 281-82
Character input with echo 343
Character input without echo 349-50
Character output 344
CHDIR (CD) command 167
Check if block device is remote 423-24
Check if block device is removable 422-23
Check if handle is remote 424-25
Check input status 353, 420-21
Check output status 421-22
child programs 218
CHKDSK command 15, 174, 222
C language
   CLEAN.C 309-11
   compiler (see C Optimizing Compiler)
   DUMP.C program 151, 161-63
   linking Ctrl-C and Ctrl-Break handlers to programs in 75-80
   MOUDEMO.C 82-83
   polling mouse and displaying mouse coordinates 82-83
   PROTO.C 303
   SHELL.C 225-29
   TRYBREAK 78-79
   tutorials 63
class type 38
CLEAN filter 303-11
   assembly source code 304-9
   C source code 309-11
clock, set tick count 589-90
CLOCK driver 282
Close file 357-58, 404-5
code page, get or set 474-75
code segment 38
code segment (CS) register 30
Color/Graphics Adapter (CGA) 86, 98, 102
color page state
   get 517
   set 515-16
color register(s)
   get 516
   get block of 516-17
   set 514-15
   set block of 515
COM1, COM2, COM3 devices 106, 110-12, 298
combine type 38
command code routines, device-driver 267-81
   function 00H, Driver initialization 268-69
   function 01H, Media Check 270-71
   function 02H, Build BIOS Parameter Block (BPB) 272
   function 03H, I/O-Control Read 272-73
   function 04H, Read 273
   function 05H, Nondestructive Read 274
   function 06H, Input Status 274
   function 07H, Flush Input Buffers 274-75
   function 08H, Write 275
   function 09H, Write with Verify 276
   function 0AH, Output Status 276
   function 0BH, Flush Output Buffers 276
   function 0CH, I/O-Control Write 276-77
   function 0DH, Device Open 277
   function 0EH, Device Close 277-78
   function 0FH, Removable Media 278
   function 10H, Output Until Busy 278-79
   function 13H, Generic IOCTL 279-80
   function 17H, Get Logical Device 280
   function 18H, Set Logical Device 280-81
   names of, and MS-DOS version support 267-68 (table)
COMMAND.COM file 14-16
   load 20
   replacing 13
   use of EXEC function 218
COMMAND.COM PLUS 13
command processor (shell) 13. See also COMMAND.COM file
commands, types of, accepted by COMMAND.COM 14-15
command tail 24, 220-21
Commit file 476-77
compatibility and portability 313-31
   degrees of compatibility 314-18
      MS-DOS applications 315-17
      ROM BIOS and hardware-compatible applications 317-18
   OS/2 compatibility 318-31
.COM program file(s) 15, 22, 25-30, 45
   assembly-language program transformed into 27-30
   vs .EXE files 22, 36 (table)
   memory allocation for 197-98
   memory image of a typical 26
CONFIG.SYS file 12
   installing device driver 293
   opening 18-19
configuration
   get equipment 535-36
   get information 525
   get system environment 573-74
console, direct input/output 347-48. See also video display
Console display and keyboard (CON) 12, 298-99
control data
   read, from block-device driver 418-19
   read, from character-device driver 415-16
   write, to block-device driver 419-20
   write, to character-device driver 416-17
Controller drive diagnostic 551
Controller internal diagnostic 551
Controller RAM diagnostic 550
cooked mode 69
C Optimizing Compiler 44, 48-50
   environmental variables 48
   version 5.1 switches 49-50
COPY command 14, 58
Country information
   get extended 470-74
   get or set 395-98
CP/M operating system 4, 5
   FCB compatibility with 129, 130-31
   program segment prefix compatibility with 24, 25
Create directory 398-99
Create file 364-65, 401-2
Create new file 458-59
Create new PSP 378-79
Create temporary file 457-58
CREF utility 44, 56-58
   cross-reference listing for HELLO.REF 57
.CRF files 45, 56
Critical-error handler address 481-82
critical-error handlers 24, 145, 147-51
   address 481-82
   skeleton program example 150-51
   stack at entry to 148, 149
cross-reference listing. See CREF utility
Ctrl-Break and Ctrl-C handlers 72-80
   compatibility issues 317
   Ctrl-C handler address 480-81
   high-level languages and 75-80
cursor
   addressing 97
   enable/disable emulation 528
   get position 502-3
   read character and attribute at 506
   set position 501-2
   set type 501
   write character and attribute at 506-7
   write character at 507-8

D
data segment 38
data segment (DS) register 31, 35
Date and time device (CLOCK$) 12
day count
   get 592-93
   set 593
Deallocate alternate map register set (EMS) 642
Deallocate DMA register set (EMS) 644
.DEF files 45
Delay 568-69
DEL(ETE) command 14
Delete directory 399
Delete file 361-62, 40, sug>8
dependency statements 61
descriptors, memory segment 321
device
   cancel redirection 467-68
   close 565
   get device information 412-13
   open 564-65
   post 572-73
   read file or 405-6
   redirect 466-67
   set device information 414-15
   wait 571
   write file or 406-7
Device Close (command code function 0EH) 277-78
Device close (MS-DOS function) 565
DEVICE commands 12
device drivers, installable 12-13, 259-96
   CLOCK driver 282
   command-code routines 267-81
   debugging 295-96
   chain before/after driver installation 294
   chain listing 295
   device attribute word 264
   error codes 267
   MS-DOS type 260-63
   processing of typical input/output requests 281-82
   structure of MS-DOS 263-67
      device header 263-64
      interrupt routine 26-67
      strategy routine 265
   writing and installing 282-95
      assembly 283-92
      installation 293-95
      linking 293
device drivers, resident 12-13
Device Open (command-code function 0DH) 277
Device open (MS-DOS function) 564-65
Device post 572-73
Device wait 571-72
Digital Research 4
DIR command 14, 167, 174
Direct console I/O 347-48
directory 166, 167-73
   create 398-99
   delete 399
   format of a single entry in a disk 184, 185
   functions controlling 167-68 get current 437-38
   hierarchical (tree) structure 166, 167
   moving files 173
   root 184-86
   searching 168-73
   set current 400
directory operations, Int 21H functions summary 339
Disable DMA on alternate map register set (EMS) 643-44
Disable EMM operating system functions (EMS) 645-46
Disable mouse driver 608-9
disk(s) 177-94. See also drive, logical; ESDI Fixed Disk Drive Adapter
   absolute read 482-84
   absolute write 484-85
   boot sector 179-82
   controller drive diagnostic 551
   controller internal diagnostic 551
   controller RAM diagnostic 550
   file allocation table 182-84
      interpreting the 188-92
   files area 186-88
   fixed-disk partitions 192-94
   format 543
   format bad track 542
   format track 541-42
   get change status 552-53
   get current 367
   get default drive data 368-69
   get drive allocation information 394-95
   get drive data 370
   get drive parameters 543-44
   get drive status 549
   get type 552
   initialize fixed disk characteristics 544-45
   map of typical logical volume 179
   park heads 554-55
   read sector 538-39
   read sector buffer 548
   read sector long 545-46
   recalibrate 550
   reserved area 182
   reset 354-55
   reset fixed disk system 548
   root directory 184-86, 187
   seek 547
   select 355-56
   set media type 554
   set type 553
   set verify flag 387-88
   verify sector 540
   write sector 539-40
   write sector buffer 549
   write sector long 546-47
disk bootstrap routine 16
   memory location of 17
disk management, Int 21H functions summary 339
disk-related errors 147, 148 (table)
Disk reset 354-55
disk system
   get status 537-38
   reset 536-37
disk transfer area (DTA) 25, 130
   get 388-89
   set 368
display page, set 503-4
Display string 350-51
DOS kernel 12, 18
   memory location of 19
double-byte character sets (DBCS), get lead byte table 469-70
drive, logical 166, 16,-73. See also disk(s)
   get map 433
   set map 434
   vs volume 174
driver. See device drivers, installable; device drivers, resident
DRIVER.ASM program 283-91
Driver Initialization (function 00H) 268-69
DUMP.ASM program 151, 152-61
   subroutines 163
DUMP.C program 151, 161-63
Duplicate handle 435
dynamic link library 331
dynamic memory allocation 199, 200, 201

E
echo
   character input with 343
   character input without 349-50
   unfiltered character input without 348-49
EMS. See Expanded Memory Specification (EMS)
Enable/disable cursor emulation 528
Enable/disable default palette loading 526-27
Enable/disable gray-scale summing 527
Enable/disable pointing device 574-75
Enable/disable screen refresh 529
Enable/disable video 527
Enable DMA on alternate map register set (EMS) 643
Enable EMM operating system functions (EMS) 645
Enable mouse driver 609
encapsulation of subroutines 323, 324-25
end of interrupt (EOI) 250
ENDP command 35, 41
ENDS command 29, 38
END statement 30-31, 36, 41
Enhanced Graphics Adapter (EGA) 86, 97, 98, 102
Enter protected mode 570-71
environment block 24, 220, 224-25
   dump of a typical 224
   three strings contained in 225
EQU statement 33
error codes, device driver 267
error codes, MS-DOS 145-51
   critical 145, 147-51
   expanded memory 207-9
error information, get/set 453-56
escape sequences, ANSI 92-93
ESDI Fixed Disk Drive Adapter (EP>
   format drive 555
   format periodic interrupt 562-63
Event wait 566-67
Exchange memory regions (EMS) 635-36
EXE2BIN utility 44, 55-56
EXEC function 15, 217-42. See also Int 21H Function 4BH
   calling convention 222
   compatibility in MS-DOS applications 317
   environment block 220, 224-25
   example programs SHELL.C and SHELL.ASM 225-40
      basic flow of both 239-40
      internal commands in 239
   example use of 223-24
   loading overlays with 240, 241-42
   making memory availinug for 218-19
   reference 441-42
   requesting 219-21
   returning from 221-24
.EXE (executable) program file(s) 15, 22, 30-36, 45
   assembly language program transformed into 33-36
   vs .COM files 22, 36 (table)
   converting, to .COM files (see EXE2BIN utility)
   header 30
   load module contents 33 load module format 32
   memory allocation for 198
   memory image of 31
   use for compatible MS-DOS applications 315
Expanded Memory Manager (EMM) 203-4
   checking for 204, 205-6
   enable/disable system functions 645-46
   error codes 207-9
Expanded Memory Specification (EMS) 201-11
   checking for expanded memory 204-6
   expanded memory defined 203-4
   functions reference (see Section IV)
      summary 614-15
   use of expanded memory 20,-11
      skeleton program illustrating 210-11
Extended communications port control 559-60
extended file control block 131
   volume-label search using 175
Extended initialize communications port 558-59
extended memory 204, 212-15
   moving blocks of data between conventional memory and 213-15
Extended open file 478-80
external (extrinsic) commands 15
external hardware interrupts 247
extra segment (ES) register 31

F
FAR attribute 35
   vs NEAR 29
faults (internal hardware interrupts) 246, 321
file(s)
   area, in disks 186-88
   close 357-58, 404
   commit 476-77
   create 364-65, 401-2
   create new 458-59
   create temporary 457-58
   delete 361-62, 407-8
   extended open 478-80
   find first 358-59, 445-46
   find next 360-61, 446-47
   get file size 375-76
   get/set date and time 450-51
   lock/unlock file region 460-61
   logical drive 166
   moving 123
   name and location 166
   open 356-57, 402-4
   read 405-6
   rename 366, 449-50
   types 45
   write 406-7
file-access skeleton program
   using FCB functions 134, 135-37
   using handle functions 141, 142-43
file allocation table (FAT) 16, 182-84
   assembly program to access 191
   contents 183
   interpreting 188-92
   media descriptor bytes 183
file attributes, get or set 410-11
file control blocks (FCBs) 25, 128
   default 130, 221
   directory searching with 169, 170-71
   extended 131, 133-34, 175
   file management with FCB functions 129-39
      advantages/disadvantages 138-39
      file-access skeleton program 134-38
      functions listed 132
      vs handle functions 128
   normal 129, 133-34
   before/after open call (Int 21H Function 0FH) 137
   restricted use 316, 319
   typical operation of 130
file management 127-63
   example programs DUMP.ASM and DUMP.C 151-63
   FCB functions 128, 129-39
   handle functions 128, 139-44
   MS-DOS Ärror codes 145-51
filename
   fully qualified 16
   parse 382-83
   requesting EXEC function 219
file operations, Int 21H functions summary 338
file pointer, set 408-9
file system 166
   structure 167
filters 297-311
   building 300-303
   CLEAN filter 303-11
   operation of 299-300
   prototype 301-3
   system support for 298-99
Find first file 358-59, 445-46
Find next file 360-61, 44-47
fixed-disk partitions 192-94
font functions 518-24
Format bad track 542
Format drive 543
Format ESDI drive 555-56
Format ESDI drive periodic interrupt 562-63
Format track 541-42
Flush input buffer and then input 353-54
Flush Input Buffers (function 07H) 274-75
Flush Output Buffers (function 0BH) 276

G
Generic I/O control for block devices 429-32
Generic I/O control for character devices 426-29
Generic IOCTL (function 13H) 279-80
Get addresses of mappable pages (EMS) 636
Get address of alternate mouse event handler 606
Get address of extended BIOS data area 574
Get all handle names (EMS) 631
Get alternate map registers (EMS) 639-40
Get attribute capability (EMS) 630
Get block of color registers 516-17
Get border color 514
Get button press information 596
Get button release information 597
Get color page state 517
Get color register 516
Get communications port status 558
Get configuration information 525
Get conventional memory size 536
Get current directory 437-38
Get current disk 367
Get cursor position 502-3
Get date 384-85, 591
Get day count 592
Get DBCS lead byte table 469-70
Get default drive data 368-69
Get device inform~on 412-13
Get disk change status 552-53
Get disk system status 537-38
Get disk type 552
Get drive allocation information 394-95
Get drive data 370-71
Get drive parameters 543-44
Get drive status 549
Get DTA address 388-89
Get enhanced keyboard flags 586-87
Get equipment configuration 535-36
Get extended country information 470-74
Get extended error information 453-56
Get extended memory size 570
Get file size 375-76
Get font information 524
Get functionality/state information 531-34
Get handle attribute (EMS) 629
Get handle count (EMS) 621-22
Get handle name (EMS) 630
Get handle pages (EMS) 622
Get hardware configuration (EMS) 637-38
Get interrupt vector 393-94
Get keyboard flags 582
Get keyboard status 582
Get language number 610
Get light pen position 503
Get Logical Device (command-code function) 280
Get logical drive map 433
Get machine name 461-62
Get mouse information 611
Get mouse position and button status 595
Get mouse save state buffer size 603
Get mouse sensitivity 607
Get MS-DOS version number 389-90
Get number of mappable pages (EMS) 637
Get number of pages (EMS) 617
Get number of raw pages (EMS) 638
Get or set allocation strategy 452-53
Get or set break flag, get boot drive 392-93
Get or set code page 474-75
Get or set country information 395-98
Get or set display combination code 530-31
Get or set file Attributes 410-11
Get or set file date and time 450-51
Get page frame address (EMS) 616
Get pages for all handles (EMS) 623
Get palette and border 514
Get palette register 513
Get pointer page 608
Get pointing device type 577
Get printer setup string 463-64
Get printer status 588
Get PSP address 468-69
Get redirection list entry 464-65
Get return code 444-45
Get size of alternate map register save area (EMS) 641
Get size of page map information (EMS) 625
Get size of partial page map information (EMS) 626-27
Get stack space for map page and call (EMS) 634
Get status (EMS) 616
Get system environment 573-74
Get tick count 589
Get time 386, 590
Get total handles (EMS) 632
Get verify flag 448
Get version (EMS) 619
Get video mode 511
Graphics CardPlus 87
graphics mode memory-mapped programming 101-3
gray-scale
   enable/disable summing 527
   get values 517
GROUP directive 39

H
handle functions
   check if handle is remote 424-25
   directory searching 169-70, 172-73
   DUMP.ASM program 151, 152-62
   DUMP.C program 151, 161-63
   duplicate handle 435
   file/record management with 139-44
      advantages/disadvantages 144
      vs FCB functions 128
      file access skeleton program 141-43
      functions listed 140-41
      typical operation 139
   keyboard input 62, 67-69
   redirect handle 436-37
   set handle count 475-76
   use for compatible MS-DOS applications 316
   volume-label search using176
hardware-compatible applications 314-15, 317-18
header(EP>
   device 263, 264, 269
   .EXE program files 30
Hercules Graphics Card 87, 97, 98
HELLO.COM program 27, 28-29, 30
   hex dump of 33
   map produced by Object Linker during generation of 51
HELLO.EXE program 33, 34-35, 36
HELLO.REF program, cross-reference listing 57
.H files 45
Hide mouse pointer 595

I
IBMBIO.COM file 16
   disk location 189-92
IBM Corporation, role in MS-DOS development 4-5
IBMDOS.COM file 13, 16
IBM PC 64
   PC/AT 64
   PS/2 64
   regen buffers in memory for various adapters 87
"ill-behaved" applications 315
.INC files 45
In-Color Card 87
Initialize communications port 556-57
Initialize fixed disk characteristics 544-45
Initialize or scroll window down 505-6
Initialize or scroll window up 505
Initialize pointing device interface 577-78
Initialize printer port 587-88
input. See character input/output; keyboard input; mouse, input; pointing
     device, input; serial port
input buffer, flush 353-54
Input/Output (I/O)-Control Read (function 03H) 272-73
Input/Output (I/O)-Control Write (function 0CH) 276-77
input/output (I/O) redirection 67, 298-99
input status, check 353, 420
Input Status (command-code function 06H) 274
INS8250 Asynchronous Communications Controller 112
installable device drivers 12-13
Int 10H, ROM BIOS video driver
   Function 00H, Set video mode 94, 500
   Function 01H, Set cursor type 94, 501
   Function 02H, Set cursor position 94, 501
   Function 03H, Get cursor position 94, 502
   Function 04H, Get light pen position 95, 503
   Function 05H, Set display page 95, 503
   Function 06H, Initialize or scroll window up 95, 505
   Function 07H, Initialize or scroll window down 95, 505
   Function 08H, Read character and attribute at cursor 95, 506
   Function 09H, Write character and attribute at cursor 94, 506
   Function 0AH, Write character at cursor 94, 507
   Function 0BH, Set palette, background, or border 95, 508
   Function 0CH, Write graphics pixel 95, 509
   Function 0DH, Read graphics pixel 95, 510
   Function 0EH, Write character in teletype mode 94, 510
   Function 0FH, Get video mode 94, 511
   Function 10H palette functions
      Subfunction 00H, Set palette register 511
      Subfunction 01H, Set border color 512
      Subfunction 02H, Set palette and border 512-13
      Subfunction 03H, Toggle blink/intensity bit 513
      Subfunction 07H, Get palette register 513
      Subfunction 08H, Get border color 514
      Subfunction 09H, Get palette and border 514
      Subfunction 10H, Set color register 514
      Subfunction 12H, Set block of color registers 515
      Subfunction 13H, Set color page state 515-16
      Subfunction 15H, Get color register 516
      Subfunction 17H, Get block of color registers 516
      Subfunction 1AH, Get color page state 517
      Subfunction 1BH, Set gray-scale values 517
   Function 11H, font functions
      Subfunctions 00H and 10H, Load user font 518
      Subfunctions 01H and 11H, Load ROM 8-by-14 font 518
      Subfunctions 02H and 12H, Load ROM 8-by-8 font 519
      Subfunction 03H, Set block specifier 520
      Subfunctions 04H and 14H, Load ROM 8-by-16 font 520
      Subfunction 20H, Set Int 1FH font pointer 521
      Subfunction 21H, Set Int 43H for user's font 522
      Subfunction 22H, Set Int 43H for ROM 8-by-14 font 522
      Subfunction 23H, Set Int 43H for ROM 8-by-8 font 523
      Subfunction 24H, Set Int 43H for ROM 8-by-16 font 523
      Subfunction 30H, Get font information 524
   Function 12H
      Subfunction 10H, Get configuration information 525
      Subfunction 20H, Select alternate printscreen 526
      Subfunction 30H, Set scan lines 526
      Subfunction 31H, Enable/disable default palette loading 526-27
      Subfunction 32H, Enable/disable video 527
      Subfunction 33H, Enable/disable gray-scale summing 527
      Subfunction 34H, Enable/disable cursor emulation 528
      Subfunction 35H, Switch active display 528
      Subfunction 36H, Enable/disable screen refresh 529
   Function 13H, Write string in teletype mode 529
   Function 1AH, Get or set display combination code 530
   Function 1BH, Get functionality/state information 531
   Function 1CH, Save or restore video state 534
Int 11H, Get equipment configuration 535
Int 12H, Get conventional memory size 536
Int 13H, ROM BIOS disk driver 319
   Function 00H, Reset disk system 536
   Function 01H, Get disk system status 537
   Function 02H, Read sector 538
   Function 03H, Write sector 539
   Function 04H, Verify sector 540
   Function 05H, Format track 541
   Function 06H, Format bad track 542
   Function 07H, Format drive 543
   Function 08H, Get drive parameters 543
   Function 09H, Initialize fixed disk characteristics 544
   Function 0AH, Read sector long 545
   Function 0BH, Write sector long 546
   Function 0CH, Seek 547
   Function 0DH, Reset fixed disk system 548
   Function 0EH, Read sector buffer 548
   Function 0FH, Write sector buffer 549
   Function 10H, Get drive status 549
   Function 11H, Recalibrate drive 550
   Function 12H, Controller RAM diagnostic 550
   Function 13H, Controller drive diagnostic 551
   Function 14H, Controller internal diagnostic 551
   Function 15H, Get disk type 552
   Function 16H, Get disk change status 552
   Function 17H, Set disk type 553
   Function 18H, Set media type for format 554
   Function 19H, Park heads 554
   Function 1AH, Format ESDI drive 555
Int 14H, ROM BIOS Serial communications port driver 111
   Function 00H, Initialize communications port 556
   Function 01H, Write character to communications port 557
   Function 02H, Read character from communications port 558
   Function 03H, Get communications port status 558
   Function 04H, Extended initialize communications port 558
   Function 05H, Extended communications port control 559
Int 15H, ROM BIOS I/O Subsystem Extensions
   Function 00H, Turn on cassette motor 560
   Function 01H, Turn off cassette motor 560
   Function 02H, Read cassette 561
   Function 03H, Write cassette 562
   Function 0FH, Format ESDI drive periodic interrupt 562
   Function 21H
      Subfunction 00H, Read POST error log 563
      Subfunction 01H, Write POST error log 563
   Function 4FH, Keyboard intercept 564
   Function 80H, Device open 564
   Function 81H, Device close 565
   Function 82H, Process termination 566
   Function 83H, Event wait 566
   Function 84H, Read joystick 567
   Function 85H, SysReq key 568
   Function 86H, Delay 568
   Function 87H, Move extended memory block 569
   Function 88H, Get extended memory size 570
   Function 89H, Enter protected mode 570
   Function 90H, Device wait 571
   Function 91H, Device post 572
   Function C0H, Get system environment 317, 573
   Function C1H, Get address of extended BIOS data area 574
   Function C2H
      Subfunction 00H, Enable/disable pointing device 574
      Subfunction 01H, Reset pointing device 575
      Subfunction 02H, Set sample rate 576
      Subfunction 03H, Set resolution 576
      Subfunction 04H, Get pointing device type 577
      Subfunction 05H, Initialize pointing device interface 577
      Subfunction 06H, Set scaling or get status 578
      Subfunction 07H, Set pointing device handler address 579
   Function C3H, Set watchdog time-out 580
   Function C4H, Programmable option select 580
Int 16H, ROM BIOS keyboard driver 322
   Function 00H, Read character from keyboard 581
   Function 01H, Get keyboard status 582
   Function 02H, Get keyboard flags 582
   Function 03H, Set repeat rate 583
   Function 04H, Set keyclick 584
   Function 05H, Push character and scan code 585
   Function 10H, Read character from enhanced keyboard 585
   Function 11H, Get enhanced keyboard status 586
   Function 12H, Get enhanced keyboard flags 586
Int 17H, ROM BIOS Parallel port printer driver 108-19
   Function 00H, Write character to printer 587
   Function 01H, Initialize printer port 587
   Function 02H, Get printer status 588
Int 18H, ROM BASIC 588
Int 19H, ROM BIOS Reboot system 588
Int 1AH, Real-time (CMOS) Clock Driver
   Function 00H, Get tick count 589
   Function 01H, Set tick count 589
   Function 02H, Get time 590
   Function 03H, Set time 590
   Function 04H, Get date 591
   Function 05H, Set date 591
   Function 06H, Set alarm 591
   Function 07H, Reset alarm 592
   Function 0AH, Get day count 592
   Function 0BH, Set day count 593
   Function 80H, Set sound source 593
Int 20H, Terminate process 341
Int 21H, MS-DOS system functions
   function execution in a typical I/O request 281-82
   function summary by category 337-40 (table)
   function summary by number 335-37 (table)
   Function 00H, Terminate process 342
   Function 01H, Character input with echo 70, 148, 343
   Function 02H, Character output 90, 344
   Function 03H, Auxiliary input 110, 344-45
   Function 04H, Auxiliary output 110, 345-46
   Function 05H, Printer output 107, 346-47
   Function 06H, Direct console I/O 70, 73, 90, 347-48
   Function 07H, Unfiltered character input without echo 70, 73, 348-49
   Function 08H, Character input without echo 70, 349-50
   Function 09H, Display string 90, 350-51
   Function 0AH, Buffered keyboard input 70-71, 351-52
   Function 0BH, Check input status 70, 353
   Function 0CH, Flush input buffer and then input 70, 353-54
   Function 0DH, Disk reset 354-55
   Function 0EH, Select disk 167, 355-56
   Function 0FH, Open file 132, 137, 356-57
   Function 10H, Close file 132, 357-58
   Function 11H, Find first file 358-59
   Function 12H, Find next file 360-61
   Function 13H, Delete file 132, 361-62
   Function 14H, Sequential read 132, 362-63
   Function 15H, Sequential write 132, 363-64
   Function 16H, Create file 132, 364-65
   Function 17H, Rename file 132, 173, 366-67
   Function 18H, Reserved 367
   Function 19H, Get current disk 167, 168, 367
   Function 1AH, Set DTA address 130, 132, 368
   Function 1BH, Get default drive data 368-69
   Function 1CH, Get drive data 370
   Function 1DH, Reserved 371
   Function 1EH, Reserved 371
   Function 1FH, Reserved 371
   Function 20H, Reserved 371
   Function 21H, Random read 132, 372-73
   Function 22H, Random write 132, 373-75
   Function 23H, Get file size 132, 375-76
   Function 24H, Set relative record number 132, 376
   Function 25H, Set interrupt vector 147, 252, 253, 316, 377-78
   Function 26H, Create new PSP 378-79
   Function 27H, Random block read 132, 379-80
   Function 28H, Random block write 132, 381-82
   Function 29H, Parse filename 129, 132, 382
   Function 2AH, Get date 384-85
   Function 2BH, Set date 385
   Function 2CH, Get time 386
   Function 2DH, Set time 386-87
   Function 2EH, Set verify flag 387-88
   Function 2FH, Get DTA address 388-89
   Function 30H, Get MS-DOS version number 148, 319, 389
   Function 31H, Terminate and stay resident 252, 253, 390-91
   Function 32H, Reserved 392
   Function 33H, Get or set break flag, get boot drive 392-93
   Function 34H, Reserved 393
   Function 35H, Get interrupt vector 252, 316, 393-94
   Function 36H, Get drive allocation information 394-95
   Function 37H, Reserved 395
   Function 38H, Get or set country information 395-98
   Function 39H, Create directory 167, 398-99
   Function 3AH, Delete directory 167, 399
   Function 3BH, Set current directory 167, 400
   Function 3CH, Create file 140, 401-2
   Function 3DH, Open file 107, 110, 140, 204, 402-4
   Function 3EH, Close file 140, 204, 404
   Function 3FH, Read file or device 67, 69, 71, 109, 110, 141, 298,
        300, 322, 405-6
   Function 40H, Write file or device 35, 88, 107, 109, 110, 141,
        298, 300, 322, 406-7
   Function 41H, Delete file 141, 407-8
   Function 42H, Set file pointer 141, 408-9
   Function 43H, Get or set file attributes 141, 410-11
   Function 44H, IOCTL (I/O control) 69, 93-94, 111, 204, 205, 411-34
      Subfunction 00H, IOCTL: get device information 412-13
      Subfunction 01H, IOCTL: set device information 414-15
      Subfunction 02H, IOCTL: read control data from character device driver
           415-16
      Subfunction 03H, IOCTL: write control data to character device driver
           416-17
      Subfunction 04H, IOCTL: read control data from block device driver
           418-19
      Subfunction 05H, IOCTL: write control data to block device driver
           419-20
      Subfunction 06H, IOCTL: check input status 420-21
      Subfunction 07H, IOCTL: check output status 421-22
      Subfunction 08H, IOCTL: check if block device is removable 422-23
      Subfunction 09H, IOCTL: check if block device is remote 423-24
      Subfunction 0AH, IOCTL: check if handle is remote 424-25
      Subfunction 0BH, IOCTL: change sharing retry count 425-26
      Subfunction 0CH, IOCTL: generic I/O control for character devices
           426-29
      Subfunction 0DH, IOCTL: generic I/O control for block devices 429-32
      Subfunction 0EH, IOCTL: get logical drive map 433
      Subfunction 0FH, IOCTL: set logical drive map 434
   Function 45H, Duplicate handle 141, 435
   Function 46H, Redirect handle 141, 299, 436-37
   Function 47H, Get current directory 167, 168, 437-38
   Function 48H, Allocate memory block 196, 202, 323, 438-39
   Function 49H, Release memory block 196, 323, 439-40
   Function 4AH, Resize memory block 196, 198, 202, 219, 239, 322,
        440-41
   Function 4BH, Execute program (EXEC) 202, 299, 441-42 (see also EXEC
        function)
   Function 4CH, Terminate process with return code 26, 31, 35, 317,
        443-44
   Function 4DH, Get return code 221, 444-45
   Function 4EH, Find first file 445-46
   Function 4FH, Find next file 446-47
   Function 50H, Reserved 447
   Function 51H, Reserved 447
   Function 52H, Reserved 447
   Function 53H, Reserved 448
   Function 54H, Get verify flag 448
   Function 55H, Reserved 448
   Function 56H, Rename file 141, 173, 449-50
   Function 57H, Get or set file date and time 141, 450-51
   Function 58H, Get or set allocation strategy 452-53
   Function 59H, Get extended error information 130, 145, 148, 453-56
   Function 5AH, Create temporary file 141, 457-58
   Function 5BH, Create new file 141, 458-59
   Function 5CH, Lock or unlock file region 141, 460-61
   Function 5DH, Reserved 461
   Function 5EH, Machine name and printer setup
      Subfunction 00H, Get machine name 461-62
      Subfunction 02H, Set printer setup string 462-63
      Subfunction 03H, Get printer setup string 463-64
   Function 5FH, Device redirection
      Subfunction 02H, Get redirection list entry 464-65
      Subfunction 03H, Redirect device 466-67
      Subfunction 04H, Cancel device redirection 467-68
   Function 60H, Reserved 468
   Function 61H, Reserved 468
   Function 62H, Get PSP address 468-69
   Function 63H, Get DBCS lead byte table 469-70
   Function 64H, Reserved 470
   Function 65H, Get extended country information 470-74
   Function 66H, Get or set code page 474-75
   Function 67H, Set handle count 141, 475-76
   Function 68H, Commit file 141, 476-77
   Function 69H, Reserved 477
   Function 6AH, Reserved 477
   Function 6BH, Reserved 477
   Function 6CH, Extended open file 141, 478-80
Int 22H, Terminate handler address 480
Int 23H, Ctrl-C handler address 317, 480-81
Int 24H, Critical-error handler address 147, 317, 481-82
Int 25H, Absolute disk read 482-84
Int 26H, Absolute disk write 319, 484-85
Int 27H, Terminate and stay resident 486-87
Int 28H, Reserved 487
Int 29H, Reserved 487
Int 2AH, Reserved 487
Int 2BH, Reserved 487
Int 2CH, Reserved 487
Int 2DH, Reserved 488
Int 2EH, Reserved 488
Int 2FH, Multiplex interrupt 488
   Function 01H, Print spooler 488-89
   Function 02H, ASSIGN 489
   Function 10H, SHARE 490
   Function B7H, APPEND 490-91
Int 33H, Microsoft Mouse driver 593
   Function 00H, Reset mouse and get status 80, 594
   Function 01H, Show mouse pointer 80, 594
   Function 02H, Hide mouse pointer 80, 595
   Function 03H, Get mouse position and button status 80, 595
   Function 04H, Set mouse pointer position 80, 596
   Function 05H, Get button press information 80, 596
   Function 06H, Get button release information 80, 597
   Function 07H, Set horizontal limits for pointer 80, 597
   Function 08H, Set vertical limits for pointer 80, 598
   Function 09H, Set graphics pointer shape 80, 598
   Function 0AH, Set text pointer type 80, 599
   Function 0BH, Read mouse motion counters 80, 599
   Function 0CH, Set user-defined mouse event handler 80, 600
   Function 0DH, Turn on light pen emulation 80, 601
   Function 0EH, Turn off light pen emulation 80, 601
   Function 0FH, Set mickeys to pixels ratio 80, 601
   Function 10H, Set mouse pointer exclusion area 80, 602
   Function 13H, Set double speed threshold 81, 602
   Function 14H, Swap user-defined mouse event handlers 81, 603
   Function 15H, Get mouse save state buffer size 81, 603
   Function 16H, Save mouse driver state 81, 604
   Function 17H, Restore mouse driver state 81, 604
   Function 18H, Set alternate mouse event handler 81, 604
   Function 19H, Get address of alternate mouse event handler 81, 606
   Function 1AH, Set mouse sensitivity 81, 606
   Function 1BH, Get mouse sensitivity 81, 607
   Function 1CH, Set mouse interrupt rate 81, 607
   Function 1DH, Select pointer page 81, 608
   Function 1EH, Get pointer page 81, 608
   Function 1FH, Disable mouse driver 81, 608
   Function 20H, Enable mouse driver 81, 609
   Function 21H, Reset mouse driver 81, 609
   Function 22H, Set language for mouse driver messages 81, 610
   Function 23H, Get language number 81, 610
   Function 24H, Get mouse information 81, 611
Int 67H, Expanded Memory Manager functions 204, 205, 207
   Function 40H, Get status 616
   Function 41H, Get page frame address 616
   Function 42H, Get number of pages 617
   Function 43H, Allocate handle and pages 617
   Function 44H, Map expanded memory page 618
   Function 45H, Release handle and expanded memory 619
   Function 46H, Get version 619
   Function 47H, Save page map 620
   Function 48H, Restore page map 620
   Function 49H, Reserved 621
   Function 4AH, Reserved 621
   Function 4BH, Get handle count 621
   Function 4CH, Get handle pages 622
   Function 4DH, Get pages for all handles 623
   Function 4EH
      Subfunction 00H, Save page map 623
      Subfunction 01H, Restore page map 624
      Subfunction 02H, Save and restore page map 624
      Subfunction 03H, Get size of page map information 625
   Function 4FH
      Subfunction 00H, Save partial page map 625
      Subfunction 01H, Restore partial page map 626
      Subfunction 02H, Get size of partial page map information 626
   Function 50H
      Subfunction 00H, Map multiple pages by number 627
      Subfunction 01H, Map multiple pages by address 627
   Function 51H, Reallocate pages for handle 628
   Function 52H
      Subfunction 00H, Get handle attribute 629
      Subfunction 01H, Set handle attribute 629
      Subfunction 02H, Get attribute capability 630
   Function 53H
      Subfunction 00H, Get handle name 630
      Subfunction 01H, Set handle name 631
   Function 54H
      Subfunction 00H, Get all handle names 631
      Subfunction 01H, Search for handle name 632
      Subfunction 02H, Get total handles 632
   Function 55H
      Subfunctions 00H and 01H, Map pages and jump 633
   Function 56H
      Subfunctions 00H and 01H, Map pages and call 633
      Subfunction 02H, Get stack space for map page and call 634
   Function 57H
      Subfunction 00H, Move memory region 635
      Subfunction 01H, Exchange memory regions 635
   Function 58H
      Subfunction 00H, Get addresses of mappable pages 636
      Subfunction 01H, Get number of mappable pages 637
   Function 59H
      Subfunction 00H, Get hardware configuration 637
      Subfunction 01H, Get number of raw pages 638
   Function 5AH
      Subfunction 00H, Allocate handle and standard pages 638
      Subfunction 01H, Allocate handle and raw pages 639
   Function 5BH
      Subfunction 00H, Get alternate map registers 639
      Subfunction 01H, Set alternate map registers 640
      Subfunction 02H, Get size of alternate map register save area 641
      Subfunction 03H, Allocate alternate map register set 641
      Subfunction 04H, Deallocate alternate map register set 642
      Subfunction 05H, Allocate DMA register set
      Subfunction 06H, Enable DMA on alternate map register set 643
      Subfunction 07H, Disable DMA on alternate map register set 643
      Subfunction 08H, Deallocate DMA register set 644
   Function 5CH, Prepare expanded memory manager for warm boot 644
   Function 5DH
      Subfunction 00H, Enable EMM operating system functions 645
      Subfunction 01H, Disable EMM operating system functions 645
      Subfunction 02H, Release access key 646
Intel 80x86 microprocessor family 4, 8, 38, 64, 203
   interrupts and 246-51
Intel 8259A Programmable Interrupt Controller 112, 320
internal hardware interrupts 246
internal (intrinsic) commands 14
interrupt(s) 13, 244-45. See also Int 10H through Int 67H
   external hardware 247
   internal hardware 246
   servicing 250-51
   software 247-49
   types 244
interrupt handlers 16
   example (ZERODIV.ASM) 254-58
   MS-DOS and 252-53
   servicing 250, 251
   tasks 245
   typical 251
interrupt (intr) routine, device-driver 266-67, 293. See also command code
     routines
interrupt vector 17, 244
   get 393-94
   set 377-78
interrupt vector table 250
IOCTL (I/O control). See Int 21H, Function 44H
IO.SYS file 16, 17
   memory location of 18

J
Japanese character set 6
joystick, read 567

K
kernel. See DOS kernel
keyboard
   get enhanced flags 586-87
   get enhanced status 586
   get flags 582
   get status 582
   input with/without echo 70
   intercept 564
   key repeat rate and delay 583-84
   push character and scan code in buffer 585
   read character from 581
   read character from enhanced 585
   set keyclick 584
keyboard input 65-72
   buffered 351-52
   Ctrl-C and Ctrl-Break handlers 72-80, 317
   with handles 66, 67-69
   read character from keyboard 581
   with ROM BIOS functions 71-72
   with traditional calls 69-71
Keyboard input with echo 70
Keyboard input without echo 70
Keyboard intercept 564
Korean character set 6

L
.LIB files 44, 45, 58. See also Library Manager (LIB)
Library Manager (LIB) 44, 58-60
   operations prefix characters 58
   table-of-contents listing for SLIBC.LIB 59
light pen
   get position 503
   turn off emulation 601
   turn on emulation 601
line printer (PRN) 12, 106, 298
LINK. See Object Linker (LINK)
Load ROM 8-by-8 font 519
Load ROM 8-by-14 font 518-19
Load ROM 8-by-16 font 520-21
Load user font 518
Lock or unlock file region 460-61
Lotus/Intel/Microsoft Expanded Memory (LIM EMS). See Expanded Memory
     Specification (EMS)
LPT1, LPT2, LPT3 devices 106, 298
.LST files 45

M
machine name, get 461-62
Macro Assembler (MASM) 44, 45-47
   command line mode 46
   interactive mode 46
   levels
      modules 37
      procedures 41-42
      segments 38-41
   tutorials 63
   version 5.1 switches 47
make files 61
MAKE utility 60-61
   switches for 61
Map expanded memory page (EMS) 618
.MAP files 45
Map multiple pages by address (EMS) 627-28
Map multiple pages by number (EMS) 627
Map pages and call (EMS) 633-34
MASM. See Macro Assembler (MASM)
master boot record 192
Media Check (function 01H) 270-71
memory
   allocation
      dynamic, of additional 199-201
      shrinking 197-99
   conventional 196
      moving blocks of data between extended memory and 213-15
   expanded (see Expanded Memory Specification (EMS))
   image of .COM file 26
   image of .EXE file 31
   location of disk bootstrap program in 17
   location of IO.SYS in 18
   location of ROM bootstrap routine in 16
   location of SYSINIT, DOS kernel, MSDOS.SYS in 19
   making available, for EXEC function 218-19
   map after startup 20
   RAM 196
memory areas, 196. See also arena entries; arena headers; transient program
     area (TPA)
memory block
   allocate 438-39
   get/set allocation strategy 452-53
   move extended 569-60
   release 439-40
   resize 440-41
memory interlace 203
memory management 195-215
   arena headers 201-2
   expanded memory 203-11
      using 207-11
   extended memory 212-15
   Int 21H functions summary 339
   MS-DOS applications compatibility and 316
   using memory-allocation functions 197-202
memory-mapped input/output 86, 96-103
   graphics mode 101-3
   text mode 96-101
memory models 39
   segments, groups, classes for 40
memory segment 321-22
memory size
   get conventional 536
   get extended 570
mickeys, set to pixel ratio 601
Microsoft Mouse driver 593-611
miscellaneous system functions, Int 21H functions summary 340
MKDIR (MD) command 167
Monochrome/Printer Display Adapter (MDA) 86, 97, 98
   example dump, regen buffer 98
MOUDEMO.C program 82-83
mouse. See also pointing device
   disable driver 608-9
   driver 593
   enable driver 609
   get address of alternate event handler 606
   get button press information 596
   get button release information 597
   get information 611
   get language number 610
   get mouse save state buffer size 603-4
   get position and button status 595
   get sensitivity 607
   hide pointer 595
   input 80-83
   read motion counters 599-600
   reset and get status 594
   reset driver 609
   save driver state 604
   set alternate event handler 604-5
   set double speed threshold 602
   set graphics pointer shape 598
   set interrupt rate 607
   set language for driver messages 610
   set pointer exclusion area 602
   set pointer horizontal limits 597-98
   set pointer page 608
   set pointer position 596
   set pointer vertical limits 598
   set sensitivity 606
   set text pointer type 599
   set user-defined event handler 600-601
   show pointer 594-95
   summary of function calls 494-99
   swap user-defined event handlers 603
Move extended memory block 569-70
Move memory region (EMS) 635
MS-DOS. See also Operating System/2 (OS/2)
   genealogy 3-9
   interrupt handlers and 252-53
   loading 16-20
   programming tools (see programming tools)
   structure 12-16
MS-DOS application programs, porting to OS/2 318-31
   conversion 326-30
   encapsulation 323, 324-25
   MS-DOS function calls and OS/2 counterparts 328-29
   optimization 330-31
   rationalization 322-23
   ROM BIOS functions and OS/2 equivalents used in MS-DOS applications 330
   segmentation 321-22
MS-DOS application programs, structure of 21-42
   assembly-language programs 27-30, 37-42
   .COM programs introduced 25-30
   creation of 62-63
   .EXE programs introduced 30-36
   program procedures 41-42
   program segment prefix 23-25
MS-DOS application programs, writing compatible 314, 315-17
   check host capabilities 316
   exception handling 317
   input and output 316
   memory management 316
   process management 317
   program structure 315
MS-DOS error codes 145-51
MS-DOS functions 334
   conversion of, to OS/2 function calls 326-27
   display functions 88-94
      binary output mode 93-94
      screen control 91-93
   EXEC (see EXEC function)
   file control block (FCB) 129-39
   handle 139-44
   memory management/allocation 196, 197-202
   OS/2 equivalents to 328-29
   printer output 107-9
   reference (see Section II)
   serial port 109-12
   typical in-line code for call to 324
MSDOS.SYS file 13, 16
   memory location of 19
MS-DOS versions
   1.0 4-5, 138
   1.25 5
   2.00 5-6, 174
      error codes 145
      volume-label search under 175
   2.11, 2.25 6
   3.0 6-7, 138, 174
      error codes 145-46
      volume-label search under 176
   3.1, 3.2, 3.3, 4.0 7
   get number 389-90
   support for select command code routines by 267-68 (table)
Multi-Color Graphics Array (MCGA) 86, 102
Multiplex interrupt 488

N
NAME statement 27, 33
NEAR attribute 27
   vs FAR 29
NEAR RETURN 27
network functions, Int 21H functions summary 339
Nondestructive Read (function 05H) 274
non-disk-related errors 147, 148 (table)

O
Object Linker (LINK) 37, 44, 50-55
   map produced by, of HELLO.EXE program 51
   switches accepted by 53-55
object modules 37
   libraries (see Library Manager (LIB))
   linking .COM files from 27, 37. See also Object Linker (LINK)
.OBJ files 45
Open file 356-57, 402-4
Operating System/2 (OS/2) 7
   code optimization 330-31
   compatibility issues 318-20
   function calls equivalent to MS-DOS function calls 328-29
   function calls equivalent to ROM BIOS function calls 330
   porting MS-DOS applications to OS/2 320-31
ORG instruction 29
output. See character input/output; printer output; serial port
output status, check 421-22
Output Status (command-code function 0AH) 276
Output Until Busy (function 10H) 278-79
overlays, loading with EXEC 240, 241-42

P
PAGE command 27, 33
page frame 203
palette
   enable/disable default 526-27
   get border and 514
   get register 513
   set 508-9
   set border and 512-13
   set register 511-12
parallel ports 106
parameter block, requesting EXEC function 220-21
parent programs 218
Park heads 554-55
Parse filename 382-84
partitions, fixed-disk 192-94
Paterson, Tim 4
path 166
PC-DOS
   version 1.0 4
   version 1.1 5
   version 2.0 5-6
   version 3.0 193-94
piping parameters 24
pixel 101
   formula to calculate bit position for 102-3
   read graphics 510
   set mickeys to pixel ratio 601-2
   write graphics 509
pointing device
   enable/disable 574-75
   get device type 577
   get scaling or get status 578-79
   initialize interface 577-78
   input 80-83
   reset 575
   set handler address 579-80
   set resolution 576-77
   set sample rate 576
POP instruction 35
portability. See compatibility and portability
POST (power-on self-test)
   read error log 563
   write error log 563-64
Prepare expanded memory manager for warm boot (EMS) 644-45
Presentation Manager, OS/2 318
printer 106, 107-9. See also line printer (PRN); standard printer (stdprn)
   get setup strings 463-64
   get status 588
   initialize port 587
   write character to 587
printer output 106, 107-9, 346-47. See also TALK.ASM program
printer setup string
   get 463-64
   set 462-63
printscreen, select alternate 526
Print spooler 488-89
PRN device 12, 106, 298-99
PROC command 29, 35, 41
procedure, declaring beginning/end of 29
process management
   for compatibility in MS-DOS applications 317
   Int 21H functions summary 339
   terminate process 566
Process termination 566
Programmable Interrupt Controller (PIC) 247
Programmable option select 580-81
programming tools 43-64
   C Optimizing compiler 48-50
   CREF utility 56-58
   example using 62-63
   EXE2BIN utility 55-56
   file types 45
   Library Manager 58-60
   MAKE utility 60-61
   MASM 45-47 (see also Macro Assembler (MASM))
   Object Linker 50-55 (see also Object Linker (LINK))
   resources and references 63-64
program modules, assembly-language 37
program procedures 41-42
program segment prefix (PSP) 15, 23-25
   create new 378-79
   get address 468-69
   structure of 23
program segments, assembly-language 38-41
protected mode, enter 570-71
PROTO.ASM program 301-2
PROTO.C program 303
P-system operating system 5
Push character and scan code 585
PUSH instruction 35

R
Random block read 379-80
Random block write 381-82
Random read 372-73
Random write 373-75
rationalizing code 322-23
raw mode 69
Read (function 04H) 273
Read cassette 561
Read character and attribute at cursor 506
Read character from communications port 558
Read character from enhanced keyboard 585
Read character from keyboard 581
Read control data from block-device driver 418-19
Read control data from character device driver 415-16
Read file or device 405-6rRead graphics pixel 510
Read joystick 567
Read mouse motion counters 599-600
Read POST error log 563
Read sector 538-39
Read sector buffer 548
Read sector long 545-46
Reallocate pages for handle (EMS) 628
Reboot system 588-89
Recalibrate drive 550
record(s)
   set relative number 376-77
   using FCB functions 129-39
   using handle functions 139-44
record operations, Int 21H functions summary 338-39
Redirect device 466-67
Redirect handle 436-37
redirection, input/output 24, 67, 298-99
   cancel 467-68
redirection list entry, get 464-65
.REF files 45, 56
refresh buffer 86
regen buffer 86
   example dump of MDA adapter 98
   formula to determine offset 102
   memory diagram showing location of 87
Release access key (EMS) 646
Release handle and expanded memory (EMS) 619
Release memory block 439-40
Removable Media (function 0FH) 278
REN(AME) command 14
Rename file 366-67, 449-50
request header format 265
   command codes for (see command code routines, device-driver)
reserved area, disk 182
reserved functions
   EMS 621
   Int 21H functions summary 340
Reset alarm 592
Reset disk system 536-37
Reset fixed disk system 548
Reset mouse and get status 594
Reset mouse driver 609
Reset pointing device 575
resident device drivers 12
Resize memory block 440-41
RESTORE command 15
Restore mouse driver state 604
Restore page map (EMS) 620-21, 624
Restore partial page map (EMS) 626
RET instruction 41
retrace interval 100
return code
   get 444
   terminate process with 443-44
RMDIR (RD) command 167
ROM 8-by-8 font
   load 519
   set Int 43H for 523
ROM 8-by-14 font
   load 518-19
   set Int 43H for 522-23
ROM 8-by-16 font
   load 520-21
   set Int 43H for 523-24
ROM BASIC 588
ROM BIOS
   display functions 94-96, 330
   interrupts of special importance to 247, 248-49
   keyboard functions 67
      input with 71-72
ROM BIOS compatibility 314-16, 317-18
   avoid unstable hardware 318
   check host capabilities 317-18
   functions of, and OS/2 equivalents 330
ROM BIOS function calls. See also Section III
   summary 494-99
ROM bootstrap routine 16
root directory 166, 184-86, 187
   partial hex dump 186
RS-232 serial-interface standard 106
RS-422 serial-interface standard 106

S
Save and restore page map (EMS) 624-25
Save mouse driver state 604
Save or restore video state 534-35
Save page map (EMS) 620, 623
Save partial page map (EMS) 625-26
scan lines, set 526
screen control with MS-DOS functions 91-93
screen refresh, enable/disable 529
Search for handle name (EMS) 632
Seattle Computer Products 4
Seek 547
SEGMENT command 29, 33, 38
segment register 321
Select alternate printscreen 526
Select disk 355-56
selector 321
Select pointer page 608
Sequential read 362-63
Sequential write 363-64
serial port 106, 109-12. See also TALK.ASM program
   extended initialize port 558-59
   extended port control 559-60
   get status 558
   initialize 556-57
   read character from 558
   write character to 557
Set alarm 591-92
Set alternate map registers (EMS) 640
Set alternate mouse event handler 604-5
Set block of color registers 515
Set block specifier 520
Set border color 512
Set color page state 515-16
Set color register 514-15
Set current directory 400
Set cursor position 501-2
Set cursor type 501
Set date 385, 591
Set day count 593
Set device information 414-15
Set disk type 553
Set display page 503-4
Set double speed threshold 602
Set DTA address 368
Set file pointer 408-9
Set graphics pointer shape 598
Set gray-scale values 517
Set handle attribute (EMS) 629
Set handle count 475-76
Set handle name (EMS) 631
Set horizontal limits for pointer 597-98
Set Int 1FH font pointer 521
Set Int 43H for ROM 8-by-8 font 523
Set Int 43H for ROM 8-by-14 font 522-23
Set Int 43H for ROM 8-by-16 font 523-24
Set Int 43H for user's font 522
Set interrupt vector 377-78
Set keyclick 584
Set language for mouse driver messages 610
Set Logical Device (function 18H) 280-81
Set logical drive map 434
Set media type for format 554
Set mickeys to pixels ratio 601
Set mouse interrupt rate 607
Set mouse pointer exclusion area 602
Set mouse pointer position 596
Set mouse sensitivity 606
Set palette and border 512-13
Set palette, background, or border 508-9
Set palette register 511-12
Set pointing device handler address 579-80
Set printer setup string 462-63
Set relative record number 376-77
Set repeat rate 583-84
Set resolution 576-77
Set sample rate 576
Set scaling or get status 578-79
Set scan lines 526
Set sound source 593
Set text pointer type 599
Set tick count 589-90
Set time 386-87, 590
Set user-defined mouse event handler 600-601
Set verify flag 387-88
Set vertical limits for pointer 598
Set video mode 500-501
Set watchdog time-out 580
SHARE 490
shell. See COMMAND.COM file; command processor (shell)
SHELL.ASM program 229-38
SHELL.C program 225-29
Show mouse pointer 594-95
SLIBC.LIB, table-of-contents listing for 59
Softech company 5
software interrupts, 247-49
sound source, set 593
STACK attribute 31
stack pointer (SP) register 25-26, 31, 35
stack segment 38
stack segment (SS) register 31, 35
standard auxiliary device (stdaux) 20, 323
   default device 298
   handle 66
standard error device (stderr) 20
   default device 298
   handle 66
standard input device (stdin) 20
   default device 298
   handle 66, 67
standard list device 20, 323
standard output device (stdout) 20
   default device 298
   handle 66
standard printer (stdprn)
   default device 298
   handle 66
strategy (strat) routine, device-driver 265, 293
string(s)
   display 350-51
Swap user-defined mouse event handlers 603
Switch active display 528-29
switches
   C Optimizing compiler 49-50
   Library Manager 60
   Macro Assembler 47
   Make utility 61
   Object Linker 53-55
SYSINIT module 17, 18, 20
   installing device drivers 293
   memory location of 19
SysReq key 568
system file table 140-41

T
TALK.ASM program 113-26
teletype mode
   write character in 510-11
   write string in 529-30
terminal-emulator program. See TALK.ASM program
Terminate and stay resident 390-91, 486-87
Terminate handler address 480
Terminate process 341, 342
Terminate process with return code 443-44
text-mode memory-mapped programming 96-101
threads 331
time and date
   day count 592, 593
   get date 384-85, 591
   get time 386, 590
   set date 385, 591
   set time 386-87, 590
TITLE command 27, 33
Toggle blink/intensity bit 513
transient program 15, 22. See also .COM program file(s);
     .EXE (executable) program file(s)
transient program area (TPA) 15, 196. See also arena entries; arena
     headers
TREE command 174
TRYBREAK.C program 78-79
Turn off cassette motor 560-61
Turn on cassette motor 560
Turn off light pen emulation 601
Turn on light pen emulation 601

U
Unfiltered character input without echo 348-49
UNIX/XENIX operating system 66, 128, 139
user font
   load 518
   set Int 1FH pointer 521
   set Int 43H for 522

V
verify flag, get 448
Verify sector 540
video display 85-103
   adapters 86-87
   enable/disable 527
   get functionality/state information 531-34
   get or set combination code 530-31
   memory-mapped techniques 96-103
      graphics mode 101-3
      text mode 96-101
   MS-DOS display functions 88-94
      binary output mode 93-94
      screen control with 91-93
   ROM BIOS display functions 94-96
   save or restore video state 534-35
   support considerations 88
   switch active display 528-29
Video Graphics Array (VGA) 86, 97, 98, 102
video mode
   get 511
   set 500-501
VOL command 174
volume labels 174-76
   search, using extended file control block 175

W
watchdog time-out, set 580
window
   initialize or scroll down 505-6
   initialize or scroll up 505
Windows 7, 318
Write (function 08H) 275
Write cassette 562
Write character and attribute at cursor 506-7
Write character at cursor 507-8
Write character in teletype mode 510-11
Write character to communications port 557
Write character to printer 587
Write control data to block-device driver 419-20
Write control data to character-device driver 416-17
Write File or Device 406-7
Write graphics pixel 509
Write POST error log 563-64
Write screen in teletype mode 529-30
Write sector 539
Write sector buffer 549
Write sector long 546-47
Write with Verify (function 09H) 276

Z
ZERODIV.ASM program 254, 255-58
Zilog Z-80 microprocessor 4
