                           Ч А С Т Ь  5.

                            ПРИЛОЖЕНИЯ.

                          ПРИЛОЖЕНИЕ  А.

                       СООБЩЕНИЯ ОБ ОШИБКАХ.

                 Сообщения об ошибках компиляции.

     Приведенные ниже списки возможных сообщений об  ошибках  можно
получить   от  компилятора  при  разработке  программы.  Когда  это
возможно,  компилятор  будет  выводить  на  дисплей  дополнительную
диагностическую  информацию  в виде имени идентификатора или файла,
например :

         Error 15 : File not found (Window.TPU)
         (Ошибка 15 : Файл не найден)

     Когда ошибка   обнаружена,  Turbo  Pascal  (в  интегрированной
среде) автоматически загружает исходный файл и  помещает  курсор  в
позицию  ошибки.  Компилятор  командной  строки  выводит на дисплей
сообщение  об  ошибке  и  ее  номер,  а  также  исходную  строку  и
использует  знак  вставки  (^)  для  указания места,  где произошла
ошибка.
     Тем не  менее  заметим,  что  некоторые  ошибки обнаруживаются
несколько позже в исходном тексте. Например, несоответствие типов в
операторе  присваивания  не может быть обнаружено до тех пор,  пока
все выражение после ":=" не будет вычислено.  В таких случаях ищите
ошибку слева или выше от курсора.

     1. Out of memory (не хватает памяти)

     Эта ошибка  происходит,  когда  компилятору не хватает памяти.
Есть несколько возможных решений этой проблемы:
     - если  опция  Compile/Destination  имеет значение Memory,  то
измените ее значение на Disk в интегрированной среде.
     - если  опция  Options/Compiler /Link buffer в интегрированной
среде имеет значение Memory ,  то измените  ее  значение  на  Disk.
В компиляторе  командной  строки  для  редактирования на диск нужно
использовать опцию /L.
     - если  используются  любые  утилиты,  находящиеся  в  памяти,
например SideKick и SuperKey, то их нужно удалить из памяти.
     - если  используется  Turbo.EXE,  то постарайтесь использовать
вместо Turbo.EXE TPC.EXE, эта программа использует меньше памяти.
     Если ни один вариант не помогает, то эта программа или модуль,
возможно,  просто слишком большие для компиляции в доступном объеме
памяти.  В  этом  случае  нужно  разбить  модуль на два или большее
количество меньших модулей.

     2. Identifier expected (ожидается идентификатор)

     В этой  точке  предполагался   идентификатор.   Возможно,   Вы
пытаетесь повторно объявить зарезервированное слово.

     3. Unknown identifier (неизвестный идентификатор)

     Этот идентификатор  не  объявлен  или  невидим  внутри текущей
сферы действия.

     4. Duplicate identifier (дублируемый идентификатор)

     Этот идентификатор уже был использован в текущем блоке.

     5. Syntax error (синтаксическая ошибка)

     В исходном тексте был найден неправильный символ. Возможно, Вы
забыли кавычки вокруг строковой константы.

     6. Error  in  real  constant (ошибка в константе вещественного
типа)

     Синтаксис констант вещественного  типа  определен  в  главе  1
"Лексемы и константы".

     7. Error  in integer constant (ошибка в константе целого типа)

     Синтаксис констант  целого типа определен в главе 1 "Лексемы и
константы".  Заметим,  что за целыми  числами  вещественного  типа,
лежащими   за  пределами  максимального  целого  диапазона,  должна
следовать десятичная точка и ноль; например :

            12345678912.0

     8. String constant exceeds line (строковая  константа  выходит
за пределы строки)

     Наиболее вероятно,   что   Вы  забыли  закрывающую  кавычку  в
строковой константе.

     9. Too many nested files (слишком много вложенных файлов)

     Компилятор допускает не более 15  вложенных  файлов.  Наиболее
вероятно, что в программе более 14 вложенных файлов.

     10. Unexpected end of file (неожиданный конец файла)

     Можно получить  такое  сообщение  об  ошибке  из-за  следующих
причин:
     - исходный  файл  заканчивается  перед  последним  end главной
операторной части.  Наиболее вероятно,  что  количество  операторов
begin и end несбалансировано.
     - включенный файл заканчивается в середине  операторной части.
Каждая  операторная  часть  должна  полностью  содержаться  в одном
файле.
     - не закрыт комментарий.

     11. Line too long (строка слишком длинная)

     Максимальная длина строки равна 126 символам.

     12. Type identifier expected (ожидается тип идентификатора)

     Этот идентификатор не обозначает тип, как это должно быть.

     13. Too many open files (слишком много открытых файлов)

     Если произошла  эта  ошибка,  то  или  в  файле CONFIG.SYS нет
записи FILES = xx,  или эта  запись  задает  слишком  мало  файлов.
Увеличьте это значение до некоторого подходящего значения, например
до 20.

     14. Invalid file name (неправильное имя файла)

     Неправильное имя  файла  или  задается   несуществующий   путь
доступа.

     15. File not found (файл не найден)

     Этот файл  не  может  быть  найден в текущем справочнике или в
любом из поисковых справочников,  которые применяются к этому  типу
файла.

     16. Disk full (диск полон)

     Удалите несколько файлов или используйте новый диск.

     17. Invalid   compiler   directive   (неправильная   директива
компиляции)

     Буква директивы компилятора  неизвестна,  один  из  параметров
директивы   компилятора   неизвестен  или  используется  глобальная
директива  компилятора,  когда  компиляция   тела   программы   уже
началась.

     18. Too many files (слишком много файлов)

     В компиляцию  программы  или  модуля  включено  слишком  много
файлов. Попытайтесь не  использовать  так  много  файлов,  например
посредством  объединения  включенных  файлов  или укорачивания имен
файлов.

     19. Undefined type in pointer definition (неопределенный тип в
определении указателя)

     На этот  тип ранее была ссылка в объявлении типа указателя, но
он не был объявлен.

     20. Variable  identifier  expected  (ожидается   идентификатор
переменной)

     Этот идентификатор  не  обозначает переменную,  как это должно
быть.

     21. Error in type (ошибка в типе)

     Этот символ не может начинать определение типа.

     22. Structure too large (структура слишком большая)

     Максимальный допустимый размер структурного типа  равен  65520
байтам.

     23. Set  base type out of range (базовый тип множества выходит
за допустимый диапазон)

     Базовый тип множества  должен  быть  поддиапазоном  ,  который
находится внутри диапазона 0..255,  или перечислимым типом, который
имеет не более 256 возможных значений.

     24. File components may not be files or  objects (компонентами
файла не могут быть файлы или объекты)

     В качестве файловых компонент не могут быть файлы или объекты,
а так же ни один из структурных типов, которые включают тип объекта
или файла.

     25. Invalid string length (неправильная длина строки)

     Объявленная максимальная  длина строки должна быть в диапазоне
1..255.

     26. Type mismatch (несоответствие типов)

     Это может быть по следующим причинам:

     - несовместимые  типы  переменной  и  выражения  в   операторе
присваивания
     - несовместимые типы фактического и  формального  параметра  в
вызове процедуры или функции
     - тип  выражения,  который  несовместим  с  типом  индекса   в
индексации массива
     - несовместимые типы операндов в выражении.

     27. Invalid subrange base  type  (неправильный  поддиапазонный
базовый тип)

     Все порядковые типы являются допустимыми базовыми типами.

     28. Lower  bound  greater  than  upper  bound  (нижняя граница
больше верхней границы)

     В объявлении  поддиапазонного  типа  нижняя  граница   указана
больше верхней границы.

     29. Orginal type expected (ожидается порядковый тип)

     В данном случае вещественный, строковый, структурный тип и тип
указателя недопустим.

     30. Integer constant expected (ожидается целая константа)

     31. Constant expected (ожидается константа)

     32. Integer or real constant  expected  (ожидается  целая  или
вещественная константа)

     33. Type identifier expected (ожидается тип идентификатора)

     Этот идентификатор не обозначает тип указателя, как это должно
быть.

     34. Invalid function result type (неправильный  тип результата
функции)

     Правильными типами  результатов  функций  являются все простые
типы, строковые типы и типы указателей.

     35. Label  identifier expected (ожидается идентификатор метки)

     Этот идентификатор не обозначает метку, как это должно быть.

     36. Begin expected (ожидается оператор begin)

     37. End expected (ожидается оператор end)

     38. Integer expession expected (ожидается целое выражение)

     Предыдущее выражение должно быть целого типа.

     39. Ordinal   expession    expected    (ожидается    выражение
порядкового типа)

     Предыдущее выражение должно быть порядкового типа.

     40. Boolean    expression    expected   (ожидается   выражение
булевского типа)

     41. Operand types do not match  operator  (типы  операндов  не
соответствуют оператору)

     Оператор не   может   быть   применен   к   операндам    этого
типа, например 'A' div '2'.

     42. Error in expression (ошибка в выражении)

     Этот символ  не  может  участвовать  в   выражении   указанным
способом.   Возможно, Вы  забыли   написать  оператор  между  двумя
операндами.

     43. Illegal assignment(неправильное присваивание)

     - Файлы   и   нетипированные   переменные   не   могут    быть
присваиваемыми значениями.
     - Идентификатору функции  можно  присваивать  значения  только
внутри операторной части функции.

     44. Field identifier expected (ожидается идентификатор поля)

     Этот идентификатор  не обозначает поле в предыдущей переменной
типа запись.

     45. Object file too large (объектный файл слишком большой)

     Turbo Pascal не может подредактировать  .OBJ  файлы,  размером
больше 64К.

     46. Undefined external (неопределенный внешний элемент)

     Внешняя процедура или функция не имеют соответствующего PUBLIC
определения в объектном файле.  Убедитесь,  что все объектные файлы
заданы   в   директивах   {$L  имя  файла}  и  проверьте  написание
идентификатора процедуры или функции в .ASM файле.

     47. Invalid object file record (неправильная запись объектного
файла)

     .OBJ файл  содержит неправильную объектную запись;  убедитесь,
что файл фактически является .OBJ файлом.

     48. Code Segment too large (сегмент кода слишком большой)

     Максимальный размер кода  программы  или  модуля  равен  65520
байт. Если  компилируется  программа,  то нужно перенести несколько
процедур или функций в модуль.  Если компилируется модуль,  то  его
нужно разбить на два или больше модулей.

     49. Data segment too large (сегмент данных слишком большой)

     Максимальный размер  сегмента  данных  программы  равен  65520
байт, включая  данные,  объявленные  используемыми  модулями.  Если
необходимо больше  глобальных  данных,  то нужно объявить структуры
большого размера  как  указатели  и  разместить  их  динамически  с
использованием процедуры New.

     50. Do expеcted (ожидается ключевое слово)

     51. Invalid   PUBLIC   definition   (неправильное  определение
PUBLIC)

     - Идентификатор был сделан общедоступным с  помощью  директивы
PUBLIC в   языке   ассемблер,   но  он  не  соответствует  external
объявлению в программе или в модуле на Паскале.
     - Две  или более директивы PUBLIC в ассемблере определяют один
и тот же идентификатор.
     - .OBJ файл определяет PUBLIC символы , которые не находятся в
сегменте CODE.

     52. Invalid EXTRN definition (неправильное определение  EXTRN)

     - На идентификатор была ссылка с  помощью  директивы  EXTRN  в
ассемблере,  но  он  не  был  объявлен ни в программе или модуле на
Паскале, ни в интерфейсной части используемых модулей.
     - Этот    идентификатор   обозначает   absolute   (абсолютную)
переменную.
     - Этот  идентификатор обозначает inline процедуру или функцию.

     53. Too many EXTRN definion (слишком много объявлений EXTRN)

     Turbo Pascal  не может обрабатывать .OBJ файлы с более чем 256
объявлениями EXTRN.


     54. OF expected (ожидается ключевое слово OF)

     55. INTERFACE expected (ожидается ключевое слово interface)

     56. Invalid relocatable reference  (неправильная  переместимая
ссылка)

     - .OBJ файл содержит данные и переместимые ссылки в сегментах,
отличных    от    CODE.    Например,    Вы    пытаетесь    объявить
инициализированные переменные в сегменте DATA.
     - .OBJ  файл  содержит  ссылки размером в байт на переместимые
символы . Эта ошибка происходит, если используются операторы HIGH и
LOW с перемеcтимыми символами или, если есть ссылка на переместимые
символы в директивах DB.
     - Операнд  ссылается  на  переместимый символ,  который не был
определен ни в сегменте CODE, ни в сегменте DATA.
     - Операнд   ссылается   на  процедуру  или  функцию  EXTRN  со
смещением, например, CALL SortProc +8.

     57. THEN expected (ожидается ключевое слово then)

     58. TO  or  DOWNTO  expected  (ожидается ключевое слово to или
downto)

     59. Undefined forward (не определен элемент, указанный ранее)

     - Эта  процедура  или  функция  была  объявлена в интерфейсной
части модуля,  но ее  определение  не  встречается  нигде  в  части
реализации.
     - Эта процедура или функция была объявлена с  ключевым  словом
forward, но ее определение нигде не обнаружено.

     60. Too many procedure (слишком много процедур)

     Turbo Pascal  не  допускает  более  512 процедур или функций в
модуле. Если  компилируется   программа,   то   нужно   переместить
несколько процедур или функций в модуль. Если компилируется модуль,
то его нужно разбить на два или более модулей.

     61. Invalid typecast (неправильное приведение типов)

     - Размеры ссылки на переменную и тип назначения отличаются при
приведении типа переменной.
     - Попытка приведения типов в выражении,  где допустима  только
ссылка на переменную.

     62. Division by zero (деление на ноль)

     Попытка деления на ноль.

     63. Invalid file type (неправильный тип файла)

     Этот тип  файла не поддерживается процедурой обработки файлов,
например, readln c типированным файлом или Seek c текстовым файлом.

     64. Cannot Read or Write variables of type (нельзя  читать или
писать переменные этого типа)

     - Read   или   Readln   могут   вводить  значения  типа  Char,
Integer, Real, и String.
     - Write или    Writeln    могут    выводить    значения    типа
Char, Integer, Real, String и Boolean.

     65. Pointer  variable  expected  (ожидается  переменная   типа
указатель)

     Предыдущая переменная должна иметь тип указатель.

     66. String variable expected (ожидается строковая переменая)

     Предыдущая переменная должна быть строкового типа.

     67. String  expession expected (ожидается выражение строкового
типа)

     Предыдущее выражение должно быть строкового типа.

     68. Circular unit reference (циклическая ссылка на модуль)

     Не допускается, чтобы два модуля использовали друг друга:

      unit U1;     unit U2;
      uses U2;     uses U1;
       ...           ...

     В этом примере при выполнении MAKE  для  любого  модуля  будет
генерироваться ошибка 68.

     69. Unit name mismatch (несоответствие имени модуля)

     Имя модуля,  найденного в .TPU файле , не соответствует имени,
заданному в предложении USES.

     70. Unit version mismatch (несоответствие версии модуля)

     Один или  более  модулей,  используемых  данным  модулем  были
изменены   после   компиляции   этого  модуля.  Для  автоматической
компиляции модулей,    которым    нужна    перекомпиляция,    нужно
использовать  Compile/Make  или  Compile  /Build  в интегрированной
среде или опции / М или /В в компиляторе командной строки.

     71. Duplicate unit name (дублированное имя модуля)

     В предложении USES уже указано это имя модуля.

     72. Unit file format error (ошибка в формате файла модуля )

     .TPU файл  почему-то  неправильный;  убедитесь,что  этот  файл
фактически является .TPU файлом.

     73. Implementation    expected   (ожидается   ключевое   слово
implementation)

     74. Constant and case types do  not  match  (константа  и  тип
переключателя в операторе case не соответствуют друг другу)

     Тип константы   оператора   case   несовместим   с  выражением
переключателя в предложении case.

     75. Record   variable   expected  (ожидается  переменная  типа
record)

     Предыдущая переменная должна иметь тип record.

     76. Constant  out  of  range  (константа выходит за допустимый
диапазон)

     - Попытка индексировать массив с помощью  константы, выходящей
за допустимый диапазон.
     - Попытка  присвоить  переменной   константу,   выходящую   за
допустимый диапазон.
     - Попытка  передать   константу,   выходящую   за   допустимый
диапазон, в качестве параметра процедуры или функции.

     77. File variable expected (ожидается переменная типа file)

     Предыдущая переменная должна иметь тип file.

     78. Pointer  expression  expected  (ожидается  выражение  типа
pointer).

     79. Integer or real expression expected  (ожидается  выражение
типа integer или real).

     80. Label  not  within  current  block  (метка  находится  вне
текущего блока).

     Оператор goto не может ссылаться  на  метку,  находящуюся  вне
текущего блока.

     81. Label already defined (метка уже определена)

     Эта метка уже помечает некоторый оператор.

     82. Undefined    label    in    preceding    statement    part
(неопределенная метка в предыдущей операторной части)

     Эта метка была объявлена и на нее  есть  ссылка  в  предыдущей
операторной части, но эта метка нигде не определена.

     83. Invalid @ argument (неправильный аргумент для @ )

     Правильными аргументами   являются   ссылки  на  переменные  и
идентификаторы процедур или функций.

     84. UNIT expected (ожидается ключевое слово UNIT)

     85. ";" expected (ожидается ; )

     86. ":" expected (ожидается : )

     87. "," expected (ожидается , )

     88. "(" expected (ожидается ( )

     89. ")" expected (ожидается ) )

     90. "=" expected (ожидается = )

     91. ":=" expected (ожидается := )

     92. "[" or "(." expected (ожидается [ или (. )

     93. "]" or ".)" expected (ожидается ] или .) )

     94. "." expected (ожидается . )

     95. ".." expected (ожидается .. )

     96. Too many variables (слишком много переменных)

     - Общий  размер  глобальных  переменных,  объявленных   внутри
программы или модуля, не может превышать 64К.
     - Общий  размер  локальных  переменных,   объявленных   внутри
процедуры или функции, не может превышать 64К.

     97. Invalid  FOR  control  variable  (неправильная управляющая
переменная в операторе for)

     Управляющая переменная в операторе  for  должна  быть  простой
переменной, определенной в описании текущей подпрограммы.

     98. Integer  variable  expected  (ожидается  переменная целого
типа)

     Предыдущая переменная должна быть целого типа.

     99. File and procedure types are not allowed here  (файловый и
процедурный тип недопустимы здесь)

     Типированная константа   не  может  быть  типа  файлового  или
процедурного типа.

     100. String length mismatch (длина строки не соответствует)

     Длина строковой   константы   не   соответствует    количеству
компонент в символьном массиве.

     101. Invalid  ordering  of fields (неправильное упорядочивание
полей)

     Поля констант типа  record  должны  быть  записаны  в  порядке
объявления.

     102. String   constant   expected  (ожидается  константа  типа
string)

     103. Integer or real variable expected  (ожидается  переменная
типа Integer или Real)

     Предыдущая переменная должна быть типа Integer или Real.

     104. Ordinal    variable    expected   (ожидается   переменная
порядкового типа )

     Предыдущая переменная должна быть порядкового типа .

     105. INLINE error (ошибка в INLINE)

     Оператор < не допустим в сочетании с перемещаемыми ссылками на
переменные, такие ссылки всегда имеют размер, равный слову.

     106. Character   expession   expected   (ожидается   выражение
символьного типа)

     Предыдущее выражение должно быть типа Сhar.

     107. Too many relocation  items  (слишком  много  перемещаемых
элементов)

     Размер перемещаемой  части таблицы в .EXE файле превышает 64К,
что является верхним пределом  в  Turbo  Pascal.  Если  эта  ошибка
возникает, то  это  означает,  что данная программа слишком большая
для обработки редактором связей Turbo Pascal.  Вероятно,  она будет
слишком  большой  для  выполнения  в  DOS  .  В  этом  случае нужно
разделить программу на "главную" часть,  которая выполняет две  или
более "подпрограмм", используя процедуру EXEC в модуле Dos.

     112. Case  constant  out  of  range  (константа оператора case
выходит за допустимый диапазон)

     Для операторов case целого типа константы должны  быть  внутри
диапазона -32768...32767.

     113. Error in statement (ошибка в операторе)

     С этого символа не может начинаться оператор.

     114. Cannot  call  an  interrupt  procedure  (нельзя  вызывать
процедуру прерывания)

     116. Must be in 8087 mode to compile this (для компиляции этой
конструкции должен быть режим 8087)

     Эта конструкция   может  компилироваться  только  в  состоянии
{$N+}. Операция над 8087 типами Single,  Double,  Extended  и  Comp
недопустимы в состоянии {$N-}.

     117. Target address not found (искомый адрес не найден)

     Команда Compile/Search  Find Error в интегрированной среде или
опция /F в версии командной строки не  может  определить  оператор,
который соответствует данному адресу.


     118. Include files are not  allowed  here  (здесь  недопустимы
включаемые файлы)

     Каждая операторная часть должна полностью содержаться в данном
файле.

     120. NIL expected (ожидается NIL)

     121. Invalid Qualifier (неправильный квалификатор)

     - Попытка  индексировать  переменную,  которая  отсутствует  в
массиве.
     - Попытка  задать  поля  в  переменной,  которая  не  является
записью.
     - Попытка   получить   значение,    на    которое    указывает
     переменная, не являющаяся указателем.

     122. Invalid   variable   reference  (неправильная  ссылка  на
переменную)

     Предыдущая конструкция   следует    синтаксису    ссылки    на
переменную, но не обозначает размещение памяти.  Наиболее вероятно,
Вы вызвали функцию  указателя,  но  забыли  получить  значение,  на
которое указывает результат.

     123. Too many symbols (слишком много символов)

     Программа или   модуль  объявляет  более  64К  символов.  Если
программа или модуль компилируется с опцией {$D+}, то попробуйте ее
выключить -   заметим,   однако,   что   это  будет  препятствовать
нахождению  ошибок  выполнения   в   этом   модуле.   В   противном
случае, можно   попробовать   переместить  несколько  объявлений  в
отдельный модуль.

     124. Statement  part  too  large  (операторная  часть  слишком
большая)

     Turbo Pascal  ограничивает размер операторной части около 24К.
Если встречается эта ошибка,  то  переместите  разделы  операторной
части в  одну  или более процедур.  В любом случае,  если программа
имеет операторную часть такого размера,  то имеет  смысл  прояснить
структуру этой программы.

     126. Files   must   be   var  parameters  (файлы  должны  быть
переменными параметрами)

     Попытка объявить значение параметра файлового  типа. Параметры
файлового типа должны быть переменными параметрами.

     127. Too many  conditional  symbols  (слишком  много  условных
символов)

     Для определения дополнительных условных  символов недостаточно
места.  Попытайтесь  исключить  несколько  символов  или  укоротить
несколько символических имен.

     128. Misplaced     conditional     directive      (неправильно
расположенная условная директива)

     Компилятор встретил   директиву   {$ELSE}   или  {$ENDIF}  без
соответствующей директивы {$IFDEF}, {$IFNDEF} или {$IFOPT}.

     129. ENDIF directive missing (отсутствует директива ENDIF)

     Исходный файл  заканчивается   внутри   конструкции   условной
компиляции.  В  исходном  файле  должно  быть одинаковое количество
директив {$IFxxx} и {$ENDIF}.

     130. Error in initial conditional defines (ошибка  в начальных
условных определениях)

     Начальные условные  символы,  заданные  в  Options/  Compiler/
Conditional defines или в директиве /D,  неправильные. Turbo Pascal
ожидает, что  0  или  более иденитификаторов разделяются пробелами,
запятыми или точками с запятой.

     131. Header does not match previous definition  (заголовок  не
соответствует предыдущему определению)

     - Заголовок  процедуры  или  функции,  заданный в интерфейсной
части или в объявлении forward, не соответствует данному заголовку.

     132. Critical dick error (критическая ошибка диска)

     Критическая ошибка    произошла    во     время     компиляции
(например, ошибка неготовности носителя)

     133. Cannot  evaluate  this  expression  (нельзя вычислить это
выражение)

     Попытка использовать неподдерживаемое Turbo Pascal  свойство в
константном выражении  или  в  отладочном выражении.  Например,  Вы
пытаетесь использовать функцию Sin в объявлении константы,  или  Вы
пытаетесь вызвать функцию, определенную пользователем, в отладочном
выражении.  Описание допустимого  синтаксиса  конкретных  выражений
приведено  в  главе  1 "Лексемы и константы".  Описание допустимого
синтаксиса отладочных выражений приведено  в  главе  5  Руководства
пользователя "Отладка программ на Turbo Pascal".

     134. Expession  incorrectly  terminated (выражение завершается
неправильно)

     Turbo Pascal ожидает или оператор,  или конец выражения в этой
точке, но ничего не находит.

     135. Invalid   format   specifier  (неправильный  спецификатор
формата )

     Используется неправильный спецификатор  формата  или  числовой
аргумент  спецификатора  формата  выходит  за  допустимый диапазон.
Список  правильных  спецификаторов  формата  приведен  в  главе   5
Руководства пользователя "Отладка программ на Turbo Pascal".

     136. Invalid   indirect   reference   (неправильная  косвенная
ссылка)

     Оператор пытается  сделать  неправильную   косвенную   ссылку.
Например,  используется  absolute  переменная,  у  которой  базовая
переменная неизвестна в  текущем  модуле  или  используется  inline
программа, которая  ссылается на переменную,  неизвестную в текущем
модуле.

     137. Structured variables are not  allowed  here  (структурные
переменные недопустимы здесь)

     Попытка выполнить  не поддерживаемую Turbo Pascal операцию над
структурной переменной. Например, попытка умножить две записи.

     138. Cannot evaluate without System unit (Нельзя вычислить без
модуля System)

     Библиотека TURBO.TPL   должна   содержать  модуль  System  для
того, чтобы отладчик мог вычислить выражение.

     139. Cannot access this  symbol  (невозможен  доступ  к  этому
символу)

     Все множество   символов  в  программе  доступно  сразу  после
компиляции программы.  Однако,  к  некоторым  символам,  таким  как
переменные,  невозможен  доступ  до  тех  пор,  пока  программа  не
начинает фактически выполняться.

     140.Invalid floating-point operation (Неправильная  операция с
плавающей точкой)

     Операция над  двумя  значениями  вещественного  типа привела к
переполнению или является делением на ноль.

     141. Cannot  compile  overlay  to memory (нельзя компилировать
оверлей в память)

     Программа, которая использует оверлеи,  должна компилироваться
на диск.

     142. Procedure  or  function  variable   expected   (ожидается
переменная типа procedure или function)

     В этом  контексте  оператор  адреса  (@)  может использоваться
только с переменной процедуры или функции.

     143. Invalid procedure  or  function  reference  (неправильная
ссылка на процедуру или функцию)

     - Если  процедура или функция должны быть присвоены переменной
типа procedure,  то их нужно компилировать в состоянии {$F+}  и  их
нельзя объявлять с ключевыми словами inline или interrupt.
     - Вы пытаетесь вызвать процедуру в выражении.

     144. Cannot overlay this  unit  (нельзя  сделать  этот  модуль
оверлейным)

     Попытка сделать    оверлейным    модуль,    который   не   был
откомпилирован в состоянии {$O+}.

     147 Object type expected (Ожидается объектный тип.)

         Идентификатор не является объектным типом.

     148 Local object types are not allowed.  (Локальный  объектный
тип недопустим.)

     Объектный тип  может  быть  определен  только  в самой внешней
сфере действия программы или модуля.  Определение  объектного  типа
внутри процедур или функций недопустимо.

     149 VIRTUAL expected. (VIRTUAL ожидается.)

     Пропущено ключевое слово VIRTUAL.

     150 Method    identifier   expected.   (Идентификатор   метода
ожидается.)

     Идентификатор не является методом.

     151 Virtual  constructors  are   not   allowed.   (Виртуальные
констракторы неразрешены.)

     Констрактор-метод должен быть статическим.

     152 Constructor     identifier     expected.    (Идентификатор
констрактора ожидается.)

     Идентификатор не является констрактором.

     153 Destructor identifier expected. (Идентификатор дестрактора
ожидается.)

     Идентификатор не является дестрактором.

     154 Fail  only  allowed  withing constructors.  (Fail допустим
только внутри констракторов.)

     Стандартная процедура  Fail  может  быть  использована  только
   внутри констракторов.

     155. Invalid  combination  of  opcode  and  operands (Неверная
комбинация кода операции и операндов)

     Код операции  не   допускает   такой   комбинации   операндов.
Возможные причины:

     - Слишком  много  или  слишком  мало  операндов для этого кода
операции; например

     INC AX, BX или MOV AX

     - Правильное  число  операндов,  но  их  тип  или  порядок  не
соответствуют коду операции; например

     DEC 1,  MOV AX,CL  или MOV 1,AX

     156. Memory reference expected (Ожидается ссылка на память)

     Этот операнд  не  ссылка  на память,  которая ожидается здесь.
Вероятно, Вы забыли  поставить  []  вокруг  регистрового  операнда.
Например

     MOV AX, BX+SI вместо MOV AX, [BX+SI]

     157. Cannot   add  or  subtract  relocatable  symbols  (Нельзя
складывать или вычитать переместимые символы)

     Над переместимыми символами можно выполнять только  сложение и
вычитание констант.  Переменные,  процедуры,  функции и метки - это
переместимые символы.  Считая,  что Var - это переменная, а Const -
это константа, инструкции MOV AX, Const+Const и MOV AX, Var+Const -
верны, а MOV AX, Var+Var - нет.

     158. Invalid   register   combination   (Неверная   комбинация
регистров)

     Правильные индексные регистровые комбинации: [BX], [BP], [SI],
[DI], [BX+SI],  [BX+DI],   [BP+SI],   [BP+DI].   Другие   индексные
регистровые комбинации  (такие,  как [AX],  [BP+BX],  [SI+DX]) - не
разрешены.

     Примечание: Локальные переменные  (переменные,  объявленные  в
процедурах и функциях) всегда распределяются в стеке и доступ к ним
производится через регистр BP.  Ассемблер  автоматически  добавляет
[BP] в ссылках на такие переменные.  Так, что даже хотя конструкция
такая, как Local[BX] (где Local - локальная  переменная) появляется
правильной, это  не  так,  поскольку  результирующий операнд будет:
Local[BP+BX].

     159. 286/287 Instructions are not enabled  (Инструкции 286/287
не разрешены.)

     Используйте директиву компилятора {$G+},  чтобы разрешить коды
операций 286/287,  но помните,  что  результирующий  код  не  может
выполняться на компьютерах с 8086 или 8088.

     160. Invalid symbol reference (Неверная ссылка на символ)

     К этому  символу  нельзя  обращаться  в ассемблерном операнде.
Возможные причины:
     - Вы   пытаетесь   обратиться   в   ассемблерном   операнде  к
стандартной процедуре, стандартной функции или специальным массивам
Mem, MemW, MemL, Pоrt, PortW.
     - Вы пытаетесь обратиться в ассемблерном операнде  к константе
типа строка, плававающая точка или множество.
     - Вы пытаетесь обратиться к специальному символу  @Result  вне
функции.
     - Вы пытаетесь обратиться в  ассемблерном  операнде  к  inline
процедуре или функции.
     - Вы пытаетесь сгенерировать короткую JMP  инструкцию, которая
переходит на что-либо отличное от метки.

     161. Code generation error (Ошибка генерации кода)

     Предыдущая операторная   часть  содержит  инструкцию:  LOOPNE,
LOOPE, LOOP или JCXZ, которая не может достичь метки назначения.

     162. ASM expected (Ожидается ASM)


                    Ошибки времени выполнения.


     Некоторые ошибки во  время  выполнения  программы  приводят  к
тому, что  программа  выводит  на  дисплей  сообщение  об  ошибке и
завершается:
     Run-time error  nnn  at  xxxх:yyyy  (ошибка  выполнения nnn по
адресу xxxх:yyyy,    где    nnn-номер    ошибки    выполнения,    а
xxxx:yyyy - адрес ошибки выполнения (сегмент и смещение))
     Ошибки выполнения разделены на четыре категории:

          ошибки операционной системы DOS:1-99
          ошибки ввода/вывода:100-149
          критические ошибки :150-199
          фатальные ошибки:200-255.


                 Ошибки операционной системы DOS.

     1. Invalid function number (Неверный номер функции)

     Вы вызываете несуществующую функцию DOS.

     2. File not found (файл не найден)

     Сообщается процедурами Reset,  Append,  Rename или Erase, если
имя назначенное файловой переменной не задает существующий файл.

     3. Path not fond (путь не найден)

    - Сообщается  процедурами Reset,  Rewrite,  Append,  Rename или
Erase,  если имя, назначенное файловой переменной,  неправильное или
задает несуществующий подсправочник.

     - Сообщается  процедурами  Chdir,  Mkdir или Rmdir,  если путь
доступа неправильный или задает несуществующий подсправочник.

     4. Too many open files (слишком много открытых файлов)

     Сообщается процедурами  Reset,  Rewrite   или   Append,   если
программа  имеет  слишком  много  открытых  файлов.  DOS никогда не
разрешает более 15 открытых файлов на процесс. Если встречается эта
ошибка, когда открытых файлов меньше 15,  то это может указывать на
то,  что файл CONFIG.SYS не содержит запись FILES =XX или,  что эта
запись задает  слишком  мало  файлов.  Увеличьте  это количество до
некоторого подходящего значения, например, до 20.

     5. File access denied (запрещен доступ к файлу)

     - Сообщается  процедурами  Reset  или  Append,  если  FileMode
разрешает запись,  а имя,  назначенное файловой переменной,  задает
справочник или файл, предназначенный только для считывания.
     - Сообщается процедурой Rewrite,  если справочник заполнен или
если имя,  присвоенное файловой переменной,  задает справочник  или
существующий файл, предназначенный только для считывания.
     - Сообщается процедурой Rename, если имя, присвоенное файловой
переменной,   задает   справочник   или   если   новое  имя  задает
существующий файл.
     - Сообщается процедурой Erase,  если имя, присвоенное файловой
переменной,  задает справочник или файл, предназначенный только для
считывания.
     - Сообщается  процедурой  MkDir,  если  файл  с  таким  именем
существует  в  "родительском  "справочнике,  или  если путь доступа
задает устройство, или если нет места в "родительском" справочнике.
     - Сообщается процедурой RmDir,  если справочник непустой; если
путь доступа не задает справочник,  или если  путь  доступа  задает
корневой справочник.
     - Сообщается процедурой Read или BlockRead  для  типированного
или нетипированного файла, если этот файл не открыт для чтения.
     - Сообщается процедурой Write или BlockWrite для типированного
или нетипированного файла, если этот файл не открыт для записи.

     6. Invalid file handle (неправильный обработчик файла)

     Эта ошибка  сообщается,  если  неправильный  обработчик  файла
передается   вызову   системы   DOS.   Это   никогда   не    должно
происходить; если  это  случается,  то  это  указывает,что файловая
переменная каким-то образом запорчена.

     12. Invalid file  access  code  (неправильный  код  доступа  к
файлу)

     Сообщается процедурами  Reset или Append для типированного или
нетипированного файла,если значение FileMode неправильное.

     15. Invalid drive number (неправильный номер устройства)

     Сообщается процедурой  GetDir  или   ChangeDir,   если   номер
устройства неправильный.

     16. Cannot  remove  current  directory (нельзя удалять текущий
справочник)

     17. Cannot rename across drives (нельзя переименовывать файлы,
находящиеся на различных устройствах)

     Сообщается процедурой  Rename,  если  оба  имени  находятся на
различных устройствах.


                       Ошибки ввода/вывода.

     Эти ошибки  вызывают завершение программы,  если этот оператор
был откомпилирован в состоянии {$I+}.  В состоянии {$I-}  программа
продолжает выполняться, а ошибка сообщается функцией IOResult.

     100. Disk read error (ошибка чтения с диска)

     Сообщается процедурой   Read  для  типированного  файла,  если
делается попытка чтения после конца файла.

     101. Disk write error (ошибка записи на диск)

     Сообщается процедурами Close,  Write, Writeln, Flush или Page,
если диск становится полным.

     102. File not assigned (файл не назначен)

     Сообщается процедурами  Reset,  Rewrite,  Append,  Rename  или
Erase,  если файловой переменной не было присвоено  имя  с  помощью
вызова Assign.

     103. File not open (файл не открыт)

     Сообщается процедурами  Close,  Read,  Write,  Eof,  FileSize,
Flush, BlockRead или BlockWrite, если файл не открыт.

     104. File not open for input (файл не открыт для ввода)

     Сообщается процедурами  Read,  Readln,  Eof,  Eoln,   SeekEof,
SeekEoln для текстовых файлов, если файл не открыт для ввода.

     105. File not open for output (файл не открыт для вывода)

     Сообщается процедурами  Write  и Writeln для текстовых файлов,
если файл не открыт для вывода.

     106. Invalid numeric format (неправильный числовой формат)

     Сообщается процедурами Read и Readln, если  числовое значение,
прочитанное   из  текстового  файла  не  соответствует  правильному
числовому формату.


                        Критические ошибки.

     150. Disk is write-protected (защита диска от записи)

     151. Unknown unit (неизвестное устройство)

     152. Drive not ready (устройство не готово)

     153. Unknown command (неизвестная команда)

     154. CRC  error  in  data  (ошибка  циклического  контроля  по
избыточности в данных)

     155. Bad drive reguest structure length  (неправильный  запрос
устройства о длине структуры)

     156. Disk seek error (ошибка поиска на диске)

     157. Unknown media type (неизвестный тип носителя)

     158. Sector not found (сектор не найден)

     159. Printer out of paper (на принтере нет бумаги)

     160. Device write fault (ошибка записи на устройство)

     161. Device read fault (ошибка чтения с устройства)

     162. Hardware failure (отказ аппаратного обеспечения)

     Более подробная  информация  о критических ошибках приведена в
Руководстве программиста для DOS.


                         Фатальные ошибки.

     Эти ошибки всегда сразу же завершают программу.

     200. Division by zero (деление на ноль)

     201. Ошибка   выхода   за   допустимый  диапазон.  Эта  ошибка
сообщается операторами, откомпилированными в состоянии {$R+}, когда
возникает одна из следующих ситуаций:

     - Индексное   выражение   квалификатора   массива  выходит  за
допустимый диапазон.
     - Была   сделана   попытка   присвоить   переменной  значение,
выходящее за допустимый диапазон.
     - Была  сделана  попытка  передать  процедуре  или  функции  в
качестве параметра значение, выходящее за допустимый диапазон.

     202. Stack overflow error (ошибка переполнения стека)

     Эта ошибка сообщается  при  входе  в  процедуру  или  функцию,
откомпилированную в  состоянии {$S+},  когда в стеке нет достаточно
места для размещения локальных  переменных  подпрограмм.  Увеличьте
размер стека с помощью директивы компилятора $M.

     Эта ошибка может возникать так же из-за бесконечной рекурсии.

     203. Heap overflow error (ошибка переполнения кучи)

     Эта ошибка  сообщается  процедурами  New или GetMem ,  когда в
куче нет достаточно места для размещения блока  требуемого размера.
Более  подробное  описание  монитора  кучи  приведено  в  главе  16
"Память".

     204. Invalid  pointer  operation  (неправильная   операция   с
указателем)

     Эта ошибка  сообщается  процедурами Dispose или FreeMem,  если
указатель равен nil или указывает на позицию за пределами кучи или,
если свободный список не может быть расширен из-за того, что список
свободных блоков полон,  или HeapPtr находится  слишком  близко  от
нижней границы списка свободных блоков.

     205. Floating point overflow (переполнение с плавающей точкой)

     Операция с  плавающей  точкой обрабатывает слишком большое для
Turbo Pascal или сопроцессора число.

     206. Floating point underflow (потеря значности при операции с
плавающей точкой)

     Операция с  плавающей точкой приводит к потере значности.  Эта
ошибка сообщается, если только  используется  числовой  сопроцессор
8087 с  контрольным словом,  которое не маскирует потерю значности.
По умолчанию,  потеря  значности  вызывает   возвращение   нулевого
результата.

     207. Invalid floating point operation (неправильная операция с
плавающей точкой)

     - Вещественное значение,  передаваемое  Trunc  или  Round,  не
может  быть преобразовано в целое внутри диапазона для типа LongInt
(-2147483648 до 214783647)
     - Аргумент,  передаваемый функции Sgrt, является отрицательным
числом.
     - Аргумент,   передаваемый   функции   Ln,   равен   нулю  или
отрицательный.
     - Произошло   переполнение   стека  сопроцессора  8087.  Более
подробное описание корректного программирования  при  использовании
сопроцессора 8087 приведено в главе 14 "Использование 8087"

     208. Overley   manager  not  installed  (монитор  оверлеев  не
инсталирован)

     Программа вызывает  оверлейную  процедуру  или   функцию,   но
монитор оверлеев не инсталирован.
     Наиболее вероятно, что Вы не вызвали OvrInit или вызов OvrInit
был  неудачным.  Заметим,  что  если  код инициализации находится в
любом  из  оверлейных  модулей, то  нужно  создать   дополнителный
неоверлейный  модуль,  который вызывает OvrInit и использовать этот
модуль перед любым из оверлейных модулей.  Полное описание монитора
оверлеев приведено в главе 13 "Модуль Overlay" .

     209. Overlay file read error (ошибка чтения оверлейного файла)

     Произошла ошибка   чтения,   когда  монитор  оверлеев  пытался
прочитать оверлей из оверлейного файла.

     210. Object not initialized. (Объект не инициализирован)

     Когда включена проверка диапазона,  Вы  вызываете  виртуальный
метод объекта до инициализации объекта через вызов констрактора.

     211. Call to abstract method. (Вызов абстрактного метода)

     Эта ошибка  генерируется процедурой Abstract в модуле Objects;
она указывает,  что Ваша программа пытается  выполнить  абстрактный
витруальный метод.  Когда  объектный  тип  содержить один или более
абстрактных методов,  он называется  абстрактным  объектным  типом.
Будет ошибкой  создавать  экземпляры  объектов  абстрактного типа -
абстрактные типы  существуют  только  для  того,  чтобы  Вы   могли
наследовать от них и перекрывать абстрактные методы.

     Например, метод   Compare   типа  TSortedCollection  в  модуле
Objects абстрактный,  указывает   на   то,   что   для   реализации
отсортированного набора  Вы  должны создать объектный тип,  который
наследуется от TSortedCollection и перекрывает метод Compare.

     212. Stream registration error. (Ошибка регистрации потока)

     Эта ошибка  генерируется  процедурой  RegisterType  в   модуле
Objects, указывая, что возникла одна из ошибок:

     - Запись регистрации потока не размещается в сегменте данных.

     - Поле ObjType записи регистрации потока = 0.

     - Тип уже зарегистрирован.

     - Существует другой тип с тем же значением ObjType.

     213. Collection index out of range.  (Индекс набора выходит за
пределы)

     Индекс, переданный в метод из TCollection, выходит за пределы.

     214. Collection overflow error. (Ошибка переполнения набора)

     Эта ошибка выдается TCollection при попытке  добавить элемент,
когда набор не может быть расширен.
