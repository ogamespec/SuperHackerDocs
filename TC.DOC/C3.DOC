            Синтаксические ошибки в нескольких исходных файлах
          Для демонстрации работы с ошибками в нескольких исходных  фай-
     лах  установите  пункт  Break make on в положение Fatal errors. Для
     этого войдите в меню  Project  нажатием  Alt-P  и  выберите  данный
     пункт. Из меню этого пункта выберите пункт Fatal errors.
          Теперь  введите  синтаксические  ошибки  в  файлы  MYMAIN.C  и
     MYFUNCS.C. Нажмите F9 /Make/ для "создания проекта". На экране поя-
     вится окно компилятора с сообщениями о транслируемых файлах и о ко-
     личестве ошибок и предупреждений, как общем, так и в каждом  файле.
     После  появления  сообщения  Press  any key /нажмите любую клавишу/
     нажмите пробел.
          Маркер должен в этот момент находится на первом  сообщении  об
     ошибке  или  предупреждении в окне сообщений. Если файл, к которому
     относится сообщение, находится в редакторе, в окне  редактора  поя-
     вится  яркая  полоса  на той строке, в которой компилятор обнаружил
     ошибку. Для просмотра всех сообщений, можно  воспользоваться  соот-
     ветствующими клавишами. Обратите внимание, что для каждого трансли-
     ровавшегося файла имеется сообщение "Compiling"  /трансляция/.  Эти
     сообщения  не указывают на ошибки, а служат для отделения сообщений
     одного файла от сообщений другого.
          После того, как вы перейдете  за  "границу  файла",  появление
     следующего  файла в окне редактора зависит от значения пункта Track
     messages в меню Debug. По умолчанию отслеживание сообщений произво-
     дится только в текущем файле.
          Таким  образом, при перемещении к сообщению, не относящемуся к
     файлу, загруженному в редактор, светящаяся полоса в редакторе  гас-
     нет.  Если вы выберите одно из таких сообщений, т.е. нажмете Enter,
     находясь на сообщении, файл, к которому оно относится, будет загру-
     жен  в редактор и высветится строка, содержащая ошибку. После возв-
     ращения в окно сообщений нажатием F6  /Message/,  слежение  в  этом
     файле возобновится.
          Если  в  пункте  Track messages установлено значение All files
     /все файлы/, тогда имеется возможность перехода при слежении  через
     границы  файлов. Это значит, что при перемещении от сообщения к со-
     общению Турбо-Си автоматически загружает в редактор тот файл, к ко-
     торому относится сообщение. Посмотрите сами, как это делается.
          Отслеживание  сообщений  можно  отключить,  установив в пункте
     Track messages значение off /выкл./. В этом случае вы выбираете  то
     сообщение,  с которым хотите работать, и нажимаете Enter. Тот файл,
     к которому относится это сообщение, будет загружен в редактор, мар-
     кер встанет на ту строку, к которой относится сообщение.
          Значение,  установленное  в пункте Track messages не влияет на
     работу оперативных клавиш F7 и F8 /предыдущая и  последующая  ошиб-
     ки/.  Эти  клавиши  всегда найдут предыдущую и последующую ошибку и
     загрузят соотвествующий файл, если это необходимо.
                     Сохранение и удаление сообщений
          Обычно, при начале трансляции сообщения, оставшиеся от  преды-
     дущего  запуска, удаляются из окна сообщений. Иногда бывают случаи,
     когда эти сообщения желательно сохранить до следующей трансляции.
          Рассмотрим следующий пример. Имеется проект, состоящий из нес-
     кольких  исходных файлов, прерывание создания производится по ошиб-
     кам. В этом случае в каждом файле может появиться по нескольку пре-
     дупреждений,  но  затем  в одном из них появляется ошибка и процесс
     прекращается. Вы исправляете ошибку и хотите узнать  о  результатах
 
     корректировки.  Но если теперь заново запустить трансляцию или соз-
     дание, будут потеряны все предыдущие предупреждения, на которые вы,
     может быть, хотели еще посмотреть. Что делать в таком случае? Уста-
     новить пункт Keep messages меню Debug в положение on/вкл./.
          При  таком положении сообщения не удаляются перед началом соз-
     дания программы. Удаляются только те сообщения, которые относятся к
     перекомпилируемому файлу, т.е. старые сообщения, относящиеся к это-
     му файлу, заменяются на новые, если они будут.
          После обработки всех сообщений их можно удалить, выбрав в меню
     Debug пункт Clear messages /удалить сообщения/. Все текущие сообще-
     ния будут удалены. Тот же результат будет получен после  установле-
     ния  пункта Keep messages в положение off и запуска файла на транс-
     ляцию.
          При смене проекта имеет смысл удалить  все  старые  сообщения.
     Для этого в меню Project имеется соответствующий пункт очистки про-
     екта - Clear project, который удаляет как имя проекта,  так  и  все
     текущие сообщения. После выбора этого пункта можно определять новый
     проект или же транслировать и запускать отдельные программы, загру-
     жая  их  в  редактор или определяя в пункте задания имени исходного
     файла - Primary C file name.
               Использование возможностей создания проекта
          До сих пор при создании проекта мы имели дело с самой простей-
     шей возможностью - использованием списка первичных исходных файлов.
     Создание проектов предоставляет на самом деле гораздо  больше  воз-
     можностей.  Вначале несколько слов о том, что происходит при созда-
     нии программы, или как работает создание проектов.
          При создании программы сравнивается  дата  создания  исходного
     файла  и дата создания компилятором объектного файла. Это сравнение
     порождает список косвенных зависимостей в проекте. В  упоминавшемся
     выше  примере  с  использованием файла MYPROG.PRJ имеются следующие
     зависимости:
          MYMAIN.OBJ зависит от MYMAIN.C
          MYFUNCS.OBJ зависит от MYFUNCS.C
          MYPROG.EXE зависит от MYMAIN.OJB, MYFUNCS.OJB и MYPROG.PRJ
          Это значит, что объектный файл MYMAIN.OBJ  считается  устарев-
     шим,  если  файл  MYMAIN.C  создан позднее, чем MYMAIN.OBJ, поэтому
     файл MYMAIN.C будет перетранслирован. Обратите внимание на то,  что
     исполняемый  файл всегда зависит от всех объектных файлов в проекте
     и от самого файла проекта. Это значит, что если один  из  объектных
     файллов   или   сам   файл  проекта  MYPROG.PRJ  старше,  чем  файл
     MYPROG.EXE, тогда при выполнении функции Make,  т.е.  при  создании
     программы,  произойдет  перекомпоновка  объектных  модулей. Все эти
     косвенные зависимости возникают на основе одного только списка  ис-
     ходных файлов в вашем проекте.
                            Явные зависимости
          Более крупные проекты требуют и более сложного сервиса, позво-
     ляющего задавать явные зависимости. Это полезно,  когда  конкретный
     файл  с  исходным  текстом зависит от нескольких других файлов. Для
     исходных текстов программ на языке Си  обычным  является  включение
     нескольких файлов заголовков /с расширением .Н/, которые определяют
     интерфейс с внешними процедурами. При изменении интерфейса  придет-
     ся, скорее всего, перетранслировать файл, использующий эти процеду-
     ры. Это делается при помощи явных зависимостей.
 
          Предположим, например, что имеется главная программа, называю-
     щаяся MYMAIN.C, включающая в себя файл заголовка MYFUNCS.H.  Проце-
     дура  Make перетранслирует файлы MYMAIN.C и MYFUNCS.C при изменении
     файла MYFUNCS.H, если вы укажете в файле проекта следующие  зависи-
     мости:
         MYMAIN.C    (MYFUNCS.H)
         MYFUNCS     (MYFUNCS.H)
          Обратите  внимание,  этот файл проекта ставит файл MYFUNCS.С в
     зависимость от файла MYFUNCS.H. Это может послужить хорошей провер-
     кой на логичность ваших файлов. Итак, теперь у нас есть те же самые
     косвенные зависимости, а также некоторые явные:
          MYMAIN.OBJ    зависит от MYMAIN.C и MYFUNCS.H
          MYFUNCS.OBJ   зависит от MYFUNCS.С и MYFUNCS.H
          MYPROG.EXE    зависит от MYMAIN.OBJ, MYFUNCS.OBJ и MYPROG.PRJ
          Для любого исходного файла можно задать любое количество явных
     зависимостей. Для этого укажите в круглых скобках, разделяя запяты-
     ми, пробелами или точками с запятой, имена файлов, от которых  дол-
     жен  зависеть файл с исходным текстом. Например, если файл MYMAIN.C
     должен зависеть от файлов MYFUNCS.H, YOURS.H и OTHER.H  напечатайте
     такую строку:
          MYMAIN.C   (MYFUNCS.H,YOURS.H,OTHER.H)
          Выше были изложены основные сведения о зависимсотях. Пользуясь
     ими можно без особых сложностей применять приемы создания программ.
                       Дополнительные возможности
          Мы перечислили еще не все возможности функции Make. Во-первых,
     можно указывать внешние объектные и библиотечные файлы, которые бу-
     дут скомпонованы с вашим проектом; во-вторых, можно изменять  стан-
     дартные загрузочные модули и библиотеки.
                 Внешние объектные и библиотечные файлы
          Время  от  времени  может  возникать  необходимость работать с
     программами, написанными на других языках - например на ассемблере,
     или для другого транслятора с Си. Или же вы можете захотеть исполь-
     зовать нестандартный библиотечный файл  для  обеспечения  некоторых
     функций,  отсутствующей в стандартной библиотеке. В таком случае вы
     можете включить имя этого объектного или библиотечного файла в про-
     ект, указав явно его расширение. Например так /порядок перечисления
     не имеет значения/:
          MYMAIN   (MYFUNCS.H)
          MYFUNCS  (MYFUNCS.H)
          SPECIAL.OBJ
          OTHER.LIB
          Когда процедура создания проектов видит файл с явно  указанным
     расширением  .OBJ,  она  просто включает этот файл в список файлов,
     которые необходимо скомпоновать. Попыток  оттранслировать  его  или
     найти исходный текст не происходит. Точно так же, имя с расширением
     .LIB, встретившееся в файле проекта, помещается в список библиотек,
     которые  просматривает  компоновщик  при разрешении внешних ссылок.
     Попытки оттранслировать файл также не предпринимаются.
          Эти файлы не могут иметь при себе  список  явных  зависимостей
     /если  таковой будет, он просто проигнорируется/, но они вполне мо-
     гут включаться в списки зависимости любого исходного файла, если он
     от них должен зависеть. Например:
          MYMAIN     (MYFUNCS.H,SPECIAL.OBJ)
          MYFUNCS    (MYFUNCS.H,OTHER.LIB)
          SPECIAL.OBJ
          OTHER.LIB
 
          Это  значит, что если файлы .OBJ или .LIB по каким-либо причи-
     нам изменятся, файл с расширением .С будет перетранслирован.
                        Замена стандартных файлов
          В некоторых случаях  бывает  необходимо  заменить  стандартные
     файлы загрузчика или библиотеки. Обычно этим занимаются люди, съев-
     шие собаку в программировании, среди начинающих замена библиотек не
     очень  распространена.  Если  же  вам это когда-нибудь понадобится,
     прочтите нижеизложенное.
          Для замены файла загрузчика необходимо первым именем  в  файлу
     проекта  указать  имя  файла  С0*.OBJ, где звездочка заменяет любое
     имя, соответствующее принятым в DOS'е  /например  C0MINE.OBJ/.  Это
     имя  обязательно  должно  начинаться с С0, стоять на первом месте в
     проекте и иметь расширение .OBJ, явно указанное.
          Для замены стандартной бибилиотеки необходимо поместить ее имя
     на  любом  месте вашего проекта. Имя библиотеки должно начинаться с
     символа "С", иметь длину ровно 2 символа и иметь  расширение  .LIB,
     которое должно быть указано. Например CX.LIB или CI.LIB.
          При  замене стандартной библиотеки компоновщик не обращается к
     математическим библиотекам, указанным в пункте Floating point  меню
     O/C/Code  generation.  Если эти библиотеки будут использоваться при
     замене стандартной библиотеки, их необходимо включить явно в список
     файла проекта.
               Трансляция и компоновка из командной строки
          Команды  могут  обрабатываться не только при помощи интегриро-
     ванного окружения, но и при помощи обычного интерфейса типа команд-
     ной  строки. Хотя интегрированное окружение более приспособлено для
     отладки и запуска программ, бывают  ситуации,  особенно  в  сложных
     программах,  когда  использование командной строки является единст-
     венным способом выполнения какой-нибудь  замысловатой  задачи.  Так
     например,  если в программе вставлены строки на ассемблере, необхо-
     димо использовать версию, работающую с командной строкой,  т.е.ТСС,
     а не интегрированное окружение ТС.
          Программа ТСС транслирует и компонует файлы, создавая выполня-
     емый файл. Она работает аналогично команде СС в операционной систе-
     ме  Unix.  Для  ассемблирования исходных файлов (.ASM) TCC вызывает
     макроассемблер MASM. Если необходимо только  оттранслировать  файл,
     используется ключ - с командной строки.
                          Командная строка ТСС
          Для  вызова Турбо-Си из командной строки напечатайте tcc в от-
     вет на подсказку Dos'а, а затем набор необходимых аргументов. Аргу-
     менты  командной  строки  - это ключи компилятора и компоновщика, а
     также имена файлов. Общий вид командной строки:
          tcc [ключ   ключ   ключ] ... имя_файла имя_файла ...
           Ключи компилятора и компоновщика в командной строке
          Перед каждым ключом ставится тире (-) и он отделяется  от  ко-
     манды  tcc, другого ключа и последующих имен файлов по крайней мере
     одним пробелом. Отменить действие ключа явным образом можно, указав
     его в командной строке с последующим тире. Например, -К- явно отме-
     няет тип unsigned char. Ключи командной строки Турбо-Си  описаны  в
     Приложении 1.
                     Имена файлов в командной строке
          После всех ключей компилятора и компоновщика в командной стро-
     ке указываются имена файлов.
 
          Трансляция файлов осуществляется в соответствии со  следующими
     правилами:
          filename      транслируется filename.c
          filename.c    транслируется filename.c
          filename.xyz  транслируется filename.xyz
          filename.obj  включается в виде объектного при компоновке
          filename.lib  включается как библиотечный при компоновке
          filename.asm  вызывается MASM для получения объектного
          Затем компилятором вызывается компоновщик, которому передаются
     имена соответствующего файла загрузчика и стандартных библиотек.
                            Исполняемый файл
          Обычно имя исполняемого файла образуется компилятором на осно-
     ве  имени  первого исходного или объектного файла, указанного в ко-
     мандной строке. Исполняемому файлу присваивается это первое  имя  с
     расширением .ЕХЕ.
          Для  указания  другого  имени используется ключ -е. Этот ключ,
     непосредственно за которым следует  требуемое  имя  /пробелы  между
     ключом и именем не допускаются/ указывается после команды tcc и пе-
     ред любыми именами, имеющимися в командной строке.
                         Примеры командных строк
          В  следующем примере показан вызов Турбо-Си из командной стро-
     ки:
          tcc-IB:\include -LB:\lib -etest start.c body.obj end
          В данном примере команда tcc вызывает  Турбо-Си  из  командной
     строки  DOS'а.  Затем  Турбо-Си  интерпретирует параметры командной
     строки следующим образом:
          -  директорией  включаемых   файлов   объявляется   директория
     B:\INCLUDE/-IB:\include/;
          - библиотеки находятся в директории B:\LIB/-LB:\lib/;
          -    полученная    программа    будет   находиться   в   файле
     TEST.EXE/-etest/
          Турбо-Си интерпретирует список  имен,  считая,  что  программа
     состоит из следующих файлов:
          - исходный файл START.C, который должен транслироваться;
          - объектный файл BODY.OBJ будет включен во время компоновки;
          - еще один исходный файл END.C, который должен транслироваться
          Ниже приведен еще один пример командной строки Турбо-Си:
          tcc -IB:\include -LB:\lib2 -mm -C-K s1 s2.c z.asm mylib.lib
          В результате обработки этой командной строки Турбо-Си будет:
          -  искать   включаемые   файлы   в   директории   В:\INCLUDE
             (-IB:\include)
          - искать библиотеки в директории B:\LIB2/-LB:\lib2/;
          - использовать среднюю /Medium/ модель памяти /-mm/;
          - использовать вложенные комментарии /-с/;
          - использовать беззнаковый тип char /-K/
          Список имен будет интерпретироваться следующим образом:
          - транслироваться будут исходные файлы SI.C и S2.C;
          - файл Z.ASM будет ассемблироваться с использованием  макроас-
            семблера MASM;
          - исполняемый файл будет назван SI.EXE;
          - во время компоновки будет подключена библиотека MYLIB.LIB
 
                             Файл TURBOC.CFG
          Кроме  параметров,  указанных в командной строке, можно указы-
     вать параметры в файле конфигурации, называемом TURBOC.CFG. В  этом
     файле параметры указываются в том виде, в каком они будут введены в
     командную строку.
          Файл ТURBOC.CFG создается любым текстовым редактором или текс-
     товым  процессором  /например редактором интегрированного окружения
     Турбо-Си/. Параметры, разделенные пробелами, могут  указываться  на
     одной  или  нескольких  строках. При комппиляции программы Турбо-Си
     использует параметры, указанные в этом файле, как если бы они  были
     введены  в командной строке, в дополнение к тем, которые в ней име-
     ются.
          При загрузке ТСС он ищет файл TURBOC.CFG в текущей директории.
     Если его там нет и если вы работаете в DOS версии 3.0 и выше, тогда
     поиск  продолжается  в  стартовой директории, т.е. в той, в которой
     находится ТСС.ЕХЕ. Обратите внимание на то, что этот файл отличает-
     ся  от  файла  TCCONFIG.TC, который является файлом конфигурации по
     умолчанию для интегрированного окружения.
          Параметры указанные в командной строке выше по приоритету  тех
     же  самых  параметров, указанных в файле конфигурации, что является
     немаловажным свойством. Если, например, ваш файл  конфигурации  со-
     держит несколько параметров, среди которых находится ключ -а, кото-
     рый вы хотите отменить, достаточно указать в командной строке  ключ
     -а- и использовать тот же самый файл конфигурации.
          Поясним  механизм  объединенной обработки параметров командной
     строки и файла конфигурации. Список параметров  файла  конфигурации
     разбивается  логически на две части: ключи -I и все остальные пара-
     метры. Ключи -I добавляются к командной строке справа,  а  все  ос-
     тальные параметры файла конфигурации вставляются сразу после коман-
     ды tcc, т.е. слева.
          Параметры командной строки определяются слева  направо,  любое
     повторение  параметра  справа приоритетнее того же параметра слева.
     Присоединение ключей -I из файла конфигурации  к  командной  строке
     справа приводит к тому, что директории включаемых файлов, указанные
     в командной строке, просматриваются первыми, что дает им  необходи-
     мый приоритет.
                        Служебная программа МАКЕ
          АВтономная  программа МАКЕ представляет из себя процедуру соз-
     дания проектов, обладающую большими  возможностями.  Она  позволяет
     описывать  зависимости  исходных  и  объектных  файлов и аналогична
     программе МАКЕ, используемой в операционной системе Unix. Программа
     МАКЕ  оценивает  указанные  зависимости  и определяет, правильно ли
     скомпилированы и скомпонованы файлы.
          Каковы преимущества использования программы МАКЕ? Так же как и
     при создании проектов, нет необходимости следить за изменением ком-
     понентов  программы после того, как их последний раз оттранслирова-
     ли. Автономная прграмма МАКЕ обладает большими  возможностями,  чем
     процедура  создания проектов, т.к. она представляет из себя инстру-
     мент создания программ общего назначения. Перед компоновкой объект-
     ных  файлов  вашей сложной программы МАКЕ перетранслирует те файлы,
     которые необходимо обновить. Затем новые файлы будут  объединены  с
     теми, которые транслировать нет необходимости и будет получен новый
     файл исполняемой программы.
          Более подробная информация о программе МАКЕ приведена в Прило-
     жении 4 "Справочного руководства".
 
          
           Запуск программ Турбо-Си из командной строки DOS'а.
          
          Для запуска выполняемого файла программы Турбо-Си из командной
     строки DOS'а просто напечатайте в строке  DOS  ее  имя.  Расширение
     .ЕХЕ  можно  не  указывать.  Например,  для  выполнения  программы
     TEST.EXE напечатайте в строке DOS имя test и нажмите  Enter.  После
     этого програма TEST начнет выполняться.
                               Заключение
          Теперь, после того как вы познакомились с процессами трансля-
     ции, компоновки, запуска и создания программ как в  интегрированном
     окружении, так и при помощи стандартной командной строки, вы можете
     считать себя готовым к работе с Турбо-Си. По мере расширения  ваших
     знаний о языке и трансляторе вам понадобится второй том данного ру-
     ководства "Справочное руководство", в  котором  приведено  описание
     иссполняющей системы, библиотечных файлов, сложной техники програм-
     мирования и реализации языка Си в системе Турбо-Си.
          Если вы знакомы с Турбо-Паскалем или Турбо-Прологом, вам могут
     показаться интересными главы 6 и 7 соответствено, в которых расска-
     зано, как исспользовать эти языки совместно с Турбо-Си.
          
     
