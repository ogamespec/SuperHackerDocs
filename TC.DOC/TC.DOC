 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                   Математическое обеспечение
                        персональных ЭВМ
 
 
 
 
 
                             TURBO-C
 
 
 
                      Описание компилятора
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                           Москва 1988
 
 
 
 
 
 
 
                              - 2 -
 
 
 
 
 
 
 
 
                            Аннотация
 
 
 
 
      В данном документе приведено краткое описание вызова  ком-
 пилятора Turbo-C и его возможностей. Приведено краткое описание
 библиотеки компилятора. Документ является переработкой "Turbo-C
 User's Manual". Авторы:  Кашкарова  В.А.,  Артамоненкова  Н.Н.,
 Стариков Ю.А. (ГВМЦ СИ).
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                              - 3 -
 
 
 
 
 
 
 
 
                           Содержание
 
 
    Аннотация................................................. 2
 
 1. ОПЦИИ КОМАНДНОЙ СТРОКИ.................................... 5
 
 1.1.  СИНТАКСИС.............................................. 5
 1.2.  ОПЦИИ МОДЕЛЕЙ ПАМЯТИ................................... 6
 1.3.  ОПРЕДЕЛЕНИЯ............................................ 7
 1.4.  ОПЦИИ ПРОЦЕССОРА....................................... 7
 1.5.  ИСХОДНЫЕ ОПЦИИ......................................... 8
 1.6.  ОПЦИИ КОДА............................................. 9
 1.7.  ОПЦИИ ОБРАБОТКИ ОШИБОК.................................11
 1.8.  ОПЦИИ ИМЕН.............................................13
 1.9.  ОПЦИИ УПРАВЛЕНИЯ КОМПИЛЯЦИЕЙ...........................14
 1.10. ОПЦИИ РЕДАКТОРА СВЯЗЕЙ.................................15
 1.11. ОПЦИИ ОКРУЖЕНИЯ........................................15
 
 2. УТИЛИТЫ TURBO-С...........................................16
 
 2.1.  ПРЕПРОЦЕССОР Turbo-C...................................16
 2.2.  УТИЛИТА MAKE...........................................16
 2.2.1. КОМАНДНЫЕ СПИСКИ......................................16
 2.2.2. МАКРООПРЕДЕЛЕНИЯ......................................17
 2.2.2.1. ОПРЕДЕЛЕНИЕ МАКРОСОВ................................18
 2.2.2.2. ИСПОЛЬЗОВАНИЕ МАКРОСОВ..............................18
 2.2.2.3. ОСОБЫЕ СЛУЧАИ.......................................18
 2.2.2.4. ПРЕДОПРЕДЕЛЕННЫЕ МАКРОСЫ............................19
 2.2.2.5. ДИРЕКТИВЫ...........................................20
 2.2.3. ВЫЗОВ MAKE............................................23
 2.2.3.1. СИНТАКСИС КОМАНДНОЙ СТРОКИ..........................23
 2.2.3.2. ФАЙЛ BULTINS.MAK....................................23
 2.2.3.3. ОПЦИИ КОМАНДНОЙ СТРОКИ..............................23
 2.3.  РЕДАКТОР СВЯЗЕЙ Turbo-C................................24
 2.3.1. ИНИЦИАЛИЗАЦИОННЫЕ МОДУЛИ..............................24
 2.3.2. БИБЛИОТЕКИ............................................25
 2.3.3. ИСПОЛЬЗОВАНИЕ TLINK с TCC.............................25
 2.3.4. ОПЦИИ РЕДАКТОРА СВЯЗЕЙ................................25
 2.3.5. ОГРАНИЧЕНИЯ...........................................26
 
 3. ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ Turbo-C............................28
 
 3.1.  ABSREAD................................................28
 3.2.  ABSWRITE...............................................29
 3.3.  ALLOCMEM...............................................29
 3.4.  ATEXIT.................................................31
 3.5.  ATOF...................................................32
 3.6.  BIOSCOM................................................33
 3.7.  BIOSDISK...............................................35
 
                              - 4 -
 
 
 
 
 3.8.  BIOSEQUIP..............................................37
 3.9.  BIOSKEY................................................38
 3.10. BIOSMEMORY.............................................39
 3.11. BIOSPRINT..............................................39
 3.12. BIOSTIME...............................................40
 3.13. BRK....................................................40
 3.14. COUNTRY................................................40
 3.15. CTRLBRK................................................42
 3.16. DISABLE................................................43
 3.17. DOSTOUNIX..............................................44
 3.18. FARMALLOC..............................................44
 3.19. FINDFIRST..............................................45
 3.20. FNMERGE................................................47
 3.21. GETCBRK................................................50
 3.22. GETCURDIR..............................................50
 3.23. GETCWD.................................................50
 3.24. GETDATE................................................51
 3.25. GETDFREE...............................................51
 3.26. GETDISK................................................52
 3.27. GETDTA.................................................52
 3.28. GETFAT.................................................52
 3.29. GETFTIME...............................................53
 3.30. GETPASS................................................53
 3.31. GETPSP.................................................54
 3.32. GETVECT................................................54
 3.33. GETVERIFY..............................................55
 3.34. HARDERR................................................55
 3.35. INPORT.................................................57
 3.36. INTR...................................................57
 3.37. IOCTL..................................................57
 3.38. ISATTY.................................................58
 3.39. KEEP...................................................58
 3.40. LOCK...................................................59
 3.41. MOVMEM.................................................59
 3.42. PARSFNM................................................59
 3.43. PEEK...................................................60
 3.44. POKE...................................................60
 3.45. POLY...................................................60
 3.46. RANDBRD................................................61
 3.47. SEARCHPATH.............................................61
 3.48. SETCBRK................................................62
 3.49. SLEEP..................................................62
 3.50. SSIGNAL................................................62
 
 Приложение. ОБЩИЕ СТАНДАРТНЫЕ ФУНКЦИИ MSC и Turbo-C..........63
 
 
 
 
 
 
 
 
 
 
                              - 5 -
 
 
 
 
                    1. ОПЦИИ КОМАНДНОЙ СТРОКИ
 
 
 
 
 
      Данный раздел содержит опции командной строки  для  вызова
 компилятора Turbo-C. Все опиции компилятора можно разделить  на
 три следующих типа:
 
      - опции компилятора;
 
      - опции редактора связей;
 
      - опции окружения.
 
      Опции компилятора подразделяются:
 
      - опции моделей памяти;
 
      - определения (опции макро определений);
 
      - опции процессора;
 
      - опции исходного кода;
 
      - опции сообщений об ошибках;
 
      - имена (имена сегментов).
 
      Большинство опций командной строки имеют  аналоги  в  Меню
 Опций в системе Turbo-C (или в некоторых других меню).
 
      В командной строке каждой опции должен предшествовать сим-
 вол (-). Например, -I. Для того, чтобы отменить опцию  добавьте
 еще один (-) после опции. Например, -A включает опцию  ключевых
 слов ANSI, а -A- отменяет данную опцию.
 
 
      1.1. СИНТАКСИС
 
 
      При вызове компилятора Turbo-C вы можете использовать  ко-
 мандную строку, которая имеет следующий синтаксис:
 
         tcc [опции... ]  имена_файлов
 
      Компилятор обрабатывает файлы в соответствии с приведенны-
 ми ниже правилами.
 
 
          filename.asm:  вызывается  MASM  при   ассемблировании
        (получении объектного файла).
 
 
                              - 6 -
 
 
 
 
 
        filename.obj: подключается объектный файл при работе ре-
        дактора связей.
 
 
        filename.lib: подключается библиотека при работе  редак-
        тора связей.
 
 
        filename: компилируется filename.c
 
 
        filename.c: компилируется filename.c
 
 
        filename.xyz: компилируется filename.xyz.
 
      Например, командная строка
 
 tcc -a -f -C -O -Z -emyexe oldfile1.c oldfile2.c nextfile.c
 
 задает компиляцию файлов OLDFILE1.C, OLDFILE2.C,  NEXTFILE.C  в
 файл .OBJ, помещая выполняемую программу в файл MYEXE.EXE; (-a)
 задает выравнивание слова, (-f) - эмуляцию плавающей точки,  (-
 C) указывает на вложенные комментарии, (-O) - оптимизация пере-
 ходов, (-Z) - регистровая оптимизация.
 
      TCC будет подключать MASM, если вы укажите файл с расшире-
 нием  .ASM  в  командной  строке  или  если  файл  .C  содержит
 встроенный ассемблер. Для подключения макроассемблера в команд-
 ной строке нужно указать следующие флаги:
 
         /ms /D_mdl_,
 
 где mld должно принимать одно из значений: TINY, SMALL, MEDIUM,
 COMPACT, LARGE или HUGE. Флаг /mx указывает MASM  на  необходи-
 мость ассемблирования с учетом регистров.
 
 
      1.2. ОПЦИИ МОДЕЛЕЙ ПАМЯТИ
 
 
 -mc
        при компиляции используется модель памяти COMPACT.
 
 -mh
        используется модель памяти HUGE.
 
 -ml
        используется модель памяти LARGE.
 
 
 
 
 
                              - 7 -
 
 
 
 
 -mm
        используется модель памяти MEDIUM.
 
 -ms
        используется модель памяти SMALL (по умолчанию).
 
 -mt
        используется модель памяти TINY  (крошечная).  Создается
        почти такой же код как и в предыдущем случае, но  всегда
        используется C0T.OBJ при работе редактора связей.
 
 
      1.3. ОПРЕДЕЛЕНИЯ
 
 
 -Dxxx
        Определяет идентификатор xxx  как  строку  состоящую  из
        единственного пробела ( ).
 
 -Dxxx=string
        Определяет идентификатор xxx как строку  string.  String
        не может содержать пробелы и табуляции.
 
 -Uxxx
        Отменяет установленные  определения  для  идентификатора
        xxx.
 
 
      1.4. ОПЦИИ ПРОЦЕССОРА
 
 
 -1
        генерация расширенных команд процессора 80186. Эта опция
        также используется при  генерации  программ  процессором
        80286 в незащищенном режиме, например, IBM PC/AT  c  MS-
        DOS 3.0.
 
 -a
        приводит к выравниванию целых данных по границе машинно-
        го слова. Крайние биты будут включаться в структуру, для
        того чтобы обеспечить выравнивание  полей.  Выравнивание
        автоматических и глобальных переменных  будет  проходить
        успешно, переменные типа char и unsigned char могут быть
        помещены по любым адресам; все остальные -  должны  быть
        помещены по четным адресам.
 
 -f87
        генерация операций плавающей  точки,  используя  команды
        встроенного сопроцессора 8087, а не библиотеку эмулятора
        8087.
 
 
 
 
 
                              - 8 -
 
 
 
 
 -f
        во время выполнения вызывается эмулятор 8087,  если  ис-
        полняющая система не имеет  сопроцессора  8087,  который
        вызывается по умолчанию для выполнения вычислений с пла-
        вающей точкой.
 
 -fуказывает
        редактору связей, что программа не содержит вычислений с
        плавающей точкой. Библиотеки плавающей точки не  подклю-
        чаются.
 
 
      1.5. ИСХОДНЫЕ ОПЦИИ
 
 
 -A
        создается ANSI-совместимый  код:  любое  ключевое  слово
        расширения Turbo-C игнорируется и может быть использова-
        но как идентификатор. К ключевым словам расширения отно-
        сятся:
 
         near    far             huge            cdecl
         asm     pascal          interrupt
         _es     _ds             _cs             _ss
 
 
        и регистровые псевдо-переменные, такие как _AX, _BX, _SI
        и др.
 
 -C
        допускает вложенные комментарии.
 
 -i#
        Компилятор распознает только первые # символов идентифи-
        каторов. Все идентификаторы, независимо от того являются
        ли они переменными, именами макроопределений  препроцес-
        сора или именами структур, рассматриваются как различаю-
        щиеся, если их первые # символов различны.
 
 
        По умолчанию Turbo-C использует 32-символьные  идентифи-
        каторы. Другие системы, включая UNIX, используют  8-сим-
        вольные идентификаторы, остальные символы  игнорируются.
        Данный флаг позволяет избежать конфликтных ситуаций  при
        использовании идентификаторов.
 
 -K
        компилятор рассматривает все описания типа char, как тип
        unsigned char. Это допускается для совместимости с  дру-
        гими к   компиляторами,   которые   считают   тип   char
        беззнаковым.
 
 
 
 
                              - 9 -
 
 
 
 
      1.6. ОПЦИИ КОДА
 
 
 -d
        сливаются совпадающие строки; это обеспечивает  уменьше-
        ние размера программ (по умолчанию).
 
 -G
        Компилятор создает большие модули, если возможно.
 
 -N
        генерация логики переполнения стека на вход каждой функ-
        ции: это будет вызывать сообщение о переполнении  стека,
        каждый раз когда переполнение стека обнаружено. Если пе-
        реполнение   обнаружено,  печатается  сообщение   "Stack
        overflow!" и программа завершается с кодом 1.
 
 -y
        включает номера строк в объектный файл для использования
        отладчика. Это приводит к увеличению размера  объектного
        файла, но не влияет на размер или  скорость  выполняемой
        программы.
 
 -O
        оптимизация размера кода за счет  исключения  избыточных
        переходов, реорганизации циклов и переключения  операто-
        ров.
 
 -p
        Компилятор порождает все вызовы подпрограмм  и  функций,
        используя Паскалевскую последовательность передачи пара-
        метров. Функции должны получать верное число и тип аргу-
        ментов, в отличии от вызова стандартного С, который  до-
        пускает переменное число аргументов функции.  Вы  можете
        использовать оператор cdecl,  для  того  чтобы  отменить
        данную опцию и специально объявить функцию C-типа.
 
 -rподавляет
        использование регистровых переменных. При наличии данной
        опции все ключевые слова register игнорируются. Если  вы
        имеете ассемблерный код, в котором не сохранены значения
        регистров SI и DI, опция -r-  позволяет  вызвать  данный
        код из Turbo-C. Подавление регистровых переменных, в об-
        щем случае, снижает эффективность кода, но может  потре-
        боваться, если вы хотите использовать существующие подп-
        рограммы.
 
 П_р_и_м_е_ч_а_н_и_е. Когда вы используете опцию  -r-,  исходный
 файл, откомпилированный с опцией -r-, может вызывать коды,  ко-
 торые являются результатом компиляции без опции -r-,  например,
 модули системных  библиотек.  Однако,  обратное  неверно,  т.е.
 файл, откомпилированный с -r-, может быть вызван только из фай-
 ла, также откомпилированного с -r-.
 
 
                             - 10 -
 
 
 
 
 -r
        допускает использование регистровых переменных (по умол-
        чанию).
 
 -Y
        порождает стандартную запись  активации  стека,  которая
        используется отладчиком для трассировки стека  вызванных
        функций.
 
 -Z
        подавляет избыточные операции загрузки, используя  ранее
        сохраненное содержимое регистров и повторное использова-
        ние их насколько возможно часто.
 
 П_р_и_м_е_ч_а_н_и_е. Необходимо соблюдать осторожность при  ис-
 пользовании данной опции, т.к. компилятор может  не  обнаружить
 ситуации,    когда   значение   регистра   косвенно   запорчено
 указателем.
 
      Например, если переменная A загружена в  регистр  DX,  она
 сохраняется. Если переменной A присваивается значение, значение
 DX обновляется, что указывает на то, что его содержимое не  яв-
 ляется более текущим.  Если  значение  A  обновляется  косвенно
 (используя указатель), Turbo-C не будет отлавливать данной  си-
 туации и будет продолжать "помнить", что DX  содержит  значение
 A.
 
      Оптимизация -Z предназначена для подавления  загрузки  ре-
 гистров, когда значение, которое загружается, уже содержится  в
 регистре. Это позволяет исключить все команды, и также преобра-
 зовать команды из ссылок в ячейки памяти, для  того  чтобы  ис-
 пользовать регистры.
 
      Следующая искусственная последовательность команд  иллюст-
 рирует преимущества и недостатки оптимизации:
 
 C-код                           Оптимизированный
                                 ассемблер
 
 funk()
 {
         int A, *P, B;
         A=4;                    mov A,4
         ...
         B=A;                    mov ax,A
                                 mov B,ax
         P=&A;                   lea bx,A
                                 mov P,bx
         *P=B+5;                 mov dx,ax
                                 add dx,5
                                 mov [bx],dx
         printf("%d\n",A);       push ax
 }
 
 
                             - 11 -
 
 
 
 
 
      Рассмотрим команду *P=B+5. Во-первых, для  генерации  кода
 используется перемещение ax в dx. Без -Z опимизации перемещение
 будет осуществляться из B. Во-вторых, *P указывает, что  P  уже
 содержится в bx, поэтому перемещение из P в  bx  после  команды
 add должно быть исключено. Это усовершенствование  безобидно  и
 обычно используется.
 
       Однако,  обращение  к  printf  не  корректно.  Компилятор
 "видит", что ax содержит значение A, и поэтому  использует  со-
 держимое регистра, а не содержимое ячейки памяти. Printf  будет
 печатить величину 4, вместо правильного значения  9.  Косвенное
 назначение переменной P изменило значение переменой A.
 
      Если бы оператор *P=B+5 был бы записан в виде A=B+5,  ком-
 пилятор обнаружил бы изменение значения.
 
      Содержимое регистров сбрасывается всякий  раз  при  вызове
 функции, или когда  достигнута  точка,  в  которой  может  быть
 выполнен переход (например метка, условный оператор, начало или
 конец цикла). Из-за данного ограничения и небольшого числа  ре-
 гистров в процесоорах серии 8086, большинство программ, исполь-
 зующих данную оптимизацию, будут работать неверно.
 
 
      1.7. ОПЦИИ ОБРАБОТКИ ОШИБОК
 
 
 -g#
        прекращает компиляцию после # сообщений  (предупреждений
        или сообщений об ошибках).
 
 -j#
        прекращает компиляцию после # сообщений об ошибках.
 
 -wxxx
        Допускает сообщения-предупреждения, указанные в xxx. Оп-
        ция -w-xxx подавляет указанные предупреждения. Возможные
        значения для -wxxx:
 
      (ANSI-нарушения)
 
 -wdup
        переопределение 'XXXXXXXX' не идентично
 
 -wret
        используется как пустой return, так и return(значение)
 
 -wstr
        'XXXXXXXXX' не часть структуры
 
 
 
 
 
                             - 12 -
 
 
 
 
 -wstu
        неопределена структура 'XXXXXXXX'
 
 -wsus
        вызывающее сомнение преобразование указателя
 
 -wvoi
        функции типа void не могут возвращать значение
 
 -wzst
        структура нулевой длины
 
      (Общие ошибки)
 
 -waus
        'XXXXXXXX' определено, но не используется
 
 -wdef
        возможно использование 'XXXXXXXX' прежде определения
 
 -weff
        неэффективный код
 
 -wpar
        параметр 'XXXXXXXX' никогда не используется
 
 -wpia
        возможно неверное присвоение
 
 -wrch
        недостигаемый код
 
 -wrvl
        функция должна возвращать значение
 
      (Менее типичные ошибки)
 
 -wamb
        неоднозначные операторы; требуются скобки
 
 -wamp
        излишний &, примененный к функции или массиву
 
 -wnod
        нет описания для функции 'XXXXXXXX'
 
 -wpro
        обращение к функции не совпадает с формальным  описанием
        (макетом)
 
 -wstv
        structure passed by value
 
 
 
                             - 13 -
 
 
 
 
 -wuse
        'XXXXXXXXX' объявлена, но не используется
 
      (Предупреждения по мобильности)
 
 -wart
        немобильное назначение указателя
 
 -wcln
        длинная константа
 
 -wcpt
        немобильное сравнение указателей
 
 -wdgn
        константа выходит за пределы диапазона при сравнении
 
 -wrpt
        немобильный возврат преобразования типов
 
 -wsig
        при преобразовании могут быть потеряны значащие разряды
 
 -wucp
        смешивание указателей на знаковый и беззнаковый тип char
 
 
      1.8. ОПЦИИ ИМЕН
 
 
 -zAname
        Изменяет имя класса кодового сегмента на name. По  умол-
        чанию кодовому сегменту присваивается класс _CODE.
 
 -zBname
          Изменяет  имя  класса  неинициализированного  сегмента
        данных на имя name. По умолчанию используется имя класса
        _BSS.
 
 -zCname
        Изменяет имя кодового сегмента на имя name. По умолчанию
        используется имя _TEXT, за исключением модели памяти ME-
        DIUM, LARGE и HUGE, для которых используется имя filena-
        me _TEXT. (В данном случае filename - имя исходного фай-
        ла.)
 
 -zDname
        Изменяет имя неинициализированного  сегмента  данных  на
        name. По умолчанию используется _BSS, за исключением мо-
        дели HUGE,  для  которой  неинициализированные  сегменты
        данных не порождаются.
 
 
 
 
                             - 14 -
 
 
 
 
 -zGname
          Изменяет  имя  группы  неинициализированного  сегмента
        данных  на  имя  name.  По  умолчанию  используется  имя
        DGROUP, за исключением модели  HUGE,  которая  не  имеет
        групп данных.
 
 -zPname
        Приводит к тому, что все выходные файлы будут генериться
        в кодовую группу в сегменте кода с именем  name.  Данная
        опция не должна использоваться с модель TINY.
 
 -zRname
        Присваивает имя name инициализированному сегменту  кода.
        По умолчанию инициализированный сегмент кода  называется
        _DATA, исключение составляет модель памяти HUGE, которая
        использует имя filename_DATA.
 
 -zSname
        Изменяет имя группы инициализированных сегментов кода на
        name. По умолчанию всегда используется  имя  DGROUP,  за
        исключением модели HUGE, где не может быть групп данных.
        Для данной модели флаг игнорируется.
 
 -zTname
        Присваивает имя name классу инициализированных сегментов
        данных. По умолчанию используется имя _DATA.
 
 -zX*
        Использует имя по умолчанию для X: например, -zA*  озна-
        чает использование имени CODE для сегмента кода.
 
 
      1.9. ОПЦИИ УПРАВЛЕНИЯ КОМПИЛЯЦИЕЙ
 
 
 -B
        Компиляция и вызов ассемблера для обработки  встроенного
        ассемблерного кода (могут быть части, написанные на  ас-
        семблере).
 
 -c
        Компиляция и ассемблирование файлов с расширениями .C  и
        .ASM, но без выполнения команды связи.
 
 -ofilename
          Результат  компиляции  помещается  в  файл  с   именем
        filename.OBJ.
 
 -S
          Компиляция  указанных  исходных  файлов  и   получение
        выходных файлов на ассемблере; без выполнения  ассембли-
        рования.
 
 
 
                             - 15 -
 
 
 
 
      1.10. ОПЦИИ РЕДАКТОРА СВЯЗЕЙ
 
 
 -efilename
        Имя выполняемой программы получается добавлением  расши-
        рения .EXE к  filename  (filename.EXE).  При  отсутствии
        данной опции используется имя исходного  или  объектного
        файла, указанное первым.
 
 -M
        Редактор связей  формирует  полную  карту  загрузки.  По
        умолчанию карта не формируется.
 
 
      1.11. ОПЦИИ ОКРУЖЕНИЯ
 
 
 -Idirectory
        Include-файлы ищутся в каталоге directory, в  дополнение
        к поиску в стандартном каталоге.  В  качестве  directory
        может быть указан спецификатор устройства или полное имя
        подкаталога. Спецификатор устройства должен заканчивать-
        ся двоеточием (:). Возможно  многократное  использование
        опции.
 
 -Ldirectory
        Редактор связей берет стартовый объектный файл C0x.OBJ и
         библиотеки  Turbo-C  (  Cx.LIB,  MATHx.LIB,  EMU.LIB  и
        FP87.LIB) из указанного каталога. По умолчанию  редактор
        связей ищет их в текущем каталоге.
 
 -nxxx
        Помещает файл .OBJ или .ASM, созданный  компилятором,  в
        каталог или на устройство, указанное в xxx.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                             - 16 -
 
 
 
 
                       2. УТИЛИТЫ TURBO-С
 
 
 
 
 
 
      2.1. ПРЕПРОЦЕССОР Turbo-C
 
 
      Утилита CPP - расширение компилятора Turbo-C. Препроцессор
 используется для обработки исходных текстов C-программ, исполь-
 зующих include-файлы и макро-определения.
 
      Вызов: CPP
 
      Результат работы препроцессора сохраняется в текущем ката-
 логе в файле с именем, совпадающем с именем исходного файла, но
 с расширением .I (Для того чтобы данный файл был записан в дру-
 гой каталог, а не в текущий, задайте опицию -n.)
 
      Опция -P  сообщает  препроцессору,  что  в  каждой  строке
 выходного файла необходимо указывать имя исходного файла и  но-
 мер строки. Если задана опция -P-, препроцессор пропускает дан-
 ную информацию. Если опция -P выключена, CPP может быть исполь-
 зован как макропрепроцессор; файл .I в последствии можно отком-
 пилировать, используя TCC или TC. По умолчанию  считается,  что
 опция -P включена.
 
 
      2.2. УТИЛИТА MAKE
 
 
 
      2.2.1. КОМАНДНЫЕ СПИСКИ
 
 
      Команды в списке команд MAKE-файла должны  быть  заданы  в
 следующем виде (команде предшествует по крайней мере один  про-
 бел или табуляция):
 
      [prefix... ] command_body
 
      Каждая команда состоит из списка префиксов, предшествующе-
 го самой команды.
 
      Префиксы, указанные в командах, изменяют обработку  данных
 команд утилитой MAKE. Префикс - это либо символ (@), либо  (-),
 за которым следует число.
 
 @
        MAKE не отображает команду на  экран  дисплея  перед  ее
        выполнением. Команда не отображается, даже если опция -s
        не была указана в командной строке при вызове MAKE.
 
                             - 17 -
 
 
 
 
 
 -num
        Если указано число num, MAKE будет аварийно  завершаться
        только в том случае, если  статус  завершения  превышает
        заданное число. Например:
 
      -4 myprog sample.x
 
      Если префикс -num не указан, MAKE проверяет статус  завер-
 шения для команды. Если статус завершения ненулевой, MAKE будет
 прерван.
 
 -
        MAKE не будет проверять статус завершения. Независимо от
        значения статуса MAKE будет продолжен.
 
      Тело команды рассматривается точно также, как если бы  она
 была введена как командная строка для  COMMAND.COM,  исключение
 составляют п   перенаправление   и    фильтры,    которые    не
 поддерживаются. MAKE выполняет  следующие  встроенные  команды,
 подключая копию COMMAND.COM:
 
 break   cd      chdir   cls     copy
 ctty    date    del     dir     erase
 md      mkdir   path    promt   ren
 rename  set     time    type    ver
 verify  vol
 
      Для поиска команд MAKE использует алгоритм MS-DOS.
 
 
      2.2.2. МАКРООПРЕДЕЛЕНИЯ
 
 
      Определенные команды, имена файлов или опции  могут  часто
 повторяться в make-файле. В таких случаях  удобно  использовать
 макроопределения.
 
      Макро - имя, которое представляет собой  некоторую  строку
 символов. В макроопределении задается имя и  текст  расширения.
 Впоследствии, когда MAKE встречает имя макроопределения, данное
 имя заменяется на текст расширения.
 
      Предположим, вы определили макрос MDL:
 
      MDL=m
 
      В  дальнейшем,  вы  можете  использовать  макроподстановку
 $(MDL).
 
      Если вы хотите при очередном запуске MAKE использовать мо-
 дель памяти LARGE, в вызове MAKE укажите опцию -D(Define):
 
      make -DMDL=l
 
                             - 18 -
 
 
 
 
      2.2.2.1. ОПРЕДЕЛЕНИЕ МАКРОСОВ
 
 
      Все макроопределения должны иметь вид:
 
      Имя_макро=Текст_расширения
 
      Имя_макро - строка букв и цифр, не содержащая пробелов.
 
      Текст_расширения - любая произвольная  строка,  содержащая
 буквы, цифры, пробелы, знаки пунктуации, и завершающаяся симво-
 лом перевода строки.
 
      Переопределить макрос можно либо в тексте маке-файла, либо
 используя опцию -D в командной строке вызова.
 
      В именах макроопределений заглавные и строчные буквы  раз-
 личаются.
 
 
      2.2.2.2. ИСПОЛЬЗОВАНИЕ МАКРОСОВ
 
 
      Макрос включается в маке-файл в формате:
 
      $(macro_name)
 
      Скобки всегда должны присутствовать, даже если имя макроса
 состоит из одного символа.  Исключение  составляют  специальные
 макросы, рассмотренные ниже.
 
      Если MAKE встречает в тексте неопределенный макрос, он за-
 мещается на пустую строку (NULL).
 
 
      2.2.2.3. ОСОБЫЕ СЛУЧАИ
 
 
 Макросы в макросе:
        Макросы не могут включаться в левую часть макроопределе-
        ния, т.е. в (macro_name). Они могут быть использованы  в
        правой части. Когда осуществляется макроподстановка, все
        макросы, включенные в текст расширения,  также  подстав-
        ляются.
 
 Макросы в правилах:
        В строках правил макроподстановка осуществляется  тотчас
        же.
 
 Макросы в директивах:
        В директивах !if и !elif макроподстановка осуществляется
        немедленно. Если макрос, указанный в директиве,  неопре-
        делен, он рассматривается как 0 (FALSE).
 
 
                             - 19 -
 
 
 
 
 Макросы в командах:
        Макроподстановка в командах  производится  во  время  их
        выполнения.
 
 
      2.2.2.4. ПРЕДОПРЕДЕЛЕННЫЕ МАКРОСЫ
 
 
      MAKE использует некоторые специальные макросы: $d, $*, $<,
 $:, $. и $&. Первый из них определен как  тест-макрос,  исполь-
 зуется в условных директивах !if и !elif; остальные  -  макросы
 имен файлов, используется в определенных и подразумеваемых пра-
 вилах. Кроме того, строки SET, устанавливающие текущее  окруже-
 ние, автоматически загружаются как макросы, и  макроопределение
 _MAKE_ определено как 1.
 
 $d - тест-макрос
        Тест-макрос заменяется 1, если определено имя макроса, и
        0, в противном случае. Содержимое текста расширения мак-
        роса безразлично. Данный макрос допускается только в ди-
        рективах !if и !elif. Например,  предположим  вы  хотите
        модифицировать маке-файл, так чтобы он использовал сред-
        нюю модель памяти. Добавте в начало маке-файла:
 
         !if !$d(MDL)    # Если MDL неопределено
         MDL=m           # Устанавливаем его в m (MEDIUM)
         !endif
 
      Различные макросы имен файлов:
 
 $* - макроопределение основы имени файла
        Макрос ($*) заменяется на имя файла, который должен быть
        построен, без расширения. Например,
 
      Имя файла: A:\P\TESTFILE.C
 
      $* распространяется до: A:\P\TESTFILE
 
 $< - макроопределение полного имени файла
        Макрос ($<) заменяется на полное имя файла, который дол-
        жен быть построен.
 
      Имя файла: A:\P\TESTFILE.C
 
      $< распространяется до: A:\P\TESTFILE.C
 
      Например, правило:
 
         startlib.obj: startlib.c
                 copy $< \oldobjs
                 tcc -c $*
 
 будет копировать startlib.obj в каталог \oldobj, перед компиля-
 цией startlib.c.
 
                             - 20 -
 
 
 
 
 
 $: - макроопределение имени пути
        Данный макрос заменяется на имя пути (без имени  файла),
        например:
 
      Имя файла: A:\P\TESTFILE.C
 
      $: распространяется до: A:\P\
 
 $. - макроопределение имени файла и расширения
 
      Имя файла: A:\P\TESTFILE.C
 
      $. распространяется до: TESTFILE.C
 
 $& - макроопределение только имени файла
 
      Имя файла: A:\P\TESTFILE.C
 
      $& распространяется до: TESTFILE
 
 
      2.2.2.5. ДИРЕКТИВЫ
 
 
      MAKE Turbo-C, в отличии от других версий  MAKE,  допускает
 директивы, позволяющие включать  другие  маке-файлы,  применять
 правила и условные команды, печатать сообщения об ошибках и "не
 определять" макросы.
 
      Директивы начинаются с символа (!),  который  должен  быть
 первым символом строки.
 
      Полный список директив MAKE:
 
         !include
         !if
         !else
         !elif
         !endif
         !error
         !undef
 
      ДИРЕКТИВЫ ВКЛЮЧЕНИЯ ФАЙЛОВ
 
      ФОРМАТ
 
      !include "filename"
 
      Директивы могут иметь произвольную вложенность. При попыт-
 ке включить файл, уже включенный на  некотором  внешнем  уровне
 вложенности, внутренняя директива будет игнорироваться как оши-
 бочная.
 
 
                             - 21 -
 
 
 
 
 
      УСЛОВНЫЕ ДИРЕКТИВЫ
 
      Формат директив аналогичен формату директив C-препроцессо-
 ра.
 
         !if выражение
                 [строки]
         !endif
 
 
         !if выражение
                 [строки]
         !else
                 [строки]
         !endif
 
 
         !if выражение
                 [строки]
         !elif
                 [строки]
         !endif
 
 П_р_и_м_е_ч_а_н_и_е. [строки] могут быть следующие:
 
      - макро-определения
 
      - явное правило
 
      - подразумеваемое правило
 
      - include-директива
 
      - if_group
 
      - error-директива
 
      - undef-директива
 
      Условные директивы  составляют  группу,  если  имеется  по
 крайней мере одна директива !if, открывающая группу, и директи-
 ва !endif, закрывающая ее.
 
      Одна директива !else может присутствовать в группе.
 
      Директивы !elif могут находиться между !if и !else.
 
      Условные директивы могут быть вложенными.
 
      ВЫРАЖЕНИЯ В УСЛОВНЫХ ДИРЕКТИВАХ
 
      Выражения, допускающиеся в условных директивах, имеют син-
 таксис аналогичный используемому в языке C. Выражение  рассмат-
 
                             - 22 -
 
 
 
 
 ривается как простое 32 разрядное целое выражение. Числа  могут
 задаваться как десятичные, восьмеричные  или  шестнадцатеричные
 константы.
 
      Выражения могут использовать следующие унарные операции:
 
 -
        отрицание
 
 ~
        побитовое дополнение
 
 !
        логическое "не"
 
      Выражения могут содержать следующие двоичные операторы:
 
         +       сложение
         -       вычитание
         *       умножение
         /       деление
         "       правая, левая кавычки
         &       поразрядное "и"
         |       поразрядное "или"
         ^       поразрядное исключающее "или"
         &&      логическое "и"
         ||      логическое "или"
         >
         <
         >=
         <=
         ==
         !=
 
      Выражение может включать тройной оператор ?.
 
        Для  группирования  операндов  могут  быть  использованы
 скобки. При их отсутствии порядок выполнения  операторов  такой
 же как в языке C.
 
      ДИРЕКТИВА error
 
      Данная директива вызывает прерывание MAKE и печать указан-
 ного диагностического сообщения.
 
      ФОРМАТ
 
      !error любой_текст
 
      ДИРЕКТИВА undef
 
      ФОРМАТ
 
      !undef имя_макро
 
                             - 23 -
 
 
 
 
 
      Директива отменяет макро-определение.  Игнорируется,  если
 макрос ранее не был определен.
 
 
      2.2.3. ВЫЗОВ MAKE
 
 
 
      2.2.3.1. СИНТАКСИС КОМАНДНОЙ СТРОКИ
 
 
      Общий случай вызова MAKE:
 
         make option option... target target
 
      Option - опции MAKE, target - имя файла, к которому должны
 быть применены указанные в MAKE правила.
 
      MAKE прерывается, если какая-либо его команда  завершилась
 через control-break. Т.о., выполнение текущей команды и сам MA-
 KE можно прервать по Ctrl-C.
 
 
      2.2.3.2. ФАЙЛ BULTINS.MAK
 
 
      В данный файл вы можете помещать  наиболее  часто  исполь-
 зуемые макро-определения и правила.  При  каждом  запуске  MAKE
 ищет файл BULTINS.MAK; если данный файл существует, MAKE читает
 его прежде чем MAKEFILE.
 
      Поиск файла BULTINS.MAK осуществляется в текущем  каталоге
 или в любом каталоге, указанном в  path.  Желательно  поместить
 данный файл в тот же каталог, что и MAKE.EXE.
 
 
      2.2.3.3. ОПЦИИ КОМАНДНОЙ СТРОКИ
 
 
 -Didentifier
        определяет указанный идентификатор как строку содержащую
        единственный символ 1.
 
 -Diden=string
        определяет указанный идентификатор как строку со  значе-
        нием, стоящим после знака (=). Строка не модет содержать
        пробелы или табуляции.
 
 -Ldirectory
        MAKE ищет включаемые файлы в указанном каталоге (так  же
        как и в текущем)
 
 
 
                             - 24 -
 
 
 
 
 -Uidentifier
        Отменяет ранее заданное определение идентификатора.
 
 -s
        Обычно, MAKE печатает каждую команду, которую выполняет.
        При включении данной опции выполняемые команды не  печа-
        таются.
 
 -n
        MAKE печатает команды, но не выполняет их.  Используется
        при отладке.
 
 -ffilename
        Использует filename как MAKE файл. Если  указанный  файл
        не существует,  и  не  задано  расширение,  производится
        попытка найти файл filename.mak.
 
 -? или -h
        Печатается help.
 
 
      2.3. РЕДАКТОР СВЯЗЕЙ Turbo-C
 
 
      Вызов
 
 tlink C0x <myobjs>, <exe>, [map], <mylibs> [emu|fp87 mathx] Cx
 
 <myobjs> = .OBJ файлы, которые должны быть связаны.
 
 <exe> = имя выполняемого файла.
 
 [map] = имя файла, куда помещается карта загрузки.
 
 <mylibs> = файлы подключаемых библиотек.
 
 C0x = инициализиционный модуль для модели памяти x.
 
 emu|fp87 = библиотеки плавающей точки (выбрать одну).
 
 Cx = системная библиотека для модели памяти x.
 
 
      2.3.1. ИНИЦИАЛИЗАЦИОННЫЕ МОДУЛИ
 
 
      Инициализационные модули имеют имя C0x.OBJ, где x  -  одна
 из следующих букв, соответствующая модели памяти: t, s,  c,  m,
 l, h. Данный модуль приводит в порядок различные сегменты прог-
 раммы. Если инициализиционный модуль не указан первым  аргумен-
 том в командной строке, сегменты программы могут быть  неудачно
 размещены в памяти.
 
      Не забудьте указать имя .EXE файла в командной  строке,  в
 
                             - 25 -
 
 
 
 
 противном случае имя вашей программы будет C0x.EXE.
 
 
      2.3.2. БИБЛИОТЕКИ
 
 
      Системные библиотеки моделей памяти должны подключаться  в
 определенном порядке.
 
      Если ваша программа использует плавающую точку, вы  должны
 указать библиотеку плавающей точки (EMU.LIB или FP87.LIB) и ма-
 тематическую библиотеку (MATHx.LIB), где x=t, s, c, m, l, h.
 
 П_р_и_м_е_ч_а_н_и_е. Если вы используете операции  с  плавающей
 точкой, вы должны включить математическую библиотеку и  библио-
 теку эмулятора ПРЕЖДЕ системной библиотеки поддержки.
 
 
      2.3.3. ИСПОЛЬЗОВАНИЕ TLINK с TCC
 
 
      Редаетор связей может быть использован как последний  про-
 ход компилятора Turbo-C. В данном случае имена файлов в команд-
 ной строке вызова компилятора должны быть заданы с явными  рас-
 ширениями .OBJ и .LIB.
 
      Например,
 
      tcc -mx mainfile.obj subl.obj mylib.lib
 
      TCC будет подключать TLINK  с  файлами  C0x.OBJ,  EMU.LIB,
 MATHx.LIB и Cx.LIB (инициализационный модуль, библиотека эмуля-
 тора (по умолчанию), математическая библиотека, системная  биб-
 лиотека поддержки).
 
 П_р_и_м_е_ч_а_н_и_е. TCC всегда подключает TLINK с опцией /c.
 
 
      2.3.4. ОПЦИИ РЕДАКТОРА СВЯЗЕЙ
 
 
      По умолчанию редактор связей всегда создает карту загрузки
 выполняемого файла. Данная карта содержит только список сегмен-
 тов программы, стартовый адрес  программы  и  предупреждения  и
 сообщения об ошибках во время работы редактора связей.
 
      Опция /m позволяет создать  более  полную  карту  загрузки
 (добавляются список общих переменных, отсортированный в порядке
 увеличения адресов).
 
      Опция /s создает такой же файл карты как опция /m, но  до-
 бавляется детализированная карта сегмента. Для каждого сегмента
 в каждом модуле карта включает адрес, длину  в  байтах,  класс,
 имя сегмента, группу, модуль и ACBP информацию.
 
                             - 26 -
 
 
 
 
 
      Опция /l создает раздел в файле .MAP для номеров строк ис-
 ходного кода. Для того, чтобы использовать данную опцию,  необ-
 ходимо компилировать исходный файл с флагом -y. Если вы  задали
 редактору связей опцию -x (не создавать карту), опция /l  будет
 игнорироваться.
 
      Опция /i помещает сегменты в выполняемый файл,  даже  если
 сегменты не содержат записи данных.
 
 П_р_и_м_е_ч_а_н_и_е. Обычно это не требуется.
 
      Опция /n приводит к тому, что редактор  связей  игнорирует
 библиотеки по умолчанию, указанные для некоторых  компиляторов.
 Данная опция необходима, если библиотеки по умолчанию  распола-
 гаются в другом каталоге, т.к. редактор связей не  поддерживает
 поиск библиотек. Кроме того, опция может быть использована, ес-
 ли связываемые модули написаны на другом языке.
 
      Опция /c обеспечивает различие строчных и заглавных букв в
 именах общих и внешних переменных.
 
      Опция /d: обычно редактор связей не сообщает  о  том,  что
 символьное имя встречается более чем в одной  библиотеке.  Если
 символьное имя должно быть включено в  программу,  TLINK  будет
 использовать копию символьного имени, упомянутого в первом фай-
 ле (библиотеке), указанном в командной строке.
 
      При наличии опции /d, будет выдаваться  список  всех  сим-
 вольных имен, продублированных в  библиотеках,  даже  если  эти
 имена не используются в программе.
 
      Кроме того, использование опции /d приводит к выдаче  пре-
 дупреждений о всех одинаковых именах, встретившихся как в файле
 .OBJ так и в файле .LIB.
 
 
      2.3.5. ОГРАНИЧЕНИЯ
 
 
      Оверлейные модули не поддерживаются.
 
      Не поддерживается Microsoft CodeView Debugger.
 
      Частично поддерживаются общие  переменные.  Должен  приме-
 няться тип public.
 
      Вы можете иметь максимально 8182 символьных  имен  и  4000
 логических сегментов.
 
      Коды, полученные MSC или MSF, не могут связываться с помо-
 щью TLINK.
 
      TLINK может использоваться с MASM и другими компиляторами,
 
                             - 27 -
 
 
 
 
 однако он несовместим с MS LINK.
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
                             - 28 -
 
 
 
 
                3. ДОПОЛНИТЕЛЬНЫЕ ФУНКЦИИ Turbo-C
 
 
 
 
 
      В этом разделе описаны функции, которых нет  в  библиотеке
 компилятора MSC.
 
 
      3.1. ABSREAD
 
 
 ИМЯ
        absread
 
 НАЗНАЧЕНИЕ
        чтение данных
 
 ВЫЗОВ
        int absread(int drive,  int  nsects,  int  sectno,  void
        *buffer);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
        int abswrite(int drive, int  nsects,  int  sectno,  void
        *buffer);
 
 INCLUDE-ФАЙЛ
        dos.h
 
 ОПИСАНИЕ
        Эти функции считывают и  пишут  специальные  сектора  на
        диске. Они игнорируют логическую структуру  диска  и  не
        обращают внимания на файлы, FATы, или каталоги.
 
        absread считывает специальные сектора диска через преры-
        вание 0x25; abswrite пишет специальные сектора  на  диск
        через прерывание 0x26.
 
      ПАРАМЕТРЫ
 
      drive = номер,  идентифицирующий  устройство,  с  которого
 считываются сектора (0 = A, 1 = B и т.д.)
 
      nsects = номера считываемых секторов
 
      sectno = начальный номер логического сектора
 
      buffer = адрес памяти, куда записываются  считываемые  или
 записываемые данные
 
      Количество считываемых секторов ограничено об'емом  памяти
 в сегменте, находящемся перед адресом buffer. Т.о., 64K -  мак-
 симальный об'ем, который может быть  считан  при  одном  вызове
 
                             - 29 -
 
 
 
 
 absread или abswrite.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        Обе функции при успешном завершении возвращают 0. В слу-
        чае ошибки возвращается -1, и errno  принимает  значение
        регистра AX, возвращаемое после системного  вызова.  См.
        документацию по MS-DOS для пояснения errno.
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
 
      3.2. ABSWRITE
 
 
 ИМЯ
        abswrite
 
 НАЗНАЧЕНИЕ
        запись данных
 
 ВЫЗОВ
        int abswrite(int drive, int  nsects,  int  sectno,  void
        *buffer);
 
 INCLUDE-ФАЙЛ
        dos.h
 
 ОПИСАНИЕ
        См. absread
 
 
      3.3. ALLOCMEM
 
 
 ИМЯ
        allocmem
 
 НАЗНАЧЕНИЕ
        выделение сегмента памяти
 
 ВЫЗОВ
        int allocmem(unsigned size, unsigned *seg);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
        int freemem(unsigned seg);  int  setblock(int  seg,  int
        newsize);
 
 INCLUDE-ФАЙЛ
        dos.h
 
 
 
 
 
                             - 30 -
 
 
 
 
 ОПИСАНИЕ
        allocmem использует  системный  вызов  0x48  MS-DOS  для
        выделения блока свободной памяти и возвращает адрес сег-
        мента выделенного блока.
 
      ПАРАМЕТРЫ
 
      size - требуемый размер памяти в параграфах.
 
      seg - указатель на слово, которому будет присвоено  значе-
 ние адреса вновь выделенного блока. Присвоения значения  слову,
 на которое указывает seg, не производится, если нет достаточно-
 го свободного места.
 
        Все  выделяемые   блоки   представляют   собой   цепочку
 параграфов.
 
      freemem освобождает  блок  памяти,  выделенный  предыдущим
 вызовом allocmem. seg - это адрес сегмента данного блока.
 
      setblock изменяет размер сегмента памяти. seg - это  адрес
 сегмента, возвращаемый предыдущим вызовом allocmem.  newsize  -
 это новый требуемый размер в параграфах.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        В случае успешного завершения allocmem возвращает -1.  В
        случае ошибки  возвращается  число  (размер  наибольшего
        свободного блока).
 
        freemem в случае нормального завершения возвращает 0.  В
        случае ошибки возвращается -1, а errno устанавливается в
 
      ENOMEM Insufficient memory
 
        setblock в случае нормального завершения возвращает  -1.
        В случае ошибки возвращается размер наибольшего  возмож-
        ного блока.
 
        Ошибочное завершение allocmem или setblock вызовет уста-
        новку _doserrno и установку глобальной переменной  errno
        в
 
      ENOMEM Not enough core
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
 СМ. ТАКЖЕ
        malloc
 
 
 
 
 
 
                             - 31 -
 
 
 
 
      3.4. ATEXIT
 
 
 ИМЯ
        atexit
 
 НАЗНАЧЕНИЕ
        определения регистров
 
      ВЫЗОВ
 
      #include <stdlib.h>
 
      int atexit(atexit_tfunk)
 
 INCLUDE-ФАЙЛ
        dos.h
 
 ОПИСАНИЕ
        atexit регистрирует функцию, на которую  указывает  func
        как на "exit function". В случае  нормального  окончания
        программы exit вызывает *func (без аргументов)  как  раз
        перед возвратом в операционную систему. Вызываемая функ-
        ция - функция типа atexit_t, который определен в typedef
        в stdlib.h.
 
        Каждый вызов atexit  регистрирует  другую  завершающуюся
        функцию. Может быть зарегистрировано до 32 функций,  ко-
        торый выполняются в порядке "последний пришел  -  первый
        ушел" (LIFO).
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        В случае нормального окончания atexit  возвращает  0,  в
        случае ошибки (нет пространства для регистрации функции)
        - ненулевое значение.
 
 СМ. ТАКЖЕ
        exec...exit,spawn...
 
      ПРИМЕР
 
         #include <stdlib.h>
         #include <stdio.h>
         void exit_fn1()
         {
             printf("Exit Function 1 called\n");
         }
 
         void exit_fn2()
         {
             printf("Exit Function 2 called\n");
         }
         main()
         {
 
                             - 32 -
 
 
 
 
             atexit(exit_fn1);   /* post exit_fn1 */
             atexit(exit_fn2);   /* post exit_fn2 */
             printf("Main quitting ...\n");
         }
     Выведется:
         Main quitting ...
         Exit Function 2 called
         Exit Function 1 called
 
 
      3.5. ATOF
 
 
 ИМЯ
        atof
 
 НАЗНАЧЕНИЕ
        преобразование строки к числу с плавающей точкой.
 
 ВЫЗОВ
        double atof(char *nptr);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
        int atoi(char *nptr); long atol(char *nptr);
 
      INCLUDE-ФАЙЛ
 
      math.h (atof)
 
      stdlib.h (atof, atoi, atol)
 
 ОПИСАНИЕ
        atof преобразует строку, на которую  указывает  nptr,  к
        числу двойной точности. Данная функция опознает:
 
      - необязательную строку из табуляций и пробелов;
 
      - необязательный знак;
 
      - строку цифр или необязательную десятичную точку;
 
      - необязательную букву e или Е, за которой следует  необя-
        зательной целое число со знаком.
 
        atoi преобразует строку, на которую  указывает  nptr,  к
        целому числу. atol преобразует строку  символов  к  типу
        long. atoi и atol опознают:
 
      - необязательную строку из табуляций и пробелов;
 
      - необязательный знак;
 
      - строку цифр.
 
 
                             - 33 -
 
 
 
 
        Во всех трех функциях первый неопознанный символ  закан-
        чивает преобразование.
 
        Во всех трех функциях не существует поддержки переполне-
        ния.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        Эти функции возвращают величину, полученную преобразова-
        нием входной строки. Если строка не может быть  преобра-
        зована к числу соответствующего типа (double  для  atof,
        int для atoi, long для atol), возвращается 0.
 
 ПЕРЕНОСИМОСТЬ
        Аналогично для UNIX.
 
 СМ. ТАКЖЕ
        scanf
 
 
      3.6. BIOSCOM
 
 
      Вызов:
 
   #include <bios.h>
   int bioscom(int cmd, char byte, int port);
 
      Функция предназначена для работы с адаптером RS232. Значе-
 ние переменной port 0 соответствует устройству  COM1,  1  соот-
 ветствует COM2 и так далее.
 
      Значение cmd может быть одним из следущих:
 
 0
        установить коммуникационные параметры, заданные парамет-
        ром byte;
 
 1
        передать символ, заданный параметром byte в линию;
 
 2
        принять символ из линии;
 
 3
        получить текущий статус крммуникационного порта.
 
      Byte представляет собой комбинацию следующих битов:
 
 0x02
        7 бит данных
 
 
 
 
 
                             - 34 -
 
 
 
 
 0x03
        8 бит данных
 
 0x00
        1 стоп-бит
 
 0x04
        2 стоп-бит
 
 0x00
        No parity
 
 0x08
        Odd parity
 
 0x18
        Even parity
 
 0x00
        110 бод
 
 0x20
        150 бод
 
 0x40
        300 бод
 
 0x60
        600 бод
 
 0x80
        1200 бод
 
 0xA0
        2400 бод
 
 0xC0
        4800 бод
 
 0xC0
        9600 бод
 
      Для всех значений cmd, возвращаемое значение есть  16-бит-
 ное слово,где старшие 8 бит - это биты статуса, а младшие возв-
 ращаемый байт. Старшие биты могут принимать следующие значения:
 
 
 
 
 
 
 
 
 
 
                             - 35 -
 
 
 
 
                                                       Таблица 1
 
 
 
            Биты старшего байта
 ----------------------------------------------------
 бит  |    значение
 ----------------------------------------------------
 15   | Time out
 14   | Transmit shift register empty
 13   | Transmit holding register empty
 12   | Break detect
 11   | Framing error
 10   | Parity error
 9    | Overrun error
 8    | Data ready
 
      Eсли значение cmd было 1 и бит 15 установлен в 1  byte  не
 был передан.
 
      Если значение cmd было 2, считанный байт в  младших  битах
 возвращаемого слова, если не было  ошибок.  Ошибкой  считается,
 если хотя бы один бит старшего байта установлен в 1.
 
      Если значение cmd было 0 или 3, старший байт может  прини-
 мать значения как было описано выше, а биты младшего байта  мо-
 гут быть следущие:
 
 
                                                       Таблица 2
 
 
 
            Биты младшего байта
 ----------------------------------------------------
 бит  |    значение
 ----------------------------------------------------
 7    | Received line signal detect
 6    | Ring indicator
 5    | Data set ready
 4    | Clear to send
 3    | Delta receive line signal detector
 2    | Trailing edge ring indicator
 1    | Delta data set ready
 0    | Delta clear to send
 
 
      3.7. BIOSDISK
 
 
      Вызов:
 
   #include <bios.h>
   int biosdisk(int cmd, int drive, int head,
 
                             - 36 -
 
 
 
 
                int track, int sector,
                int nsect, void *buffer);
 
      Эта функция использует прерывание 0х13 для работы с диском
 через bios.
 
      Drive есть номер диска. 0 соответсвует первому флоппи-дис-
 ку, 1 - второму и т.д. Для работы с винчестерским диском  нуме-
 рация начинается с 0х80. 0х80 - первый, 0х81 - второй и так да-
 лее. Для жестких дисков определяется физический номер устройст-
 ва, а не часть. Прикладные программы сами должны  интерпретиро-
 вать информацию из таблицы частей если им это необходимо.
 
      Параметр cmd указывает необходимую операцию. Он может при-
 нимать следующие значения:
 
 
                                                       Таблица 3
 
 
 
            Принимаемые значения cmd
 ----------------------------------------------------
 бит  |    значение
 ----------------------------------------------------
     Для IBM PC, XT или AT
 
 0    | Сброс
      | Все остальные параметры игнорируются
 1    | Возвращает статус последней дисковой операции
      | Все остальные параметры игнорируются
 2    | Читает один или более секторов в память
      | Начальный сектор задается параметрами:
      | head, track и sector. Число секторов
      | задается параметром nsect. Данные читаются
      | по 512 байт на сектор в buffer.
 3    | Запись одного или более секторов из памяти.
      | Начальный сектор задается параметрами:
      | head, track и sector. Число секторов
      | задается параметром nsect. Данные записываются
      | по 512 байт на сектор из buffer.
 4    | Проверка одного или более секторов.
      | Начальный сектор задается параметрами:
      | head, track и sector. Число секторов
      | задается параметром nsect.
 5    | Форматирование дорожки. Дорожка определяется
      | параметрами head и track. buffer указывет на
      | таблицу соответствия секторов и головок.
      | Смотрите Ваш Technical Reference Manual
      | для описания этой таблицы и операции
      | форматирования.
 
      Только для XT и AT
 
 
                             - 37 -
 
 
 
 
                                             Продолжение табл. 3
 
            Принимаемые значения cmd
 ----------------------------------------------------
 бит  |    значение
 ----------------------------------------------------
 6   | Форматирование дорожки и установка флогов
     | для плохих секторов.
 7   | Форматирование начинается с определенной
     | дорожки
 8   | Получить текущие параметры устройства.
     | Информация возвращается в buffer в первых
     | четырех байтах.
 9   | Initalizes drive-pair characteristics
 10  | Длинное чтение, при котором читаются
     | 512 байт + 4 extra байт на сектор
 11  | Длинная запись, при котором пишутся
     | 512 байт + 4 extra байт на сектор
 12  | Установка в нужноу место
     |(Does a disk seek)
 13  | Альтернативный сброс диска
 14  | Считать секторный буфер
 15  | Записать секторный буфер
 16  | Проверить на готовность указанное устройство
 17  | Recalibrates the drive
 18  | Диагностика ОЗУ контроллера
 19  | Диагностика устройства
 20  | Внутренния диагностика контроллера
 
      При успешном завершении возвращается 0, при ошибке возвра-
 щается не 0. Смотрите Ваш Technical Reference Manual  для  под-
 робного описания возможных ошибок.
 
 
      3.8. BIOSEQUIP
 
 
      Вызов:
 
   #include <bios.h>
   int biosequip(void);
 
      Эта функция возвращает целое значение, описывающее подклю-
 ченные устройства к системе. Используется прерывание 0х11 BIOS.
 Бита   возвращаемого  значения   если   установлены   указывают
 следущее:
 
 
 
 
 
 
 
 
 
                             - 38 -
 
 
 
 
                                                       Таблица 4
 
 
 
            Принимаемые значения
 ----------------------------------------------------
 бит  |    устройство
 ----------------------------------------------------
 15   |
       > число принтеров
 14   |
 13   | не используется
 12   | Джойстик
 11   |
       > число портов RS232
 10,9 |
 8    | не используется
 7    |
       > число дискет
 6    |  00 - 1 устройство
      |  01 - 2 устройства
      |  10 - 3 устройства
      |  11 - 4 устройства, толко если 0 бит в 1
 5    |
       > 00 - не используется
 4    |  01 - 40х25 BW with color card
      |  10 - 80x25 BW with color card
      |  11 - 80x25 BW with mono card
 3    |
       > Размер ОЗУ
 2    |  00 - 16 К
      |  01 - 32 К
      |  10 - 48 К
      |  11 - 64 К
 1    | Сопроцессор плавающей точки
 0    | Загрузка с дискеты
 
 
      3.9. BIOSKEY
 
 
      Вызов:
 
   #include <bios.h>
   int bioskey(int cmd);
 
      Эта функция производит разнообразные операции с  клавиату-
 рой используя прерывание 0х14  BIOS.  Параметр  cmd  определяет
 следующие операции:
 
 0
        Return the next key struck at the keyboard. If the lower
        8 bits are non-zero, that is the ASCII character struck.
        If the lower 8 bits are zero, the upper 8 bits  are  ex-
 
                             - 39 -
 
 
 
 
        tended keyboard kodes defined in the Technical Reference
        Manual for the IBM PC.
 
 1
        This tests whether a keystroke is available to be  read.
        A return value of zero means no key is available. Other-
        wise, the value of the next keystroke is  returned.  The
        keystroke itself is kept to be returned by the next call
        to bioskey that has cmd value of zero.
 
 2
        Request the current shift key status. The value is  com-
        posed from ORing the following values together:
 
     0x80 Insert toggled
     0x40 Caps toggled
     0x20 Num Lock toggled
     0x10 Scroll Lock toggled
     0x08 Alt down
     0x04 Ctrl down
     0x02 Left Shift down
     0x01 Right Shift down
 
 
      3.10. BIOSMEMORY
 
 
      ВЫЗОВ
 
   #include <bios.h>
   int biosmemory(void);
 
      Функция использует прерывание 0х12 BIOS. Возвращает размер
 памяти в 1К блоках.
 
 
      3.11. BIOSPRINT
 
 
      ВЫЗОВ
 
   #include <bios.h>
   int biosprint(int cmd, int byte, int port);
 
      Эта функция предназначена для  работы  с  принтером,  ука-
 занным параметром port. Если  он  равен  0,  это  соответствует
 LPT1, 1 - LPT2 и т.д.
 
      Параметр cmd может принимать следующие значения:
 
 
 
 
 
 
                             - 40 -
 
 
 
 
                                                       Таблица 5
 
 
 
            Принимаемые значения cmd
 ----------------------------------------------------
 cmd  |    описание
 ----------------------------------------------------
 0    | напечатать символ в byte
 1    | инициализация принтера
 2    | прочитать статус принтера
 
      Если возвращаемое значение для операции 0 не равно 0,  это
 свидетельствует об ошибке. Для остальных операций  возвращаемое
 значение описано в Вашем Technical Reference Manual for the IBM
 PC.
 
 
      3.12. BIOSTIME
 
 
      ВЫЗОВ
 
   #include <bios.h>
   long biosprint(int cmd, long newtime);
 
      Эта функция читает или устанавливает  таймер  BIOS.  Время
 определяется в тиках от полуночи. В каждой  секунде  содержится
 18.2 тика. Если cmd равно 0, функция возвращает текущее время в
 таймере. Если cmd равно 1, устанавливается новое время в тайме-
 ре.
 
 
      3.13. BRK
 
 
      Полностью совподает с аналогичной функцией в Демосе-2.
 
 
      3.14. COUNTRY
 
 
 ИМЯ
        country
 
      ВЫЗОВ
 
    #include <dos.h>
    struct country *country(int countrycode,
                        struct country *countryp);
 
 
 
 
 
                             - 41 -
 
 
 
 
 ОПИСАНИЕ
         Функция  возвращает  информацию,  зависящую  от  страны
        (дата, время и т.д.). Величина,  устанавливаемая  данной
        функцией, зависит от конкретной версии ДОС.
 
        Если countryp имеет значение -1, текущая страна  берется
        из значения countrycjde, которое не должно  быть  равным
        0.  С  другой  стороны,  на  структуру  стран  указывает
        countryp. Эта структура заполнена информацией, зависящей
        от страны:
 
      текущая страна (если countrycode установлен в 0), или
 
      страна, заданная countrycode(ом).
 
      Структура стран определяется следующим образом:
 
         struct country {
                 int co_date     /* Формат даты */
                 char co_curr[5];  /* Currency symbol */
                 char co_thsep[2]; /* Разделитель
                                         между тысячами */
                 char co_desep[2]; /* Десятичный
                                          разделитель */
                 char co_dtsep[2]; /* Разделитель в дате */
                 char co_tmset[2]; /* Разделитель во
                                                 времени */
                 char co_currstyle; /* Текущий стиль */
                 char co_digits; /* Количество значимых
                         цифр in currency */
                 int(far *co_case) {};  /* Case map function */
                 char co_dasep; /* разделитель между данными */
                 char co_fill[10];  /* Символ-заполнитель */
 
      Формат даты в co_date:
 
      0 - для стиля даты, месяца и времени США;
 
      1 - европейский стиль;
 
      2 - японский стиль.
 
      Текущий стиль изображения, задаваемый co_currstyle(ом):
 
      0 - перед текущим символом численное значение ставится без
 пробела;
 
      1 - численное значение, следующее за  символом,  не  отде-
 ляется от него пробелом;
 
      2 - предшествующее текущему символу численное значение от-
 делено от него пробелом;
 
      1 - численное значение, следующее за символом,  отделяется
 
                             - 42 -
 
 
 
 
 от него пробелом.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        Возвращает указатель countryp.
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
 
      3.15. CTRLBRK
 
 
 ИМЯ
        ctrlbrk
 
 ВЫЗОВ
 
         #include <dos.h>
         void ctrlbrk(int(*fptr)(void));
 
 ОПИСАНИЕ
        Функция устанавливает новую функцию обработки комбинации
        control-break, на которую указывает fptr. Вектор  преры-
        вания 0x23 преобразуется для вызова названной функции.
 
        Названная функция не вызывается непосредственно. ctrlbrk
          делает  так,  что  ДОС-овский  обработчик   прерываний
        вызывает нужную функцию.
 
        Обрабатывающая функция может выполнять любое  количество
        операций и системных вызовов. Обработчик не имеет  возв-
        рата; он  может  использовать  longjmp  для  возврата  в
        произвольную точку программы.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        ctrlbrk ничего не возвращает. Функция-обработчик возвра-
        щает 0 для сброса текущей программы; любое другое значе-
        ние вызовет продолжение выполнения программы.
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
 СМ. ТАКЖЕ
        longjmp, setjmp
 
         ПРИМЕР
 
         #include <stdio.h>
         #include <dos.h>
 
         #define ABORT 0
 
         int c_break(void)
         {
 
                             - 43 -
 
 
 
 
           printf("Control-Break hit. Program aborting ...\n");
           return(ABORT);
         }
         main
         {
           ctrlbrk(c_break);
           for(;;) {  /* Неопределенная петля */
             printf("Looping ...\n");
           }
        }
  Вывод:
       Looping ...
       Looping ...
       Looping ...
       ^C
       Control-Break hit. Program aborting ...
 
 
      3.16. DISABLE
 
 
 ИМЯ
        disable - отменияет прерывания
 
      ВЫЗОВ
 
         #include <dos.h>
         void disable(void);
 
      ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
 
         void enable(void);
         void geninterrupt(int intr_num);
 
 ОПИСАНИЕ
        Эти функции помогают программисту осуществить гибкое уп-
        равление аппаратными прерываниями.
 
        disable отменяет прерывания. Допускается лишь прерывание
        NMI от любого внешнего устройства.
 
        enable включает прерывания.  Допускаются  прерывания  от
        всех устройств.
 
        geninterrupt инициирует внутреннее прерывание  от  прог-
        раммы, заданное параметром intr_num.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        disable и  enable  ничего  не  возвращают.  geninterrupt
        возвращает значение, зависящее от вызванного прерывания.
 
 
 
 
 
                             - 44 -
 
 
 
 
 ПЕРЕНОСИМОСТЬ
        Только для архитектуры с 8086.
 
 СМ. ТАКЖЕ
        getvect
 
 
      3.17. DOSTOUNIX
 
 
 ИМЯ
        dostounix
 
 ВЫЗОВ
         #include <dos.h>
         long dostounix(struct date *dateptr,
                        struct time *timeptr);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
 
         void unixtodos(long utime, struct date *dateptr,
                        struct time *timeptr);
 
 ОПИСАНИЕ
        dostounix преобразует дату и время,  возвращаемые  функ-
        циями getdate и gettime, в unix-овский формат. dateptr -
        указатель на структуру даты, а timeptr  -  указатель  на
        структуру времени, содержащие информацию о времени и да-
        те, соответствующих данной ДОС.
 
        unixtodos преобразует время в unix-овском формате, полу-
        ченное из utime, в ДОС-овский формат, и  заносит  его  в
        структуры даты и времени, на которые указывают dateptr и
        timeptr.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
          dostounix  возвращает  unix-овскую   версию   текущего
        времени: число секунд со времени 00:00:00 1 января  1970
        г. (GMT).
 
 ПЕРЕНОСИМОСТЬ
        Обе функции - только для MS-DOS.
 
 СМ. ТАКЖЕ
        ctime, getdate, gettime
 
 
      3.18. FARMALLOC
 
 
 ИМЯ
        farmalloc - выделение памяти для данных типа far
 
 ВЫЗОВ
 
                             - 45 -
 
 
 
 
         #include <alloc.h>
         void far *farmalloc(unsigned long size);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
 
         void far *farcalloc(unsigned long nunits,
                             unsigned long unitsz);
         long farcoreleft(void);
         void farfree(void far *block);
         void far *farrealloc(void far *block,
                              unsigned long newsize);
 
 ОПИСАНИЕ
        Все названные функции по назначению подобны  аналогичным
        им malloc, calloc и т.д., но  употребляются  для  данных
        типа far.
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
 СМ. ТАКЖЕ
        malloc
 
 
      3.19. FINDFIRST
 
 
 ВЫЗОВ
         #include <dir.h>
         #include <dos.h>
         int findfirst(char *pathname, struct ffblk *ffblk,
                       int attrib);
 
 ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
 
         int findnext(struct ffblk *ffblk);
 
 ОПИСАНИЕ
        findfirst начинает поиск каталога  на  диске,  используя
        системный вызов MS-DOS 0x4E.
 
        pathname - строка, содержащая необязательный  специфика-
        тор устройства и полное имя искомого  файла  (включающее
        имя пути). Имя файла может содержать регулярное  выраже-
        ние (? или *). Когда заданный  файл  найден,  происходит
        наполнение структуры ffblk информацией о каталоге.
 
        attrib - байт атрибутов файла MS-DOS,  используемый  при
        выборе допустимых файлов в поиске. attrib  может  прини-
        мать одно из следудующих значений, определенных в dos.h:
 
      FA_RDONLY Только чтение
 
      FA_HIDDEN Скрытый файл
 
                             - 46 -
 
 
 
 
 
      FA_SYSTEM Системный
 
      FA_LABEL Метка тома
 
      FA_DIREC Каталог
 
      FA_ARCH Архив
 
        findnext используется для поиска следующего  файла,  имя
        которого подходит под регулярное выражение,  заданное  в
        findfirst. ffblk -  это  блок,  заполненный  при  вызове
        findfirst. Он содержит информацию, необходимую для  про-
        должения поиска. На каждый вызов findnext будет  возвра-
        щаться одно имя файла до тех пор, пока не найдется более
        имени файла, подходищего под заданное регулярное выраже-
        ние.
 
      Формат структуры ffblk:
 
         struct ffblk {
           char ff_reserved[21];  /* Зарезервировано ДОС */
           char ff_attrib;  /* Искомый атрибут */
           int ff_ftime;   /* Время модификации файла */
           int ff_fdate;   /* Дата модификации файла */
           int ff_fsize;   /* Размер файла */
           int ff_fname;   /* Имя искомого файла */
         }
 
        Эти функции устанавливают DTA для адресации ffblk.  Если
        вам нужно значение DTA, вы можете  вы  можете  сохранять
        его и восстанавливать (с помощью getdta и setdta)  после
        каждого вызова findfirst и findnext.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        Возвращают 0 при успешном завершении поика. Если файл не
        найден, или в имени файла встретилась какая-либо ошибка,
        возвращается -1, и глобальной переменное errno  присваи-
        вается одно из значений:
 
      ENOENT Имя ненайденного файла
 
      ENMFILE Файлов нет
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
      ПРИМЕР
 
  #include <dir.h>
  #include <dos.h>
 
  main()
  {
 
                             - 47 -
 
 
 
 
         struct ffblk ffblk;
         int done;
         printf("Directory listing of *.*\n");
         done = findfirst("*.*",&ffblk,0);
         while(!done) {
                 printf("  %s\n", ffblk.ff_name);
                 done = findenext(&ffblk);
        }
  }
         Вывод:
         Directory listing of *.*
         FINDFRST.C
         FINDFRST.OBJ
         FINDFRST.MAP
         FINDFRST.EXE
 
 
      3.20. FNMERGE
 
 
      ВЫЗОВ
 
  #include <dir.h>
  void fnmerge(char *path, char *drive, char *dir,
               char *name, char *ext);
 
      ВЫЗОВ РОДСТВЕННЫХ ФУНКЦИЙ
 
  void fnsplit(char *path, char *drive, char *dir,
               char *name, char *ext);
 
 ОПИСАНИЕ
        fnmerge создает новое имя файла из отдельных компонент:
 
      X:\DIR\SUBDIR\NAME.EXT
 
      где X задается drive(ом);
 
      \DIR\SUBDIR\ - dir(ом);
 
      NAME.EXT - name(ом) и ext(ом).
 
        fnsplit полное имя файла (path) представляет строкой ви-
        да
 
      X:\DIR\SUBDIR\NAME.EXT и разбивает path на  4  компоненты.
 Затем они помещаются в строки, на которые указывают drive, dir,
 name, ext. Каждая компонента обязательна, но может  быть  NULL-
 ой.
 
        Максимальные размеры этих строк представлены константами
        MAXDRIVE, MAXDIR, MAXPATH, MAXNAME, MAXEXT, описаннsми в
        dir.h, и каждый размер включает в себя пробел для конеч-
        ного нулевого знака.
 
                             - 48 -
 
 
 
 
 
 Константа   Максимальный   Строка
               размер
 
 MAXPATH        80         path
 MAXDRIVE       3          drive, включая двоеточие (:)
 MAXDIR         66         dir, включая нач. и послед.
                           слэши (/)
 MAXFILE        9          name
 MAXEXT         5          ext, включая начальную точку (.)
 
        fnsplit полагает, что достаточно места для хранения каж-
        дой ненулевой компоненты. fnmerge полагает, что для пол-
        ного имени достаточно места. Максимальная длина  полного
        имени определяется MAXPATH.
 
        При разбитии path на части fnsplit трактует знаки  пунк-
        туации следующим образом:
 
      drive включает в себя двоеточие (C:, A: и т.д.)
 
      dir  содержит  нач.  и  послед.  слэши  (\turboc\include\,
 \source\ и т.д.)
 
      ext содержит точку, предшествующую расширению (.c, .exe  и
 т.д.)
 
      Эти две описанные функции взаимно  дополняют  друг  друга:
 если вы разбили данный path с помощью fnsplit, об'единения  по-
 лученных компонент с помощью fnmerge снова даст вам path.
 
 ВОЗВРАЩАЕМОЕ ЗНАЧЕНИЕ
        fnsplit возвращает целое  значение,  составленное  из  5
        флагов, определенных в dir.h, показывающее, какие компо-
        ненты полного имени были представлены в  path.  Флаги  и
        представляемые ими компоненты:
 
      EXTENSION расширение
 
      FILENAME имя файла
 
      DIRECTORY каталог (и, возможно, подкаталоги)
 
      DRIVE спецификация устройства (см. dir.h)
 
      WILDCARD регулярное выражение (символы ? и *)
 
 ПЕРЕНОСИМОСТЬ
        Только для MS-DOS.
 
      ПРИМЕР
 
  #include <stdio.h>
  #include <dir.h>
 
                             - 49 -
 
 
 
 
 
 char drive[MAXDRIVE];
 char dir[MAXDIR];
 char file[MAXFILE];
 char ext[MAXEXT];
 
 main()
 {
     char s[MAXPATH], t[MAXPATH];
     int flag;
 
     for (;;)  {
         printf("> ");  /* Печать приглашения */
         if(!gets(s)) break; /* ожидание ввода */
         flag = fnsplit(s,drive,dir,file,ext);
 
         /* печать компонент */
         printf("   drive: %s, dir: %s, file: %s, ext: %s, ",
                    drive,dir,file.ext);
         printf("flags: ");
         if (flag & DRIVE)
            printf(":");
         if (flag & DIRECTORY)
            printf("d");
         if (flag & FILENAME)
            printf("f");
         if (flag & EXTENSION)
            printf("e");
            printf("\n");
 
       /* сбор частей вместе и сравнение с
                         исходными данными */
         fnmerge(s,drive,dir,file,ext);
         if(strcmp(t,s) != 0)
             printf(" --> strings are different!");
         }
 }
         Вывод:
 > C:\TURBOC\FN.C
   drive: C:, dir: \TURBOC\, file: FN, ext: .C, flags: dfe
 > FILE.C
   drive: , dir: , file: FILE, ext: .C, flags: :fe
 > \TURBOC\SUBDIR\NOEXT.
   drive: , dir: \TURBOC\SUBDIR, file: NOEXT, ext: ., flags: dfe
 > C:MYFILE
   drive: C:, dir: , file: MYFILE, ext: , flags: :f
 > ^Z
 
 
 
 
 
 
 
 
                             - 50 -
 
 
 
 
      3.21. GETCBRK
 
 
      ВЫЗОВ
 
             #include <dos.h>
             int getcbrk(void);
 
      ОПИСАНИЕ
 
        Функция  возвращает  установленную  реакцию  на   символ
 (control-break (ctrl/c). Функция использует прерывание 0х33 MS-
 DOS. Если функция вернула 0, то проверка выключена и  программа
 по control-break не прерывается, если 1 - включена.
 
 
      3.22. GETCURDIR
 
 
      ВЫЗОВ
 
               #include <dir.h>
               int getcurdir(int drive, char *direc);
 
      ОПИСАНИЕ
 
      Функция читает имя текущего рабочего каталога на указанном
 параметром drive устройстве.
 
      Нумерация устройств с 0 (0 - по умолчанию, 1=А, 2=В, 3=С и
 т.д.).
 
      Имя каталога возвращается в массиве direc. Функция возвра-
 щает -1 при ошибке и 0 в противном случае.
 
 
      3.23. GETCWD
 
 
      ВЫЗОВ
 
             #include <dir.h>
             char *getcwd (char *buf, int n);
 
      ОПИСАНИЕ
 
      Функция  читает  полное  имя  текущего  рабочего  каталога
 (включая имя устройства) длины не более n, сохраняя его в  buf.
 Если полное имя пути больше n, фиксируется ошибка. Если  перво-
 начально buf=NULL, буфер длины n байт будет выделен для  вас  с
 помощью malloc. Функция возвращает buf в случае ошиьки NULL.
 
 
 
 
                             - 51 -
 
 
 
 
      3.24. GETDATE
 
 
      ВЫЗОВ
 
         #include <dos.h>
         void getdate (struct date *dateblk);
         void gettime (struct time *timep);
         void setdate (struct date *dateblk);
         void settime (struct time *timep);
 
      ОПИСАНИЕ
 
      Функция getdate получает текущую дату и помещает ее в  da-
 teblk. setdate устанавливает текущую дату, заданную в  dateblk.
 gettime получает текущее время в timep.  settime  устанавливает
 текущее время, заданное в timep.
 
         struct date {
         int da_year /* текущий год */
         char da_day /* месяц года */
         char da_mon /* месяц/январь-1 */
       }
         struct time {
         unsigned char ti_min /* минуты */
         unsigned char ti_hour /* часы */
         unsigned char ti_hund /* сотые доли секунд */
         unsigned char ti_sec /* секунды */
      }
 
 
      3.25. GETDFREE
 
 
      Вызов:
 
        #include <dos.h>
         void getdfree (int drive, struct dfree *dfreep);
 
      ОПИСАНИЕ
 
      Функция получает свободное  пространство  на  диске  drive
 (0=по умолчанию, 1=А, 2=В и  т.д.).  Результат  возвращается  в
 структуре dfreep следующего вида:
 
         struct dfree {
                unsigned df_avail; /* число годных кластеров */
                unsigned df_total; /* общее число кластеров */
                unsigned df_bsec /* число байт в секторе */
                unsigned df_sclus /* число секторов в кластере */
 
        }
 
      Функция не  возвращает  значение.  Если  произошла  ошибка
 
                             - 52 -
 
 
 
 
 df_sclus устанавливается в -1.
 
 
      3.26. GETDISK
 
 
      Вызов:
 
         #include <dir.h>
         int getdisk (void);
         int setdisk (int drive);
 
      ОПИСАНИЕ
 
      Функция getdisk возвращает номер текущего диска (0=А, 1=В,
 2=С и т.д.), используя прерывание 0х19 DOS. Функция setdisk ус-
 танавливает текущим диском drive (0=A, 1=B, 3=C  и  т.д.),  ис-
 пользуя 0х0Е прерывание DOS.  setdisk  возвращает  общее  число
 дисков, имеющихся в наличии.
 
 
      3.27. GETDTA
 
 
      Вызов:
 
        #include <dos.h>
        char *getdta(void);
        void setdta(char far *dta);
 
      ОПИСАНИЕ
 
      Функция  getdta  возвращает  текущий  установленный  адрес
 преобразования диска (DTA) (подробности смотри Technical  Refe-
 rence Manual). setdta изменяет текущий DTA на значение,  задан-
 ное dta.
 
 П_р_и_м_е_ч_а_н_и_е. Корректно работает только с моделями памя-
 ти: compact, large и huge.
 
 
      3.28. GETFAT
 
 
      Вызов:
 
        #include <dos.h>
        void getfat(int drive, struct fatinfo *fatblkp);
        void getfatd(struct fatinfo *fatblkp);
 
      ОПИСАНИЕ
 
      Функции получают информацию из таблицы  размещения  файлов
 (FAT). Для функции getfat необходимо указать  устройство  (0=по
 
                             - 53 -
 
 
 
 
 умолчанию текущий, 1=А, 2=В, 3=С и т.д.). Функция getfatd полу-
 чает информацию о текущем диске.
 
      Обе функции  заполняют  структуру,  на  которую  указывает
 fatblkp, типа:
 
         struct fatinfo {
         char fi_sclus; /* число секторов в кластере */
         char fi_fatid; /* The FAT id byte */
         char fi_ndus /* число кластеров */
         int fi_bysec /* число байт в секторе */
        }
 
 
      3.29. GETFTIME
 
 
      Вызов:
 
        #include <dos.h>
        int getftime (int handle, struct ftime *ftime);
        int setftime (int handle, struct ftime *ftimep);
 
      ОПИСАНИЕ
 
      Функция getftime получает время и дату создания файла  для
 дискового  файла,  открытого  с  помощью  open  с  дескриптором
 handle. Результат возвращается в ftimep.
 
      Функция setftime изменяет дату и время для открытого файла
 с дескриптором handle. Время и дата берется из ftimep.
 
      Структура ftime имеет следующий вид:
 
         struct ftime {
         unsigned ft_sec:5;  /* two seconds */
         unsigned ft_min:6;  /* минуты */
         unsigned ft_hour:5; /* часы */
         unsigned ft_day:5; /* дни */
         unsigned ft_month:4; /* месяц */
         unsigned ft_year:7; /* год, начиная с 1980 */
       };
 
      Обе функции возвращают 0 при успешном завершении  и  число
 <0 при ошибке.
 
 
      3.30. GETPASS
 
 
      Вызов:
 
         include <conio.h>
         char *getpass(char *prompt);
 
                             - 54 -
 
 
 
 
 
      ОПИСАНИЕ
 
      Функция аналогична getpass в OC DEMOC-2.
 
 
      3.31. GETPSP
 
 
      Вызов:
 
        #include <dos.h>
        unsigned getpsp(void);
 
      ОПИСАНИЕ
 
      Функция получает сегментный адрес (segment adress) префик-
 са программного сегмента (PSP), используя 0х62 прерывание DOS.
 
 П_р_и_м_е_ч_а_н_и_е. Работает только в MS-DOS версий 3.х
 
 
      3.32. GETVECT
 
 
      Name ...... getvect-gets interrupt vector entry
 
      Usage ..... void interrupt(getvect(int intr_num)) ();
 
      Related
 
      fuctions usage ... void  setvect(int_num,  void  interrupt
 (isr) ());
 
      Prototype in ..... dos.h
 
      Description ...... MS-DOS includes a set  of  "hard-wired"
 interrupt vectors, numbered 0 to 255. The 4-byte value in  each
 vector is actually an address, which is the location of an  in-
 terrupt function&
 
      getvect reads the value of the vector  named  by  intr_num
 and interprets that value read as a (far) pointer to  some  in-
 terrupt function.
 
      setvect sets the value of the vector named by intr_num  to
 a new value, vector, which is a far pointer containing the add-
 ress of a new interrupt function. The address of  a  C  routine
 may only be passed to vector if that routine is declared to  be
 an interrupt routine.
 
      Note: If you use the prototypes declared in dos.h, you can
 simply pass the address of an interrupt function to setvect  in
 any memory model.
 
                             - 55 -
 
 
 
 
 
      Return value ..... getvect returns the current 4-byte  va-
 lue stored in the interrupt vector named by  intr_num.  setvect
 returns nothing.
 
      Portability ...... Unique to MS-DOS.
 
      See also ......... disable
 
 
      3.33. GETVERIFY
 
 
      Вызов:
 
        #include <dos.h>
        int getverify(void);
        int setverify(int value);
 
      ОПИСАНИЕ
 
      Функции предназначены для работы с флагом проверки  записи
 на диск MS-DOS. Если этот флаг включен, каждая операция  записи
 на диск проверяется.
 
      Функция getverify возвращает 0, если флаг включен.
 
      Функция setverify устанавливает флаг: 0 - выключить,  1  -
 включить.
 
 
      3.34. HARDERR
 
 
      Вызов:
 
        #include <dos.h>
        void harderr(int (*fptr) ());
        void hardresumed(int rescode);
        void hardretn(int errcode);
 
      ОПИСАНИЕ
 
      Эти функции предназначены для обработки аппаратных ошибок.
 
      Функция harderr указывает на функцию,  которая  будет  ис-
 пользоваться д   для   обработки   аппаратных   ошибок   вместо
 стандартных. Она использует прерывание 0х24. Функция, на  кото-
 рую указывает harderr, должна иметь вид:
 
         handler(int errval, int ax, int bp, int si)
 
 errval - это код ошибки, установленный в регистре DI; ax, bp  и
 si - это соответствующие регистры; ах указывает на каком  диске
 
                             - 56 -
 
 
 
 
 или устройстве произошла ошибка. Если ах<0, то не на диске. Ес-
 ли ах>0, то используя маску 0х00FF, можно получить номер  диска
 (1=А, 2=В и т.д.).
 
      Функция hardresumed используется для возврата в MS-DOS  со
 значениями: 0 - игнорировать, 1 - для повторения, 2 - аборт.
 
      Функция hardretn возвращает вызвавшей программе ошибку.
 
 П_р_и_м_е_ч_а_н_и_е. Функция handler должна возвращать 0 -  для
 игнорирования ошибки, 1 - повторить операцию, 2 - прекратить.
 
      Примеры:
 
         #include <stdio.h>
         #include <dos.h>
 
         #define DISPLAY STRING   0x09
         #define IGNORE 0
         #define RETRY. 1
         #define ABORT  2
       int handler(int errval, int ax, int bp, int si)
       {
         char msg[25]; int drive;
 
         if (ax < 0) )  /* device error */
            /* can only use dos functions 0 - 0x0C */
            bdosptr(DISPLAY_STRING, "device erro$", 0);
            hardretn(-1); /* return to calling program */
        }
         drive = (ax & 0x00FF);
         sprintf(msg, "disk error on drive %c$", `A` + drive);
         bdosptr(DISPLAY_STRING, msg, 0);
         return(ABORT);  /* abort calling program */
       }
 
       main()
       {
          harderr(handler);
 
          printf("Make sure there is no disk in drive A:\n");
          printf("Press a key when ready...\n");
          getch();
 
          printf("Attempting to access A:n");
          fopen("A:ANY.FIL,"r");
       }
 
 
 
 
 
 
 
 
                             - 57 -
 
 
 
 
      3.35. INPORT
 
 
      Вызов:
 
         #include <dos.h>
         int inport(int port);
         int inportb(int port);
         void outport(int port, int word);
         void outportb(int port, char byte);
 
      ОПИСАНИЕ
 
      Inport читает слово из порта ввода port.
 
      Inportb читает байт из порта ввода port.
 
      Outport записывает слово word в порт вывода port.
 
      Outportb записывает байт byte в порт вывода port.
 
 П_р_и_м_е_ч_а_н_и_е. Inport и outport - не функции, а макросы!
 
 
      3.36. INTR
 
 
      Вызов:
 
         #include <dos.h>
         void intr (int intr_num, struct REGPACK *preg);
 
      ОПИСАНИЕ
 
      Функция выполняет прерывание intr_num  для  8086,  копируя
 значение регистров из preg. После завершения прерывания  значе-
 ния регистров возвращаются опять же в preg.
 
      Структура REGPACK описана в <dos.h>.
 
 
      3.37. IOCTL
 
 
      Вызов:
 
  #include <io.h>
  int ioctl(int handle, int cmd[, int *argdx,
            int argcx]);
 
 Функция предназначена для контроля устройств ввода/вывода.  Ис-
 пользует системный вызов 0х44 MS-DOS.  Параметр  cmd  указывает
 вид операции для устройства:
 
 
                             - 58 -
 
 
 
 
                                                       Таблица 6
 
 
 
 -------------------------------------------------
 cmd    |                Операция
 -------------------------------------------------
 0      | Получить информацию об устройстве
 1      | Установить информацию об устройстве
 2      | Прочитать argcx байт по адресу, указанному в
        | argdx
 3      | Записать argcx байт по адресу, указанному в
        | argdx
 4      | Аналогично 2, только handle интерпретируется
        | как номер устройства (0=текущий, 1=A и т.д.)
 5      | Аналогично 3, только handle интерпретируется
        | как номер устройства (0=текущий, 1=A и т.д.)
 6      | Прлучить статус ввода
 7      | Получить статус вывода
 8      | Test removability; DOS 3.x only
 11     | Set sharing conflict retry count;
        | DOS 3.x only
 
      Функция возвращает -1 при ошибке.
 
 П_р_и_м_е_ч_а_н_и_е. Смотрите Ваш MS-DOS Programmer's Reference
 Manual для больших подробностей.
 
 
      3.38. ISATTY
 
 
      Вызов:
 
         #include <io.h>
         int isatty (int handle);
 
      ОПИСАНИЕ
 
      Функция возвращает не  0,  если  устройство,  связанное  с
 handle, является символьным устройством, и 0 - в противном слу-
 чае.
 
      Символьными  устройствами  считаются:  терминал,  консоль,
 принтер, последовательный порт.
 
 
      3.39. KEEP
 
 
      Вызов:
 
         #include <dos.h>
         void keep(int status, intsize);
 
                             - 59 -
 
 
 
 
 
      ОПИСАНИЕ
 
        Возвращает  управление  MS-DOS  со  статусом  завершения
 status. Текущая программа становится резидентной. Программа ус-
 танавливается в size параграфов длины и оставляет память  прог-
 раммы свободной. keep должна использоваться для  установки  TSR
 программ. Использует прерывание 0х31 DOS.
 
 
      3.40. LOCK
 
 
      Вызов:
 
  #include <io.h>
  int lock(int handle, long offset, long length);
  int unlock(int handle, long offset, long length);
 
       Функции  предназначены  для  блокировки  и  разблокировки
 файла, заданного дескриптором handle. Работает только в версиях
 MS-DOS 3.X. Если файл заблокирован то все  остальные  программы
 могут только читать область, заданную offset и length.
 
      Функции возвращают 0 при успехе и -1 при ошибке.
 
 
      3.41. MOVMEM
 
 
      Вызов:
 
  #include <mem.h>
  int movmem(void *source, void *destin,
             unsigned len);
  int setmem(void *adr,int len, char value);
 
      Movmem копирует len байт из блока source  в  блок  destin.
 Если исходная и результирующия строка перекрываются,  копирова-
 ние производиться все равно корректно.
 
      Setmem устанавливает первые len байт блока adr в  значение
 value.
 
 
      3.42. PARSFNM
 
 
      Вызов:
 
  #include <dos.h>
  char *parsfnm(char *cmdline, struct fcb *fcbptr,
                int option);
 
 
                             - 60 -
 
 
 
 
 
      Функция разбирает строку, обычно командную строку, на  ко-
 торую указывает cmdline, для получения имени файла.  Имя  файла
 будет размещено в структуре  fcbptr.  Функция  использует  сис-
 темный вызов 0x29 для разбора имени файла. Смотрите Ваш  MS-DOS
 Programmer's Reference Manual для детального перечисления  воз-
 можныз значений параметра option.  Здесь  отметим,  что  option
 соответствует   значению  регистра  AL  указанного   систменого
 вызова.
 
      Если вызов прошел удачно, то функция возвращает  указатель
 следующего байта в строке после имени файла, в противном случае
 NULL.
 
 
      3.43. PEEK
 
 
      Вызов:
 
  #include <dos.h>
  int peek(int segment, unsigned offset);
  int peekb(int segment, unsigned offset);
 
      Функция peek возвращает значение слова памяти  по  адресу,
 заданного параметрами segment и offset.
 
      Функция peekb возвращает значение байта памяти по  адресу,
 заданного параметрами segment и offset.
 
 
      3.44. POKE
 
 
      Вызов:
 
  #include <dos.h>
  int poke(int segment, unsigned offset, int value);
  int pokeb(int segment, unsigned offset, char value);
 
      Функция poke устанавливает значение value слова памяти  по
 адресу, заданного параметрами segment и offset.
 
      Функция pokeb устанавливает значение value байта памяти по
 адресу, заданного параметрами segment и offset.
 
 
      3.45. POLY
 
 
      Вызов:
 
  #include <math.h>
  double poly(double x, int n, double c[]);
 
                             - 61 -
 
 
 
 
 
      Функция получает значение полинома в точке  x  степени  n,
 заданного коэффициентами c[0], c[1], ..., c[n].
 
 
      3.46. RANDBRD
 
 
      Вызов:
 
  #include <dos.h>
  int randbrd(struct fcb *fcbptr, int reccnt);
  int randbwr(struct fcb *fcbptr, int reccnt);
 
      Функция randbrd читает reccnt записей, используя  открытый
 FCB указатель fcbptr. Функция использует системный  вызов  0x27
 MS-DOS.
 
       Функция  randbwr  записывает  reccnt  записей,  используя
 открытый FCB указатель  fcbptr.  Функция  использует  системный
 вызов 0x28 MS-DOS.
 
      Функции возвращают следующие значения:
 
      - 0 - все записи считаны или записаны
 
      - 1 - для записи - нет свободного места, для чтения -  ко-
        нец файла означает конец последней записи
 
      - 2 - считываемая запись имеет  адрес  превышающий  0xFFFF
        (записей больше чем возможно считать).
 
      - 3 - конец файла не означает конец последней записи.
 
 
      3.47. SEARCHPATH
 
 
      Вызов:
 
  #include <dir.h>
  char *searchpath(char *filename);
 
      Функция используется для поиска  файла  filename.  Сначала
 файл ищется в текущем каталоге, если его здесь нет то ищется  в
 каталогах, которые  определены  в  переменной  окружения  PATH.
 Возвращается полное имя файла при удачном  поиске  и  NULL  при
 неудачном.
 
 
 
 
 
 
 
                             - 62 -
 
 
 
 
      3.48. SETCBRK
 
 
      ВЫЗОВ
 
      #include <dos.h>
      setcbrk (int value);
 
      ОПИСАНИЕ
 
      Функция устанавливает реакцию на символ control-break.
 
      Если значение value равно 0, то проверка выключается.
 
      Если значение value равно 1, то включается ( программа  по
 символу ctrl/c или ctrl/break прерывается ).
 
 
      3.49. SLEEP
 
 
      Вызов:
 
         #include <dos.h>
         unsigned sleep(unsigned seconds);
 
      Функция приостанавливает выполнение программы  на  seconds
 секунд.
 
 
      3.50. SSIGNAL
 
 
      Вызов:
 
          #include <signal.h>
          int *ssignal(int sig, int (*action)())();
          int gsignal(int sig);
 
      Функция ssignal аналогична функции signal MSC  V.4.  и  ОС
 ДЕМОС-2.
 
      Функция gsignal возвращает:
 
      - 1 - если для сигнала sig установлен SIG_IGN
 
      - 0 - если для сигнала sig  установлен  SIG_DFL  или  если
        указано неверное значение сигнала.
 
 
 
 
 
 
 
                             - 63 -
 
 
 
 
                                                      Приложение
 
 
             ОБЩИЕ СТАНДАРТНЫЕ ФУНКЦИИ MSC и Turbo-C
 
 
 
 
 
         abs
         assert
         bdos
         bsearch
         cabs
         cfil
         cgets
         chmod
         _clear87
         clearerr
         close
         cosh
         cprintf
         cputs
         create
         cscanf
         ctime, localtime, gmtime, asctime
         difftime
         dosexterr
         dup
         dup2
         ecvt
         eof
         execl
         execle
         execlp, execvp
         execlpe, execvpe
         execve
         _exit
         exit
         exp
         fabs
         fclose
         fcloseall
         fcvt
         fdopen
         feof
         ferror
         fflush
         fgetc
         fgetchar
         fgets
         filelength
         fileno
         floor
 
                             - 64 -
 
 
 
 
         flushall
         fmode
         _fmsize
         fopen
         fp_off, fp_seg
         _fpreset
         fprintf
         fputc
         fputchar(c) int c;
         fputs
         fread
         frexp
         fscanf
         fseek
         ftell
         ftime
         fwrite
         gcvt
         getc
         getenv
         getch
         getche
         getcwd
         gets
         getw
         hypot
         int86
         int86x
         intdos
         intdosx
         isalnum
         isatty
         itoa
         kbhit
         labs
         ldexp
         lfind-lsearch
         log
         log10
         longjmp
         lseek
         ltoa
         malloc
         matherr
         memccpy
         memchr
         memcpy
         memicmp
         memset
         mkdir
         mktmp
         modf
         movedata
         perror
 
                             - 65 -
 
 
 
 
         pow
         printf
         putc
         putch
         putchar
         putenv
         puts
         putw
         qsort
         rand
         rename
         rewind
         rmdir
         sbrk
         scanf
         segread
         setbuf
         setjmp
         setmode
         setvbuf
         sin
         sinh
         sqrt
         srand
         _status87
         strcat
         strchr
         strcmp
         strcmpi, stricmp
         strcpy
         strcspn
         strdup
         strerror
         strlen
         strlwr
         strncat
         strncmp
         strncpy
         strnicmp
         strnset
         strpbrk
         strrchr
         strrev
         strset
         strspn
         strstr
         strtod
         strtol
         strtok
         strupr
         swab
         system
         tan
         tanh
 
                             - 66 -
 
 
 
 
         tell
         time
         toascii-toupper
         tzset
         ultoa
         ungetc
         ungetch
         va_arg-va_start
         vfprintf-vsprintf
         write
