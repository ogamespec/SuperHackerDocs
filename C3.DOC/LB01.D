                                      - 54 -
               
            
                
                    ЧАСТЬ 2.  ОПИСАНИЕ  ФУНКЦИЙ  БИБЛИОТЕКИ  СИ
         
               
               ABORT
            
            #include <process.h>  требуется только для объявления
                                  функции
            #include <stdlib.h>   использует  либо  <process.h>,
                                  либо <stdlib.h>
            void abort();
         
               Описание.
               
               Функция  abort  распечатывает  сообщение  "Abnormal program
         termination" (аварийное (непредвиденное) завершение программы)  в
         stderr,  затем оканчивает вызванный процесс, возвращая управление
         процессу, который инициировал вызванный процесс (обычно  операци-
         онной системе). Функция abort не обновляет буферы потоков.
            
               Возвращаемое значение.
            
               Возвращается статус выхода 3 к parent-процессу  либо к опе-
         рационной системе.
               См.также  execl,  execle,  execip,  execlpe, execv, execve,
         execvp, execvpe, exit, _exit, signal, spawnl,  spawnle,  spawnlp,
         spawnlpe, spawnv, spawnve, spawnvp, spawnvpe.
            
               Пример:
            
            #include <stdio.h>
            
            main(args, argv)
            int argc;
            char *argv[];
            {
            FILE *stream;
            if ((stream=fopen(argv[argc-1],"r"))==NULL) {
               frpintf(stderr,
                       "%s couldn't open file %s\n", argv[0],
                       argv[argc-1]);
               abort();
               }
            
               /*  Замечание.  Имя программы хранится в argv[0] только для
         версии MS DOS 3.0 и старших; в ранних  версиях  argv[0]  содержит
         строку "С". */
            
               }
      
               Образец командной строки:
            
               update employ.dat
            
               На выходе:

                                      - 55 -
         
         
            
            C:\BIN\UPDATE.EXE  couldn't open file employ.dat.
            
               Abnormal program termination.
               (Непредвиденное завершение программы).
                
               ABS
            
            #include <stdlib.h>          требуется   только    для
                                         объявления функции
            int abs(n);
            int n;                       целое значение
            
               Описание.
            
               Функция  abs  возвращает  абсолютное значение своего целого
         аргумента n.
            
               Возвращаемое значение.
            
               Функция abs возвращает абсолютное значение своего  аргумен-
         та. Возвращаемого значения в случае ошибки нет.
               См. также cabs, fabs, labs.
            
               Пример:
            
            #include <stdlib.h>
            
            int x = -4, y;
            
            y = abs(x);
            printf("%d\t%d\n", x, y);.
            
               На выходе:
            
            -4       4.

      
               ACCESS
            
            #include <io.h>          требуется только для объявления
                                     функции
            
            int access(pathname, mode);
            char *pathname;          path-имя файла или директория
            int mode;                разрешенный доступ
                
               Описание.
            
               Для  файлов  функция  access определяет, существует или нет
         определенный файл, может ли он быть доступен  в  заданном  режиме
         mode.  Возможные  значения mode и их обозначения в вызовах access
         приведены ниже.
            

                                      - 56 -
         
         
            ЗНАЧЕНИЕ             СМЫСЛ ЗНАЧЕНИЯ
                           
                06         Проверка   на  доступ  по  чтению   и
                           записи
                           
                04         Проверка   на  доступ  по  чтения
                           
                02         Проверка   на  доступ  по  записи
                           
                00         Проверка   только на существование

            
               В MS DOS все существующие файлы имеют доступ по чтению, по-
         этому режимы 00 и 04 вырабатывают один и тот же результат. Анало-
         гично, режимы 06 и 02 являются эквивалентными, поскольку в MS DOS
         доступ по записи предполагает доступ по чтению.
               Для директориев access определяет, существуют или  нет  за-
         данные  директории;  под  управлением MS DOS все директории имеют
         доступ по чтению и записи.
            
               Возвращаемое значение.
            
               Функция access возвращает значение 0, если файл  имеет  за-
         данный  режим  mode.  Возвращаемое  значение -1 свидетельствует о
         том, что названный файл не существует или недоступен  в  заданном
         mode, и errno устанавливается в одно из следующих значений:
            
           ЗНАЧЕНИЕ                  СМЫСЛ ЗНАЧЕНИЯ
                           
            EACCES               Доступ  запрещен; установленный  статус
                                 для  файла  не допускает заданного  до-
                                 ступа
                           
            ENOENT               Файл или path-имя не найдено

            
               См.также chmod, fstat, open, stat.
            
               Пример:
            
            #include <io.h>
            #include <fcntl.h>
            
            int fh;
            .
            .
            .
            /* проверка доступа по записи */
            if ((access("data",2))==-1 {
                   perror("data file not writable");
                   exit(1);
                   }
                
            else
                   fh=open("data", O_WRONLY);
            

                                      - 57 -
         
         
      
               ACOS
                              
            #include <math.h>
            
            double acos(x);
            double x;
            
               Описание.
            
               Функция acos возврaщaет aрккосинус x в интервaле от 0 до n.
         Знaчение x должно быть между -1 и 1.
            
               Возврaщaемое знaчение.
            
               Функция acos возврaщaет результaт aрккосинусa. Если x мень-
         ше -1 или больше 1, acos устaнaвливaет errno в EDOM, печaтaет со-
         общение об ошибке DOMAIN в stderr и возврaщaет 0.
               Обрaботкa ошибок может быть  модифицировaнa  при  изменении
         процедуры matherr.
               См.тaкже asin, atan, atan2, cos, matherr, sin, tan.
            
               Пример:
            
               В следующем примере прогрaммa выдaет подскaзки для вводa до
         тех пор, покa введенное знaчение не будет в интервaле от -1 до 1.
            
            #include <math.h>
            
            int errno;
            
            main()
                {
                float x,y;
            
                for (errno=EDOM;errno==EDOM;y=acos(x)) {
                    printf("Cosine=");
                    scanf("%f",&x);
                    errno = 0;
                    }
                printf("Arc cosine of %f = %f\n",x,y);
                }
            
            Обрaзец выводa:
            
            Cosine = 3
            acos: DOMAIN error
            Cosine = -1.0
            Arc cosine of -1.000000 = 3.141593
            
      
               ALLOCA
            
            #include <malloc.h>    требуется только для объявления
                                   функции

                                      - 58 -
         
         
            
            char *alloca(size);
            unsigned size;         захваченные байты из стека
            
               Описание.
            
               Процедура alloca захватывает байты size из стека программы.
         Захваченное  пространство  автоматически освобождается при выходе
         из функции, вызвавшей alloca.
            
               Возвращаемое значение.
            
               Процедура alloca возвращает указатель char  на  захваченное
         пространство.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.  Чтобы
         получить  указатель на тип, отличный от char, используется преоб-
         разователь типа  возвращаемого  значения.  Возвращается  значение
         NULL, если пространство не было захвачено.
               См.также calloc, malloc, realloc.
            
               Предупреждение.  Значение указателя, возвращаемого процеду-
         рой alloca, не может быть аргументом для free. Так как alloca об-
         рабатывает стек, она должна использоваться только в простых  опе-
         раторах  выделения  и не должна использоваться в выражениях-аргу-
         ментах функций.
            
               Пример:
                      
            #include <malloc.h>
            int *intarray;
            
            /* захватывает память в стеке для 10 целых */
            
            intarray=(int*)alloca(10*sizeof(int));

      
               ASCTIME
            
            #include <time.h>
            
            char *asctime(time);
            struct tm *time;       указатель на структуру,
                                   объявленную в <time.h>
            
               Описание.
      
               Функция  asctime преобразует время, хранимое как структура,
         в символьную строку. Значение time обычно  получается  из  вызова
         gmtime  или  localtime, которые возвращают указатель на структуру
         tm, объявленную в <time.h> (cм. gmtime для описания полей  струк-
         туры  tm).  Результирующая строка, выработанная asctime, содержит
         26 символов и имеет форму, приведенную ниже в примере:
                
               Mon Jan 02 02:03:55 1980\n\0

                                      - 59 -
         
         
                
               Используется 24 часа. Все  поля  имеют  постоянную  ширину.
         Символ  новой строки ('\n') и нулевой символ ('\0') занимают  две
         последние позиции в строке.
            
               Возвращаемое значение.
            
               Функция asctime возвращает указатель на  символьную  строку
         результата. Возвращаемого значения в случае ошибки нет.
               См.также ctime, ftime, gmtime, localtime, time, tzset.
            
               Замечание. Функции asctime и ctime используют один и тот же
         статистически захваченный буфер для хранения в нем строки резуль-
         тата. Каждый вызов одной из этих  процедур  уничтожает  результат
         предыдущего вызова.
            
               Пример:
            
            #include <time.h>
            #include <stdio.h>
            
            struct tm *newtime;
            long ltime;
            .
            .
            .
            time(&ltime);  /*взять время в секундах*/
            newtime=localtime(&ltime); /*преобразовать к структуре
                                        tm  и  напечатать  местное
                                        время в виде строки*/
            printf("the current date and time are %s\n",
                 asctime(newtime));
            
      
               ASIN
           
            #include <math.h>
            
            double asin(x);
            double x;
            
               Описaние.
            
               Функция  asin вычисляет арксинус x в интервале -n/2 до n/2.
         Значение x должно быть между -1 и 1.
            
               Возвращаемое значение.
            
               Функция asin возвращает результат арксинуса. Если x  меньше
         -1  или больше 1, asin устанавливает errno в EDOM, печатает сооб-
         щение об ошибке DOMAIN в stderr и возвращает 0.
               Обрaботкa ошибок может быть  модифицировaнa  при  изменении
         процедуры matherr.
               См.тaкже acos, atan, atan2, cos, matherr, sin, tan.
            

                                      - 60 -
         
         
               Пример:
            
            #include <math.h>
            
            int errno;
            
            main()
            
               {
               float x,y;
               for (errno=EDOM; errno==EDOM; y=asin(x)) {
                    printf("Sine=");
                    scanf("%f", &x);
                    errno = 0;
                            }
               printf("Arc sine of %f\n",x,y);
               }
            
               На выходе:
            
            Sine = -1.001
            asin: DOMAIN error
            Sine = -1
            Arc sine of -1.000000=-1.570796
            
      
               ASSERT
            
            #include <assert.h>
            
            void assert(expression);
            
               Описание.
            
               Процедура  assert  печатает диагностическое сообщение и за-
         вершает вызванный процесс, если expression ложно,  0.  Диагности-
         ческое сообщение имеет форму:
            
            Assertion failed:  file <filename>, line <linenumber>,
           
         где filename  -  имя  исходного файла, linenumber - номер строки,
         которая ошибочна.
               Если expression истинно (ненулевое), никакого  действия  не
         выполняется.
               Процедура assert обычно используется для обнаружения  логи-
         ческих ошибок в программе. Выражение expression должно быть зада-
         но  таким образом, чтобы оно было истинным, если программа выпол-
         няется как намечено. После того  как  отлажена  программа,  может
         быть  использован специальный "no debug" идентификатор NDEBUG для
         удаления вызовов assert из программы. Если NDEBUG определен  (лю-
         бым  значением)  опцией  командной  строки  /D  или  с директивой
         #define, препроцессор языка Си удаляет все вызовы assert  из  ис-
         ходной программы.
            
               Возвращаемое значение.

                                      - 61 -
         
         
            
               Возвращаемого значения нет.
            
               Замечание. Процедура assert реализована как макро.
            
               Пример:
            
            #include <stdio.h>
            #include <assert.h>
            
            analyse_string (string)
            char *string;
            
            {
           /*  проверка строки перед обработкой  */
            
            assert (string != NULL);      /*  не может быть NULL,
                                            здесь   должна   быть
                                            строка */
            assert (*string != '\0');     /*    не   может   быть
                                             пустой */
            .
            .
            .
            }.
            
      
               ATAN - ATAN2
            
            #include <math.h>
            
            double atan(x);     вычисляет арктангенс x
            double x;
            
            double atan2(y,x);  вычисляет арктангенс y/x
            double x;
            double y;
            
               Описание.
            
               Обе  функции atan и atan2 возвращают результат арктангенса.
         Если оба аргумента atan2 равны 0, функция устанавливает  errno  в
         EDOM,  печатает  сообщение об ошибке DOMAIN в stderr и возвращает
         0.
               Обрaботкa ошибок  может  быть  модифицировaнa  при  исполь-
         зовaнии процедуры matherr.
               См.тaкже acos, asin, cos, matherr, sin, tan.
            
               Пример:
            
            #include <math.h>
            
            printf("%.7f\n", atan(1.0));            /* n/4 */
            printf("%.7f\n", atan2(-1.0,1.0));     /* -n/4 */
            

                                      - 62 -
         
         
               На выходе:
            
            0.7853982
            -0.7853982
            
      
               ATOF-ATOL
               
               #include <match.h>     Использует  либо <match.h>,
               #include <stdlib.h>    либо <stdlib.h>.
                                           
               double atof (string);  преобразует строку  string в
                                      double
            
               char *string           строка,  подлежащая преобра-
                                      зованию
               int atoi (string)      преобразует строку string  в
                                      int
            
               long atol (string)     преобразует строку string  в
                                      long
            
               char *string           строка, подлежащая  преобра-
                                      зованию
               
               Описание.
               
               Эти функции преобразуют символьную строку в значение с пла-
         вающей  точкой  двойной  точности (atof), в целое значение (atoi)
         или в длинное целое значение (atol).
               Исходная строка string  представляет  собой  последователь-
         ность  символов, которые могут быть интерпретированы как числовое
         значение определенного типа.
               Функция прекращает чтение исходной строки  как только  поя-
         вится  первый  символ,  который не может быть воспринят как часть
         числа (им может быть NULL-символ, завершающий строку).
               Функция atof предполагает, что строка string имеет  следую-
         щую форму:
               
               [whitespace][sign][digits][{d|D|E}[sign]digits]  ,
               
         где  [whitespase]  состоит из пробелов  и/или  знаков  табуляции,
         которые игнорируются; [sign] означает "+" или "-";  [digits]   -
         -  одна или несколько десятичных цифр. Если перед десятичной точ-
         кой нет цифр, то хотя бы одна цифра должна стоять после нее.  Де-
         сятичные  цифры  могут  следовать за показателем степени, который
         состоит из буквы (d,D,e или E) и десятичного целого со знаком.
               Функции atoi и atol не обрабатывают  десятичные  точки  или
         показатели степени. Аргумент string для этих функций имеет вид:
               
               [whitespace][sign]digits     ,
               
         где  whitespace,  sign,  digits обозначают то же, что и для atof.
               
               Возвращаемое значение.

                                      - 63 -
         
         
               
               Каждая из функций возвращает значение типа double, int  или
         long,  получаемое в результате интерпретации входных символов как
         чисел.
      
               Возвращаемое значение равно 0 (0L для atol), если  вход  не
         может  быть  преобразован  в  значение данного типа. Возвращаемое
         значение не определено в случае  переполнения.
               См. также ecvt, fcvt, gcvt.
                
               Пример:
           
               Следующие  примеры показывают, как числа, записанные в виде
         строк, могут быть преобразованы в числовые значения при использо-
         вании функций atof, atoi, atol:
               
               #include <math.h>
               
               extern long atol (\ );
               main (\ )
                     {
                     char *s;
                     double x;
                     int i;
                     long l;

                     s=" -2309.12E-15";
                     x=atof(s);
                     printf("%e\t",x);

                     s="7.8912654773d210";
                     x=atof(s);
                     printf("%e\t",x);

                     s="-9885";
                     i=atoi(s);
                     printf("%d\t",i);

                     s="98854 dollars";
                     l=atol(s);
                     printf("%ld\n",l);
                     }
      
               BDOS
            
            #include <dos.h>
            
            int bdos(dosfn, dosdx, dosal);
            int dosfn;                        номер функции
            unsigned int dosdx;               значение регистра DX
            unsigned int dosal;               значение регистра AL
            
               Описание.
            
               Функция bdos выполняет системный вызов MS DOS, номер  кото-

                                      - 64 -
         
         
         рого определен в dosfn, после размещения соответственно в регист-
         рах DX и AL значений dosdx и dosal. Функция bdos выполняет коман-
         ду INT 21H для осуществления системного вызова.
               Функция   bdos   задается  для  использования  при  вызовах
         DOS-системных вызовов, которые не принимают аргументов  или толь-
         ко принимают их в регистры DX(DH,DL) и/или AL.
            
               Возвращаемое значение.
            
               Функция bdos возвращает значение регистра AX,  запомненного
         системным вызовом.
               См.также intdos, intdosx.
            
               Замечание. Этот вызов не может использоваться для осуществ-
         ления системных вызовов, в которых указываются ошибки посредством
         установки  флага  переноса.  Т.к. Си-программы не имеют доступа к
         этому флагу, статус возвращаемого значения не может быть  опреде-
         лен. В этом случае используется функция intdos.
            
               Пример:
            
               В  следующем  примере выводится подсказка 9 функцией MS DOS
         (вывод строки). Поскольку значение регистра AL не является  необ-
         ходимым,  то  передается 0. Этот пример работает правильно только
         для малой и средней моделей памяти, так как bdos не меняет значе-
         ния сегментов регистров.
            
            #include <dos.h>
            
            char *buffer = "Enter file name :$";
            
            /* AL не является необходимым, поэтому передается 0 */
            
            bdos(9,(unsigned)buffer,0);

               BESSEL
            
            #include <math.h>
           
            double j0(x);
            
            double j1(x);
            
            double jn(n,x);
            
            double y0(x);

            double y1(x);
            
            double yn(n,x);
            
            double x;           значение с плавающей точкой
            int n;              целый порядок
            

                                      - 65 -
                        
               
               Описание.
          
               Процедуры j0, j1, jn вычисляют соответственно функции  Бес-
         селя первой степени порядка - 0, 1 и n.
               Процедуры  y0, y1, yn вычисляют соответственно функции Бес-
         селя второй степени порядка - 0,1 и n. Аргумент x должен быть по-
         ложительным.
            
               Возвращаемое значение.
      
               Эти функции возвращают результат функций Бесселя для x. Ес-
         ли x является отрицательным для y0, y1, yn, процедура  устанавли-
         вает errno в EDOM, печатает сообщение об ошибке DOMAIN в stderr и
         возвращает отрицательное значение HUGE.
               Обрaботкa  ошибок  может  быть модифицировaнa при изменении
         процедуры matherr.
               См.также matherr.
            
               Пример:
            
            #include <math.h>
            
            double x, y, z;
            .
            .
            .
            y = j0(x);
            z = yn(3,x);
            
      
               BSEARCH
            
            #include <search.h>    требуется только для объявления
                                   функции
            
            char *bsearch(key,base,num,width,compare);
            char *key;             ключ поиска
            char *base;            указатель  на  поисковую   базу
                                   данных
            unsigned num,width;    число и размер элементов
            int (*compare)();      указатель на функцию  сравнения
            
               Описание.
            
               Функция bsearch производит двоичный поиск в отсортированном
         массиве из num элементов, размер  каждого  элемента  равен  width
         байт.  Base  -  указатель на начало массива, key - значение ключа
         поиска.
               Аргумент compare является указателем на процедуру,  постав-
         ляемую  пользователем,  которая сравнивает два элемента массива и
         возвращает значение, определяющее их отношение. В течении  поиска
         функция  bsearch  может  вызывать процедуру compare один или нес-
         колько раз, передавая в каждом вызове указатели на  два  элемента
         массива. Процедура должна сравнивать элементы, а затем возвращать
         одно из следующих значений.
                

                                      - 66 -
         
         
              ЗНАЧЕНИЕ            СМЫСЛ ЗНАЧЕНИЯ
            
            меньше 0         element1 меньше, чем element2
                             
               0             element1 равен element2
                             
            больше 0         element1 больше, чем element2
                
            
               Возвращаемое значение.
            
               Функция  bsearch  возвращает  указатель на первое вхождение
         ключа key в массив, на который указывает base.
               Если key не найден, функция возвращает NULL.
               См. также lfind, lsearch, gsort.
            
               Пример:
            
               /* Функция bsearch производит двоичный поиск  в  отсортиро-
         ванном  массиве  для  элемента  "key"  и  возвращает указатель на
         структуру, в которой находится ключ key, или возвращает NULL, ес-
         ли ключа нет. */
            
            #include <search.h>
            #include <string.h>
            #include <stdio.h>
            int compare();
      
               /* должна быть объявлена как функция */
            
            main (argc, argv)
                 int argc;
                 char **argv;
                 {
            
                  char **result;
                  char *key = "PATH";
            
               /* следующий  оператор  находит  аргумент,  начинающийся  с
         "PATH", в предположении, что аргументы лексикографически отсорти-
         рованы */
            
                  result = (char **)bsearch((char *)&key,
                           (char *)argv, argc, sizeof(char *),
                           compare);
                  if (result)
                     printf ("%s found\n", *result);
                  else
                     printf("PATH not found!\n");
                 }
            
            int compare (arg1, arg2)
                char **arg1, **arg2;
            
                {

                                      - 67 -
         
         
                 return(strncmp(*arg1, *arg2, strlen(*arg1)));
                }.
            
               CABS
            
            #include <math.h>
          
            double cabs(z);
            struct  complex  z;  содержит  вещественную  и  мнимую
                                 части
            
               Описание.
            
               Функция  cabs  вычисляет  абсолютное  значение комплексного
         числа. Комплексное число должно быть структурой с типом  complex,
         объявленной в <math.h>, следующим образом:
            struct complex  {
                    double x,y;
                    };
            
               Вызов cabs эквивалентен следующему:
            
               sgrt(z.x*z.x + z.y*z.y)
               
               Возвращаемое значение.
            
               Функция cabs возвращает абсолютное значение как описано вы-
         ше.  При переполнении функция вызывает процедуру matherr, возвра-
         щает значение HUGE и устанавливает errno в ERANGE.
               См.также abs, fabs, labs.
            
               Пример:
            
            #include <math.h>
            
            struct complex value;
            double d;
            
            value.x = 3.0;
            value.y = 4.0;
            
            d = cabs(value);
            
      
               CALLOC
            
            #include <malloc.h>    требуется только для объявления
                                   функции
            
            char *calloc(n,size);
            unsigned n;            количество элементов
            unsigned size;         длина каждого элемента в байтах
            Описание
            
               Функция calloc захватывает пространство для хранения масси-

                                      - 68 -
         
         
         ва из n элементов, каждый длиной size байт. Каждый элемент иници-
         ализируется в 0.
            
               Возвращаемое значение.
            
               Функция calloc возвращает  указатель  char  на  захваченное
         пространство.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.  Чтобы
         получить  указатель на тип, отличный от char, используется преоб-
         разователь типа возвращаемого значения.
               Возвращается значение NULL, если осталось недостаточно  па-
         мяти.
               См.также free, haloc, hfree, malloc, realloc.
            
               Пример:
            
            #include <malloc.h>
            
            long *lalloc;
                 .
                 .
                 .
         /*  захватывает достаточное количество места для 40 длинных
         целых и инициализирует их в 0 */
            
            lalloc=(long*)calloc(40, sizeof(long));
                                                                
               
               CEIL
            
            #include <math.h>
            
            double ceil(x);
            double x;        значение с плавающей точкой
            
               Описание.
            
               Функция ceil возвращает значение double, представляющее на-
         именьшее целое, которое больше или равно x.
            
               Возвращаемое значение.
            
               Функция ceil  возвращает  double  результат.  Возвращаемого
         значения в случае ошибки нет.
      
               См.также floor, fmod.
            
            
               Пример:
           
            #include <math.h>
            
            double y;
            .

                                      - 69 -
         
         
            .
            .
            y = ceil(1.05);    /* y = 2.0 */
            y = ceil(-1.05);   /* y = -1.0 */

      
               CGETS
            
            #include <conio.h>   требуется только  для  объявления
                                 функции
            
           
            char *cgets(str);
            char *str;           память для хранения данных
            
            Описание.
                
               Функция  cgets читает строку символов прямо с консоли и за-
         поминает строку и ее длину в местоположении, указанном  str.  Str
         должно быть указателем на массив символов. Первый элемент массива
         -  str[0] должен содержать максимальную длину (в символах) читае-
         мой строки. Массив должен быть достаточно большим,  чтобы  содер-
         жать  строку, символ окончания '\0' и  два дополнительных  байта.
         Функция  cgets продолжает считывать символы, пока не будет прочи-
         тана  комбинация  "ВК-ПС"  или определенное количество  символов.
         Строка  запоминается,  начиная с str[2]. Если  комбинация "ВК-ПС"
         прочитана, перед  запоминанием  она  заменяется  нулевым символом
         '\0'.
               Функция  cgets во втором элементе массива str[1] запоминает
         действительную длину строки.
            
               Возвращаемое значение.
            
               Функция cgets возвращает указатель к началу строки, которая
         находится в str[2]. Возвращаемого значения в случае ошибки нет.
               См.также getch, getche.
            
               Пример:
            
            #include <conio.h>
            
            char *result;
            int numread;
            .
            .
            .
            *buffer=80; / *максимальное количество символов */
                        
            /* Внимание. *buffer эквивалентно *buffer[0] */
            
               /* следующие операторы вводят строку с клавиатуры и находят
         ее длину: */
            
                result=cgets(buffer);
                numread=buffer[1];

                                      - 70 -
         
         
                
               /* result указывает на строку, numread - на ее длину  ("ВК"
         не считается, т.к. заменяется нулевым символом */.

               CHDIR
            
            #include <direct.h>  требуется  только  для объявления
                                 функции
            
            int chdir(pathname);
            char *pathname;      path-имя  нового  рабочего дирек-
                                 тория
            
               Описание.
            
               Функция chdir изменяет текущий рабочий директорий на дирек-
         торий, определяемый по pathname; pathname должен ссылаться на су-
         ществующий директорий.
            
               Возвращаемое значение.
            
               Функция  chdir возвращает значение 0, если рабочий директо-
         рий успешно изменен. Возвращаемое значение -1 указывает на  ошиб-
         ку;  в  этом случае errno устанавливается в ENOENT, указывая, что
         заданное path-имя не может быть найдено. Ошибки не возникают, ес-
         ли pathname определяет текущий рабочий директорий.
               См.также mkdir, rmdir, system.
            
               Пример:
            
            #include <direct.h>
            
            /* следующий оператор изменяет текущий рабочий
            ** директорий на директорий корня   */
            
            chdir("/"); /* Замечание: эквивалентно chdir("\\") */
            
      
      
               CHMOD
         
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только для объявления
                                  функции
            
            int chmod(pathname,pmode);
            char *pathname;       path-имя существующего файла
            int pmode;            разрешенный доступ для файла
            
               Описание.
            
               Функция chmod изменяет разрешенный доступ для файла, задан-
         ного path-именем. Разрешенный доступ управляет чтением и  записью
         файла. Константное выражение pmode состоит из одной или обеих ма-

                                      - 71 -
         
         
         нифестных констант S_IWRITE и S_IREAD, определенных в <sys\stat.h>.
         Любое  другое  значение  для pmode игнорируется. Когда заданы обе
         константы, они объединяются логическим оператором ИЛИ (:). Значе-
         ния аргументов pmode представлены ниже.

            
            ЗНАЧЕНИЕ                      СМЫСЛ ЗНАЧЕНИЯ
            
            S_IWRITE                     разрешена запись
            
            S_IREAD                      разрешено чтение
            
            S_IREAD : S_IWRITE           разрешены чтение и запись
            
               Если разрешение на запись не задано, файл  доступен  только
         для  чтения.  В MS DOS все файлы доступны для чтения, поэтому не-
         возможно задание разрешения  только  на  запись.  Поэтому  режимы
         S_IWRITE и S_IREAD : S_IWRITE являются эквивалентными.
            
               Возвращаемое значение.
            
               Функция  chmod возвращает значение 0, если разрешенный дос-
         туп успешно изменен. Возвращаемое значение -1 свидетельствует  об
         ошибке;  в  этом случае errno устанавливается в ENOENT, указывая,
         что определенный файл не может быть найден.
               См.также access, creat, fstat, open, stat.
            
           
               Пример:
            
            #include <sys\types.h>
            #include <sys.stat.h>
            #include <io.h>
            int result;
            .
            .
            .
            result=chmode("data",S_IREAD);
               /* создать файл только для чтения */
            if (result==-1)
               perror("can't change file mode");
            
      
      
               CHSIZE
            
            #include <io.h>      требуется  только для  объявления
                                 функции
            
            int chsize(handle,size);
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            long size;           новая длина файла в байтах
            
               Описание.

                                      - 72 -
         
         
            
               Функция  chsize увеличивает или уменьшает файл, связанный с
         handle-ром, до размера, определяемого аргументом size. Файл  дол-
         жен  быть  открыт  в  режиме, который разрешает запись. Если файл
         увеличивается, к нему добавляются нулевые символы '\0'. Если файл
         уменьшается,  все  данные от конца укороченного файла до первона-
         чальной длины файла теряются.
            
               Возвращаемое значение.
            
               Функция chsize возвращает значение 0, если файл успешно из-
         менен.  Возвращаемое  значение  -1  свидетельствует  об ошибке  и
         errno устанавливается в одно из следующих значений:
                           
            ЗНАЧЕНИЕ             СМЫСЛ ЗНАЧЕНИЯ
                           
            EACCES         Заданный  файл  определен  только   для
                           чтения. Для версий MS DOS 3.0 и старших,
                           EACCES свидетельствует о принудительной
                           блокировке.(Определенный файл  заблоки-
                           рован для доступа)
                           
            EBADF          Неверный файловый handle
                           
            ENOSPC         На  устройстве не  осталось  свободного
                           места
            
               См.также close, creat, open.
            
               Пример:
            
            #include <io.h>
            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            
            #define MAXSIZE 32768L
            
            int fh, result;
            .
            .
            .
            fh=open("data", O_RDWR|O_CREAT, S_IREAD|S_IWRITE);
      
            .
            .
            .
            /* перед закрытием файла нужно убедиться, что он
            ** не длиннее 32К
            */
            if (lseek(fh,LO,2)>MAXSIZE)
               result=chsize(fh,MAXSIZE);
            
      
               _CLEAR87

                                      - 73 -
         
         
            
            #include <float.h>
            
            unsigned int _clear87();  получает  и  очищает слово
                                      статуса  плавающей точки
            
               Описание.
            
               Функция _clear87 получает и стирает слово статуса плавающей
         точки. Слово статуса плавающей точки является  комбинацией  слова
         статуса  8087/80287 и других состояний, обнаруживаемых 8087/80287
         handler-ом, таких как переполнение и потеря значимости стека пла-
         вающей точки.
            
               Возвращаемое значение.
            
               Биты в возвращаемом значении  обозначают  статус  плавающей
         точки.  Смотрите  include-файл <float.h> для полного описания би-
         тов, возвращаемых функцией _clear87.
               Замечание. Большинство из математических библиотечных функ-
         ций модифицирует слово статуса 8087/80287 с  непредсказуемым  ре-
         зультатом.  Возвращаемые  значения  функций  _clear87 и _status87
         становятся более достоверными после выполнения нескольких  опера-
         ций  с  плавающей  точкой  с известными состояниями слова статуса
         плавающей точки.
               См.также _control87, _status87.
            
               Пример:
            
            #include <stdio.h>
            #include<float.h>
            
            double a = 1e-40,b;
            float x,y;
            
            main()
              {
              printf("status=%.4x - clear\n",_clear87());
              y = a;
                
               /* запомненное в y является неточным и с потерянной  значи-
         мостью */
              printf("status=%.4xx - inexact, underflow\n",
                     _clear87());
              b = y;    /* y является неправильным */
              printf("status=%.4x - denormal\n", _clear87());
              }
            
      
               CLEARERR
            
            #include <stdio.h>
            void clearerr(stream);
            
            FILE  *stream;          указатель на структуру FILE

                                      - 74 -
         
         

               Описание.
            
               Функция  clearerr переустанавливает для потока stream инди-
         катор ошибки и индикатор конца файла (EOF) в 0. Индикаторы ошибок
         автоматически не очищаются; если для потока установлен  индикатор
         ошибки,  то операции над потоком будут возвращать значения ошибок
         до тех пор, пока функции clearerr или rewind не будут вызваны.
               См. также функции eof, feof, ferror, perror.
            
               Пример:
            
            #include <stdio.h>
            #include <stdlib.h>
            
            FILE *stream;
            int c;

               /* следующие операторы читают данные из потока и проверяют,
         возникла или нет ошибка при чтении. Перед  чтением  поток  должен
         быть предварительно открыт */.
            if ((c=getc(stream))==EOF)
            {  if (ferror(stream))
               {  fprintf(stderr, "write error\n");
                  clearerr(stream);
               }
            }
            
      
            CLOSE.
                    
            #include <io.h>     требуется  только  для  объявления
                                функции.
            int close(handle);
            int handle;         handle-р,  ссылающийся на открытый
                                файл.
            
               Описание.
            
               Функция   close  закрывает  все  файлы,  ассоциированные  с
         handle.
            
               Возвращаемое значение.
            
               Эта функция возвращает 0, если файл успешно закрыт. Возвра-
         щаемое значение -1 свидетельствует об ошибке; функция errno уста-
         навливается в EBADF, что свидетельствует о неправильном аргументе
         handle-ра файла.
               См. также chsize, creat, dup, dup2, open, unlink.
            
               Пример:
            
            #include <io.h>
            #include <fcntl.h>
            

                                      - 75 -
         
         
            int fh;
            
            fh = open("data", O_RDONLY);
            .
            .
            .
            close(fh);.
            
            
               _CONTROL87
            
            #include <float.h>
            
            unsigned int _control87(new,mask); получает слово уп-
                                               равления плавающей
                                               точки
            
            unsigned int new;                  новые    значения
                                               битов       слова
                                               управления
            
            unsigned int mask;                 устанавливаемая
                                               маска   для новых
                                               битов слова управ-
                                               ления
            
               Описание.
            
               Функция _control87 получает и устанавливает слово  управле-
         ния  плавающей  точки. Слово управления плавающей точки позволяет
         изменять в программе режимы точности, округления и  бесконечности
         для  математического пакета программ с плавающей точкой. Исключи-
         тельные состояния с плавающей точкой также можно маскировать  или
         размаскировать, используя для этого функцию _control87.
               Если  значение  для mask равно 0, тогда _control87 получает
         слово управления с плавающей точкой. Если mask  ненулевая,  уста-
         навливается  новое  значение для слова управления следующим обра-
         зом: для любого бита равного 1 в mask соответствующий бит  в  new
         используется для обновления слова управления словами. Это записы-
         вается так:
            
                fpcntrl=((fpcntrl & ~mask) : (new & mask)),
      
         где fpcntrl является словом управления с плавающей точкой.
            
                Возвращаемое значение.
            
               Биты  в возвращаемом значении обозначают состояние управле-
         ния с плавающей точкой. См. include-файл  <float.h>  для  полного
         описания битов, возвращаемых _control87.
               См.также _clear87, _status87.
            
            
            

                                      - 76 -
         
               Пример:
         
            #include <stdio.h>
            #include<float.h>

            double a = .1;
            
            main()
               {
               /* получает слово управления */
               printf("control=%.4x\n", _control87(0,0));
               printf("a*a=.01=%.15e\n",a*a);
            
               /* устанавливает точность в 24 бита */
               _control87(PC_24, MCW_PC);
               printf("a*a=.01(rounded to 24 bits)=%.15e\n",a*a);
            
               /* восстанавливает к первоначальному умолчанию */
               _control87(CW_DEFAULT, 0xffff);
               printf("a*a=.01=%.15e\n",a*a);
               }
            
      
               COS-COSH
            
            #include <math.h>
            
            double cos(x);      вычисляет косинус x
            double cosh(x);     вычисляет гиперболический косинус
                                x
            double x;           радиан
            
               Описание.
           
               Функции  cos и cosh возвращают соответственно косинус и ги-
         перболический косинус x.
            
               Возвращаемое значение.
            
               Функция cos возвращает косинус x. Если x большой, в резуль-
         тате может возникнуть частичная потеря значимости. В этом  случае
         cos  вырабатывает  ошибку PLOSS, но сообщения не печатает. Если x
         настолько большой, что теряется общая значимость  результата,  то
         cos печатает сообщение об ошибке TLOSS в stderr и возвращает 0. В
         обоих случаях errno устанавливается в ERANGE.
               Функция cosh возвращает гиперболический косинус x. Если ре-
         зультат  большой,  cosh  возвращает значение HUGE и устанавливает
         errno в ERANGE.
               Обрaботкa ошибок  может  быть  модифицировaнa  при  исполь-
         зовaнии процедуры matherr.
               См.также  acos, asin, atan, atan2, matherr, sin, sinh, tan,
         tanh.
            
               Пример:
            
            #include <math.h>
            

                                      - 77 -
         
         
            double x,y;
            .
            .
            .
            
            y = cos(x);
            y = cosh(x);
            
      
               CPRINTF
            
           #include <conio.h>      требуется только для объявления
                                   функции
           int cprintf(format-string[,argument...]);
           char *format-string;   строка управления форматом

               Описание.
            
               Функция cprints форматирует и печатает различные символы  и
         значения прямо на консоль, используя для выводимых символов функ-
         цию  putch.  Каждый  arguments (если он есть) преобразовывается и
         выводится  согласно  соответствующей   спецификации   формата   в
         format-string.  Format-string  имеет ту же самую форму и функцию,
         что и аргумент format-string для функции printf (См.описание фун-
         кции printf для получения подробной информации о format-string  и
         аргументах).
            
               Возвращаемое значение.
            
               Функция cprintf возвращает число напечатанных символов.
               См.также fprintf, printf, sprintf, vprintf.
               Замечание!  В отличии от функций sprintf, printf и sprintf,
         функция cprintf на выходе не транслирует символы ПС в  комбинацию
         "ВК-ПС".
            
               Пример:
      
            #include <conio.h>
            
            int i=-16, j=29;
            unsigned int k=511;
            
           /* следующий оператор напечатает i = -16, j = 0x1d, k = 511 */
            cprintf("i=%d, j=%#x, k=%u\n", i,j,k);
            
            
               CPUTS
            
            #include <conio.h>     требуется только для объявления
                                   функции
            
            void cputs(str);
            char *str;             указатель на выводимую строку
            

                                      - 78 -
         
         
               Описание.
            
               Функция  cputs  записывает  строку,  оканчивающуюся нулевым
         символом и на которую указывает str, прямо на консоль.
               Замечание. В строке комбинация "Возврат каретки  -  Перевод
         строки" после записи автоматически не появляется.
            
               Возвращаемое значение.
            
               Возвращаемого значения нет.
           
               См.также putch.
            
               Пример:
            
            #include <conio.h>
            
            char *buffer = "Insert data disk in drive a: \r\n";
            
            /* следующий оператор выводит подсказку на консоль */.
            
            cputs(buffer);.
            
               CREAT
            
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только для объявления
                                  функций.
                                  
            int creat(pathname, pmode);
            char *pathname;       path-имя нового файла
            int pmode;            разрешенный режим доступа
                          
               Описание.
            
               Функция creat либо создает новый файл, либо открывает и об-
         новляет  (усекает  до длины 0) существующий файл. Если существует
         файл, определяемый path-именем, то создается новый файл с  задан-
         ным  режимом  доступа и являющийся открытым для записи. Если файл
         существует и его режим доступа позволяет  запись,  тогда  функция
         creat  усекает файл к длине 0, уничтожая все содержимое, и однов-
         ременно открывает файл.
               Разрешенный режим доступа - pmode - применяется только  для
         вновь  созданных  файлов. Новый файл получает установленный режим
         доступа после первого его закрытия. Целое выражение pmode состоит
         из  одной  или  нескольких  манифестных  констант  -  S_IWRITE  и
         S_IREAD,  объявленных  в <sys\stat.h>. Если задаются обе константы,
         они объединяются при помощи логического OR (:). Значение аргумен-
         та pmode приводится ниже.
            
            КОНСТАНТА              СМЫСЛОВОЕ  ЗНАЧЕНИЕ
                                 
            S_IWRITE               разрешает запись
            
            S_IREAD                разрешает чтение

                                      - 79 -
         
         
            
            S_IREAD:S_IWRITE       разрешают чтение и запись
                                
               Если запись не разрешена, файл предназначен только для чте-
         ния. В MS DOS нельзя  разрешить  только  запись.  Поэтому  режимы
         S_IWRITE и S_IREAD: S_IWRITE являются эквивалентными.
               В версиях MS DOS 3.0 и старших файлы, открываемые при помо-
         щи  creat, всегда открываются в совмещенном режиме (compatibility
         mode).
               Функция creat перед установкой  флага  доступа  присваивает
         pmode маске доступа (подробно об этом смотрите umask).
            
               Возвращаемое значение.
            
               В  случае успешного вызова эта функция возвращает handle на
         созданный файл. Возвращаемое значение -1 свидетельствует об ошиб-
         ке; errno устанавливается в одно из следующих значений:
            
            
            ВОЗВРАЩАЕМАЯ              СМЫСЛОВОЕ  ЗНАЧЕНИЕ
            ВЕЛИЧИНА
      
            EACCES           Path-имя   определяет    существующий
                             файл   только   для    чтения     или
                             определяет директорий вместо файла
            
            EMFILE           другие  handle-ры  файла не пригодны,
                             т.к. много открытых файлов
            
            ENOENT           path-имя не найдено.
      
               См. также chmod, chsize, close,  dup,  dup2,  open,  sopen,
         umask.
               Замечание.  Процедура  create  обеспечивает  первоначальную
         совместимость с предыдущими библиотеками. Вызов open  при  помощи
         значений O_CREAT и O_TRUNC, определенных в аргументе oflag, явля-
         ется зквивалентным и предпочтительным для нового кода.
            
               Пример:
            
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>
            
            int fh;
            
            fh = creat("data", S_IREAD|S_IWRITE);
            
            if (fh == -1)
                perror("Couldn't create data file");.
            
            
            

                                      - 80 -
         
               CSCANF
         
            #include <conio.h>     требуется только для объявления
                                   функции
            
            int cscanf(format-string[,argument...]);
            char *format-string;   строка управления форматом
            
               Описание.
      
               Функция cscanf читает данные прямо с консоли в место, зада-
         ваемое  arguments  (если они есть), используя для чтения символов
         функцию getch. Каждый аргумент argument должен быть указателем на
         переменную с типом, который соответствует  определенному  типу  в
         format-string. Format-string управляет интерпретацией полей ввода
         и  имеет  ту же самую форму и функцию, что аргумент format-string
         для функции scanf (см. описание функции scanf для получения  под-
         робной информации о format-string).
            
               Возвращаемое значение.
            
               Функция  scanf  возвращает  число успешно преобразованных и
         назначенных полей. Возвращаемое значение не содержит прочитанных,
         но не назначенных полей. При попытке чтения конца файла возвраща-
         ется значение EOF. Возвращаемое значение 0 означает,  что  назна-
         ченных полей нет.
               См.также fscanf, scanf, sscanf.
            
               Пример:
            
            #include <conio.h>
            
            int result;
            char buffer [20];
            .
            .
            .
            cprintf("Please enter file name: ");
            
         /*  следующий  оператор  запоминает  введенную с клавиатуры
         строку */
            
            result = csanf("%19s", buffer);
            
         /* result - число верно введенных полей. Он равен  0,  если
         нет соответствия */
            
      
               CTIME
            
            #include <time.h>   требуется только для объявления
                                функции
            char *ctime(time);
            long *time;         указатель на хранимое время
            
           

                                      - 81 -
         
               Описание.
         
               Функция  ctime преобразует время, хранимое как long- значе-
         ние, в символьную строку. Значение time обычно получается из  вы-
         зова функции time, которая возвращает количество секунд, пройден-
         ных от значения времени по Гринвичу, т.е. с 1 января 1980 года.
               Строка  результата, выработанная по ctime, содержит 26 сим-
         волов и имеет форму, приведенную ниже в примере:
                
               Mon Jan 02 02:03:55 1980\n\0
                
               Используется 24 часа. Все  поля  имеют  постоянную  ширину.
         Символ  новой строки ('\n') и нулевой символ ('\0') занимают  две
         последние позиции в строке.
               В MS DOS даты раньше 1980 года  не  понимаются.  Если  time
         представляет дату перед 1 января 1980 года, ctime возвращает сим-
         вольную строку, представленную 00:00:00 January 1,1980.
            
               Возвращаемое значение.
            
               Функция ctime возвращает указатель на символьную строку ре-
         зультата. Возвращаемого значения в случае ошибки нет.
               См.также asctime, ftime, gmtime, localtime, time.
            
               Замечание. Функции asctime и ctime используют один и тот же
         статистически захваченный буфер для хранения в нем строки резуль-
         тата.  Каждый  вызов  одной из этих процедур уничтожает результат
         предыдущего вызова.
            
               Пример:
            
            #include <time.h>
            #include <stdio.h>
            
            long time;
            
            time(&ltime);
            printf("the time is %s\n",ctime(&ltime));
            
      
               DIIEEETOMSBIN-DMSBINTOIEEE
            
            
            #include <math.h>
            
            int dieeetomsbin(src8,dst8); преобразует число двойной
                                         точности формата  IEEE  к
                                         двоичному двойному форма-
                                         ту MS
            
            int dmsbintoieee(src8,dst8); преобразует число двойной
                                         точности в  формате  MS к
                                         числу в формате IEEE
            
               Описание.
            
               Процедура dieeetomsbin преобразует число двойной точности в

                                      - 82 -
         
         
         формате IEEE к двоичному формату Microsoft.
               Процедура dmsbintoieee преобразует число двойной точности в
         двоичном формате Microsoft к IEEE формату.
               Эти процедуры позволяют программам Си,  которые  записывают
         числа  с  плавающей точкой в формате IEEE, использовать численные
         данные в полях данных случайного доступа,  созданные  при  помощи
         Microsoft  BASIC,  который  записывает числа с плавающей точкой в
         двоичный формат Microsoft и наоборот.
               Аргумент  src8   является   указателем   на   преобразуемое
         double-значение.  Результат записывается в расположение, заданное
         аргументом dst8.
            
               Возвращаемое значение.
            
               Эти функции возвращают 0, если преобразование  было  успеш-
         ным, и 1 - если преобразование повлекло переполнение.
               См.также fieeetomsbin, fmsbintoieee.
            
               Замечание.  Эти процедуры не обрабатывают IEEE NAN и беско-
         нечность. Необычные IEEE трактуются в преобразованиях как 0.
            
      
               DIFFTIME
            
            
            #include <time.h>   требуется  только  для  объявления
                                функции
            
            double difftime(time2,time1);
            time_t time2;       тип time_t, объявленный в <time.h>
            
            
               Описание.
            
               Функция difftime вычисляет разность между time2 и time1.
            
            
               Возвращаемое значение.
            
               Функция difftime возвращает пройденное время в секундах  от
         time1 до time2 как число с двойной точностью.
               См.также time.
            
            
               Пример:
            
            #include <time.h>
            
            int mark[10000];
            
            main()
                {
               /*  это - пример употребления времени посредством использо-
         вания difftime. Она вычисляет, сколько времени ей  потребовалось,
         чтобы найти простые числа от 3 до 10000. Для вывода простого чис-

                                      - 83 -
         
         
         ла  уничтожается  самый  внешний цикл и комментарии ограничителей
         вокруг "printf("%d\t",n);"*/
            
                time_t start, finish;
                register int i, loop, n, num, step;
            
                time(&start);
                for(loop=0; loop<1000; ++loop)
                   for(num=0,n=3;n<10000;n+=2)
                      if(!mark[n]) {
                          /* printf("%d\t",n); */
                          step=2*n;
                          for(i=3*n;i<10000;i+=step)
                                mark[i]=-1;
                          ++num;
                          }
                time(&finish);
            
                /*  в "sieve" печается в среднем 1000 циклов */
            
      
                printf("\nProgram takes %f seconds to find %d
                       primes.\n",
                       difftime(finish,start)/1000,num);
                }
            
               На выходе:
            
            Program takes 0.482000 seconds to find 1228 primes.
            
      
               DOSEXTERR
            
            
            #include <dos.h>
            
            int dosexterr(buffer);
            struct DOSERROR *buffer;
            
               Описание.
            
               Функция dosexterr получает значение регистра, возвращаемого
         системным вызовом MS DOS 59H, и записывает это значение в  струк-
         туру,  на  которую  указывает  buffer. Эта функция полезна, когда
         системные вызовы вырабатываются в версиях MS DOS 3.0 и старших  и
         которые предлагают расширенную обработку ошибок.  Более  подробно
         системные  вызовы  MS DOS описаны в руководстве "Microsoft MS DOS
         Programmer's Reference Manual".
               Тип структуры DOSERROR объявлен в  <dos.h>  и  представляет
         следующее:
            
            struct DOSERROR {
                   int exterror;
                   char class;
                   char action;

                                      - 84 -
         
         
                   char locus;
                   };
            
               Аргумент  NULL-указателя посредством dosexterr определяет в
         AX возвращаемое значение.
            
               Возвращаемое значение.
            
               Функция dosexterr возвращает значение в регистр  AX  (иден-
         тично   значению в поле структуры exterror).
               См.также perror.
            
               Пример:
            
            #include <dos.h>
            #include <fcntl.h>
            #include <stdio.h>
            
            struct DOSERROR doserror;
            int fd;
            
            if ((fd=open("test.dat",O_RDONLY))==-1 {
               dosexterr(&doserror);
               printf("error=%d,class=%d,action=%d,locus=%d\n",
                       doserror.exterror, doserror.class,
                       doserror.action, doserror.locus);
               }
                
               
               DUP - DUP2
            
            #include <io.h>      требуется  только для  объявления
                                 функций

            int dup(handle);     создает   второй   handle-р   для
                                 открытого файла
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            
            int dup2(handle1, handle2);
                                 форсирует handle1 для  ссылки  на
                                 handle2 файла
            
            int handle1;         handle-р, ссылающийся на открытый
                                 файл
            int handle2;         любое значение handle
            
               Описание.
            
               Функции  dup и dup2 вызывают второй handle-р файла, связан-
         ный с  открытым  файлом.  Операции  в  файле  могут  пересылаться
         handle-ром, тогда как все handle-ры, связанные с заданным файлом,
         используют тот же самый указатель на файл. Создание нового handle
         не влияет на тип доступа файла.
               Функция dup возвращает следующий доступный handle-р для за-

                                      - 85 -
         
         
         данного  файла.  Функция  dup2 форсирует (force) заданный handle,
         т.е. handle2, чтобы сослаться на тот же самый  файл,  на  который
         ссылается handle1. Если во время вызова handle2 связан с открытым
         файлом, то этот файл закрывается.
            
               Возвращаемое значение.
            
               Функция  dup  возвращает новый handle-р файла. Функция dup2
         возвращает 0 в случае успеха. Если возникает ошибка, обе  функции
         возвращают  -1 и errno устанавливается в одно из следующих значе-
         ний.
            
            ВЕЛИЧИНА                 СМЫСЛОВОЕ  ЗНАЧЕНИЕ
            
            EBADF               Неверный handle-р файла
            
            EMFILE              Другие   handle-ры файла  для него
                                не доступны, т.к.  много  открытых
                                файлов

               См. также close, creat, open.
            

               Пример:
            
            #include <io.h>
            #include <stdlib.h>
      
            int fh;
            .
            .
            .
               /* выбирает другой handle-р файла, чтобы сослаться  на  тот
         же самый файл, на который указывает handle1 (stdout) */
            
            fh = dup(1);
            
            if (fh == -1)
               perror("dup(1) failure");
            
               /*  создает  handle3 файла для ссылки на тот же самый файл,
         на который ссылается handle 1 (stdout). Если handle3 файла  явля-
         ется также открытым, он закрывается первым */
            
            fh = dup2(1,3);
            
            if (fh != 0)
               perror("dup2(1,3) failure");.
            
      
               ECVT
               
            
               #include <stdlib.h>      требуется    только    для
                                        объявления функции

                                      - 86 -
         
         
               char *ecvt(value, ndigits, decptr,signptr);
               
               double value;            преобразуемое число
                                    
               int ndigits;             количество    запоминаемых
                                        цифр
            
               int *decptr;             указатель  на  запомненное
                                        положение десятичной точки
            
               int *signptr;            указатель  на  запомненный
                                        индикатор  знака
               
            
               Описание.
               Функция  ecvt  преобразовывает  число  с плавающей точкой в
         символьную строку. Value - это число с плавающей точкой,  которое
         должно быть преобразовано. Ecvt запоминает цифры ndigits из value
         как строку и добавляет к ней нулевой символ ('\0'). Если количество
         цифр в value превышает ndigits, последняя значащая цифра округля-
         ется. Если цифр меньше, чем ndigits, строка дополняется нулями.
               В  строке хранятся только цифры. Положение десятичной точки
         и знака в value может быть определено  после  вызова  функции  из
         decptr и signptr. Аргумент decptr указывает на целое число, опре-
         деляющее положение десятичной точки относительно начала строки. 0
         или  отрицательное значение означают, что десятичная точка распо-
         ложена левее первой цифры. Аргумент signptr указывает  на  целое,
         определяющее  знак  преобразуемого  числа.  Если signptr равно 0,
         число положительное, иначе - отрицательное.
               
            
               Возвращаемое значение.
               
               Функция ecvt возвращает указатель на строку цифр. В  случае
         ошибки возвращаемого значения нет.
               См.также atof, atoi, atol, fcvt, gcvt.
           
               Замечание.  Функции ecvt и fcvt используют для преобразова-
         ния один и тот же статически распределенный буфер. Каждое обраще-
         ние к одной из этих процедур уничтожает результат предыдущего об-
         ращения.
            
            
               Пример:
               
               #include <stdlib.h>
           
               int decimal, sign;
               char *buffer;
               int preciision=10;
               
      
               buffer=ecvt(3.1415926535,precision,&decimal,&sign);
                  /*буфер содержит "3141592654",decimal=1,sign=0*/
                                        

                                      - 87 -
         
         
               
               EOF
            
            #include <io.h>      требуется только  для  объявления
                                 функции
            
            int eof(handle);
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            
               Описание.
            
               Функция eof определяет достижение конца  файла  для  файла,
         ассоциированного с handle.
            
               Возвращаемое значение.
            
               Эта функция возвращает значение 1, если текущая позиция яв-
         ляется  концом файла; 0 - в противном случае. Возвращаемое значе-
         ние -1 свидетельствует об ошибке; errno устанавливается в  EBADF,
         инициируя при этом неверный handle файла.
               См. также clearerr, feof, ferror, perror.
            
               Пример:
            
            #include <io.h>
            #include <fgntl.h>
            
            int fh, count;
            char buf[10];
            
            fh = open("data", O_RDONLY);
            
               /* следующий оператор проверяет перед чтением условие конца
         файла */
            
            while (!eof(fh))
            { count = read(fh, buf, 10);
              .
              .
              .
              }.

      
               EXECL - EXECVPE
            
            
            #include  <process.h>       требуется    только    для
                                        объявления функций
            
            int execl(pathname, arg0, arg1 ... ,argn, NULL);
            
            int execle(pathname, arg0, arg1 ... ,argn, NULL, envp);
            
            int execlp(pathname, arg0, arg1 ... ,argn, NULL);

                                      - 88 -
         
         
            
            int execlpe(pathname, arg0, arg1 ... ,argn, NULL, envp);
            
            int execv(pathname, argv);
            
            int execve(pathname, argv, envp);
            
            int execvp(pathname, argv);
            
            int exevpe(pathname, argv, envp);
            
            char *pathname;                 path-имя  выполняемого
                                            файла
            char *arg0, *arg1, ..., *argn;  список  указателей  на
                                            аргументы
            char *argv[];                   массив  указателей  на
                                            аргументы
            char *envp[];                   массив  указателей  на
                                            установленное  окруже-
                                            ние
               Описание.
            
               Функции  exec  загружают  и  выполняют новый child-процесс.
         Когда вызов произошел успешно, child-процесс размещается в  памя-
         ти,  занятой  вызвавшим  процессом.  Для  загрузки  и  выполнения
         child-процесса должно быть доступно достаточно памяти.
               Pathname может определять полный  path  (из  корня),  часть
         path (из текущего рабочего директория) или просто имя файла.
               Если pathname не имеет расширения для имени файла  или если
         оно не заканчивается точкой (.), тогда функции exec устанавливают
         расширение  .EXE. Если pathname имеет расширение, то используется
         только это расширение. Если pathname заканчивается  точкой,  exec
         осуществляет  поиск  pathname  без  расширения. Процедуры execlp,
         execlpe, execvpe осуществляют поиск для pathname (используя те же
         самые процедуры) в директориях, определенных переменной окружения
         PATH.
               Аргументы для нового процесса передаются  как  аргументы  в
         вызове exec путем задания одного или более указателей на символь-
         ные  строки. Эти символьные строки образуют список аргументов для
         child-процесса. Общая длина строк, определяющая список аргументов
         для нового процесса, не может превышать 128 байтов. Нулевой  сим-
         вол окончания '\0 'для  каждой строки в эту длину не засчитывает-
         ся,а символы пробела (автоматически вставляемые для аргументов) -
         засчитываются.
               Указатели аргументов могут передаваться как отдельные аргу-
         менты  (в execl, execle, execlp, execlpe) или как массив указате-
         лей (в execv, execve, execvp, execvpe). По крайней мере один  ар-
         гумент  -  arg0 или argv[0] - должен быть передан child-процессу.
         По соглашению этот аргумент является копией  аргумента  pathname.
         (Другое  значение  не  будет воспринято как ошибка). В версиях MS
         DOS, ранних от 3.0, передаваемое значение arg0 или argv[0]  явля-
         ется не доступным для использования в child-процессе. Однако, для
         версий  MS  DOS  3.0  и  старших   pathname доступно как arg0 или
         argv[0].
               Вызовы execl, execle, execlp, execlpe  обычно  используются

                                      - 89 -
         
         
         тогда,  когда  количество  аргументов  известно заранее. Аргумент
         arg0 обычно является указателем на pathname. Аргументы от arg1 до
         argn указывают на символьные строки, образующие новый список  ар-
         гументов. Идущий за аргументом argn NULL-указатель определяет ко-
         нец списка аргументов.
               Обычно  вызовы  execv, execve, execvp, execvpe используются
         тогда, когда число аргументов для нового процесса является  пере-
         менным.  Указатели на аргументы пересылаются как массив argv. Ар-
         гумент argv[0] обычно является указателем на pathname.  Аргументы
         от  argv[1] до argv[n] указывают на символьные строки, образующие
         новый список аргументов. Аргумент argv[n+1] должен быть NULL-ука-
         зателем для определения конца списка аргументов.
               Файлы, открытые до вызова exec, остаются открытыми и в  но-
         вом  процессе.  В вызовах execl, execlp, execv, execvp child-про-
         цесс наследует окружение parent-процесса. Вызовы execle, execlpe,
         execve, execvpe позволяют  пользователю  изменять  окружение  для
         child-процесса,  передавая  список установленного окружения через
         аргумент envp.
               Аргумент envp является массивом указателей на char,  каждый
         элемент  которого (исключая последний элемент) указывает на стро-
         ку, которая заканчивается нулем и определяет  переменную  окруже-
         ния. Обычно эта строка имеет форму:
            
               NAME = value   ,
            
         где  NAME -  имя  переменной  окружения,  value  - значение стро-
         ки  (заметим, что  value не заключается в кавычки "..."). Послед-
         ним элементом массива envp должен быть NULL.
               Если значением envp является NULL, child-процесс  наследует
         установленное окружение parent-процесса.

               Возвращаемое значение.
            
               Функции  exec  не  имеют  нормального возврата в вызывающий
         процесс. Если из функции exec происходит возврат, то это означает
         ошибку и возвращаемое значение равно  -1.  Переменная  errno  при
         этом устанавливается в одно из следующих значений:
            
            
            ЗНАЧЕНИЕ               СМЫСЛ ЗНАЧЕНИЯ
      
            
            E2BIG          Список аргументов превышает  128  байт,
                           или    пространство,    требуемое   для
                           информации окружения, превышает 32К
                           
            EACCES         Блокировка  или  разделение файла  (для
                           версий 3.0 и старших)
                           
            EMFILE         Много  открытых файлов (специфицирован-
                           ный файл должен  быть  открыт,    чтобы
                           начать его выполнение)
                           
            ENOENT         Файл или path-имя не найдено
                           

                                      - 90 -
         
         
            ENOEXEC        Заданный файл  не является  выполняемым
                           или имеет неверный формат
                           
            ENOMEM         Доступной   памяти  не  достаточно  для
                           выполнения child-процеса; или доступная
                           память    является   запорченной;   или
                           существуют неверные блоки, указывающие,
                           что parent-процесс неверно размещен

               См.  также  abort,  exit,  _exit,  onexit, spawnl, spawnle,
         spawnlp, spawnlpe, spawnv, spawnve, spawnvp, spawnvpe, system.
               Замечание. Вызовы exec не сохраняют текстовый режим  преоб-
         разования  для открытых файлов. Если child-процесс должен исполь-
         зовать файлы, унаследованные  от  parent-процесса,  тогда  должна
         быть  использована процедура setmode для установки требуемого ре-
         жима преобразования для этих файлов.
               Установки сигналов прерывания не сохраняются  в  child-про-
         цессе,  созданном вызовом процедуры exec. Эти установки переуста-
         навливаются по умолчанию в child-процессе.
            
               Пример:
               
            #include <process.h>
            #include <stdio.h>
            
            extern char **environ;
            
            char *args[4];
            int result;
            
            args[0] = "child";
            args[1] = "one";
            args[2] = "two";
            args[3] = NULL;
               
               /*  все  следующие  операторы  позволяют выполнять процесс,
         названный "child.exe", и передать ему три аргумента. */
            
            
            result = execl("child.exe", "child", "one", "two",
                           NULL);
            result = execle("child.exe", "child", "one", "two",
                           NULL, environ);
            result = execlp("child.exe", "child", "one", "two",
                           NULL);
            result = execv("child.exe", args);
            result = execve("child.exe", args, environ);
            result = execvp("child.exe", args);.
            
      
               EXIT - _EXIT
            
            #include <process.h>   требуется только для объявления
                                   функции
            #include <stdlib.h>    использует  либо  <process.h>,

                                      - 91 -
         
         
                                   либо <stdlib.h>
            
            void exit(status);     завершает процесс  после закры-
                                   тия файла
            
            void _exit(status);    завершает процесс  без обновле-
                                   ния буферов потока
            int status;            статус выхода
            
            
               Описание.
            
               Функции exit и _exit завершают вызванный процесс. Перед за-
         вершением  процесса функция exit обновляет все буферы и закрывает
         все открытые файлы. Функция _exit завершает все процессы без  об-
         новления буферов потока. Значение status обычно устанавливается в
         0  для указания нормального выхода и устанавливается в любое дру-
         гое значение для определения  ошибки.  Поскольку  вызовы  exit  и
         _exit  не возвращают значения, младший байт status является возв-
         ратом для ожидающего parent-процесса. Если  нет  parent-процесса,
         то значение status теряется.
            
               Возвращаемое значение.
            
               Возвращаемого значения нет.
               См.также  abort,  execl,  execle,  execlp,  execv,  execve,
         execvp,  onexit,  spawnl,  spawnle,  spawnlp,  spawnv,   spawnve,
         spawnvp, system.
            
               Пример:
            
            #include <process.h>
            #include <stdio.h>
            
            FILE *stream;
            .
            .
            .
            
               /*  следующие  операторы вызывают завершение процесса после
         обновления буферов и закрытия открытых файлов */
            
            if((stream=fopen("data","r"))==NULL) {
                fprintf(stderr,"couldn't open data file\n");
                exit (1);
                }
               /* следующие операторы вызывают немедленное завершение про-
         цесса, если файл не может быть открытым */
            
            if((stream=fopen("data","r"))==NULL)
             
                {
      
                fprintf(stderr,"couldn't open data file\n");
                _exit (1);
               
                }
               

                                      - 92 -
         
               
               EXP
            
            
            #include <math.h>
            
            double exp(x);
            double x;          значение с плавающей точкой
            
               Описание.
                
               Функция exp возвращает экспоненциальную функцию своего  ар-
         гумента x с плавающей точкой.
                
               Возвращаемое значение.
            
               Функция exp возвращает e в степени x. При переполнении фун-
         кция  возвращает  HUGE и устанавливает errno в ERANGE, при потере
         значимости exp возвращает 0, но не устанавливает errno.
               См.также log.
            
               Пример:
            
            #include <math.h>
            
            double x,y;
            .
            .
            .
            y = exp(x);.
            
      
      
               _EXPAND
            
            
            #include <malloc.h>    требуется только для объявления
                                   функции
            
            char *_expand(ptr,size);
            char *ptr;             указатель на ранее  захваченный
                                   блок памяти
            unsigned size;         новый размер в байтах
            
            
               Описание.
            
               Функция _expand изменяет размер  ранее  захваченных  блоков
         памяти,  пытаясь  расширить  или сузить блок без передвижения его
         местоположения в heap.
               Аргумент ptr указывает на начало блока. Аргумент size зада-
         ет новый размер блока в байтах. Содержимое блоков не изменяется.
               Аргумент ptr также указывает на освобождающийся блок до тех

                                      - 93 -
         
         
         пор, пока не будут внешне вызваны calloc, _expand, halloc, malloc
         или realloc, либо пока блок будет свободен.
               Если ptr указывает на освобожденный блок, то этот блок  ос-
         тается свободным и после вызова _expand.
            
               Возвращаемое значение.
            
               Функция  _expand возвращает char-указатель на перезахвачен-
         ный блок памяти. В отличии от realloc, _expand не может  передви-
         гать  блок и изменять его размеры. Это означает, что аргумент ptr
         для _expand является тем же самым, что и  возвращаемое  значение,
         если  памяти  достаточно, чтобы расширить блок без его передвиже-
         ния.
               Возвращается значение NULL, если  памяти  недостаточно  для
         расширения блока. В этом случае объект, на который указывает ptr,
         будет расширен настолько, насколько позволяет его расположение.
               В  памяти,  на которую указывает возвращаемое значение, га-
         рантировано выравнивание для хранения любого типа объекта.
               Новый размер объекта может быть проверен функцией _msize.
               Чтобы получить указатель, тип которого отличен от char, ис-
         пользуется преобразователь типа возвращаемого значения.
               См.также calloc, free, halloc, malloc, _msize, realloc.
            
            
               Пример:
            
            #include <stdio.h>
            #include <malloc.h>
            
            main()
               
              {
               long *oldptr;
               unsigned int newsize=64000;
            
               oldptr=(long*)malloc(10000*sizeof(long));
               printf("Size of memory block pointed to by
                      oldptr=%u\n", _msize(oldptr));
            
               if (_expand(oldptr,newsize)!= NULL)
                 printf("expand was able to increase block
                        to %u\n", _msize(oldptr));
            
               else
                printf("expand was able to increase block to
                       only %u\n", _msize(oldptr));
               }

                      

