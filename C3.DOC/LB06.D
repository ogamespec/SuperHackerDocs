                                      - 238 -
                                        
 
            
               Пример:
            
            #include <stdlib.h>
            #define NBYTES  1024
            
            char from[NBYTES],  to [NBYTES];
            
               /*  копирует  n байтов из одного расположения в другое, пе-
         реставляет (обменивает) каждую пару смежных байтов */
            
            swab(from, to, NBYTES);.
      
            
               SYSTEM
                
            #include <process.h>   требуется только для объявления
                                   функции
            #include <stdlib.h>    использует  либо  <process.h>,
                                   либо <stdlib.h>
            
            int system(string);
            char *string;          выполняемая команда
            
                
               Описание.
            
               Функция  system передает заданную строку string к интерпре-
         татору команд и обрабатывает эту строку как команду MS DOS. Функ-
         ция system ссылается на переменные окружения COMSPEC и PATH, что-
         бы расположить файл COMMAND.COM, который используется при  выпол-
         нении команды string.
            
                
               Возвращаемое значение.
            
               Если  string  успешно отработала, функция system возвращает
         значение 0. Возвращаемое значение -1 свидетельствует об ошибке  и
         errno устанавливается в одно из следующих значений:
                
            ЗНАЧЕНИЕ                        ЕГО СМЫСЛ

          E2BIG            Список аргументов для команды превышает
                           128 байтов, или пространство, требуемое
                           для информации окружения, превышает 32К.
                           
          ENOENT           COMMAND.COM не может быть найден.
                 
          ENOEXEC          Файл   COMMAND.COM   не   может    быть
                           выполненным и имеет неверный формат.
                           
          ENOMEM           Для выполнения child-процеса памяти  не
                           достаточно, или эта  память    является
                           запорченной,  или  существуют  неверные
                           блоки, указывающие,  что parent-процесс
                           не захвачен.
               

                                      - 239 -
         
         

               См. также execl, execle,  execlp,  execv,  execve,  execvp,
         exit, _exit, spawnl, spawnle, spawnlp, spawnlpe, spawnv, spawnve,
         spawnvp.
      
               Пример:
            
            #include <process.h>
            
            int result;
      
            
               /* следующий оператор добавляет номер версии DOS к log фай-
         лу */
            
            result = system("ver >> result.log");
      
      
            
            TAN-TANH
              
            #include <math.h>
            
            double tan(x);       вычисляет тангенс x
            double tanh(x);      вычисляет гиперболический тангенс x
            double x;            радиан
            
               Описание.
            
               Функции  tan  и tanh вычисляют соответственно тангенс и ги-
         перболический тангенс x.
           
               Возвращаемое значение.
            
               Функция tan возвращает тангенс x. Если x большой,  при  вы-
         числениях  может  возникнуть  частичная потеря значимости. В этом
         случае tan вырабатывает ошибку PLOSS, но сообщения  не  печатает.
         Если x настолько большой, что общая значимость результата теряет-
         ся, тогда tan печатает сообщение об ошибке TLOSS в stderr и возв-
         ращает 0. В обоих случаях errno устанавливается в ERANGE.
               Функция  tanh возвращает гиперболический тангенс x. Возвра-
         щаемого значения в случае ошибки нет.
               См.также acos, asin, atan, atan2, cos, cosh, sin, sinh.
            
               Пример:
            
            #include <math.h>
            
            double pi,x,y;
                
            pi = 3.1415926535;
            x = tan(pi/4.0);     /* x равен 1.0 */
            y = tanh(x);         /* y равен 1.6 */
            

                                      - 240 -
         
         
      
            
               TEMPNAM - TMPNAM
            
            #include <stdio.h>
            
            char *tmpnam(string);
            char *string;            указатель на временное имя.
            
            char *tempnam(dir, prefix);
            char *dir;
            char *prefix;
            
               Описание.
            
               Функция tmpnan генерирует имя  временного  файла.  Это  имя
         хранится  в  string.  Если string является NULL, память для строк
         размещается посредством функции malloc. При этом, если  использо-
         валась функция malloc, пользователь сам является ответственным за
         освобождение памяти.
               Символьная  строка, созданная по tmpnam, состоит из цифр от
         "0" до "9"; численное значение этой строки может изменяться от  1
         до 65535.
               Функция  tempnam  позволяет  пользователю создать временный
         файл в другом директории. Prefix является приставкой к имени фай-
         ла. Эта функция рассматривает файл с заданным именем в других ди-
         ректориях, расположенных в порядке старшинства.
            
            
                   УСЛОВИЕ                ИСПОЛЬЗУЕМЫЙ ДИРЕКТОРИЙ
           
         Устанавливается    переменная   Директорий,  определяемый
         окружения  TMP,  и существует   по ТМР.
         директорий,  определяемый  по
         TMP.
        
         Переменная  окружения  TMP не   Аргумент dir для  tempnam.
         устанавливается     или    не
         существует        директорий,
         определяемый по TMP.
        
         Аргумент  dir  является  NULL   P_tmpdir  в <stdio.h>.
         или  dir  является  именем не
         существующего директоия.
        
         Не существует P_tmpdir.         \tmp.
            
               Если все это отсутствует, tempnam возвращает значение NULL.
            
               Возвращаемое значение.
            
               Эти функции возвращают указатель  на  сгенерированное  имя,
         если  есть  возможность создать это имя, или если имя не является
         единственным (уникальным). Если имя не может быть создано или оно
         всегда существует, функции tmpnam и tempnam  возвращают  значение

                                      - 241 -
         
         
               NULL
      
               См. также tmpfile.
            
               Пример:
            
            #include <stdio.h>
            
            main ()
            {
            char *name1, *name2;
            
            if ((name1 = tmpnam(NULL)) != NULL)
               printf("%s is safe to use as a temporary file.\n",
                      name1);
            else
               printf("cannot create a unique file name\n");
            
            if ((name2 = tempnam("a:\\tmp", "stq")) != NULL)
               printf("%s is safe to use as a temporary file.\n",
                      name2);
            else
               printf("cannot create a unique file name\n");
            }.
      
            
            
               TELL
            
            #include <io.h>    требуется  только  для  объявления
                               функции
            long tell(handle);
            int handle;        handle-р,  ссылающийся на открытый
                               файл
            
               Описание.
            
               Функция  tell берет текущую позицию указателя на файл (если
         он есть), связанного с handle. Позиция выражается как число  бай-
         тов от начала файла.
            
               Возвращаемое значение.
            
               Функция  tell возвращает текущую позицию. Возвращаемое зна-
         чение -1L указывает на ошибку  и errno устанавливается  в  EBADF,
         которое определяет неверный аргумент handle-ра файла. Для устрой-
         ств,  не  приспособленных к поиску (таких как терминалы и принте-
         ры), возвращаемые значения не определены.
               См.также ftell, lseek
            
               Пример:
            
            #include<io.h>
            #include<stdio.h>
            #include<fcntl.h>

                                      - 242 -
         
         
            int fh;
            long position;
            
            fh = open ("data", O_RDONLY);
            .
            .
            .
            position = tell (fh);
            /* запоминает текущую позицию */
            .
            .
            .
            lseek (fh, position,0);
            /* находит предыдущую позицию */
      
      
            
            
               TIME
            
            #include <time.h>  требуется только для объявления
                               функции
            long time(timeptr);
            long *timeptr;     память для хранения времени
            
               Описание.
            
               Функция time в соответствии с системными часами  возвращает
         количество  секунд,  прошедших  от  00:00:00  значения времени по
         Гринвичу,т.е. с 1 января 1980 года. Возвращаемое значение хранит-
         ся в расположении, заданном по timeptr. Если возввращаемое значе-
         ние не запомнено, timeptr является NULL.
            
            
               Возвращаемое значение.
      
               Функция time возвращает пройденное время (в секундах). Воз-
         вращаемого значения нет.
               См.также asctime, ftime, gmtime, localtime, utime.
            
               Пример:
            
            #include <time.h>
            #include <stdio.h>
            
            long ltime;
            
            time(&ltime);
            printf("the time is %s\n", ctime(&ltime));
            
      
      
            
               TMPFILE
            

                                      - 243 -
         
         
            #include <stdio.h>
            
            FILE *tmpfile();           значение,   указывающее  на
                                       структуру   типа   FILE.
            
               Описание.
            
               Функция tmpfile создает временный файл и возвращает  указа-
         тель  на  этот  файл.  Если  файл  не  может быть открыт, функция
         tmpfile возвращает указатель NULL. Этот временный файл  автомати-
         чески удаляется, когда программа заканчивается нормально  или ес-
         ли вызвана функция rmtmp, а текущий рабочий директорий не был из-
         менен.
               Временный файл открывается в режиме "w".
            
               Возвращаемое значение.
            
               Эта функция возвращает указатель на поток. Если файл не от-
         крывается - возвращается NULL-указатель.
               См. также tmpnam, tempnam, rmtmp.
            
               Пример:
            
            #include <stdio.h>
      
            FILE *stream;
            char tmpstring[] = "String to be temporary written".
            
            main ()
            
            {
            if ((stream = tmpfile()) == NULL)
                perror("Couldn't make temporary file");
            else
                fprintf(stream, "%s", tmpstring);
            }.
                                                                  
               
            
               TOASCII-_TOUPPER
           
            #include <ctype.h>
            int toascii(c)        преобразует "c"  в  символ  ASCII
            
            int tolower(c)        преобразует  "c" в символ верхнего
                                  регистра   (в   строчную букву),
                                  если это возможно
            
            int _tolower(c)       преобразует "c"  в строчную  букву
            
            int toupper(c)        преобразует "c"  в символ  нижнего
                                  регистра (прописную букву), если
                                  это возможно
            
            int _toupper(c)       преобразует "c"  в символ  нижнего

                                      - 244 -
         
         
                                  регистра
            
            int c;                преобразуемый символ
               
               
               Описание.
                
               Макро toascii, tolower, toupper и _toupper преобразуют сим-
         вол "c" так, как описано ниже.
               Макро toascii устанавливает первые 7 битов "c" в нуль  так,
         что  преобразованное  значение  соответствует символу ASCII. Если
         "c" уже соответствует ASCII, то он не изменяется.
               Макро tolower преобразует "c" в строчную  букву,  если  "c"
         соответствует прописной литере. Иначе - "c" не изменяется.
               Макро  _tolower  является  версией  tolower, использующейся
         только тогда, когда "c" - прописная буква. Если это не  так,  ре-
         зультат выполнения _tolower не определен.
               Макро toupper преобразует "c" в строчную букву, если "c" не
         является строчной буквой. Иначе - "c" не изменяется.
               _Toupper является версией toupper, используемой только тог-
         да,  когда  "c"  -  строчная буква. Если "c" не является строчной
         буквой, то результат не определен.
               
               Возвращаемое значение.
               
               Макро toascii, tolower, toupper и _toupper возвращают  пре-
         образованный  символ  "c". Возвращаемого значения в случае ошибки
         нет.
               См.также   isalnum,  isalpha,  isascii,  iscntrl,  isdigit,
         isgraph, islower, isprint, ispunct, isspace, isupper, isxdigit.
               
               Замечание. Эти  процедуры  реализуются  как  макро.  Однако
         tolower  и  toupper  также реализуются и как функции, т.к. версии
         макро некорректно обрабатывают аргументы с  побочными  эффектами.
         Версии функций могут быть использованы, если удалить макроопреде-
         ления  директивой #undef или не подключать <ctype.h>. Определения
         функций tolower и toupper даны в <stdlib.h>.
               
               Пример:
               
               #include <stdio.h>
               #include <ctype.h>
               int ch;
               
               /*следующие операторы анализируют все
         **символы между кодами 0х0 и 0х7f.
         **Макро toupper и tolower применяются
         **для  любых кодов.  _Toupper и _tolower
         **применяются только для кодов, имеющих
         **смысл */
               
               for (ch=0; ch<=0x7f; ch++)  {
                   printf (" toupper=%#04x", toupper (ch));
                   printf (" tolower=%#04x", tolower (ch));
               

                                      - 245 -
         
         
                   if (islower(ch))
                      printf(" _toupper=%#04x", _toupper(ch));
                   if (isupper(ch))
                      printf("_tolower=%#40x", _tolower(ch));
                   putchar ('\n');
                   }
            
      
            
               TZSET
            
            #include <time.h>  требуется только для объявления
                               функции
            
            void tzset();
            
            int daylight;      флаг перехода на летнее/зимнее
                               время
            long timezone;     различие в секундах от GMT
            char *tzname[2]l   строки трехбуквенных временных
                               зон
            
               Описание.
            
               Функция tzset использует текущую установку переменной окру-
         жения TZ, чтобы назначить  значения  трем  переменным:  daylight,
         timezone,  tzname.  Эти  переменные используются функциями ftime,
         localtime для изменения значения времени  по  Гринвичу  (GMT)  на
         местное время.
               Значением переменной окружения TZ должно быть трехбуквенное
         имя  временной  зоны,  такой как PST, следующей за необязательным
         знаковым числом, задающим различие в часах между значением време-
         ни по Гринвичу и местным временем.Число может идти за трехбуквен-
         ной зоной перехода на летнее/зимнее время, такой как PDT.  Напри-
         мер,  "PST8PDT"  представляет  действительное  значение  для зоны
         Pacific time.
               Когда  вызывается  tzset,  переменным  daylight,  timezone,
         tzname назначаются следующие значения:
            
            Переменная                      Значение
                           
            timezone       Различие  между  значением  времени  по
                           Гринвичу и местным временем
                           
            daylight       Ненулевое значение, если в установке TZ
                           определен  переход   на   летнее/зимнее
                           время; иначе -0
                           
            tzname[0]      Строковое     значение,    определяющее
                           трехбуквенное  имя  временной  зоны  из
                           установки TZ
                           
            tzname[1]      Строковое  значение,  определяющее зону
                           перехода на  летнее/зимнее  время,  или
                           пустую  строку, если эта зона пропущена
                           в установке TZ
               

                                      - 246 -
         
         
            

               Если   TZ  не  установлена,  по  умолчанию  устанавливается
         PST8PDT, которая соответствует зоне Pacific  time.  По  умолчанию
         для daylight устанавливается 1, timezone - 28800, для tzname[0] -
         "PST", tzname[1] - "PDT".
            
      
               Возвращаемое значение.
            
               Возвращаемого значения нет.
               См.также asctime, ftime, localtime.
            
               Пример:
            
            #include <time.h>
            
            int daylight;
            llong timezone;
            char *tzname[];
            .
            .
            .
            putenv("TZ=EST5");
            tzset();
      
            
               ULTOA
                
            #include <stdlib.h>           требуется   только   для
                                          объявления функции
            char ultoa(value, string, radix);
                
            unsigned long value;          преобразуемое число
            char *string;                 строка результата
            int radix;                    основание value
            
               Описание.
               
               Функция ultoa преобразует символы value в символьную  стро-
         ку, оканчивающуюся NULL-символом, и запоминает ее в string. Пере-
         полнение  не  контролируется. Аргумент radix определяет основание
         системы счисления value. Он может принимать значения от 2 до 36.
                
               Возвращаемое значение.
                
               Функция  ultoa возвращает указатель на строку string. Возв-
         ращаемого значения в случае ошибки нет.
               См.также itoa, ltoa.
                
               Замечание: Память, отводимая под string, должна быть  боль-
         ше,  чем  требуется  для  возвращаемой строки. Функция возвращает
         строку длиной до 33 байтов.
                

                                      - 247 -
         
         
               Пример:
                
                #include <stdlib.h>
                
                int radix = 16;
                char buffer [40];
                char *p;
                        /* p будет "501d9138 */
                p=ultoa (1344115000L, buffer, radix);
      
      
            
               UMASK
            
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>       требуется только  для объявления
                                  функции
            
            int umask(pmode);
            int pmode;            доступ, разрешенный по умолчанию
            
               Описание.
            
               Функция umask устанавливает  для  текущего  процесса  маску
         разрешенного  доступа  для файла в режим, который определяется по
         pmode. Маска разрешенного доступа  используется  для  модификации
         установленного  доступа  для  новых файлов, созданных посредством
         функций create, open или sopen. Если бит в маске равен 1, то  со-
         ответствующий  ему бит в значении режима доступа к файлу устанав-
         ливается в 0 (запрещение). Если бит в маске равен 0, соответству-
         ющий ему бит остается неизмененным. Маска доступа для нового фай-
         ла не установится, пока файл не закроется хотя бы один раз. Аргу-
         мент pmode является константным выражением, содержащим  одну  или
         обе  манифестные  константы  S_IWRITE  и  S_IREAD, определенные в
         <sys\stat.h>.Когда заданы обе константы, они объединяются логичес-
         ким опратором ИЛИ(:).
            
               Значение аргумента pmode приводится ниже.
            
         Значение                          Его смысл
           
         S_IWRITE           Запись не допускается (файл только  для
                            чтения)
            
         S_IREAD            Чтение не допускается (файл только  для
                            записи)

            
               Например, если в маске установлен бит записи,  любые  новые
         файлы будут доступны для чтения.
            
               Замечание.  В MS DOS все файлы доступны для чтения, поэтому
         доступ только по записи задать невозможно.  Это  обозначает,  что
         установка бита чтения в umask не имеет смысла.

                                      - 248 -
         
         
      
               Возвращаемое значение.
            
               Функция umask возвращает предыдущее значение pmode. Возвра-
         щаемого значения в случае ошибки нет.
               См.также chmod, creat, mkdir, open.
            
            
               Пример:
      
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            
            int oldmask;
            
            oldmask=umask(S_IWRITE);
            /* создать файлы только для чтения */
            
      
            
               UNGETC
            
            #include <stdio.h>
            
            int ungetc(c, stream);
            int c;                     возвращаемый символ
            
            FILE *stream;              указатель на структуру типа
                                       FILE

               Описание.
            
               Функция ungetc возвращает символ "c" в заданный поток ввода
         stream. Stream должен быть буферизованным и открытым для  чтения.
         Последующая  операция  чтения из stream начинается с символа "c".
         EOF вернуть в поток посредством использования ungetc нельзя.  Эта
         функция возвращает значение ошибки, если из stream ничего не про-
         читано   или  если "c" назад не возвращен. Символы, размещаемые в
         потоке посредством ungetc, могут быть  уничтожены,  если  функции
         fseek или rewind вызваны перед считыванием символа из stream.
            
               Возвращаемое значение.
            
               Эта  функция  возвращает аргумент символа "c". Возвращаемое
         значение EOF свидетельствует о  неудачном  возвращении  заданного
         символа.
               См. также getc, getchar, putc, putchar.
            
               Пример:
            
            #inc <stdio.h>
            #include <ctype.h>
            
            FILE *stream;

                                      - 249 -
         
         
            int ch;
            int result = 0;
            .
            .
            .
               /* следующие операторы выбирают десятичное целое из  потока
         stream */
            
            while ((ch = getc(stream)) != EOF && isdigit(ch))
                  result = result * 10 + ch - '0';
            
            if (ch != EOF)
               ungetc(ch, stream);
               /* возвращает назад не десятичное целое. */
         
               
            UNGETCH
            
            #include <conio.h>     требуется только для объявления
                                   функции
            
            int ungetch(c);
            int c;                 возвращаемый символ
            
               Описание.
            
               Функция  ungetch возвращает символ "c" на консоль и опреде-
         ляет его как следующий читаемый символ. Функция ungetch не выпол-
         няется, если перед следующим чтением она  вызывается  более   чем
         один раз.
            
               Возвращаемое значение.
            
               Функция  ungetch возвращает символ "c", если функция удачно
         отработала. Возвращаемое значение EOF указывает на ошибку.
               См.также cscanf, getch, getche.

               Пример:
            
            #include <conio.h>
            #include <ctype.h>
            
            char bufffer[100];
            int count=0;
            int ch;
            
               /*  следующий код берет обозначение, ограниченное пробелами
         или новыми строками, из клавиатуры */
            
            ch = getche();
            
            while (isspace(ch))
                ch = getche();
            
            while (count < 99)

                                      - 250 -
         
         
            {  if (isspase(ch))
               break;
            
               buffer[count++] = ch;
               ch = getche();
            }
            
            ungetch(ch);
            buffer[count] = '\0';
      
            
               UNLINK
            
            #include <io.h>     требуется  только  для объявления
                                функции
            #include <stdio.h>  использует   либо   <io.h>,  либо
                                <stdio.h>
            
            int unlink(pathname);
            char *pathname;     path-имя удаляемого файла
            
               Описание.
            
               Функция unlink удаляет файл, определенный по pathname.
            
               Возвращаемое значение.
            
               Функция unlink возвращает 0, если файл успешно удален. Воз-
         вращаемое значение -1 свидетельствует об ошибке  и errno устанав-
         ливается в одно из следующих значений:

           Значение                         Его смысл
            
          EACCES             Path-имя определяет директорий или файл
                             только для чтения
            
          ENOENT             Файл или path-имя не найдено
           
               См.также close, remove.
            
               Пример:
            
            #include <io.h>
            #include <stdio.h>
            
            int result;
            
            result=unlink("tmpfile");
            if (result == -1)
              perror("couldn't delete tmpfile");
      
            
               UTIME
            
            #include <sys\types.h>

                                      - 251 -
         
         
            #include <sys\utime.h>
            
            int utime(pathname, times);
            char *pathname;                  path-имя файла
            struct utimbuf *times;           указатель на хранимые
                                             значения времени
            
               Описание.
            
               Функция utime устанавливает время модификации файла,  кото-
         рый  определяется по pathname. Процесс должен иметь доступ по за-
         писи к файлу, иначе   время не будет изменяться.
               Поскольку структура utimbuf содержит поле времени  доступа,
         в MS DOS устанавливается только время модификации.
               Если  times является NULL-указателем, время модификации ус-
         танавливается по текущему времени. Иначе  times должно  указывать
         на  структуру  типа utimbuf, определенную в <sys\utime.h>. В этой
         структуре время модификации устанавливается из поля modtime.
            
               Возвращаемое значение.
            
               Функция utime возвращает значение 0, если время модификации
         было изменено. Возвращаемое значение -1 свидетельствует об  ошиб-
         ке  и errno устанавливается в одно из следующих значений:
            
            ЗНАЧЕНИЕ                     ЕГО СМЫСЛ
            
            EACCES           Path-имя  файла определяет директорий
                             или файл, предназначенный только  для
                             чтения.
                             
            EMFILE           Существует   много   открытых  файлов
                             (файл  должен   быть   открытым   для
                             изменения времени его модификации).
                             
            ENOENT           Файл или path-имя не найдено.
            
               См.  также asctime, ctime, fstat, ftime, gmtime, localtime,
         stat, time.
            
      
               Пример.
            
            #include <sys\types.h>
            #include <sys\utime.h>
            #include <stdio.h>
            #include <stdlib.h>
            
               /* Время модификации файла устанавливается по текущему вре-
         мени */
            
            if (utime("/tmp/data", NULL) == -1)
                     perror ("utime failed").
            
      

                                      - 252 -
         
         
            
               VA_ARG - VA_START
            
            #include <varargs.h>           требуется          для
                                           совместимости с UNIX V.
            
            #include<stdarg.h>             требуется          для
                                           совместимости       со
                                           стандартом   ANSI   C.
            
            void  va_start(arg-ptr);       макро   для   установки
                                           arg-ptr    к     началу
                                           списка   необязательных
                                           аргументов      (только
                                           версия <varargs.h>).
            
            void va_start(arg-ptr, prev-param);
                                           макро   для   установки
                                           arg-ptr к началу списка
                                           необязательных    аргу-
                                           ментов  (только  версия
                                           <stdarg.h>).
            
            type va_start(arg-ptr, type);  макро  для  возвращения
                                           текущего аргумента
            
            void va_arg(arg-ptr);          макро для переустановки
                                           arg-ptr
            
            va_list arg-ptr;               указатель   на   список
                                           аргументов;
            type                           тип       возвращаемого
                                           аргумента;
            prev-param                     параметр, предшедствую-
                                           щий             первому
                                           необязательному   аргу-
                                           менту  (только   версия
                                           <stdarg.h>).
            
            va_alist                       имя параметра для вызы-
                                           ваемой  функции (только
                                           версия <varargs.h>).
            
            va_dcl                         объявление     va_alist
                                           (только          версия
                                           <varargs.h>).
            
               Описание.
            
               Макро va_start, va_arg, va_end обеспечивают способ  доступа
         к  аргументам  функции, когда она принимает переменное количество
         аргументов.
               Доступны  2 версии макро: макро, объявленные в <varargs.h>,
         которые совместимы с определением системы UNIX 5, и макро, объяв-
         ленные в <stdarg.h>, которые приведены в соответствии со стандар-

                                      - 253 -
         
         
         том ANSI C.
               Обе версии макро предполагают, что функция принимает фикси-
         рованное число требуемых аргументов, следующее за переменным чис-
         лом необязательных аргументов. Требуемые аргументы объявлены  как
         необязательные  параметры для функций и могут быть доступны через
         имена параметров. Необязательные аргументы доступны  через  макро
         <varargs.h>  или  <stdarg.h>,  которые устанавливают указатель на
         первый необязательный аргумент в  списке  аргументов;  возвращают
         аргументы из списка и переустанавливают указатель, когда обработ-
         ка аргументов завершена.
               Макро  системы UNIX 5, объявленные в <varargs.h>, использу-
         ются как показано ниже.
            
               1. Любые требуемые параметры для функции могут быть  объяв-
         лены обычным способом как параметры.
               2.  Последний параметр для функции представляет список нео-
         бязательных аргументов. Этот параметр должен быть назван va_alist
         (не  перепутайте  его  с  va_list,  который  объявлен   как   тип
         va_alist).
               3. Макро va_dcl появляется после объявления функции и перед
         открытой  левой скобкой функции. Эта макро объявляется как полное
         описание параметра va_alist, оканчивающегося  точкой  с  запятой,
         однако, за va_dcl не может идти точка с запятой.
               4.  Внутри  функции  макро va_start устанавливает arg-ptr к
         началу списка необязательных параметров, который передается функ-
         ции. Макро va_start должна использоваться перед va_arg, использу-
         емой в первый раз. Аргумент arg-ptr должен иметь тип va_list.
               5. Макро va_arg выполняет следующее:
               * возвращает значение заданного типа type из того  располо-
         жения, которое определяется по аргументу arg-ptr;
               *  увеличивает arg-ptr, чтобы указать на следующий аргумент
         в списке, используя размер type для определения начала расположе-
         ния следующего аргумента.
               Внутри функций макро va_arg может использоваться любое  ко-
         личество раз, чтобы возвратить требуемые аргументы из списка.
               6.  После возвращения всех аргументов  va_end устанавливает
         указатель в NULL.
            
               Макро, предлагаемые  стандартом  ANSI  C  и  объявленные  в
         <stdarg.h>,  незначительно отличаются от макро, которые объявлены
         в <varargs.h>.
               1. Все требуемые аргументы для функции объявляются как  па-
         раметры. Макро va_dcl не используется вместе с макро <stdarg.h>.
               2.  Макро va_start устанавливает arg-ptr на первый необяза-
         тельный аргумент из списка аргументов, который  передается  функ-
         ции.   Аргумент   arg-prt  должен  иметь  тип  va_list.  Аргумент
         prev-param является именем требуемого параметра,  непосредственно
         предшедствующего  первому необязательному параметру из списка ар-
         гументов. Макро va_start должна быть использована  перед  va_arg,
         используемой в первый раз.
               3. Макро va_arg выполняет следующее:
               * возвращает значение типа type из того расположения, кото-
         рое определяется по аргументу arg-ptr.
               *  чтобы указать на следующий аргумент в списке, она увели-
         чивает arg-ptr и использует размер type  для  определения  начала

                                      - 254 -
         
         
         расположения следующего аргумента.
               Внутри  функций макро va_arg может использоваться любое ко-
         личество раз, чтобы возвратить требуемые аргументы из списка.
               4. После возвращения всех аргументов, va_end переустанавли-
         вает указатель в NULL.
            
               Возвращаемое значение.
      
               Макро va_arg возвращает текущий аргумент; va_start и va_end
         значений не возвращают.
               См. также vfprintf, vprintf, vsprintf.
            
               Пример:
            
               Ниже приводится листинг программы, использующей <varargs.h>
         для совместимости с UNIX V.
            
            #include <stdio.h>
            #include <varargs.h>
            
            main()
            {
                   int n;
                   .
                   .
                   .
               /* вызывается функция 4-х  аргументов;  последний  аргумент
         задается равным -1, чтобы отметить конец списка аргументов */
            
                   n = average(2, 3, 4, -1);
            printf("Average is: %d\n", n);
                   .
                   .
                   .
               /*  вызывается  функция 5-ти аргументов; последний аргумент
         задается равным -1, чтобы отметить конец списка аргументов */
            
                   n = average(5, 7, 9, 11, -1);
            printf("Average is: %d\n", n);
            }
            
            average(va_alist)
            va_dcl
              {
                 int i = 0, count = 0, sum = 0;
                 va_list arg_marker;
            
                 va_start(arg_marker);
            
               /* возвращение аргументов и прибавление к sum, пока не вст-
         ретится последний аргумент -1. */
      
             for (; (i = va_arg(arg_marker, int)) >= 0;
                         sum+=i, count++)
                              ;

                                      - 255 -
         
         
                 return (count ? (sum/count) : count);
              }.
            
            
               Аналогичная  программа, перезаписанная для совместимости со
         стандартом ANSI C.
            
            #include <stdio.h>
            #include <stdarg.h>
            
            main()
            {
                   int n;
                   .
                   .
                   .
               /* вызывается функция 4-х  аргументов;  последний  аргумент
         задается равным -1, чтобы отметить конец списка аргументов */
            
                   n = average(2, 3, 4, -1);
            printf("Average is: %d\n", n);
                   .
                   .
                   .
               /*  вызывается  функция 5-ти аргументов; последний аргумент
         задается равным -1, чтобы отметить конец списка аргументов */
            
                   n = average(5, 7, 9, 11, -1);
            printf("Average is: %d\n", n);
            }
            
            average(first)
            int first;
              {
                 int i = 0, count = 0, sum;
                 va_list arg_marker;
            
                 va_start(arg_marker, first);
            
               /* первый  аргумент  прибавляется  к  sum  и  увеличивается
         count; если первый аргумент равен -1, происходит возврат */
            
                 if (first != -1)
                      sum = first;
                 else
                      return (0);
                 count++;
               /*  возвращение  дополнительных  аргументов и прибавление к
         sum, пока не встретится последний аргумент -1. */
            
                 for (; (i = va_arg(arg_marker, int)) >= 0;
                         sum+=i, count++)
                              ;
                 return (sum/count);
              }.

                                      - 256 -
         
         

      
      
               VFPRINTF - VSPRINTF
                   
            #include <stdio.h>
            #include <varargs.h>    требуется  для совместимости с
                                    UNIX V.
            
            #include <stdarg.h>     требуется для совместимости со
                                    стандартом ANSI C.
            
            int vfprintf(stream, format-string, arg-ptr);
            int vprintf(format-string, arg-ptr);
            int vsprintf(buffer, format-string, arg-ptr);
            
            FILE *stream;            указатель на  структуру  типа
                                     FILE.
            char *buffer;            память  для  хранения резуль-
                                     тата
            char *format-string;     строка управления форматом
            va_list arg-ptr;         указатель   на  список  аргу-
                                     ментов.
               Описание.
            
               Функции vfprintf, vprintf, vsprintf форматируют  и  выводят
         данные соответственно в поток stream, поток стандартного вывода и
         буфер  buffer.  Эти  функции  похожи  на  свои  двойники fprintf,
         printf, sprintf, но используют  указатель  на  список  аргументов
         вместо списка аргументов.
               Format-string  имеет ту же самую форму и функцию, что и ар-
         гумент строки формата для функции printf; (см.  описание  функции
         printf).
               Параметр   arg-ptr   имеет   тип  va_list,  определяемый  в
         <vararg.h> и <stdarg.h>. Этот параметр указывает на список  аргу-
         ментов, которые преобразовываются и выводятся согласно соответст-
         вующим спецификациям формата в format-string.
            
               Возвращаемое значение.
            
               Возвращаемым  значением является количество выведенных сим-
         волов.
               См.  также  fprintf,  printf,  sprintf,   va_arg,   va_end,
         va_start.
            
               Пример:
            
               В качестве примера приводится листинг программы, использую-
         щей <varargs.h> для совместимости с UNIX V.
            
            #include <stdio.h>
            #include <varargs.h>
            
            main ()
            {

                                      - 257 -
         
         
            int line = 1;
      
            char *filename = "EXAMPLE";
            .
            .
            .
            error("Error: line %d, file %s\n", line, filename);
            .
            .
            .
            error("Syntax error\n");
            }
            
            error(va_alist);
            va_dcl;
            {
               char *fmt;
               va_list arg_ptr;
            
                 va_start(arg_ptr);
               /* arg_ptr сейчас указывает на строку формата */
                 fmt = va_arg(arg_ptr, char *);
               /* arg_ptr сейчас указывает на аргумент после строки форма-
         та */
                 vprintf(fmt, arg_ptr);
                 va_end(arg_ptr);
            }
            
            На выходе:
            
            Error: line 1, file EXAMPLE
            Syntax error.
            
               Ниже  приводится  аналогичная программа, перезаписанная для
         совместимости со стандартом ANSI C.
            
            #include <stdio.h>
            #include <stdarg.h>
            
            main ()
            {
            int line = 1;
            char *filename = "EXAMPLE";
            .
            .
            .
            error("Error: line %d, file %s\n", line, filename);
            .
            .
            .
            error("Syntax error\n");
            }
            
            error(fmt);
            char *fmt;

                                      - 258 -
         
         
            {
               va_list arg_ptr;
               va_start(arg_ptr, fmt);
      
      
               /* arg_ptr сейчас указывает на аргумент после строки форма-
         та */
                 vprintf(fmt, arg_ptr);
                 va_end(arg_ptr);
            }
            
            На выходе:
            
            Error: line 1, file EXAMPLE
            Syntax error.
            
      
      
            
               WRITE
            
            #include<io.h>       требуется только  для  объявления
                                 функции
            
            int write (handle, buffer, count);
            int handle;          handle-р, ссылающийся на открытый
                                 файл
            char *buffer;       записываемые данные
            unsigned int count; число байтов
            
               Описание.
            
               Функция write записывает байты count  из  буфера  buffer  в
         файл, связанный с handle. Операции write начинаются с текущей по-
         зиции  указателя  на файл (указатель ассоциирован с заданным фай-
         лом). Если файл открыт для добавления, операции выполняются в ко-
         нец файла. После осуществления операций записи указатель на  файл
         (если он есть) увеличивается на количество действительно записан-
         ных байтов.
            
               Возвращаемое значение.
                            
               Функция  write  возвращает  число  действительно записанных
         байтов. Возвращаемое значение должно быть положительным, но мень-
         ше числа count (например, когда размер для  записи  count  байтов
         выходит  за пределы пространства на диске). Возвращаемое значение
         -1 указывает на ошибку; errno устанавливается в одно из следующих
         значений:
            
            ЗНАЧЕНИЕ            ЕГО СМЫСЛ
            
            EACCES           файл открыт для чтения или закрыт для
                             записи
            
            EBADF            неверный handle-р файла

                                      - 259 -
         
         
            
            ENOSPC           на устройстве нет свободного места
            
               Если в файл записано более 32К  (максимальный   размер  для
         типа  int),  возвращаемое  значение  будет иметь тип unsigned int
         (см.нижеследующий пример). Однако, максимальное число  записывае-
         мых байтов в файл равно 65534; поскольку число 65535 является не-
         отличимым  от -1, то возвращается ошибка. Если заданный файл отк-
         рыт в текстовом режиме, каждый символ "Перевод строки" на  выходе
         заменяется  парой "Возврат каретки-Перевод строки". Эта замена не
         влияет на возвращаемое значение.
               См.также fwrite, open, read.
            
               Замечание. При записи в файл, открытый в текстовом  режиме,
         символ  трактуется как логический конец файла. При записи на уст-
         ройство символ в буфере влияет на окончание #include<io.h>.
      
            #include<stdio.h>
            #include<fcntl.h>
            
            char buffer [60000];
      
            main ()
           
               {
               int fh;
               unsigned int nbytes = 60000, byteswritten;
            
               if ((fh=open("c:/data/conf.dat",O_WRONLY))==-1) {
                   perror("open failed on output file");
                   exit (1);
                   }
               if ((byteswritten=write(fh,buffer,nbytes))==-1)
                   perror ("");
               else
                 printf("Wrote %u bytes to file\n",byteswritten);
               .
               .
               .
               }
.
                                      - 260 -
         
         
               
               
                
                                
                                                  П Р И Л О Ж Е Н И Е
                                                  
               
                               Сообщения об ошибках
            
            
               1. Введение
                
                
               В этом приложении содержится список и описание значений,  в
         которые устанавливается переменная errno, если при вызове библио-
         течной  процедуры возникает ошибка. Заметим, что некоторые проце-
         дуры сами устанавливают переменную errno.  Сообщения  об  ошибках
         связаны с каждым значением errno. Эти сообщения и сообщения, пос-
         тавляемые пользователями, печатаются посредством применения функ-
         ции perror.
               Значение errno отражает соответствующее значение ошибки для
         того  вызова, в котором установлено errno. Значение errno автома-
         тически не убирается. Поэтому, чтобы получить правильные  резуль-
         таты работы программы, нужно сразу же после вызова этой программы
         проверять  ее  на  ошибки и печатать соответствующие сообщения об
         ошибках .
               Include-файл <erno.h> содержит объявления  значений  errno.
         Однако  в  MS  DOS  используются  не  все  объявления, заданные в
         <errno.h>. Include-файл содержит также полное множество значений,
         которое обеспечивает  поддержку  совместимости  с  XENIX  и  UNIX
         include-файлами, имеющими аналогичное имя. В этом приложении при-
         водится список значений errno, используемых в MS DOS. Полный спи-
         сок  значений errno приведен в include-файле <errno.h>. Здесь со-
         держится также список ошибок, возникающих при выполнении  матема-
         тических  процедур.  Эти ошибки соответствуют таким типам ошибок,
         которые объявлены в <math.h> и при  возникновении  математической
         ошибки возвращаются функцией matherr.
      
      
               2. Значения errno
            
               В таблице А.1 заданы значения errno, используемые в MS DOS,
         системные сообщения об ошибках, соответствующие каждому значению,
         а также краткое описание случаев, повлекших ошибку.
            
                                                          Таблица А.1
               
                           Значения errno и их описания
            
         Значение       Сообщение                Описание
                       
         E2BIG        Список аргументов   Список аргументов превышает
                      очень длинный.      128К   или    пространство,
                                          требуемое   для  информации
                                          окружения, превышает 32К.

                                      - 261 -
         
         
           
         EACCES       Доступ              Доступ запрещен: разрешение,
                      запрещен            установленное для файла, не
                                          задает требуемый доступ.
                                          Эта ошибка возникает  в тех
                                          случаях,   когда    сделана
                                          попытка  доступа  к   файлу
                                          путем,  который несовместим
                                          с     атрибутами     файла.
                                          Например,  ошибка  возникла
                                          при чтении из файла,  кото-
                                          рый не является   открытым;
                                          при записи в открытый файл,
                                          предназначенный только  для
                                          чтения;    при     открытии
                                          директория вместо файла.  В
                                          версиях   MS   DOS   3.0  и
                                          старших EACCES может указы-
                                          вать на нарушение блокиров-
                                          ки или режима разделения.
                                          Ошибка возникает также  при
                                          переименовании  файла   или
                                          оглавления; при уничтожении
                                          существующего директория.
                                       
         EBADF        Неверное файловое   Значение  handle  для файла
                      число.              не является правильным,либо
                                          оно не ссылается  на откры-
                                          тый  файл;   либо   сделана
                                          попытка  записи  в файл или
                                          на   устройство,   открытые
                                          только для чтения (и наобо-
                                          рот).
                                       
         EDEADLOCK    Может возникнуть    Принудительная  блокировка:
                      зависание           файл    не     может   быть
                      (тупик)             блокирован         после 10
                                          попыток (для версии MS  DOS
                                          3.0 и последующих).
                                       
         EDOM         Математический      Аргумент для математической
                      аргумент.           функции    не   принадлежит
                                          области  определения   этой
                                          функции.
                   
         EEXIST       Файл существует.    Флаги   O_CREATE  и  O_EXCL
                                          определены   при   открытии
                                          файла, но файл  с  заданным
                                          именем уже существует.
           
         EINVAL       Неверный            Задан неверный аргумент для
                      аргумент.           одного     из    аргументов
                                          функции. Например, значение
                                          для  origin  (адрес  начала
                                          программы), задается, когда

                                      - 262 -
         
         
                                          указатель на файл находится
                                          перед   началом файла.
                                       
         EMFILE       Много открытых      Другие handle-ры для  файла
                                          недоступны,  так как нельзя
                                          больше открыть другие файлы.
                                       
         ENOENT       Нет данного файла   Заданный      файл      или
                      или директория.     директорий  не   существует
                                          или  не  может быть найден.
                                          Это   сообщение  возникает,
                                          если заданный файл  не  су-
                                          ществует или в существующем
                                          директории   не  определена
                                          компонента path-имени.
                               
         ENOEXEC      Ошибка .EXE-        Сделана   попытка   создать
                      формата.            файл, который  не  является
                                          выполнимым    или   который
                                          имеет неверный .EXE-формат.
                                       
         ENOMEM       Памяти недоста-     Доступно       недостаточно
                      точно.              памяти. Это сообщение может
                                          возникать,    когда     для
                                          выполнения   child-процесса
                                          памяти   недостаточно,  или
                                          когда для памяти невозможно
                                          обеспечить такое расположе-
                                          ние,  которое требуется при
                                          вызовах  sbrk или getcwd.
                                       
         ENOSPC       На устройстве не    Свободного пространства  на
                      осталось свобод-    устройстве    недостаточно,
                      ного места          чтобы  произвести   запись,
                                          (например, диск полон).
                                       
         ERANGE       Результат очень     Аргумент для математической
                      большой.            функции очень большой, по-
                                          этому происходит  частичная
                                          или полная потеря значимос-
                                          ти результата. Эта   ошибка
                                          также  может  возникнуть  в
                                          других    функциях,   когда
                                          аргумент    больше,     чем
                                          предполагается.  (Например,
                                          когда  аргумент  path-имени
                                          для  функции getcwd больше,
                                          чем предполагается).
           
         EXDEV        Перекрестная связь  Сделана попытка перемещения
                      с устройством.      файла на другое  устройство
                                          (используется ф-я rename).
                 
                                       
                   

                                      - 263 -
         
         
               3. Математические ошибки
            
               Ошибки,  приведенные ниже, порождаются математическими про-
         цедурами библиотеки Си. Эти ошибки соответствуют только тем типам
         ошибок, которые объявлены в  <math.h>,  и  возвращаются  функцией
         matherr.  Более  подробно  обо  всех ошибках приведено в описании
         функции matherr в части 2 данного руководства.
            
                           
           Ошибка                        Описание
            
           DOMAIN          Аргумент   для  функции  находится  вне
                           области определения функции.
                           
           OVERFLOW        Результат очень большой  для предостав-
                           ления его в возвращаемом значении.
                           
           PLOSS           Возникла частичная потеря значимости.
                           
           SING            Особенность  аргумента:  аргумент   для
                           функции    имеет    неверное   значение
                           (например,  пересылается значения 0   к
                           той функции, которая требует ненулевого
                           значения).
                           
           TLOSS           Возникла общая потеря значимости.
                           
           UNDERFLOW       Результат очень маленький для предоста-
                           вления  его  в  возвращаемом  значении.

                           


