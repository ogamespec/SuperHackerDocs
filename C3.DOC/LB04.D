                                  - 174 -
                                         
 
               PERROR

            #include <stdlib.h>            требуется только для
                                           обьявления функции
            
            void perror(string);
            char *string;                  сообщение, поставляемое
                                           пользователем
            
            int errno;                     счетчик ошибок
            int sys_nerr;                  число системных сообще-
                                           ний
            char sts_errlist[sys_nerr];    массив   сообщений   об
                                           ошибках.
            
               Описание.
            
               Функция perror печатает сообщение об  ошибке  в  stderr.  В
         этом сообщении аргумент string печатается первым, затем печатает-
         ся двоеточие, системное сообщение об ошибке для последнего библи-
         отечного вызова, выработавшего ошибку, и новая строка. Номер дей-
         ствительной ошибки хранится в переменной errno, которая объявлена
         на  внешнем  уровне. Системное сообщение об ошибке доступно через
         переменную sys_errlist, которая является массивом  сообщений  для
         счетчика ошибок.
               Функция  perror печатает приблизительное сообщение об ошиб-
         ке, используя значение errno как индекс для sys_errlist. Значение
         переменной sys_nerr определяется как максимальное число элементов
         в массиве sys_errlist.
               Чтобы выработать правильный результат, функция perror долж-
         на быть вызвана сразу же после библиотечной процедуры, возвращаю-
         щей ошибку. Иначе  значение errno  может  быть  перезаписано  для
         последующих вызовов.
            
               Возвращаемое значение.
            
               Функция perror не возвращает никакого значения.
               См. также clearerr, ferror, strerror.
            
               Замечание. В MS DOS некоторые значения errno, приведенные в
         <errno.h>,  не  используются.  Смотрите  приложение "Сообщение об
         ошибках", где приведен список значений errno, используемых  в  MS
         DOS,  и соответствующие сообщения об ошибках. Для значения errno,
         не использующегося в MS DOS, функция perror печатает пустую стро-
         ку.
            
            
               Пример.
            
            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>
            

                                      - 175 -
         
         
            int fh1, fh2;
                
            fh1 = open("data1", O_RDONLY);
            if (fh1 == -1)
               perror("open failed on input file");
            
            fh2 = open("data2", O_WRONLY:O_TRUNC:O_CREAT,
                       S_IREAD:S_IWRITE);
            if (fh2 == -1)
               perror("open failed on output file");.
           
                
               POW
            
            #include <math.h>
            
            double pow(x,y);
            double x;               возводимое число
            double y;               степень числа x
            
               Описание.
            
               Функция pow вычисляет x, возведенное в степень y.
            
               Возвращаемое значение.
           
               Функция pow возвращает значение x в степени y. Если y равна
         0, pow возвращает значение 1. Если x равно 0 и  y  отрицательная,
         pow  устанавливает errno в ERANGE и возвращает HUGE. Если x отри-
         цательное, а y не является целой, функция печатает  сообщение  об
         ошибке DOMAIN в stderr, устанавливает errno в ERANGE и возвращает
         либо  положительное,  либо  отрицательное значение HUGE. В случае
         переполнения или потери значимости никакого сообщения не  печата-
         ется. См.также exp, log, sqrt.
            
               Пример.
            
            #include <math.h>
            double x = 2.0, y = 3.0, z;
            .
            .
            .
            z = pow(x,y);  /* z = 8.0 */
                           
               
               PRINTF
            
            #include <stdio.h>
                                                                  
            int printf (format-string [, argument...]);
            char *format-string;       строка управления форматом.
            
                                                                  


                                      - 176 -
         
               Описание.
         
               Функция  printf  форматирует  и  печатает наборы символов и
         значений в выходной стандартный поток stdout. Строка формата сос-
         тоит из обычных символов, escape-последовательностей и,  если  за
         строкой формата следуют аргументы,    еще и спецификации формата.
         Обычные  символы  и escape-последовательности просто копируются в
         stdout в порядке их появления.
                
                Например, строка
            
            printf ("Line one\n\t\tLine two\n");

         выработает на выводе
            
            Line one
                            Line two.
               Более подробно escape-последовательности описываются в гла-
         ве 2.2.4 руководства MSC Compiler Language Reference.
            
               Если за строкой формата следуют аргументы arguments, то эта
         строка также должна содержать спецификации формата,  определяющие
         формат  вывода этих аргументов. Спецификация формата всегда начи-
         нается с символа знака процента (%). Ниже о нем описывается  под-
         робнее.
               Строка  формата  читается  слева направо. Когда встречается
         первая спецификация формата (если она есть), то значение  первого
         аргумента после строки формата преобразовывается и выводится сог-
         ласно заданной спецификации. Вторая спецификация формата вызывает
         преобразование  и  вывод  второго аргумента и так далее, до конца
         строки формата. Если аргументов больше, чем спецификаций формата,
         то эти дополнительные аргументы игнорируются. Результат  является
         неопределенным,  если аргументов недостаточно для всех специфика-
         ций формата.
               Спецификация формата имеет следующую форму:
            
            %х[flags][wigth][.precision][{F:N:h:I}]type.
            
               Каждое поле в спецификации формата является отдельным  сим-
         волом  или  числом,  выражающим  отдельную  опцию формата. Символ
         type, появляющийся после последнего необязательного поля формата,
         определяет аргумент как символ,  строку  или  число.  (См.  табл.
         R.1.).
               Простейшая  спецификация  формата  содержит  только символ
         знака  процента  и  символ  типа  (например, %S).  Необязательные
         поля  управляют другими аспектами форматирования, как описывается
         ниже.
                                                           
            ПОЛЕ                      ОПИСАНИЕ
            
            flags          Включение   вывода  и  печати   знаков,
                           пробелов,       десятичных       точек,
                           восьмеричных     и    шестнадцатеричных
                           префиксов. (См. табл. R.2.).
                           
            width          Минимальное число выводимых символов.
                           

                                      - 177 -
         
         
            precision      Максимальное число символов, печатаемых
                           на  всем  или  части  поля  вывода; или
                           минимальное  число   цифр   для  печати
                           целых значений. (См. табл. R.3.).
                           
            F, N           Префиксы, позволяющие пользователю over-
                           ride,  по умолчанию,  адресацию соглаше-
                           ний моделей памяти.
                           
            F              Используется для малой модели для печати
                           значения, объявленного far.
                                     
            N              Используется   для   средней, большой  и
                           huge-моделей  для near-значений.
                           
                           F  и N могут быть использованы только с
                           типами символов s и  p,  поскольку  они
                           уместны     только    с    аргументами,
                           представляющими указатель.
                           
            h, l           Предполагаемый размер аргумента:
                           
                           h используется в  качестве  префикса  с
                           целыми   типами  d,  i,  o,  x,  X  для
                           определения,  что   аргумент   является
                           short int.
                           
                           l  используется  в  качестве префикса с
                           типами d, i, o, x, X  для  обозначения,
                           что  аргумент является long int. Символ
                           l  используется  также  как  префикс  с
                           типами  e,  E, f, g, G для определения,
                           что  аргумент  является  скорее double,
                           чем float.
            
               Если за символом знака  процента  (%)  следует  символ,  не
         обозначающий  тип  формата,  то  этот  символ  копируется в поток
         stdout. Например, для печати символа знака процента  используется
         комбинация %%.
           
           
                                                      Таблица R.1.
               
                          Типы символов функции printf
         
               
            СИМВОЛ    ТИП АРГУМЕНТА          ФОРМАТ ВЫВОДА
            
              d         целый           целочисленный   десятичный
                                        знаковый
            
              i         целый           целочисленный   десятичный
                                        знаковый
            
              u         целый           беззнаковый  целочисленный

                                      - 178 -
         
         
                                        десятичный
            
              o         целый           беззнаковый   восьмеричный
                                        целый
            
              x         целый           беззнаковый   шестнадцате-
                                        ричный целый, использующий
                                        "abcdef"
            
              X         целый           беззнаковый   шестнадцате-
                                        ричный целый, использующий
                                        "ABCDEF".
            
              f       с  плавающей      знаковое значение, имеющее
                      точкой            форму  [-]dddd.dddd,   где
                                        dddd  -  одна   или  более
                                        десятичных  цифр.    Коли-
                                        чество      цифр     перед
                                        десятичной точкой  зависит
                                        от   величины   числа,   а
                                        количество   цифр    после
                                        десятичной  точки  зависит
                                        от требуемой точности.
            
             e        с плавающей       знаковое значение, имеющее
                      точкой            форму [-]d.dddde[sign]ddd,
                                        где  d - десятичная цифра,
                                        dddd  -  одна  или   более
                                        десятичныхя  цифр,  ddd  -
                                        ровно    три    десятичных
                                        цифры,  и sign - либо "+",
                                        либо "-".
            
             E        с плавающей       идентично формату "e",  за
                      точкой            исключением   того,    что
                                        вместо "e" вводится "E".
            
             g        с плавающей       знаковое значение, распеча-
                      точкой            тываемое в формате "f" или
                                        "e",  и  являющееся  более
                                        компактным  для  выбранных
                                        значения  и точности  (как
                                        показано ниже). Формат "e"
                                        используется, только когда
                                        значение экспоненты меньше
                                        -4    или    больше,   чем
                                        precision.  Ведущие   нули
                                        отсекаются,  и  десятичная
                                        точка  появляется   тогда,
                                        когда  за ней следует одна
                                        или несколько цифр.
            
             G       с плавающей        идентично  формату "g", за
                     точкой             исключением    того,   что
                                        вместо     "e"    вводится

                                      - 179 -
         
         
                                        экспонента "E"  (если  она
                                        необходима).
            
             c       символьный         отдельный символ.
            
             s       строковый          символы    печатаются   до
                                        первого  нулевого  символа
                                        '\o'   или  до  достижения
                                        precision.
            
             n       указатель на       число   символов   успешно
                     целый              записывается   в     поток
                                        stream;    это    значение
                                        хранится  в  целом,  адрес
                                        которого   выбирается  как
                                        аргумент.

             p       far-указатель      печать адреса, указываемо-
                                        го аргументом,  в    форме
                                        xxxx:yyyy,    где     xxxx
                                        является  сегментом,  yyyy
                                        является разветвлением,  а
                                        цифры   x   и  y  являются
                                        шестнадцатеричными цифрами
                                        верхнего  регистра (upper-
                                        case). %Np печатает только
                                        адрес  разветвления  yyyy.
                                        Поскольку  %p предполагает
                                        указатель на far-значение,
                                        аргументы      p-указателя
                                        могут быть сброшены к  far
                                        в    маленьких     моделях
                                        программ.
               
               
            
                                                      Таблица R.2.
               
                          Символы flags функции printf
            
            FLAG(*)        ЗНАЧЕНИЕ                  ПО УМОЛЧАНИЮ
            
              -      Смещение результата влево    Смещение  вправо
                     внутри поля wigth
            
           
              +      Присоединение   знака   к    Знак  "-"  появ-
                     выводимому значению, если    ляется    только
                     оно имеет знаковый тип       для  отрицатель-
                                                  ных     знаковых
                                                  значений
                                                  
            blank    К выводимому значению при-   Без пробела
            (' ')    соединяется ' ', если  вы-
                     водимое значение  является

                                      - 180 -
         
         
                     знаковым и  положительным;
                     флаг  "+"  override   флаг
                     blank,  если  оба  есть, и
                     положительное     знаковое
                     значение выводится  вместе
                     со знаком
                     
            #        При использовании с форма-   Без префикса
                     тами o, x, X,  флаг # при-
                     соединяет к любому ненуле-
                     вому  выводимому значению,
                     соответственно, 0, 0х, 0Х
                     
                     Когда флаг #  используется   Десятичная точ-
                     в  формате  e,  E,  f,  он   ка   появляется
                     определяет   наличие деся-   только   тогда,
                     тичной  точки в  выводимом   когда   за  ней
                     значении                     идут цифры
                     
                     Когда флаг #  используется   Десятичная точ-
                     в формате g, G, он опреде-   ка   появляется
                     ляет  наличие   десятичной   только   тогда,
                     точки в выводимом значении   когда   за  ней
                     и  препятствует  отсечению   идут цифры
                     ведущих нулей                Ведущие    нули
                                                  отсекаются
                                                  
                     Флаг  # игнорируется,  при
                     его использовании в форма-
                     тах c, d, i, u, s
                     
               Примечание. В формате спецификации может содержаться более,
         чем один flag.

               Width  -  неотрицательное  десятичное целое, контролирующее
         минимальное число напечатанных символов. Если  число  символов  в
         значении  вывода  меньше, чем в width, слева и справа добавляются
         пробелы (в зависимости от того, где определен флаг "-"), пока ми-
         нимальная ширина не будет достигнута. Если к width присоединяется
         0, то 0 будут добавляться до тех пор, пока не будет достигнут ми-
         нимум width. (Это не применяется для чисел, смещенных влево).
               Спецификация width не требует отсечения значения; если чис-
         ло символов выводимого значения больше  чем определено  в  width,
         или  не задано в нем, все значения символов распечатываются (под-
         лежат спецификации precision).
               В спецификации width может быть звездочка (*), когда вместо
         значения подставляется соответствующий ему аргумент из списка ар-
         гументов. Аргумент width должен предшедствовать  соответствующему
         значению.
               Спецификация  precision является неотрицательным десятичным
         целым, которому предшедствует точка (.), определяющая  количество
         печатаемых символов  или же число десятичных мест.
               В  отличии  от  спецификации  width, спецификация precision
         требует отсечения выводимого значения или, в  случае  значения  с
         плавающей  точкой, его округления. В случае подстановки аргумента

                                      - 181 -
         
         
         из списка аргументов  в спецификации precision может  быть  звез-
         дочка  (*).  В списке аргументов аргумент precision предшедствует
         форматируемому значению. Объяснение значений precision, в зависи-
         мости от типа type  и случая, когда precision  пропущено,  предс-
         тавлено в таблице R.3.
               
                                                      Таблица R.3.
               
               Как тип type влияет на значение precision в функции printf
         
               
            ТИП             ЗНАЧЕНИЕ                ПО УМОЛЧАНИЮ

             d     Precision         определяет   Если   precision
             i     минимальное число печатаемых   равна 0 или про-
             u     цифр.  Если  число  цифр   в   пущена, или если
             o     аргументе     меньше,    чем   появляется точка
             x     размер   precision,    слева   (.)  без  идущих
             X     перед   выводимым  значением   за ней цифр,  то
                   добавляются нули. Если число   precision  уста-
                   цифр  не  превосходит размер   навливается рав-
                   precision,    значение    не   ной 1
                   отсекается
                                                  
             e     Precision  определяет  число   Precision     по
             E     цифр,    печатаемых    после   умолчанию  равна
             f     десятичной  точки. Последняя   6; если она рав-
                   печатаемая цифра округляется   на  0  или перед
                                                  ней   появляется
                                                  точка   (.)  без
                                                  следуемых за ней
                                                  цифр,      тогда
                                                  десятичная точка
                                                  не печатается
                                                  
             g     Precision         определяет   Печатаются   все
             G     максимальное   число  важных   важные   (много-
                   (многозначных)    печатаемых   значные) цифры
                   символов
                   
             c     Не    происходит    никакого   Печать символа
                   действия
            
             s     Precision определяет макси-    Печать символов,
                   мальное число печатаемых       пока  не  встре-
                   символов                       тится    нулевой
                   Символы,  превышающие размер   символ
                   precision, не печатаются
            
            
               Возвращаемое значение.
            
               Эта функция возвращает количество напечатанных символов.
               См.  также  fprintf,  scanf,  sprintf,  vfprintf,  vprintf,
         vsprintf.

                                      - 182 -
         
         
            
               Пример:
            
            main ()
      
         /* форматирование и печать различных данных */
            
            {
            char ch = 'h', *string = "computer";
            int count = 234, *ptr, hex = 0x10, oct = 010, dec = 10;
            double fp = 251.7366;
            
            printf("%d  %+d  %06d  %X  %x  %o\n\n",
                  count, count, count, count, count, count);
            
            printf("1234567890123%n45678901234567890\n\n", &count);
            printf("Value of count should be 13; count = %d\n\n",
                   count);
            
            printf("%10c%5c\n\n", ch, ch);
            
            printf("%25s\n%25.4s\n\n", string, string);
            
            printf("%f  %.2f  %e  %E\n\n", fp, fp, fp, fp);
            
            printf("%i  %i  %i\n\n", hex, oct, dec);
            
            ptr = &count;
            printf("%Np  %p  %Fp\n",
                   ptr, (int far *) ptr, (int far *)ptr);
            }
            
            Тогда на выводе получится следующее:
            
            234  +234  000234   EA  ea  352
            
            123456789012345678901234567890
            
                            
            Value of count should be 13; count = 13;
                h    h
                      computer
                               comp
            
            251.736600    251.74   2.517366e+002   2.517366E+002
            
            16  8  10
            
            127A  1328:127A   1328:127A.
            
            
            PUTC-PUTCHAR

            #include <stdio.h>
                                                                                                       

                                      - 183 -
         
         
            int putc (c, stream);   записывает символ в поток stream
            int c;                  записываемый символ
            
            FILE *stream;           указатель на структуру FILE
            
            int putchar(c);         записывает символ в <stdout>
            int c;                  записываемый символ
            
            
               Описание.

               Процедура putc записывает отдельный символ  "с"  в  текущую
         позицию выходного потока stream. Процедура putchar идентична про-
         цедуре putc(c, stdout).
            
               Возвращаемое значение.
            
               Эти  обе  процедуры  возвращают записанный символ. В случае
         ошибки  возвращается значение EOF. Так  как  значение  EOF  может
         быть  воспринято  как  целая величина, поэтому для проверки места
         возникновения ошибки применяется функция ferror.
               См. также fputc, fputchar, getc, getchar.
               Замечание: Процедуры  putc  и  putchar  идентичны  fputc  и
         fputchar, но они являются макро, а не функциями.
            
               Пример:
            
            #include <stdio.h>
                                                                 
            FILE *stream;
            char buffer[81];
            int i, ch;
            .
            .
            .
         /* следующий оператор позволяет записать буфер в поток */
            
            for  (i = 0;  (i < 81)  &&  ((ch = putc(buffer[i],
                                               stream)) != EOF) ;)
                     ++i;
            
         /* Замечание: Поскольку  тело  утверждения  пусто,  операция
         записи происходит в выражении проверки. */
            
            
              PUTCH
            
            #include <conio.h>     требуется только для объявления
                                   функции
            
            void putch(c)
            int c;                 выводимый символ
            
            

                                      - 184 -
         
         
               Описание.
            
               Функция putch записывает символ "c" прямо на консоль.
            
               Возвращаемое значение.
            
               Возвращаемого значения нет.
               См.также cprintf, getch, getche.
            
               Пример:
            
            #include <conio.h>
                                 
          /* в следующем примере показано, как может быть определена функ-
         ция getche посредством использования функций putch и getch.*/
         
            int getche()
            {
                int ch;
            
                ch=getch();
                putch(ch);
                return(ch);
            }
            
            
               PUTENV
            
            #include <stdlib.h>              требуется только  для
                                             объявления функции
                                             
            int putenv(envstring);           объявление   строки
            char *envstring;                 окружения
                                             
               Описание.
            
               Функция putenv добавляет новые переменные окружения или мо-
         дифицирует значения существующих переменных окружения.
               Переменные окружения определяют окружение, в котором выпол-
         няется  процесс (например, поиск по умолчанию path для библиотек,
         линкуемых вместе с программой).
               Аргумент envstring должен быть указателем на строку в  сле-
         дующей форме:
            
               varname = string,
            
               где varname - имя добавляемой или модифицируемой переменной
         окружения  и  string - значение этой переменной. Если varname уже
         является  частью  окружения,  она  заменяет  существующую  строку
         string, иначе - к окружению добавляется новая строка string. Зна-
         чение  переменной может быть установлено пустым, если string пус-
         тая.
               Указатель на вход (запись) окружения  не  освобождается  до
         тех пор, пока вход (запись) окружения остается неизменным при ис-
         пользовании   или пока переменная окружения не будет указывать на
         освобожденное пространство. Аналогичная  проблема  может  возник-

                                      - 185 -
         
         
         нуть, если передается указатель на локальную переменную для функ-
         ции putenv, а затем   происходит выход на функцию, в которой объ-
         явлена переменная.
            
               Возвращаемое значение.
            
               Функция  putenv  возвращает 0, если она успешно отработала.
         Возвращаемое значение -1 указывает на ошибку.
               См. также getenv.
            
               Замечание: Функции getenv и  putenv  используют  глобальную
         переменную  environ  для  доступа к таблице переменных окружения.
         Функция putenv может изменять значение environ, делая  недействи-
         тельным аргумент "envp" для функции "main".
         
               Пример:
      
            #include<stdlib.h>
            #include<stdio.h>
            #include<process.h>
            
               /* попытка изменения переменной окружения */
            
            if (putenv("PATH=a:\\bin;b:\\tmp") == -1)
            {   printf("putenv failed -- out of memory");
                exit(1);
            }
           
           
            
               PUTS
            
            #include <stdio.h>
                                                                 
            int puts (string);
            char *string;                    выводимая строка
            
            
               Описание.

               Эта  функция записывает выбранную строку string в стандарт-
         ный поток вывода stdout, заменяя в выходном потоке нулевой символ
         окончания строки ('\0') символом новой строки ('\n').
            
               Возвращаемое значение.
            
               Функция puts возвращает последний записанный символ,  кото-
         рым обычно является символ новой строки '\n'. Значение EOF свиде-
         тельствует об ошибке.
               См. также fputs, gets.
            
               Пример:
            
            #include <stdio.h>
            

                                      - 186 -
         
         
            int result;
            
               /* следующий оператор позволяет записать подсказку "Вставь-
         те дискету с данными и нажмите любую клавишу" в stdout. */
            
            result = puts("Insert data disk and strike any key");.
           
            
               PUTW
            
            #include <stdio.h>
                                                                  
            int putw(binint, stream);
            int binint;              выводимое двоичное целое
                                                                  
            FILE *stream;            указатель на структуру FILE
                                                                  
               Описание.
                                                                  
               Функция putw записывает двоичное значение типа int в  теку-
         щую  позицию  потока stream. Эта функция не выравнивает единицы в
         потоке и не предполагает специального выравнивания.
         
               Возвращаемое значение.
           
               Функция putw возвращает записанное значение.  Значение  EOF
         свидетельствует  об  ошибке.  Поскольку EOF может быть воспринято
         также как целая величина, то для проверки ошибки может  быть  ис-
         пользована функция ferror.
               См. также getw.
               Замечание: Эта функция позволяет обеспечивать совместимость
         с предыдущими библиотеками. Нужно заметить, что при использовании
         данной  функции  могут  возникать проблемы переносимости из одной
         системы в другую систему, поскольку в них отличаются размеры  int
         и порядок расположения байтов в int.
            
               Пример:
            
            #include <stdio.h>
            #include <stdlib.h>
            
            FILE *stream;
            .
            .
            .
            
               /*  следующие  операторы  позволяют  записать слово в поток
         stream и проверить на наличие ошибки. */
            
            putw(0345, stream);
            
            if (ferror(stream))
            {     fprintf(stderr, "putw failed\n");
                  clearerr(stream);
            }

                                      - 187 -
         
         
           
            
               QSORT
            
            #include <search.h>    требуется только для объявления
                                   функции
            
            void gsort(base,num, width, compare);
            char *base;
            unsigned num, width;
            int (*compare)();
            
               Описание.
            
               Функция qsort выполняет алгоритм быстрой сортировки,  чтобы
         отсортировать  массив  из  num элементов, каждый элемент размером
         width байт. Аргумент base является указателем  на  базу  массива,
         который  нужно  отсортировать.  Функция qsort перезаписывает этот
         массив с отсортированными элементами.
               Аргумент compare является указателем на процедуру,  постав-
         ляемую  пользователем,  которая сравнивает два элемента массива и
         возвращает значение, определяющее их отношение.
               Функция qsort может вызывать  процедуру  compare  один  или
         несколько  раз в процессе сортировки, передавая при каждом вызове
         указатели на два элемента массива.  Процедура  должна  сравнивать
         элементы, а затем возвращать одно из следующих значений:
            
            Значение                   Его смысл
            
            меньше 0           element 1 меньше element 2
                
               0               element 1 равен element 2
                
            больше 0           element 1 больше element 2
            
                
               Возвращаемое значение.
            
               Возвращаемого значения в случае ошибки нет.
               См.также bsearch, lsearch.
            
               Пример:
           
            #include <search.h>
            #include <string.h>
            #include <stdio.h>
            
            int compare ();
            /* должна быть объявлена как функция */
            
            main (argc, argv)
                int argc;
                char **argv;
                {
                .

                                      - 188 -
         
         
                .
                .
               /*  следующий оператор сортирует аргументы командной строки
         в лексикографическом порядке: */
            
                qsort((char*)argv,argc,sizeof(char*),compare);
                for (i=0; i<argc; ++i)
                  printf("%s\n", argv[i]);
                .
                .
                .
                }
            
            int compare (arg1, arg2)
               char **arg1, **arg2;
            
               {
               return(strcmp(*arg1, *arg2));
               }
            
            
               RAND
            
            #include<stdlib.h>              требуется только   для
                                            объявления функции
            
            int rand;
            
               Описание.
            
               Функция rand возвращает псевдослучайное целое  в  интервале
         от 0 до 32767. Процедура srand может использоваться перед вызовом
         rand для установки начальной случайной точки.
            
               Возвращаемое значение.
            
               Функция rand возвращает псевдослучайное число.
               См. также srand.
            
               Пример:
            
            #include<stdlib.h>
            #include<stdio.h>
            
            int x;
            
         /* печатает 20 первых сгенерированных случайных чисел */
            
            for (x = 1; x <= 20; x++)
                printf("iteration %d, rand=%d\n", x, rand());.
            
           
            


                                      - 189 -
         
               READ
         
            #include<io.h>        требуется только для объявления
                                  функции
            
            int read(handle, buffer,count)
            int handle;           handle-р,  ссылающийся на откры-
                                  тый файла
            char *buffer;         память для хранения данных
            unsigned int count;   максимальное количество байтов
            
               Описание.
            
               Функция read позволяет читать байты count из файла, связан-
         ного с handle, в буфер buffer. Операции чтения начинаются с теку-
         щей позиции указателя на файл, который соответствует данному фай-
         лу.  После выполнения операции чтения этот указатель устанавлива-
         ется на следующий непрочитанный символ.
            
               Возвращаемое значение.
            
               Функция read  возвращает  число  действительно  прочитанных
         байтов, которое может быть меньше, чем count. Возвращаемое значе-
         ние 0 указывает на попытку чтения конца файла, а 1 - свидетельст-
         вует  об ошибке; в этих случаях errno устанавливается в значение,
         которое описано ниже.
            
            Величина          Смысловое значение
            
            EBADF       заданный handle неверный, или файл не яв-
                        ляется открытым для чтения,  или же  файл
                        заблокирован (закрыт). (Версия MS DOS 3.0
                        и последующие).
            
               Если прочитано больше 32К (максимальный размер типа int) из
         файла, возвращаемое значение будет типа unsigned int  (см.пример,
         приведенный ниже). Однако максимальное число байтов, которое мож-
         но  прочитать из файла, равно 65534; поскольку 65534 (или OXFFFF)
         является неотличимым от -1, поэтому будет возвращена ошибка. Если
         файл открыт в текстовом режиме, возвращаемое  значение  может  не
         соответствовать числу действительно прочитанных байтов. Если тек-
         стовый  режим эффективен, каждая пара "ВК-ПС" заменяется символом
         ПС. Подсчитывается в возвращаемом значении только отдельный  сим-
         вол ПС. Эта замена не влияет на указатель файла.
               См.также creat, fread, open, write.
            
               Замечание: В MS DOS, когда файл открыт в текстовом  режиме,
         символ  трактуется  как  индикатор  конца файла. Если встречается
         CONTROLL-Z, чтение оканчивается и при следующем чтении  возвраща-
         ется  0  байтов.  Индикатор  конца  файла может воспрепятствовать
         очистке файла.
            
               Пример:
            
            #include <io.h>
            #include <stdio.h>
            #include <fcntl.h>

                                      - 190 -
         
         
            
            char buffer [60000]
            
            main ()
             {
               int fh;
               unsigned int nbytes=60000, bytesread;
            
               if ((fn=open("c:/data/conf.dat",O_RDONLY))==-1) {
                      perror("open failed on input file");
                      exit (1);
                      }
               if ((bytesread=read(fh,buffer,nbytes))==-1)
                      perror("");
               else
                   printf("Read %u bytes from file\n",bytesread);
               .
               .
               .
               }
         
               
               REALLOC
            
            #include <malloc.h>    требуется только для объявления
                                   функции
            
            char *realloc(ptr,size);
            char *ptr;             указатель  на ранее захваченный
                                   блок памяти
            unsigned size;         новый размер в байтах
            
               Описание.
            
               Функция realloc изменяет размер  ранее  захваченного  блока
         памяти. Аргумент ptr указывает на начало блока. Аргумент size за-
         дает новый размер блока в байтах. Содержимое блока не изменяется.
         Аргумент  ptr  может указывать на блок, который должен быть осво-
         божден прежде,  чем  последуют  вызовы  calloc,  halloc,  malloc,
         realloc.
            
               Возвращаемое значение.
            
               Функция  realloc возвращает char-указатель на перезахвачен-
         ный блок памяти. Блок может быть передвинут, если его размеры из-
         менены, поэтому аргумент ptr для функции realloc  не  обязательно
         должен быть таким же, как и возвращаемое значение.
               Возвращается значение NULL, если памяти недостаточно, чтобы
         расширить  блок к заданному размеру. Если это происходит, то пер-
         воначальный блок освобождается.
               В памяти, на которую указывает возвращаемое  значение,  га-
         рантировано  выравнивание для хранения любого типа объекта. Чтобы
         получить указатель на тип, отличный от char, используется  преоб-
         разователь типа возвращаемого значения.
               См.также caloc, free, halloc, malloc.

                                      - 191 -
         
         
            
               Пример:
           
            #include <malloc.h>
            #include <stdio.h>
            
            char *alloc;
            
            /*  выбирает  достаточно  большое  пространство для 50
            символов */
            
            alloc=malloc(50*sizeof(char));
            .
            .
            .
            
               /* перезахватывает блок, который содержит 100 символов */
            if (alloc != NULL)
               alloc=realoc(alloc,100*sizeof(char));
         
               
               REMOVE
               
            #include <io.h>     требуется  только  для  объявления
                                функции
            #include <stdio.h>  использует  либо  <io.h>,     либо
                                <stdio.h>
            
            int remove(pathname);
            char *pathname;     path-имя удаляемого файла
            
               Описание.
            
               Функция remove удаляет файл, определенный по pathname.
            
               Возвращаемое значение.
            
               Функция remove возвращает 0, если файл успешно удален. Воз-
         вращаемое значение -1 свидетельствует об ошибке  и errno устанав-
         ливается в одно из следующих значений.
            
            
               Значение                         Его смысл
            
         EACCES               path-имя определяет директорий или файл
                              только для чтения
            
         ENOENT               файл или path-имя не найдено
            
               См.также close, unlink.
            
               Пример:
            
            #include <io.h>
            #include <stdio.h>

                                      - 192 -
         
         
            
            int result;
            
            result=remove("tmpfile");
            if (result == -1)
              perror("couldn't delete tmpfile");
                                                         
               
               RENAME
            
            #include <io.h>    требуется  только  для   объявления
                               функции
            #include <stdio.h> использует   либо   <io.h>,    либо
                               <stdio.h>
            
            int rename (oldname,newname);
            char *oldname;      указатель на старое имя
            char *newname;      указатель на новое имя
            
               Описание.
            
               Функция rename переименовывает файл или директорий, опреде-
         ляемый по имени newname. Oldname должно задавать path-имя сущест-
         вующего  файла  или директория. Newname не определяет имя уже су-
         ществующего файла или директория. Функцию rename можно  использо-
         вать  для  перемещения  файла из одного директория в другой, если
         задать другое path-имя в аргументе newname. Однако, файлы не  мо-
         гут  быть  перемещены  с одного устройства на другое (например, с
         дисковода А на дисковод В). Директории  можно  переименовывать  и
         нельзя перемещать.
            
               Возвращаемое значение.
            
               Функция  rename возвращает 0, если она выполнена успешно. В
         случае ошибки возвращается ненулевое значение  и errno устанавли-
         вается в одно из следующих значений:

                           
               Значение                          Его смысл
                           
         EACCES               Файл  или  директорий,  заданный     по
                              newname, существует или не  может  быть
                              создан (неверный  path),   или  oldname
                              является    директорием   и     newname
                              определяет другой  path.
                
                           
         ENOENT               Файл или path-имя, заданные по oldname,
                              не  найдены.
                           
         EXDEV                Попытка  перемещения  файла  на  другое
                              устройство.

            
               См.также create, fopen, open.

                                      - 193 -
         
         
            
               Замечание. Нужно заметить, что порядок аргументов в  rename
         для Microsoft C 4.0 противоположен порядку rename для ранних вер-
         сий.  Это  изменение  было  сделано  в соответствии со стандартом
         ANSI.
               
               Пример:
            
            #include <io.h>
            
            int result;
            
               /* следующий оператор изменяет имя файла "input" ** на  имя
         "data" */
            
            result = rename("input", "data");
         
               
               REWIND
            
            #include <stdio.h>
            
            void rewind(stream);
                                                                  
            FILE *stream;            указатель на структуру FILE.
                                                                  
               Описание.
                                                                  
               Функция rewind перемещает указатель на  файл,  связанный  с
         потоком stream, к началу файла. Вызов функции rewind эквивалентен
         вызову следующей функции:
            
            fseek(stream, OL, SEEK_SET);
            
               с учетом того, что в потоке rewind очищает ошибки и индика-
         торы  конца файла, а fseek этого не делает. Fseek возвращает зна-
         чение,которое определяет, успешно или нет  передвинут  указатель.
         Rewind не возвращает никакого значения.
            
               Возвращаемое значение.
           
               Возвращаемого значения нет.
               См. также fseek, ftell.
            
               Пример:
            
            #include <stdio.h>
                                                                  
            FILE *stream;
            int data1, data2;
            .
            .
            .
            fprintf(stream, "%d  %d", data1, data2);
            /* располагает данные в файл */

                                      - 194 -
         
         
            
            rewind(stream);
            /* читает файл данных */
            
            fscanf(stream, "%d", &data1);.
            
               
               RMDIR
            
            #include <direct.h>  требуется  только  для объявления
                                 функции
            
            int rmdir(pathname);
            char *pathname;      path-имя удаляемого директория
            
               Описание.
              
               Функция rmdir удаляет директорий, определяемый по pathname.
         Директорий  должен быть пустым и он не может быть текущим рабочим
         директорием или директорием корня.
            
               Возвращаемое значение.
            
               Функция rmdir возвращает значение 0, если директорий успеш-
         но удален. Возвращаемое значение -1 свидетельствует об ошибке   и
         errno устанавливается в одно из следующих значений:

               Значение                       Его смысл
                                 
         EACCES               Заданное path-имя не является  директо-
                              рием; или директорий не пуст,  или  ди-
                              ректорий является текущим рабочим   ди-
                              ректорием  или директорием корня.
                           
         ENOENT               Path-имя не найдено

            
               См.также chdir, mkdir.
            
               Пример:
            
            #include <direct.h>
            
            int result1, result2;
            
               /*  следующие  операторы  удаляют два директория: ** один в
         корне, другой - в текущем рабочем ** директории */
            
            result1=rmdir("/data1");
            result2=rmdir("data2");
         
               
               RMTMP
            
            #include <stdio.h>

                                      - 195 -
         
         
                                                                  
            int rmtmp;
                                                                  
               Описание.
                                                                  
               Функция  rmtmp используется для очистки всех временных фай-
         лов в текущем директории. Эта функция очищает  и  удаляет  только
         файлы, созданные при помощи tmpfile.
               Функция  rmtmp может использоваться в том же самом директо-
         рии, где создавались временные файлы.
            
               Возвращаемое значение.
            
               Эта функция возвращает количество очищенных и  уничтоженных
         временных файлов.
               См. также flushall, tmpfile, tmpnam.
            
               Пример:
            
            #include <stdio.h>
            
            main ()
            
                 {
                  int numdeleted;
                  .
                  .
                  .
                  if ((stream = tmpfile()) == NULL)
                     perror ("Couldn't open new temporary file");
                  .
                  .
                  .
                  numdeleted = rmtmp;
                  printf ("Number of files closed and deleted in\
                  current directory = %d\n", numdeleted);
                 }.
               
               
               
               SBRK
            
            #include <malloc.h>    требуется только для объявления
                                   функции
            
            char *sbrk(incr);
            int incr;              количество   добавляемых    или
                                   вычитаемых  байтов
            
               Описание.
            
               Функция sbrk переустанавливает значение разрыва для вызван-
         ного  процесса.  Значением  разрыва  является адрес первого байта
         захваченной памяти. Функция sbrk добавляет incr байты к  значению
         разрыва;  соответственно этому устанавливается размер захватывае-

                                      - 196 -
         
         
         мой памяти.
            
               Замечание. Incr может быть отрицательным, тогда  количество
         захваченной памяти уменьшается на incr байтов.
            
               Возвращаемое значение.
            
               Функция sbrk возвращает старое значение разрыва. Возвращае-
         мое  значение  -1  указывает на ошибку  и errno устанавливается в
         ENOMEN, указывая, что осталось недостаточно памяти.
               См.также calloc, free, malloc, realloc.
            
               Замечание. В компактной, большой  и  huge-моделях  программ
         функция  sbrk отсутствует и возвращает значение -1. В больших мо-
         делях программ для захвата используется функция malloc.

            
               Пример:
            
            #include <malloc.h>
            #include <stdio.h>
            
            /* захватывает память в 100 байт */
            
            char *alloc;
            alloc=sbrk(100);
            .
            .
            .
            
            /* уменьшает захваченную память до 60 байт  */
            
            if (alloc != (char)-1)
                   sbrk(-40);
                                                
               
               SCANF
            
            #include <stdio.h>
                                                                  
            int scanf(format-string[[, argument...]]);
            char *format-string.       строка управления форматом.
                                                                  
               Описание.
                                                                  
               Функция scanf читает данные из стандартного потока stdin  в
         место, определяемое аргументами arguments. Каждый аргумент должен
         быть  указателем на значение с типом, который соответствует типу,
         заданному в строке формата. Строка формата управляет преобразава-
         ниями полей ввода. Эта строка может содержать следующее:
            
               "Пробельные" символы, т.е. символ пробела ' ', табуляции \t,
         новой строки '\n'. Для функции scanf символом пробела определяет-
         ся считывание, но без запоминания, всех вводимых последующих сим-
         волов пробела вплоть до первого символа, не являющегося пробелом.

                                      - 197 -
         
         
         При  вводе один символ пробела в строке формата соответствует лю-
         бому числу, включая 0, или любой комбинации символов пробела.
               Любой символ управления, не являющийся пробелом и  символом
         знака  процента %. Тогда по этому символу для функции scanf опре-
         деляется считывание, но без запоминания соответствующих  символов
         управления. Если следующий символ в <stdin> не соответствует сим-
         волам управления, то scanf оканчивает свою работу.
               Спецификацию  формата, введенную со знаком %. В этом случае
         scanf читает и преобразовывает введенные символы к значениям  за-
         данного типа, причем значения определяются соответствующими аргу-
         ментами из списка аргументов.
            
               Строка формата читается слева направо. Символы вне специфи-
         кации формата предполагаются согласованными с последовательностью
         символов в потоке stdin; эти согласованные символы в stdin скани-
         руются,  но  не  запоминаются.  Если  символ в stdin противоречит
         строке формата, scanf оканчивает свою работу. Этот  конфликтующий
         символ остается в stdin, так как он не может быть прочитан. Когда
         встречается  первая  спецификация формата, тогда значение первого
         поля ввода преобразовывается в соответствии со спецификацией фор-
         мата и запоминается в месте, заданном первым аргументом. По  вто-
         рой  спецификации формата выполняется преобразование второго поля
         ввода и запоминание его по второму  аргументу;  и  так  до  конца
         строки формата.
               Поле  ввода ограничивается первым "пробельным" символом или
         первым символом, который не может  преобразоваться  по  заданному
         формату, или случаем достижения поля width, которое идет первым.
               Если для выбранной спецификации формата задано больше аргу-
         ментов, чем требуется, то лишние аргументы игнорируются.
               Спецификация формата имеет следующую форму.

               %<flags><wigth><.precision><{F:N:h:I}><type>.
            
               Каждое  поле в формате спецификаций является отдельным сим-
         волом или числом,  выражающим  отдельную  опцию  формата.  Символ
         type, появляющийся после последнего необязательного поля формата,
         определяет тип поля ввода как символьного, строкового или числен-
         ного.
               Простейший формат спецификации содержит только символ знака
         процента и символ типа (например, %S).
               Каждое поле спецификации формата описывается ниже.
               Если  за  знаком  процента  % следует символ, не являющийся
         символом управления форматом, то этот символ и идущие за ним сим-
         волы, вплоть до следующего знака %, трактуются как обычная после-
         довательность символов, т.е. последовательность,  которая  должна
         быть введена. Например, чтобы ввести символ знака %, используется
         комбинация %%.
               Звездочка  (*),  идущая  за  знаком %, подавляет назначение
         следующего поля ввода, задающегося как поле,  определяемое  типом
         type. Это поле сканируется, но не запоминается.
               Widht  является  положительным десятичным целым и управляет
         максимально возможным числом символов, считываемых из stdin. Пре-
         образовываются и запоминаются по соответствующему аргументу толь-
         ко те символы, которые не превышают width. Если в width  встреча-
         ются  "пробельные"  символы,  т.е. символы пробела, табуляции или

                                      - 198 -
         
         
         новой строки, то по выбранному формату они не  преобразовываются,
         пока не будет достигнут размер width.
               Необязательные  префиксы  F  и  N  не учитывают принятое по
         умолчанию адресное соглашение используемых моделей памяти. F  мо-
         жет  быть префиксом к аргументу argument, указыващему на far-объ-
         ект; а N - на near-объект.
               Необязательный префикс l свидетельствует о том, что исполь-
         зуется версия long; а префикс h - указывает на использование вер-
         сии  short.  Соответствующий  argument  указывает  на  long   или
         double-объект  (при  помощи префикса l)  или на short-объект (при
         помощи префикса h). Модификаторы l и h могут использоваться вмес-
         те с типами символов d, i, o, x, u. Модификатор l также может ис-
         пользоваться с символами type e и f. Если определен любой  другой
         type, модификаторы l и h игнорируются.
                
               Символы type и их значения описаны в таблице R.4.
            
                                                        Таблица R.4
               
                           Типы символов функции scanf
            
            СИМВОЛ    ПРЕДПОЛАГАЕМЫЙ ТИП        ТИП АРГУМЕНТА
                           ВВОДА
           
      
              d       десятичный   целый     указатель на  int.
                
              D       десятичный   целый     указатель на  long.
           
              o       восьмеричный целый     указатель на  int.
            
              O       восьмеричный целый     указатель на  long.
                                       
              x       шестнадцатеричный      указатель на  int.
                      целый
            
              X       шестнадцатеричный      указатель на  long.
                      целый
            
              i       десятичный,  вось-     указатель на  int.
                      меричный или шест-
                      надцатеричный  це-
                      лый
      
              I       десятичный,  вось-     указатель на  long.
                      меричный или шест-
                      надцатеричный  це-
                      лый
            
              u       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          int.
                                        
              U       беззнаковый  деся-     указатель на unsigned
                      тичный  целый          long.
                                        

                                      - 199 -
         
         
              e       значение с  плава-     указатель на  float
              f       ющей  точкой,  со-
                      держащее  необяза-
                      тельный знак ("+",
                      "-"),   одну   или
                      больше  десятичную
                      цифру, обычно  со-
                      держащую  десятич-
                      ную точку и экспо-
                      ненту ("е", "Е"),
                      которая    записы-
                      вается за знаковым
                      целым   значением.
                                        
              c       символьный. Симво-     указатель на  char
                      лы пробела,  табу-
                      ляции   или  новой
                      строки, так  назы-
                      ваемые "пробельные
                      символы",  которые
                      обычно  пропускают-
                      ся,  при   задании
                      этого типа  считы-
                      ваются. Для считы-
                      вания   следующего
                      символа, не являю-
                      щегося   "пробель-
                      ным", используется
                      комбинация %1s.
            
              s       строковый.             указатель на символь-
                                             ный массив, достаточ-
                                             но большой для вводи-
                                             мого  поля  вместе с
                                             нулевым     символом
                                             окончания '\0',  по-
                                             являющимся автомати-
                                             чески.
            
              n       чтение  при  вводе     указатель на  int, в
                      из   stream    или     котором записывается
                      буфера  не  проис-     число  успешно  счи-
                      ходит.                 танных  символов  из
                                             потока  или  буфера,
                                             вплоть до  указанных
                                             в вызове scanf.
                                              
              p       значение в   форме     указатель   на  far-
                      xxxx : yyyy,   где     группу данных.
                      цифры x и y  явля-
                      ются  шестнадцате-
                      ричными    цифрами
                      верхнего регистра.

            

                                      - 200 -
         
         
               При  чтении  строк, не ограниченных символами пробела, мно-
         жество символов в квадратных скобках [] должно заменяться строко-
         вым типом s. Соответствующее поле ввода читается вплоть до перво-
         го символа, не содержащегося в ограниченном квадратными  скобками
         множестве символов. Если в этом множестве первым символом являет-
         ся  caret  (^),  результат сохраняется: поле ввода считывается до
         первого символа, не входящего в это множество символов. Чтобы за-
         помнить строку без нулевого символа '\0', применяется  специфика-
         ция %nc, где n - десятичное целое. В этом случае символьный тип s
         определяет  аргумент,  который указывает на массив символов. Сле-
         дующие  n  символов считываются из входного потока в определенное
         местоположение  и нулевой символ не записывается.
               Функция scanf для каждого поля ввода  сканирует  символ  за
         символом.  Она может окончить чтение отдельного поля при достиже-
         нии символа пробела, если либо достигнуто поле width; либо следу-
         ющий вводимый символ не может быть преобразован по заданному фор-
         мату; либо следующий символ  конфликтует  с  соответствующим  ему
         символом  в  управляющей строке формата; либо же следующий символ
         отсутствует в выбранном множестве символов. Когда происходит  вы-
         нужденный  процесс  окончания считывания, то следующее поле ввода
         рассматривается с самого  первого  конфликтующего  символа.  Этот
         символ, если он один, рассматривается как непрочитанный, либо как
         первый  символ  следующего  поля  ввода, либо как первый символ в
         последующих операциях чтения потока stdin.
            
               Возвращаемое значение.
            
               Эта функция возвращает число успешно преобразованных и наз-
         наченных полей. В возвращаемом значении не содержится число  про-
         читанных   но  не назначенных полей. При попытке считывания конца
         файла возвращается значение EOF. Возвращаемое значение 0 указыва-
         ет, что нет назначенных полей.
               См.  также  fscanf,  printf,  sscanf,  vfprintf,   vprintf,
         vsprintf.
            
               Пример 1.
            
            #include <stdio.h>
            
            int i;
            float fp;
            char c, s[81];
            
            scanf("%d  %f  %c  %s", &i, &fp, &c, s);
            /* ввод различных данных */.
            
            Пример 2.
            
            #include <stdio.h>
            
            main ()          /* преобразование шестнадцатеричного
                             ** или  восьмеричного   целого     к
                             ** десятичному целому  */
            {
            int numassigned, val;

                                      - 201 -
         
         
            
            pintf("Enter hexadecimal or octal #, or 00
                   to guit:\n");
            do
               {  printf("# = ");
                  numassigned = scanf("%i", &val);
                  printf("Decimal # = %i\n", nal);
               }
            while (val && numassigned);
      
               /*  конец  цикла,  если  значение  ввода равно 00, или если
         scanf не способна назначить поле */.
            
            }

               Тогда на выходе будет следующее.
            
            Enter hexadecimal or octal #, or 00 to guit:
                
            # = 0xf
            Decimal # = 15
                
            # = 0100
                
            Decimal # = 64
                
            # = 00
                
            Decimal # = 0.
            
           
            
               SEGREAD
           
            #include <dos.h>
            
            void segread (segregs);
            struct SREGS *segregs;    значения регистров сегмента
            
               Описание.
            
               Функция  segread  заполняет структуру, на которую указывает
         segregs, текущим содержимым регистров сегмента. Эта функция может
         использоваться вместе с функциями intdosx и int86, чтобы  восста-
         навливать значения регистров сегментов, используемых последними.
            
               Возвращаемое значение.
            
               Возвращаемого значения нет.
               См.также intdosx, int86x, FP_SEG.
            
               Пример:
            
            #include <dos.h>
            

                                      - 202 -
         
         
            struct SREGS segregs;
            unsigned int cs, ds, es, ss;
            
               /* следующие операторы задают  текущие  значения  регистров
         сегмента */
            
            segread(&segregs);
            cs=segregs.cs;
            ds=segregs.ds;
            es=segregs.es;
            ss=segregs.ss;
           
           
            
            SETBUF

            #include <stdio.h>
            
            void setbuf(stream, buffer);
            FILE *stream;        указатель на структуру FILE
            char *buffer;        буфер, размещаемый пользователем.
            
               Описание.
            
               Функция setbuf позволяет пользователю управлять буферизаци-
         ей  потока  stream.  Аргумент  stream может ссылаться на открытый
         файл. Если аргумент buffer является NULL, то stream не  буферизо-
         ванный;  если  поток буферизованный, то buffer может указывать на
         массив символов  размером BUFSIZ, где размер BUFSIZ  определен  в
         <stdio.h>. Пользователь может использовать буфер buffer для буфе-
         ризации  ввода/вывода  вместо  буфера,  размещаемого  системой по
         умолчанию для потока stream.
               Стандартные потоки stderr и stdaux по умолчанию являются не
         буферизованными, но при использовании функции setbuf   они  могут
         назначать буферы.
            
               Возвращаемое значение.
            
               У этой функции возвращаемого значения нет.
               См. также fflush, fopen, fclose.
            
               Пример:
            
            #include <stdio.h>
            
            char buf[BUFSIZ];
            FILE *stream1, stream2;
            
            stream1 = fopen("data1", "r");
            stream2 = fopen("data2", "w");
            
            setbuf(stream, buf);
         /* stream1 использует буфер, назначенный пользователем */
            setbuf(stream, NULL);
         /* stream2 является небуферизованным */.

                                      - 203 -
         
         
           
           
            
               SETJMP
            
            #include<setjmp.h>
            
            int setjmp(env);
            jmp_buf env;                   переменная, в  которой
                                           хранится окружение.
            
               Описание.
            
               Функция  setjmp  сохраняет  состояние  стека, который может
         быть последовательно восстановлен посредством использования функ-
         ции longjmp.
               Функции setjmp и longjmp обеспечивают возможность  выполне-
         ния  нелокального  (nonlocal)  перехода и обычно используются для
         передачи управления к обработке ошибок  для восстановления кода в
         ранее вызванной процедуре (без  использования  обычного  вызова),
         для возврата условных обозначений. Вызов setjmp активизирует сох-
         ранение текущего состояния стека в env. Последующий вызов longjmp
         восстанавливает  сохраненное состояние и возвращает управление на
         указатель (точку входа), непосредственно следующий за  соответст-
         вующим вызовом setjmp. Когда вызывается функция longjmp, значения
         всех  переменных  (за исключением переменных регистра) становятся
         доступными для процедуры, которая принимает управление и содержит
         значения этих переменных. Значения переменных регистра непредска-
         зуемы.
            
               Возвращаемое значение.
            
               После сохранения состояния стека функция setjmp  возвращает
         значение 0. Если в результате вызова longjmp возвращается setjmp,
         тогда возвращается и значение value аргумента longjmp. Возвращае-
         мого значения в случае ошибки нет.
               См. также longjmp.
            
               Замечание. После выполнения longjmp значения переменных ре-
         гистра в процедуре, вызывающей setjmp, не могут быть восстановле-
         ны (возвращены) к собственным значениям.
       
            
               Пример:
            
            #include <stdio.h>
            #include <setjmp.h>
            
            jmp_buf mark;
            
            main()
                 {
                 if (setjmp(mark) != 0)
           
                 {   printf("longjmp has been called\n");

                                      - 204 -
         
         
                     recover();
                     exit(1);
                  }
                 printf("setjmp has been called\n");
                 .
                 .
                 .
                 p();
                 .
                 .
                 .
                 }
                
            
                p()
                {
      
                int error = 0;
                .
                .
                .
                if (error != 0)
                   longjmp(mark, -1);
                .
                .
                .
                }
            
                recover()
                {
            
               /*  при  выходе из программы убедитесь, что файлы данных не
         будут запорчены */
            
                .
                .
                .
                }.
           
           
            
            
               SETMODE
            
            #include <fcntl.h>
            #include <io.h>    требуется только для объявления
                               функции
            
            int setmode(handle,mode);
            int handle;        файловый handle
            int mode;          новый режим преобразования
            
               Описание.
            
               Функция setmode устанавливает в mode  режим  преобразования

                                      - 205 -
         
         
         файла, заданного по handle.
               Mode может быть одной из следующих констант.

         Manifest-константа                Ее значение
           
          O_TEXT           Устанавливается  текстовый  режим  пре-
                           образования. Комбинация "Возврат карет-
                           ки - Перевод строки"  преобразуется  на
                           входе к одному символу "Перевод строки"
                           (ПС). Символ ПС на выводе преобразуется
                           в комбинацию "Возврат каретки - Перевод
                           строки".
                           
         O_BINARY          Устанавливается  двоичный  режим.   Все
                           вышеприведенные преобразования  не под-
                           держиваются.

               Функция  setmode обычно используется для модификации режима
         преобразования, устанавливаемого по умолчанию, для stdin, stdout,
         stderr, stdaux, stdprn, но может использоваться для любого файла.
            
               Возвращаемое значение.
            
               В случае верной установки функция setmode возвращает преды-
         дущий режим преобразования. Возвращаемое значение -1 указывает на
         ошибку  и errno устанавливается в одно из следующих значений:
            
            
          Значение                      Его смысл
            
          EBADF                Неверный файловый handle.

          EINVAL               Неверный аргумент mode. (Ни O_TEXT,  ни
                               O_BINARY).

               См.также create, fopen, open.
           
            
               Пример:
                
            #include <stdio.h>
            #include <fcntl.h>
            #include <io.h>
            
            int result;
            
               /* следующий оператор устанавливает stdin в режим  преобра-
         зования binary (первоначально он был text) */
            
            result = setmode(fileno(stdin), O_BINARY);
           
           
            
            

                                      - 206 -
               
               SETVBUF
         
         
            #include <stdio.h>
            
            int setvbuf(stream, buf, type, size);
           
            FILE *stream;      указатель на структуру FILE
            char *buf;         буфер, назначенный пользователем.
            int type           тип буфера:
                                   _IONBF - нет буфера;
                                   _IOFBF - полная буферизация;
                                   _IOLBF - строковая буферизация.
            int size;          размер буфера.
            
               Описание.
            
               Функция  setvbuf позволяет пользователю управлять буфериза-
         цией и размером буфера для потока stream. Stream может  ссылаться
         на  открытый файл. Массив, на который указывает buf, используется
         как буфер, если он не является NULL, т.е. поток не является буфе-
         ризованным. Если поток буферизованный, используется тип,  опреде-
         ленный по type; этот тип может быть либо _IONBF, либо _IOFBF, ли-
         бо  _IOLBF. Если используется тип _IOFBF, размер буфера определя-
         ется по size; если используется тип _IOLBF или _IONBF, поток  яв-
         ляется небуферизованным, а size и buf игнорируются.
            
            ЗНАЧЕНИЕ ТИПА              ЕГО СМЫСЛ
            
            _IONBF             Буфер не используется, несмотря  на
                               присутствие size и buf
            
            _IOFBF             Полная буферизация, если buf не яв-
                               ляется  NULL;  поэтому  buf исполь-
                               зуется в качестве буфера, а  size -
                               его размера
            
            _IOLBF             Аналогично _IOFBF
            
               Истинное  значение  size  обычно больше 0, но меньше макси-
         мального целого размера.
            
               Возвращаемое значение.
            
               Эта функция возвращает ненулевое  значение,  если  тип  или
         размер буфера неправильно определен, и возвращает значение 0, ес-
         ли все определено верно.
               См. также setbuf, fflush, fopen, fclose.
            
           
               Пример:
            
            #include <stdio.h>
            
            char buf[1024];
           
            FILE *stream1, *stream2;
            

                                      - 207 -
         
         
            main()
            
            {
            stream1 = fopen("data1", "r");
            stream2 = fopen("data2", "w");
            
               /*  Stream1  будет использовать буфер размером 1024 байта и
         назначенный пользователем, а stream2 является небуферизованным */
            
            if (setvbuf(stream1, buf, _IOFBF, sizeof(buf)) !=0)
                  printf("Incorrect type or size of buffer1\n");
            if (setvbuf(stream2, _IONBF, 0) != 0)
                  printf("Incorrect type or size of buffer2\n");
            }.
           
           
               SIGNAL
            
            #include <signal.h>
            
            int (*signal(sig, func)();
            int sig;                           значение сигнала
            int (*func)();                     выполняемая функция
            
               Описание.
            
               Функция signal позволяет выбрать  из  операционной  системы
         один  из трех способов обработки сигнала прерывания. Аргумент sig
         может быть одной из манифестных констант SIGINT или SIGFPE, опре-
         деленых в <signal.h>. Манифестная константа SIGINT  соответствует
         в  MS DOS сигналу прерывания INT 23H. SIGFPE соответствует преры-
         ваниям плавающей точки, которые не маскированы, такие  как  пере-
         полнение, деление на ноль, неверная операция. Аргумент func может
         быть одной из манифестных констант SIG_DFL или SIG_IGN (также оп-
         ределенных в <signal.h>), или адресом функции. При получении сиг-
         нала  прерывания  принимаемое действие зависит от значения func и
         является следующим:
            
         ЗНАЧЕНИЕ                           ЕГО СМЫСЛ
            
         SIG_IGN           Сигнал   прерывания  игнорируется.  Это
                           значение для SIGFPE не задается,   т.к.
                           состояние  процесса  с плавающей точкой
                           остается неопределенным.
                           
         SIG_DFL           Вызванный процесс завершен;  управление
                           передается   на  уровень команд MS DOS.
                           Все файлы, открытые в процессе,  закры-
                           ваются, но буферы не обновляются.
                           
         Адрес функции     Для сигналов SIGINT функции, на которую
                           указывает func,  передается    аргумент
                           SIGINT и она выполняется. Если  функция
                           завершается нормально, прерванный  про-
                           цесс возобновляет выполнение с команды,

                                      - 208 -
         
         
                           следующей за той, в которой был получен
                           сигнал  прерывания.  Перед  выполнением
                           специфицированной функции значение func
                           устанавливается  в  SIG_DFL;  следующий
                           сигнал прерывания трактуется как и  для
                           SIG_DFL,  если  внешний  вызов  signal,
                           задающий другое значение прерывания, не
                           определен.  Это  позволяет пользователю
                           переустанавливать сигналы  в вызываемых
                           функциях, если необходимо. Для   SIGFPE
                           функциц,   на  которую  указывает func,
                           передаются два аргумента - SIGFPE и це-
                           лый подкод ошибки,  FPE-xxx-,  и  затем
                           она выполняется. (Смотрите include-файл
                           <float.h>   для   определения  подкодов
                           FPE-xxx.)     Значение     func      не
                           переустановится  до  тех  пор,  пока не
                           будет  получен  сигнал прерывания;  для
                           выхода  из  состояния  плавающей  точки
                           используется  setjmp  вместе  с longjmp
                           (см. пример  для функции_fprset).  Если
                           функция завершается нормально, прерван-
                           ный    процесс     возобновляется     в
                           неопределенном    состоянии   плавающей
                           точки.
                           
                           
               Возвращаемое значение.
            
               Функция signal возвращает предыдущее значение func. Возвра-
         щаемое значение -1 свидетельствует об ошибке и errno устанавлива-
         ется в EINVAL, определяя неверное значение sig.
               См.также abort, exit,  _exit,  _fpreset,  spawnl,  spawnle,
         spawnlp, spawnv, spawnve, spawnvp.
            
               Замечание: В тех child-процессах, которые созданы посредст-
         вом  вызова процедур exec или spawn, установленные сигналы преры-
         ваний не сохраняются. Эти сигналы в child-процессе переустанавли-
         ваются по умолчанию.
      
               Пример:
            
            #include <stdio.h>
            #include <signal.h>
            #include <stdlib.h>
            #include <process.h>
            int handler();
            
            main()
                  {
                  if(signal(SIGINT, handler)==(int(*)())-1) {
                      fprintf(stderr,"couldn't set SIGINT\n");
                      abort();
                      }
                      .

                                      - 209 -
         
         
                      .
                      .
                  }
            
            int handler()
                  {
                  char ch;
                  printf("terminate processing? ");
           
                  scanf("%1c", &ch);
                  if (ch=='y' ::ch=='Y')
                        exit(0);
                  signal(SIGINT, handler);
                  }
            
               /* функция signal, вызванная здесь для  следующего  сигнала
         прерываний, посылает управление не в ОС, а к handler() */
            
           
            
               SIN-SINH
            
            #include <math.h>
            
            double sin(x);         вычисляет синус x
            double sinh(x);        вычисляет гиперболический синус
                                   x
            double x;              радиан
            
               Описание.
            
               Функции  sin и sinh вычисляют соответственно синус и гипер-
         болический синус x.
            
               Возвращаемое значение.
            
               Функция sin возвращает синус x. Если x  большой,  то  может
         возникнуть  частичная потеря значимости результата. В этом случае
         sin вырабатывает ошибку PLOSS, но сообщения не печатает.  Если  x
         настолько большой, что теряется общая значимость результата, тог-
         да  sin  печатает сообщение об ошибке TLOSS в stderr и возвращает
         0. В обоих случаях errno устанавливается в ERANGE.
               Функция sinh возвращает гиперболический синус x.  Если  ре-
         зультат большой, sinh возвращает значение HUGE (отрицательное или
         положительное, в зависимости от знака x)  и устанавливает errno в
         ERANGE.
               Обрaботкa  ошибок  может  быть модифицировaнa при изменении
         процедуры matherr.
               См.также acos, asin, atan, atan2, cos, cosh, tan, tanh.
            
               Пример:
            
            #include <math.h>
            
            double pi = 3.1415926535,x,y;

                                      - 210 -
         
         
            
            x = pi/2;);
            y = sin(x);  /* y равен 1.0 */
            
            y = sinh(x); /* y равен 2.3 */
           
           

               SOPEN
            
            #include <fentl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <sharc.h>
            #include <io.h>        требуется только для объявления
                                   функции
            
            int sopen(pathname,oflag,shflag{,pmode]);
            char *pathname;        path-имя  файла
            int oflag;             тип разрешенных операций
            int shflag;            разрешенный тип разделения
            int pmode;             разрешенный тип доступа
            
               Описание.
            
               Функция sopen открывает файл,  заданный  по  path-имени,  и
         подготавливает его к последующему разделенному чтению или записи,
         что определяется значением oflag или shflag. Oflag является целым
         выражением,  состоящим из комбинации одной или нескольких следую-
         щих манифестных констант, объявленных в <fcntl.h>.  Когда  задана
         более  чем одна манифестная константа, тогда они объединяются при
         помощи оператора ИЛИ(:).

            OFLAG                          ЗНАЧЕНИЕ
                            
            O_APPEND        Перед   каждой    операцией     записи
                            перемещает указатеь  на  файл  в конец
                            файла.
                            
            O_CREAT         Новый файл создан и открыт для записи;
                            это  не  эффективно,  если  существует
                            файл, определяемый по path-имени.
                            
            O_EXCL          Возвращается  значение  ошибки,   если
                            существует файл, определяемый по path-
                            имени. Используется вместе с O_CREATE.

            O_RDONLY        Файл  открыт  только  для чтения, если
                            задан этот флаг, также может быть  вы-
                            бран флаг O_RDWR или O_WRONLY.
                            
            O_RDWR          Файл открыт одновременно для чтения  и
                            записи; если  задается  этот  флаг, то
                            может быть выбран флаг  O_RDONLY   или
                            O_WRONLY.

                                      - 211 -
         
         
                            
            O_TRUNC         Существующий  файл  открыт  и усечен к
                            длине 0; этот файл должен иметь разре-
                            шение  на  запись.   Содержимое  файла
                            уничтожается.
           
            O_WRONLY        Файл  открыт  только  для чтения; если
                            задан этот  флаг,  должен  быть  задан
                            флаг O_RDONLY или O_RDWR.
                            
            O_BINARY        Файл открыт в двоичном  (не транслиро-
                            ванном) режиме.  (См. описание  двоич-
                            ного режима у функции  fopen).
                            
            O_TEXT          Файл открыт в текстовом (транслирован-
                            ном) режиме.   (См.  описание  тексто-
                            вого режима у функции fopen).
            
               Замечание:  O_TRUNC полностью уничтожает содержимое сущест-
         вующего файла, поэтому нужно внимательно использовать  эту  конс-
         танту.
               Аргумент  shflag является константным выражением, состоящим
         из следующих манифестных констант, объявленных в <share.h>.  Под-
         робно  информация  о режиме разделения приведена в руководстве по
         MS DOS.
      
            shflag                          Значение
            
           SH_COMPAT        устанавливается режим совместимости
            
           SH_DENYRW        доступ по чтению  и записи в файле  не
                            разрешен
      
           SH_DENYWR        доступ по записи в файле не разрешен
            
           SH_DENYRD        доступ по чтению в файле не разрешен
            
           SH_DENYNO        доступ по чтению и записи разрешен
            
            
               Аргумент pmode требуется  только  тогда,  когда  определена
         константа 0_CREAT. Если файл не существует, pmode также определя-
         ет  типы доступа для файла, которые устанавливаются во время пер-
         вого закрытия нового файла. В противном случае аргумент pmode иг-
         норируется. Аргумент pmode является целым выражением,  содержащим
         одну  или  больше манифестных констант S_IWRITE и S_IREAD, объяв-
         ленных в <sys\stat.h>. Когда задаются обе константы, они объединя-
         ются оператором ИЛИ(!). Значение аргумента pmode приведено ниже.
            
            КОНСТАНТА            ЕЕ СМЫСЛОВОЕ ЗНАЧЕНИЕ
            
            S_IWRITE             разрешает запись
            
            S_IREAD              разрешает чтение


                                      - 212 -
         
         
            S_IREAD:S_IWRITE     разрешают чтение и запись

               Если запись не разрешена, файл предназначен только для чте-
         ния.  В MS DOS все файлы открыты для чтения, разрешение по записи
         не задается. Поэтому модели S_IWRITE и S_IREAD: S_IWRITE являются
         эквивалентными.
               Перед  установкой разрешения функция sopen прикладывает те-
         кущую маску файла к pmode (см. umask).
            
               Возвращаемое значение.
            
               Функция sopen возвращает handle-р на открытый файл. Возвра-
         щаемое значение -1 указывает на ошибку; errno  устанавливается  в
         одно из следующих значений:
            
            ЗНАЧЕНИЕ                ЕГО СМЫСЛ
      
            EACCES         Заданное path-имя является директорием
                           или сделана попытка  записать  в  файл,
                           открытый   только   для   чтения,   или
                           возникло нарушение в режиме разделения.
                           (Версии MS DOS 3.0 и старше).
            
            EINVAL         Командный файл SHARE.COM не инстоллиро-
                           ван.
            
            EEXIST         Флаги O_CREAT и O_EXCL  определены,  но
                           названный файл всегда существует.
                           
            EMFILE         Другие handle-ры  файла  не   доступны,
                           т.к. много открытых файлов.
                           
            ENOENT         Файл или path-имя не найдено.

               См.также close, create, fopen, open, umask.
            
               Замечание:  Функция sopen используется в версиях 3.0 MS DOS
         и старших. В ранних версиях MS DOS аргумент shflag игнорируется.
               Режимы разделения файлов работают неверно с буферизованными
         файлами, поэтому fdopen не используется для связи потока и файла,
         открытого к разделению или закрытию.
            
               Пример:
            
            #include <fcntl.h>
            #include<sys\types.h>
            #include<sys\stat.h>
            #include<share.h>
            #include<io.h>
            
            extern unsigned char _osmajor;
            int fh;
            
                
               /* Перед вызовом sopen используется переменная _osmajor для

                                      - 213 -
         
         
         проверки номера версии MS DOS . */.
           
            if (_osmajor >=3)
               fh = sopen ("data", O_RDWR:O_BINARY, SH_DENYRW);
            
            else
               fh = open ("data", O_RDWR: O_BINARY);


               SPAWNL-SPAWNVPE
            
               #include <stdio.h>
               #include <process.h>
            
         int spawnl(modeflag,pathname,arg0,arg1...,argn,NULL);
         int spawnle(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
         int spawnlp(modeflag,pathname,arg0,arg1...,argn,NULL);
         int spawnlpe(modeflag,pathname,arg0,arg1...,argn,NULL,envp);
         int spawnv(modeflag,pathname,argv);
         int spawnve(modeflag,pathname,argv,envp);
         int spawnvp(modeflag,pathname,argv);
         int spawnvpe(modeflag,pathname,argv,envp);
            
         int modeflag;               режим выполнения parent-процесса
         char *pathname;             path-имя выполняемого файла
         char *arg0,*arg1...,*argn;  список указателей на аргументы
         char *argv[];               массив указателей на аргументы
         char *envp[];               массив указателей на установлен-
                                     ное окружение
                                
               Описание.
                                 
               Функции  spawn создают и выполняют новый child-процесс. Для
         загрузки и выполнения child-процесса должно быть доступно  доста-
         точно  памяти.  Аргумент modeflag определяет действия, выбираемые
         parent-процессом перед и на протяжении spawn. Следующие  значения
         modeflag объявлены в <process.h>
                           
         Значение                        Его смысл
                           
         P_WAIT               Приостанавливает  parent-процесс,  пока
                              не завершится child-процесс.
                           
         P_NOWAIT             Продолжает  выполнение  parent-процесса,
                              параллельного с child-процессом.
          
         P_OVERLAY            Parent-процесс  перекрывается с  child-
                              процессом; parent-процесс  уничтожается
                              (то же действие, что и при вызовах exec)
            
               Могут  использоваться  только  значения modeflag, такие как
         P_WAIT и P_OVERLAY. Значение P_NOWAIT сохраняется  для  возможной
         будущей реализации. Если используется P_NOWAIT, возвращается зна-
         чение  ошибки. Аргумент pathname определяет файл, выполняемый как
         child-процесс. Pathname может определять полный path (из  корня),
         часть path (из текущего рабочего директория), или просто имя фай-
         ла.



