                                      - 137 -
                                          
                                     
            
               INP
      
               #include <conio.h>      требуется  только   для  объявления
                                       функции
               int inp(port);
               unsigned port;          номер порта
            
               Описание.
            
               Функция  inp читает 1 байт из порта ввода, определенного по
         port. Аргумент port может быть любым беззнаковым целым  числом  в
         пределах от 0 до 65535.
            
               Возвращаемое значение.
            
               Функция inp возвращает прочитанный байт из port. Возвращае-
         мого значения в случае ошибки нет.
               Смотри также output.

                                     
               Пример:
            
               #include <conio.h>
               unsigned port;
               char result;
               .
               .
               .
               /*  следующий оператор вводит тот байт из порта, на который
         установлен port */
            
               result=inp(port);
               INT86
               #include <dos.h>
               int int86(intno,inregs,outregs);
               int ntno;                     номер (число) прерывания зна-
               union REGS *inregs;           чения  регистров  при вызове
               union REGS *outregs;          значения  регистров  при воз-
                                             врате
                
               Описание.
                
               Функция int86 выполняет прерывание 8086 программного  обес-
         печения,  которое  определено номером прерывания intno. Перед вы-
         полнением прерывания int86 копирует содержимое inregs в соответс-
         твующие регистры. После возврата прерывания функция копирует зна-
         чение текущего регистра в outregs. Она также копирует статус  пе-
         реносимого  флага  системы  в поле cflag, содержащееся в outregs.
         Аргументы inregs и outregs являются объединениями типа REGS.  Тип
         объединения объявлен в include-файле <dos.h>. Использование функ-
         ции int86 предназначено для вызовов прерываний DOS.
                
                

                                      - 138 -

               
               Возвращаемое значение.
         
               Возвращаемым значением является значение в регистре AX пос-
         ле возврата прерывания. Если поле cflag в outregs ненулевое, воз-
         никает ошибка и переменная _doserrno также устанавливает соответ-
         ствующий код ошибки.
               Смотри также bdos, intdos, intdosx, int86x.
                
               Пример:
                
               #include <signal.h>
               #include <dos.h>
               #include <stdio.h>
               #include <process.h>
                
               /*  прерывание  номер 0х23, подхватываемое процедурой обра-
         ботки прерываний int_handler.  Замечание:  Значения  в  структуре
         regs не имеют смысла для этого прерывания. */
                
               #define CNTRL_C 0x23
               int int_handler(int);
               union REGS regs;
               .
               .
               .
               signal (SIGINT, int_handler);
               .
               .
               .
               int86 (CNTRL_C, &regs, &regs);
               
               
               INT86X
                
               #include <dos.h>
               int int86x(intno,inregs,outregs,segregs);
               int intno;                    номер (число) прерываний
               union REGS *inregs;           значение  регистров  при
                                             вызове
               union REGS *outregs;          значение  регистров  при
                                             возврате
               struct SREGS *segregs;        значение  сегментов  при
                                             вызове
             

                                     
               Описание.
                
               Функция int86x выполняет прерывание 8086 программного обес-
         печения,  которое  определено номером прерывания intno. В отличие
         от функции int86, функция int86x принимает значения регистра сег-
         мента в segregs, позволяя программам, использующим сегменты  дан-
         ных  большой  модели или far-указатели, определять, какой сегмент
         или указатель должен быть использован в процессе системного вызо-
         ва. Перед выполнением определенного  прерывания  int86x  копирует
         содержимое inregs и segregs в соответствующие регистры. В segregs
         используются  только  значения  регистров DS и ES. После возврата

                                      - 139 -
         
         
         прерываний функция копирует значения текущего регистра в  outregs
         и  перезаписывает DS. Она также копирует состояние (статус) пере-
         носимого флага системы в поле cflag, содержащееся в outregs.  Ар-
         гументы  inregs и outregs являются объединениями типа REGS. Аргу-
         мент segregs является структурой типа SREGS. Эти типы объявлены в
         include-файле <dos.h>. Использование функции int86x предназначено
         для прямого вызова прерываний DOS, которые берут аргумент  в  ре-
         гистре  ES  или значение регистра DS, которое отличается от умал-
         чиваемого сегмента данных.
                
               Возвращаемое значение.
                
               Возвращаемым значением является значение в регистре AX пос-
         ле возвращения прерываний. Если поле flag в outregs является  не-
         нулевым, возникает ошибка и переменная _doserrno также устанавли-
         вает соответствующий код ошибки.
               См.также bdos, intdos, intdosx, int86, segread, FP_SEG.
                
               Замечание!  Значения  сегмента  для  аргумента segreg могут
         быть получены либо при использовании функции segread, либо  макро
         FP_SEG.
      
               Пример:
                
               #include <signal.h>
               #include <dos.h>
               #include <stdio.h>
               #include <process.h>
                
               /* процедура int86x используется для генерирования прерыва-
         ния 0х21 (системный вызов), который, в свою очередь, активизирует
         системный  вызов  "Изменение  атрибутов"  DOS. Здесь используется
         процедура int86x, поскольку ссылка на имя файла может  находиться
         в сегменте, отличном от умалчиваемого сегмента данных (ссылка при
         помощи  far-указателя), поэтому регистр DS может быть точно уста-
         новлен со структурой SREGS. */
                
               #define SYSCALL 0x21
               /* INT 21H вызывает системные вызовы */
               #define CHANGE_ATTR 0x43
               /* системный вызов 43H - изменения атрибутов */
               char far *filename;
               /* имя файла в far-сегменте данных */
               union REGS inregs, outregs;
               struct SREGS segregs;
               int result;
               .
               .
               .
               inregs.h.ah=CHANGE_ATTR;
               /* AH - номер (число) системного вызова */
               inregs.h.al=0;
               /* AL - функция вызова атрибутов */
               inregs.x.dx=FP_OFF(filename);
               /* DS:DX указывают на имя файла */

                                      - 140 -
         
         
               segregs.ds=FP_SEG(filename);
               result=int86x(SYSCALL,&inregs,&outregs,&segregs);
               if (outregs.x.cflag) {
                   printf("can't get attributes of file; error
                           number %d\n", result);
                   exit(1);
                   }
               else {
                   printf("Attribs=%#x\n", outregs.x.cx);
                   }
                
               INTDOS
                
                
               #include <dos.h>
               int intdos(inregs, outregs);
               union REGS *inregs;           значения  регистров  при
                                             вызове
               union REGS *outregs;          значения  регистров  при
                                             возврате
                
               Описание.
                
               Функция intdos осуществляет выполнение системного вызова MS
         DOS, который определен значением регистров, объявленных в inregs,
         и возвращает результат системного  вызова  в  outregs.  Аргументы
         inregs  и outregs являются объединениями типа REGS. Тип объедине-
         ния объявлен в include-файле <dos.h>.
               Для осуществления системного вызова intdos выполняет коман-
         ду INT 21H. Перед выполнением команды функция копирует содержимое
         inregs в соответствующие регистры. После  возврата  команды  INT,
         intdos  копирует  значение текущего регистра в outregs. Она также
         копирует статус переносимого флага системы в поле  cflag,  разме-
         щенное в outregs. Если это поле является ненулевым, флаг устанав-
         ливается системным вызовом и указывает на условие ошибки.
               Функция  intdos используется для выполнения системных вызо-
         вов DOS, которые берут аргументы  в  регистрах,  отличных  от  DX
         (DH/DL) и AL, или для системных вызовов, которые определяют ошиб-
         ки посредством переносимого флага.
                
               Возвращаемое значение.
                
               Функция intdos возвращает значение регистра AX после завер-
         шения системного вызова. Если поле cflag в outregs является нену-
         левым,  возникает ошибка  и _doserrno устанавливает соответствую-
         щий код ошибки.
               См.также bdos, intdosx.
                
               Пример:
                
                
               #include <dos.h>
               #include <stdio.h>
               union REGS inregs, outregs;
               .

                                      - 141 -
         
         
               .
               .
               /* следующие операторы  выбирают  текущую  дату,  используя
         шестнадцатеричный вызов функции DOS 2a */
               inregs.h.ah=0x2a;
               intdos(&inregs,&outregs);
               printf("date is %d/%d/%d\n", outregs.h.dh,
                       outregs.h.dl, outregs.x.cx);
                                     
      
               INTDOSX
              
               #include <dos.h>
               int intdosx(intno,inregs,outregs,segregs);
               union REGS *inregs;           значение  регистров  при
                                             вызове
               union REGS *outregs;          значение  регистров  при
                                             возврате
               struct SREGS *segregs;        значение  сегментов  при
                                             вызове

               Описание.
                
               Функция  intdosx  осуществляет выполнение системного вызова
         DOS, который определен значением регистра, объявленным в  inregs,
         и  возвращает результат системного вызова в outregs. В отличии от
         функции intdos, функция intdosx принимает значения регистров сег-
         мента в segregs, позволяя программам, которые используют сегменты
         данных большой модели или far-указатели, определить,  какой  сег-
         мент  или указатель должен быть использован на протяжении систем-
         ного вызова. Аргументы inregs и  outregs  являются  объединениями
         типа  REGS.Аргумент  segregs  является структурой типа SREGS. Эти
         типы объявлены в include-файле <dos.h>. Для активизации системно-
         го вызова функция intdosx выполняет команду INT 21H. Перед выпол-
         нением команды функция копирует содержимое inregs и segregs в со-
         ответствующие регистры. В segregs  используются  только  значения
         регистров  DS  и  ES. После возврата команды INT intdosx копирует
         текущее значение регистра в outregs и перезаписывает DS.
               Она также копирует статус переносимого флага системы в поле
         cflag, размещенное в outregs. Если это поле  является  ненулевым,
         флаг устанавливается посредством системного вызова и указывает на
         условие ошибки.
               Область  действия  функции intdosx расширяется и на область
         действия системных вызовов DOS, которые берут аргумент в регистре
         ES или значение регистра DS, отличное от  умалчиваемого  сегмента
         данных.
                  
               Возвращаемое значение.
                  
               После  завершения системного вызова функция intdosx возвра-
         щает значение регистра AX. Если поле cflag в outregs является не-
         нулевым, возникает ошибка и _doserrno также  устанавливает  соот-
         ветствующий код ошибки.
               См.также bdos, intdos, segread, FP_SEG.
                  

                                      - 142 -
         
         
               Замечание!  Значения  сегмента  для  аргумента segreg могут
         быть получены либо при использовании функции segread, либо  макро
         FP_SEG.
      
               Пример:
      
               #include <dos.h>
               union REGS inregs, outregs;
               struct SREGS segregs;
               char far *dir = "/test/bin";
               /*следующий  оператор  заменяет  текущий рабочий директорий
         вызовом шеснадцатеричной функции DOS 36 */
                inregs.h.ah=0x3b;
                /* измененный директорий */
                inregs.x.dx=FP_OFF(dir);
                /* имя файла offset*/
                segregs.ds=FP_SEG(dir);
                /* имя файла сегмента */
                intdosx(&inregs,&outregs,&segregs);
      
      
               ISALNUM-ISASCII
                
               #include <ctype.h>
               int isalnum (c);     проверяет  символы  на   при-
                                    надлежность  к алфавитно-циф-
                                    ровому типу (A-Z,a-z,0-9)
               int isalpha(c);      проверяет на буквы (A-Z,a-z)
               int isascii(c);      проверяет  на  символы   кода
                                    ASCII (0x00-0x7F)
               int c;               проверяемая величина
                
               Описание.
                
               Процедуры,  описанные  в  ctype,  проверяют введенное целое
         значение и возвращают ненулевое значение, если целое удовлетворя-
         ет условиям проверки, и нулевое значение, если этого не  происхо-
         дит.  Предполагается, что на установленном оборудовании использу-
         ются коды ASCII.
               Процедура isascii выдает значение результата для всех цело-
         численных значений. Однако остальные процедуры выдают  определен-
         ный  результат только для тех целочисленных значений, которые мо-
         гут быть преобразованы в символы кода ASCII (что происходит толь-
         ко тогда, когда проверка с помощью isascii дает положительный ре-
         зультат) или значение EOF (определенное в <stdio.h>)  для  симво-
         лов, не принадлежащих к ASCII.
               См.также   iscntrl,   isdigit,  isgraf,  islower,  isprint,
         ispunct, isspace, isupper, isxdigit, toascii, tolower, toupper.
             
               Замечание! Процедуры ctype реализованы как макро.
                
            
               Пример:
                
               #include <stdio.h>

                                      - 143 -
         
         
               #include <ctype.h>
               int ch;
               /*Следующие операторы анализируют все **символы между кода-
         ми 0х0 и 0х7F, *печатает "A" для букв, "AN" - для  буквенно**циф-
         ровых символов и "AS" для символов **кода ASCII : */
               for (ch=0;ch<=0x7F;ch++) {
                        printf ("%#04x",ch);
                        printf ("%3S",isalnnum(ch)  ? "AN":" ");
                        printf ("%2S",isalpha(ch)   ? "A":" ");
                        printf ("%3S",isascii(ch)   ? "AS":" ");
                        putchar ('\n');
      
                
               ISATTY
            
               #include <io.h>   требуется  только   для   объявления
                                 функции
               int isatty(handle);
               int handle;       handle-р, ссылающийся на проверяемое
                                 устройство
            
               Описание.
            
               Функция  isatty определяет, является ли даный handle-р свя-
         занным с символьным устройством  (таким  как  терминал,  консоль,
         принтер или последовательный порт).
            
               Возвращаемое значение.
            
               Функция isatty возвращает ненулевое значение, если устройс-
         тво является символьным. Иначе - возвращается значение 0.
            
               Пример:
            
               #include <io.h>
               int fh;
               long loc;
               .
               .
               .
               if (isatty(fh)==0)
               /* если не устройство, то выдает текущую позицию */
               loc=tell(fh);
      
                
               ISCNTRL-ISXDIGIT
                
               #include <ctype.h>
               iscntrl(c);        проверяет   на  управляющий
                                  символ (0х00-0х1f или 0x7F)
               isdigit (c);       проверяет на цифру (0-9)
               isgraph(c);        проверяет на  печатаемые симво-
                                  лы,  исключая  символ   пробела
                                  (0х21-0х7e)
               islower(c);        проверяет  на  строчные буквы

                                      - 144 -
         
         
                                  (a-z)
               isprint(c);        проверяет  на  печатаемые
                                  символы (0x20-0x7e)
               ispunct(c);        проверяет на  знаки  пунктуации
                                  (когда   проверки  с    помощью
                                  isalnum(c),   iscntrl(c)      и
                                  isspace(c) имеют  отрицательный
                                  результат
               isspace(c);        проверяет на пробельные символы
                                  (0x09-0x0d или 0x20)
               isupper(c);        проверяет  на  прописные  буквы
                                  (A-Z)
               isxdigit(c);       проверяет  на шестнадцатеричные
                                  цифры  (A-F,a-f, 0-9)
               int c;             проверяемое целое
               
               Описание.
                
               Процедуры  ctype, описанные выше, проверяют введенное целое
         значение и возвращают ненулевое значение, если целое удовлетворя-
         ет условиям проверки, и 0 -  в  противном  случае.  (Используется
         оборудование  с символами кода ASCII). Эти процедуры вырабатывают
         определенный результат только для целых значений, соответствующих
         символам кода ASCII (это возможно только тогда, когда isascii ис-
         тинна) или значение EOF (определенное в <stdio.h>),  если  символ
         не принадлежит к ASCII.
               См.также   isalnum,  isalpha,  isascii,  toascii,  tolower,
         toupper.
               
               Замечание! Процедуры ctype реализуются как макро.
      
               Пример:
                
               #include <stdio.h>
               #include <ctype.h>
               int ch;
               /*  следующие операторы анализируют все
               ** симовлы между кодами 0х0 и 0х7f,
               ** печатая "U" для прописных букв,
               ** "L" - для  строчных, "D" для цифр,
               ** "X" для шестнадцатеричных цифр,
               ** "S" для пробелов, "PU" для знаков
               ** пунктуации, "PR" для печатаемых
               ** символов,   "G" для графических,
               ** "C" для управляющих.
               ** Если код может быть напечатан, он печатается.   */
               for (ch=0; ch<=0x7f; ch++)
                 { printf ("%2s", iscntrl (ch)  ? "C":" ");
                   printf ("%2s", isdigit (ch)  ? "D":" ");
                   printf ("%2s", isgraph (ch)  ? "G":" ");
                   printf ("%2s", islower (ch)  ? "L":" ");
                   printf ("%c",  isprint (ch)  ? ch :'\0');
                   printf ("%3s", ispunct (ch)  ? "PU":" ");
                   printf ("%2s", isspace (ch)  ? "S":" ");
                   printf ("%3s", isprint (ch)  ? "PR":" ");

                                      - 145 -
         
         
                   printf ("%2s", isupper (ch)  ? "U":" ");
                   printf ("%2s", isxdigit (ch)  ? "X":" ");
                   putchar('\n');
                 }
               

               ITOA
                
               #include <stdlib.h>          Требуется   только    для
                                            объявления функции
               char *itoa(value,string,radix);
               int value;                   преобразуемое число
               char *string;                строка результата
               int radix;                   основание value
               
               Описание.
                
               Функция itoa преобразует символы числа value  в  символьную
         строку,  заканчивающуюся  NULL-символом, и запоминает результат в
         string. Аргумент radix определяет основание системы счисления для
         value; его значение может лежать в пределах  от  2  до  36.  Если
         radix  =  10  и value - отрицательное число, то первым символом в
         строке результата будет знак минус.
           
               Возвращаемое значение.
                
               Функция itoa возвращает указатель на строку.  Возвращаемого
         значения в случае ошибки нет.
               См.также ltoa, ultoa.
                
               Замечание! Размер памяти, отводимой для string, должен быть
         больше, чем требуется для возвращаемой строки. Функция может воз-
         вращать строку длиной до 17 байтов.
                
               Пример:
                
               #include <stdlib.h>
               int radix=8;
               char buffer[20];
               char *p;
               p=itoa(-3445,buffer,radix); /*p="1712113"*/
      
            
               KBHIT
            
               #include <conio.h>     требуется только для объявления
                                      функции
               int kbhit();
               
               Описание.
            
               Функция kbhit проверяет нажатие клавиши на консоли.
            
               Возвращаемое значение.
            

                                      - 146 -
         
         
               Функция  kbhit  возвращает ненулевое значение, если клавиша
         нажата. В противном случае возвращается 0.
            
               Пример:
           
               #include <conio.h>
               int result;
               /* следующий оператор проверяет, была ли нажата клавиша */
            result = kbhit();
               /* если результат result ненулевой, буфер  ожидает  нажатие
         клавиши.  Ее можно задать при помощи getch или getche. Если getch
         или getche были вызваны функцией kbhit  без  проверки,  программа
         делает паузу и ожидает ввод символа. */
      
            
               LABS
            
               #include <stdlib.h>             требуется  только  для
                                               описания функции
               long labs(n);
               long n;                         длинное целое значение
               
               Описание.
            
               Функция  labs вырабатывает абсолютное значение своего длин-
         ного целого аргумента n.
            
               Возвращаемое значение.
            
               Функция labs возвращает абсолютное значение своего аргумен-
         та. Возвращаемого значения в случае ошибки нет.
               См. также abs, cabs, fabs.
            
            Пример:
            
            #include <stdlib.h>
            long x, y;
            x = -41567L;
            y = labs(x);            /* y = 41567L */
      
            
               LDEXP
            
               #include <math.h>
               double ldext(x,exp);
               double x;            значение с плавающей точкой
               int *exp;            целая экспонента
                                 
            
               Описание.
            
               Функция  ldexp возвращает x, умноженное на 2 в степени exp.
         В случае переполнения результата  функция  возвращает  +HUGE  или
         -HUGE (в зависимости от знака x) и устанавливает errno в ERANGE.
               См.также frexp, modf.

                                      - 147 -
         
         
            
               Пример:
            
               #include <math.h>
               double x,y;
               int p;
               x = 1.5;
               p = 5;
               y = ldexp(x,p);    /* y = 48.0 */
      
            
               LFIND - LSEARCH
            
               #include <search.h>    требуется только для объявления
                                      функции
               char *lsearch(key,base,num,width,compare);
               char *lfind(key,base,num,width,compare);
               char *key;              ключ поиска
               char *base;             указатель  на  поисковую  базу
                                       данных
               unsigned *num,width;    число и размер элементов
               int (*compare)();       указатель на функцию сравнения
            
               Описание.

               Функции lsearch и lfind производят строковый поиск для зна-
         чения key в массиве из num элементов, каждый размером width байт.
         (В отличии от bsearch, lsearch и lfind не требуют отсортированно-
         го массива). Аргумент base является указателем на  базу  массива,
         который нужно найти.
               Если key не найден, lsearch присоединяет его в конец. Функ-
         ция lfind этого не делает.
               Аргумент  compare является указателем на процедуру, постав-
         ляемую пользователем, которая сравнивает два элемента  массива  и
         возвращает значение, определяющее их отношение. Обе функции вызы-
         вают  процедуру  compare в течении поиска один или несколько раз,
         пересылая в каждом вызове указатели на два элемента массива.  Эта
         процедура  должна сравнивать элементы, а затем возвращать одно из
         следующих значений:
            
            Значение                     Его смысл
            
            не равно 0           element 1 и element 2 различны
            
               0                 element 1 равен element 2
            
            
               Возвращаемое значение.
            
               Обе функции lsearch и lfind возвращают указатель на  первое
         возникновение key в массиве, на который указывает base.
               Если key не найден, эти функции возвращают NULL.
               См.также bsearch.
            

                                      - 148 -
         
         
            
               Пример:
                
               /* функция lsearch производит строковый поиск в массиве для
         элемента "key"; lsearch возвращает указатель на структуру, если в
         ней содержится key, и NULL - если его нет. */
            
               #include <search.h>
               #include <string.h>
               #include <stdio.h>
               int compare();
               /* должна быть объявлена как функция */
               main (argc, argv)
               int argc;
               char **argv;
                {
               char **result;
               char *key = "PATH";
               /*  следующий  оператор  находит  аргумент,  начинающийся с
         "PATH", в предположении, что аргументы лексикографически отсорти-
         рованы */
               result = (char **)bsearch((char *)&key,
                        (char *)argv, argc, sizeof(char *),
                         compare);
               if (result)
                   printf ("%s found\n", *result);
               else
                   printf("PATH not found!\n");
                 }
               int compare (arg1, arg2)
               char **arg1, **arg2;
                {
                 return(strncmp(*arg1, *arg2, strlen(*arg1)));
                }.
            
            
               LOCALTIME
            
               #include <time.h>
               struct tm *localtime(time);
               long *time;                 указатель на хранимое
                                           время
               
               Описание.
            
               Функция  localtime  преобразовывает  время,  хранимое   как
         long-значение,  к  структуре. Long-значение time представляет се-
         кунды, прошедшие от 00:00:00 значения времени по Гринвичу, т.е. с
         1 января 1980 года. Это значение обычно получается из вызова фун-
         кции time.
               Функция localtime разрывает значение time, корректирует зо-
         ну местного времени и переход на  летнее/зимнее  время,  если  он
         назначен,  и запоминает откорректированное время в структуре типа
         tm.(Смотрите gmtime для описания полей стрктуры tm.)
               В MS DOS даты раньше 1980 года  не  понимаются.  Если  time
         представляет  дату перед 1 января 1980 года ,localtime возвращает

                                      - 149 -
         
         
         символьную строку, представленную 00:00:00 January 1,1980.
               Функция localtime делает изменения для зоны местного време-
         ни, если пользователь впервые установил переменную окружения  TZ.
         Значением  TZ должна быть названная трехбуквенная временная зона,
         например PST, следующая за возможным  знаковым  числом,  задающим
         различие  между  значением  времени  по Гринвичу и зоной местного
         времени. Число должно следовать за трехбуквенной  зоной  перехода
         на  летнее/зимнее время (например PDT). Функция localtime исполь-
         зует различия между значением времени по Гринвичу и местным  вре-
         менем  для  установки значения запомненного времени. Если в уста-
         новке TZ  присутствует  зона  перехода  на  летнее/зимнее  время,
         localtime  также  изменяет переход на летнее/зимнее время. Если в
         TZ нет текущего значения, используется значение PST8PDT, устанав-
         ливаемое по умолчанию.
               Когда TZ  установлена,  автоматически  устанавливаются  три
         другие переменные окружения - timezone, daylight, tzname. Смотри-
         те функцию tzset для описания этих переменных.
            
               Возвращаемое значение.
            
               Функция  localtime  возвращает  указатель  на  результат  в
         структуре. Возвращаемого значения в случае ошибки нет.
               См.также asctime, ctime, ftime, gmtime, time, tzset.
      
               Пример:
            
               #include <stddio.h>
               #include <time.h>
               main()
               {
                 struct tm *newtime;
                 char *am_pm="PM";
                 time_t long_time;
                 time(&long_time);
                 newtime=localtime(&long_time);
                 if(newtime->tm_hour<12)
                    am_pm="AM";
                 if(newtime->tm_hour>12)
                    newtime->tm_hour-=12;
                 printf("%.19s %s\n", asctime(newtime), am_pm);
               }
            
               На выходе:
               Tue Dec 10 11:30:12 AM
      
            
               LOCKING
            
               #include <sys\locking.h>
               #include <io.h>        требуется только для объявления
                                      функции
               int locking(handle,mode,nbyte);
               int handle;            файловый handle
               int mode;              режим блокировки файла
               int nbyte;             число блокированных байтов

                                      - 150 -
         
         
            
                
               Описание.
            
               Функция locking блокирует  или  разблокирует  байты  nbytes
         файла, определенного по handle. Блокировка байтов в файле не раз-
         решает последующего чтения и записи этих байтов другими процесса-
         ми. Разблокировка файла разрешает другим процессам читать или за-
         писывать в байты, заблокированные ранее. Блокирование или разбло-
         кирование  начинается с текущей позиции указателя на файл и расп-
         ространяется до следующих nbyte байтов или до конца файла.
               Аргумент mode определяет выполняемые  действия  блокировки.
         Он может быть одной из следующих manifest-констант.
            
                           
         Мanifest-константа                Значение
                           
         LK_LOCK           Блокировка заданных байтов. Если  байты
                           не      заблокировались,     происходит
                           повторная попытка  блокировки  через  1
                           секунду. Если после 10 попыток байты не
                           заблокировались, возвращается ошибка.
                           
         LK_RLCK           Аналогично LK_LOCK.
                           
         LK_NBLCK          Блокировка заданных байтов.  Если байты
                           не заблокированы, возвращается ошибка.
                           
         LK_NRLCK          Аналогично LK_NBLCK.
                           
         LK_UNLCK          Разблокировка  заданных  байтов.  Байты
                           должны быть ранее заблокированы.

                
               Для  файла может быть заблокирована более чем одна область,
         но работа с перектытыми областями не допускается. Кроме  того,  в
         одно  и  то же время не может быть разблокирована более  чем одна
         область.
               Когда  файл  разблокируется,  область разблокируемого файла
         должна соответствовать  ранее  заблокированной  области.  Функция
         locking не может разблокировать одновременно смежные области, так
         как   если  две  области являются смежными, каждая область должна
         быть разблокирована отдельно.
               Все блокировки должны быть удалены  перед  закрытием  файла
         или перед выходом из программы.
            
               Возвращаемое значение.
            
               Функция locking возвращает 0, если она успешно выполнилась.
         Возвращаемое значение -1 свидетельствует о неудаче  и errno уста-
         навливается в одно из следующих значений:
           
         Значение                          Его смысл
            
         EACCES            принудительная блокировка (файл  всегда

                                      - 151 -
         
         
                           блокирован или разблокирован).
                           
         EBADF             неверный файловый handle.
                           
         EDEADLOCK         принудительная блокировка. Это значение
                           возвращается,  если задан фллаг LK_LOCK
                           или  LK_RLCK, и файл  не   может   быть
                           заблокирован после  10 попыток.
                           
               См.также open, creat.
            
               Замечание!  Функция  locking может быть использована только
         для версий MS DOS 3.0 и последующих, в ранних версиях MS DOS  она
         не дает никакого результата.
            
               Пример:
            
               #include <io.h>
               #include <sys\locking.h>
               #include <stdlib.h>
               extern unsigned char _osmajor;
               int fh;
               long pos;
               .
               .
               .
               /*  сохранить текущую позицию указателя на файл, затем бло-
         кировать область от начала файла до сохраненной позиции указателя
         на файл */
               if (_osmajor >= 3)  {
                  pos=tell(fh);
                  lseek(fh, OL, O);
                  if ((locking(fh, LK_NBLCK,pos)) != -1)  {
                  .
                  .
                  .
                  lseek(fh, OL, O);
                  locking((fh, LK_UNLCK, pos);
                                                           }
                                    }
      
            
               LOG-LOG10
            
               #include <math.h>
               double log(x);    вычисляет натуральный логарифм x.
               double log10(x);  вычисляет десятичный  логарифм x.
               double x;         значение с плавающей точкой.
            
               Описание.
            
               Функции log и log10 вычисляют соответственно натуральный  и
         десятичный логарифм x.
            

                                      - 152 -
         
         
               Возвращаемое значение.
            
               Функции  log и log10 возвращают результат логарифма. Если x
         отрицательное значение, обе функции печатают сообщение об  ошибке
         DOMAIN  в stderr и возвращают отрицательное значение HUGE. Если x
         равно 0, обе функции печатают сообщение об ошибке SING и  возвра-
         щают отрицательное значение HUGE. И в том и в другом случае errno
         устанавливается в EDOM.
               Обработка  ошибок  может  быть модифицирована при изменении
         процедуры matherr.
               См.также exp, matherr, pow.
            
               Пример:
            
               #include <math.h>
               double xx = 1000.0, y;
               y = log(x);   /* y = 6.907755 */
               /* функция log10 вычисляет десятичный логарифм для заданно-
         го значения */
               y = log10(x); /* y = 3.0 */
               
               
            
               LONGJMP.
            
               #include <setjmp.h>
               void longjmp(env, value);
               jmp_buf env;                  переменная,   в  которой
                                             хранится окружение
               int value;                    значение,   возвращаемое
                                             при вызове setjmp.
               
               Описание.
            
               Функция longjmp восстанавливает состояние стека, ранее сох-
         раненное в env функцией setjmp.
               Функции setjmp и longjmp обеспечивают возможность  выполне-
         ния  нелокального  (nonlocal)  перехода и обычно используются для
         передачи управления на выполнение обработки ошибок;  восстанавли-
         вают  код в ранее вызванной процедуре (без использования обычного
         вызова); возвращают условные обозначения.
               Вызовом setjmp сохраняется текущее состояние стека  в  env.
         Последующий вызов longjmp восстанавливает сохраненное состояние и
         возвращает управление на указатель (точку входа), непосредственно
         следующий за соответствующим вызовом setjmp.
               Выполнение  возобновляется,  когда  вызов setjmp возвращает
         заданное value. Когда вызывается longjmp, значения всех  перемен-
         ных  (за  исключением  переменных регистра) становятся доступными
         для процедуры, которая принимает управление и  содержит  значения
         этих переменных. Значения переменных регистра непредсказуемы.
               Функция longjmp должна вызываться ранее функции, определяю-
         щей возврат setjmp. Если longjmp вызвана после функции, определя-
         ющей возврат setjmp, то может произойти непредсказуемое поведение
         программы.
               Значение  value,  возвращаемое longjmp, должно быть ненуле-
         вым. Если для value задан аргумент 0, значение возврата заменяет-

                                      - 153 -
         
         
         ся значением 1.
            
               Возвращаемое значение.
            
               Возвращаемого значения нет.
               См. также setjmp.
            
               Предупреждение! Значения переменных регистра  в  процедуре,
         вызывающей setjmp, после выполнения longjmp не могут быть восста-
         новлены к собственным значениям.
               
      
            Пример:
         
            #include <stdio.h>
            #include <setjmp.h>
            jmp_buf mark;
            main()
                 {
                 if (setjmp(mark) != 0)
                 {   printf("longjmp has been called\n");
                     recover();
                     exit(1);
                  }
                 printf("setjmp has been called\n");
                 .
                 .
                 .
                 p();
                 .
                 .
                 .
                 }
            
            p()
                {
                int error = 0;
                .
                .
                .
                if (error != 0)
                   longjmp(mark, -1);
                .
                .
                .
                }
            
            recover()
                {
            
               /*  при  выходе из программы убедитесь, что файлы данных не
         будут запорчены */
               .
               .
               .
               }.
               

                                      - 154 -
         
         
                    
               
               LSEEK
               
               
               #include <stdio.h>   требуется  только  для объявления
                                    функций.
               long lseek (stream, offset, origin);
               int handle;           handle, ссылающийся на  открытый
                                     файл
               long offset;          число байтов из origin.
               int оrigin;           начальная позиция.
                                                                                                                      
               Описание.
                                                                
               Функция lseek передвигает указатель на файл (если он есть),
         связанный с handle, на новое место расположения, которое является
         байтами offset из origin.
               Следующая операция в файле выполняется на новом месте  рас-
         положения.
               Аргумент origin может быть одной из следующих констант, оп-
         ределенных в <stdio.h>.
            
            ORIGIN                ОПРЕДЕЛЕНИЕ
          
            SEEK-SET              начало файла.
            
            SEEK-CUR              текущая позиция указателя на
                                  файл.
            
            SEEK-END              конец файла.
            
               Функция  lseek используется для перемещения указателя в лю-
         бое место файла. Указатель должен быть размещен вне конца  файла.
         Однако попытка расположить указатель на файл в начале файла обыч-
         но приводит к ошибке.
            
               Возвращаемое значение.
            
               Функция  lseek возвращает разветвление origin в байтах, оп-
         ределенное как значение от новой позиции до начала файла. Возвра-
         щаемое значение -1 указывает на ошибку; errno  устанавливается  в
         одно из следующих значений:
      
            ВЕЛИЧИНА                ЕЕ СМЫСЛОВОЕ  ЗНАЧЕНИЕ
            
            EBADF               Неверный handle-р файла.
            
            ENIVAL              Неверное значение для origin   или
                                позиция,  определенная  при помощи
                                offset,  находится  перед  началом
                                файла.

               Для устройств, не приспособленных для поиска (seek), (таких

                                      - 155 -
         
         
         как терминал и печать), возвращаемое значение неопределено.
               См. также fseek, tell.
            
            Пример:
            
            #include <io.h>
            #include <fcntl.h>
            #include <stdlib.h>
            int fh;
            long position;
            fh = open("data", O_RDONLY);
            .
            .
            .
            /* 0 - разветвление от начала */
            position = lseek (fh, 0L, SEEK_SET);
            if (position == -1L)
               perror("lseek to beginning failed");
            .
            .
            .
            /* находит текущую позицию */
            position = lseek (fh, 0L, SEEK_CUR);
            if (position == -1L)
               perror("lseek to current position failed");
            .
            .
            .
            /* выполняет до конца файла */
            if (position == -1L)
               perror("lseek to end failed");.
      
            
               LTOA
                
               #include <stdlib.h>         Требуется    только    для
                                           объявления функции
               char *ltoa(value,string,radix);
               int value;                  преобразуемое число
               char *string;               строка результата
               int radix;                  основание value
               
               Описание.
                
               Функция ltoa преобразует символы value в символьную строку,
         заканчивающуюся  NULL-символом,  и запоминает результат в string.
         Аргумент radix определяет основание системы счисления для  value;
         его  значение может лежать в пределах от 2 до 36. Если radix = 10
         и value - отрицательное число, то первым символом  результирующей
         строки будет знак минус.
                
               Возвращаемое значение.
                
               Функция  ltoa возвращает указатель на строку. Возвращаемого
         значения в случае ошибки нет.

                                      - 156 -
         
         
               См.также itoa, ultoa.
                
               Замечание! Размер памяти, отводимой для string, должен быть
         больше, чем требуется для возвращаемой строки. Функция может воз-
         вращать строку длиной до 33 байтов.
                
               Пример:
                
               #include <stdlib.h>
               int radix=10;
               char buffer[20];
               char *p;
               p=itoa(-344115L,buffer,radix); /*p="-344115"*/
      
            
               MALLOC
            
               #include <malloc.h>    требуется только для объявления
                                      функции
               char *malloc(size);
               unsigned size;         количество байтов в захваченном
                                      блоке
               
               Описание.
            
               Функция malloc захватывает блок памяти  по крайней мере  не
         меньшей,  чем  из  size байтов. (Блок может быть больше, чем size
         байтов, принадлежащих пространству, которое требуется для  вырав-
         нивания и для поддержания информации).
            
               Возвращаемое значение.
            
               Функция  malloc  возвращает  char-указатель  на захваченное
         пространство.
               В памяти, на которую указывает возвращаемое  значение,  га-
         рантировано  выравнивание для хранения любого типа объекта. Чтобы
         получить указатель на тип, отличный от char, используется  преоб-
         разователь типа возвращаемого значения.
               Возвращается  значение NULL, если свободной памяти осталось
         мало.
               См.также calloc, free, realloc.
            
               Пример:
            
               #include <malloc.h>
               int *intarray;
               /* захватывает пространство для 20 целых */
               intarray=(int*)malloc(20*sizeof(int));
      
            
               MATHERR
            
               #include <math.h>
               int matherr(x);
               struct exception *x;     информация  о  математических

                                      - 157 -
         
         
                                        исключениях
               
               Описание.
            
               Функция matherr обрабатывает ошибки, порожденные  функциями
         математической   библиотеки.   Математические   функции  вызывают
         matherr, когда обнаружена ошибка. Пользователь  может  обеспечить
         различные объявления (определения) для функции matherr, выполняю-
         щие обработку специальных ошибок.
               Если  в  математической  процедуре возникла ошибка, matherr
         вызывается с указателем на  следующую  структуру  (объявленную  в
         <math.h>) как аргумент.
            
               struct exeption {
               int type;
               char *name;
               double arg1, arg2, retval;
               };
            
               Type  определяет  тип  математической ошибки. Он может быть
         одним из следующих значений, объявленных в <math.h>
      
          Значение                       Его смысл
                           
          DOMAIN               Ошибка области (определения) аргумента.
                           
          SING                 Особенность аргумента.
                           
          OVERFLOW             Ошибка диапазона (области) переполнения
                           
          UNDERFLOW            Ошибка диапазона потери значимости.
                
          TLOSS                Общая потеря значимости.
                           
          PLOSS                Частичная потеря значимости.
            
               Элемент структуры name является указателем на строку, окан-
         чивающуюся нулевым символом и содержащую имя  функции,  вызвавшей
         ошибку.  Элементы структуры arg1 и arg2 определяют значения, выз-
         вавшие ошибку. (Если задан только один аргумент, он  запоминается
         в  arg1).  Для заданной ошибки по умолчанию возвращается значение
         retval. Это значение можно изменить.  По  возвращаемому  значению
         можно  определить,  действительно  или  нет возникла ошибка. Если
         matherr возвращает 0, высвечивается сообщение об ошибке  и  errno
         устанавливается  в  приблизительное значение ошибки. Если matherr
         возвращает ненулевое значение, сообщение об ошибке не  высвечива-
         ется  и errno остается неизменной.
      
            
               Возвращаемое значение.
            
               Функция  matherr  в  случае ошибки возвращает 0 и ненулевое
         значение, если действие верно и успешно выполнено.
               См.также acos, asin, atan, atan2, bessel, ccabs, cosh, exp,
         hypot, log, pow, sin, sinh, sqrt, tan.

                                      - 158 -
         
         
            
               Пример:
            
               #include <math.h>
               #include <string.h>
               /* вылавливает ошибки в вызовах процедур log и log10.  Если
         ошибка  является  результатом  отрицательного  аргумента  (ошибка
         DOMAIN), возвращается log или log10 для абсолютного значения  ар-
         гумента.  Появляется  сообщение об ошибке. Если ошибка является 0
         аргументом  или ошибка сгенерирована некоторой другой процедурой,
         действие выбирается по умолчанию */
               int matherr(x)
               struct exception *x;
               {
               if (x->type==DOMAIN) {
                 if(strsmp(x->name,"log")==0\0  {
                    x->retval=log(-(x->arg1));
                    return(1);
                    }
                 else if(strsmp(x->name,"log10")==0) {
                    x->retval=log10(-(x->arg1));
                    return(1);
                    }
               }
               return(0);
               /* используется действие по умолчанию */
               }
            
            
               _MEMAVL
            
               #include <malloc.h>    требуется только для объявления
                                      функции
               unsigned int_memavl();
               
               Описание.
            
               Функция _memavl возвращает приблизительный размер памяти  в
         байтах,  доступной  для  динамического  размещения в умалчиваемом
         сегменте данных.  Эта  функция  может  использоваться  с  calloc,
         malloc,  realloc в малой и средней моделях памяти и с _nmalloc во
         всех моделях памяти.
            
               Возвращаемое значение.
            
               Функция _memavl возвращает размер в байтах как  беззнаковое
         целое.
               См.также calloc, malloc, _freect, realloc, stackavail.
            
               Пример:
            
               main()
               {
               long *longptr;
               printf("Memory available before malloc=%u\n",

                                      - 159 -
         
         
                     _memavl());
               longptr=(long*)malloc(5000*sizeof(long));
               printf("Memory available after malloc=%u\n",
                     _memavl());
               }
      

               MEMCCPY
            
               #include <memory.f>          Требуется   только    для
               #include <string.h>          объявления функции;   ис-
                                            пользует либо <string.h>,
                                            либо <memory.h.>
            
               char *memccpy(dest,src,c,cnt);
               char *dest;                   Указатель  на  результат
               char *src;                    Указатель  на   исходный
                                             буфер
               int c;                        Последний     копируемый
                                             символ
               insigned cnt;                 Количество символов
            
               Описание.
                
               Функция  memccpy  копирует 0 или более байтов из src в dest
         вплоть до первого появления символа, указанного в переменной c (и
         включая его), или пока не будет скопировано cnt байтов.
            
               Возвращаемое значение.
                 
               Если  символ  c скопирован, memccpy возвращает указатель на
         тот байт в dest, который непосредственно следует за символом. Ес-
         ли c не был скопирован, memccpy возвращает NULL.
               См. также функции memchr, memcmp, memcpy, memset.
            
               Пример:
           
               #include <memory.h>
               char buffer[100],source[100];
               char *result;
               .
               .
               .
               /* Копируются байты из source в buffer, пока не будет
               ** скопировано '\n', но не более 100 байтов
               */
               result=memccpy(buffer,source,'\n',100);
      
                   
               MEMCHR
            
               #include <memory.h>       Требуется только для
               #include <string.h>       объявления функции; исполь-
                                         зует либо  <string.h>, либо
                                         <memory.h>

                                      - 160 -
         
         
               char *memchr(buf,c,cnt);
               char *buf;                 Указатель на буфер
               int c;                     Копируемый символ
               unsigned cnt;              Количество символов
            
               Описание.
            
               Функция memchr находит первые cnt байтов из buf с целью об-
         наружения первого появления символа c. Поиск продолжается до  тех
         пор, пока не будет найден указанный символ или не будут проверены
         все cnt байтов.
            
               Возвращаемое значение.
            
               Функция memchr возвращает указатель на расположение символа
         c  в  buf.  Если  символ c не будет обнаружен в первых cnt байтах
         buf, возвращается NULL.
               Cм. также memccpy, memcmp, memcpy, memset.
            
               Пример:
                
               #include <memory.h>
               char buffer[100];
               char *result;
               .
               .
               .
               /*  Поиск первого символа 'a' в buffer. Если 'a' нет в
               ** первых 100 байтах, возвращается NULL
               */
               result=memchr(buffer,'a',100);
      
            
               MEMCMP
                
               #include <memory.h>       Требуется    только     для
               #include <string.h>       объявления функции; исполь-
                                         зует либо  <memory.h>, либо
                                         <string.h>
               int memcmp(buf1,buf2,cnt);
               char *buf1;                Первый буфер
               char *buf2;                Второй буфер
               unsigned cnt;              Количество символов
                                                  
           
               Описание.

               Функция memcmp производит лексикографическое сравнение пер-
         вых cnt байтов из buf1 и buf2 и возвращает значение,  указывающее
         на соотношение этих буферов, так как показано ниже:

                Значение                          Смысл
      
                Меньше 0                      buf1 меньше,чем buf2
                

                                      - 161 -
         
         
                0                             buf1 идентичен buf2
                
                Больше 0                      buf1 больше,чем buf2

                
               Возвращаемое значение.
            
               Функция memcmp возвращает целое число.
               См. также memccpy, memchr, memcpy, memset.
            
               Пример:
            
               #include <memory.h>
               char first[100], second[100];
               int result;
               /* Следующий оператор сравнивает first[] и second[] и
               ** определяет, что из них больше. Если   первые  100
               ** байтов указанных буферов идентичны, то они счита-
               ** ются равными */
               result=memcmp(first,second,100);
      
                
               MEMCPY
                
               #include <memory.h>   требуется только  для объявления
               #include <string.h>   функции;   использует       либо
                                     <string.h>, либо <memory.h>
               char memcpy (dest, src, cnt);
               char *dest;           указатель на результат
               char *src;            указатель на исходный буфер
               unsigned cnt;         количество символов
                
                
               Описание.
                
               Функция  memcpy копирует cnt байтов из src в dest. Если не-
         которые участки src и dest перекрываются, memcpy гарантирует, что
         байты из перекрываемого участка, принадлежащие src, будут  скопи-
         рованы перед перезаписью.
                
               Возвращаемое значение.
                
               Функция memcpy возвращает указатель на dest.
               См.также memccpy, memchr, memcmp, memsct.
                
               Пример:
                
               #include <memory.h>
               char source [200], destiination [200];
               .
               .
               .
               /*  Пересылаются  200 байтов из **source в destination ** и
         возвращается указатель на destination */
               memcpy (destination, source, 200);

                                      - 162 -
         
         
      
                
               MEMICMP
                
               
               #include <memory.h>   требуется только для  объявления
               #include <string.h>   функции;    использует      либо
                                     <string.h>, либо <memory.h>
               int memicmp (buf1, buf2, cnt);
               char *buf1;                    первый буфер
               char *buf2;                    второй буфер
               unsigned cnt;                  количество символов
                
               Описание.
                
               Функция memicmp  лексикографически  сравнивает  первые  cnt
         байтов из buf1 и buf2 вне зависимости от типа регистра, т.е. бук-
         вы верхнего и нижнего регистров считаются эквивалентными. Функция
         memicmp возвращает значение, указывающее соотношение buf1 и buf2,
         а именно:
                
               Величина               Значение
                
               меньше 0          buf1 меньше, чем buf2
                              
               0                 buf1 идентично buf2
                
               больше 0          buf1 больше, чем buf2
                
               Возвращаемое значение.
                
               Функция memicmp возвращает целое число.
               См.также memccpy, memchr, memcmp, memcpy, memset.
                
               Пример:
                
               #include <memory.h>
               char first[100], second [100];
               int result;
               strcpy (first,"Those, Who Will Not Learn from
                       History");
               strcpy  (second,  "THOSE WHO WILL NOT LEARN FROM their
                        mistakes");
               result = memicmp (first, second, 29);
               printf ("%d\n", result);
            
               На выходе:
                       0
      
            
               MEMSET
                
               #include <memory.h>   требуется только для  объявления
               #include <string.h>   функции;    использует      либо
                                     <string.h>, либо <memory.h>

                                      - 163 -
         
         
               char *memset (dest, c, cnt);
               char *dest;                 указатель на результат
               int c;                      символ-заполнитель
               unsigned cnt;               количество символов
                
               Описание.
                
               Функция memset заполняет первые cnt байтов буфера dest сим-
         волом c.
                
               Возвращаемое значение.
                
               Функция memset возвращает указатель на буфер dest.
               См.также memccpy, memchr, memcmp, memcpy
                
               Пример:
                
               #include <memory.h>
               char buffer [100];
               /* заполняет первые 100 байтов buffer
               ** нулями */
               memset (buffer, '\0', 100);
      
                
               MKDIR
            
               #include <direct.h>  требуется  только для  объявления
                                    функции
               int mkdir(pathname);
               char *pathname;      path-имя нового директория
               
               Описание.
            
               Функция mkdir создает новый директорий с заданным pathname.
         В  одно  и  то же время может быть создан только один директорий,
         потому что только последняя компонента  pathname  может  называть
         новый директорий.
            
               Возвращаемое значение.
            
               Функция  mkdir возвращает значение 0, если создан новый ди-
         ректорий. Возвращаемое значение -1 свидетельствует об  ошибке   и
         errno устанавливается в одно из следующих значений:
            
            
         Значение                      Его смысл
                                 
         EACCES               Директорий  не  создан.  Заданное   имя
                              является  именем  существующего  файла,
                              директория, устройства.
                           
         ENOENT               Path-имя не найдено.
            
               См.также chdir, rmdir.
            

                                      - 164 -
         
         
               Пример:
            
               #include <direct.h>
               int result;
               /*  следующие  2  оператора  создают 2 новых директория: **
         один - в корне диска b, второй - в поддиректории ** "tmp" текуще-
         го рабочего директория */
               result=mkdir("b:/tmp); /* может быть использовано
                                      ** также "b:\\tmp" */
               result=mkdir("tmp/sub"); /* может быть использовано
                                        ** также "tmp\\sub" */
      
      
            
               MKTEMP
            
               #imclude <io.h>   требуется только для объявления
                                 функции
               char *mktemp(template);
               char *template;   шаблон имени файла
               
               Описание.
            
               Функция  mktemp  создает  уникальное имя файла, модифицируя
         данный template. Аргумент template имеет форму:
            
               baseXXXXXX,
            
               где base является частью нового имени файла,  предлагаемого
         пользователем  и X...X являются знакоместами для части, формируе-
         мой mktemp; mktemp сохраняет base и заменяет шесть  Х  алфавитным
         символом,  следующим  за значением из 5 цифр. 5-цифровое значение
         является уникальным номером, идентифицирующим вызываемый процесс.
         При первом вызове mktemp с заданным  template  алфавитный  символ
         равен  символу  0('0').  В  последующих вызовах из того же самого
         процесса с тем же самым template mktemp проверяет, использовались
         ли ранее возвращенные имена для создания файлов. Если файла с за-
         даным именем не существует, mktemp возвращает это имя.  Если  для
         всех ранее возвращенных имен файлы существуют, mktemp создает но-
         вое имя, заменяя в нем алфавитный символ следующей доступной бук-
         вой нижнего регистра.
               Например,  если  первое возвращенное имя было t012345 и это
         имя использовалось для создания файла, то следующее  возвращаемое
         имя  будет ta12345. При создании новых имен mktemp использует '0'
         и буквы нижнего регистра от "a" до "z".
            
               Возвращаемое значение.
            
               Функция mktemp  возвращает  указатель  на  модифицированный
         template.  Возвращаемым  значением  является  NULL, если аргумент
         template образован неверно или больше не может быть создано  уни-
         кальных имен из заданного template.
               Смотри также fopen, getpid, open.
            
               Замечание.  Функция mktemp генерирует уникальные имена фай-

                                      - 165 -
         
         
         лов, но не создает и не открывает файлы.
            
               Пример:
            
               #include <io.h>
               char *template="fnXXXXXX";
               char *result;
            
               /* следующий оператор вызывает mktemp для создания **  уни-
         кального имени файла */
               result=mktemp(template);
               MODF
               #include <math.h>
               double modf(x,intptr);
               double x;              значение с плавающей точкой
               double *intptr;        указатель на хранение целой части
            
               Описание.
            
               Функция  modf  разрывает  значение  с плавающей точкой x на
         дробную и целую части. Возвращается знаковая дробная часть x. Це-
         лая часть хранится в intptr как значение с плавающей точкой.
            
               Возвращаемое значение.
            
               Функция modf возвращает знаковую дробную часть x. Возвраща-
         емого значения в случае ошибки нет.
               См. также frexp, ldexp.
            
               Пример:
            
               #include <math.h>
               double x,y,n;
               x = -14.87654321;
               y = modf(x,&n);   /* y = -0.87654321, n = -14.0 */
      
            
               MOVEDATA
                
               #include <memory.h>           Требуется   только   для об-
               #include <string.h>           явления  функции, использует
                                             либо   <string.h>,      либо
                                             <memory.h>
            
              void movedata (srcseg,  srcoff,  destseg,  destoff,
                          nbytes);
              int srcseg;                    адрес исходного сегмента
              int srcoff;                    смещение исходного сегмента
              int destseg;                   адрес результирующего сегмента
              int destoff;                   смещение  результирующего сег-
                                             мента
              unsigned nbytes;               количество байтов

                

                                      - 166 -
         
               Описание.
         
               Функция movedata копирует nbytes байтов, начиная с исходно-
         го адреса, обозначенного srcseg:srcoff, в адрес результата, обоз-
         наченный destseg:destoff. Функция movedata предназначена для  пе-
         ресылки  far-данных  в  программах малых или средних моделей, где
         адреса сегментов данных не известны. В программах больших моделей
         может быть использована функция memcpy,  когда  адреса  сегментов
         известны.
                
               Возвращаемое значение.
                
               Возвращаемого значения нет.
               См. также memcpy, segread, FP_SEG.
                
               Замечание!  Значения  сегментов  для  аргументов  srcseg  и
         destseg могут быть получены с  помощью  применения  либо  функции
         segread, либо макроопределения FR_SEG.
               Функция movedata не обрабатывает все случаи пересылок с пе-
         рекрытием  корректно  (пересылки  с перекрытием происходят тогда,
         когда часть результирующего поля является в этой же области памя-
         ти частью исходного). Пересылки с перекрытием корректно обрабаты-
         ваются функцией memcpy.
                
               Пример:
            
               #include <memory.h>
               #include <dos.h>
               char far *src;
               char far *dest;
               .
               .
               .
               /* следующие операторы пересылают 512
                   ** байтов данных из src в dest.   */
            
               movedata (FP_SEG (src), FPSEG(dest),
                          FP_OFF(dest), 512);

            
               _ MSIZE
             
               #include <malloc.h>       требуется только для  объявления
                                         функции
                
               unsigned_msize(ptr);
               char *ptr;                указатель на блок памяти
                
               Описание.
                
               Функция _ msize возвращает размер блока памяти (в  байтах),
         распределенного посредством вызовов calloc, malloc или realloc.
                
               Возвращаемое значение.
                
               Величина в байтах возвращается как беззнаковое целое.
               См. также calloc, _expand, malloc, realloc.

                                      - 167 -
         
         
        
               Пример:
                
               #include <stdio.h>
               #include <malloc.h>
               main()
               {
               long *oldptr;
               unsigned int newsize=64000;
            
               oldptr=(long*)malloc(10000*sizeof(long));
               printf("Size of memory block pointed to by
                     oldptr=%u\n", _msize(oldptr));
            
               if (_expand(oldptr,newsize) != NULL)
               printf("expand was able to increase block to
                      %u\n", _msize(oldptr));
               else
                printf("expand was able to increase block to
                       only %u\n", _msize(oldptr));
               }

              _NFREE
            
               #include <malloc.h>      требуется только  для  объявления
                                        функции
               void _nfree(ptr);
               char near *ptr;          указатель  на  захваченный блок
                                        памяти
            
               Описание.
            
               Функция _nfree освобождает блок памяти. Аргумент ptr указы-
         вает на ранее захваченный блок памяти посредством _nmalloc.
               Числом  освобожденных байтов является число байтов, опреде-
         ленных при захвате блока. После вызова освободившиеся блоки  при-
         годны к размещению.
            
               Возвращаемое значение.
      
               Возвращаемого значения нет.
               См.  также _nmalloc, free, malloc.
                
               Замечание.  Попытка  освободить  неверный ptr (указатель не
         захватывается посредством _nmalloc) может привести к последующему
         захвату и вызвать ошибку.
                
               Пример:
      
               #include <malloc.h>
               #include <stdio.h>
      
               char near *alloc;
      
               /* захватывает 100 байтов и затем освобождает их */

                                      - 168 -
         
         
      
               /* проверяет указатель на правильность: */
      
               if ((alloc=_nmalloc(100))==NULL)
               printf("unable to allocate memory\n");
               else {
                .
                .
                .
               /* освобождает память для heap: */
            
               _nfree(alloc);
                   }
      
              _NMALLOC
      
               #include <malloc.h>       требуется только для  объявления
                                         функции
      
               char near *_nmalloc(size);
               unsigned size;            количество байтов в захваченном
                                         блоке
      
            
               Описание.
      
               Функция _nmalloc внутри умалчиваемого сегмента данных  зах-
         ватывает блок памяти, по крайней мере не меньше, чем из size бай-
         тов. (Блок может быть больше, чем из size байтов,но принадлежащих
         пространству, которое требуется для выравнивания).
            
               Возвращаемое значение.
            
               Функция _nmalloc возвращает near-указатель на char. В памя-
         ти, на которую указывает возвращаемое значение, гарантировано вы-
         равнивание  для хранения любого типа объекта. Чтобы получить ука-
         затель на тип, отличный от char, используется преобразователь ти-
         па возвращаемого значения.
               Возвращается значение NULL, если пространство не было  зах-
         ваченным.
               См. также _nrfee, _msize, malloc, realloc.
         
               Пример:
            
               #include <malloc.h>
               int *intarray;
               /* захватывает память для 20 целых */
               intarray=(int*)_nmalloc(20*sizeof(int));

               _NMSIZE
            
               #include <malloc.h>       требуется только  для объявления
                                         функции
               unsigned _nmsize(ptr);
               char near ptr;            указатель на блок памяти

                                      - 169 -
         
         
            
               Описание.
            
               Функция  _nmsize  возвращает  размер блока памяти в байтах,
         захваченного посредством _nmalloc.
            
               Возвращаемое значение.
            
               Функция _nmsize возвращает размер в байтах, как беззнаковое
         целое.
               См. также  _ffree,  _fmalloc,  _fmsize, malloc, _msize,
        _nfree, _nmalloc.
            
               Пример:
            
               #include <malloc.h>
           
               #include <stdio.h>
            
               main()
                 {
                char near *stringarray;
            
                stringarray=_nmalloc(200*sizeof(char));
                if (stringarray != NULL)
                   printf("%u bytes allocated\n",
                          _nmsize(stringarray));
                else
                   printf("Allocation request failed.\n");
                }
         
               
               ONEXIT
            
               #include <stdlib.h>       требуется только  для  объявления
                                         функции
               onexit_t onexit(func);    тип  onexit_t,  определенный  в
                                         <stdlib.h>
               onexit_t func;
            
               Описание.
            
               Функция onexit передает адрес функции (func), которая будет
         выполнена, если программа нормально завершится.  Успешные  вызовы
         onexit  создают  набор функций, выполняемый по правилу магазина -
         "последний зашел, первый вышел". При  помощи  onexit  могут  быть
         созданы  наборы  не  более   чем из 32 функций; onexit возвращает
         значение NULL, если число функций в наборе превышает 32. Функции,
         передаваемые к onexit, не могут иметь параметров.
            
               Возвращаемое значение.
            
               Функция onexit в случае успеха возвращает указатель на фун-
         кцию  и возвращает NULL, если не осталось места для хранения ука-
         зателя на функцию.

                                      - 170 -
         
         
            См.также exit.
            
               Пример:
            
               #include <stdlib.h>
               main()
               {
               int fn1(), fn2(), fn3(), fn4();
               onexit(fn1);
               onexit(fn2);
               onexit(fn3);
               onexit(fn4);
               printf("This is executed first.\n");
               }
               int fn1()
                   {
                   printf("next.\n");
                   }
               int fn2()
                   {
                   printf("executed");
                   }
               int fn3()
                   {
                   printf("is");
                   }
               int fn4()
                   {
                   printf("This");
                   }
            
            
               На выходе:
            
               This is executed first.
               This is executed next.
      
            
               OPEN
            
               #include <fcntl.h>
               #include <sys\types.h>
               #include <sys\stat.h>
               #include <io.h>        требуется только для объявления
                                      функций.
               int open(pathname, oflag [[, pmode]]);
               char *pathname;        path-имя файла
               int oflag;             доступный тип операций
               int pmode;             разрешенный тип доступа.
            
               Описание.
                                                                  
               Функция open открывает файл, определяемый по  path-имени, и
         подготавливает  его к последующему чтению или записи, что опреде-
         ляется посредством oflag.

                                      - 171 -
         
         
               Аргумент oflag является целым выражением, состоящим из ком-
         бинации одной  или  более  манифестных  констант,  объявленных  в
         <fcntl.h>. Если задана больше  чем одна константа, тогда они объ-
         единяются при помощи логического оператора ИЛИ (:).
            
            OFLAG                          ЗНАЧЕНИЕ
                            
            O_APPEND        Указатель  на файл  перемещен  в конец
                            файла перед каждой операцией записи.
                            
            O_CREAT         Новый файл создан и открыт для записи;
                            это  не  эффективно,  если  существует
                            файл, определяемый по path-имени.
                            
            O_EXCL          Возвращается  значение   ошибки,  если
                            существует файл, определяемый по path-
                            имени.  Применяется  только  вместе  с
                            O_CREATE.

            O_RDONLY        Файл  открыт  только  для чтения; если
                            задается этот флаг, может быть  выбран
                            либо флаг O_RDWR, либо O_WRONLY.
                            
            O_RDWR          Файл   открыт  одновременно для чтения
                            и записи;  если  задается  этот  флаг,
                            может быть выбран  либо флаг O_RDONLY,
                            либо O_WRONLY.
                            
            O_TRUNC         Существующий файл  открыт и  усечен  к
                            длине  0;   этот  файл  должен   иметь
                            разрешение на запись. Содержимое файла
                            уничтожается.
                            
            O_WRONLY        Файл  открыт  только  для чтения; если
                            задан этот  флаг,  должен  быть  задан
                            также либо флаг O_RDONLY, либо ORDWR.
                            
            O_BINARY        Файл  открыт  в  двоичном (не трансли-
                            рованном) режиме.  (См. описание  дво-
                            ичного режима у функции fopen).
                            
            O_TEXT          Файл  открыт  в  текстовом   (трансли-
                            рующем) режиме. (См. описание  тексто-
                            вого режима у функции fopen).
                            
               Замечание!  O_TRUNC полностью уничтожает содержимое сущест-
         вующего файла; поэтому нужно внимательно использовать  эту  конс-
         танту.
               Аргумент  pmode  требуется  только  тогда, когда определена
         константа O_CREAT. Если файл существует,  pmode  игнорируется.  В
         противном  случае   pmode определяет разрешенные типы доступа для
         файла, которые устанавливаются во время первого  закрытия  нового
         файла.
               Pmode  - целое выражение, содержащее одну или обе манифест-
         ные константы S_IREAD, S_IWRITE, объявленные в <sys\stat.h>. Когда

                                      - 172 -
         
         
         заданы  обе константы, они объединяются логическим оператором ИЛИ
         (:). Значение аргумента pmode приводится ниже.
            
            КОНСТАНТА            ЕЕ СМЫСЛОВОЕ ЗНАЧЕНИЕ
            
            S_IWRITE             разрешает запись.
            
            S_IREAD              разрешает чтение.

            S_IREAD|S_IWRITE     разрешают чтение и запись.

               Если запись не разрешена, файл предназначен только для чте-
         ния. В MS DOS все файлы открыты для чтения; для них  не  возможно
         задать  разрешение  только  на запись. Поэтому, модели S_IWRITE и
         S_IREAD: S_IWRITE являются эквивалентными.
               Функция open перед установкой разрешенного доступа  прикла-
         дывает текущую маску файла к pmode. (Подробно об этом описывается
         у функции umask).
            
               Возвращаемое значение.
            
               Эта функция возвращает handle на созданный файл. Возвращае-
         мое значение -1 указывает на ошибку; errno устанавливается в одно
         из следующих значений.
            
            ЗНАЧЕНИЕ                ЕГО СМЫСЛ
      
            EACCES         Заданное path-имя является директорием;
                           или сделана попытка  записать  в  файл,
                           открытый   только   для   чтения,   или
                           возникло  sharing-нарушение.  (Sharing-
                           режим файла для операций не допускается.
                           Версии MS DOS 3.0 и старше).
            
            EEXIST         Флаги O_CREAT и O_EXCL  определены,  но
                           названный файл всегда существует.
                           
            EMFILE         Другие handle-ры файла не доступны, т.к.
                           много открытых файлов.
                          
            ENOENT         Файл или path-имя не найдено.
      
               См.  также  access,  chmod, close, creat, dup, dup2, fopen,
         sopen, umask.
            
            Пример:
            
            #include <fcntl.h>
            #include <sys\types.h>
            #include <sys\stat.h>
            #include <io.h>
            #include <stdlib.h>
            main ()
             {
              int fh1, fh2;

                                      - 173 -
         
         
              fh1 = open("data1", O_RDONLY);
              if (fh1 == -1)
                  perror("open failed on input file");
              fh2 = open("data2", O_WRONLY:O_TRUNC:O_CREAT,
                                  S_IREAD:S_IWRITE);
              if (fh2 == -1)
                  perror("open failed on output file");
              .
              .
              .
             }.
              fh1 = open("data1", O_RDONLY);
              if (fh1 == -1)
                  perror("open failed on input file");.
      
      
            
               OUTP
            
               #include <conio.h>     требуется только для объявления
                                      функции
               int outp(port, value);
               unsigned port;         номер порта
               int value;             выводимое значение
            
               Описание.
            
               Функция outp записывает значение value в выходной порт, оп-
         ределенный по port. Аргумент port может  быть  любым  беззнаковым
         целым  в  пределах  от 0 до 65535, value может быть любым целым в
         пределах от 0 до 255.
               См.также inp.
            
               Пример:
            
               #include <conio.h>
               int port, byte_val;
               .
               .
               .
               /* следующий оператор выводит тот байт из порта, на который
         установлен port. */
               outp (port, byte_val);.
            

