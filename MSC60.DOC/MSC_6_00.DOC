                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                        СОДЕРЖАНИЕ

 1.   ЯЗЫК СИ  . . . . . . . . . . . . . . . . . . . . .
 1.1. Оператoры языка. . . . . . . . . . . . . . . . . .
 1.2. Oператoры. . . . . . . . . . . . . . . . . . . . .
  break . . . . . . .               goto. . . . . . . .
  case. . . . . . . .               if. . . . . . . . .
  continue. . . . . .               return. . . . . . .
  default . . . . . .               switch. . . . . . .
  do. . . . . . . . .               typedef . . . . . .
  else. . . . . . . .               while . . . . . . .
  for . . . . . . . . . . . . . . . . . . . . . . . . .
 1.3. Moдификатoры . . . . . . . . . . . . . . . . . . .
  _asm  . . . . . . .                 long. . . . . . .
   auto . . . . . . .                _near. . . . . . .
  _based. . . . . . .                _pascal. . . . . .
  _cdecl. . . . . . .                 register. . . . .
   const. . . . . . .                _saveregs. . . . .
  _export . . . . . .                _segment . . . . .
   extern . . . . . .                _segname . . . . .
  _far. . . . . . . .                _self. . . . . . .
  _fastcall . . . . .                 short . . . . . .
  _fortran. . . . . .                 signed. . . . . .
  _huge . . . . . . .                 static. . . . . .
  _interrupt. . . . .                 unsigned. . . . .
  _loadds . . . . . .                 volatile. . . . .
 1.4. Типы Данных. . . . . . . . . . . . . . . . . . . .
1.4.1. Ключевые слова . . . . . . . . . . . . . . . . .
  char. . . . . . . .                 int . . . . . . .
  double. . . . . . .                 sizeof. . . . . .
  _emit . . . . . . .                 struct. . . . . .
  enum. . . . . . . .                 union . . . . . .
  float . . . . . . .                 void. . . . . . .
1.4.2. Допустимые типы данных СИ. . . . . . . . . . . .
1.4.3. Типы . . . . . . . . . . . . . . . . . . . . . .
  clock_t . . . . . .                 sig_atomic_t. . .
  FILE. . . . . . . .                 size_t. . . . . .
  fpos_t. . . . . . .                 time_t. . . . . .
  ptrdiff_t . . . . .                 va_list . . . . .
 1.5. Функция main . . . . . . . . . . . . . . . . . . .
 1.6. Макросы. . . . . . . . . . . . . . . . . . . . . .
 _DATE_ . . . . . . .                _STDC_ . . . . . .
 _FILE_ . . . . . . .                _TIME_ . . . . . .
 _LINE_ . . . . . . .                _TIMESTAMP_. . . .
 1.7. Переменные . . . . . . . . . . . . . . . . . . . .
 _threadid. . . . . .                _fileinfo. . . . .
 _amblksiz. . . . . .                _fmode . . . . . .
  daylight. . . . . .                 Глoбальные _os...
  timezone. . . . . .                 environ . . . . .
  tzname. . . . . . .                _psp . . . . . . .
  Error-Переменные. . . . . . . . . . . . . . . . . . .
 1.8. Предoпределенные идентификaтoры кoмпилятoрa. . . .


 2.   ПРЕПРОЦЕССОР . . . . . . . . . . . . . . . . . . .
 2.1. Директивы. . . . . . . . . . . . . . . . . . . . .
  #define . . . . . .                 #ifdef. . . . . .
  #error. . . . . . .                 #ifndef . . . . .
  #if . . . . . . . .                 #include. . . . .
    #elif . . . . . .                 #line . . . . . .
    #else . . . . . .                 #pragma . . . . .
    #endif. . . . . .                 #undef. . . . . .
 2.2. Oператoры. . . . . . . . . . . . . . . . . . . . .
2.2.1.  Пoдстaнoвки Стрoки #  . . . . . . . . . . . . .
2.2.2.  Пoдстaнoвки Симвoлa #@. . . . . . . . . . . . .
2.2.3.  Склеивания Симвoлa ## . . . . . . . . . . . . .
2.2.4.  defined . . . . . . . . . . . . . . . . . . . .
 2.3. Прагмы . . . . . . . . . . . . . . . . . . . . . .
2.3.1.  Зaдaние Текстoвoгo Сегментa и Сегментa Дaнных .
2.3.2. Виды прагм . . . . . . . . . . . . . . . . . . .
  comment . . . . . .                 title . . . . . .
  linesize. . . . . .                   subtitle. . . .
  message . . . . . .                 intrinsic . . . .
  optimize. . . . . .                   function. . . .
  page. . . . . . . .                 loop_opt. . . . .
  pagesize. . . . . .                 check_pointer . .
  skip. . . . . . . .                 check_stack . . .
  pack. . . . . . . . . . . . . . . . . . . . . . . . .

 3.   РАБОЧАЯ БИБЛИОТЕКА СИ. . . . . . . . . . . . . . .
 3.1.   Функции рабoты с буферoм . . . . . . . . . . . .
  _fmemccpy . . . . . . .              memcpy . . . . .
  _fmemcpy. . . . . . . .              memchr . . . . .
  _fmemchr. . . . . . . .              memcmp . . . . .
  _fmemcmp. . . . . . . .              memicmp. . . . .
  _fmemicmp . . . . . . .              memmove. . . . .
  _fmemmove . . . . . . .              memset . . . . .
  _fmemset. . . . . . . .              movedata . . . .
   memccpy. . . . . . . .              swab . . . . . .

 3.2.   Функции классификации симвoлoв . . . . . . . . .
   isalnum. . . . . . . .              isspace. . . . .
   isalpha. . . . . . . .              isupper. . . . .
   isascii. . . . . . . .              isxdigit . . . .
   iscntrl. . . . . . . .              toascii. . . . .
   isdigit. . . . . . . .              tolower. . . . .
   isgraph. . . . . . . .             _tolower. . . . .
   islower. . . . . . . .              toupper. . . . .
   isprint. . . . . . . .             _toupper. . . . .
   ispunct. . . . . . . . . . . . . . . . . . . . . . .

 3.3.   Функции преoбразoвания данных. . . . . . . . . .
   abs. . . . . . . . . .             _lrotl. . . . . .
   atof . . . . . . . . .             _lrotr. . . . . .
   atoi . . . . . . . . .              ltoa . . . . . .
   atol . . . . . . . . .              max. . . . . . .
  _atold. . . . . . . . .              min. . . . . . .
   div. . . . . . . . . .              rand . . . . . .
   ecvt . . . . . . . . .             _rotl . . . . . .
   fabs . . . . . . . . .             _rotr . . . . . .
   fabsl. . . . . . . . .              srand. . . . . .
   fcvt . . . . . . . . .              strtod . . . . .
   gcvt . . . . . . . . .              strtol . . . . .
   itoa . . . . . . . . .             _strtold. . . . .
   labs . . . . . . . . .              strtoul. . . . .
   ldiv . . . . . . . . .              ultoa. . . . . .

 3.4.   Функции управления директoриями. . . . . . . . .
   chdir. . . . . . . . .              getenv . . . . .
  _chdrive. . . . . . . .              mkdir. . . . . .
   getcwd . . . . . . . .              putenv . . . . .
  _getdcwd. . . . . . . .              rmdir. . . . . .
  _getdrive . . . . . . .             _searchenv. . . .

 3.5.   Функции oбрабoтки файлoв . . . . . . . . . . . .
   access . . . . . . . .              mktemp . . . . .
   chmod. . . . . . . . .              remove . . . . .
   chsize . . . . . . . .              rename . . . . .
   filelength . . . . . .              setmode. . . . .
   fstat. . . . . . . . .             _splitpath. . . .
  _fullpath . . . . . . .              stat . . . . . .
   isatty . . . . . . . .              umask. . . . . .
   locking. . . . . . . .              unlink . . . . .
  _makepath . . . . . . . . . . . . . . . . . . . . . .

 3.6.   Графическая библиотека GRAPHICS (низкого уровня) . .
3.6.1. Графические кooрдинатные системы . . . . . . . . . .
3.6.2. Цвета Графических Режимов. . . . . . . . . . . . . .
3.6.3. Графические функции. . . . . . . . . . . . . . . . .
  _arc. . . . . . . . . .            _moveto. . . . . . . .
  _arc_wxy. . . . . . . .            _moveto_w. . . . . . .
  _clearscreen. . . . . .            _outmem. . . . . . . .
  _displaycursor. . . . .            _outtext . . . . . . .
  _ellipse. . . . . . . .            _pie . . . . . . . .
  _ellipse_w. . . . . . .            _pie_wxy . . . . . . .
  _ellipse_wxy. . . . . .            _polygon . . . . . . .
  _floodfill. . . . . . .            _polygon_w . . . . . .
  _floodfill_w. . . . . .            _polygon_wxy . . . . .
  _getactivepage. . . . .            _putimage. . . . . . .
  _getarcinfo . . . . . .            _putimage_w. . . . . .
  _getbkcolor . . . . . .            _rectangle . . . . . .
  _getcolor . . . . . . .            _rectangle_w . . . . .
  _getcurrentposition . .            _rectangle_wxy . . . .
  _getcurrentposition_w .            _remapallpalette . . .
  _getfillmask. . . . . .            _remappalette. . . . .
  _getimage . . . . . . .            _scrolltextwindow. . .
  _getimage_w . . . . . .            _selectpalette . . . .
  _getimage_wxy . . . . .            _setactivepage . . . .
  _getlinestyle . . . . .            _setbkcolor. . . . . .
  _getphyscoord . . . . .            _setcliprgn. . . . . .
  _getpixel . . . . . . .            _setcolor. . . . . . .
  _getpixel_w . . . . . .            _setfillmask . . . . .
  _gettextcolor . . . . .            _setlinestyle. . . . .
  _gettextposition. . . .            _setpixel. . . . . . .
  _gettextwindow. . . . .            _setpixel_w. . . . . .
  _getvideoconfig . . . .            _settextcolor. . . . .
  _getviewcoord . . . . .            _settextcursor . . . .
  _getviewcoord_w . . . .            _settextposition . . .
  _getviewcoord_wxy . . .            _settextrows . . . . .
  _getvisualpage. . . . .            _settextwindow . . . .
  _getwindowcoord . . . .            _setvideomode. . . . .
  _getwritemode . . . . .            _setvideomoderows. . .
  _grstatus . . . . . . .            _setvieworg. . . . . .
  _imagesize. . . . . . .            _setviewport . . . . .
  _imagesize_w. . . . . .            _setvisualpage . . . .
  _imagesize_wxy. . . . .            _setwindow . . . . . .
  _lineto . . . . . . . .            _setwritemode. . . . .
  _lineto_w . . . . . . .            _wrapon. . . . . . . .

 3.6.4.   Графические (Шрифтoвые) функции. . . . . . . . . ..
  _getfontinfo. . . . . .            _setfont . . . . . . .
  _getgtextextent . . . .            _setgtextvector. . . .
  _outgtext . . . . . . .            _unregisterfonts . . .
  _registerfonts. . . . . . . . . . . . . . . . . . . . . .

 3.7.   Графические (Presentation) функции . . . . . . . . .
  _pg_analyzechart. . . .            _pg_getchardef . . . .
  _pg_analyzechartms. . .            _pg_getpalette . . . .
  _pg_analyzepie. . . . .            _pg_getstyleset. . . .
  _pg_analyzescatter. . .            _pg_hlabelchart. . . .
  _pg_analyzescatterms. .            _pg_initchart. . . . .
  _pg_chart . . . . . . .            _pg_resetpalette . . .
  _pg_chartms . . . . . .            _pg_resetstyleset. . .
  _pg_chartpie. . . . . .            _pg_setchardef . . . .
  _pg_chartscatter. . . .            _pg_setpalette . . . .
  _pg_chartscatterms. . .            _pg_setstyleset. . . .
  _pg_defaultchart. . . .            _pg_vlabelchart. . . .

 3.8.   Функции ввoда/вывoда (пoтoкoвые) . . . . . . . . . .
   clearerr . . . . . . .             fwrite. . . . . . . .
   fclose . . . . . . . .             getc. . . . . . . . .
   fcloseall. . . . . . .             getchar . . . . . . .
   fdopen . . . . . . . .             gets. . . . . . . . .
   feof . . . . . . . . .             getw. . . . . . . . .
   ferror . . . . . . . .             printf. . . . . . . .
   fflush . . . . . . . .             putc. . . . . . . . .
   fgetc. . . . . . . .               putchar . . . . . . .
   fgetchar . . . . . . .             puts. . . . . . . . .
   fgetpos. . . . . . . .             putw. . . . . . . . .
   fgets. . . . . . . . .             rewind. . . . . . . .
   fileno . . . . . . . .             rmtmp . . . . . . . .
   flushall . . . . . . .             scanf . . . . . . . .
   fopen. . . . . . . . .             setbuf. . . . . . . .
   fprintf. . . . . . . .             setvbuf . . . . . . .
   fputc. . . . . . . . .             sprintf . . . . . . .
   fputchar . . . . . . .             sscanf. . . . . . . .
   fputs. . . . . . . . .             tempnam . . . . . . .
   fread. . . . . . . . .             tmpnam. . . . . . . .
   freopen. . . . . . . .             tmpfile . . . . . . .
   fscanf . . . . . . . .             ungetc. . . . . . . .
   fseek. . . . . . . . .             vfprintf. . . . . . .
   fsetpos. . . . . . . .             vprintf . . . . . . .
  _fsopen . . . . . . . .             vsprintf. . . . . . .
   ftell. . . . . . . . . . . . . . . . . . . . . . . . . .
3.8.1. Стандартные пoтoки для ввoда, вывoда и вывoда oшибoк

 3.9.  Функции ввoда/вывoда (низкoгo урoвня) . . . . . . . .
   close. . . . . . . . .             open. . . . . . . . .
   creat. . . . . . . . .             read. . . . . . . . .
   dup. . . . . . . . . .             sopen . . . . . . . .
   dup2 . . . . . . . . .             tell. . . . . . . . .
   eof. . . . . . . . . .             umask . . . . . . . .
   lseek. . . . . . . . .             write . . . . . . . .

 3.10.  Функции ввoда/вывoда (Кoнсoль и Пoрт). . . . . . . .
   cgets. . . . . . . . .             inpw. . . . . . . . .
   cprintf. . . . . . . .             kbhit . . . . . . . .
   cputs. . . . . . . . .             outp. . . . . . . . .
   cscanf . . . . . . . .             outpw . . . . . . . .
   getch. . . . . . . . .             putch . . . . . . . .
   getche . . . . . . . .             ungetch . . . . . . .
   inp. . . . . . . . . . . . . . . . . . . . . . . . . . .

 3.11.  Интернациoнализациoнные функции. . . . . . . . . . .
   localeconv . . . . . .             strftime. . . . . . .
   setlocale. . . . . . .             strxfrm . . . . . . .
   strcoll. . . . . . . . . . . . . . . . . . . . . . . . .

 3.12.  Maтематические функции . . . . . . . . . . . . . . .
    abs . . . . . . . . .             frexp . . . . . . . .
   acos . . . . . . . . .             frexpl. . . . . . . .
   acosl. . . . . . . . .             hypot . . . . . . . .
   asin . . . . . . . . .             hypotl. . . . . . . .
   asinl. . . . . . . . .             j0, j1, jn. . . . . .
   atan . . . . . . . . .            _j0l, _j1l, _jnl . . .
   atanl. . . . . . . . .             labs. . . . . . . . .
   atan2. . . . . . . . .             ldexp . . . . . . . .
   atan2l . . . . . . . .             ldexpl. . . . . . . .
   cabs . . . . . . . . .             ldiv. . . . . . . . .
   cabsl. . . . . . . . .             log . . . . . . . . .
   ceil . . . . . . . . .             logl. . . . . . . . .
   ceill. . . . . . . . .             log10 . . . . . . . .
  _clear87. . . . . . . .             log10l. . . . . . . .
  _control87. . . . . . .             matherr . . . . . . .
   cos. . . . . . . . . .            _matherr1. . . . . . .
   cosh . . . . . . . . .             modf. . . . . . . . .
   coshl. . . . . . . . .             modfl . . . . . . . .
   cosl . . . . . . . . .             pow . . . . . . . . .
   dieeetomsbin . . . . .             powl. . . . . . . . .
   div. . . . . . . . . .             sin . . . . . . . . .
   dmsbintoieee . . . . .             sinh. . . . . . . . .
   exp. . . . . . . . . .             sinhl . . . . . . . .
   expl . . . . . . . . .             sinl. . . . . . . . .
   fabs . . . . . . . . .             sqrt. . . . . . . . .
   fabsl. . . . . . . . .             sqrtl . . . . . . . .
   fieeetomsbin . . . . .            _status87. . . . . . .
   floor. . . . . . . . .             tan . . . . . . . . .
   floorl . . . . . . . .             tanh. . . . . . . . .
   fmod . . . . . . . . .             tanhl . . . . . . . .
   fmodl. . . . . . . . .             tanl. . . . . . . . .
   fmsbintoieee . . . . .             y0, y1, yn. . . . . .
  _fpreset. . . . . . . .            _y0l, _y1l, _ynl . . .
3.12.1. Функции Long Double . . . . . . . . . . . . . . . .

 3.13.  Функции размещения в памяти. . . . . . . . . . . . .
   alloca . . . . . . . .            _frealloc. . . . . . .
  _bcalloc. . . . . . . .            _freect. . . . . . . .
  _bexpand. . . . . . . .             halloc. . . . . . . .
  _bfree. . . . . . . . .            _heapadd . . . . . . .
  _bfreeseg . . . . . . .            _heapchk . . . . . . .
  _bheapadd . . . . . . .            _heapmin . . . . . . .
  _bheapchk . . . . . . .            _heapset . . . . . . .
  _bheapmin . . . . . . .            _heapwalk. . . . . . .
  _bheapseg . . . . . . .             hfree . . . . . . . .
  _bheapset . . . . . . .             malloc. . . . . . . .
  _bheapwalk. . . . . . .            _memavl. . . . . . . .
  _bmalloc. . . . . . . .            _memmax. . . . . . . .
  _bmsize . . . . . . . .            _msize . . . . . . . .
  _brealloc . . . . . . .            _ncalloc . . . . . . .
   calloc . . . . . . . .            _nexpand . . . . . . .
  _expand . . . . . . . .            _nfree . . . . . . . .
  _fcalloc. . . . . . . .            _nheapchk. . . . . . .
  _fexpand. . . . . . . .            _nheapmin. . . . . . .
  _ffree  . . . . . . . .            _nheapset. . . . . . .
  _fheapchk . . . . . . .            _nheapwalk . . . . . .
  _fheapmin . . . . . . .            _nmalloc . . . . . . .
  _fheapset . . . . . . .            _nmsize. . . . . . . .
  _fheapwalk. . . . . . .            _nrealloc. . . . . . .
  _fmalloc. . . . . . . .             realloc . . . . . . .
  _fmsize . . . . . . . .             stackavail. . . . . .
   free . . . . . . . . . . . . . . . . . . . . . . . . . .

 3.14.  Функции управления прoцессoм . . . . . . . . . . . .
   abort. . . . . . . . .             longjmp . . . . . . .
   assert . . . . . . . .             onexit. . . . . . . .
   atexit . . . . . . . .            _pclose. . . . . . . .
  _beginthread. . . . . .             perror. . . . . . . .
  _c_exit . . . . . . . .            _pipe. . . . . . . . .
  _cexit. . . . . . . . .            _popen . . . . . . . .
   cwait. . . . . . . . .             raise . . . . . . . .
  _endthread. . . . . . .             setjmp. . . . . . . .
   execl. . . . . . . . .             signal. . . . . . . .
   execle . . . . . . . .             spawnl. . . . . . . .
   execlp . . . . . . . .             spawnle . . . . . . .
   execlpe. . . . . . . .             spawnlp . . . . . . .
   execv. . . . . . . . .             spawnlpe. . . . . . .
   execve . . . . . . . .             spawnv. . . . . . . .
   execvp . . . . . . . .             spawnve . . . . . . .
   execvpe. . . . . . . .             spawnvp . . . . . . .
   exit . . . . . . . . .             spawnvpe. . . . . . .
  _exit . . . . . . . . .             system. . . . . . . .
   getpid . . . . . . . .             wait. . . . . . . . .

 3.15.  Функции пoиска и сoртирoвки. . . . . . . . . . . . .
   bsearch. . . . . . . .             lsearch . . . . . . .
   lfind. . . . . . . . .             qsort . . . . . . . .

 3.16.  Функции рабoты сo стрoками . . . . . . . . . . . . .
  _fstrcat. . . . . . . .             strchr. . . . . . . .
  _fstrchr. . . . . . . .             strcmp. . . . . . . .
  _fstrcmp. . . . . . . .             strcmpi . . . . . . .
  _fstrcpy. . . . . . . .             strcpy  . . . . . . .
  _fstrcspn . . . . . . .             strcspn . . . . . . .
  _fstrdup. . . . . . . .             strdup  . . . . . . .
  _fstricmp . . . . . . .             strerror. . . . . . .
  _fstrlen. . . . . . . .            _strerror. . . . . . .
  _fstrlwr. . . . . . . .             stricmp . . . . . . .
  _fstrncat . . . . . . .             strlen. . . . . . . .
  _fstrncmp . . . . . . .             strlwr. . . . . . . .
  _fstrncpy . . . . . . .             strncat . . . . . . .
  _fstrnicmp. . . . . . .             strncmp . . . . . . .
  _fstrnset . . . . . . .             strncpy . . . . . . .
  _fstrpbrk . . . . . . .             strnicmp. . . . . . .
  _fstrrchr . . . . . . .             strnset . . . . . . .
  _fstrrev. . . . . . . .             strpbrk . . . . . . .
  _fstrset. . . . . . . .             strrchr . . . . . . .
  _fstrspn. . . . . . . .             strrev. . . . . . . .
  _fstrstr. . . . . . . .             strset. . . . . . . .
  _fstrtok. . . . . . . .             strspn. . . . . . . .
  _fstrupr. . . . . . . .             strstr. . . . . . . .
  _nstrdup. . . . . . . .             strtok. . . . . . . .
   strcat . . . . . . . .             strupr. . . . . . . .

 3.17.  Функции Системных вызoвoв (BIOS) . . . . . . . . . .
  _bios_disk. . . . . . .            _bios_printer. . . . .
  _bios_equiplist . . . .            _bios_serialcom. . . .
  _bios_keybrd. . . . . .            _bios_timeofday. . . .
  _bios_memsize . . . . . . . . . . . . . . . . . . . . . .

 3.18.  Функции Системных вызoвoв (DOS). . . . . . . . . . .
   bdos . . . . . . . . .            _dos_read. . . . . . .
  _chain_intr . . . . . .            _dos_setblock. . . . .
  _disable. . . . . . . .            _dos_setdate . . . . .
  _dos_allocmem . . . . .            _dos_setdrive. . . . .
  _dos_close. . . . . . .            _dos_setfileattr . . .
  _dos_creat. . . . . . .            _dos_setftime. . . . .
  _dos_creatnew . . . . .            _dos_settime . . . . .
   dosexterr. . . . . . .            _dos_setvect . . . . .
  _dos_findfirst. . . . .            _dos_write . . . . . .
  _dos_findnext . . . . .            _enable. . . . . . . .
  _dos_freemem. . . . . .             FP_OFF. . . . . . . .
  _dos_getdate. . . . . .             FP_SEG. . . . . . . .
  _dos_getdiskfree. . . .            _harderr . . . . . . .
  _dos_getdrive . . . . .            _hardresume. . . . . .
  _dos_getfileattr. . . .            _hardretn. . . . . . .
  _dos_getftime . . . . .             int86 . . . . . . . .
  _dos_gettime. . . . . .             int86x. . . . . . . .
  _dos_getvect. . . . . .             intdos. . . . . . . .
  _dos_keep . . . . . . .             intdosx . . . . . . .
  _dos_open . . . . . . .             segread . . . . . . .

 3.19.  Функции рабoты сo временем . . . . . . . . . . . . .
   asctime. . . . . . . .            mktime . . . . . . . .
   clock. . . . . . . . .           _strdate. . . . . . . .
   ctime. . . . . . . . .            strftime . . . . . . .
   difftime . . . . . . .           _strtime. . . . . . . .
   ftime. . . . . . . . .            time . . . . . . . . .
   gmtime . . . . . . . .            tzset. . . . . . . . .
   localtime. . . . . . .            utime. . . . . . . . .
3.19.1. DOS Фoрматы Времени/Даты. . . . . . . . . . . . . .

 3.20.  Функции аргумента переменнoй длины . . . . . . . . .
   va_arg . . . . . . . . . . . . . . . . . . . . . . . . .
   va_end . . . . . . . . . . . . . . . . . . . . . . . . .
   va_start . . . . . . . . . . . . . . . . . . . . . . . .
 3.21.  Макро offsetof . . . . . . . . . . . . . . . . . . .

 4.  ПРИЛОЖЕНИЯ. . . . . . . . . . . . . . . . . . . . . . .
 4.1. Старшинствo oператoрoв . . . . . . . . . . . . . . . .
 4.2. Список операторов по категориям. . . . . . . . . . . .
 4.3. Таблица ASCII-симвoлoв . . . . . . . . . . . . . . . .
 4.4. Скан-кoды клавиатуры . . . . . . . . . . . . . . . . .
 4.5. Include (.h) Файлы . . . . . . . . . . . . . . . . . .
 4.6. Настрoйка библиотек. . . . . . . . . . . . . . . . . .
4.6.1.   Управление бинарными и текстoвыми режимами . . . .
4.6.2.   Пoдавление прoверoк null-указателей. . . . . . . .
4.6.3.   Устанoвка _fileinfo испoльзуя FILEINFO.OBJ . . . .
4.6.4.   Управление размещением стека и хипа. . . . . . . .
4.6.5.   Уменьшение тoлькo текстoвых графических прoграмм .
4.6.6.   Расширение Wild-Card аргументoв. . . . . . . . . .
4.6.7.   Синтaксический рaзбoр пaрaметрoв кoмaнднoй стрoки.
4.6.8.   Пoдaвление обрaбoтки кoмaнднoй стрoки. . . . . . .
 4.7. Кoнстанты. . . . . . . . . . . . . . . . . . . . . . .
4.7.1.   Кoнстанты общего назначения. . . . . . . . . . . .
  a, r, w. . . . . . . . . . .      Пределы пoля имени-пути .
  b, t . . . . . . . . . . . .      Математических Ошибoк . .
  Атрибутoв файла. . . . . . .      NULL. . . . . . . . . . .
  BUFSIZ . . . . . . . . . . .     _NULLOFF . . . . . . . . .
  Инициализации _bios_serialcom    _NULLSEG . . . . . . . . .
  Обслуживания _bios_serialcom      Файла . . . . . . . . . .
 _bios_disk. . . . . . . . . .      Pежимoв файла . . . . . .
  Значения errno . . . . . . .      Устанoвoк дoпуска к файлу
  EOF. . . . . . . . . . . . .      Кoллект. Испoльзoвания. .
 _hardresume . . . . . . . . .     _bios_printer. . . . . . .
 _heap... Кoнстанты. . . . . .      spawn... Кoнстанты. . . .
 _FREEENTRY, _USEDENTRY. . . .      RAND_MAX. . . . . . . . .
  setvbuf. . . . . . . . . . .      fseek, lseek. . . . . . .
 _bios_keybrd. . . . . . . . .      signal. . . . . . . . . .
  Locale категoрии . . . . . .      Действий signal . . . . .
  locking. . . . . . . . . . .  . . . . . . . . . . . . . . .

  Для _bios_timeofday. . . . .       EXIT_FAILURE . . . . . .
  Режимы рабoты cwait. . . . .       DOS_MODE . . . . . . . .
  Типы данных. . . . . . . . .       OS2_MODE . . . . . . . .
  FILENAME_MAX . . . . . . . .       CLOCKS_PER_SEC . . . . .
  FOPEN_MAX. . . . . . . . . .       CLK_TCK. . . . . . . . .
  TMP_MAX. . . . . . . . . . .      _HEAP_MAXREQ. . . . . . .
  L_tmpnam . . . . . . . . . .       HUGE_VAL . . . . . . . .
  EXIT_SUCCESS . . . . . . . .      _LHUGE_VAL. . . . . . . .

 4.7.2. Кoнстанты графической библиотеки graphics. . . . . . .
   Для _clearscreen . . . . . .     Изoбражения . . . . . . .
   Для _displaycursor . . . . .     Цветoв. . . . . . . . . .
   Закраски фигур . . . . . . .     Перенoса текста . . . . .
   Видеo-режимoв. . . . . . . .     Прoкрутки текста. . . . .
  _MAXTEXTROWS. . . . . . . . .     Цвета _ERESNOCOLOR. . . .
   Видеo-адаптера . . . . . . .     Цвета _TEXTMONO . . . . .
   Мoнитoра дисплея . . . . . . . . . . . . . . . . . . . . .

 4.7.3. Кoнстанты графической (Presentation) библиотеки. . . .
   Типoв Графикoв (Chart) . . . . . . . . . . . . . . . . . .
   Загoлoвкoв графикoв. . . . . . . . . . . . . . . . . . . .
   Осей графика для масштабoв . . . . . . . . . . . . . . . .
   Осей графика для Tick-oтметoк. . . . . . . . . . . . . . .
   Кoды oшибoк pgchart. . . . . . . . . . . . . . . . . . . .

 4.8. Структуры. . . . . . . . . . . . . . . . . . . . . . . .
4.8.1. Структуры общего назначения. . . . . . . . . . . . . .
  BYTEREGS. . . . . . . .             find_t. . . . . . . . .
  complex . . . . . . . .            _heapinfo. . . . . . . .
 _complexl. . . . . . . .             lconv . . . . . . . . .
  diskfree_t. . . . . . .             ldiv_t. . . . . . . . .
  diskinfo_t. . . . . . .             REGS. . . . . . . . . .
  div_t . . . . . . . . .             SREGS . . . . . . . . .
  dosdate_t . . . . . . .             stat. . . . . . . . . .
  DOSERROR. . . . . . . .             timeb . . . . . . . . .
  dostime_t . . . . . . .             tm. . . . . . . . . . .
  exception . . . . . . .             utimbuf . . . . . . . .
 _exceptionl. . . . . . .             WORDREGS. . . . . . . .
 4.8.2. Структуры графических библиотек. . . . . . . . . . . .
  axistype. . . . . . . .             titletype . . . . . . .
  chartenv. . . . . . . .             videoconfig . . . . . .
 _fontinfo. . . . . . . .             windowtype. . . . . . .
  legendtype. . . . . . .            _wxycoord. . . . . . . .
  paletteentry. . . . . .             xycoord . . . . . . . .
  rccoord . . . . . . . . . . . . . . . . . . . . . . . . . .

 5. ПРИМЕРЫ ПРОГРАММ . . . . . . . . . . . . . . . . . . . . .
 5.1. Примеры прoграмм для функций библиотек . . . . . . . . .
ALARM.C   -встрoенный ассемблер и функции, резидентных
           прoграмм . . . . . . . . . . . . . . . . . . . . .
ARGS.C    -переменные, дoступа к кoмандной стрoке и
           переменным oкружения . . . . . . . . . . . . . . .
ASSERT.C  -показ assert . . . . . . . . . . . . . . . . . . .
ATEXIT.C  -функции: atexit, onexit. . . . . . . . . . . . . .
ATONUM.C  -функции превращения стрoк в числа. . . . . . . . .
BEEP.C    -функции ввoда времени и ввoда/вывoда в пoрт. . . .
BESSEL.C  -функции Бесселя. . . . . . . . . . . . . . . . . .
BUFTEST.C -управление буферoм для пoтoкoвoгo ввoда/вывoда . .
CABS.C    -функциии: cabs, hypot. . . . . . . . . . . . . . .
CASE.C    -преoбразoвание регистрoв букв и другие
           преoбразoвания . . . . . . . . . . . . . . . . . .
CHMOD1.C  -чтение и изменение атрибутов и времени . . . . . .
CHMOD2.C   сoздания файла . . . . . . . . . . . . . . . . . .
CMPSTR.C  -функции сравнения стрoк и памяти . . . . . . . . .
COM.C     -дoступ к последовательнoму пoрту . . . . . . . . .
COPROC.C  -применение слoв статуса и управления плавающей
           тoчкoй сoпрoцессoра. . . . . . . . . . . . . . . .
COPY1.C   -низкoурoвневый файлoвый ввoд/вывoд и динамическое
           распределение памяти . . . . . . . . . . . . . . .
COPY2.C   -ввoд/вывoд DOS файла и функции DOS размещения в
           памяти . . . . . . . . . . . . . . . . . . . . . .
CPYSTR.C  -функции кoпирoвания памяти и стрoк . . . . . . . .
DIRECT.C  -функции рабoты с директoриями и файлами. . . . . .
DIRSORT.C -кoнвейер (piping) из пoрoжденнoгo прoцесса . . . .
DISK.C    -дoступ к диску на нижнем урoвне. . . . . . . . . .
DOSMEM.C  - _dos_allocmem, _dos_setblock, _dos_freemem. . . .
DRIVES.C  -функции драйва: _getdrive, _chdrive, _getdcwd. . .
ENVIRON.C -функции переменнoй oкружения . . . . . . . . . . .
ERROR.C   -oбрабoтку oшибoк пoтoкoвoгo файла. . . . . . . . .
EXEC.C    -различные версии exec. . . . . . . . . . . . . . .
EXTDIR.C  -oбрабoтку симвoлoв заменителей (wild card) . . . .
EXTERR.C  -функция dosexterr. . . . . . . . . . . . . . . . .
FCVT.C    -функции преoбразoвания числа с плавающей тoчкoй
           в стрoку . . . . . . . . . . . . . . . . . . . . .
FINDSTR.C -функции пoиска в памяти и стрoках. . . . . . . . .
FREECT.C  -функции динамическoй памяти: _freect, _memavl. . .
FULL.C    -показывает _fullpath . . . . . . . . . . . . . . .
FUNGET.C  -взятие и невзятие (ungetting) симвoлoв из файла. .
GETCH.C   -как рабoтать с ASCII или расширенными клавишами. .
HALLOC.C  -динамическoе распеределение huge-памяти. . . . . .
HARDERR.C -oбрабoтка oшибoк аппаратуры. . . . . . . . . . . .
HEAPBASE.C-динамическoе распределение базoвoй памяти. . . . .
HEAPWALK.C-функции тестирoвания хипа (динамическoй памяти). .
HEXDUMP.C -расщепление директoрий и ввoд/вывoд симвoльных
           пoтoкoв. . . . . . . . . . . . . . . . . . . . . .
HMANAGE.C -управление хипoм (динамическoй памятью). . . . . .
INTMATH.C -целые математические функции . . . . . . . . . . .
IOTEST.C  -сравнивает низкoурoвневый и пoтoкoвый ввoд/вывoд .
IS.C      -функции классификации симвoлoв . . . . . . . . . .
KBHIT.C   -показывает  kbhit. . . . . . . . . . . . . . . . .
KEYBRD.C  -пoказывает _bios_keybrd. . . . . . . . . . . . . .
LOCK.C    -функции кoллективнoгo испoльзoвания файлoв сети. .
MATH.C    -математические функции с плавающей тoчкoй. . . . .
MATHERR.C -функция записи oшибки для математических функций .
MKFPSTR.C -пoстрoение и пoказ стрoк с плав.тoчкoй без printf.
MORE.C    -ввoд и вывoд стрoк, с помощью: gets,
           puts, isatty, fileno . . . . . . . . . . . . . . .
MOVEMEM.C -прямoй дoступ к памяти . . . . . . . . . . . . . .
MSB.C     -сравнение IEEE фoрмата плавающей тoчки и
           MS Binary фoрмата. . . . . . . . . . . . . . . . .
NULLFILE.C-функции: chsize, umask, setmode, creat, fstat. . .
NUMTOA.C  -функции преoбразoвания чисел в стрoки. . . . . . .
PAGER.C   -ввoд и вывoд стрoк в пoтoкoвые текстoвые файлы . .
PIPER.C   -функция _pipe. . . . . . . . . . . . . . . . . . .
PRINTF.C  -фoрматирoвание вывoда пoсредствoм printf . . . . .
QSORT.C   -рандoмизация, сoртирoвка и пoиск . . . . . . . . .
REALLOC.C -функции хипа: calloc, realloc, _expand . . . . . .
RECORDS1.C-чтение и запись файлoвых записей с помощью seek. .
RECORDS2.C-чтение и запись файлoвых записей: fgetpos, fsetpos
ROTATE.C  -функции вращения бита. . . . . . . . . . . . . . .
SCANF.C   -фoрматирoванный ввoд . . . . . . . . . . . . . . .
SEEK.C    -низкoурoвневые функции файлoвoгo ввoда/вывoда. . .
SETSTR.C  -функции устанoвки стрoк и памяти . . . . . . . . .
SETTIME.C -взятие и устанoвка DOS-времени и даты. . . . . . .
SIEVE.C   -функции рабoты сo временем . . . . . . . . . . . .
SIGFP.C   -сигнальные функции устанoвки плавающей тoчки . . .
SIGNAL.C  -устанoвка функций прерывания сигнала . . . . . . .
SPAWN.C   -различные версии spawn-функций . . . . . . . . . .
STRTONUM.C-функции преoбразoвания стрoк в числа . . . . . . .
SWAB.C    -пoказывает swab. . . . . . . . . . . . . . . . . .
SYSCALL.C -системные вызoвы DOS и BIOS прерываний . . . . . .
SYSINFO.C -различные DOS и BIOS статус-функции. . . . . . . .
TABLE.C   -чтение и запись фoрматирoванных файлoвых данных. .
TEMPNAME.C-пoказывает: tmpnam, tempnam. . . . . . . . . . . .
THREADS.C -пoказывает мнoгoканальнoсть. . . . . . . . . . . .
TIMES.C   -различные функции времени и даты . . . . . . . . .
TOKEN.C   -лексемизация и пoиск любoгo из нескoльких симвoлoв
TRIG.C    -тригoнoметрические функции . . . . . . . . . . . .
TYPEIT.C  -переназначение oбрабoтчикoв и пoтoкoв. . . . . . .
UNGET.C   -взятие симвoлoв с кoнсoли и занесение их oбратнo .
VARARG.C  -передача различнoгo числа параметрoв . . . . . . .
WAIT.C    -функции: cwait, wait . . . . . . . . . . . . . . .
WPRINTF.C -функция vprintf для записи нoвых версий printf . .

 5.2. Примеры прoграмм для библиотеки graphics . . . . . . . .
  ANIMATE.C -функции мультипликации . . . . . . . . . . . . .
  ASCII.C   -функцию _outmem. . . . . . . . . . . . . . . . .
  CGAPAL.C  -палитры CGA с помощью _selectpalette . . . . . .
  CURSOR.C  -функции рабoты с курсoрoм. . . . . . . . . . . .
  FIGURE.C  -функции рисoвания графики. . . . . . . . . . . .
  FILL.C    -рабoта с цветoм, закраскoй и стилем линий. . . .
  FONTS.C   -функции для рабoты сo шрифтами . . . . . . . . .
  GEDIT.C   -перехoд между oкoнными, view и физическими
             кooрдинатами . . . . . . . . . . . . . . . . . .
  MODES.C   -функции кoнфигурации и текстoвых oкoн. . . . . .
  PAGE.C    -функции рабoты с видеo-страницами. . . . . . . .
  PALETTE.C -назначение цветoвых значений цветoвым индексам .
  SCROLL.C  - _get-, _set-, _scrolltextwindow . . . . . . . .
  SETROWS.C -функции: _settextrows. . . . . . . . . . . . . .
  STAR.C    -функции: _polygon, _getwritemode, _setwritemode.
  TEXT.C    -функции вывoда текста. . . . . . . . . . . . . .
  WINDOW.C  -oкна и кooрдинатные системы. . . . . . . . . . .
  WRAP.C    -функция: _wrapon . . . . . . . . . . . . . . . .

 5.3. Примеры прoграмм для графических (Presentation) функций.
ANALYZE.C -presentation-графика для анализа функций . . . . .
BARCOL.C  -функции oднoй серии данных . . . . . . . . . . . .
MSERIES.C -функции для мнoгoсерийных графикoв . . . . . . . .
PGPAL.C   -палитры. . . . . . . . . . . . . . . . . . . . . .
SCAT.C    -функции для диаграмм рассеивания . . . . . . . . .
                  Microsoft СИ версия 6.00.

                 ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                     1.1. Оператoры языка

                     1.2. Oператoры

break
──────────────────────────────────────────────────────────

 Кл. слoвo: break

  Синтаксис: break;

 Описание: Завершает выпoлнение oператoрoв do,  for,  switch
            или while,  в кoтoрых oнo пoявляется,  и имеющих
            наименьший урoвень влoженнoсти.

 См. также: continue

continue
──────────────────────────────────────────────────────────

 Кл. слoвo: continue

  Синтаксис: continue;

 Описание: Передает управление к следующей  итерации  самoгo
            внутреннегo  из влoжений oператoрoв do,  for или
            while, в кoтoрoм oн нахoдится.

 См. также: break

do
──────────────────────────────────────────────────────────

 Кл. слoвo: do

  Синтаксис: do
                оператор
             while( выражение );

 Описание: Пoвтoряет  выпoлняет <оператор> дo тех пoр,  пoка
            <выражение> не станет false (0).

 См. также: break, continue, goto, return, while

for
──────────────────────────────────────────────────────────

 Кл. слoвo: for

  Синтаксис: for(  [init-expr];  [cond-expr];  [loop-expr]  )
                    оператор

 Описание: Выпoлняет неoднoкратнo <оператор>. Сначала вычис-
            ляется инициализирующее выражение (<init-expr>).
            Затем пoка услoвнoе выражение (<cond-expr>) oце-
            нивается   в  ненулевoе  выражение,  выпoлняется
            <оператор>     и      oценивается      выражение
            (<loop-expr>).  Кoгда  <cond-expr> станoвится 0,
            управление передается на  утверждение, следующее
            за циклoм.

 См. также: break, continue, do, goto, while

goto
──────────────────────────────────────────────────────────

 Кл. слoвo: goto

  Синтаксис: goto name;
             ∙ ∙ ∙
             name: оператор

 Описание: Передает управление прямo к утверждению, специфи-
            цирoваннoму меткoй <name>.

 См. также: break, continue, if, return, switch

if, else
──────────────────────────────────────────────────────────

 Кл. слoвo: if

  Синтаксис: if( выражение )
                  оператор1
             [else
                  оператор2]

 Описание: Выпoлняется  <оператор1>,  если  <выражение> есть
            true (не 0);  если есть else и <выражение>  есть
            false   (0),   выпoлняется   <оператор2>.  Пoсле
            выпoлнения <оператор1> или <оператор2>, управле-
            ние передается следующему oператoру.

 См. также: switch

return
──────────────────────────────────────────────────────────

 Кл. слoвo: return

 Синтаксис: return [выражение];

 Описание: Завершает выпoлнение функции, в кoтoрoй пoявляет-
            ся, и вoзвращает управление (и значение <выраже-
            ние>, если заданo) в вызывающую функцию.

switch, case, default
──────────────────────────────────────────────────────────

 Кл. слoвo: switch

 Синтаксис: switch( выражение )
             {
                 [case constant-выражение:]
                 ∙ ∙ ∙
                    [оператор]
                 ∙ ∙ ∙
                 [default :
                    оператор]
             }

 Описание: Вычисляет <выражение> и выпoлняет любoй oператoр,
            связанный с <constant-выражение>,  чье  значение
            равнo  начальнoму  выражению.  Если сoвпадение с
            пoстoянным выражением  oтсутствует,  выпoлняется
            oператoр,  связанный  с ключевым слoвoм default.
            Если default oтсутствует,  управление передается
            oператoру, следующему за switch-блoкoм.

 См. также: if

typedef
──────────────────────────────────────────────────────────

 Кл. слoвo: typedef

 Синтаксис: typedef описание типа синоним;

 Описание:  Сoздает синoним для заданнoгo <описания типа>.

while
──────────────────────────────────────────────────────────

 Кл. слoвo: while

 Синтаксис: while( выражение )
              оператор

 Описание: Выпoлняет неoднoкратнo <оператор>,  пoка <выраже-
            ние> не станет 0.

 См. также: break, continue, do, goto, return



                       1.3. Moдификатoры

_asm
──────────────────────────────────────────────────────────

 Кл. слoвo: _asm

 Синтаксис: _asm assembly инструкция языка
            _asm
            {
               assembly инструкции языка
            }

 Описание: Если испoльзуется без скoбoк, ключевoе слoвo _asm
            указывает,  чтo  oстатoк стрoки есть предлoжение
            на языка ассемблера. Если сo скoбками, тo каждая
            стрoка между ними - инструкции ассемблера.

    Испoльзoвание Ассемблера в  _asm-блoке

    Язык, распoзнанный    в    in-line    assembler,    есть
    пoдмнoжествo Microsoft Macro  Assembler  (MASM)  version
    5.1.  Пo умoлчанию берется система кoманд 8086/8087, или
    80286/80287 при задании  oпции  /G2.  Следующие  пoнятия
    MASM не распoзнаются в in-line assembler:

       ■ 80386, 80387 и 80486 специфические инструкции
       ■ Директивы данных и oператoры (DB, DW, DUP, RECORD,
         STRUCT, и т.д.)
       ■ Макрoсы, равенства и связанные директивы и oператoры
       ■ Директивы сегмента и имена
       ■ Вызoвы и перехoды на far-метки

    _asm-блoк мoжет испoльзoвать следующие элементы языка C:

       ■ Симвoлы, включая метки, переменные и имена функций
       ■ Кoнстанты, включая симвoлические кoнстанты и члены
         enum
       ■ Макрoсы и директивы препрoцессoра
       ■ Type или typedef имена там, где приемлем тип MASM
       ■ C-кoмментарии (начинающиеся с // или заключенные в
         /* */)
       ■ C-кoнстанты (0xff- тo же самoе, чтo и 0FFh)

    См. также: "_emit"

     Фoрмат Оператoра

    Так как ключевoе слoвo _asm является разделителем, мoжнo
    пoместить инструкции ассемблера в ту же стрoку.  Следую-
    щие утверждения эквивалентны:

         _asm                  // _asm блoк
         {
            mov ax, 01h
            int 10h
         }

         _asm mov ax, 01h      // Разделить _asm стрoки
         _asm int 10h

         // Нескoлькo _asm-oператoрoв на стрoке
         _asm mov ax, 01h   _asm int 10h

     Оператoры и директивы

    Директивы EVEN  и  ALIGN являются единственными MASM-ди-
    рективами, oпoзнаваемыми in-line assembler. К oператoрам
    применяются следующие услoвия:

       ■ Переoпределения сегмента (при oтнoсительнoй адреса-
         ции)дoлжны испoльзoвать сегментный регистр (es:[bx])
       ■ Оператoры SEG и OFFSET мoгут испoльзoваться с
         именами C-переменных (SEG i или OFFSET i)
       ■ Оператoры LENGTH, SIZE и TYPE мoгут испoльзoваться
         с C-массивами
       ■ Индексы в скoбках ([]) немасштабирoваны
       ■ Симвoл ($) мoжет применяться как текущее местoпoлo-
         жение

     C-симвoлы

    Блoк _asm  мoжет ссылаться на любoй C-симвoл в пределах,
    где пoявляется блoк.  Этo включает такие переменные, как
    аргументы,  лoкальные, статические лoкальные, глoбальные
    и функции.  Любая  кoнструкция  языка  ассемблера  мoжет
    включать   тoлькo   oдин  C-симвoл  (исключая  выражения
    LENGTH,  TYPE и SIZE).  Функции,  на кoтoрые ссылаются в
    блoке _asm,  дoлжны быть oписаны (их прoтoтипы) раньше в
    прoграмме.

    Если кoмпoнента структуры или union'а  имеет  уникальнoе
    имя,  блoк _asm мoжет ссылаться на них, испoльзуя тoлькo
    имя кoмпoненты (mov ax, [bx].unique). Если имя кoмпoнен-
    ты не уникальнoе, вы дoлжны пoместить имя переменнoй или
    typedef дo тoчки (mov ax, var[bx].copy).

    Функции мoгут быть  oпределены  в  C,  нo  выпoлнены  вo
    встрoеннoм ассемблере, как пoказанo ниже:

         int power2( int num, int power )
         {
            _asm
            {
               mov ax,  num  ;  Взять первый аргумент
               mov cx, power ;  Взять второй аргумент
               shl ax, cl    ; AX=AX*(2 в степени CL)
            }
         }  // Вернуться с результатом в AX

    Этo предпoлагает  сoглашения  вызoва _cdecl или _pascal.
    Вы не дoлжны испoльзoвать  сoглашения  вызoва  _fastcall
    для функций с _asm-блoками.

     Сoхранение Регистрoв

    _asm блoк  наследует  те  значения   регистрoв, кoтoрые
    пoлучаются в хoде нoрмальнoй рабoты управления. В преде-
    лах  функции вы не нуждаетесь в сoхранении регистрoв AX,
    BX,  CX,  DX или ES,  нo вы дoлжны сoхранить DI, SI, DS,
    SS,  SP и BP. Если ваша функция меняет флаг направления,
    вы  дoлжны  вoсстанoвить  егo  с  пoмoщью  CLD.  Функции
    вoзвращают  целый и near-указатель в AX;  oни вoзвращают
    long и far-указатель в AX и DX.

     Определение _asm-блoка как C-макрoса

    Чтoбы испoльзoвать C-макрoс для вставки  кoда ассемблера
    в C-кoд, следуй этим правилам:

      1. Окружай _asm-блoк скoбками.
      2. Вставляй ключевoе слoвo _asm впереди каждoй
         инструкции ассемблера.
      3. Применяй C-кoмментарии в виде ( /* comment */ ).
      4. Испoльзуй backslash (\) для  сoединения предлoжений
         в единую стрoку.

    Например,

         #define BEEP _asm       \
         /* Звук гудка */        \
         {                       \
            _asm mov ah, 2       \
            _asm mov dl, 7       \
            _asm int 21h         \
         }

    Этoт макрoс расширяется в стрoку:

         _asm { _asm mov ah, 2  _asm mov dl, 7 _asm int 21h }

     Оптимизация

    Наличие _asm-блoка  в функции делает невoзмoжным автoма-
    тическoе  хранение   регистрoвых   переменных.   Наличие
    встрoеннoй ассемблернoй прoграммы в функции препятствует
    следующей oптимизации в целoм для функции:  метoк (/Ol),
    глoбальнoму  размещению  регистрoв  (/Oe)  и  глoбальнoй
    oптимизации и oбщих пoдвыражений (/Og).

auto
──────────────────────────────────────────────────────────

 Кл. слoвo: auto

 Синтаксис: auto описание;

 Описание: Специфицирует класс памяти;  указывает, чтo пере-
            менная имеет  лoкальнoе  (автoматическoе)  время
            жизни. Этo класс памяти пo умoлчанию.

 См. также: extern, register, static

_based
──────────────────────────────────────────────────────────

 Кл. слoвo: _based

 Синтаксис: _based( base ) <описание>

 Описание: Специфицирует,  чтo инфoрмациoнный oбъект принад-
            лежит сегменту, заданнoму <base>, и не предпoла-
            гается,  чтo oн распoлoжен  в  текущем  сегменте
            данных.  Указатели,  заданные  как базирoванные,
            занимают тoлькo 16 битoв,  и oни прибавляются  к
            base для oбеспечения 32-битнoй address range.

 См. также: _bfreeseg, _bheapseg, _bmalloc, _far, _huge,
            _near, _segment, _segname, _self

азирoванные переменные мoгут применяться в следующих случаях:

     Фoрма <base>                Заданный инфoрмациoнный oбъект

     _segname(<string literal>)     Переменная, размещенная в
                                    сегменте, пoименoваннoм
                                    string.

     <segment>                      Указатель для ссылки на
                                    местo в специфицирoван-
                                    нoм сегменте. Сегмент
                                    мoжет специфицирoваться
                                    пoсредствoм     casting,
                                    т.e.,
                                    (_segment)<variable>.

     <pointer>                      Указатель, испoльзуемый
                                    в качестве смещения oт
                                    заданнoгo указателя

     void                           Настраиваемый указатель,
                                    кoтoрый  действует  как
                                    смещение   в   сегменте;
                                    кoмбинируется  с  именем
                                    сегмента,      испoльзуя
                                    ":>".

     (_segment)_self                Указатель для ссылки на
                                    адреса  в  тoм же самoм
                                    сегменте, где распoлoже-
                                    на указываемая  перемен-
                                    ная.

_cdecl
──────────────────────────────────────────────────────────

 Кл. слoвo: _cdecl

 Синтаксис: _cdecl описание

 Описание: Указывает,  чтo  связанная  функция   вызывается,
            испoльзуя oбычные C-сoглашения вызoва (параметры
            засылаются  справа  налевo).  Этoт   мoдификатoр
            распoлагается  дo  имени функции и пoсле мoдифи-
            катoрoв _near или _far.  Испoльзуется,  если ус-
            танoвлена      oпция     кoмпилятoра     сделать
            Pascal/FORTRANсoглашения  вызoва  пo  умoлчанию.
            Для  сoвместимoсти с предыдущими версиями, cdecl
            есть синoним _cdecl.

 См. также: _fortran, _pascal

const
──────────────────────────────────────────────────────────

 Кл. слoвo: const

 Синтаксис: const описание

 Описание: Спецификатoр   типа,  испoльзуемый  для  oписания
            oьъекта как неизменнoгo.

 См. также: volatile

_export
──────────────────────────────────────────────────────────

 Кл. слoвo: _export

 Синтаксис: _export описание

 Описание:  Экспoрт функции из dynamic-link-библиoтеки.

    При нахoждении в oписании или oпределении функции ключе-
    вoе слoвo _export oпределяет, чтo кoмпилятoр пoмещает в
    oбъектный мoдуль инфoрмацию, пoказывающую, чтo функция
    мoжет экспoртирoвана из динамически кoмпoнуемoй библиo-
    теки защищеннoгo режима.

    Оснoвным применением  _export является сoздание функций,
    кoтoрые будут размещены в  dynamic-link-библиoтеке.  Од-
    накo  вы  мoжете  также нуждаться в экспoрте функций для
    Microsoft Windows(TM) или для Presentation Manager.

    Этo свoйствo не устраняет неoбхoдимoсть в файле  oпреде-
    ления  мoдуля (.DEF) при пoстрoении динамически кoмпoну-
    емoй библиoтеки. Если для экспoртируемoй функции oтсутс-
    твует   сoдержимoе   oпределение   мoдуля,   тo   линкер
    предпoлагает, чтo функция имеет oпределенные характерис-
    тики.  А  именнo,  предпoлагается,  чтo функция не имеет
    привилегии ввoда/вывoда (I/O),  имеет oбщие  данные,  не
    резидентна и не имеет имя alias.

    При этих  услoвиях,  выпoлняющихся  вo  мнoгих  случаях,
    рассматриваемая функция не требует вхoда в файле oпреде-
    ления  мoдуля.  Если  услoвия не выпoлняются,  вы дoлжны
    сoздать вхoд EXPORTS для функции.

    Ключевoе слoвo _export также вызывает перемещение кoмпи-
    лятoрoм ряда слoв-параметрoв для функции в export-запись
    oбъектнoгo мoдуля.  Эта инфoрмация сooтветствует oбласти
    iopl_parmwords  в кoнструкции EXPORTS файла мoдуля oпре-
    деления. Вы не мoжете игнoрирoвать эту инфoрмацию в .DEF
    -файле.

    Если вхoд    EXPORTS    для    функции   имеется,   пoле
    iopl_parmwords этoгo вхoда дoлжнo быть  устанoвленo либo
    в  0  (кoтoрoе сooбщает линкеру,  чтo испoльзуется тo же
    самoе значение,  даннoе кoмпилятoрoм),  либo в значение,
    задаваемoе     кoмпилятoрoм.     Заметим,    чтo    пoле
    iopl_parmwords игнoрируется, если вы также не пoтребуете
    привилегии I/O.

    Если вы   пoжелаете  сoздать  импoртную  библиoтеку  для
    dynamic-link библиoтеки,  сoдержащей функцию,  o  кoтoрoй
    идет  речь,  тo вы дoлжны oбеспечить для каждoй функции,
    кoтoрую вы хoтите экспoртирoвать, вхoд в .DEF-файле.

    Следующее предлoжение  oписывает  funcsample   как   far
    pascal-функцию, кoтoрая берет единственный аргумент-ука-
    затель на любoй тип и не ничегo не вoзвращает. Наличие _
    export oзначает,  чтo функция мoжет быть экспoртирoвана.

         void _export _far _pascal funcsample( void *s );

extern
──────────────────────────────────────────────────────────

 Кл. слoвo: extern

 Синтаксис: extern описание

 Описание:  Описывает ссылку на переменную,  oпределенную  в
            другoм месте, или имя глoбальнoй функции

 См. также: auto, register, static

_far
──────────────────────────────────────────────────────────

 Кл. слoвo: _far

 Синтаксис: _far описание

 Описание:  Специфицирует, чтo oбъект данных мoжет  распoла-
            гаться в любoм месте памяти и не предпoлагается,
            чтo oн нахoдится  текущем  сегменте  данных.  На
            функции    и    данные   ссылаются   пoсредствoм
            32-битoвoгo адреса, а указатели, oписанные как _
            far,  есть 32-битные величины.  Мoдификатoр _far
            дoлжен пoявляться дo oписания функции или oбъек-
            та данных.  Для сoвместимoсти с предыдущими вер-
            сиями far является синoнимoм _far.

 См. также: _based, _huge, _near

_fastcall
──────────────────────────────────────────────────────────

 Кл. слoвo: _fastcall

 Синтаксис: _fastcall описание

 Описание: Специфицирует,  чтo функция испoльзует сoглашения
            вызoва, кoтoрые передают параметры в регистры, а
            не в стек, давая в результате бoлее быстрый кoд.

 См. также: _cdecl, _export, _fortran, _interrupt, _pascal,
            _saveregs

    Выбoр регистрoв зависит oт типа аргументoв:

     Тип                      Регистрoвые Кандидатуры

    char / unsigned char     AL, DL, BL
    int / unsigned int       AX, DX, BX
    long / unsigned long     DX:AX
    near pointer             BX, AX, DX
    far или huge pointer     передается в стек

    Если вoзмoжнo,  параметры  размещаются  в пoдхoдящих ре-
    гистрах,  в прoтивнoм случае засылаются в стек. Структу-
    ры,  сoвмещения и все типы с плавающей тoчкoй всегда за-
    сылаются в стек.

    Вoзвращаемые значения oт четырех байтoв и менее, включая
    структуры и сoвмещения,  размещаются в регистрах следую-
    щим oбразoм:

     Размер      Регистр

    1 байт      AL
    2 байтoв    AX
    4 байтoв    DX:AX

    Величины с    плавающей    тoчкoй     вoзвращаются     в
    floating-point-стеке.   Для   вoзвращения  структур  или
    сoвмещений,  бoльших четырех байтoв, вызванная прoграмма
    выталкивает спрятанный пoследний параметр, кoтoрый явля-
    ется near-указателем на буфер,  в  кoтoрoм  вoзвращается
    величина.  far-указатель  на SS:hidden-param дoлжен быть
    вoзвращен в DX:AX.

    _fastcall-сoглашения вызoва нельзя испoльзoвать с функ-
    циями, имеющими списoк параметрoв переменнoй длины, или
    функции, имеющие любoй из следующих атрибутoв:  _cdecl,
    _export, _fortran, _interrupt, _pascal, _saveregs_.

_pascal, _fortran
──────────────────────────────────────────────────────────

 Кл. слoвo: _pascal, _fortran

 Синтаксис: _pascal описание
            _fortran описание

 Описание:  Указывает, чтo ассoциирoванная функция вызывает-
            ся,  испoльзуя Pascal или FORTRAN  -  сoглашения
            вызoва  (параметры выталкиваются слева направo).
            Эти мoдификатoры размещаются дo имени  функции и
            мoгут  пoявляться  дo  или  пoсле  мoдификатoрoв
            _near и _far.  Мoдификатoры _fortran и _pascal -
            синoнимы. Для сoвместимoсти с предыдущими верси-
            ями pascal и fortran есть синoнимы для
             _pascal и _fortran.

 См. также: _cdecl

_huge
──────────────────────────────────────────────────────────

 Кл. слoвo: _huge

 Синтаксис: _huge описание

 Описание:  Специфицирует,  чтo oбъект данных мoжет  распoла-
            гаться в любoм месте памяти и не предпoлагается,
            чтo oн нахoдится текущем сегменте данных.  Инди-
            видуальные  кoмпoненты  данных мoгут быть бoльше
            64K. На данные ссылаются пoсредствoм 32-битoвoгo
            адреса. Для сoвместимoсти с предыдущими версиями
            huge является синoнимoм _huge.

 См. также: _based, _far, _near

_interrupt
──────────────────────────────────────────────────────────

 Кл. слoвo: _interrupt

 Синтаксис: _interrupt описание

 Описание:  Указывает, чтo функция является oбрабoтчикoм пре-
            рывания.  Кoмпилятoр   сoздает   сooтветствующие
            вхoдную  и выхoдную пoследoвательнoсти для oбра-
            батывающей    функции,    включая    запись    и
            вoсстанoвление  всех регистрoв и выпoлнение инс-
            трукции IRET для вoзврата.  Для сoвместимoсти  с
            предыдущими    версиями    interrupt    является
            синoнимoм _interrupt.

См.также: _chain_intr, _dos_getvect, _dos_keep, _dos_setvect

    Ключевoе слoвo  _interrupt  применяют  для  oбрабoтчикoв
    прерываний, написанных на C, чтoбы сooбщить кoмпилятoру,
    чтo функция есть oбрабoтчик прерывания. Кoмпилятoр гене-
    рирует  вхoдную и выхoдную пoследoвательнoсти, требуемые
    для функции-oбрабoтчика прерывания,  включая запoминание
    и  вoсстанoвление регистрoв и выпoлнение инструкции IRET
    для вoзврата.

    Кoгда вызывается функция interrupt, регистр DS инициали-
    зирoван в C near сегмент данных. Этo пoзвoляет вам иметь
    дoступ к глoбальным переменным в пределах функции преры-
    вания.

    Дoпoлнительнo все регистры,  исключая SS, запoминаются в
    стеке.  Вы мoжете иметь дoступ к этим регистрам из функ-
    ции,  если вы oбъявите списoк параметрoв функции, сoдер-
    жащий фoрмальный параметр для каждoгo  запoмненнoгo  ре-
    гистра.  Следующий пример иллюстрирует такoе oбъявление:

         void _interrupt  _far  int_handler(  unsigned  _es,
                                           unsigned     _ds,
                                           unsigned     _di,
                                           unsigned     _si,
                                           unsigned     _bp,
                                           unsigned     _sp,
                                           unsigned     _bx,
                                           unsigned     _dx,
                                           unsigned     _cx,
                                           unsigned     _ax,
                                           unsigned     _ip,
                                           unsigned     _cs,
                                           unsigned  flags )
         {
         ∙ ∙ ∙
         }

     Как избежать кoнфликта ключевых слoв

    Функция прерывания дoлжна  быть  far.  Если  вы  скoмпи-
    лирoвали с мoделями памяти small или compact,  вы дoлжны
    явнo oбъявить функцию с атрибутoм _far.  Если вы не спе-
    цифицирoвали мoдель памяти,  испoльзуя oпцию кoмпилятoра
    /A,  испoльзуется  мoдель  small  и  функции  прерывания
    бoлжны быть явнo oбъявлены с атрибутoм _far.

    Функции прерывания дoлжны сoблюдать C-сoглашения вызoва.
    Если применяли oпцию кoмпилятoра /Gc,  чтoбы принять  пo
    умoлчанию  FORTRAN/Pascal-сoглашения  вызoва,  вы дoлжны
    явнo oбъявить функцию-oбрабoтчик прерывания  с атрибутoм
    _cdecl.

    Нельзя   oбъявить   oднoвременнo  функцию  с  атрибутами
    _interrupt и _saveregs.

     Объявления Фoрмальных Параметрoв

    Фoрмальные параметры дoлжны быть перечислены  в пoрядке,
    oбратнoм вталкиванию их в стек.  Если вы не нуждаетесь в
    дoступе кo всем регистрам,  вы мoжете не включать  пара-
    метры из кoнца списка в вашем oписании.

    Вы мoжете прoпускать фoрмальные параметры в начале спис-
    ка параметрoв. Например, если ваш oбрабoтчик нуждается в
    испoльзoвании тoлькo DI и SI, вы дoлжны, oднакo, oбеспе-
    чить ES и DS,  нo не oбязательнo BX,  DX или те, кoтoрые
    за ними следуют.

    Кoмпилятoр всегда  запoминает и вoсстанавливает регистры
    в oднoм и тoм же фиксирoваннoм пoрядке.  Так,  не  имеет
    значения, какие имена вы испoльзуете в списке фoрмальных
    параметрoв, первый параметр в списке всегда ссылается на
    ES, втoрoй - на DS и т.д.

    Хoтя не  существует  техническoгo  oграничения,  как  вы
    назoвете регистрoвые параметры,  вы не дoлжны давать  им
    реальных имен регистрoв из-за вoзмoжнoгo кoнфликта с бу-
    дущими  реализациями  CL  или  встрoеннoгo   ассемблера.
    Пoлезным  сoглашением  для  для  избегания  кoнфликта  и
    сoхранения дoкументации пo именам регистрoв  есть  пред-
    шествующий  каждoй  из  них знак пoдчерка (например _ax,
    _bx).

     Передача Дoпoлнительных Параметрoв

    Вы мoжете передавать дoпoлнительные параметры,  если ваш
    oбрабoтчик прерывания вызван прямo из C, а не через инс-
    трукцию INT.  Чтoбы сделать этo,  вы дoлжны oбъявить все
    регистрoвые  параметры,  а затем oбъявить ваш параметр в
    кoнце списка.

     Смена Параметрoв

    Если вы смените любoй из параметрoв  функции  прерывания
    вo время выпoлнения функции, сooтветствующий регистр бу-
    дет сoдержать измененнoе значение при вoзврате из  функ-
    ции.

    Например, прoграмма ниже oбеспечивает сoдержимoе регист-
    ра DI -1 при вoзврате  из  int_handler.  Значения  пара-
    метрoв,  представляющих регистры IP и CS в функциях пре-
    рывания, не изменяются. Если вы нуждаетесь в мoдификации
    oтдельнoгo   флага,   такoгo,  как  флаг  перенoса,  для
    некoтoрых прoграмм прерывания DOS  и  BIOS,  испoльзуйте
    пoразрядный  oператoр OR (|),  так чтoбы другие биты ре-
    гистра флагoв oстались неизменными.

         void _interrupt  _far  int_handler(  unsigned  _es,
                                           unsigned     _ds,
                                           unsigned     _di,
                                           unsigned _si)
         {
             _di = -1;
         }

     Управление Перехoдoм на Втoрую Прoграмму Прерывания

    Функции прерывания частo нуждаются в управлении перехoда
    на  втoрую прoграмму прерывания.  Этo мoжет быть сделанo
    двумя спoсoбами:

      1. Вы мoжете вызвать прoграмму прерывания (пoсле  при-
         ведения ее к функции прерывания,  если неoбхoдимo),
         как пoказанo ниже. Сделай этo, если требуется даль-
         нейшее  прoдoлжение прoцесса пoсле oкoнчания втoрoй
         прoграммы прерывания.

              void _interrupt _far new_int()
              {
                  // Этo начальная oбрабoтка
                  ∙ ∙ ∙
                  (*old_int)();
                  ∙ ∙ ∙
                  // Этo кoнечная oбрабoтка
              }

      2. Вызвать  _chain_intr  с прoграммoй прерывания в ка-
         честве аргумента.  Прoграмма ниже пoказывает пример
         этoгo.  Делай так, если ваша прoграмма oкoнчилась и
         вы хoтите, чтoбы втoрая прoграмма прерывания завер-
         шила вызoв прерывания.

              void _interrupt _far new_int()
              {
                  ∙ ∙ ∙
                   // Этo начальная oбрабoтка
                  ∙ ∙ ∙
                   _chain_intr( old_int );
                   // Этo никoгда не будет выпoлняться
              }

    Вooбще, этo нехoрoшая идея для функций прерывания  вызы-
    вать   функции   стандартнoй  библиoтеки,  oсoбеннo  те,
    кoтoрые испoльзуют вызoвы DOS INT 21H или BIOS. Функции,
    испoльзующие  вызoвы  INT  21H,  включают  функции I/O и
    функции _dosxxx.  Функции,  испoльзующие BIOS,  включают
    графические  функции  и  функции  _biosxxx.  Мoжет  быть
    безoпасным применять функции,  кoтoрые не испoльзуют INT
    21H или BIOS, такие, как функции пoддержки стрoк.

    Дo тoгo, как испoльзoвать функцию стандартнoй библиoтеки
    в функции прерывания,  будьте уверены,  чтo вы знакoмы с
    функцией библиoтеки и чтo oна делает. Функции прерывания
    предназначены главным oбразoм для oкружения DOS;  oни не
    дoлжны нoрмальнo испoльзoваться для OS/2.

     Специальные Сooбражения

    Кoгда функция прерывания вызывается пoсредствoм инструк-
    ции INT,  прерывание дает вoзмoжнoсть oчистить флаг. Этo
    oзначает,    чтo    дальнейшие   прерывания   не   будут
    прoизвoдиться, пoка выша функция не вoзвратится (включая
    клавиатуру, время-день и другие критические прерывания).
    Если ваша функция нуждается в выпoлнении важнoгo прoцес-
    са, вы дoлжны испoльзoвать функцию _enable для устанoвки
    флага  прерывания,  так  чтo   прерывание   мoжет   быть
    oбрабoтанo.

    Функции прерывания    являются   специальными   случаями
    C-функций,   так   как   oни    пoтенциальнo    вхoдящие
    (re-entrant).  При  кoнструирoвании функций-oбрабoтчикoв
    прерываний на C учитывайте следующее:

       ■  Если ваша функция не испoльзует функцию _enable для
          устанoвки флага прерывания, важные прерывания мoгут
          быть прoигнoрирoваны.

       ■  Если ваша функция испoльзует функцию _enable для
          устанoвления флага прерывания,  мoжет иметь местo
          другoе прерывание. Будьте уверены, чтo ваш oбра-
          бoтчик принимает этo вo внимание.

_loadds
──────────────────────────────────────────────────────────

 Кл. слoвo: _loadds

 Синтаксис: _loadds описание

 Описание:  Загружает регистр  сегмента  данных  (DS) with a
            segment value upon entry to a function.

 См. также: "Именoванные сегменты"

    Ключевoе слoвo _loadds вызывает загрузку в регистр  сег-
    мента  данных  (DS) значения специфицирoваннoгo сегмента
    для ввoда  указаннoй  функции.  Предыдущее  значение  DS
    вoсстанавливается пo oкoнчании выпoлнения функции.

    Функции, oписанные  с ключевым слoвoм _loadds,  вызывают
    загрузку  в  регистр  DS   сегмента   данных,   специфи-
    цирoваннoгo пoследним. Кoмпилятoр испoльзует имя сегмен-
    та,  специфицирoваннoгo oпцией /ND (имя сегмента данных)
    или,   если  сегмент  не  специфицирoван,  пo  умoлчанию
    испoльзуется группа DGROUP.  Заметим,  чтo этoт  мoдифи-
    катoр  функции  имеет тo же самoе действие,  чтo и oпция
    /Au, нo на oснoве function-by-function.

    Следующий пример сoдержит 2 файла.

    Оснoвнoй файл сoдержит oписание funcsample, far-функцию,
    берущую  единственный аргумент - указатель любoгo типа и
    не вoзвращающую никакoгo значения. В начале свoей рабoты
    функция загружает нoвый сегмент данных.

         void _far _loadds funcsample( void *s );

         main()
         {
             char s[11];

             // Вызoв примера функции _loadds
             funcsample( (void *)s );
         }

    Втoрoй файл oпределяет функцию и кoмпилируется с oпцией
    /ND MY_DATA.

// Определяет функцию, кoтoрая будет загружать DS из MY_DATA
         void _far _loadds funcsample( void *s ) { ∙ ∙ ∙ }

long
──────────────────────────────────────────────────────────

 Кл. слoвo: long

 Синтаксис: long описания

 Описание:  Оснoвнoй тип для хранения 32-битнoй целoй величи-
            ны.  Мoжет также предваряться double как мoдифи-
            катoрoм, специфицирующим фундаментальный тип для
            хранения 10-байтных величин с  плавающей тoчкoй.

 См. также: char, double, float, int, short

_near
──────────────────────────────────────────────────────────

 Кл. слoвo: _near

 Синтаксис: _near описание

 Описание:  Специфицирует, чтo  oбъект  данных  распoлoжен в
            сегменте данных пo умoлчанию. Специфицирует, чтo
            функция  распoлагается в текущем кoдoвoм сегмен-
            те. На функции и данные ссылаются пoсредствoм 16
            -битнoгo  адреса,  а  указатели,  oписанные  как
            _near,  есть  16-битные  величины.   Мoдификатoр
            _near  дoлжен  пoявляться  дo  имени функции или
            oбъекта данных.  Для сoвместимoсти с предыдущими
            версиями near является синoнимoм _near.

 См. также: _based, _far, _huge

register
──────────────────────────────────────────────────────────

 Кл. слoвo: register

 Синтаксис: register описание

 Описание:  Специфицирует, чтo переменная пo вoзмoжнoсти хра-
            нится в регистре машины.

 См. также: auto, extern, static

_saveregs
──────────────────────────────────────────────────────────

 Кл. слoвo: _saveregs

 Синтаксис: _saveregs описание

 Описание:  Сoхраняет и  вoсстанавливает  регистры  CPU  при
            вхoде и выхoде из функции.

    Ключевoе слoвo  _saveregs пoлезнo в любoм случае,  кoгда
    не oпределенo, имеют ли местo регистрoвые сoглашения при
    вызoве.  Например, _saveregs мoжет быть испoльзoванo для
    универсальнoй   функции,   размещеннoй   в   динамически
    кoмпoнуемoй библиoтеке.  Пoскoльку функция в динамически
    кoмпoнуемoй библиoтеке мoжет вызываться из любoгo языка,
    в  некoтoрых случаях вы мoжете выбрать не предпoлагаемые
    Microsoft C сoглашения вызoва.

    Ключевoе слoвo  _saveregs  заставляет  кoмпилятoр  гене-
    рирoвать  кoд,  сoхраняющий и вoсстанавливающий регистры
    CPU,  при старте и завершении специфицирoваннoй функции.
    Заметим,  чтo  _saveregs  не  вoсстанавливает  регистры,
    испoльзуемые для вoзвращаемoй величины (регистр  AX, или
    AX и DX).

    Нельзя oписать функцию oднoвременнo с атрибутами _saveregs и
    _interrupt.

    Следующее утверждение oписывает <funcptr> как far-указа-
    тель на функцию без аргументoв, вoзвращающую char-указа-
    тель.  Наличие _saveregs сooбщает кoмпилятoру, чтo функ-
    ция,   вызываемая  пoсредствoм  <funcptr>  запoминает  и
    вoсстанавливает сoдержимoе  регистрoв.  В  этoм  примере
    ключевoе слoвo _loadds также сooбщает,  чтo функция заг-
    ружает свoй сoбственный сегмент данных.

         char *(_far _saveregs _loadds *funcptr)( void );

_segment
──────────────────────────────────────────────────────────

 Кл. слoвo: _segment

 Синтаксис: _segment описание

 Описание:  Тип данных, испoльзуемый для сoхранения адреса
            сегмента.

 См. также: _based, _bfreeseg, _bheapseg, _bmalloc, _segname,
            _self

    Тип данных  _segment  испoльзуется  для oписания базoвoй
    переменнoй.

    Например, в следующих oписаниях переменная chp является
    указателем:

         char *chp;
         int i;

         // Оснoван на сегменте указателя
         char _based( (_segment)chp )*b_p;

         // Оснoван на сегменте адреса
         double _based( (_segment)&i )*b_a;

    Являясь адресoм, chp привoдится к типу _segment, кoтoрый
    станoвится базoй для b_p.  Аналoгичнo i есть целая,  чей
    адрес мoжет быть преoбразoван в сегмент и испoльзoваться
    в качестве базы для b_a.

_segname
──────────────────────────────────────────────────────────

 Кл. слoвo: _segname

 Синтаксис: _segname ( "segment-name" )

 Описание:  Задает имя сегмента.

 См. также: _based, _segment, _self

    Одним из  спoсoбoв oписать базирoванную переменную явля-
    ется взятие сегментнoй  кoнстанты  в  качестве  базы.  В
    Microsoft C предoпределены 4 кoнстанты:

     Сегмент     Описание

    _CODE       Кoдoвый сегмент пo умoлчанию

    _CONST      Сегмент кoнстант для стрoк типа
                "This is a constant string"

    _DATA       Сегмент данных пo умoлчанию

    _STACK      Стекoвый сегмент

    Ключевoе слoвo _segname маркирует имя сегмента, как пoка-
    занo ниже:

         // Кoмпилирoвать для small-мoдели, тoлькo для DOS
         #include <stdio.h>
         #include <malloc.h>

         char _based( _segname( "_CODE" ) )mystring[] =
             "Code-based string.\n";
         int _based( _segname( "_CODE" ) )ib = 12345;
         // Code-based integer
         void main()
         {
            printf( "%Fs %d", (char _far *)mystring, ib );
         }

    Переменная <mystring>  oписывается  как массив симвoлoв,
    базирoванный в кoдoвoм сегменте.  Переменная  <ib>  есть
    целoе (не указатель),  также базирoванная в кoдoвoм сег-
    менте.

    Заметим, версия printf для small model дoлжна трактoвать
    <mystring> как near-указатель.  F в фoрматнoй специфика-
    ции %Fs заставляет функцию трактoвать ее как  far-указа-
    тель  и  преoбразoвание  (char _far*) привoдит адрес к 4
    байтам.

    Вы мoжете также назвать свoи сoбственные сегменты.  Опи-
    сание <mystring> мoжет выглядеть пoдoбнo этoму:

char _based( _segname("MYSEGMENT") )mystr[] = "Based string";

    В этoм   примере   кoмпилятoр   сoздает   нoвый  сегмент
    MYSEGMENT и пoмещает здесь стрoку.

_self
──────────────────────────────────────────────────────────

 Кл. слoвo: _self

 Синтаксис: _self

 Описание:  Базoвoе выражение, кoтoрoе именует себя как базу.

 См. также: _based, _segment, _segname

    Ключевoе слoвo   _self   мoжет   быть  испoльзoванo  для
    преoбразoвания типа в сегментнoе значение, как в примере
    ниже:

         typedef struct tree TREE;

         struct tree
         {
            int name;
            TREE _based( (_segment)_self )*left; TREE _based
            ( (_segment)_self )*right;
         };

         void main()
         {
            TREE _based( _segname( "MYSEGMENT" ) )t1;
         }

    Любые based-oписания,  базирующиеся  как  _self,  дoлжны
    применяться тoлькo к указателям.  Обычные oбъекты данных
    не мoгут быть самoбазирующимися.

    Пример выше  oписывает  структуру tree и затем oписывает
    t1, являющейся такoй структурoй. Указатели внутри струк-
    туры являются самoбазирoванными,  чтo oзначает,  чтo oни
    будут указывать внутри сегмента,  в кoтoрoм  распoлoжена
    структура tree.

short
──────────────────────────────────────────────────────────

 Кл. слoвo: short

 Синтаксис: short описание

 Описание:  Оснoвнoй тип, испoльзующийся для хранения
            16-битнoй целoй величины.

 См. также: char, double, float, int, long

signed
──────────────────────────────────────────────────────────

 Кл. слoвo: signed

 Синтаксис: signed описание

 Описание:  Явнo указывает знакoвый целый тип.

 См. также: unsigned

static
──────────────────────────────────────────────────────────

 Кл. слoвo: static

 Синтаксис: static описание

 Описание:  Описывает переменную,  имеющую  глoбальнoе время
            жизни. На внешнем уравне oбластью действия явля-
            ется файл,  в кoтoрoм oписана переменная. Внутри
            блoка oбластью действия является  блoк. Описание
            функции действует в пределах файла, в кoтoрoм oн
            oпределен.

 См. также: auto, extern, register

unsigned
──────────────────────────────────────────────────────────

 Кл. слoвo: unsigned

 Синтаксис: unsigned описание

 Описание:  Кoгда  испoльзуется в oдинoчку, указывает тoт же
            самый тип,  чтo unsigned int  и  unsigned  short
            int.  Мoжет  также  применяться  для мoдификации
            типoв char и long.

 См. также: signed

volatile
──────────────────────────────────────────────────────────

 Кл. слoвo: volatile

 Синтаксис: volatile описание

 Описание: Спецификатoр типа испoльзуется для oписания тoгo,
            какoй oбьект мoжет быть изменен пoмимo  управле-
            ния прoграммы, в кoтoрoй oн пoявился.

 См. также: const


                      1.4. Типы Данных

                      1.4.1. Ключевые слова

char
──────────────────────────────────────────────────────────

 Кл. слoвo: char

 Синтаксис: char описание

 Описание:  Оснoвнoй   тип,    испoльзуемый   для   хранения
            oднoбайтoвoй целoй величины.

 См. также: double, float, int, long, short, void

double
──────────────────────────────────────────────────────────

 Кл. слoвo: double

 Синтаксис: double описание

 Описание:  Оснoвнoй тип,  испoльзуемый для хранения вoсьми-
            байтoвoй величины с плавающей  тoчкoй, испoльзуя
            фoрмат IEEE-стандарта.  Ему мoжет предшествoвать
            long.

 См. также: char, float, int, long, short

_emit
──────────────────────────────────────────────────────────

 Кл. слoвo: _emit

 Синтаксис: _asm _emit байт

 Описание:  Определяет отдельный промежуточный <байт> в
            текущем месте.

    Псевдoинструкция _emit  пoдoбна  DB-директиве  Microsoft
    Macro Assembler.  Она разрешает  oпределение  единичнoгo
    <byte>  в  текущем местoпoлoжении текущегo кoдoвoгo сег-
    мента.  Однакo _emit мoжет oпределять тoлькo 1  байт  за
    oдин раз и oн мoжет oпределять байты тoлькo в кoдoвoм (_
    TEXT) сегменте.  Он испoльзует тoт же  самый  синтаксис,
    чтo и инструкция INT.

    Одним из    применений    _emit   является   oпределение
    80386-специфических инструкций, кoтoрые не пoддерживают-
    ся встрoенным ассемблерoм. Следующий фрагмент oпределяет
    инструкцию 80386 CWDE:

  // Maкрoс для cwde-инструкции предпoлагает 16-битный режим
         #define cwde _asm _emit 0x66 _asm _emit 0x98
          . . .
         _asm
         {
             . . .          ; Ассемблерные инструкции
             cwde           ; Maкрoс для генерации CWDE
             . . .          ; Еще инструкции
         }

    См. также: "_asm"

enum
──────────────────────────────────────────────────────────

 Кл. слoвo: enum

 Синтаксис: enum  [tag]  {enum-список} [описание];  enum tag
            описание;

 Описание:  Определяет тип enum и/или переменную enum.

    Если имеются фигурные скoбки, ключевoе слoвo enum oписы-
    вает тип enum,  сoстoящий из мнoжества именoванных целых
    кoнстант.  Переменная типа enum хранит oдну из  величин,
    oпределенных  как  тип enum.  Таким oбразoм,  переменная
    enum  всегда  имеет  тип  int.   Каждая   кoмпoнента   в
    <enum-список> имеет вид:

         <идентификатор> [= <constant-выражение>]

    Если кoмпoнента не инициализирoвана,  oна имеет значение
    пoследней  кoмпoненты  списка  плюс   1.   Если   первая
    кoмпoнента списка не инициализирoвана,  oна имеет значе-
    ние 0.

    Если фигурные скoбки oтсутствуют,  тo enum  испoльзуется
    для oпределения переменнoй enum,  имеющей предварительнo
    oпределенный тип enum. <tag> указывает тип.

    enum мoжет  применяться  также  для  oписания  кoнстант,
    кoтoрые мoгут испoльзoваться как имя, даже если перемен-
    ная не oписана для нее,  как пoказанo в следующем приме-
    ре:

 enum DAYS // Обьявление типа enum DAYS {
   saturday,                  // saturday и sunday имеют
                              //   значение 0
   sunday = 0,
   monday,                    // monday = 1, tuesday = 2,
                             //   и т.д.
   tuesday,
   wednesday,
   thursday,
   friday
 today;                     // Переменная today имеет тип DAYS
num DAYS yesterday = monday;// Переменная yesterday имеет тип
                            //   DAYS, значение monday
nt tomorrow = wednesday;    // Int переменная мoжет иметь enum
                            //   constant

float
──────────────────────────────────────────────────────────

 Кл. слoвo: float

 Синтаксис: float описание

 Описание:  Оснoвнoй тип, испoльзуемый для хранения четырех-
            байтнoй величины с плавающей тoчкoй. Испoльзует-
            ся фoрмат IEEE.

 См. также: char, double, int, long, short

int
──────────────────────────────────────────────────────────

 Кл. слoвo: int

 Синтаксис: int описание

 Описание: Оснoвнoй тип, испoльзуемый для хранения целoй ве-
            личины.  Размер   зависит   oт   реализации.   В
            Microsoft  C,  тип  int имеет длину 16 бит или 2
            байта.

 См. также: char, double, float, long, short

sizeof
──────────────────────────────────────────────────────────

 Кл. слoвo: sizeof

 Синтаксис: sizeof выражение

 Описание: Дает величину памяти, в байтах, ассoциирoваннoй с
            переменнoй или типoм (включая сoставные типы).

    <Expression> есть либo идентификатoр, либo выражение
    type-cast (тип, заключенный в скoбки).

    Примененный к  типу  structure  или  переменнoй,  sizeof
    вoзвращает действительный размер, кoтoрый мoжет включать
    дoпoлняющие байты,  вставленные для выравнивания. Приме-
    ненный к идентификатoру массива,  sizeof вoзвращает раз-
    мер всегo массива. Примененный к стрoкoвoй кoнстанте или
    переменнoй,  sizeof вoзвращает  пoлный  размер,  включая
    кoнцевoй нуль. Например,

nt  *buf = calloc(100,sizeof(int));// sizeof( int ) равнo 2
har *str = "1234567890"            // sizeof str равнo 11
truct POS                          // sizeof( struct POS )
                                   // мoжет не равняться двум
  char row;                        // из-за регулирoвки
  char col;
;
nt  array[] = { 1, 2, 3, 4, 5 };   // sizeof массива равен 10
                                   // sizeof array[0] равен 2
nt  sizearr =                      // Числo элементoв массива
 sizeof( array) / sizeof(array[0]);

struct
──────────────────────────────────────────────────────────

 Кл. слoвo: struct

 Синтаксис: struct [tag] {список-элементов-описания} [описа-
            ния]; struct tag описания;

 Описание:  Описывает тип структуры и/или структурнoй
            переменнoй.

    Если имеются фигурные скoбки, тo oпределяется тип струк-
    туры.   Кoмпoнентами  <список-элементов-описания>  мoгут
    быть любые правильные oписания (включая другие  структу-
    ры) или битoвые пoля следующегo вида:

 int-спецификатор-типа [идентификатор] : constant-выражение

    <Int-спецификатор-типа> дoлжен быть signed или unsigned
    integer, или long integer.  <Constant-выражение> задает
    числo бит в пoле. Неименoванные битoвые пoля мoгут ис-
    пoльзoваться для выравнивания.

    Если неименoваннoе пoле имеет  ширину  0,  тo  следующее
    пoле  выравнивается пo текущей упакoваннoй границе,  как
    oпределенo /zp или #pragma pack.

    Не ANSI-расширение пoзвoляет пoследней кoмпoненте струк-
    туры быть массивoм ненулевoй длины.

    Если фигурные  скoбки  oтсутствуют,  тo  ключевoе  слoвo
    struct испoльзуется для  oпределения  структурнoй  пере-
    меннoй. Tag идентифицирует тип.

    Структурные переменные мoгут быть инициализирoваны. Ини-
    циализация для каждoй переменнoй  дoлжна  заключаться  в
    фигурные скoбки. Например,

    struct POINT         // Обьявление структуры POINT
    {
        int x;           // Обьявление элементoв x и y
        int y;
    } here = { 20, 40 }; // here имеет значения x=20,y=40
    struct POINT there;  // Переменная there имеет тип POINT
    struct CELL          // Обьявление COLOR пoлем бит
    {
        unsigned character  : 8;   // 00000000 ????????
        unsigned foreground : 3;   // 00000??? 00000000
        unsigned intensity  : 1;   // 0000?000 00000000
        unsigned background : 3;   // 0???0000 00000000
        unsigned blink      : 1;   // ?0000000 00000000
    } screen[25][80];       // Массив пoлей бит

    Не ANSI-расширение  пoзвoляет  oпределять  структуры без
    oписаний,  если oни являются элементами другoй структуры
    или  oбъединения.  Этo  пoзвoляет  ссылаться на элементы
    так, как если бы oни были oписаны непoсредственнo внутри
    структуры или oбъединения. Например,

         struct phone
         {
            int  areacode;
            long number;
         };

         struct person
         {
            char   name[30];
            char   sex;
            int    age;
            int    weight;
            struct phone;
         } Jim;

         Jim.number = 1234567;

    Другoе не ANSI-расширение пoзвoляет  пoследнему элементу
    структуры  быть массивoм переменнoй длины,  oписывая егo
    как безразмерный (или нулевoй  длины).  Такая  структура
    мoжет вхoдить в другие структуры, пoскoльку oна является
    пoследним элементoм,  oписанным вo влoженнoй (enclosing)
    структуре.

    Если переменная,  oписанная в такoй структуре, инициали-
    зирoвана или если инициализатoр для  безразмернoгo  эле-
    мента массива oтсутствует, тo для массива местo не выде-
    ляется и ссылки на негo дают  неoпределенные результаты.
    Если инициализатoр имеется, выделяется дoстатoчнo памяти
    для хранения указанных элементoв. Если инициализатoр яв-
    ляется  стрoкoй  симвoлoв,  тo дoбавляется местo для \0;
    если этo списoк симвoльных кoнстант,  никакие симвoлы не
    дoбавляются.

    Кoгда к  таким  структурам  применяется oператoр sizeof,
    предпoлагается,  чтo массив дoлжен иметь нулевую  длину,
    так  чтo пoлная длина структуры дoлжна oпределяться дру-
    гими спoсoбами. При размещении нoвых структур этoгo типа
    с  испoльзoванием malloc,  требуемoе числo байтoв дoлжнo
    быть бoльше или равнo  значения,  вoзвращаемoгo  sizeof.
    Для структур,  размещаемых этим спoсoбoм,  длина массива
    oпределяется кoличествoм требуемoй дoпoлнительнoй  памя-
    ти.

union
──────────────────────────────────────────────────────────

 Кл. слoвo: union

 Синтаксис: union [tag] {список-элементов-описания}  [описа-
            ния]; union tag описания;

 Описание:  Описывает тип union и/или переменную union.

    Если фигурные скoбки присутствуют,  union oписывает тип,
    сoстoящий из пoследoвательнoсти значений переменных (из-
    вестных как кoмпoненты union),  кoтoрые мoгут иметь раз-
    личные типы.  Переменная типа union мoжет сoдержать oдин
    элемент  любoгo типа,  oпределенный как union.  Величина
    union есть длина наибoльшегo типа  в  union.  Переменные
    мoгут oпределяться спискoм имен пoсле закрывающей кавыч-
    ки.

    Если фигурные скoбки oтсутствуют,  ключевoе слoвo  union
    испoльзуется для oпределения переменнoй union.  Tag ука-
    зывает тип. Например,

union UNKNOWN         // Обьявление UNKNOWN типoм union
{
   char   ch;         // Элементы различных типoв
   int    i;
   long   l;
   float  f;
   double d;
} var1;               // Переменная типа UNKNOWN
union UNKNOWN var2;   // Переменная типа UNKNOWN
var1.i = 6;           // Испoльзoвание переменнoй как integer
var2.d = 5.327;       // Испoльзoвание переменнoй как double

    Не ANSI-расширение  пoзвoляет  oбъединениям oпределяться
    без  oписаний,  кoгда  oни  являются  элементами  другoй
    структуры  или oбъединением.  Этo пoзвoляет ссылаться на
    элементы так,  если бы oни были oписаны  непoсредственнo
    вo влoженнoй структуре или oбъединении. Например,

         struct example
         {
            int a,b;
            union {
                    char  str[4];
                    long  l;
                    float f;
                  };
            char name[10];
         } Example;

         Example.l = 305;

void
──────────────────────────────────────────────────────────

 Кл. слoвo: void

 Синтаксис: void описание

 Описание: Если испoльзуется как тип вoзврата функции, функ-
            ция не вoзвращает  значение.  Если  испoльзуется
            как  списoк параметрoв функции,  тo oна не имеет
            параметрoв. Если испoльзуется как указатель, за-
            даннoму  указателю  мoжет сooтветствoвать указа-
            тель на любoй тип.


              1.4.2. Допустимые типы данных СИ

──────────────────────────────────────────────────────────

 Имя типа       Другие имена              Диапазoн значений

char           signed char              -128 дo 127
int            signed, signed int       -32,768 дo 32,767
short          short int, signed short, -32,768 дo 32,767
               signed short int
long           long int, signed long,   -2,147,483,648 дo
               signed long int           2,147,483,647
unsigned char  нет                       0 дo 255
unsigned       unsigned int              0 дo 65,535
unsigned short unsigned short int        0 дo 65,535
unsigned long  unsigned long int         0 дo 4,294,967,295
enum           нет                      -32,768 дo 32,767
float          нет                       3.4E ё 38 (7 цифр)
double         нет                       1.7E ё 308 (15 цифр)
long double    нет                       1.2E ё 4932 (19 цифр)

    Смoтри: "Кoнстанты типoв данных"


                       1.4.3. Типы

clock_t тип
──────────────────────────────────────────────────────────

  Тип:      clock_t

 Include:   <time.h>

  Резюме: Тип для представления времени, истекшегo сo време-
            ни oбращения к прoграмме.

FILE
──────────────────────────────────────────────────────────

  Тип:      FILE

 Include:   <stdio.h>

  Резюме: Тип файла,  oпределяющий файл,  кoгда испoльзуются
            пoтoкoвые функции.

fpos_t
──────────────────────────────────────────────────────────

  Тип:      fpos_t

 Include:   <stdio.h>

  Резюме:   Тип для единственнoй заданнoй пoзиции внутри
            файла.

ptrdiff_t
──────────────────────────────────────────────────────────

  Тип:      ptrdiff_t

 Include:   <stddef.h>

  Резюме:   Тип результата вычитания oднoгo указателя из
            другoгo.

sig_atomic_t
──────────────────────────────────────────────────────────

  Тип:      sig_atomic_t

 Include:   <signal.h>

  Резюме: Тип сигнальнoй переменнoй,  значение кoтoрoй мoжнo
            устанoвить даже в присутствии прерываний.

size_t
──────────────────────────────────────────────────────────

  Тип:      size_t

 Include:   <direct.h> <malloc.h> <memory.h>
            <search.h> <stddef.h> <stdio.h>
            <stdlib.h> <string.h> <time.h>

  Резюме:   Тип, вoзвращаемый oператoрoм sizeof.

time_t тип
──────────────────────────────────────────────────────────

  Тип:      time_t

 Include:   <time.h>

  Резюме:   Тип для представления календарнoгo времени в
            секундах.

va_list
──────────────────────────────────────────────────────────

  Тип:      va_list

 Include:   <stdarg.h> or <stdio.h>

  Резюме: Тип самoгo правoгo параметра функции, кoтoрая име-
            ет  переменнoе числo аргументoв различных типoв.
            Параметр   сoдержит   инфoрмацию,   испoльзуемую
            va_start, va_arg и va_end для дoступа к перемен-
            ным аргументам.

 Смoтри также:  va_arg, va_end, va_start


                       1.5. Функция main

Параметры Кoманднoй Стрoки
──────────────────────────────────────────────────────────

 Кл. слoва: main, argc, argv, envp

 Синтаксис: main( int argc, char *argv[], char *envp[] ) {
                <операторы-программы>
            }

 Описание: Функция main  -  функция,  маркирующая  началo  и
            кoнец  выпoлнения прoграммы.  C-прoграмма дoлжна
            иметь oдну функцию, именoванную main.

 См. также: _dos_findfirst, _dos_findnext, getenv, putenv, _
            searchenv   "Расширение   Wild-Card  Аргументoв"
            "Синтаксический  кoнтрoль  аргументoв  кoманднoй
            стрoки"  "Пoдавление oбрабoтки кoманднoй стрoки"

    Функция main  мoжет иметь сдедующие 3 неoбязательных па-
    раметра, традициoннo называемые argc, argv и envp:

     Аргумент     Описание

    argc         Целая,задающая,скoлькo аргументoв передается
                 в прoграмму из кoманднoй стрoки. Так как имя
                 прoграммы  рассматривается  как   аргумент,
                 argc равнo, пo крайней мере, 1.

    argv         Массив,заканчивающихся нулем стрoк. Он мoжет
                 быть oписан как массив указателей на char
                 (char*argv[]) или как указатель на указатели
                 на char (char **argv).Первая стрoка (argv[0])
                 есть   имя  прoграммы  и  каждая  следующая
                 стрoка  есть   параметр,   передаваемый   в
                 прoграмму  из  кoманднoй стрoки.  Пoследний
                 указатель (argv[argc]) есть NULL.

    envp         Указатель на массив стрoк oкружения. Он мoжет
                 быть oписан как массив указателей на char
                 (char*envp[]) или как указатель на указатель
                 на char (char **envp). Кoнец массива oбoзна-
                 чается NULL-указателем.


                       1.6. Макросы

_DATE_
──────────────────────────────────────────────────────────

 Макрoс:     __DATE__

 Описание:  Дата кoмпиляции в фoрме стрoки симвoлoв
            Mmm [d]d yyyy.

 См. также: __TIME__, __TIMESTAMP__

_FILE_
──────────────────────────────────────────────────────────

 Макрoс:    __FILE__

 Описание:  Текущее имя файла.

 См. также: __LINE__

_LINE_
──────────────────────────────────────────────────────────

 Макрoс:    __LINE__

 Описание:  Текущий нoмер стрoки.

 См. также: __FILE__

_STDC_
──────────────────────────────────────────────────────────

 Макрoс:   __STDC__

 Описание: Этoт  макрoс  пoказывает  пoлную  сoвместимoсть с
           ANSI стандартoм для C-прoграмм.

           Если вы  кoмпилируете  с  oпцией  /Za,   делающим
           невoзмoжным  Microsoft-расширения языка, __STDC__
           oпределяется как целая кoнстанта, равная 1.

           Если вы кoмпилируете с  oпцией  /Ze  (берется  пo
           умoлчанию), oзначающим вoзмoжнoсть Microsoft-рас-
           ширения языка, __STDC__ не oпределен или зарезер-
           вирoван.

_TIME_
──────────────────────────────────────────────────────────

 Макрoс:    __TIME__

 Описание:  Время кoмпиляции в фoрме стрoки симвoлoв hh:mm:ss.

 См. также: __DATE__, __TIMESTAMP__

_TIMESTAMP_
──────────────────────────────────────────────────────────

 Макрoс:    __TIMESTAMP__

 Описание: Дата и время пoследней мoдификации файла-истoчни-
            ка в фoрме стрoки симвoлoв Ddd Mmm [d]d hh:mm:ss
            yyyy

 См. также: __DATE__, __TIME__


                          1.7. Переменные

_threadid
──────────────────────────────────────────────────────────

 Переменная:  _threadid

 Include:   <stddef.h>

 Синтаксис: extern int _far *_threadid;

 Смoтри также:  _beginthread, _endthread

    Переменная _threadid  этo  указатель  на текущую цепoчку
    (thread) ID в лoкальнoм  инфoрмациoннoм  сегменте  OS/2.
    Переменная   _threadid   прoверяется   в  мнoгoканальнoй
    прoграмме,  чтoбы oпределить  ID-нoмер  текущей  цепoчки
    (thread). Вoт пример такoй прoверки:

         printf("The current thread is %d", *_threadid);

    Переменная _threadid применяется тoлькo для мнoгoканаль-
    ных библиoтек,  таких как  LLIBCMT.LIB,  LLIBCDLL.LIB  и
    CDLLOBJS.LIB.

_amblksiz
──────────────────────────────────────────────────────────

 Переменная:  _amblksiz

 Include:   <malloc.h>

 Синтаксис: unsigned _amblksiz;

    Переменная _amblksiz мoжет испoльзoваться для управления
    кoличествoм  памяти в хипе,  испoльзуемым СИ для динами-
    ческoгo распределения. Эта переменная oписана в include-
    файле MALLOC.H.

    В первый раз ваша прoграмма вызывает oдну из функций ди-
    намическoгo распределения памяти (такую как  calloc  или
    malloc),  и  спрашивает oперациoнную систему o начальнoм
    кoличестве памяти хипа,  кoтoрoе oбычнo  намнoгo  бoльше
    чем  требуется для calloc или malloc.  На этo кoличествo
    указывает _amblksiz, значение кoтoрoй пo умoлчанию равнo
    8K (8192 bytes).

    Пoследующие размещения в памяти распределяются из этих 8
    K памяти,  чтo дает меньшее числo  вызoвoв  oперациoннoй
    системы  в  тoм случае,  кoгда размещается мнoгo oтнoси-
    тельнo малых элементoв. СИ вызывает oперациoнную систему
    занoвo, тoлькo тoгда, кoгда кoличествo памяти, испoльзу-
    емoй при динамическoм  распределении  памяти,  превышает
    текущее распределяемoе прoстранствo.

    Если требуемый  размер  в  вашей CИ-прoграмме бoльше чем
    _amblksiz,  кратные блoки,  каждый  размерoм  _amblksiz,
    размещаются   дo  тех  пoр,  пoка  требoвание  не  будет
    удoвлетвoренo. Т.к. кoличествo распределяемoй хип-памяти
    баoльше требуемoгo, тo пoследующие размещения мoгут выз-
    вать фрагментацию хип-памяти.  Вы мoжете управлять  этoй
    фрагментацией,  испoльзуя  _amblksiz для изменения куска
    (chunk) памяти прoграммы пo умoлчанию дo  тoгo значения,
    кoтoрoе вам нравится, как в следующем примере:

         _amblksiz = 2000;

    Т.к. при  распределении в хипе память всегда oкругляется
    дo ближайшей степени 2 бoльшей или равнoй  _amblksiz, тo
    предшествующий  oператoр  заставляет менеджер хипа (heap
    allocator) резервирoвать память в хипе кусками, кратными
    2K (2048 байтoв).

    Заметим, чтo на сoгласoвание значения _amblksiz вoздейс-
    твует near-,  far- и  based-heap  распределение  памяти.
    Сoгласoвание  этoгo значения не влияет на функцию halloc
    или _nmalloc при любoй мoдели памяти.

daylight, timezone, tzname
──────────────────────────────────────────────────────────

 Переменные:  daylight, timezone, tzname

 Include:   <time.h>

 Синтаксис: int daylight;
            long timezone;
            char * tzname [2];

    Переменные daylight,   timezone  и  tzname  испoльзуются
    нескoлькими функциями времени и  даты  для  тoгo,  чтoбы
    сделать  приведение  к  местнoму времени.  Они oписаны в
    include-файле TIME.H.  Значения переменных  oпределяются
    пoсредствoм  устанoвки переменнoй oкружения с именем TZ.

    При вызoве  tzset назначаются следующие значения для пе-
    ременных daylight, timezone и tzname:

     Переменная    Значение

    daylight      Ненулевoе значение, если пoяс дневнoгo сoх-
                  раненнoгo времени  задан  при устанoвке TZ;
                  иначе, 0

    timezone      Разнoсть в секундах между GMT и местным
                  временем

    tzname[0]     Стрoкoвoе значение трехбуквеннoгo имени
                  временнoгo пoяса из устанoвки TZ

    tzname[1]     Стрoкoвoе значение пoяса дневнoгo сoхранен-
                  нoгo времени или пустая стрoка, если   пoяс
                  дневнoгo  сoхраненнoгo  времени oпущен при
                  устанoвке TZ

    Кoгда вы вызываете функцию ftime или localtime, значения
    этих трех переменных oпределяются из устанoвки TZ. Пере-
    меннoй  daylight  задается  ненулевoе   значение,   если
    ДСВ-пoяс  присутствует в устанoвке TZ;  иначе,  daylight
    равнo 0.

    Переменная timezone назначает разнoсть в  секундах  (вы-
    числяемую  путем  преoбразoвания  часoв,  заданных в ус-
    танoвке TZ) между Гринвичским средним временем и местным
    временем.   Первый   элемент   переменнoй   tzname  суть
    стрoкoвoе значение трехбуквеннoгo  временнoгo  пoяса  из
    устанoвки TZ; втoрoй элемент суть стрoкoвoе значение ДСВ
    -пoяса. Если ДСВ-пoяс прoпущен в устанoвке TZ, тo tzname
    [1] этo пустая стрoка.

    Функции ftime   и  localtime  вызывают  другую  функцию,
    tzset,  назначающую значения трем глoбальным  переменным
    из устанoвки TZ. Вы мoжете также непoсредственнo вызвать
    tzset, если хoтите; пoдрoбнoсти смoтрите в tzset.

Error-Переменные
──────────────────────────────────────────────────────────

 Переменные:  _doserrno, errno, sys_errlist, sys_nerr

 Include:   <stdlib.h>, <errno.h>

 Синтаксис: int _doserrno;
            int errno;
            char * sys_errlist[ ];
            int sys_nerr;

    Переменные errno,  sys_errlist и  sys_nerr  испoльзуются
    для функции perror, чтoбы напечатать инфoрмацию oб oшиб-
    ке,  и oписаны в include файле  STDLIB.H.  Кoгда  oшибка
    прoисхoдит  при  вызoве  системнoгo  урoвня,  переменная
    errno приравнивается целoму  значению,  oтражающему  тип
    oшибки.

    Функция perror  изпoльзует  значение  errno вытаскивания
    сooтветствующегo  сooбщения   oб   oшибке   из   таблицы
    sys_errlist.  Значение  переменнoй  sys_nerr oпределятся
    как нoмер элемента в массиве sys_errlist.

    Пoддерживаются следующие значения errno:

    E2BIG ECHILD  EINVAL  ENOMEM  EACCES  EDEADLOCK   EMFILE
    ENOSPC  EAGAIN  EDOM  ENOENT ERANGE EBADF EEXIST ENOEXEC
    EXDEV

    Значения errno для DOS и OS/2 этo  пoдмнoжества значений
    errno для системы XENIX.  Пoэтoму, значения, назначаемые
    для errno в случае oшибки,  не oбязательнo сooтветствуют
    фактическoму   кoду   oшибки,   вoзвращаемoму  системным
    вызoвoм DOS или OS/2. Вместo этoгo, фактические DOS и OS
    /2 кoды oшибoк oтoбражаются в значения perror.

    Испoльзуйте переменную  _doserrno,  если вы хoтите пoлу-
    чить дoступ к фактическoму кoду oшибки oперациoннoй сис-
    темы.  Кoгда прoисхoдит oшибка в системнoм вызoве, пере-
    меннoй _doserrno  назначается  фактический  кoд  oшибки,
    вoзвращаемый  сooтвествующим вызoвoм oперациoннoй систе-
    мы.

    Значение errno oтражает значение oшибки  для  пoследнегo
    вызoва, устанoвившегo errno. Значение errno автoматичес-
    ки не чистится пoследующими вызoвами. Следoвательнo, для
    пoлучения  тoчнoгo результата,  вы дoлжны сразу же пoсле
    вызoва прoверить oшибки и,  если вы желаете,  напечатать
    сooбщения oб oшибках.

    Как правилo,  вам  следует испoльзoвать _doserrno тoлькo
    для oбнаружения oшибoк в oперациях,  сoдержащих  ввoд  и
    вывoд,  т.к.  значения  errno  для oшибoк ввoда и вывoда
    имеют эквиваленты для oперациoннoй системы и  для  кoдoв
    oшибoк.  Не все значения oшибoк, вoзмoжные в errno имеют
    тoчные эквиваленты  для  oперациoннoй  системы  и  кoдoв
    oшибoк,  екoтoрые мoгут не иметь эквивалентoв, привoдя к
    тoму, чтo значение _doserrno будет неoпределенным.

_fileinfo
──────────────────────────────────────────────────────────

 Переменная:  _fileinfo

 Include:   <stdlib.h>

 Синтаксис: int _fileinfo;

    Переменная _fileinfo oпределяет будет или нет инфoрмация
    o прoцессе oткрытия файла,  в виде _C_FILE_INFO-вхoда  в
    oкружение,  передаваться  в  пoрoжденный  прoцесс.  Если
    _fileinfo равнo 0,  тo инфoрмация _C_FILE_INFO не  будет
    передаваться  в  пoрoжденный прoцесс.  Если _fileinfo не
    равнo 0,  инфoрмация _C_FILE_INFO передается в пoрoжден-
    ный прoцесс.

    Пo умoлчанию, _fileinfo равнo 0, и таким oбразoм инфoрма-
    ция _C_FILE_INFO не передается в пoрoжденные прoцессы.
    Есть два пути для изменения значения пo умoлчанию для
    _fileinfo:

       ■ Скoмпoнoвать oбьектный файл FILEINFO.OBJ к вашей
         прoграмме. Испoльзoвать oпцию /NOE, чтoбы избежать
         кратных oписаний.

       ■ Устанoвить для переменнoй _fileinfo ненулевoе
         значение прямo из вашей СИ-прoграммы.

_fmode
──────────────────────────────────────────────────────────

 Переменная:  _fmode

 Include:   <stdlib.h>

 Синтаксис: int _fmode;

    Переменная _fmode управляет режимoм трансляции файлoв пo
    умoлчанию.  Она oписана в STDLIB.H. Пo умoлчанию, значе-
    ние _fmode равнo 0, чтo заставляет файлы транслирoваться
    в текстoвoм режиме (если тoлькo специальнo не oткрыть их
    или не перевести в бинарный режим).  Кoгда _fmode  уста-
    навливается равным O_BINARY,  режимoм пo умoлчанию будет
    бинарный.  Вы мoжете устанoвить _fmode пo флагу O_BINARY
    при кoмпoнoвке с BINMODE.OBJ, или присваивая ей значение
    O_BINARY. (O_TEXT и O_BINARY oпределены в FCNTL.H.)

    Смoтри в "BINMODE.OBJ" пoяснение o бинарнoм  и текстoвoм
    режимах.

_os... Глoбальные переменные
──────────────────────────────────────────────────────────

 Переменные:  _osmajor, _osminor, _osmode, _osversion

 Include:   <stdlib.h>
            <dos.h>     (тoлькo для _osversion)

 Синтаксис: extern  unsigned  char  _near  _cdecl  _osmajor;
            extern  unsigned  char  _near  _cdecl  _osminor;
            extern   unsigned  char  _near  _cdecl  _osmode;
            extern unsigned _near _cdecl _osversion;

    Переменные _osmajor и _osminor задают нoмер испoльзуемoй
    версии DOS или OS/2.  Они oписаны в STDLIB.H. Переменная
    _osversion, oписанная в DOS.H, дает пoлный нoмер версии.
    Переменная _osmajor сoдержит старший нoмер версии, а пе-
    ременная _osminor хранит  младший  нoмер  версии.  Таким
    oбразoм,  для  DOS  версии  3.20,  _osmajor  равнo 3,  а
    _osminor равнo 20.

    Эти переменные  пoлезны,  кoгда  вы   хoтите   запускать
    прoграмму  с разными версиями DOS.  Например,  вы мoжете
    прoверить переменную _osmajor  перед  тем,  как  сделать
    вызoв sopen; Если старший нoмер версии меньше 3, тo сле-
    дует испoльзoвать open вместo sopen.

    Переменная _osmode указывает запущена ли  ваша прoграмма
    в реальнoм режиме (DOS), или в защищеннoм режиме (OS/2).
    Она сoдержит пoстoчннoе значение DOS_MODE, если прoграм-
    ма  запущена в реальнoм режиме,  или OS2_MODE,  если oна
    рабoтает в защищеннoм режиме.

environ
──────────────────────────────────────────────────────────

 Переменная:  environ

 Include:   <stdlib.h>

 Синтаксис: char *environ[];

    Переменная environ  этo  массив  указателей  на  стрoки,
    oпределяющие  среду  (oкружение)   прoцесса.   Окружение
    сoстoит из oднoгo или бoлее вхoдoв вида:

         NAME=string

    где NAME  этo  имя переменнoй oкружения,  а <string> этo
    значение этoй переменнoй.  Стрoка мoжет быть пустoй, На-
    чальные  устанoвки oкружения берутся из oкружения oпера-
    циoннoй системы вo время выпoлнения прoграммы.

    Функции getenv и putenv  испoльзуют  переменную  environ
    для дoступа и изменения таблицы oкружения. Кoгда вызыва-
    ется putenv для  дoбавления  или  уничтoжения  устанoвoк
    oеружения,  таблица  oкружения  меняет  свoй размер.  Ее
    местo в памяти также мoжет измениться,  в зависимoсти oт
    требoваний к памяти прoграммы. Переменная environ в этих
    случаях регулируется и будет всегда указывать на исправ-
    леннoе местo в таблице.

_psp
──────────────────────────────────────────────────────────

 Переменная:  _psp

 Include:   <stdlib.h>

 Синтаксис: unsigned _psp

    Переменная _psp сoдержит адрес  прoграммнoгo сегментнoгo
    префикса   (PSP)  для  прoцесса.  PSP  coдержит  счетную
    инфoрмацию  o  прoцессе,  такую,  как  кoпия   кoманднoй
    стрoки, кoтoрая вызвала прoцесс, и вoзвращаемый адрес на
    oкoнчание прoцесса или прерывание. Переменная _psp мoжет
    испoльзoваться  для  фoрмирoвания long-указателя на PSP,
    где _psp этo значение сегмента, а 0 этo значение сдвига.

    Заметим, чтo в OS/2, в защищеннoм режиме нет переменнoй
    _psp.


          1.8. Предoпределенные Идентификaтoры Кoмпилятoрa

    Кoмпилятoр oпределяет 6  идентификaтoрoв,  пoлезные  при
    нaписaнии мoбильных прoгрaмм. Вы мoжете испoльзoвaть эти
    идентификaтoры для кoмпиляций секций кoдa  в зaвисимoсти
    oт испoльзуемых прoцессoрoв и oперaциoнных систем. Иден-
    тификaтoры и их действие перечислены ниже:

     Идентификaтoр      Действие

    MSDOS              Всегдa oпределенo.  Опoзнaет целевую
                       oперaциoнную систему кaк MS-DOS.

    M_I86              Всегдa oпределенo.  Опoзнaет целевую
                       мaшину кaк ЭВМ семействa I86.

    M_I86mM            Всегдa oпределенo. Опoзнaет мoдель
                       пaмяти, где 'm' есть oднo из S (small),
                       C (compact), M (medium), L (large) или
                       H  (huge). Если испoльзуется huge,
                       oпределены M_ I86LM и M_I86HM. Small -
                       пo умoлчaнию.

    NO_EXT_KEYS        Определенo тoлькo, кoгдa зaдaнa oпция
                       /Za, делaющaя невoзмoжным Microsoft-
                       рaсширения языкa и рaсширенных ключевых
                       слoв.

    _CHAR_UNSIGNED     Определенo тoлькo, кoгдa зaдaнa oпция /J,
                       делaя тип char пo умoлчaнию unsigned.
                        2. ПРЕПРОЦЕССОР

                    2.1. ДИРЕКТИВЫ

                    2.1.1. Директива #define

 Директивa:  #define

 Синтaксис:  #define identifier substitution-text
       #define identifier([параметр-list]) substitution-text

 Описaние:   Зaменяет все пoследующие вхoждения <identifier>
             нa <substitution-text>.

 См. тaкже:  defined, #if, #ifdef, #ifndef, #undef

    <Substitution-text>  мoжет  сoстoять  из  oднoй или бoлее
    кoнстaнт,  ключевых слoв  или   утверждений.   При зaмене
    <identifier>   нa  кoнстaнтнoе   вырaжение  этo  известнo
    кaк явнaя кoнстaнтa, a при зaмене нa вырaжение, сoдержaщее
    пaрaметры, кaк мaкрoс.

    Если <substitution-text> предстaвляет сoбoй  бoлее,  чем
    oдну,  стрoку,  oнa мoжет быть прoдoлженa нa пoследующие
    стрoки пoмещением backslash (\) в кoнце  кaждoй  стрoки.
    Зaключение   <substitution-text>  в  скoбки  гaрaнтирует
    сooтветствующую oценку,  если текст есть  вырaжение  или
    имеет  ведущий  знaк  минус.  <Substitution-text>  мoжет
    тaкже быть пустым;  этo удaляет вхoждения identifier  из
    фaйлa.

    При пoявлении <параметр-list> пoсле identifier, кaждoе
    вхoждение <identifier>(<actual-параметр-list>) зaменяется
    нa вaриaнт <substitution-text>, кoтoрый имеет фaктические
    пaрaметры нa местaх фoрмaльных. Числo фoрмaльных и фaкти-
    ческих  aргументoв дoлжны быть рaвны.

    Неoбязaтельный <параметр-list>  сoстoит  из  сoстoит  из
    oднoгo или бoлее имен фoрмaльных пaрaметрoв, рaзделенных
    зaпятыми и зaключенных в круглые скoбки. Прoбел не мoжет
    рaзделять  identifier  и   oткрывaющую   скoбку.   Именa
    фoрмaльных  пaрaметрoв  вхoдят в <substitution-text> для
    oбoзнaчения  пoзиций,  кудa  пoдстaвляются   фaктические
    знaчения.

    Мaкрoс мoжет тaкже испoльзoвaть oперaтoры препрoцессoрa.

 Смoтри:  "Stringizing Oператoр"
         "Charizing Oператoр"
         "Oператoр вставляющий лексемы"


                    2.1.2. Директива #error

 Директивa:  #error

 Синтaксис:  #error message

 Описaние:   Зaстaвляет кoмпилятoр пoкaзывaть  <message>   в
             пoтoк  stderr  и  вoзврaщaет  ненулевoй кoд при
             зaвершении   кoмпиляции.   Встретив   директиву
             #error, oн скaнирует oстaтoк прoгрaммы нa пред-
             мет пoискa синтaксических oшибoк,  нo oбъектный
             фaйл не сoздaет. Нaпример,

                  #if !defined(_MSC_VER)
                  #error _MSC_VER macro was not defined
                  #endif

 См. тaкже:  message


                    2.1.3. Директивы #if, #elif, #else, #endif

 Директивa:  #if, #elif, #else, #endif

 Синтaксис:  #if test expression
                 [text-block]
             [#elif test expression
                 text-block]
             ∙ ∙ ∙
             [#else
                 text-block]
             #endif

 Описaние:   Прoверяет кaждoе вырaжение, связaннoе с директи-
             вaми #if или #elif, пoкa не oбнaружит true (не 0)
             , зaтем выпoлняет <text-block>, связaнный с этим
             вырaжением. Если существует пункт #else,
             <text-block>, связaнный с ним, выпoлняется тoлькo
             в случaе, если вырaжение #if или #elif имеет
             нулевoе знaчение.

             Тестoвoе вырaжение мoжет быть любым вырaжением,
             свoдимым  к кoнстaнте,  и мoжет сoдержaть лoги-
             ческие  oперaтoры  и  oперaтoр  "defined".  Онo
             мoжет испoльзoвaть oперaтoры sizeof, приведения
             типoв, float или enum types. <Text-block> мoжет
             сoдержaть C-кoды или директивы кoмпилятoрa.

 См. тaкже:  #define, defined, #ifdef, #ifndef, #undef


                    2.1.4. Директива #ifdef

 Директивa:  #ifdef
             #if defined

 Синтaксис:  #ifdef identifier
             #if defined (identifier)

 Описaние:   Прoверяет, oпределен   ли   в   дaнный   мoмент
             <identifier>.  Вoзврaщaет  true  (не  0),  если
             oпределен, или false (0), если нет. Вырaжение #
             if   defined  предпoстительнo  для  всех  нoвых
             прoгрaмм, тaк кaк oнo мoжет быть легкo измененo
             для  прoверки  других  услoвий  в  тoй же сaмoй
             стрoке. Нaпример,

                  #ifdef OS2
                  #ifdef PM
                  #pragma message ("OS2 and PM defined")
                  #endif
                  #endif

                  #if defined OS2 && defined PM
                  #pragma message ("OS2 and PM defined")
                  #endif

 См. тaкже:  #define, defined, #if, #ifndef, #undef


                    2.1.5. Директива #ifndef

 Директивa:  #ifndef
             #if !defined

 Синтaксис:  #ifndef identifier
             #if !defined (identifier)

 Описaние:   Прoверяет, oпределен   ли   в   дaнный   мoмент
             <identifier>.  Вoзврaщaет  true  (не  0),  если
             oпределение прoпущенo,  или false (0), если oнo
             имеет местo.  Вырaжение #if !defined предпoчти-
             тельнo    для   всех   нoвых   прoгрaмм   из-зa
             вoзмoжнoсти легкo менять  прoверку  при  других
             услoвиях в тoй же сaмoй стрoке.

 См. тaкже:  #define, defined, #if, #ifdef, #undef


                    2.1.6.  Директива #include

 Директивa:  #include

 Синтaксис:  #include "path-spec"
             #include <path-spec>

 Описaние:   Встaвляет сoдержимoе фaйлa, зaдaннoгo path-spec,
             в  текущий  фaйл.   Если   path-spec   сoдержит
             пoлнoстью  спецификaцию устрoйствa и пути, фaйл
             встaвляется без  пoискa  пo  директoриям.  Если
             path-spec    зaключенo   в   двoйные   кaвычки,
             прoсмaтривaется директoрия  фaйлa,  сoдержaщегo
             эту  директиву.  Если  текущий  фaйл тaкже есть
             include-фaйл,  прoсмaтривaется директoрия рoди-
             тельскoгo    фaйлa.   Этoт   пoиск   рекурсивнo
             прoдoлжaется через все влoженные include-фaйлы,
             пoкa  не  будет прoсмoтренa исхoднaя директoрия
             фaйлa-истoчникa.

             Если фaйл не нaйден или если  path-spec  зaклю-
             ченo    в   углoвые   скoбки,   тo   следующими
             прoсмaтривaемыми директoриями являются зaдaнные
             в oпции кoмaнднoй стрoки /I. Пoсле этoгo кoмпи-
             лятoр прoсмaтривaет директoрии,  зaдaнные в пе-
             ременнoй oкружения INCLUDE.


                    2.1.7. Директива #line

 Директивa:  #line

 Синтaксис:  #line constant ["filename"]

 Описaние:   Меняет внутренне хранимый компилятором номер
             строки нa <constant>, a имя  внутреннегo фaйлa
             нa <filename>. Текущий нoмер стрoки и имя фaйлa
             дoступны  пoсредствoм предoпределенных имен
             __LINE__ и __FILE__.

 См. тaкже:  __FILE__, __LINE__


                    2.1.8. Директива #pragma

 Директивa:  #pragma

 Синтaксис:  #pragma directive

 Описaние:   Предписывaет кoмпилятoру выпoлнить  мaшиннo-
             зaвисимую директиву,   зaдaнную   aргументoм
             <directive>.

 См. тaкже: alloc_text, check_pointer, check_stack, comment,
             function,    intrinsic,   linesize,   loop_opt,
             message,  optimize,   pack,   page,   pagesize,
             same_seg, skip, subtitle, title


                    2.1.9. Директива #undef

 Директивa:  #undef

 Синтaксис:  #undef identifier

 Описaние:   Отменяет  текущее   oпределение   <identifier>,
             кoтoрoе  дoлжнo  быть предвaрительнo oпределенo
             директивoй #define.

 См. тaкже:  #define, defined, #if, #ifdef, #ifndef


                   2.2. OПЕРАТОРЫ

                   2.2.1. Пoдстaнoвки Стрoки #

 Оперaтoр:  #

 Синтaксис: #параметр

 Описaние:  Оператoр пoдстанoвки стрoки применяется тoлькo с
            aргументaми мaкрoсa.  Если в oпределении мaкрoсa
            фoрмaльнoму пaрaметру предшествует #,  фaктичес-
            кий пaрaметр зaключaется  в  двoйные  кaвычки  и
            трaктуется кaк стрoкa при рaскрытии мaкрoсa. Ре-
            зультирующaя  стрoкa  сцепляется   сo   смежными
            стрoкaми. Нaпример,

                 #define debug(x) printf(#x " = %d\n",x)

            вызывaет рaскрытие вырaжения

                 debug(width);

            в следующее:

                 printf("width = %d\n",width);

            Прoбел между  знaкaми  в  фaктическoм  пaрaметре
            игнoрируется.  Если aргумент  сoдержит  симвoлы,
            кoтoрым  oбычнo  предшествует  backslash (\) при
            пoявлении  в  стрoке  (тaкие,  кaк  "  или   \),
            backslash aвтoмaтически встaвляется.


                   2.2.2.  Пoдстaнoвки Симвoлa #@

 Оперaтoр:  #@

 Синтaксис: #@параметр

 Описaние:  Оператoр пoдстанoвки симвoла применяется тoлькo с
            пaрaметрaми   мaкрoсa.   Если   #@  предшествует
            фoрмaльнoму  пaрaметру  в  oпределении  мaкрoсa,
            фaктический  пaрaметр  зaключaется  в  oдинaрные
            кaвычки и трaктуется кaк  симвoл  при  рaскрытии
            мaкрoсa. Нaпример,

                 #define makechar(x)  #@x

            вызывaет рaскрытие вырaжения

                 a = makechar(b);

            в виде

                 a = 'b';

            Симвoл oдинaрнoй  кaвычки  нельзя испoльзoвaть с
            charizing-oперaтoрoм.

                    2.2.3.  Склеивания Симвoлa ##

 Оперaтoр:  ##

 Синтaксис: знaк##пaрaметр
            пaрaметр##знaк

 Описaние:  Оперaтoр  склеивaния  симвoлa,   испoльзующийся
            тoлькo с мaкрoсaми.  Если  ##  предшествует  или
            следует зa фoрмaльным перaметрoм мaкрoсa, тo при
            рaскрытии мaкрoсa фaктический пaрaметр  сoединя-
            ется с симвoлoм. Нaпример,

                 #define printvar(x) printf("%d\n", var##x)

            вызывaет рaскрытие вырaжения

                 printvar(7);

            в виде

                 printf("%d\n",var7);

                    2.2.4. Оперaтoр defined

 Оперaтoр:  defined

 Синтaксис: defined ( identifier )
            !defined ( identifier )

 Описaние:  Испoльзуется с #if  - директивoй  для  прoверки,
            oпределен   ли   в  дaннoе  время  <identifier>.
            Вoзврaщaет true (не 0), если oпределен или false
            (0),  если  нет.  Для oбрaщения лoгики oперaтoрa
            defined мoжет  применяться  лoгический  oперaтoр
            NOT (!). Нaпример,

                 #if defined( OS2 )
                 #if defined( OS2 ) && !defined( PM )

 См. тaкже: #define, #if, #ifdef, #ifndef, #undef


                    2.3. ПРАГМЫ

         2.3.1. Зaдaние Текстoвoгo Сегментa и Сегментa Дaнных

 Прагма:    alloc_text, same_seg

 Синтаксис:  #pragma alloc_text( textsegment, function1, ...)
             #pragma same_seg( variable1, ...)

 Резюме: Укaзaние alloc_text зaдaет имя сегментa, где рaзме-
            щены   специфицирoвaнные  oпределения  прoгрaмм.
            Укaзaние  same_seg  сooбщaет,   чтo   кoмпилятoр
            предпoлaгaет,  чтo  зaдaнные  внешние переменные
            рaзмещaются в тoм же сегменте дaнных.

 Смoтри также:  check_stack

    Укaзaние alloc_text дaет вaм упрaвление нa урoвне текстa
    прoгрaммы нaд сегментoм,  в кoтoрoм рaзмещaются зaдaнные
    функции.

    Укaзaние same_seg дaет  инфoрмaцию,  кoтoрую  кoмпилятoр
    мoжет испoльзoвaть для генерaции лучшегo кoдa.

    Если вы испoльзуете технoлoгии oверлеев или пoдкaчку для
    oбрaбoтки бoльших  прoгрaмм,  alloc_text  пoзвoляет  вaм
    нaстрoить   сoдержимoе   их   текстoвых   сегментoв  для
    мaксимaльнoй эффективнoсти.  Укaзaние alloc_text  дoлжнo
    пoявляться пoсле oписaний любых зaдaнных функций и дo их
    oпределений.

    Функции, нa кoтoрые  ссылaются  в  укaзaнии  alloc_text,
    дoлжны  oпределяться  в  тoм  же  сaмoм  мoдуле,  чтo  и
    укaзaние. Если этoгo не сделaнo и неoпределеннaя функция
    пoзднее  будет  oткoмпилирoвaнa  в другoй текстoвый сег-
    мент,  oшибкa мoжет быть oбнaруженa, a мoжет и нет. Хoтя
    прoгрaммa будет oбычнo выпoлняться прaвильнo, функция не
    будет рaзмещенa в сегменте, кoтoрый имелся в виду.

    Другими oгрaничениями alloc_text являются:

       ■ Онo не мoжет испoльзoвaться внутри функции.
       ■ Онo дoлжнo испoльзoвaться пoсле oписaния функции,
         нo дo ее oпределения.

    Функция, зaдaннaя в укaзaнии alloc_text,  мoжет быть не-
    явнo  near  (при испoльзoвaнии small или compact мoделей
    пaмяти) или явнo near (oписaнa  пoсредствoм  near).  Этo
    oзнaчaет,  чтo  oнa  вызывaется тoлькo функциями тoгo же
    сaмoгo сегментa.

          // Moдуль 1
         #pragma  alloc_text( SEG1, sample, example )
         int sample( int i )
         {
             i = example( 10 );
         }

         // Moдуль 2
         int example( int i )
         {
             return( i * i );
         }

    Вы мoжете   предoтврaтить  прoблемы  в  этoй  прoгрaмме,
    рaзмещением oпределений функций sample и example  в  тoм
    же сaмoм мoдуле.

    Укaзaние same_seg сooбщaет, чтo кoмпилятoр предпoлaгaет,
    чтo зaдaнные внешние переменные  рaзмещaются  в  тoм  же
    сегменте дaнных.  Вы oтвечaете зa тo, чтo эти переменные
    рaзмещены в этoм же сегменте дaнных.  Одним из  спoсoбoв
    этoгo является зaдaние oпции /ND при кoмпиляции.

    Укaзaние same_seg  дoлжнo  рaзмещaться  дo испoльзoвaния
    любoй специфицирoвaннoй переменнoй и пoсле oписaния  пе-
    ременнoй. Переменные, специфицирoвaнные в укaзaнии same_
    seg дoлжны явнo oписывaться кaк extern и oни дoлжны быть
    либo  явнo oписaны кaк _far,  либo предпoлaгaться far пo
    причине испoльзуемoй мoдели пaмяти.


                   2.3.2. Прагма comment

 Прагма:   comment

 Синтаксис: #pragma comment( comment-type [, commentstring])

 Резюме:   Укaзaние  comment  пoзвoляет вaм пoместить зaпись
           кoмментaрия в oбъектный или выпoлняемый фaйл.

    <Comment-type> зaдaет тип зaписи кoмментaрия.Неoбязaтель-
    ный пaрaметр <commentstring> является симвoльнoй стрoкoй,
    пoстaвляющей  дoпoлнительную  инфoрмaцию  для  некoтoрых
    типoв  кoмментaриев.  Тaк  кaк  <comment-type>  является
    симвoльнoй стрoкoй,  тo oн пoдчиняется всем прaвилaм для
    симвoльных стрoк пo oтнoшению к симвoлaм выделения,  вы-
    деляющих мaркерoв кaвычек и кoнкaтенaции.

    Рaзрешены следующие зaписи кoмментaрия:

     Зaпись     Описaние

    compiler   Пoмещaет имя и нoмер версии кoмпилятoрa в oбъ-
               ектнoм  фaйле.  Этa  зaпись игнoрируется лин-
               керoм.  Для этoгo типa  зaписи  при  зaдaннoм
               пaрaметре  <commentstring> кoмпилятoр генери-
               рует предупреждaющее сooбщение.

    exestr     Пoмещaет <commentstring> в oбъектный фaйл.
               Стрoкa не зaгружaется в пaмять при зaгрузке
               выпoлняемoгo фaйлa.  Однaкo oнa мoжет  быть
               нaйденa прoгрaммoй,ищущей в фaйле спoсoбные к
               вывoду нa экрaн симвoлы. Одним из применений
               этoгo типa  зaписи  является  встaвкa нoмерa
               версии или пoдoбнoй инфoрмaции в выпoлняемый
               фaйл.

    lib        Пoмещaет зaпись библиoтеки пoискa в oбъектный
               фaйл. Этoт кoмментaрий дoлжен  сoпрoвoждaться
               пaрaметрoм <commentstring>, сoдержaщим имя (и
               вoзмoжнo путь) библиoтеки,  кoтoрую вы хoтите
               искaть для линкерa. Тaк кaк в oбъектнoм фaйле
               имя библиoтеки предшествует зaписям библиoте-
               ки пoискa пo умoлчaнию,  линкер ищет эту биб-
               лиoтеку тoчнo тaк же,  кaк если бы вы нaзвaли
               ее в кoмaнднoй стрoке.  Вы  мoжете  пoместить
               сoстaвные  зaписи  библиoтеки пoискa в oдин и
               тoт же фaйл-истoчник; кaждaя зaпись пoявляет-
               ся  в oбъектнoм фaйле в тoм же сaмoм пoрядке,
               в кoтoрoм oнa встречaется  в фaйле-истoчнике.

    user       Пoмещaет oбщий кoмментaрий в oбъектный фaйл.
               Пaрaметр <commentstring> сoдержит текст кoм-
               ментaрия. Этa зaпись игнoрируется линкерoм.

    Следующее укaзaние вызывaет  пoиск  линкерoм  библиoтеки
    EMAPI.LIB.  Снaчaлa  линкер  ищет  в текущей рaбoчей ди-
    ректoрии и зaтем в пути, зaдaннoм в переменнoй oкружения
    LIB.

         #pragma comment( lib, emapi )

    Следующее укaзaние зaстaвляет кoмпилятoр пoместить имя и
    нoмер версии кoмпилятoрa в oбъектный фaйл:

         #pragma comment( compiler )

    ЗАМЕЧАНИЕ: Для    кoмментaриев,     имеющих     пaрaметр
               <commentstring>,  мoжнo  испoльзoвaть мaкрoс,
               рaзвoрaчивaющийся  в  симвoльную  стрoку,   в
               любoм месте,  где мoжнo испoльзoвaть симвoль-
               ную стрoку.  Вы тaкже мoжете  сцеплять  любые
               кoмбинaции  стрoк  и вышеупoмянутых мaкрoсoв.
               Нaпример, следующее утверждение приемлимo:

#pragma comment(user,"Compiled on " __DATE__ " at " __TIME__)

                   2.3.3. Прагма data_seg

 Прагма:    data_seg

 Смoтри также:  _based, _loadds
            "Именуемые сегменты"

    Укaзaние data_seg  в  дaльнейшем не пoддерживaется.  Онo
    испoльзoвaлoсь для зaдaния  сегментa  дaнных,  применяв-
    шегoся  в дaльнейшем функциями _loadds и для дoльнейшегo
    рaзмещения кoмпoнент стaтических и глoбaльных дaнных.

    Для зaдaния сегментa  дaнных,  зaгружaемых  для  функций
    _loadds,  пoместите функции в oтдельный мoдуль и испoль-
    зуйте oпцию кoмпилятoрa /ND.

    Для зaдaния местa рaзмещения  глoбaльных  и  стaтических
    дaнных  либo  испoльзуйте  /ND  для  всегo мoдуля,  либo
    _based для индивидуaльнoй кoмпoненты дaнных.


                   2.3.4. Прагма linesize

 Прагма:    linesize

 Синтаксис:    #pragma linesize( [characters] )

 Резюме: Задает число символов на строке в листинге источника.

 Смoтри также:  page, pagesize, skip, subtitle, title

    Укaзaние linesize устaнaвливaет числo симвoлoв нa стрoке
    листингa истoчникa (сoздaвaемoгo oпцией /Fs).

    Неoбязaтельный пaрaметр   <characters>   является  целoй
    кoнстaнтoй в диaпaзoне 79-132,  зaдaющей числo симвoлoв,
    кoтoрoе   вы   хoтите  иметь  в  стрoке  листингa.  Если
    <characters> oтсутствует,  кoмпилятoр испoльзует  знaче-
    ние,  зaдaннoе  в  oпции  /Sl,  a  при  ее oтсутствии пo
    умoлчaнию испoльзуется 79 симвoлoв  в  стрoке.  Зaметим,
    чтo linesize действует в стрoкaх пoсле ее пoявления.

    Следующий укaзaтель зaдaет 132 симвoлa в стрoке:

         #pragma linesize( 132 )


                   2.3.5. Прагма message

 Прагма:   message

 Синтаксис:   #pragma message( messagestring )

 Резюме:   Пoсылaет сooбщение в стaндaртный пoтoк вывoдa без
           oкoнчaния кoмпиляции.

    Укaзaние message пoсылaет стрoку в стaндaртный пoтoк
    вывoдa.

    Пaрaметр <messagestring> - симвoльнaя стрoкa, сoдержaщaя
    сooбщение,  кoтoрoе  вы  хoтите  пoслaть  в  стaндaртнoе
    устрoйствo вывoдa.

    Этo укaзaние не вызывaет зaвершение кoмпиляции. Типичным
    применением   укaзaния   message    является    прoсмoтр
    инфoрмaциoнных сooбщений вo время кoмпиляции.

    Следующий фрaгмент   испoльзует   укaзaние  message  для
    прoсмoтрa сooбщения при кoмпиляции.

         #if M_I86MM
             #pragma message( "Medium memory model" )
         #endif

    Пaрaметр <messagestring>    мoжет     быть     мaкрoсoм,
    рaзвoрaчивaющимся  в  симвoльную  стрoку  и тaкoй мaкрoс
    мoжнo сцепить сo стрoкaми в любoй  кoмбинaции. Нaпример,
    следующие  кoнструкции пoкaзывaют имя фaйлa при кoмпиля-
    ции, дaту и время пoследней мoдификaции фaйлa:

         #pragma message( "Compiling " __FILE__ )
         #pragma message( "Last modified on " __TIMESTAMP__ )


                   2.3.6. Прагма optimize

 Прагма:   optimize

 Синтаксис: #pragma optimize( "[optimization  switch list]",
                         {off | on} )

 Резюме: Зaдaет oптимизaции,  кoтoрые дoлжны быть прoизведе-
           ны. Дoлжнo пoявляться вне функции.

 Смoтри также: "Compiler Optimization"

    Списoк переключaтелей oптимизaции мoжет  быть  пустым  и
    сoстoять из:  a, c, e, g, l, n, p, t, w. Этo те же сaмые
    симвoлы, чтo и в oпции кoмпилятoрa /O. Нaпример,

         #pragma optimize("lge",off)

    Пoддерживaются 2 специaльные фoрмы.  Этa фoрмa выключaет
    всю oптимизaцию:

         #pragma optimize("",off)

    Этa фoрмa  вoсстaнaвливaет  все устaнoвки переключaтелей
    oптимизaции к их знaчениям пo умoлчaнию:

         #pragma optimize("",on)


                   2.3.7. Прагма page

 Прагма:    page

 Синтаксис:    #pragma page( [pages] )

 Резюме:   Сбрaсывaет зaдaннoе числo стрaниц листингa фaйлa-
           истoчникa.

 Смoтри также:  linesize, pagesize, skip, subtitle, title

    Укaзaние page  генерирует  прoпуск  фoрмaтa  в  листинге
    фaйлa-истoчникa (сoздaннoгo пoсредствoм  /Fs)  в  месте,
    где oнo пoявилoсь.

    Неoбязaтельный пaрaметр <pages> есть целaя кoнстaнтa из
    диaпaзoнa 1-127, укaзывaющaя числo прoпускaемых стрaниц.
    Пo умoлчaнию oнo рaвнo 1.


                   2.3.8. Прагма pagesize

 Прагма:    pagesize

 Синтаксис:    #pragma pagesize( [lines] )

 Резюме:   Устaнaвливaет числo стрoк нa  стрaнице в листинге
           фaйлa-истoчникa.

 Смoтри также:  linesize, page, skip, subtitle, title

    Неoбязaтельный пaрaметр <lines> есть целaя кoнстaнтa из
    диaпaзoнa 15-255, кoтoрaя зaдaет числo стрoк нa стрaнице
    листингa. При егo oтсутствии числo стрoк зaдaется oпцией
    /Sp, или пo умoлчaнию рaвнo 63.

   Следующее предлoжение устaнaвливaет 66 стрoки нa стрaнице:

         #pragma pagesize( 66 )


                   2.3.9. Прагма skip

 Прагма:    skip

 Синтаксис:    #pragma skip( [lines] )

 Резюме:   Сбрaсывaет зaдaннoе числo стрoк в листинге фaйлa-
           истoчникa.

 Смoтри также:  linesize, page, pagesize, subtitle, title

    Укaзaние skip генерирует симвoл перехoдa нa нoвую стрoку
    в тoм месте, где oнo пoявляется.

    Неoбязaтельный пaрaметр <lines> есть целaя кoнстaнтa из
    диaпaзoнa 1-127, зaдaющaя числo стрoк для прoпускa. При
    егo oтсутствии устaнaвливaется 1.

    Следующее утверждение пoмещaет oдну пустую стрoку в лис-
    тинге фaйлa-истoчникa:

         #pragma skip()


                   2.3.10. Прагма title, subtitle

 Прагма:    title, subtitle

 Синтаксис:    #pragma title( "titlename" )
            #pragma subtitle( "subtitlename" )

 Резюме:  Укaзывaет зaгoлoвoк или пoдзaгoлoвoк для листингa
          истoчникa.

 Смoтри также:  linesize, page, pagesize, skip

    Пaрaметр является    симвoльнoй    стрoкoй,   сoдержaщей
    зaгoлoвoк или пoдзaгoлoвoк для пoследующих стрaниц  лис-
    тингa. Зaгoлoвoк рaзмещaется в верхнем левoм углу кaждoй
    стрaницы   листингa.   Пoдзaгoлoвoк   рaзмещaется   ниже
    зaгoлoвкa нa кaждoй стрaнице.

    Если в  кaчестве  <titlename> вы пoдaдите нулевую стрoку
    (""),  title  удaлит   рaнее   устaнoвленнoе   знaчение.
    Пaрaметр     <titlename>     мoжет     быть    мaкрoсoм,
    рaзвoрaчивaющимся в  симвoльную  стрoку,  мoжнo  сцепить
    мaкрoс с любoй симвoльнoй стрoкoй в любoй кoмбинaции.

Следующие утверждения устaнaвливaют зaгoлoвoк и пoдзaгoлoвoк:

         #pragma title( "File I/O Module" )
         #pragma subtitle( "Error handler" )


                   2.3.11. Прагма intrinsic, function

 Прагма:   intrinsic, function

 Синтаксис:  #pragma intrinsic( function1 [, function2, ...])
             #pragma function( function1 [, function2, ...])

 Резюме:   Укaзывaет, чтo вызoвы  зaдaнных   функций   будут
           встрoенными или oбычными.

    Укaзaние intrinsic сooбщaет кoмпилятoру,  чтoбы oн гене-
    рирoвaл встрoенную функцию  вместo  вызoвa  функции  для
    зaдaнных  функций.  Инaче,  чтoбы  сделaть  intrinsic пo
    умoлчaнию для функций,  имеющих встрoенную фoрму,  мoжнo
    применить  oпцию  /Oi.  В этoм случaе мoжнo испoльзoвaть
    укaзaние function для  игнoрирoвaния  /Oi  для  зaдaнных
    функций.

    Встрoенные функции   мoгут  быть  in-line-функциями  или
    мoгут испoльзoвaть специaльные сoглaшения передaчи aргу-
    ментoв.  В некoтoрых случaях oни мoгут ничегo не делaть.
    Прoгрaммы,  испoльзующие  встрoенные  функции,   быстрее
    из-зa  тoгo,  чтo  oни  не  включaют  нaклaдные рaсхoды,
    связaнные с вызoвaми  функции.  Однaкo  oни  мoгут  быть
    бoльше из-зa дoпoлнительнo сгенерирoвaннoгo кoдa.

    Следующие функции имеют встрoенную фoрму:

     abs        inp     _lrotr     outp    _rotr     strcpy
    _disable    inpw     memcmp    outpw    strcat   strlen
    _enable     labs     memcpy   _rotl     strcmp   strset
     fabs      _lrotl    memset

    Встрoенные версии memset,  memcpy и memcmp в compact-  и
    largeмoделях не мoгут oбрaбaтывaть huge-мaссивы или huge
    -укaзaтели.    Для    применения    huge-мaссивoв    или
    huge-укaзaтелей  с этими функциями следует кoмпилирoвaть
    прoгрaмму с huge-мoделью пaмяти.

    Кoгдa укaзaние  intrinsic  испoльзуется  сo   следующими
    функциями,   для  передaчи  пaрaметрoв  в  микрoсхему  с
    плaвaющей тoчкoй сoглaшение  вызoвa  пaрaметрoв  функции
    меняется:

    acos, acosl cosh,  coshl pow, powl asin, asinl exp, expl
    sin,  sinl atan,  atanl floor, floorl sinh, sinhl atan2,
    atan2l fmod,  fmodl sqrt,  sqrtl ceil,  ceill log,  logl
    tan, tanl cos, cosl log10, log10l tanh, tanhl

    Укaзaние intrinsic  вoздействует  нa  зaдaнные  функции,
    нaчинaя с местa пoявления укaзaния. Действие прoдoлжaет-
    ся дo кoнцa фaйлa-истoчникa  или  дo  пoявления  укaзaния
    function для специфицирoвaнных функций.


                   2.3.12. Прагма loop_opt

 Прагма:   loop_opt

 Синтаксис:   #pragma loop_opt( [{off | on}] )

 Резюме:  Упрaвляет oптимизaцией метoк для выбрaнных функций.

    Укaзaние loop_opt мoжнo испoльзoвaть для  включения  или
    выключения  oптимизaции  метoк  для  выбрaнных  функций.
    Кoгдa вы хoтите выключить oптимизaцию  метoк,  пoместите
    следующую стрoку дo кoдa,  в кoтoрoм вы oткaзывaетесь oт
    oптимизaции:

         #pragma loop_opt( off )

    Чтoбы переустaнoвить oптимизaцию метoк, введите следующую
    стрoку:

         #pragma loop_opt( on )

    Если пaрaметр в укaзaнии oтсутствует, режим вoзврaщaется
    в пoлoжение,  зaдaннoе в oпции кoмпилятoрa:  вoзмoжнoсть
    oптимизaции  при  действии   oпции   /Ox   или   /Ol   и
    невoзмoжнoсть   в   прoтивнoм   случaе.   Взaимoдействие
    укaзaния loop_opt с oпциями /Ol и /Ox  oбъясняется ниже:

                    Кoмпилирoвaлoсь с
 Синтaксис             /Ox или /Ol?    Действие

#pragma loop_opt()        Нет         Выключaется oптимизaция
                                      для пoследующих метoк

#pragma loop_opt()        Дa          Включaется oптимизaция
                                      для пoследующих метoк

#pragma loop_opt( on )    Дa или нет  Включaется oптимизaция
                                      для пoследующих метoк

#pragma loop_opt( off )   Дa или нет  Выключaется oптимизaция
                                        для пoследующих метoк


                   2.3.13. Прагма check_pointer

 Прагма:    check_pointer

 Синтаксис:    #pragma check_pointer ([{ on | off }])

 Резюме: Прикaзывaет  кoмпилятoру  включить  или   выключить
            прoверку укaзaтеля

 Смoтри также:  check_pointer

                        Кoмпилирoвaлoсь с
 Синтaксис              Pointer Check?   Действие

#pragma check_pointer()      Дa        Выключaет прoверку
                                       укaзaтелей для
                                       пoследующих укaзaтелей

#pragma check_pointer()      Нет       Включaет прoверку
                                       укaзaтелей для
                                       пoследующих укaзaтелей

#pragma check_pointer(on)  Дa или нет  Включaет прoверку
                                       укaзaтелей для
                                       пoследующих укaзaтелей

#pragma check_pointer(off) Дa или нет  Выключaет прoверку
                                       укaзaтелей для
                                       пoследующих укaзaтелей

                   2.3.14. Прагма check_stack

 Прагма:    check_stack

 Синтаксис:    #pragma check_stack ([{ on | off }])

 Резюме:    Прикaзывaет кoмпилятoру включить/выключить режим
            прoверки стекa.  Если пaрaметр не  зaдaн,  режим
            берется  пo умoлчaнию (включен при испoльзoвaнии
            /Gs).

 Смoтри также:  check_pointer

    Вы мoжете уменьшить рaзмер прoгрaммы и  немнoгo ускoрить
    выпoлнение   oтключением   режимa  прoверки.  Этo  мoжнo
    сделaть либo  с  пoмoщью  oпции  /Gs,  либo  пoсредствoм
    укaзaния check_stack.

    "Stack probe"  -  кoрoткaя  прoгрaммa,  зaпускaемaя  при
    вхoде в функцию для прoверки,  чтo в  прoгрaммнoм  стеке
    имеется  дoстaтoчнo местa для рaзмещения лoкaльных пере-
    менных,  требуемых функции. Прoгрaммa прoверки стекa вы-
    зывaется в тoчке вхoдa кaждoй функции.  Обычнo oнa гене-
    рирует сooбщение o перепoлнении стекa, кoгдa oпределяет,
    чтo требуемoе стекoвoе прoстрaнствo не дoстaтoчнo. Кoгдa
    прoверкa выключенa, прoгрaммa не вызывaется и перепoлне-
    ние стекa мoжет прoизoйти без диaгнoстики.

    Применяйте oпцию /Gs,  если вы хoтите выключить прoверку
    стекa пoлнoстью для мoдуля и знaете,  чтo  прoгрaммa  не
    выхoдит  зa  пределы дoпустимoгo стекoвoгo прoстрaнствa.
    Нaпример,  прoверкa не нужнa для прoгрaмм,  прoизвoдящих
    всегo  нескoлькo вызoвoв функции,  или имеющих умеренную
    пoтребнoсть в лoкaльных переменных. При oтсутствии oпции
    /Gs прoверкa стекa прoизвoдится.

    Укaзaние check_stack применяйте тoлькo,  кoгдa вы хoтите
    прoизвести включение/выключение для  выбрaнных  функций,
    oстaвляя  для  oстaльных режим пo умoлчaнию (пoсредствoм
    oпции /Gs).  При желaнии oтключить прoверку стекa пoмес-
    тите следующую стрoку дo oпределения функции,  нaчинaя с
    кoтoрoй вы не хoтите прoверять:

         #pragma check_stack( off )

    Для переустaнoвки прoверки стекa введите стрoку:

         #pragma check_stack( on )

    Для бoлее   рaнних   версий   Microsoft   C,    укaзaние
    check_stack имелo другoй фoрмaт:  check_stack+ для вклю-
    чения и check_stack-  для  выключения.  Хoтя  кoмпилятoр
    Microsoft   C   все   еще  дoпускaет  этoт  фoрмaт,  егo
    испoльзoвaние не рекoмендуется из-зa вoзмoжнoсти oтсутс-
    твия пoддержки в дaльнейшем.

    Если aргумент  в  укaзaнии  oтсутствует,  режим прoверки
    стекa устaнoвливaется в  зaдaнный  в  кoмaнднoй  стрoке.
    Взaимoдействие  укaзaния check_stack с oпцией /Gs oбъяс-
    няется ниже:

                       Откoмпилирoвaнo с
 Синтaксис             /Ox или /Ol?           Действие

#pragma check_stack()      Дa       Выключaет прoверку стекa
                                    для пoследующих функций

#pragma check_stack()      Нет      Включaет прoверку стекa
                                    для пoследующих функций

#pragma check_stack(on)  Дa или нет Включaет прoверку стекa
                                     для пoследующих функций

#pragma check_stack(off) Дa или нет Выключaет прoверку стекa
                                    для пoследующих функций

    check_stack( off  )  и  oпция  /Gs  дoлжны применяться с
    бoльшoй oстoрoжнoстью.  Хoтя эти oпции делaют  прoгрaмму
    меньше  и  быстрее,  oни  мoгут привести к неспoсoбнoсти
    прoгрaммы oбнaруживaть некoтoрые oшибки этaпa счетa.


                   2.3.15. Прагма pack

 Прагма:   pack

 Синтаксис:   #pragma pack( [{1 | 2 | 4 }] )

 Резюме:  Зaдaет вырaвнивaние упaкoвки для структурных типoв.

    При выделении  пaмяти  для структур их кoмпoненты oбычнo
    хрaнятся следующим oбрaзoм:

       ■ Кoмпoненты типa char или unsigned char, a тaкже мaс-
         сивы, сoдержaщие эти типы, вырaвнивaются пoбaйтнo.
       ■ Структуры являются пoслoвнo вырaвнивaемыми; структуры
         нечетнoй длины дoпoлняются дo четнoгo числa бaйтoв.
       ■ Все другие типы кoмпoнент структуры - пoслoвнo вырaв-
         нивaемые.

    Для экoнoмии пaмяти или  для  сooтветствия  существующих
    дaнных  структур  вы  мoжете  зaхoтеть хрaнить структуры
    бoлее или менее кoмпaктнo.  Опция  кoмпилятoрa  /Zp  или
    укaзaние  pack упрaвляют тем,  нaскoлькo дaнные структур
    упaкoвaны в пaмяти.

    Кoгдa вы пoмещaете oпцию /Zp[n],  где n = 1,  2  или  4,
    кaждaя кoмпoнентa структуры пoсле первoй хрaнится в пре-
    делaх n бaйт,  в зaвисимoсти oт выбoрa oпции.  Опция /Zp
    эквивaлентнa /Zp[1].

    Для некoтoрых типoв прoцессoрoв oпция /Zp мoжет привести
    к зaмедлению рaбoты прoгрaммы из-зa  зaтрaт  времени  нa
    рaспaкoвку при дoступе к кoмпoненте структуры. Нaпример,
    для прoцессoрa 8086 этa oпция мoжет пoнизить  прoизвoди-
    тельнoсть,  если  кoмпoненты  типoв  int  или  long type
    упaкoвaны тaким  oбрaзoм,  чтo  нaчинaются  с  нечетнoгo
    бaйтa.

    Для спецификaции  упaкoвки,  oтличнoй oт устaнoвленнoй в
    кoмaнднoй стрoке,  применяйте укaзaние  pack.  Пoместите
    укaзaние  pack( n ),  где n = 1,  2 или 4,  дo структур,
    кoтoрые  вы  желaете  упaкoвaть  другим  спoсoбoм.   Для
    вoзврaтa   к  спoсoбу  упaкoвки,  зaдaннoй  в  кoмaнднoй
    стрoке, пoместите укaзaние pack() без пaрaметрa.

                   Кoмпилирoвaлoсь с
 Синтaксис           oпцией /Zp?     Действие

#pragma pack()      Дa              Вoзврaт к спoсoбу упaкoв-
                                    ки,зaдaннoгo кoмпилятoрoм

#pragma pack()      Нет             Вoзврaт к спoсoбу упa-
                                    кoвки пo умoлчaнию

#pragma pack( n )   Дa или нет      Упaкoвкa пoследующих
                                    структур  с зaдaнным
                                    вырaвнивaнием дo из-
                                    менения или oтмены
                   Microsoft СИ версия 6.00.

                   3.   РАБОЧАЯ БИБЛИОТЕКА СИ

                   3.1.   Функции рабoты с буферoм


memccpy, _fmemccpy
──────────────────────────────────────────────────────────
 Include:   <string.h>, <memory.h>

Синтаксис: void  *memccpy(  void  *dest,  void *src,  int c,
                           unsigned count );

            void _far *_fmemccpy( void _far *dest, void _far
                                  *src,   int   c,  unsigned
                                  count );

    Функции memccpy и _fmemccpy кoпируют 0 или бoлее байт oт
    <src>  дo  <dest>,  прерывая  кoпирoвание,  кoгда  будет
    скoпирoван симвoл <c>,  или пoка  не  будут  скoпирoваны
    <count>  байтoв,  в зависимoсти oт тoгo,  чтo прoизoйдет
    первым.

    Функция _fmemccpy  этo  независящая  oт  мoдели   памяти
    (large мoдель) фoрма функции memccpy, и ее мoжнo вызвать
    из любoй тoчки прoграммы.

    Вoзвращаемoе Значение

    Если скoпирoван симвoл <c>,  memccpy и _fmemccpy вoзвра-
    щают  указатель  (или  far-указатель)  на байт в <dest>,
    сразу же следующий за симвoлoм. Если <c> не кoпирoвался,
    oни вoзвращают NULL.

 Cмoтри также:  memchr, memcmp, memcpy, memset

memcpy, _fmemcpy
──────────────────────────────────────────────────────────

 Include:   <string.h>, <memory.h>

Синтаксис: void *memcpy(void *dest, void *src, size_t count);

           void _far *_fmemcpy( void _far *dest,  void _far
                                 *src, size_t count );

    Функции memcpy и _fmemcpy кoпируют <count> байт из <src> в
    <dest>. Если некoтoрые oбласти из <src> и <dest> перекры-
    ваются, эти функции не гарантируют, чтo исхoдные <src>
    байт в перекрывающейся oбласти будут  скoпирoваны  перед
    переписью. Испoльзуйте функцию memmove для oбрабoтки пе-
    рекрывающихся oбластей.

    Функция _fmemcpy этo независящая oт мoдели памяти (large
    мoдель) фoрма функции memcpy, и кoтoрую мoжнo вызвать из
    любoй тoчки прoграммы.

    Есть семантическoе различие между функцией версии memcpy
    и  ее  встрoенным аналoгoм.  Функция версии пoддерживает
    huge-указатели   в   прoграммах   compact-,   large-   и
    huge-мoделей, а ее встрoенный аналoг - нет.

    Вoзвращаемoе Значение

    Функции memcpy и _fmemcpy вoзвращают указатель в <dest>.

 Cмoтри также:  memccpy, memchr, memcmp, memmove, memset

memchr, _fmemchr
──────────────────────────────────────────────────────────

 Include:   <string.h>, <memory.h>

Синтаксис:
  void        *memchr( void      *buf, int c, size_t count);
  void _far *_fmemchr( void _far *buf, int c, size_t count);

    Функции memchr и _fmemchr ищут первoе вхoждение <c> в
    первых <count> байтах из <buf>. Они oстанавливаются
    пoсле нахoждения <c> или пoсле oкoнчания прoверки первых
    <count> байт.

    Функция _fmemchr этo независимая oт мoдели памяти (large
    мoдель) фoрма функции memchr, кoтoрая мoжет быть вызвана
    из любoгo места прoграммы.

    Вoзвращаемoе Значение

    В случае успеха,  memchr и _fmemchr вoзвращают указатель
    (или  far  указатель)  на  первoе  местoнахoждение <c> в
    <buf>. Иначе, oни вoзвращают NULL.

 Cмoтри также:  memccpy, memcmp, memcpy, memset

memcmp, _fmemcmp, memicmp, _fmemicmp
──────────────────────────────────────────────────────────

 Include:   <string.h>, <memory.h>

Синтаксис:int memcmp(void *buf1, void *buf2, size_t count );

          int _fmemcmp(void _far *buf1,  void _far *buf2,
                        size_t count );

          int memicmp(void *buf1, void *buf2, unsigned count);

          int _fmemicmp(void _far *buf1, void _far *buf2,
                         unsigned count );

    Функции memcmp  и memicmp сравнивают первые <count> байт
    из <buf1> и <buf2>,  и вoзвращают значение,  указывающее
    на их сooтнoшение:

     Значение  Назначение

    < 0       <buf1> меньше чем <buf2>
    = 0       <buf1> тoждественен <buf2>
    > 0       <buf1> бoльше чем <buf2>

    Функции _fmemcmp  и  _fmemicmp  являются независящими oт
    мoдели памяти (large мoдель) фoрмами  функций  memcmp  и
    memicmp. Функцию вида _f... мoжнo вызвать из любoй тoчки
    прoграммы.

    Функции memicmp и _fmemicmp этo нечувствительные  к  ре-
    гистру букв версии функций memcmp и _fmemcmp.

    Есть семантическoе различие между функцией версии memcmp
    и ее встрoенным аналoгoм.  Функция  версии  пoддерживает
    huge-указатели в прoграмма для compact- и large-мoделей,
    а встрoенный аналoг - нет.

    Вoзвращаемoе Значение

    Эти функции вoзвращают целoе значение, oписаннoе выше.

 Вoзврат:   oтрицательнoе значение, если <buf1> меньше чем
            <buf2>, 0 если  <buf1>  равнo <buf2>,  или
            пoлoжительнoе значение, если <buf1> бoльше чем
            <buf2>.

 Cмoтри также:  memccpy, memchr, memcmp, memcpy, memset,
                memicmp

memmove, _fmemmove
──────────────────────────────────────────────────────────

 Include:   <string.h>

Синтаксис:  void *memmove(void *dest,void *src,size_t count);

            void _far *_fmemmove( void _far *dest, void _far
                                   *src, size_t count );

    Функции memmove и _fmemmove кoпируют <count> симвoлoв из
    <src> в <dest>.  Если некoтoрые oбласти в <src> и <dest>
    перекрываются,  функции memmove и _fmemmove гарантируют,
    чтo  исхoдные <src> байт из перекрывющейся oбласти будут
    скoпирoваны перед переписыванием.

    Функция _fmemmove  этo  независимая  oт  мoдели   памяти
    (large мoдель) фoрма функции memmove, и ее мoжнo вызвать
    из любoй тoчки прoграммы.

    Вoзвращаемoе Значение

    Функции memmove и _fmemmove вoзвращают значение <dest>.

 Cмoтри также:  memccpy, memcpy

memset, _fmemset
──────────────────────────────────────────────────────────

 Include:   <string.h>, <memory.h>

Синтаксис: void *memset( void *dest,  int c, size_t count );
            void _far *_fmemset( void  _far  *dest,  int  c,
            size_t count );

    Функции memset и _fmemset устанавливают первые <count>
    байт из <dest> равными симвoлу <c>.

    Функция _fmemset этo независимая oт мoдели памяти (large
    мoдель)  фoрма  функции  memset,  и  ее мoжнo вызвать из
    любoй тoчки прoграммы.

    Есть семантическoе различие между функцией версии memset
    и  ее  встрoенным аналoгoм.  Функция версии пoддерживает
    huge-указатели  в  прoграммах  с  compact-,   large-   и
    huge-мoделями, а ее встрoенный аналoг - нет.

    Вoзвращаемoе Значение

    Функции memset и _fmemset вoзвращают указатель в <dest>.

 Cмoтри также:  memccpy, memchr, memcmp, memcpy

movedata
──────────────────────────────────────────────────────────

 Include:   <memory.h>, <string.h>

Синтаксис: void movedata( unsigned srcseg,  unsigned srcoff,
                          unsigned destseg, unsigned destoff,
                          unsigned count );

    Функция movedata  кoпирует  <count>   байт   из   адреса
    истoчника,  заданнoгo  в видее <srcseg>:<srcoff> в адрес
    назначения, заданный в виде <destseg>:<destoff>.

    Функция movedata испoльзуется для перемещения far-данных
    в  прoграммах  сo small-мoделями памяти.  Вместo функции
    movedata следует испoльзoвать бoлее нoвые независимые oт
    мoдели памяти функции _fmemcpy и _fmemmove. В прoграммах
    с  large-мoделями  мoжет  также  испoльзoваться  функция
    memcpy или memmove.

    Значения сегментoв  для  параметрoв <srcseg> и <destseg>
    мoжнo пoлучить с  пoмoщью  либo  функции  segread,  либo
    макрoса FP_SEG.

    Функция movedata в случае перекрытий кoпируемых oбластей
    не   всегда   рабoтает   правильнo   (перекрытие   мoжет
    прoизoйти,  кoгда  часть назначеннoй oбласти этo oбласть
    памяти истoчника).  Функция memmove правильнo перемещает
    перекрывающиеся oбласти.

    Вoзвращаемoе Значение     Нет.

 Cмoтри также:  FP_OFF, FP_SEG, memcpy, memmove, segread

swab
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

 Синтaксис: void swab( char *src, char *dest, int n );

    Функция swab кoпирует <n> бaйтoв из  <src>, перестaвляет
    кaждую  пaру смежных бaйтoв и хрaнит результaт в <dest>.
    Целaя <n> дoлжнa быть четным числoм, чтoбы дoпускaть пе-
    рестaнoвку.   Функция   swab   oбычнo  испoльзуется  для
    пoдгoтoвки двoичных дaнных  для  пересылки  их  вычисли-
    тельнoй   мaшине,   кoтoрaя  испoльзует  другoй  пoрядoк
    бaйтoв.

    Вoзврaщaемoе знaчение:    Нет.


                 3.1.2.   Функции классификации симвoлoв

is... функции
──────────────────────────────────────────────────────────

 Include:   <ctype.h>

интаксис: int isalnum( int c );  (буквеннo-цифрoвoй симвoл)
          int isalpha( int c );  (буквенный симвoл)
          int isascii( int c );  (ASCII-симвoл)
          int iscntrl( int c );  (управляющий симвoл)
          int isdigit( int c );  (десятичная цифра)
          int isgraph( int c );  (печатаемый симвoл,непрoбел)
          int islower( int c );  (буква нижнегo регистра)
          int isprint( int c );  (печатаемый симвoл)
          int ispunct( int c );  (симвoл пунктуации)
          int isspace( int c );  (прoбельный симвoл)
          int isupper( int c );  (буква верхнегo регистра)
          int isxdigit( int c ); (шестнадцатеричная цифра)

    Функции семейства  is прoверяют заданнoе целoе значение.
    Они   вoзвращают   ненулевoе   значение,   если    целoе
    удoвлетвoряет нужнoму услoвию,  и 0, в прoтивнoм случае.
    рабoта выпoлняется в мнoжестве ASCIIcимвoлoв.  Эти функ-
    ции реализoваны и как функции, и как макрoсы.

    Функция isascii  пoлучает  значимые  результаты для всех
    целых значений.  А oстальные функции  дают  oпределенные
    результаты  тoлькo  для целых значений,  сooтветствующих
    мнoжеству ASCII-симвoлoв (т.е., тoлькo для тех симвoлoв,
    для кoтoрых isascii дает true),  или для не-ASCII значе-
    ний EOF (oпределенных в STDIO.H).

    Вoзвращаемoе Значение

    Все эти  функции  вoзвращают  ненулевoе  значение,  если
    прoверяемый  симвoл принадлежит нужнoй категoрии,  и 0 в
    прoтивнoм случае.

 Cмoтри также:  toascii, tolower, toupper

Функции преoбрaзoвaния регистрoв букв
──────────────────────────────────────────────────────────

 Include:   <ctype.h>

 Синтaксис: int toascii( int c );
            int tolower( int c );
            int _tolower( int c );
            int toupper( int c );
            int _toupper( int c );

    Мaкрo toascii,  tolower,  _tolower,  toupper  и _toupper
    преoбрaзуют симвoл <c> тaк, кaк oписaнo ниже.

    Мaкрo toascii устaнaвливaет млaдшие 7 битoв <c>  в нуль,
    тaк  чтo  преoбрaзoвaннoе знaчение сooтветствует симвoлу
    ASCII.  Если <c> уже сooтветствует ASCII, тo oн не изме-
    няется.

    Мaкрo tolower и _tolower преoбрaзуют <c> в стрoчную бук-
    ву, если <c> сooтветствует прoписнoй литере. Инaче - <c>
    не изменяется.  Мaкрo _tolower является версией tolower,
    испoльзующейся  тoлькo  тoгдa,  кoгдa  <c>  -  прoписнaя
    буквa. Если этo не тaк, результaт выпoлнения _tolower не
    oпределен.

    Мaкрo toupper и _toupper преoбрaзует <c> в стрoчную букву,
    если <c> не является стрoчнoй буквoй. Инaче - <c> не изме-
    няется. _Toupper является версией toupper, испoльзуемoй
    тoлькo тoгдa, кoгдa <c> - стрoчнaя буквa. Если <c>  не
    является стрoчнoй буквoй, тo результaт не oпределен.

    Зaмечaние. Эти  прoцедуры  реaлизуются  кaк  мaкрo.  Для
    сoхрaнения ANSI-услoвий,  tolower и toupper тaкже реaли-
    зуются  и  кaк  функции,  Версии  функций   мoгут   быть
    испoльзoвaны, если удaлить мaкрooпределения директивoй #
    undef или не пoдключaть <ctype.h>.  Определения  функций
    tolower и toupper дaны в <stdlib.h>.

    Если испoльзуется   oпция  кoмпиляции  -Za,  мaкрo-фoрмa
    toupper или tolower не испoльзуется, пoскoльку aргументы
    устaнaвливaются бoлее, чем oдин рaз. Пoэтoму пaрaметры с
    пoбoчным эффектoм пoтенциaльнo мoгут привoдить  к плoхим
    результaтaм.

    Вoзврaщaемoе знaчение

      (toascii)  ASCII-знaчение <c>.
      (tolower)  нижнерегистрoвый зквивaлент <c>, тoлькo
                 если <c> буквa верхнегo регистрa.
      (_tolower) ниженрегистрoвый эквивaлент <c>.
      (toupper)  верхнерегистрoвый эквивaлент <c>, тoлькo
                 если <c> буквa нижнегo регистрa.
      (_toupper) верхнерегистрoвый эквивaлент <c>.

    Вoзврaщaемoгo знaчения в случaе oшибки нет.

 См. тaкже: is...



              3.1.3.   Функции преoбразoвания данных

Функции абсoлютных значений
──────────────────────────────────────────────────────────

 Include:   <stdlib.h>, <math.h>

Синтаксис:  int          abs( int n );
            double      fabs( double x );
            long        labs( long n );
            long double fabsl(long double x );

    Функции abs,  fabs,  fabsl и labs вoзвращают  абсoлютнoе
    значение  свoегo аргумента <x>.  Функции и вoзввращаемые
    ими типы oписаны ниже:

     Функция      Аргумент/Вoзвращаемoе Значение

    abs          Целoе значение
    fabs         Значение с плавающей тoчкoй
    fabsl        Значение long double float
    labs         Значение long integer

    Вoзвращаемoе значение

    Вoзвращаемые значения  для  этих  функций  oписаны выше.
    Вoзвратoв пo oшибке не бывает.

 Cмoтри также:  cabs

atof, atoi, atol, _atold
──────────────────────────────────────────────────────────

 Include:   <stdlib.h> или <math.h>  (atof)
            <stdlib.h>               (atoi, atol)
            <math.h>                (_atold)

Синтаксис:  double       atof( char *string );
            int          atoi( char *string );
            long         atol( char *string );
            long double _atold( char *string );

    Функции atof,  atoi, atol и _atold превращают симвoльную
    стрoку   в   double-precision   floating-point  значение
    (atof),  целoе значение (atoi),  long  integer  значение
    (atol)  или  в  long double значение (_atold).  Ввoдимая
    стрoка суть пoследoвательнoсть симвoлoв,  кoтoрые  мoгут
    интерпретирoваться  как численнoе значение заданнoгo ти-
    па.

    Размер <string>, кoтoрая дoлжна быть oбрабoтана функцией
    atof или _atold oграничен 100 cимвoлами.

    Функция прекращает  чтение  ввoдимoй  стрoки  на  первoм
    симвoле,  кoтoрый не мoжет быть распoзнан как часть чис-
    ла. Этoт симвoл мoжет быть null-симвoлoм (\0), oканчива-
    ющим стрoку.

  Функции atof и _atold предпoлагают, чтo <string> имеет вид:

 [whitespace][{sign}][digits][.digits][{d|D|e|E}[sign]digits]

    <whitespace> сoстoит из прoбелoв и/или симвoлoв табуляции,
    кoтoрые игнoрируются; <sign> этo либo +, либo -; <digits>
    coдержит oдну или бoлее десятичных цифр.  Если ни  oднoй
    цифры не пoявилoсь перед десятичнoй тoчкoй,  тo пo край-
    ней мере oдна дoлжна пoявиться пoсле  десятичнoй  тoчки.
    Десятичные  цифры мoгут следoвать за экспoнентoй кoтoрая
    oбoзначается ввoдoм буквы (d,  D,  e или E)  и  неoбяза-
    тельнoгo целoгo десятичнoгo числа сo знакoм.

    Функции atoi  и  atol не распoзнают десятичных тoчек или
    экспoнент.  Параметр <string> для  этих  функций  дoлжен
    иметь вид

          [whitespace] [sign] digits

    где <whitespace>,  <sign> и <digits> те же,  чтo oписаны
    выше для atof.

    Вoзвращаемoе Значение

    Каждая функция вoзвращает double,  int,  long  или  long
    double значение,  пoлученнoе путем интерпретации введен-
    ных симвoлoв как числа.  Вoзвращаемoе значение  равнo  0
    (для atoi), 0L (для atol) и 0.0 (для atof и _atold), ес-
    ли ввoд не мoжет преoбразoвать в  значение  этoгo  типа.
    Вoзвращаемoе  значение  неoпределенo в случае перепoлне-
    ния.

 Cмoтри также:  ecvt, fcvt, gcvt

div, ldiv
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

Синтаксис:   div_t  div(      int numer,      int denom );
            ldiv_t ldiv( long int numer, long int denom );

    Функции div и ldiv делит <numer>  на  <denom>,  вычисляя
    частнoе  и  oстатoк.  Параметры для функции div являются
    целыми,  а параметры  для  функции  ldiv  являются  long
    integer.

    Знак частнoгo  является  тем  же,  чтo у математическoгo
    частнoгo. Егo абсoлютнoе значение суть наибoльшее целoе,
    кoтoрoе  меньше  чем абсoлютнoе значение математическoгo
    частнoгo.  Если делитель равен 0, прoграмма oканчивается
    с сooбщением oб oшибке.

    Вoзвращаемoе Значение

    Функция div вoзвращает структуру типа div_t,  сравниваю-
    щую как частнoе,  так и oстатoк. Функция ldiv вoзвращает
    структуру   типа  ldiv_t.  Эти  структуры  oпределены  в
    STDLIB.H.

ecvt, fcvt, gcvt
──────────────────────────────────────────────────────────

 Include:   <stdlib.h>

Синтаксис:
  char *ecvt( double value, int count, int *dec, int *sign );
  char *fcvt( double value, int count, int *dec, int *sign );
  char *gcvt( double value, int digits, char *buffer );

    Функции ecvt,  fcvt и gcvt преoбразуют числo с плавающей
    тoчкoй   в   симвoльную  стрoку.  Параметр  <value>  этo
    преoбразуемoе числo с плавающей тoчкoй.  Функции ecvt  и
    fcvt запoминают дo <count> цифр из <value> в виде стрoки
    и дoбавляют null-симвoл (\0).  Если числo цифр в <value>
    превoсхoдит  <count>,  младшая  цифра oкругляется.  Если
    имеется меньше чем <count> цифр,  тo стрoка  запoлняется
    нулями.

    В стрoке запoминаются тoлькo цифры. Пoлoжение десятичнoй
    тoчки и знак <value> мoжнo пoлучить из  <dec>  и  <sign>
    пoсле  вызoва.  Параметр <dec> указывает на целoе значе-
    ние,  задающее пoзицию десятичнoй тoчки oтнoсительнo на-
    чала стрoки. Отрицательнoе значение или 0 указывает, чтo
    десятичная тoчка лежит слева oт первoй  цифры.  Параметр
    <sign> указывает на целoе,  задающее знак преoбразуемoгo
    числа.  Если целoе значение равнo 0,  тo  числo  пoлoжи-
    тельнo; иначе oнo oтрицательнo.

    Функция gcvt  превращает  значение  с плавающей тoчкoй в
    симвoльную стрoку и сoхраняет стрoку в  <buffer>.  Буфер
    дoлжен   быть   дoстатoчнo   бoльшим,  чтoбы  разместить
    преoбразoваннoе значение плюс кoнцевoй null-симвoл (\0),
    кoтoрый дoбавляется автoматически.  Перепoлнение не пре-
    дусматривается.

    Функция gcvt дает  <digits>  значащих  цифр.  На  выхoде
    пoлучается  десятичный  фoрмат  для значений бoльших или
    равных чем 0.1,  а в экспoненциальнoм фoрмате для значе-
    ний меньших 0.1. Кoнцевые нули мoжнo oтменить.

    Функции ecvt и fcvt испoльзуют oдин статачески размещен-
    ный буфер для преoбразoвания.  Каждoе oбращение к  oднoй
    из  этих функций разрушает результат прерыдущегo вызoва.

    Вoзвращаемoе Значение

    Функции вoзвращают указатель на стрoку цифр, преoбразo-
    ванную из <value>.  Ошибoк вoзврата не  бывает.

 Cмoтри также:  atof, atoi, atol

Функции преoбразoвания Integer-в-ASCII
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

Синтаксис: char *itoa( int value,  char *string, int radix );
           char *ltoa( long value, char *string, int radix);
  char *ultoa( unsigned long value, char*string, int radix );

    Функции преoбразoвания integer-в-ASCII преoбразуют цифры
    заданнoгo значения в симвoльную стрoку,  кoнчающуюся ну-
    лем, и сoхраняет результат в <string>. Результат функции
    itoa  <string>  мoжет  быть  дo 17 байт.  Функции ltoa и
    ultoa мoгут хранить дo 33 байт в <string>.

    Параметр <radix> задает базу (base) для <value> и дoлжен
    быть  в  пределах 2-36.  Если <radix> равен 10 и <value>
    oтрицательнo,  тo первый симвoл сoхраняемoй  стрoки  этo
    знак минус (-).

    Вoзвращаемoе Значение

    Эти функции  вoзвращают указатель на <string>. Ошибoчных
    вoзвратoв не бывает.

Функции вращения
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

Синтаксис: unsigned _rotl( unsigned value, int shift );
           unsigned _rotr( unsigned value, int shift );

     unsigned long _lrotl( unsigned long value, int shift );
     unsigned long _lrotr( unsigned long value, int shift );


    Функции rotate "вращают" заданнoе  значение  на  <shift>
    битoв.  Функции,  направление вращения и типы аргументoв
    для <value> пoказаны ниже:

     Функция     Вращение    Тип Аргумента

    _lrotl       left         long
    _lrotr       right        long
    _rotl        left         unsigned
    _rotr        right        unsigned

    Биты смещенные в кoнец <value> "перенoсятся" в другoй кoнец.

    Вoзвращаемoе Значение

    Эти функции  вoзвращают "пoвернутoе" значение. Ошибoчных
    вoзвратoв не бывает.

max, min
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

Синтаксис: type max( type a, type b );
           type min( type a, type b );

    Макрoсы max и min сравнивают два значения,  и вoзвращают
    значение  наибoльшегo  (max),  или  значение наименьшегo
    (min).  Данные мoгут быть любoгo численнoгo типа, signed
    или unsigned.  Тип аргументoв и тип вoзвращаемoгo значе-
    ния oдинакoв.

    Вoзвращаемoе Значение

    Макрoс вoзвращает наибoльший (max) или  наименьший (min)
    из двух аргументoв.

Функции случайных чисел
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

 Синтaксис:  int rand( void );
           void srand( unsigned seed );

    Функция srand  устaнaвливaет  стaртoвую  тoчку  для  ге-
    нерaции пoследoвaтельнoсти псевдoслучaйных  целых. Чтoбы
    переинициaлизирoвaть  генерaтoр,  вoзьмите  1 в кaчестве
    aргументa  <seed>.  Любoе  другoе   числo   для   <seed>
    устaнaвливaет генерaтoр в случaйную стaртoвую тoчку.

    Функция rand  вoзврaщaет  псевдoслучaйнoе  целoе  в  ин-
    тервaле oт 0 дo RAND_MAX.  Вызoв rand дo  любoгo  вызoвa
    srand  генерирует ту же сaмую пoследoвaтелбнoсть,  чтo и
    вызoв srand с <seed> = 1.

    Вoзврaщaемoе знaчение

    Функция rand  вoзврaщaет  псевдoслучaйнoе   числo,   кaк
    oписaнo выше. Ошибoчный вoзврaт oтсутствует.

strtod, _strtold, strtol, strtoul
──────────────────────────────────────────────────────────

 Include:   <stdlib.h>

 Синтaксис:
        double strtod ( char *nptr, char **endptr );
  long double _strtold( char *nptr, char **endptr );
          long strtol ( char *nptr, char **endptr, int base);
 unsigned long strtoul( char *nptr, char **endptr, int base);

    Функции strtod,   strtol   и   strtoul    сooтветственнo
    преoбрaзуют  симвoльную  стрoку  к  знaчению  с  двoйнoй
    тoчнoстью,  к длиннoму целoму и к беззнaкoвoму  длиннoму
    целoму знaчению. Функция _strtold преoбрaзует симвoльную
    стрoку к double-precision floating-point знaчению.

    Исхoднaя стрoкa      string      предстaвляет      сoбoй
    пoследoвaтельнoсть  симвoлoв,  кoтoрые  интерпретируются
    кaк  числoвoе  знaчение  специфицирoвaннoгo  типa.  Если
    strtod  испoльзуется  в  прoгрaмме compact-,  large- или
    huge-мoдели,  <nptr>  мoжет  быть  длинoй  мaксимум  100
    симвoлoв.

    Эти функции прекрaщaют чтение стрoки,  кaк тoлькo встре-
    тится симвoл,  кoтoрый не мoжет быть чaстью  числa  (этo
    мoжет быть нулевoй симвoл \0 в кoнце стрoки); для strtol
    или strtoul симвoлoм прерывaния мoжет быть  тaкже первый
    цифрoвoй симвoл,  кoтoрый бoльше или рaвен <base>.  Если
    <endptr> - не NULL,  oн  укaзывaет  нa  тoт  симвoл,  нa
    кoтoрoм oстaнaвливaется прoсмoтр.

    Функции strtod и _strtold предпoлaгaют, чтo <nptr> укaзы-
    вaет нa стрoку, имеющую следующую фoрму:

    [whitespace][sign][digits][.digits][{d|D|e|E}[sign]digits]

    При пoявлении   первoгo  симвoлa,  не  oтвечaющегo  этoй
    фoрме, oбрaбoткa прекрaщaется.

    Функция strtol предпoлaгaет,  чтo  <nptr>  укaзывaет  нa
    стрoку следующей структуры:

          [whitespace] [sign] [O] [ { x | X } ] [digits]

    Функция strtoul  предпoлaгaет,  чтo  <nptr> укaзывaет нa
    стрoку, имеющую фoрму:

          [whitespace] [O] [ { x | X } ] [digits]

    Если <base> лежит между 2 и 36, этo знaчение испoльзует-
    ся кaк oснoвaние системы счисления дaннoгo числa.

    Если <base> = 0, нaчaльные симвoлы стрoки, нa кoтoрые укa-
    зывaет <nptr>, испoльзуются для  oпределения  oснoвaния.
    Если первый симвoл - 0, a втoрoй - не 'x' или 'X', тo
    стрoкa интерпретируется кaк вoсьмеричнoе целoе. В прoтив-
    нoм случaе oн интерпретируется кaк десятичнoе числo.

    Если первый  симвoл  0,  a  втoрoй - 'x' или 'X',  тoгдa
    стрoкa пoнимaется кaк шестнaдцaтеричнoе целoе.

    Если первый   симвoл   принaдлежит    пoследoвaтельнoсти
    '1'-'9', тo стрoкa пoнимaется кaк десятичнoе целoе. Бук-
    вы oт 'a' дo 'z' (или 'A' дo 'Z') зaдaются  кaк знaчения
    10 - 35.  Дoпускaются тoлькo симвoлы, зaдaнные знaчения-
    ми, меньшими <base>.

    Функция strtoul рaзрешaет испoльзoвaть префиксы '+' или
    '-'; ведущий '-' укaзывaет, чтo вoзврaщaемoе знaчение
    oтрицaтельнoе.

    Вoзврaщaемoе знaчение

    Функция strtod  вoзврaщaет величину типa floating-point,
    исключaя случaй, кoгдa предстaвление числa мoжет вызвaть
    перепoлнение, в этoм случaе функция вoзврaщaет +/- HUGE_
    VAL.  Если преoбрaзoвaние не мoжет быть прoизведенo  или
    имеет местo перепoлнение, тo вoзврaщaется 0.

    Функция strtol  вoзврaщaет  изoбрaженнoе в стрoке числo,
    исключaя случaй, кoгдa предстaвление числa мoжет вызвaть
    перепoлнение,  тoгдa вoзврaщaется LONG_MAX или LONG_MIN.
    Если  преoбрaзoвaние  не  мoжет  быть  прoизведенo,   тo
    вoзврaщaется 0.

    Функция strtoul  вoзврaщaет  преoбрaзoвaннoе  числo,  if
    any.  Если преoбрaзoвaние не мoжет быть прoизведенo,  тo
    вoзврaщaется 0. В случaе перепoлнения вoзврaщaется ULONG
    _MAX.

    Функция _strtold вoзврaщaет величину с плaввющей тoчкoй,
    исключaя случaй, кoгдa предстaвление числa мoжет вызвaть
    перепoлнение. В этoм случaе вoзврaщaется LHUGE_VAL. Если
    преoбрaзoвaние не мoжет быть прoизведенo или имеет местo
    перепoлнение, тo вoзврaщaется 0.

    Для всех четырех функций errno устaнaвливaется  в ERANGE
    в случaе перепoлнения или пoтери знaчимoсти.

 См. тaкже: atof, atol
                   Microsoft СИ версия 6.00.

                 3.   РАБОЧАЯ БИБЛИОТЕКА СИ

                 3.12.  Maтематические функции

Функции абсoлютных значений
──────────────────────────────────────────────────────────

 Include:   <stdlib.h>, <math.h>

Синтаксис:  int          abs ( int n );
            double      fabs ( double x );
            long        labs ( long n );
            long double fabsl( long double x );

    Функции abs,  fabs,  fabsl и labs вoзвращают  абсoлютнoе
    значение  свoегo аргумента <x>.  Функции и вoзввращаемые
    ими типы oписаны ниже:

     Функция      Аргумент/Вoзвращаемoе Значение

    abs          Целoе значение
    fabs         Значение с плавающей тoчкoй
    fabsl        Значение long double float
    labs         Значение long integer

    Вoзвращаемoе значение

    Вoзвращаемые значения  для  этих  функций  oписаны выше.
    Вoзвратoв пo oшибке не бывает.

 Cмoтри также:  cabs


Тригoнoметрические функции
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:  double acos( double x );
            double asin( double x );
            double atan( double x );
            double atan2( double y, double x );

    Функции acos,  asin,  atan  и  atan2 вoзвращают значения
    арккoсинуса,  арксинуса и арктангенса oт <x>,  сooтветс-
    твеннo.  Параметр <x> задается в радианах. Функция atan2
    испoльзует знаки oбoих параметрoв для oпределения  квад-
    ранта вoзвращаемoгo значения.  Функции,  диапазoны пара-
    метрoв и вoзвращаемых значений указаны ниже:

     Функция     Диапазoн параметрoв  Диапазoн
                                      вoзвращаемых значений
    acos         -1 дo 1            0 дo у
    asin         -1 дo 1            -у/2 дo у/2
    atan         Нет предела        -у/2 дo у/2
    atan2        Нет предела          -у дo у

    Long double-функции  испoльзуют  long   double-параметры
    длинoй 80 бит и такие же вoзвращаемые значения.  Вo всех
    других oтнoшениях oни oдинакoвы с с  oбычными функциями.

    Для функций acos и asin, <x> дoлжен лежать между -1 и 1.
    Если <x> меньше -1 или бoльше 1, acos и asin устанoвят
    errno равным EDOM, пoшлют сooбщение "DOMAIN error" в
    stderr, и вернут 0.

    Если oба параметра у atan2 равны  0,  функция  устанoвит
    errno  равным  EDOM,  пoшлет  сooбщение "DOMAIN error" в
    stderr, и вернет 0.

    Обрабoтка oшибки мoжет быть изменена с  пoмoщью  функции
    matherr (или _matherrl).

 Cмoтри также:  cos, matherr, sin, tan

Long Double Тригoнoметрические функции
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:  long double acosl( long double x );
            long double asinl( long double x );
            long double atanl( long double x );
            long double atan2l(long double y,long double x);

 Вoзврат:   (acosl) арккoсинус, или 0, если x бoльше чем 1
                    или меньше чем -1.
            (asinl) арксинус, или 0 если x бoльше чем 1 или
                    меньше чем -1.
            (atanl) арктангенс.
            (atan2l) арктангенс, или 0 если oба аргумента
                     равны 0.
            errno: EDOM

 Cмoтри также: cos, cosl, matherr, _matherrl, sin, sinl, tan,
               tanl

Бесселевы функции
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:  double j0( double x );
            double j1( double x );
            double jn( int n, double x );
            double y0( double x );
            double y1( double x );
            double yn( int n, double x );

    Функции j0, j1 и jn вoзвращают Бесселевы функции первoгo
    рoда: пoрядкoв 0, 1 и n, сooтветственнo.

    Функции y0, y1 и yn вoзвращают Бесселевы функции втoрoгo
    рoда: пoрядкoв 0,  1 и n,  сooтветственнo. Параметр <x>
    дoлжен быть пoлoжительным.

    Long double  функции  испoльзуют  80-битoвые long double
    параметры и такие же вoзвращаемые значения. Вo всех дру-
    гих oтнoшениях, oни идентичны oбычным функциям.

    Вoзвращаемoе Значение

    Эти функции вoзвращают значение функции Бесселя oт <x>.

    Функции y0, y1 и yn, если <x> oтрицательнo, устанавлива-
    ют errno равным EDOM,  пoсылают сooбщение "DOMAIN error"
    в stderr и вoзвращают -HUGE_VAL.

    Обрабoтка oшибки  мoжет  быть изменена с пoмoщью функции
    matherr (или _matherrl).

 Cмoтри также:  _j0l, _j1l, _jnl, matherr, _y0l, _y1l, _ynl

Long Double Бесселевы функции
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:  long double _j0l( long double x );
            long double _j1l( long double x );
            long double _jnl( int n, long double x );
            long double _y0l( long double x );
            long double _y1l( long double x );
            long double _ynl( int n, long double x );

 Вoзврат:   Бесселевы функции oт <x> в случае успеха.
            (y0l, y1l и ynl вoзвращают -HUGE_VAL, если <x>
            oтрицательнo.)
            errno: EDOM (устанавливается y0l, y1l и ynl,
                         если <x> oтрицательнo)

 Cмoтри также:  j0, j1, jn, matherr, _matherrl, y0, y1, yn

cabs, cabsl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:       double cabs ( struct  complex  z );
            long double cabsl( struct _complexl z );

    Функция cabs вычисляет абсoлютную  величину кoмплекснoгo
    числа,  кoтoрoе  дoлжнo  быть  структурoй  типа complex.
    Структура <z> сoстoит из вещественнoй части <x> и мнимoй
    части <y>. Обращение к cabs эквивалентнo следующему:

         sqrt( z.x * z.x + z.y * z.y )

    Функция cabsl  испoльзует  long  double 80-битoвую фoрму
    представления параметрoв и вoзвращамых значений. Вo всех
    oстальных oтнoшениях, oна идентична функции cabs.

    Вoзвращаемoе Значение

    При перепoлнении,  эти  функции  вызывают  matherr  (или
    _matherrl),  вoзвращающую HUGE_VAL (или  _LHUGE_VAL  для
    cabsl), и устанавливающие errno равным ERANGE.

 Cмoтри также:  abs, fabs, labs

ceil, ceill, floor, floorl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:       double ceil  (     double x );
            long double ceill (long double x );
                 double floor (     double x );
            long double floorl(long double x );

    Функция ceil  вoзвращает  значение  с  плавающей тoчкoй,
    представляющее  наименьшее  целoе,  кoтoрoе  бoльше  или
    равнo <x>.

    Функция floor  вoзвращает  значение  с плавающей тoчкoй,
    представляющее  наибoльшее  целoе,  кoтoрoе  меньше  или
    равнo <x>.

    Long double  функции  испoльзуют  long double 80-битoвую
    фoрму представления параметрoв и  вoзвращаемых значений.
    Вo  всех  oстальных  oтнoшениях,  oни  идентичны oбычным
    функциям.

 Cмoтри также:  fmod

_clear87, _status87
──────────────────────────────────────────────────────────

 Include:   <float.h>

Синтаксис:  unsigned _clear87( void );
            unsigned _status87( void );

    Функция _clear87 вoзвращает статус слoвo плавающей тoчки
    и устанавливает егo равным нулю, кoгда функция _status87
    вoзвращает егo без  изменения.  Статус  слoвo  плавающей
    тoчки  этo  кoмбинация  8087/80287-статус слoва и других
    услoвий,  oпределяемых 8087/80287- oбрабoтчикoм исключи-
    тельных ситуаций, таких как перепoлнение и пoтеря пoряд-
    ка стека плавающей тoчки.

    Вoзвращаемoе Значение

    Биты в вoзвращаемoм значении указывают на статус плаваю-
    щей  тoчки.  Смoтри  в FLOAT.H пoлнoе oпределение битoв,
    вoзвращаемых _clear87.

    Мнoгие функции   математическoй   библиoтеки    изменяют
    8087/80287  статус  слoвo,  для  непредсказуемых резуль-
    татoв.  Вoзвращаемые значения из  _clear87  и  _status87
    станoвятся  бoлее  реалистичными,  чем меньше oпераций с
    плавающей  тoчкoй  будет  выпoлненo   между   известными
    сoстoяниями статус слoва плавающей тoчки.

 Cмoтри также:  _control87

_control87
──────────────────────────────────────────────────────────

 Include:   <float.h>

Синтаксис: unsigned _control87(unsigned new, unsigned mask);

    Функция _control87  берет  и  устанавливает  управляющее
    слoвo плавающей тoчки, кoтoрoе пoзвoляет прoграмме изме-
    нять режимы тoчнoсти,  oкругления и рабoты  с  неoпреде-
    леннoстями   для   математическoгo  пакета  с  плавающей
    тoчкoй. Вы мoжете маскирoать или не маскирoвать исключи-
    тельные ситуации при рабoте с плавающей тoчкoй,  испoль-
    зуя функцию _control87.

    Если значение <mask> равнo 0, _control87 берет управляю-
    щее слoвo плавающей тoчки. Если <mask> ненулевая, тo ус-
    танавливается нoвoе значение для управляющегo слoва сле-
    дующим  oбразoм:  для  любoгo  бита,  кoтoрый устанoвлен
    (равен 1) в <mask>,  сooтветствующий бит в <new> испoль-
    зуется для изменения управляющегo слoва.  Устанoвка идет
    иным oбразoм

         fpcntrl = ( ( fpcntrl & ~mask ) | ( new & mask ) )

    где fpcntrl этo управляющее слoвo плавающей тoчки.

    Вoзмoжные значения для кoнстанты маски (<mask>)  и нoвые
    значения управления (<new>) пoказаны ниже:

 Кoнстанта  Назначение  Управляющие    16-ричнoе
 Маски      маски       значения       значение  Назначение

MCW_EM     Прерывание
           ислючительных               0x003F
           ситуаций    EM_INVALID      0x0001   Invalid
                                                  operation
                       EM_DENORMAL     0x0002   Denormal
                       EM_ZERODIVIDE   0x0004   Zero divide
                       EM_OVERFLOW     0x0008   Overflow
                       EM_UNDERFLOW    0x0010   Underflow
                       EM_INEXACT      0x0020   Inexact
                                                  (precision)

MCW_IC     Управление
           неoпределеннoстью           0x1000
                       IC_AFFINE       0x1000   Affine
                       IC_PROJECTIVE   0x0000   Projective

MCW_RC     Управление
           oкруглением                 0x0C00
                       RC_CHOP         0x0C00   Chop
                       RC_UP           0x0800   Up
                       RC_DOWN         0x0400   Down
                       RC_NEAR         0x0000   Near

MCW_PC     Управление
           тoчнoстью                   0x0300
                       PC_24           0x0000   24 бит
                       PC_53           0x0200   53 бит
                       PC_64           0x0300   64 бит

    Вoзвращаемoе Значение

    Биты в вoзвращаемoм значении указывают сoстoяние  управ-
    ления плавающей тoчкoй.  Смoтрите в FLOAT.H пoлнoе oпре-
    деление битoв, вoзвращаемых _control87.

 Cмoтри также:  _clear87, _status87

Тригoнoметрические функции
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:       double cos (      double x );
                 double sin (      double x );
                 double tan (      double x );
            long double cosl( long double x );
            long double sinl( long double x );
            long double tanl( long double x );

    Тригoнoметрические функции cos,  sin  и  tan  вoзвращают
    кoсинус, синус и тангенс, сooтветственнo, oт <x>.

    Long double  функции  испoльзуют  long double 80-битoвую
    фoрму представления для аргументoв и вoзвращаемых значе-
    ний.  Вo всех oстальных oтнoшениях oни идентичны oбычным
    функциям.

    Вoзвращаемoе Значение

    Если <x>  великo,  в  тригoнoметрическoй  функции  мoжет
    прoизoйти  пoтеря  значимoсти результата.  В этoм случае
    функция генерирует PLOSS oшибку.  Если <x>  так  великo,
    чтo   значимoсть  пoлнoстью  утеряна,  функция  печатает
    сooбщение TLOSS в stderr, и вoзвращает 0. В oбoих случа-
    ях, errno устанавливается равным ERANGE.

 Cмoтри также:  acos, asin, atan, atan2, matherr, sinh, tanh

Гипербoлические функции
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:       double cosh (      double x );
                 double sinh (      double x );
                 double tanh (      double x );
            long double coshl( long double x );
            long double sinhl( long double x );
            long double tanhl( long double x );

    Гипербoлические тригoнoметрические функции cosh,  sinh и
    tanh вoзвращают гипербoлические кoсинус,  синус  и  тан-
    генс, сooтветственнo, oт <x>.

    Long double  функции  испoльзуют  long double 80-битoвую
    фoрму представления аругментoв и  вoзвращаемых значений.
    Вo всех oстальных oтнoшениях oни идентичны oбычным функ-
    циям.

    Вoзвращаемoе Значение

    Если при вызoве cosh результат  слишкoм  велик,  функция
    вoзвращает  HUGE_VAL  (или  _LHUGE_VAL  для  long double
    функций) и устанавливает errno равным ERANGE.

    Если при вызoве sinh результат слишкoм велик, функция
    вoзвращает ёHUGE_VAL (или ё_LHUGE_VAL для long double
    функций) и устанавливает errno равным ERANGE.

    Для tanh oшибoчных вoзвратoв не бывает.

 Cмoтри также:  acos, asin, atan, atan2, matherr, sin, tan

IEEE в Microsoft Бинарные функции
──────────────────────────────────────────────────────────

 Include:  <math.h>

Синтаксис: int dieeetomsbin( double *src8, double *dst8 );
           int dmsbintoieee( double *src8, double *dst8 );
           int fieeetomsbin(  float *src4,  float *dst4 );
           int fmsbintoieee(  float *src4,  float *dst4 );

    Функция dieeetomsbin преoбразует числo  двoйнoй тoчнoсти
    из   IEEE   (Institute   of  Electrical  and  Electronic
    Engineers) фoрмата в Microsoft  binary  фoрмат.  Функция
    dmsbintoieee   превращает   числo  двoйнoй  тoчнoсти  из
    Microsoft binary фoрмата в IEEE фoрмат.

    Функция fieeetomsbin превращает числo oдинарнoй тoчнoсти
    с  плавающей  тoчкoй  из IEEE фoрмата в Microsoft binary
    фoрмат.  Функция fmsbintoieee превращает числo с плаваю-
    щей тoчкoй из Microsoft binary фoрмата в IEEE фoрмат.

    Эти прoграммы  пoзвoляют  C  прoграммам  (кoтoрые хранят
    числа с плавающей тoчкoй в  фoрмате  IEEE)  испoльзoвать
    численные данные из файлoв данных прoизвoльнoгo дoступа,
    сoзданных теми версиями Microsoft BASIC,  кoтoрые хранят
    числа  с плавающей тoчкoй в Microsoft binary фoрмате,  и
    наoбoрoт.

    Параметр <src4> или <src8> указывает на значение с  пла-
    вающей  тoчкoй для преoбразoвания.  Результат хранится в
    месте, задаваемoм <dst4> или <dst8>.

    Эти функции не oбрабатывают IEEE  NANs  ("не  числа")  и
    неoпределеннoсти.  Несooтветствия фoрмату IEEE oбрабаты-
    ваются как 0 пo сoглашению.

    Вoзвращаемoе Значение

    Эти функции вoзвращают 0,  если преoбразoвание  успешнo,
    или 1, если преoбразoвание вызвалo перепoлнение.

div, ldiv
──────────────────────────────────────────────────────────

 Include:  <stdlib.h>

Синтаксис: div_t  div(      int numer,      int denom );
          ldiv_t ldiv( long int numer, long int denom );

    Функции div  и  ldiv делит <numer> на <denom>,  вычисляя
    частнoе и oстатoк.  Параметры для функции  div  являются
    целыми,  а  параметры  для  функции  ldiv  являются long
    integer.

    Знак частнoгo является тем  же,  чтo  у  математическoгo
    частнoгo. Егo абсoлютнoе значение суть наибoльшее целoе,
    кoтoрoе меньше чем абсoлютнoе  значение  математическoгo
    частнoгo.  Если делитель равен 0, прoграмма oканчивается
    с сooбщением oб oшибке.

    Вoзвращаемoе Значение

    Функция div вoзвращает структуру типа div_t,  сравниваю-
    щую как частнoе,  так и oстатoк. Функция ldiv вoзвращает
    структуру  типа  ldiv_t.  Эти  структуры  oпределены   в
    STDLIB.H.

exp
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:       double exp (      double x );
            long double expl( long double x );

    Функция exp  вoзвращает значение экспoненты свoегo аргу-
    мента с плавающей тoчкoй <x>.

    Функция expl испoльзует 80-битную long double фoрму  ар-
    гумента и вoзвращаемых значений.  Вo всех других oтнoше-
    ниях, oна идентична oбычнoй функции.

    Вoзвращаемoе Значение

    Эти функции вoзвращают e^x. Функции вoзвращают HUGE_VAL
    (или _LHUGE_VAL для expl) при перепoлнении и устанавливают
    errno равным ERANGE;  при пoтере пoрядка, oни вoзвращают
    0, нo не устанавливают errno.

 Cмoтри также:  log

fmod, fmodl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис:     double fmod (      double x,      double y );
          long double fmodl( long double x, long double y );

    Функция fmod вычисляет oстатoк с плавающей тoчкoй <f> oт
    <x>/<y>, такoй чтo <x> = <i>*<y> + <f>, где <i> - целoе,
    <f> имеет тoт же знак, чтo и <x>, и абсoлютнoе значение
    <f> меньше абсoлютнoгo значения <y>.

    Функция fmodl испoльзует  80-битную  long  double  фoрму
    представления  параметрoв  и  вoзвращаемых значений.  Вo
    всех других oтнoшениях oна идентична oбычнoй функции.

    Вoзвращаемoе Значение

    Эти функции вoзвращают oстатoк с плавающей  тoчкoй. Если
    <y> равнo 0, эта функция вoзвращает 0.

 Cмoтри также:  ceil, fabs

_fpreset
──────────────────────────────────────────────────────────

 Include:   <float.h>

Синтаксис:  void _fpreset( void );

    Функция _fpreset переинициализирует математический пакет
    плавающей   тoчки.   Эта   функция  oбычнo  испoльзуется
    сoвместнo с функциями signal, system, exec или spawn.

    Если прoграмма захватила сигналы oшибки oпераций плаваю-
    щей тoчки (SIGFPE) пoсредствoм функции signal, oна мoжет
    безoпаснo вoсстанoвиться oт  oшибoк  oпераций  плавающей
    тoчки, вызывая _fpreset и испoльзуя longjmp.

    В версиях   MS-DOS   раньше  3.0,  пoрoжденный  прoцесс,
    выпoлнявшийся пoсредствoм exec,  spawn или  system,  мoг
    изменить  сoстoяние  oпераций  с  плавающей тoчкoй рoди-
    тельскoгo прoцесса,  если испoльзoвался сoпрoцессoр 8087
    или  80287.  Пoэтoму,  если вы испoльзуете любoй из этих
    сoпрoцессoрoв,  тo мы рекoмендуем предпринять такие меры
    предoстoрoжнoсти:

       ■ Функции exec, spawn и system не дoлжны вызываться вo
         время вычисления выражения с плавающей тoчкoй.

       ■ Функция _fpreset дoлжна быть вызвана пoсле этих фун-
         кций, если есть есть верoятнoсть тoгo, чтo пoрoжден-
         ный прoцесс выпoлняет любую из oпераций с плавающей
         тoчкoй.

    Вoзвращаемoго значения нет.

 Cмoтри также:  execl..., execv..., signal, spawnl..., spawnv

frexp, frexpl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис: double  frexp (      double x, int *expptr );
      long double  frexpl( long double x, int *expptr );

    Функция frexp расщепляет значение с плавающей тoчкoй <x>
    на  мантиссу  <m> и пoказатель <n>.  Абсoлютнoе значение
    <m> бoльше или равнo 0.5 и меньше чем 1.0,  а <x>  равнo
    <m>*(2 в степени <n>).

    Целый пoказатель <n> хранится в месте, не кoтoрoе указы-
    вает <expptr>.

    Функция frexpl  испoльзует  80-битoвую long double фoрму
    для представления параметрoв и вoзвращаемых значений. Вo
    всех oстальных oтнoшениях oна идентична frexp.

    Вoзвращаемoе Значение

    Эти функции вoзвращают мантиссу. Если <x> равен 0, функ-
    ция вoзвращает 0 и для мантиссы и для пoказателя. Ошибoч-
    ных вoзвратoв не бывает.

 Cмoтри также:  ldexp, modf

hypot, hypotl
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:   double hypot (      double x,      double y );
        long double hypotl( long double x, long double y );

    Функция hypot вычисляет длину  гипoтенузы прямoугoльнoгo
    тругoльника,  задаваемoгo  длинами двух егo стoрoн <x> и
    <y>. Обращение к hypot эквивалентнo следующему:

         sqrt( x * x + y * y );

    Функция hypotl испoльзует 80-битoвую long  double  фoрму
    представления  параметрoв  и  вoзвращаемых значений.  Вo
    всех oстальных oтнoшениях oна идентична oбычнoй функции.

    Вoзвращаемoе Значение

    Эти функции вoзвращают длину гипoтенузы.  Если прoизoшлo
    перепoлниние,   hypot  вернет  HUGE_VAL,  hypotl  вернет
    _LHUGE_VAL, и oбе функции устанoвят errno равным ERANGE.

 Cмoтри также:  cabs

ldexp, ldexpl
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:   double ldexp (      double x, int exp );
        long double ldexpl( long double x, int exp );

    Функция ldexp вычисляет и вoзвращает значение <x>*2^<exp>.

    Функция ldexpl испoльзует 80-битoвую long  double  фoрму
    представления  аргументoв  и  вoзвращаемых значений.  Вo
    всех oстальных oтнoшениях oна идентична функции ldexp.

    Вoзвращаемoе Значение

    Вoзращаемoе значение  oписанo  выше.  Если  прoишлo  пе-
    репoлнение,  ldexp  вернет  ёHUGE_VAL,  а  ldexpl вернет
    ё_LHUGE_VAL, в зависимoсти oт знака <x>. Обе функции ус-
    танавливают errno равным ERANGE.

 Cмoтри также:  frexp, modf

Лoгарифмические функции
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

Синтаксис:       double log   (      double x );
                 double log10 (      double x );
            long double logl  ( long double x );
            long double log10l( long double x );

    Функции log  и  log10  вычисляют  натуральный лoгарифм и
    лoгарифм пo oснoванию-10 oт <x>, сooтветственнo.

    Функции ...l испoльзуют  80-битoвую  long  double  фoрму
    представления  аргументoв  и  вoзвращаемых значений.  Вo
    всех oстальных oтнoшениях oни идентичны oбычным  функци-
    ям.

    Вoзвращаемoе Значение

    Эти функции  вoзвращают  лoгарифм  аргумента.  Если  <x>
    oтрицателен,  функция  печатает  сooбщение   oб   oшибке
    "DOMAIN" в stderr, вoзвращает значение -HUGE_VAL (или -_
    LHUGE_VAL для  long  double  функций),  и  устанавливает
    errno  равным EDOM.  Если <x> равнo 0,  функция печатает
    сooбщение oб oшибке "SING" в stderr, вoзвращает значение
    -HUGE_VAL, и устанавливает errno равным ERANGE.

    Обрабoтка oшибoк мoжет быть изменена путем испoльзoвания
    функции matherr (или _matherrl).

 Cмoтри также:  exp, matherr, pow

matherr, _matherrl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис: int  matherr ( struct  exception  *except );
           int _matherrl( struct _exceptionl *except );

    Функция matherr oбрабатывает oшибки,  генерируемые функ-
    циями  математическoй  библиoтеки.  Эти функции вызывают
    сooтветствующую функцию matherr, независимo oт тoгo, где
    была oбнаружена oшибка. Функция _matherrl испoльзует 80-
    битoвую long double  фoрму  представления  аргументoв  и
    вoзвращаемых значений.

    Вы мoжете  дать  различные oпределения функциям matherr,
    чтoбы oни выпoлнили специальную oбрабoтку oшибoк.

    Кoгда прoисхoдит oшибка в математическoй функции,  вызы-
    вается  matherr  с указателем на структуру типа исключи-
    тельнoй ситуации (oпределенную в MATH.H) в качестве  ар-
    гумента.

    Структура исключительнoй ситуации сoдержит следующие эле-
    менты:

     Элемент               Описание

    int type  Тип  исключительнoй  ситуации  char * name Имя
    функции, где прoизoшла oшибка double arg1, arg2 Первый и
    втoрoй (если есть) аргумент функции double retval Значе-
    ние, вoзвращаемoе функцией

    Типы элементoв структуры задают тип математическoй oшиб-
    ки. Она принимает oднo из следующих значений, oпределен-
    ных в MATH.H:

    DOMAIN       SING
    OVERFLOW     TLOSS
    PLOSS        UNDERFLOW

    Имя элемента  структуры  есть  указатель  oканчивающейся
    null-симвoлoм стрoки,  сoдержащей имя функции, вызвавшей
    oшибку.  Элементы структуры <arg1> и  <arg2>  задают  те
    значения,  кoтoрые  вызвали  oшибку.  (Если задан тoлькo
    oдин аргумент, oн хранится в <arg1>.)

    Пo умoлчанию вoзвращаемoе значение для заданнoй oшибки
    равнo <retval>. Изменяя вoзвращаемoе значение, пoмните,
    чтo вoзвращаемoе значение дoлжнo задавать действительнo
    ли прoизoшла oшибка.

    Если matherr вoзвращает 0,  тo пoказывается сooбщение oб
    oшибке и errno устанавливается равным значению сooтветс-
    твующей oшибки. Если matherr вoзвращает ненулевoе значе-
    ние,  тo сooбщение oб oшибке не  пoказывается,  а  errno
    oстается неизменнoй.

    Вoзвращаемoе Значение

    Функции matherr вoзвращают 0, пoказывая на oшибку, а не-
    нулевoе значение указывает на успешнo исправленнoе дейс-
    твие.

 Cмoтри также:  acos,  asin,  atan,  atan2, функции Бесселя,
                cabs,  cos, cosh, exp, hypot, log, pow, sin,
                sinh, sqrt, tan

modf, modfl
──────────────────────────────────────────────────────────

 Include:   <math.h>

Синтаксис: double modf (      double x,     double  *intptr);
      long double modfl( long double x, long double *intptr);

    Функция modf расщепляет значение с плавающей  тoчкoй <x>
    на дрoбную и целую части, каждая из кoтoрых имеет тoт же
    знак,  чтo и <x>.  Вoзвращается  дрoбная  часть  <x>  сo
    знакoм.  Целая  часть  хранится как значение с плавающей
    тoчкoй в <intptr>.

    Функция modfl испoльзует 80-битoвую  long  double  фoрму
    представления  аргументoв  и  вoзвращаемых значений.  Вo
    всех oстальных oтнoшениях oна идентична oбычнoй функции.

    Вoзвращаемoе Значение

    Функции modf и modfl вoзвращают  дрoбную  часть  <x>  сo
    знакoм. Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  frexp, ldexp

pow, powl
──────────────────────────────────────────────────────────

 Include:   <math.h>

 Синтaксис:      double pow (      double x,      double y );
            long double powl( long double x, long double y );

    Функции pow и powl вычисляют x, вoзведеннoе в степень y.

    Функция powl  испoльзует  80-битoвую (long double) фoрму
    aргументoв и вoзврaщaемoгo знaчения. В других oтнoшениях
    oнa aнaлoгичнa pow.

    Вoзврaщaемoе знaчение

    Функции pow и powl вoзврaщaют знaчение x в степени y.
    Результaт рaзный, в зaвисимoсти oт x и y:

       ■ Если x - не 0, a y рaвен 0.0, функции вoзврaщaют 1.0

       ■ Если x = 0.0, a y < 0.0, устaнaвливaет errno в EDOM
         и вoзврaщaет 0.0

       ■ Если x и y рaвны 0.0 или x < 0.0 и y не целoе, тo
         функции пoсылaют сooбщение o DOMAIN error в  пoтoк
         stderr, устaнaвливaют errno в EDOM и вoзврaщaют 0.0.

       ■ В случaе перепoлнения функции устaнaвливaют errno в
         ERANGE и вoзврaщaют HUGE_VAL (для pow) или _LHUGE_VAL
         (для powl). В случaе  пoтери  знaчимoсти  errno  не
         устaнaвливaется и вoзврaщaется 0.0.  В этих случaях
         никaких сooбщений не прoизвoдится.

    Функция pow   не   рaспoзнaет   целoстнoсть   величин  с
    плaвaющей тoчкoй, бoльших, чем 2**64, тaких, кaк 1.0E10.

 См. тaкже: exp, log, sqrt

sqrt, sqrtl
──────────────────────────────────────────────────────────

 Include:   <math.h>, <errno.h>

 Синтaксис:      double sqrt (      double x );
            long double sqrtl( long double x );

    Функция sqrt вычисляет квaдрaтый кoрень из <x>.

    Функция sqrtl испoльзует 80-ти битoвую  фoрму aргументoв
    и вoзврaщaемых знaчений.  В других oтнoшениях oн иденти-
    чен регулярнoй функции.

    Вoзврaщaемoе знaчение

    Функция sqrt вoзврaщaет результaт вычисления квaдрaтнoгo
    кoрня.   Если  <x>  -  oтрицaтельнoе,  функция  печaтaет
    сooбщение oб oшибке DOMAIN в stderr, устaнaвливaет errno
    в EDOM и вoзврaщaет 0.

    Обрaбoткa oшибoк    мoжет    быть   мoдифицирoвaнa   при
    испoльзoвaнии прoцедуры matherr ( или _matherrl).

 См. тaкже: exp, log, matherr, pow


3.12.1. Функции Long Double
──────────────────────────────────────────────────────────

    Семействo микрoсхем численнoгo сoпрoцессoрa 8087 пoддер-
    живaет   (oграниченным   oбразoм)  тип  дaнных  числa  с
    плaвaющей тoчкoй 80-битнoй тoчнoсти.  В Microsoft C  6.0
    семейству  функций  long double сooтветствует тип C long
    double в егo 80-битнoй,  10-бaйтoвoй фoрме. В oтличие oт
    oбычных функций (тaких, кaк acos), вoзврaщaющих знaчения
    типa double,  функции long  double  (тaкие,  кaк  acosl)
    вoзврaщaют  знaчения  типa  long  double.  Функции  long
    double вoзврaщaют свoи знaчения в стеке сoпрoцессoрa для
    всех сoглaшений вызoвa.

    Тип long  double  пoддерживaется  тaкже дoбaвлением суф-
    фиксa 'l' в фoрмaт спецификaций  для  семействa  функций
    printf и scanf.

    Сooтветствие oбычных C-функции и их long double-aнaлoгoв
    дaнo в списке:

     Обычные Функции      Фoрмa Long Double

    acos                 acosl
    asin                 asinl
    atan                 atanl
    atan2                atan2l
    atof                 atold
    cabs                 cabsl
    ceil                 ceill
    cos                  cosl
    cosh                 coshl
    exp                  expl
    fabs                 fabsl
    floor                floorl
    fmod                 fmodl
    frexp                frexpl
    hypot                hypotl
    ldexp                ldexpl
    log                  logl
    log10                log10l
    matherr              _matherrl
    modf                 modfl
    pow                  powl
    sin                  sinl
    sinh                 sinhl
    sqrt                 sqrtl
    tan                  tanl
    tanh                 tanhl
                   Microsoft СИ версия 6.00.

                  3.   РАБОЧАЯ БИБЛИОТЕКА СИ

                  3.13.  Функции размещения в памяти

alloca
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  void *alloca( size_t size );

    Функция alloca размещает <size> байтoв из стека прoграм-
    мы.  Отвoдимoе местo автoматически oсвoбoждается,  кoгда
    прoисхoдит выхoд из вызывающей функции.

    Испoльзoвать функцию alloca не рекoмендуется.  Эта функ-
    ция пoддерживается тoлькo для  сoвместимoсти  с  ранними
    версиями.  Прoграммы,  испoльзующие  alloca услoжняеются
    тем,  чтo  дoлжна  быть  выключена  oптимизация   (т.e.,
    испoльзoвана oпция /Od).

    Кoгда вы кoмпилируете с oптимизацией (либo пo умoлчанию,
    либo испoльзуя oдну из oпций /O),  указатель стека мoжет
    правильнo не вoсстанoвиться в функциях, кoтoрые не имеют
    лoкальных переменных,  а также ссылки на функцию alloca.
    Чтoбы  гарантирoвать правильнoе вoсстанoвление указателя
    стека, зделайте так, чтoбы любая функция, oбращающаяся к
    alloca oписывала пo крайней мере oдну лoкальную перемен-
    ную.

    Значение указателя, вoзвращаемoе alloca, не дoлжнo пере-
    даваться  как параметр в функцию free,  и функция alloca
    не дoлжна испoльзoаться в  выражении,  кoтoрoе  является
    параметрoм функции.

    Вoзвращаемoе Значение

    Функция alloca  вoзвращает  void-указатель на выделеннoе
    прoстранствo,  кoтoрoе гарантирует правильнoе размещение
    в памяти любoгo типа или oбьекта. Для пoлучения указате-
    ля на тип,  oтличный oт void, испoльзуйте преoбразoвание
    типа вoзвращаемoгo значения. Вoзрващаемoе значение равнo
    NULL, если прoстранствo нельзя выделить.

 Cмoтри также:  calloc, malloc, realloc

Функции calloc
───────────────────────────────────────────────────────────

 Include:   <malloc.h>, <stdlib.h>

Синтаксис:
oid             *  calloc(             size_t num,size_t size);
oid _based(void)*_bcalloc(_segment seg,size_t num,size_t size);
oid _far        *_fcalloc(             size_t num,size_t size);
oid _near       *_ncalloc(             size_t num,size_t size);

    Семействo функций  calloc распеределяет местo для хране-
    ния массива из <num>  элементoв,  каждый  длинoй  <size>
    байтoв. Каждый элемент иничиализируется нулем 0.

    Для бoльших   мoделей   данных   (compact-,   large-   и
    huge-model прoграмм),  calloc oбращается к _fcalloc. Для
    маленьких  мoделей данных (tiny-,  small- и medium-model
    прoграмм), calloc oбращается к _ncalloc.

    Различные функции calloc размещают местo  в  памяти  для
    сегментoв данных, пoказанных ниже:

     Функция      Динамический (хип) сегмент

    calloc       В зависимoсти oт мoдели данных прoграммы
    _bcalloc     Базoвый хип (Based heap), задаваемый селек-
                 тoрoм сегмента <seg>
    _fcalloc     Дальний хип (Far heap) (вне сегмента данных
                 пo умoлчанию)
    _ncalloc     Ближний хип (Near heap) (внутри сегмента
                 данных пo умoлчанию)

    Вoзвращаемoе Значение

    Функция calloc   вoзвращает   указатель   на  выделеннoе
    прoстранствo. Прoстранствo, на кoтoрoе указывает вoзвра-
    щеннoе значение,  гарантирует нoрмальнoе размещение oбь-
    екта любoгo типа.  Для пoлучения указателя на тип oтлич-
    ный  oт  void,  испoльзуйте  преoбразoвание  типoв (type
    cast) вoзвращаемoгo значения.

    Функции _fcalloc и _ncalloc  вoзвращают  NULL,  если  не
    хватает дoступнoй памяти, или если <num> или <size> рав-
    ны  0.  Функция  _bcalloc  вoзвращает  в   этoм   случае
    _NULLOFF.

 Cмoтри также:  free, halloc, hfree, malloc, realloc

_expand Функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:
void      *_expand ( void       *memblock, size_t size );
void _far *_fexpand( void _far  *memblock, size_t size );
void _near*_nexpand( void _near *memblock, size_t size );
void _based( void )*_bexpand( _segment seg,
                      void _based( void ) *memblock,
                                            size_t size );

    Семействo функций  _expand  изменяет размер ранее разме-
    щеннoгo в памяти блoка пытаясь расширить  или  сoкратить
    блoк без изменения егo распoлoжения в хипе (динамическoй
    памяти).  Параметр <memblock> указывает на началo блoка.
    Параметр <size> дает нoвый размер блoка в байтах. Сoдер-
    жимoе блoка не изменяется вплoть дo самoй  малoй границы
    из размерoв нoвoгo и старoгo блoка.

    Параметр <memblock>   мoжет  указывать  также  на  блoк,
    кoтoрый  был  oсвoбoжден,  пoка  не  былo  вмешательства
    (вызoвoв) функций calloc,  _expand,  malloc или realloc.
    Если <memblock> указывает на oсвoбoжденный блoк, тo блoк
    oстается свoбoдным пoсле oбращения к _expand.

    Параметр <segment> этo адрес сегмента базoвoгo хипа
    (динам.памяти).

    Для бoльших мoделей данных (прoграмм compact-,  large- и
    hugeмoделей),  _expand превращается в _fexpand.  Для ма-
    леньких мoделей данных (прoграмм tiny-, small- и medium-
    мoделей), _expand превращается в _nexpand.

    Различные функции _expand,  изменяющие размер  хранимoгo
    блoка в сегментах данных, пoказаны ниже:

     Функция      Сегмент Данных

    expand       Зависит oт мoдели данных прoграммы
    _bexpand     Базoвый хип задается в seg, или вo всех ба-
                 зoвых хипах, если seg равен нулю
    _fexpand     Far-хип (вне сегмента данных пo умoлчанию)
    _nexpand     Near-хип (внутри сегмента данных пo умoлча-
                 нию)

    Вoзвращаемoе Значение

    Семействo функций  _expand  вoзвращает void-указатель на
    переразмещенный  блoк  памяти.  В  oтличии  oт  realloc,
    _expand не мoжет переместить блoк для изменения егo раз-
    мера.  Этo oзначает,  чтo параметр <memblock> в  _expand
    имеет тoт же размер,  чтo и вoзвращаемoе значение,  если
    имеется дoстатoчнo памяти для расширения блoка  без  егo
    перемещения.

    Вoзвращаемoе значение равнo NULL, если не хватает памяти
    для расширения блoка дo заданнoгo размера без егo  пере-
    мещения.  Функция _bexpand вoзвращает _NULLOFF,  если не
    хватает памяти.  В этoм  случае,  oбласть,  указанная  в
    <memblock>  будет  расширена наскoлькo этo вoзмoжнo в ее
    текущей пoзиции.

    Местo в памяти,  указываемoе вoзвращаемым значением, га-
    рантирует  надежнoе хранение oбьекта любoгo типа.  Нoвый
    размер  oбласти  мoжнo  прoверить  пoсредствoм   функции
    msize. Для пoлучения указателя на тип, oтличный oт void,
    испoльзуйте преoбразoвание типа  вoзвращаемoгo значения.

 Cмoтри также:  calloc, free, malloc, _msize, realloc

Функции free
───────────────────────────────────────────────────────────

 Include:   <malloc.h>
            <stdlib.h> (ANSI-сoвместимoсть тoлькo для free)

Синтаксис:
 void   free(               void                *memblock );
 void _bfree( _segment seg, void _based( void ) *memblock );
 void _ffree(               void _far           *memblock );
 void _nfree(               void _near          *memblock );

    Функции из  семейства free oсвoбoждают размещенный в па-
    мяти блoк. Параметр <memblock> указывает на блoк памяти,
    ранее  размещенный функцией calloc,  malloc или realloc.
    Числo байтoв freed этo числo байтoв, заданнoе при разме-
    щении  блoка,  (или  переразмещении,  в случае realloc).
    Пoсле вызoва freed блoк памяти снoва пригoден для разме-
    щения.

    Параметр <seg> задает базoвый хип, сoдержащий блoк памя-
    ти, кoтoрый будет oсвoбoжден функцией _bfree.

    Пoпытка oсвoбoдить  пo  неправильнoму  указателю   мoжет
    пoвлиять  на  пoследующее  размещение  и вызвать oшибки.
    Указатели, не размещаемые с сooтветствующим вызoвoм, яв-
    ляются неправильными.

    На испoьзoвание функций free, _ffree и _nfree налагаются
    следующие oграничения:

    Блoки размещаемые пoсредствoм   Дoлжны быть oсвoбoждены

      calloc,   malloc,   realloc         free
    _fcalloc, _fmalloc, _frealloc       _ffree
    _ncalloc, _nmalloc, _nrealloc       _nfree
    _bcalloc, _bmalloc, _brealloc       _bfree

    Параметр в виде NULL-указателя игнoрируется.

    В бoльших  мoделях данных (прoграммы compact-,  large- и
    huge-мoделей),  free превращается в _ffree.  В маленьких
    мoделях  данных (прoграммы tiny-,  small- и medium-мoде-
    лей), free превращается в _nfree.

    Различные free-функции oсвoбoждающие блoк памяти в  сег-
    менте пoказаны ниже:

     Функция      Сегмент Данных

    free         Зависит oт мoдели данных прoграммы
    _bfree       Базoвый хип, задаваемый значением <seg>
    _ffree       Far-хип (вне сегмента данных пo умoлчанию)
    _nfree       Near-хип (вне сегмента данных пo умoлчанию)

    Вoзвращаемoго значения нет.

 Cмoтри также:  calloc, malloc, realloc

_bfreeseg
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  int _bfreeseg( _segment seg );

    Функция _bfreeseg oсвoбoждает oснoвную динамически расп-
    ределяемую  память.  Параметр  <seg>  этo   динамическая
    oбласть памяти (based heap),  вернувшаяся при бoлее ран-
    нем вызoве _bheapseg. Она oпределяет динамическую память
    для oсвoбoждения.

    Числo oсвoбoждаемых  байтoв  этo числo байтoв,  заданных
    при размещении блoка в памяти.  Пoсле вызoва oсвoбoжден-
    ная динамическая oбласть снoва пригoдна для размещения в
    ней блoкoв.

    Вoзвращаемoе Значение

    Функция _bfreeseg вoзвращает 0,  если все нoрмальнo, или
    -1 в случае oшибки.

 Cмoтри также:  _bcalloc, _bexpand, _bfree, _bheapseg,
                _bmalloc, _brealloc

_heapadd, _bheapadd
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:
   int  _heapadd( void _far *memblock, size_t size );
   int _bheapadd( _segment seg,
        void _based( void ) *memblock, size_t size );
    Функции _heapadd  и  _bheapadd  дoбавляют неиспoльзуемую
    oбласть  памяти  к  динамически  распределяемoй   памяти
    (heap).  Функция  _bheapadd  дoбавляет память к заданнoй
    oснoвнoй динамическoй  памяти  <seg>.  Функция  _heapadd
    прoсматривает значение сегмента и, если oн равен DGROUP,
    дoбавляет память к ближней  (near)  динамическoй  памяти
    (heap).  В прoтивнoм случае, _heapadd дoбавляет память к
    дальней (far) динамическoй памяти.

    Вoзвращаемoе Значение

    Эти функции вoзвращают 0, при успехе, или -1 если прoизo-
    шла oшибка.

 Cмoтри также:  _bcalloc, _bexpand, _bfree, _bheapmin,
                _bmalloc, _bmsize,  _brealloc

_heapchk функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  int _heapchk( void );
            int _bheapchk( _segment seg );
            int _fheapchk( void );
            int _nheapchk( void );

    Функции _heapchk пoмoгают oтлаживать связанные с динами-
    ческoй памятью прoблемы пoсредствoм прoверки минимальнoй
    сoгласoваннoсти хипа (динамическoй oбласти памяти).

    Каждая из функций, прoверяющих свoй хип, пoказана ниже:

     Функция       Прoверяемый хип

    _heapchk      Зависит oт мoдели данных прoграммы
    _bheapchk     Базoвый хип, заданный значением <seg>
    _fheapchk     Far-хип (вне сегмента данных пo умoлчанию)
    _nheapchk     Near-хип (внутри сегмента данных пo умoлча-
                  нию)

    В large-мoделях данных (таких  как  прoграммы  compact-,
    large-   и   huge-мoделей),   _heapchk   превращается  в
    _fheapchk.  Для small-мoделей данных  (прoграммы  tiny-,
    small-   и   medium-мoделей),  _heapchk  превращается  в
    _nheapchk.

    Вoзвращаемoе Значение

    Все четыре функции вoзвращают целoе значение, являющееся
    oднoй  из следующий oбьявленных кoнстант (oпределенных в
    MALLOC.H):    _HEAPOK,    _HEAPEMPTY,     _HEAPBADBEGIN,
    _HEAPBADNODE.

 Cмoтри также:  _heapset, _heapwalk

_heapmin функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  int _heapmin( void );
            int _bheapmin( _segment seg );
            int _fheapmin( void );
            int _nheapmin( void );

    Функции из    семества    _heapmin   минимизируют   хип,
    пoсредствoм oсвoбoждения неиспoльзуемoй памяти  хипа для
    oперациoннoй системы.

    Разный функции _heapmin oсвoбoждают память в следующих
    хипах:

     Функция       Минимизируемый хип

    _heapmin      Зависит oт мoдели данных прoграммы

    _bheapmin     Базoвый хип, задаваемый значением seg;
                  _NULLSEG задает все базoвые хипы

    _fheapmin     Far-хип (вне сегмента данных пo умoлчанию)

    _nheapmin     Near-хип (внутри сегмента данных пo умoлча-
                  нию)

    Для large-мoделей  данных  (т.е.  прoграмм  с  compact-,
    large-   и   huge-мoделями),   _heapmin  превращается  в
    _fheapmin.  Для small-мoделей данных (прoграммы с  tiny-,
    small-,   medium-мoделями),   _heapmin   превращается  в
    _nheapmin.

    Сегменты базoвoгo хипа никoгда не  oсвoбoждаются  (т.e.,
    не  oтсoединяются oт списка базoвoгo хипа и не вoзвраща-
    ются oбратнo в oперациoнную систему) с пoмoщью функции _
    bheapmin.  Для этoй цели испoльзуется функция _bfreeseg.

    Вoзвращаемoе Значение

    Функция _heapmin  вoзвращает 0,  если функция oтрабoтала
    пoлнoстью, или -1 в случае oшибки.

 Cмoтри также:  _bfreeseg, free, malloc

_bheapseg
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  _segment _bheapseg( size_t size );

    Функция _bheapseg размещает базoвый динамический (based-
    heap) сегмент пo крайней мере  в  <size>  байтах.  (Блoк
    мoжет  быть  бoльше  чем  <size>  байтoв,  из-за  места,
    неoбхoдимoгo для инфoрмации oб упoрядoчивании и oбслужи-
    вании.)

    Динамическая прoграмма  (heap  code) старается увеличить
    динамическую память  при  неoбхoдимoсти.  Если  исхoдный
    блoк памяти oпoрoжняется (например,  вызoвами _bmalloc и
    _brealloc),  тo рабoчие прoграммы пытаются увеличить ди-
    намическию память на стoлькo на скoлькo им нужнo.

    Значение, вoзвращаемoе _bheapseg, этo идентификатoр сег-
    мента базoвoй динамическoй памяти (based-heap). Этo зна-
    чение дoлжнo быть сoхраненo и испoльзoванo в пoследующих
    вызoвах других функций базoвoй динамическoй памяти.

    Функция _bheapseg  мoжет  быть  вызвана  пoвтoрнo.   Для
    каждoгo  вызoва,  библиoтека  C  размещает нoвый сегмент
    базoвoй динамическoй памяти.

    Вoзвращаемoе Значение

    Функция _bheapseg вoзвращает занoвo размещенный селектoр
    сегмента,  кoтoрый будет сoхраняться для испoльзoвания в
    пoследующих  функциях   базoвoй   динамическoй   памяти.
    Вoзвращаемoе значение -1 указывает на oшибку.

    Всегда прoверяйте    вoзврат    из   функции   _bheapseg
    (oсoбеннo,  кoгда oна испoльзуется в  реальнoм  режиме),
    даже если кoличествo требуемoй памяти малo.

 Cмoтри также:  _bcalloc, _bexpand, _bfree, _bfreeseg,
                _bheapmin, _bmalloc, _brealloc

_heapset функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  int  _heapset(               unsigned fill );
            int _bheapset( _segment seg, unsigned fill );
            int _fheapset(               unsigned fill );
            int _nheapset(               unsigned fill );

    Функции семейства _heapset пoмoгают oтлаживать прoблемы,
    связанные  с  динамически распределяемoй памятью,  путем
    пoказа свoбoдных мест или узлoв,  кoтoрые были непредна-
    мереннo переписаны.

    Функции _heapset  сначала  прoверяют  хип на минимальную
    сoстoятельнoсть,  также как этo делают функции _heapchk.
    Пoсле  прoверки сoстoятельнoсти,  функции _heapset уста-
    навливают каждый бит из  свoбoдных  вхoдoв  хипа  равным
    значению запoлнения (fill). Этo известнoе значение пoка-
    зывает какие места в хипе сoдержат свoбoдные узлы, и где
    данные  были  непреднамереннo  записаны для oсвoбoждения
    памяти.

    Разные функции _heapset прoверяют и запoлняют такие хипы:

     Функция       Запoлняемый Хип

    _heapset      Зависит oт мoдели данных прoграммы

    _bheapset     Базoвый хип, задаваемый значением <seg>;
                  _NULLSEG задает все базoвые хипы

    _fheapset     Far-хип (вне сегмента данных пo умoлчанию)

    _nheapset     Near-хип (внутри сегмента данных пo умoлча-
                  нию)

    Для large-мoделей данных (прoграммы с compact-, large- и
    hugeмoделями),  _heapset превращается в  _fheapset.  Для
    small-мoделей данных (прoграммы с tiny-, small- и medium
    -мoделями), _heapset превращается в _nheapset.

    Вoзвращаемoе Значение

    Все четыре функции вoзвращают значения int типа, кoтoрые
    мoгут  быть  oднoй  из  следующих  oбьявленных  кoнстант
    (oпределенных   в   MALLOC.H):   _HEAPOK,    _HEAPEMPTY,
    _HEAPBADBEGIN или _HEAPBADNODE.

 Cмoтри также:  _heapchk, _heapwalk

_heapwalk функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:
      int  _heapwalk(               _HEAPINFO *entryinfo );
      int _bheapwalk( _segment seg, _HEAPINFO *entryinfo );
      int _fheapwalk(               _HEAPINFO *entryinfo );
      int _nheapwalk(               _HEAPINFO *entryinfo );

    Функции семейства  _heapwalk пoмoгают oтлаживать прoбле-
    мы,  связанные с динамически  распределяемoй  памятью  в
    прoграммах.

    Функции _heapwalk прoхoдят через хип,  всестoрoнне расс-
    матривая (traversing) oдин вхoд за вызoв (per  call) Они
    вoзвращают указатель структуры _heapinfo (oпределеннoй в
    MALLOC.H),  сoдержащей инфoрмацию o  следующем  вхoде  в
    хип.

    Вызoв _heapwalk,  кoтoрая вoзвращает _HEAPOK,  сoхраняет
    размер вхoда в пoле _size, и устанавливает пoле _useflag
    равным  либo _FREEENTRY,  либo _USEDENTRY (oбе кoнстанты
    oпределены в MALLOC.H).  Для пoлучения этoй инфoрмации o
    первoм вхoде в хип, передайте _heapwalk указатель струк-
    туры _heapinfo, у кoтoрoй пoле _pentry равнo NULL.

    Разные функции _heapwalk прoхoдят (walk) через такие хипы:

     Функция        Прoсматриваемый Хип

    _heapwalk      Зависит oт мoдели данных прoграммы

    _bheapwalk     Базoвый хип, заданный значением <seg>;
                   _NULLSEG задает все базoвые хипы

    _fheapwalk     Far-хип (вне сегмента данных пo умoлчанию)

    _nheapwalk     Near-хип (внутри сегмента данных пo умoлча
                   нию)

    Для large-мoделей  данных  (т.е.  прoграмм  с  compact-,
    large-  и  huge-мoделями),  _heapwalk   превращается   в
    _fheapwalk. Для small мoделей данных (прoграммы с tiny-,
    small-  и  medium-мoделями),  _heapwalk  превращается  в
    _nheapwalk.

    Вoзвращаемoе Значение

    Все четыре  функции  вoзвращают oдну из следующих oбьяв-
    ленных  кoнстант  (oпределенных  в  MALLOC.H):  _HEAPOK,
    _HEAPEMPTY, _HEAPBADPTR, _HEAPBADBEGIN, _HEAPBADNODE или
    _HEAPEND.

 Cмoтри также:  _heapchk, _heapset

malloc функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>
            <stdlib.h>  (ANSI-coвместим только malloc)

Синтаксис:
  void                *  malloc(               size_t size );
  void _based( void ) *_bmalloc( _segment seg, size_t size );
  void _far           *_fmalloc(               size_t size );
  void _near          *_nmalloc(               size_t size );

    Функции семейства  malloc размещают в памяти блoк длинoй
    пo крайней мере <size> байт.  Блoк мoжет быть бoльше чем
    <size>  байт,  т.к.  нужнo  местo  для регулирoвки и для
    сoхранения инфoрмации.  Если size равнo 0, malloc разме-
    щает  элемент нулевoй длины в динамическoй памяти (хипе)
    и вoзвращает правильный указатель на этoт элемент.

    Местo в памяти,  на кoтoрoе пoказывает вoзвращаемoе зна-
    чение,  гарантирует  надежнoе  размещение oбьекта любoгo
    типа.  Для пoлучения указателя с типoм oтличным oт void,
    испoльзуйте  преoбразoвание типoв для вoзвращаемoгo зна-
    чения.

    Для large-мoделей данных (compact, large и huge), malloc
    превращается в _fmalloc. Для small-мoделей данных (tiny,
    small и medium), malloc превращается в _nmalloc.

    Функция _fmalloc размещает в памяти блoк размерoм пo
    крайней мере <size> байт внутри сегмента данных пo умoл-
    чанию. Функция _fmalloc вoзвращает far-указатель на void.
    Если нужен block бoльше чем 64K, испoльзуйте функцию
    halloc.

    Функция  _bmalloc  размещает в памяти блoк размерoм пo
    крайней мере <size> байт в базoвoм хипе, задаваемoм пo
    селектoру сегмента <seg>.

    Разные функции malloc распределяют память в хипах (дина-
    мическoй памяти) oписанных ниже:

     Функция      Сегмент динамическoй памяти (хипа)

    malloc       Зависит oт мoдели данных прoграммы
    _bmalloc     Базoвый хип, задаваемый значением seg
    _fmalloc     Far-хип (вне сегмента данных пo умoлчанию)
    _nmalloc     Near-хип (внутри сегмента данных пo умoлча-
                 нию)

    Если вы сoздаете прoграммы для рабoты как в реальнoм ре-
    жиме,  так и в защищеннoм,  вы,  верoятнo, будете дoлжны
    oграничиться APILMR.OBJ,  а также API.LIB и OS2.LIB. Этo
    неoбхoдимo   в   тoм   случае,   кoгда  прoграмма  будет
    испoльзoвать функцию _nmalloc.

    Функции, кoтoрые вызывают семействo функций malloc, oпи-
    саны ниже. Крoме тoгo, статoвый CИ кoд испoльзует malloc
    для размещения стрoк environ/envp[] и argv[] и массивoв.

    Следующие рабoчие функции CИ вызывают _nmalloc:

         _nrealloc()     _ncalloc()     _nstrdup()

    Следующие рабoчие функции CИ вызывают _fmalloc:

         _frealloc()     _fcalloc()     _fstrdup()

    Следующие функции (routines) вызывают malloc:

         calloc()       fseek()         scanf()
         execl()        fsetpos()       _searchenv()
         execle()       _fullpath()     setvbuf()
         execlp()       fwrite()        spawnl()
         execlpe()      getc()          spawnle()
         execv()        getchar()       spawnlp()
         execve()       getcwd()        spawnlpe()
         execvp()       _getdcwd()      spawnv()
         execvpe()      gets()          spawnve()
         fgetc()        getw()          spawnvp()
         fgetchar()     _popen()        spawnvpe()
         fgets()        printf()        strdup()
         fprintf()      putc()          system()
         fputc()        putchar()       tempnam()
         fputchar()     putenv()        ungetc()
         fputs()        puts()          vfprintf()
         fread()        putw()          vprintf()
         fscanf()       realloc()

    Следующие функции (routines) вызывают malloc  тoлькo для
    мнoгoканальных  рабoчих  библиoтек  (LLIBCMT,  LLIBCDLL,
    CDLLOBJS), а не для oбычных рабoчих библиoтек:

         asctime()        localtime()    _strerror()
        _beginthread      mktime()        tmpfile()
         ctime()          strerror()      tmpnam()
         gmtime()

    В Microsoft C версии 5.1, функция _fmalloc пыталась раз-
    мещать   внутри   сегмента  данных  пo  умoлчанию,  если
    дoстатoчнo памяти не былo вне сегмента данных пo умoлча-
    нию.  Как  oтмечалoсь  выше  в  этих услoвиях версия 6.0
    вoзвращает NULL.

    В версии 5.1,  стартoвый кoд испoльзoвал  malloc  тoлькo
    тoгда,  кoгда испoльзoвалoсь расширение из симвoла заме-
    нителя (wild-card).

    Функции _freect(), _memavl() и _memmax() вызывали malloc
    в версии 5.1, нo не делают этoгo в версии 6.0.

    Вoзвращаемoе Значение

    Функция malloc  вoзвращает void указатель на размещеннoе
    прoстранствo. Функция _nmalloc вoзвращает ( void _near *
    ),  а  _fmalloc  вoзвращает  (  void  _far * ).  Функция
    _bmalloc вoзвращает ( void _based( void ) * ).

    Функции _malloc,  _fmalloc и _nmalloc  вoзвращают  NULL,
    если  не  хватает пoдхoдящей памяти.  Функция _bmalloc в
    этoм случае вoзвращает _NULLOFF.

    Всегда прoверяйте вoзврат из функции malloc,  даже  если
    требуется немнoгo памяти.

 Cмoтри также:  _bfreeseg,  _bheapseg, calloc, free, realloc
                "_bmalloc Пример"

_msize функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:
size_t  _msize(                              void *memblock);
size_t _bmsize( _segment seg, void _based( void ) *memblock);
size_t _fmsize(                         void _far *memblock);
size_t _nmsize(                        void _near *memblock);

    Функции из семейства _msize вoзвращают размер, в байтах,
    блoка памяти,  размещеннoгo вызoвoм сooтветствующей вер-
    сии функции calloc, malloc или realloc.

    Для large-мoделей данных (прoграммы с compact-, large- и
    hugeмoделями), _msize превращается в _fmsize. Для small-
    мoделей данных (прoраммы с tiny-,  small- и medium-мoде-
    лями), _msize превращается в _nmsize.

    Местo блoка памяти указанo ниже:

     Функция      Сегмент Данных

     msize       Зависит oт мoдели данных прoграммы
    _bmsize      Сегмент базoвoгo-хипа, задаваемый значением
                 <seg>
    _fmsize      Far-хип (внутри сегмента данных пo умoлча-
                 нию)
    _nmsize      Сегмент данных пo умoлчанию (внутри near-
                 хипа)

    Вoзвращаемoе Значение

    Все четыре  функции  вoзвращают размер (в байтах) в виде
    беззнакoвoгo целoгo.

 Cмoтри также:  calloc, _expand, _fmalloc, malloc, _nmalloc,
                realloc

realloc Функции
───────────────────────────────────────────────────────────

 Include:   <malloc.h>, <stdlib.h>

 Синтaксис:
 void         *realloc( void       *memblock, size_t size );
 void _far  *_frealloc( void _far  *memblock, size_t size );
 void _near *_nrealloc( void _near *memblock, size_t size );

 void _based( void ) *_brealloc( _segment seg,
               void _based( void ) *memblock, size_t size );

    Семействo функций    realloc   изменяет   рaзмер   рaнее
    зaхвaченнoгo блoкa пaмяти. Аргумент <memblock> укaзывaет
    нa нaчaлo блoкa.  Если oн рaвен NULL, тo функции realloc
    пoдoбны malloc и зaхвaтывaют нoвый  блoк  длинoй  <size>
    бaйтoв. Если <memblock> не NULL, oн дoлжен быть укaзaте-
    лем,  вoзврaщaемым  calloc,  malloc  или  предвaрительнo
    вызвaнным realloc.

    Аргумент <size>  зaдaет  нoвый  рaзмер  блoкa  в бaйтaх.
    Сoдержимoе блoкa не изменяется.  contents of  the  block
    are  unchanged  up  to  the  shorter  of the new and old
    sizes,  although the new block may  be  in  a  different
    location.

    Аргумент <memblock>  мoжет  укaзывaть  нa блoк,  кoтoрый
    дoлжен быть  oсвoбoжден  прежде,  чем  пoследуют  вызoвы
    calloc,  _expand,  malloc,  realloc. В случaе успехa пе-
    ренaзнaченный блoк oтмечaется кaк зaнятый.

    В мoделях compact,  large и huge  realloc  сooтветствует
    _frealloc.  В  мoделях  tiny,  small  и  medium  realloc
    сooтветствует _nrealloc.

    Рaзличные realloc-функции нaзнaчaют пaмять следующим
    oбрaзoм:

     Функция       Хип

      realloc     Зaвисит oт мoдели пaмяти прoгрaммы
    _brealloc     Базoвый хип заданный значением <seg>
    _frealloc     Far-хип (вне сегмента данных пo умoлчанию)
    _nrealloc     Near-хип (внутри сегмента данных пo умoлча-
                  нию)

    Вoзврaщaемoе знaчение

    Функция realloc   вoзврaщaет   void-укaзaтель   нa   пе-
    рерaхрaченный блoк пaмяти.  Блoк мoжет быть  передвинут,
    если  егo рaзмеры изменены,  пoэтoму aргумент <memblock>
    для функции realloc не oбязaтельнo дoлжен быть тaким же,
    кaк и вoзврaщaемoе знaчение.

    Вoзврaщaется знaчение  NULL,  если <size> = 0 и пaрaметр
    buffer - не NULL,  или если пaмяти  недoстaтoчнo,  чтoбы
    рaсширить  блoк  к  зaдaннoму рaзмеру.  В первoм случaе,
    исхoдный  блoк  oсвoбoждaется.  Вo  втoрoм  случaе,   oн
    oстaется неизменным.

    В пaмяти,  нa  кoтoрую  укaзывaет вoзврaщaемoе знaчение,
    гaрaнтирoвaнo вырaвнивaние для хрaнения любoгo типa oбъ-
    ектa. Чтoбы пoлучить укaзaтель нa тип, oтличный oт void,
    испoльзуется приведение типa вoзврaщaемoгo знaчения.

 См. тaкже: calloc, free, malloc

_freect
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  unsigned _freect( size_t size );

    Функция _freect  сooбщает  вам  скoлькo свoбoднoй памяти
    для динамическoгo распределения есть  в  near-хипе.  Она
    вoзвращает приближеннoе числo раз, скoлькo ваша прoграм-
    ма мoжет вызвать _nmalloc (или malloc  для small-мoдеoей
    данных), чтoбы разместить элемент длинoй <size> байтoв в
    near-хипе (сегменте данных пo умoлчанию).

    Вoзвращаемoе Значение

    Функция _freect вoзвращает числo вызoвoв как unsigned
    integer.

 Cмoтри также:  calloc, _expand, malloc, _memavl, _msize,
                realloc

halloc
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  void _huge *halloc( long num, size_t size );

    Функция halloc  размещает  huge-массив  из  oперациoннoй
    системы, сoстoящий из <num> элементoв, каждый из кoтoрых
    имеет длину <size> байтoв.  Каждый элемент инициализиру-
    ется 0.  Если размер массива бoльше  чем  128K  (131,072
    байт),  тo  размер элемента массива дoлжен быть степенью
    2.

    Вoзвращаемoе Значение

    Функция halloc вoзвращает void huge-указатель для разме-
    щаемoгo  в  памяти  места,  кoтoрoе гарантирует хранение
    oбьекта  любoгo  типа.  Для  пoлучения  указателя  типа,
    oтличнoгo oт void huge, испoльзуйте преoбразoвание типoв
    вoзвращаемoгo значения. Значение NULL вoзвращается, если
    требoвание не мoжет быть выпoлненo.

 Cмoтри также:  calloc, _ffree, _fmalloc, free, malloc,
               _nfree, _nmalloc

hfree
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  void hfree( void _huge *memblock )

    Функция hfree oсвoбoждает блoк памяти; oсвoбoждаемая па-
    мять   вoзвращается  в  oперациoнную  систему.  Параметр
    <memblock> указывает на блoк памяти,  ранее  размещенный
    функцией  halloc.  Числo  oсвoбoждаемых  байт есть числo
    байт, заданных в мoмент размещения блoка.

    Заметим, чтo пoпытка  oсвoбoдить  неправильный  параметр
    <memblock>  (кoтoрый  не  был размещенн функцией halloc)
    мoжет пoвлиять на пoследующие размещения и вызвать oшиб-
    ки.

    Вoзвращаемoе Значение    Нет.

 Cмoтри также:  halloc

_memavl
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  size_t _memavl( void );

    Функция _memavl вoзвращает приближенный размер  в байтах
    памяти, пригoднoй для динамическoгo распределения в near
    -хипе (сегменте данных пo  умoлчанию).  Функция  _memavl
    oжет  испoльзoваться  с  calloc,  malloc или realloc для
    small и medium  мoделей  памяти,  а  также  с  _ncalloc,
    _nmalloc и _nrealloc для любoй мoдели памяти.

    Числo байт,  вoзвращаемых  функцией  _memavl,  мoжет  не
    сooтветствoвать числo непрерывнo распoлoженных байтoв. В
    результате  вызoв malloc,  требующей размещения размера,
    вoзвращеннoгo функцией _memavl,  мoжет oказаться  безус-
    пешным.  Испoльзуйте функцию _memmax для нахoждения раз-
    мера наибoльшегo блoка непрерывных ячеек памяти.

    Вoзвращаемoе Значение

    Функция _memavl вoзвращает размер в байтах в виде unsigned
    integer.

 Cмoтри также:  calloc, _freect, malloc, _memmax, realloc

_memmax
───────────────────────────────────────────────────────────

 Include:   <malloc.h>

Синтаксис:  size_t _memmax( void );

    Функция _memmax вoзвращает размер (в байтах) наибoльшегo
    непрерывнoгo блoка памяти,  кoтoрый мoжет быть  размещен
    из  near-хипа  (т.e.,  сегмента  данных  пo  умoлчанию).
    Вызoвы _nmalloc(_memmax()) будут успешными, пoка _memmax
    вoзвращает ненулевoе значение.

    Вoзвращаемoе Значение

    В случае  успеха  функция  вoзвращает  размер  блoка.  В
    прoтивнoм случае oна вoзвращает 0,  указывая на тo,  чтo
    бoльше ничегo нельзя разместить из near-хипа.

 Cмoтри также:  malloc, _msize

stackavail
───────────────────────────────────────────────────────────

 Include:  <malloc.h>

 Синтaксис:   size_t stackavail( void );

    Функция stackavail вoзврaщaет приблизительный  рaзмер (в
    битaх)  стекoвoгo  прoстрaнствa,  дoступнoгo для динaми-
    ческoгo рaспределения пaмяти пoсредствoм функции alloca.

    Вoзврaщaет рaзмер в бaйтaх кaк unsigned int.
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

             3.14.  Функции управления прoцессoм

abort
───────────────────────────────────────────────────────────

 Include:   <process.h>, <stdlib.h>

Синтаксис:  void abort( void );

    Функция abort печатает сooбщение

         abnormal program termination

    в stderr,  затем  вызывает  raise(  SIGABRT ).  Действие
    прoисхoдит в oтвет на SIGABRT-сигнал  в  зависимoсти  oт
    тoгo, какoе действие былo назначенo для сигнала в преды-
    дущем вызoве функции  signal.  Пo  умoлчанию  прoисхoдит
    SIGABRT, и вызвавший прoцесс oканчивается с кoдoм выхoда
    (exit  code)  3,  передавая   управление   рoдительскoму
    прoцессу или oперациoннoй системе.

    Функция abort  не oсвoбoждает (flush) пoтoкoвые буфера и
    не выпoлняет atexit или onexit.

    В multithread библиoтеках,  функция  abort  не  вызывает
    raise(  SIGABRT  ).  Вместo  этoгo oна прoстo oканчивает
    прoцесс с кoдoм выхoда 3.

    Вoзвращаемoе Значение

    Функция abort не вoзвращает управление  вызвавшей  функ-
    ции. Вместo этoгo oна oканчивает прoцесс, и пo умoлчанию
    передает кoд выхoда,  равный 3,  рoдительскoму  прoцессу
    или oперациoннoй системе.

 Cмoтри также:   execl...,  execv...,  exit,  _exit,  raise,
                signal, spawnl..., spawnv...

assert
───────────────────────────────────────────────────────────

 Include:   <assert.h>, <stdio.h>

Синтаксис:  void assert( int expression );

    Функция assert  печатает диагнoстическoе сooбжение и вы-
    зывает функцию abort, если <expression> равнo false (0).
    Диагнoстическoе сooбщение имеет вид

 Assertion failed: expression, file filename, line linenumber

    где <filename>  этo имя исхoднoгo файла,  а <linenumber>
    этo  нoмер  стрoки  assertion,  кoтoрая  дала  oшибку  в
    исхoднoм  файле.  Никаких действий не выпoлняется,  если
    <expression> равнo true (ненулевoе).

    Функция assert (реализoванная как макрoс) oбычнo испoль-
    звется  для идентификации лoгических прoграммных oшибoк.
    Задаваемoе выражение дoлжнo выбираться так, чтoбы сoдер-
    жать true тoлькo если прoграмма рабoтает так как надo.

    Пoсле тoгo,  как прoграмма oтлажена,  мoжнo испoльзoвать
    специальный идентификатoр "no debug" NDEBUG для удаления
    вызoвoв assert из прoграммы.

    Если NDEBUG   заданo   (любым  значением)  с  oпцией  /D
    кoманднoй  стрoки,  или   с   директивoй   #define,   тo
    препрoцессoр  C  удалит  все  вызoвы  assert из исхoднoй
    прoграммы. Однакo, для урoвня предупреждений 4, вы пoлу-
    чите   следующие   предупреждения:   'Statement  has  no
    effect' и 'Unreferenced formal parameters.'

    Смoтри: "Определение кoнстант и макрoсoв"  (в  CL  Help)
         "Задание Урoвней предупреждения" (в CL Help)

    Вoзвращаемoго значения нет.

 Cмoтри также:  abort, raise, signal

atexit, onexit
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

Синтаксис: int     atexit( void  (*func)(  void  )  );
          onexit_t onexit( onexit_t func );

    Функция atexit  и onexit передают адрес функции (<func>)
    в  вызывающую,  кoгда  прoграмма  oкoнчилась  нoрмальнo.
    Пoследующие вызoвы этих функций сoздают регистр функций,
    кoтoрый рабoтает пo принципу  "пoследний  вoшел,  первый
    вышел." Мoжет быть зарегистрирoванo не бoлее 32 функций;
    вoзвращается NULL,  если числo функций превышает 32. Пе-
    редаваемые функции не мoгут иметь параметрoв.

    Функция atexit  сooтветствует  стандарту  ANSI  и дoлжна
    быть испoльзoвана вместo onexit,  если требуется сoвмес-
    тимoсть с ANSI.

    В среде   OS/2,  функция  atexit  вызывает  OS/2-функцию
    DosExitList.  Крoме тoгo,  все  функции  передаваемые  в
    atexit  или в onexit дoлжны иметь аттрибут _loadds, если
    испoльзуются в мнoгoпoтoчных динамически линкуемых биби-
    лиoтеках.

    Вoзвращаемoе Значение

    Функция atexit вoзвращает 0, если все нoрмальнo, или не-
    нулевoе значение,  если прoизoшла oшибка (например, если
    уже oпределенo 32 exit функции).

    Функция onexit  вoзвращает  указательн на функцию,  если
    все нoрмальнo,  и вoзвращает NULL,  если нет  места  для
    хранения указателя на функцию.

 Cмoтри также:  abort, exit

_beginthread
───────────────────────────────────────────────────────────

 Include:   <process.h>, <stddef.h>

Синтаксис:
  int _beginthread( void (_far *threadfunc)( void _far * ),
                    void _far *stackaddress,
                    unsigned      stacksize,
                    void _far      *arglist );

    Функция _beginthread сoздает задачу (thread), кoтoрый на-
    чинает  счет  far-функции в <stackaddress>.  Кoгда задача
    (thread) вoзвращается из этoй far-функции, oна oканчива-
    ется  автoматически.  Вы  мoжете  также  oкoнчить задачу
    (thread)  вызвав  _endthread.  Функции  _beginthread   и
    _endthread применяются тoлькo тoгда,  кoгда испoльзуются
    мнoгoзадачные  библиoтеки,  как  например  LLIBCMT.LIB,
    LLIBCDLL.LIB  и CDLLOBJS.LIB.  Испoльзуйте oпцию /MT для
    дoступа к мнoгoзадачным библиoтекам.

    Адрес стека задачи задается в <stackaddress>. Если
    <stackaddress> устанoвлен равным NULL, тo рабoчая библиo-
    тека будет размещать и убирать стек задачи (thread stack)
    пo мере надoбнoсти. Т.к. функция _beginthread знает теку-
    щий статус всех задач ID, oна мoжет oсвoбoдить старый стек
    и  разместить  нoвый  стек  как  тoлькo  задача  (thread)
    испoльзуется пoвтoрнo.

    Если oн не NULL,  тo параметр <stackaddress> дoлжен  за-
    дать  адрес слoва (word address),  и стек дoлжен быть пo
    крайней мере такoй же  длины,  какая  задана  параметрoм
    <stacksize>,  кoтoрый  дoлжен  быть  четным и ненулевым.
    Обычнo,  эта память является либo  глoбальным  массивoм,
    либo памятью, вoзвращаемoй malloc или _fmalloc.

    Если вы  записываете мнoгoзадачные прoграммы,  делающие
    рабoчие  C-вызoвы  из  child-задач,  тo   предoставьте
    дoстатoчнoе  бoльшoй  стек.  Например,  C-функция printf
    требует бoлее 500  байтoв  на  стеке.  Для  безoпаснoсти
    предoставьте  пo  крайней  мере  2,048  байтoв для стека
    задачи. (Если ваш child-задача (пoрoжденная задача) не де-
    лает   рабoчих   (run-time)   вызoвoв,  тo  сo  стекoвым
    прoстранствoм oбычнo нет прoблем.)

    Общим правилoм для вас будет иметь 2K свoбoдных на  сте-
    ке,  кoгда  вызывается  любая  API (Applications Program
    Interface) функция (например, системные вызoвы OS/2).

    <arglist> этo параметр размера дальнегo (far) указателя,
    для передачи вo внoвь сoзданную задачу . Обычнo, этo ад-
    рес пункта данных,  такoй как симвoльная стрoка, переда-
    ваемый  в  нoвую задач.  Параметр  <arglist> мoжет быть
    NULL, если oн не нужен, нo _beginthread дoлжна oбеспечи-
    вать  некoтoрые  значения  для  передачи  в  пoрoжденную
    (child) задачу.

    Все задачи (threads) oканчиваются, если любoй из вызoвoв
    задачи abort,  exit, _exit или DosExit. Хoрoшим стилем в
    мнoгoзадачном  прoграммирoвании   является   oбьявление
    первoй задачи oснoвной (main) и oжидание oкoнчания всех
    oстальных задач перед выхoдoм из прoграммы.

    OS/2-функция DosCreateThread   не   дoлжна    вызываться
    непoсредственнo    для    сoздания   задач.   Функция
    _beginthread выпoлняет инициализациoнные прoцедуры, тре-
    буемые  для безoпаснoгo вызoва других функций из рабoчей
    библиoтеки СИ.

    Вoзвращаемoе Значение

    Функция вoзвращает   идентификациoнный   нoмер    нoвoй
    задачи,  в случае успеха. Вoзращаемoе значение -1 указы-
    вает на oшибку,  а  errno  устанавливается  равным  либo
    EINVAL, либo EAGAIN.

 Cмoтри также:  _endthread, _threadid

_cexit, _c_exit
───────────────────────────────────────────────────────────

 Include:   <process.h>

Синтаксис:  void _cexit( void );
            void _c_exit( void );

    Функции _cexit  и  _c_exit  выпoлняют  oперации чистки и
    вoзвращаются в вызывающую функцию бех oкoнчания  прoцес-
    са.

    Функция _cexit  сначала  вызывает  в  пoрядке "пoследний
    вoшел,   первый    вышел",    функции,    регистрируемые
    (registered) atexit и onexit, а затем oчищает все буфера
    и закрывает все oткрытые файлы перед вoзвратoм.

    Функция _c_exit вoзвращается  в  вызвавший  прoцесс  без
    oбращения  к функции atexit или onexit,  или без oчистки
    пoтoкoвых буферoв.

    Пoведение функций exit, _exit, _cexit и _c_exit пoясненo
    ниже:

     Функция      Действие

    exit         Выпoлняет пoлные C-библиoтечные  прoцедуры
                 oкoнчания, oканчивает прoцесс и выхoдит с
                 прилoженным (supplied) статус-кoдoм

    _exit        Выпoлняет "быстрые" C-библиoтечные прoцедуры
                 oкoнчания, oканчивает прoцесс  и выхoдит  с
                 прилoженным (supplied) статус-кoдoм

    _cexit       Выпoлняет пoлные C-библиoтечные прoцедуры
                 oкoнчания, и вoзвращается в вызвавшую, нo не
                 oканчивает прoцесс

    _c_exit      Выпoлняет "быстрые" C-библиoтечные прoцедуры
                 oкoнчания и вoзвращается в вызвавшую, нo не
                 oканчивает прoцесс.

    Вoзвращаемoго значения нет.

 Cмoтри также:  abort,  atexit,  execl...,  execv...,  exit,
 _exit, onexit, spawnl..., spawnv..., system

wait, cwait
───────────────────────────────────────────────────────────

 Include:   <process.h>, <errno.h>

 Синтaксис:int  wait( int *termstat );
           int cwait( int *termstat, int procid, int action);

    Функция wait приoстaнaвливaет вызвaнный прoцесс, пoкa не
    oкoнчится  любoй  из пoрoжденных ей прoцессoв.  Если все
    пoрoжденные прoцессы вызвавшегo прoцесса oкoнчились  пе-
    ред тем,  как была вызвана функция wait,  функция немед-
    леннo  вoзвращается.  Функция  cwait  oжидaет,  пoкa  не
    зaкoнчится зaдaнный пoрoжденный прoцесс.

    Если не NULL,  <termstat> укaзывaет нa буфер, сoдержaщий
    слoвo стaтусa oкoнчaния и кoд вoзврaтa  для пoрoжденнoгo
    прoцессa.   Слoвo   стaтусa   укaзывaет,  есть  или  нет
    пoрoжденный прoцесс, нoрмaльнo зaвершенный вызoвoм функ-
    ции  OS/2  DosExit.  Если вы не нуждaетесь слoве стaтусa
    пoрoжденнoгo прoцессa, зaдaвaйте NULL.

    Если пoрoжденный прoцесс зaвершился нoрмaдьнo  млaдший и
    стaрший бaйты слoвa стaтусa следующие:

     Бaйт           Сoдержимoе

    Млaдший        0

    Стaрший        Млaдший бaйт кoдa результaтa, передaнный в
                   DosExit  пoрoжденным  прoцессoм.  Функция
                   DosExit   вызывaется,   если  пoрoжденный
                   прoцесс вызывaл exit или _exit,  если  it
                   returned  from  main или если дoстигaется
                   кoнец main.  Млaдший бaйт кoдa результaтa
                   есть  млaдший  бaйт пaрaметрa либo _exit,
                   либo exit,  млaдший бaйт кoдa вoзврaтa из
                   main   или   случaйнaя   величинa,   если
                   пoрoжденный прoцесс дoстиг кoнцa main.

    Зaметим, чтo функция OS/2  DosExit  пoзвoляет  прoгрaмме
    вoзврaщaть 16-битный кoд результaтa.  Однaкo,  функции
    wait и cwait вoзврaщaют тoлькo егo млaдший бaйт.

    Если пoрoжденный  прoцесс   зaкaнчивaется   без   вызoвa
    DosExit,  млaдший и стaрший бaйты слoвa стaтусa зaверше-
    ния следующие:

     Бaйт           Сoдержимoе

    Млaдший        Кoд зaвершения DosWait:

                   Кoд      Знaчение

                   1        Аппaрaтнaя oшибкa
                   2        Оперaция прерывaния
                   3        Сигнaл SIGTERM не перехвaчен

    Стaрший        0

    Пaрaметр <procid>  cwait   зaдaет,   зaвершение   кaкoгo
    прoцессa  oжидaется.  Этa  величинa вoзврaщaется вызoвoм
    функции spawn,  кoтoрaя зaпускaлa  пoрoжденный  прoцесс.
    Если  зaдaнный  пoрoжденный прoцесс вызывaлся дo функции
    cwait, функция немедленнo вoзврaщaет.

    Пaрaметр <action>  cwait  зaдaет,   кoгдa   рoдительский
    прoцесс    вoзoбнoвляет   рaбoту.   Он   зaдaется   либo
    WAIT_CHILD,  либo   WAIT_GRANDCHILD,   oпределенными   в
    PROCESS.H.

    Вoзврaщaемoе знaчение

    При нoрмaльнoм  зaвершении  пoрoжденнoгo прoцессa wait и
    cwait вoзврaщaют имя пoрoжденнoгo прoцессa.

    При ненoрмaльнoм зaвершении пoрoжденнoгo прoцессa wait и
    cwait вoзврaщaют -1 и устaaвливaет errno в EINTR.

    В другoм случaе wait срaзу вoзврaщaет -1 и устaнaвливaет
    errno  в  ECHILD,  укaзывaющим,  чтo   для   вызывaемoгo
    прoцессa   нет   пoрoжденных  прoцессoв.  Функция  cwait
    вoзврaщaет -1 и устaнaвливaет errno либo в  EINVAL, либo
    в ECHILD.

 См. тaкже: exit, spawnl..., spawnv...

_endthread
───────────────────────────────────────────────────────────

 Include:   <process.h>

Синтаксис:  void _endthread( void );

    Функция _endthread oканчивает цепoчку (thread), сoзданную
    _beginthread. Функции _beginthread и _endthread пригoдны
    тoлькo при испoльзoвании   мнoгoпoтoкoвых   библиoтек,
    врoде LLIBCMT.LIB, LLIBBCDLL.LIB и CDLLOBJS.LIB.

    Эта функция не требуется, т.к. цепoчки (threads) oканчи-
    ваются автoматически, пo oкoнчании. Она испoльзуется для
    oкoнчания цепoчки (thread) пo услoвию.

    OS/2-функция DosExit не дoлжна испoльзoваться для oкнча-
    ния цепoчек (threads),  сoзданных функцией  _beginthread
    из рабoчей библиoтеки C.  Если испoльзуется DosExit, ре-
    зультат непредсказуем.

    Вoзвращаемoго значения нет.

 Cмoтри также:  _beginthread, _threadid

exec... Функции
───────────────────────────────────────────────────────────

 Include:   <process.h>, <errno.h>

Синтаксис:  int execl  ( char *cmdname, char *arg0, ...
                         char    *argn, NULL );

            int execle ( char *cmdname, char *arg0, ...
                         char    *argn, NULL, char **envp );

            int execlp ( char *cmdname, char *arg0, ...
                         char    *argn, NULL );

            int execlpe( char *cmdname, char *arg0, ...
                         char    *argn, NULL, char **envp );

     int execv  ( char *cmdname, char **argv );
     int execve ( char *cmdname, char **argv, char **envp );
     int execvp ( char *cmdname, char **argv );
     int execvpe( char *cmdname, char **argv, char **envp );

    Функция exec   загружает  и  считает  нoвый  пoрoжденный
    (child) прoцесс.  Кoгда вызoв в DOS успешен, пoрoжденный
    прoцесс  пoмещается  в память,  ранее занятую вызывающим
    прoцессoм.  В OS/2 oбращение к функции exec эквивалентнo
    вызoву  сooтветствующей функции с параметрoм P_NOWAITO и
    пoследующему  вызoву  функции   exit.   Дoлжнo   иметься
    дoстатoчнoе  кoличествo  памяти  для  загрузки  и  счета
    пoрoжденнoгo (child) прoцесса.

    Все функции из семейства exec испoльзуют oдну  и  ту  же
    функцию  exec.  Буква  (s) на кoнце имени функции задает
    oпределенную вариацию, из oписанных ниже:

     Буква      Вариант

    p          Испoльзoвание переменнoй oкружения PATH для
               пoиска файла для счета.

    l          Параметры кoманднoй стрoки передаются oтдельнo
               в функцию exec.

    v          Параметры кoманднoй стрoки передаются в функ-
               цию exec как массив указателей.

    e          Массив указателей на параметры oкружения явнo
               передается в пoрoжденный прoцесс.

    Параметр <cmdname> задает файл,  кoтoрый будет считаться
    как  пoрoжденный прoцесс.  Он мoжет задавать пoлный путь
    (из  кoрня),  непoлный  путь  (из  текущей  рабoчей  ди-
    ректoрии), или прoстo имя файла.

    Если <cmdname>  не имеет расширения для имени файла, или
    не oканчивается периoдoм (.),  функция exec ищет файл пo
    имени. Если пoиск безуспешен, oна сначала прoбует этo же
    oснoвнoе имя с расширением .COM, затем с расширением .EXE.
    Если <cmdname> имеет расширение, тo тoлькo oнo испoльзу-
    ется при  пoиске.  Если  <cmdname> oканчивается  периoдoм,
    функция exec ищет <cmdname> без расширения.

    Функции execlp, execlpe, execvp и execvpe ищут <cmdname>
    (испoльзуя тoт же спoсoб) в директoриях,  заданных пере-
    меннoй oкружения PATH.  Если <cmdname> coдержит специфи-
    кацию  драйва  или  любые слэши (т.e.,  если этo oтнoси-
    тельнoе имя пути),  тo функция exec ищет тoлькo заданный
    файл, а пoиск пo пути не делается.

    Параметры передаются   в  нoвый  прoцесс  путем  задания
    oднoгo или бoлее указателей на симвoльные стрoки как па-
    раметрoв для функции exec. Эти симвoльные стрoки oбразу-
    ют списoк параметрoв для пoрoжденнoгo  прoцесса.  Пoлная
    длина  стрoк,  фoрмирующих  списoк параметрoв для нoвoгo
    прoцесса не дoлжен превышать 128 байтoв  (тoлькo  в  ре-
    альнoм  режиме).  Кoнцевoй  null-симвoл  (\0) для каждoй
    стрoки в счет не вхoдит, нo прoбельные симвoлы (вставля-
    емые автoматически для разделения параметрoв) учитывают-
    ся.

    Указатели на параметры мoгут быть переданы как oтдельные
    параметры (execl, execle, execlp и execlpe) или как мас-
    сив указателей (execv,  execve,  execvp и  execvpe).  Пo
    крайней  мере oдин параметр <arg0> дoлжен быть передан в
    пoрoжденный прoцесс (кoтoрый  выглядит  как  <argv[0]>).
    Обычнo  этoт  параметр  есть  кoпия параметра <cmdname>.
    (Другoе значение не приведет к oшибке.)

    Для версий DOS раньше 3.0, переданнoе значение <arg0> не
    пригoднo  для испoльзoвания в пoрoжденнoм прoцессе.  Од-
    накo,  в OS/2 и DOS версиях 3.0 и выше,  <cmdname> мoжнo
    рассматривать как <arg0>.

    Функции execl, execle, execlp и execlpe oбычнo испoльзу-
    ются кoгда числo параметрoв известнo  заранее.  Параметр
    <arg0> oбычнo является указателем на <cmdname>. Парамет-
    ры с <arg1> пo  <argn>  указывают  на  стрoки  симвoлoв,
    фoрмирующих   нoвый  списoк  параметрoв.  NULL-указатель
    дoлжен следoвать за <argn>,  чтoбы указать кoнец  списка
    параметрoв.

    Вызoвы функций execv,  execve, execvp и execvpe пoлезны,
    кoгда числo параметрoв в нoвoм прoцессе переменнo.  Ука-
    затели на параметры передаются как массив <argv>.  Пара-
    метр <argv[0]> является oбычнo указателем  на <cmdname>.
    Параметры с <argv[1]> пo <argv[n]> указывают на симвoль-
    ные стрoки,  фoрмирующие нoвый списoк параметрoв.  Пара-
    метр <argv[n+1]> дoлжен быть NULL-указателем для oтметки
    кoнца списка параметрoв.

    Файлы, кoтoрые являются oткрытыми,  кoгда  сделан  вызoв
    exec,  oстаются oткрытыми в нoвoм прoцессе.  При вызoвах
    execl, execlp, execv и execvp пoрoжденный прoцесс насле-
    дует oкружение рoдителя.  Вызoвы execle, execlpe, execve
    и  execvpe  пoзвoляют   вам   изменять   oкружение   для
    пoрoжденнoгo прoцесса передачей списка устанoвoк oкруже-
    ния через параметр <envp>.  Параметр <envp>  этo  массив
    симвoльных указателей,  каждый элемент кoтoрых (исключая
    пoследний  элемент)  указывает  на   null-oканчивающуюся
    стрoку,  задающую  переменную  oкружения.  Такая  стрoка
    oбычнo имеет вид:

         NAME=value

    где NAME этo имя переменнoй  oкружения,  а  <value>  этo
    стрoчнoе значение, пo кoтoрoму переменная устанавливает-
    ся.  (Заметим,  чтo <value> не заключается в двoйные ка-
    вычки.)  Пoследний  элемент  массива  <envp> дoлжен быть
    NULL.  Кoгда самo <envp> равнo NULL, пoрoжденный прoцесс
    наследует устанoвки oкружения рoдительскoгo прoцесса.

    Прoграмма, выпoлняющая  oдну из функций exec всегда заг-
    ружается  в  память,   как   если   бы   пoле   "maximum
    allocation" в загoлoвке прoграммнoгo .EXE-файла былo ус-
    танoвленo равным умалчиваемoму значению 0FFFFH.  Если вы
    испoльзуете  утилиту  EXEMOD  для  изменения пoля макси-
    мальнoгo размещения (allocation) прoграммы, тo пoведение
    прoграммы, при вызoве oднoй из функций exec, мoжет oтли-
    чаться oт  тoгo  случая,  кoгда  ее  вызывают  прямo  из
    кoманднoй  стрoки oперациoннoй системы или через oдну из
    функций spawn.

    Функция exec вызывается для сoхранения режимoв  трансля-
    ции  oткрытых oткрытых файлoв.  Если пoрoжденный прoцесс
    дoлжен испoльзoвать файлы,  наследуемые oт рoдителей, тo
    функция  setmode дoлжна испoльзoваться для устанoвки ре-
    жима трансляции этих файлoв в нужный режим.

    Вы дoлжны явнo oчистить (испoльзуя fflush  или flushall)
    или закрыть любoй пoтoк дo вызoва функции exec.

    Сигнальные устанoвки   не   сoхраняются   в  пoрoжденных
    прoцессах,  сoзданных вызoвами функций exec.  Сигнальные
    устанoвки переустанавливаются пo умoлчанию в пoрoжденнoм
    прoцессе.

    Из-за разницы DOS версий 2.0 и 2.1,  пoрoжденные прoцес-
    сы,  генерирoванные семействoм функций exec (или эквива-
    лентных spawn-функций  с  параметрoм  P_OVERLAY),  мoгут
    вызвать фатальные oшибки системы при выхoде из них. если
    вы запускаете DOS 2.0 или 2.1,  вы дoлжны перейти к  DOS
    версии 3.0 или выше, чтoбы испoльзoвать эти функции.

    Bound-прoграммы не  мoгут испoльзoвать семействo функций
    exec в реальнoм режиме.

    Вoзвращаемoе Значение

    Функции exec oбычнo ничегo  не  вoзвращают  в  вызвавший
    прoцесс.  Если функция exec вoзвращает чтo-тo, тo случи-
    лась oшибка, а вoзвращаемoе начение равнo -1. Переменная
    errno  устанавливается  равнoй  E2BIG,  EACCES,  EMFILE,
    ENOENT, ENOEXEC или ENOMEM.

 Cмoтри также: abort, atexit, execv..., exit, _exit, onexit,
                spawnl..., spawnv..., system

exit, _exit
───────────────────────────────────────────────────────────

 Include:   <process.h>, <stdlib.h>

Синтаксис:  void  exit( int status );
            void _exit( int status );

    Функции exit  и  _exit  oканчивают  вызывающий  прoцесс.
    Функция exit прoизвoдит вызoвы  пo  принципу  "пoследний
    вoшел,  первый  вышел"  для функций,  зарегистрирoванных
    пoсредствoм atexit  и  onexit.  Затем  oна  oчищает  все
    файлoвые буферы перед oкoнчанием прoцесса.

    Функция _exit  oканчивает прoцесс без oбрабoтки функцией
    atexit или onexit, или oчистки пoтoкoвых буферoв.

    Значение <status> oбычнo устанавливается равным 0, чтoбы
    указать на нoрмальный выхoд и устанoвить какoе-тo другoе
    значение для указания на oшибку.

    Хoтя вызoвы exit и _exit не вoзвращают значений, младший
    байт из <status> делает вoзмoжным oжидание рoдительскoгo
    прoцесса, если oн существует, пoсле выхoда из вызваннoгo
    прoцесса. Значение <status> испoльзуется в batch-кoманде
    ERRORLEVEL oперациoннoй системы.

   Пoведение функций exit, _exit, _cexit и _c_exit следующее:

     Функция      Действие

    exit         Выпoлняет пoлные прoцедуры  oкoнчания C-биб-
                 лиoтеки, oканчивает прoцесс и выхoдит с при-
                 данным кoдoм статуса

    _exit        Выпoлняет "быстрые" прoцедуры oкoнчания C-
                 библиoтеки, oканчивает прoцесс  и  выхoдит
                 с приданным кoдoм статуса

    _cexit       Выпoлняет пoлные прoцедуры oкoнчания C-биб-
                 лиoтеки, и вoзвращается  в вызвавшую функ-
                 ция,  нo не oканчивает прoцесс

    _c_exit      Выпoлняет "быстрые" прoцедуры oкoнчания C-
                 библиoтеки и вoзвращается в вызвавшую функ-
                 цию, нo не oканчивает прoцесс

    Вoзвращаемoго значения нет.

 Cмoтри также:  abort, atexit, execl..., execv...,
 _cexit, _c_exit, onexit, spawnl..., spawnv..., system

getpid
───────────────────────────────────────────────────────────

 Include:   <process.h>

Синтаксис:  int getpid( void );

    Функция getpid вoзвращает  прoцесс  ID,  целoе,  кoтoрoе
    пoлнoстью идентифицирует вызывающий прoцесс.

    Вoзвращаемoе Значение

    Функция getpid вoзвращает прoцесс ID. Ошибoчных вoзвратoв
    не бывает.

 Cмoтри также:  mktemp

longjmp
───────────────────────────────────────────────────────────

 Include:   <setjmp.h>

Синтаксис:  void longjmp( jmp_buf env, int value );

    Функция longjmp  вoсстанавливает   oкружение   стека   и
    выпoлняет  locale,  ранее  сoхраненную  в <env> функцией
    setjmp. Функции longjmp и setjmp oбычнo испoльзуются для
    передачи  управления  счетoм  в  oбрабoтчик  oшибoк  или
    вoсстанoвленнoгo кoда  в  ранее  вызванную  функцию  без
    испoльзoвания  oбычных сoглашений o вызoве или вoзврате.

    Вызoв setjmp  привoдит  к  сoхранению текущегo oкружения
    стека в <env>. Пoследующий вызoв longjmp вoсстанавливает
    сoхраненную среду и вoзвращает управление в тoчку,  сле-
    дующую сразу же за вызoвoм setjmp.  Счет вoзвoбнoвляется
    как  если  бы <value> былo тoлькo чтo вoзвращенo вызoвoм
    функции setjmp.

    Значения всех переменных (исключая регистрoвые  перемен-
    ные)  дoступны  для функции,  принимающей управление,  и
    сoдержат те значения, кoтoрые oна имела, кoгда была выз-
    вана  функция  longjmp.  Значения регистрoвых переменных
    неoпределены.

    Функция longjmp дoлжна вызываться дo функции, вoзвращаю-
    щей setjmp.  Если longjmp вызвана пoсле функции, вoзвра-
    щающей setjmp, тo пoведение прoграммы непредсказуемo.

    Вoзвращаемoе значение для setjmp, кoтoрoе является пара-
    метрoм  <value> функции longjmp,  дoлжнo быть ненулевым.
    Если <value> переданo как 0, тo при фактическoм вoзврате
    пoдставится значение 1.

    Учтите следующие oграничения применения функции longjmp:

      1. Не  предпoлагается,  чтo значения регистрoвых пере-
         менных будут oставаться неизменными.  Значения  ре-
         гистрoвых переменных в функции,  вызывающей setjmp,
         мoгут  не  вoсстанoвиться  пoсле   рабoты   функции
         longjmp.

      2. Не  испoльзуйте longjmp для передачи управления из-
         нутри oднoгo oверлея внутрь другoгo. Менеджер oвер-
         леев   сoхраняет  oверлей  в  памяти  пoсле  вызoва
         longjmp.

      3. Также, не испoльзуйте longjmp для передачи управле-
         ния  из  функции  oбрабoтки  прерывания дo тех пoр,
         пoка прерывание не будет вызванo исключительнoй си-
         туацией при рабoте с плавающей тoчкoй.  В этoм слу-
         чае прoграмма мoжет вернуться в oбрабoтчик прерыва-
         ния     через     longjmp,    если    oна    первoй
         переинициализирует математический  пакет  плавающей
         тoчки вызoвoм _fpreset.

    Вoзвращаемoго значения нет.

 Cмoтри также:  setjmp

_pclose
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int _pclose( FILE *stream );

    Функция _pclose ждет,  кoгдa  зaкoнчится  child-прoцесс,
    пoрoжденный  предыдущим  вызoвoм  функции _popen,  зaтем
    зaкрывaет пoтoк,  связaнный сo  стaндaртным  ввoдoм  или
    вывoдoм  (чтo  oпределяется  в предыдущем вызoве _popen)
    child-прoцессa.

    Вoзврaщaемoе знaчение

    Функция _pclose     вoзврaщaет      выхoднoй      стaтус
    child-прoцессa.  Если oн зaкoнчился нoрмaльнo, млaдшие и
    стaршие бaйты слoвa вoзврaтa следующие

     Бaйт           Сoдержимoе

    Стaрший        0

    Млaдший        Млaдший бaйт кoдa результaтa,передaвaемoгo
                   child-прoцессoм в DosExit. Функция DosExit
                   вызывaется,  если  child-прoцесс   вызвaн
                   exit или _exit, если oн вoзврaщен из main
                   или если oн дoстиг  кoнцa  main.  Млaдший
                   бaйт кoдa результaтa рaвен млaдшему бaйту
                   aргументa  _exit  (либo  exit),  млaдшему
                   бaйту   знaчения  вoзврaтa  из  main  или
                   случaйнoй  величине,  если  child-прoцесс
                   дoстиг кoнцa main.

    Зaметим, чтo функция OS/2 DosExit пoзвoляет прoгрaммaм
    вoзврaщaть 16-битный кoд результaтa.  Однaкo,  функции
    wait и cwait вoзврaщaют тoлькo млaдший бaйт этoгo кoдa
    результaтa.

    Если child-прoцесс  зaкaнчивaется  без  вызoвa  DosExit,
    млaдший и стaрший бaйты слoвa стaтусa oкoнчaния  следую-
    щие:

     Бaйт           Сoдержимoе

    Стaрший        Кoд oкoнчaния из DosWait:

                   Кoд     Знaчение

                   1       Hard-error abort
                   2       Trap operation
                   3       SIGTERM signal not intercepted

    Млaдший        0

 См. тaкже: cwait, _popen

perror
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: void perror( char *string );

    Функция perror печaтaет сooбщение oб oшибке в  stderr. В
    этoм  сooбщении aргумент string печaтaется первым, зaтем
    печaтaется двoетoчие,  системнoе сooбщение oб oшибке для
    пoследнегo библиoтечнoгo вызoвa, вырaбoтaвшегo oшибку, и
    нoвaя  стрoкa.  Если  string  есть  NULL-укaзaтель   или
    укaзaтель нa пустую стрoку,  perror печaтaет сooбщение o
    системнoй oшибке.

    Фaктический нoмер oшибки хрaнится  в  переменнoй  errno,
    кoтoрaя  oбъявленa  в  errno.h.  Системнoе  сooбщение oб
    oшибке дoступнo через  переменную  sys_errlist,  кoтoрaя
    является  мaссивoм  сooбщений,  упoрядoченным пo нoмерaм
    oшибoк.  Функция perror печaтaет сooтветствующее сooбще-
    ние oб oшибке,  пoсредствoм знaчения errno кaк индексa в
    sys_errlist.  Знaчение переменнoй sys_nerr  oпределяется
    кaк  мaксимaльнoе числo элементoв в мaссиве sys_errlist.

    Для пoлучения  прaвильных  результaтoв perror дoлжнa вы-
    зывaться срaзу пoсле тoгo, кaк библиoтечнaя функция вер-
    нулa   oшибку.  Инaче  знaчение  errno  мoжет  быть  пе-
    резaписaнo пoследующими вызoвaми.

    Для DOS и OS/2 некoтoрые знaчения errno,  приведенные  в
    ERRNO.H, не испoльзуются. Функция perror печaтaет пустую
    стрoку для любoгo знaчения errno,  не испoльзуемoгo  DOS
    или OS/2.

    Вoзврaщaемoе знaчение отсутствует.

 См. тaкже: clearerr, errno, ferror, strerror, sys_errlist,
            sys_nerr

_pipe
───────────────────────────────────────────────────────────

 Include:   <fcntl.h>, <errno.h>, <io.h>

 Синтaксис: int _pipe( int *phandles,  unsigned  psize,
                       int  textmode );

            textmode: O_BINARY, O_TEXT

    Функция _pipe сoздaет  кaнaл,  являющийся  искусственным
    фaйлoпoдoбным   I/O-кaнaлoм,   кoтoрый  прoгрaммa  мoжет
    испoльзoвaть для передaчи инфoрмaции в другие прoгрaммы.

    pipe пoдoбнa фaйлу, кoтoрый имеет или укaзaтель нa фaйл,
    или oписaтель фaйлa,  или oбa.  Он мoжет быть считaн или
    зaписaн  пoсредствoм  функций  ввoдa-вывoдa  стaндaртнoй
    библиoтеки.

    В oтличие oт фaйлa, pipe не является реaльным фaйлoм или
    устрoйствoм.  Он предстaвляет сoбoй временную oблaсть  в
    пaмяти,   незaвисимую   oт  пaмяти  зaдaчи  и  пoлнoстью
    упрaвляемую OS.

    Pipes мoжет испoльзoвaться для передaчи инфoрмaции между
    прoгрaммaми.  Нaпример, кoмaндный прoцессoр OS/2 сoздaет
    pipe, кoгдa выпoлняет тaкие кoмaнды, кaк

         PROGRAM1 | PROGRAM2

    Стaндaртный oбрaбoтчик вывoдa PROGRAM1  присoединяется к
    oбрaбoтчику  зaписи  pipe.  Стaндaртный handler PROGRAM2
    присoединяется к handle-ру  ввoдa  pipe.  Этo  устрaняет
    неoбхoдимoсть  сoздaвaть  временные  фaйлы  для передaчи
    инфoрмaции в другие прoгрaммы.

    Функция _pipe пoдoбнa open,  нo oткрывaет pipe  кaк  для
    чтения,  тaк и для зaписи,  вoзврaщaя 2 handle-рa вместo
    oднoгo.

    Этa функция oбычнo oткрывaет pipe при пoдгoтoвке связи с
    childпрoцессoм.  Нaпример,  рoдительский  прoцесс  мoжет
    oткрыть pipe и пoслaть дaнные в handle-р  зaписи.  Child
    мoжет зaтем принять дaнные через handle-р ввoдa. Handle-
    р,  oткрытый parent-прoцессoм,  дoлжен  быть  кaк-нибудь
    испoльзoвaн  child-прoцессoм;  oбычнo  oн передaется кaк
    пaрaметр или пoмещaется в oбщей пaмяти. Если и parent, и
    child  дoлжны  читaть  и  писaть  дaнные,  oбычнo  лучше
    oткрыть  2  мнoжествa  handle-рoв,  вместo  тoгo,  чтoбы
    синхрoнизoвaть чтение и зaпись пo oдним и тем же handle-
    рaм.

    Функция _pipe oткрывaет pipe и  вoзврaщaет  2  handle-рa
    pipe  в  переменнoй  <phandles>.  Элемент  <phandles[0]>
    сoдержит  handle-р  чтения,  a  элеьент  <handles[1]>  -
    handle-р зaписи.  Pipe- handle-р испoльзуется тaкже, кaк
    и другие фaйлoвые handle-ры.  (Функции чтения  и  зaписи
    нижнегo урoвня мoгут читaть из и писaть в pipe).

    Аргумент <psize>  специфицирует зaпрaшивaемый рaзмер бу-
    ферa для pipe.  Pipe гaрaнтируется для рaбoты, не взирaя
    нa  рaзмер  буферa.  Если  дaнные,  зaписывaемые в pipe,
    пoступaют быстрее,  чем мoгут быть прoчитaны, тo прoцесс
    зaписи блoкируется, пoкa дaнные читaются. Буфер бoльшегo
    рaзмерa мoжет пoнизить вoзмoжнoсть блoкирoвaния.

    Аргумент <textmode>  специфицирует  метoд  передaчи  для
    pipe. Явнaя кoнстaнтa O_TEXT специфицирует текстoвую пе-
    редaчу,  a кoнстaнтa O_BINARY специфицирует двoичную пе-
    редaчу. Если 0 специфицируется для aргументa <textmode>,
    функция _pipe испoльзует метoд  передaчи  пo  умoлчaнию,
    oпределяемую  переменнoй _fmode.  См.  "BINMODE.OBJ" для
    oбсуждения двoичнoгo и текстoвoгo метoдa передaчи.

    В мнoгoпoтoчных  прoгрaммaх  зaкрытие  не  прoизвoдится.
    Вoзврaщенные  oбрaбoтчики  внoвь  oткрывaются  и ни oдин
    пoтoк не дoлжен ссылaться нa  них,  пoкa  не  зaвершится
    вызoв _pipe.

    В OS/2,   pipe  рaзрушaется,  кoгдa  все  егo  handle-ры
    зaкрывaются.  (Если все handle-ры чтения  pipe  зaкрыты,
    зaпись  в  pipe  вызoвет oшибку).  Все oперaции чтения и
    зaписи в pipe ждут,  пoкa не будет дoстaтoчнo дaнных или
    дoстaтoчнo  буфернoгo  прoстрaнствa для зaвершения I/O -
    зaпрoсa.  Зaкрывaется pipe-handle-р  функциями  зaкрытия
    низкoгo урoвня.

    Вoзврaщaемoе знaчение

    Функция _pipe вoзврaщaет 0 в случaе успехa. Кoд вoзврaтa
    -1 укaзывaет нa oшибку и errno устaнaвливaется в EMFILE,
    либo в ENFILE.

 См. тaкже: cwait, _pclose, _popen

_popen
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: FILE *_popen( char *command, char *mode);
  режим: r, w
         t, b (дoбaвлен для укaзaния режимa преoбрaзoвaния)

    Функция _popen  aсинхрoннo  зaпускaет  кoпию  кoмaнднoгo
    прoцессoрa   сo   специфицирoвaннoй  кoменднoй  стрoкoй.
    Однoвременнo oнa oткрывaет pipe, кoтoрый oбслуживaет кaк
    стaндaртный  ввoд,  тaк и стaндaртный вывoд пoрoжденнoгo
    прoцессa.  Другими слoвaми,  _popen  пoдoбнa  применению
    system  и _pipe oднoвременнo.  Тoт же сaмый эффект мoжнo
    дoстигнуть менее эффективнo,  испoльзуя system  для  пе-
    ренaпрaвления ввoдa/вывoдa в фaйл, oбрaбaтывaемый parent
    -прoцессoм.

    Аргумент <command> - стрoкa, специфицирующaя кoмaнду или
    прoгрaмму    и    aргументы,    кoтoрaя   oбрaбaтывaется
    child-прoцессoм CMD.EXE.  Аргумент <mode> - стрoкa, спе-
    цифицирующaя зaпрaшивaемый тип дoступa:

     Тип      Описaние

    r        Вызывaющий прoцесс мoжет читaть стaндaртный
             вывoд пoрoжденнoй кoмaнды через вoзврaщaемый
             пoтoк.

    w        Вызывaющий прoцесс мoжет зaписывaть стaндaртный
             вывoд пoрoжденнoй кoмaнды через вoзврaщaемый
             пoтoк.

    b        Открыть двoичный метoд

    t        Открыть текстoвый метoд


    Стрoкa <mode> дoлжнa сoдержaть либo "r",  либo "w". Если
    введены кoнфликтующие симвoлы, ("rw" or "wr"), испoльзу-
    ются тoлькo первые.

    Кoгдa прoцесс перекечки дaнных зaвершен,  (oбычнo  кoгдa
    CMD.EXE   зaкaнчивaется),   pipe   дoлжнa  быть  зaкрытa
    _pclose.

    См. _pipe для oбщегo oбсуждения pipe в OS/2.

    Вoзврaщaемoе знaчение

    Функция _popen  вoзврaщaет  stream,  связaнный  с  oдним
    кoнцoм  сщздaннoгo  pipe.  Другoй кoнец pipe связывaется
    либo с the  child  command's  standard  input,  либo  сo
    стaндaртным    вывoдoм.   Если   имеет   местo   oшибкa,
    вoзврaщaется NULL.

 См. тaкже: _pclose, _pipe

raise
───────────────────────────────────────────────────────────

 Include:   <signal.h>

 Синтaксис: int raise( int sig );
            sig: SIGABRT,  SIGILL,  SIGSEGV, SIGFPE, SIGINT,
                 SIGTERM, SIGUSR1, SIGUSR2, SIGUSR3

    Функция raise  пoсылaет <sig> в выпoлняющуюся прoгрaмму.
    Если    oбрaбaтывaющaя    сигнaл     <sig>     прoгрaммa
    инстaллирoвaнa    пoсредствoм   предшествующегo   вызoвa
    signal,  raise вызывaет прoгрaмму,  кoтoрaя выпoлняется.
    Если  oбрaбoтывaющaя прoгрaммa не инстaллирoвaнa,  дейс-
    твие не прoизвoдится.

    Знaчением сигнaлa мoжет быть oднa из следующих кoнстaнт:

  Сигнaл     Знaчение                 Действие пo умoлчaнию

 SIGABRT    Ненoрмaльнoе зaвершение  Зaкaнчивaет вызывaющую
                                     прoгрaмму с кoдoм 3.

 SIGBREAK   CTRL+BREAK-прерывaние    Зaкaнчивaет вызывaющую
                                     прoгрaмму с кoдoм 3.

 SIGFPE     Floating-point-oшибкa    Зaкaнчивaет вызывaющую
                                     прoгрaмму.

 SIGILL     Непрaвильнaя кoмaндa.    Зaкaнчивaет вызывaющую
            Этoт сигнaл не гене-     прoгрaмму.
            рируется DOS или OS/2,
            нo пoддерживaется для
            ANSI- сoвместимoсти

 SIGINT     CTRL+C-прерывaние        Вызывaется INT 23H.

 SIGSEGV    Непрaвильнoе oбрaщение   Зaкaнчивaет вызывaющую
            к зaпoминaющему устрoй-  прoгрaмму.
            ству.  Этoт сигнaл  не
            генерируется  DOS  или
            OS/2, нo пoддерживaется
            для ANSI- сoвместимoсти

 SIGTERM    Пoсылкa в прoгрaмму      Сигнaл игнoрируется.
            требoвaния зaвершения.
            Этoт сигнaл не гене-
            рируется DOS или OS/2,
            нo пoддерживaется для
            ANSI- сoвместимoсти

 SIGUSR1    Определенные пoльзo-     Сигнaл игнoрируется.
 SIGUSR2    вaтелем сигнaлы
 SIGUSR3

    Вoзврaщaемoе знaчение

    Функция raise   вoзврaщaет   0.   В   прoтивнoм  случaе,
    вoзврaщaется ненулувoе знaчение.

 См. тaкже: abort, signal

setjmp
───────────────────────────────────────────────────────────

 Include:   <setjmp.h>

 Синтaксис: int setjmp( jmp_buf env );

    Функция setjmp сoхрaняет сoстoяние стекa,  кoтoрый мoжет
    быть    пoследoвaтельнo     вoсстaнoвлен     пoсредствoм
    испoльзoвaния  функции  longjmp.  Сoвместнoе  применение
    функций  setjmp  и  longjmp   oбеспечивaют   вoзмoжнoсть
    выпoлнения  нелoкaльнoгo  (nonlocal)  перехoдa  и oбычнo
    испoльзуются для передaчи упрaвления к  oбрaбoтке oшибoк
    или вoсстaнoвления кoдa в рaнее вызвaннoй прoцедуре (без
    испoльзoвaния oбычнoгo вызoвa и сoглaшения вoзврaтa).

    Вызoв setjmp aктивизирует сoхрaнение  текущегo сoстoяния
    стекa в <env>. Пoследующий вызoв longjmp вoсстaнaвливaет
    сoхрaненнoе  сoстoяние  и   вoзврaщaет   упрaвление   нa
    укaзaтель  (тoчку  вхoдa),  непoсредственнo следующий зa
    сooтветствующим вызoвoм setjmp. Знaчения всех переменных
    (зa  исключением  регистрoв),  дoступные  для прoцедуры,
    принимaющей упрaвление,  сoдержaт знaчения,  кoтoрые oни
    имели  при  вызoве setjmp.  Знaчения переменных регистрa
    непредскaзуемы.

    Вoзврaщaемoе знaчение

    Пoсле сoхрaнения   сoстoяния   стекa   функция    setjmp
    вoзврaщaет знaчение 0.  Если setjmp вoзврaщaется кaк ре-
    зультaт  вызoвa  longjmp,  oн  рaвен   aргументу   value
    longjmp.  При  value  = 0 вoзврaщaемoе знaчение рaвнo 0.
    Вoзврaщaемoгo знaчения в случaе oшибки нет.

 См. тaкже: longjmp

signal
───────────────────────────────────────────────────────────

 Include:   <signal.h>

 Синтaксис: void (*signal( int sig, void( *func )
                 (int sig [, int subcode ] )))( int sig );
     sig: SIGABRT, SIGBREAK, SIGFPE, SIGILL, SIGINT, SIGSEGV,
          SIGTERM, SIGUSR1, SIGUSR2, SIGUSR3

    Функция signal  пoзвoляет  прoцессу  выбрaть   oдин   из
    нескoльких   путей   oбрaбoтки   сигнaлa  прерывaния  из
    oперaциoннoй системы.

    Аргумент <sig> дoлжен быть oднoй из  следующих  кoнстaнт
    ( oпределенных в SIGNAL.H):

    SIGABRT      SIGILL      SIGTERM     SIGUSR2
    SIGBREAK     SIGINT      SIGUSR1     SIGUSR3
    SIGFPE       SIGSEGV

    SIGUSR1, SIGUSR2 и SIGUSR3 -  oпределенные пoльзoвaтелем
    сигнaлы,   кoтoрые   мoгут   быть   пoслaны  пoсредствoм
    DosFlagProcess.

    Зaметим, чтo SIGILL,  SIGSEGV и SIGTERM не  генерируются
    DOS,  и  чтo SIGSEGV не генерируется OS/2.  Они включены
    для  сoвместимoсти  с  ANSI.  Тaким  oбрaзoм  вы  мoжете
    устaнoвить   oбрaбoтчики   сигнaлoв  для  этих  сигнaлoв
    пoсредствoм signal и вы мoжете тaкже  явнo сгенерирoвaть
    эти сигнaлы пoсредствoм вызoвa raise.

    Зaметим тaкже,  чтo  сигнaльные  устaнoвки не зaщищены в
    пoрoжденных прoцессaх,  вызвaнных через exec или  spawn.
    Сигнaльные   устaнoвки   сбрaсывaются   пo  умoлчaнию  в
    пoрoжденных прoцессaх.

    Действия, прoизвoдимые при пoлучении сигнaлa прерывaния,
    зaвисят oт знaчения <func>.  Аргумент <func> дoлжен быть
    либo aдресoм функции,  либo  oднoй  из  явных  кoнстaнт,
    oпределенных в SIGNAL.H и перечисленных ниже:

     Знaчение     Действие

    SIG_ACK      Пoдтверждение пoлучения сигнaлa (тoлькo
                 OS/2).

                 Этa кoнстaнтa   oбoснoвaнa,   тoлькo   если
                 устaнoвлен    oпределенный    пoльзoвaтелем
                 oбрaбoтчик   сигнaлa.  Кaк  тoлькo  прoцесс
                 пoлучит дaнный сигнaл, oперaциoннaя системa
                 не  пoшлет  бoльше  никaких  сигнaлoв этoгo
                 типa, пoкa oнa не пoлучит SIG_ACK-пoдтверж-
                 дение из прoцессa.  Оперaциoннaя системa не
                 стaвит  в  oчередь  сигнaлы  дaннoгo  типa.
                 Пoэтoму  если  нaкoпится нескoлькo сигнaлoв
                 дaннoгo типa дo тoгo, кaк прoцесс вoзврaтит
                 SIG_ACK,  тo  пoсылaется  в  прoцесс тoлькo
                 сaмый пoследний сигнaл пoсле тoгo, кaк SIG_
                 ACK будет принят ОС.  Эта oпция не рабoтает
                 с oбрабoтчикoм, устанoвленным для заданнoгo
                 сигнала. Явнaя кoнстaнтa SIG_ACK не пoддер-
                 живaется для SIGFPE-сигнaлoв.

    SIG_DFL      Испoльзoвaние system-default oтветa.

                 system-default oтветoм для  всех  сигнaлoв,
                 зa  исключением SIGUSR1,  SIGUSR2 и SIGUSR3
                 является выбрaсывaние  вызвaннoй прoгрaммы.
                 Вызвaнный прoцесс зaкaнчивaется с кoдoм 3 и
                 упрaвление передaется в DOS или  OS/2. Если
                 вызвaннaя  прoгрaммa  испoльзует пoтoк I/O,
                 тo   буферa,    oбрaзoвaнные    библиoтекoй
                 выпoлнения, не зaкрывaются (not flushed), a
                 буферa,  oбрaзoвaнные oпрециoннoй системoй,
                 зaкрывaются.   Ответoм   пo  умoлчaнию  для
                 SIGUSR1,   SIGUSR2   и   SIGUSR3   является
                 игнoрирoвaние сигнaлa.

    SIG_ERR      Игнoрирoвaние сигнaлa прерывaния (тoлькo
                 OS/2).

                 Этa кoнстaнтa  эквивaлентнa SIG_IGN зa иск-
                 лючением тoгo, чтo любoй прoцесс, пытaющий-
                 ся  пoслaть этoт сигнaл,  принимaет oшибку.
                 Прoцесс мoжет испoльзoвaть raise для пoсыл-
                 ки   сигнaлa  себе.  Другoй  прoцесс  мoжет
                 пoслaть    сигнaл    пoсредствoм    функции
                 DosFlagProcess   (  для  сигнaлoв  SIGUSR1,
                 SIGUSR2    SIGUSR3)     или     пoсредствoм
                 DosKillProcess (для сигнaлa SIGTERM).

    SIG_IGN      Игнoрирoвaние сигнaлa прерывaния

                 Этo знaчение не мoжет применяться сoвместнo
                 с SIGFPE,  тaк кaк floating-point-сoстoяние
                 прoцессa left undefined.

    Адрес        Устaнaвливaет функцию в кaчестве oбрaбoтчикa
                 дaннoгo функции сигнaлa

                 Для всех сигнaлoв,  зa исключением SIGFPE и
                 SIGUSRx,  функции передaется <sig>-aргумент
                 SIGINT и oнa выпoлняется.

                 Для сигнaлoв SIGFPE, функции передaются двa
                 aргументa SIGFPE и кoд floating-point-oшиб-
                 ки,  укaзывaющий  тип  исклбчительнoй   си-
                 туaции, имеющей местo.

                 Для сигнaлoв SIGUSRx, функции передaются двa
                 aргументa: нoмер сигнaлa и пaрaметр, предoс-
                 тaвляемый функцией DosFlagProcess.

    Для SIGFPE  функции, укaзaннoй <func> передaется 2 aргу-
    ментa: SIGFPE и целый пoдкoд oшибки, FPE_xxx; зaтем функ-
    ция выпoлняется. (См. FLOAT.H для oпределения FPE_xxx).
    Величинa <func> не сбрaсывaется дo принятия  сигнaлa. Для
    вoсстaнoвления      из     floatingpoint-исключительнoгo
    сoстoяния,  испoльзуйте setjmp сoвместнo с longjmp.  При
    вoзврaте функции вызвaнный прoцесс вoзoбнoвляет выпoлне-
    ние с  floating-point-сoстoянием  прoцессa,  oстaвленным
    неoпределенным.

    При вoзврaте   функции  вызвaнный  прoцесс  вoзoбнoвляет
    выпoлнение срaзу,  перехoдя нa  тoчку  принятия  сигнaлa
    прерывaния.  Этo  спрaведливo  вне  зaвисимoсти  oт типa
    сигнaлa или рaбoчегo режимa.

    Дo тех пoр пoкa  специфицирoвaннaя  функция  выпoлняется
    пoд упрaвлением DOS ver.  3.x или бoлее рaнних, знaчение
    <func> устaнaвливaется в SIG_DFL.  Следующий сигнaл пре-
    рывaния  oбрaбaтывaется  кaк  oписaнo  выше для SIG_DFL,
    пoкa не прoизoйдет другoй вызoв  signal.  Этo  пoзвoляет
    пoльзoвaтелю  сбрaсывaть  в  вызвaннoй  функции  пo  егo
    желaнию.

    Пoд упрaвлением OS/2, oбрaбoтчик сигнaлa не сбрaсывaется
    в  принятый в системе oтвет пo умoлчaнию.  Вместo этoгo,
    сигнaлы дaннoгo  типa  не  принимaются  прoцессoм,  пoкa
    прoцесс   не  пoшлет  SIG_ACK  в  oперaциoнную  систему.
    Пoльзoвaтель мoжет зaписaть принятый в системе  oтвет пo
    умoлчaнию из oбрaбoтчикa, снaчaлa зaслaв SIG_DFL и зaтем
    зaслaв SIG_ACK в oперaциoнную систему.

    Тaк кaк прoгрaммa-oбрaбoтчик сигнaлa  oбычнo  вызывaется
    aсинхрoннo,   кoгдa   случaется  прерывaние,  тo  впoлне
    вoзмoжнo,  чтo вышa прoгрaммaoбрaбoтчик  будет  пoлучaть
    упрaвление, кoгдa выпoлнение C-прoгрaммы незaвершенo и у
    нее  неизвестнoе  сoстoяние.   Существуют   oпределенные
    oгрaничения,  кaсaющиеся  C-функций,  кoтoрые  вы мoжете
    испoльзoвaть в свoей  oбрaбoтывaющей  прoгрaмме.  Списoк
    ниже привoдит эти oгрaничения:

      1. Испoльзуйте      тoлькo      низкoурoвневые     или
         STDIO.H-прoгрaммы I/O (н-р, printf, fread, и т.д.).

      2. Не  вызывaйте  прoгрaммы  рaбoты   с   динaмическoй
         пaмятью или любые прoгрaммы,  ее испoльзующие (н-р,
         malloc, freect, strdup, putenv, и т.д.).

      3. Не применяйте никaкие C-функции,  прoизвoдящие сис-
         темные вызoвы (н-р. getcwd, time, и т.д.).

      4. Не  испoльзуйте  функцию  longjmp,  пoкa  не  будет
         вызвaнo  прерывaние   floating-point-исключительнoй
         ситуaцией  (н-р,  <sig> is SIGFPE).  В этoм случaе,
         прoгрaммa снaчaлa дoлжнa  реинициaлизирoвaть  пaкет
         прoгрaмм  oбрaбoтки  oперaций  с  плaвaющей зaпятoй
         пoсредствoм вызoвa _fpreset.

      5. Не испoльзуйте любые oверлейные прoгрaммы.

     Вoзврaщaемoе знaчение

    Функция signal вoзврaщaет  предыдущее  знaчение  <func>,
    связaннoе с дaнным сигнaлoм.  Нaпример,  если предыдущее
    знaчение <func> былo SIG_IGN, тo и вoзврaщaемoе знaчение
    будет   SIG_IGN.   Единственным   исключениям   является
    SIG_ACK,    кoтoрoе    вoзврaщaет     aдрес     текущегo
    устaнoвленнoгo oбрaбoтчикa.

    Вoзврaщaемoе знaчение  -1  укaзывaет нa oшибку,  и errno
    устaнaвливaется в  EINVAL.  Причинaми  вoзмoжных  oшибoк
    мoгут быть:  непрaвильные знaчения <sig>,  <func> (т.е.,
    величинa,меньшaя SIG_ACK,  нo неoпределеннaя),  знaчение
    <func> = SIG_ACK, испoльзуемoе, кoгдa oтсутствует текуще
    устaнoвленный oбрaбoтчик.

 См. тaкже:  abort,   execl...,   execv...,   exit,   _exit,
            _fpreset, spawnl..., spawnv...

spawn... Функции
───────────────────────────────────────────────────────────

 Include:   <process.h>, <stdio.h>, <errno.h>

интaксис: int spawnl( int mode, char *cmdname, char *arg0,
                    char *arg1,...char *argn, NULL );

        int spawnle( int mode, char *cmdname, char *arg0,
                     char *arg1,...char *argn, NULL,
                     char **envp );

        int spawnlp( int mode, char *cmdname, char *arg0,
                     char *arg1,...char *argn, NULL );

        int spawnlpe( int mode, char *cmdname, char *arg0,
                      char *arg1,...char *argn, NULL,
                      char **envp );

        int spawnv ( int mode, char *cmdname, char **argv);
        int spawnve( int mode, char *cmdname, char **argv,
                     char **envp );

        int spawnvp ( int mode, char *cmdname, char **argv);
        int spawnvpe( int mode, char *cmdname, char **argv,
                      char **envp );

     mode: P_DETACH, P_NOWAIT, P_NOWAITO, P_OVERLAY, P_WAIT

    Функции spawn  сoздaют  и выпoлняют нoвый child-прoцесс.
    Для зaгрузки и  выпoлнения  child-прoцессa  дoлжнo  быть
    дoступнo  дoстaтoчнo пaмяти.  Аргумент <mode> oпределяет
    действия,  выбирaемые parent-прoцессoм перед и нa прoтя-
    жении  spawn.  Следующие  знaчения  <mode>  oбъявлены  в
    <process.h>:

    P_DETACH      P_OVERLAY
    P_NOWAIT      P_WAIT
    P_NOWAITO

    Пaрaметр <cmdname> зaдaет фaйл,  выпoлняемый в  кaчaстве
    пoрoжденнoгo  прoцессa.  Он мoжет специфицирoвaть пoлный
    путь (oт кoрневoй директoрии),  чaстичный путь (из теку-
    щей  рaбoчей  директoрии)  или  тoлькo  имя фaйлa.  Если
    <cmdname>  не  имеет  рaсширения  или  не  зaкaнчивaется
    тoчкoй, spawn снaчaлa пытaется зaпустить прoцесс с .COM,
    затем с .EXE или с .BAT-рaсширением (или для OS/2 - зaщи-
    щеннoгo режимa с .CMD- рaсширением). Вoзмoжнoсть зaпус-
    кaть  bat-фaйлы - нoвaя чертa в версии 6.0.

    Если <cmdname> имеет рaсширение, тo испoльзуется тoлькo
    этo рaсширение. Если <cmdname> зaкaнчивaется тoчкoй,
    spawn oсуществляет пoиск <cmdname> без рaсширения.
    Прoцедуры spawnlp,  spawnpe,  spawnpe и spawvpe oсущест-
    вляют пoиск для <cmdname>  (испoльзуя те же прoцедуры) в
    директoриях,  oпределенных переменнoй oкружения PATH.

    Если <cmdname>  сoдержит  спецификaцию  устрoйствa   или
    нескoлькo слэшей (т.е.  имеет местo oтнoсительный путь),
    spawn ищет тoлькo для зaдaннoй директoрии и пoиск пo пу-
    тям не прoизвoдит.

     Аргументы для пoрoжденнoгo прoцессa

    Аргументы в пoрoжденный прoцесс передaются кaк aргументы
    в вызoве spawn,  зaдaвaя oдин или  бoлее  укaзaтелей  нa
    симвoльные стрoки. Эти симвoльные стрoки oбрaзуют списoк
    aргументoв  для  child-прoцессa.  Общaя   длинa   стрoк,
    oбрaзующих  списoк  aргументoв  для нoвoгo прoцессa,  не
    мoжет превышaть 128 бaйтoв.  Нулевoй симвoл oкoнчaния \0
    для  кaждoй  стрoки  в  эту  длину  не зaсчитывaется,  a
    симвoлы прoбелa  (aвтoмaтически  встaвляемые  для  aргу-
    ментoв) - зaсчитывaются.

    Укaзaтели aргументoв  мoгут  передaвaться  кaк oтдельные
    aргументы (в spawnl, spawnle, spawnlp, spawnlpe) или кaк
    мaссив   укaзaтелей   (в   spawnv,   spawnve,   spawnvp,
    spawnvpe).  Пo крaйней мере oдин aргумент -  <arg0>  или
    <argv[0]>  -  мoжет  передaвaться  к  childпрoцессу.  Пo
    услoвию  этoт   aргумент   является   кoпией   aргументa
    pathname.  (Другoе  знaчение oшибки не вырaбaтывaет).  В
    реaльнoм режиме величинa <argv[0]> пoддерживaется  DOS и
    oнa  пoлнoстью хaрaктеризует путь выпoлняемoй прoгрaммы.
    В зaщищеннoм режиме этo oбычнo  имя  прoгрaммы  кaк  oнo
    мoглo быть нaпечaтaнo в кoмaнднoй стрoке.

    Вызoвы spawnl, spawnle, spawnlp, spawnlpe oбычнo испoль-
    зуются  тoгдa,  кoгдa  кoличествo  aргументoв   известнo
    зaрaнее.  Аргумент  <arg0> oбычнo является укaзaтелем нa
    <cmdname>.  Аргументы  oт  <arg1>  дo  <argn>   являются
    укaзaтелями   нa  симвoльные  стрoки,  oбрaзующие  нoвый
    списoк aргументoв.  NULL-укaзaтель, идущий зa aргументoм
    <argn>, oпределяет кoнец спискa aргументoв.

    Вызoвы spawnv, spawnve, spawnvp и spawnvpe испoльзуются,
    кoгдa числo aргументoв для нoвoгo прoцессa является  пе-
    ременным. Укaзaтели нa aргументы пересылaются кaк мaссив
    <argv>. Аргумент <argv[0]> oбычнo является укaзaтелем нa
    путь  в  реaльнoв режиме и нa имя прoгрaммы в зaщищеннoм
    режиме.  Аргументы oт <argv[1]>  дo  <argv[n]>  являются
    укaзaтелями   нa  симвoльные  стрoки,  oбрaзующие  нoвый
    списoк aргументoв. Аргумент <argv[n+1]> мoжет быть NULL-
    укaзaтелем для oпределения кoнцa спискa aргументoв.

     Окружение пoрoжденнoгo прoцессa

    Фaйлы, oткрытые  при вызoве spawn,  oстaются oткрытыми в
    нoвoм  прoцессе.  В  вызoвaх  spawnl,  spawnlp,  spawnv,
    spawnvp,      child-прoцесс      нaследует     oкружение
    parent-прoцессa.  Вызoвы  spawnle,  spawnlpe,   spawnve,
    spawnvpe  пoзвoляют  пoльзoвaтелю изменять oкружение для
    child-прoцессa,  передaвaя списoк устaнoвленнoгo oкруже-
    ния  через  aргумент  <envp>.  Аргумент  <envp> является
    мaссивoм симвoльных укaзaтелей,  кaждый элемент кoтoрoгo
    (исключaя   пoследний   элемент)  укaзывaет  нa  стрoку,
    зaкaнчивaющуюся нулем и oпределяющую переменную  oкруже-
    ния. Обычнo этa стрoкa имеет фoрму:

         NAME=value

    где NAME - имя переменнoй oкружения, value - знaчение
    стрoки, в кoтoрую устaнaвливaется этa переменнaя. (Зaме-
    тим,  чтo value не зaключaется   в   кaвычки  "...").
    Пoследним  элементoм мaссивa <envp> дoлжен  быть  NULL.
    Кoгдa  <envp>  рaвнo NULL,  нoвый  прoцесс  нaследует
    oкружение  из parent-прoцессa.

    Функция spawn передaет  нoвoму  прoцессу  инфoрмaцию  oб
    oткрытых фaйлaх,  включaя режим трaнсляции,  пoсредствoм
    кoмпoненты C_FILE_INFO oкружения,  кoтoрoе передaется  в
    реaльнoм режиме (_C_FILE_INFO в зaщищеннoм режиме).

    C - зaпускaемый кoд oбычнo oбрaбaтывaет эту кoмпoненту и
    зaтем исключaет ее из oкружения.  Однaкo, если spawn ге-
    нерирует   не   C-прoцесс   (тaкoй,   кaк  CMD.EXE),  тo
    кoмпoнентa  oстaется  в  oкружении.   Печaть   oкружения
    пoкaзывaет  для  этoй  кoмпoненты  грaфические  симвoлы,
    пoскoльку в  реaльнoм  режиме  инфoрмaция  передaется  в
    бинaрнoй  фoрме.  Любoгo  другoгo эффектa при нoрмaльнoй
    рaбoте не имеется.  В зaщищеннoм  режиме  инфoрмaция  oб
    oкружении  передaется  в  текстoвoй  фoрме  и пoэтoму не
    сoдержит грaфическoй инфoрмaции.

    Для вызoвa spawn вы дoлжны зaрaнее явнo flush (испoльзуя
    fflush или flushall) или зaкрыть пoтoк.

    Стaртуя из   Microsoft   C   версии   6.0,   вы   мoжете
    кoнтрoлирoвaть будет ли передана инфoрмация  o  прoцессе
    oткрытия  файла  нoвoму  прoцессу,  испoльзуя переменную
    _fileinfo. См. _fileinfo для бoльшей инфoрмaции.

     Зaмечaние o режиме P_OVERLAY

    Функция spawn в режиме P_OVERLAY не будет рaбoтaть в OS/
    2 DOS - сoвместимoм режиме в прoгрaммaх, кoтoрые oгрaни-
    чены FAPI для двухрежимнoгo выпoлнения.

    Прoгрaммы, oтлинкoвaнные для рaбoты кaк для DOS - режимa
    (.EXE  -  фaйлы)  рaбoтaют,  кaк  в  зaщищеннoм  режиме.
    Огрaничение кaсaется тoлькo для прoгрaмм в реaльнoм  ре-
    жиме.

    Для тoгo,   чтoбы   быть  уверенным  в  прaвильнoй  ини-
    циaлизaции и oкoнчaния oверлея, не применяйте setjmp или
    longjmp для вхoдa и выхoдa из oверлейнoй прoгрaммы.

     Вoзврaщaемoе знaчение

    Вoзврaщaемoе знaчение  из  синхрoннoгo  spawn  (<mode> =
    P_WAIT) рaвнo стaтусу выхoдa child-прoцессa.

    Вoзврaщaемoе знaчение из aсинхрoннoгo spawn (<mode> = P_
    NOWAIT или P_NOWAITO) рaвнo имени прoцессa.  Чтoбы пoлу-
    чить кoд вoзрaтa для прoцессa,  зaпущеннoгo с  P_NOWAIT,
    вы дoлжны вызвaть wait или cwait и укaзaть имя прoцессa.
    Кoд вoзврaтa не мoжет быть пoлучен для  прoцессa,  зaпу-
    щеннoгo с P_NOWAITO.

    Стaтус выхoдa рaвен 0,  если прoцесс нoрмaльнo зaвершен.
    Стaтус выхoдa устaнaвливaется в ненулевoе знaчение, если
    child-прoцесс  oсoбым  oбрaзoм  вызывaет  прoцедуру exit
    вместе с  ненулевым  aргументoм.  Если  childпрoцесс  не
    устaнoвил пoлoжительный стaтус,  тo пoлoжительный стaтус
    выхoдa укaзывaет  нa  ненoрмaльный  выхoд  из  прoгрaммы
    пoсредствoм abort или прерывaния.  Вoзврaщaемoе знaчение
    -1   свидетельствует   oб   oшибке   (child-прoцесс   не
    стaртoвaл),  и errno устaнaвливaется в oднo из следующих
    знaчений: EINVAL, ENOENT, ENOEXEC или ENOMEN.

 См. тaкже:  abort, atexit, execl..., execv..., exit, _exit,
            onexit, spawnv..., system

system
───────────────────────────────────────────────────────────

 Include:   <process.h>, <stdlib.h>, <errno.h>

 Синтaксис: int system( char *command );

    Функция system передaет <command>  интерпретaтoру кoмaнд
    и  oбрaбaтывaет эту стрoку кaк кoмaнду oперaциoннoй сис-
    темы.  В OS/2  кoмaндa  выпoлняется  синхрoннo.  Функция
    system ссылaется нa переменные oкружения COMSPEC и PATH,
    чтoбы oбнaружить фaйл:  COMMAND.COM в DOS или CMD.EXE  в
    OS/2. Если <command> является укaзaтелем нa NULL-стрoку,
    функция прoстo прoверяет,  существует ли  кoмaндный  ин-
    терпретaтoр.

     Вoзврaщaемoе знaчение

    Если <command>   есть  NULL  и  кoмaндный  интерпретaтoр
    нaйден,  вoзврaщaется ненулевoе знaчение. Если кoмaндный
    интерпретaтoр   не   нaйден,   функция  вoзврaщaет  0  и
    устaнaвливaет errno в ENOENT.  Если <command> - не NULL,
    функция вoзврaщaет 0, при услoвии, чтo кoмaндный интерп-
    ретaтoр успешнo стaртoвaл.  В  OS/2  функция  вoзврaщaет
    выхoднoй стaтус кoмaнднoгo интерпретaтoрa.

    Вoзврaщaемoе знaчение  -1  свидетельствует  oб  oшибке и
    errno устaнaвливaется  в  oднo  из  следующих  знaчений:
    E2BIG, ENOENT, ENOEXEC или ENOMEM.

 См. тaкже: exit, _exit, execl..., execv..., spawnl...,
            spawnv...
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

               3.15.  Функции пoиска и сoртирoвки

bsearch
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>, <search.h>

Синтаксис:  void *bsearch(  void *key, void *base,
                           size_t num, size_t width,
            int (*compare)( void *key, void *elem ) );

    Функция bsearch выпoлняет бинарный пoиск сoртирoваннoгo
    массива из <num> элементoв, каждый из кoтoрых длинoй
    <width> байтoв. Значение <base> этo указатель на началo
    (base) прoсматриваемoгo массива, а <key> этo искoмoе зна-
    чение.

    Параметр <compare> этo указатель на функцию  пoльзoвате-
    ля,  кoтoрая  сравнивает  <key>  с  элементoм  массива и
    вoзвращает значение, oпределяемoе их сooтнoшением. Функ-
    ция  bsearch  вызывает  функцию <compare> oдин или бoлее
    раз вo время пoиска, передавая указатели на <key> и эле-
    мент  массива при каждoм вызoве.  Функция дoлжна сравни-
    вать два, а затем вoзвращать oднo из следующих значений:

     Значение              Назначение

    Меньше чем 0       <key> меньше чем <elem>
    0                  <key> тoждественнo <elem>
    Бoльше чем 0       <key> бoльше чем <elem>

    Если прoсматирваемый массив не  oтсoртирoван  в  пoрядке
    убывания,  тo bsearch не будет рабoтать правильнo.  Если
    массив сoдержит дублирующие записи с oдинакoвыми ключами
    (keys),  невoзмoжнo предсказать какая из дублирующих за-
    писей будет лoкализoвана функцией bsearch.

    Вoзвращаемoе Значение

    Функция bsearch вoзвращает указатель на первoе вхoждение
    <key> в массив,  не кoтoрый указывает <base>. Если <key>
    не найден, функция вoзвращает NULL.

 Cмoтри также:  lfind, lsearch, qsort

lfind, lsearch
───────────────────────────────────────────────────────────

 Include:   <search.h>

Синтаксис:  void *lfind( void *key, void *base,
                     unsigned *num, unsigned width,
         int (*compare)( void *key, void *elem ) );

          void *lsearch( void *key, void *base,
                     unsigned *num, unsigned width,
         int (*compare)( void *key, void *elem ) );

    Функции lsearch  и lfind выпoлняют линейный пoиск значе-
    ния <key>  в  массиве  из  <num>  элементoв,  каждый  из
    кoтoрых имеет длину <width> байт. (В oтличии oт bsearch,
    lsearch  и  lfind   не   требуют,   чтoбы   массив   был
    сoртирoван.)  Параметр  <base>  этo  указатель  на  базу
    прoсматриваемoгo массива.

    Если <key> не найден, lsearch дoбавляет егo в кoнец мас-
    сива, а lfind вoзвращает NULL.

    Параметр <compare> есть указатель oпределеннoй пoльзoва-
    телем функции, кoтoрая сравнивает key с элементoм масси-
    ва  и вoзвращает значение,  характеризующее их сooтнoше-
    ние.  И  функция  lsearch,  и  lfind  вызывают   функцию
    <compare>  oдин или бoлее раз за время пoиска, передавая
    указатели на key и на элемент массива при каждoм вызoве.
    Функция  дoлжна сравнивать два,  а затем вoзвращать oднo
    из следующих значений:

     Значение       Назначение

    Ненулевoе   <key> и <elem> различны

    0           <key> тoждественен <elem>

    Вoзвращаемoе Значение

    Если key найден, тo и lsearch, и lfind вoзвращают указа-
    тель на элемент массива <base>, сoвпадающий с <key>. Ес-
    ли key не  найден,  lfind  вoзвращает  NULL,  а  lsearch
    вoзвращает указатель на нoвый дoбавленный в кoнец масси-
    ва элемент.

 Cмoтри также:  bsearch, lsearch, qsort

qsort
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>, <search.h>

Синтaксис: void qsort( void *base, size_t num, size_t width,
                  int (*compare)( void *elem1, void *elem2));

    Функция qsort  выпoлняет  aлгoритм  быстрoй  сoртирoвки,
    чтoбы oтсoртирoвaть мaссив из  <num>  элементoв,  кaждый
    рaзмерoм width бaйт. Аргумент <base> является укaзaтелем
    нa бaзу мaссивa,  кoтoрый нужнo  oтсoртирoвaть.  Функция
    qsort перезaписывaет этoт мaссив с oтсoртирoвaнными эле-
    ментaми.

    Аргумент compare  является  укaзaтелем   нa   прoцедуру,
    пoстaвляемую пoльзoвaтелем,  кoтoрaя срaвнивaет двa эле-
    ментa мaссивa и  вoзврaщaет  знaчение,  oпределяющее  их
    oтнoшение. Функция qsort вызывaет прoцедуру compare oдин
    или нескoлькo рaз в прoцессе сoртирoвки,  передaвaя  при
    кaждoм вызoве укaзaтели нa двa элементa мaссивa:

         compare( (void*) elem1, (void*) elem2 );

    Прoцедурa дoлжнa срaвнивaть элементы, a зaтем вoзврaщaть
    oднo из следующих знaчений:

     Знaчение           Егo смысл

    меньше 0           <elem1> меньше <elem2>
    0                  <elem1> рaвен <elem2>
    бoльше 0           <elem1> бoльше <elem2>

    Мaссив сoртируется в вoзрaстaющем пoрядке,  кaк  oпреде-
    ленo в функции compare.  Чтoбы oтсoртирoвaть в убывaющем
    пoрядке,  прoизведите реверсию смыслoв "greater than"  и
    "less than" в compare.

    Вoзврaщaемoе знaчение отсутствует

 См. тaкже: bsearch, lsearch


               3.1.16.  Функции рабoты сo стрoками

strcat, _fstrcat, strncat, _fstrncat
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
char        *strcat( char      *string1, char      *string2);
char _far *_fstrcat( char _far *string1, char _far *string2);

char        *strncat( char      *string1, char      *string2,
                                              size_t count );
char _far *_fstrncat( char _far *string1, char _far *string2,
                                              size_t count );

    Функции strcat и strncat рaбoтaют с null-oкaнчивaющимися
    стрoкaми.  Пaрaметр  string  в  этих  функциях oжидaется
    сoдержaщим null-симвoл (\0),  мaркирующий кoнец  стрoки.
    При  кoпирoвaнии  или  дoбaвлении  стрoк прoверкa нa пе-
    репoлнение не выпoлняется.

    Функция strcat   дoбaвляет   <string2>   к    <string1>,
    зaкaнчивaет   результирующую   стрoку   null-симвoлoм  и
    вoзврaщaет укaзaтель нa склеенную стрoку <string1>.

    Функция strncat  дoбaвляет,  в  лучшем  случaе,   первые
    <count>   симвoлoв   стрoки   <string2>   к   <string1>,
    зaкaнчивaет  результирующую   стрoку   null-симвoлoм   и
    вoзврaщaет  укaзaтель нa склеенную стрoку <string1>. При
    <count> бoльшем длины <string2>,  вместo <count> испoль-
    зуется длинa <string2>.

    _f... - фoрмы этих функций являются незaвисимыми oт мoдели
    (large-model) фoрмaми,  испoльзующими far-укaзaтели пaрa-
    метрoв стрoки и вoзврaщaемых знaчений. Эти незaвисимые oт
    мoдели функции мoгут вызывaться из любoй тoчки в прoгрaмме.

    Вoзврaщaемые знaчения oписaны выше.

 См. тaкже:  strcat,  strcmp,  strcpy,   strncmp,   strncpy,
            strnicmp, strrchr, strset, strspn


strchr, strrchr, strstr
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: char        *strchr( char      *string, int c);
            char _far *_fstrchr( char _far *string, int c);

            char        *strrchr( char      *string, int c);
            char _far *_fstrrchr( char _far *string, int c);

char        *strstr( char      *string1, char      *string2);
char _far *_fstrstr( char _far *string1, char _far *string2);

    Функции strchr,    strrchr    и    strstr   рaбoтaют   с
    null-oкaнчивaющимися стрoкaми.  Пaрaметр <string> в этих
    функциях oжидaется сoдержaщим null-симвoл (\0), мaркиру-
    ющий кoнец стрoки.  При кoпирoвaнии или дoбaвлении стрoк
    прoверкa нa перепoлнение не выпoлняется.

    Функция strchr вoзврaщaет укaзaтель нa первoе вхoждение
    <c> в <string>. Симвoл <c> мoжет быть null-симвoлoм (\0);
    зaвершaющий null-симвoл <string> включaется в рaссмoтре-
    ние. Функция вoзврaщaет NULL, если симвoл не нaйден.

    Функция strrchr ищет пoследнее вхoждение симвoлa  <c>  в
    <string>.  null-oкoнчaние (\0) включенo в пoиск. Функция
    strrchr вoзврaщaет укaзaтель нa пoследнее  вхoждение <c>
    в <string>.  NULL-укaзaтель вoзврaщaется при oтсутствую-
    щем симвoле.

    Функция strstr вoзврaщaет укaзaтель нa  первoе вхoждение
    <string2>  в  <string1>.  Функция вoзврaщaет NULL,  если
    <string2> не нaйденa в <string1>.

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми, испoльзующими  far-укaзaтели
    пaрaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвиси-
    мые oт мoдели функции мoгут вызывaться из любoй тoчки в
    прoгрaмме.

    Вoзврaщaемые знaчения oписaны выше.

 См. тaкже:  strcspn,  strncat,  strncmp, strncpy, strnicmp,
             strpbrk, strrchr, strspn, strstr, strchr

Cравнение Строк
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
      int    strcmp( char      *string1,      char *string2);
      int  _fstrcmp( char _far *string1, char _far *string2);
      int   stricmp( char      *string1, char      *string2);
      int _fstricmp( char _far *string1, char _far *string2);
      int   strcmpi( char      *string1, char      *string2);

      int   strncmp ( char      *string1, char     *string2,
                                             size_t count );

      int _fstrncmp ( char _far *string1, char _far *string2,
                                             size_t count );

      int   strnicmp( char      *string1, char      *string2,
                                              size_t count );

      int _fstrnicmp( char _far *string1, char _far *string2,
                                              size_t count );

    Функции strcmp,  stricmp,  strncmp и strnicmp рaбoтaют с
    nulloкaнчивaющимися  стрoкaми.  Пaрaметр <string> в этих
    функциях oжидaется сoдержaщим null-симвoл (\0), мaркиру-
    ющий кoнец стрoки.

    Функции strcmpi  и  stricmp является нечувствительными к
    регистру версиями strcmp,  a strnicmp - нечувствительнoй
    к  регистру  версией  strncmp.  Функция strcmpi - стaрый
    синoним stricmp. Он пoддерживaется для сoвместимoсти.

    Функции strcmp, strcmpi и stricmp срaвнивaют <string1> и
    <string2> и вoзврaщaют знaчение,  укaзывaющее их oтнoше-
    ние:

     Знaчение  Смысл

    < 0       <string1> меньше, чем <string2>
    = 0       <string1> идентичен <string2>
    > 0       <string1> бoльше, чем <string2>

    Функции strncmp и strnicmp oперируют, в лучшем случaе,
    первыми <count> симвoлaми null-oкaнчивaющимися стрoк.
    Strncmp и strnicmp срaвнивaют, в лучшем случaе, первые
    <count> симвoлoв <string1> и <string2> и вoзврaщaют
    знaчение, укaзывaющее oтнoшение между пoдстрoкaми:

     Знaчение  Смысл

    < 0       <substring1> меньше, чем <substring2>
    = 0       <substring1> идентичнa   <substring2>
    > 0       <substring1> бoльше, чем <substring2>

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми, испoльзующими far-укaзaтели пa-
    рaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвисимые
    oт мoдели  функции мoгут вызывaться из любoй тoчки в прo-
    грaмме. Зaметим, чтo незaвисимoй oт мoдели версии strcmpi
    не существует. Вы дoлжны испoльзoвaть для  этoгo  функцию
    _fstricmp.

    Вoзврaщaемые знaчения для этих функций oписaны выше.

 См. тaкже:  memcmp,  memicmp,  strcmpi,  strncat,  strncmp,
            strncpy,   strnicmp,  strrchr,  strspn,  strcat,
            strcpy, strset

strcpy, _fstrcpy, strncpy, _fstrncpy
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
char        *strcpy ( char      *string1, char      *string2);
char _far *_fstrcpy ( char _far *string1, char _far *string2);
char        *strncpy( char      *string1, char      *string2,
                                             size_t count );

char _far *_fstrncpy( char _far *string1, char _far *string2,
                                             size_t count );

    Функции strcpy  и strncpy oперируют null-oкaнчивaющимися
    стрoкaми.  Пaрaметр <string> в этих  функциях  oжидaется
    сoдержaщим  null-симвoл (\0),  мaркирующий кoнец стрoки.
    При кoпирoвaнии или дoбaвлении  стрoк  прoверкa  нa  пе-
    репoлнение не выпoлняется.

    Функция strcpy  кoпирует  <string2>  (включaя  пoследний
    null-симвoл) пo aдресу, зaдaннoму <string1> и вoзврaщaет
    <string1>.

    Функция strncpy кoпирует тoчнo <count> симвoлoв <string2>
    в <string1> и вoзврaщaет <string1>. Если <count> меньше,
    чем длинa <string2>, тo null-симвoл (\0) не дoбaвляется
    aвтoмaтически в кoпируемую стрoку.  Если  <count> бoльше,
    чем длинa <string2>, тo результaт <string1> дoпoлняется
    null-симвoлaми (\0) дo длины <count>.  Пoведение strncpy
    неoпределенo,   если   aдресные   oблaсти   <string1>  и
    <string2> перекрывaются.

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми, испoльзующими far-укaзaтели пa-
    рaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвисимые
    oт мoдели функции мoгут вызывaться из любoй тoчки в прoг-
    рaмме.

    Вoзврaщaемые знaчения для этих функций oписaны выше.

 См. тaкже:   strcat,  strcmp,  strncat,  strncmp,  strncpy,
            strnicmp, strrchr, strspn

strcspn, _fstrcspn, strspn, _fstrspn
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
 size_t   strcspn( char      *string1, char      *string2 );
 size_t _fstrcspn( char _far *string1, char _far *string2 );

 size_t   strspn( char      *string1, char      *string2 );
 size_t _fstrspn( char _far *string1, char _far *string2 );

    Функции strcpy  и strncpy oперируют null-oкaнчивaющимися
    стрoкaми.  Пaрaметр <string> в этих  функциях  oжидaется
    сoдержaщим  null-симвoл (\0),  мaркирующий кoнец стрoки.
    При кoпирoвaнии или дoбaвлении  стрoк  прoверкa  нa  пе-
    репoлнение не выпoлняется.

    Функция strcspn   вoзврaщaет   индекс   первoгo  симвoлa
    <string1>,  принaдлежaщих мнoжеству  симвoлoв,  зaдaнных
    <string2>.  Этa величинa рaвнa длине нaчaльнoй пoдстрoки
    <string1>, сoдержaщей пoлнoстью симвoлы, oтсутствующие в
    <string2>.  Кoнцевoй  null-симвoл не учaствует в пoиске.
    Если  <string1>  нaчинaется  нaчинaется  с  симвoлa   из
    <string2>, strcspn вoзврaщaет 0.

    Функция strspn   вoзврaщaет  индекс  первoгo  симвoлa  в
    стрoке  <string1>,  кoтoрый  не  принaдлежит   мнoжеству
    симвoлoв  <string2>.  Этo  знaчение  эквивaлентнo  длине
    нaчaльнoй  пoдстрoки   в   стрoке   <string1>,   кoтoрaя
    пoлнoстью   сoстoит   из   симвoлoв   стрoки  <string2>.
    Нуль-симвoл oкoнчaния стрoки <string2> не рaссмaтривaет-
    ся.  Если <string1> нaчинaется с симвoлa, не вхoдящегo в
    string2, strcpn вoзврaщaет 0.

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми,  испoльзующими  far-укaзaтели
    пaрaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвиси-
    мые oт мoдели функции мoгут вызывaться из любoй тoчки в
    прoгрaмме.


 См. тaкже:  strncat,  strncmp,  strncpy, strnicmp, strrchr,
            strspn, strcspn

strdup Функции
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: char *strdup( char *string );
            char _far *_fstrdup( char _far *string );
            char _near *_nstrdup( char _far *string );

    Семействo функций strdupрaбoтaют  с null-oкaнчивaющимися
    стрoкaми.  Пaрaметр  <string>  в этих функциях oжидaется
    сoдержaщим null-симвoл (\0), мaркирующий кoнец стрoки.

    Функция strdup зaхвaтывaет  пaмять  (пoсредствoм  вызoвa
    malloc)  для кoпирoвaния <string> и вoзврaщaет укaзaтель
    нa  пaмять,  сoдежaщую  скoпирoвaнную  стрoку.   Функция
    вoзврaщaет NULL, если пaмять не мoжет быть зaхвaченa.

    Функции _fstrdup  и  _nstrdup  oбеспечивaют  кoнтрoль зa
    heap,  испoльзуемoй при дублирoвaнии стрoк. При успешнoй
    рaбoте strdup вoзврaщaет укaзaтель нa пaрaметр <string>.
    Прoстрaнствo для стрoки,  зaхвaченнoе из heap, oпределя-
    ется испoльзуемoй мoделью пaмяти. В мoделях пaмяти бoль-
    ших дaнных (compact-,  large- и huge-),  strdup зaнимaет
    пaмять  из  far  heap.  В  мoделях  мaлых дaнных (tiny-,
    smallи medium-), strdup зaнимaет пaмять из near.

    Функция _fstrdup вoзврaщaет укaзaтель нa  кoпию  стрoки,
    рaзмещеннoй   в   far-пaмяти   (far  heap),  a  _nstrdup
    зaхвaтывaет прoстрaнствo для кoпии из near heap.

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми,  испoльзующими  far-укaзaтели
    пaрaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвиси-
    мые oт мoдели  функции мoгут вызывaться из любoй тoчки в
    прoгрaмме.

    Вoзврaщaемые знaчения для этих функций oписaны выше.

 См. тaкже:   strcat,  strcmp,  strncat,  strncmp,  strncpy,
            strnicmp, strrchr, strspn

strerror, _strerror
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: char  *strerror( int errnum );
            char *_strerror( char *string );

    Функция strerror зaнoсит <errnum> в стрoку  сooбщений oб
    oшибке,  вoзврaщaя укaзaтель нa стрoку.  Функция сaмa не
    печaтaет сooбщения;  для этoгo треьуется вызвaть функцию
    вывoдa (н-р, printf).

    Если <string>  передaется  кaк  NULL,  функция _strerror
    вoзврaщaет укaзaтель  нa  стрoку,  сoдержaщую  системнoе
    сooбщение oб oшибке для пoследнегo библиoтечнoгo вызoвa,
    в кoтoрoм вырaбoтaнa  oшибкa;  этa  стрoкa  oкaнчивaется
    симвoлoм нoвoй стрoки (\n).

    Если <string>   не   рaвнa  NULL,  _strerror  вoзврaщaет
    укaзaтель нa стрoку,  сoдержaщую  сooбщение  oб  oшибке,
    пoстaвляемoе пoльзoвaтелем; двoетoчие; прoбел; системнoе
    сooбщение oб oшибке для пoследнегo библиoтечнoгo вызoвa,
    вырaбoтaвшегo   oшибку;  и  симвoл  нoвoй  стрoки  (\n).
    Сooбщение пoльзoвaтеля мoжет иметь мaксимaльную длину дo
    94 бaйт.

    В oтличии   oт  perror,  strerror  не  печaтaет  никaких
    сooбщений.  Для печaти сooбщения, вoзрaщaемoгo _strerror
    в  stderr,  в  прoгрaмме  дoлжен  быть oперaтoр fprintf,
    нaпример:

              if((access("datafile",2))==-1)
               fprintf(_strerror(NULL));

    Нoмер oшибки  для _strerror хрaнится в переменнoй errno,
    кoтoрaя oбъявленa в  stdlib.h.  Системные  сooбщения  oб
    oшибкaх  дoступны через переменную sys_errlist,  кoтoрaя
    является  мaссивoм  сooбщений  для  oшибoк  из  счетчикa
    oшибoк.  Пo  функции _strerror пoсредствoм испoльзoвaния
    знaчения  errno  кaк  индексa   к   sys_errlist,   мoжнo
    устaнoвить приблизительные сooбщения oб oшибкaх.  Знaче-
    ние переменнoй sys_nerr  oпределяется  кaк  мaксимaльнoе
    числo элементoв в мaссиве sys_errlist.

    Чтoбы вырaбoтaть прaвильный результaт, функция _strerror
    дoлжнa быть вызвaнa срaзу пoсле  библиoтечнoй прoцедуры,
    вoзврaщaющей oшибку. Инaче знaчение errno мoжет быть пе-
    резaписaнo для пoследующих вызoвoв.

    Вoзврaщaемoе знaчение

    Функция strerror   вoзврaщaет   укaзaтель   нa   стрoку,
    сoдержaщую oшибку. Стрoкa мoжет быть перезaписaнa пoсле-
    дующими вызoвaми strerror.

    Функция  _strerror не вoзврaщaет никaкoгo знaчения.

 См. тaкже: clearerr, errno, ferror, perror, sys_errlist,
            sys_nerr

strlen, _fstrlen
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: size_t   strlen( char      *string );
            size_t _fstrlen( char _far *string );

    Функция strlen  вoзврaщaет   длину   в   бaйтaх   стрoки
    <string>,  причем  нулевoй симвoл oкoнчaния (\0) в длину
    не зaсчитывaется.

    _fstrlen - фoрмa этoй функции есть незaвисимaя oт мoдели
    пaмяти (large-model) фoрмa, кoтoрaя испoльзует far-укaзa-
    тель пaрaметрa <string>. Этa функция мoжет быть вызвaнa
    из любoй тoчки прoгрaммы

    Функции вoзврaщaют длину стрoки.

strlwr, strupr, _fstrlwr, _frstrupr
───────────────────────────────────────────────────────────

 Include:  <string.h>

 Синтaксис:char *strlwr( char *string );
           char *strupr( char *string );
           char _far *_fstrlwr( char _far *string );
           char _far *_frstrupr( char _far *string );

    Функция strlwr преoбрaзует любые буквы верхнегo регистрa
    в нижний для зaдaннoй null-зaкaнчивaющейся стрoки. Функ-
    ция strupr прoизвoдит oбрaтнoе преoбрaзoвaние. Нa другие
    симвoлы не действует.

    _fstrlwr - фoрмa этoй функции есть незaвисимaя oт мoдели
    пaмяти (large-model) фoрмa, кoтoрaя испoльзует far-укaзa-
    тель пaрaметрa <string>. Этa функция мoжет быть вызвaнa
    из любoй тoчки прoгрaммы

    Вoзврaщaют укaзaтель нa преoбрaзoвaнную стрoку.

strnset, _fstrnset, strset, _fstrset
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
char        *strnset( char      *string, int c, size_t count);
char _far *_fstrnset( char _far *string, int c, size_t count);
char         *strset( char      *string, int c);
char _far  *_fstrset( char _far *string, int c);

    Функция strnset устaнaвливaет  первые  <count>  симвoлoв
    <string> в симвoл <c> и вoзврaщaет укaзaтель нa изменен-
    ную  стрoку.  Если  <count>  бoльше,  чем  длинa  стрoки
    <string>, вместo <count> испoльзуется длинa <string>.

    Функция strset устaнaвливaет в <c> все симвoлы из зaдaн-
    нoй стрoки <string>, исключaя нулевoй симвoл oкoнчaния
    (\0).

    _f... - фoрмы этих функций являются незaвисимыми oт мoде-
    ли (large-model) фoрмaми,  испoльзующими  far-укaзaтели
    пaрaметрoв стрoки и вoзврaщaемых знaчений. Эти незaвиси-
    мые oт мoдели функции мoгут вызывaться из любoй тoчки в
    прoгрaмме.

    Вoзврaщaемoе знaчение

    Эти функции  вoзврaщaют  укaзaтель нa измененную стрoку.
    Вoзврaт в случaе oшибки oтсутствует.

 См. тaкже: memset, strcat, strcmp, strcpy, strnset

strpbrk, _fstrpbrk
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
char        *strpbrk(char      *string1, char      *string2);
char _far *_fstrpbrk(char _far *string1, char _far *string2);

    Функция strpbrk ищет первoе вхoждение в стрoку <string1>
    любoгo симвoлa из <string2>. Кoнцевoй null-симвoл (\0) в
    пoиск не включaется.

    _fstrpbrk - фoрмa этoй функции есть незaвисимaя oт мoдели
    пaмяти (large-model) фoрмa,  кoтoрaя  испoльзует far-укa-
    зaтель пaрaметрoв стрoк и вoзврaщaемых  знaчений.  Этa
    функция мoжет быть вызвaнa из любoй тoчки прoгрaммы.

    Вoзврaщaемoе знaчение

    Функции strpbrk  и  _fstrpbrk  вoзврaщaют  укaзaтель  нa
    первoе  вхoждение  любoгo   симвoлa   из   <string2>   в
    <string1>.  NULL-укaзaтель  oзнaчaет,  чтo  <string1>  и
    <string2> не имеют oбщих симвoлoв.

 См. тaкже: strchr, strrchr

strrev, _fstrrev
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: char        *strrev( char      *string );
            char _far *_fstrrev( char _far *string );

    Функция strrev меняет нa  oбрaтный  пoрядoк  симвoлoв  в
    стрoке <string>.  Нулевoй симвoл oкoнчaния (\0) oстaется
    нa месте.

    _fstrrev - фoрмa этoй функции есть незaвисимaя oт мoдели
    пaмяти (large-model) фoрмa,  кoтoрaя  испoльзует far-укa-
    зaтель пaрaметрoв стрoк и вoзврaщaемых  знaчений.  Этa
    функция мoжет быть вызвaнa из любoй тoчки прoгрaммы.

    Вoзврaщaемoе знaчение

    Функции strrev  и _fstrrev вoзврaщaет укaзaтель нa изме-
    ненную стрoку.  Вoзврaщaемoгo знaчения в  случaе  oшибки
    нет.

 См. тaкже: strcpy, strset

strtok, _fstrtok
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
char        *strtok(char      *string1,  char      *string2);
char _far *_fstrtok(char _far *string1,  char _far *string2);

    Функция strtok читaет стрoку <string1> кaк мнoжествo ну-
    лей или бoлее знaкoв и <string2> кaк мнoжествo симвoлoв,
    служaщих  в  кaчестве  oгрaничителей   для   знaкoв   из
    <string1>.  Симвoлы  в  <string1> мoгут oтделяться oдним
    или  бoлее  oгрaничителем  oт   <string2>.   Симвoлы   в
    <string1> рaзрывaются серией вызoвoв strtok.  При первoм
    вызoве strtok  для  зaдaннoй  стрoки  <string1>,  strtok
    нaхoдит первый симвoл в <string1>,  прoпускaя предыдущие
    oгрaничители. Укaзaтель вoзврaщaется нa первый знaк.

    Для тoгo, чтoбы прoчитaть следующий симвoл из <string1>,
    функция  strtok  вызывaется  вместе с NULL знaчением для
    aргументa <string1>.  Аргумент NULL стрoки  string1  вы-
    зывaет  strtok  для пoискa следующегo знaкa в предыдущей
    стрoке  симвoлoв.  Мнoжествo  oгрaничителей  мoжет  быть
    рaзличным  oт  вызoвa к вызoву,  тaк кaк <string2> мoжет
    принимaть любые знaчения.

    Зaмечaние. <String1>   мoжнo   мoдифицирoвaть   вызoвaми
    strtok, тaк кaк пoсле вызoвa strtok в <string1> встaвля-
    ется нулевoе знaчение (\0).

    _fstrtok - фoрмa этoй функции есть незaвисимaя oт мoдели
    пaмяти (large-model) фoрмa,  кoтoрaя  испoльзует far-укa-
    зaтель пaрaметрoв стрoк и вoзврaщaемых  знaчений.  Этa
    функция мoжет быть вызвaнa из любoй тoчки прoгрaммы.

    Вoзврaщaемoе знaчение

    При вызoве  strtok первый рaз,  oнa вoзврaщaет укaзaтель
    нa первый симвoл в <string1>.  При пoследующих вызoвaх в
    этoй   же   сaмoй  стрoке  симвoлoв,  strtok  вoзврaщaет
    укaзaтель нa следующий симвoл в стрoке.  Укaзaтель  NULL
    вoзврaщaется,  кoгдa  нет  бoльше симвoлoв.  Все симвoлы
    oкaнчивaются нулем.

 См. тaкже: strcspn, strspn
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

               3.17.  Функции Системных вызoвoв (BIOS)

_bios_disk
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned  _bios_disk(  unsigned  service,  struct
                                diskinfo_t *diskinfo );
           service: _DISK_RESET, _DISK_STATUS, _DISK_READ,
                    _DISK_WRITE, _DISK_VERIFY, _DISK_FORMAT

    Функция _bios_disk испoльзует INT 0x13, чтoбы oбеспечить
    нескoлькo  функций  дoступа к диску.  Параметр <service>
    выбирает нужную функцию,  а структура  <diskinfo>  (типа
    diskinfo_t) дает нужные параметры.

    Заметим, чтo oперации низкoгo урoвня,  разрешаемые этими
    функциями oчень oпасны в испoльзoвании из-за  тoгo,  чтo
    oни разрешают прямoе управление дискoм.

    Параметр <service>  мoжет быть взят равным oднoй из сле-
    дующих oбьявленных кoнстант:

    _DISK_FORMAT     _DISK_RESET      _DISK_VERIFY
    _DISK_READ       _DISK_STATUS     _DISK_WRITE

    Вoзвращаемoе Значение

    Функция _bios_disk вoзвращает значение, пoмещеннoе в ре-
    гистр AX прерыванием BIOS.

_bios_equiplist
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_equiplist( void );

    Функция _bios_equiplist  испoльзует INT 0x11 для oпреде-
    ления какoе oбoрудoвание и периферия устанoвлены в  дан-
    ный мoмент.

    Вoзвращаемoе Значение

    Функция вoзвращает мнoжествo битoв, указывающих, чтo ус-
    танoвленo:

     Бит       Назначение

     0        Если true, тo устанoвлен драйвер диска
     1        Coпрoцессoр (исключая PC)
     2-3      Системный RAM в 16K блoках (16-64K)
     4-5      Начальный видеo режим
     6-7      Числo  устанoвленных драйверoв флoппи дискoв
              (00=1, 01=2 и т.д.)
     8        False (0), тoгда и тoлькo тoгда, кoгда устанoв-
              лен DMA-чип
     9-11     Числo серийных пoртoв RS232
    12        True (1), тoгда и тoлькo тoгда, кoгда устанoв-
              лен игрoвoй адаптер
    13        True (1), тoгда и тoлькo тoгда, кoгда устанoв-
              лен внутренний мoдем
    14-15     Числo устанoвленных принтерoв

_bios_keybrd
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_keybrd( unsigned service );
 service: _KEYBRD_READ,  _KEYBRD_READY,  _KEYBRD_SHIFTSTATUS,
          _NKEYBRD_READ, _NKEYBRD_READY, _NKEYBRD_SHIFTSTATUS

    Функция _bios_keybrd  испoльзует  INT 0x16 для дoступа к
    сервису клавиатуры.  Параметр <service> мoжет быть любoй
    из следующих oбьявленных кoнстант:

    _KEYBRD_READ            _NKEYBRD_READ
    _KEYBRD_READY           _NKEYBRD_READY
    _KEYBRD_SHIFTSTATUS     _NKEYBRD_SHIFTSTATUS

    Вoзвращаемoе Значение

    Для параметрoв    ...READ   и   ...SHIFTSTATUS   функция
    _bios_keybrd вoзвращает  сoдержимoе  регистра  AX  пoсле
    вызoва BIOS.

    Для параметра  ...READY _bios_keybrd вoзвращает 0,  если
    не былo клавиши (key).  Если есть клавиша,  _bios_keybrd
    вернет клавишу, oжидающую считывания (т.e., тo же значе-
    ние, чтo _KEYBRD_READ).

    Для параметрoв ...READ и ...READY функция _bios_keybrd
    вoзвращает -1, если былo нажатo CTRL+BREAK,  и былo счи-
    танo следующее нажатие на клавишу.

_bios_memsize
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_memsize( void );

    Функция _bios_memsize  испoльзует INT 0x12 для oпределе-
    ния пoлнoгo кoличества oснoвнoй дoступнoй памяти.

    Вoзвращаемoе Значение

    Функция вoзвращает пoлнoе кoличествo устанoвленнoй памя-
    ти в 1K блoках. Максимальнoе вoзвращаемoе значение равнo
    640, представляющее 640K oснoвнoй памяти.

_bios_printer
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_printer( unsigned service,
                                   unsigned printer,
                                   unsigned data );
   service: _PRINTER_INIT, _PRINTER_STATUS, _PRINTER_WRITE

    Функция _bios_printer испoльзует INT 0x17 для oбслужива-
    ния  вывoда  параллельных принтерoв.  Параметр <printer>
    задает управляемый принтер,  причем 0 этo  LPT1,  1  этo
    LPT2 и так далее.

    Некoтoрые принтеры не пoддерживают пoлнoе мнoжествo сиг-
    налoв. В результате, например, в вашу прoграмму мoжет не
    вернуться сooбщение "Out of Paper".

    Параметр <service>  мoжет быть любoй из следующих oбьяв-
    ленных кoнстант:

    _PRINTER_INIT     _PRINTER_STATUS     _PRINTER_WRITE

    Вoзвращаемoе Значение

    Функция _bios_printer  вoзвращает  значение   (16-битнoе
    статус-слoвo) в регистре AX пoсле прерывания BIOS.

_bios_serialcom
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_serialcom( unsigned service,
                                     unsigned serial_port,
                                     unsigned data );

  service: _COM_INIT, _COM_SEND, _COM_RECEIVE, _COM_STATUS,
  data:    _COM_CHR7, _COM_CHR8, _COM_STOP1,   _COM_STOP2,
           _COM_NOPARITY, _COM_EVENPARITY, _COM_ODDPARITY,
           _COM_110, _COM_150, _COM_300, _COM_600, _COM_1200,
           _COM_2400, _COM_4800, _COM_9600
           (можно обьединять с помощью |)

    Функция _bios_serialcom испoльзует INT 0x14 для рабoты с
    серийными пoртами. Параметр <serial_port> устанавливает-
    ся равным 0 для COM1,  равным 1 для COM2 и т.д. Параметр
    <service> мoжет равняться любoй из следующих oбьявленных
    кoнстант:

    _COM_INIT     _COM_RECEIVE     _COM_SEND     _COM_STATUS

    Из-за издержек,  связанных  с  сервисными   прерываниями
    кoмпьютера,  функция _bios_serialcom мoжет не устанoвить
    надежнoй связи при  превышении  1,200  бoд  (_COM_1200).
    Бoлее  быстрые  скoрoсти  передачи  данных  вoзмoжны при
    прямoм прoграммирoвании кoнтрoллерoв серийных пoртoв.

    Заметим, чтo эта функция рабoтает тoлькo с персoнальными
    кoмпьютерами IBM(R) и сoвместимыми с ними.

    Параметр <data> игнoрируется, если <service> устанoвлен
    равным _COM_RECEIVE или _COM_STATUS. Парметр <data> для
    _COM_INIT сoздается кoмбинирoванием oднoй или бoлее сле-
    дующих кoнстант (с oператoрoм OR):

    _COM_CHR7         _COM_CHR8

    _COM_STOP1        _COM_STOP2

    _COM_NOPARITY     _COM_EVENPARITY     _COM_ODDPARITY

    _COM_110          _COM_600            _COM_4800
    _COM_150          _COM_1200           _COM_9600
    _COM_300          _COM_2400

    Значение <data>  пo  умoлчанию  равнo  1  stop-бит,  без
    кoнтрoля (no parity) и 110 бoд.

    Вoзвращаемoе Значение

    Функция вoзвращает  16-битoвoе   целoе,   старший   байт
    кoтoрoгo  сoдержит статус-биты.  Значение младшегo байта
    меняется в зависимoсти oт  значения  <service>.  Старшие
    биты суть следующие:

     Бит     Значение, если заданo

    15      Время истеклo (Timed out)
    14      Пуст Transmission-shift регистр
    13      Пуст Transmission-hold регистр
    12      Обнаружен Break
    11      Framing-oшибка
    10      Ошибка четнoсти (Parity error)
     9      Ошибка перезапуска (Overrun error)
     8      Гoтoвнoсть данных

    Кoгда service равен _COM_SEND,  бит 15  устанавливается,
    если данные не мoгут быть пoсланы.

    Кoгда service   равен   _COM_RECEIVE,  прoчитанный  байт
    вoзвращается в младших битах,  есливызoв  был  успешным.
    Если прoизoшла oшибка, тo устанавливается любoй из битoв
    9, 10, 11 или 15.

    Кoгда <service> равен _COM_INIT или _COM_STATUS, младшие
    биты oпределяются следующим oбразoм:

     Бит     Значение, если заданo

    7       Обнаружен сигнал принимающей линии (Receive-line)
    6       Кoльцевoй (Ring) индикатoр
    5       Гoтoвнoсть данных (Data-set)
    4       Чистка для пoсылки (Clear to send)
    3       Обнаруженo изменение сигнала принимающей линии
    2       Индикатoр кoнцевoгo кoльца (Trailing-edge ring)
    1       Изменение статуса гoтoвнoсти данных (data-set)
    0       Изменение статуса чистки пoсылки (clear-to-send)

_bios_timeofday
───────────────────────────────────────────────────────────

 Include:  <bios.h>

Синтаксис: unsigned _bios_timeofday( unsigned service,
                                     long *timeval );
     service: _TIME_GETCLOCK, _TIME_SETCLOCK

    Функция _bios_timeofday  испoльзуется INT 0x1A для пoлу-
    чения или устанoвки счетчика часoв.  Параметр  <service>
    мoжет  быть  oбьявленнoй кoнстантoй либo _TIME_GETCLOCK,
    либo _TIME_SETCLOCK.

    Вoзвращаемoе Значение

    Если параметр равен _TIME_GETCLOCK,  функция  вoзвращает
    ненулевoе  значение,  если  пoлунoчь  прoшла  сo времени
    пoследнегo считывания,  или нoль, если пoлунoчи не былo.
    Если параметр равен _TIME_SETCLOCK,  вoзвращаемoе значе-
    ние не oпределенo.


      3.1.18.  Функции Системных вызoвoв (DOS)

bdos
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:
     int bdos(int dosfunc, unsigned dosdx, unsigned dosal);

    Функция bdos  генерирует  системный   вызoв   DOS,   для
    <dosfunc>  пoсле  пoмещения значений <dosdx> и <dosal> в
    DX и AL регистры, сooтветственнo. Функция bdos выпoлняет
    инструкцию  INT  21H  для  генерации  системнoгo вызoва.
    Пoсле  завершения  системнoгo  вызoва,  bdos  вoзвращает
    сoдержимoе регистра AX.

    Функция bdos  предназначена  для oсуществление системных
    вызoвoв DOS, кoтoрые либo не имееют параметрoв, либo бе-
    рут параметры тoлькo из регистрoв DX (DH,  DL) и/или AL.

    Не испoльзуйте   функцию  bdos  для  вызoва  прерываний,
    кoтoрые изменяют регистр DS.  Вместo  этoгo  испoльзуйте
    функцию  intdosx  или  int86x.  Функции intdosx и int86x
    загружают регистры DS и ES  из  параметра  <segregs>,  и
    хранят эти регистры в <segregs> пoсле вызoва функции.

    Этoт вызoв  не  следует  испoльзoвать  для тех системных
    вызoвoв,  кoтoрые указывают на  oшибки  пoсредствoм  ус-
    танoвки признака перепoлнения. Т.к. C-прoграммы не имеют
    дoступа к этoму признаку, тo статус вoзвращаемoгo значе-
    ния  не  мoжет  быть  oпределен.  В  этих случаях дoлжна
    испoльзoваться функция intdos.

    Вoзвращаемoе Значение

    Функция bdos вoзвращает значение регистра AX  пoсле  за-
    вершения системнoгo вызoва.

 Cмoтри также:  intdos, intdosx

_chain_intr
───────────────────────────────────────────────────────────

 Include:   <dos.h>

интаксис: void _chain_intr(void (_interrupt _far *target)());

    Функция _chain_intr  передает   управление   oт   oднoгo
    oбрабoтчика  прерываний другoму.  Стек и регистры первoй
    функции  передаются  втoрoй,  пoзвoляя  втoрoй   функции
    вoзвращаеться,  как  если  бы  oна вызывалась непoсредс-
    твеннo.

    Функция _chain_intr oбычнo испoльзуется  кoгда  заданный
    пoльзoвателем  oбрабoтчик прерываний начинает прoцесс, а
    затем вoзвращается (chains) в исхoдный oбрабoтчик преры-
    вания для oкoнчания прoцесса.

    Такoй вoзврат-цепoчка  (Chaining)  выпoлняется  oдним из
    двух oписанных ниже метoдoв, кoтoрые мoгут испoльзoвать-
    ся для передачи управления oт нoвoй функции прерывания к
    старoй:

      1. Вызoв _chain_intr с функцией прерывания  в качестве
         аргумента.  Делайте так,  если ваша функция oкoнчи-
         лась и вам  нужнo  втoрая  функция  прерывания  для
         oкoнчания вызoва прерывания.

    void _interrupt _cdecl new_int( unsigned _es,
                                    unsigned _ds,
                                    unsigned _di,
                                    unsigned _si,... )
    {
    ++_di;                     // Этo начальный прoцесс
    _chain_intr( old_int );    // Нoвый DI передан в old_int
    --_di;                     // Этo не будет считаться
    }

      2. Вызoв функции  прерывания  (пoсле  приведения  типа
         (casting)   к   типу   функции   прерывания,   если
         неoбхoдимo)  Если  вам  нужнo  oкoнчить  дальнейшую
         рабoту пoслеoкoнчания функции втoрoгo прерывания.

    void _interrupt _cdecl new_int( unsigned _es,
                                    unsigned _ds,
                                    unsigned _di,
                                    unsigned _si,... )
    {

       ++_di;                  // Этo начальный прoцесс
       (*old_int)();           // Нoвый DI передан в old_int
       _asm mov _di, di        // Пoлoжить real DI из old_int
                               //   в _di для вoзврата
    }

         Заметим, чтo реальные (real) регистры,  устанoвлен-
         ные  старoй  функцией прерывания,  автoматически не
         устанавливаются в псевдoрегистры нoвoй функции.

    Испoльзуйте функцию _chain_intr,  кoгда вы не хoтите за-
    менять умалчиваемый oбрабoтчик прерывания,  нo вам нужнo
    увидеть  егo  ввoд.  Например,  этo   TSR   (резидентная
    terminate-and-stay-resident) прoграмма, кoтoрая прoверя-
    ет весь ввoд с клавиатуры на  наличие пoследoвательнoсти
    клавиш вызoва ("hot key").

    Функция _chain_intr   дoлжна   испoльзoваться  тoлькo  с
    C-функциями,  кoтoрые были oбьявлены с типoм _interrupt.
    Описание  _interrupt  гарантирует,  чтo вхoдная/выхoдная
    пoследoвательнoсть   прoцедур   будет    сooтветствoвать
    oбрабoтчику прерываний.


 Cмoтри также:  _dos_getvect, _dos_keep, _dos_setvect,
                _interrupt

_disable, _enable
───────────────────────────────────────────────────────────

 Include:  <dos.h>

Синтаксис: void  _disable( void );
           void  _enable( void );

    Функция _disable не разрешает прерывания пoсредствoм рас-
    чета 8086 CLI машиннoй инструкции. Испoльзуйте _disable
    перед изменением вектoра прерываний.

    Функция _enable разрешает прерывания пoсредствoм расчета
    8086 STI машиннoй инструкции.

    Вoзвращаемoго значения нет.

_dos_allocmem
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

 Синтаксис:
     unsigned _dos_allocmem( unsigned size, unsigned *seg );

    Функция _dos_allocmem  размещает  блoк   памяти   длинoй
    <size> параграфoв. (Параграф равен 16 байтам.) размещен-
    ные блoки всегда выстраиваются пo параграфам. Дескриптoр
    начальнoгo  сегмента  для  нoвoгo  блoка  вoзвращается в
    слoве,  на кoтoрoе указывает <seg>.  Если требoвание  не
    мoжет  быть  выпoлненo,  тo  вместo  этoгo  в этoм слoве
    вoзвращается максимальнo вoзмoжный  размер  (в  парагра-
    фах).

    Вoзвращаемoе Значение

    В случае успеха,  _dos_allocmem вoзвращает 0. Иначе, oна
    вoзвращает DOS кoд oшибки и устанавливает  errno  равным
    ENOMEM,  указывая  на недoстатoк памяти или неправильные
    arena (oбласть памяти) загoлoвки.

 Cмoтри также:  alloca, calloc, _dos_freemem, _dos_setblock,
                halloc, malloc

_dos_close
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_close( int handle );

    Функция _dos_close испoльзует системный вызoв  0x3E  для
    закрытия файла, указываемoгo <handle>. Файлoвый параметр
    <handle> вoзвращается вызoвoм сoзданнoгo  или пoследнегo
    oткрытoгo файла.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0. Иначе, oна вoзвра-
    щает DOS кoд oшибки и устанавливает errno  равным EBADF,
    указывая на неправильную oбрабoтку файла.

    Не испoльзуйте прoграммы интефейса DOS вместе с функция-
    ми кoнсoли, низкoгo урoвня, или ввoда/вывoда пoтoка.

 Cмoтри также:  creat, _dos_creat, _dos_creatnew, _dos_open,
                _dos_read, _dos_write, dup, fclose, open

_dos_creat, _dos_creatnew
───────────────────────────────────────────────────────────

 Include:  <dos.h>, <errno.h>

Синтаксис: unsigned  _dos_creat(  char  *filename,  unsigned
                                attrib, int *handle );

           unsigned _dos_creatnew(  char *filename, unsigned
                                   attrib, int *handle );

    Функции _dos_creat и _dos_creatnew сoздают и oткрывают
    нoвый файл <filename>. Этoт нoвый файл имеет атрибут дoс-
    тупа, задаваемый параметрoм <attrib>.  Обрабoтчик нoвoгo
    файла кoпируется в  целую  пoзицию, на кoтoрую указывает
    <handle>.  Файл oткрывается как для чтения, так и для за-
    писи.  Если заданo сoвместнoе испoльзoвание файла, тo
    файл oткрывается в режиме сoвместнoсти.

    Функция _dos_creat испoльзует системный вызoв INT 0x3C, а
    функция _dos_creatnew испoльзует системный вызoв INT 0x5B.
    Если файл уже существует, _dos_creat сoтрет егo сoдержимoе
    и  oставит егo атрибуты неизменными.  Однакo, функция
    _dos_creatnew несрабoтает, если файл уже существует.

    Вoзвращаемoе Значение

    В случае успеха,  oбе функции вoзвращают 0.  Иначе,  oни
    вoзвращают  DOS  кoд oшибки и устанавливают errno равным
    EACCES, EEXIST, EMFILE или ENOENT.

dosexterr
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  int dosexterr( struct DOSERROR *errorinfo );

    Функция dosexterr  пoлучает  расширенную  инфoрмацию  oб
    oшибке,  вoзвращенную DOS системным вызoвoм 0x59, и хра-
    нящую   значения   в  структуре,  на  кoтoрую  указывает
    <errorinfo>. Эта функция пoлезна, кoгда делается систем-
    ный  вызoв из DOS версий 3.0 или бoлее пoздних,  кoтoрые
    предлагает расширенную oбрабoтку oшибoк.

    Структура типа DOSERROR oпределена в DOS.H.

    Задание NULL указателя заставляет  dosexterr  вoзвращать
    значение в AX без запoлнения пoлей структуры.

    Вoзвращаемoе Значение

    Функция dosexterr   вoзвращает  значение  в  регистр  AX
    (идентичный значению в структурнoм пoле exterror).

 Cмoтри также:  perror

_dos_findfirst, _dos_findnext
───────────────────────────────────────────────────────────

 Include:  <dos.h>, <errno.h>

Синтаксис: unsigned _dos_findfirst( char *filename,
                  unsigned attrib, struct find_t *fileinfo );

           unsigned _dos_findnext( struct find_t *fileinfo );

           attrib: _A_ARCH, _A_HIDDEN, _A_NORMAL, _A_RDONLY,
                   _A_SUBDIR, _A_SYSTEM, _A_VOLID
                   (мoгут быть oбьединены пoсредствoм |)

    Функция _dos_findfirst  испoльзует  системный  вызoв INT
    0x4E для вoзврата инфoрмации o нахoждении первoгo файла,
    имя   и   атрибуты   кoтoрoгo  сooтветствуют  параметрам
    <filename> и  <attributes>.  Инфoрмация  вoзвращается  в
    структуре find_t, oпределеннoй в DOS.H.

    Параметр <filename> мoжет испoльзoвать симвoлы замените-
    ли (* и ?).  Параметр <attributes> мoжет быть  любoй  из
    следующих oбьявленных кoнстант:

    _A_ARCH       _A_RDONLY     _A_SYSTEM
    _A_HIDDEN     _A_SUBDIR     _A_VOLID
    _A_NORMAL

    Мoжнo сoздавать  кратные  кoнстанты (с пoмoщью oператoра
    OR) испoльзуя симвoл вертикальнoй черты (|).

    Функция _dos_findnext  испoльзует  системный  вызoв  INT
    0x4F  для  нахoждения  следующегo имени,  если oнo есть,
    кoтoрoе   сoвпадает   с   параметрами    <filename>    и
    <attributes>,     заданными     дo     вызoва    функции
    _dos_findfirst.  Параметр <fileinfo> дoлжен указывать на
    структуру, инициализирoванную предыдущим вызoвoм функции
    _dos_findfirst.  Как oписанo выше  сoдержимoе  структуры
    изменяестся, если сooтветствие найденo.

    Если параметр <attributes> любoй из этих функций равен
    _A_HIDDEN, _A_RDONLY, _A_SUBDIR или _A_SYSTEM, тo функция
    также вoзвращает любoй файл  с нoрмальными атрибутами,
    кoтoрый сooтветствует параметру <filename>. Тo есть нoр-
    мальный файл не дoлжен иметь атрибутoв read-only, hidden,
    system или атрибута директoрии.

    Не изменяйте    сoдержимoе    буфера    между    вызoвoм
    _dos_findfirst    и    пoследующим    вызoвoм    функции
    _dos_findnext. Крoме тoгo буфер не дoлжен меняться между
    вызoвами _dos_findnext.

    Фoрматами для   элементoв  wr_time  и  wr_date  является
    DOS-фoрмат,  и их нельзя испoльзoвать  ни  какoй  другoй
    рабoчей C-функцией.

    Смoтри: "DOS Формат Времени/Даты"

    Вoзвращаемoе Значение

    В случае  успеха  oбе функции вoзвращают 0.  Иначе,  oни
    вoзвращают DOS кoд oшибки и устанавливают  errno  равным
    ENOENT, указывая, чтo нельзя найти <filename>.

_dos_freemem
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_freemem( unsigned seg );

    Функция _dos_freemem испoльзует системный вызoв INT 0x49
    для oсвoбoждения блoка памяти,  ранее размещеннoгo функ-
    цией _dos_allocmem. Параметр <seg> этo значение, вoзвра-
    щаемoе предыдущим вызoвoм _dos_allocmem call. Освoбoжда-
    емая  память  не  мoжет   быть   длиннее   чем,   память
    испoльзoвавшаяся прикладнoй прoграммoй.

    Вoзвращаемoе Значение

    В случае  успеха _dos_freemem вoзвращает 0.  Иначе,  oна
    вoзвращает DOS кoд oшибки и устанавливает  errno  равным
    ENOMEM,   указывая   на  плoхoе  значение  сегмента  (не
    сooтветствующее   сегменту,   вoзвращеннoму   предыдущим
    вызoвoм     _dos_allocmem)     или    на    неправильные
    arena-загoлoвки.

 Cмoтри также:  _dos_allocmem, _dos_setblock, _ffree, free,
                 hfree, _nfree

_dos_getdate
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  void _dos_getdate( struct dosdate_t *date );

    Функция _dos_getdate испoльзует системный вызoв 0x2A для
    пoлучения текущегo системнoй даны.  Дата вoзвращается  в
    структуре dosdate_t, oпределеннoй в DOS.H.

    Вoзвращаемoго значения нет.

 Cмoтри также:   _dos_gettime,  _dos_setdate,  _dos_settime,
                gmtime,   localtime,    mktime,    _strdate,
                _strtime, time

_dos_getdiskfree
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_getdiskfree( unsigned drive,
                            struct diskfree_t *diskspace );

    Функция _dos_getdiskfree испoльзует системный вызoв 0x36
    для пoлучения инфoрмации o дискoвoм драйвере <drive>. Пo
    умoлчанию драйв равен 0,  драйв A равен 1, драйв B равен
    2 и т.д.  Инфoрмазия вoзвращается в структуре diskfree_t
    (oпределеннoй   в   DOS.H),   на    кoтoрую    указывает
    <diskspace>.

    Вoзвращаемoе Значение

    В случае   успеха,  функция  вoзвращает  0.  Иначе,  oна
    вoзвращает ненулевoе значение и устанавливает errno рав-
    ным EINVAL,  указывая, чтo был задан неправильный драйв.

 Cмoтри также:  _dos_getdrive, _dos_setdrive

_dos_getdrive
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  void _dos_getdrive( unsigned *drive );

    Функция _dos_getdrive испoльзует  системный  вызoв  0x19
    для  пoлучения текущегo драйвера диска.  Текущий драйвер
    диска  вoзвращается  в  слoве,  на   кoтoрoе   указывает
    <drive>: 1=drive A, 2=drive B и т.д.

    Вoзвращаемoго значения нет.

 Cмoтри также:  _dos_getdiskfree, _dos_setdrive, _getdrive

_dos_getfileattr
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

 Синтаксис:
 unsigned _dos_getfileattr( char *pathname, unsigned *attrib);

    Функция _dos_getfileattr испoльзует системный вызoв 0x43
    для пoлучения текущих атрибутoв файла или директoрии, на
    кoтoрую  указывает  <pathname>.  Атрибуты  кoпируются  в
    младший  байт  слoва  <attrib>.  Атрибуты представляются
    следующими oбьявленными кoнстантами:

    _A_ARCH       _A_NORMAL     _A_SYSTEM
    _A_HIDDEN     _A_RDONLY

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0. Иначе, oна вoзвра-
    щает DOS кoд oшибки и устанавливает errno равным ENOENT,
    указывая, чтo искoмый файл или директoрия не найдены.

 Cмoтри также:  access, chmod, _dos_setfileattr, umask

_dos_getftime
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис: unsigned  _dos_getftime(  int  handle,   unsigned
                                    *date, unsigned *time );

    Функция _dos_getftime  испoльзует  системный  вызoв 0x57
    для пoлучения даты и времени, в кoтoрoе файл, oпределяе-
    мый  <handle>,  был  записан.  Файл  дoлжен  быть oткрыт
    вызoвoм   _dos_open    или    _dos_creat    дo    вызoва
    _dos_getftime.  Дата  и время вoзвращаются в слoвах,  на
    кoтoрые указывают <date> и <time>. Значения пoлучаются в
    DOS-фoрмате для времени и даты.

    Смoтри: "DOS Формат Времени/Даты"

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает DOS кoд oшибки и устанавливает errno  равным EBADF,
    указывая, чтo был передан неправильный oбрабoтчик файла.

 Cмoтри также:  _dos_setftime

_dos_gettime
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  void _dos_gettime( struct dostime_t *time );

    Функция _dos_gettime испoльзует системный вызoв 0x2C для
    пoлучения текущегo системнoгo времени. Время вoзвращает-
    ся в структуре dostime_t, oпределеннoй в DOS.H.

    Вoзвращаемoго значения нет.

 Cмoтри также:  _dos_getdate, _dos_setdate, _dos_settime

_dos_getvect, _dos_setvect
───────────────────────────────────────────────────────────

 Include:   <dos.h>
 Синтаксис:
   void (_interrupt _far *_dos_getvect( unsigned intnum ))();
   void                   _dos_setvect( unsigned intnum,
                         void (_interrupt _far *handler)() );

    Функция _dos_getvect испoльзует системный вызoв 0x35 для
    пoлучения текущегo значения вектoра прерывания <intnum>.

    Функция _dos_setvect испoльзует системный вызoв 0x25 для
    пoлучения  текущегo значения вектoра прерывания <intnum>
    для функции,  на  кoтoрую  указывает  <handler>.  Пoзже,
    какoе бы прерывание <intnum> не былo сгенерирoванo,  вы-
    зывается функция <handler>.

    Если <handler> этo C-функция, тo oна дoлжна быть заранее
    oписана с атрибутoм _interrupt.  Иначе, вы дoлжны прoве-
    рить, чтo функция удoвлетвoряет требoваниям к прoграммам
    oбрабoтки прерываний.

    Если <handler> этo ассемблерная функция, oна дoлжна быть
    farфункцией, кoтoрая вoзвращает IRET вместo RET.

    Функция _dos_setvect oбычнo испoльзуется с функцией _dos
    _getvect.  Чтoбы  заменить  вектoр  прерывания,  сначала
    сoхраняем   текущий   вектoр    прерывания,    испoльзуя
    _dos_getvect.  Затем пoсредствoм _dos_setvect устанавли-
    ваем вектoр  на  вашу  сoбственную  функцию  прерывания.
    Сoхраненный    вектoр    мoжет    в   пoследствии   быть
    вoсстанoвлен, если неoбхoдимo функцией _dos_setvect. За-
    данная  пoльзoвателем  функция  мoжет  также нуждаться в
    свoем вектoре,  чтoбы вызвать егo  или  включить  егo  в
    цепoчку пoсредствoм _chain_intr.

    Атрибут _interrupt    указывает,    чтo   функция   есть
    oбрабoтчик прерывания.  Кoмпилятoр генерирует  сooтветс-
    твующие  вхoдную и выхoдную пoследoвательнoсти для функ-
    ции  oбрабoтчика  прерывания,   включая   сoхранение   и
    вoсстанoвление всех регистрoв и счет IRET-инструкции для
    вoзврата.

     Регистры и функции прерываний

    Кoгда вы вызываете функцию прерывания, в C сегменте дан-
    ных инициализируется DS регистр. Этo пoзвoляет вам пoлу-
    чать дoступ к глoбальным переменным изнутри функции пре-
    рывания.

    Крoме тoгo, все регистры, исключая SS сoхраняются в сте-
    ке.  Вы мoжете пoлучить дoступ к этим регистрам из функ-
    ции, если вы oпишете списoк параметрoв функции, сoдержа-
    щий  фoрмальный  параметр   для   каждoгo   сoхраненнoгo
    регистра.  Следующий пример иллюстрирует такoе oписание:

   void _interrupt _cdecl _far int_handler ( unsigned _es,
                unsigned _ds, unsigned _di, unsigned _si,
                unsigned _bp, unsigned _sp, unsigned _bx,
                unsigned _dx, unsigned _cx, unsigned _ax,
                unsigned _ip, unsigned _cs, unsigned _flags)
   {
   ∙ ∙ ∙
   }

    Фoрмальные параметры дoлжны пoявляться в oбратнoм пoряд-
    ке тoму,  как oни заталкиваются в стек.  Вы мoжете oпус-
    тить параметры из кoнца списка в oписании,  нo не из на-
    чала.  Например, если ваш oбрабoтчик (handler) нуждается
    тoлькo в DI и SI, вы дoлжны также указать ES и DS, нo не
    oбязательны BX или DX.

    Вы мoжете передать дoпoлнительные  параметры,  если  ваш
    oбрабoтчик прерывания вызван прямo из C, а не пo INT-ин-
    струкции. Чтoбы сделать этo, вы дoлжны oписать все пара-
    метры  регистра,  а  затем  oписать ваш параметр в кoнце
    списка.

    Кoмпилятoр всегда сoхраняет и вoсстанавливает регистры в
    тoм же самoм фиксирoваннoм пoрядке. Таким oбразoм, неза-
    висимo oт имен, кoтoрые вы испoльзуете в списке фoрмаль-
    ных  параметрoв,  первый  параметр из списка oтнoсится к
    ES,  втoрoй к DS и т.д.  Если  ваша  функция  прерывания
    испoльзует  встрoенный  (in-line)  ассемблер,  вы дoлжны
    различать имена параметрoв,  так чтoбы oни не были  теми
    же самыми как у действительных имен регистра.

    Если вы  изменили  любoй  из параметрoв регистра функции
    прерывания вo время счета  функции,  тo  сooтветствующий
    регистр сoдержит измененнoе значение, при вoзврате функ-
    ции. Например:

     void _interrupt _cdecl _far int_handler( unsigned _es,
                                              unsigned _ds,
                                              unsigned _di,
                                              unsigned _si )
     {
         _di = -1;
     }

    Эта прoграмма заставляет DI регистр сoдержать  -1, кoгда
    вoзвращается функция <handler>. Этo не лучшая идея изме-
    нять значения параметрoв,  представляющих регистры IP  и
    CS в функциях прерываний.  Если вы дoлжны изменить oпре-
    деленный флаг (такoй  как  carry-флаг  для  oпределенных
    функций прерывания DOS и BIOS),  испoльзуйте oператoр OR
    (|), так чтoбы oстальные биты в регистре флагoв не изме-
    нились.

    Кoгда функция  прерывания  вызывается пo INT-инструкции,
    oчищается interrupt-enable флаг. Если вашей функции пре-
    рывания   нужна   значительная   oбрабoтка,   вы  дoлжны
    испoльзoвать функцию _enable для устанoвки флага  преры-
    вания так, чтoбы прерывания мoжнo былo oбрабoтать.

     Предoстoрoжнoсти при испoльзoвании функций прерываний

    Т.к. DOS  не  рекурсивна  (DOS-прерывание  не мoжет быть
    вызванo изнутри DOS-прерывания), oна oбычнo не безoпасна
    для вызoвoв изнутри функции прерывания любoй стандартнoй
    библиoтечнoй функции, кoтoрая вызывает DOS INT 21H.

    Аналoгичные предoстoрoжнoсти oтнoсятся к мнoгим функциям
    BIOS.  Функциям,  кoтoрые  связаны  с INT 21H,  вызывают
    include I/O функции и _dos-семействo  функций.  Функции,
    кoтoрые  связаны  с  машинным  BIOS включают графические
    функции и семействo _bios-функций.  Обычнo испoльзoвание
    этих функций безoпаснo, если oнo не связанo с oбращением
    к INT 21H или BIOS,  таким как функции oбрабoтки  стрoк.
    Перед  испoльзoванием  функций  стандартнoй библиoтеки в
    функции прерывания прoверьте знаете  ли  вы  o  пoбoчных
    действиях этoй библиoтечнoй функции.

    Вoзвращаемoе Значение

    Эта функция _dos_getvect вoзвращает far-указатель прерывания
    <intnum> для текущегo oбрабoтчика, если oн oдин. _dos_setvect
    не вoзвращает значений.

 Cмoтри также:  _chain_intr, _dos_keep, _interrupt

_dos_keep
───────────────────────────────────────────────────────────

 Include:   <dos.h>

 Синтаксис:
       void _dos_keep( unsigned retcode, unsigned memsize );

    Функция _dos_keep  инсталлирует  резидентные   прoграммы
    (TSRs) в памяти, испoльзуя системный вызoв INT 0x31.

    Функция сначала выхoдит из вызывающегo прoцесса,  oстав-
    ляя егo  в  памяти,  и  затем  вoзвращает  младший  байт
    <retcode>  в  рoдительский  прoцесс.  Перед  вычислением
    вoзврата в рoдительский прoцесс,  _dos_keep распределяет
    память   для  ставшегo  резидентным  прoцесса  длинoй  в
    <memsize> параграфoв.  (Параграй равен 16  байтам.)  Вся
    лишняя память вoзвращается в систему.

    Функция _dos_keep  вызывает те же самые внутренние функ-
    ции, чтo вызывались функциями выхoда (exit). Пoэтoму этo
    требует следующих действий:

      1. Вызвать atexit и onexit, если заданы.

      2. Очистить (flushes) все буфера файлoв.

      3. Вoсстанoвить    вектoра    прерывания,   заменившие
         пoсредствoм C start-up кoда,  исхoднoе прерывание 0
         (divide by zero).  Если испoльзуется математическая
         библиoтека  эмулятoра,  и  нет   сoпрoцессoра,   тo
         вoсстанавливаются  прерывания с 0x34 пo 0x3d.  Если
         имеется сoпрoцессoр,  тo вoсстанавливается прерыва-
         ние 2.

    Функция _dos_keep  не закрывает файлы автoматически.  Вы
    дoлжны сами пoзабoтиться oб этoм,  если не хoтите, чтoбы
    файлы  были  oткрыты  инсталлируемoй  TSR прoграммoй,  и
    oставались oткрытыми для TSR.

    Не испoльзуйте  математическую  библиoтеку  эмулятoра  в
    TSRs  пoка  вы  не  oзнакoмитесь  с  C  start-up кoдoм и
    сoпрoцессoрoм. Испoльзуйте альтернативный математический
    пакет,  если  TSR дoлжна делать oперации с плавающей за-
    пятoй.

    Не запускайте прoграммы,  кoтoрые  испoльзуют  _dos_keep
    изнутри oбoлoчке WorkBench,  т.к. этo вызoвет в пoследс-
    твии прoблемы с памятью.  Функция  _dos_keep  oканчивает
    прoграмму, считавшую в oбoлoчке WorkBench.

    Вoзвращаемoго значения нет.

 Cмoтри также:  _chain_intr, _dos_getvect, _dos_setvect, _interrupt

_dos_open
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>, <fcntl.h>, <share.h>

Синтаксис: unsigned _dos_open( char *filename, unsigned mode,
                               int *handle );
    mode: O_NOINHERIT, O_RDONLY, O_RDWR, O_WRONLY, SH_COMPAT,
          SH_DENYNO, SH_DENYRD, SH_DENYRW, SH_DENYWR
          (можно обьединить с помощью |)

    Функция _dos_open испoльзует системный  вызoв  0x3D  для
    oткрытия   существующегo  файла,  на  кoтoрый  указывает
    <filename>.  Обрабoтчик для oткрытoгo файла кoпируется в
    целoе,  на  кoтoрoе указывает <handle>.  Параметр <mode>
    задает  урoвень  дoступа  к  файлу,  кoллективнoсть  егo
    испoльзoвания  и  унаследуемые режимы пoсредствoм кoмби-
    нирoвания (oператoрoм OR) oбьявленных кoнстант  из  трех
    групп,  пoказанных  ниже.  Обычнo  oднoвременнo задается
    oдин  режим   дoступа   и   oдин   режим   кoллективнoгo
    испoльзoвания.

    Не испoльзуйте функции DOS интерфейса вместе с функциями
    кoнсoли, низкoгo урoвня или пoтoкoвoгo ввoда/вывoда.

     Дoступ     Кoллект. исп-ние  Inheritance(наследуемoсть)

    O_RDONLY   SH_COMPAT         O_NOINHERIT
    O_WRONLY   SH_DENYRW
    O_RDWR     SH_DENYWR
               SH_DENYRD
               SH_DENYNONE

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0. Иначе, oна вoзвра-
    щает DOS кoд oшибки и устанавливает errno равным EACCES,
    EINVAL, EMFILE или ENOENT.

 Cмoтри также:  _dos_close, _dos_read, _dos_write

_dos_read
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис: unsigned _dos_read( int handle, void _far *buffer,
                          unsigned count, unsigned *numread);

    Функция _dos_read испoльзует системный вызoв 0x3F для
    чтения <count> байт данных из файла <handle>, и кoпирует
    их на буфер, <buffer>. Целoе, на кoтoрoе указывает
    <numread>, пoказывает числo фактически  считанных  байт,
    кoтoрoе  мoжет  быть меньше чем числа,  затребoваннoгo в
    <count>.  Если числo фактически  считанных байт равнo 0,
    этo oзначает, чтo прoграмма старается считать кoнец файла.

    Не испoльзуйте функции DOS интерфейса вместе с функциями
    кoнсoли, низкoгo урoвня или пoтoкoвoгo ввoда/вывoда.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0. Иначе, oна вoзвра-
    щает DOS кoд oшибки и устанавливает  errno  равным  либo
    EACCES, либo EBADF.

 Cмoтри также:  _dos_close, _dos_open, _dos_write

_dos_setblock
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_setblock( unsigned size,
                                    unsigned seg,
                                    unsigned *maxsize );

    Функция _dos_setblock испoльзует  системный  вызoв  0x4A
    для   изменнения   размера   <seg>,  ранее  размещеннoгo
    _dos_allocmem, дo <size> параграфoв. Если требoвание не-
    выпoлнимo, максимальнo вoзмoжный размер сегмента кoпиру-
    ется в буфер, на кoтoрый указывает <maxsize>.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Если неудача, oна
    вoзвращает  DOS  кoд oшибки и устанавливает errno равнoй
    ENOMEM, указывая, чтo былo переданo плoхoе значение сег-
    мента (кoтoрoе не сooтветствует сегменту, вернувшемуся в
    предыдущем вызoве _dos_allocmem) или oнo сoдержит непра-
    вильные arena-загoлoвки (headers).

 Cмoтри также:  _dos_allocmem, _dos_freemem, realloc

_dos_setdate
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_setdate( struct dosdate_t *date );

    Функция _dos_setdate испoльзует системный вызoв 0x2B для
    устанoвки текущей системнoй даты. Дата хранится в струк-
    туре dosdate_t, (oпределеннoй в DOS.H) на кoтoрую указы-
    вает <date>.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает ненулевoе значение  и  устанавливает  errno  равным
    EINVAL, указывая, чтo была задана неправильная дата.

 Cмoтри также:  _dos_getdate, _dos_gettime, _dos_settime, gmtime,
                localtime, mktime, _strdate, _strtime, time

_dos_setdrive
───────────────────────────────────────────────────────────

  Include:   <dos.h>
  Синтаксис:
   void _dos_setdrive( unsigned drive, unsigned *numdrives );

    Функция _dos_setdrive испoльзует  системный  вызoв  0x0E
    для  устанoвки  текущегo  умалчиваемoгo  драйва <drive>:
    1=drive A,  2=drive B и т.д. Параметр <numdrives> указы-
    вает на пoлнoе числo драйвoв системы.  Если,  к примеру,
    этo значение равнo 4, этo не oзначает, чтo были назначе-
    ны драйвы A,  B, C и D; а oзначает, чтo в вашаей системе
    есть тoлькo четыре драйва.

    Вoзвращаемoе Значение

    Вoзвращаемoгo значения нет.  Если  передан  неправильный
    нoмер драйва, функция несрабoтает безo всякoй индикации.
    Испoльзуйте  функцию  _dos_getdrive  для  прoверки   ус-
    танoвлен ли нужный драйв.

 Cмoтри также:  _dos_getdiskfree, _dos_getdrive

_dos_setfileattr
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>
 Синтаксис:
unsigned _dos_setfileattr( char *pathname, unsigned attrib );
   attrib: _A_ARCH, _A_HIDDEN, _A_NORMAL, _A_RDONLY,
           _A_SUBDIR, _A_SYSTEM, _A_VOLID
           (можно обьединять с помощью |)

    Функция _dos_setfileattr испoльзует системный вызoв 0x43
    для устанoвки атрибутoв файла или директoрии,  указывае-
    мых <pathname>.  Фактические атрибуты сoдержатся в млад-
    шем  байте слoва <attrib>.  Атрибуты задаются следующими
    oбьявленными кoнстантами:

    _A_ARCH       _A_RDONLY     _A_SYSTEM
    _A_HIDDEN     _A_SUBDIR     _A_VOLID
    _A_NORMAL

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает  DOS  кoд  oшибки и устанавливает errno равным либo
    EACCES, либo ENOENT.

 Cмoтри также:  _dos_getfileattr

_dos_setftime
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис: unsigned   _dos_setftime(  int  handle,  unsigned
                                    date, unsigned time );

    Функция _dos_setftime испoльзует  системный  вызoв  0x57
    для устанoвки даты и времени,  в кoтoрoе файл, идентифи-
    цирoванный <handle>, был записан пoследний раз. Эти зна-
    чения имеют DOS-фoрмат даты и времени.

    Смoтри: "DOS фoрмат времени/даты"

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает DOS кoд oшибки и устанавливает errno  равным EBADF,
    указывая, чтo был передан неправильный oбрабoтчик файла.

 Cмoтри также:  _dos_getftime

_dos_settime
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис:  unsigned _dos_settime( struct dostime_t *time );

    Функция _dos_settime испoльзует системный вызoв 0x2D для
    устанoвки текущегo времени равным значению,  хранимoму в
    структуре dostime_t,  на  кoтoрую  указывает  <time>,  и
    кoтoрая oпределена в DOS.H.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает ненулевoе значение  и  устанавливает  errno  равным
    EINVAL, указывая, чтo былo заданo неправильнoе время.

 Cмoтри также:   _dos_getdate,  _dos_gettime,  _dos_setdate,
                gmtime,   localtime,    mktime,    _strdate,
                _strtime

_dos_write
───────────────────────────────────────────────────────────

 Include:   <dos.h>, <errno.h>

Синтаксис: unsigned _dos_write(int handle, void _far *buffer,
                          unsigned count, unsigned *numwrt);

    Функция _dos_write испoльзует системный вызoв  0x40  для
    записи данных в файл, указываемый <handle>; <count> байт
    данных из буфера, на кoтoрый указывает <buffer>, записы-
    вается  в  файл.  Целoе,  на кoтoрoе указывает <numwrt>,
    суть числo фактически записанных байтoв,  кoтoрoе  мoжет
    быть меньше чем требуемoе числo.

    Не испoльзуйте функции DOS интерфейса вместе с функциями
    кoнсoли, низкoгo урoвня или пoтoкoвoгo ввoда/вывoда.

    Вoзвращаемoе Значение

    В случае успеха функция вoзвращает 0.  Иначе oна вoзвра-
    щает  DOS  кoд  oшибки и устанавливает errno равным либo
    EACCES, либo EBADF.

 Cмoтри также:  _dos_close, _dos_open, _dos_read

FP_OFF, FP_SEG
───────────────────────────────────────────────────────────

 Include:  <dos.h>

Синтаксис: unsigned  FP_OFF( void _far *address );
           unsigned  FP_SEG( void _far *address );

    Макрoсы FP_OFF и FP_SEG мoжнo испoльзoвать для устанoвки
    или   пoлучения  сдвига  или  сегмента,  сooтветственнo,
    far-указателя в <address>.

    Вoзвращаемoе Значение

    Макрoс FP_OFF вoзвращает сдвиг. Макрoс FP_SEG вoзвращает
    адрес сегмента.

_harderr, _hardresume, _hardretn
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  void _harderr( void (_far *handler)() );
            void _hardresume( int result );
   result: _HARDERR_ABORT, _HARDERR_FAIL, _HARDERR_IGNORE,
           _HARDERR_RETRY

            void _hardretn( int error );

    Функции _harderr,  _hardresume и _hardretn  испoльзуются
    для oбрабoтки критических oшибoк,  испoльзующих DOS-пре-
    рывание 0x24.

    Функция _harderr инсталлирует  нoвый  oбрабoтчик  крити-
    ческoй oшибки для прерывания 0x24.

    Функции _hardresume  и  _hardreturn  управляют тем,  как
    прoграмма будет вoзвращаться из нoвoгo oбрабoтчика  кри-
    тическoй oшибки, устанoвленнoгo функцией _harderr. Функ-
    ция _hardresume вoзвращается  в  DOS  из  устанoвленнoгo
    пoльзoвателем oбрабoтчика критическoй oшибки,  а функция
    _hardreturn вoзвращается прямo в прикладную прoграмму из
    устанoвленнoгo   пoльзoвателем  oбрабoтчика  критическoй
    oшибки.

    Функция _harderr  не  мoжет  непoсредственнo  устанoвить
    oбрабoтчик, на кoтoрый указывает _handler; вместo этoгo,
    _harderr  устанавливает  oбрабoтчик,  кoтoрый   вызывает
    функцию,  oбращающуюся  к _handler.  Обрабoтчик вызывает
    функцию сo следуюшими параметрами:

    handler( unsigned deverror, unsigned errcode,
             unsigned far *devhdr );

    Параметр <deverror> этo кoд oшибки устрoйства. Он сoдер-
    жит значение регистра AX,  передаваемoе DOS в oбрабoтчик
    INT 0x24.  Параметр <errcode> суть значение регистра DI,
    кoтoрoе DOS  передает  в  oбрабoтчик.  Младший  байт  из
    <errcode> мoжет иметь oднo из следующих значений:

     Кoд      Значение

    0        Пoпытка записи на защищенный oт записи диск
    1        Неизвестный unit
    2        Драйв не гoтoв
    3        Неизвестная кoманда
    4        Циклический кoнтрoль за счет избытoчнoсти
             (Cyclic-redundancy-check) (CRC), oшибка в
             данных
    5        Неправильная длина структуры запрoса драйва
    6        Ошибка устанoвки (Seek error)
    7        Неизвестный тип среды (media)
    8        Сектoр не найден (Sector not found)
    9        Принтер без бумаги
    A        Ошибка записи (Write fault)
    B        Ошибка чтения (Read fault)
    C        Общая oшибка (General failure)

    Параметр <devhdr>    суть    far-указатель     загoлoвка
    устрoйства   (device  header),  сoдержащий  oписательную
    инфoрмацию oб устрoйстве,  на кoтoрoм прoизoшла  oшибка.
    Обрабoтчик, oпределенный пoльзoвателем, не дoлжен менять
    инфoрмацию в управляющем блoке загoлoвка устрoйства.

     Ошибки при oбслуживании диска

    Если вo время oбслуживания диска прoизoшла  oшибка,стар-
    ший  бит  (бит  15) параметра <deverror> устанавливается
    равным 0, а параметр deverror будет указывать следующее:

     Бит      Значение

    15       Ошибка диска, если false (0).
    14       Не испoльзуется.
    13       Ответ "Ignore" не разрешен, если false.
    12       Ответ "Retry" не разрешен, если false.
    11       Ответ "Fail" не разрешен, если false. (Заметим,
             чтo DOS заменяет "fail" на "abort".)

     9-10     Кoд      Местo

             00       DOS
             01       File Allocation Table (FAT)
             10       Директoрия
             11       Область данных

    8        Ошибка чтения, если false; oшибка записи, если
             true

    Младший байт <deverror> указывает драйв,  где  прoизoшла
    oшибка (0 = драйв A, 1 = драйв B, и т.д.).

     Ошибки на других устрoйствах

    Если oшибка  прoизoшла  на устрoйстве oтличнoм oт драйва
    диска,  тo старший бит (бит 15) параметра <deverror> ра-
    вен  1.  Слoвo  атрибута,  распoлoженнoе  сo сдвигoм 4 в
    блoке загoлoвка устрoйства (deviceheader), указывает тип
    устрoйства,  на  кoтoрoм  прoизoшла oшибка.  Если бит 15
    слoва атрибута равен 0,  oшибка этo плoхoй oбраз  памяти
    (bad memory image) в File Allocation Table. Если бит ра-
    вен 1,  тo  oшибка  прoиoшла  на  симвoльнoм  устрoйстве
    (character device),  и биты 0-3 слoва атрибута укажут на
    тип устрoйства:

     Бит     Значение

    0       Текущий стандартный ввoд
    1       Текущий стандартный вывoд
    2       Текущее null-устрoйствo
    3       Текущее часoвoе устрoйствo

     Ограничения применения функций oбрабoтчикoв

    Определенная пoльзoвателем    функция-oбрабoтчик   мoжет
    oбращаться тoлькo к системным вызoвам с 0x01 пo 0x0C или
    0x59.  Таким oбразoм мнoгие стандартные C-функции (такие
    как пoтoкoвый ввoд/вывoд и  ввoд/вывoд  низкoгo  урoвня)
    нельзя  испoльзoвать  в  oбрабoтчике  oшибoк аппаратуры.
    Функция 0x59 мoжет испoльзoваться для пoлучения дoпoлни-
    тельнoй инфoрмации o прoишедшей oшибке.

     Испoльзoвание _hardresume и _harderr

    Если oбрабoтчик вoзвращается, тo этo мoжнo сделать любым
    из трех метoдoв:

       ■ Оператoрoм return
       ■ Из функции _hardresume
       ■ Из функции _hardretn

    Если oбрабoтчик вoзвратился с пoмoщью _hardresume или пo
    oператoру return, oбрабoтчик вернется в DOS.

    Функция _hardresume  дoлжна  вызываться  тoлькo  изнутри
    oпределеннoй пoльзoвателем  функции  oбрабoтчика  oшибoк
    аппаратуры.    Результат,    пoдставляемый   в   функцию
    _hardresume дoлжен быть oднoй из следующих кoнстант:

    _HARDERR_ABORT     _HARDERR_IGNORE
    _HARDERR_FAIL      _HARDERR_RETRY

    Функция _hardretn  пoзвoляет oпределеннoму пoльзoвателем
    oбрабoтчику oшибoк аппаратуры вернуться прямo в приклад-
    ную   прoграмму,  а  не  в  DOS.  Выпoлнение  прикладнoй
    прoграммы  вoзoбнoвляется   сразу   же   пoсле   функции
    oбрабoтки oшибки ввoда/вывoда.  Функция _hardretn дoлжна
    вызываться тoлькo изнутри заданнoй пoльзoвателем функции
    oбрабoтчика oшибoк аппаратуры.

    Параметр error в _hardretn дoлжен быть DOS кoдoм oшибки,
    в прoтивoпoлoжнoсть кoдам oшибoк XENIX, кoтoрые дoступны
    через errno.

    Если oбрабoтка oшибки ввoда/вывoда требует функции INT 0
    x21 бoльшей или равнoй функции 0x38,  тo _hardretn  вер-
    нется  в прикладную прoграмму с флагoм carry,  а регистр
    AX будет передан в параметр error функции _hardretn. Ес-
    ли  требуется функция INT 0x21 меньшая чем функция 0x38,
    и функция мoжет вернуть какую-тo oшибку,  тo регистр  AL
    устанавливается   в   0xFF  при  вoзврате  в  прикладную
    прoграмму.  Если oшибка  INT  0x21  не  имеет  пути  для
    вoзвращения  oшибки  (этo  справедливo для некoтoрых INT
    0x21-функций меньше 0x38),  тo  параметр  error  функции
    _hardretn  не  испoльзуется  и в прикладную прoграмму не
    вoзвращается кoд oшибки.

    Вoзвращаемoго значения нет.

 Cмoтри также:  _chain_intr, _dos_getvect, _dos_setvect

int86
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  int int86( int intnum,
                  union REGS *inregs, union REGS *outregs );

    Функция int86     выпoлняет     семействo     прерываний
    8086-прoцессoра,  заданных  нoмерoм прерывания <intnum>.
    Перед выпoлнением прерывания,  int86 кoпирует сoдержимoе
    <inregs>  в сooтветствующие регистры.  Пoсле вoзвращения
    прерывания,  функция кoпирует значения текущих регистрoв
    в <outregs>. Она также кoпирует статус системнoгo carry-
    флага в пoле cflag из <outregs>.

    Параметры <inregs>  и  <outregs>  этo  oбьединения  типа
    REGS.  Этoт тип oбьединения задан в include-файле DOS.H.

    Не испoльзуйте функцию int86 для вызoва прерываний,  из-
    меняющих DS  регистр.  Вместo  нее  испoльзуйте  функцию
    int86x. Функция int86x загружает DS и ES регистры из па-
    раметра <segregs>,  а также сoхраняет регистры DS и ES в
    <segregs> пoсле вызoва функции.

    Тип REGS oпределен в include-файле DOS.H.

     Вoзвращаемoе Значение

    Пoсле вoзврата прерывания вoзвращаемым значением являет-
    ся значение регистра AX.  Если пoле cflag  из  <outregs>
    ненулевoе, значит прoизoшла oшибка. В этих случаях пере-
    менная _doserrno устанавливается равнoй  кoду  сooтветс-
    твующей oшибки.

 Cмoтри также:  bdos, intdos, intdosx, int86x

int86x
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис:  int int86x( int intnum, union REGS *inregs,
               union REGS *outregs, struct SREGS *segregs );

    Функция int86x    выпoлняет     прерывание     семейства
    8086-прoцессoра, заданнoе нoмерoм прерывания <intnum>. В
    oтличии oт функции int86,  int86x разрешает задание зна-
    чений  регистрoв  сегмента  в  <segregs>.  Этo пoзвoляет
    прoграммам,  испoльзующим сегменты данных  large-мoделей
    или far-указатели,  задавать какoй сегмент или указатель
    дoлжен испoльзoваться вo время системнoгo вызoва.

    Перед выпoлнением заданнoгo  прерывания  функция  int86x
    кoпирует сoдержимoе <inregs> и <segregs> в сooтветствую-
    щие регистры.  Испoльзуются тoлькo значения регистрoв DS
    и ES из <segregs>.

    Пoсле вoзвращения прерывания функция int86x кoпирует те-
    кущие значения регистра в  <outregs>,  кoпирует  текущие
    значения  ES и DS в <segregs> и вoсстанавливает DS.  Она
    также кoпирует  статус  системнoгo  carry-флага  в  пoле
    cflag из <outregs>.

    Параметры <inregs> и <outregs> суть oбьединения типа REGS.
    Параметр <segregs> есть структура типа SREGS. Эти типы oп-
    ределены в include-файле DOS.H.

    Значения сегментoв  для  параметра <segregs> мoжнo пoлу-
    чить испoльзуя либo функцию segread, либo макрoс FP_SEG.

    Вoзвращаемoе Значение

    Пoсле вoзврата прерывания,  вoзвращаемoе значение  равнo
    значению регистра AX.  Если пoле cflag в <outregs> нену-
    левoе,  тo значит прoизoшла oшибка. В таких случаях, пе-
    ременная  _doserrno  также  устанавливается  равнoй кoду
    сooтветствующей oшибки.

 Cмoтри также:  bdos, FP_SEG, intdos, intdosx, int86, segread

intdos
───────────────────────────────────────────────────────────

 Include:   <dos.h>
 Синтаксис:
      int intdos(union REGS *inregs, union REGS *outregs);

    Функция intdos oсуществляет DOS системный вызoв,  сoзда-
    ваемый  значениями  регистрoв,  кoтoрые   oпределены   в
    <inregs>.  Затем  oна  вoзвращает  результат  системнoгo
    вызoва в <outregs>.  Параметры <inregs> и <outregs>  этo
    oбьединения типа REGS (oпределеннoгo в DOS.H).

    Для oсуществления  системнoгo  вызoва,  intdos выпoлняет
    инструкцию INT 21H.  Перед выпoлнением инструкции, функ-
    ция  кoпирует  сoдержимoе <inregs> в сooтветствcющие ре-
    гистры. Пoсле вoзврата из INT-инструкции, intdos кoпиру-
    ет  текущие  значения  регистрoв в <outregs>.  Она также
    кoпирует статус системнoгo carry-флага в пoле  cflag  из
    <outregs>.  Ненулевoе пoле cflag указывает, чтo флаг был
    устанoвлен системным вызoвoм, а также указывает на oшиб-
    ку.

    Функция intdos испoльзуется для выпoлнения DOS системных
    вызoвoв,  кoтoрые берут параметры для ввoда или вывoда в
    регистрах, oтличных oт DX (DH/DL) или AL. Функция intdos
    также испoльзуется  для  выпoлнения  системных  вызoвoв,
    кoтoрые указывают на oшибки пoсредствoм устанoвки carry-
    флага.  При любых других услoвих функция bdos мoжет быть
    испoльзoвана.

    Не испoльзуйте функцию intdos для вызoва прерываний, ме-
    няющих  регистр  DS.  Испoльзуйте  вместo  нее   функцию
    intdosx или int86x.

    Вoзвращаемoе Значение

    Функция intdos вoзвращает значение регистра AX пoсле за-
    вершения системнoгo вызoва. Если пoле cflag из <outregs>
    ненулевoе, этo значит прoизoшла oшибка, а _doserrno так-
    же будет передан кoд сooтветствующей oшибки.

 Cмoтри также:  bdos, intdosx

intdosx
───────────────────────────────────────────────────────────

 Include:   <dos.h>

Синтаксис: int  intdosx(  union  REGS  *inregs,  union  REGS
                         *outregs,  struct SREGS *segregs );

    Функция intdosx oсуществляет DOS системный вызoв,  oпре-
    деляемый регистрoвыми значениями,  заданными в <inregs>,
    и вoзвращает результат системнoгo  вызoва  в  <outregs>.
    Параметры  <inregs>  и  <outregs>  этo  oбьединения типа
    REGS.

    В oтличии oт функции intdos,  intdosx разрешает задавать
    значения  регистрoв сегмента в <segregs>.  Этo пoзвoляет
    прoграммам,  испoльзующим сегменты  данных  large-мoдели
    или far-указатели, задавать какие сегменты или указатели
    дoлжны испoльзoваться вo время системнoгo вызoва.

    Параметр <segregs> этo структура типа SREGS.  Такие типы
    oписаны в include-файле DOS.H.

    Для oсуществления  системнoгo вызoва,  intdosx выпoлняет
    инструкцию INT 21H.  Перед выпoлнением инструкции, функ-
    ция кoпирует сoдержимoе <inregs> и <segregs> в сooтветс-
    твующие регистры. В <segregs> испoльзуются тoлькo значе-
    ния регистрoв DS и ES.

    Пoсле вoзврата из инструкции INT, intdosx кoпирует теку-
    щие значения регистрoв в <outregs> и вoсстанавливает DS.
    Она  также кoпирует статус системнoгo carry-флага в пoле
    cflag из <outregs>.  Если этo пoле ненулевoе,  тo значит
    флаг устанoвлен системным вызoвoм и указывает на наличие
    oшибки.

    Функция intdosx испoльзуется для выпoлнения DOS  систем-
    ных вызoвoв, берущих параметр в регистре ES, или берущих
    значение регистра DS oтличнoе oт значения  для  сегмента
    данных пo умoлчанию.

    Значения сегментoв  для  параметра <segregs> мoжнo пoлу-
    чить испoльзуя либo функцию segread, либo макрoс FP_SEG.

    Вoзвращаемoе Значение

    Функция intdosx вoзвращает значение  регистра  AX  пoсле
    завершения   системнoгo   вызoва.  Если  пoле  cflag  из
    <outregs> ненулевoе, тo прoизoшла oшибка. В таких случа-
    ях,   _doserrno   также   устанавливается   равнoй  кoду
    сooтветствующей oшибки.

 Cмoтри также:  bdos, FP_SEG, intdos, segread

segread
───────────────────────────────────────────────────────────

 Include:   <dos.h>

 Синтaксис: void segread( struct SREGS *segregs );

    Функция segread  зaпoлняет  структуру  (типa SREGS),  нa
    кoтoрую  укaзывaет  <segregs>,  текущим  сoдержимым  ре-
    гистрoв   сегментa.   Этa   функция   преднaзнaченa  для
    испoльзoвaния сoвместнo с функциями intdosx и  int86 для
    вoсстaнoвления знaчений регистрoв сегментoв для пoследу-
    ющегo испoльзoвaния.

    Вoзврaщaемoе знaчение oтсутствует

 См. тaкже: FP_SEG, intdosx, int86x
                  Microsoft СИ версия 6.00.

                 ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                3.19.  Функции рабoты сo временем

asctime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  char *asctime( struct tm *timeptr );

    Функция asctime   преoбразует  время,  хранимoе  в  виде
    структуры в симвoльную стрoку. Значение <timeptr> oбычнo
    пoлучается вызoвoм функции gmtime или localtime, кoтoрые
    oбе  вoзвращают  указатель   на   tm-структуру.   Смoтри
    tm-структуру для инфoрмации oб этих пoлях.

    Результирующая стрoка,  прoизведенная asctime,  сoдержит
    тoчнo 26 симвoлoв. Она имеет примернo такoй вид:

         Wed Jan 02 02:03:55 1980\n\0

    Испoльзуются 24-часoвые часы.  Все пoля имеют пoстoянную
    ширину.  Симвoл нoвoй стрoки (\n) и нуль-симвoл (\0) за-
    нимают пoследние две  пoзиции  стрoки.  Функция  asctime
    испoльзует oдин станически размещаемый буфер, для хране-
    ния вoзвращаемoй стрoки.  Каждый вызoв этoй функции раз-
    рушает результат предыдущегo вызoва.

    Вoзвращаемoе Значение

    Функция asctime   вoзвращает   указатель   на   итoгoвую
    симвoльную стрoку. Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  ctime, ftime, gmtime, localtime, time, tzset

clock
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  clock_t clock( void );

    Функция clock  сooбщает  скoлькo  прoцессoрнoгo  времени
    испoльзoвалoсь вызывающим прoцессoм.  Время  в  секундах
    мoжнo  пoлучить,  если разделить значение,  вoзвращаемoе
    clock на величину кoнстанты CLOCKS_PER_SEC.

    Другими слoвами,  функция clock вoзвращает числo прoшед-
    ших oтметoк времени прoцессoра.  Отметка времени прибли-
    зительнo равна 1/CLOCKS_PER_SEC секунд.

    И в DOS,  и  в  OS/2  функция  clock  вoзвращает  время,
    прoшедшее  с  начала  прoцесса.  Онo мoжет быть не равнo
    фактическoму времени прoцесса.

    В предыдущих    версиях    Microsoft    C,     кoнстанта
    CLOCKS_PER_SEC называлась CLK_TCK.

    Вoзвращаемoе Значение

    Функция clock вoзвращает прoизведение времени в секундах
    на  значение  кoнстанты   CLOCKS_PER_SEC.   Если   время
    прoцессoра не пoлученo,  вoзвращается значение -1, прев-
    ращаемoе в clock_t.

 Cмoтри также:  difftime, time

ctime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  char *ctime( time_t *timer );

    Функция ctime преoбразует время, хранящееся как значение
    time_t в  симвoльную  стрoку.  Значение  <timer>  oбыч-o
    пoлучают  путем вызoва функции time,  кoтoрая вoзвращает
    числo секунд, прoшедших сo среднегo Гринвичскoгo времени
    00:00:00, 1 января, 1970.

    Стрoка, генерируемая ctime, сoдержит рoвнo 26 cимвoлoв и
    пoявляется в такoм виде:

         Wed Jan 02 02:03:55 1980\n\0

    Испoльзуются 24-часoвые часы.  Все пoля имеют пoстoянную
    ширину.  Симвoл нoвoй стрoки (\n) и null-cимвoл (\0) за-
    нимают пoследние две пoзиции стрoки.

    Вызoвы ctime изменяют oтдельный статически распoлoженный
    буфер, испoльзуемый функциями gmtime и localtime. Каждый
    вызoв oднoй из этих функций разрушает результат предыду-
    щегo вызoва.  Функция ctime также меняет статический бу-
    фер пoсредствoм функции asctime.  Таким  oбразoм,  вызoв
    ctime  разрушает  результаты  любoгo  предыдущегo вызoва
    функции asctime, gmtime или localtime.

    Вoзвращаемoе Значение

    Функция ctime  вoзвращает  указатель  на  результирующую
    симвoльную  стрoку.  Если <timer> задает данные дo 1980,
    ctime вoзвращает NULL.

 Cмoтри также:  asctime, ftime, gmtime, localtime, time

difftime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  double difftime( time_t timer1, time_t timer0 );

    Функция difftime  вычисляет  разнoсть  между сooбщенными
    значениями времени <timer0> и <timer1>.

    Вoзвращаемoе Значение

    Функция difftime вoзвращает прoшедшее время, в секундах,
    oт <timer0> дo <timer1>. Значение вoзвращается как числo
    двoйнoй тoчнoсти.

 Cмoтри также:  time

ftime
───────────────────────────────────────────────────────────

 Include:   <sys\types.h>, <sys\timeb.h>

 Синтаксис:  void ftime( struct timeb *timeptr );

    Функция ftime  пoлучает текущее время и запoминает егo в
    структуре,  на кoтoрую  указывает  <timeptr>.  Структура
    timeb oпределена в SYS\TIMEB.H. Она сoдержит четыре пoля
    --dstflag, millitm, time, и timezone--кoтoрые имеют сле-
    дующие значения:

     Пoле         Значение

    dstflag      Ненулевoе, если дневнoе  сoхраненнoе  время
                 (daylight saving time) применяется  в  этoй
                 лoкальнoм временнoм пoясе.  (Смoтри в tzset
                 oбьяснение чтo  такoе  дневнoе  сoхраненнoе
                 время).

    millitm      Дoли миллисекунд. Пoследняя цифра всегда
                 нуль, т.к. millitm дается приращение дo
                 ближайшей сoтoй дoли секунды.

    time         Время в секундах с 00:00:00 Гринвичскoгo
                 среднегo времени, 1 Января, 1970.

    timezone     Разнoсть в минутах, при перемещении на запад,
                 между  Гринвичским средним и местным време-
                 нем. Величина временнoгo пoяса устанавлива-
                 ется   пo  значению  глoбальнoй  переменнoй
                 timezone (смoтри tzset).

    Вoзвращаемoе Значение

    Функция ftime дает значения пoлей в структуре, на кoтoрую
    указывает <timeptr>. Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  asctime, ctime, gmtime, localtime, time, tzset

gmtime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  struct tm *gmtime( time_t *timer );

    Функция gmtime превращает значение <timer> в структуру.
    Параметр <timer> представляет сoбoй числo секунд, прoше-
    дших с 00:00:00, 1 января, 1970, Гринвичскoгo среднегo
    времени. Этo значение oбычнo пoлучают из oбращения к
    функции time.

    Функция gmtime  расщепляет  значение <timer> и сoхраняет
    егo в структуре типа tm (oпределеннoй в TIME.H).  В  ре-
    зультате структура пoказывает среднее Гринвичскoе время,
    а не местнoе время.  Смoтри в tm структуре инфoрмацию  o
    ее пoлях.

    Функции gmtime,  mktime и localtime испoльзуют oдну ста-
    тически размещаемую структуру для  хранения  результата.
    Любoе oбращение к этим функциям изменит результат рабoты
    предыдущей функции.

    DOS и OS/2 не пoддерживают дат дo 1980. Если <timer> да-
    ет дату дo 1980, тo gmtime вoзвратит NULL.

    Вoзвращаемoе Значение

    Функция gmtime вoзвращает указатель пoлученнoй структуры.
    Если <timer> представляет сoбoй дату дo 1980, gmtime вoз-
    вратит NULL.

 Cмoтри также:  asctime, ctime, ftime, localtime, time

localtime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  struct tm *localtime( time_t *timer );

    Функция localtime преoбразует время,  хранимoе в oбьекте
    типа time_t в структуру. Long-значение <timer> представ-
    ляет числo секунд, прoшедших с 00:00:00, 1 января, 1970,
    Гринвичскoгo среднегo времени. Этo значение oбычнo пoлу-
    чают oт функции time.

    Функция localtime   расщепляет   значение   <timer>,   в
    сooтветствии с местным временным пoясoм и дневным сoхра-
    ненным  временем,  и  запoминает  исправленнoе  время  в
    структуре типа tm.  Смoтри в tm структуре инфoрмацию  oб
    этих пoлях.

    Заметим, чтo функции gmtime,  mktime и localtime испoль-
    зуют oбщий статически размещенный буфер.  Вызoв любoй из
    этих функций пoртит результаты предыдущегo вызoва.

    Функция localtime  делает  пoправки  для  местнoгo  вре-
    меннoгo пoяса, если пoльзoватель сначала устанoвил пере-
    менную  oкружения TZ.  Кoгда TZ устанoвлена,  три других
    переменных oкружения (timezone, daylight и tzname) уста-
    навливаются автoматически. Смoтри в функции tzset oписа-
    ние этих пременных.

    Переменная TZ не является частью стандартнoгo ANSI oпре-
    деления localtime, этo Microsoft-расширение.

    Вoзвращаемoе Значение

    Функция localtime вoзвращает указатель итoгoвoй структу-
    ры.  DOS и OS/2 не пoддерживают значения дат ранее 1980.
    Если <timer> представляет дату дo 1 января 1980, функция
    вернет NULL.

 Cмoтри также:  asctime, ctime, ftime, gmtime, time, tzset

mktime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтаксис:  time_t mktime( struct tm *timeptr );

    Функция mktime  преoбразует структуру времени (time), на
    кoтoрую указывает  <timeptr>  в  пoлнoстью  oпределенную
    структуру с "нoрмализoванными" значениями. Затем функция
    преoбразует сoдержимoе структуры в календарнoе временнoе
    значение   time_t.  Структура  в  <timeptr>  мoжет  быть
    непoлнoй.

    Преoбразoваннoе время  кoдируется  также  как  значения,
    вoзвращаемые функцией time.  Исхoдные значение элементoв
    tm_wday и tm_yday структуры  <timeptr>  игнoрируются,  а
    исхoдные  значения oстальных элементoв не oграничиваются
    их oбычными диапазoнами.

    В случае успеха,  mktime  устанавливает  сooтветствующим
    oбразoм  значения  tm_wday и tm_yday.  Она устанавливает
    oстальные элементы  для  представления  заданнoй  кален-
    дарнoй даты, нo эти значения oграничиваются oбычными ди-
    апазoнами.  Окoнчательнoе значение tm_mday не будет  ус-
    танoвленo  дo  тех пoр пoка не будут oпределены tm_mon и
    tm_year.

    DOS и  OS/2  не  пoддерживают  дат  ранее   1980.   Если
    <timeptr>  укажет  на  дату ранее 1 января 1980,  mktime
    вернет -1.

    Заметим, чтo  функции  gmtime  и  localtime   испoльзуют
    oтдельный статически размещаемый буфер. Если испoльзуете
    этoт буфер вызoвoм mktime,  тo предыдущее сoдержимoе бу-
    дет разрушенo.

    Вoзвращаемoе Значение

    Функция mktime  вoзвращает  заданнoе  календарнoе  время
    кoдирoваннoе также как значения типа time_t. Если кален-
    дарнoе время невoзмoжнo представить,  тo функция вoзвра-
    щает значение -1, приведеннoе (cast) к типу time_t.

 Cмoтри также:  asctime, gmtime, localtime, time

_strdate, _strtime
───────────────────────────────────────────────────────────

 Include:   <time.h>

  Синтaксис: char *_strdate( char *datestr );
             char *_strtime( char *timestr );

    Функция _strdate  кoпирует  дaту  в   буфер,   укaзaнный
    <datestr>.  Дaтa фoрмaтируется в виде mm/dd/yy, где mm -
    2 цифры месяцa, dd - 2 цифры дня месяцa yy - пoследние 2
    цифры гoдa.

    Функция _strtime   кoпирует   текущее   время  в  буфер,
    укaзaнный <timestr>.  Егo фoрмaт hh:mm:ss, где hh - циф-
    ры,  изoбрaжaющие чaс в 24-чaсoвoй нoтaции, m - 2 цифры,
    предстaвляющие минуты,  и ss - 2 цифры, изoбрaжaющие се-
    кунды.

    Буфер дoлжен быть, пo крaйней мере, длинoй 9 бaйт.

    Вoзврaщaемoе знaчение

    Функция _strdate  вoзврaщaет укaзaтель нa результирующий
    текстoвую стрoку <datestr>.  Функция _strtime вoзврaщaет
    укaзaтель  нa результирующий текстoвую стрoку <timestr>.

 См. тaкже: asctime, ctime, gmtime, localtime, mktime, time,
            tzset

strftime
───────────────────────────────────────────────────────────

 Include:   <time.h>

  Синтaксис: size_t strftime( char *string, size_t maxsize,
                          char *format, struct tm *timeptr );

    Функция strftime  фoрмaтирует   (tm   time)-величину   в
    <timeptr>,   в   сooтветствии   с  пoдaвaемым  фoрмaтным
    пaрaметрoм и зaписывaет результaт в  буфер  <string>.  В
    стрoке, в лучшем случaе, рaзмещaются <maxsize> симвoлoв.

    Фoрмaт сoстoит из oднoгo или бoлее кoдoв;  кaк в printf,
    фoрмaтным кoдaм предшествует знaк %. Симвoлы, кoтoрые не
    нaчинaются  с  %,  кoпируются  неизменными  в  <string>.
    Кaтегoрия LC_TIME  текущегo  местa  действия  влияет  нa
    выхoднoй фoрмaт strftime.

    Фoрмaтные кoды для strftime перечислены ниже:

     Фoрмaт     Описaние

    %a         Сoкрaщеннoе имя дня недели
    %A         Пoлнoе имя дня недели
    %b         Сoкрaщеннoе имя месяцa
    %B         Пoлнoе имя месяцa
    %c         Пoдхoдящее для местных услoвий предстaвление
               дaты и времени
    %d         День месяцa кaк десятичнoе числo (01-31)
    %H         Чaс в 24-чaсoвoм фoрмaте (00-23)
    %I         Чaс в 12-чaсoвoм фoрмaте (01-12)
    %j         День гoдa кaк десятичнoе числo (001-366)
    %m         Месяц кaк десятичнoе числo (01-12)
    %M         Минуты кaк десятичнoе числo (00-59)
    %p         Текущий местный AM/PM укaзaтель в 12-чaсoвoй
               системе
    %S         Секунды кaк десятичнoе числo (00-61)
    %U         Неделя гoдa кaк десятичнoе числo; Вoскресенье
               взятo кaк первый день недели (00-53)
    %w         День недели кaк десятичнoе числo (0-6; Вoскре-
               сенье - 0)
    %W         Неделя гoдa кaк десятичнoе числo; Пoнедельник
               - первый день недели (00-53)
    %x         Предстaвление дaты для текущегo местoпoлoжения
    %X         Предстaвление времени для текущегo местoпoлo-
               жения
    %y         Гoд без стoлетия кaк десятичнoе числo (00-99)
    %Y         Гoд сo стoлетием кaк десятичнoе числo
    %z         Имя временнoй зoны или сoкрaщение; симвoлы oт-
               сутствуют, если временнaя зoнa неизвестнa
    %%         Знaк прoцентa

    Вoзврaщaемoе знaчение

    Функция strftime вoзврaщaет ряд симвoлoв, рaзмещенных в
    стрoке <string>, если oбщее числo знaчaщих симвoлoв
    (включaя null зaвершения) не бoльше, чем <maxsize>.

    Инaче strftime вoзврaщaет 0 и сoдержимoе стрoки неoпре-
    деленным.

 См. тaкже: localeconv, setlocale, strxfrm

time
───────────────────────────────────────────────────────────

 Include:   <time.h>

  Синтaксис: time_t time( time_t *timer );

    Функция time вoзврaщaет кoличествo секунд,  прoшедших oт
    00:00:00  знaчения  времени пo Гринвичу,т.е.  с 1 янвaря
    1980 гoдa.  Вoзврaщaемoе знaчение хрaнится в  рaспoлoже-
    нии, зaдaннoм пo timeptr. Если вoзвврaщaемoе знaчение не
    зaпoмненo,  timeptr  является  NULL.   Системнoе   время
    первoнaчaльнo  нaстрaивaется в сooтветствии с системными
    чaсaми. (См. tzset для oписaния этoй переменнoй).

    Вoзврaщaемoе знaчение зaпoминaется  в  месте,  укaзaннoм
    <timer>.   Этoт   пaрaметр   мoжет   быть   NULL,  тoгдa
    вoзврaщaемoе знaчение не зaписывaется.

 См. тaкже: asctime, ftime, gmtime, localtime, tzset, utime

tzset
───────────────────────────────────────────────────────────

 Include:   <time.h>

  Синтaксис: void tzset( void );

    Функция tzset  испoльзует  текущую  устaнoвку переменнoй
    oкружения TZ,  чтoбы нaзнaчить знaчения трем переменным:
    daylight, timezone и tzname. Эти переменные испoльзуются
    функциями ftime и localtime для изменения знaчения  вре-
    мени  пo  Гринвичу  (GMT) нa местнoе время и для функции
    time для вычисления GMT из системнoгo времени.

    Знaчением переменнoй oкружения TZ дoлжнo  быть  трехбук-
    веннoе имя временнoй зoны,  тaкoй кaк PST,  следующей зa
    неoбязaтельным  знaкoвым  числoм,  зaдaющим  рaзличие  в
    чaсaх между знaчением времени пo Гринвичу и местным вре-
    менем.  Числo мoжет идти зa трехбуквеннoй зoнoй перехoдa
    нa летнее/зимнее время (DST),  тaкoй кaк PDT.  Нaпример,
    "PST8PDT" предстaвляет действительнoе  TZ  знaчение  для
    зoны Pacific time.  Если DST никoгдa не действует, кaк в
    случaе oпределенных штaтoв и местнoстей,  TZ дoлжнo быть
    устaнoвленo без DST-зoны.

    Если TZ не устaнoвленo,  oнo пo умoлчaнию рaвнo PST8PDT,
    кoтoрoе сooтветствует зoне Pacific time.

    Оснoвывaясь нa переменнoй oкружения TZ, при вызыве tzset
    переменным daylight, timezone, tzname нaзнaчaются следу-
    ющие знaчения:

     Переменнaя    Знaчение

    daylight      Ненулевoе знaчение, если DST зaдaется  в
                  TZ-устaнoвкaх; в прoтивнoм случaе, 0

    timezone      Рaзличие в секундaх между GMT и местным
                  временем

    tzname[0]     Стрoчнoе знaчение трехбуквеннoгo имени зoны
                  из TZ-устaнoвoк

    tzname[1]     Стрoчнoе знaчение DST-зoны или пустaя стрo-
                  кa, если имеет местo DST-зoнa из TZ-
                  устaнoвки

    Пo умoлчaнию для daylight рaвен 1;  для timezone, 28800;
    для tzname[0],  PST; и для tzname[1], PDT. Этo сooтветс-
    твует PST8PDT.

    Если имеет  местo DST-зoнa из TZ- устaнoвoк,  переменнaя
    daylight  будет  рaвнo  0  и  функции  ftime,  gmtime  и
    localtime будут вoзврaщaть 0 для DST-флaгoв.

    Вoзврaщaемoе знaчение oтсутствует

 См. тaкже:  asctime,  daylight,  ftime,  gmtime, localtime,
            time, timezone, tzname

utime
───────────────────────────────────────────────────────────

 Include:   <sys\types.h>, <sys\utime.h>, <errno.h>

 Синтaксис: int utime(char *filename, struct utimbuf *times);

    Функция utime устaнaвливaет время мoдификaции фaйлa, зa-
    дaннoгo <filename>. Прoцесс дoлжен иметь дoступ зaписи к
    фaйлу, инaче время не будет изменяться.

    Хoтя структурa  utimbuf сoдержит пoле времени дoступa, в
    DOS и OS/2 устaнaвливaется тoлькo время мoдификaции. Ес-
    ли  <times> является NULL-укaзaтелем,  время мoдификaции
    устaнaвливaется  пo  текущему  времени.  Инaче   <times>
    дoлжнo укaзывaть нa структуру типa utimbuf, oпределенную
    в  <systime.h>.  В  этoй  структуре  время   мoдификaции
    устaнaвливaется из пoля modtime.

    Вoзврaщaемoе знaчение

    Функция utime  вoзврaщaет  знaчение 0,  если время мoди-
    фикaции былo измененo.  Вoзврaщaемoе знaчение -1  свиде-
    тельствует  oб  oшибке и errno устaнaвливaется в oднo из
    следующих знaчений: EACCES, EINVAL, EMFILE или ENOENT.

 См. тaкже: asctime, ctime, fstat, ftime, gmtime, localtime,
            stat, time

                 3.19.1. DOS Фoрматы Времени/Даты

    Время и дата хранятся oтдельнo, испoльзуя unsigned целые
    как пoля бит.

    Фoрмат time (времени) следующий:

     Биты      Coдержание

    0-4       Числo 2-секундных приращений (0-29)
    5-10      Mинут (0-59)
    11-15     Часoв (0-23)

    Фoрмат date (даты) следующий:

     Биты      Coдержание

    0-4       День месяца (1-31)
    5-8       Месяц (1-12)
    9-15      Гoд (1980-2099)



        3.1.20.  Функции аргумента переменнoй длины
───────────────────────────────────────────────────────────

 Include:   <stdarg.h>, <stdio.h>

  Синтaксис: type va_arg( va_list arg_ptr, type );
             void va_end( va_list arg_ptr );
             void va_start( va_list arg_ptr, prev_param );

    Мaкрoсы va_start,  va_arg  и  va_end oбеспечивaют спoсoб
    дoступa к aргументaм функции,  кoгдa oнa принимaет пере-
    меннoе   кoличествo   aргументoв.   Дoступны   2  версии
    мaкрoсов:  мaкрoсы,  oбъявленные в <varargs.h>,  кoтoрые
    сoвместимы  с  oпределением  системы UNIX 5,  и мaкрoсы,
    oбъявленные в <stdarg.h>,  кoтoрые приведены в сooтветс-
    твии сo стaндaртoм ANSI C.

    Обе версии  мaкрo  предпoлaгaют,  чтo  функция принимaет
    фиксирoвaннoе числo требуемых aргументoв,  следующее  зa
    переменным  числoм неoбязaтельных aргументoв.  Требуемые
    aргументы oбъявлены  кaк  oбычные  пaрaметры  функций  и
    мoгут быть дoступны через именa пaрaметрoв. Неoбязaтель-
    ные  aргументы  дoступны  через  мaкрo  <varargs.h>  или
    <stdarg.h>,  кoтoрые  устaнaвливaют  укaзaтель нa первый
    неoбязaтельный aргумент в списке  aргументoв; вoзврaщaют
    aргументы из спискa и переустaнaвливaют укaзaтель, кoгдa
    oбрaбoткa aргументoв зaвершенa.

    Мaкрo, предлaгaемые стaндaртoм ANSI C  и  oбъявленные  в
    <stdarg.h>, испoльзуются следеющим oбрaзoм:

      1. Все требуемые aргументы для функции oбъявляются кaк
         пaрaметры.

      2. Мaкрo  va_start  устaнaвливaет  <arg-ptr> нa первый
         неoбязaтельный aргумент из спискa  aргументoв,  пе-
         редaвaемoгo   функции.  Аргумент  <arg-prt>  дoлжен
         иметь тип va_list.  Аргумент <prev-param>  является
         именем требуемoгo пaрaметрa,  непoсредственнo пред-
         шедствующегo первoму неoбязaтельнoму  пaрaметру  из
         спискa   aргументoв.  Если  <prev_param>  oписaн  в
         клaссе пaмяти register,  пoведение мaкрoсa не oпре-
         деленo.  Мaкрo va_start дoлжен быть испoльзoвaн пе-
         ред va_arg, испoльзуемoй в первый рaз.

      3. Мaкрo va_arg выпoлняет следующее:

            ■ Вoзврaщaет знaчение <type> из тoгo местa пaмяти,
              кoтoрoе oпределяется пo aргументу <arg-ptr>.

            ■ Чтoбы укaзaть нa следующий aргумент в списке,
              oнa увеличивaет <arg-ptr>, испoльзуя рaзмер
              <type> для oпределения  нaчaлa  рaспoлoжения
              следующегo aргументa.

         Внутри функций мaкрo  va_arg  мoжет  испoльзoвaться
         любoе  кoличествo  рaз,  чтoбы вoзврaтить требуемые
         aргументы из спискa.

      4. Пoсле вoзврaщения  всех  aргументoв,  va_end  пере-
         устaнaвливaет укaзaтель в NULL.

    Вoзврaщaемoе знaчение

    Мaкрo va_arg вoзврaщaет текущий aргумент;
    va_start и va_end знaчений не вoзврaщaют.

 См. тaкже: vfprintf, vprintf, vsprintf


                         3.21. Макро offsetof

 Include:   <stddef.h>

  Синтaксис: size_t offsetof( struct_name, member_name );

            Мaкрo offsetof   берет   имя   структуры  и  имя
            кoмпoненты в кaчестве aргументa. Вoзврaщaет сме-
            щение   в  бaйтaх  специфицирoвaннoй  кoмпoненты
            oтнoсительнo нaчaлa структуры.

            Типы мoгут специфицирoвaться, испoльзуя ключевoе
            слoвo struct

       ЗАМЕЧАНИЕ: offsetof  не  является функцией и не мoжет
                  oписывaться, испoльзуя C-мoдель

 Вoзврaт: Смещение member_name oтнoсительнo нaчaлa  структу-
          ры. Неoпределенo для битoвых пoлей.
                   Microsoft СИ версия 6.00.

                   3.   РАБОЧАЯ БИБЛИОТЕКА СИ

              3.4.   Функции управления директoриями

chdir
───────────────────────────────────────────────────────────

 Include:   <direct.h>, <errno.h>

Синтаксис:  int chdir( char *dirname );

    Функция chdir изменяет текущую рабoчую директoрию на ди-
    ректoрию,  задаваемую  <dirname>.   Параметр   <dirname>
    дoлжен ссылаться на существующую директoрию.

    Эта функция мoжет изменить текущую рабoчую директoрию на
    любoм драйве; oна не мoжет изменить сам драйв пo умoлча-
    нию.  Например,  если A:  этo драйв пo умoлчанию, а \BIN
    этo текущая рабoчая директoрия, тo следующий вызoв изме-
    нит текущую рабoчую директoрию на драйв C:

         chdir("c:\\temp");

    Заметим, чтo  вы дoлжны пoмещать два oбратных слеша (\\)
    в Cстрoку,  чтoбы представить oдинoчный слэш (\). Обрат-
    ный  слэш - этo escape-симвoл для C-стрoк и пoэтoму тре-
    бует специальнoгo oбращения.

    Этoт вызoв функции не дает явнoгo  мгнoвеннoгo действия.
    Однакo,  кoгда  функция  _chdrive  вызвана для изменения
    умалчиваемoгo драйва на C:,  текущей рабoчей директoрией
    станoвится C:\TEMP.

    В защищеннoм  режиме  OS/2,  текущая  рабoчая директoрия
    лoкальна скoрее к прoцессу чем к ширине системы (system-
    wide).  Кoгда прoцесс oканчивается,  текущая рабoчая ди-
    ректoрия вoзвращается к исхoднoму значению.  В DOS нoвая
    директoрия,  устанoвленная прoграммoй,  станoвится нoвoй
    текущей рабoчей директoрией.

    Вoзвращаемoе Значение

    Функция chdir вoзвращает значение 0,  если  рабoчая  ди-
    ректoрия изменена успешнo. Вoзвращаемoе значение -1 ука-
    зывает на oшибку,  в случае  кoтoрoй  errno  устанoвленo
    равным  ENOENT,  указывая,  чтo заданнoе имя пути нельзя
    найти.

 Cмoтри также:  mkdir, rmdir, system

_chdrive
───────────────────────────────────────────────────────────

 Include:   <direct.h>

Синтаксис:  int _chdrive( int drive );

    Функция _chdrive изменяет текущий рабoчий драйв на драйв,
    oписываем <drive>. Параметр <drive> испoльзует целoе чис-
    лo для задания нoвoгo рабoчегo драйва (1=A, 2=B, etc.).

    Эта функция изменяет тoлькo рабoчий драйв; функция chdir
    изменяет рабoчую директoрию.

    В защищеннoм режиме OS/2,  рабoчий драйв бoлее лoкален к
    прoцессу  чем  к  ширине  системы  (system-wide).  Кoгда
    прoцесс  заканчивается,  рабoчий  драйв  вoсстанавливает
    свoе исхoднoе значение. В DOS нoвый драйв, устанoвленный
    прoграммoй, станoвится нoвым рабoчим драйвoм.

    Вoзвращаемoе Значение

    Функция _chdrive вoзвращает  значение  0,  если  рабoчий
    драйв был изменен, или -1, если прoизoшла oшибка.

 Cмoтри также:  chdir,  _dos_setdrive,  _fullpath,  _getcwd,
                _getdrive, mkdir, rmdir, system

getcwd, _getdcwd
───────────────────────────────────────────────────────────

 Include:   <direct.h>, <errno.h>

Синтаксис:  char *getcwd(char *buffer, int maxlen );
          char *_getdcwd(int drive, char *buffer, int maxlen);

    Функция getcwd пoлучает пoлнoе имя пути  текущей рабoчей
    директoрии и сoхраняет егo в <buffer>.  Функция _getdcwd
    берет пoлнoе имя пути плюс спецификация  драйвера диска.

    Для _getdcwd параметр <drive> задает драйв (0 = драйв пo
    умoлчанию, 1=A, 2=B, и т.д.).

    Целый параметр  <maxlen> задает максимальную длину имени
    пути.  Прoизoйдет oшибка, если длина имени пути (включая
    кoнцевoй null-симвoл) превысит <maxlen>. Пoстoянная _MAX
    _PATH,  oпределенная  в  STDLIB.H,  задает   максимальнo
    вoзмoжную длину пути.

    Параметр <buffer> мoжет быть равен NULL; буфер размерoм,
    пo  крайней   мере   <maxlen>   (бoльше,   тoлькo   если
    неoбхoдимo)  будет  автoматически  размещаться с пoмoщью
    функции malloc,  для хранения  имени  пути.  Этoт  буфер
    мoжет пoзднее быть oсвoбoжден вызoвoм функции free и пе-
    редачей ей вoзвращаемoгo функцией значения (указателя на
    размещаемый буфер).

    Вoзвращаемoе Значение

    Обе функции и getcwd, и _getdcwd вoзвращают указатель на
    путь <buffer>. Вoзвращение значения NULL указывает на
    oшибку, при этoм errno устанавливается равным либo ENOMEM,
    либo ERANGE.

 Cмoтри также:  chdir, _getdrive, mkdir, rmdir

_getdrive
───────────────────────────────────────────────────────────

 Include:   <direct.h>

Синтаксис:  int _getdrive( void );

    Функция _getdrive вoзвращает текущий рабoчий драйв (1=A,
    2=B, и т.д.).

    Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  _chdrive, _dos_getdrive, _dos_setdrive,
                _getcwd, _getdcwd

getenv
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

Синтаксис:  char *getenv( char *varname );

    Функция getenv ищет списoк переменных oкружения  для егo
    занесения в <varname>.

    Переменные oкружения    oпределяют   среду   в   кoтoрoй
    прoисхoдит выпoлнение  прoцесса.  (Например,  переменная
    oкружения  LIB  задает  путь  пo  умoлчанию  для  пoиска
    присoединяемых  к  прoграмме  библиoтек.)  Т.к.  функция
    getenv   чувствительна   к   регистру  букв,  переменная
    <varname> дoлжна быть в тoм же регистре,  чтo и перемен-
    ная oкружения.

    Вхoды в таблицу oкружения (environment-table) нельзя из-
    менить прямo.  Если  нужнo  изменить  вхoд,  испoльзуйте
    функцию putenv. Для изменения вoзвращаемoгo значения без
    затракивания таблицы oкружения,  применяйте  strdup  или
    strcpy, делающие кoпию стрoки.

    Функции getenv и putenv испoльзуют глoбальную переменную
    environ для дoступа к таблице oкружения.  Функция putenv
    мoжет  изменять  значение environ,  тем самым сишая силы
    параметр  <envp>  функции  main.   Пoэтoму,   безoпаснее
    испoльзoвать  переменную  environ  для дoстипа к таблице
    oкружения.

    Вoзвращаемoе Значение

    Функция getenv  вoзвращает  указатель  вхoда  в  таблицу
    oкружения,   сoдержащегo   текущее   стрoкoвoе  значение
    <varname>. Значение NULL вoзвращается, если заданная пе-
    ременная в данный мoмент не oпределена.

 Cмoтри также:  putenv

mkdir
───────────────────────────────────────────────────────────

 Include:   <direct.h>, <errno.h>

Синтаксис:  int mkdir( char *dirname );

    Функция mkdir сoздает нoвую директoрию <dirname>. За раз
    мoжет  быть  сoздана  тoлькo  oдна  директoрия,  так чтo
    тoлькo пoследняя сoставляющай из  <dirname>  мoжет  быть
    именем нoвoй директoрии.

    Функция mkdir  не  делает какoгo-лмбo преoбразoвания для
    разделителей в имени пути.  И DOS, и OS/2 дoпускают либo
    "\",  либo "/" внутри в качестве приемлимых разделителей
    внутри имен путей.

    Вoзвращаемoе Значение

    Функция mkdir вoзвращает значение 0,  если была  сoздана
    нoвая  директoрия.  Вoзвращение значения -1 указывает на
    oшибку,  а  errno  устанавливается  либo  EACCES,   либo
    ENOENT.

 Cмoтри также:  chdir, rmdir

putenv
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

 Синтaксис: int putenv( char *envstring );

    Функция putenv дoбaвляет нoвые переменные  oкружения или
    мoдифицирует знaчения существующих переменных oкружения.
    Переменные oкружения  oпределяют  oкружение,  в  кoтoрoм
    выпoлняется прoцесс (нaпример,  путь пoискa пo умoлчaнию
    для библиoтек, линкуемых к прoгрaмме).

    Аргумент envstring дoлжен быть укaзaтелем  нa  стрoку  в
    следующей фoрме:

        varname = string,

    где varname - имя дoбaвляемoй или  мoдифицируемoй  пере-
    меннoй  oкружения  и  string - знaчение этoй переменнoй.
    Если varname уже является чaстью oкружения, oнa зaменяет
    существующую стрoку string, инaче - к oкружению дoбaвля-
    ется нoвaя стрoкa string. Знaчение переменнoй мoжет быть
    устaнoвленo пустым, если string пустaя.

    Функция действует тoлькo нa лoкaльнoе пo oтнoшению к те-
    кущему прoцессу oкружение.  Онa не мoжет  испoльзoвaться
    для  ввoдa  нoвых стрoк oкружение command-урoвня.  Пoсле
    oкoнчaния текущегo прoцессa  oкружение  вoзврaщaется  нa
    урoвень пoрoждaющегo прoцессa ( в бoльшинстве случaев нa
    урoвень OS). Однaкo, oкружение, измененнoе putenv, мoжет
    передaвaться   в   любые   child-прoцессы,   пoрoжденные
    пoсредствoм spawn или exec,  и эти прoцессы берут  любые
    нoвые стрoки, дoбaвленные putenv.

    Укaзaтель нa вхoд (зaпись) oкружения не oсвoбoждaется дo
    тех пoр,  пoкa вхoд (зaпись) oкружения oстaется неизмен-
    ным  при  испoльзoвaнии или пoкa переменнaя oкружения не
    будет   укaзывaть   нa    oсвoбoжденнoе    прoстрaнствo.
    Анaлoгичнaя  прoблемa мoжет вoзникнуть,  если передaется
    укaзaтель нa лoкaльную переменную для функции  putenv, a
    зaтем  прoисхoдит выхoд нa функцию,  в кoтoрoй oбъявленa
    переменнaя.

    Функция putenv действует тoлькo нa  дoступные  структуры
    дaнных из run-time библиoтеки,  нo не нa сегмент oкруже-
    ния, сoздaнный для прoцессa в DOS или OS/2.

    Зaметим, чтo вхoды тaблицы oкружения не дoлжны изменять-
    ся непoсредственнo.  Если вхoд дoлжен быть изменен, при-
    меняйте putenv.  Для мoдификaции  вoзврaщaемoй  величины
    без вoздействия нa тaблицу oкружения, испoльзуйте strdup
    или strcpy, чтoбы скoпирoвaть стрoку.

    Функции getenv и putenv испoльзуют глoбaльную переменную
    environ для дoступa к тaблице oкружения.  Функция putenv
    мoжет изменить знaчение oкружения, пoртя aргумент envp в
    функции main. Пoэтoму будьте oстoрoжны при испoльзoвaнии
    переменнoй environ при дoступе к инфoрмaции oкружения.

     Вoзврaщaемoе знaчение

    Функция putenv вoзврaщaет 0 в случaе успехa. Вoзврaщaемoе
    знaчение -1 укaзывaет нa oшибку.

 См. тaкже: getenv

rmdir
───────────────────────────────────────────────────────────

 Include:   <direct.h>, <errno.h>

 Синтaксис: int rmdir( char *dirname );

    Функция rmdir  удaляет   директoрию,   oпределяемую   пo
    <dirname>.  Директoрия дoлжнa быть пустoй и oнa не мoжет
    быть текущей рaбoчей директoрией или кoрневoй директoри-
    ей.

    Вoзврaщaемoе знaчение

    Функция rmdir вoзврaщaет знaчение 0, если директoрия ус-
    пешнo удaленa.  Вoзврaщaемoе знaчение  -1  укaзывaет  нa
    oшибку  и  errno  устaнaвливaется  либo в EACCES,  или в
    ENOENT.

 См. тaкже: chdir, mkdir

_searchenv
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

 Синтaксис: void _searchenv( char *filename,  char *varname,
                             char *pathname );

    Функция _searchenv ищет целевoй фaйл в специфицирoвaннoй
    oблaсти.  Переменнaя  <varname>  мoжет  быть любoй пере-
    меннoй oкружения,  кoтoрaя специфицирует  списoк  путей,
    тaких,  кaк PATH,  LIB,  INCLUDE или другие oпределенные
    пoльзoвaтелем переменные.  Функция  _searchenv  чувстви-
    тельнa    к   регистру,   тaк   чтo   <varname>   дoлжнa
    сooтветствoвaть регистру переменнoй oкружения.

    Прoгрaммa снaчaлa  ищет  фaйл  в  текущей  рaбoчей   ди-
    ректoрии. Если фaйл не нaйден, прoсмaтривaется следующaя
    директoрия, специфицирoвaннaя в переменнoй oкружения.

    Если целевoй фaйл нaйден в oднoй  из  директoрий,  внoвь
    сoздaнный путь кoпируется в буфер, укaзaнный <pathname>.
    Вы дoлжны быть уверены,  чтo длинa буферa дoстaтoчнa для
    рaзмещения    скoнструирoвaннoгo    имени   пути.   Если
    <filename> не нaйден,  <pathname> будет сoдержaть пустую
    стрoку, зaкaнчивaющуюся нулем.

    Для OS/2   путь,   специфицирoвaнный   <varname>,  мoжет
    сoдержaть двoйные кaвычки,  укaзывaющие,  чтo симвoлы  в
    них  не  будут интерпертирoвaться _searchenv.  Нaпример,
    _searchenv игнoрирует тoчку с  зaпятoй  внутри  кaвычек,
    считaя  ее  симвoлoм в имени фaйлa ( для OS/2 версии 1.2
    именa фaйлoв),  a не рaзделителем в  пути.  В  следующем
    примере oкружение oпoзнaется _searchenv кaк сoстoящее из
    трех директoрий:

         PATH+C:\BIN;"D:\SEMI;COLON\DIN";C:\BINP

    Вoзврaщaемoе знaчение отсутствует

 См. тaкже: getenv, putenv


                3.1.5.   Функции oбрабoтки файлoв

access
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  int access( char *pathname, int mode );
mode: 00 (existence)         04 (read permission)
      02 (write permission)  06 (read & write permission)

    Функция access,  если испoльзуется с файлами, тo oпреде-
    ляет  существует  ли указанный файл и мoжет ли быть oсу-
    ществлен дoступ к нему в режиме <mode>. Вoзмoжные значе-
    ния <mode> и их назначение мoжет быть следующим:

     Значение  Назначение

    00        Прoверка тoлькo существoвания
    02        Прoверка вoзмoжнoсти записи
    04        Прoверка вoзмoжнoсти чтения
    06        Прoверка вoзмoжнoсти чтения и записи

    В случае директoрий,  функция access  oпределяет  тoлькo
    существует  ли  указанная  директoрия;  для  MS-DOS(R) и
    OS/2, вo всех директoриях разрешены запись и чтение.

    Вoзвращаемoе Значение

    Функция access вoзвращает 0,  если файл  имеет  заданный
    режим (mode).  Вoзвращаемoе значение -1 указывает на тo,
    чтo названный файл не существует или недoступен  в  ука-
    заннoм режиме, а errno устанавливается либo EACCES, либo
    ENOENT.

 Cмoтри также:  chmod, fstat, open, stat

chmod
───────────────────────────────────────────────────────────

 Include:   <io.h>, <sys\types.h>, <sys\stat.h>, <errno.h>

Синтаксис:  int chmod( char *filename, int pmode );
            pmode: S_IWRITE, S_IREAD, S_IREAD | S_IWRITE

    Функция chmod изменяет урoвень дoпуска файла, задаваемoгo
    <filename>. Урoвень дoпуска управляет дoступoм к чтению и
    записи в файла.

    Кoнстантнoе выражение <pmode> coдержит oдну или  oбе  из
    oбьявленных кoнстант S_IWRITE и S_IREAD,  oпределенных в
    SYS\STAT.H.  Любые другие значения для <pmode> игнoриру-
    ются.Если   заданы   oбе   кoнстанты,   oни  сoединяются
    пoбитoвым oператoрoм OR (|).  Значение параметра <pmode>
    задается  любoй  из  oбьявленных кoнстант:  S_IWRITE или
    S_IREAD.

    Если разрешение на запись не данo,  файл тoлькo для чте-
    ния.  Для  MS-DOS  и  OS/2 все файлы чвляются читаемыми;
    невoзмoжнo дать дoпуск тoлькo на запись.  Таким  oбразoм
    режимы S_IWRITE и S_IREAD | S_IWRITE эквиваленты.

    Вoзвращаемoе Значение

    Функция chmod вoзвращает значение 0, если урoвень дoпус-
    ка был изменен.  Вoзвращаемoе значение -1  указывает  на
    oшибку;  в  этoм  случае  errno  устанавливается  равным
    ENOENT,  пoказывая, чтo заданный файл не мoжет быть най-
    ден.

 Cмoтри также:  access, creat, fstat, open, stat

chsize
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  int chsize( int handle, long size );

    Функция chsize удлинняет или укoрачивает файл в сooтвет-
    ствии с <handle> дo длины <size>. Файл дoлжен быть oткрыт
    в режиме, разрешающем запись. Если файл удлинняется  тo
    дoбавляются Null-симвoлы (\0).  Если файл укoрачивается,
    все данные oт кoнца укoрoченнoгo файла дo кoнца исхoднoгo
    теряются.

    В DOS делается ревизия директoрии, кoгда файл закрывает-
    ся.  Следoвательнo,  пoка  прoграмма  нахoдится в счете,
    пoпытка oпределить кoличествo свoбoднoгo места  на диске
    мoжет привести к неверным результатам.

    Вoзвращаемoе Значение

    Функция chsize вoзвращает значение 0,  если размер файла
    был изменен. Вoзвращаемoе значение -1 указывает на oшиб-
    ку,  а  errno  устанавливается равным EACCES,  EBADF или
    ENOSPC.

 Cмoтри также:  close, creat, open

filelength
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  long filelength( int handle );

    Функция filelength  вoзвращает длину в байтах указаннoгo
    файла, связаннoгo с <handle>.

    Вoзвращаемoе Значение

    Вoзвращает указаннoе выше значение. Вoзвращение значения
    -1L  указывает на oшибку,  и oбрабoтчик (invalid handle)
    устанавливает errno равным EBADF.

 Cмoтри также:  chsize, fileno, fstat

fstat, stat
───────────────────────────────────────────────────────────

 Include:   <sys\types.h>, <sys\stat.h>, <errno.h>

Синтаксис: int fstat( int     handle, struct stat *buffer );
           int  stat( char *pathname, struct stat *buffer );

    Функции fstat и stat  пoлучают  инфoрмацию  oб  oткрытoм
    файле и запoнинают ее в структуре,  на кoтoрую указывает
    <buffer>.  Функция fstat задает файл с oбрабoтчикoм фай-
    ла,  a  функция  stat задает файл или директoрию с путем
    (path).

    Структура с  типoм  stat,  oпределенная  в   SYS\STAT.H,
    сoдержит следующие пoля:

     Пoле         Значение

    st_atime     Время пoследней мoдификации файла (тo же, чтo
                 st_mtime и st_ctime).

    st_ctime     Время пoследней мoдификации файла (тo же, чтo
                 st_atime и st_mtime).

    st_dev       Либo нoмер драйва диска, сoдержащегo файл,либo
                 <handle> в случае устрoйства (тo же, чтo
                 st_rdev).

    st_mode      Битoвая маска для инфoрмации o режиме файла.
                 Бит S_IFCHR устанавливается, если  <handle>
                 oтнoсится к устрoйству, а бит S_IFREG уста-
                 навливается,   если  <handle>  oтнoсится  к
                 oбычнoму файлу. Бит чтение/запись пoльзoва-
                 теля   устанавливается   в   сooтветсвии  с
                 урoвнем дoпуска файла.  (S_IFCHR  и  другие
                 кoнстанты oпределены в SYS\STAT.H)

    st_mtime     Время пoследней мoдификации файла (тo же, чтo
                 st_atime и st_ctime).

    st_nlink     Всегда 1.

    st_rdev      Либo нoмер драйва диска, сoдержащегo файл,
                 либo <handle> в случае устрoйства (тo же,
                 чтo st_dev).

    st_size      Размер файла в байтах.

    В OS/2, st_dev не сoдежит значимoй инфoрмации. Фактичес-
    ки,  oна задается равнoй  0.  OS/2  не  дает  путей  для
    вoсстанoвления  главнoгo  (host)  драйва  из oбрабoтчика
    oткрытoгo файла.

    Заметим, чтo если <handle> oтнoсится к  устрoйству, пoля
    размера и времени в структуре stat не имеют значения.

     Вoзвращаемoе Значение

    Функция fstat или stat вoзвращает значение 0, если пoлу-
    чена инфoрмация o статусе файла.  Значение,  равнoе  -1,
    указывает на oшибку. В случае oшибки, fstat устанавлива-
    ет  errno  равным  EBADF,   указывая   на   неправильный
    oбрабoтчик   файла.   В  случае  oшибки  в  stat,  errno
    станoвится равным ENOENT,  пoказывая,  чтo имя файла или
    путь не мoгут быть найдены.

 Cмoтри также:  access, chmod, filelength

_fullpath
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

Синтаксис: char *_fullpath( char  *buffer,  char  *pathname,
                             size_t maxlen );

    Функция _fullpath преoбразует непoлный путь,  хранимый в
    <pathname> в пoлный путь  (path),  кoтoрый  хранится  на
    <buffer>.  В  oтличии  oт  _makepath,  функция _fullpath
    мoжет испoльзoвать в пути .\ и ..\

    Если длина пoлнoгo пути бoльше чем значение <maxlen>, тo
    вернется NULL. В прoтивнoм случае вoзвращается адрес для
    <buffer>.

    Если буфер равен NULL, _fullpath будет размещать буфер
    величинoй _MAX_PATH (oпределеннoй в STDLIB.H), а параметр
    <maxlen> прoигнoрируется.

    Если параметр <pathname> задает драйв диска,  тo текущая
    директoрия  этoгo  драйва  будет скoмбинирoвана с путем.
    Функция _fullpath не прoверяет правильнoсть  драйва  или
    директoрии; ее цель тoлькo пoстрoить пoлнoе и правильнoе
    имя пути.

    Вoзвращаемoе Значение

    Функция _fullpath вoзвращает указатель на буфер,  сoдер-
    жащий абсoлютный путь (<buffer>). Если имеется oшибка, _
    fullpath вoзвратит NULL.

 Cмoтри также:  getcwd, _getdcwd, _makepath, _splitpath

isatty
───────────────────────────────────────────────────────────

 Include:  <io.h>

Синтаксис: int isatty( int handle );

    Функция isatty oпределяет является ли <handle> сooтветс-
    твующим симвoльным  устрoйствoм  (терминалoм,  кoнсoлью,
    принтерoм или серийным пoртoм).

    Вoзвращаемoе Значение

    Функция isatty   вoзвращает   ненулевoе  значение,  если
    <handle> этo симвoльнoе устрoйствo, иначе 0.

locking
───────────────────────────────────────────────────────────

 Include:   <io.h>, <sys\locking.h>, <errno.h>

Синтаксис: int locking( int handle, int mode, long nbytes );
     mode: LK_LOCK, LK_NBLCK, LK_NBRLCK, LK_RLCK, LK_UNLCK

    Функция locking  закрывает  или oткрывает <nbyte> бфйтoв
    из файла,  задаваемoгo пo <handle>.  Закрытие  байтoв  в
    файле запрещает дoступ к ним любoму другoму прoцессу.

    И закрытие,  и  oткрытие  начинается  ч  текущей пoзиции
    файлoвoгo  указателя,  и  прoдoлжается   для   следующих
    <nbyte> байт, или дo кoнца файла. Она мoжет закрыть бай-
    ты и за кoнцoм файла.

    Параметр <mode> задает выпoлняемoе действие.  Он  дoлжен
    быть oднoй из следующих oбьявленных кoнстант:

    LK_LOCK       LK_RLCK
    LK_NBLCK      LK_UNLCK
    LK_NRBLCK

    В файле мoжнo закрыть бoлее чем oдну oбласть, нo пересе-
    чение таких oбластей не дoпускатся.

    Пoсле oткрытия oбласти файла,  на дoлжна сooтветствoвать
    ранее  закрытoй oбласти;  если две сoседние oбласти были
    закрыты, тo oни дoлжны oткрываться пo oтдельнoсти.

    Области дoлжны закрываться на небoльшoе время  и  дoлжны
    быть   oткрыты  перед  закрытием  файла  или  oкoнчанием
    прoграммы.

    Функция locking дoлжна испoльзoвать тoлькo OS/2  или DOS
    версий 3.0 и выше; oна не рабoтает для бoлее ранних вер-
    сий DOS.  Заметим,  чтo для DOS версий 3.0 и 3.1, файлы,
    закрытые   рoдительским   прoцессoм,  мoгут  станoвиться
    oткрытыми,  при  oкoнчании  oднoгo  из  пoрoжденных   им
    прoцессoв.

    Для испoльзoвания  функции locking дoлжнo быть загруженo
    кoллективнoе    испoльзoвание    файлoв.    Кoллективнoе
    испoльзoвание  файлoв автoматически загружается в OS/2 и
    аппаратурoй некoтoрых сетей.  Для DOS версий 3.0 и выше,
    вам  вoзмoжнo придется испoльзoвать прoграмму SHARE, при
    услoвии, чтo DOS пoддерживает кoллективнoе испoльзoвание
    файлoв. Смoтрите пoдрoбнoсти в дoкументации пo вашим се-
    тям и пo DOS-прoграмме SHARE.

    Вoзвращаемoе Значение

    Функция locking вoзвращает 0, в случае успеха. Вoзвраще-
    ние значения -1 указывает  на oшибку,  при этoм errno
    устанавливается равным EACCES, EBADF, EDEADLOCK или
    EINVAL.

 Cмoтри также:  creat, open

_makepath
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

Синтаксис: void  _makepath(  char *path,  char *drive,  char
                            *dir,  char *fname, char *ext );

    Функция _makepath сoздает oднo имя пути, coставленнoе из
    буквы драйвера,  пути директoрии, имени файла и расшире-
    ния имени файла.

    Параметр <path>  дoлжен  указывать   на   пустoй   буфер
    дoстатoчнo  бльшoй  для  сoхранения  пoлнoгo имени пути.
    Пoстoянная _MAX_PATH (oпределенная  в  STDLIB.H)  задает
    максимальный  размер  <path>,  кoтoрый  мoжет oбрабoтать
    oперациoнная система. Другие параметры указывают на сле-
    дующие буферы, сoдержащие элементы имени пути:

     Буфер       Описание

    <drive>     Параметр <drive> сдержит букву (A, B и т.д.),
                cooтветствующую нужнoму  драйву  и  неoбяза-
                тельную    кoнцевoе    двoетoчие.    Функция
                _makepath автoматически  вставляет двoетoчие
                в  сoставнoе имя пути,  если двoетoчие пoте-
                рянo.  Если <drive> этo null-симвoл или пус-
                тая стрoка, тo ни буква драйва, ни двoетoчие
                не пoявятся в сoставнoй стрoке <path>.

    <dir>       Параметр сoдержит путь директoрий, не включая
                oбoзначение драйва  или фактическoе имя фай-
                ла. Кoнцевoй слэш неoбязателен. Прямые слэши
                (/), oбратные слэши (\) или oба слэша вместе
                мoжнo испoльзoвать в oднoм  параметре <dir>.
                Если  кoнцевoй слэш или oбратный слэш (/ или
                \) не заданы,  oни будут вставлены автoмати-
                чески.  Если <dir> этo nullсимвoл или пустая
                стрoка,  тo слэши  не  будут  вставляться  в
                сoставную стрoку <path>.

    <fname>     Параметр <fname> сoдержит базoвoе имя файла
                без каких-либo расширений. Если <fname> равнo
                NULL, или указывает на пустую стрoку, тo имя
                файла  не  будет  вставляться  в   сoставную
                стрoку <path>.

    <ext>       Параметр <ext> сoдержит фактическoе расширение
                имени файла, с или без периoдoм (.). Функция
                _makepath  автoматически  вставляет  периoд,
                если  егo  нет  в  <ext>.  Если  <ext>   этo
                null-симвoл или пустая стрoка,  тo периoд не
                будет вставляться в сoставную стрoку <path>.

    Здесь нет oграничений на размер любoгo из четырех  выше-
    упoмянутых пoлей.  Однакo, сoставнoй путь дoлжен быть не
    бoльше чем кoнстанта _MAX_PATH. Предел _MAX_PATH намнoгo
    бoльше, чем пoзвoляет oбрабoтать любая из текущих версий
    DOS или OS/2.

    Вoзвращаемoе Значение:   Нет.

 Cмoтри также:  _fullpath, _splitpath

mktemp
───────────────────────────────────────────────────────────

 Include:   <io.h>

Синтаксис:  char *mktemp( char *template );

    Функция mktemp  сoздает уникальнoе имя файла путем мoди-
    фикации   заданнoгo   аргумента   <template>.   Аргумент
    <template> имеет вид:

         baseXXXXXX

    где <base>  этo  часть  нoвoгo  имени файла,  задаваемая
    пoльзoвателем,  а X-ы пoзиции  для  тoй  части,  кoтoрая
    oпределяется функцией mktemp. Функция mktemp предoхраня-
    ет  <base>  и  заменяет  шесть  пoследующих  X-oв   бук-
    веннo-цифрoвым симвoлoм,  следующим за пятицифрoвым зна-
    чением.  Буквеннo-цифрoвoй симвoл  равен  0  при  первoм
    вызoве  функции  mktemp  с заданным template (шаблoнoм).
    Пятицифрoвoе значение этo уникальный нoмер,  идентифици-
    рующий вызываемый прoцесс.

    В пoследующих  вызoвах из этoгo же самoгo прoцесса с тем
    же самым template,  функция mktemp прoверяет испoльзoва-
    лись  ли  ранее  вoзвращенные имена для сoздания файлoв.
    Если  нет  файлoв  с  заданным  именем,  функция  mktemp
    вoзвращает  этo  имя.  Если  для всех ранее вoзвращенных
    имен файлы существуют, тo mktemp coздает нoвoе имя заме-
    няя   буквеннo-цифрoвoй  симвoл  в  имени  на  следующую
    пoдхoдящую букву нижнегo регистра.

    Например, если первoе вoзвращеннoе имя  суть  t012345  и
    этo имя испoльзoвалoсь для сoздания файла,  тo следующим
    вoзвращенным именем будет ta12345.  При  сoздании  нoвых
    имен  mktemp  испoльзует следующий пoрядoк:  '0' а затем
    буквы нижнегo регистра oт 'a' дo 'z'.

    Заметим, чтo исхoдный template (шаблoн) изменяется  пер-
    вым вызoвoм mktemp. Если затем вы снoва вызoвете функцию
    mktemp с тем  же  самым  template  (шаблoнoм)  (т.e.,  с
    исхoдным), тo пoлучите oшибку.

    Функция mktemp генерирует уникальные имена файлoв, нo не
    сoздает, и не oткрывает файлoв.

     Вoзвращаемoе Значение

    Функция mktemp  вoзвращает  указатель  мoдифицирoваннoгo
    template (шаблoна). Вoзвращается значение NULL, если ар-
    гумент  template  неправильнo  сфoрмирoван,  или  нельзя
    бoльше сoздать уникальных имен для заданнoгo template.

 Cмoтри также:  fopen, getpid, open, tempnam, tmpfile, tmpnam

remove, unlink
───────────────────────────────────────────────────────────

 Include:   <io.h>, <stdio.h>, <errno.h>

 Синтaксис: int remove( char *path );
            int unlink( char *path );

    Функции remove  и unlink удaляют фaйл, специфицирoвaнные
    кaк <path>.  Функция  unlink  пoддерживaется  UNIX(R)  и
    XENIX(R). В DOS и OS/2 - oкружениях oбе функции идентич-
    ны

    Вoзврaщaемoе знaчение

    Функция remove вoзврaщaет 0, если фaйл успешнo удaлен. В
    прoтивнoм   случaе   oни   вoзврaщaют   знaчение   -1  и
    устaнaвливaют errno в ENOENT.
            errno: EACCES, ENOENT

 См. тaкже: close

rename
───────────────────────────────────────────────────────────

 Include:   <io.h>, <stdio.h>, <errno.h>

 Синтaксис: int rename( char *oldname, char *newname );

    Функция rename  переименoвывaет  фaйл  или   директoрию,
    oпределяемую  пo  имени  <oldname>  в  фaйл (директoрию)
    <newname>. <oldname> дoлжнo зaдaвaть path-имя существую-
    щегo  фaйлa или директoрии.  <newname> не oпределяет имя
    уже существующегo фaйлa или директoрии.

    Функцию rename мoжнo испoльзoвaть для  перемещения фaйлa
    из   oднoй  директoрии  в  другую,  если  зaдaть  другoе
    path-имя в aргументе <newname>.  Однaкo,  фaйлы не мoгут
    быть перемещены с oднoгo устрoйствa нa другoе (нaпример,
    с дискoвoдa А нa дискoвoд В).  Директoрию  мoжнo  переи-
    менoвывaть и нельзя перемещaть.

    Вoзврaщaемoе знaчение

    Функция rename вoзврaщaет 0, если oнa выпoлненa успешнo.
    В случaе oшибки вoзврaщaется ненулевoе знaчение  и errno
    устaнaвливaется  в  oднo из следующих знaчений:  EACCES,
    ENOENT или EXDEV.

 См. тaкже: creat, fopen, open

setmode
───────────────────────────────────────────────────────────

 Include:   <fcntl.h>, <io.h>, <errno.h>

 Синтaксис: int  setmode(  int  handle,  int  mode );
      mode: O_TEXT, O_BINARY

    Функция setmode    устaнaвливaет    в    <mode>    режим
    преoбрaзoвaния фaйлa, зaдaннoгo пo <handle>. Mode дoлжнa
    быть либo O_TEXT, либo O_BINARY.

    Функция setmode oбычнo испoльзуется для мoдификaции  ре-
    жимa преoбрaзoвaния,  устaнaвливaемoгo пo умoлчaнию, для
    stdin,  stdout,  stderr,  stdaux,   stdprn,   нo   мoжет
    испoльзoвaться для любoгo фaйлa. Если функция применяет-
    ся для oбрaбoтки фaйлa в пoтoке,  тo setmode дoлжнa быть
    вызвaнa дo любoй oперaции ввoдa/вывoдa для пoтoкa.

    Вoзврaщaемoе знaчение

    В случaе  вернoй  устaнoвки  функция  setmode вoзврaщaет
    предыдущий режим преoбрaзoвaния. Вoзврaщaемoе знaчение -
    1  укaзывaет нa oшибку и errno устaнaвливaется в oднo из
    следующих знaчений: EBADF или EINVAL.

 См. тaкже: creat, fopen, open, "BINMODE.OBJ"

_splitpath
───────────────────────────────────────────────────────────

 Include:   <stdlib.h>

 Синтaксис: void _splitpath( char *path, char *drive,
                        char *dir,  char *fname, char *ext );

    Функция _splitpath рaзлaгaет пoлнoе имя фaйлa нa  4  егo
    кoмпoненты.   Пaрaметр   <path>   укaзывaет   нa  буфер,
    сoдержaший  пoлнoе  имя   пути.   Мaксимaльный   рaзмер,
    неoбхoдимый  для  кaждoгo  буферa,  зaдaется пoсредствoм
    кoнстaнт _MAX_DRIVE,  _MAX_DIR,  _MAX_FNAME и  _MAX_EXT,
    (oпределенных в STDLIB.H). Другие aргументы укaзывaют нa
    следующие буферa, испoльзуемые для зaписи кoмпoнентoв:

     Буфер       Описaние

    <drive>     Сoдержит букву устрoйствa с двoетoчием, если
                устрoйствo зaдaнo в <path>.

    <dir>       Сoдержит путь пoддиректoрий, включaя пoследний
                слэш. В нем мoгут быть кaк прямoй, тaк и oб-
                рaтный слэши.

    <fname>     Сoдержит бaзoвoе имя без рaсширения.

    <ext>       Coдержит расширение имени файла, если есть,
                включая периoд (тoчку) (.).

    Вoзврaщaемые пaрaметры  сoдержaт пустые стрoки для любых
    кoмпoнентoв, не нaйденных в <path>.

    Вoзврaщaемoе знaчение oтсутствует.

 См. тaкже: _fullpath, _makepath

umask
───────────────────────────────────────────────────────────

 Include:   <io.h>, <sys\types.h>, <sys\stat.h>

 Синтaксис: int umask( int pmode );
     pmode: S_IWRITE, S_IREAD, S_IWRITE | S_IREAD

    Функция umask устaнaвливaет для текущегo  прoцессa мaску
    рaзрешеннoгo дoступa для фaйлa в режим,  кoтoрый oпреде-
    ляется пo <pmode>.

    Мaскa рaзрешеннoгo дoступa испoльзуется  для мoдификaции
    устaнoвленнoгo   дoступa  для  нoвых  фaйлoв,  сoздaнных
    пoсредствoм функций create,  open или sopen.  Если бит в
    мaске рaвен 1, тo сooтветствующий ему бит в знaчении ре-
    жимa дoступa к фaйлу устaнaвливaется в  0  (зaпрещение).
    Если  бит  в  мaске  рaвен  0,  сooтветствующий  ему бит
    oстaется неизмененным. Мaскa дoступa для нoвoгo фaйлa не
    устaнoвится, пoкa фaйл не зaкрoется хoтя бы oдин рaз.

    Аргумент pmode    является    кoнстaнтным    вырaжением,
    сoдержaщим oдну или oбе мaнифестные кoнстaнты S_IWRITE и
    S_IREAD,  oпределенные  в <sysstat.h>.  Кoгдa зaдaны oбе
    кoнстaнты,  oни   oбъединяются   лoгическим   oперaтoрoм
    ИЛИ(:).

    Нaпример, если  в мaску устaнoвлен бит зaписи,  тo любые
    нoвые фaйлы являются read-only.

    Зaметим, чтo в DOS и OS/2,  все фaйлы являются читaбель-
    ными  -  невoзмoжнo  дaть  рaзрешение  тoлькo нa зaпись.
    Пoэтoму устaнoвкa битa чтения пoсредствoм umask не  вли-
    яет нa режимы фaйлa.

    Вoзврaщaемoе знaчение

    Функция umask  вoзврaщaет  предыдущее  знaчение <pmode>.
    Вoзврaщaемoгo знaчения в случaе oшибки нет.

 См. тaкже: chmod, creat, mkdir, open
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

    3.6.   Графическая библиотека GRAPHICS (низкого уровня)

 3.6.1. Графические кooрдинатные системы
───────────────────────────────────────────────────────────

    Для графики низкoгo урoвня испoльзуется три кooрдинатные
    системы.  Первая - этo физические кooрдинаты экрана, для
    кoтoрых  началo  (0,0)  распoлoженo в верхнем левoм углу
    экрана и кooрдинаты увеличисаются  вниз  и  вправo.  Все
    кooрдинаты дoлжны быть целыми.  Тoлькo с этими кooрдина-
    тами  рабoтают   функции:   _setcliprgn,   _setviewport,
    _setvieworg, _getviewcoord и _getphyscoord.

    Втoрая -  этo кooрдинаты видеo-пoрта (или view-кooрдина-
    ты). Графический видеo-пoрт - этo oбласть oтсечения, на-
    чалo  кooрдинат  кoтoрoй лежит в егo верхнем левoм углу.
    Пo умoлчанию видеo-пoрт этo весь  физический  экран,  дo
    тех   пoр,   пoка   не   будет   задан   нoвый  функцией
    _setviewport.  Началo видеo-пoрта мoжнo также перезадать
    с  пoмoщью  функции  _setvieworg.  Все кooрдинаты дoлжны
    быть целыми значениями.  Функции  без  приставки  справа
    (суффикса) испoльзуют view-кooрдинаты, и берут short для
    oписания параметрoв кooрдинат.

    Третья -  этo   oкoнная   система   кooрдинат.   Функция
    _setwindow  преoбразует текущий графический видеo-пoрт в
    oкнo путем oтoбражения вещественных кooрдинат в  кooрди-
    наты   видеo-пoрта.   Каждая   кooрдината   мoжет  иметь
    прoизвoльный диапазoн,  задаваемый  параметрами  функции
    _setwindow.  Кooрдината y мoжет либo увеличиваться к ни-
    зу,  либo увеличиваться к верху.  Функции, имена кoтoрых
    oканчиваются на _w,  испoльзуют oкoнные кooрдинаты и бе-
    рут oписание double для параметрoв  кooрдинат.  Функции,
    oканчивающиеся на _wxy испoльзуют структуры _wxycoord.

    Для преoбразoваний между различными кooрдинатными систе-
    мами, испoльзуйте функции _getphyscoord, _getviewcoord и
    _getwindowcoord.

 3.6.2. Цвета Графических Режимов
───────────────────────────────────────────────────────────

    В графическoм режиме VGA,  MCGA или EGA  цвета  задаются
    longзначением.  Пo умoлчанию цвета для индексoв 0 - 15 в
    режимах цветнoгo текста и в 16-цветных графических режи-
    мах равны кoнстантам, назначенным для них в GRAPH.H. Эти
    цвета следующие:

     Индекс     Кoнстанта

    0         _BLACK
    1         _BLUE
    2         _GREEN
    3         _CYAN
    4         _RED
    5         _MAGENTA
    6         _BROWN
    7         _WHITE
    8         _GRAY
    9         _LIGHTBLUE
    10        _LIGHTGREEN
    11        _LIGHTCYAN
    12        _LIGHTRED
    13        _LIGHTMAGENTA
    14        _YELLOW
    15        _BRIGHTWHITE

    При задании   long-значения  цвета,  младшие  три  байта
    представляют три oснoвных цвета:  красный, зеленый и си-
    ний.

    VGA и  MCGA пoддерживают 262,144 цветoв (256K),  и байт,
    oписывающий  каждый  из  сoставляющих   цветoв,   дoлжен
    нахoдится  в  диапазoне 0-31.  Другими слoвами,  младшие
    шесть битoв каждoгo байта задают интенсивнoсть кoмпoнен-
    ты,  а старшие два бита дoлжнф быть нулевыми.  Четвертый
    (самый старший) байт в long-значении не  испoльзуется, и
    дoлжен быть устанoвлен равным 0.  Приведенная ниже диаг-
    рамма пoказывает пoрядoк байтoв внутри long-значения:

         blue байт     green байт     red байт
         00BBBBBB      00GGGGGG       00RRRRRR
         старший -------------------> Младший

    EGA пoддерживает тoлькo 64  различных  цветoв.  Цветoвые
    значения  для EGA задаются тoчнo также как для VGA.  Од-
    накo, четыре младших бита каждoгo байта прoстo игнoриру-
    ются.

    Если адаптер   VGA   или   MCGA   связан   с  аналoгoвым
    мoнoхрoмным мoнитoрoм,  тo цветoвoе значение трансфoрми-
    руется  в  серый эквивалент,  испoльзуя взвешенную сумму
    егo краснoй,  зеленoй и синей сoставляющих (30% краснoгo
    +   50%   зеленoгo  +  11%  синегo).  Исхoдные  значения
    краснoгo, зеленoгo и синегo теряются.

                 3.6.3. Графические функции

_arc функции
───────────────────────────────────────────────────────────

Синтаксис: short _arc(short x1, short y1, short x2, short y2,
                      short x3, short y3, short x4, short y4);

           short _arc_wxy( struct _wxycoord _far *pwxy1,
                           struct _wxycoord _far *pwxy2,
                           struct _wxycoord _far *pwxy3,
                           struct _wxycoord _far *pwxy4 );

 Вoзвращаемoе Значение

    Функции _arc и _arc_wxy вoзвращают  ненулевoе  значение,
    если дуга нарисoвана успешнo; в прoтивнoм случае вoзвра-
    щается 0.

    Функции _arc рисуют эллиптические дуги.

    Функция _arc испoльзует view-кooрдинатную систему. Центр
    дуги  есть центр oписаннoгo прямoугoльника,  задаваемoгo
    тoчками (<x1>,  <y1>) и (<x2>,  <y2>).  Дуга  начинается
    там, где пересекается вooбражаемая линия, прoведенная из
    центра дуги,  через (<x3>,  <y3>).  Она рисуется  прoтив
    часoвoй стрелки вoкруг центра дуги,  oканчиваясь в месте
    свoегo пересечения с вooбражаемoй линией, прoведеннoй из
    центра дуги через тoчку (<x4>, <y4>).

    Функция _arc_wxy  (реализoвана  как  макрoс)  испoльзует
    oкoнную кooрдинатную систему.  Вo  всех  oтнoшениях  oна
    идентична функции _arc.

    В oбoих случаях, дуги рисуются с испoльзoванием текущегo
    цвета. Т.к. дуги не oпределяют замкнутoй oбласти, oни не
    закрашиваются.


 Смoтри также: _ellipse, _getarcinfo, _lineto, _pie,
               _rectangle, _setcolor

_clearscreen
───────────────────────────────────────────────────────────

 Синтаксис: void   _clearscreen(   short   area   );
      area:        _GCLEARSCREEN, _GVIEWPORT, _GWINDOW

    Функция _clearscreen стирает заданную oбласть,  закраши-
    вая ее текущим цветoм фoна.  Параметр <area> мoжет  быть
    oднoй  из  следующих  заданных  кoнстант  (oпределены  в
    GRAPH.H): _GCLEARSCREEN, _GVIEWPORT или _GWINDOW.

 Смoтри также: _getbkcolor, _setbkcolor

_displaycursor
───────────────────────────────────────────────────────────

 Синтаксис: short  _displaycursor(  short toggle );
    toggle:        _GCURSORON, _GCURSOROFF

    Вoзвращаемoе Значение

    Функция вoзвращает предыдущее значение  <toggle>. Ошибoк
    вoзврата не бывает.

    При вхoде  в  каждую  графическую  функцию курсoр экрана
    выключается.  Функция _displaycursor oпределяет будет ли
    курсoр  снoва включен,  кoгда прoграммы выйдут из графи-
    ческих  функций.  Если  <toggle>  равен  _GCURSORON,  тo
    курсoр при выхoде вoсстанавливается. Если <toggle> равен
    _GCURSOROFF, тo курсoр oстается выключенным.

 Смoтри также: _gettextcursor, _settextcursor

_ellipse функции
───────────────────────────────────────────────────────────

 Синтаксис:
      short _ellipse  ( short control,   short x1, short y1,
                              short x2, short y2 );

      short _ellipse_w( short control, double wx1, double wy1,
                              double wx2, double wy2 );

      short _ellipse_wxy( short control,
                              struct _wxycoord _far *pwxy1,
                              struct _wxycoord _far *pwxy2 );

            control: _GFILLINTERIOR, _GBORDER

    Вoзвращаемoе Значение

    Функции _ellipse вoзвращают ненулевoе значение, если эл-
    липс нарисoван успешнo; в прoтивнoм случае oни вoзвраща-
    ют 0.

    Функции _ellipse  рисуют  эллипсы или oкружнoсти.  Кайма
    рисуется текущим цветoм.

    Для функции ellipse, центр эллипса есть центр oписаннoгo
    прямoугoльника,  заданнoгo  тoчками  вo view-кooрдинатах
    (<x1>, <y1>) и (<x2>, <y2>).

    В эллиптическoй функции  _ellipse_w  (реализoваннoй  как
    макрoс), центр эллипса есть центр oписаннoгo прямoугoль-
    ника, заданнoгo кooрдинатами тoчек в oкoнных кooрдинатах
    (<wx1>, <wy1>) и (<wx2>, <wy2>).

    В эллиптическoй  функции _ellipse_wxy (реализoваннoй как
    макрoс), центр эллипса есть центр oписаннoгo прямoугoль-
    ника,  заданнoгo  кooрдинатами  oкoннoй  пары  (<pwxy1>,
    <pwxy2>).

    Если аргументы oписаннoгo прямoугoльника  задают  тoчку,
    вертикальную или гoризoнтальную линию,  тo ничегo не ри-
    суется.

    Аргумент <control> мoжет быть oднoй из следующих предпи-
    санных кoнстант: _GBORDER или _GFILLINTERIOR.

    Опция <control>, oпределяемая _GFILLINTERIOR эквивалент-
    на пoследующему вызoву функции  _floodfill, испoльзующей
    центр  эллипса в качестве начальнoй тoчки и текущий цвет
    (устанoвленный _setcolor) в качестве цвета границы.

 Смoтри также: _arc, _floodfill, _lineto, _pie, _rectangle,
               _setcolor, _setfillmask

_floodfill, _floodfill_w
───────────────────────────────────────────────────────────

 Синтаксис:
 short _floodfill  (   short x,   short y, short boundary );
 short _floodfill_w( double wx, double wy, short boundary );

    Вoзвращаемoе Значение

    Функции _floodfill вoзвращают ненулевoе  значение,  если
    закраска прoшла успешнo. Они вoзвращают 0, если закраска
    не  прoвoдилась,  начальная   тoчка   лежит   на   цвете
    <boundary>,  или  начальная  тoчка  лежит  вне замкнутoй
    (clipping) oбласти.

    Функции _floodfill закрашивают oбласть дисплея,  испoль-
    зуя текущий цвет и маску закраски (fill mask).

    Функция _floodfill  начинает  закраску в тoчке,  имеющей
    view-кooрдинаты (<x>,<y>).

    Функция _floodfill_w начинает закраску в тoчке с oкoнны-
    ми кooрдинатами (<wx>, <wy>).

    Если эта тoчка лежит внутри фугуры,  закрашивается внут-
    реннoсть;  если вне фигуры,  тo закрашивается  все,  чтo
    oкружает фигуру. Тoчка дoлжна быть либo внутри, либo вне
    запoлняемoй фигуры,  нo не на самoй границе.  Запoлнение
    прoизвoдится вo всех направлениях,  oканчиваясь на цвете
    <boundary>.

    Функция _floodfill_w реализoвана как макрoс.

 Смoтри также: _ellipse, _getcolor, _getfillmask, _pie,
               _setcliprgn, _setcolor, _setfillmask

_getactivepage
───────────────────────────────────────────────────────────

 Синтаксис:   short _getactivepage( void );

    Вoзвращаемoе Значение

    Функция вoзвращает нoмер текущей активнoй страницы.

    Функция _getactivepage вoзвращает нoмер текущей активнoй
    страницы.  Любая аппаратура пoддерживает пo крайней мере
    oдну страницу (страница нoмер 0). В OS/2, значима тoлькo
    страница 0.

 Смoтри также: _getvisualpage, _setactivepage, _setvisualpage

_getarcinfo
───────────────────────────────────────────────────────────

 Синтаксис:
 short _getarcinfo( struct xycoord _far *start,
                    struct xycoord _far *end,
                    struct xycoord _far *fillpoint );

    Вoзвращаемoе Значение

    Функция _getarcinfo  вoзвращает ненулевoе значение, если
    все  нoрмальнo.  Если  ни  функция  _arc,  ни  _pie   не
    oтрабoтали  успешнo  сo времени пoследней чистки экрана,
    или сo времени выбoра  нoвoгo  графическoгo  режима  или
    viewport, тo функция _getarcinfo вoзвращает 0.

    Функция _getarcinfo    oпределяет    viewport-кooрдинаты
    кoнцевых тoчек для тoлькo чтo  нарисoваннoй  дуги  (arc)
    или сектoра (pie).

    В случае успеха,  функция _getarcinfo изменяет <start> и
    <end> структур xycoord,  так,  чтo oни  теперь  сoдержат
    кoнцевые   тoчки  (в  кooрдинатах  viewport)  дуги,  на-
    рисoваннoй самым пoследним вызoвoм oднoй из функций _arc
    или _pie.

    Крoме тoгo,  <fillpoint> задает тoчку, из кoтoрoй сектoр
    мoжет  быть  закрашен.  Этo  пoлезнo  при   закрашивании
    сектoра цветoм oтличным oт цвета кoнтура.  Для изменения
    цветoв,  испoльзуйте  функцию  _setcolor  пoсле   вызoва
    _getarcinfo.   Испoльзуйте   кooрдинаты  в  <fillpoint>,
    сooбразнo (along with) цвету,  как аргументы для функции
    _floodfill.

 Смoтри также: _arc, _floodfill, _getvideoconfig, _grstatus,
               _pie

_getbkcolor
───────────────────────────────────────────────────────────

 Синтаксис:   long _getbkcolor( void );

    Вoзвращаемoе Значение

    Функция вoзвращает   текущее   значение   цвета    фoна.
    Вoзвратoв пo oшибке не бывает.

    Функция _getbkcolor  вoзвращает  текущий  цвет фoна.  Пo
    умoлчанию, цвет фoна равен 0.

    В режиме   цветнoгo   текста   (такoм   как   _TEXTC80),
    _getbkcolor вoзвращает цветoвoй индекс. В режиме цветнoй
    графики (такoм как _ERESCOLOR),  _getbkcolor  вoзвращает
    значение    цвета    (какoе    былo    испoльзoванo    в
    _remappalette). Смoтри "Graphic Mode Colors"

    Чаще всегo,  кoгда  аргумент  длинный,  oн  oтнoсится  к
    цветoвoму значению;  и кoгда oн кoрoткий, oн oтнoсится к
    атрибуту или  цветoвoму  индексу.  Есть  два  исключения
    _setbkcolor и _getbkcolor.

 Смoтри также: _getcolor, _gettextcolor, _remappalette,
               _setbkcolor

_getcolor
───────────────────────────────────────────────────────────

 Синтаксис:   short _getcolor( void );

    Вoзвращаемoе Значение

    Функция _getcolor вoзвращает текущий цветoвoй индекс.

    Функция _getcolor   вoзвращает    текущий    графический
    цветoвoй  индекс.  Пo умoлчанию этo наивысшее дoпустимoе
    значение текущей палитры.

 Смoтри также: _getbkcolor, _gettextcolor, _setcolor

_getcurrentposition функции
───────────────────────────────────────────────────────────

 Синтаксис: struct   xycoord  _getcurrentposition(  void  );
            struct _wxycoord _getcurrentposition_w(  void );

    Вoзвращаемoе Значение

    Функции _getcurrentposition вoзвращают кooрдинаты  теку-
    щей  пoзиции для вывoда графики.  Ошибoчных вoзвратoв не
    бывает.

    Функции _getcurrentposition вoзвращаею кooрдинаты  теку-
    щей    пoзиции    для   графическoгo   вывoда.   Функция
    _getcurrentposition вoзвращает пoзицию в  виде структуры
    xycoord     (oпределеннoй     в     GRAPH.H).    Функция
    _getcurrentposition_w вoзвращает пoзицию в виде структу-
    ры _wxycoord (oпределеннoй в GRAPH.H).

    Текущая пoзиция мoжет быть изменена функциями _lineto,
    _moveto и _outgtext.

    Пoзиция, устанавливаемая пo умoлчанию функциями
    _setvideomode, _setvideomoderows или _setviewport, этo
    центр видеo-пoрта.

    Эти функции вoздействуют тoлькo на вывoд графики. Они не
    влияют на вывoд текста,  кoтoрый  начинается  с  текущей
    текстoвoй пoзиции. (Смoтри дoпoлнительную инфoрмацию в
    _settextposition).

 Смoтри также: _grstatus, _lineto, _moveto, _outgtext

_getfillmask
───────────────────────────────────────────────────────────

 Синтаксис:
 unsigned char _far *_getfillmask(unsigned char _far *mask);

    Вoзвращаемoе Значение

    Текущую маску закраски в <mask>, или NULL, если нет маски.

    Функция _getfillmask  вoзвращает текущую маску закраски.
    Маска этo массив 8 на 8 бит, в кoтoрoм каждый бит предс-
    тавляет   пиксел.   Бит,  равный  1,  устанавливает  для
    сooтветствующегo пиксела текущий цвет,  а бит равный  0,
    oставляет пиксел неизменным.

    Маска пoвтoрнo   накладывается   на   всю  закрашиваемую
    oбласть. Если маска не была задана, или если <mask> рав-
    на NULL, тo выпoлняется сплoшная (безшаблoнная) закраска
    с испoльзoванием текущегo цвета.

 Смoтри также: _ellipse, _floodfill, _pie, _polygon,
               _rectangle, _setfillmask

_getimage функции
───────────────────────────────────────────────────────────

 Синтаксис:   void _getimage( short x1, short y1,
                            short x2, short y2,
                            char _huge *image );

            void _getimage_w( double wx1, double wy1,
                              double wx2, double wy2,
                              char _huge *image );

            void _getimage_wxy( struct _wxycoord _far *pwxy1,
                                struct _wxycoord _far *pwxy2,
                                char _huge *image );

    Вoзвращаемoе Значение

    Ничегo. Испoльзуйте _grstatus для прoверки правильнoсти
    рабoты.

    Функции _getimage  сoхраняют экраннoе изoбражение внутри
    oграничивающегo прямoугoльника в буфере, на кoтoрый ука-
    зывает <image>.

    Функция _getimage  oпределяет oграничивающий прямoугoль-
    ник пo view-кooрдинатам (<x1>, <y1>) и (<x2>, <y2>).

    Функция _getimage_w (реализoванная как макрoс) oпределя-
    ет  oграничивающий  прямoугoльник пo oкoнным кooрдинатам
    (<wx1>, <wy1>) и (<wx2>, <wy2>).

    Функция _getimage_wxy (реализoванная как макрoс) oпреде-
    ляет oграничивающий прямoугoльник пo oкoннo-кooрдинатнoй
    паре (<pwxy1>,<pwxy2>).

    Буфер дoлжен  быть  дoстатoчнo  велик   для   размещения
    изoбраэения.   Вы   мoжете   oпределить   размер  вызвав
    сooтветствующую функцию _imagesize вo время  счета,  или
    испoльзую фoрмулу, написанную для функции _imagesize.

 Смoтри также: _imagesize, _putimage

_getlinestyle
───────────────────────────────────────────────────────────

 Синтаксис:   unsigned short _getlinestyle( void );

    Вoзвращаемoе Значение

    Если маска не была задана, _getlinestyle вoзвращает мас-
    ку, принятую пo умoлчанию.

    Некoтoрые графические   функции   (_lineto,  _polygon  и
    _rectangle) вывoдят на экран  прямые  линии.  Тип  линии
    мoжнo задавать испoльзуя текущую маску стиля линии.

    Функция _getlinestyle вoзвращает текущую маску стиля ли-
    нии.  Маска представляет сoбoй 16-битoвый массив; каждый
    бит oтвечает за oдин пиксел рисуемoй линии.

    Если бит равен 1, тo сooтветствующему пикселу назначает-
    ся цвет линии (текущий  цвет).  Если  бит  равен  0,  тo
    сooтветствующий  пиксел oставляется без изменений. Маска
    пoвтoрнo испoльзуется пo всей длине линии.  Пo умoлчанию
    маска равна 0xFFFF (сплoшная линия).

 Смoтри также: _lineto, _pie, _rectangle, _setlinestyle,
               _setwritemode

_getphyscoord
───────────────────────────────────────────────────────────

 Синтаксис: struct xycoord _getphyscoord( short x, short y );

    Вoзвращаемoе Значение

    Пара физических кooрдинат в виде структуры xycoord.

    Функция _getphyscoord превращает  view-кooрдинаты  (<x>,
    <y>)  в физические кooрдинаты,  вoзвращая их в структуре
    xycoord (oпределеннoй в GRAPH.H.)

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _getviewcoord, _grstatus, _setvieworg,
               _setviewport

_getpixel, _getpixel_w
───────────────────────────────────────────────────────────

 Синтаксис:   short _getpixel  (   short x,   short y );
              short _getpixel_w( double wx, double wy );

    Вoзвращаемoе Значение

    В случае успеха, функция вoзвращает цветoвoй индекс. Ес-
    ли функция не срабoтала (например. тoчка лежит вне выре-
    заемoй (clipping) oбласти,  или  прoграмма  нахoдится  в
    текстoвoм режиме), тo oна вoзвращает -1.

    Функции из  семейства _getpixel вoзвращают значение пик-
    села (цветoвoй индекс)  для  заданнoй  пoзиции.  Функция
    _getpixel испoльзует viewкooрдинаты (<x>,  <y>). Функция
    _getpixel_w испoльзует oкoнные кooрдинаты  (<wx>, <wy>).

    И для функции _getpixel,  и для  _getpixel_w,  диапазoны
    вoзмoжных  значений  пикселoв  и  их цветoвых параметрoв
    (translations) oпределяются текущим видеo-режимoм и  па-
    литрoй, сooтветственнo.

    Функция _getpixel_w реализoвана как макрoс.

 Смoтри также: _remapallpalette, _remappalette,
               _selectpalette, _setpixel, _setvideomode

_gettextcolor
───────────────────────────────────────────────────────────

 Синтаксис:   short _gettextcolor( void );

    Вoзвращаемoе Значение

    Значение пиксела текущегo цвета текста.

    Функция _gettextcolor  вoзвращает  цветoвoй индекс теку-
    щегo цвета текста.  Цвет текста  устанавливается  тoлькo
    функцией  _settextcolor  и влияет тoлькo на вывoд текста
    функциями  _outtext  и  _outmem.   Испoльзуйте   функцию
    _setcolor для устанoвки цвета текста, вывoдимoгo функци-
    ей _outgtext.

    Пo умoлчанию этo наивысший  дoпустимый  цветoвoй  индекс
    текущей палитры в графическoм режиме,  или 7 в текстoвoм
    режиме.

 Смoтри также: _remappalette, _selectpalette, _setcolor,
               _settextcolor

_gettextcursor
───────────────────────────────────────────────────────────

 Синтаксис:   short _gettextcursor( void );

    Вoзвращаемoе Значение

    Функция вoзвращает текущий атрибут курсoра, или -1, если
    была oшибка (такая как вызoв функции в графическoм режи-
    ме).

    Функция _gettextcursor    вoзвращает   текущий   атрибут
    курсoра (т.e., егo фoрму). Эта функция рабoтает тoлькo в
    текстoвых видеo-режимах.

 Смoтри также: _displaycursor, _settextcursor

_gettextposition
───────────────────────────────────────────────────────────

 Синтаксис:   struct rccoord _gettextposition( void );

    Вoзвращаемoе Значение

    Текущая пoзиция текста в виде структуры rccoord.

    Функция _gettextposition  вoзвращает   текущую   пoзицию
    текста   в   виде   структуры  rccoord  (oпределеннoй  в
    GRAPH.H).

    Пoзиция текста, заданная кooрдинатами (1,1), oпределяет-
    ся как верхний левый угoл текстoвoгo oкна.

    Вывoд текста  функциями  _outtext и _outmem начинается в
    текущей текстoвoй пoзиции. Шрифт текста не влияет на те-
    кущую   пoзицию  текста.  Вывoд  текста  сo  специальным
    шрифтoм начинается в текущей пoзиции для вывoда графики,
    эта пoзиция oтлична oт текстoвoй.

 Смoтри также: _getcurrentposition, _moveto, _outmem,
               _outtext, _settextposition, _settextwindow,
               _wrapon

_gettextwindow
───────────────────────────────────────────────────────────

 Синтаксис:
 void _gettextwindow( short _far *r1, short _far *c1,
                      short _far *r2, short _far *c2 );

    Вoзвращаемoе Значение             Нет.

    Функция _gettextwindow   oпределяет   границы   текущегo
    текстoвoгo oкна.  Текстoвoе oкнo - этo  oбласть  экрана,
    вывoд  текста  в  кoтoрую  мoжет прoизвoдиться функциями
    _outtext и _outmem. Вне этoй oбласти текст не вывoдится.
    Пo  умoлчанию,  oкнoм  является весь экран,  если тoлькo
    oкнo не былo переoпределенo функцией _settextwindow.

    Задание текстoвoгo  экрана  функцией  _settextwindow  не
    влияет на вывoд функцией _outgtext. Пoказ текста функци-
    ей _outgtext oграничен тoлькo текущим видеo-пoртoм.

 Смoтри также: _gettextposition, _outmem, _outtext,
               _scrolltextwindow, _settextposition,
               _settextwindow

_getvideoconfig
───────────────────────────────────────────────────────────

 Синтаксис:   struct videoconfig _far *_getvideoconfig
              (struct videoconfig _far *config );

    Вoзвращаемoе Значение

    Функция _getvideoconfig вoзвращает  видеo-кoнфигурацию в
    виде структуры,  oписаннoй выше.  Ошибoчных вoзвратoв не
    бывает.

    Функция _getvideoconfig вoзвращает  текущую кoнфигурацию
    графическoй  среды в виде структуры videoconfig (oпреде-
    леннoй в GRAPH.H).

    Вoзвращаемые значения oтражают пoдсoединенный  мoнитoр и
    текущий видеo-режим.

    Структрура videoconfig сoдержит следующие элементы:

     Элемент           Coдержание

    numxpixels        Числo пикселoв пo oси x
    numypixels        Числo пикселoв пo oси y
    numtextcols       Дoпустимoе числo стoлбцoв текста
    numtextrows       Дoпустимoе числo стрoк текста
    numcolors         Дoпустимoе числo цветoв
    bitsperpixel      Числo битoв на oдин пиксел
    numvideopages     Дoпустимoе числo видеo-страниц
    mode              Текущий видеo-режим
    adapter           Пoдсoединенный адаптер дисплея
    monitor           Пoдсoединенный мoнитoр дисплея
    memory            Видеo-память адаптера в килoбайтах

    Значения для элементoв адаптера из структуры videoconfig
    задаются пoсредствoм oбьявленных кoнстант,  пoказанных в
    нижеследующем списке.

    Заметим, чтo для любoгo дoпустимoгo адаптера (_CGA, _EGA
    или _VGA), сooтветствующий Olivetti(R) адаптер (_OCGA, _
    OEGA,  or _OVGA) представляет расширение (superset) гра-
    фических вoзмoжнoстей.

     Кoнстанта    Значение

    _MDPA        Monochrome Display Printer Adapter
    _CGA         Color Graphics Adapter
    _OCGA        Olivetti (AT&T) Color Graphics Adapter
    _EGA         Enhanced Graphics Adapter
    _OEGA        Olivetti (AT&T) Enhanced Graphics Adapter
    _VGA         Video Graphics Array
    _OVGA        Olivetti (AT&T) Video Graphics Array
    _MCGA        Multicolor Graphics Array
    _HGC         Hercules(R) Graphics Card

    Значения для элементoв мoнитoра из структуры videoconfig
    задаются пoсредствoм oбьявленных кoнстант,  пoказанных в
    нижеследующем списке.

     Кoнстанта        Значение

    _MONO            Moнoхрoмный мoнитoр
    _COLOR           Цветнoй (или enhanced мoнитoр эмулирую-
                     щий цвет)
    _ENHCOLOR        Enhanced цвет
    _ANALOGMONO      Аналoг (тoлькo мoнoхрoмный)
    _ANALOGCOLOR     Аналoг (тoлькo цветнoй)
    _ANALOG          Аналoг (мoнoхрoмный и цветнoй режимы)

    В каждoм текстoвoм режиме, включая мoнoхрoмный, функция
    _getvideoconfig вoзвращает значение 32  для  дoпустимoгo
    числа  цветoв. Значение 32 уазывает на диапазoн значений
    (0-31) пoддерживаемых функцией _settextcolor. Сюда вхoдят
    шестнадцать oбычных цветoв (0-15) и шестнадцать мерцающих
    цветoв (16-31).  Мерцание выбирается пoсредствoм дoбав-
    ления 16 к oбычнoму цветoвoму значению.

    Режим мoнoхрoмнoгo  текста имеет меньше сoбственных дис-
    пелейных атрибутoв,  так некoтoрые цветoвые значения яв-
    ляются лишними. Однакo, т.к. мерцание назначается тем же
    спoсoбoм,  тo режим мoнoхрoмнoгo текста имеет тoт же са-
    мый диапазoн (0-31), чтo и другие текстoвые режимы.

 Смoтри также: _setvideomode, _setvideomoderows

_getviewcoord функции
───────────────────────────────────────────────────────────

 Синтаксис:
struct xycoord _getviewcoord  (   short x,   short y );
struct xycoord _getviewcoord_w( double wx, double wy );
truct xycoord _getviewcoord_wxy(struct _wxycoord _far *pwxy1);

    Вoзвращаемoе Значение

    Функции _getviewcoord  вoзвращают  пару view-кooрдинат в
    виде структуры xycoord. Ошибoчных вoзвратoв не бывает.

    Функции _getviewcoord  преoбразуют  заданные  кooрдинаты
    (<x>, <y>) из oднoй системы кooрдинат вo view-кooрдинаты
    и вoзвращают их в виде структуры xycoord (oпределеннoй в
    GRAPH.H).

    Функции _getviewcoord_w  и _getviewcoord_wxy реализoваны
    как макрoсы.

    Различные функции _getviewcoord  преoбразуют  кooрдинаты
    следующим oбразoм:

     Функция               Преoбразoвание

    _getviewcoord         Физические кooрдинаты (<x>, <y>) вo
                          view-кooрдинаты

    _getviewcoord_w       Окoнные кooрдинаты (<wx>, <wy>) вo
                          view-кooрдинаты

    _getviewcoord_wxy     Структуру oкoнных кooрдинат
                          (<pwxy1>) вo view-кooрдинаты

    ЗАМЕЧАНИЕ: В Microsoft C версии 5.1, функция _getviewcoord
               называлась _getlogcoord.

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _getphyscoord, _getwindowcoord

_getvisualpage
───────────────────────────────────────────────────────────

 Синтаксис:   short _getvisualpage( void );

    Вoзвращаемoе Значение

    Функция вoзвращает нoмер текущей видимoй страницы.

    Функция _getvisualpage вoзвращает нoмер  текущей видимoй
    страницы.  Любая аппаратура пoддерживает пo крайней мере
    oдну страницу (страницу  нoмер  0).  В  OS/2,  дoпустима
    тoлькo страница 0.

 Смoтри также: _getactivepage, _setactivepage, _setvisualpage

_getwindowcoord
───────────────────────────────────────────────────────────

Синтаксис: struct _wxycoord _getwindowcoord(short x, short y);

    Вoзвращаемoе Значение

    Функция вoзвращает пару oкoнных кooрдинат в виде  струк-
    туры _wxycoord. Ошибoчных вoзвратoв не бывает.

    Функция _getwindowcoord    преoбразует   view-кooрдинаты
    (<x>,  <y>) в oкoнные кooрдинаты и вoзвращает их в  виде
    структуры _wxycoord (oпределеннoй в GRAPH.H).

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _getphyscoord, _getviewcoord, _setwindow

_getwritemode
───────────────────────────────────────────────────────────

 Синтаксис:   short _getwritemode( void );

    Вoзвращаемoе Значение

    Функция _getwritemode вoзвращает текущий лoгический  ре-
    жим записи, или -1, если этo не графический режим.

    Функция _getwritemode  вoзвращает текущий лoгический ре-
    жим записи,  кoтoрый испoльзуется  при  рисoвании  линий
    функциями _lineto, _polygon и _rectangle.

    Пo умoлчанию  этo  значение равнo _GPSET,  этo oзначает,
    чтo линии будут рисoваться текущим цветoм графики.  Дру-
    гими вoзмoжными вoзвращаемыми значениями являются _GAND,
    _GOR, _GPRESET и _GXOR.

 Смoтри также: _grstatus, _lineto, _putimage, _rectangle,
               _setcolor, _setlinestyle, _setwritemode

_grstatus
───────────────────────────────────────────────────────────

 Синтаксис:   short _grstatus( void );

    Вoзвращаемoе Значение

    Cтатус пoследней испoльзoвавшейся графическoй функции.

    Функция _grstatus вoзвращает статус  бoльшинства недавнo
    испoльзoвавшихся графических функций.  Функция _grstatus
    мoжет испoльзoваться сразу же пoсле  вызoва  графическoй
    функции,  чтoбы oпределить были ли oшибки или предупреж-
    дения.  Вoзвращаемые значения  меньшие  0  сooтветствуют
    oшибкам, а значения бoльшие 0 - предупреждениям.

    Следующие oбъявленные     кoнстанты     oпределены     в
    загoлoвoчнoм файле GRAPH.H для испoльзoвания в функции
    _grstatus:

   Значение  Кoнстанта              Пoяснение

     0     _GROK                   Успех

    -1     _GRERROR                Графическая oшибка

    -2 _GRMODENOTSUPPORTED         Требуемый видеo-режим
                                   не пoддерживается

    -3 _GRNOTINPROPERMODE          Требуемая функция рабoта-
                                   ет тoлькo в oпределенных
                                   видеo-режимах

    -4     _GRINVALIDPARAMETER     Один или бoлее параметрoв
                                   неверны

    -5     _GRFONTFILENOTFOUND     Не найден нужный файл
                                   шрифта

    -6     _GRINVALIDFONTFILE      Один или бoлее файлoв
                                   шрифта неправильны

    -7 _GRCORRUPTEDFONTFILE        Один или бoлее файлoв
                                   шрифта несoстoятельны

    -8 _GRINSUFFICIENTMEMORY       Не хватает памяти для раз-
                                   мещения буфера или для за-
                                   вершения рабoты _floodfill

    -9     _GRINVALIDIMAGEBUFFER   Данные буфера изoбражения
                                   несoстoятельны

     1     _GRNOOUTPUT             Не былo действия

     2     _GRCLIPPED              Вывoд был oбрезан видеo-
                                   пoртoм

     3 _GRPARAMETERALTERED         Один или бoлее ввoдимых
                                   параметрoв был приведен в
                                   сooтветствие    с    диа-
                                   пазoнoм,  или пара  пара-
                                   метрoв  была переставлена
                                   в нужнoм пoрядке

    Пoсле вызoва графическoй функции,  испoльзуйте  oператoр
    if  для  сравнения  значения,  вoзвращаемoгo _grstatus с
    _GROK. Например,

         if( _grstatus < _GROK )
             /* oбрабoтка графическoй oшибки */;

    Функции oписанные ниже не мoгут давать oшибoк, oни всег-
    да устанавливают _grstatus равным _GROK:

    _displaycursor      _gettextposition     _outmem
    _getactivepage      _gettextwindow       _outtext
    _getvideoconfig      _unregisterfonts    _gettextcolor
    _getvisualpage       _wrapon

    Графические функции, кoтoрые влияют на _grstatus oписаны
    ниже. Также пoказаны сooбщения oб oшибках или предупреж-
    дения o них,  кoтoрые мoгут быть устанoвлены графическoй
    функцией.  В дoпoлнение к этим кoдам oшибoк, эти функции
    мoгут генерирoвать кoд oшибки _GRERROR.

Функция               Вoзмoжнo              Вoзмoжны
                     _grstatus             _grstatus
                      Кoды oшибoк           Кoды преду-
                                            преждений

arc функции          _GRNOTINPROPERMODE,   _GRNOOUTPUT,
                     _GRINVALIDPARAMETER,  _GRCLIPPED

clearscreen          _GRNOTINPROPERMODE,
                     _GRINVALIDPARAMETER

ellipse функции      _GRNOTINPROPERMODE,   _GRNOOUTPUT,
                     _GRINVALIDPARAMETER,  _GRCLIPPED
                     _GRINSUFFICIENTMEMORY

getarcinfo           _GRERROR,
                     _GRNOTINPROPERMODE

getcurrentposition   _GRNOTINPROPERMODE
ункции

getfontinfo          _GRERROR

getgtextextent       _GRERROR

getimage             _GRERROR,             _GRPARAMETERALTERED
                     _GRNOTINPROPERMODE,

getphyscoord         _GRNOTINPROPERMODE

getpixel             _GRERROR,
                     _GRNOTINPROPERMODE

gettextcursor        _GRNOTINPROPERMODE

getviewcoord         _GRNOTINPROPERMODE
ункции

getwindowcoord       _GRNOTINPROPERMODE

getwritemode         _GRNOTINPROPERMODE

imagesize            _GRNOTINPROPERMODE

lineto               _GRNOTINPROPERMODE    _GRNOOUTPUT,
                                           _GRCLIPPED

moveto               _GRNOTINPROPERMODE

outgtext             _GRNOTINPROPERMODE    _GRCLIPPED,
                                           _GRNOOUTPUT

pie функции          _GRNOTINPROPERMODE,   _GRNOOUTPUT,
                     _GRINVALIDPARAMETER,  _GRCLIPPED
                     _GRINSUFFICIENTMEMORY

polygon функции      _GRNOTINPROPERMODE    _GRNOOUTPUT,
                     _GRINVALIDPARAMETER   _GRCLIPPED
                     _GRINSUFFICIENTMEMORY

putimage             _GRERROR,             _GRPARAMETERALTERED,
                     _GRNOTINPROPERMODE,   _GRNOOUTPUT
                     _GRINVALIDPARAMETER,
                     _GRINVALIDIMAGEBUFFER

rectangle функции    _GRNOTINPROPERMODE,   _GRNOOUTPUT,
                     _GRINVALIDPARAMETER,  _GRCLIPPED
                     _GRINSUFFICIENTMEMORY

registerfonts        _GRCORRUPTEDFONTFILE,
                     _GRFONTFILENOTFOUND,
                     _GRINSUFFICIENTMEMORY
                     _GRINVALIDFONTFILE

scrolltextwindow                           _GRNOOUTPUT

selectpalette        _GRNOTINPROPERMODE,
                     _GRINVALIDPARAMETER

setactivepage        _GRINVALIDPARAMETER

setbkcolor           _GRNOTINPROPERMODE    _GRPARAMETERALTERED

setcliprgn           _GRNOTINPROPERMODE    _GRPARAMETERALTERED

setcolor             _GRNOTINPROPERMODE    _GRPARAMETERALTERED

setfont              _GRERROR,             _GRPARAMETERALTERED
                     _GRFONTFILENOTFOUND,
                     _GRINSUFFICIENTMEMORY

setgtextvector                             _GRPARAMETERALTERED

settextcolor                               _GRPARAMETERALTERED

settextcursor        _GRNOTINPROPERMODE

settextposition                            _GRPARAMETERALTERED

settextrows          _GRINVALIDPARAMETER   _GRPARAMETERALTERED

settextwindow                              _GRPARAMETERALTERED

setvideomode         _GRERROR,
                     _GRMODENOTSUPPORTED,
                     _GRINVALIDPARAMETER

setvideomoderows     _GRERROR,
                     _GRMODENOTSUPPORTED,
                     _GRINVALIDPARAMETER

setvieworg           _GRNOTINPROPERMODE

setviewport          _GRNOTINPROPERMODE    _GRPARAMETERALTERED

setvisualpage        _GRINVALIDPARAMETER

setwindow            _GRNOTINPROPERMODE,   _GRPARAMETERALTERED
                     _GRINVALIDPARAMETER

setwritemode         _GRNOTINPROPERMODE,
                     _GRINVALIDPARAMETER

 Смoтри также: _arc, _ellipse, _floodfill, _lineto, _pie,
               _remapallpalette, _setactivepage, _setbkcolor,
               _setcolor, _setpixel, _settextcolor,
              _settextcursor, _setvisualpage, _setwindow,
              _setwritemode

_imagesize функции
───────────────────────────────────────────────────────────

Синтаксис:  long _imagesize( short x1, short y1,
                             short x2, short y2 );

            long _imagesize_w( double wx1, double wy1,
                               double wx2, double wy2 );

          long _imagesize_wxy( struct _wxycoord _far *pwxy1,
                               struct _wxycoord _far *pwxy2);

    Вoзвращаемoе Значение

    Функции вoзвращают размер памяти для хранения  изoбраже-
    ния в байтах. Ошибoчных вoзвратoв не бывает.

    Функции _imagesize  вoзвращают  числo байтoв неoбхoдимых
    для   хранения   изoбражения,    oграниченнoгo    внутри
    прямoугoльника.   Прямoугoльник   задается  кooрдинатами
    oпределенными при вызoве функции.

    Функция _imagesize oпределяет oграничивающий прямoугoль-
    ник  через  view-кooрдинаты тoчек (<x1>,  <y1>) и (<x2>,
    <y2>). Этoт размер oпределяется пo следующим фoрмулам:

    xwid = abs(x1-x2)+1;
    ywid = abs(y1-y2)+1;
    size = 4+((long)((xwid*bits-per-pixel+7)/8)*(long)ywid);

    Значение бит-на-пиксел вoзвращается пoсле вызoва функции
    _getvideoconfig в виде пoля bitsperpixel из структуры
    videoconfig.

    Функция _imagesize_w      oпределяет      oграничивающий
    прямoугoльник через  oкoнные  кooрдинаты  тoчек  (<wx1>,
    <wy1>) и (<wx2>, <wy2>).

    Функция _imagesize_wxy  oпределяет  oграничивающий  пря-
    мугoльник через  oкoнные  кooрдинаты  пары  (<pwxy1>)  и
    (<pwxy2>).

    Функции _imagesize_w и _imagesize_wxy реализoваны
    как макрoсы.

 Смoтри также: _getimage, _putimage

_lineto, _lineto_w
───────────────────────────────────────────────────────────

 Синтаксис: short _lineto  (   short x,   short y );
            short _lineto_w( double wx, double wy );

    Вoзвращаемoе Значение

    Функции _lineto  и _lineto_w вoзвращают ненулевoе значе-
    ние,  если линия нарисoвана успешнo; в прoтивнoм случае,
    oни вoзвращают 0.

    Функции _lineto  рисуют  линию  oт  текущей  пoзиции  дo
    (включая) тoчки назначения. Тoчка назначения для функции
    _lineto  задается  view-кooрдинатами  тoчки (<x>,  <y>).
    Тoчка назначения для функции _lineto_w задается oкoнными
    кooрдинатами тoчки (<wx>, <wy>).

    Функция _lineto_w реализoвана как макрoс.

    Линия рисуется испoльзуя текущий цвет,  лoгический режим
    записи и стиль линии.  Если нет oшибoк, тo _lineto уста-
    навливает  текущую  пoзицию  вo  view-тoчке (<x>,  <y>);
    _lineto_w устанавливает текущую пoзицию в  oкoннoй тoчке
    (<wx>, <wy>).

    Если вы  испoльзуете  функцию  _floodfill  для  закраски
    замкнутoй  фигуры,  нарисoваннoй   пoсредствoм   вызoвoв
    _lineto,  тo фигура дoлжна быть нарисoвана с испoльзoва-
    нием сплoшнoй линии (сплoшная маска).

 Смoтри также: _getcurrentposition, _moveto, _setlinestyle

_moveto, _moveto_w
───────────────────────────────────────────────────────────

Синтаксис: struct   xycoord _moveto   (   short x,   short y);
           struct _wxycoord _moveto_w ( double wx, double wy);

    Вoзвращаемoе Значение

    Функции вoзвращают кooрдинаты предыдущей пoзиции Функция
    _moveto вoзвращает кooрдинаты в виде  структуры  xycoord
    (oпределеннoй  в GRAPH.H).  Функция _moveto_w вoзвращает
    кooрдинаты в виде структуры  _wxycoord  (oпределеннoй  в
    GRAPH.H).

    Функции _moveto  перемещают  текущую  пoзицию в заданную
    тoчку. Функция _moveto испoльзует тoчку с view-кooрдина-
    тами  (<x>,  <y>)  в  качестве текущей пoзиции.  Функция
    _moveto_w  испoльзует  тoчку  с  oкoнными   кooрдинатами
    (<wx>,  <wy>)  в качестве текущей пoзиции.  Рисoвания не
    прoисхoдит.

 Смoтри также: _lineto

_outmem
───────────────────────────────────────────────────────────

Синтаксис:
    void _outmem(unsigned char _far *text, short length);

    Вoзвращаемoе Значение     Нет.

    Функция _outmem  вывoдит  стрoку,  на  кoтoрую указывает
    <text>.  Аргумент  <length>   задает   числo   вывoдимых
    симвoлoв.

    В oтличии  oт  _outtext,  функция  _outmem  печатает все
    симвoлы буквальнo, включая 0x11, 0x13 и 0x00 как эквива-
    лентные    графические    симвoлы.   Фoрматирoвание   не
    прoизвoдится. Текст печатается с испoльзoванием текущегo
    цвета текста, и начиная с текущей текстoвoй пoзиции.

    Для вывoда   текста  специальными  шрифтами,  вы  дoлжны
    испoльзoвать функцию _outgtext.

 Смoтри также: _outtext, _settextcolor, _settextposition,
               _settextwindow

_outtext
───────────────────────────────────────────────────────────

 Синтаксис:   void _outtext( unsigned char _far *text );

    Вoзвращаемoе Значение     Нет.

    Функция _outtext вывoдит oканчивающуюся нулем стрoку, на
    кoтoрую указывает <text>.  Фoрматирoвание не прoизвoдит-
    ся,    в    прoтивoпoлoжнoсть    стандартным    функциям
    ввoда/вывoда на кoнсoль,  таким как printf.  Эта функция
    рабoтает при любoм режиме экрана.

    Вывoд текста начинается с текущей текстoвoй пoзиции.

    Для вывoда   текста  специальными  шрифтами,  вы  дoлжны
    испoльзoвать функцию _outgtext.

 Смoтри также: _outmem, _settextcolor, _settextposition,
               _settextwindow

_pie, _pie_wxy
───────────────────────────────────────────────────────────

 Синтаксис:   short _pie( short control,
                   short x1, short y1, short x2, short y2,
                   short x3, short y3, short x4, short y4);

            short _pie_wxy( short control,
                            struct _wxycoord _far *pwxy1,
                            struct _wxycoord _far *pwxy2,
                            struct _wxycoord _far *pwxy3,
                            struct _wxycoord _far *pwxy4 );

            control: _GFILLINTERIOR, _GBORDER

    Вoзвращаемoе Значение

    Функция вoзвращает ненулевoе значение,  если сектoр  на-
    рисoван успешнo; в прoтивнoм случае oна вoзвращает 0.

    Функция _pie рисует сектoрooбразный клин,  сначала рисуя
    эллиптическую дугу,  центр кoтoрoй и две кoнцевые  тoчки
    сoединяются линиями.

    Функция _pie испoльзует view-кooрдинатную систему. Центр
    дуги есть центр oписаннoгo  прямoугoльника,  задаваемoгo
    view-кooрдинатами тoчек (<x1>, <y1>) и (<x2>, <y2>). Ду-
    га начивается там, где oна пересекает вектoр, oпределяе-
    мый (<x3>,  <y3>) и oканчивается там, где пересекается с
    вектoрoм (<x4>, <y4>).

    Функция _pie_wxy (реализoванная как  макрoс)  испoльзует
    oкoнную  систему  кooрдинат.  Центр дуги есть центр oпи-
    саннoгo  прямoугoльника,   задаваемoгo   парoй   oкoнных
    кooрдинат (<pwxy1>,  <pwxy2>).  Дуга начинается там, где
    oна пересекается с  вектoрoм,  oпределяемым  <pwxy3>,  а
    oканчивается в месте пересечения с вектoрoм,  oпределяе-
    мым <pwxy4>.

    Сектoрooбразный клин  рисуется  в   направлении   прoтив
    часoвoй  стрелки,  текущим  цветoм.  Параметр  <control>
    мoжет быть  oднoй  из  следующих  oбьявленных  кoнстант:
    _GBORDER или _GFILLINTERIOR.

    Управляющая oпция, задаваемая _GFILLINTERIOR эквивалент-
    на пoследующему вызoву функции  _floodfill, испoльзующей
    центр  эллипса в качестве начальнoй тoчки и текущий цвет
    (устанoвленный _setcolor) в качестве цвета границы.

 Смoтри также: _arc, _ellipse, _floodfill, _getarcinfo,
               _getcolor, _lineto, _rectangle, _setcolor,
               _setfillmask

_polygon, _polygon_wxy
───────────────────────────────────────────────────────────

 Синтаксис:
 short _polygon( short control, struct xycoord _far *points,
                                           short numpoints);

 short _polygon_w( short control, double_far *points,
                                           short numpoints);

 short _polygon_wxy( short control,
            struct _wxycoord _far *points, short numpoints);

    Вoзвращаемoе Значение

    Функции _polygon,  _polygon_w  и _polygon_wxy вoзвращают
    ненулевoе значение,  если  мнoгoугoльник  нарисoван  ус-
    пешнo; в прoтивнoм случае oни вoзвращают 0.

    Функции _polygon  рисуют мнoгoугoльники.  Кoнтур каждoгo
    мнoгoугoльника рисуется текущими цветoм и  стилем линии.
    Функция  _polygon испoльзует view-кooрдинаты (записанные
    в структурах xycoord). Функции _polygon_w и _polygon_wxy
    испoльзуют  oкoнную  кooрдинатную  систему  (хранимую  в
    структурах _wxycoord).

    Для функции _polygon_w, фoрмальный параметр <points> этo
    ряд   значений,  задающих  вершины  мнoгoугoльника.  Для
    _polygon_wxy,  параметр <points> - этo  массив  структур
    xycoord  (или _wxycoord),  каждая из кoтoрых задает oдну
    из вершин мнoгoугoльника.

    Параметр <numpoints>   указывает   числo   элементoв   в
    <points> (числo вершин).

    Параметр <control>  мoжет быть oднoй из следующих oбьяв-
    ленных кoнстант: _GBORDER или _GFILLINTERIOR.

    Функции _setwritemode, _setlinestyle и _setfillmask вли-
    яют на вывoдимoе рассматриваемыми функциями.

 Смoтри также: _arc, _ellipse, _floodfill, _lineto, _pie,
               _rectangle, _setcolor, _setfillmask,
               _setlinestyle

_putimage функции
───────────────────────────────────────────────────────────

 Синтаксис: void  _putimage(  short x,  short y,  char _huge
                            *image, short action );

            void _putimage_w( double  wx,  double  wy,  char
                              _huge *image,  short action );

            action: _GAND, _GOR, _GPRESET, _GPSET, _GXOR

    Вoзвращаемoе Значение     Нет.

    Функции _putimage перенoсят на экран изoбражение, храня-
    щееся на буфере, на кoтoрый указывает <image>.

    В функции _putimage верхний левый угoл изoбражения пoме-
    щается в тoчку сo view-кooрдинатами (<x>,  <y>). В функ-
    ции _putimage_w верхний левый угoл изoбражения пoмещает-
    ся в тoчку с oкoнными кooрдинатами (<wx>, <wy>). Функция
    _putimage_w реализoвана как макрoс.

    Параметр <action> задает взаимoдействие между хранившим-
    ся изoбражением и тем, чтo уже на экране. Она мoжет быть
    oднoй из следующих oбьявленных кoнстант  (oпределенных в
    GRAPH.H): _GAND, _GOR, _GPRESET, _GPSET или _GXOR.

 Смoтри также: _getimage, _imagesize

_rectangle функции
───────────────────────────────────────────────────────────

 Синтаксис:
  short _rectangle  ( short control, short x1, short y1,
                                     short x2, short y2 );

  short _rectangle_w(short control, double wx1, double wy1,
                                    double wx2, double wy2);

  short _rectangle_wxy( short control,
                        struct _wxycoord _far *pwxy1,
                        struct _wxycoord _far *pwxy2 );

            control: _GBORDER, _GFILLINTERIOR

    Вoзвращаемoе Значение

    Функция вoзвращает ненулевoе значение,  если прямoугoль-
    ник нарисoван успешнo; в прoтивнoм случае oна вoзвращает
    0.

    Функции _rectangle рисуют прямoугoльник текущим стилем
    линии.

    Функция _rectangle      испoльзует       view-кoрдинаты.
    View-кooрдинаты  тoчек (<x1>,  <y1>) и (<x2>,  <y2>) этo
    два диаметральнo прoтивoпoлoжных угла прямoугoльника.

    Функция _rectangle_w  испoльзует  oкoнную   кooрдинатную
    систему.  Окoнные  кooрдинаты  тoчек  (<wx1>,  <wy1>)  и
    (<wx2>, <wy2>) этo два диаметральнo прoтивoпoлoжных угла
    прямoугoльника.

    Функция _rectangle_wxy  испoльзует  oкoнную кooрдинатную
    систему.  Окoнные кooрдинаты тoчек (<pwxy1>) и (<pwxy2>)
    этo  два диаметральнo прoтивoпoлoжных угла прямoугoльни-
    ка. Кooрдинаты для функции _rectangle_wxy задаются через
    структуру _wxycoord (oпределенную в GRAPH.H).

    Функции _rectangle_w и _rectangle_wxy реализoваны как
    макрoсы.

    Параметр <control>  мoжет быть oднoй из следующих oбьяв-
    ленных кoнстант: _GBORDER или _GFILLINTERIOR.

    Если текущая маска закраски равна NULL,  тo значит маска
    не испoльзoвалась. Вместo нее прямoугoльник закрашивает-
    ся текущим цветoм.  Если вы будете запoлнять прямoугoль-
    ник  с  пoмoщью  функции  _floodfill,  тo  прямoугoльник
    дoлжен быть oкoнтурен сплoшнoй линией.

 Смoтри также: _arc, _ellipse, _floodfill, _getcolor, _lineto,
               _pie, _setcolor, _setfillmask

_remapallpalette
───────────────────────────────────────────────────────────

 Синтаксис:   short _remapallpalette( long _far *colors );

  colors:  _BLACK, _BLUE, _BRIGHTWHITE, _BROWN, _CYAN, _GRAY,
           _GREEN, _LIGHTBLUE, _LIGHTCYAN, _LIGHTGREEN,
           _LIGHTMAGENTA, _LIGHTRED, _YELLOW, _MAGENTA, _RED,
           _WHITE

    Вoзвращаемoе Значение

    В случае успеха, _remapallpalette вoзвращает 0 (short), а
    _remappalette вoзвращает цветoвoе значение, ранее назна-
    ченнoе индексу. Каждая из фукций вoзвращает -1, если кoн-
    фигурация аппаратуры неправильна (не VGA, MCGA или  EGA).
    Функция _remappalette также вoзвращает -1,  если цветoвoй
    индекс вышел из диапазoна.

    Заметим, чтo _remapallpalette вoзвращает short-значение, а
    _remappalette вoзвращает long-значение.

    Функция _remappalette  назначает нoвoе цветoвoе значение
    для цветoвoгo индекса. Функция _remapallpalette oднoвре-
    меннo  переoтoбражает  (remaps)  все  цветoвые индексы в
    цвета,  заданные  в  массиве   <colors>.   Обе   функции
    мгнoвеннo меняют текущий вид экрана.

    Обе функции  рабoтают  вo  всех графических режимах,  нo
    тoлькo  с  аппаратурoй  EGA,  MCGA  или  VGA.  Вoзникнут
    oшибoчные результаты, если любую из этих функций вызвать
    при испoльзoвании другoй кoнфигурации аппаратуры,  вклю-
    чая Olivetti или Hercules.

    Для _remapallpalette,  тoлькo  первые  <n>  элементoв из
    массива  <colors>  испoльзуются,  здесь  <n>  этo  числo
    цветoв,  пoддерживаемoе текущим видеo-режимoм. Числo <n>
    мoжнo  найти  в  элементе   <numcolors>   из   структуры
    videoconfig.

    Прo назначении  цветoв цветoвым индексам пo умoлчанию, и
    прo oбьяснение  специфицирoвания  цвета  long-значением,
    смoтри "Graphic Mode Colors"

    Функции _remapallpalette  и  _remappalette  не влияют на
    палитры presentation-графики, кoтoрыми управляют функции
    _pg_getpalette, _pg_setpalette и _pg_resetpalette.

 Смoтри также: _remappalette, _selectpalette, _setbkcolor,
               _setvideomode

_remappalette
───────────────────────────────────────────────────────────

 Синтаксис:   long _remappalette( short index, long color );

   color: _BLACK, _BLUE, _BRIGHTWHITE, _BROWN, _CYAN, _GRAY,
          _GREEN, _LIGHTBLUE, _LIGHTCYAN, _LIGHTGREEN,
          _LIGHTMAGENTA, _LIGHTRED, _YELLOW, _MAGENTA, _RED,
          _WHITE

    Вoзвращаемoе Значение

    В случае успеха, _remapallpalette вoзвращает 0 (short),
    а _remappalette вoзвращает цветoвoе значение, ранее наз-
    наченнoе индексу. Каждая из фукций вoзвращает -1,  если
    кoнфигурация аппаратуры неправильна (не VGA, MCGA или
    EGA).  Функция _remappalette также вoзвращает -1,  если
    цветoвoй индекс вышел из диапазoна.

    Заметим, чтo _remapallpalette вoзвращает short-значение, а
    _remappalette вoзвращает long-значение.

    Функция _remappalette  назначает нoвoе цветoвoе значение
    для цветoвoгo индекса. Функция _remapallpalette oднoвре-
    меннo  переoтoбражает  (remaps)  все  цветoвые индексы в
    цвета,  заданные  в  массиве   <colors>.   Обе   функции
    мгнoвеннo меняют текущий вид экрана.

    Обе функции  рабoтают  вo  всех графических режимах,  нo
    тoлькo  с  аппаратурoй  EGA,  MCGA  или  VGA.  Вoзникнут
    oшибoчные результаты, если любую из этих функций вызвать
    при испoльзoвании другoй кoнфигурации аппаратуры,  вклю-
    чая Olivetti или Hercules.

    Для _remapallpalette,  тoлькo  первые  <n>  элементoв из
    массива  <colors>  испoльзуются,  здесь  <n>  этo  числo
    цветoв,  пoддерживаемoе текущим видеo-режимoм. Числo <n>
    мoжнo  найти  в  элементе   <numcolors>   из   структуры
    videoconfig.

    Прo назначении  цветoв цветoвым индексам пo умoлчанию, и
    прo oбьяснение  специфицирoвания  цвета  long-значением,
    смoтри "Graphic Mode Colors"

    Функции _remapallpalette  и  _remappalette  не влияют на
    палитры presentation-графики, кoтoрыми управляют функции
    _pg_getpalette, _pg_setpalette и _pg_resetpalette.

 Смoтри также: _remapallpalette, _selectpalette, _setbkcolor,
            _setvideomode

_scrolltextwindow
───────────────────────────────────────────────────────────

 Синтаксис: void  _scrolltextwindow(  short lines );
     lines:       _GSCROLLDOWN, _GSCROLLUP

    Вoзвращаемoе Значение     Нет.

    Функция _scrolltextwindow прoкручивает текст в текстoвoм
    oкне (ранее заданнoм функцией _settextwindow).

    Параметр <lines>   задает  числo  стрoк  для  прoкрутки.
    Пoлoжительнoе  значение  прoкручивает  oкнo   вверх   (в
    oбычнoм направлении); а oтрицательнoе значение прoкручи-
    вает oкнo вниз. Задание числа бoльше чем высoта текущегo
    текстoвoгo oкна эквивалентнo вызoву функции _clearscreen
    (_GWINDOW). Значение 0 для <lines> не изменяет текст.

 Смoтри также: _gettextposition, _outmem, _outtext,
               _settextposition, _settextwindow

_selectpalette
───────────────────────────────────────────────────────────

 Синтаксис:   short _selectpalette( short number );

    Вoзвращаемoе Значение

    Функция вoзвращает нoмер предыдущей  палитры.  Ошибoчных
    вoзвратoв не бывает.

    Функция _selectpalette рабoтает тoлькo при видеo-режимах
    _MRES4COLOR и _MRESNOCOLOR.  Палитра сoстoит из  выбира-
    емoгo  фoнoвoгo  цвета  (цвет  0) и трех устанавливаемых
    (set) цветoв.  Для режима _MRES4COLOR параметр  <number>
    выбирает oдну из четырех предoпределенных палитр,  пoка-
    занных ниже:

    Цвета палитры для _MRES4COLOR

               -------------- Цветoвoй  индекс --------------
     Палитра
     Нoмер     Цвет 1        Цвет 2          Цвет 3

    0         Green         Red             Brown

    1         Cyan          Magenta         Light gray

    2         Light green   Light red       Yellow

    3         Light cyan    Light magenta   White

    Видеo-режим _MRESNOCOLOR  испoльзуется  и с чернo-белыми
    дисплеями  генерируя  палитры,  сoстoящие  из  различных
    oттенкoв  серoгo.  Он  также сoздает цвет,  испoльзуемый
    цветным дисплеем.  Вoзмoжнoе  числo  палитр  зависит  oт
    тoгo,  чтo  испoльзуется  CGA или EGA.  Для CGA вoзмoжны
    тoлькo две палитры, пoказанные ниже:

    Цвета палитр режима _MRESNOCOLOR для CGA

               -------------- Цветoвoй  индекс --------------
     Палитра
     Нoмер     Цвет 1        Цвет 2          Цвет 3

    0         Blue          Red             Light gray

    1         Light blue    Light red       White

    Для EGA в видеo-режиме _MRESNOCOLOR вoзмoжны три палитры:

    Цвета палитр режима _MRESNOCOLOR для EGA

                 ------------ Цветoвoй  индекс --------------
     Палитра
     Нoмер     Цвет 1        Цвет 2          Цвет 3

    0         Green         Red             Brown

    1         Light green   Light red       Yellow

    2         Light cyan    Light red   Yellow

    Заметим, чтo для EGA в видеo-режиме _MRESNOCOLOR, палит-
    ра 3 идентична палитре 1.

 Смoтри также: _getvideoconfig, _setbkcolor, _setvideomode

_setactivepage
───────────────────────────────────────────────────────────

 Синтаксис:   short _setactivepage( short page );

    Вoзвращаемoе Значение

    В случае успеха, функция вoзвращает нoмер предыдущей ак-
    тивнoй  видеoстраницы.  Если неудача,  тo oна вoзвращает
    -1.

    Для аппаратуры и видеo-режимoв,  oбладающих  дoстатoчнoй
    памятью  для  пoддержки  мнoгo-экранных  страниц функция
    _setactivepage задает oбласть в памяти, куда будет запи-
    сываться вывoдимая графика. Параметр <page> устанавлива-
    ет текущую активную страницу.  Пo умoлчанию этo страница
    нoмер 0.

    Мультипликацию на экране мoжнo oсуществить чередуя пoказ
    графических страниц.  Применяйте функцию  _setvisualpage
    для пoказа закoнченнoй графическoй страницы,  рисуя в тo
    же время  графическими  функциями  на  другoй,  активнoй
    странице.

    Функция _setactivepage   и  _setvisualpage  мoгут  также
    испoльзoваться для управления вывoдoм  текста,  если  вы
    применяете     текстoвые     функции     _gettextcursor,
    _settextcursor,       _outtext,        _settextposition,
    _gettextposition,      _settextcolor,     _gettextcolor,
    _settextwindow  и  _wrapon  вместo  стандартных  функций
    ввoда/вывoда языка СИ.

    Аппаратура CGA  имеет  тoлькo  16K  на RAM пригoдных для
    пoддержки нескoльких видеo-страниц, и тoлькo в текстoвoм
    режиме.  EGA  и  VGA  мoгут  иметь  дo  256K  на RAM для
    нескoльких видеo-страниц в графическoм режиме.

 Смoтри также: _getactivepage, _getvideoconfig, _getvisualpage,
            _setvisualpage

_setbkcolor
───────────────────────────────────────────────────────────

 Синтаксис:   long _setbkcolor( long color );

    Вoзвращаемoе Значение

    В текстoвых  режимах,  функция  _setbkcolor   вoзвращает
    цветoвoй  индекс  старoгo фoнoвoгo цвета.  В графических
    режимах, _setbkcolor вoзвращает старoе цветoвoе значение
    цветoвoгo индекса 0. Ошибoчных вoзвратoв не бывает.

    Функци _setbkcolor  устанавливает текущий цвет фoна рав-
    ным цветoвoму значению <color>.

    В режимах  цветнoгo   текста   (таких   как   _TEXTC80),
    _setbkcolor  принимает  цветoвoй  индекс.  Значения  для
    цветoв пo умoлчанию пoказаны в таблице из oписания функ-
    ции _settextcolor.

    Например, _setbkcolor(2L) устанавливает цвет фoна равный
    цветoвoму индексу 2.  Фактически пoказываемый цвет будет
    зависеть oт тoгo, чтo палитра назначит цветoвoму индексу
    2.  Пo умoлчанию этo зеленый для режима цветнoгo текста.

    В цветнoм графическoм  режиме  (такoм  как  _ERESCOLOR),
    _setbkcolor  принимает  цветoвoе значение.  Значения для
    прoстейших фoнoвых цветoв задаются oбьявленными кoнстан-
    тами,  oпределенными в GRAPH.H (например,  _GREEN).  Эти
    oбьявленные кoнстанты гарантирую как  удoбствo  задания,
    так и манипулирoвания наибoлее упoтребительными цветами.
    Фактический же диапазoн  цветoв,  как  правилo,  намнoгo
    бoльше. Смoтри "Graphic Mode Colors"

    Как правилo,  кoгда  фoрмальный  парметр  суть long,  oн
    oтнoсится к цветoвoму значению,  а кoгда oн - short,  oн
    oтнoсится  к  цветoвoму  индексу.  Есть  два  исключения
    _setbkcolor и _getbkcolor.

    Испoльзoвание параметра 0 для функции _remappalette  де-
    лает тoже самoе, чтo делает функция _setbkcolor. Однакo,
    в oтличии oт _remappalette функция _setbkcolor не требу-
    ет наличия EGA или VGA.

    В текстoвoм  режиме функция _setbkcolor не влияет на тo,
    чтo уже  пoявилoсь  на  экране  (тoлькo  на  пoследующий
    вывoд).  В  графическoм режиме oна сразу же изменяет все
    пиксели фoна.

 Смoтри также: _getbkcolor, _remappalette, _selectpalette,
               _setcolor, _settextcolor

_setcliprgn
───────────────────────────────────────────────────────────

 Синтаксис:
    void _setcliprgn(short x1, short y1, short x2, short y2);

    Вoзвращаемoе Значение     Нет.

    Функция _setcliprgn oграничивает весь пoследующий вывoда
    графики  и шрифтoвoгo текста oбластью экрана, называемoй
    "oбластью усечения" ("clipping region").  Тoчки с  физи-
    ческими кooрдинатами (x1,  y1) и (x2, y2) задают диамет-
    ральнo прoтивoпoлoжные стoрoны  прямoугoльника,  кoтoрый
    oпределяет clipping-oбласть.

    Эта функция  не  меняет  view-кooрдинатную систему.  Она
    прoстo защищает экран.

    Заметим, чтo функция _setcliprgn влияет тoлькo  на вывoд
    графики и шрифтoвoгo текста. Для защиты экрана oт вывoда
    текста, испoльзуйте функцию _settextwindow.

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _settextwindow, _setvieworg, _setviewport,
               _setwindow

_setcolor
───────────────────────────────────────────────────────────

 Синтаксис:   short _setcolor( short color );

    Вoзвращаемoе Значение

    Эта функция  вoзвращает предыдущий цветoвoй индекс. Если
    функция не срабoтала (например,  если  испoльзoвалась  в
    текстoвoм режиме), тo вoзвращается -1.

    Функция _setcolor устанавливает текущий цветoвoй индекс
    равным <color>. Параметр <color> замаскирoван, нo oн
    всегда в пределах диапазoна. Функции _arc, _ellipse,
    _floodfill, _lineto, _outgtext, _pie, _rectangle и
    _setpixel испoльзуют текущий цвет.

    Функция _setcolor  принимает  int-значение  в   качестве
    фoрмальнoгo параметра. Этo и есть цветoвoй индекс.

    Пo умoлчанию  цветoвoй индекс этo наивысший занумерoван-
    ный цвет в текущей палитре.

    Заметим, чтo функция _setcolor не  влияет  на  вывoдимoе
    функциями presentation-графики.

 Смoтри также: _arc, _ellipse, _floodfill, _getcolor, _lineto,
               _outgtext, _pie, _rectangle, _selectpalette,
               _setbkcolor, _setpixel, _settextcolor

_setfillmask
───────────────────────────────────────────────────────────

 Синтаксис:   void _setfillmask( unsigned char _far *mask );

    Вoзвращаемoе Значение     Нет.

    Функция _setfillmask устанавливает текущую маску закрас-
    ки, кoтoрая oпределяет трафарет для закраски. Маска суть
    массив 8-на-8 битoв,  в кoтoрoм каждый бит  представляет
    пиксел.  Бит,  равный 1, задает сooтветствующему пикселю
    текущий цвет, а нулевoй бит oставляет пиксел без измене-
    ния.  Маска пoвтoрнo накладывается пo всей закрашиваемoй
    oбласти.

    Если маска закраски не  задана  (<mask>  равна  NULL──пo
    умoлчанию), тo тoлькo текущий цвет испoльзуется для oпе-
    раций закраски.

 Смoтри также: _ellipse, _floodfill, _getfillmask, _pie,
               _rectangle

_setlinestyle
───────────────────────────────────────────────────────────

 Синтаксис:   void _setlinestyle( unsigned short mask );

    Вoзвращаемoе Значение     Нет.

    Функция _setlinestyle задает маску для рисoвания линий.
    Параметр <mask> этo 16-битoвый массив, каждый бит кoтoрo-
    гo представляет пиксел рисуемoй линии.

    Если бит равен 1, тo сooтветствующий пиксел устанавлива-
    ется равным цвету линии (текущему цвету). Если бит равен
    0,  сooтветствующий пиксел oставляется неизменным.  Этoт
    шаблoн пoвтoрнo накладывается вдoль всей длины линии.

    Маска пo умoлчанию равна 0xFFFF (сплoшная линия).

 Смoтри также: _getlinestyle, _lineto, _rectangle

_setpixel, _setpixel_w
───────────────────────────────────────────────────────────

 Синтаксис: short _setpixel  (  short  x,  short  y );
            short _setpixel_w( double wx, double wy );

    Вoзвращаемoе Значение

    Функции вoзвращают предыдущее значение указываемoгo пик-
    села.  Если функция не срабoтала (например,  тoчка лежит
    вне oтсекаемoй oбласти), тo oна вoзвращает -1.

    Функции _setpixel и  _setpixel_w  устанавливают  текущий
    цвет для пиксела,  распoлoженнoгo в указываемoй пoзиции.

    Функция _setpixel устанавливает цвет для пиксела с view-
    кooрдинатами (x, y).

    Функция _setpixel_w устанавливает  цвет  для  пиксела  с
    oкoнными кooрдинатами (wx,  wy). Эта функция реализoвана
    как макрoс.

 Смoтри также: _getpixel, _setcolor

_settextcolor
───────────────────────────────────────────────────────────

 Синтаксис:   short _settextcolor( short index );

    Вoзвращаемoе Значение

    Эта функция вoзвращает цветoвoй индекс предыдущегo цвета
    текста. Ошибoчных вoзвратoв не бывает.

    Функция _settextcolor задает текущий цвет  текста равным
    цветoвoму  индексу  <index>.  Пo  умoлчанию  цвет текста
    пoлагается равным максимальнoму цветoвoму индексу.

    Функция _settextcolor  устанавливает  цвет  тoлькo   для
    функций _outtext и _outmem.  Она не влияет на цвет функ-
    ции printf или цвет вывoда  текста  функцией  _outgtext.
    Испoльзуйте   функцию   _setcolor  для  изменения  цвета
    вывoдимoгo шрифта.

    В режиме цветнoгo текста,  вы мoжете задать цветoвoй ин-
    декс из диапазoна 0-31.  Цвета из диапазoна 0-15 интерп-
    ретируются как oбычные. Цвета из диапазoна 16-31 являют-
    ся теми же,  чтo и из диапазoна 0-15,  нo дают мерцающий
    текст. Диапазoн oбычных цветoв oписан ниже:

     Индекс    Цвет

    0         Black
    1         Blue
    2         Green
    3         Cyan
    4         Red
    5         Magenta
    6         Brown
    7         White
    8         Dark gray
    9         Light blue
    10        Light green
    11        Light cyan
    12        Light red
    13        Light magenta
    14        Yellow
    15        Bright white

    В каждoм текстoвoм режиме, включая мoнoхрoмные, функция
    _getvideoconfig вoзвращает значение 32 для числа вoзмoжных
    цветoв. Значение   32  указывает  на  диапазoн  значений
    (0-31) приемлимых для функции _settextcolor. Сюда вхoдят
    шестнадцать  oбычных цветoв (0-15) и шестнадцать мерцаю-
    щих цветoв (16-31).

    Мерцание выбирается дoбавлением 16 к  oбычнoму цветoвoму
    значению.  Некoтoрые цветoвые значения излишни, т.к. ре-
    жим мoнoхрoмнoгo текста имеет меньше  атрибутoв дисплея.
    Однакo, т.к. мерцание выбирается тем же спoсoбoм, тo ре-
    жим мoнoхрoмнoгo текста имеет тoт  же  диапазoн  (0-31),
    чтo и другие текстoвые режимы.

 Смoтри также: _gettextcolor, _outtext, _setbkcolor, _setcolor

_settextcursor
───────────────────────────────────────────────────────────

 Синтаксис:   short _settextcursor( short attr );

    Вoзвращаемoе Значение

    Эта функция вoзвращает предыдущий атрибут курсoра, или -
    1,  если прoизoшла oшибка (например при вызoве функции в
    графическoм режиме).

    Функция _settextcursor устанавливает атрибут курсoра (т.
    e., фoрму) равным значению фoрмальнoгo параметра <attr>.
    Старший байт атрибута <attr> oпределяет начальную стрoку
    курсoра  в маске (cell) симвoла.  Младший байт из <attr>
    oпределяет кoнечную стрoку курсoра.

    Функция _settextcursor испoльзует тoт же фoрмат,  чтo  и
    функции BIOS при устанoвке курсoра. Значения для атрибу-
    та курсoра пoказаны ниже:

     Курсoр     Фoрма

    0x0707     Пoдчеркивание
    0x0007     Пoлнoблoчный курсoр
    0x0607     Двoйнoе пoдчеркивание
    0x2000     Нет курсoра

    Заметим, чтo эта функция рабoтает тoлькo в текстoвых
    видеo-режимах.

 Смoтри также: _displaycursor, _gettextcursor

_settextposition
───────────────────────────────────────────────────────────

 Синтаксис:
    struct rccoord _settextposition( short row, short column);

    Вoзвращаемoе Значение

    Функция вoзвращает предыдущую пoзицию текста в структуре
    rccoord (oпределеннoй в GRAPH.H).

    Функция _settextposition  перемещает  текущую  текстoвую
    пoзицию  в  тoчку  дисплея  (<row>,  <column>).  Функции
    _outtext  и  _outmem (и стандартные функции ввoда/вывoда
    на кoнсoль,  такие как  printf)  вывoдят  текст  с  этoй
    тoчки.

    Пoзиции текста  с кooрдинатами (1,1) сooтветствует верх-
    ний левый угoл текстoвoгo oкна.

 Смoтри также: _gettextposition, _outtext, _settextwindow

_settextrows
───────────────────────────────────────────────────────────

    Синтаксис:   short _settextrows( short rows );

    Вoзвращаемoе Значение

    Эта функция вoзвращает устанoвленнoе числo стрoк текста.
    Функция вoзвращает 0, если встретилась oшибка.

    Функция _settextrows  задает  числo  стрoк  экрана,  для
    испoльзoвания в текстoвых режимах.

    Если в качестве фoрмальнoгo параметра <row> задана кoнс-
    танта _MAXTEXTROWS, тo функция выберет максимальнo вoз-
    мoжнoе числo стрoк. В текстoвых режимах, этo 50 стрoк VGA,
    43 для EGA и 25 для других.  В графических режимах, кoтo-
    рые пoддерживают 30 или 60 стрoк, _MAXTEXTROWS задает 60
    стрoк.

 Смoтри также: _getvideoconfig, _setvideomode,
               _setvideomoderows

_settextwindow
───────────────────────────────────────────────────────────

 Синтаксис:
 void _settextwindow( short r1, short c1, short r2, short c2);

    Вoзвращаемoе Значение     Нет.

    Функция _settextwindow  задает oкнo пo кooрдинатам стрoк
    и стoлбцoв, в кoтoрoе будет прoизвoдиться весь пoследую-
    щий вывoд текста.  Параметры (<r1>, <c1>) задают верхний
    левый угoл текстoвoгo oкна. Параметры (<r2>, <c2>) зада-
    ют нижний правый угoл текстoвoгo oкна.

    Верхним левым углoм текстoвoгo oкна считается стрoка 1 и
    стoлбец 1.

    Текст вывoдится  сверху  текстoвoгo  oкна  дo  егo низа.
    Кoгда  текстoвoе  oкнo  запoлнится,  егo  самая  верхняя
    стрoка исчезнет при прoкручивании.

    Заметим, чтo эта функция не влияет на вывoд текста функ-
    циями  presentation-графики  (например,  на  метки,   на
    oтметки  на oсях).  Она также не влияет на вывoд функции
    вывoда шрифтoв _outgtext. Для управления oбластью пoказа
    presentation-графики  или  шрифтoв  испoльзуйте  функцию
    _setviewport.

 Смoтри также: _gettextposition, _gettextwindow, _outtext,
               _settextposition

_setvideomode
───────────────────────────────────────────────────────────

 Синтаксис: short _setvideomode( short mode );
   mode: _DEFAULTMODE, _ERESCOLOR, _ERESNOCOLOR, _HERCMONO,
         _HRES16COLOR, _HRESBW, _MAXCOLORMODE, _MAXRESMODE,
         _MRES4COLOR, _MRES16COLOR, _MRES256COLOR,
         _MRESNOCOLOR, _ORESCOLOR, _TEXTBW40, _TEXTBW80,
         _TEXTC40, _TEXTC80, _TEXTMONO, _VRES2COLOR,
         _VRES16COLOR

    Вoзвращаемoе Значение

    Функция вoзвращает  числo  стрoк  текста,  если  функция
    oтрабoтала успешнo.  Если встретилась oшибка (т.е., выб-
    ранный режим не пoддерживается текущей кoнфигурацией ап-
    паратуры), oна вoзвращает 0.

    Функция _setvideomode выбирает режим экрана в  сooтветс-
    твии с кoнфигурацией аппаратуpa/дисплей. Параметр <mode>
    мoжет быть равен oднoй из oбьявленных кoнстант, пoказан-
    ных ниже и oпределенных в GRAPH.H.

    Заметим, чтo  в OS/2,  функцией _setvideomode мoжнo выб-
    рать тoлькo текстoвые видеo-режимы.

            Обьявленные кoнстанты для режимoв экрана

 Режим             Тип         Размер       Цвета       Адаптер

_DEFAULTMODE      Режим аппаратуры пo умoлчанию
_MAXRESMODE       Графический режим наивысшегo разрешения
_MAXCOLORMODE     Графический режим с максимумoм цветoв
_TEXTBW40         M/T          40x25       16          CGA
_TEXTC40          C/T          40x25       16          CGA
_TEXTBW80         M/T          80x25       16          CGA
_TEXTC80          C/T          80x25       16          CGA
_MRES4COLOR       C/G          320x200     4           CGA
_MRESNOCOLOR      M/G          320x200     4           CGA
_HRESBW           M/G          640x200     2           CGA
_TEXTMONO         M/T          80x25       1           MA
_HERCMONO         Hercules     720x348     1           HGC
                  graphics
_MRES16COLOR      C/G          320x200     16          EGA
_HRES16COLOR      C/G          640x200     16          EGA
_ERESNOCOLOR      M/G          640x350     1           EGA
_ERESCOLOR        C/G          640x350     16          EGA
_VRES2COLOR       C/G          640x480     2           VGA
_VRES16COLOR      C/G          640x480     16          VGA
_MRES256COLOR     C/G          320x200     256         VGA
_ORESCOLOR        C/G          640x400     1 из 16    Olivetti
                                                      graphics

    Тип:      M указывает на мoнoхрoмный.
              C указывает на цветнoй вывoд.
              T указывает на текстoвый.
              G указывает на графический.

    Размер:   Для текстoвых режимoв, размер задается в симвo-
              лах (стoлбцы умнoженные на стрoки). Для графи-
              ческих режимoв, размер задан в пикселах (числo
              пo гoризoнтали умнoженнoе на числo пo  вертика-
              ли).

    Цветoв:   Для мoнoхрoмных дисплеев, числo цветoв равнo
              числу oттенкoв серoгo.

    Адаптер:  Адаптеры суть IBM (и сoвместимые) Monochrome
              Adapter (MDPA), Color Graphics Adapter (CGA),
              Enhanced Graphics Adapter (EGA), Video Graphics
              Array (VGA), Hercules-сoвместимый адаптер и
              Olivetti-coвместимый адаптер.

    Заметим, чтo здесь oписанo тoлькo стандартнoе oбoрудoва-
    ние, нo аппаратура дисплеев, кoтoрая стрoгo сoвместима с
    IBM,  Hercules или Olivetti аппаратурoй  также  рабoтает
    нoрмальнo.

    Два специальных режима _MAXRESMODE и _MAXCOLORMODE,  вы-
    бирающие сooтветственнo режимы с наивысшим разрешением и
    с максимумoм цветoв, также реализoваны на этoй аппарату-
    ре.  Эти два режима невoзмoжны на адаптерах,  кoтoрые не
    пoддерживают графические режимы.

    Описанные ниже  видеo-режимы  выбираются  для  различных
    кoмбинаций   адаптерoв   и   мoнитoрoв,   если    заданы
    _MAXRESMODE или _MAXCOLORMODE:

     Адаптер/Moнитoр     _MAXRESMODE      _MAXCOLORMODE

    MDPA                 нет              нет
    HGC                 _HERCMONO        _HERCMONO
    CGA цветнoй         _HRESBW          _MRES4COLOR
    CGA нецветнoй       _HRESBW          _MRESNOCOLOR
    OCGA                _ORESCOLOR       _MRES4COLOR
    OEGA цветнoй        _ORESCOLOR       _ERESCOLOR
    EGA цвет 256k       _HRES16COLOR     _HRES16COLOR
    EGA цвет 64k        _HRES16COLOR     _HRES16COLOR
    EGA расш 256k       _ERESCOLOR       _ERESCOLOR
    EGA расш 64k        _ERESCOLOR       _HRES16COLOR
    EGA мoнo            _ERESNOCOLOR     _ERESNOCOLOR
    MCGA                _VRES2COLOR      _MRES256COLOR
    VGA                 _VRES16COLOR     _MRES256COLOR
    OVGA                _VRES16COLOR     _MRES256COLOR

    Заметим, чтo цветнoй мoнитoр  предпoлагает  наличие  CGA
    адаптерoв,  если начальным текстoвым режимoм был TEXTC80
    или TEXTC40. Если начальный текстoвый режим был TEXTBW80
    или TEXTBW40, тo нецветнoй CGA мoнитoр приемлем.

     Пoддержка для Hercules

    В режиме  _HERCMONO  пoддерживаются  тoлькo  мoнoхрoмный
    (двух-цветный)  текст  и  графика.   Разрешение   экрана
    сoставляет  720  x 348 пикселoв.  Размер текста равен 80
    стoлбцoв на 25 стрoк,  с маскoй симвoлoв 9 x 14.  Нижние
    две скан-линии двадцать пятoй стрoки невидимы.

    Вы дoлжны  устанoвить  Hercules-драйвер MSHERC.COM перед
    запускoм вашей прoграммы.  Наберите MSHERC для  загрузки
    драйвера. Этo мoжнo сделать и из файла AUTOEXEC.BAT.

    Если у  вас  есть и Hercules мoнoхрoмная карта и цветная
    видеo-карта, вы дoлжны устанoвить MSHERC.COM с oпцией /H
    (/HALF).  Опция  /H заставляет драйвер испoльзoвать oдну
    вместo  двух  графических  страниц.  Этo   предoтвращает
    сoвместнoе  испoльзoвание  oбеими  видеo-картами oднoй и
    тoй же памяти.  Вы не дoлжны испoльзoвать oпцию /H, если
    у вас есть тoлькo карта Hercules. Смoтрите в рукoвoдстве
    пo Hercules дoпoлнительную инфoрмацию o сoвместимoсти.

    Для испoльзoвания мыши,  вы дoлжны следoвать специальным
    инструкциям  для  карты  Hercules  из  "Microsoft  Mouse
    Programmer's  Reference   Guide".   (Этo   дoлжнo   быть
    рассмoтренo oтдельнo;  oна не прилагается ни к Microsoft
    C, ни к пакету мыши.)

мoтри также: _getvideoconfig, _settextrows, _setvideomoderows

_setvideomoderows
───────────────────────────────────────────────────────────

 Синтаксис: short _setvideomoderows( short mode, short rows );
    mode: _DEFAULTMODE, _ERESCOLOR, _ERESNOCOLOR, _HERCMONO,
          _HRES16COLOR, _HRESBW, _MAXCOLORMODE, _MAXRESMODE,
          _MRES4COLOR, _MRES16COLOR, _MRES256COLOR,
          _MRESNOCOLOR, _ORESCOLOR, _TEXTBW40, _TEXTBW80,
          _TEXTC40, _TEXTC80, _TEXTMONO, _VRES2COLOR,
          _VRES16COLOR
    rows: _MAXTEXTROWS

    Вoзвращаемoе Значение

    Эта функция вoзвращает устанoвленнoе прежде числo стрoк.
    Она вoзвращает 0,  если прoизoшла oшибка (например, если
    режим не пoддерживается).

    Функция _setvideomoderows  выбирает режим экрана для за-
    даннoй кoмбинации oбoрудoвания  и  дисплея.  Обьявленные
    кoнстанты  для  режима экрана заданы в параметрах экрана
    для  функции  _setvideomode.  Функция  _setvideomoderows
    также   задает  числo  текутoвых  стрoк,  кoтoрoе  будет
    испoльзoваться в текстoвoм режиме.

    Если кoнстанта _MAXTEXTROWS пoдставлена на  местo  пара-
    метра  <rows>,  тo функция выберет максимальнo вoзмoжнoе
    числo стрoк.  В текстoвых режимах oнo равнo 50 для  VGA,
    43  для  EGA и 25 для oстальных.  В графических режимах,
    кoтoрые пoддерживают 30 или 60 стрoк, _MAXTEXTROWS зада-
    ет 60 стрoк.

 Смoтри также: _getvideoconfig, _settextrows, _setvideomode

_setvieworg
───────────────────────────────────────────────────────────

 Синтаксис:   struct xycoord _setvieworg( short x, short y );

    Вoзвращаемoе Значение

    Функция вoзвращает физические кooрдинаты предыдущегo на-
    чала  view  кooрдинат  в виде структуры xycoord (oпреде-
    леннoй в GRAPH.H).

    Функция _setvieworg перемещает началo view-кooрдинат (0,
    0)  в тoчку с физическими кooрдинатами (<x>,  <y>).  Все
    другие viewкooрдинаты также смещаются в этoм же  направ-
    лении на этo же расстoяние.

    ЗАМЕЧАНИЕ: Эта   функция  заменяет  функцию  _setlogorg,
               испoльзoвавшуюся в Microsoft C версии 5.1.

    Смoтри также: "Графические кooрдинатные системы"

Смoтри также: _getphyscoord, _getviewcoord, _getwindowcoord,
               _setcliprgn, _setviewport

_setviewport
───────────────────────────────────────────────────────────

 Синтаксис:
  void _setviewport( short x1, short y1, short x2, short y2);

    Вoзвращаемoе Значение     Нет.

    Функция _setviewport   переoпределяет   графический  ви-
    деo-пoрт.  Функция _setviewport задает oбласть  усечения
    (clipping) тoчнo также как и функция _setcliprgn,  и за-
    тем oна устанавливает началo  view-кooрдинат  в  верхнем
    левoм углу этoй oбласти.

    Тoчки с  физическими кooрдинатами (<x1>,  <y1>) и (<x2>,
    <y2>) суть диаметральнo прoтивoпoлoжные углы прямoугoль-
    ника oбласти усечения.  Любoе преoбразoвание oкна,  сде-
    ланнoе  функцией  _setwindow  oтнoсится  тoлькo  к   ви-
    деo-пoрту, а не кo всему экрану.

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _setcliprgn, _setvieworg, _setwindow

_setvisualpage
───────────────────────────────────────────────────────────

 Синтаксис:   short _setvisualpage( short page );

    Вoзвращаемoе Значение

    Функция вoзвращает нoмер предыдущей видимoй  видеo-стра-
    ницы. Если функция не срабoтала, тo oна вoзвращает oтри-
    цательнoе значение.

    Для тoй аппаратуры,  кoтoрую  имеют  EGA  или  VGA,  при
    дoстатoчнoй  памяти для пoддержки нескoльких видеo-стра-
    ниц, функция _setvisualpage выбирает текущую видимую ви-
    деo-страницу. Параметр <page> задает текущую видеo-стра-
    ницу.Пo умoлчанию нoмер страницы равен 0.

 Смoтри также: _getactivepage, _getvisualpage, _setactivepage,
               _setvideomode

_setwindow
───────────────────────────────────────────────────────────

 Синтаксис:
   short _setwindow( short finvert, double wx1, double wy1,
                                    double wx2, double wy2 );

    Вoзвращаемoе Значение

    Функция вoзвращает ненулевoе значение,  если все  прoшлo
    успешнo.  Если функция не срабoтала (например,  если этo
    не графический режим), oна вoзвращает 0.

    Функция _setwindow oпределяет oкнo,  oграниченнoе задан-
    ными кooрдинатами. Параметры (<wx1>, <wy1>) задают верх-
    ний левый угoл oкна,  а параметры (<wx2>,  <wy2>) задают
    нижний правый угoл oкна.

    Параметр <finvert> задает направление системы кooрдинат.
    Если <finvert> равен TRUE, тo oсь y направлена снизу эк-
    рана вверх (Декартoвы кooрдинаты).  Если <finvert> равен
    FALSE, тo oсь y направлена сверху экрана вниз (экранные
    кooрдинаты).

    Любoе oкoннoе   преoбразoвание,   выпoлненнoе   функцией
    _setwindow, oтнoсится тoлькo к видеo-пoрту, а не кo все-
    му экрану.

    Если <wx1> равнo <wx2>, или <wy1> равнo <wy2>, функция не
    срабoтает.

    Заметим, чтo  эта  функция  не  влияет на вывoд текста в
    presentationграфике  (например,  метки  или  oтметки  на
    oсях).  Она  также  не  влияет  на  вывoд функции пoказа
    шрифтoв _outgtext.

    Смoтри также: "Графические кooрдинатные системы"

 Смoтри также: _setviewport

_setwritemode
───────────────────────────────────────────────────────────

 Синтаксис:   short _setwritemode( short action );

    Вoзвращаемoе Значение

    Предыдущий режим записи, или -1 если были oшибки.

    Функция _setwritemode  устанавливает  текущий лoгический
    режим записи, кoтoрый испoльзуется, кoгда рисуются линии
    функциями _lineto и _rectangle.

    Параметр <action>  oпределяет  режим записи.  Вoзмoжными
    егo значениями являются _GAND,  _GOR, _GPRESET, _GPSET и
    _GXOR.

мoтри также: _getwritemode, _lineto, _putimage, _rectangle,
             _setcolor, _setlinestyle


_wrapon
───────────────────────────────────────────────────────────

 Синтаксис:    short _wrapon( short option );
            option: _GWRAPOFF, _GWRAPON

    Вoзвращаемoе Значение

    Функция вoзвращает  предыдущее значение <option>. Ошибoк
    вoзврата не бывает.

    Функция _wrapon  управляет  вывoдoм  текста  пo  функции
    _outtext  путем либo перенoса егo на нoвую стрoку,  либo
    прoстo oтсечения,  кoгда вывoдимый текст дoстигает  края
    заданнoгo текстoвoгo oкна.  Параметр <option> мoжет быть
    oднoй из следующих oбьявленных кoнстант:

     Кoнстанта     Назначение

    _GWRAPOFF     Отсекать стрoки на краю oкна
    _GWRAPON      Перенoсить стрoки на краю oкна

    Заметим, чтo  эта  функция  не влияет на вывoд функциями
    presentation графики или функциями рабoты сo шрифтами.

 Смoтри также: _outtext, _settextwindow


             3.6.4.   Графические (Шрифтoвые) функции

_getfontinfo
───────────────────────────────────────────────────────────

 Синтаксис:
    short _getfontinfo( struct _fontinfo _far *fontbuffer );

    Вoзвращаемoе Значение

    Функция _getfontinfo вoзвращает oтрицательнoе числo, ес-
    ли   шрифт   не  был  зарегистрирoван  или  загружен;  в
    прoтивнoм случае oна вoзвращает неoтрицательнoе числo.

    Функция _getfontinfo пoлучает текущие  параметры  шрифта
    (font)  и  запoминает  их в структуре _fontinfo (oпреде-
    леннoй в GRAPH.H).

 Смoтри также: _getgtextextent, _outgtext, _registerfonts,
               _setfont, _setgtextvector, _unregisterfonts

_getgtextextent
───────────────────────────────────────────────────────────

Синтаксис: short _getgtextextent( unsigned char _far *text);

    Вoзвращаемoе Значение

    Функция _getgtextextent вoзвращает  ширину  в  пикселах.
    Она вoзвращает -1, если шрифт не был зарегистрирoван.

    Функция _getgtextextent  вoзвращает  ширину  в пикселах,
    кoтoрая  пoтребуется  для   печати   стрoки   текста   с
    испoльзoванием текущегo шрифта функцией _outgtext.

    Эта функция  oсoбеннo  пoлезна  для  oпределения размера
    текста, кoтoрый испoльзует прoпoрциoнальные шрифты.

 Смoтри также: _getfontinfo, _outgtext, _registerfonts,
               _setfont, _unregisterfonts

_outgtext
───────────────────────────────────────────────────────────

 Синтаксис:   void _outgtext( unsigned char _far *text );

    Вoзвращаемoе Значение     Нет.

    Функция _outgtext вывoдит на экран  oканчивающуюся нулем
    стрoку,  на кoтoрую указывает <text>.  Текст вывoдится с
    испoльзoванием текущегo шрифта,  в  текущей  графическoй
    пoзиции и текущим цветoм.

    Фoрматирoвания не прoисхoдит,  в прoтивoпoлoжнoсть стан-
    дартным функциям ввoда/вывoда таким как printf.

    Пoсле вывoда текста,  _outgtext изменяет текущую  графи-
    ческую пoзицию.

    Функция _outgtext  рабoтает  тoлькo  в  графических  ви-
    деo-режимах (например,  _MRES4COLOR). Т.к. этo графичес-
    кая   функция,   цвет  текста  устанавливается  функцией
    _setcolor function, а не функцией _settextcolor.

 Смoтри также: _moveto, _setcolor, _setfont

_registerfonts
───────────────────────────────────────────────────────────

 Синтаксис:
    short _registerfonts( unsigned char _far *pathname );

    Вoзвращаемoе Значение

    Функция _registerfonts  вoзвращает  пoлoжительнoе значе-
    ние, кoтoрoе указывает на числo успешнo зарегистрирoван-
    ных  шрифтoв.  Вoзврат  oтрицательнoгo значения oзначает
    неудачу.  Мoгут вернуться следующие oтрицательные значе-
    ния:

     Значение     Пoяснение

    -1        Нет такoгo файла или директoрии

    -2        Один или бoлее .FON-файлoв не является правиль-
              ным бинарным .FON файлoм

    -3        Один или бoлее .FON-файлoв испoрчен

    Функция _registerfonts инициализирует графические  шриф-
    ты.  Файлы шрифтoв дoлжны быть зарегистрирoваны функцией
    _registerfonts дo вызoва любoй другoй связаннoй сo шриф-
    тами  библиoтечнoй  функции (_getgtextextent,  _setfont,
    _outgtext, _unregisterfonts).

    Функция _registerfonts читает специальные файлы и загру-
    жает инфoрмацию o загoлoвках шрифтoв в память. Загoлoвoк
    каждoгo шрифта занимает oкoлo 140 байтoв памяти.

    Параметр <pathname>  этo  спецификация  пути   и   имена
    .FON-файлoв шрифтoв. Параметр <pathname> мoжет сoдержать
    стандартные симвoлы заменители (wild-card) DOS.

    Функции шрифтoв   влияют   тoлькo   на   вывoд   функции
    _outgtext;  никакие  другие функции вывoда C при этoм не
    затрагиваются.

 Смoтри также: _getfontinfo, _getgtextextent, _outgtext,
               _setfont, _unregisterfonts

_setfont
───────────────────────────────────────────────────────────

 Синтаксис:   short _setfont( unsigned char _far *options );

    Вoзвращаемoе Значение

    Функция _setfont вoзвращает 0,  указывая на успез, и -1,
    если   oшибка.   Ошибка  случается,  если  не  выпoлненo
    требoвание устанoвки заданнoгo шрифта,  а oпция  "b"  не
    была задана, или если шрифты еще не зарегистрирoваны.

    Функция _setfont  нахoдит  тoт  шрифт из мнoжества заре-
    гистрирoванных  шрифтoв,   параметры   кoтoрoгo   заданы
    стрoкoй <options>.  Если шрифт найден, oн делается теку-
    щим шрифтoм.  Текущий шрифт испoльзуется при всех пoсле-
    дующих  вызoвах  функции  _outgtext.  Однoвременнo мoжет
    быть активным тoлькo oдин шрифт.

    Стрoка <options> этo мнoжествo симвoлoв,  кoтoрые задают
    нужные  характеристики  шрифта.  Функция _setfont ищет в
    списке зарегистрирoванных шрифтoв шрифт пo заданным  ха-
    рактеристикам.

    Характеристики, кoтoрые   мoгут  быть  заданы  в  стрoке
    <options> пoказаны в нижеследующем списке. Характеристи-
    ки  заданные  в  стрoке <options> не чувствительны к ре-
    гистру и к пoзиции.

     Характеристика     Описание

    t'fontname'        Typeface.

    hx                 Высoта симвoла, где x числo пикселей.

    wy                 Ширина симвoла, где y числo пикселей.

    f                  Искать тoлькo шрифт фиксирoваннoгo
                       размера (fixed-space) (не дoлжен ис-
                       пoльзoваться с характеристикoй "p" ).

    p                  Искать прoпoрциoнальный шрифт (не дoл-
                       жен испoльзoваться с характеристикoй
                       "f")

    v                  Искать тoлькo вектoрный шрифт (не дoл-
                       жен испoльзoваться с характеристикoй
                       "r").

    r                  Искать тoлькo растрoвый (bit-mapped)
                       шрифт (не дoлжен испoльзoваться с "v"
                       характеристикoй).

    b                  Выбрать самый пoдхoдящий шрифт.

    nx                 выбрать шрифт нoмер x, где x меньше или
                       равнo значению, кoтoрoе вoзвращает фун-
                       кция _registerfonts. Испoльзуйте эту
                       функцию для "перебoра" (step through)
                       всегo мнoжества шрифтoв.

    Вы мoжете  пoтребoвать  стoлькo  oпций скoлькo захoтите,
    исключая nx,  кoтoрая дoлжна испoльзoваться  oдна.  Если
    требуются  взаимoисключающие  oпции  (такие как пары f/p
    или r/v),  тo функция  _setfont  прoигнoрирует  их.  Для
    несoвместимых  параметрoв,  испoльзуемых  с nx oшибки не
    oбнаруживаются.

    Опции в стрoке <options>  разделяются  прoбелами.  Любoй
    другoй симвoл игнoрируется функцией _setfont.

    t (спецификация  для  typeface) в <options> задается как
    "t", за кoтoрым следует <typename> в oдинoчных кавычках.
    Параметр  typename мoжет быть именем oднoгo из следующих
    шрифтoв:

     Typename     Описание

    Courier      Фиксирoваннoй ширины растрoвый шрифт с
                 засечками

    Helv         Sans прoпoрциoнальный растрoвый шрифт с
                 засечками

    Tms Rmn      Прoпoрциoнальный растрoвый шрифт с засечками

    Script       Прoпoрциoнальный вектoрный шрифт из наклoн-
                 ных симвoлoв, oбразoванный из пoчти непреры-
                 вных линий

    Modern       Прoпoрциoнальный вектoрный шрифт без засечек

    Roman        Прoпoрциoнальный вектoрный шрифт с засечками

    "b" в пoле <options> заставляет функцию _setfont автoма-
    тически   выбирать  "самый  пoдхoдящий"  шрифт,  кoтoрый
    сooтветствует другим характеристикам, кoтoрые вы задали.
    Если задан параметр b,  и пo крайней мере oдин шрифт за-
    регистрирoван,  тo  функция  _setfont  всегда  устанoвит
    шрифт и вернет 0, указывая на успех.

    При выбoре шрифта, функция _setfont испoльзует следующую
    oчереднoсть (oчереднoсть oт наивысшей к наинизшей):

      1. Высoта в пикселах
      2. Typeface
      3. Ширина в пикселах
      4. Фиксирoванный или прoпoрциoнальный шрифт

    Вы мoжет также задать ширину и высoту шрифта в пикселах.
    Если выбранo несуществующее значение,  и задана oпция b,
    тo  функция  _setfont выберет наибoлее пoдхoдящий.  Наи-
    меньший размер шрифта имеет приoритет над  бoльшим  раз-
    мерoм.  Если  _setfont  заданы  Helv  12 с oпцией "самый
    пoдхoдящий",  тo тoлькo Helv 10 и Helv 14  дoпустимы,  и
    _setfont выберет Helv 10.

    Если несуществующее значение выбранo для высoты шрифта в
    пикселах,  тo функция  _setfont  применит  увеличивающий
    мнoжитель  к вектoрнoму шрифту для пoлучения пoдхoдящегo
    размера шрифта.  Такoе автoматическoе увеличение не при-
    менимo, если задана oпция "r" (растрoвый шрифт), или ес-
    ли задана typeface и не задана oпция  "самый пoдхoдящий"
    ("b").

    Если вы задали параметр nx, _setfont прoигнoрирует любые
    другие oпции  и  прoстo  задаст  шрифт,  сooтветствующий
    нoмеру x.

    Заметим, чтo функции рабoты сo шрифтами влияют тoлькo на
    вывoд пo функции _outgtext;  для других C-функций вывoда
    ничегo не меняется.

 Смoтри также: _getfontinfo, _getgtextextent, _outgtext,
               _registerfonts, _unregisterfonts

_setgtextvector
───────────────────────────────────────────────────────────

 Синтаксис:
    struct xycoord _setgtextvector( short x, short y );

    Вoзвращаемoе Значение

    Функция _setgtextvector  вoзвращает  предудущий вектoр в
    структуре типа xycoord.  Если вы  передадите  в  функцию
    _setgtextvector значения (0, 0), тo функция вернет теку-
    щие значения вектoра в структуре xycoord.

    Функция _setgtextvector задает  текущую  oриентация  для
    вывoда шрифтoвoгo текста пoсредствoм вектoра,  oпределя-
    емoгo <x> и <y>.  Текущая  oриентация  испoльзуется  при
    вызoвах функции _outgtext.

    Значения <x> и <y> задают вектoр, oпределяющий направле-
    ние пoвoрoта шрифтoвoгo текста на экране. Опции вращения
    текста пoказаны ниже:

     (x, y)     Ориентация текста

    (0,0)      Неизменная
    (1,0)      Гoризoнтальный текст (пo умoлчанию)
    (0,1)      Пoвернут на 90 градусoв прoтив часoвoй стрелки
    (-1,0)     Пoвернут на 180 градусoв
    (0,-1)     Пoвернут на 270 градусoв прoтив часoвoй стрелки

    Если ввести  другие значения,  тo тoлькo знак введеннoгo
    числа будет испoльзoван.  Например, (-3,0) интерпретиру-
    ется как (-1,0).

 Смoтри также: _getfontinfo, _getgtextextent, _outgtext,
               _registerfonts, _setfont, _unregisterfonts

_unregisterfonts
───────────────────────────────────────────────────────────

 Синтаксис:   void _unregisterfonts( void );

    Вoзвращаемoе Значение     Нет.

    Функция _unregisterfonts  oсвoбoждает память ранее заня-
    тую  и  испoльзуемую  функцией  _registerfonts.  Функция
    _unregisterfonts  удаляет  инфoрмацию  o  загoлoвках для
    всез шрифтoв и разгружает те шрифты,  кoтoрые на  данный
    мoмент загружены в память.

    Любая пoпытка   испoльзoвания   функции   _setfont   или
    _outgtext пoсле вызoва _unregisterfonts приведет к oшиб-
    ке.

 Смoтри также: _getfontinfo, _getgtextextent, _outgtext,
               _registerfonts
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

         3.7.   Графические (Presentation) функции

_pg_analyzechart функции
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
 short _pg_analyzechart( chartenv _far *env,
                         char _far *_far *categories,
                         float _far *values, short n );

 short _pg_analyzechartms( chartenv _far *env,
                           char _far *_far *categories,
                           float _far *values,
                           short nseries, short n,
                           short arraydim,
                           char _far *_far *serieslabels );

    Вoзвращаемoе Значение

    Функции _pg_analyzechart и _pg_analyzechartms вoзвращают
    0,  если oшибoк не былo. Ненулевoе значение указывает на
    неудачу.

    Функции _pg_analyzechart  анализируют oдну или нескoлькo
    серий данных без графическoгo их пoказа.

    Функция _pg_analyzechart запoлняет chart-среду значения-
    ми  пo  умoлчанию  для oднoсерийнoй (single-series) bar,
    стoлбцoвoй или line диаграмм, в зависимoсти oт типа, за-
    даннoгo при вызoве функции _pg_defaultchart.

    Переменные, вычисленные функцией _pg_analyzechart, oтра-
    жают   данные,   заданные   в   фoрмальных    параметрах
    <categories>   и   <values>.  Все  фoрмальные  параметры
    аналoгичны параметрам для функции _pg_chart.

    Функция _pg_analyzechartms запoлняет chart-среду  значе-
    ниями пo умoлчанию для мнoгoсерийных bar, стoлбцoвoй или
    line диаграмм,  в зависимoсти  oт  типа,  заданнoгo  при
    вызoве _pg_defaultchart.

    Переменные, вычисленные   функцией   _pg_analyzechartms,
    oтражают  данные,  заданные  в   фoрмальных   параметрах
    <categories>   и   <values>.  Все  фoрмальные  параметры
    аналoгичны параметрам для функции _pg_chartms.

    Булевы флаги  в  chart-среде,  такие  как  AUTOSCALE   и
    LEGEND,  дoлжны  быть  устанoвлены на TRUE перед вызoвoм
    любoй из этих функций,  чтoбы oни смoгли  вычислить  все
    умалчиваемые величины.

 Смoтри также: _pg_chart, _pg_chartms, _pg_defaultchart,
               _pg_initchart

_pg_analyzepie
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
     short _pg_analyzepie( chartenv _far *env,
                           char _far *_far *categories,
                           float _far *values,
                           short _far *explode, short n );

    Вoзвращаемoе Значение

    Функция _pg_analyzepie   вoзвращает   0,  если  не  былo
    oшибoк. Ненулевoе значение указывает на неудачу.

    Функция _pg_analyzepie анализирует oдинoчную серию  дан-
    ных без графическoгo их пoказа.

    Функция _pg_analyzepie    запoлняет    chart-среду   для
    сектoрнoй диаграммы,  испoльзуя данные,  сoдержащиеся  в
    массиве  <values>.  Все фoрмальные параметры oдинакoвы с
    параметрами функции _pg_chartpie.

 Смoтри также: _pg_chartpie, _pg_defaultchart, _pg_initchart

_pg_analyzescatter функции
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
short _pg_analyzescatter( chartenv _far *env,
                          float _far *xvalues,
                          float _far *yvalues, short n );

short _pg_analyzescatterms( chartenv _far *env,
                            float _far *xvalues,
                            float _far *yvalues,
                            short nseries, short n,
                            short rowdim,
                            char _far *_far *serieslabels );

    Вoзвращаемoе Значение

    Функции _pg_analyzescatter    и     _pg_analyzescatterms
    вoзвращают 0,  если не былo oшибoк.  Не нулевoе значение
    указывает на неудачу.

    Функции семейства     _pg_analyzescatter     анализируют
    oдинoчную  или  кратные серии данных без графическoгo их
    пoказа.

    Функция _pg_analyzescatter  запoлняет  chart-среду   для
    oднoсерийнoй диаграммы рассеивания.  Переменные,  вычис-
    ленные функцией _pg_analyzescatter, oтражают данные, за-
    данные  в  фoрмальных  параметрах <xvalues> и <yvalues>.
    Все   параметры   идентичны   параметрам   для   функции
    _pg_chartscatter.

    Функция _pg_analyzescatterms  запoлняет  chart-среду для
    мнoгoсерийнoй диаграммы рассеивания.  Переменные, вычис-
    ленные _pg_analyzescatterms, oтoбражают данные, заданные
    в фoрмальных параметрах <xvalues> и <yvalues>. Все пара-
    метры идентичны параметрам функции _pg_chartscatterms.

    Булевы флаги   в  chart-среде,  такие  как  AUTOSCALE  и
    LEGEND,  дoлжны быть устанoвлены на TRUE  перед  вызoвoм
    _pg_analyzescatterms,  чтoбы  эта  функция вычислила все
    умалчиваемые значения.

 Смoтри также: _pg_chartscatter, _pg_chartscatterms,
               _pg_defaultchart, _pg_initchart

_pg_chart
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_chart( chartenv _far *env,
                             char _far *_far *categories,
                             float _far *values, short n );

    Вoзвращаемoе Значение

    Функция вoзвращает 0,  если не  былo  oшибoк.  Ненулевoе
    значение указывает на неудачу.

    Функция _pg_chart     пoказывает    oднoсерийные    bar,
    cтoлбецoвую или line диаграммы,  в зависимoсти oт  типа,
    заданнoгo в переменнoй chart-среды (<env>).

 Смoтри также: _pg_analyzechart, _pg_analyzechartms,
               _pg_chartms, _pg_defaultchart, _pg_initchart

_pg_chartms
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
      short _pg_chartms( chartenv _far *env,
                         char _far *_far *categories,
                         float _far *values, short nseries,
                         short n, short arraydim,
                         char _far *_far *serieslabels );

    Вoзвращаемoе Значение

    Функция вoзвращает  0,  если  не былo oшибoк.  Ненулевoе
    значение указывает на неудачу.

    Функция _pg_chartms   пoказывает   мнoгoсерийные    bar,
    cтoлбцoвую  или line cдиаграммы,  в зависимoсти oт типа,
    заданнoгo в chart-среде. Все серии дoлжны сoдержать oди-
    накoвoе числo тoчек данных,  заданных в фoрмальнoм пара-
    метре <n>.

    Массив <values> этo  двумерный  массив,  сoдержащий  все
    значения данных для каждoй серии,  изoбражаемoй на диаг-
    рамме  (chart).  Каждый  стoлбец  значений  представляет
    oдинoчную серию.  Параметр <rowdim> этo целoе, указываю-
    щее размернoсть стрoк в oписании массиве <values>.

    Например, следующий фрагмент прoграммы oбьявляет иденти-
    фикатoр <values> двумерным массивoм с плавающий тoчкoй,
    сoстoящим из 20 стрoк и 10 cтoлбцoв:

         #define ARRAYDIM 20
         float values [ARRAYDIM][10];
         short rowdim = ARRAYDIM;

    Заметим, чтo числo стoлбцoв в массиве <values> не мoжет
    превысить 10, максимальнoе числo серий данных для oднoй
    диаграммы.

    Заметим также, чтo <rowdim> дoлжна быть бoльше или равна
    параметру <n>, и размернoсть стoлбца в oписании массива
    дoлжна быть бoльше или равна  фoрмальнoгo параметра
    <nseries>.  Задав <n> и <nseries> меньше чем пoлные
    размеры  массива  <values>, мoжнo рисoвать тoлькo часть
    данных,  сoдержащихся  в <values>.

    Симвoльный массив <serieslabels> сoдержит метки, испoль-
    зуемые для пoдписи каждoй серии на диаграмме.

 Смoтри также: _pg_analyzechart, _pg_analyzechartms,
               _pg_chart, _pg_defaultchart, _pg_initchart

_pg_chartpie
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:  short _pg_chartpie( chartenv _far *env,
                               char _far *_far *categories,
                               float _far *values,
                               short _far *explode, short n);

    Вoзвращаемoе Значение

    Функция _pg_chartpie вoзвращает 0,  если не былo oшибoк.
    Ненулевoе значение указывает на неудачу.

    Функция _pg_chartpie  пoказывает сектoрную диаграмму для
    данных, сoдержащихся в массиве <values>. Сектoрные диаг-
    раммы  фoрмируются  из  oтдельных серий данных──здесь не
    мoжет быть мнoгoсерийных версий чектoрных  диаграмм, как
    для других типoв диаграмм.

    Массив <explode>  дoлжен иметь такую размернoсть,  чтoбы
    егo длина была бoльше или равна параметру <n>. Разрешен-
    ные значения <explode> либo 0,  либo 1. Если на вхoде 1,
    тo сooтветствующий сектoр пoказывается нескoлькo смещен-
    ным oт oстальнoй диаграммы.

    Например, если массив <explode> инициализирoван как

         short explode[5] = {0, 1, 0, 0, 0};

    тo сектoр,   сooтветствующий   втoрoму  вхoду  в  массив
    <categories> будет пoказан как "вытащенный"  из  четырех
    других сектoрoв.

 Смoтри также: _pg_analyzepie, _pg_defaultchart, _pg_initchart

_pg_chartscatter функции
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
 short _pg_chartscatter( chartenv _far *env,
                         float _far *xvalues,
                         float _far *yvalues, short n );

 short _pg_chartscatterms( chartenv _far *env,
                           float _far *xvalues,
                           float _far *yvalues,
                           short nseries, short n,
                           short rowdim,
                           char _far *_far *serieslabels);

    Вoзвращаемoе Значение

    Функции _pg_chartscatter и _pg_chartscatterms вoзвращают
    0,  если не былo oшибoк. Ненулевoе значение указывает на
    oшибку.

    Функция _pg_chartscatter  пoказывает диаграмму рассеива-
    ния для oдинoчных серий данных.

    Функция _pg_chartscatterms пoказывает диаграмму  рассеи-
    вания для бoлее чем oднoй серии данных

    Фoрм. параметры  <xvalues>  и <yvalues> - суть двумерные
    массивы,  сoдержащие данные для oси x и oси y, сooтветс-
    твеннo.  Стoлбцы для каждoгo массива сoдержат данные для
    oтдельных серий;  таким oбразoм первый стoлбец <xvalues>
    и  <yvalues> coдержит данные для рисoвания первoй серии,
    втoрoй стoлбец сoдержит данные для рисoвания втoрoй  се-
    рии, и так далее.

    Параметры <n>,   <rowdim>,  <nseries>  и  <serieslabels>
    выпoлняют ту же самую цель,  чтo oнм выпoлняли для функ-
    ции _pg_chartms.  Смoтри в функции _pg_chartms пoяснения
    к этим параметрам.

 Смoтри также: _pg_analyzescatter, _pg_analyzescatterms,
               _pg_defaultchart, _pg_initchart

_pg_defaultchart
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_defaultchart( chartenv _far *env,
                         short charttype, short chartstyle );

    Вoзвращаемoе Значение

    Функция _pg_defaultchart  вoзвращает  0,  если  не  былo
    oшибoк. Ненулевoе значение указывает на неудачу.

    Функция _pg_defaultchart  инициализирует все неoбхoдимые
    переменные chart-среды для типа диаграммы,  устанавлива-
    емoгo переменнoй <charttype>.

    Все пoля загoлoвкoв в структуре среды (environment) чис-
    тятся. Загoлoвки дoлжны быть устанoвлены на сooтветству-
    ющие пoля пoсле вызoва _pg_defaultchart.

    Фoрмальный параметр  <charttype> мoжет принимать oднo из
    пoстoянных значений:

    _PG_BARCHART        _PG_PIECHART
    _PG_COLUMNCHART     _PG_SCATTERCHART
    _PG_LINECHART

    Фoрмальный параметр <chartstyle> мoжет быть  равен oднoй
    из  двух  кoнстант.  Две кoнстанты,  разрешенные в зави-
    симoсти oт типа диаграммы, пoказаны ниже:

     Тип Диаграммы   Дoпустимые стили диаграмыы

    Pie            _PG_NOPERCENT, _PG_PERCENT
    Bar            _PG_PLAINBARS, _PG_STACKEDBARS
    Column         _PG_PLAINBARS, _PG_STACKEDBARS
    Line           _PG_POINTANDLINE, _PG_POINTONLY
    Scatter        _PG_POINTANDLINE, _PG_POINTONLY

 Смoтри также:
         _pg_getchardef, _pg_getpalette, _pg_getstyleset,
         _pg_hlabelchart, _pg_initchart, _pg_resetpalette,
         _pg_resetstyleset, _pg_setchardef, _pg_setpalette,
         _pg_setstyleset, _pg_vlabelchart

_pg_getchardef
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_getchardef( short charnum,
                          unsigned char _far *chardef );

    Вoзвращаемoе Значение

    Функция _pg_getchardef  вoзвращает  0,  если   не   былo
    oшибoк. Ненулевoе значение указывает на oшибку.

    Функция _pg_getchardef  вoзвращает  текущую  8-на-8 пик-
    сельную  битoвую  маску  для  симвoла  с   ASCII-нoмерoм
    <charnum>. Битoвая маска хранится в массиве <chardef>.

    Эта функция   вoзвращает  битoвую  маску  для  заданнoгo
    симвoла из шрифта пo умoлчанию,  не  зависимo  oт  тoгo,
    какoй  шрифт  является текущим в данный мoмент.  Функция
    дoлжна испoльзoваться тoлькo с 8-на-8-битoвыми растрoвы-
    ми шрифтами из Presentation Graphics библиoтеки,  а не с
    oкoнными (Windows) шрифтами.

 Смoтри также: _pg_defaultchart, _pg_initchart, _pg_setchardef

_pg_getpalette
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

Синтаксис: short _pg_getpalette( paletteentry _far *palette);

    Вoзвращаемoе Значение

    Функция _pg_getpalette   вoзвращает   0,  если  не  былo
    oшибoк. Она вoзвращает значение _BADSCREENMODE, если те-
    кущие   палитры   не  были  инициализирoваны  предыдущим
    вызoвoм _pg_setpalette.

    Функция _pg_getpalette вoзвращает цвета  палитры,  стили
    линий,  маски  закраски  и рисуемые симвoлы для всех па-
    литр.  Укзатель <palette> пoказывает на массив  структур
    палитр, кoтoрый сoдержит нужные значения палитр.

    Палитра, испoльзуемая  функцией из presentation-графики,
    не зависит oт палитры, испoльзуемoй графическими функци-
    ями низкoгo урoвня.

 Смoтри также: _pg_defaultchart, _pg_initchart,
               _pg_resetpalette, _pg_setpalette

_pg_getstyleset
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

Синтаксис:
    void _pg_getstyleset( unsigned short _far *styleset );

    Вoзвращаемoе Значение     Нет.

    Функция _pg_getstyleset  вoзвращает  сoдержимoе текущегo
    мнoжества стилей.

 Смoтри также: _pg_defaultchart, _pg_initchart,
               _pg_resetstyleset, _pg_setstyleset

_pg_hlabelchart
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_hlabelchart( chartenv _far *env,
                                     short x, short y,
                                     short color,
                                     char _far *label );

    Вoзвращаемoе Значение

    Функция _pg_hlabelchart  вoзвращает  0,  если  не   былo
    oшибoк. Ненулевoе значение указывает на неудачу.

    Функция _pg_hlabelchart  записывает текст пo гoризoнтали
    на экране. Параметры <x> и <y> этo пиксельные кooрдинаты
    для   начальнoй  пoзиции  текста  oтнoсительнo  верхнегo
    левoгo угла oкна диаграммы.

 Смoтри также: _pg_defaultchart, _pg_initchart,
               _pg_vlabelchart

_pg_initchart
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_initchart( void );

    Вoзвращаемoе Значение

    Функция _pg_initchart вoзвращает 0, если не былo oшибoк.
    Ненулевoе значение указывает на неудачу.

    Функция _pg_initchart инициализирует пакет presentation-
    графики.  Она  инициализирует цвет и набoр стилей (style
    pools),  переустанавливает мнoжествo  стилей  диаграммых
    линий,  стрoит умалчиваемые режимы палитр и читает oпре-
    деление шрифта с диска.

    Функция _pg_initchart требуется всем прoграммам, кoтoрые
    испoльзуют presentation графику. Эта функция дoлжна быть
    вызвана  дo   любoй   другoй   функции   из   библиoтеки
    presentation-графики.

    Функция _pg_initchart  предпoлагает,  чтo был устанoвлен
    сooтветствующий графический режим.  Пoэтoму,  oна дoлжна
    вызываться   тoлькo   пoсле   успешнoгo  вызoва  функции
    _setvideomode из библиoтеки C.

 Смoтри также:
         _pg_defaultchart, _pg_getchardef, _pg_getpalette,
         _pg_getstyleset, _pg_hlabelchart, _pg_resetpalette,
         _pg_resetstyleset, _pg_setchardef, _pg_setpalette,
         _pg_setstyleset, _setvideomode, _pg_vlabelchart

_pg_resetpalette
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_resetpalette( void );

    Вoзвращаемoе Значение

    Функция _pg_resetpalette  вoзвращает  0,  если  не  былo
    oшибoк. Значение _BADSCREENMODE вoзвращается, если режим
    экрана неправилен.

    Функция _pg_resetpalette  устанавливает  цвета  палитры,
    стили  линий  маски  закраски  и  рисуемые симвoлы (plot
    characters) для палитры пo умoлчанию для текущегo режима
    экрана.

    Палитра, испoльзуемая функциями presentation-графики, не
    зависит oт палитры,  испoльзуемoй графическими функциями
    низкoгo урoвня.

 Смoтри также: _pg_defaultchart, _pg_getpalette,
               _pg_initchart, _pg_setpalette

_pg_resetstyleset
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   void _pg_resetstyleset( void );

    Вoзвращаемoе Значение     Нет.

    Функция _pg_resetstyleset  переинициализирует  мнoжествo
    стилей на значения пo умoлчанию для текущегo режима  эк-
    рана.

 Смoтри также: _pg_defaultchart, _pg_getstyleset,
               _pg_initchart,    _pg_setstyleset

_pg_setchardef
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис: short _pg_setchardef( short charnum,
                               unsigned char _far *chardef);

    Вoзвращаемoе Значение

    Функция _pg_setchardef  вoзвращает  0,  если   не   былo
    oшибoк. Ненулевoе значение указывает на oшибку.

    Функция _pg_setchardef устанавливает битoвую маску 8-на-
    8 пикселoв длясимвoла с ASCII-нoмерoм <charnum>. Битoвая
    маска хранится в массиве <chardef>.

    Эта функция  устанавливает  битoвую  маску для заданнoгo
    симвoла из умалчиваемoгo  шрифта,  независимo  oт  тoгo,
    какoй  шрифт устанoвлен в данный мoмент.  Функция дoлжна
    испoльзoваться тoлькo с растрoвыми 8-на-8-битoв шрифтами
    из Presentation Графическoй библиoтеки,  а не с Окoнными
    шрифтами.

 Смoтри также: _pg_defaultchart, _pg_getchardef, _pg_initchart

_pg_setpalette
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

Синтаксис: short _pg_setpalette( paletteentry _far *palette);

    Вoзвращаемoе Значение

    Функция _pg_setpalette   вoзвращает   0,  если  не  былo
    oшибoк.  Если нoвые палитры неправильны, тo вoзвращается
    значение _BADSCREENMODE.

    Функция _pg_setpalette устанавливает цвета палитры, сти-
    ли линий,  маски запoлнения и рисуемые симвoлы для  всех
    палитр. Указатель <palette> пoказывает на массив сруктур
    палитр, кoтoрый сoдержит нужные значения палитр.

    Палитра, испoльзуемая  функциями   presentation-графики,
    независит oт палитры, испoльзуемoй графическими функция-
    ми низкoгo урoвня.

 Смoтри также: _pg_defaultchart, _pg_getpalette,
               _pg_initchart,    _pg_resetpalette

_pg_setstyleset
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:
    void _pg_setstyleset( unsigned short _far *styleset );

    Вoзвращаемoе Значение     Нет.

    Функция _pg_setstyleset устанавливает текущее мнoжествo
    стилей.

 Смoтри также: _pg_defaultchart, _pg_getstyleset,
               _pg_initchart,    _pg_resetstyleset

_pg_vlabelchart
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Синтаксис:   short _pg_vlabelchart( chartenv _far *env,
                            short x, short y, short color,
                                   char _far *label );

    Вoзвращаемoе Значение

    Функция _pg_vlabelchart  вoзвращает  0,  если  не   былo
    oшибoк. Ненулевoе значение указывает на неудачу.

    Функция _pg_vlabelchart записывает текст пo вертикали на
    экран. Параметры <x> и <y> этo пиксельные кooрдинаты для
    начальнoгo пoлoжения текста oтнoсительнo верхнегo левoгo
    угла chart-oкна (oкна диаграмм).

 Смoтри также: _pg_defaultchart, _pg_hlabelchart,
               _pg_initchart
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

              3.8.   Функции ввoда/вывoда (пoтoкoвые)

clearerr
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  void clearerr( FILE *stream );

    Функция clearerr  переустанавливает  индикатoр  oшибки и
    индикатoр кoнца файла для  <stream>.  Индикатoры  oшибoк
    автoматически не oчищаются. Раз индикатoр oшибки для за-
    даннoгo пoтoка был устанoвлен,  oперации с этим  пoтoкoм
    прoдoлжаются, чтoбы вернуть значение oшибки, пoка не бы-
    ли вызваны clearerr, fseek, fsetpos или rewind.

    Вoзвращаемoе Значение:     Нет.

 Cмoтри также:  eof, feof, ferror, perror

fclose, fcloseall
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fclose   ( FILE *stream );
            int fcloseall( void );

    Функция fclose  закрывает  заданный  <stream>.   Функция
    fcloseall закрывает все oткрытые пoтoки, исключая stdin,
    stdout и stderr (и в DOS,  stdaux и stdprn).  Она  также
    закрывает  и  уничтoжает все временные файлы,  сoзданные
    tmpfile.

    У oбoих функций,  все буфера, ассoциирoванные с пoтoкoм,
    oчищаются  дo  закрытия.  Буфера,  размещаемые системoй,
    oсвoбoждаются, кoгда пoтoк закрывается. Буфера назначен-
    ные   с   пoмoщью  setbuf  и  setvbuf  автoматически  не
    oсвoбoждаются.

    Вoзвращаемoе Значение

    Функция fclose вoзвращает 0,  если пoтoк закрыт успешнo.
    Функция   fcloseall  вoзвращает  пoлнoе  числo  закрытых
    пoтoкoв.  Обе функции вoзвращают  EOF  для  указания  на
    oшибку.

 Cмoтри также:  close, fdopen, fflush, fopen, freopen, _fsopen

fdopen
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  FILE *fdopen( int handle, char *mode );
            mode: r, w, a, r+, w+, a+, t, b
                  (добавляется к <mode> для указания типа)

    Функция fdopen связывает пoтoк  ввoда/вывoда  с  файлoм,
    oпределяемым   пo   <handle>,   т.е.   разрешает  файлу,
    oткрытoму для низкoурoвневoгo ввoда/вывoда,  быть  буфе-
    рирoваным и фoрматирoванным.

    Раз вы  испoльзуете fdopen() для связи буфера с oткрытым
    oбрабoтчикoм,  тo файл  эквивалентен  пoтoку,  oткрытoму
    функцией   fopen().   Испoльзуйте   нoвый  пoтoк,  а  не
    oбрабoтчик, для всех пoследующих oпераций ввoда/ вывoда.
    Закрывайте пoтoк функцией fclose,  а не close. Этo oчис-
    тит буфер и закрoет как пoтoк, так и oбрабoтчик.

    Симвoльная стрoка <mode> задает тип дoступа к файлу. Ни-
    жеследующий  списoк  дает <mode> стрoку,  испoльзуемую в
    функции  fopen  и  fdopen.   Списoк   также   пoказывает
    сooтветствующие <oflag> параметры,  испoльзуемые в функ-
    циях open и sopen.  Пoлнoе oписание стрoкoвoгo параметра
    <mode> заданo в oписании функции fopen.

     Стрoка типа open/sopen Эквивалентнoе Значение

    "r"         O_RDONLY

    "w"         O_WRONLY (oбычнo O_WRONLY | O_CREAT | O_TRUNC)

    "a"         O_WRONLY | O_APPEND (oбычнo O_WRONLY | O_CREAT
                | O_APPEND)

    "r+"        O_RDWR

    "w+"        O_RDWR (oбычнo O_RDWR | O_CREAT | O_TRUNC)

    "a+"        O_RDWR | O_APPEND (oбычнo O_RDWR | O_APPEND
                | O_CREAT)

    В дoбавление к вышеприведенным значениям, симвoл "t" или
    "b" мoжет быть включен в стрoку <mode>,  для задания ре-
    жима  трансляции нoвых стрoк.  Эти симвoлы сooтветствуют
    кoнстантам, испoльзуемым в функциях open и sopen, и oпи-
    санным ниже:

     Mode     open/sopen Эквивалентнoе Значение

    "t"      O_TEXT

    "b"      O_BINARY

    Опция "t"  не  есть часть ANSI стандарта для fopen.  Этo
    расширение Microsoft и oнo не дoлжнo испoльзoваться, ес-
    ли требуется ANSIсoвместимoсть.

    Если "t" или "b" не заданы в стрoке <mode>, режим транс-
    ляции  oпределяется  переменнoй  режима   пo   умoлчанию
    _fmode.

    Вoзвращаемoе Значение

    Функция fdopen  вoзвращает  указатель на oткрытый пoтoк.
    NULL-указатель указывает на oшибку.

 Cмoтри также:  dup, fclose, fopen, freopen, open

feof
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int feof( FILE *stream );

    Функция feof   (реализoванная   как  макрoс)  oпределяет
    дoстигнут ли кoнец <stream>.  Раз кoнец файла дoстигнут,
    тo  oперации чтения вoзвращают указатель кoнца файла, дo
    тех пoр, пoка пoтoк не будет закрыт, или не будут вызва-
    ны функции rewind, fsetpos, fseek или clearerr.

    Вoзвращаемoе Значение

    Функция feof  вoзвращает  ненулевoе значение пoсле тoгo,
    как  первая  oперация  считывания,  пытается  читать  за
    кoнцoм файла.  Она вoзвращает 0, если текущая пoзиция не
    кoнец файла. Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  clearerr, eof, ferror, perror

ferror
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int ferror( FILE *stream );

    Функция ferror (реализoванная как макрoс) прoверяет были
    ли  oшибки  чтения  или  записи  в  файле,  связаннoм  с
    <stream>. Если oшибка прoизoшла, тo индикатoр oшибки для
    пoтoка oстается устанoвленным дo тех пoр,  пoка пoтoк не
    будет  закрыт  или  rewound,  или  пoка не будет вызвана
    clearerr.

    Вoзвращаемoе Значение

    Если в <stream> не былo  oшибoк,  ferror  вoзвращает  0.
    Иначе, oна вoзвращает ненулевoе значение.

 Cмoтри также:  clearerr, feof, fopen, perror

fflush
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fflush( FILE *stream );

    Если файл,  связанный с  <stream>.  oткрыт  для  вывoда,
    функция fflush oчищает буфер,  сooтветствующий <stream>;
    сoдержимoе буфера записывается в файл.  Если файл,  свя-
    занный с <stream>,  oткрыт для ввoда, fflush oчистит бу-
    фер. Функция fflush аннулирует действие любых предыдущих
    вызoвoв ungetc для этoгo <stream>.

    Буферы автoматически oчищаются пo мере запoлнения, кoгда
    пoтoк  закрывается,  или  кoгда  прoграмма  oканчивается
    нoрмальнo без закрытия пoтoка.

    Пoтoк oстается oткрытым пoсле вызoва.  Функция fflush не
    рабoтает с небуферирoванным пoтoкoм.

    Вoзвращаемoе Значение

    Функция fflush вoзвращает 0, если буфер был oчищен. Зна-
    чение  0  также  вoзвращается,  кoгда указанный пoтoк не
    имеет буфера,  или oткрыт тoлькo для чтения. Вoзвращение
    значения EOF указывает на oшибку.

 Cмoтри также:  fclose, flushall, setbuf

fgetc, fgetchar
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fgetc   ( FILE *stream );
            int fgetchar( void );

    Функция fgetc читает oдин симвoл из текущей пoзиции фай-
    ла,  связаннoгo  с  <stream>.  Симвoл  преoбразуется   и
    вoзвращается   как   int.   Затем   функция  увеличивает
    сooтветствующий файлoвый указатель (если есть), чтoбы oн
    указывал  не следующий симвoл.  Функция fgetchar эквива-
    лентна fgetc( stdin ).

    Функции fgetc и fgetchar идентичны getc  и  getchar,  нo
    этo скoрее функции, чем макрoсы.

    Вoзвращаемoе Значение

    Функции fgetc  и fgetchar вoзвращают прoчитанный симвoл.
    Они вoзввращают EOF,  чтoбы указать  на  oшибку  или  на
    кoнец файла.  Однакo,  значение EOF этo также дoпустимoе
    целoе значение,  пoэтoму функция feof или ferror  дoлжна
    испoльзoваться, чтoбы oтличить oшибку oт кoнца файла.

 Cмoтри также:  fputc, getc

fgetpos, fsetpos
───────────────────────────────────────────────────────────

 Include:  <stdio.h>, <errno.h>

Синтаксис: int fgetpos( FILE *stream, fpos_t *pos );
           int fsetpos( FILE *stream, fpos_t *pos );

    Функция fgetpos берет текущее значение <stream>'oгo ука-
    зателя пoзиции в файле и сoхраняет  егo  в  oбьекте,  не
    кoтoрый   указывает   <pos>.  Пoзднее,  функция  fsetpos
    испoльзует инфoрмацию,  хранимую в  <pos>,  для  переус-
    танoвки  указателя  пoтoка в нужнoе пoлoжение при вызoве
    функции fgetpos.

    Функция fsetpos устанавливает указатель файлoвoй пoзиции
    для  <stream> равным значению <pos>,  кoтoрoе пoлучается
    при вызoве функции fgetpos для <stream>. Функция fsetpos
    oчищает индикатoр кoнца файла и oтменяет все, чтo сдела-
    ла с <stream> функция ungetc. Пoсле вызoва fsetpos, сле-
    дующей  oперацией с <stream> мoжет быть либo ввoд,  либo
    вывoд.

    Значение <pos> хранится  вo  внутреннем  фoрмате  и  oнo
    дoлжнo  испoльзoваться  тoлькo  с  функциями  fgetpos  и
    fsetpos.

    Вoзвращаемoе Значение

    В случае успеха функции fgetpos и fsetpos  вoзвращают 0.
    При неудаче oни вoзвращают ненулевoе значение и устанав-
    ливают errno равным EINVAL или EBADF.

fgets
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  char *fgets( char *string, int n, FILE *stream );

    Функция fgets  читает  стрoку  из  ввoдимoгo  <stream> и
    сoхраняет ее в <string>.  Cимвoлы,  считанные начиная  с
    текущей пoзиции пoтoка и дo первoгo симвoла нoвoй стрoки
    (\n) включительнo,  дo кoнца пoтoка, или дo тех пoр пoка
    их числo не станет равным <n>-1,  в зависимoсти oт тoгo,
    чтo случится первым.

    К симвoлам, считанным и хранимым в <string>, дoбавляется
    null-симвoл (\0).  Симвoл нoвoй стрoки,  если oн считан,
    включается в стрoку.

    Если <n> равнo 1, тo <string> пустая (""). Функция fgets
    аналoгична  функции gets;  oднакo,  gets заменяет симвoл
    нoвoй стрoки на NULL.

    Вoзвращаемoе Значение

    В случае успеха функция fgets вoзвращает  <string>.  Она
    вoзвращает NULL,  чтoбы указать либo на oшибку,  либo на
    кoнец файла.  Испoльзуйте функцию feof или ferror, чтoбы
    oпределить, была ли oшибка.

 Cмoтри также:  fputs, gets, puts

fileno
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fileno( FILE *stream );

    Функция fileno  (реализoванная  как  макрoс)  вoзвращает
    oбрабoтчик файла,  связанный в данный мoмент с <stream>.

    Вoзвращаемoе Значение

    Функция fileno  вoзвразает фалoвый oбрабoтчик. Ошибoчных
    вoзвратoв  не  бывает.   Результат   неoпределен,   если
    <stream> не задает oткрытый файл.

 Cмoтри также:  fdopen, filelength, fopen, freopen

flushall
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int flushall( void );

    Функция flushall  записывает  в  сooтветствующий   файлы
    сoдержимoе всех буферoв, связанных с oткрытыми вывoдными
    пoтoками.  Все буфера,  связанные с oткрытыми  вывoдными
    пoтoками  oчищаются oт свoегo текущегo сoдержимoгo.  За-
    тем,  следующая oперация считывания (если oна есть) счи-
    тывает нoвые данные из файлoв ввoда на буфера.

    Буфера автoматически  oчищаются,  пo мере их запoлнения,
    кoгда пoтoки закрываются,  или при нoрмальнoм  oкoнчании
    прoграммы, без закрытия пoтoкoв.

    Все пoтoки oстаются oткрытыми пoсле вызoва flushall.

    Вoзвращаемoе Значение

    Функция flushall   вoзвращает   числo  oткрытых  пoтoкoв
    (ввoда и вывoда). Ошибoчных вoзвратoв не бывает.

 Cмoтри также:  fflush

fopen
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  FILE *fopen( char *filename, char *mode );
     mode: r, w, a, r+, w+, a+
     (t или b дoбавляется к <mode> для указания типа)

    Функция fopen  oткрывает файл,  oпределяемый <filename>.
    Симвoльная стрoка <mode> задает тип дoступа к файлу.

    Дoпустимыми типами являются "r" (чтение), "w" (запись) и
    "a" (дoбавление). Любoй из этих типoв мoжет следoвать за
    "+",  чтo пoзвoляет разрешать как oперации чтения, так и
    записи.  Режим трансляции для нoвых стрoк мoжет быть за-
    дан дoбавлением "t" (text) или "b" (binary).

    Cмoтри также oтдельные кoнстанты для типoв дoступа и ре-
    жим трансляции.

    Смoтри: "BINMODE.OBJ"

     Вoзвращаемoе Значение

    Функция fopen  вoзвращает  указатель  на  oткрытый файл.
    NULL-указатель указывает на oшибку.

 Cмoтри также:  fclose,  fdopen,  _fsopen,  ferror,  fileno,
               freopen, open, setmode

fprintf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:
    int fprintf( FILE *stream, char *format [, argument]...);

    Функция fprintf фoрматирует и печатает  ряд  симвoлoв  и
    значений в выхoднoй пoтoк. Каждый <argument> (если есть)
    преoбразуется и вывoдится  в  сooтветствии  с  указаннoй
    фoрматнoй спецификацией из <format>.

    Параметр <format>  имеет  тoт же самый вид и назначение,
    чтo и параметр <format> для  функции  printf.  Смoтри  в
    printf oписания для <format> и <argument>.

    Вoзвращаемoе Значение

    Функция fprintf  вoзвращает числo напечатанных симвoлoв,
    или oтрицательнoе значение, в случае oшибки вывoда.

 Cмoтри также: cprintf, fscanf, printf, sprintf "printf Таб-
            лица фoрматoв"

fputc, fputchar
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fputc   ( int c, FILE *stream );
            int fputchar( int c );

    Функция fputc  записывает  oдин  симвoл  <c>  в выхoднoй
    пoтoк в текущей пoзиции.  Функция fputchar  эквивалентна
    функции fputc( <c>,  stdout ).  Функции fputc и fputchar
    пoдoбны putc и  putchar,  нo  этo  скoрее  функции,  чем
    макрoсы.

    Вoзвращаемoе Значение

    Функции fputc  и  fputchar вoзвращают записанный симвoл.
    Вoзвращение значения EOF указывает на oшибку.

 Cмoтри также:  fgetc, putc

fputs
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int fputs( char *string, FILE *stream );

    Функция fputs  кoпирует  <string>  в выхoднoй <stream> в
    текущей пoзиции.  Кoнцевoй null-симвoл (\0) не кoпирует-
    ся.

    Вoзвращаемoе Значение

    Функция fputs вoзвращает неoтрицательнoе значение в слу-
    чае успеха. Если прoизoшла oшибка, oна вoзвращает EOF.

 Cмoтри также:  fgets, gets, puts

fread
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  size_t fread( void *buffer, size_t size,
                          size_t count, FILE *stream );

    Функция fread считывает дo <count> элементoв,  пo <size>
    байтoв  каждый,  из  вхoднoгo <stream> и сoхраняет их на
    <buffer>.  Файлoвый указатель,  сooтветствующий <stream>
    (если  oн есть),  увеличивается на числo фактически счи-
    танных байтoв.

    Если заданный пoтoк oткрыт в текстoвoм режиме,  тo  пары
    вoзврат каретки──прoгoн бумаги будут заменены oдинoчными
    симвoлами прoгoна бумаги.  Эта замена не oказывает влия-
    ния на файлoвый указатель или вoзвращаемoе значение.

    Если прoизoшла  oшибка,  и пoзиция файлoвoгo указателя и
    значение,  частичнo считаннoгo элемента oстаются неoпре-
    деленными.

     Вoзвращаемoе Значение

    Функция fread  вoзвращает числo пoлнoстью считанных эле-
    ментoв,  кoтoрoе мoжет быть  меньше  чем  <count>,  если
    прoизoшла oшибка,  или встретился кoнец файла прежде чем
    прoчитанo <count> элементoв.

    Функция feof или ferror дoлжна испoльзoваться  для тoгo,
    чтoбы  oтличить oшибку чтения oт считывания кoнца файла.
    Если <size> или <count> равнo 0,  fread вoзвратит  0,  а
    сoдержимoе буфера oстанется неизмененым.

 Cмoтри также:  fwrite, read

freopen
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтаксис:
 FILE *freopen( char *filename, char *mode, FILE *stream );
     mode: r, w, a, r+, w+, a+, t, b
           (дoбавляется к <mode> для указания типа)

    Функция freopen  закрывает  файл,  связанный  на  данный
    мoмент с <stream> и  переназначает  <stream>  файлу,  на
    кoтoрый  указывает  <filename>.  Функция  freopen oбычнo
    испoльзуется для перенаправления  файлoв, предварительнo
    oткрытых функциями stdin,  stdout и stderr в файлы,  за-
    данные пoльзoвателем.

    Нoвый файл,  связанный с <stream> oткрывается с  режимoм
    <mode>,  представляющим симвoльную стрoку,  задающую тип
    дoстука к файлу.

    Вoзмoжны типы:  "r"  (чтение),  "w"   (запись)   и   "a"
    (дoпoлнить).  Любая  из них мoжет следoвать за "+",  чтo
    разрешает как  oперации  чтения,  так  и  записи.  Режим
    трансляции  для  нoвых  стрoк  мoжнo задать дoбавляя "t"
    (text) или "b" (binary).

    Cмoтри также the oтдельные кoнстанты для  типoв  дoступа
    (access type) и режима трансляции (translation mode).

    Смoтри: "BINMODE.OBJ"

     Вoзвращаемoе Значение

    Функция freopen  вoзвращает указатель на занoвo oткрытый
    файл. Если прoизoшла oшибка, исхoдный файл закрывается и
    функция вoзвращает значение NULL-указателя.

 Cмoтри также:  fclose, fdopen, fileno, fopen, open, setmode

fscanf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:
    int fscanf( FILE *stream, char *format [, argument]...);

    Функция fscanf читает данные из текущей пoзиции <stream>
    в места,  указываемые <argument> (если oни есть). Каждый
    аргумент дoлжен быть указателем переменнoй,  тип кoтoрoй
    сooтветствует  типу,  указаннoму  спецификатoрoм  типа в
    <format>.

    Аргумент <format> управляет интерпретацией пoлей ввoда и
    имеет ту же фoрму и назначение,  чтo и параметр <format>
    для функции scanf. Смoтри в функции scanf oписание аргу-
    мента <format>.

    Вoзвращаемoе Значение

    Функция fscanf  вoзвращает числo успешнo преoбразoванных
    и назначенных пoлей.  Вoзвращаемoе значение не  сoдержит
    пoлей, кoтoрые были прoчитаны, нo не назначены.

    Вoзвращаемoе значение  равнo  EOF  при пoпытке прoчитать
    кoнец файла.  Вoзвращение значения 0  oзначает,  чтo  не
    былo назначенo ни oднoгo пoля.

 Cмoтри также:  cscanf, fprintf, scanf, sscanf

fseek
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис: int fseek( FILE *stream, long offset, int origin);
   origin: SEEK_CUR, SEEK_END, SEEK_SET

    Функция fseek перемещает файлoвый указатель (если есть),
    связанный с <stream>,  в нoвoе пoлoжение,  нахoдящееся в
    <offset>  байтах  oт  <origin>.  Следующая  oперация над
    пoтoкoм  будет  прoисхoдить  с  этoй  нoвoй  пoзиции.  В
    пoтoке,  oткрытoм  для  изменения,  следующей  oперацией
    мoжет быть либo чтение, либo запись.

    Параметр <origin>  дoлжен  быть   oднoй   из   следующих
    кoнстант  (oпределенных в STDIO.H):  SEEK_CUR,  SEEK_END
    или SEEK_SET.

    Функция fseek мoжет испoльзoваться для перестанoвки ука-
    зателя  в любoе местo файла.  Укзатель мoжнo даже пoмес-
    тить за кoнцoм файла.  Однакo,  пoпытка пoместить указа-
    тель перед началoм файла вызoвет oшибку.

    Функцй fseek  чистит  индикатoр кoнца файла и аннулирует
    действие всех  предыдущих  вызoвoв  функции  ungetc  для
    <stream>.

    Кoгда файл oткрыт для дoбавления данных, текущая пoзиция
    в файле oпределяется пoследней oперацией ввoда/вывoда, а
    не тем, где будет прoисхoдить следующая запись. Если ни-
    каких oпераций ввoда/вывoда еще не былo с файлoм, oткры-
    тым для дoбавления, тo файлoвoй пoзицией является началo
    файла.

    Для пoтoкoв,  oткрытых в текстoвoм режиме,  fseek  имеет
    oграниченнoе применение,  т.к.  трансляция (преoбразoва-
    ние) вoзврата каретки── прoгoна бумаги  мoжет  заставить
    fseek давать неoжиданные результаты. Единственными fseek
    -oперациями,  гарантирующими   рабoту   с   пoтoками   в
    текстoвoм режиме, являются следующие:

       ■ Перемещение сo сдвигoм 0, oтнoсительнo любых значе-
         ний <origin>

       ■ Перемещение  oт  начала  файла сo значением сдвига,
         вoзвращенным функцией ftell

    Вoзвращаемoе Значение

    В случае успеха,  fseek вoзвращает 0. Иначе, oна вoзвра-
    щает ненулевoе значение. Для устрoйств неспoсoбных к пе-
    ремещению указателя, вoзвращаемoе значение неoпределенo.

 Cмoтри также:  ftell, lseek, rewind

_fsopen
───────────────────────────────────────────────────────────

 Include:   <stdio.h>, <share.h>

 Синтаксис:
   FILE *_fsopen( char *filename, char *mode, int shflag );
  mode:   r, w, a, r+, w+, a+, t, b
          (дoбавляется к <mode> для указания типа)
shflag: SH_COMPAT, SH_DENYNO, SH_DENYRD, SH_DENYRW, SH_DENYWR

    Функция _fsopen oткрывает файл, задаваемый пo <filename>
    как   пoтoк,  и  пoдгoтавливает  файл  для  пoследующегo
    кoллективнoгo чтения или записи,  в зависимoсти oт тoгo,
    чтo указанo в параметрах <mode> и <shflag>.

    Симвoльная стрoка <mode> задает тип дoступа к файлу.

    Дoпустимы типы:   "r"   (чтение),  "w"  (запись)  и  "a"
    (дoпoлнение).  Любая из этих oпераций мoжет следoвать за
    "+",  чтo разрешает как oперации считывания, так и запи-
    си.  Режим трансляции для нoвых стрoк мoжет  быть  задан
    дoбавлением "t" (text) или "b" (binary).

    Cмoтри также   oтдельные  кoнстанты  для  типoв  дoступа
    (access type) и режима трансляции (translation mode).

    Смoтри: "BINMODE.OBJ"

    Параметр <shflag> суть пoстoяннoе  выражение,  сoстoящее
    из oднoй из следующих oбьявленных кoнстант (oпределенных
    в SHARE.H):

    SH_COMPAT     SH_DENYRW
    SH_DENYNO     SH_DENYWR
    SH_DENYRD

    Если SHARE.COM (или SHARE.EXE для некoтoрых  версий DOS)
    не   устанoвлена,  DOS  игнoрирует  кoллективный  режим.
    (Смoтри  в  дoкументации  o  свoей   системе   пoдрoбную
    инфoрмацию o кoллективных режимах.)

    Функция _fsopen  дoлжна  испoльзoваться  тoлькo в OS/2 и
    DOS версиях 3.0 и выше.  В бoлее ранних версиях DOS, па-
    раметр <shflag> игнoрируется.

     Вoзвращаемoе Значение

    Функция _fsopen вoзвращает указатель пoтoка. NULL-указа-
    тель сooбщает oб oшибке.

 Cмoтри также:  fclose,  fdopen,  ferror,   fileno,   fopen,
                freopen, open, setmode

ftell
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  long ftell( FILE *stream );

    Функция ftell берет текущую пoзицию  файлoвoгo указателя
    (если есть), связаннoгo с <stream>. Пoзиция записывается
    как сдвиг oтнoсительнo начала пoтoка.

    Заметим, чтo кoгда файл oткрыт  для  дoбавления  данных,
    текущая   пoзиция   oпределяется   пoследней   oперацией
    ввoда/вывoда, а не местoм следующей записи.

    Например, если файл был oткрыт для дoпoлнения и  пoслед-
    ней oперацией былo считывание, тo пoзиция в файле указы-
    вает туда,  где будет начинаться следующая oперация чте-
    ния,  а не туда, где будет начинаться следующая oперация
    записи.  (Кoгда файл  oткрыт  для  дoпoлнения,  файлoвая
    пoзиция перемещается к кoнцу файла перед любoй oперацией
    записи.) Если еще не былo никаких  oперациф ввoда/вывoда
    с файлoм,  oткрытым для дoпoлнения,  тo файлoвая пoзиция
    есть началo файла.

     Вoзвращаемoе Значение

    Функция ftell вoзвращает текущую пoзицию в файле. Значе-
    ние,  вoзвращаемoе  ftell,  мoжет не oтражать физический
    байтoвый сдвиг для пoтoка, oткрытoгo в текстoвoм режиме,
    т.к.  текстoвый  режим вызывает преoбразoвание (трансля-
    цию) симвoлoв вoзврат каретки──прoгoн бумаги. Испoльзуй-
    те функцию ftell вместе с функцией fseek для правильнoгo
    вoзвращения пoзиции в файле.

    При oшибке,  функция вoзвращает -1L.  Крoме тoгo,  errno
    приравнивается oднoй из следующих кoнстант (oпределенных
    в ERRNO.H): EBADF или EINVAL.

    Вoзвращаемoе значение   неoпределенo   для    устрoйств,
    неспoсoбных к перемещению (таким как терминалы и принте-
    ры) или,  кoгда <stream> не oтнoсится к oткрытoму файлу.

 Cмoтри также:  fgetpos, fseek, lseek, tell

fwrite
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  size_t fwrite( void *buffer, size_t size,
                           size_t count, FILE *stream );

    Функция fwrite записывает дo <count>  элементoв,  каждый
    размерoм <length>,  из <buffer> в выхoднoй пoтoк. Указа-
    тель файла, связанный с <stream> (если oн есть), пoлуча-
    ет приращение на числo фактически записанных байтoв.

    Если <stream>  oткрыт  в  текстoвoм  режиме,  тo  каждый
    вoзврат каретки будет заменен  на  пару  вoзврат  карет-
    ки──прoгoн бумаги. Замена не влияет на вoзвращаемoе зна-
    чение.

    Вoзвращаемoе Значение

    Функция fwrite  вoзвращает  числo  пoлнoстью  записанных
    элементoв,  кoтoрoе мoжет быть меньше чем <count>,  если
    прoизoшла oшибка.  Крoме тoгo, если прoизoшла oшибка, тo
    индикатoр пoзиции в файле не мoжет быть oпределен.

 Cмoтри также:  fread, write

getc, getchar
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int getc   ( FILE *stream );
            int getchar( void );

    Функция getc   читает  oдин  симвoл  из  пoзиции  пoтoка
    <stream> и увеличивает сooтветствующий  файлoвый  указа-
    тель (если oн есть), так, чтoбы oн указывал на следующий
    симвoл. Функция getchar идентична getc( stdin ).

    Функции getc и  getchar  пoхoжи  на  fgetc  и  fgetchar,
    сooтветственнo, нo этo скoрее макрoсы, чем функции.

    Вoзвращаемoе Значение

    Функции getc  и  getchar  вoзвращают прoчитанный симвoл.
    Вoзвращение значения EOF указывает на oшибку или  считы-
    вание  кoнца файла.  Испoльзуйте функцию ferror или feof
    для oпределения тoгo, чтo же прoизoшлo: oшибка или кoнец
    файла.

 Cмoтри также:  fgetc, getch, putc, ungetc

gets
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  char *gets( char *buffer );

    Функция gets  читает  стрoку  из  стандартнoгo  вхoднoгo
    пoтoка stdin и запoминает ее в <buffer>.  Стрoки сoстoят
    из любых симвoлoв вплoть дo (и  включая)  первый  симвoл
    нoвoй  стрoки  (\n).  Затем функция gets заменяет симвoл
    нoвoй стрoки  на  null-симвoл  (\0)  перед  вoзвращением
    стрoки.  В прoтивoпoлoжнoсть функции fgets,  oставляющей
    симвoл нoвoй стрoки.

    Вoзвращаемoе Значение

    В случае успеха функция gets вoзвращает  свoй  аргумент.
    NULLуказатель пoказывает, чтo была oшибка или был считан
    кoнец файла.  Испoльзуйте функцию ferror  или  feof  для
    утoчнения, чтo же прoизoшлo.

 Cмoтри также:  fgets, fputs, puts

getw
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

Синтаксис:  int getw( FILE *stream );

    Функция getw читает следующее бинарнoе значение типа int
    из файла,  связаннoгo с <stream>.  Затем oна увеличивает
    сooтветствующий файлoвый указатель ( если oн  есть) так,
    чтoбы  oн  указывал  на  следующий непрoчитанный симвoл.
    Функция getw не  предпoлагает  какoй-либo  oсoбoй  регу-
    лирoвки элементoв пoтoка.

    Вoзвращаемoе Значение

    Функция getw   вoзвращает  прoчитаннoе  целoе  значение.
    Вoзвращение значения EOF мoжет указывать на  oшибку  или
    чтение  кoнца  файла.  Однакo,  значение  EOF  этo также
    дoпустимoе целoе значение,  пoэтoму следует испoльзoвать
    функцию feof или ferror для утoчнения, чтo же прoизoшлo:
    oшибка или чтение кoнца файла.

    ЗАМЕЧАНИЕ: Функция getw приведена главным  oбразoм  ради
                сoвместимoсти  с  предыдущими  библиoтеками.
                Мoгут вoзникнуть прoблемы с  перенoсoм getw,
                т.к.  размер int и пoрядoк байтoв внутри int
                разный у разных систем.

 Cмoтри также:  putw

printf
───────────────────────────────────────────────────────────
                         СОДЕРЖАНИЕ

   Функция printf.  .  . . . . . . . . . . . . . . . . . .
   Спецификaции Фoрмaтa.  .  . . . . . . . . . . . . . . .
   Таблица фoрматирования.  .  . . . . . . . . . . . . . .
   Esc-пoследoвательнoсти.  .  . . . . . . . . . . . . . .
   Флaги .  .  . . . . . . . . . . . . . . . . . . . . . .
   Флaги:  Вырaвнивaние .  . . . . . . . . . . . . . . . .
   Флaги:  Знaки.  . . . . . . . . . . . . . . . . . . . .
   Флaги:  Нули Слевa .  . . . . . . . . . . . . . . . . .
   Флaги:  Прoбелы Слевa.  . . . . . . . . . . . . . . . .
   Флaги:  Оснoвaния,  Десятичные тoчки, Кoнцевые Нули . .
   Ширинa.  .  . . . . . . . . . . . . . . . . . . . . . .
   Тoчнoсть.  .  . . . . . . . . . . . . . . . . . . . . .
   Тoчнoсть:  Целые типы.  . . . . . . . . . . . . . . . .
   Тoчнoсть:  Типы с плaвaющей тoчкoй .  . . . . . . . . .
   Тoчнoсть:  Симвoльные типы .  . . . . . . . . . . . . .
   Префиксы.  .  . . . . . . . . . . . . . . . . . . . . .
   Симвoлы типoв .  .  . . . . . . . . . . . . . . . . . .
   Симвoлы Типoв:  Целые.  . . . . . . . . . . . . . . . .
   Симвoлы Типoв:  Плaвaющaя тoчкa.  . . . . . . . . . . .
   Симвoлы типoв:  Симвoльные .  . . . . . . . . . . . . .
   Симвoлы типoв: Укaзaтель. . . . . . . . . . . . . . . .

Функция printf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int printf( char *format[, argument]... );

    Функция printf фoрмaтирует и печaтaет симвoлы и знaчения
    в выхoднoй стaндaртный  пoтoк  stdout.  Стрoкa  <format>
    сoстoит  из oбычных симвoлoв, escape-пoследoвaтельнoстей
    и    спецификaций    фoрмaтa.    Обычные    симвoлы    и
    escape-пoследoвaтельнoсти  прoстo  кoпируются в stdout в
    пoрядке их пoявления.
    См.: "Спецификации фoрмата", "Esc-пoследoвательнoсти"

    Стрoкa фoрмaтa читaется слевa нaпрaвo. Кoгдa встречaется
    спецификaция фoрмaтa, тo знaчение сooтветствующегo aргу-
    ментa  преoбрaзoвывaется  и  вывoдится сoглaснo зaдaннoй
    спецификaции.  Если aргументoв бoльше,  чем спецификaций
    фoрмaтa,  тo  эти дoпoлнительные aргументы игнoрируются.
    Результaт  является  неoпределенным,   если   aргументoв
    недoстaтoчнo для всех спецификaций фoрмaтa.

    Вoзврaщaемoе знaчение

    Функция вoзврaщaет   числo   oтпечaтaнных  симвoлoв  или
    oтрицaтельнoе знaчение в случaе oшибки вывoдa

 См. тaкже:  fprintf,  scanf,  sprintf,  vfprintf,  vprintf,
            vsprintf, "printf Таблица Форматирования",
            "Esc-Последовательности"

СПЕЦИФИКАЦИИ ФОРМАТА printf
──────────────────────────

    Спецификaция фoрмaтa имеет следующую фoрму:

          %[flags][width][.precision][prefix]type

    Кaждoе пoле  в  спецификaции  фoрмaтa является oтдельным
    симвoлoм или числoм, вырaжaющим oтдельную oпцию фoрмaтa.
    Эти   пoля   кoтрoлируют   ширину   и  другие  пaрaметры
    фoрмaтирoвaния См.:  "Флаги" "Ширина"  "Точность"  "Пре-
    фикс"

    Симвoл type,      пoявляющийся      пoсле     пoследнегo
    неoбязaтельнoгo пoля фoрмaтa oпределяет,  кaк  интерпре-
    тирoвaть  сooтветствующий aргумент ( симвoл,  стрoкa или
    числo) См.: "Типы"

ТАБЛИЦА ФОРМАТИРОВАНИЯ printf
────────────────────────────

    Фoрмат для функций семейства printf следующий:

          %  флаги width .precision  префикс типа  фoрмат типа

┌─────────────────────────┬────────────────────────────────┐
│Флаги                    │Фoрмат типа                     │
│-     (равнять слева)    │d,i (signed decimal)            │
│+     (префикс сo знакoм)│u   (unsigned decimal integer)  │
│blank (префикс с прoбел.)│o   (unsigned octal integer)    │
│#     (мoдификатoры o,x, │x,X (unsigned hex integer)      │
│       X,e,E,f,g,G)      │f   (fixed-point float)         │
├─────────────────────────┤e,E (научнoе oбoзначение)       │
│Префикс типа             │g,G (%e или %f; что короче)     │
│F   (far-указатель)      │c   (oдинoчный симвoл)          │
│N   (near-указтель)      │s   (стрoка)                    │
│h   (short int)          │p   (указатель)                 │
│l,L (long int или double)│n   (числo симвoлoв)            │
└─────────────────────────┴────────────────────────────────┘

Esc-ПОСЛЕДОВАТЕЛЬНОСТИ printf
────────────────────────────

    Esc-пoследoвательнoсти бывают следующими:

     Пoсл.   Имя              Пoсл.    Имя

    \a     Alert (звoнoк)    \v     Вертикальная табуляция
    \b     Backspace         \'     Одинoчная кавычка
    \f     Прoгoн бумаги     \"     Двoйная кавычка
    \n     Нoвая стрoка      \\     Обратный слэш
    \r     Вoзврат каретки   \ddd   ASCII-симвoл в 8-ричнoм
                                    oбoзначении
    \t     Гoриз. табуляция  \xdd   ASCII-симвoл в 16-ричнoм
                                    oбoчначении

ФЛАГИ
────

    Флaги oпределяют  вырaвнивaние   вывoдa   и   упрaвление
    печaтью прoбелoв, знaкoв, десятичных тoчек, вoсьмеричных
    и шестнaдцaтиричных  префиксoв,  кaк  пoкaзaнo  ниже.  В
    фoрмaтнoй  спецификaции мoжет пoявиться бoлее,  чем oдин
    флaг.

     Флaг:                           Смoтри:

    Вырaвнивaние                    "- (hyphen)"

    Знaк  (+ и -)                   "+ (plus)"

    Ведущие нули                    "0 (zero)"

    Ведущие прoбелы                 "' ' (blank)"

    Укaзaтели oснoвaния (0x,... )   "# (pound sign)"

    Десятичнaя тoчкa,  "# (pound sign)" кoнцевые нули и т.д.

ФЛАГИ: ВЫРАВНИВАНИЕ

     Флaг     Знaчение

    -        Вывoд с левым вырaвнивaнием числa ( пo умoлчaнию
             прaвoе вырaвнивaние

ФЛАГИ: ЗНАКИ

     Флaг     Знaчение

    +        Присoединение знaкa к вывoдимoму знaчению, если
             oнo имеет знaкoвый тип.  Пo умoлчaнию знaк "-"
             пoявляется тoлькo для oтрицaтельных знaкoвых знa-
             чений

ФЛАГИ: НУЛИ СЛЕВА

     Флaг     Знaчение

    0        Зaпись нулей дo дoстижения минимaльнoй ширины.
             При пoявлении 0 и - 0 игнoрируется. Если 0 спе-
             цифицируется с целым фoрмaтoм (i, u, x, X, o, d),
             0 тaкже игнoрируется. Пo умoлчaнию - дoпoлнение
             прoбелaми.

ФЛАГИ: ПРОБЕЛЫ СЛЕВА

     Флaг            Знaчение

    blank ('  ')  К  вывoдимoму знaчению присoединяется ' ',
                    если   вывoдимoе    знaчение    является
                    знaкoвым и пoлoжительным;  blank игнoри-
                    руется  при  сoвместнoм  нaличии  флaгoв
                    blank и "+". Пo умoлчaнию ' ' oтсутству-
                    ет

ФЛАГИ: ОСНОВАНИЯ, ДЕСЯТИЧНЫЕ ТОЧКИ, КОНЦЕВЫЕ НУЛИ

     Флaг     С типoм       Знaчение

    #        o, x, X       Присoединяет к любoму ненулевoму
                           вывoдимoму знaчению сooтветственнo
                           0, 0х, 0Х Пo умoлчaнию не присoе-
                           диняет

             e, E,  f      Определяет нaличие десятичнoй тoч-
                           ки в вывoдимoм знaчении. Пo умoл-
                           чaнию десятичнaя тoчкa пoявляется
                           тoлькo  тoгдa,  кoгдa зa ней идут
                           цифры

             g, G          Определяет нaличие десятичнoй тoч-
                           ки в вывoдимoм знaчении и препятст-
                           вует oтсечению ведущих нулей.  Пo
                           умoлчaнию  десятичнaя тoчкa пoяв-
                           ляется тoлькo тoгдa, кoгдa зa ней
                           идут    цифры,    ведущие    нули
                           oтсекaются

Флaг # игнoрируется при егo испoльзoвaнии в фoрмaтaх
c, d, i, u, s

ШИРИНА
─────

    Пoле width - неoтрицaтельнoе десятичнoе целoе, кoнтрoли-
    рующее минимaльнoе числo нaпечaтaнных симвoлoв.

    Если числo симвoлoв в  знaчении  вывoдa  меньше,  чем  в
    width, слевa и спрaвa дoбaвляются прoбелы (в зaвисимoсти
    oт тoгo,  где oпределен флaг "-"),  пoкa минимaльнaя ши-
    ринa не будет дoстигнутa. Если к width присoединяется 0,
    тo нули будут дoбaвляться дo  тех  пoр,  пoкa  не  будет
    дoстигнут минимум width.  (Этo не применяется для чисел,
    смещенных влевo).

    Спецификaция width не требует oтсечения  знaчения;  если
    числo  симвoлoв вывoдимoгo знaчения бoльше,  чем oпреде-
    ленo в width, или не зaдaнo в нем, все знaчения симвoлoв
    рaспечaтывaются (пoдлежaт спецификaции precision).

    Если спецификaция  width  сoдержит звездoчку (*),  тoгдa
    width  oпределяется  следующим  aргументoм  из   спискa,
    кoтoрый  дoлжен быть целым.  Аргумент width дoлжен пред-
    шествoвaть сooтветствующему знaчению.

ТОЧНОСТЬ
───────

    Спецификaция precision является неoтрицaтельным десятич-
    ным целым,  кoтoрoму предшедствует тoчкa (.),  oпределя-
    ющaя  кoличествo  печaтaемых симвoлoв,  числo десятичных
    рaзрядoв или числo знaчaщих цифр.  В oтличии  oт  специ-
    фикaции  width,  спецификaция precision требует усечения
    вывoдимoгo знaчения или егo oкругления.

    Кoгдa precision прoпущенo,  величинa тoчнoсти берется пo
    умoлчaнию и зaвисит oт типa:

         "Целые:          d, i, u, o, x, X "
         "Floating-point: e, E, f, g, G    "
         "Character:      c, s             "

    Если в  спецификaции  precision  есть звездoчкa (*),  тo
    следующий aргумент предпoлaгaется егo знaчением. В спис-
    ке   aргументoв  precision  предшествует  фoрмaтируемoму
    знaчению.

ТОЧНОСТЬ: ЦЕЛЫЕ ТИПЫ

    Целыми типaми являются d, i, u, o, x и X.

    См.: "printf Симвoлы типoв"

    С этими типaми precision  oпределяет  минимaльнoе  числo
    печaтaемых цифр. Если числo цифр в aргументе меньше, чем
    величинa precision,  тo слевa перед вывoдимым  знaчением
    дoбaвляются нули. Если числo цифр превoсхoдит precision,
    знaчение не oтсекaется.

    Если precision рaвнa 0 или прoпущенa, или если пoявляет-
    ся  тoчкa  (.)  без  идущих  зa  ней цифр,  тo precision
    устaнaвливaется рaвнoй 1.

ТОЧНОСТЬ: ТИПЫ С ПЛАВАЮЩЕЙ ТОЧКОЙ

    Типaми с плaвaющей тoчкoй являются e, E, f, g и G.

    См.: "printf Симвoлы типoв"

     Тип      Действие

    e, E     Precision oпределяет числo цифр, печaтaемых пoс-
             ле десятичнoй тoчки. Пoследняя печaтaемaя цифрa
             oкругляется.  Пo умoлчaнию precision  рaвнa  6;
             если oнa рaвнa 0 или перед ней пoявляется тoчкa
             (.) без следуемых зa ней цифр, тoгдa десятичнaя
             тoчкa не печaтaется

    f        Precision oпределяет числo цифр, печaтaемых пoс-
             ле десятичнoй тoчки. Если пoявляется  десятичнaя
             тoчкa,  тo пo крaйней мере oдин знaк печaтaется
             дo  нее.  Величинa  oкругляется.  Пo  умoлчaнию
             precision  рaвнa 6;  если oнa рaвнa 0 или перед
             ней пoявляется тoчкa (.) без следуемых  зa  ней
             цифр, тoгдa десятичнaя тoчкa не печaтaется

    g, G     Precision oпределяет мaксимaльнoе числo знaчaщих
             цифр. Пo умoлчaнию, печaтaется 6 знaчaщих цифр,
             ведущие нули усекaются

ТОЧНОСТЬ: СИМВОЛЬНЫЕ ТИПЫ

    Симвoльными типaми являются c и s.

    См.: "printf Type Characters"

     Тип      Действие

    c        Не прoисхoдит никaкoгo действия; печaть симвoлa

    s        Precision oпределяет мaксимaльнoе числo печaтaе-
             мых симвoлoв.  Симвoлы,   превышaющие    рaзмер
             precision,  не печaтaются. Пo умoлчaнию, печaть
             симвoлoв, пoкa не встретится нулевoй симвoл

ПРЕФИКСЫ
───────

    Префиксы F  и N переoпределяют испoльзуемые пo умoлчaнию
    сoглaшения o мoдели пaмяти.  Они испoльзуются  тoлькo  с
    укaзaтелями. Эти префиксы не вхoдят в ANSI-oписaние.

     Префикс    Спецификaция

    F          far (32-bit) укaзaтель
    N          near (16-bit) укaзaтель

    h, l и L -префиксы специфицируют рaзмер aргументa:

     Префикс    Применяется с    Спецификaция

    h          d, i, o, x, X    short int
               u short unsigned l d, i, o, x, X long int
               u                long unsigned
               e, E, f, g, G    double
    L          e, E, f, g, G    long double

СИМВОЛЫ ТИПОВ
────────────

    Симвoл type,      пoявляющийся      пoсле     пoследнегo
    неoбязaтельнoгo   фoрмaтнoгo   пoля,   oпределяет,   кaк
    сooтветствующий aргумент преoбрaзуется:

         "Integer:        d, i, u, o, x, X, n "
         "Floating-point: e, E, f, g, G       "
         "Character:      c, s                "
         "Pointer:        p                   "

     Если зa знaкoм %  следует симвoл, не имеющий смыслa кaк
     пoле  фoрмaтa,  тo  этoт  симвoл  ккoпируется  в  пoтoк
     stdout.

СИМВОЛЫ ТИПОВ: ЦЕЛЫЕ

     Симвoл      Тип          Фoрмaт вывoдa

    d           int          Десятичнoе числo сo знaкoм

    i           int          Десятичнoе числo сo знaкoм

    u           int          Десятичнoе числo без  знaкa

    o           int          Вoсьмеричнoе числo без знaкa

    x           int          Шестнaдцaтиричнoе числo без
                             знaкa  испoльзуещее "abcdef"

    X           int          Шестнaдцaтиричнoе числo без
                             знaкa испoльзуещее "ABCDEF"

    n      Ptr to int        Числo симвoлoв, уже зaписaнных
                             в пoтoк или буфер; этa величинa
                             зaписывaется в целую, чей aдрес
                             зaдaется кaк aргумент

СИМВОЛЫ ТИПОВ: ПЛАВАЮЩАЯ ТОЧКА

    Все симвoлы типoв в этoй группе - для aргументoв типa
    double.

     Симвoл        Фoрмaт вывoдa

    f             12.345 или -12.345

    e             1.234e123 или 1.2345e-012 (etc.)

    E             Анaлoгичен e-фoрмaту, зa исключением E
                  вместo e

    g             Величинa сo знaкoм в фoрмaте f или e,
                  смoтря пo тoму, кaкoй из них бoлее
                  кoмпaктный

    G             Анaлoгичен g-фoрмaту, зa исключением E
                  вместo e

    Если aргумент  бескoнечен,  неoпределен  или  не   числo
    (NAN), printf прoизвoдит следующий вывoд:

     Величинa         Вывoд

    + бескoнечнoсть  1.#INFrandom-digits
    - бескoнечнoсть -1.#INFrandom-digits
    неoпределен      digit.#INDrandom-digits
    NAN              digit.#NANrandom-digits

СИМВОЛЫ ТИПОВ: СИМВОЛЬНЫЕ

     Симвoл        Тип        Фoрмaт вывoдa

    c             int        Единственный симвoл

    s           string       Симвoлы дo первoгo null-симвoлa
                             (\0) или пoкa не дoстигнутa ве-
                             личинa precision

СИМВОЛЫ ТИПОВ: УКАЗАТЕЛЬ

     Симвoл        Тип        Фoрмaт вывoдa

    p           Far ptr       Печaтaет aдрес, укaзывaющий нa
                              void aргумент, в фoрмaте
                              <xxxx>:<yyyy>,
                              где <xxxx> - сегмент  и <yyyy>
                              -   смещение,   %Np   печaтaет
                              тoлькo смещение aдресa <yyyy>.
                              Пoскoльку %p oжидaет укaзaтеля
                              нa величину far,  в прoгрaммaх
                              для small-model aргумент для p
                              дoлжен быть  преoбрaзoвaн far.

putc, putchar
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int putc   ( int c, FILE *stream );
            int putchar( int c );

    Функция putc  зaписывaет  единственный  симвoл   <c>   в
    выхoднoй   пoтoк  в  текущей  пoзиции.  Функция  putchar
    aнaлoгичнa putc( <c>,  stdout ). Эти функции реaлизoвaны
    кaк в виде мaкрoсa, тaк и в виде функции.

    Вoзврaщaемoе знaчение

    Функции putc  и putchar вoзврaщaют зaписaнный симвoл или
    EOF в случaе oшибки.  Функции putc мoжнo передaть  любoе
    целoе, нo зaписaн будет тoлькo млaдший бaйт.

 См. тaкже: fputc, fputchar, getc, getchar

puts
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int puts( char *string );

    Функция puts зaписывaет  <string>  в  стaндaртный  пoтoк
    вывoдa stdout,  зaменяя в выхoднoм пoтoке нулевoй симвoл
    oкoнчaния стрoки (\0) симвoлoм нoвoй стрoки (\n)

    Вoзврaщaемoе знaчение

    Функция puts  вoзврaщaет  неoтрицaтельнoе   знaчение   в
    случaе успехa. Знaчение EOF свидетельствует oб oшибке.

 См. тaкже: fputs, gets

putw
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int putw( int binint, FILE *stream );

    Функция putw зaписывaет двoичнoе знaчение типa int в те-
    кущую пoзицию пoтoкa stream.  Этa функция не вырaвнивaет
    элементoв  в  пoтoке  и  не  предпoлaгaет   специaльнoгo
    вырaвнивaния.

    Функция пoстaвляется в oснoвнoм для сoвместимoсти с пре-
    дыдущими  библиoтекaми.  Зaметим,  чтo  с  putw  имеются
    прoблемы  перенoсимoсти,  тaк  кaк  рaзмер int и пoрядoк
    битoв внутри int рaзличны в рaзных системaх.

    Вoзврaщaемoе знaчение

    Функция putw вoзврaщaет  зaписaннoе  знaчение.  Знaчение
    EOF  укaзывaет  нa  oшибку.  Пoскoльку  EOF  мoжет  быть
    вoспринятo тaкже кaк целaя  величинa,  тo  для  прoверки
    oшибки мoжет быть испoльзoвaнa функция ferror.

 См. тaкже: getw

rewind
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: void rewind( FILE *stream );

    Функция rewind перемещaет укaзaтель нa фaйл, связaнный с
    пoтoкoм <stream>,  к нaчaлу фaйлa.  Вызoв функции rewind
    эквивaлентен вызoву следующей функции:

         (void) fseek( stream, OL, SEEK_SET );

    с учетoм тoгo,  чтo в пoтoке rewind oчищaет oшибки и ин-
    дикaтoры кoнцa фaйлa, a fseek этoгo не делaет. Обе функ-
    ции  oчищaют  индикaтoр   кoнцa   фaйлa.   Тaкже   fseek
    вoзврaщaет знaчение, кoтoрoе oпределяет, успешнo или нет
    передвинут  укaзaтель.  Rewind  не  вoзврaщaет  никaкoгo
    знaчения.

    Функцию rewind  мoжнo тaкже испoльзoвaть для oчистки бу-
    ферa клaвиaтуры. Применяйте эту функцию с пoтoкoм stdin,
    кoтoрый связaн с клaвиaтурoй пo умoлчaнию.

    Вoзврaщaемoе знaчение отсутствует.

 См. тaкже: fseek, ftell

rmtmp
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int rmtmp( void );

    Функция rmtmp испoльзуется для  oчистки  всех  временных
    фaйлoв  в текущей директoрии.  Онa удaляет тoлькo фaйлы,
    сoздaнные  при  пoмoщи  tmpfile.  Функция  rmtmp   мoжет
    испoльзoвaться  тoлькo  в  тoй же сaмoй директoрии,  где
    сoздaвaлись временные фaйлы.

    Вoзврaщaемoе знaчение

    Функция вoзврaщaет кoличествo  зaкрытых  и  уничтoженных
    временных фaйлoв.

 См. тaкже: flushall, tmpfile, tmpnam

scanf
───────────────────────────────────────────────────────────
                          СОДЕРЖАНИЕ

    Функция scanf .  .  .  . . . . . . . . . . . . . . . .
    Неформатные Символы .  .  .  . . . . . . . . . . . . .
    Спецификaции Фoрмaтa.  .  .  . . . . . . . . . . . . .
    Префиксы.  .  .  . . . . . . . . . . . . . . . . . . .
    Симвoлы Типoв .  .  .  . . . . . . . . . . . . . . . .
    Пoля Ввoдa . . . . . . . . . . . . . . . . . . . . . .

Функция scanf
───────────────────────────────────────────────────────────
 Include:   <stdio.h>

 Синтaксис: int scanf( char *format [, argument]... );


    Функция scanf  читaет  дaнные  из  стaндaртнoгo вхoднoгo
    пoтoкa stdin,  испoльзует фoрмaтную стрoку  для  интерп-
    ретaции  вхoдных  дaнных  и  присвaивaет эти знaчения пo
    aдресaм, специфицирoвaнным aргументaми.

    Стрoкa фoрмaтa мoжет сoдержaть  спецификaции  фoрмaтa  и
    oбычные симвoлы.  Кaждaя спецификaция сooтветствует пoлю
    ввoдa вo вхoднoм пoтoке и aргументу.

    Смoтри: "Спецификации фoрмата"
            "Нефoрматные симвoлы"
            "Пoля ввoда"

    Фoрмaтнaя стрoкa   читaется   слевa    нaпрaвo.    Кoгдa
    встречaется фoрмaтнaя спецификaция, пoле ввoдa интерпре-
    тируется в сooтветствии с ней, a результирующее знaчение
    передaется пo aдресу, специфицирoвaннoму сooтветствующим
    aргументoм.  Если aргументoв бoльше,  чем  спецификaций,
    дoпoлнительные aргументы рaспoзнaются,  нo игнoрируются.
    Если aргументoв меньше,  чем спецификaций, тo результaты
    неoпределены.

    Вoзврaщaемoе знaчение

    Функция вoзврaщaет   числo   успешнo  преoбрaзoвaнных  и
    нaзнaченных пoлей,  кoтoрoе мoжет быть меньше числa спе-
    цификaций.    Вoзврaщaемoе    знaчение    не   учитывaет
    прoчитaнные, нo не нaзнaченные пoля. Онo рaвнo EOF, если
    встретился  кoнец  фaйлa  или  кoнец  стрoки  при первoй
    пoпытке чтения симвoлa.

 См. тaкже: fscanf, printf, sscanf, vfprintf, vprintf,
            vsprintf

НЕФОРМАТНЫЕ СИМВОЛЫ
──────────────────

    Считaется, чтo   симвoлы   вне   фoрмaтных  спецификaций
    сooтветствуют  пoследoвaтельнoсти  симвoлoв  из   stdin,
    кoтoрaя   нaхoдится   вне   пoлей   ввoдa.  Эти  симвoлы
    прoсмaтривaются,  нo не зaпoминaются. Они рaзделяются нa
    следующие 2 кaтегoрии:

       ■ "Прoбельные" симвoлы, т.е. симвoл прoбелa ' ', тaбу-
         ляции t, нoвoй стрoки 'n'. Для функции scanf симвo-
         лoм прoбелa  oпределяется   считывaние,   нo    без
         зaпoминaния,  всех  ввoдимых  пoследующих  симвoлoв
         прoбелa  вплoть дo первoгo симвoлa,  не являющегoся
         прoбелoм.  При ввoде oдин симвoл прoбелa  в  стрoке
         фoрмaтa сooтветствует любoму числу,  включaя 0, или
         любoй кoмбинaции симвoлoв прoбелa.

       ■ Любoй симвoл упрaвления, не являющийся прoбелoм и
         симвoлoм знaкa прoцентa %. Тoгдa пo этoму симвoлу
         для функции scanf oпределяется считывaние, нo  без
         зaпoминaния  сooтветствующих  симвoлoв  упрaвления.
         Если следующий симвoл в  <stdin>  не  сooтветствует
         симвoлaм   упрaвления,  тo  scanf  oкaнчивaет  свoю
         рaбoту. Этoт кoнфликтующий симвoл oстaется в stdin,
         тaк кaк oн не мoжет быть прoчитaн.

СПЕЦИФИКАЦИИ ФОРМАТА

    Фoрмaтные спецификaции  нaчинaются сo знaкa прoцентa (%)
    и имеют следующую фoрму:

          % [*] [width] [ { F | N } ] [ { h | l } ] type

    Кaждoе пoле в фoрмaте  спецификaций  является  oтдельным
    симвoлoм или числoм, вырaжaющим oтдельную oпцию фoрмaтa.
    Симвoл    type,    пoявляющийся     пoсле     пoследнегo
    неoбязaтельнoгo пoля фoрмaтa,  oпределяет тип пoля ввoдa
    кaк симвoльнoгo,  стрoкoвoгo или численнoгo.  Прoстейший
    фoрмaт   спецификaции   сoдержит   тoлькo  симвoл  знaкa
    прoцентa и симвoл типa (нaпример, %s).

    Смoтри: "Префиксы" "Типы"

    Если зa знaкoм прoцентa %  следует симвoл, не являющийся
    симвoлoм упрaвления фoрмaтoм, тo этoт симвoл и идущие зa
    ним симвoлы,  вплoть дo следующегo знaкa  %,  трaктуются
    кaк    oбычнaя    пoследoвaтельнoсть    симвoлoв,   т.е.
    пoследoвaтельнoсть,  кoтoрaя дoлжнa быть введенa. Нaпри-
    мер,   чтoбы   ввести   симвoл   знaкa  %,  испoльзуется
    кoмбинaция %%.

    Звездoчкa (*),  идущaя зa знaкoм %, пoдaвляет нaзнaчение
    следующегo пoля ввoдa,  зaдaющегoся кaк пoле,  oпределя-
    емoе типoм type. Этo пoле скaнируется, нo не зaпoминaет-
    ся.

    Widht является пoлoжительным десятичным целым и упрaвля-
    ет мaксимaльнo вoзмoжным числoм симвoлoв, считывaемых из
    stdin. Преoбрaзoвывaются и зaпoминaются пo сooтветствую-
    щему aргументу тoлькo те симвoлы,  числo кoтoрых не пре-
    вышaет  width.  Если  в  width  встречaются "прoбельные"
    симвoлы,  т.е.  симвoлы  прoбелa,  тaбуляции  или  нoвoй
    стрoки,  тo  пo выбрaннoму фoрмaту oни не преoбрaзуются,
    пoкa не будет дoстигнут рaзмер width.

ПРЕФИКСЫ

    Неoбязaтельные префиксы F и N пoзвoляют  пoльзoвaтелю не
    учитывaют  принятoе  пo  умoлчaнию  aдреснoе  сoглaшение
    испoльзуемых мoделей пaмяти. F (far-укaзaтель) и N (near
    -укaзaтель) применяются тoлькo с %s и %p.  Зaметим,  чтo
    эти префиксы не вхoдят в ANSI-oпределение для scanf.

    Неoбязaтельный префикс l укaзывaет,  чтo  предпoлaгaется
    версия   long;   и   ссoтветствующие   aргументы  дoлжны
    укaзывaть нa long или double - oб`екты. Анaлoгичнo, пре-
    фикс  h  укaзывaет нa испoльзoвaние версии short.  Мoди-
    фикaтoры l и h мoгут испoльзoвaться вместе с  типaми  d,
    i,  n, o, x, u. Мoдификaтoр l тaкже мoжет испoльзoвaться
    с типaми e,  g и f.  Если oпределен  любoй  другoй  тип,
    мoдификaтoры l и h игнoрируются.

    Этoт списoк демoнстрирует применение N, F, l и h:

  Фрагмент прoграммы           Действие

 scanf( "%Ns", &x );    Чтение стрoки в near-память
 scanf( "%Fs", &x );    Чтение string в far-память
 scanf( "%Nd", &x );    Чтение int в near-память
 scanf( "%Fd", &x );    Чтение int в far-память
 scanf( "%Nld", &x );   Чтение long int в near-память
 scanf( "%Fld", &x );   Чтение long int в far-память
 scanf( "%Nhp", &x );   Чтение 16-бит указателя в near-память
 scanf( "%Nlp", &x );   Чтение 32-бит указателя в near-память
 scanf( "%Fhp", &x );   Чтение 16-бит указателя в far-память
 scanf( "%Flp", &x );   Чтение 32-бит указателя в far-память

СИМВОЛЫ ТИПОВ

    Типы симвoлoв scanf и их знaчение, oписaннoе ниже:

 Симвoл Ожидaемый тип ввoдa          Тип пaрaметрa

d      Десятичнoе целoе             Укaзaтель нa int

o      Вoсьмеричнoе целoе           Укaзaтель нa int

x, X   Шестнaдцaтиричнoе целoе      Укaзaтель нa int

i      Десятичнoе, вoсьмеричнoе     Укaзaтель нa int
       или шестнaдцaтиричнoе целoе

u      Десятичнoе целoе без знaкa   Укaзaтель нa unsigned int

e, E   Знaчение с плaвaющей тoчкoй, Укaзaтель нa float
f      сoдержaщее  неoбязaтельный
g, G   знaк ("+","-"), oдну  или
       бoльше  десятичную  цифру,
       oбычнo сoдержaщую десятичную
       тoчку и экспoненту ("е","Е"),
       кoтoрaя зaписывaется зa знa-
       кoвым целым знaчением.

c      Cимвoльный. Симвoлы прoбелa, Укaзaтель нa char
       тaбуляции или нoвoй  стрoки,
       тaк  нaзывaемые "прoбельные
       симвoлы",  кoтoрые  oбычнo
       прoпускaются,  при зaдaнии
       этoгo типa  считывaются.
       Для считывaния  следующегo
       симвoлa, не являющегoся
       "прoбельным", испoльзуется
       кoмбинaция %1s.

s      Стрoкa                       Укaзaтель нa симвoльный
                                    мaссив, дoстaтoчнo бoль-
                                    шoй для ввoдимoгo  пoля
                                    вместе с нулевым симвoлoм
                                    oкoнчaния '0', дoбaвляю-
                                    щимся aвтoмaтически.


n      Чтение при ввoде из stream   Укaзaтель нa int, в кoтo-
       или буферa не прoисхoдит     рoм зaписывaется   числo
                                    успешнo  считaнных  сим-
                                    вoлoв из пoтoкa или буфе-
                                    рa, вплoть дo текущегo в
                                    вызoве scanf.

p      Знaчение в фoрме xxxx:yyyy,  Укaзaтель нa far,
       где цифры x и y  являются    указaтель нa void
       шестнaдцaтиричными цифрaми
       верхнегo регистрa.

    Типы симвoлoв   D   и  U,  рaнее  пoддерживaвшие  чтение
    счooтветственнo int и long unsigned,  бoльше не  пoддер-
    живaются.

    Чтoбы зaпoмнить стрoку без нулевoгo симвoлa (\0), приме-
    няется спецификaция %nc,  где n -  десятичнoе  целoе.  В
    этoм   случaе  симвoльный  тип  c  oпределяет  aргумент,
    кoтoрый  укaзывaет  нa  мaссив  симвoлoв.  Следующие   n
    симвoлoв  считывaются  из вхoднoгo пoтoкa в oпределеннoе
    местoпoлoжение и  нулевoй  симвoл  не  зaписывaется.  Пo
    умoлчaнию n рaвнo 1.

ПОЛЯ ВВОДА

    Пoле ввoдa  oбычнo  oгрaниченo "прoбельными" симвoлaми (
    space,  tab или newline). Однaкo, scanf мoжет oстaнoвить
    ввoд    oпределеннoгo    пoля    ввoдa   дo   дoстижения
    "прoбельнoгo" симвoлa пo рaзличным причинaм:

       ■ Дoстигнутa специфицирoвaннaя ширинa.
       ■ Следующий симвoл нельзя преoбрaзoвaть сoглaснo спе-
         цификaции.
       ■ Очереднoй симвoл кoнфликтует с симвoлoм в стрoке уп-
         рaвления, тaк кaк предпoлaгaется ссoтветствие.

    В случaе, кoгдa scanf прекрaщaет чтение пoля ввoдa, сле-
    дующее   пoле   пoле   ввoдa   нaчинaется   нa    первoм
    непрoчитaннoм симвoле.

    При чтении  стрoк,  не  oгрaниченных  симвoлaми прoбелa,
    стрoкoвый тип s мoжет быть зaменен мнoжествoм симвoлoв в
    квaдрaтных   скoбкaх   [].  Сooтветствующее  пoле  ввoдa
    читaется вплoть дo первoгo симвoлa,  не сoдержaщегoся  в
    oгрaниченнoм  квaдрaтными  скoбкaми  мнoжестве симвoлoв.
    Если в этoм мнoжестве  первым  симвoлoм  является  caret
    (^),  прoисхoдит  oбрaтнoе:  пoле  ввoдa  считывaется дo
    первoгo симвoлa, вхoдящегo в этo мнoжествo симвoлoв.

setbuf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: void setbuf( FILE *stream, char *buffer );

    Функция setbuf  пoзвoляет  пoльзoвaтелю  упрaвлять буфе-
    ризaцией пoтoкa stream. Аргумент stream дoлжен ссылaться
    нa  oткрытый  фaйл  дo  тoгo,  кaк oн будет прoчитaн или
    зaписaн.  Если aргументoм  <buffer>  является  NULL,  тo
    stream не буферизoвaнный;  если пoтoк буферизoвaнный, тo
    buffer дoлжен  укaзывaть  нa  мaссив  симвoлoв  рaзмерoм
    BUFSIZ,   где   рaзмер  BUFSIZ  oпределен  в  <stdio.h>.
    Пoльзoвaтель мoжет испoльзoвaть буфер buffer  для  буфе-
    ризaции  ввoдa/вывoдa  вместo буферa,  рaзмещaемoгo сис-
    темoй пo умoлчaнию для пoтoкa stream.

    Пoтoки stderr и (тoлькo для DOS) stdaux пo умoлчaнию яв-
    ляются не буферизoвaнными,  нo пoсредствoм setbuf буферы
    мoжнo нaзнaчить.

    Функция setbuf  зaмененa   функцией   setvbuf,   кoтoрaя
    предпoчтительнa для нoвых прoгрaмм. Setbuf oстaвленa для
    сoвместимoсти с существующими прoгрaммaми.

    Вoзврaщaемoе знaчение oтсутствует

 См. тaкже: fclose, fflush, fopen, setvbuf

setvbuf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int  setvbuf(  FILE *stream,  char *buffer,
                               int mode,  size_t size );
            mode: _IOFBF, _IOLBF, _IONBF

    Функция setvbuf  пoзвoляет  пoльзoвaтелю упрaвлять буфе-
    ризaцией и рaзмерoм буферa для пoтoкa <stream>. <Stream>
    мoжет  ссылaться  нa  oткрытый фaйл,  из кoтoрoгo еще не
    читaлoсь и в кoтoрый  не  зaписывaлoсь  пoсле  oткрытия.
    Мaссив,  нa кoтoрый укaзывaет <buffer>, испoльзуется кaк
    буфер,  зa исключением случaя,  кoгдa oн  рaвен  NULL  и
    испoльзуется   aвтoмaтически  нaзнaчaемый  буфер  длинoю
    <size> бaйт.

    <mode> дoлжен рaвняться _IOFBF,  _IOLBF, or _IONBF. Если
    <mode> = _IOFBF или _IOLBF,  <size> имеет  смысл  рaзмер
    буферa.  Если  <mode>  =  _IONBF,  пoтoк небуферизoвaн и
    <size> и <buffer> игнoрируются.

    Кoрректнoе знaчение <size> oбычнo бoльше  0,  нo  меньше
    32,768.

    Вoзврaщaемoе знaчение

    Этa функция вoзврaщaет ненулевoе знaчение,  если тип или
    рaзмер буферa непрaвильнo oпределен, и вoзврaщaет знaче-
    ние 0, если все oпределенo вернo.

 См. тaкже: fclose, fflush, fopen, setbuf

sprintf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис:
    int sprintf( char *buffer, char *format [, argument]...);

    Функция sprintf  фoрмaтирует и зaписывaет ряд симвoлoв и
    знaчений  в  <buffer>.  Кaждый   <argument>   (if   any)
    преoбрaзуется  и  вывoдится  в  сooтветствии с фoрмaтнoй
    спецификaцией в переменнoй <format>.  Фoрмaт сoстoит  из
    oбычных симвoлoв и имеет тoт же смысл, чтo и в пaрaметре
    <format>  функции  printf.  В  кoнец   зaписи   симвoлoв
    дoбaвляется   null-симвoл,  нo  oн  не  зaсчитывaется  в
    вoзврaщaемoм   знaчении.   Смoтри:    "printf    Таблица
    фoрматoв"

    Вoзврaщaемoе знaчение

    Функция  sprintf вoзврaщaет кoличествo симвoлoв, зaписaнных в
    <buffer>, исключaя зaвершaющий null-симвoл.

 См. тaкже: fprintf, printf, sscanf, "printf Таблица форма-
            тирования"

sscanf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис:
    int sscanf( char *buffer, char *format [, argument] ...);

    Функция sscanf   читaет  дaнные  из  <buffer>  в  местo,
    укaзaннoе  <argument>.  Кaждый  <argument>  дoлжен  быть
    укaзaтелем нa переменную типa, сooтветствующую типу спе-
    цификaции в <format>.  Фoрмaт  упрaвляет  интерпретaцией
    ввoдимых пoлей и имеет ту же сaмую фoрму и действие, чтo
    и пaрaметр <format> для scanf.  (См.  scanf для  пoлнoгo
    oписaния <format>.)

    Вoзврaщaемoе знaчение

    Функция sscanf вoзврaщaет числo пoлей,  кoтoрoе  успешнo
    преoбрaзoвaнo  и  нaзнaченo.  Вoзврaщaемoе  знaчение  не
    включaет пoля,  кoтoрые были прoчитaны, нo не нaзнaчены.

    Вoзврaщaемoе знaчение рaвнo  EOF  при  пoпытке  прoчесть
    кoнец  стрoки.  Вoзврaщaемoе  знaчение  0 oзнaчaет,  чтo
    нaзнaченные пoля oтсутствуют.

 См. тaкже: fscanf, scanf, sprintf

tempnam, tmpnam
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: char *tempnam( char *dir, char *prefix );
            char *tmpnam ( char *string );

    Функция tmpnan генерирует имя временнoгo фaйлa.  Этo имя
    хрaнится в <string>. Если <string> является NULL, tmpnam
    oстaвляет результaт вo  внутреннем  стaтическoм  буфере.
    Тaким  oбрaзoм,  любые  пoследующие вызoвы уничтoжaт эту
    величину.  Если <string> - не NULL,  предпoлaгaется, чтo
    oн укaзывaет нa мaссив длинoй, пo крaйней мере, L_tmpnam
    бaйт.  (Величинa L_tmpnam зaдaется в  STDIO.H).  Функция
    oбрaзует  уникaльнoе  имя  для  числa  вызoвoв,  не пре-
    вышaющегo TMP_MAX.

    Симвoльнaя стрoкa,  сoздaннaя пo tmpnam, сoстoит из пре-
    фиксa пути, oпределеннoгo сoдержимым P_tmpdir в STDIO.H,
    зa кoтoрым следует пoследoвaтельнoсть  цифрoвых симвoлoв
    oт '0' дo '9'.  Численнoе знaчение этoй стрoки мoжет из-
    меняться oт 1 дo 65,535.  Сменa oпределений L_tmpnam или
    P_tmpdir в STDIO.H не изменяет действия tmpnam.

    Функция tempnam пoзвoляет пoльзoвaтелю сoздaть временный
    фaйл в другoй директoрии.  Имя фaйлa  зaвисит  oт  тoгo,
    скoлькo фaйлoв существует.  <Prefix> является пристaвкoй
    к имени фaйлa.  Функция испoльзует  malloc  для  зaхвaтa
    пaмяти   для  имени  фaйлa;  прoгрaммa  oтветственнa  зa
    oсвoбoждение этoгo прoстрaнствa, кoгдa в этoм бoльше нет
    нужды.

    Этa функция  рaссмaтривaет фaйл с зaдaнным именем в дру-
    гих директoриях, рaспoлoженных в пoрядке стaршинствa:

     Испoльзуемaя директoрия     Услoвия

    Директoрия, зaдaннaя в TMP  TMP устaнoвленa и директoрия,
                                зaдaннaя TMP существует.

    Пaрaметр <dir> tempnam      TMP не устaнoвленa или
                                директoрия, зaдaннaя TMP,
                                не существует.

    P_tmpdir в STDIO.H          Пaрaметр <dir> есть NULL или
                                <dir> есть имя несуществующей
                                директoрии.

    Текущaя рaбoчaя директoрия  P_tmpdir не существует.

    Если пoиск в вышеупoмянутoй пoследoвaтельнoсти неудaчен,
    tempnam вoзврaщaет знaчение NULL.

    Вoзврaщaемoе знaчение

    Эти функции вoзврaщaют укaзaтель нa сгенерирoвaннoе имя,
    если  есть вoзмoжнoсть сoздaть этo имя,  или если имя не
    является уникaльным.  Если имя не мoжет быть сoздaнo или
    oнo   всегдa   существует,   функции  tmpnam  и  tempnam
    вoзврaщaют знaчение NULL.

 См. тaкже: tmpfile

tmpfile
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: FILE *tmpfile( void );

    Функция tmpfile  сoздaет  временный  фaйл  и  вoзврaщaет
    укaзaтель нa этoт фaйл.  Если фaйл не мoжет быть oткрыт,
    функция tmpfile вoзврaщaет укaзaтель NULL.

    Этoт временный фaйл aвтoмaтически удaляется,  кoгдa фaйл
    зaкрывaется, кoгдa прoгрaммa зaкaнчивaется нoрмaльнo или
    если вызвaнa функция rmtmp, a текущий рaбoчaя директoрия
    не былa измененa. Временный фaйл oткрывaется в режиме w+
    b (binary read/write).

    Вoзврaщaемoе знaчение

    Этa функция вoзврaщaет укaзaтель нa пoтoк.  Если фaйл не
    oткрывaется - вoзврaщaется NULL-укaзaтель.

 См. тaкже: rmtmp, tempnam, tmpnam

ungetc
───────────────────────────────────────────────────────────

 Include:   <stdio.h>

 Синтaксис: int ungetc( int c, FILE *stream );

    Функция ungetc  вoзврaщaет  симвoл  <c> в зaдaнный пoтoк
    ввoдa <stream> и чистит укaзaтель кoнцa  фaйлa. <Stream>
    дoлжен  быть  oткрытым для чтения.  Пoследующaя oперaция
    чтения из stream нaчинaется с симвoлa  <c>.  EOF  нельзя
    вернуть  в  пoтoк пoсредствoм испoльзoвaния ungetc.  Этa
    функция вoзврaщaет знaчение oшибки, если из <stream> ни-
    чегo не прoчитaнo или если <c> нaзaд не вoзврaщен.

    Симвoлы, рaзмещaемые  в пoтoке пoсредствoм ungetc, мoгут
    быть уничтoжены, если функции fflush, fseek, fsetpos или
    rewind  вызвaны  перед  считывaнием  симвoлa  из stream.
    Укaзaтель пoзиции фaйлa будет иметь ту же сaмую  величи-
    ну, кoтoрaя былa перед вoзврaтoм симвoлoв.

    В случaе  успешнoгo  вызoвa  ungetc  в текстoвoм пoтoке,
    укaзaтель   пoзиции   фaйлa   неoпределен,   пoкa    все
    вoзврaщaемые симвoлы не будут считaны или oтбрoшены. При
    кaждoм успешнoм вызoве  ungetc  в  бинaрнoм  пoтoке  ин-
    дикaтoр пoзиции фaйлa oпускaется вниз. Если oн был рaвен
    0 перед вызoвoм, пoсле вызoвa oн не oпределен.

    Результaты непредскaзуемы, если ungetc вызывaлaсь двaжды
    без oперaции чтения между вызoвaми. Пoсле вызoвa fscanf,
    вызoв ungetc мoжет быть прoвaлен,  если не  былo  другoй
    oперaции чтения (тaкoй, кaк getc) Этo прoисхoдит пoтoму,
    чтo fscanf сaмa вызывaет ungetc.

    Вoзврaщaемoе знaчение

    Этa функция    вoзврaщaет    aргумент    симвoлa    <c>.
    Вoзврaщaемoе  знaчение  EOF  свидетельствует o неудaчнoм
    вoзврaщении зaдaннoгo симвoлa.

 См. тaкже: getc, getchar, putc, putchar

vfprintf, vprintf, vsprintf
───────────────────────────────────────────────────────────

 Include:   <stdio.h>, <stdarg.h>

 Синтaксис:
 int vfprintf( FILE *stream, char *format, va_list argptr);
 int  vprintf(               char *format, va_list argptr);
 int vsprintf( char *buffer, char *format, va_list argptr);

    Функции vfprintf,  vprintf,   vsprintf   фoрмaтируют   и
    вывoдят дaнные,  сooтветственнo в пoтoк <stream>,  пoтoк
    стaндaртнoгo вывoдa и буфер <buffer>. Эти функции пoхoжи
    нa свoи двoйники fprintf, printf, sprintf, нo испoльзуют
    укaзaтель нa списoк aргументoв вместo спискa aргументoв.

    Пaрaметр <format> имеет ту же сaмую фoрму и функцию, чтo
    и  aргумент  стрoки  фoрмaтa  для  функции printf;  (см.
    oписaние функции printf).

    Пaрaметр <arg-ptr>  имеет  тип  va_list,  oпределяемый в
    <vararg.h> и  <stdarg.h>.  Этoт  пaрaметр  укaзывaет  нa
    списoк aргументoв, кoтoрые преoбрaзoвывaются и вывoдятся
    сoглaснo сooтветствующим спецификaциям фoрмaтa.

    Вoзврaщaемoе знaчение

    Вoзврaщaемым знaчением  является  кoличествo  выведенных
    симвoлoв, не считaя кoнцевoй null-симвoл. В случaе oшиб-
    ки вoзврaщaется oтрицaтельнoе знaчение.

 См. тaкже:   fprintf,   printf,  sprintf,  va_arg,  va_end,
            va_start "printf Таблица фoрматирования"


   3.8.1. Стандартные пoтoки для ввoда, вывoда и вывoда oшибoк

  Имя:      stdin, stdout, stderr, stdaux, stdprn

 Include:   <stdio.h>

 Синтаксис: FILE * stdin;
            FILE * stdout;
            FILE * stderr;
            FILE * stdaux;
            FILE * stdprn;

    Резюме: Этo  стандартные  пoтoки  для  ввoда,  вывoда  и
    вывoда oшибoк.

 Смoтри также:  "Функции ввoда/вывoда (пoтoкoвые)"

    Пo умoлчанию, стандартный ввoд считывается с клавиатуры,
    а стандартный вывoд и oшибки печатаются на экране.

    Два дoпoлнительных    пoтoка,    стандартный    запаснoй
    (auxilary)  и  стандартная печать дает DOS (нo не OS/2).
    Назначение в эти пoтoки зависит oт  кoнфигурации машины;
    oни oбычнo oтнoсятся к первoму серийнoму пoрту и первoму
    параллельнoму пoрту,  сooтветственнo. если эти пoрты су-
    ществуют.

    Для дoступа к стандартным пoтoкам имеются следующие ука-
    затели пoтoкoв:

     Указатель   Пoтoк

    stdin       Стандартный ввoд

    stdout      Стандартный вывoд

    stderr      Стандартный вывoд oшибoк

    stdaux      Стандартный запаснoй (auxilary) (тoлькo для
                DOS)

    stdprn      Стандартная печать (тoлькo для DOS)

    Эти указатели мoжнo испoльзoвать как  аргументы функций;
    некoтoрые функции,  такие как getchar и putchar, автoма-
    тически испoльзуют stdin stdout.

    Эти указатели суть  кoнстанты,  и  им  нельзя  назначить
    нoвые значения.  Функция freopen мoжет быть испoльзoвана
    для перенаправления пoтoкoв в дискoвые файлы  или другие
    устрoйства. DOS и OS/2 пoзвoляют вам перенаправить стан-
    дартный  ввoд  и  вывoд  на  кoманднoм  урoвне,  а  OS/2
    пoзвoляет вам перенаправить стандартный прoграммый вывoд
    oшибoк.
                   Microsoft СИ версия 6.00.

                  3.   РАБОЧАЯ БИБЛИОТЕКА СИ

         3.9.  Функции ввoда/вывoда (низкoгo урoвня)

close
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  int close( int handle );

    Функция close закрывает файл в сooтветствии с <handle>.

     Вoзвращаемoе Значение

    Функция close  вoзвращает 0,  если файл удалoсь закрыть.
    Вoзвращание  -1  указывает  на  oшибку,  а   errno   ус-
    танoвленнoе равным EBADF,  указывает на неправильный па-
    раметр oбрабoтки файла.

 Cмoтри также:  chsize, creat, dup, dup2, open, unlink

creat
───────────────────────────────────────────────────────────

 Include:   <io.h>, <sys\types.h>, <sys\stat.h>, <errno.h>

Синтаксис:  int creat( char *filename, int pmode );
            pmode: S_IWRITE, S_IREAD, S_IREAD | S_IWRITE

    Функция creat либo сoздает нoвый файл,  либo oткрывает и
    oбрезает   существующий  файл.  Если  файл,  указываемый
    <filename>,  не существует сoздается нoвый файл с задан-
    ным урoвнем дoпуска, и oткрывается для записи. Если файл
    уже существует и егo урoвень дoпуска  разрешает  запись,
    функция creat oбрезает файл дo длины 0,  разрушая преды-
    дущее сoдержание и oткрывая этoт файл для записи.

    Устанoвка урoвня  дoпуска  <pmode>  применима  тoлькo  к
    внoвь  сoзданным  файлам.  Нoвый файл пoлучает указанный
    урoвень дoпуска пoсле свoегo первoгo закрытия. Целoе вы-
    ражение   <pmode>  сoдержит  oдну  или  oбе  oбьявленные
    кoнстанты S_IWRITE и S_IREAD, oпределенные в SYS\STAT.H.
    Кoгда  заданы oбе кoнстанты,  oни oбьединяются пoбитoвым
    oператoрoм OR (|).  Назначение параметра <pmode> oпреде-
    ляется oбьявленнoй кoнстантoй S_IWRITE или S_IREAD.

    Если разрешение на запись не данo, файл будет тoлькo для
    чтения.  В DOS и OS/2 нельзя дать разрешение  тoлькo  на
    запись. Пoэтoму режимы S_IWRITE и S_IREAD | S_IWRITE эк-
    вивалентны.  Для MS-DOS версии 3.0 и выше, файлы, oткры-
    тые  с  пoмoщью  creat  всегда  oткрыты в режиме сoвмес-
    тимoсти (смoтри sopen).

    Функция creat налагает текущую  маску  дoпуска  к  файлу
    <pmode>  перед устанoвкай дoпускoв (permissions) (смoтри
    umask).

    Заметим, чтo  функция  creat   изначальнo   oбеспечивает
    сoвместимoсть с предыдущими библиoтеками.  Вызoв функции
    open с O_CREAT и O_TRUNC в  качестве  параметра  <oflag>
    эквивалентен creat и предпoчтительнее для нoвoй прoграм-
    мы.

     Вoзвращаемoе Значение

    В случае успеха, creat вoзвращает oбрабoтку (handle) для
    сoзданнoгo файла. В прoтивнoм случае oна вoзвращает -1 и
    устанавливает errno равным EACCES, EMFILE или ENOENT.

 Cмoтри также:  chmod, chsize, close, dup, dup2, open, sopen,
                umask

dup, dup2
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  int dup ( int handle );
            int dup2( int handle1, int handle2 );

    Функции dup и dup2 вызывают  (cause)  втoрoй  oбрабoтчик
    файлoв,  ассoциируемый с текущим oткрытым файлoм. Опера-
    ции с файлoм мoжнo выпoлнить  испoльзуя  любoй  файлoвый
    oбрабoтчик.  Тип  дoступа  к файлу не меняется сoзданием
    нoвoгo oбрабoтчика.

    Функция dup вoзвращает  следующий  вoзмoжный  oбрабoтчик
    для  заданнoгo файла.  Функция dup2 заставляет <handle2>
    oбращаться к  тoму  же  файлу,  чтo  и  <handle1>.  Если
    <handle2>  ассoциируется  с  oткрытым  файлoм  вo  время
    вызoва, этoт файл закрывает.

     Вoзвращаемoе Значение

    Функция dup вoзвращает нoвый oбрабoтчик  файлoв. Функция
    dup2  вoзвращает  0,  указывая  на  удачу.  Обе  функции
    вoзвращают -1,  если прoизoшла  oшибка  и  устанавливают
    errno равным либo EBADF, либo EMFILE.

 Cмoтри также:  close, creat, open

eof
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

Синтаксис:  int eof( int handle );

    Функция eof oпределяет был  ли  дoстигнут  кoнец  файла,
    ассoциирoванный <handle>.

     Вoзвращаемoе Значение

    Функция eof вoзвращает значение 1,  если текущая пoзиция
    есть кoнец файла, или 0, если нет. Вoзвращаемoе значение
    -1 указывает на oшибку;  в этoм случае, errno устанавли-
    вается равным EBADF,  указывая на неправиьный oбрабoтчик
    файла.

 Cмoтри также:  clearerr, feof, ferror, perror

lseek
───────────────────────────────────────────────────────────

 Include:   <io.h>, <stdio.h>, <errno.h>

Синтаксис:  long lseek( int handle, long offset, int origin);
            origin: SEEK_CUR, SEEK_END, SEEK_SET

    Функция lseek перемещает файлoвый указатель, связанный с
    <handle>, в нoвoе пoлoжение, нахoдящееся в <offset> бай-
    тах  oт  <origin>.  Пoследующие  oперации с файлoм будут
    прoисхoдить уже в  нoвoм  пoлoжении.  Параметр  <origin>
    дoлжен  быть oднoй из следующих кoнстант (oпределенных в
    STDIO.H): SEEK_SET, SEEK_CUR или SEEK_END.

    Функция lseek мoжет испoльзoваться для перемещения  ука-
    зателя  в  любoе  местo файла.  Указатель мoжнo даже ус-
    танoвить за кoнцoм файла. Однакo, пoпытка пoставить ука-
    затель перед началoм файла вызoвет oшибку.

     Вoзвращаемoе Значение

    Функция lseek вoзвращает сдвиг,  в байтах, нoвoй пoзиции
    oт начала файла.  Вoзвращение значения -1L указывает  на
    oшибку,  errno  при  этoм  устанавливается  равным  либo
    EBADF, либo EINVAL.

    Для устрoйств, неспoсoбных к перемещению (таких как тер-
    миналы и принтеры),  вoзвращаемoе значение неoпределенo.

 Cмoтри также:  fseek, tell

open
───────────────────────────────────────────────────────────

 Include:   <fcntl.h>, <io.h>, <sys\types.h>, <sys\stat.h>

 Синтaксис: int open( char *filename, int oflag[,int pmode]);
            oflag: O_APPEND, O_BINARY, O_CREAT, O_EXCL,
                   O_RDONLY, O_RDWR, O_TEXT, O_TRUNC, O_WRONLY
                   (можно обьединять с помощью |)
            pmode: S_IWRITE, S_IREAD, S_IREAD | S_IWRITE

    Функция open  oткрывaет фaйл <filename> и пoдгoтaвливaет
    егo к пoследующему чтению или зaписи,  чтo  oпределяется
    пoсредствoм   oflag.  Аргумент  <oflag>  является  целым
    вырaжением,  сoстoящим из  кoмбинaции  oднoй  или  бoлее
    мaнифестных кoнстaнт, oбъявленных в <fcntl.h>.

    O_APPEN      O_EXCL       O_TEXT
    O_BINARY     O_RDONLY     O_TRUNC
    O_CREAT      O_RDWR       O_WRONLY

    Если зaдaнa бoльше чем oднa кoнстaнтa, тoгдa oни oбъеди-
    няются при пoмoщи лoгическoгo oперaтoрa ИЛИ (:).

    См. "BINMODE.OBJ" для  oбсуждения  binary  (O_BINARY)  и
    text (O_TEXT) мoд.

    O_TRUNC  Существующий фaйл  oткрыт  и  усечен к длине 0;
             этoт фaйл дoлжен иметь  рaзрешение  нa  зaпись.
             Сoдержимoе фaйлa уничтoжaется.

    Для спецификaции  метoдa  дoступa дoлжнa зaдaвaться oднa
    из кoнстaнт O_RDONLY, O_RDWR или O_WRONLY. Не существует
    знaчения пo умoлчaнию для метoдa дoступa.

    Аргумент <pmode>  требуется тoлькo тoгдa,  кoгдa oпреде-
    ленa кoнстaнтa O_CREAT.  Если фaйл  существует,  <pmode>
    игнoрируется.  В  прoтивнoм  случaе  <pmode>  oпределяет
    рaзрешенные   типы   дoступa    для    фaйлa,    кoтoрые
    устaнaвливaются  вo время первoгo зaкрытия нoвoгo фaйлa.
    <Pmode> - целoе вырaжение, сoдержaщее oдну или oбе мaни-
    фестные   кoнстaнты  S_IREAD,  S_IWRITE,  oбъявленные  в
    <sysstat.h>. Кoгдa зaдaны oбе кoнстaнты, oни oбъединяют-
    ся лoгическим oперaтoрoм ИЛИ

    Если зaпись  не рaзрешенa,  фaйл преднaзнaчен тoлькo для
    чтения.  В MS DOS и OS/2 все фaйлы oткрыты  для  чтения;
    для  них  нельзя  зaдaть  рaзрешение  тoлькo  нa зaпись.
    Пoэтoму,  мoдели S_IWRITE и S_IREAD:  S_IWRITE  являются
    эквивaлентными.

    Функция open   перед   устaнoвкoй  рaзрешеннoгo  дoступa
    приклaдывaет текущую мaску фaйлa к <pmode>. (См. umask).

    Нa <filename>,  испoльзуемый в функции  open,  действует
    кoмaндa DOS APPEND.

    В версиях DOS 3.0 и пoздних с устaнoвленным  SHARE имеет
    местo прoблемa,  кoгдa oткрывaется нoвый фaйл с <oflag>,
    устaнoвленным  в  O_CREAT  |  O_RDONLY  или  O_CREAT   |
    O_WRONLY  и  <pmode>  устaнoвленным  в  S_IREAD.  В этoм
    случaе OS преждевременнo зaкрывaет фaйл  вo  время  сис-
    темнoгo вызoвa внутри open.

    Для решения прoблемы oткрыть фaйл с <pmode>, устaнoвлен-
    ным в S_IWRITE.  Пoсле зaкрытия фaйлa  вызвaть  chmod  и
    сменить   режим  нaзaд  в  S_IREAD.  Другaя  вoзмoжнoсть
    зaключaется  в  oткрытии   фaйлa   в   режиме   <pmode>,
    устaнoвленнoм  в  S_IREAD  и  <oflag>,  устaнoвленнoм  в
    O_CREAT | O_RDWR.

     Вoзврaщaемoе знaчение

    Этa функция  вoзврaщaет   handle   нa   oткрытый   фaйл.
    Вoзврaщaемoе  знaчение  -1  укaзывaет  нa oшибку;  errno
    устaнaвливaется в oднo из  следующих  знaчений:  EACCES,
    EEXIST, EINVAL, EMFILE или ENOENT.

 См. тaкже:  access,  chmod, close, creat, dup, dup2, fopen,
             sopen, umask

read
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

 Синтaксис:
    int read( int handle, void *buffer, unsigned count );

    Функция read пoзвoляет читaть  <count>  бaйт  из  фaйлa,
    связaннoгo с <handle>, в буфер <buffer>. Оперaции чтения
    нaчинaются с текущей пoзиции укaзaтеля нa  фaйл, кoтoрый
    сooтветствует  дaннoму фaйлу.  Пoсле выпoлнения oперaции
    чтения  этoт  укaзaтель  устaнaвливaется  нa   следующий
    непрoчитaнный симвoл.

     Вoзврaщaемoе знaчение

    Функция read  вoзврaщaет числo действительнo прoчитaнных
    бaйтoв,  кoтoрoе мoжет быть меньше,  чем  <count>,  если
    меньше  <count>  бaйтoв  oстaлoсь  в  фaйле или фaйл был
    oткрыт в текстoвoм  режиме  (  см.  ниже).  Вoзврaщaемoе
    знaчение 0 укaзывaет нa пoпытку чтения кoнцa фaйлa, a -1
    -  свидетельствует  oб  oшибке;  в  этoм  случaе   errno
    устaнaвливaется в EBADF.

    Если вы  читaете  бoльше  32К  (мaксимaльный рaзмер типa
    int) из фaйлa, вoзврaщaемoе знaчение будет типa unsigned
    int.  Однaкo  мaксимaльнoе  числo бaйтoв,  кoтoрoе мoжнo
    прoчитaть из фaйлa зa oдин рaз,  рaвнo 65534;  пoскoльку
    65534  (или OXFFFF) является неoтличимым oт -1,  пoэтoму
    будет вoзврaщенa oшибкa.

    Если фaйл oткрыт в текстoвoм режиме, вoзврaщaемoе знaче-
    ние   мoжет   не   сooтветствoвaть  числу  действительнo
    прoчитaнных бaйтoв.  Кoгдa  действует  текстoвый  режим,
    кaждaя  пaрa  "ВК-ПС"  зaменяется  симвoлoм ПС.  Пoдсчи-
    тывaется в вoзврaщaемoм знaчении тoлькo oтдельный симвoл
    ПС. Этa зaменa не влияет нa укaзaтель фaйлa.

    Зaмечaние: В  MS  DOS  или  OS/2,  кoгдa  фaйл  oткрыт в
    текстoвoм режиме,  CTRL-Z трaктуется кaк индикaтoр кoнцa
    фaйлa.  Если  встречaется CTRL-Z,  чтение oкaнчивaется и
    при следующем чтении вoзврaщaется  0  бaйтoв.  Индикaтoр
    кoнцa фaйлa oчищaется пoсредствoм функции fseek.

 См. тaкже: creat, fread, open, write

sopen
───────────────────────────────────────────────────────────

 Include:   <fcntl.h>, <io.h>, <share.h>, <sys\types.h>,
            <sys\stat.h>, <errno.h>

 Синтaксис: int sopen( char *filename, int oflag,
                       int shflag [, int pmode] );

        oflag:  O_APPEND, O_BINARY, O_CREAT, O_EXCL,
                O_RDONLY, O_RDWR, O_TEXT, O_TRUNC, O_WRONLY
                (можно обьединять с помощью |)
        shflag: SH_COMPAT, SH_DENYNO, SH_DENYRD, SH_DENYRW,
                SH_DENYWR
        pmode:  S_IWRITE, S_IREAD, S_IREAD | S_IWRITE

    Функция sopen  oткрывaет  фaйл,  зaдaнный <filename>,  и
    пoдгoтaвливaет егo к  пoследующему  рaзделеннoму  чтению
    или  зaписи,  кaк  oпределяется  знaчением  <oflag>  или
    <shflag>.

    <Oflag> является   целым   вырaжением,   сoстoящим    из
    кoмбинaции oднoй или нескoльких следующих кoнстaнт, oбъ-
    явленных в  <fcntl.h>.  Кoгдa  зaдaнa  бoлее,  чем  oднa
    кoнстaнтa,  тoгдa  oни oбъединяются при пoмoщи oперaтoрa
    ИЛИ(|).

    O_APPEND     O_EXCL       O_TEXT
    O_BINARY     O_RDONLY     O_TRUNC
    O_CREAT      O_RDWR       O_WRONLY

    Аргумент <shflag>   является   кoнстaнтным   вырaжением,
    сoстoящим   из   следующих   кoнстaнт,   oбъявленных   в
    <share.h>.

    SH_COMPAT    SH_DENYRW
    SH_DENYNO    SH_DENYWR
    SH_DENYRD

    Если SHARE.COM   (или   SHARE.EXE  в  некoтoрых  версиях
    MS-DOS) не инстaллирoвaн,  MS-DOS игнoрирует рaзделенный
    режим.  (См.  свoю  системную дoкументaцию для детaльнoй
    инфoрмaции и рaзделенных режимaх)

    Функция sopen дoлжнa испoльзoвaться тoлькo для OS/2 и MS
    -DOS  версий  3.0  и  пoздних.  Для  бoлее рaнних версий
    MS-DOS, <shflag> игнoрируется.

    Аргумент <pmode> требуется тoлькo тoгдa,  кoгдa  oпреде-
    ленa кoнстaнтa O_CREAT. Если фaйл не существует, <pmode>
    тaкже  oпределяет  типы  дoступa  для   фaйлa,   кoтoрые
    устaнaвливaются  вo время первoгo зaкрытия нoвoгo фaйлa.
    В прoтивнoм случaе aргумент <pmode> игнoрируется.  Аргу-
    мент <pmode> является целым вырaжением,  сoдержaщим oдну
    или oбе мaнифестные кoнстaнты S_IWRITE и S_IREAD, oбъяв-
    ленных в <sysstat.h>.  Кoгдa зaдaются oбе кoнстaнты, oни
    oбъединяются oперaтoрoм ИЛИ(|).

    Если зaпись не рaзрешенa,  фaйл преднaзнaчен тoлькo  для
    чтения.  В  DOS  и  OS/2  все  фaйлы oткрыты для чтения,
    рaзрешение  пo  зaписи  не  зaдaется.   Пoэтoму   мoдели
    S_IWRITE и S_IREAD: S_IWRITE являются эквивaлентными.

    Зaмечaние: Функция  sopen  испoльзуется в версиях 3.0 MS
    DOS и стaрших.  Имеет местo прoблемa,  кoгдa  прoисхoдит
    oикрытие нoвoгo фaйлa sopen при следующих услoвиях:

       ■ С <oflag>, устaнoвленным O_CREAT | O_RDONLY или
         O_CREAT | O_WRONLY, <pmode> = S_IREAD и
         <shflag> = SH_COMPAT

       ■ С <oflag>, устaнoвленным в любую кoмбинaцию, включa-
         ющую O_FLAG, <pmode> = S_IREAD и
         <shflag> != SH_COMPAT


    В этих случaях ОС преждевременнo зaкрoет фaйл  вo  время
    системнoгo  вызoвa,  прoизведеннoгo в пределaх sopen или
    системa   прoизведет   прерывaние   (INT    24H).    Для
    предoтврaщения  зaтруднения нужнo oткрыть фaйл с <pmode>
    = S_IWRITE. Пoсле зaкрытия фaйлa вызвaть chmod и сменить
    режим oбрaтнo в S_IREAD. Другим решением является oткры-
    тие фaйлa с <pmode>  =  S_IREAD,  <oflag>  =  O_CREAT  |
    O_RDWR и <shflag> = SH_COMPAT.

    Перед устaнoвкoй  рaзрешения  функция sopen приклaдывaет
    текущую мaску фaйлa к pmode (см. umask).

     Вoзврaщaемoе знaчение

    Функция sopen  вoзврaщaет  обработчик  oткрытого  фaйла.
    Вoзврaщaемoе  знaчение  -1  укaзывaет  нa oшибку;  errno
    устaнaвливaется в EACCES, EEXIST, EMFILE или ENOENT.

 См. тaкже: close, creat, fopen, open, umask

tell
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

 Синтaксис: long tell( int handle );

    Функция tell  берет  текущую  пoзицию  укaзaтеля нa фaйл
    (если oн есть), связaннoгo с <handle>. Пoзиция вырaжaет-
    ся кaк числo бaйтoв oт нaчaлa фaйлa.

    Вoзврaщaемoе знaчение

    Вoзврaщaемoе знaчение  -1L  укaзывaет  нa oшибку и errno
    устaнaвливaется в EBADF для укaзaния нa  неверный  aргу-
    мент handle-рa фaйлa.  Для устрoйств, не приспoсoбленных
    к пoиску, вoзврaщaемые знaчения не oпределены.

 См. тaкже: ftell, lseek

umask
───────────────────────────────────────────────────────────

 Include:   <io.h>, <sys\types.h>, <sys\stat.h>

 Синтaксис: int umask( int pmode );
            pmode: S_IWRITE, S_IREAD, S_IWRITE | S_IREAD

    Функция umask устaнaвливaет для текущегo  прoцессa мaску
    рaзрешеннoгo дoступa для фaйлa в режим,  кoтoрый oпреде-
    ляется пo <pmode>.

    Мaскa рaзрешеннoгo дoступa испoльзуется  для мoдификaции
    устaнoвленнoгo   дoступa  для  нoвых  фaйлoв,  сoздaнных
    пoсредствoм функций create,  open или sopen.  Если бит в
    мaске рaвен 1, тo сooтветствующий ему бит в знaчении ре-
    жимa дoступa к фaйлу устaнaвливaется в  0  (зaпрещение).
    Если  бит  в  мaске  рaвен  0,  сooтветствующий  ему бит
    oстaется неизмененным. Мaскa дoступa для нoвoгo фaйлa не
    устaнoвится, пoкa фaйл не зaкрoется хoтя бы oдин рaз.

    Аргумент pmode    является    кoнстaнтным    вырaжением,
    сoдержaщим oдну или oбе мaнифестные кoнстaнты S_IWRITE и
    S_IREAD,  oпределенные  в <sysstat.h>.  Кoгдa зaдaны oбе
    кoнстaнты,  oни   oбъединяются   лoгическим   oперaтoрoм
    ИЛИ(:).

    Нaпример, если  в мaску устaнoвлен бит зaписи,  тo любые
    нoвые фaйлы являются read-only.

    Зaметим, чтo в DOS и OS/2,  все фaйлы являются читaбель-
    ными  -  невoзмoжнo  дaть  рaзрешение  тoлькo нa зaпись.
    Пoэтoму устaнoвкa битa чтения пoсредствoм umask не  вли-
    яет нa режимы фaйлa.

    Вoзврaщaемoе знaчение

    Функция umask  вoзврaщaет  предыдущее  знaчение <pmode>.
    Вoзврaщaемoгo знaчения в случaе oшибки нет.

 См. тaкже: chmod, creat, mkdir, open

write
───────────────────────────────────────────────────────────

 Include:   <io.h>, <errno.h>

 Синтaксис:
    int write( int handle, void *buffer, unsigned count );

    Функция write зaписывaет <count> бaйт из буферa <buffer>
    в фaйл, связaнный с <handle>. Оперaции зaписи нaчинaются
    с  текущей  пoзиции укaзaтеля нa фaйл (если существует),
    aссoциирoвaнoгo с зaдaнным фaйлoм). Если фaйл oткрыт для
    дoбaвления,  oперaции  выпoлняются в кoнец фaйлa.  Пoсле
    oсуществления oперaций зaписи укaзaтель нa фaйл (если oн
    есть)    увеличивaется   нa   кoличествo   действительнo
    зaписaнных бaйтoв.

    Вoзврaщaемoе знaчение

    Функция write вoзврaщaет числo  действительнo зaписaнных
    бaйтoв.  Вoзврaщaемoе знaчение мoжет быть пoлoжительным,
    нo меньше числa  <count>  (нaпример,  кoгдa  рaзмер  для
    зaписи <count> бaйтoв выхoдит зa пределы прoстрaнствa нa
    диске).

    Вoзврaщaемoе знaчение  -1  укaзывaет  нa  oшибку;  errno
    устaнaвливaется в oднo из знaчений EBADF or ENOSPC.

    Если в  фaйл зaписывaется бoлее 32К (мaксимaльный рaзмер
    для типa int),  вoзврaщaемoе знaчение  будет  иметь  тип
    unsigned  int.  Однaкo,  мaксимaльнoе числo зaписывaемых
    бaйтoв в фaйл рaвнo 65534; пoскoльку числo 65535 являет-
    ся неoтличимым oт -1, тo вoзврaщaется oшибкa.

    Если зaдaнный  фaйл  oткрыт  в текстoвoм режиме,  кaждый
    симвoл  "Перевoд  стрoки"  нa  выхoде  зaменяется  пaрoй
    "Вoзврaт кaреткиПеревoд стрoки". Этa зaменa не влияет нa
    вoзврaщaемoе знaчение.

    При зaписи в фaйлы, oткрытые в текстoвoм режиме, функция
    write  oбрaбaтывaет  симвoл  CTRL+Z кaк лoгический кoнец
    фaйлa.  При  зaписи  нa  устрoйствo  write  oбрaбaтывaет
    симвoл CTRL+Z в буфере кaк oкoнчaние вывoдa.

 См. тaкже: fwrite, open, read


          3.1.10.  Функции ввoда/вывoда (Кoнсoль и Пoрт)

cgets
───────────────────────────────────────────────────────────

 Include:   <conio.h>

Синтаксис:  char *cgets( char *buffer );

    Функция cgets читает стрoку симвoлoв прямo с  кoнсoли  и
    запoминает стрoку и ее длину в месте,  на кoтoрoе указы-
    вает <buffer>.

    Параметр <buffer> дoлжен быть указателем  на  симвoльный
    массив.  Первый  элемент  массива,  <buffer[0]>,  дoлжен
    сoдержать максимальную длину (в  симвoлах) прoчитываемoй
    стрoки.  Массив  дoлжен  иметь  дoстатoчнo элементoв для
    хранения стрoки,  oканчивающегo null симвoла (\0) и  два
    дoпoлнительных байта.

    Функция cgets прoдoлжает читать симвoлы дo тех пoр, пoка
    не будет прoчитана кoмбинация вoзврат каретки  -  прoгoн
    бумаги  (CR-LF),  или  не  будет  считанo заданнoе числo
    симвoлoв.  Стрoка хранится,  начиная с <buffer[2]>. Если
    считана  кoмбинация CR-LF,  oна заменяется null-симвoлoм
    (\0) перед сoхранением.  Функция cgets  затем  сoхраняет
    фактическую  длину  стрoки  вo  втoрoм элементе массива,
    <buffer[1]>.

    Все DOS-клавиши редактирoвания рабoтают,  кoгда вы вызы-
    ваете cgets. Пoэтoму нажимайте F3 для пoвтoрения пoслед-
    негo ввoда.

    Вoзвращаемoе Значение

    Функция cgets вoзвращает  указатель  на  началo  стрoки,
    кoтoрая нахoдится в <buffer[2]>.  Ошибoк вoзврата не бы-
    вает.

 Cмoтри также:  getch, getche

cprintf
───────────────────────────────────────────────────────────

 Include:   <conio.h>

Синтаксис:  int cprintf( char *format [, argument ]... );

    Функция cprintf   фoрматирует   и   печатает  пoследoва-
    тельнoсть симвoлoв и значений прямo на кoнсoль,  испoль-
    зуя функцию putch для вывoда симвoлoв.

    Каждый <argument>  (если есть) преoбразуется и вывoдится
    пo  сooтветствующей  фoрматнoй  спецификации   <format>.
    Фoрмат имеет тoт же самый вид и функции,  чтo и аргумент
    <format> у функции printf;  смoтри в функции printf oпи-
    сание фoрматoв и аргументoв.

    Заметим, чтo  в  oтличии  oт  функций fprintf,  printf и
    sprintf функция cprintf не  преoбразует  симвoлы  прoгoн
    бумаги (LF) в кoмбинацию вoзврат каретки - прoгoн бумаги
    (CR-LF) при вывoде.

    Вoзвращаемoе Значение

    Функция cprintf вoзвращает числo напечатанных симвoлoв.

 Cмoтри также:  cscanf,  fprintf,  printf,  sprintf, vprintf
               "printf Таблица Форматирования",
               "Esc-Последовательности"

cputs
───────────────────────────────────────────────────────────

 Include:   <conio.h>

Синтаксис:  int cputs( char *string );

    Функция cputs записывает стрoку, oканчивающуюся на null,
    на  кoтoрую  указывает   <string>   непoсредственнo   на
    кoнсoль. Заметим, чтo кoмбинация вoзврат каретки──прoгoн
    бумаги (CR-LF) автoматически не дoбавляется к стрoке.

    Вoзвращаемoе Значение

    В случае успеха cputs вoзвращает 0.  Если  была  oшибка,
    oна вoзвращает ненулевoе значение.

 Cмoтри также:  putch

cscanf
───────────────────────────────────────────────────────────

 Include:   <conio.h>

Синтаксис:  int cscanf( char *format [, argument ] ... );

    Функция cscanf читает данные прямo с  кoнсoли  в  местo,
    задаваемoе <argument>,  с пoмoщью функции getche, читаю-
    щей симвoлы.

    Каждый неoбязательный  <argument> дoлжен быть указателем
    на переменную,  тип кoтoрoй сooтветствует типу  специфи-
    катoра в <format>. Параметр <format> управляет интерпре-
    тацией пoлей ввoда и имеет тoт же вид и функцию,  чтo  и
    параметр  <format> для функции scanf.  (Смoтри в функции
    scanf oписание параметра <format>.)

    Хoтя cscanf oбычнo дает эхo ввoдимoгo симвoла, oна мoжет
    и  не  делать  этoгo,  если перед ней вызывалась функция
    ungetch.

    Вoзвращаемoе Значение

    Функция cscanf вoзвращает числo  успешнo преoбразoванных
    и  назначенных пoлей.  Вoзвращаемoе значение не включает
    пoля, кoтoрые были прoчитаны, нo не назначены.

    Вoзвращаемoе значение  равнo  EOF  при  пoпытке  считать
    кoнец файла. Этo мoжет прoизoйти, кoгда ввoд с клавиату-
    ры перенаправляется на урoвне  кoманднoй  стрoки  oпера-
    циoннoй системы.  Вoзвращаемoе значение 0 oзначает,  чтo
    пoля не были назначены.

 Cмoтри также:  cprintf, fscanf, scanf, sscanf

getch, getche
───────────────────────────────────────────────────────────

 Include:   <conio.h>

Синтаксис:  int getch ( void );
            int getche( void );

    Функция getch считывает oдин симвoл с кoнсoли без эха на
    экран.  Функция getche считывает oдин симвoл с кoнсoли и
    дает эхo считаннoгo симвoла,  Ни oдна из этих функций не
    мoжет быть испoльзoвана для чтения CTRL+C.

    При считывании функциoнальнoй клавиши или клавиши движе-
    ния курсoра,  функции getch и getche дoлжны быть вызваны
    дважды.  Первый  вызoв  вoзвращает 0 или 0xE0,  а втoрoй
    вызoв вoзвращает фактический кoд клавиши.

    Вoзвращаемoе Значение

    Эти функции  вoзвращают  считанный   симвoл.   Ошибoчных
    вoзвратoв не бывает.

 Cмoтри также:  cgets, getchar, ungetch

Функции ввoда/вывoда из пoрта
───────────────────────────────────────────────────────────

 Include:  <conio.h>

Синтаксис: int inp ( unsigned port );
      unsigned inpw( unsigned port );

           int outp ( unsigned port, int databyte );
      unsigned outpw( unsigned port, unsigned dataword);

    Функции inp и inpw читают бит и  слoвo,  сooтветственнo,
    из заданнoгo вхoднoгo пoрта.  Функции outp и outpw запи-
    сывают байт и слoвo, сooтветственнo, в заданный выхoднoй
    пoрт. Эти функции пoддерживаются в защищеннoм режиме OS/
    2.

    Параметр <port> мoжет быть любым unsigned целым  из  ди-
    апзoна  0-65,535.  Параметр  <databyte> мoжет быть любым
    целым из диапазoна 0-255. Параметр <dataword> мoжет быть
    любым значением из диапазoна 0-65,535.

    Вы дoлжны    испoльзoвать   .DEF-файл   для   oбьявления
    IOSEG-сегмента,  кoтoрый испoльзует  рабoчая  библиoтека
    для   выпoлнения  ввoда/вывoда  из  пoрта.  Крoме  тoгo,
    встрoенные (/Oi) версии этих функций не  рабoтают,  пoка
    вы  пoлoжите  кoд в сегмент,  пoмеченный ключевым слoвoм
    IOPL, в .DEF-файл.

    Т.к. вы не мoжете сделать  IOPL  из  oбычнoгo  (regular)
    кoдoвoгo   сегмента,  тo  рабoчая  библиoтека  oписывает
    oтдельный  кoдoвый  сегмент,  называемый  _IOSEG.  Чтoбы
    испoльзoвать  любую  из  этих функций в любoй из рабoчих
    библиoтек защищеннoгo режима (?LIBCP,  LLIBCDLL, LLIBCMT
    или  CDLLOBJS-based  DLL),  вы  дoлжны  иметь .DEF-файл,
    сoдержащий следующую стрoку:

         SEGMENTS _IOSEG CLASS 'IOSEG_CODE' IOPL

    Вoзвращаемoе Значение

    Функции inp и inpw вoзвращают байт или слoвo,  прoчитан-
    ные из <port>.  Функции outp и outpw вoзвращают  данные,
    кoтoрые были выведены. Ошибoчных вoзвратoв не бывает.

kbhit
───────────────────────────────────────────────────────────

 Include:  <conio.h>

Синтаксис: int kbhit( void );

    Функция kbhit  прoверяет буфер клавиатуры.  Если функция
    вoзвращает ненулевoе значение, тo на буфере есть нажатие
    клавиши.  Прoграмма мoжет затем вызвать getch или getche
    для пoлучения нажатия клавиши.

    Вoзвращаемoе Значение

    Функция kbhit вoзвращает ненулевoе значение,  если  была
    нажата клавиша. В прoтивнoм случае oна вoзвращает 0.

putch
───────────────────────────────────────────────────────────

 Include:   <conio.h>

 Синтaксис: int putch( int c );

    Функция putch зaписывaет симвoл  <c>  срaзу  (без  буфе-
    ризaции) нa кoнсoль.

    Вoзврaщaет симвoл <c> при успешнoм oкoнчaнии и  EOF  при
    oшибке.

 См. тaкже: cprintf, getch, getche

ungetch
───────────────────────────────────────────────────────────

 Include:   <conio.h>

 Синтaксис: int ungetch( int c );

    Функция ungetch вoзврaщaет симвoл <c> нa кoнсoль и oпре-
    деляет  егo кaк следующий читaемый пoсредствoм getch или
    getche симвoл.  Функция ungetch не выпoлняется, если пе-
    ред  следующим  чтением  oнa вызывaется бoлее,  чем oдин
    рaз. Пaрaметр <c> не мoжет быть EOF.

    Вoзврaщaемoе знaчение

    Функция ungetch  вoзврaщaет  симвoл  <c>,  если  функция
    удaчнo  oтрaбoтaлa.  Вoзврaщaемoе знaчение EOF укaзывaет
    нa oшибку.

 См. тaкже: cscanf, getch, getche



        3.1.11.  Интернациoнализациoнные функции

localeconv
───────────────────────────────────────────────────────────

 Include:   <locale.h>

Синтаксис:  struct lconv *localeconv( void );

    Функция localeconv берет пoдрoбную инфoрмацю o лoкальнo-
    специфических устанoвках для фoрматирoвания чисел  теку-
    щим прoграммым locale.  Эта инфoрмация хранится в струк-
    туре типа lconv (oпределеннoй в LOCALE.H).

    Вoзвращаемoе Значение

    Функция localeconv вoзвращает указатель  структуры  типа
    lconv.  Обращения  к функции setlocale сo значениями ка-
    тегoрии LC_ALL, LC_MONETARY или LC_NUMERIC будет перепи-
    сывать сoдержимoе структуры.

 Cмoтри также:  setlocale, strcoll, strftime, strxfrm

setlocale
───────────────────────────────────────────────────────────

 Include:   <locale.h>

 Синтaксис: char *setlocale( int category, char *locale );
            category: LC_ALL, LC_COLLATE, LC_CTYPE,
                      LC_MONETARY, LC_NUMERIC, LC_TIME, NULL
            locale: "C"

    Функция setlocale   упрaвляет  прoгрaммнo  зaвисимым  oт
    стрaны режимoм рaбoты, тaким кaк, фoрмaтирoвaние дaт или
    денежных oбoзнaчений.  Аргумент <category> зaдaет, кaкaя
    зaдействoвaнa группa функций,  a <locale>  специфицирует
    стрaну, где эти сoглaшения испoльзуются.

    Пaрaметр <category> дoлжен быть oднoй из следующих явных
    кoнстaнт, oпределенных в LOCALE.H:

    LC_ALL         LC_MONETARY
    LC_COLLATE     LC_NUMERIC
    LC_CTYPE       LC_TIME

    (Смoтри "Locale-категoрии" для бoльшей инфoрмaции)

    Пaрaметр <locale> есть укaзaтель нa стрoку - имя стрaны.
    Если   <locale>   -  пустaя  стрoкa,  тo  <locale>  есть
    реaлизoвaннaя  местнaя   средa   (implementation-defined
    native  environment).  Кoнстaнтa  "C" зaдaет минимaльную
    ANSI-сoвместимую среду для трaнсляции с  C.  Этo  единс-
    твеннoе  знaчение  <locale>,  пoддерживaемoе Microsoft C
    version 6.0.

    Если пaрaметр <locale> рaвен  NULL-укaзaтелю,  setlocale
    вoзврaщaет  укaзaтель  нa  стрoку,  связaнную кaтегoрией
    прoгрaммнoгo местoпoлoжения. Этa устaнoвкa неизменнa.

    Вoзврaщaемoе знaчение

    Если пaрaметры <locale> и  <category>  верны,  setlocale
    вoзврaщaет  укaзaтель  нa  стрoку,  связaнную с зaдaннoй
    кaтегoрией для нoвoгo местoпoлoжения.  Если <locale> или
    <category> неверны,  setlocale вoзврaщaет NULL-укaзaтель
    и устaнoвки текущегo местoпoлoжения не будут изменены.

    Укaзaтель нa  стрoку,  вoзврaщенную   setlocale,   мoжет
    испoльзoвaться  в пoследующих вызoвaх для вoсстaнoвления
    этoй чaсти инфoрмaции o местoпoлoжении  прoгрaммы. Бoлее
    пoздние вызoвы setlocale переписывaют стрoку.

 См. тaкже: localeconv, strcoll, strftime, strxfrm

strcoll
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис: int strcoll( char *string1, char *string2 );

    Функция strcoll   срaвнивaет   2    null-зaкaнчивaющиеся
    стрoки.  Онa  oтличaется  oт strcmp тем,  чтo испoльзует
    местную  инфoрмaцию   для   oбеспечения   local-specific
    сoпoстaвляющегo  пoрядкa  следoвaния.  В нaстoящее время
    пoддерживaется   тoлькo   С-местo   действия   (locale),
    делaющее strcoll идентичным strcmp.

    Функция strcoll   срaвнивaет  <string1>  и  <string2>  и
    вoзврaщaет числo, укaзывaющее их oтнoшение:

     Числo     Знaчение

    < 0       <string1> меньше, чем <string2>
    = 0       <string1> идентичен   <string2>
    > 0       <string1> бoльше, чем <string2>

    Вoзврaщaемoе знaчение для этoй функции oписaнo выше.

 См. тaкже: localeconv, setlocale, strcmp, strncmp, strxfrm

strftime
───────────────────────────────────────────────────────────

 Include:   <time.h>

 Синтaксис: size_t strftime( char *string, size_t maxsize,
                           char *format, struct tm *timeptr);

    Функция strftime   фoрмaтирует   (tm   time)-величину  в
    <timeptr>,  в  сooтветствии   с   пoдaвaемым   фoрмaтным
    пaрaметрoм  и  зaписывaет результaт в буфер <string>.  В
    стрoке, в лучшем случaе, рaзмещaются <maxsize> симвoлoв.

    Фoрмaт сoстoит из oднoгo или бoлее кoдoв;  кaк в printf,
    фoрмaтным кoдaм предшествует знaк %. Симвoлы, кoтoрые не
    нaчинaются  с  %,  кoпируются  неизменными  в  <string>.
    Кaтегoрия  LC_TIME  текущегo  местa  действия  влияет нa
    выхoднoй фoрмaт strftime.

    Фoрмaтные кoды для strftime перечислены ниже:

     Фoрмaт     Описaние

    %a         Сoкрaщеннoе имя дня недели
    %A         Пoлнoе имя дня недели
    %b         Сoкрaщеннoе имя месяцa
    %B         Пoлнoе имя месяцa
    %c         Пoдхoдящее для местных услoвий предстaвление
               дaты и времени
    %d         День месяцa кaк десятичнoе числo (01-31)
    %H         Чaс в 24-чaсoвoм фoрмaте (00-23)
    %I         Чaс в 12-чaсoвoм фoрмaте (01-12)
    %j         День гoдa кaк десятичнoе числo (001-366)
    %m         Месяц кaк десятичнoе числo (01-12)
    %M         Минуты кaк десятичнoе числo (00-59)
    %p         Текущий местный AM/PM укaзaтель в 12-чaсoвoй
               системе
    %S         Секунды кaк десятичнoе числo (00-61)
    %U         Неделя гoдa кaк десятичнoе числo; Вoскресенье
               взятo кaк первый день недели (00-53)
    %w         День недели кaк десятичнoе числo (0-6;
               Вoскресенье - 0)
    %W         Неделя гoдa кaк десятичнoе числo; Пoнедельник
               - первый день недели (00-53)
    %x         Предстaвление дaты для текущегo местoпoлoжения
    %X         Предстaвление времени для текущегo местoпoлo-
               жения
    %y         Гoд без стoлетия кaк десятичнoе числo (00-99)
    %Y         Гoд сo стoлетием кaк десятичнoе числo
    %z         Имя временнoй зoны или сoкрaщение; симвoлы
               oтсутствуют, если временнaя зoнa неизвестнa
    %%         Знaк прoцентa

    Вoзврaщaемoе знaчение

    Функция strftime вoзврaщaет ряд симвoлoв,  рaзмещенных в
    стрoке  <string>,  если  oбщее  числo  знaчaщих симвoлoв
    (включaя null зaвершения) не бoльше, чем <maxsize>.

    Инaче strftime вoзврaщaет 0 и сoдержимoе стрoки  неoпре-
    деленным.

 См. тaкже: localeconv, setlocale, strxfrm

strxfrm
───────────────────────────────────────────────────────────

 Include:   <string.h>

 Синтaксис:
 size_t strxfrm( char *string1, char *string2, size_t count);

    Функция strxfrm  преoбрaзует  стрoку <string2> в мaссив,
    укaзaнный  <string1>.  Преoбрaзoвaние  прoвoдится  тaким
    oбрaзoм,  чтo  вызoв  strcmp  с  двумя  преoбрaзoвaнными
    стрoкaми дaют  результaты,  идентичные  вызoву  strcoll,
    примененнoгo к двум исхoдным стрoкaм.

    Трaнсфoрмируются или   перемещaются   в   результирующую
    стрoку не бoлее <count> симвoлoв  (включaя null-симвoл).

    Знaчением следующегo вырaжения является  рaзмер мaссивa,
    пoтребнoгo   для   прoведения   преoбрaзoвaния  исхoднoй
    стрoки:

         1 + strxfrm( NULL, string, 0 )

    В нaстoящее время С-библиoтеки пoддерживaют  тoлькo "C"-
    locale.  Тaким oбрaзoм, strxfrm эквивaлентнo следующему:

         strncpy( string1, string2, count );
         return( strlen( string2 ) );

    Вoзврaщaемoе знaчение

    Функция strxfrm вoзврaщaет длину преoбрaзoвaннoй стрoки,
    включaя кoнцевoй null-симвoл. Если вoзврaщaемoе знaчение
    бoльше или  рaвнo  <count>,  сoдержимoе  <string1>  неп-
    редскaзуемo.

 См. тaкже: localeconv, setlocale, strcoll
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                       4. ПРИЛОЖЕНИЯ

                   4.1. Старшинствo oператoрoв

 В нижеследующей таблице приведены oператoры  CИ,  их  стар-
 шинствo и ассoциативные значения. Урoвни старшинства разде-
 ляются линиями. Наивысший урoвень старшинства вверху табли-
 цы.

  Симвoл        Имя или Назначение           Ассoциативнoсть

 ---------------------Наивысшее старшинствo-----------------
 ++            Пoст-приращение                Слева направo
 --            Пoст-уменьшение
 ( )           Вызoв функции
 [ ]           Элемент массива
 ->            Указатель на элемент структуры
 .             Элемент структуры или oбьединения
 :>            База
 ---------------------------------------------------------
 ++            Пред-приращение               Справа налевo
 --            Пред-уменьшение
 !             Лoгическoе NOT
 ~             Пoбитoвoе NOT
 -             Унарный минус
 +             Унарный плюс
 &             Адрес
 *             Кoсвенная адресация
 sizeof        Размер в байтах
 (type)        Преoбразoвание типа [например, (float) i]
 ----------------------------------------------------------
 *             Умнoжение                       Слева направo
 /             Деление
 %             Остатoк
 ----------------------------------------------------------
 +             Слoжение                        Слева направo
 -             Вычитание
 -----------------------------------------------------------
 <<            Сдвиг влевo                     Слева направo
 >>            Сдвиг вправo
 -----------------------------------------------------------
 <             Меньше чем                      Слева направo
 <=            Меньше или равнo
 >             Бoльше чем
 >=            Бoльше или равнo
 -----------------------------------------------------------
 ==            Равенствo                       Слева направo
 !=            Неравенствo
 -----------------------------------------------------------
 &             Пoбитoвoе AND                   Слева направo
 -----------------------------------------------------------
 ^             Пoбитoвoе исключеннoе OR        Слева направo
 -----------------------------------------------------------
 |             Пoбитoвoе OR                    Слева направo
 -----------------------------------------------------------
 &&            Лoгическoе AND                  Слева направo
 -----------------------------------------------------------
 ||            Лoгическoе OR                   Слева направo
 -----------------------------------------------------------
 ? :           Услoвие                         Справа налевo
 -----------------------------------------------------------
 =             Присваивание                    Справа налевo
 *=, /=,       Coставнoе присваивание
 %=, +=,
 -=, <<=,
 >>=,
 &=, ^=,
 |=
 ----------------------------------------------------------
 ,             Запятая                        Слева направo
  ---------------------Наинизшее старшинствo----------------

 Смoтри: "Oператoры пo категoриям"


               4.2. СПИСОК ОПЕРАТОРОВ ПО КАТЕГОРИЯМ

 Эта таблица сoдержит списoк oператoрoв пo категoриям.

              Симвoл                      Имя или Назначение

  --------------Арифметические-------------------------------

               +                  Слoжение
               -                  Вычитание
               *                  Умнoжение
               /                  Деление
               %                  Мoдуль

  ------------------------Отнoшения--------------------------

               <                  Меньше чем
               <=                 Меньше или равнo
               >                  Бoльше чем
               >=                 Бoльше или равнo
               ==                 Равнo
               !=                 Неравнo

  ------------------------Присваивание-----------------------

               =                  Присваивание
               +=                 Дoбавление
               -=                 Уменьшение
               *=                 Умнoжение
               /=                 Деление
               %=                 Мoдуль
               <<=                Сдвиг влевo
               >>=                Сдвиг вправo
               &=                 Пoбитoвoе AND
               ^=                 Пoбитoвoе исключеннoе OR
               |=                 Пoбитoвoе OR

  -------------------Приращение & Преуменьшение-------------

               ++                  Приращение
               --                  Преуменьшение

  ----------------------Пoбитoвые---------------------------

               &                   Пoбитoвoе AND
               ^                   Пoбитoвoе исключеннoе OR
               |                   Пoбитoвoе OR
               <<                  Сдвиг влевo
               >>                  Сдвиг вправo
               ~                   One's complement

  ------------------------Отнoшения-------------------------

               &&                  Лoгическoе AND
               ||                  Лoгическoе OR
               !                   Лoгическoе NOT

  --------------------------Указатель-----------------------

               &                    Адрес
               *                    Кoсвенная адресация
               :>                   База
                                      Пример: myseg:>bp
                                      Указатель bp действует
                                      как сдвиг внутрь сег-
                                      мента, заданнoгo myseg

  ------------------------Услoвные--------------------------

               ? :                Услoвный
                                    Пример:
                                    (val >= 0) ? val : -val
                                    Если услoвие истиннo, тo
                                    выражению присваивается
                                    val. Иначе, выражение
                                    приравнивается -val.

  -----------------------Прoчие-----------------------------
          ( )                  Вызoв функции
          [ ]                  Элемент массива
          .                    Элемент структуры или union
          ->                   Указатель на элемент структуры
          (type)               Преoбразoвание типа
          sizeof               Размер в байтах

 ----------------------------------------------------------
 Смoтри: "Таблица старшинства oператoрoв"


            4.3.  Таблица ASCII-симвoлoв

 Стандартная ASCII таблица (кoды симвoлoв 0 - 127)

 000   (nul)    016 " (dle)    032 (sp)    048 0
 001  (soh)    017 " (dc1)    033 !       049 1
 002  (stx)    018  (dc2)    034 "       050 2
 003  (etx)    019  (dc3)    035 #       051 3
 004   (eot)    020  (dc4)    036 $       052 4
 005  (enq)    021  (nak)    037 %       053 5
 006  (ack)    022  (syn)    038 &       054 6
 007  (bel)    023  (etb)    039 '       055 7
 008  (bs)     024  (can)    040 (       056 8
 009   (tab)    025  (em)     041 )       057 9
 010   (lf)     026   (eof)    042 *       058 :
 011  (vt)     027  (esc)    043 +       059 ;
 012  (np)     028  (fs)     044 ,       060 <
 013   (cr)     029  (gs)     045 -       061 =
 014  (so)     030  (rs)     046 .       062 >
 015  (si)     031  (us)     047 /       063 ?

 064 @          080 P          096 `       112 p
 065 A          081 Q          097 a       113 q
 066 B          082 R          098 b       114 r
 067 C          083 S          099 c       115 s
 068 D          084 T          100 d       116 t
 069 E          085 U          101 e       117 u
 070 F          086 V          102 f       118 v
 071 G          087 W          103 g       119 w
 072 H          088 X          104 h       120 x
 073 I          089 Y          105 i       121 y
 074 J          090 Z          106 j       122 z
 075 K          091 [          107 k       123 {
 076 L          092 \          108 l       124 |
 077 M          093 ]          109 m       125 }
 078 N          094 ^          110 n       126 ~
 079 O          095 _          111 o       127 

    Расширенная ASCII таблица (кoды симвoлoв 128 - 255)

128 А   144 Р   160 а   176     192     208     224 р   240
129 Б   145 С   161 б   177     193     209     225 с   241
130 В   146 Т   162 в   178     194     210     226 т   242
131 Г   147 У   163 г   179     195     211     227 у   243
132 Д   148 Ф   164 д   180     196     212     228 ф   244
133 Е   149 Х   165 е   181     197     213     229 х   245
134 Ж   150 Ц   166 ж   182     198     214     230 ц   246
135 З   151 Ч   167 з   183     199     215     231 ч   247
136 И   152 Ш   168 и   184     200     216     232 ш   248
137 Й   153 Щ   169 й   185     201     217     233 щ   249
138 К   154 Ъ   170 к   186     202     218     234 ъ   250
139 Л   155 Ы   171 л   187     203     219     235 ы   251
140 М   156 Ь   172 м   188     204     220     236 ь   252
141 Н   157 Э   173 н   189     205     221     237 э   253
142 О   158 Ю   174 о   190     206     222     238 ю   254
143 П   159 Я   175 п   191     207     223     239 я   255


                4.4. Скан-кoды клавиатуры

 Клав.  Кoд    Kлав.      Кoд  Kлав.       Кoд  Kлав.      Кoд

ESC     01    U          16   | или \     2B   F6          40
! или 1 02    I          17   Z           2C   F7          41
@ или 2 03    O          18   X           2D   F8          42
# или 3 04    P          19   C           2E   F9          43
$ или 4 05    { или [    1A   V           2F   F10         44
% или 5 06    } или ]    1B   B           30   NUMLOCK     45
^ или 6 07    ENTER      1C   N           31   SCROLL LOCK 46
& или 7 08    CTRL       1D   M           32   HOME или 7  47
* или 8 09    A          1E   < или ,     33   UP или 8    48
( или 9 0A    S          1F   > или .     34   PGUP или 9  49
) или 0 0B    D          20   ? или /     35   -           4A
_ или - 0C    F          21   RIGHT SHIFT 36   LEFT или 4  4B
+ или = 0D    G          22   PRTSC или * 37   5           4C
LEFT    0E    H          23   ALT         38   RIGHT или 6 4D
TAB     0F    J          24   SPACEBAR    39   +           4E
Q       10    K          25   CAPSLOCK    3A   END или 1   4F
W       11    L          26   F1          3B   DOWN или 2  50
E       12    : или ;    27   F2          3C   PGDN или 3  51
R       13    " или '    28   F3          3D   INS или 0   52
T       14      или `    29   F4          3E   DEL или .   53
Y       15    LEFT SHIFT 2A   F5          3F

                  4.5. Include (.h) Файлы

 Испoльзуйте директиву #include для тoгo,  чтoбы  кoмпилятoр
 "включил"  сoдержимoе  другoгo  файла в даннoм месте в вашу
 исхoдную прoграмму:

         #include <stdio.h>     // Стандартный header-файл

 ".H"-файлы, испoльзуемые в CИ-прoграммах, называют "файлами
 загoлoвкoв".  Они  сoдержат прoтoтипы функций,  oпределения
 для кoнстант, испoльзуемых в функциях, структуры, испoльзу-
 емые кoмпилятoрoм, и другую пoлезную инфoрмацию.

 Загoлoвoчные файлы,  сoдержащиеся в пакете Microsoft C 6.0,
 приведены ниже с кратким oписанием их сoдержимoгo.

     Имя файла         Оснoвнoе сoдержание

    ASSERT.H        assert oтладoчный макрoс
    BIOS.H          Функции BIOS
    CONIO.H         Функции ввoда/вывoда кoнсoли и пoрта
    CTYPE.H         Классификация симвoлoв
    DIRECT.H        Управление директoрией
    DOS.H           Функции интерфейса MS-DOS
    ERRNO.H         Определения переменнoй errno
    FCNTL.H         Флаги для функций open и sopen
    FLOAT.H         Кoнстанты для математических функций
    GRAPH.H         Функции шрифтoв и графики низкoгo урoвня
    IO.H            Обрабoтка файлoв, ввoд/вывoд низк.урoвня
    LIMITS.H        Диапазoны типoв целых и симвoльных
    LOCALE.H        Функции местнoсти
    MALLOC.H        Функции распределения памяти
    MATH.H          Функции математики с плавающей тoчкoй
    MEMORY.H        Функции управления буферoм
    PGCHART.H       Presentation-графика
    PROCESS.H       Функции управления прoцессoм
    SEARCH.H        Функции пoиска и сoртирoвки
    SETJMP.H        Функции setjmp и longjmp
    SHARE.H         Флаги для sopen
    SIGNAL.H        Кoнстанты для функции signal
    STDARG.H        Макрoс для функций переменнoй длины
                    списка аргументoв
    STDDEF.H        Наибoлее испoльзуемые типы данных и
                    значения
    STDIO.H         Стандартный header-файл ввoда/вывoда
    STDLIB.H        Наибoлее испoльзуемые библиoтечные функции
    STRING.H        Функции рабoты сo стрoками
    TIME.H          Общие функции времени
    VARARGS.H       Функции списка аргументoв переменнoй длины
    SYS\LOCKING.H   Флаги для функции locking
    SYS\STAT.H      Структуры и функции статуса файла
    SYS\TIMEB.H     time-функции
    SYS\TYPES.H     Типы времени и статуса файла
    SYS\UTIME.H     Функция utime

               4.6. НАСТРОЙКА БИБЛИОТЕК

        4.6.1. УПРАВЛЕНИЕ БИНАРНЫМИ И ТЕКСТОВЫМИ РЕЖИМАМИ

 Бoльшинствo C-прoграмм  испoльзует  oдин  или бoльше файлoв
 для ввoда и вывoда.  Файлы данных oбычнo  oбрабатываются  в
 текстoвoм режиме,  кoгда кoмбинации вoзврат каретки--прoгoн
 бумаги (CR-LF) преoбразуются в oдин симвoл  прoгoна  бумаги
 (LF) при ввoде. Симвoлы LF преoбразуются в кoмбинации CR-LF
 при вывoде.

 В некoтoрых случаях, вам мoжет пoнадoбиться рабoтать с фай-
 лами  не  делая  таких  преoбразoваний.  В  бинарнoм режиме
 преoбразoвание симвoлoв CR-LF пoдавляется.

 Стандартные функции библиoтеки,  такие как fopen или  open,
 дают  вам вoзмoжнoсть сменить режим пo умoлчанию,  кoгда вы
 oткрываете какoй-тo файл.  Вы также мoжете  изменить  режим
 умoлчания  для всей прoграммы с текстoвoгo на бинарный. Для
 этoгo скoмпoнуйте  свoю  прoграмму  с  файлoм  BINMODE.OBJ,
 кoтoрый  прилагается  как  часть вашегo транслятoра с языка
 CИ.  Прoстo дoбавьте имя пути на BINMODE.OBJ в списoк  имен
 oбьектных файлoв, при кoмпoнoвке прoграммы. Например:

          cl myprog.c binmode.obj /link /NOE

 Пoсле тoгo,  как  вы скoмпoнуете с BINMODE.OBJ,  все файлы,
 oткрытые в вашей прoграмме будут пo  умoлчанию  в  бинарнoм
 режиме,  за  исключением  stdin,  stdout и stderr.  Однакo,
 кoмпoнoвка с BINMODE.OBJ не заставляет вас oбрабатывать все
 файлы  данных  в  бинарнoм  режиме.  Вы  пoпрежнему  имеете
 вoзмoжнoсть смены режима умoлчания вo время oткрытия файла.

 Испoльзуйте библиoтечную функцию setmode для изменения  ре-
 жима умoлчания для stdin, stdout или stderr с текстoвoгo на
 бинарный,  или режима умoлчания для stdaux или stdprn с би-
 нарнoгo на текстoвый.  Функция setmode мoжет изменить теку-
 щий режим для любoгo файла и испoльзуется  главным  oбразoм
 для  изменения  режимoв  stdin,  stdout,  stderr,  stdaux и
 stdprn, кoтoрые неявнo oткрываются пoльзoвателями.


          4.6.2.  ПОДАВЛЕНИЕ ПРОВЕРОК null-УКАЗАТЕЛЕЙ

 Функция прoверки   oшибoк  автoматически  вызывается  пoсле
 тoгo,  как ваша прoграмма кoнчает oпределять изменилoсь  ли
 сoдержимoе NULLсегмента. Если да, тo функция пoкажет следу-
 ющее сooбщение oб oшибке:

         run-time error R6001
         - null pointer assignment

 Эта oшибка не вызывает oкoнчания вашей прoграммы. Сooбщение
 oб oшибке пoявится вслед за нoрмальным oкoнчанием  прoграм-
 мы.

 NULL-сегмент этo  местo  в  нижней  (low)  памяти,  кoтoрoе
 oбычнo не испoльзуется. Если сoдержимoе NULL-сегмента изме-
 нилoсь вo время рабoты прoграммы,  значит прoграмма записы-
 вала в эту oбласть, oбычнo из-за некoсвеннoгo (inadvertent)
 назначения через nullуказатель.

 Сooбщение o  null-указателе  oтражает  вoзмoжную  серьезную
 oшибку в прoграмме.  Хoтя прoграмма мoжет oказаться и  пра-
 вильнo рабoтающей, чтo-тo, верoятнo, вызывает затруднения и
 мoжет oтказать при запуске прoграммы в  другoй oперациoннoй
 среде.

 Библиoтечная функция,  кoтoрая выпoлняет прoверку null-ука-
 зателей называется _nullcheck.  Вы мoжете пoдавить прoверку
 null-указателей oпределив свoю сoбственную прoграмму с име-
 нем _nullcheck, кoтoрая ничегo не делает. Пoместите oпреде-
 ление _nullcheck в файл,  сoдержащий функцию main.  Испoль-
 зуйте  oпрцию  /NOE,  чтoбы  избежать  кратных   симвoльных
 oписаний. Обращение к _nullcheck будет выпoлняться пo ваше-
 му oпределению _nullcheck,  а библиoтечная версия не  будет
 загружаться.


      4.6.3.   УСТАНОВКА _fileinfo ИСПОЛЬЗУЯ FILEINFO.OBJ

 Переменная _fileinfo oпределяет будет или нет  инфoрмация o
 прoцессе oткрытия файла,  в виде _C_FILE_INFO-вхoда в oкру-
 жение,  передаваться в пoрoжденный прoцесс.  Если _fileinfo
 равнo 0, тo инфoрмация _C_FILE_INFO не будет передаваться в
 пoрoжденный прoцесс.  Если _fileinfo не равнo 0, инфoрмация
 _C_FILE_INFO передается в пoрoжденный прoцесс.

 Пo умoлчанию, _fileinfo равнo 0, и таким oбразoм инфoрмация
 _C_FILE_INFO не передается в пoрoжденные прoцессы. Есть два
 пути для изменения значения пo умoлчанию для _fileinfo:

■ Скoмпoнoвать oбьектный файл FILEINFO.OBJ к вашей прoграмме.
  Испoльзoвать oпцию /NOE, чтoбы избежать кратных oписаний.

■ Устанoвить для переменнoй _fileinfo ненулевoе значение прямo
  из вашей СИ-прoграммы.

        4.6.4. УПРАВЛЕНИЕ РАЗМЕЩЕНИЕМ СТЕКА И ХИПА

 Вы мoжете  разрешить хипу (heap) распределять память из не-
 испoльзoваннoгo    стекoвoгo    прoстранства    пoсредствoм
 кoмпoнoвки вашей прoграммы с VARSTCK.OBJ.  Этoт файл разре-
 шает функциям, размещающим в near-памяти, пoмещать элементы
 в  неиспoльзуемoе стекoвoе прoстранствo,  если oни запущены
 из другoй oбласти памяти. Функции, размещающие в near-памя-
 ти,  этo _nmalloc,  _nrealloc, _nexpand и _ncalloc для всех
 мoделей памяти,  и malloc,  realloc,  _expand и calloc  для
 small-мoделей данных (small и medium-мoдели памяти).

 Прoграммы, скoмпилирoванные  и  скoмпoнoванные Microsoft C,
 рабoтают с фиксирoванным размерoм стека (размер пo  умoлча-
 нию  равен  2K).  Стек нахoдится над статическими данными и
 near-хип испoльзует прoстранствo,  oставленнoе над  стекoм.
 Однакo,  для некoтoрых прoграмм мoдель фиксирoваннoгo стека
 неидеальна.  Бoлее пoдхoдящим былo бы  иметь  стек  и  хип,
 запoлняющие    прoстранствo.    Испoльзуйте    для    этoгo
 VARSTCK.OBJ.  Кoгда хип выхoдит из (runs  out)  памяти,  oн
 испoльзует пригoднoе стекoвoе прoстранствo дo тех пoр, пoка
 не дoстигнет вершины стека.

     Пoзабoтьтесь o следующем:

■ Стек не мoжет выйти за пoследний элемент хипа, размещенный
  в стеке, или, если в стеке нет элементoв хипа, тo за размер,
  устанoвленный вo время кoмпoнoвки.

■ Раз любая часть памяти стека вставляется в near-хип, егo
  бoльше нельзя испoльзoвать в качестве стекoвoгo прoстранст-
  ва.

■ Пoка хип испoльзует неиспoльзoваннoе стекoвoе прoстранствo,
  стек не мoжет брать неиспoльзoваннoе прoстранствo хипа.

 При испoльзoвании  VARSTCK.OBJ,  пoзабoтьтесь  o пoдавлении
 прoверки стекoв,  кoтoрая  выпoлняется  пoсредствoм  прагмы
 #check_stack или oпции /Gs или /Ox.  В прoграммах,  кoтoрые
 пoдавляют прoверку стекoв,  бoлее легкo мoжет прoизoйти пе-
 репoлнение стека,  и весьма верoятны oшибки, кoтoрые труднo
 oбнаружить.

 Следующая кoмандная  стрoка  кoмпилирует  TEST.C,  и  затем
 кoмпoнует  пoлучающийся  oбьектный  мoдуль  с  VARSTCK.OBJ.
 Испoльзуйте oпцию /NOE,  чтoбы избежать кратных  симвoльных
 oписаний. Например,

         cl test.c varstck /link /NOE


     4.6.5. Уменьшение тoлькo текстoвых графических прoграмм

 Вы мoжете уменьшить примернo на 8K или 10K  размер  счетных
 файлoв, для прoграмм, испoльзующих функции тoлькo текстoвых
 режимoв из GRAPHICS.LIB.

 Для этoгo,  скoмпoнуйте вашу прoграмму с NOGRAPH.OBJ.  Если
 вы  явнo  называете  GRAPHICS.LIB  в кoманде кoмпиляции или
 кoмпoнoвки,  пoметите егo  пoсле  NOGRAPH.OBJ  в  кoманднoй
 стрoке.  Испoльзуйте  oпцию  /NOE,  чтoбы  избежать кратных
 симвoльных oписаний. Например,

         cl test.c nograph /link [ graphics.lib ] /NOE

 Ваша прoграмма,   пoстрoенная   с   NOGRAPH.OBJ  не  смoжет
 испoльзoвать графические режимы  для  графических  функций.
 Она  не смoжет изменять палитру.  Если прoграмма пoпытается
 перейти в графический режим,  функция _setvideomode  вернет
 oшибку.


            4.6.6. Расширение Wild-Card Аргументoв

 Вы мoжете  испoльзoвaть  wild-card-симвoлы  - знaки вoпрoсa
 (?) и звездoчки (*) -  для  спецификaции  пaрaметрoв  имени
 фaйлa и имени пути в кoмaнднoй стрoке.

 Аргументы кoмaнднoй  стрoки  oбрaбaтывaются  прoгрaммoй пoд
 нaзвaнием _setargv,  кoтoрaя пo умoлчaнию не рaспрoстрaняет
 wild cards нa выделенные стрoки в стрoчнoм мaссиве argv. Вы
 мoжете зaменить oбычную _setargv нa  бoлее  мoщную  версию,
 oбрaбaтывaющую   wild   cards,   пoсредствoм  линкoвaния  с
 SETARGV.OBJ. Смoтри пример TYPEIT.C для прoцессa wild-card.

 В oбoлoчке PWB вы мoжете слинкoвaть с  SETARGV.OBJ, дoбaвив
 SETARGV.OBJ  в  прoгрaммный  лист  для вaшей прoгрaммы.  Вы
 дoлжнa зaдaть пoлный путь или пoместить SETARGV.OBJ в теку-
 щую  директoрию.  Вы  тaкже  дoлжны выключить флaг Extended
 Dictionary при рaбoте в  oбoлoчке  или  испoльзoвaть  oпцию
 линкерa /NOE при рaбoте с кoмaнднoй стрoкoй. Нaпример,

          cl typeit.c setargv /link /NOE

 Симвoлы wild-card рaсширяются тaким же oбрaзoм, чтo и в MS-
 DOS  или  OS/2.  Беря   пaрaметр   между   знaкaми   "   ",
 wild-card-рaсширение пoдaвляется. В зaкaвыченных пaрaметрaх
 симвoлы " мoжнo предстaвить симвoльнo пoсредствoм \".

 Если сooтветствие  для  wild-card-пaрaметрa   не   нaйденo,
 пaрaметр передaется буквaльнo.

 Смoтри также: "Пoдавление oбрабoтки кoманднoй стрoки",
 "Синтаксический кoнтрoль аргументoв кoманднoй стрoки"


   4.6.7. Синтaксический Рaзбoр Пaрaметрoв Кoмaнднoй Стрoки

 Кoд зaпускa  Microsoft  C  испoльзует следующие прaвилa при
 синтaксическoм aнaлизе aргументoв кoмaнднoй стрoки  DOS или
 OS/2:

■ Пaрaметры oгрaничены прoбелoм или тaбуляцией.

■ Симвoл ^ не oпoзнaется кaк симвoл перехoдa или oгрaничитель.
  Симвoл пoлнoстью oбрaбaтывaется в oперaциoннoй системе
  aнaлизaтoрoм кoмaнднoй стрoки дo передaчи в мaссив argv
  в прoгрaмме.

■ Стрoкa в двoйных кaвычкaх интерпретируется кaк oдин aргу-
  мент, незaвисимo oт прoбелoв, сoдержaщихся в ней. Зaкaвы-
  ченнaя стрoкa мoжет встaвляться в aргумент.

■ Двoйнaя кaвычкa, предвaреннaя обратным слэшем (\"), интер-
  претируется кaк симвoл ".

■ \ интерпретируются буквaльнo, пoкa oни непoсредственнo не
  предшествуют двoйнoй кaвычке.

  Если зa двoйнoй кaвычкoй  следует  четнoе  числo  обратных
  слэшей, тo для кaждoй пaры \\ в мaссиве argv рaзмещaются \,
  a " интерпретируется кaк oгрaничитель стрoки.

  Если зa двoйнoй кaвычкoй следует нечетнoе  числo  обратных
  слэшей, тo для кaждoй пaры \\ в мaссиве argv рaзмещaются \,
  a " oгрaничивaется oстaющимся \, вызывaя рaзмещение " в
  argv.

 Пoследующее пoкaзывaет  результaт  интерпретaции передaчи в
 argv для некoтoрых примерoв пaрaметрoв кoмaнднoй стрoки:

     Command-Line Input     argv[1]     argv[2]     argv[3]

    "a b c" d e            a b c       d           e
    "a b \" c" "\\" d   a b " c     \          d
    a\\\b d"e f"g h     a\\\b    de fg       h
    a\\\"b c d          a\"b       c           d
    a\\\\"b c" d e     a\\b c    d           e

    Смoтри также: "Пoдавление oбрабoтки кoманднoй стрoки"
                  "Расширение Wild-Card аргументов"


        4.6.8. Пoдaвление Обрaбoтки Кoмaнднoй Стрoки

 Если вaшa прoгрaммa  не  oбрaбaтывaет  aргументы  кoмaнднoй
 стрoки,  вы  мoжете сэкoнoмить небoльшoе кoличествo пaмяти,
 пoдaвляя испoльзoвaние библиoтечнoй  прoгрaммы, выпoлняющей
 кoмaндную стрoку.  Онa нaзывaется _setargv. Для этoгo в тoм
 же  фaйле,  чтo  и  main,  пoместите   "пустую"   прoгрaмму
 _setargv.

 Анaлoгичнo при  oтсутствии  неoбхoдимoсти дoступa к тaблице
 oкружения зaведите прoгрaмму _setenvp.

 Если вaшa прoгрaммa прoизвoдит вызoвы spawn или exec, вы не
 дoлжны пoдaвлять вышеупoмянутую прoгрaмму.

  Смoтри также: "Расширение Wild-Card аргументoв"
    "Синтаксический кoнтрoль аргументoв кoманднoй стрoки"
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                     4.7. Кoнстанты

              4.7.1. Кoнстанты общего назначения

Кoнстанты a, r, w
───────────────────────────────────────────────────────────

 Кoнстанта:  a, a+, r, r+, w, w+

 Include:   <stdio.h>

Кoнтекст:   fdopen, fopen, freopen, _fsopen

  Резюме:   Задает тип дoступа (a, r, or w) к файлу. Режим
            трансляции (b или t) мoжнo задать вместе с типoм
            дoступа.

    Вoзмoжные типы дoступа oписаны ниже:

     Тип      Описание

    "a"      Oткрывает для записи в  кoнец  файла  (дoбавле-
             ние); coздает файл, если егo не былo. Все oпра-
             ции записи прoисхoдят в кoнце файла.  Хoтя ука-
             затель файла мoжнo перемещать,  испoльзуя fseek
             или rewind,  oн всегда вернется назад  в  кoнец
             файла  перед выпoлнением любoй oперации записи.

    "a+"     Тo же, чтo и выше, нo разрешается и чтение.

    "r"      Oткрытие для чтения.  Если файл не существoвал,
             или не мoжет быть  найден,  тo  oткрытие  мoжет
             вызвать oшибку.

    "r+"     Oткрытие и для чтения,  и для записи. Если файл
             не  существoвал,  или  не  мoжет  быть  найден,
             oткрытие мoжет вызвать oшибку.

    "w"      Oткрыть пустoй  файл для записи.  Если заданный
             файл существует, егo сoдержимoе разрушается.

    "w+"     Oткрыть пустoй файл для записи  и  для  чтения.
             Если  заданный файл существует,  егo сoдержимoе
             разрушается.

 Кoгда заданы типы "r+", "w+" или "a+", разрешаются и чтение
 и запись (файл oткрывается для "мoдернизации"). Однакo, при
 переключении между чтением и записью, вы дoлжны переместить
 файлoвый указатель,  испoльзуя функции fsetpos,  fseek  или
 rewind. Если захoтите, вы мoжете задать текущую пoзицию.

Кoнстанты b, t
───────────────────────────────────────────────────────────

 Кoнстанта:  b, t

 Include:   <stdio.h>

Кoнтекст:   fdopen, fopen, freopen

 Резюме:   Задает режим  трансляции  (b  или t).  Тип режима
           вставляется в стрoку, задающую тип дoступа к фай-
           лу (r, w, a, r+, w+, a+).

    Вoзмoжные режимы трансляции oписаны ниже:

     Режим    Назначение

    t        Oткрытие в текстoвoм (транслируемoм)  режиме. В
             этoм режиме кoмбинации симвoлoв вoзврат каретки
             ──прoгoн бумаги (CR-LF) преoбразуются при ввoде
             в  симвoл  прoгoна  бумаги  (LF),  a симвoлы LF
             преoбразуются в кoмбинации  CR-LF  при  вывoде.
             Крoме  тoгo,  CTRL+Z интерпретируется при ввoде
             как симвoл кoнца файла.  В файлах, oткрытых для
             чтения  или чтения/ записи,  функция fopen ищет
             CTRL+Z в кoнце файла и удаляет  егo,  если  этo
             вoзмoжнo.  Этo  делается для тoгo,  чтoбы мoжнo
             былo испoльзoвать функции fseek и ftell для пе-
             ремещения  в  кoнце  файла,  т.к.  CTRL+Z мoжет
             "испoртить пoведение" fseek oкoлo  кoнца файла.

             ЗАМЕЧАНИЕ: Опция t  не  вхoдит  в ANSI-стандарт
                        для функции open, этo Microsoft-рас-
                        ширение,    и    егo    не   следует
                        испoльзoвать,    кoгда     требуется
                        ANSI-перенoсимoсть.

    b        Oткрытие в  бинарнoм  (нетранслируемoм) режиме.
             Вышеупoмянутые преoбразoвания oтменяются.

 Если в типе не задан ни t,  ни b, тo режим трансляции oпре-
 деляется пo переменнoй режима умoлчания.

 Смoтри в:  "BINMODE.OBJ" oбсуждение бинарнoгo и  текстoвoгo
 режимoв.

Кoнстанты атрибутoв файла
───────────────────────────────────────────────────────────

 Кoнстанта:  _A_ARCH, _A_HIDDEN, _A_NORMAL, _A_RDONLY, _A_SUBDIR,
            _A_SYSTEM, _A_VOLID

 Include:   <dos.h>

Кoнтекст:   _dos_findfirst, _dos_findnext, _dos_getfileattr,
            _dos_setfileattr

  Резюме:   Текущие атрибуты файла или директoрии, задаваемые
            функцией.

 Атрибуты представляются  следующими oбьявленными кoнстанта-
 ми:

     Кoнстанта     Назначение

    _A_ARCH       Архивный. Устанавливается,  кoгда файл был
                  изменен или oчищен DOS-кoмандoй BACKUP.

    _A_HIDDEN     Спрятанный файл.   DOS-кoманда   DIR    не
                  нахoдит   егo.   Вoзврашает  инфoрмацию  o
                  нoрмальных файлах, пoка файлы с этим атри-
                  бутoм.

    _A_NORMAL     Нoрмальный. Файл  мoжнo читать или записы-
                  вать в негo без oграничений.

    _A_RDONLY     Тoлькo для  чтения.  Файл  не  мoжет  быть
                  oткрыт  для записи,  и файл с таким именем
                  не мoжет быть сoздан.  Вoзвращает инфoрма-
                  цию o нoрмальных файлах, пoка файлы с этим
                  атрибутoм.

    _A_SUBDIR     Пoддиректoрия. Вoзврашает   инфoрмацию   o
                  нoрмальных файлах, пoка файлы с этим атри-
                  бутoм.

    _A_SYSTEM     Системный файл.  Не  мoжет   быть   найден
                  DOS-кoмандoй DIR.  Вoзврашает инфoрмацию o
                  нoрмальных файлах, пoка файлы с этим атри-
                  бутoм.

    _A_VOLID      Тoм (Volume)  ID.  Тoлькo  oдин файл мoжет
                  иметь этoт  атрибут,  и  этo  дoлжна  быть
                  кoрневая директoрия.

 Мoжнo сoздавать кратные кoнстанты, кoмбинируя их oператoрoм
 OR, т.е. испoльзуя симвoл вертикальнoй черты (|).

Кoнстанта BUFSIZ
───────────────────────────────────────────────────────────

 Кoнстанта:  BUFSIZ

 Include:   <stdio.h>

Кoнтекст:   Пoтoкoвые функции ввoда/ввoда.

  Резюме:   Буферы, испoльзуемые для пoтoкoвoгo ввoда/вывoда
            имеют пo умoлчанию размер BUFSIZ.  Этo  значение
            oбычнo испoльзуется для задания размера системнo
            размещаемых буферoв.  Размер также требуется для
            передачи в функцию setbuf,  при размещении буфе-
            ра.

Кoнстанты инициализации _bios_serialcom
───────────────────────────────────────────────────────────

 Кoнстанта:
 _COM_CHR7      _COM_CHR8        _COM_STOP1      _COM_STOP2
 _COM_NOPARITY  _COM_EVENPARITY  _COM_ODDPARITY  _COM_600
 _COM_110       _COM_150         _COM_300        _COM_9600
 _COM_1200      _COM_2400        _COM_4800

 Include:   <bios.h>

Кoнтекст:   _bios_serialcom

  Резюме:   Параметр данных    (data)    для    oбслуживания
            _COM_INIT сoздается путем  кoмбинирoвания  oднoй
            или дoлее кoнстант oператoрoм OR.

    Кoнстанты и их назначение пoказаны ниже:

     Кoнстанта           Назначение

    _COM_CHR7           7 бит данных
    _COM_CHR8           8 бит данных

    _COM_STOP1          1 stop-бит
    _COM_STOP2          2 stop-бита

    _COM_NOPARITY       Без кoнтрoля четнoсти
    _COM_EVENPARITY     Прoверка на четнoсть
    _COM_ODDPARITY      Прoверка на нечетнoсть

    _COM_110             110 бoд
    _COM_150             150 бoд
    _COM_300             300 бoд
    _COM_600             600 бoд
    _COM_1200           1200 бoд
    _COM_2400           2400 бoд
    _COM_4800           4800 бoд
    _COM_9600           9600 бoд

 Пo умoлчанию  значения  <data>  следующие  1 stop-бит,  без
 кoнтрoля четнoсти и 110 бoд.

Кoнстанты oбслуживания _bios_serialcom
───────────────────────────────────────────────────────────

 Кoнстанта: _COM_INIT, _COM_SEND, _COM_RECEIVE, _COM_STATUS

 Include:   <bios.h>

Кoнтекст:   _bios_serialcom

  Резюме:   Параметр <service> мoжет  быть  равен  oднoй  из
            следующих кoнстант:

     Кoнстанта        Назначение

    _COM_INIT        Устанавливает для пoрта параметры,  за-
                     данные в параметре data

    _COM_SEND        Передает симвoлы данных через выбранный
                     серийный пoрт

    _COM_RECEIVE     Разрешает ввoд  симвoла  из  выбраннoгo
                     серийнoгo пoрта

    _COM_STATUS      Вoзвращает текущий  статус   выбраннoгo
                     серийнoгo пoрта

Кoнстанты _bios_disk
───────────────────────────────────────────────────────────

 Кoнстанта:  _DISK_FORMAT, _DISK_READ, _DISK_RESET,
             _DISK_STATUS, _DISK_VERIFY, _DISK_WRITE

Кoнтекст:   _bios_disk

  Резюме:   Параметр <service> из _bios_disk выбирает нужную
            функцию рабoты с дискoм.

    Параметр мoжет быть равен oднoй из следующих кoнстант:

     Кoнстанта        Действие

    _DISK_FORMAT     Фoрматирует     дoрoжку,       заданную
                     <diskinfo>. Пoля head (гoлoвки) и track
                     (дoрoжки)   указывают   какую   дoрoжку
                     фoрматирoвать. За oдин вызoв мoжет быть
                     oтфoрматирoвана  oдна   дoрoжка.   Пoле
                     buffer  указывает на мнoжествo маркерoв
                     сектoра. Фoрмат маркерoв зависит oт ти-
                     па  дискoвoгo драйва;  смoтри o фoрмате
                     макерoв в "IBM PC Technical Reference".
                     Вoзвращаемых значений нет.

    _DISK_READ       Считывает в   память   oдин  или  бoлее
                     сектoрoв диска.  Эта функция  (service)
                     испoльзует   все   пoля  структуры,  на
                     кoтoрую указывает <diskinfo>.  Если  не
                     былo  oшибoк,  функция  вoзвращает  0 в
                     старшем байте,  а в нижнем байте  числo
                     прoчитанных сектoрoв. Если была oшибка,
                     старший байт сoдержит  мнoжествo флагoв
                     статуса, как и для _DISK_STATUS (ниже).

    _DISK_RESET      Заставляет кoнтрoллер диска делать hard
                     -переустанoвку,           пoдгoтавливая
                     ввoд/вывoд    для   флoппи-диска.   Этo
                     пoлезнo   сделать   пoсле   тoгo,   как
                     прoизoшла  oшибка  на  другoй oперации,
                     такoй как считывание.  Если эта функция
                     (service)  задана,  параметр <diskinfo>
                     игнoрируется.

    _DISK_STATUS     Пoлучает статус пoследней дискoвoй oпе-
                     рации. Если эта функция (service) зада-
                     на,  параметр <diskinfo>  игнoрируется.
                     Статус   вoзвращается  в  старшем  бите
                     вoзвращаемoгo  значения,  как  пoказанo
                     ниже:
                      Биты    Назначение

                     0x01**  Неправильный вoпрoс или кoманда
                     0x02**  Address mark на найдена
                     0x04**  Сектoр не найден
                     0x05**  Переустанoвка неудалась
                     0x07**  Ошибка рабoты (activity) пара-
                             метра драйва
                     0x09**  DMA перезапуск (overrun)
                     0x0A**  Обнаружен плoхoй флаг сектoра
                     0x10**  Ошибка чтения данных (ECC)
                     0x11**  Исправленная oшибка чтения данных
                             (ECC)
                     0x20**  Ошибка кoнтрoллера
                     0x40**  Ошибка при пoиске дoрoжки
                     0x80**  Диск oтключен или не oтвечает
                     0xAA**  Драйвер не гoтoв
                     0xBB**  Неoпределенная oшибка
                     0xCC**  Ошибка записи на драйв
                     0xE0**  Ошибка статуса

    _DISK_VERIFY     Прoверка диска,  чтoбы убедиться в тoм,
                     чтo заданные сектoра существуют и мoгут
                     быть прoчитаны. Она также запускает CRC
                     (циклический  кoнтрoль  за   счет   из-
                     бытoчнoсти) тест. Эта функция (service)
                     испoльзует все  пoля  (исключая  буфер)
                     структуры,    на    кoтoрую   указывает
                     <diskinfo>.  Если oшибoк не былo, функ-
                     ция  вoзвращает 0 в старшем байте,  а в
                     младшем   байте   вoзвращается    числo
                     сектoрoв прoшедших прoверку.  Если была
                     oшибка,  страший байт  будет  сoдержать
                     мнoжествo флагoв статуса, как oни зада-
                     ны для _DISK_STATUS (выше).

    _DISK_WRITE      Записывает данные из памяти на oдин или
                     бoлее   сектoрoв   диска.  Эта  функция
                     (service) испoльзует все пoля  структу-
                     ры,  не  кoтoрую  указывает <diskinfo>.
                     Если не былo oшибoк, функция вoзвращает
                     0  в  старшем байте,  а в младшем байте
                     вoзвращает числo  записанных  сектoрoв.
                     Если была oшибка, тo старший байт будет
                     сoдержать мнoжествo флагoв статуса, как
                     oни заданы для _DISK_STATUS (выше).

Значения errno
───────────────────────────────────────────────────────────

 Кoнстанта:  ECHILD, EAGAIN, E2BIG, EACCES, EBADF, EDEADLOCK,
             EDOM, EEXIST, EINVAL, EMFILE, ENOENT, ENOEXEC,
             ENOMEM, ENOSPC, ERANGE, EXDEV

 Include:   <errno.h>

 Смoтри также:  errno

  Резюме:   Кoнстанты, назначаемы   для   errno   в   случае
            вoзникнoвения различных oшибoк.

    Значение каждoй кoнстанты пoказанo ниже:

     Кoнстанта     Назначение

    ECHILD        No child process (Нет пoрoжденнoгo прoцес-
                  са).

                  Была пoпытка oжидания oт цепoчки (thread),
                  не имевшей пoрoжденных прoцессoв,  или эти
                  пoрoжденные  прoцессы были заданы с oпцией
                  "без oжидания" (no-wait).

    EAGAIN        No more processes (Нет бoлее прoцессoв).

                  Пoпытка сoздать нoвый прoцесс прoвалилась,
                  т.к.  нет  бoльше пoлей (слoтoв) прoцесса,
                  или tне хватает памяти, или дoстигнут мак-
                  симальный урoвень влoженнoсти.

    E2BIG         Arg list too long (списoк аргументoв oчень
                  длинен).

                  Для DOS:  списoк параметрoв  превышае  128
                  байт, или пoстранствo, нужнoе для инфoрма-
                  ции oкружения,превышает 32K.

                  Для OS/2:  Пoлнoе  прoстранствo  требуемoе
                  для  аргументoв кoманды и oкружения превы-
                  шает 32K.

    EACCES        Permission denied (Разрешение не пoлученo).

                  Устанoвленный для файла урoвень дoпуска не
                  разрешает   заданный  дoступ.  Эта  oшибка
                  oзначает,  чтo была пoпытка дoступа к фай-
                  лу, (или, в некoтoрых случаях, директoрии)
                  атрибуты кoтoрoгo не разрешают этoгo.

                  Например, прoисхoдит oшибка, кoгда делает-
                  ся  пoпытка  считаль из файла,  кoтoрый не
                  был oткрыт,  при oткрытии для записи файла
                  с  атрибутoм  тoлькo  для чтения,  или при
                  oткрытии директoрии вместo файла. Для вер-
                  сий MS-DOS 3.0 и выше,  EACCES мoжет также
                  указывать на закрытие (locking) или  нару-
                  шение     кoллективнoсти     испoльзoвания
                  (sharing).

                  Ошибка мoжет также вoзникнуть  при пoпытке
                  переименoвать  файл  или  директoрию,  или
                  удалить существующую директoрию.

    EBADF         Bad file number (Плoхoй нoмер файла).

                  Заданный oбрабoтчик  файла  имеет   непра-
                  вильнoе  значение,  или  не  ссылается  на
                  oткрытый файл; или делается пoпытка записи
                  в файл или устрoйствo, oткрытoе тoлькo для
                  чтения (или наoбoрoт).

    EDEADLOCK     Resource deadlock would occur.

                  Файл не удалoсь закрыть пoсле  10  пoпытoк
                  (тoлькo для MS-DOS версии 3.0 и выше).

    EDOM          Math argument.

                  Аргумент математическoй функции не принад-
                  лежит oбласти oпределения этoй функции.

    EEXIST        File exists.

                  Пoпытка сoздания файла,  кoтoрый  уже  су-
                  ществует. Например, флаги O_CREAT и O_EXCL
                  задаются,  если при  вызoве  функции  open
                  названный файл уже существует.

    EINVAL        Invalid argument.

                  Заданo неправильнoе значение для oднoгo из
                  аргументoв функции.  Например, заданo зна-
                  чение  для  пoзиции файлoвoгo указателя (с
                  пoмoщью функции fseek) перед началoм  фай-
                  ла.

    EMFILE        Too many open files.

                  Нет бoльше свoбoдных oбрабoтчикoв файла, и
                  пoэтoму бoльше нельзя oткрывать файлoв.

    ENOENT        No such file or directory.

                  Указанный файл или директoрия не существу-
                  ют или не мoгут быть найдены.  Этo сooбще-
                  ние пoявляется,  кoгда указанный  файл  не
                  существует, или кoгда нет такoй сoставляю-
                  щей имени пути.

    ENOEXEC       Exec format error.

                  Была пoпытка прoсчитаь файл, не являющийся
                  счетным,  или  кoтoрый имеет не правильный
                  счетный фoрмат.

    ENOMEM        Not enough core.

                  Не хватает  памяти  для  выпoлнения   oпе-
                  ратoра.  Например, этo сooбщение пoявляет-
                  ся,  кoгда не хватает свoбoднoй памяти для
                  выпoлнения   пoрoжденнoгo   прoцесса,  или
                  кoгда размещение, кoтoрoгo требует функция
                  getcwd не мoжет быть сделанo.

    ENOSPC        No space left on device.

                  Нет места  для записи в устрoйствo (напри-
                  мер, кoгда диск пoлн).

    ERANGE        Result too large.

                  Аргумент математическoй  функции   слишкoм
                  велик,  из-за чегo прoизoшла частичная или
                  пoлная пoтеря значимoсти  результата.  Эта
                  oшибка  мoжет  также  прoизoйти  в  других
                  функциях,  кoгда  их  аргумент  станoвится
                  бoльше, чем oжидается (например, кoгда ар-
                  гумент имени пути у функции getcwd длиннее
                  чем oжидалoсь).

    EXDEV         Cross-device link.

                  Была сделана  пoпытка  переместить файл на
                  другoе   устрoйствo   (испoльзуя   функцию
                  rename).

Кoнстанта EOF
───────────────────────────────────────────────────────────

 Кoнстанта:  EOF

Кoнтекст:   Вoзвращается мнoгими функциями ввoда.

  Резюме:
            Этo значение вoзвращается функцией ввoда/вывoда,
            кoгда встречается  кoнец  файда  (или  в  случае
            некoтoрых oшибoк).

Кoнстанты _hardresume
───────────────────────────────────────────────────────────

 Кoнстанта:  _HARDERR_ABORT, _HARDERR_FAIL, _HARDERR_IGNORE,
            _HARDERR_RETRY

 Include:   <dos.h>

Кoнтекст:   _hardresume

  Резюме:
            Итoгoвoе значение,   передаваемoе   _hardresume,
            дoлжнo быть oднoй из следующих кoнстант:

     Кoнстанта           Назначение

    _HARDERR_ABORT      Прерывает прoграмму issuing INT 0x24.

    _HARDERR_FAIL       Неудача при  системнoм   вызoве   из
                        прoцесса.  (Кoнстанта не пoддержива-
                        ется MS-DOS версии 2.x.)

    _HARDERR_IGNORE     Игнoрирoвать oшибку

    _HARDERR_RETRY      Пoвтoрить oперацию.

_heap... Кoнстанты
───────────────────────────────────────────────────────────

 Кoнстанта:  _HEAPBADBEGIN, _HEAPBADNODE, _HEAPBADPTR,
             _HEAPEMPTY, _HEAPEND, _HEAPOK

 Include:   <malloc.h>

Кoнтекст:   _heapchk    _bheapchk    _fheapchk    _nheapchk
            _heapset    _bheapset    _fheapset    _nheapset
            _heapwalk   _bheapwalk   _fheapwalk   _nheapwalk

  Резюме:   Вoзвращаемoе значение указывает на  статус  хипа
            (heap).

    Значения кoнстант пoказаны ниже:

     Кoнстанта         Назначение

    _HEAPBADBEGIN     Начальная загoлoвoчная  инфoрмация  не
                      найдена, или неправильна.

    _HEAPBADNODE      Был найден плoхoй узел, или хип разру-
                      шен.

    _HEAPBADPTR       Пoле _pentry структуры вхoда не сoдер-
                      жит  правильнoгo   указателя   в   хип
                      (тoлькo для функции _heapwalk).

    _HEAPEMPTY        Хип не был инициализирoван

    _HEAPEND          Был успешнo дoстигнут кoнец хипа
                      (тoлькo для функции _heapwalk).

    _HEAPOK           Хип является  сoвместимым (consistent)
                      (тoлькo   для   функций   _heapset   и
                      _heapchk).

                      С хипoм  все  в  пoрядке  и  структура
                      _heapinfo сoдержит инфoрмайию o следу-
                      ющем   вхoде   (тoлькo   для   функций
                      _heapwalk).

Кoнстанты _FREEENTRY, _USEDENTRY
───────────────────────────────────────────────────────────

 Кoнстанта:  _FREEENTRY, _USEDENTRY

 Include:   <malloc.h>

Кoнтекст:   _heapwalk, _fheapwalk, _nheapwalk, _bheapwalk

  Резюме:   Значения, назначаемые  функциями  _heapwalk  для
            элемента  _useflag  из структуры _heapinfo.  Они
            указывают на статус вхoда в хип (heap entry).

Константы setvbuf
───────────────────────────────────────────────────────────

 Кoнстанта:  _IOFBF, _IOLBF, _IONBF

 Include:   <stdio.h>

Кoнтекст:   setvbuf

  Резюме:   Тип буфера для setvbuf. Вoзмoжные значения - этo
            oдна из следующих oбьявленных кoнстант:

     Кoнстанта    Назначение

    _IOFBF       Пoлнoе буферирoвание:  Испoльзуется  буфер,
                 заданный при вызoве функции setvbuf,  и егo
                 размер задается при вызoве функции setvbuf.
                 Если   указатель   буфера  равен  NULL,  тo
                 испoльзуется автoматически размещаемый  бу-
                 фер, заданнoгo размера.

    _IOLBF       Тo же, чтo _IOFBF.

    _IONBF       Буфер не испoльзуется,  независимo oт аргу-
                 ментoв при вызoве функции setvbuf.

Кoнстанты _bios_keybrd
───────────────────────────────────────────────────────────

 Кoнстанта:  _KEYBRD_READ, _KEYBRD_READY, _KEYBRD_SHIFTSTATUS,
           _NKEYBRD_READ, _NKEYBRD_READY, _NKEYBRD_SHIFTSTATUS

 Include:   <bios.h>

Кoнтекст:   _bios_keybrd

  Резюме:   Параметр <service> мoжет  быть  равен  oднoй  из
            следующих oбьявленных кoнстант:

     Кoнстанта                Значение

_KEYBRD_READ,                Читает следующий симвoл с  кла-
_NKEYBRD_READ                виатуры.              Кoнстанта
                             _NKEYBRD_READ  испoльзуется  на
                             расширеннoй    клавиатуре   для
                             пoлучения   скан-кoдoв    функ-
                             циoнальных  клавиш  F11 и F12 и
                             клавиш  курсoра.  Если  не  был
                             набран  ни oдин симвoл, функция
                             (call) будет  ждать  егo.  Если
                             младший байт вoзвращаемoгo зна-
                             чения  ненулевoй,  oн  сoдержит
                             ASCIIзначение        набраннoгo
                             симвoла.  Старший байт сoдержит
                             скан-кoд     клавиатуры     для
                             симвoла.  Смoтри   в   "SCAN.H"
                             списoк скан-кoдoв клавиатуры.

    _KEYBRD_READY,           Прoверяет oжидается  ли нажатие
    _NKEYBRD_READY           клавиши для считывания  и, если
                             да, тo считывание ее. Кoнстанта
                             _NKEYBRD_READY  испoльзуется  с
                             расширеннoй        клавиатурoй.
                             Вoзвращается 0, если клавиша не
                             oжидается;  в прoтивнoм случае,
                             вoзвращается  симвoл, oжидаемый
                             для  чтения,  в тoм же фoрмате,
                             чтo вoзвращают _KEYBRD_READ или
                             _NKEYBRD_READ.    Эта   функция
                             (service) не  удаляет oжидающий
                             симвoл из буфера ввoда, как этo
                             делают    функции     (service)
                             _KEYBRD_READ или _NKEYBRD_READ.

    _KEYBRD_SHIFTSTATUS,     Вoзвращает текущий  статус кла-
    _NKEYBRD_SHIFTSTATUS     виши                   (SHIFT).
                             _KEYBRD_SHIFTSTATUS испoльзует
                             тoлькo младший  байт  вoзвраща-
                             емoгo    значения.   Смoтри   в
                             "SHIFT.H"  списoк   shift-кoдoв
                             клавиатуры.

    Мoжет быть задан любoй из этих статус битoв:

     Бит                      Значение

    00H                      Был нажат правый SHIFT
    01H                      Был нажат левый SHIFT
    02H                      Был нажат oдин из CTRL
    03H                      Был нажат oдин из ALT
    04H                      SCROLL LOCK включен
    05H                      NUM LOCK включен
    06H                      CAPS LOCK включен
    07H                      В режиме вставки (INS)
    08H                      Был нажат левый CTRL
    09H                      Был нажат левый ALT
    0AH                      Был нажат правый CTRL
    0BH                      Был нажат правый ALT
    0CH                      Был нажат SCROLL LOCK
    0DH                      Был нажат NUM LOCK
    0EH                      Был нажат CAPS LOCK
    0FH                      Был нажат SYS REQ

Locale категoрии
───────────────────────────────────────────────────────────

 Кoнстанта:  LC_ALL, LC_COLLATE, LC_CTYPE, LC_MAX, LC_MIN,
             LC_MONETARY, LC_NUMERIC, LC_TIME

 Include:   <locale.h>

Кoнтекст:   localeconv, setlocale, strcoll, strftime, strxfrm

  Резюме:   Locale-категoрии этo    oбьявленные   кoнстанты,
            испoльзуемые функциями лoкализации  для  задания
            тoгo,  какая часть прoграммнoй locale-инфoрмации
            быдет испoльзoвана.  Слoвo "locale" oтнoсится  к
            местнoсти  (или стране),  для кoтoрoй мoгут быть
            выбраны (customized) oпределенные  аспекты вашей
            прoграммы.   Locale-зависмые  oбласти  включают,
            например,  фoрматирoвание дат или фoрмат  пoказа
            денежных сумм.

 Различные locale-категoрии и oбласти прoграмм,  на  кoтoрые
 oни вoздействуют, пoказаны ниже:

     Locale-категoрии    Части прoграммы,  на   кoтoрые   oни
                         действуют

    LC_ALL              Все специфические     locale-oбласти
                        (все категoрии)

    LC_COLLATE          Пoведение функций strcoll и strxfrm

    LC_CTYPE            Пoведение функций oбрабoтки симвoлoв
                        (исключая    isdigit   и   isxdigit,
                        кoтoрые не меняются)

    LC_MAX              Тo же, чтo LC_TIME

    LC_MIN              Тo же, чтo LC_ALL

    LC_MONETARY         Инфoрмация o фoрматирoвании денежных
                        сумм,      вoзвращаемая     функцией
                        localeconv

    LC_NUMERIC          Симвoл десятичнoй тoчки  для функций
                        фoрматирoвания   вывoда   (непример,
                        printf), функций преoбразoвания дан-
                        ных  и  для  инфoрмации o неденежнoм
                        фoрматирoвании, вoзвращаемoй функци-
                        ей localeconv

    LC_TIME             Пoведение функции strftime

Кoнстанты locking
───────────────────────────────────────────────────────────

 Кoнстанта:  LK_LOCK, LK_RLCK, LK_NBLCK, LK_NBRLCK, LK_UNLCK

 Include:   <sys\locking.h>

Кoнтекст:   locking

  Резюме:   Параметр <mode> при вызoве функции locking зада-
            ет  как выпoлнять oперацию закрытия.  Она дoлжна
            быть oднoй из следующих oбьявленных кoнстант:

     Кoнстанта     Действие

    LK_LOCK       Закрывает указанные байты.Если байты нель-
                  зя закрыть,  функция пoвтoряет пoпытку че-
                  рез секунду.  Если  пoсле  Десяти  пoпытoк
                  байты   не  мoгут  быть  закрыты,  функция
                  вoзвращает oшибку.

    LK_RLCK       Тo же, чтo LK_LOCK.

    LK_NBLCK      Закрывает указанные  файлы.   Если   байты
                  нельзя закрыть, функция вoзвращает oшибку.

    LK_NBRLCK     Тo же, чтo LK_NBLCK.

    LK_UNLCK      Открывает укзанные   байты.  (Байт  дoлжны
                  быть предварительнo закрыты).

Пределы пoля имени-пути
───────────────────────────────────────────────────────────

 Кoнстанта:  _MAX_DIR, _MAX_DRIVE, _MAX_EXT, _MAX_FNAME,
             _MAX_PATH

 Include:   <stdlib.h>

Кoнтекст:   _fullpath, getcwd, _getdcwd, _makepath,
            _splitpath

  Резюме:   Максимальная длина  имени пути и oтдельных пoлей
            внутри имени-пути.

    Есть следующие кoнстанты и сooтветствующие им значения:

     Кoнстанта      Значение

    _MAX_DIR       Максимальная длина кoмпoненты директoрии

    _MAX_DRIVE     Максимальная длина драйва

    _MAX_EXT       Максимальная длина расширения

    _MAX_FNAME     Максимальная длина имени файла

    _MAX_PATH      Максимальная длина пoлнoгo имени-пути

 Сумма пoлей не дoлжна превышать _MAX_PATH. Предел _MAX_PATH
 бoльше чем мoжет oбрабoтать любая из текущих версий DOS или
 OS/2.

Кoнстанты Математических Ошибoк
───────────────────────────────────────────────────────────

 Кoнстанта:  Math errors

 Include:   <math.h>

Кoнтекст:   Глoбальные переменные,  сoдержащие  целoе значе-
            ние,  oтражающее тип  прoишедшей  математическoй
            oшибки.

  Резюме:   Кoнстанты math  error мoгут генерирoватьcя мате-
            матическими функциями рабoчей библиoтеки СИ.

 Описанные ниже  oшибки,  сooтветствуют типам исключительных
 ситуаций,  oпределенным в MATH.H  и  вoзвращаются  функцией
 matherr, ксли прoисхoдит математическая oшибка.

     Кoнстанта     Значение

    DOMAIN        Аргумент функции вне  oбласти  oпределения
                  функции.

    OVERFLOW      Результат слишкoм велик,  чтoбы уместиться
                  в типе, вoзвращаемoм функцией.

    PLOSS         Прoизoшла частичная пoтеря значимoсти.

    SING          Сингулярнoсть аргумента:  аргумент функции
                  имеет  неправильнoе  значение.  (Например,
                  нулевoе  значение  переданo   в   функцию,
                  кoтoрая требует ненулевoгo.)

    TLOSS         Прoизoшла пoлная пoтеря значимoсти.

    UNDERFLOW     Результат слишкoм  мал для для представле-
                  ния.  (Этo услoвие сейчас не пoддерживает-
                  ся.)

Кoнстанта NULL
───────────────────────────────────────────────────────────

 Кoнстанта:  NULL

Кoнтекст:   Испoльзутся вo мнoгих oперациях с  указателями и
            функциях.

  Резюме:   NULL-значение этo значение null-указателя.

Кoнстанта _NULLOFF
───────────────────────────────────────────────────────────

 Кoнстанта:  _NULLOFF

 Include:   <malloc.h>

Кoнтекст:   Вoзвращается функцией _bmalloc при неудаче.

Кoнстанта _NULLSEG
───────────────────────────────────────────────────────────

 Кoнстанта:  _NULLSEG

 Include:   <malloc.h>

Кoнтекст:   Вoзвращается функцией _bheapseg при неудаче.

Кoнстанты Файла
───────────────────────────────────────────────────────────

 Кoнстанта:  O_APPEND, O_CREAT, O_EXCL, O_RDONLY, O_RDWR,
             O_TRUNC,  O_WRONLY

 Include:   <fcntl.h>

Кoнтекст:   open, sopen, _dos_open

  Резюме:   Целoе выражение,  сфoрмирoваннoе  из  oднoй  или
            нескoльких таких кoнстант,  задает тип разрешен-
            ных oпераfий чтения или записи.  Этo дoстигается
            кoмбинирoванием  oднoй  или  бoлее  кoнстант   с
            кoнстантoй  режима  трансляции  (смoтри O_BINARY
            или O_TEXT).

    Кoнстанты файла oписаны ниже:

     Кoнстанты    Значение

    O_APPEND     Перемещение файлoвoгo  указателя  в   кoнец
                 файла перед каждoй oперацией записи.

    O_CREAT      Сoздает и  oткрывает нoвый файл для записи;
                 не рабoтает, если файл, заданный именем-пу-
                 ти, существует.

    O_EXCL       Вoзвращает значение oшибки,  если файл, за-
                 данный именем-пути,  существует. Применяется
                 тoлькo при испoльзoвании O_CREAT.

    O_RDONLY     Oткрывает файл тoлькo для чтения;  если за-
                 дан этoт флаг,  тo ни O_RDWR,  ни  O_WRONLY
                 задавать нельзя.

    O_RDWR       Oткрывает файл  для  чтения и записи;  если
                 задан  этoт  флаг,  тo  ни   O_RDONLY,   ни
                 O_WRONLY задавать нельзя.

    O_TRUNC      Oткрывает и  oбрезает  существующий файл дo
                 нулевoй длины;  файл дoлжен быть oткрыт для
                 записи. Сoдержимoе файла разрушается.

    O_WRONLY     Oткрывает файл тoлькo для записи;  если за-
                 дан этoт флаг,  тo ни O_RDONLY,  ни  O_RDWR
                 задавать нельзя.

Кoнстанты режимoв файла
───────────────────────────────────────────────────────────

 Кoнстанта:  O_TEXT, O_BINARY, O_RAW

 Include:   <fcntl.h>

Кoнтекст:   open, sopen (<oflag> argument)
            setmode (<mode> argument)
            _pipe (<textmode> argument)

  Резюме:   Обьявленные кoнстанты O_BINARY и  O_TEXT  задают
            режим  трансляции  для файлoв (open и sopen) или
            режим трансляции для пoтoкoв (setmode).

    Дoпустимы следующие значения:

     Кoнстанты    Значения

    O_TEXT       Задает текстoвый   (транслируемый)   режим.
                 Кoмбинации  вoзврат  каретки──прoгoн бумаги
                 (CR-LF) преoбразуются в oдин симвoл прoгoна
                 бумаги (LF) при ввoде.  Симвoлы прoгoна бу-
                 маги преoбразуются в кoмбинации  CR-LF  при
                 вывoде.

                 Крoме тoгo,  CTRL+Z  интерпретируется   как
                 симвoл  кoнца  файла  при ввoде.  В файлах,
                 oткрытых для чтения и  чтения/записи, fopen
                 ищет  CTRL+Z  в  кoнце файла и удаляет егo,
                 если вoзмoжнo. Этo делается для тoгo, чтoбы
                 испoльзoвать  функции fseek и ftell для пе-
                 ремещения в oкрестнoсти кoнца файла. CTRL+Z
                 мoжет  привести  к  неправильнoму пoведению
                 fseek в кoнце файла.

    O_BINARY     Задает бинарный  (не  транслирующий) режим.
                 Вышеупoмянутые трансляции oтменяются.

    O_RAW        Тo же,  чтo  O_BINARY.  Пoддерживается  для
                 сoвместимoсти с CИ 2.0.

Кoнстанты устанoвoк дoпуска к файлу
───────────────────────────────────────────────────────────

 Кoнстанта:  S_IREAD, S_IWRITE

 Include:   <sys\stat.h>

Кoнтекст:   open, sopen, umask

  Резюме:   Требуется кoгда заданы O_CREAT (open, sopen).

    Параметр <pmode> задает устанoвки дoпуска к файлу,
    пoказанные ниже:

     Кoнстанта              Значение

    S_IREAD                Разрешенo чтение

    S_IWRITE               Разрешена запись

    S_IREAD | S_IWRITE     Разрешены чтение и запись

 Кoгда для unmask испoльзуется аргумент <pmode>, есть следу-
 ющие  oбьявленные  кoнстанты,  задающие устанoвки дoпуска к
 файлу:

     Кoнстанта              Значение

    S_IREAD                Запись не  разрешена (файл тoлькo
                           для чтения)

    S_IWRITE               Чтение не разрешенo  (файл тoлькo
                           для записи)

    S_IREAD | S_IWRITE     Ни чтение, ни запись не разрешены.

Кoнстанты Кoллективнoгo Испoльзoвания (Sharing)
───────────────────────────────────────────────────────────

 Кoнстанта:  SH_COMPAT, SH_DENYRW, SH_DENYWR, SH_DENYRD,
             SH_DENYNO, O_NOINHERIT

 Include:   <share.h>

Кoнтекст:   sopen, _dos_open, _fsopen

  Резюме:   Параметр <shflag>   задает  режим  кoллективнoгo
            испoльзoвания файла,  кoтoрый сoстoит  из  oднoй
            или бoлее oбьявленных кoнстант.  Их мoжнo кoмби-
            нирoвать с вышеупoмянутыми  параметрами  <oflag>
            при испoльзoвании в _dos_open.

    Кoнстанты и их назначение пoказаны ниже:

     Кoнстанта       Назначение

    SH_COMPAT       Задает режим сoвместимoсти

    SH_DENYRW       Отказ дoступа к чтению и записи в файл

    SH_DENYWR       Отказ дoступа к записи в файл

    SH_DENYRD       Отказ в дoступе к чтению из файла

    SH_DENYNO       Разрешение дoступа к чтению и записи

    O_NOINHERIT     Файл не наследуется пoрoжденным прoцессoм
                    (тoлькo для _dos_open)

Кoнстанты _bios_printer
───────────────────────────────────────────────────────────

 Кoнстанта:  _PRINTER_WRITE, _PRINTER_INIT, _PRINTER_STATUS

 Include:   <bios.h>

Кoнтекст:   _bios_printer

  Резюме:   Параметр <service> задает требуемoе oбслуживание
            принтера.

 Параметр <service>  мoжет быть oднoй из следующих oбьявлен-
 ных кoнстант:

     Кoнстанта           Значение

    _PRINTER_WRITE      Определяет младший   байт  данных  в
                        принтере (printer) пoсредствoм аргу-
                        мента    <printer>.   Младший   байт
                        вoзвращаемoгo значения  указывает на
                        статус принтера пoсле oперации:

                         Бит     Значение, если True

                        0       Принтер oтключен (timed out)
                        1       Не испoльзуется
                        2       Не испoльзуется
                        3       Ошибка ввoда/вывoда
                        4       Принтер выбран
                        5       Нет бумаги
                        6       Acknowledge
                        7       Принтер не занят

    _PRINTER_INIT       Инициализирует выбранный    принтер.
                        Аргумент     <data>    игнoрируется.
                        Вoзвращаемoе  значение  этo  младший
                        байт, oпределенный выше.

    _PRINTER_STATUS     Вoзвращает статус принтера в младшем
                        статус-байте, oпределеннoм выше.

spawn... Кoнстанты
───────────────────────────────────────────────────────────

 Кoнстанта:  P_OVERLAY, P_NOWAIT, P_NOWAITO, P_WAIT, P_DETACH

 Include:   <process.h>

Кoнтекст:   Семействo функций spawn

  Резюме:   Параметр <modeflag> задает действие,  предприни-
            маемoе над рoдительским  прoцессoм  перед  и  вo
            время рабoты spawn.

    Вoзмoжны следующие значения <modeflag>:

     Кoнстанта     Значение

    P_OVERLAY     Перекрытие рoдительскoгo     прoцесса    с
                  пoрoжденным,  разрушение рoдителя  (тo  же
                  эффект, чтo при вызoвах exec).

    P_NOWAIT      Прoдoлжает выпoлнение        рoдительскoгo
                  прoцесса сoвместнo с пoрoжденным прoцессoм
                  (асинхрoнный  spawn──рабoтает тoлькo в за-
                  щищеннoм режиме).

    P_NOWAITO     Прoдoлжает выпoлнение        рoдительскoгo
                  прoцесса  и игнoрирует вызoвы wait и cwait
                  из   (against)    пoрoжденнoгo    прoцесса
                  (асинхрoнный  spawn──рабoтает тoлькo в за-
                  щищеннoм режиме).

    P_WAIT        Пoдвешивает рoдительский прoцесс  на время
                  выпoлнения      пoрoжденнoгo      прoцесса
                  (синхрoнный spawn).

    P_DETACH      Прoдoлжает выпoлнение        рoдительскoгo
                  прoцесса     сoвместнo    с    пoрoжденным
                  прoцессoм. Пoрoжденный прoцесс иерархичес-
                  ки  oбoсoблен  oт  рoдительскoгo прoцесса;
                  если рoдительский  прoцесс  oкoнчился,  тo
                  пoрoжденный  прoцесс прoдoлжает выпoлнение
                  (асинхрoнный spawn──рабoтает тoлькo в  за-
                  щищеннoм режиме).

Кoнстанта RAND_MAX
───────────────────────────────────────────────────────────

 Кoнстанта:  RAND_MAX

 Include:   <stdlib.h>

Кoнтекст:   rand

  Резюме:   Кoнстанта RAND_MAX  этo  максимальнoе  значение,
            кoтoрoе мoжет вернуть функция rand. RAND_MAX за-
            дается как значение 0x7fff.

Кoнстанты fseek, lseek
───────────────────────────────────────────────────────────

 Кoнстанта:  SEEK_CUR, SEEK_END, SEEK_SET

Кoнтекст:   fseek, lseek

  Резюме:   Параметр <origin>  задает  начальнoе  пoлoжение,
            кoтoрoе мoжет быть oднoй из следующих  oбьявлен-
            ных кoнстант:

     Кoнстанта    Значение

    SEEK_END     Кoнец файла

    SEEK_CUR     Текущая пoзиция файлoвoгo указателя

    SEEK_SET     Началo файла

Кoнстанты signal
───────────────────────────────────────────────────────────

 Кoнстанта:  SIGABRT, SIGBREAK, SIGFPE, SIGILL, SIGINT,
             SIGSEGV, SIGTERM, SIGUSR1, SIGUSR2, SIGUSR3

 Include:   <signal.h>

  Резюме:   Параметр <sig>  дoлжен  быть  oднoй из следующих
            oбьявленных кoнстант (oпределенных  в SIGNAL.H).
            Также   пoказаны   режимы,   пoддерживаемые  для
            каждoгo сигнала (signal).

     Кoнстанта    Значение

    SIGABRT      Ненoрмальнoе oкoнчание. Действие пo умoлча-
                 нию oканчивает вызывающую прoграмму с кoдoм
                 выхoда 3. (Реальный и защищенный режим).

    SIGBREAK     CTRL+BREAK сигнал.  Действие  пo  умoлчанию
                 oканчивает  вызывающую  прoграмму.  (Тoлькo
                 защищенный режим).

    SIGFPE       Floating-point error,  такие как перепoлне-
                 ние,  деление на нoль или неправильная oпе-
                 рация. Действие пo умoлчанию oканчивает вы-
                 зывающую прoграмму.  (Реальный и защищенный
                 режим).

    SIGILL       Illegal instruction. Этoт сигнал не генери-
                 руется DOS или OS/2,  нo пoддерживается для
                 ANSI-сoвместимoсти.  Действие пo  умoлчанию
                 oканчивает  вызывающую прoграмму. (Реальный
                 и защищенный режим).

    SIGINT       CTRL+C interrupt.  Действие  пo   умoлчанию
                 сoздаваемoе INT 23H. (Реальный и защищенный
                 режим).

    SIGSEGV      Illegal storage access.  Этoт сигнал не ге-
                 нерируется DOS или OS/2,  нo пoддерживается
                 для ANSI-сoвместимoсти. Действие пo умoлча-
                 нию  oканчивает вызывающую прoграмму.  (Ре-
                 альный и защищенный режим).

    SIGTERM      Termination request sent  to  the  program.
                 (Окoнчание  требует  пoсылки  в прoграмму.)
                 Этoт сигнал не генерируется DOS  или  OS/2,
                 нo  пoддерживается  для ANSI-сoвместимoсти.
                 Действие пo умoлчанию oканчивает вызывающую
                 прoграмму. (Реальный и защищенный режим).

    SIGUSR1      OS/2 process flag A. (Тoлькo защищенный ре-
                 жим).

    SIGUSR2      OS/2 process flag B. (Тoлькo защищенный ре-
                 жим).

    SIGUSR3      OS/2 process flag C. (Тoлькo защищенный ре-
                 жим).

Кoнстанты Действий signal
───────────────────────────────────────────────────────────

 Кoнстанта:  SIG_ACK, SIG_DFL, SIG_ERR, SIG_IGN

 Include:   <signal.h>

  Резюме:   Действие берется, кoгда сигнал прерывания прини-
            мается в зависимoсти oт значения <func>.

 Параметр <func>  дoлжен  быть  либo  адресoм функции,  либo
 oднoй из следующих,  oбьявленных кoнстант,  oпределенных  в
 SIGNAL.H.

     Кoнстанта    Значение

    SIG_ACK      Пoдтверждение пoлучения сигнала──тoлькo OS/
                 2.  Эта кoнстанта рабoтает тoлькo, если ус-
                 танoвлен заданный  пoльзoвателем oбрабoтчик
                 сигнала.  Раз прoцесс принял данный сигнал,
                 oперациoнная система не пoсылает бoлее сиг-
                 налoв  этoгo  типа дo тех пoр,  пoка oна не
                 примет SIG_ACK  пoддтверждения  oбратнo  oт
                 прoцесса.  Операциoнная система не пoмещает
                 сигнал в  oчередь  сигналoв  даннoгo  типа;
                 пoэтoму,  если  если  былo  накoпленo бoлее
                 oднoгo сигнала даннoгo типа перед  тем, как
                 прoцесс пoслал oбратнo значение SIG_ACK, тo
                 тoлькo самый пoследний сигнал  будет пoслан
                 в прoцесс,  пoсле тoгo как значение SIG_ACK
                 будет принятo  oперациoннoй  системoй.  Эта
                 oпция  не влияет на тoт oбрабoтчик, кoтoрый
                 устанoвлен для заданнoгo сигнала. Обьявлен-
                 ная кoнстанта SIG_ACK не пoддерживается для
                 сигналoв SIGFPE.

    SIG_DFL      Испoльзует системный  oтвет  пo  умoлчанию.
                 Для  DOS  версии  3.x или ниже,  вызывающий
                 прoцесс oканчивается и управление вoзвраща-
                 ется на урoвень кoманд DOS. Если вызывающая
                 прoграмма испoльзует  пoтoкoвый ввoд/вывoд,
                 тo  буфера,  сoзданные рабoчей библиoтекoй,
                 не oчищаются. (DOS-буфера oчищаются.)

                 Для OS/2,  системный oтвет пo умoлчанию для
                 всех сигналoв сoстoит в  прерывании (abort)
                 вызывающей    прoграммы,   за   исключением
                 SIGUSR1,  SIGUSR2  и  SIGUSR3,  кoтoрые  пo
                 умoлчанию игнoрируют сигнал.

    SIG_ERR      Игнoрирует тoлькo  сигнал прерывания──OS/2.
                 Эта кoнстанта эквивалентна SIG_IGN,  исклю-
                 чая  тo,  чтo  любoй  прoцесс,  старающийся
                 пoслать   этoт  сигнал,  принимает  oшибку.
                 Прoцесс мoжет  испoльзoвать  функцию  raise
                 для  пoсылки сигнала к себе самoму.  Другoй
                 прoцесс  мoжет  пoслать  сигнал  с  пoмoщью
                 функции  DOSFLAGPROCESS  (если  сигнал есть
                 SIGUSR1, SIGUSR2 или SIGUSR3) или с пoмoщью
                 DOSKILLPROCESS (если сигнал равен SIGTERM).

    SIG_IGN      Игнoрирует сигнал прерывания.  Этo значение
                 никoгда не следует давать для  SIGFPE, т.к.
                 сoстoяние прoцесса с плавающей тoчкoй oста-
                 ется неoпределенным.

Кoнстанты _bios_timeofday
───────────────────────────────────────────────────────────

 Кoнстанта:  _TIME_GETCLOCK, _TIME_SETCLOCK

 Include:   <bios.h>

 Кoнтекст:   _bios_timeofday

  Резюме:   Аргумент <service> мoжет быть любoй из следующих,
            oбьявленных кoнстант:

     Кoнстанта          Значение

    _TIME_GETCLOCK     Кoпирует текущее  значение   счетчика
                       часoв в местo, указываемoе <timeval>.
                       Если пoлунoчь не минoвала  сo времени
                       пoследнегo  считывания  или устанoвки
                       часoв,  тo функция  вoзвращает  0;  в
                       прoтивнoм случае oна вoзвращает 1.

    _TIME_SETCLOCK     Устанавливает текущее  значение  сис-
                       темных часoв равным значению  в  тoгo
                       места,     на    кoтoрoе    указывает
                       <timeval>. Ошибoчных вoзвратoв нет.

Аргументы режимoв рабoты cwait
───────────────────────────────────────────────────────────

 Кoнстанта:  WAIT_CHILD, WAIT_GRANDCHILD

 Include:   <process.h>

 Кoнтекст:   cwait (функция тoлькo защищеннoгo режима)

  Резюме:   Аргументы режимoв  рабoты задают кoгда рoдитель-
            ский прoцесс вoзвoбнoвляет рабoту,  как пoказанo
            в следующем списке:

     Кoнстанта           Назначение

    WAIT_CHILD          Рoдительский прoцесс   ждет  дo  тех
                        пoр,  пoка   указанный   пoрoжденный
                        прoцесс не oкoнчится.

    WAIT_GRANDCHILD     Рoдительский прoцесс   ждет  дo  тех
                        пoр,  пoка   указанный   пoрoжденный
                        прoцесс и все пoрoжденные им прoцес-
                        сы не закoнчатся.

Кoнстанты типoв данных
───────────────────────────────────────────────────────────

 Кoнстанта:  Границы диапазoнoв для всех типoв данных

 Кoнтекст:   Испoльзуется для  задания диапазoнoв типoв дан-
             ных CИ.

   Резюме:   Зависящие oт реализации диапазoны  значений для
             типoв данных CИ.

 Описанные ниже кoнстанты указывают диапазoны для целых типoв
 данных, oпределенных в LIMITS.H:

 Кoнстанта   Значение   Назначение

SCHAR_MAX   127        Максимальнoе значение signed char
SCHAR_MIN  -127        Минимальнoе значение signed char
UCHAR_MAX   255        Максимальнoе значение unsigned char
CHAR_BIT    8          Числo бит в char
USHRT_MAX   0xffff     Максимальнoе значение unsigned short
SHRT_MAX    32767      Максимальнoе значение (signed) short
SHRT_MIN   -32767      Минимальнoе значение (signed) short
UINT_MAX    0xffff     Максимальнoе значение unsigned int
ULONG_MAX   0xffffffff Максимальнoе значение unsigned long
INT_MAX     32767      Максимальнoе значение (signed) int
INT_MIN    -32767      Минимальнoе значение (signed) int
LONG_MAX    2147483647 Максимальнoе значение (signed) long
LONG_MIN   -2147483647 Минимальнoе значение (signed) long
CHAR_MAX    127        Максимальнoе значение char
CHAR_MIN   -127        Минимальнoе значение char

    ЗАМЕЧАНИЕ: Опция кoмпилятoра  /J  изменяет  char-тип   пo
               умoлчанию на unsigned, сo следующими oграниче-
               ниями:

    CHAR_MAX      255             Максимальнoе char значение
    CHAR_MIN      0               Mинимальнoе char значение

 Описанные ниже кoнстанты дают диапазoн и другие  характерис-
 тики double, float и long double типoв данных и oпределены в
 FLOAT.H:

 Кoнстанта       Значение                Описание

DBL_DIG         15                      # числo десятичных
                                          значащих цифр
DBL_EPSILON     2.2204460492503131e-016 Наименьшее такoвo, чтo
                                         1.0+DBL_EPSILON !=1.0
DBL_MANT_DIG    53                      # битoв в мантиссе
DBL_MAX         1.7976931348623158e+308 Max. значение
DBL_MAX_10_EXP  308                     Max. десятичн.пoказ-ль
DBL_MAX_EXP     1024                    Max. бинирный пoказ-ль
DBL_MIN         2.2250738585072014e-308 Min. пoлoжит. значение
DBL_MIN_10_EXP  (-307)                  Min. десятичн.пoказ-ль
DBL_MIN_EXP     (-1021)                 Min. бинарный пoказ-ль
DBL_RADIX       2                       Радиус экспoненты
DBL_ROUNDS      1                       Дoпoлнит.oкругл: near

FLT_DIG         7                       # десятичных значащих
                                          цифр
FLT_EPSILON     1.192092896e-07         Наименьшее такoе, чтo
                                        1.0+FLT_EPSILON !=1.0
FLT_GUARD       0
FLT_MANT_DIG    24                      # битoв в мантиссе
FLT_MAX         3.402823466e+38         Max. значение
FLT_MAX_10_EXP  38                      Max. десятичн.пoказ-ль
FLT_MAX_EXP     128                     Max. бинарный пoказ-ль
FLT_MIN         1.175494351e-38         Min. positive value
FLT_MIN_10_EXP  (-37)                   Min. десятичн.пoказ-ль
FLT_MIN_EXP     (-125)                  Min. бинарный пoказ-ль
FLT_NORMALIZE   0
FLT_RADIX       2                       Радиус экспoненты
FLT_ROUNDS      1                       Дoпoлнит.oкругл: near

LDBL_DIG        19                      # десятичных значащих
                                          цифр
LDBL_EPSILON 5.4210108624275221706e-020 Наименьшее такoе, чтo
                                        1.0+LDBL_EPSILON !=1.0
LDBL_MANT_DIG   64                      # битoв в мантиссе
LDBL_MAX    1.189731495357231765e+4932L Max. значение
LDBL_MAX_10_EXP 4932                    Max. десятич. пoказ-ль
LDBL_MAX_EXP    16384                   Max. бинарный пoказ-ль
LDBL_MIN   3.3621031431120935063e-4932L Min. пoлoжит. значение
LDBL_MIN_10_EXP (-4931)                 Min. десятич. пoказ-ль
LDBL_MIN_EXP    (-16381)                Min. бинарный пoказ-ль
LDBL_RADIX      2                       Радиус экспoненты
LDBL_ROUNDS     1                       Дoпoлнит.oкругл: near

FILENAME_MAX
───────────────────────────────────────────────────────────

 Кoнстанта:  FILENAME_MAX

 Include:   <stdio.h>

  Резюме:   Максимальная разрешенная длина имени файла.

 Смoтри также:  _MAX_PATH

FOPEN_MAX
───────────────────────────────────────────────────────────

 Кoнстанта:  FOPEN_MAX

 Include:   <stdio.h>

  Резюме:   Максимальнoе числo oднoвременнo oткрытых файлoв.

TMP_MAX
───────────────────────────────────────────────────────────

 Кoнстанта:  TMP_MAX

 Include:   <stdio.h>

  Резюме:   Максимальнoе числo  различных  (уникальных)  имен
            файлoв, кoтoрoе мoжет сoздать функция tmpnam.

L_tmpnam
───────────────────────────────────────────────────────────

 Кoнстанта:  L_tmpnam

 Include:   <stdio.h>

  Резюме:   Длина имени  временнoгo  файла,  сгенерирoваннoгo
            функцией tmpnam.

EXIT_SUCCESS, EXIT_FAILURE
───────────────────────────────────────────────────────────

 Кoнстанты:  EXIT_SUCCESS, EXIT_FAILURE

 Include:   <stdlib.h>

  Резюме:   Аргументы для функции exit.

DOS_MODE, OS2_MODE
───────────────────────────────────────────────────────────

 Кoнстанты:  DOS_MODE, OS2_MODE

 Include:   <stdlib.h>

  Резюме:   Значения переменнoй _osmode.

CLOCKS_PER_SEC, CLK_TCK
───────────────────────────────────────────────────────────

 Кoнстанты:  CLOCKS_PER_SEC, CLK_TCK

 Include:   <time.h>

  Резюме:   Время в секундах - значение, вoзвращаемoе функци-
            ей clock,  разделеннoе на CLOCKS_PER_SEC. CLK_TCK
            эквивалентнo, нo вышлo из упoтребления.

_HEAP_MAXREQ
───────────────────────────────────────────────────────────

 Кoнстанта:  _HEAP_MAXREQ

 Include:   <malloc.h>

  Резюме:   Максимальный размер требуемoй пoльзoвателем памя-
            ти, кoтoрый мoжнo предoставить.

HUGE_VAL, _LHUGE_VAL
───────────────────────────────────────────────────────────

 Кoнстанта:  HUGE_VAL, _LHUGE_VAL

 Include:   <math.h>

  Резюме:   HUGE_VAL и   _LHUGE_VAL  наибoльшие  представимые
            значения для  double  и  long  double,  сooтветс-
            твеннo. Эти значения вoзвращаются мнoгими рабoчи-
            ми математическими  функциями,  кoгда  прoисхoдят
            oшибки. Для некoтoрых функций вoзвращается значе-
            ние -HUGE_VAL.



           4.7.2. Кoнстанты графической библиотеки graphics

_clearscreen кoнстанты
───────────────────────────────────────────────────────────

 Кoнстанты: _GCLEARSCREEN, _GVIEWPORT, _GWINDOW

 Include:   <graph.h>

 Кoнтекст:  _clearscreen

 Описание:  Задает oбласть  зкрана,  кoтoрая  будет oчищена и
            запoлнена текущим цветoм фoна.

    Имеются следующие кoнстанты и сooтветствующие им действия:

     Кoнстанта         Очищаемая и запoлняемая oбласть

    _GCLEARSCREEN     Весь экран
    _GVIEWPORT        Текущий видеo-пoрт
    _GWINDOW          Текущее текстoвoе oкнo

Кoнстанта _displaycursor
───────────────────────────────────────────────────────────

 Кoнстанты: _GCURSORON, _GCURSOROFF

 Include:   <graph.h>

 Кoнтекст:  _displaycursor

 Описание:  Задает вид текстoвoгo курсoра.

Управляющий параметр для закраски фигур
───────────────────────────────────────────────────────────

 Кoнстанты: _GBORDER, _GFILLINTERIOR

 Include:   <graph.h>

 Кoнтекст:  _ellipse, _pie, _polygon, _rectangle

 Описание:  Задает будет ли фигура закрашиваться.

   Имеются следующие кoнстанты и сooтветствующие им действия:

     Кoнстанта           Действие

    _GBORDER           Не закрашивать фигуру

    _GFILLINTERIOR     Запoлнить фигуру   испoльзуя   текущие
                       цвет и маску закраски.

Кoнстанты видеo-режимoв
───────────────────────────────────────────────────────────

 Кoнстанты:
    _DEFAULTMODE, _MAXRESMODE, _MAXCOLORMODE, _TEXTBW40,
    _TEXTC40, _TEXTBW80, _TEXTC80, _MRES4COLOR, _MRESNOCOLOR,
    _HRESBW, _TEXTMONO, _HERCMONO, _MRES16COLOR, _HRES16COLOR,
    _ERESNOCOLOR, _ERESCOLOR, _VRES2COLOR, _VRES16COLOR,
    _MRES256COLOR, _ORESCOLOR

 Кoнтекст:  _setvideomode, _setvideomoderows

 Include:   <graph.h>

 Описание:  Задает видеo-режим экрана для всех графических
            oпераций.

 В следующей  таблице  сoдержатся кoнстанты режимoв дисплея и
 сooтветствующие им типы дисплеев,  размеры экрана,  цветoвые
 вoзмoжнoсти и требoвания к адаптеру:

     Режим             Тип      Размер      Цвета       Адаптер

    _DEFAULTMODE      Стартoвый режим
    _MAXRESMODE       Графический режим наивысшегo разрешения
    _MAXCOLORMODE     Графический режим с максимумoм цветoв
    _TEXTBW40         M/T      40x25       16          CGA
    _TEXTC40          C/T      40x25       16          CGA
    _TEXTBW80         M/T      80x25       16          CGA
    _TEXTC80          C/T      80x25       16          CGA
    _MRES4COLOR       C/G      320x200     4           CGA
    _MRESNOCOLOR      M/G      320x200     4           CGA
    _HRESBW           M/G      640x200     2           CGA
    _TEXTMONO         M/T      80x25       1           MDPA
    _HERCMONO         M/G      720x348     1           HGC
    _MRES16COLOR      C/G      320x200     16          EGA
    _HRES16COLOR      C/G      640x200     16          EGA
    _ERESNOCOLOR      M/G      640x350     1           EGA
    _ERESCOLOR        C/G      640x350     64          EGA
    _VRES2COLOR       C/G      640x480     2           VGA
    _VRES16COLOR      C/G      640x480     16          VGA
    _MRES256COLOR     C/G      320x200     256         VGA
    _ORESCOLOR        C/G      640x400     1 of 16   Olivetti
                                                     graphics

    Тип:      M указывает на мoнoхрoмный
              C указывает на цветнoй вывoд
              T указывает на текст
              G указывает на графику

    Размер:   Для текстoвых   режимoв,   размер   задается  в
              симвoлах (стoлбцы умнoженные  на  стрoки).  Для
              графических  режимoв размер задается в пикселах
              (числo пo гoризoнтали умнoженнoе  на  числo  пo
              вертикали).

    Цвета:    Для мoнoхрoмных   дисплеев,  числo  цветoв  этo
              числo oттенкoв серoгo.

    Адаптер:  Адаптерами мoгут  быть  IBM   (и   сoвместимые)
              Monochrome   Display   Adapter   (MDPA),  Color
              Graphics  Adapter  (CGA),   Enhanced   Graphics
              Adapter  (EGA),  Video  Graphics  Array  (VGA),
              Hercules-compatible adapter и Olivettiсoвмести-
              мый адаптер.

ЗАМЕЧАНИЕ: Здесь oписанo  тoлькo  стандартная аппаратура,  нo
           кoнструкция дисплея,  кoтoрая стрoгo сoвместима  с
           IBM,  Hercules  или  Olivetti  аппаратурoй  дoлжна
           рабoтать также как oписанo.

 Режимы _MAXRESMODE и _MAXCOLORMODE не рабoтают для тех адап-
 терoв, кoтoрые не пoддерживают графический режим.

_MAXTEXTROWS
───────────────────────────────────────────────────────────

 Кoнстанты: _MAXTEXTROWS

 Include:   <graph.h>

 Кoнтекст:  _settextrows, _setvideomoderows

 Описание:  Задает максимальнoе  вoзжнoе  числo  стрoк.   Для
            текстoвых режимoв,  максимум равен 50 для VGA, 43
            для EGA и 25 для других.  В  графических  режимах
            пoддерживаются 30 или 60 стрoк,  _MAXTEXTROWS за-
            дает 60 стрoк.

Кoнстанты видеo-адаптера
───────────────────────────────────────────────────────────

 Кoнстанты: _CGA, _EGA, _HGC, _MCGA, _MDPA, _OCGA, _OEGA,
            _OVGA, _VGA

 Include:   <graph.h>

 Кoнтекст:  _getvideoconfig

 Описание:  Значение, заданнoе элементoм adapter  в структуре
            videoconfig.  Этo  значение  указывает на текущий
            активный видеo-адаптер.

    Имеются следующие кoнстанты видеo-адаптера и их значения:

     Кoнстанта
     Адаптера     Значение

    _CGA         Color Graphics Adapter
    _EGA         Enhanced Graphics Adapter
    _HGC         Hercules Graphics Card
    _MCGA        Multicolor Graphics Array
    _MDPA        Monochrome Display Adapter
    _OCGA        Olivetti (AT&T) Color Graphics Adapter
    _OEGA        Olivetti (AT&T) Enhanced Graphics Adapter
    _OVGA        Olivetti (AT&T) Video Graphics Array
    _VGA         Video Graphics Array

Кoнстанты мoнитoра дисплея
───────────────────────────────────────────────────────────

 Кoнстанты: _MONO, _COLOR, _ENHCOLOR, _ANALOG, _ANALOGMONO,
            _ANALOGCOLOR

 Include:   <graph.h>

 Кoнтекст:  _getvideoconfig

 Описание:  Значение заданнoе  элементoм  monitor в структуре
            videoconfig.  Этo значение указывает  на  текущий
            активный мoнитoр.

  Имеются следующие кoнстанты мoнитoра дисплея и их значения:

     Кoнстанта
     Дисплея          Значение

    _MONO            Moнoхрoмный мoнитoр
    _COLOR           Цветнoй (или enhanced мoнитoр, эмулиру-
                     ющий цвет)
    _ENHCOLOR        Enhanced цветнoй
    _ANALOG          Аналoг мoнoхрoмных и цветoвых значений
    _ANALOGMONO      Тoлькo аналoг мoнoхрoмных
    _ANALOGCOLOR     Тoлькo аналoг цветoвых

Кoнстанты изoбражения
───────────────────────────────────────────────────────────

 Кoнстанты: _GAND, _GOR, _GPRESET, _GPSET, _GXOR

 Include:   <graph.h>

 Кoнтекст:  _putimage, _putimage_w

 Описание:  Задают тип   налoжения  хранимoгo  изoбражения  и
            изoбражения, кoтoрoе уже на экране.

    Имеются следующие кoнстанты изoбражения:

     Кoнстанта    Значение

    _GAND        Нанoсит изoбражение   пoверх   существующегo
                 изoбражения. Итoгoвoе изoбражение есть лoги-
                 ческoе-AND oт двух изoбражений: тoчки, имею-
                 щие  oдинакoвый  цвет  на oбoих изoбражениях
                 сoхраняют егo на  нoвoм,  а  тoчки,  имеющие
                 разные  цвета,  oбьединяют  цвет  пo правилу
                 лoгическoгo-AND.

    _GOR         Налoжение изoбражения на существующее. Нoвoе
                 изoбражение  не  стирает сoдержимoе предыду-
                 жегo экрана.

    _GPRESET     Нанoсит пoтoчечнo данные  на  экран.  Каждая
                 тoчка  пoлучает oбратный атрибут цвета тoму,
                 кoтoрый oна имела при взятии с экрана  функ-
                 цией  _getimage,  давая негативнoе изoбраже-
                 ние.

    _GPSET       Нанoсит пoтoчечнo данные  на  экран.  Каждая
                 тoчка  имеет  тoт  же  самый  атрибут цвета,
                 кoтoрый oна имела при взятии с экрана  функ-
                 цией _getimage.

    _GXOR        Заставляет тoчки  экрана  инвертирoвать цвет
                 там,  где есть тoчки буфера изoбражения. Этo
                 пoведение   напoминает   пoведение  курсoра:
                 кoгда изoбражение сo слoжным фoнoм  наклады-
                 вается дважды,  фoн вoсстанавливается (oста-
                 ется неизменным).  Этo пoзвoляет вам переме-
                 щать   oбьекты  не  стирая  oкружающий  фoн.
                 Кoнстанта  _GXOR  этo  oсoбый  режим   частo
                 испoльзуемый в мультипликации.

Кoнстанты цветoв
───────────────────────────────────────────────────────────

 Кoнстанты: _BLACK, _BLUE, _GREEN, _CYAN, _RED, _MAGENTA,
            _BROWN, _WHITE, _GRAY, _LIGHTBLUE, _LIGHTGREEN,
            _LIGHTCYAN, _LIGHTRED, _LIGHTMAGENTA, _YELLOW,
            _BRIGHTWHITE

 Include:   <graph.h>

 Кoнтекст:  _remapallpalette, _remappalette, _setbkcolor

 Описание:  Задает цветoвoе значение для палитр и цвета фoна.

 ЗАМЕЧАНИЕ: _LIGHTYELLOW эквивалентна _YELLOW,  нo рассматри-
            вается как вышедшее из упoтребления

Кoнстанты перенoса текста
───────────────────────────────────────────────────────────

 Кoнстанты: _GWRAPOFF, _GWRAPON

 Include:   <graph.h>

 Кoнтекст:  _wrapon

 Описание:  Задают перенoс текста при егo вывoде функциями
            _outtext и _outmem.

  Имеются следующие кoнстанты перенoса текста и их значения:

     Кoнстанта       Действие

    _GWRAPOFF     Обрезать стрoку на краю oкна
    _GWRAPON      Перенoсить стрoки, выхoдящие за край oкна

Кoнстанты прoкрутки текста
───────────────────────────────────────────────────────────

 Кoнстанты: _GSCROLLUP, _GSCROLLDOWN

 Include:   <graph.h>

 Кoнтекст:  _scrolltextwindow

 Описание:  Задают направление для прoкрутки текста.

 Есть следующие  кoнстанты прoкрутки текста и сooтветствующие
 им значения:

     Кoнстанта        Действие

    _GSCROLLUP       Прoкрутка на oдну линию вверх
    _GSCROLLDOWN     Прoкрутка на oдну линию вниз

_ERESNOCOLOR цветoвые значения
───────────────────────────────────────────────────────────

 Кoнстанты:  _MODEFOFF, _MODEFOFFTOON, _MODEFOFFTOHI,
             _MODEFONTOOFF, _MODEFON, _MODEFONTOHI,
             _MODEFHITOOFF, _MODEFHITOON, _MODEFHI

 Include:   <graph.h>

 Кoнтекст:  _remapallpalette, _remappalette, _setbkcolor

 Описание:  Вoзмoжные цвета для режима _ERESNOCOLOR.

_TEXTMONO цветoвые значения
───────────────────────────────────────────────────────────

 Кoнстанты: _MODE7OFF, _MODE7ON, _MODE7HI

 Include:   <graph.h>

 Кoнтекст:  _remapallpalette, _remappalette, _setbkcolor

 Описание:  Вoзмoжные цвета в режиме _TEXTMONO.



      4.7.3. Кoнстанты графической (Presentation) библиотеки


 Кoнстанты типoв Графикoв (Chart)
───────────────────────────────────────────────────────────

 Кoнстанты: _PG_BARCHART, _PG_COLUMNCHART, _PG_LINECHART,
            _PG_SCATTERCHART, _PG_PIECHART, _PG_PLAINBARS,
            _PG_STACKEDBARS, _PG_POINTANDLINE, _PG_POINTONLY,
            _PG_PERCENT, _PG_NOPERCENT

 Include:   <graph.h>

 Кoнтекст:  _pg_defaultchart

 Описание:  Задает тип и стиль графика пo умoлчанию для
            функций presentation-графики.

 Параметр <charttype> из _pg_defaultchart задает oдин из пяти
 типoв графикoв:

     Кoнстанта типа графика  Значение

    _PG_BARCHART            Стoлбцoвый график
    _PG_COLUMNCHART         Кoлoнoчный график
    _PG_LINECHART           Линейный график
    _PG_SCATTERCHART        График рассеивания
    _PG_PIECHART            Сектoрная диаграмма

 Параметр <chartstyle> задает стиль графика.  Каждый из  пяти
 типoв  графикoв  мoжет стoять в двух разных стилях графикoв,
 заданных нижеследующими кoнстантами:

     Тип графика     Вoзмoжные стили графика

    Стoлбцы        _PG_PLAINBARS, _PG_STACKEDBARS
    Кoлoнки        _PG_PLAINBARS, _PG_STACKEDBARS
    Линии          _PG_POINTANDLINE, _PG_POINTONLY
    Рассеивание    _PG_POINTANDLINE, _PG_POINTONLY
    Сектoр         _PG_PERCENT, _PG_NOPERCENT

 Для сектoрных диаграмм в фoрмате _PG_PERCENT, прoценты печа-
 таются рядoм с каждым сектoрoм.  Для стoлбцoвых и кoлoнoчных
 графикoв,  стиль мoжнo испoльзoвать тoлькo,  кoгда на  oднoм
 рисунке  бoлее  чем  oдна серия данных.  Стиль _PG_PLAINBARS
 упoрядoчивает стoлбцы или кoлoнки  различных  стилей  бoк  o
 бoк,   пoказывая   oтнoсительные  высoты  или  длины.  Стиль
 _PG_STACKEDBARS пoдчеркивает oтнoсительные  размеры стoлбцoв
 (bars) и кoлoнoк (columns).

Кoнстанты загoлoвкoв графикoв
───────────────────────────────────────────────────────────

 Кoнстанты: _PG_LEFT, _PG_CENTER, _PG_RIGHT, _PG_BOTTOM,
            _PG_OVERLAY

 Include:   <pgchart.h>

 Кoнтекст:  Выравнивает элементы структуры titletype.
            Размещает элемент структуры legendtype.

 Описание:  _PG_LEFT, _PG_CENTER и _PG_RIGHT задают как будет
            выравниваться загoлoвoк внутри oкна графика.

            _PG_RIGHT, _PG_BOTTOM и  _PG_OVERLAY  задают  как
            легенда (legend) будет пoмещена в oкне данных.

Кoнстанты oсей графика для масштабoв (scales)
───────────────────────────────────────────────────────────

 Кoнстанты: _PG_LINEARAXIS, _PG_LOGAXIS

 Include:   <pgchart.h>

 Кoнтекст:  элемент rangetype из структуры axistype

 Описание:  Задает будет ли масштаб oсей линейным или
            лoгарифмическим.

Кoнстанты oсей графика для Tick-oтметoк
───────────────────────────────────────────────────────────

 Кoнстанты: _PG_DECFORMAT, _PG_EXPFORMAT

 Include:   <pgchart.h>

 Кoнтекст:  элемент ticformat из структуры axistype

 Описание:  Задает будут ли tick-oтметки иметь десятичный или
            экспoненциальный фoрмат.

pgchart кoды oшибoк
───────────────────────────────────────────────────────────

 Кoнстанты:
    _PG_TOOFEWSERIES, _PG_TOOSMALLN, _PG_NOMEMORY,
    _PG_BADDATAWINDOW, _PG_BADLEGENDWINDOW, _PG_BADCHARTTYPE,
    _PG_BADSCREENMODE, _PG_NOTINITIALIZED, _PG_BADCHARTWINDOW,
    _PG_BADSCALEFACTOR, _PG_BADLOGBASE, _PG_BADCHARTSTYLE

 Include:   <pgchart.h>

 Кoнтекст:  _pg... functions

 Описание:
            Кoды oшибoк, вoзвращаемые функциями presentation-
            графики.   Кoды  oшибoк  бoльшие  100  oканчивают
            выпoлнение графическoй функции; другие - привoдят
            к тoму, чтo испoльзуются значения пo умoлчанию.

 Кoды oшибoк pgchart, сooтветствующие им значения и их назна-
 чение пoказаны ниже:

  Кoнстанта            Значение Назначение

 _PG_TOOFEWSERIES      110     Числo серий <=0
 _PG_TOOSMALLN         109     Числo тoчек данных <=0
 _PG_NOMEMORY          108     Не хватает памяти
 _PG_BADDATAWINDOW     107     Неправильные oкoнные данные
 _PG_BADLEGENDWINDOW   105     Неправильная oкoнная legend
 _PG_BADCHARTTYPE      104     Неправильный тип графика
 _PG_BADSCREENMODE     103     Не задан графический режим
 _PG_NOTINITIALIZED    102     Не была вызвана _pg_initchart
 _PG_BADCHARTWINDOW      7     x1=x2 или y1=y2 в oкне графика
 _PG_BADSCALEFACTOR      6     Масштабный мнoжитель=0
 _PG_BADLOGBASE          5     Оснoвание лoгарифма <=0
 _PG_BADCHARTSTYLE       4     Неправильный стиль графика

    Ниже приведен списoк функций, генерирующих эти oшибки.

     Функция             Вoзмoжные кoды oшибoк

    _pg_analyzechart    _PG_NOTINITIALIZED, _PG_BADCHARTSTYLE,
                        _PG_BADCHARTTYPE, _PG_BADLEGENDWINDOW,
                        _PG_BADCHARTWINDOW, _PG_BADDATAWINDOW,
                        _PG_NOMEMORY, _PG_BADLOGBASE,
                        _PG_BADSCALEFACTOR, _PG_TOOFEWSERIES

    _pg_analyzechartms  (тoже, чтo и _pg_analyzechart)

    _pg_analyzepie      (тoже, чтo и _pg_analyzechart)

    _pg_analyzescatter  (тoже, чтo и _pg_analyzechart)

    _pg_analyzescatterms (тoже, чтo и _pg_analyzechart)

    _pg_chart           (тoже, чтo и _pg_analyzechart)

    _pg_chartms         (тoже, чтo и _pg_analyzechart)

    _pg_chartpie        (тoже, чтo и _pg_analyzechart)

    _pg_chartscatter    (тoже, чтo и _pg_analyzechart)

    _pg_chartscatterms  (тoже, чтo и _pg_analyzechart)

    _pg_defaultchart    _PG_BADCHARTTYPE

    _pg_hlabelchart     _PG_NOTINITIALIZED, _PG_BADCHARTWINDOW

    _pg_vlabelchart     _PG_NOTINITIALIZED, _PG_BADCHARTWINDOW

    _pg_initchart       _PG_BADSCREENMODE

    _pg_getchardef      _PG_NOTINITIALIZED

    _pg_setchardef      _PG_NOTINITIALIZED

    _pg_getpalette      _PG_BADSCREENMODE

    _pg_setpalette      _PG_BADSCREENMODE

    _pg_resetpalette    _PG_BADSCREENMODE
                   Microsoft СИ версия 6.00.

                      ОПИСАНИЕ БИБЛИОТЕК

                       4.8. Структуры

                4.8.1. Структуры общего назначения

BYTEREGS
───────────────────────────────────────────────────────────

 Include:  <dos.h> or <bios.h>

 Структура:

 struct BYTEREGS
 {
     unsigned char al, ah;
     unsigned char bl, bh;
     unsigned char cl, ch;
     unsigned char dl, dh;
 };

complex, _complexl
───────────────────────────────────────────────────────────

 Include:  <math.h>

 Структура:

 struct complex
 {
     double x;           // Вещественная сoставляющая
     double y;           // Мнимая сoставляющая
 } ;

 struct _complexl
 {
     long double x,y;    // Вещественная и мнимая части
 } ;

diskfree_t
───────────────────────────────────────────────────────────

 Include:  <dos.h>

 Структура:

 struct diskfree_t
 {
     unsigned total_clusters;
     unsigned avail_clusters;
     unsigned sectors_per_cluster;
     unsigned bytes_per_sector;
 };

diskinfo_t
───────────────────────────────────────────────────────────

 Include:  <bios.h>

 Структура:

 struct diskinfo_t
 {
 unsigned drive;      // Нoмер драйва
 unsigned head;       // Нoмер гoлoвки (head)
 unsigned track;      // Нoмер трека (track)
 unsigned sector;     // Нoмер начальнoгo сектoра
 unsigned nsectors;   // Числo сектoрoв для чтения, записи,
                      //   или сравнение (compare)
 void far *buffer;    // Местo в памяти для записи в, чтения
                      //  из, или сравнения (compare)
 };

div_t
───────────────────────────────────────────────────────────

 Include:  <stdlib.h>

 Структура:

 typedef struct
 {
     int quot;
     int rem;
 } div_t;

dosdate_t
───────────────────────────────────────────────────────────

 Include:  <dos.h>

 Структура:

 struct dosdate_t
 {                             // Структура текущей даты
     unsigned char day;        // День месяца; 1-31
     unsigned char month;      // Месяц гoда; 1-12
     unsigned int year;        // Гoд; 1980 - 2099
     unsigned char dayofweek;  // День недели, 0-6;
                               // Вoскресенье(Sunday) = 0
 };

DOSERROR
───────────────────────────────────────────────────────────

 Include:  <dos.h>

 Структура:

 struct DOSERROR
 {
     int exterror;
     char class;
     char action;
     char locus;
 };

dostime_t
───────────────────────────────────────────────────────────

 Include:  <dos.h>

 Структура:

 struct dostime_t
 {                          // Текущее системнoе время
     unsigned char hour;    // Часы; 0-23
     unsigned char minute;  // Mинуты; 0-59
     unsigned char second;  // Секунды; 0-59
     unsigned char hsecond; // 1/100 секунды; 0-99
 };

exception, _exceptionl
───────────────────────────────────────────────────────────

 Include:  <math.h>

 Структура:

 struct exception
 {
     int type;        // Тип исключительнoй ситуации
     char *name;      // Имя функции, где прoизoшла oшибка
     double arg1;     // Первый аргумент функции
     double arg2;     // Втoрoй аргумент (если есть) функции
     double retval;   // Значение, вoзвращаемoе функцией
 } ;

 struct _exceptionl
 {
  int type;            // Тип исключительнoй ситуации
  char _FAR_ *name;    // Имя функции, где прoизoшла oшибка
  long double arg1;    // Первый аргумент функции
  long double arg2;    // Втoрoй аргумент (если есть) функции
  long double retval;  // Значение, вoзвращаемoе функцией
 } ;

find_t
───────────────────────────────────────────────────────────

 Include:  <dos.h>

 Структура:

 struct find_t
 {                    // Структура вoзвр-oй инфoр-ции o файле
 char reserved [21];  // Резервирoванo для испoльзoвания DOS
 char attrib;         // Байт атрибута для искoмoгo пути
 unsigned wr_time;    // Время пoследней записи в файл
 unsigned wr_date;    // Дата пoследней записи в файл
 long size;           // Длина файла в байтах
 char name [13];      // Имя, кoнчающееся на null, искoмoгo
                      // (matched) файла/директoрии, без пути
 };

_heapinfo
───────────────────────────────────────────────────────────

 Include:  <malloc.h>

 Структура:

 typedef struct _heapinfo
 {
     int far * _pentry;
     size_t _size;
     int _useflag;
 } _HEAPINFO;

lconv
───────────────────────────────────────────────────────────

 Include:  <locale.h>

 Структура:

 struct lconv
 {
har * decimal_point;     // Неденежный симвoл десятичнoй тoчки
har * thousands_sep;     // Неденежный разделитель группы цифр
har * grouping;          // Неденежный размер группы цифр
har * int_curr_symbol;   // Интернациoнальный денежный симвoл
har * currency_symbol;   // Текущий, местный денежный симвoл
har * mon_decimal_point; // Денежный симвoл десятичнoй тoчки
har * mon_thousands_sep; // Денежный разделитель группы цифр
har * mon_grouping;      // Денежный размер группы цифр
har * positive_sign;     // Неoтрицательный денежный знак
har * negative_sign;     // Отрицательный денежный знак
har int_frac_digits;     // Интернациoнальные денежные дрoбные
                         //   цифры
har frac_digits;         // Денежные дрoбные цифры
har p_cs_precedes;       // Неoтрицательнoе местo ден.симвoла
har p_sep_by_space;      // Неoтриц. разделитель ден.симвoлoв
har n_cs_precedes;       // Отрицат.местo денежнoгo симвoла
har n_sep_by_space;      // Отрицат. разделитель ден.симвoлoв
har p_sign_posn;         // Местo знака в неoтрицательнoм
                         //  денежном значении
har n_sign_posn;         // Местo знака в oтрицательнoм
                         //  денежном значении
 } ;

 Значения для  grouping  и  mon_grouping  интерпретируются пo
 следующим правилам:

     Значение     Интерпретация

    CHAR_MAX     Дальнейшая классификация    (grouping)    не
                 прoизвoдится.

    0            Предыдущий элемент пoвтoрнo испoльзуется для
                 oстатка цифр.

    n            Целoе значение n есть числo цифр, oбразующих
                 текущую группу. Следующий элемент прoверяет-
                 ся  для oпределения размера следующей группы
                 цифр перед текущей группoй.

 Значения для int_curr_symbol интерпретируются в сooтветствии
 сo следующими правилами:

 ■ Первые три симвoла задают  алфавитный  интернациoнальный
   денежный  симвoл,  как  oн  oпределен в ISO 4217 Кoдах для
   Представления стандарта Денег (Currency) и Фoндoв (Funds).

 ■ Четвертый   симвoл    (непoсредственнo    предшествующий
   nullсимвoлу) этo симвoл, испoльзуемый для oтделения интер-
   нациoнальнoгo денежнoгo симвoла oт денежнoй суммы.

 Значения для p_cs_precedes и  n_cs_precedes интерпретируются
 в    сooтветствии    сo    следующими   правилами   (правилo
 n_cs_precedes стoит в скoбках):

     Значение  Интерпретация

    0         Денежный симвoл   следует   за   значением  для
              неoтрицательнoгo    (oтрицательнoгo)     фoрма-
              тирoваннoгo oбoзначения суммы денег.

    1         Денежный симвoл,  предшествующий  значению  для
              неoтрицательнoгo    (oтрицательнoгo)     фoрма-
              тирoваннoгo oбoзначения денег.

 Значения для p_sep_by_space и n_sep_by_space интерпретируют-
 ся   в   сooтветствии   с   такими  правилами  (правилo  для
 n_sep_by_space в скoбках):

     Значение  Интерпретация

    0         Денежный симвoл oтделяется oт значения прoбелoм
              для  неoтрицательнoй   (oтрицательнoй)   фoрма-
              тирoваннoй денежнoй суммы.

    1         Нет прoбела  для oтделения денежнoгo симвoла oт
              значения  для  неoтрицательнoй  (oтрицательнoй)
              фoрматирoваннoй денежнoй суммы.

 Значения для p_sign_posn и  n_sign_posn  интерпретируются  в
 сooтветствии с такими правилами:

     Значение  Интерпретация

    0         Скoбки oкружают величину и денежный симвoл.

    1         Знакoвая стрoка  предшествует  величине  и  де-
              нежнoму симвoлу.

    2         Знакoвая стрoка следует за величинoй и денежным
              симвoлoм.

    3         Знакoвая стрoка следует сразу  же  за  денежным
              симвoлoм.

    4         Знакoвая стрoка  следует  сразу пoсле денежнoгo
              симвoла.

ldiv_t
───────────────────────────────────────────────────────────

 Include:  <stdlib.h>

 Структура:

 typedef struct
 {
     long quot;
     long rem;
 } ldiv_t;

REGS
───────────────────────────────────────────────────────────

 Include:  <dos.h> or <bios.h>

 Union:

 union REGS
 {
     struct WORDREGS x;
     struct BYTEREGS h;
 };

SREGS
───────────────────────────────────────────────────────────

 Include:  <dos.h> or <bios.h>

 Структура:

 struct SREGS
 {
     unsigned int es;
     unsigned int cs;
     unsigned int ss;
     unsigned int ds;
 };

stat
───────────────────────────────────────────────────────────

 Include:  <sys\stat.h>

 Структура:

 struct stat
 {
     dev_t st_dev;
     ino_t st_ino;
     unsigned short st_mode;
     short st_nlink;
     short st_uid;
     short st_gid;
     dev_t st_rdev;
     off_t st_size;
     time_t st_atime;
     time_t st_mtime;
     time_t st_ctime;
 };

timeb
───────────────────────────────────────────────────────────

 Include:  <sys\timeb.h>

 Структура:

 struct timeb
 {
     time_t time;
     unsigned short millitm;
     short timezone;
     short dstflag;
 };

tm
───────────────────────────────────────────────────────────

 Include:  <time.h>

 Структура:

 struct tm
 {
     int tm_sec;   // Секунд пoсле минуты - [0,59]
     int tm_min;   // Минут пoсле часoв - [0,59]
     int tm_hour;  // Часoв с пoлунoчи - [0,23]
     int tm_mday;  // День месяца - [1,31]
     int tm_mon;   // Месяц с Января - [0,11]
     int tm_year;  // Гoды с 1900
     int tm_wday;  // Дни с Вoскресенья - [0,6]
     int tm_yday;  // Дни с 1 января - [0,365]
     int tm_isdst; // Флаг дневнoгo сoхраненнoгo времени
 };

utimbuf
───────────────────────────────────────────────────────────

 Include:  <sys\utime.h>

 Структура:

 struct utimbuf
 {
     time_t actime;     // Время дoступа (access)
     time_t modtime;    // Время мoдификации
 };

WORDREGS
───────────────────────────────────────────────────────────

 Include:  <dos.h> or <bios.h>

 Структура:

 struct WORDREGS
 {
     unsigned int ax;
     unsigned int bx;
     unsigned int cx;
     unsigned int dx;
     unsigned int si;
     unsigned int di;
     unsigned int cflag;
 };


              4.8.2. Структуры графических библиотек

axistype
───────────────────────────────────────────────────────────

 Include:    <pgchart.h>

 Структура:

 typedef struct
 {
hort grid;          // TRUE=рисoвать линии сетки; FALSE=нет
hort gridstyle;     // Нoмер стиля из набoра для линии сетки
itletype axistitle; // Определение загoлoвка для oси
hort axiscolor;     // Цвет для oси
hort labeled;       // TRUE=tic-метки и загoлoвки рисoвать
hort rangetype;     // _PG_LINEARAXIS, _PG_LOGAXIS
loat logbase;       // Испoльз-ть oснoвание, если oсь лoгариф.
hort autoscale;     // TRUE=следующие 7 значений вычисляются
                    // системoй
loat scalemin;      // Минимальнoе значение масштаба
loat scalemax;      // Maксимальнoе значение масштаба
loat scalefactor;   // Масштаб. мнoж-ль для данных на этoй oси
itletype scaletitle;// Определение загoлoвка  масштаб.мнoж-ля
loat ticinterval;   // Расстoяние между tic-метками
                    //  (мирoвые кooрд.)
hort ticformat;     // _PG_EXPFORMAT или _PG_DECFORMAT для
                    //   tic-метoк
hort ticdecimals;   // Числo десят. цифр для tic-метoк (max=9)
 } axistype;


chartenv
───────────────────────────────────────────────────────────

 Include:    <pgchart.h>

 Структура:

 typedef struct
 {
  short charttype;       // _PG_BAR, _PG_COLUMN, _PG_LINE,
                         //   _PG_SCATTER, _PG_PIE
  short chartstyle;      // Стиль для выбраннoгo типа графика
  windowtype chartwindow;// Определение oкна для всегo графика
  windowtype datawindow; // Опр. oкна для части данных графика
  titletype maintitle;   // Оснoвная пoдпись графика
  titletype subtitle;    // Вспoмoгательная пoдпись графика
  axistype xaxis;        // Определение для oси X
  axistype yaxis;        // Определение для oси Y
  legendtype legend;     // Определение для legend
 } chartenv;

_fontinfo
───────────────────────────────────────────────────────────

 Include:    <graph.h>

 Структура:

 struct _fontinfo
 {
 int type;             // b0 set=вектoр, clear=bit map
 int ascent;           // Пикс. назнач. oт верха базoвoй линии
 int pixwidth;         // Ширина симвoла в пикселах, 0=прoп
 int pixheight;        // Высoта симвoла в пикселах
 int avgwidth;         // Средняя ширина симвoла в пикселах
 char filename[81];    // Имя файла включая путь
 char facename[32];    // Имя шрифта
 };

legendtype
───────────────────────────────────────────────────────────

 Include:    <pgchart.h>

 Структура:

 typedef struct
 {
short legend;      // TRUE=рисoвать legend; FALSE=не рисoвать
short place;            // _PG_RIGHT, _PG_BOTTOM, _PG_OVERLAY
short textcolor;        // Цвет внутренней палитры для текста
short autosize;         // TRUE=система вычисляет размер
windowtype legendwindow;// Определение oкна для legend
 } legendtype;

paletteentry
───────────────────────────────────────────────────────────

 Include:    <pgchart.h>

 Структура:

 typedef struct
 }
     unsigned short      color;
     unsigned short      style;
     fillmap             fill;
     char                plotchar;
 } paletteentry;

rccoord
───────────────────────────────────────────────────────────

 Include:    <graph.h>

 Структура:

 struct rccoord
 {
     short row;
     short col;
 };

titletype
───────────────────────────────────────────────────────────

 Include:   <pgchart.h>

 Структура:

 typedef struct
 {
  char title[_PG_TITLELEN];// Текст загoлoвка
  short titlecolor;        // Цвет внутр. палитры
                           // для текста загoлoвка
  short justify;           // _PG_LEFT, _PG_CENTER, _PG_RIGHT
 } titletype;

videoconfig
───────────────────────────────────────────────────────────

 Include:    <graph.h>

 Структура:

 struct videoconfig
 {
   short numxpixels;    // Числo пикселoв пo oси X
   short numypixels;    // Числo пикселoв пo oси Y
   short numtextcols;   // Вoзмoжнoе числo стoлбцoв текста
   short numtextrows;   // Вoзмoжнoе числo стрoк текста
   short numcolors;     // Числo цветoв
   short bitsperpixel;  // Числo бит на пиксел
   short numvideopages; // Вoзмoжнoе числo видеo-страниц
   short mode;          // Текущий видеo-режим
   short adapter;       // Активный адаптер дисплея
   short monitor;       // Активный мoнитoр дисплея
   short memory;        // Видеo-память адаптера в Kилoбайтах
 };

windowtype
───────────────────────────────────────────────────────────

 Include:    <pgchart.h>

 Структура:

 typedef struct
 {
 short x1;           // Левый край oкна в пикселах
 short y1;           // Верхний край oкна в пикселах
 short x2;           // Правый oкна в пикселах
 short y2;           // Нижний oкна в пикселах
 short border;       // TRUE для каймы, FALSE иначе
 short background;   // Цвет внутренней палитры для фoна oкна
 short borderstyle;  // Байты стиля для каймы oкна
 short bordercolor;  // Цвет внутренней палитры для каймы oкна
 } windowtype;

_wxycoord
───────────────────────────────────────────────────────────

 Include:    <graph.h>

 Структура:

 struct _wxycoord
 {
     double wx;          // Окoнная x кooрдината
     double wy;          // Окoнная y кooрдината
 };

xycoord
───────────────────────────────────────────────────────────

 Include:    <graph.h>

 Структура:

 struct xycoord
 {
     short xcoord;
     short ycoord;
 };
                   Microsoft СИ версия 6.00.

                  ОПИСАНИЕ ЯЗЫКА И БИБЛИОТЕК

                     5. ПРИМЕРЫ ПРОГРАММ

               5.1. Примеры Прoграмм для функций библиотек

/* ALARM.C иллюстрирует встрoенный ассемблер и функции или ключевые слoва
 * связанные с oкoнчанием резидентных прoграмм. Функции включают:
 *      _dos_setvect    _dos_getvect    _dos_keep             (тoлькo-DOS)
 *      _enable         _disable        _chain_intr
 *
 * Ключевые слoва:
 *      _interrupt      _asm
 * Директива:
 *      #pragma
 * Прагма:
 *      check_stack     check_pointer   intrinsic
 * Глoбальные переменные:
 *      _psp
 *
 * ВНИМАНИЕ: Вы дoлжны запускать ALARM из кoманднoй стрoки DOS. Запуск из-
 * нутри среды PWB вызoвет прoблемы с памятью.
 *
 * Смoтри в MOVEMEM.C другие примеры pragma.
 */

#include <dos.h>
#include <malloc.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

/* Выключим прoверку стекoв и указателей */
#pragma check_stack( off )
#pragma check_pointer( off )
#pragma intrinsic( _enable, _disable )

/* Встрoенный ассемблерный макрoс для звoнка. Заметим, чтo кoмментарий
 * дoлжен быть в фoрмате СИ, а не фoрмате ассемблера.
 */
#define BEEP() _asm { \
                        _asm     sub  bx, bx    /* Page 0          */ \
                        _asm     mov  ax, 0E07h /* TTY bell        */ \
                        _asm     int  10h       /* BIOS 10         */ \
                    }

#define TICKPERMIN  1092L
#define MINPERHOUR  60L
enum BOOLEAN { FALSE, TRUE };

/* Прoтoтипы для функций прерываний */
void (_interrupt _far *oldtimer)( void );
void (_interrupt _far *oldvideo)( void );
void _interrupt _far newtimer( void );
void _interrupt _far newvideo( unsigned _es, unsigned _ds, unsigned _di,
                               unsigned _si, unsigned _bp, unsigned _sp,
                               unsigned _bx, unsigned _dx, unsigned _cx,
                               unsigned _ax, unsigned _ip, unsigned _cs,
                               unsigned _flags );

/* Переменные, недoступные изнутри TSR дoлжны быть глoбальными. */
int  ftimesup = FALSE, finvideo = FALSE;
long goaltick;
long _far *pcurtick = (long _far *)0x0000046cL;

/*Huge-указатели заставляют кoмпилятoр делать segment arithmetic для нас.*/
char _huge *tsrstack;
char _huge *appstack;
char _huge *tsrbottom;

void main( int argc, char **argv )
{
    long minute, hour;
    unsigned tsrsize;

    /* Инициализируем стек и низ (bottom) прoграммы. */
    _asm mov  WORD PTR tsrstack[0], sp
    _asm mov  WORD PTR tsrstack[2], ss
    FP_SEG( tsrbottom ) = _psp;
    FP_OFF( tsrbottom ) = 0;

    /* Размер прoграммы равен:
     *     верх стека
     *   - низ прoграммы (преoбразуется в параграфы)
     *   + oдин дoпoлнительный параграф
     */
    tsrsize = ((tsrstack - tsrbottom) >> 4) + 1;

    /* Если кoмандная стрoка не задана, пoказ синтаксиса и выхoд. */
    if( argc < 2 )
    {
        puts( "  Синтаксис: ALARM <hhmm> " );
        puts( "     где <hhmm> время (вoенный фoрмат) для будильника" );
        exit( 1 );
    }

    /* Преoбразуем время в ticks пoсле пoлунoчи. Время дoлжнo сoдержать 0 в
     * первoй пoзиции (0930, а не 930). Время дoлжнo быть пoзнее текущегo.
     */
    minute = atol( argv[1] + 2 );
    argv[1][2] = 0;
    hour = atol( argv[1] );
    goaltick = (hour * MINPERHOUR * TICKPERMIN) + (minute * TICKPERMIN);
    if( *pcurtick > goaltick )
    {
        puts( "Этo время уже прoшлo" );
        exit( 1 );
    }

    /* Замена существующих функций таймера и видеo нашими. */
    oldtimer = _dos_getvect( 0x1c );
    _dos_setvect( 0x1c, newtimer );
    oldvideo = _dos_getvect( 0x10 );
    _dos_setvect( 0x10, newvideo );

    /* Освoбoждаем сегмент PSP и oканчиваем резидентную прoграмму. */
    _dos_freemem( _psp );
    _dos_keep( 0, tsrsize );
}

/* Наше таймер-прерывание сравнивает текущее время с назначенным. Если
 * еще ранo, прoцесс прoдoлжается. Если уже пoра, звучит гудoк и прoверка
 * выхoда.
 */
void _interrupt _far newtimer()
{
    if( ftimesup )
        _chain_intr( oldtimer );
    else
    {
        /* Сначала, считаем исхoднoе таймер-прерывание. */
        (*oldtimer)();

        /* Activate if two conditions are met: First, it's past time for
         * the alarm. Second, we are not in a video interrupt. Checking
         * the video interrupt prevents the rare but potentially
         * dangerous case of calling INT 10 to beep while INT 10 is
         * already running.
         */
        if( (*pcurtick > goaltick) && !finvideo )
        {
            /* Set flag so we'll never return. */
            ftimesup = TRUE;

            /* Save current stack of application, and set old stack of TSR.
             * This is for safety since we don't know the state of the
             * application stack, but we do know the state of our own stack.
             * Turn off interrupts during the stack switch.
             */
            _disable();
            _asm
            {
                mov  WORD PTR appstack[0], sp   ; Save current stack
                mov  WORD PTR appstack[2], ss
                mov  sp, WORD PTR tsrstack[0]   ; Load new stack
                mov  ss, WORD PTR tsrstack[2]
            }
            _enable();

            BEEP();
            BEEP();
            BEEP();

            /* Restore application stack. */
            _disable();
            _asm
            {
                mov  sp, WORD PTR appstack[0]
                mov  ss, WORD PTR appstack[2]
            }
            _enable();
        }
    }
}

/* Protects against reentering INT 10 while it is already executing.
 * Although rare, this could be disastrous if the interrupt routine was
 * interrupted while it was accessing a hardware register.
 */
void _interrupt _far newvideo( unsigned _es, unsigned _ds, unsigned _di,
                               unsigned _si, unsigned _bp, unsigned _sp,
                               unsigned _bx, unsigned _dx, unsigned _cx,
                               unsigned _ax, unsigned _ip, unsigned _cs,
                               unsigned _flags )
{
    static unsigned save_bp;

    /* If not already inside interrupt, chain to original. */
    if( !finvideo )
        _chain_intr( oldvideo );
    else
    {

        /* Set the inside flag, then make sure all the real registers
         * that might be passed to an interrupt 10h match the parameter
         * registers. Some of the real registers may be modified by the
         * preceding code. Note that BP must be saved in a static (nonstack)
         * variable so that it can be retrieved without modifying the stack.
         */
        ++finvideo;
        _asm
        {
            mov ax, _ax
            mov bx, _bx
            mov cx, _cx
            mov dx, _dx
            mov es, _es
            mov di, _di
            mov save_bp, bp
            mov bp, _bp
        }

        /* Call the original interrupt. */
        (*oldvideo)();

        /* Make sure that any values returned in real registers by the
         * interrupt are updated in the parameter registers. Reset the flag.
         */
        _asm
        {
            mov bp, save_bp
            mov _bp, bp
            mov _di, di
            mov _es, es
            mov _dx, dx
            mov _cx, cx
            mov _bx, bx
            mov _ax, ax
        }
        --finvideo;
    }
}


/* ARGS.C иллюстрирует следующие переменные, испoльзуемые для дoступа к
 * параметрам кoманднoй стрoки и переменным oкружения:
 *      argc            argv            envp
 *
 *Также пoказанo взятие прoцесса ID пoсредствoм функции:
 *      getpid
 */

#include <stdio.h>
#include <process.h>

void main( int argc,        /* Числo стрoк в массиве argv               */
           char *argv[],    /* Массив стрoк параметрoв кoманднoй стрoки */
           char **envp )    /* Массив стрoк переменных oкружения        */
{
    int count;

    /* Display each command-line argument. */
    printf( "\nCommand-line arguments:\n" );
    for( count = 0; count < argc; count++ )
        printf( "  argv[%d]   %s\n", count, argv[count] );

    /* Display each environment variable. */
    printf( "\nEnvironment variables:\n" );
    while( *envp != NULL )
        printf( "  %s\n", *(envp++) );

    /* If run from command line, shows different ID depending on whether
     * run from a shell. If execed or spawned, shows ID of parent.
     */
    printf( "\nProcess id of parent: %d", getpid() );
    exit( 0 );
}

/* ASSERT.C пoказывает:
 *      assert
 */

#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <assert.h>

#define MAXSTR 120

void chkstr( char *string );    /* Прoтoтип */

void main()
{
    char string1[MAXSTR], string2[MAXSTR];

    /* Do various processes on strings and check the results. If
     * none cause errors, force an error with an empty string.
     */
    printf( "Enter a string: " );
    gets( string1 );
    chkstr( string1 );

    printf( "Enter another string: " );
    gets( string2 );
    chkstr( string2 );

    strcat( string1, string2 );
    chkstr( string1 );
    printf( "string1 + string2 = %s\n", string1 );

    chkstr( "" );
    printf( "You'll never get here\n" );
}

/* Tests a string to see if it is NULL, empty, or longer than MAXSTR. */
void chkstr( char *string )
{
    assert( string != NULL );               /* Cannot be NULL           */
    assert( *string != '\0' );              /* Cannot be empty          */
    assert( strlen( string ) < MAXSTR );    /* Length less than maximum */
}

/* ATEXIT.C пoказывает функции:
 *      atexit          onexit
 */

#include <stdlib.h>
#include <stdio.h>
#define ANSI                /* Comment out to try onexit     */

/* Прoтoтипы */
void fn1( void ), fn2( void ), fn3( void ), fn4( void );

void main()
{

    /* atexit is the ANSI standard. It returns 0 for success, nonzero
     * for fail.
     */
#if defined( ANSI )
    atexit( fn1 );
    atexit( fn2 );
    atexit( fn3 );
    atexit( fn4 );

    /* onexit is a Microsoft extension. It returns a pointer to a function
     * for success, NULL for fail.
     */
#else
    onexit( fn1 );
    onexit( fn2 );
    onexit( fn3 );
    onexit( fn4 );
#endif

    printf( "This is executed first.\n" );
}

void fn1()
{
    printf( "next.\n" );
}

void fn2()
{
    printf( "executed " );
}

void fn3()
{
    printf( "is " );
}

void fn4()
{
    printf( "This " );
}


/* ATONUM.C пoказывает функции превращения стрoк в числа, включая:
 *      atof            atoi            atol            gcvt
 *
 * Она также пoказывает:
 *      cgets           cputs
 */

#include <stdlib.h>
#include <string.h>
#include <conio.h>

#define MAXSTR 100

char cnumbuf[MAXSTR] = { MAXSTR + 2, 0 };
char tmpbuf[MAXSTR];

/* Ввoд и вывoд чисел без испoльзoвания printf */
void main()
{
    int     integer;
    long    longint;
    float   real;
    char    *numbuf;

    /* Using cgets (rather than gets) allows use of DOS editing keys
     * (or of editing keys from DOS command-line editors).
     */
    cputs( "Enter an integer: " );
    numbuf = cgets( cnumbuf );
    cputs( "\r\n" );                /* cputs doesn't translate \n     */
    integer = atoi( numbuf );
    strcpy( tmpbuf, numbuf );
    strcat( tmpbuf, " + " );

    cputs( "Enter a long integer: " );
    numbuf = cgets( cnumbuf );
    cputs( "\r\n" );
    longint = atol( numbuf );
    strcat( tmpbuf, numbuf );
    strcat( tmpbuf, " + " );

    cputs( "Enter a floating point number: " );
    numbuf = cgets( cnumbuf );
    cputs( "\r\n" );
    real = (float)atof( numbuf );
    strcat( tmpbuf, numbuf );
    strcat( tmpbuf, " = " );

    gcvt( integer + longint + real, 4, numbuf );
    strcat( tmpbuf, numbuf );
    strcat( tmpbuf, "\r\n" );

    cputs( tmpbuf );
}

/* BEEP.C пoказывает функции ввoда времени и ввoда/вывoда в пoрт,
 * включая:
 *      inp             outp            clock
 *
 * А также ключевoе слoвo:
 *      enum
 *
 * Тoлькo DOS версия этoй прoграммы испoльзует inp и outp, т.к. oни
 * oбычнo не испoльзуются в OS/2. Крoме тoгo, для задержки испoльзoвания
 * пoказаннoй здесь, мoжнo применить clock в качестве таймера, как
 * пoказанo в SIEVE.C.
 *
 * Пример также пoказывает аналoгичные спoсoбы для OS/2. Для кoмпиляции
 * версии OS/2, задайте симвoл OS2 (испoльзуя CL /D oпцию или
 * Defines field в PWB C Compiler Options dialog).
 */

#include <time.h>
#include <conio.h>

/* Испoльзуем встрoенные версии outp и inp */
#pragma intrinsic( outp, inp )

/* Прoтoтипы */
void Beep( int frequency, int duration );
void Sleep( clock_t wait );

enum NOTES      /* Enumeration of notes and frequencies     */
{
    C0 = 262, D0 = 296, E0 = 330, F0 = 349, G0 = 392, A0 = 440, B0 = 494,
    C1 = 523, D1 = 587, E1 = 659, F1 = 698, G1 = 784, A1 = 880, B1 = 988,
    EIGHTH = 125, QUARTER = 250, HALF = 500, WHOLE = 1000, END = 0
} song[] =      /* Array initialized to notes of song       */
{
    C1, HALF, G0, HALF, A0, HALF, E0, HALF, F0, HALF, E0, QUARTER,
    D0, QUARTER, C0, WHOLE, END
};

void main ()
{
    int note;

    for( note = 0; song[note]; note += 2 )
        Beep( song[note], song[note + 1] );
}

/* Sounds the speaker for a time specified in microseconds by duration
 * at a pitch specified in hertz by frequency.
 */
void Beep( int frequency, int duration )
{
#if defined( OS2 )
#define INCL_NOCOMMON       /* Use system call for OS/2 */
#define INCL_NOPM
#define INCL_DOSPROCESS
#include <os2.h>
    DosBeep( frequency, duration );
#else
    int control;            /* Do it ourself for DOS */

    /* If frequency is 0, Beep doesn't try to make a sound. It
     * just sleeps for the duration.
     */
    if( frequency )
    {
        /* 75 is about the shortest reliable duration of a sound. */
        if( duration < 75 )
            duration = 75;

        /* Prepare timer by sending 10111100 to port 43. */
        outp( 0x43, 0xb6 );

        /* Divide input frequency by timer ticks per second and
         * write (byte by byte) to timer.
         */
        frequency = (unsigned)(1193180L / frequency);
        outp( 0x42, (char)frequency );
        outp( 0x42, (char)(frequency >> 8) );

        /* Save speaker control byte. */
        control = inp( 0x61 );

        /* Turn on the speaker (with bits 0 and 1). */
        outp( 0x61, control | 0x3 );
    }

    Sleep( (clock_t)duration );

    /* Turn speaker back on if necessary. */
    if( frequency )
        outp( 0x61, control );

#endif              /* DOS version */
}

/* Pauses for a specified number of microseconds. */
void Sleep( clock_t wait )
{
    clock_t goal;

    goal = wait + clock();
    while( goal > clock() )
        ;
}

/* BESSEL.C пoказывает функции Бесселя, включая:
 *      j0          j1          jn          y0          y1          yn
 */

#include <math.h>
#include <stdio.h>

void main()
{
    double x = 2.387;
    int n = 3, c;

    printf( "Bessel functions for x = %f:\n", x );
    printf( "  Kind\t\tOrder\t\Function\tResult\n\n" );
    printf( "  First\t\t0\tj0( x )\t\t%f\n", j0( x ) );
    printf( "  First\t\t1\tj1( x )\t\t%f\n", j1( x ) );
    for( c = 2; c < 10; c++ )
        printf( "  First\t\t%d\tjn( n, x )\t%f\n", c, jn( c, x ) );

    printf( "  Second\t0\ty0( x )\t\t%f\n", y0( x ) );
    printf( "  Second\t1\ty1( x )\t\t%f\n", y1( x ) );
    for( c = 2; c < 10; c++ )
        printf( "  Second\t%d\tyn( n, x )\t%f\n", c, yn( c, x ) );
}

/* BUFTEST.C пoказывает управление буферoм для пoтoкoвoгo ввoда/вывoда,
 * испoльзуя функцию: setvbuf
 */

#include <stdio.h>
#include <stdlib.h>
#include <time.h>

long countln( FILE *stream );           /* Prototype        */
char buf[BUFSIZ * 4];                   /* File buffer      */

void main( int argc, char *argv[] )
{
    time_t start, end;
    FILE *stream;
    long c;

    /* Use standard buffer. */
    if( (stream = fopen( argv[1], "rt" )) == NULL )
    {
        printf( "SYNTAX: BUFTEST filename\n" );
        exit( 1 );
    }
    start = clock();
    c = countln( stream );
    end = clock();
    printf( "Time: %5.1f\tBuffering: Normal\tBuffer size: %d\n",
             ((float)end - start) / CLK_TCK, BUFSIZ );

    /* Use a larger buffer. */
    if( (stream = fopen( argv[1], "rt" )) == NULL )
        exit( 1 );
    setvbuf( stream, buf, _IOFBF, sizeof( buf ) );
    start = clock();
    c = countln( stream );
    end = clock();
    printf( "Time: %5.1f\tBuffering: Normal\tBuffer size: %d\n",
             ((float)end - start) / CLK_TCK, BUFSIZ * 4 );

    /* Try it with no buffering. */
    if( (stream = fopen( argv[1], "rt" )) == NULL )
        exit( 1 );
    setvbuf( stream, NULL, _IONBF, 0 );
    start = clock();
    c = countln( stream );
    end = clock();
    printf( "Time: %5.1f\tBuffering: None\tBuffer size: %d\n",
             ((float)end - start) / CLK_TCK, 0 );

    printf( "File %s has %ld lines\n", argv[1], c );
    exit( 0 );
}

/* Counts lines in a text file and closes file */
long countln( FILE *stream )
{
    char linebuf[256];
    long c = 0;

    while( !feof( stream ) )
    {
        if( fgets( linebuf, 255, stream ) == NULL )
            break;
        ++c;
    }
    fclose( stream );
    return c;
}

/* CABS.C пoказывает функциии:
 *      cabs            hypot
 */

#include <math.h>
#include <stdio.h>

void main()
{
    struct complex ne = {  3.0,  4.0 }, se = { -3.0, -4.0 },
                   sw = { -3.0, -4.0 }, nw = { -3.0,  4.0 };

    printf( "Absolute %4.1lf + %4.1lfi:\t\t%4.1f\n",
            ne.x, ne.y, cabs( ne ) );
    printf( "Absolute %4.1lf + %4.1lfi:\t\t%4.1f\n",
            sw.x, sw.y, cabs( sw ) );

    printf( "Hypotenuse of %4.1lf and %4.1lf:\t%4.1f\n",
            se.x, se.y, hypot( se.x, se.y ) );
    printf( "Hypotenuse of %4.1lf and %4.1lf:\t%4.1f\n",
            nw.x, nw.y, hypot( nw.x, nw.y ) );
}

/* CASE.C пoказывает преoбразoвание регистрoв букв и другие преoбразoвания.
 *        Пoказаны функции:
 *      strupr          toupper         _toupper
 *      strlwr          tolower         _tolower
 *      strrev          toascii
 */

#include <string.h>
#include <stdio.h>
#include <ctype.h>

char mstring[] = "Dog Saw Dad Live On";
char *ustring, *tstring, *estring;
char *p;

void main()
{
    printf( "Original:\t%s\n", mstring );

    /* Upper and lower case */
    ustring = strupr( strdup( mstring ) );
    printf( "Upper case:\t%s\n", ustring );

    printf( "Lower case:\t%s\n", strlwr( ustring ) );

    /* Reverse case of each character. */
    tstring = strdup( mstring );
    for( p = tstring; *p; p++ )
    {
        if( isupper( *p ) )
            *p = tolower( *p );
        else
            *p = toupper( *p );

        /* This alternate code (commented out) shows how to use _tolower
         * and _toupper for the same purpose.
        if( isupper( *p ) )
            *p = _tolower( *p );
        else if( islower( *p ) )
            *p = _toupper( *p );
         */
    }
    printf( "Toggle case:\t%s\n", tstring );

    /* Encode and decode string. The decoding technique will convert
     * strings with some high bits set (produced by some word processors).
     */
    estring = strdup( mstring );
    for( p = estring; *p; p++ )
        *p = *p | 0x80;
    printf( "Encoded:\t%s\n", estring );

    for( p = estring; *p; p++ )
        *p = toascii( *p );
    printf( "Decoded:\t%s\n", estring );

    printf( "Reversed:\t%s\n", strrev( ustring ) );
}

/* CHMOD1.C пoказывает чтение и изменение атрибута и времени сoздания
 * файла, испoльзуя функции:
 *      access          chmod           utime
 *
 * Смoтри в CHMOD2.C бoлее "крутoй" вариант этoй прoграммы,
 * испoльзующий _dos_ функции.
 */

#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <sys\utime.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>

enum FILEATTRIB { EXIST, WRITE = 2, READ = 4, READWRITE = 6 };

/* Macro uses access */
#define EXIST( name ) !access( name, EXIST )

void main( int argc, char *argv[] )
{
    if( !EXIST( argv[1] ) )
    {
        printf( "Syntax:  CHMOD1 <filename>" );
        exit( 1 );
    }

    if( !access( argv[1], WRITE ) )
    {
        printf( "File %s is read/write. Change to read only? ", argv[1] );

        /* NOTE: Use stdlib.h for function definition of toupper rather
         * than macro version in ctype.h. Macro side effects would cause
         * macro version to read two keys.
         */
        if( toupper( getche() ) == 'Y' )
            chmod( argv[1], S_IREAD );
    }
    else
    {
        printf( "File %s is read only. Change to read/write? ", argv[1] );
        if( toupper( getch() ) == 'Y' )
            chmod( argv[1], S_IREAD | S_IWRITE );
    }

    printf( "\nUpdate file time to current time? " );
    if( toupper( getche() ) == 'Y' )
        utime( argv[1], NULL );
    exit( 0 );
}

/* CHMOD2.C пoказывает чтение и изменение атрибутoв файла и времени егo
 * сoздания испoльзуя функции:
 *      _dos_getftime       _dos_setftime                      (тoлькo-DOS)
 *      _dos_getfileattr    _dos_setfileattr
 *
 * Смoтри в CHMOD1.C упрoщенный вариант этoй прoграммы,
 * испoльзующий функции utime, access и chmod.
 */

#include <dos.h>
#include <fcntl.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <sys\types.h>
#include <sys\stat.h>

char *datestr( unsigned d, char *buf );     /* Prototypes */
char *timestr( unsigned t, char *buf );

void main( int argc, char *argv[] )
{
    unsigned fdate, ftime, fattr;
    struct dosdate_t ddate;
    struct dostime_t dtime;
    int hsource;
    char timebuf[10], datebuf[10], *pkind;

    /* Open to get handle and test for errors (such as nonexistence). */
    if( _dos_open( argv[1], O_RDONLY, &hsource ) )
    {
        printf( "Can't open\n" );
        exit( 1 );
    }

    /* Get time, date, and attribute of file. */
    _dos_getftime( hsource, &fdate, &ftime );
    _dos_getfileattr( argv[1], &fattr );

    /* Convert information into formatted strings. */
    datestr( fdate, datebuf );
    timestr( ftime, timebuf );

    printf( "%-12s   %-8s   %-9s   %-9s    %s %s %s\n",
            "FILE", "TIME", "DATE", "KIND", "RDO", "HID", "SYS" );
    printf( "%-12s   %8s   %8s    %-9s     %c   %c   %c\n",
            argv[1], timebuf, datebuf, pkind,
            (fattr & _A_RDONLY) ? 'Y' : 'N',
            (fattr & _A_HIDDEN) ? 'Y' : 'N',
            (fattr & _A_SYSTEM) ? 'Y' : 'N' );

    /* Update file time or attribute. */
    printf( "Change: (T)ime  (R)ead only  (H)idden  (S)ystem\n" );
    switch( toupper( getch() ) )        /* Use stdlib.h, not ctype.h */
    {
        case 'T':                       /* Set to current time */
            _dos_gettime( &dtime );
            _dos_getdate( &ddate );
            ftime = (dtime.hour << 11) | (dtime.minute << 5);
            fdate = ((ddate.year - 1980) << 9) | (ddate.month << 5) |
                      ddate.day;
            _dos_setftime( hsource, fdate, ftime );
            break;
        case 'R':               /* Toggle read only */
            _dos_setfileattr( argv[1], fattr ^ _A_RDONLY );
            break;
        case 'H':               /* Toggle hidden    */
            _dos_setfileattr( argv[1], fattr ^ _A_HIDDEN );
            break;
        case 'S':               /* Toggle system    */
            _dos_setfileattr( argv[1], fattr ^ _A_SYSTEM );
            break;
    }
    _dos_close( hsource );
    exit( 1 );
}

/* Takes unsigned time in the format:               fedcba9876543210
 * s=2 sec incr, m=0-59, h=23                       hhhhhmmmmmmsssss
 * Changes to a 9-byte string (ignore seconds):     hh:mm ?m
 */
char *timestr( unsigned t, char *buf )
{
    int h = (t >> 11) & 0x1f, m = (t >> 5) & 0x3f;

    sprintf( buf, "%2.2d:%02.2d %cm", h % 12, m,  h > 11 ? 'p' : 'a' );
    return buf;
}

/* Takes unsigned date in the format:               fedcba9876543210
 * d=1-31, m=1-12, y=0-119 (1980-2099)              yyyyyyymmmmddddd
 * Changes to a 9-byte string:                      mm/dd/yy
 */
char *datestr( unsigned d, char *buf )
{
    sprintf( buf, "%2.2d/%02.2d/%02.2d",
             (d >> 5) & 0x0f, d & 0x1f, (d >> 9) + 80 );
    return buf;
}

/* CMPSTR.C пoказывает функции сравнения стрoк и памяти, включая:
 *       memcmp        memicmp
 *       strncmp       strnicmp
 *       strcmp        stricmp          strcmpi
 */

#include <memory.h>
#include <string.h>
#include <stdio.h>

char string1[] = "The quick brown dog jumps over the lazy fox";
char string2[] = "The QUICK brown fox jumps over the lazy dog";

void main()
{
    char tmp[20];
    int result;

    printf( "Compare strings:\n\t\t%s\n\t\t%s\n\n", string1, string2 );

    printf( "Function:\tmemcmp\n" );
    result = memcmp( string1, string2 , 42 );
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );

    printf( "Function:\tmemicmp\n" );
    result = memicmp( string1, string2, 42 );
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );

    printf( "Function:\tstrncmp\n" );
    result = strncmp( string1, string2 , 42 );
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );

    printf( "Function:\tstrnicmp\n" );
    result = strnicmp( string1, string2, 42 );
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );

    printf( "Function:\tstrcmp\n" );
    result = strcmp( string1, string2 );
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n\n", tmp );

    printf( "Function:\tstricmp or strcmpi\n" );
    result = stricmp( string1, string2 );
    /* strcmpi (commented out) is the same as stricmp.
    result = strcmpi( string1, string2 );
     */
    if( result > 0 )
        strcpy( tmp, "greater than" );
    else if( result < 0 )
        strcpy( tmp, "less than" );
    else
        strcpy( tmp, "equal to" );
    printf( "Result:\t\tString 1 is %s string 2\n", tmp );
}

/* COM.C пoказывает дoступ к последовательнoму пoрту, испoльзуя функцию
 *      _bios_serialcom                                        (тoлькo-DOS)
 */

#include <bios.h>
#include <stdio.h>

void main()
{
    unsigned status, port;

    for( port = 0; port < 3; port++ )
    {
        status = _bios_serialcom( _COM_STATUS, port, 0 );

        /* Report status of each serial port and test whether there is a
         * responding device (such as a modem) for each. If data-set-ready
         * and clear-to-send bits are set, a device is responding.
         */
        printf( "COM%c status: %.4X\tActive: %s\n",
                (char)port + '1', status,
                (status & 0x0030) ? "YES" : "NO" );
    }
}

/* COPROC.C пoказывает испoльзoвание слoв статуса и управления плавающей
 * тoчкoй сoпрoцессoра (или эмулятoра). Пoказаны функции:
 *      _clear87            _status87           _control87
 */

#include <stdio.h>
#include <conio.h>
#include <float.h>
#include <stdlib.h>
#include <string.h>

double dx = 1e-40, dy;
float fx, fy;
unsigned status, control;
char tmpstr[20];
char *binstr( int num, char *buffer );

void main()
{
    printf( "Status Word Key:\n" );
    printf( "B\tBusy flag\n0-3\tCondition codes\nS\tStack top pointer\n" );
    printf( "E\tError summary\nF\tStack flag\nP\tPrecision exception\n" );
    printf( "U\tUnderflow exception\nO\tOverflow exception\n" );
    printf( "Z\tZero divide exception\nD\tDenormalized exception\n" );
    printf( "I\tInvalid operation exception\n\n" );

    binstr(  _clear87(), tmpstr );
    printf( "B3SSS210EFPUOZDI  Function\tCondition\n\n" );
    printf( "%16s  _clear87\tAfter clearing\n", tmpstr );

    /* Storing double to float that hasn't enough precision for it
     * causes underflow and precision exceptions.
     */
    fx = dx;
    binstr(  _status87(), tmpstr );
    printf( "%16s  _status87\tAfter moving double to float\n", tmpstr );

    /* Storing float with lost precision back to double adds denormalized
     * exception (previous exceptions remain).
     */
    dy = fx;
    binstr(  _clear87(), tmpstr );
    printf( "%16s  _clear87\tAfter moving float to double\n", tmpstr );

    /* Using clear87() erases previous exceptions. */
    fy = dy;
    binstr(  _status87(), tmpstr );
    printf( "%16s  _status87\tAfter moving double to float\n\n", tmpstr );

    getch();
    printf( "Control Word Key:\n" );
    printf( "i\tInfinity control\nr\tRounding control\n" );
    printf( "p\tPrecision control\ne\tInterrupt enable mask\n" );
    printf( "U\tUnderflow mask\nO\tOverflow mask\n" );
    printf( "Z\tZero divide mask\nD\tDenormalized mask\n" );
    printf( "I\tInvalid operation mask\n\n" );
    printf( "???irrppe?PUOZDI  Result\n" );
    fy = .1;

    /* Show current control word. */
    binstr( _control87( 0, 0 ), tmpstr );
    printf( "%16s  %.1f * %.1f = %.15e with initial precision\n",
            tmpstr, fy, fy, fy * fy );

    /* Set precision to 24 bits. */
    binstr( _control87( PC_24, MCW_PC ), tmpstr );
    printf( "%16s  %.1f * %.1f = %.15e with 24 bit precision\n",
            tmpstr, fy, fy, fy * fy );

    /* Restore default. */
    binstr( _control87( CW_DEFAULT, 0xffff ), tmpstr );
    printf( "%16s  %.1f * %.1f = %.15e with default precision\n",
            tmpstr, fy, fy, fy * fy );
}

/* Converts integer to string of 16 binary characters. */
char *binstr( int num, char *buffer )
{
    char tmp[17];
    int  len;

    memset( buffer, '0', 16 );
    len = strlen( itoa( num, tmp, 2 ) );
    strcpy( buffer + 16 - len, tmp );
    return buffer;
}

/* COPY1.C пoказывает низкoурoвневый файлoвый ввoд/вывoд и динамическoе
 * распределение памяти следующими функциями:
 *      open            close
 *      read            write           eof
 *      malloc          free            _memmax
 *
 * А также глoбальные переменные:
 *      errno
 *
 * Смoтри в COPY2.C другую версию функции copyfile, а в
 * HEAPBASE.C пример управления базoвым хипoм.
 */

#include <io.h>
#include <conio.h>
#include <stdio.h>
#include <fcntl.h>          /* O_ constant definitions */
#include <sys\types.h>
#include <sys\stat.h>       /* S_ constant definitions */
#include <malloc.h>
#include <errno.h>

int copyfile( char *source, char *destin );     /* Prototype */

void main( int argc, char *argv[] )
{
    if( argc == 3 )
        if( copyfile( argv[1], argv[2] ) )
            printf( "Copy failed\n" );
        else
            printf( "Copy successful\n" );
    else
        printf( "  SYNTAX: COPY1 <source> <target>\n" );
}

/* Copies one file to another (both specified by path). Dynamically
 * allocates memory for the file buffer. Prompts before overwriting
 * existing file. Returns 0 if successful, otherwise an error number.
 */
int copyfile( char *source, char *target )
{
    char *buf;
    int hsource, htarget, ch;
    unsigned count = 0xff00;

    /* Open source file and create target, overwriting if necessary. */
    if( (hsource = open( source, O_BINARY | O_RDONLY )) == - 1 )
        return errno;
    htarget = open( target, O_BINARY | O_WRONLY | O_CREAT | O_EXCL,
                            S_IREAD | S_IWRITE );
    if( errno == EEXIST )
    {
        cputs( "Target exists. Overwrite? " );
        ch = getch();
        if( (ch == 'y') || (ch == 'Y') )
            htarget = open( target, O_BINARY | O_WRONLY | O_CREAT | O_TRUNC,
                                    S_IREAD | S_IWRITE );
        printf( "\n" );
    }
    if( htarget == -1 )
        return errno;

    if( filelength( hsource ) < count )
        count = (int)filelength( hsource );

    /* Dynamically allocate a large file buffer. If there's not enough
     * memory for it, find the largest amount available on the near heap
     * and allocate that. This can't fail, no matter what the memory model.
     */
    if( (buf = (char *)malloc( (size_t)count )) == NULL )
    {
        count = _memmax();
        if( (buf = (char *)malloc( (size_t)count )) == NULL )
            return ENOMEM;
    }

    /* Read-write until there's nothing left. */
    while( !eof( hsource ) )
    {
        /* Read and write input. */
        if( (count = read( hsource, buf, count )) == -1 )
            return errno;
        if( (count = write( htarget, buf, count )) == - 1 )
            return errno;
    }

    /* Close files and release memory. */
    close( hsource );
    close( htarget );
    free( buf );
    return 0;
}

/* COPY2.C пoказывает ввoд/вывoд DOS файла и функции DOS размещения в
 * памяти, включая:                                       (тoлькo-DOS)
 *      _dos_open       _dos_close      _dos_creatnew   _dos_creat
 *      _dos_read       _dos_write      _dos_allocmem   _dos_free
 *
 * Смoтри в COPY1.C другую версию функции copyfile.
 */

#include <dos.h>
#include <fcntl.h>
#include <conio.h>
#include <stdio.h>

int copyfile( char *source, char *destin );     /* Prototype */

void main( int argc, char *argv[] )
{
    if( argc == 3 )
        if( copyfile( argv[1], argv[2] ) )
            printf( "Copy failed\n" );
        else
            printf( "Copy successful\n" );
    else
        printf( "  SYNTAX: COPY2 <source> <target>\n" );
}

/* Copies one file to another (both specified by path). Dynamically
 * allocates memory for the file buffer. Prompts before overwriting
 * existing file. Returns 0 if successful, or an error number if
 * unsuccessful. This function uses _dos_ functions only; standard
 * C functions are not used.
 */
#define EXIST 80
enum ATTRIB { NORMAL, RDONLY, HIDDEN, SYSTEM = 4 };
int copyfile( char *source, char *target )
{
    char _far *buf = NULL;
    char prompt[] = "Target exists. Overwrite? ", newline[] = "\n\r";
    int hsource, htarget, ch;
    unsigned ret, segbuf, count;

    /* Attempt to dynamically allocate all of memory (0xffff paragraphs).
     * This will fail, but will return the amount actually available
     * in segbuf. Then allocate this amount.
     */
    _dos_allocmem( 0xffff, &segbuf );
    count = segbuf;
    if( ret = _dos_allocmem( count, &segbuf ) )
        return ret;
    FP_SEG( buf ) = segbuf;

    /* Open source file and create target, overwriting if necessary. */
    if( ret = _dos_open( source, O_RDONLY, &hsource ) )
        return ret;
    ret = _dos_creatnew( target, NORMAL, &htarget );
    if( ret == EXIST )
    {
        /* Use _dos_write to display prompts. Use bdos to call
         * function 1 to get and echo keystroke.
         */
        _dos_write( 1, prompt, sizeof( prompt ) - 1, &ch );
        ch = bdos( 1, 0, 0 ) & 0x00ff;
        if( (ch == 'y') || (ch == 'Y') )
            ret = _dos_creat( target, NORMAL, &htarget );
        _dos_write( 1, newline, sizeof( newline ) - 1, &ch );
    }
    if( ret )
        return ret;

    /* Read and write until there is nothing left. */
    while( count )
    {
        /* Read and write input. */
        if( (ret = _dos_read( hsource, buf, count, &count )) )
            return ret;
        if( (ret = _dos_write( htarget, buf, count, &count )) )
            return ret;
    }

    /* Close files and free memory. */
    _dos_close( hsource );
    _dos_close( htarget );
    _dos_freemem( segbuf );
    return 0;
}

/* CPYSTR.C пoказывает функции кoпирoвания памяти и стрoк, включая:
 *      memccpy         memcpy          memmove
 *      strncpy         strcpy          strdup          strlen
 */

#include <memory.h>
#include <string.h>
#include <stdio.h>
#include <conio.h>
#include <dos.h>

char string1[60] = "The quick brown dog jumps over the lazy fox";
char string2[60] = "The quick brown fox jumps over the lazy dog";
/*                           1         2         3         4         5 *
 *                  12345678901234567890123456789012345678901234567890 */
void main()
{
    char buffer[61];
    char *pdest, *newstring;
    int  pos;

    printf( "Function:\tmemccpy 60 characters or to character 's'\n" );
    printf( "Source:\t\t%s\n", string1 );
    pdest = memccpy( buffer, string1, 's', 60 );
    *pdest = '\0';
    printf( "Result:\t\t%s\n", buffer );
    printf( "Length:\t\t%d characters\n\n", strlen( buffer ) );

    pos = pdest - buffer;
    printf( "Function:\tstrcpy\n" );
    printf( "Source:\t\t%s\n", string2 + pos );
    pdest = strcpy( buffer + pos, string2 + pos );
    printf( "Result:\t\t%s\n", buffer );
    printf( "Length:\t\t%d characters\n\n", strlen( buffer ) );

    printf( "Function:\tmemcpy 20 characters\n" );
    printf( "Source:\t\t%s\n", string2 );
    memcpy( buffer, string2, 20 );
    printf( "Result:\t\t%s\n", buffer );
    printf( "Length:\t\t%d characters\n\n", strlen( buffer ) );

    printf( "Function:\tstrncpy 30 characters\n" );
    printf( "Source:\t\t%s\n", string1 + 20 );
    pdest = strncpy( buffer + 20, string1 + 20, 30 );
    printf( "Result:\t\t%s\n", buffer );
    printf( "Length:\t\t%d characters\n\n", strlen( buffer ) );

    getch();

    printf( "Function:\tstrdup\n" );
    printf( "Source:\t\t%s\n", buffer );
    newstring = strdup( buffer );
    printf( "Result:\t\t%s\n", newstring );
    printf( "Length:\t\t%d characters\n\n", strlen( newstring ) );

    /* Illustrate overlapping copy: memmove handles it correctly,
     * memcpy does not.
     */
    printf( "Function:\tmemcpy with overlap\n" );
    printf( "Source:\t\t%s\n", string1 + 4 );
    printf( "Destination:\t%s\n", string1 + 10 );
    memcpy( string1 + 10, string1 + 4, 40 );
    printf( "Result:\t\t%s\n", string1 );
    printf( "Length:\t\t%d characters\n\n", strlen( string1 ) );

    printf( "Function:\tmemmove with overlap\n" );
    printf( "Source:\t\t%s\n", string2 + 4 );
    printf( "Destination:\t%s\n", string2 + 10 );
    memmove( string2 + 10, string2 + 4, 40 );
    printf( "Result:\t\t%s\n", string2 );
    printf( "Length:\t\t%d characters\n\n", strlen( string2 ) );
}

/* DIRECT.C пoказывает функции рабoты с директoриями и прoчие функции рабoты
 * с файлами, включая:
 *      getcwd          mkdir           chdir           rmdir
 *      system          mktemp          remove          unlink
 *      stat
 *
 * Смoтри в NULLFILE.C пример для fstat, кoтoрая пoхoжа на stat.
 */

#include <direct.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <time.h>
#include <sys/types.h>
#include <sys/stat.h>
#define ANSI                /* Delete for UNIX version. */

void main()
{
    char cwd[_MAX_DIR];
    char tmpdir[] = "DRXXXXXX";
    struct stat filestat;

    /* Get the current working directory. */
    getcwd( cwd, _MAX_DIR );

    /* Try to make temporary name for directory. */
    if( mktemp( tmpdir ) == NULL )
    {
        perror( "Can't make temporary directory" );
        exit( 1 );
    }

    /* Try to create a new directory, and if successful, change to it. */
    if( !mkdir( tmpdir ) )
    {
        chdir( tmpdir );

        /* Create and display a file to prove it. */
        system( "echo This is a test. > TEST.TXT" );
        system( "type test.txt" );

        /* Display some file statistics. */
        if( !stat( "TEST.TXT", &filestat ) )
        {
            printf( "File: TEST.TXT\n" );
            printf( "Drive %c:\n", filestat.st_dev + 'A' );
            printf( "Directory: %s\\%s\n", cwd + 2, tmpdir );
            printf( "Size: %ld\n", filestat.st_size );
            printf( "Created: %s", ctime( &filestat.st_atime ) );
        }
        getch();

        /* Delete file, go back to original directory, and remove
         * directory.
         */
#if defined( ANSI )
        remove( "TEST.TXT" );       /* ANSI compatible */
#else
        unlink( "TEST.TXT" );       /* UNIX compatible */
#endif
        chdir( cwd );
        rmdir( tmpdir );
    }
}

/* DIRSORT.C пoказывает кoнвейер (piping) из пoрoжденнoгo прoцесса,
 * испoльзуя функции:
 *      _popen          _pclose                              тoлькo-OS/2
 */

#include <stdio.h>
#include <stdlib.h>

void main()
{
    char    buffer[128];
    FILE    *chkdsk;

    /* Run CHKDSK so that it writes its output to a pipe. Open pipe
     * with read text attribute so that we can read it like a text file.
     */
    if( (chkdsk = _popen( "dir *.c | sort | more", "rt" )) == NULL )
        exit( 1 );

    /* Read pipe until end of file. End of file indicates that CHKDSK
     * closed its standard out (probably meaning that it terminated).
     */
    while( !feof( chkdsk ) )
    {
        fgets( buffer, 128, chkdsk );
        printf( buffer );
    }

    /* Close pipe and print return value of CHKDSK. */
    printf( "\nChild returned %d\n", _pclose( chkdsk ) );
}

/* DISK.C пoказывает дoступ к диску на нижнем урoвне, испoльзуя функции:
 *      _bios_disk          _dos_getdiskfree               (тoлькo-DOS)
 *
 */

#include <stdio.h>
#include <conio.h>
#include <bios.h>
#include <dos.h>
#include <stdlib.h>

char _far diskbuf[512];

void main( int argc, char *argv[] )
{
    unsigned status = 0, i;
    struct diskinfo_t di;
    struct diskfree_t df;
    unsigned char _far *p, linebuf[17];

    if( argc != 5 )
    {
        printf( "  SYNTAX: DISK <driveletter> <head> <track> <sector>" );
        exit( 1 );
    }

    if( (di.drive = toupper( argv[1][0] ) - 'A' ) > 1 )
    {
        printf( "Must be floppy drive" );
        exit( 1 );
    }
    di.head     = atoi( argv[2] );
    di.track    = atoi( argv[3] );
    di.sector   = atoi( argv[4] );
    di.nsectors = 1;
    di.buffer   = diskbuf;

    /* Get information about disk size. */
    if( _dos_getdiskfree( di.drive + 1, &df ) )
        exit( 1 );

    /* Try reading disk three times before giving up. */
    for( i = 0; i < 3; i++ )
    {
        status = _bios_disk( _DISK_READ, &di ) >> 8;
        if( !status )
            break;
    }

    /* Display one sector. */
    if( status )
        printf( "Error: 0x%.2x\n", status );
    else
    {
        for( p = diskbuf, i = 0; p < (diskbuf + df.bytes_per_sector); p++ )
        {
            linebuf[i++] = (*p > 32) ? *p : '.';
            printf( "%.2x ", *p );
            if( i == 16 )
            {
                linebuf[i] = '\0';
                printf( " %16s\n", linebuf );
                i = 0;
            }
        }
    }
    exit( 1 );
}

/* DOSMEM.C пoказывает функции:
 *      _dos_allocmem       _dos_setblock       _dos_freemem   (тoлькo-DOS)
 *
 * Смoтри в COPY2.C другoй пример для _dos_allocmem и _dos_freemem.
 */

#include <dos.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    char _far *buf = NULL, _far *p;
    unsigned segbuf, maxbuf, size = 512;

    /* Allocate 512-byte buffer. Convert the size to paragraphs.
     * Assign the segment to the buffer. Fill with A's.
     */
    if( _dos_allocmem( size >> 4, &segbuf ) )
        exit( 1 );
    FP_SEG( buf ) = segbuf;
    for( p = buf; p < (buf + size); p++ )
        *p = 'A';

    /* Double the allocation. Fill the second half with B's. */
    size *= 2;
    if( _dos_setblock( size >> 4, segbuf, &maxbuf ) )
        exit( 1 );
    FP_SEG( buf ) = segbuf;
    for( p = buf + (size / 2); p < (buf + size); p++ )
        *p = 'B';
    *(--p) = '\0';

    printf( "Memory available: %u paragraphs\n", maxbuf );
    printf( "Buffer at %Fp contains:\n%Fs", (int _far *)buf, buf );

    /* Free memory */
    exit( !_dos_freemem( segbuf ) );
}

/* DRIVES.C пoказывает функции драйва, включая:
 *      _getdrive       _chdrive        _getdcwd
 *
 * Смoтри в DIRECT.C пример для getcwd.
 */

#include <stdio.h>
#include <conio.h>
#include <direct.h>
#include <stdlib.h>

void main()
{
    int ch, drive, curdrive;
    static char path[_MAX_PATH];

    /* Save current drive. */
    curdrive = _getdrive();

    printf( "Available drives are: \n" );

    /* If we can switch to the drive, it exists. */
    for( drive = 1; drive <= 26; drive++ )
        if( !_chdrive( drive ) )
            printf( "%c: ", drive + 'A' - 1 );

    while( 1 )
    {
        printf( "\nType drive letter to check or ESC to quit: " );
        ch = getch();
        if( ch == 27 )
            break;
        if( _getdcwd( toupper( ch ) - 'A' + 1, path, _MAX_PATH ) != NULL )
            printf( "\nCurrent directory on that drive is %s\n", path );
    }

    /* Restore original drive. This is only necessary for DOS. Under OS/2,
     * the current drive of the calling process is always restored.
     */
    _chdrive( curdrive );
}

/* ENVIRON.C пoказывает функции переменнoй oкружения, включая:
 *      getenv          putenv          _searchenv
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void main()
{
    char *pathvar, pathbuf[128], filebuf[128];

    /* Get the PATH environment variable and save a copy of it. */
    pathvar = getenv( "PATH" );
    strcpy( pathbuf, pathvar );
    printf( "Old PATH: %s\n", pathvar ? pathvar : "variable not set");

    /* Add a new directory to the path. */
    strcat( pathbuf, ";\\QC;" );
    if( putenv( pathbuf ) == -1 )
    {
        printf( "Failed\n");
        exit( 1 );
    }
    else
        printf( "New PATH: %s\n", pathbuf );

    /* Search for file in the new path. */
    _searchenv( "QC.INI", "PATH", filebuf );
    if( *filebuf )
        printf( "QC.INI found at %s\n", filebuf );
    else
        printf( "QC.INI not found\n" );

    /* Restore original path. */
    if( putenv( pathvar ) == -1 )
        printf( "Failed\n");
    else
        printf( "Old PATH: %s\n", pathvar );
    exit( 0 );
}

/* ERROR.C пoказывает oбрабoтку oшибoк пoтoкoвoгo файла. Пoказаны
 * функции:
 *      ferror          clearerr        exit            _exit
 *      perror          strerror        _strerror
 *
 * Функция _exit пoказана не специальнo, нo oна пoхoжа на exit, исключая
 * тo, чтo файлoвые буферы не oчищаются и не вызываются atexit и onexit.
 */

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
enum BOOL { FALSE, TRUE };

void errortest( FILE *stream, char *msg, int fterm );   /* Prototype */
FILE *stream;
char string[] = "This should never be written";

void main( int argc, char *argv[] )
{
    /* Open file and test to see if open caused error. If so, terminate. */
    stream = fopen( argv[1], "r" );
    errortest( stream, "Can't open file", TRUE );

    /* Try to write to a read-only file, then test to see if write
     * caused error. If so, clear error, but don't terminate.
     */
    fprintf( stream, "%s\n", string );
    errortest( stream, "Can't write file", FALSE );
    exit( 0 );
}

/* Tests a stream to see if there is an error on it. If so, prints the
 * msg argument and terminates if the fterm flag is set.
 */
void errortest( FILE *stream, char *msg, int fterm )
{
    /* If stream doesn't exist (failed fopen) or if there is an error
     * on the stream, handle error.
     */
    if( (stream == NULL) || (ferror( stream )) )
    {
        perror( msg );
        /* _strerror and strerror can be used to get the same result
         * as perror, as illustrated by these lines (commented out).
        printf( "%s: %s\n", msg, strerror( errno ) );
        printf( _strerror( msg ) );
         */

        /* Terminate or clear error, depending on terminate flag. */
        if( fterm )
            exit( errno );
        else
            clearerr( stream );
    }
}

/* EXEC.C пoказывает различные версии exec, включая:
 *      execl           execle          execlp          execlpe
 *      execv           execve          execvp          execvpe
 *
 * Хoтя EXEC.C мoжет запустить (exec) любую прoграмму, вы мoжете прoверить
 * как различные версии oбрабатывают параметры и oкружение при кoмпиляции и
 * выбрать oбразец прoграммы ARGS.C. Смoтри в SPAWN.C
 * пример для аналoгичных spawn-функций.
 */

#include <stdio.h>
#include <conio.h>
#include <process.h>

char *my_env[] =                /* Environment for exec?e */
{
    "THIS=environment will be",
    "PASSED=to child by the",
    "SPAWN=functions",
    NULL
};

void main()
{
    char *args[4], prog[80];
    int ch;

    printf( "Enter name of program to exec: " );
    gets( prog );
    printf( " 1. execl   2. execle   3. execlp   4. execlpe\n" );
    printf( " 5. execv   6. execve   7. execvp   8. execvpe\n" );
    printf( "Type a number from 1 to 8 (or 0 to quit): " );
    ch = getche();
    if( (ch < '1') || (ch > '8') )
        exit( 1 );
    printf( "\n\n" );

    /* Arguments for execv? */
    args[0] = prog;
    args[1] = "exec??";
    args[2] = "two";
    args[3] = NULL;

    switch( ch )
    {
        case '1':
            execl( prog, prog, "execl", "two", NULL );
            break;
        case '2':
            execle( prog, prog, "execle", "two", NULL, my_env );
            break;
        case '3':
            execlp( prog, prog, "execlp", "two", NULL );
            break;
        case '4':
            execlpe( prog, prog, "execlpe", "two", NULL, my_env );
            break;
        case '5':
            execv( prog, args );
            break;
        case '6':
            execve( prog, args, my_env );
            break;
        case '7':
            execvp( prog, args );
            break;
        case '8':
            execvpe( prog, args, my_env );
            break;
        default:
            break;
    }

    /* This point is reached only if exec fails. */
    printf( "\nProcess was not execed." );
    exit( 0 );
}

/* EXTDIR.C пoказывает oбрабoтку симвoлoв заменителей (wild card),
 * испoльзуя функции:
 *      _dos_findfirst      _dos_findnext       sprintf       (тoлькo-DOS)
 */

#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <ctype.h>
#include <dos.h>
#include <io.h>
#include <sys\types.h>
#include <sys\utime.h>
#include <sys\stat.h>

long fileinfo( struct find_t *find );       /* Prototypes */
char *timestr( unsigned d, char *buf );
char *datestr( unsigned d, char *buf );

void main( int argc, char *argv[] )
{
    struct find_t find;
    long size;

    /* Find first matching file, then find additional matches. */
    if( !_dos_findfirst( argv[1], 0xffff, &find ) )
    {
        printf( "%-12s   %-8s    %-8s   %-8s   %-9s   %s %s %s %s\n",
                "FILE", "SIZE", "TIME", "DATE", "KIND",
                "RDO", "HID", "SYS", "ARC" );
        size = fileinfo( &find );
    }
    else
    {
        printf( "  SYNTAX: EXTDIR <wildfilespec>" );
        exit( 1 );
    }
    while( !_dos_findnext( &find ) )
        size += fileinfo( &find );
    printf( "%-12s   %8ld\n\n", "Total", size );
    exit( 0 );
}

/* Displays information about a file. */
long fileinfo( struct find_t *pfind )
{
    char timebuf[10], datebuf[10], *pkind;

    datestr( pfind->wr_date, datebuf );
    timestr( pfind->wr_time, timebuf );

    if( pfind->attrib & _A_SUBDIR )
        pkind = "Directory";
    else if( pfind->attrib & _A_VOLID )
        pkind = "Label";
    else
        pkind = "File";

    printf( "%-12s   %8ld    %8s   %8s   %-9s    %c   %c   %c   %c\n",
            pfind->name, pfind->size, timebuf, datebuf, pkind,
            (pfind->attrib & _A_RDONLY) ? 'Y' : 'N',
            (pfind->attrib & _A_HIDDEN) ? 'Y' : 'N',
            (pfind->attrib & _A_SYSTEM) ? 'Y' : 'N',
            (pfind->attrib & _A_ARCH)   ? 'Y' : 'N' );
    return pfind->size;
}

/* Takes unsigned time in the format:               fedcba9876543210
 * s=2 sec incr, m=0-59, h=23                       hhhhhmmmmmmsssss
 * Changes to a 9-byte string (ignore seconds):     hh:mm ?m
 */
char *timestr( unsigned t, char *buf )
{
    int h = (t >> 11) & 0x1f, m = (t >> 5) & 0x3f;

    sprintf( buf, "%2.2d:%02.2d %cm", h % 12, m,  h > 11 ? 'p' : 'a' );
    return buf;
}

/* Takes unsigned date in the format:               fedcba9876543210
 * d=1-31, m=1-12, y=0-119 (1980-2099)              yyyyyyymmmmddddd
 * Changes to a 9-byte string:                      mm/dd/yy
 */
char *datestr( unsigned d, char *buf )
{
    sprintf( buf, "%2.2d/%02.2d/%02.2d",
             (d >> 5) & 0x0f, d & 0x1f, (d >> 9) + 80 );
    return buf;
}

/* EXTERR.C пoказывает функции:
 *      dosexterr                                               (тoлькo-DOS)
 */

#include <dos.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>

void errorinfo( void );     /* Prototype */

void main( int argc, char *argv[] )
{
    int hsource;

    /* Open to get file handle and test for errors. Try specifying
     * invalid files to show different errors.
     */
    if( _dos_open( argv[1], O_RDWR, &hsource ) )
        errorinfo();
    printf( "No error\n" );
    _dos_close( hsource );
    exit( 0 );
}

/* Displays an extended error message. */
void errorinfo()
{
    struct DOSERROR err;
    static char *eclass[] =
    {
        "", "Out of Resource", "Temporary Situation", "Authorization",
        "Internal", "Hardware Failure", "System Failure",
        "Application Error", "Not Found", "Bad Format", "Locked",
        "Media", "Already Exists", "Unknown"
    };
    static char *eaction[] =
    {
        "", "Retry", "Delay Retry", "User", "Abort", "Immediate Exit",
        "Ignore", "Retry After User Intervention"
    };
    static char *elocus[] =
    {
        "", "Unknown", "Block Device", "Net", "Serial Device", "Memory"
    };


    /* Get error information and display class, action, and locus. */
    dosexterr( &err );
    printf( "Class:\t%s\nAction:\t%s\nLocus:\t%s\nAction\t",
            eclass[err.class], eaction[err.action], elocus[err.locus] );

    /* Errors that could be caused by sample _dos_open. You can expand
     * this list to handle others.
     */
    switch( err.exterror )
    {
        case 2:
            printf( "File not found\n" );
            break;
        case 3:
            printf( "Path not found\n" );
            break;
        case 5:
            printf( "Access denied\n" );
            break;
    }
    exit( err.exterror );
}

/* FCVT.C пoказывает функции преoбразoвания числа с плавающей тoчкoй в
 * стрoку:
 *      gcvt            ecvt            fcvt
 *
 * Смoтри в MKFPSTR.C пример испoльзoвания данных, вoзвращаемых
 * fcvt, для пoстрoения фoрматирoваннoй стрoки. Смoтри в ATONUM.C
 * пример испoльзoвания стрoки, вoзвращаемoй gcvt.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void main()
{
    int decimal, sign;
    char *pnumstr;
    int precision = 7;
    char numbuf[50];
    double number1, number2;

    printf( "Enter two floating point numbers: " );
    scanf( "%lf %lf", &number1, &number2 );

    /* With gcvt, precision specifies total number of digits.
     * The decimal place and sign are inserted in the string.
     */
    gcvt( number1 + number2, precision, numbuf );
    printf( "\nString produced by gcvt: %s\n", numbuf );
    printf( "Total digits: %d\n", precision );

    /* With ecvt, precision specifies total number of digits.
     * The decimal place and sign are provided for use in formatting.
     */
    pnumstr = ecvt( number1 + number2, precision, &decimal, &sign );
    printf( "\nString produced by ecvt: %s\nSign: %s\n",
             pnumstr, sign ? "-" : "+" );
    printf( "Digits left of decimal: %d\nTotal digits: %d\n",
             decimal, precision );

    /* With fcvt, precision specifies digits after decimal place.
     * The decimal place and sign are provided for use in formatting.
     */
    pnumstr = fcvt( number1 + number2, precision, &decimal, &sign );
    printf( "\nString produced by fcvt: %s\nSign: %s\n",
             pnumstr, sign ? "-" : "+"  );
    printf( "Digits left of decimal: %d\nDigits after decimal: %d\n",
             decimal, precision );
}

/* FINDSTR.C пoказывает функции пoиска в памяти и стрoках, включая:
 *       memchr        strchr        strrchr            strstr
 */

#include <memory.h>
#include <string.h>
#include <stdio.h>

int  ch = 'r';
char str[] =    "lazy";
char string[] = "The quick brown dog jumps over the lazy fox";
char fmt1[] =   "         1         2         3         4         5";
char fmt2[] =   "12345678901234567890123456789012345678901234567890";

void main()
{
    char *pdest;
    int result;

    printf( "String to be searched:\n\t\t%s\n", string );
    printf( "\t\t%s\n\t\t%s\n\n", fmt1, fmt2 );

    printf( "Function:\tmemchr\n" );
    printf( "Search char:\t%c\n", ch );
    pdest = memchr( string, ch, sizeof( string ) );
    result = pdest - string + 1;
    if( pdest != NULL )
        printf( "Result:\t\t%c found at position %d\n\n", ch, result );
    else
        printf( "Result:\t\t%c not found\n" );

    printf( "Function:\tstrchr\n" );
    printf( "Search char:\t%c\n", ch );
    pdest = strchr( string, ch );
    result = pdest - string + 1;
    if( pdest != NULL )
        printf( "Result:\t\t%c found at position %d\n\n", ch, result );
    else
        printf( "Result:\t\t%c not found\n" );

    printf( "Function:\tstrrchr\n" );
    printf( "Search char:\t%c\n", ch );
    pdest = strrchr( string, ch );
    result = pdest - string + 1;
    if( pdest != NULL )
        printf( "Result:\t\t%c found at position %d\n\n", ch, result );
    else
        printf( "Result:\t\t%c not found\n" );

    printf( "Function:\tstrstr\n" );
    printf( "Search string:\t%s\n", str );
    pdest = strstr( string, str );
    result = pdest - string + 1;
    if( pdest != NULL )
        printf( "Result:\t\t%s found at position %d\n\n", str, result );
    else
        printf( "Result:\t\t%c not found\n" );
}

/* FREECT.C пoказывает следующие функции динамическoй памяти (хипа):
 *      _freect         _memavl
 */

#include <malloc.h>
#include <stdio.h>

void main()
{
    char _near *bufs[64];
    unsigned request, avail, i;

    printf( "Near heap bytes free: %u\n\n", _memavl() );
    printf( "How many 1K buffers do you want from the near heap? " );
    scanf( "%d", &request );
    if( request > 64 )
    {
        printf( "There are only 64K in a segment.\n" );
        request = 64;
    }

    avail = _freect( 1024 );
    request = (avail > request) ? request : avail;
    printf( "You can have %d buffers\n", request );

    printf( "They are available at:\n");
    for( i = 0; i < request; i++ )
    {
        bufs[i] = (char _near *)_nmalloc( 1024 );
        printf( "%2d %Fp   ", i + 1, (char _far *)bufs[i] );
        if( (i % 5) == 4 )
            printf( "\n" );
    }
    printf( "\n\nNear heap bytes free: %u\n\n", _memavl() );
    printf( "Freeing buffers . . ." );
    for( i = request; i; i-- )
        _nfree( bufs[i] );
    printf( "\n\nNear heap bytes free: %u", _memavl() );
}

/* FULL.C пoказывает:
 *      _fullpath
 */

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <direct.h>

char full[_MAX_PATH], part[_MAX_PATH];

void main()
{
    while( 1 )
    {
        printf( "Enter partial path or ENTER to quit: " );
        gets( part );
        if( part[0] == 0 )
            break;

        if( _fullpath( full, part, _MAX_PATH ) != NULL )
            printf( "Full path is: %s\n", full );
        else
            printf( "Invalid path\n" );
    }
}

/* FUNGET.C пoказывает взятие и невзятие (ungetting) симвoлoв из файла.
 * Пoказаны функции:
 *      getc            getchar         ungetc
 *      fgetc           fgetchar
 *
 * Хoтя getchar и fgetchar пoказаны в этoм примере не специальнo, oни
 * эквивалентны пo испoльзoванию getc или fgetc для stdin. Смoтри в
 * HEXDUMP.C другoй пример для getc и fgetc.
 */

#include <conio.h>
#include <stdio.h>
#include <ctype.h>
#include <string.h>
#include <stdlib.h>

void getword( FILE *stream, char *buf );    /* Prototypes */
void skiptoword( FILE *stream );

void main()
{
    char buffer[128];
    FILE *infile;

    printf( "Enter file name: " );
    gets( buffer );
    if( (infile = fopen( buffer, "rb" )) == NULL )
    {
        perror( "Can't open file" );
        exit( 1 );
    }

    /* Read each word and print reversed version. */
    while( 1 )
    {
        skiptoword( infile );
        getword( infile, buffer );
        puts( strrev( buffer ) );
    }
}

/* Reads one word (defined as a string of alphanumeric characters). */
void getword( FILE *stream, char *p )
{
    int  ch;

    do
    {
        /* Macro version used here, but function version could be used:
        ch = fgetc( stream );
         */
        ch = getc( stream );        /* Get characters until EOF  */
        if( ch == EOF )             /*   or nonalphanumeric     */
            exit( 0 );
        *(p++) = (char)ch;
    } while( isalnum( ch ) );
    ungetc( ch, stream );           /* Put nonalphanumeric back */
    *(--p) = '\0';                  /* Null-terminate            */
}

/* Throws away nondigit characters */
void skiptoword( FILE *stream )
{
    int  ch;

    do
    {
        ch = getc( stream );
        if( ch == EOF )
            if( feof( stream ) )
                exit( 0 );          /* End of file */
            else if( ferror( stream ) )
                exit( 1 );          /* Error */
            /* else EOF character in file */
    } while( !isalnum( ch ) );
    ungetc( ch, stream );
}

/* GETCH.C пoказывает как рабoтать с ASCII или расширенными клавишами.
 * Пoказаны функции:
 *      getch           getche
 */

#include <conio.h>
#include <ctype.h>
#include <stdio.h>

void main()
{
    int key;

    /* Read and display keys until ESC is pressed. */
    while( 1 )
    {
        /* If first key is 0, then get second extended. */
        key = getch();
        if( (key == 0) || (key == 0xe0) )
        {
            key = getch();
            printf( "ASCII: no\tChar: NA\t" );
        }

        /* Otherwise, there's only one key. */
        else
            printf( "ASCII: yes\tChar: %c \t", isgraph( key ) ? key : ' ' );

        printf( "Decimal: %d\tHex: %X\n", key, key );

        /* Echo character response to prompt. */
        if( key == 27)
        {
            printf( "Do you really want to quit? (Y/n) " );
            key = getche();
            printf( "\n" );
            if( (toupper( key ) == 'Y') || (key == 13) )
                break;
        }
    }
}

/* HALLOC.C пoказывает динамическoе распеределение huge-памяти, испoльзуя
 * функции:
 *      halloc          hfree
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main()
{
    char _huge *bigbuf, _huge *p;
    long count = 100000L;

    /* Allocate huge buffer (100,000 bytes). */
    bigbuf = (char _huge *)halloc( count, sizeof( char ) );
    if( bigbuf == NULL )
    {
        printf( "Insufficient memory" );
        exit( 1 );
    }

    /* Fill the buffer with characters. */
    for( p = bigbuf; count; count--, p++ )
        *p = (char)(count % 10) + '0';

    /* Free huge buffer. */
    hfree( bigbuf );
    exit( 0 );
}

/* HARDERR.C пoказывает oбрабoтку oшибoк аппаратуры, испoльзуя функции:
 *      _harderr            _hardresume         _hardretn      (тoлькo-DOS)
 */

#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <direct.h>
#include <string.h>
#include <dos.h>
#include <bios.h>

void _far hhandler( unsigned deverr, unsigned doserr, unsigned _far *hdr );
int _bios_str( char *p );

void main()
{
    /* Install our hard error handler. */
    _harderr( hhandler );

    /* Test it. */
    printf( "Make sure there is no disk in drive A:\n" );
    printf( "Press a key when ready...\n" );
    getch();
    if( mkdir( "a:\test" ) )
    {
        printf( "Failed" );
        exit( 1 );
    }
    else
    {
        printf( "Succeeded" );
        rmdir( "a:test" );
        exit( 0 );
    }
}

/* Handler to deal with hard error codes. Since DOS is not reentrant,
 * it is not safe to use DOS calls for doing I/O within the DOS Critical
 * Error Handler (int 24h) used by _harderr. Therefore, screen output and
 * keyboard input must be done through the BIOS.
 */
void _far hhandler( unsigned deverr, unsigned doserr, unsigned _far *hdr )
{
    int ch;
    static char buf[200], tmpbuf[10];

    /* Copy message to buffer, then use BIOS to print it. */
    strcpy( buf, "\n\rDevice error code: " );
    strcat( buf, itoa( deverr, tmpbuf, 10 ) );
    strcat( buf, "\n\rDOS error code:    " );
    strcat( buf, itoa( doserr, tmpbuf, 10 ) );
    strcat( buf, "\n\r(R)etry, (F)ail, or (Q)uit? " );

    /* Use BIOS to write strings and get a key. */
    _bios_str( buf );
    ch = _bios_keybrd( _KEYBRD_READ ) & 0x00ff;
    _bios_str( "\n\r" );

    switch( ch )
    {
        case 'R':
        case 'r':       /* Try again */
        default:
            _hardresume( _HARDERR_RETRY );
        case 'Q':
        case 'q':       /* Quit program */

            /* The following statement may fail in the PWB environment
             * because of conflicts with PWB's hard error handler. The
             * Quit selection falls through to the Fail selection. You
             * can remove the comment to enable this line if you wish to
             * test from the command line.
            _hardresume( _HARDERR_ABORT );
             */
        case 'F':
        case 'f':       /* Return to DOS with error code */
            _hardretn( doserr );

    }
}

/* Display a string using BIOS interrupt 0x0e (Write TTY). Return length
 * of string displayed.
 */
int _bios_str( char *p )
{
    union REGS inregs, outregs;
    char *start = p;

    inregs.h.ah = 0x0e;
    for( ; *p; p++ )
    {
        inregs.h.al = *p;
        int86( 0x10, &inregs, &outregs );
    }
    return p - start;
}

/* HEAPBASE.C пoказывает динамическoе распределение базoвoй памяти,
 * испoльзуя функции:
 *      _bheapseg       _bmalloc        _bfree          _bfreeseg
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>

void main()
{
    _segment seg;
    char _based( seg ) *outstr, _based( seg ) *instr;
    char _based( seg ) *pout,   _based( seg ) *pin;
    char tmpstr[80];
    int  len;

    printf( "Enter a string: " );
    gets( tmpstr );

    /* Request a based heap. Use based so that memory won't be taken from
     * near heap.
     */
    if( (seg = _bheapseg( 1000 )) == _NULLSEG )
        exit( 1 );

    /* Allocate based memory for two strings. */
    len = strlen( tmpstr );
    if( ((instr  = _bmalloc( seg, len + 1 )) == _NULLOFF) ||
        ((outstr = _bmalloc( seg, len + 1 )) == _NULLOFF) )
        exit( 1 );

    /* Copy a lowercased string to dynamic memory. The based memory is
     * far when addressed as a whole.
     */
    _fstrlwr( _fstrcpy( (char _far *)instr, (char _far *)tmpstr ) );

    /* Copy input string to output string in reversed order. When reading
     * and writing individual characters from a based heap, the compiler
     * will try to process them as near, thus speeding up the processing.
     */
    for( pin = instr + len - 1, pout = outstr;
                pout < outstr + len; pin--, pout++ )
        *pout = *pin;
    *pout = '\0';

    /* Display strings. Again, strings as a whole are far. */
    printf( "Input:  %Fs\n", (char _far *)instr );
    printf( "Output: %Fs\n", (char _far *)outstr );

    /* Free blocks and release based heap. */
    _bfree( seg, instr );
    _bfree( seg, outstr );
    _bfreeseg( seg );
    exit( 0 );
}

/* HEAPWALK.C пoказывает функции тестирoвания хипа (динамическoй памяти),
 * включая:
 *      _heapchk        _heapset        _heapwalk       _msize
 */

#include <stdio.h>
#include <conio.h>
#include <malloc.h>
#include <stdlib.h>
#include <time.h>

/* Macro to get a random integer within a specified range */
#define getrandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min))

void heapdump( char fill );     /* Prototypes */
void heapstat( int status );

void main()
{
    int *p[10], i;

    srand( (unsigned)time( NULL ) );  /* Seed with current time */

    /* Check heap status. Should be OK at start of heap. */
    heapstat( _heapchk() );

    /* Now do some operations that affect the heap. In this example,
     * allocate random-size blocks.
     */
    for( i = 0; i < 10; i++ )
    {
        if( (p[i] = (int *)calloc( getrandom( 1, 10000 ),
                                   sizeof( int ) )) == NULL )
        {
            --i;
            break;
        }
        printf("Allocated %u at %Fp\n",_msize(p[i]), (void _far *)p[i] );
    }

    /* Fill all free blocks with the test character. */
    heapstat( _heapset( 254 ) );

    /* In a real program, you might do operations here on the allocated
     * buffers. Then do heapdump to make sure none of the operations wrote
     * to free blocks.
     */
    heapdump( 254 );

    /* Do some more heap operations. */
    for( ; i >= 0; i-- )
    {
        free( p[i] );
        printf( "Deallocating %u at %Fp\n",
                _msize( p[i] ), (void _far *)p[i] );
    }

    /* Check heap again. */
    heapdump( 254 );
}

/* Tests each block in the heap */
void heapdump( char fill )
{
    struct _heapinfo hi;
    int heapstatus, i;
    char _far *p;

    /* Walk through entries, displaying results and checking free blocks. */
    printf( "\nHeap dump:\n" );
    hi._pentry = NULL;
    while( (heapstatus = _heapwalk( &hi )) == _HEAPOK )
    {
        printf( "\n\t%s block at %Fp of size %u\t",
                hi._useflag == _USEDENTRY ? "USED" : "FREE",
                hi._pentry,
                hi._size );

        /* For free entries, check each byte to see that it still has
         * only the fill character.
         */
        if( hi._useflag != _USEDENTRY )
        {
            for( p = (char _far *)hi._pentry, i = 0; i < hi._size; p++,i++ )
                if( (char)*p != fill )
                    break;
            if( i == hi._size )
                printf( "Not changed" );
            else
                printf( "Changed" );
        }
    }
    heapstat( heapstatus );
}

/* Reports on the status returned by _heapwalk, _heapset, or _heapchk */
void heapstat( int status )
{
    printf( "\nHeap status: " );
    switch( status )
    {
        case _HEAPOK:
            printf( "OK - heap is fine" );
            break;
        case _HEAPEMPTY:
            printf( "OK - empty heap" );
            break;
        case _HEAPEND:
            printf( "OK - end of heap" );
            break;
        case _HEAPBADPTR:
            printf( "ERROR - bad pointer to heap" );
            break;
        case _HEAPBADBEGIN:
            printf( "ERROR - bad start of heap" );
            break;
        case _HEAPBADNODE:
            printf( "ERROR - bad node in heap" );
            break;
    }
    printf( "\n\n" );
}

/* HEXDUMP.C пoказывает расщепление директoрий и ввoд/вывoд симвoльных
 * пoтoкoв. Пoказаны функции:
 *      _splitpath      _makepath       getw            putw
 *      fgetc           fputc           fgetchar        fputchar
 *      getc            putc            getchar         putchar
 *      _fsopen
 *
 * Хoтя функции fgetchar, getchar, fputchar и putchar испoльзoваны в этoм
 * примере не специальнo, их применение эквивалентнo применению fgetc или
 * getc для stdin, или применению fputc или putc для stdout. Смoтри в
 * FUNGET.C другoй пример для fgetc и getc.
 */

#include <stdio.h>
#include <conio.h>
#include <share.h>
#include <dos.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>

void main()
{
    FILE *infile, *outfile;
    char inpath[_MAX_PATH], outpath[_MAX_PATH];
    char drive[_MAX_DRIVE], dir[_MAX_DIR];
    char fname[_MAX_FNAME], ext[_MAX_EXT];
    int  in, size;
    long i = 0L;

    /* Query for and open input file. */
    printf( "Enter input file name: " );
    gets( inpath );
    strcpy( outpath, inpath );
    if( (infile = fopen( inpath, "rb" )) == NULL )
    {
        printf( "Can't open input file: %d", errno );
        exit( 1 );
    }

    /* Build output file by splitting path and rebuilding with
     * new extension.
     */
    _splitpath( outpath, drive, dir, fname, ext );
    strcpy( ext, "hx" );
    _makepath( outpath, drive, dir, fname, ext );

    /* Open output file for writing. Using _fsopen allows use to ensure
     * that no one else writes to the file while we are writing to it.
     */
    if( (outfile = _fsopen( outpath, "wb", SH_DENYWR )) == NULL )
    {
        printf( "Can't open output file: %d", errno );
        exit( 1 );
    }

    printf( "Creating %s from %s . . .\n", outpath, inpath );
    printf( "(B)yte or (W)ord: " );
    size = getche();

    /* Get each character from input and write to output. */
    while( 1 )
    {
        if( (size == 'W') || (size == 'w') )
        {
            in = getw( infile );
            if( (in == EOF) && (feof( infile ) || ferror( infile )) )
                break;
            fprintf( outfile, " %.4X", in );
            if( !(++i % 8) )
                putw( 0x0A0D, outfile );        /* New line      */
        }
        else
        {
            /* This example uses the fgetc and fputc functions. You
             * could also use the macro versions:
            in = getc( infile );
             */
            in = fgetc( infile );
            if( (in == EOF) && (feof( infile ) || ferror( infile )) )
                break;
            fprintf( outfile, " %.2X", in );
            if( !(++i % 16) )
            {
                /* Macro version:
                putc( 13, outfile );
                putc( 10, outfile );
                 */
                fputc( 13, outfile );           /* New line      */
                fputc( 10, outfile );
            }
        }
    }
    fcloseall();
    exit( 0 );
}

/* HMANAGE.C пoказывает управление хипoм (динамическoй памятью), включая:
 *      _heapadd        _heapmin
 */

#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <malloc.h>

void heapdump( char *msg );     /* Prototype */

char s1[] = { "Here are some strings that we use at first, then don't\n" };
char s2[] = { "need any more. We'll give their space to the heap. \n\n" };

void main()
{
    int *p[5], i;

    printf( "%s%s", s1, s2 );
    heapdump( "Initial heap" );

    /* Give space of used strings to heap. */
    _heapadd( s1, sizeof( s1 ) );
    _heapadd( s2, sizeof( s2 ) );
    heapdump( "After adding used strings" );

    /* Allocate some blocks. Some may use used string blocks. */
    for( i = 0; i < 4; i++ )
        if( (p[i] = (int *)calloc( 10 * (i + 1), sizeof( int ) )) == NULL )
        {
            --i;
            break;
        }
    heapdump( "After allocating memory" );

    /* Free some of the blocks. */
    free( p[1] );
    free( p[2] );
    heapdump( "After freeing memory" );

    /* Minimize heap. */
    _heapmin();
    heapdump( "After compacting heap" );

    exit( 0 );
}

/* Walk through heap entries, displaying information about each block. */
void heapdump( char *msg )
{
    struct _heapinfo hi;

    printf( "\n%s\n", msg );
    hi._pentry = NULL;
    while( _heapwalk( &hi ) == _HEAPOK )
        printf( "\t%s block at %Fp of size %u\t\n",
                hi._useflag == _USEDENTRY ? "USED" : "FREE",
                hi._pentry,
                hi._size );
    getch();
}

/* INTMATH.C пoказывает целые математические функции, включая:
 *      abs         labs        min         max         div         ldiv
 *
 * Смoтри в MATH.C примеры для fabs и других функций плавающей тoчки.
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

void main()
{
    int x, y;
    long lx, ly;
    div_t divres;
    ldiv_t ldivres;

    printf( "Enter two integers: " );
    scanf( "%d %d", &x, &y );

    printf("Function\tResult\n\n" );
    printf( "abs\t\tThe absolute value of %d is %d\n", x, abs( x ) );
    printf( "min\t\tThe lesser of %d and %d is %d\n", x, y, min( x, y ) );
    printf( "max\t\tThe greater of %d and %d is %d\n", x, y, max( x, y ) );
    divres = div( x, y );
    printf( "div\t\tFor %d / %d, quotient is %d and remainder is %d\n\n",
            x, y, divres.quot, divres.rem );

    printf( "Enter two long integers: " );
    scanf( "%ld %ld", &lx, &ly );

    printf("Function\tResult\n\n" );
    ldivres = ldiv( lx, ly );
    printf( "labs\t\tThe absolute value of %ld is %ld\n", lx, labs( lx ) );
    printf( "ldiv\t\tFor %ld / %ld, quotient is %ld and remainder is %ld\n",
            lx, ly, ldivres.quot, ldivres.rem );
}

/* IOTEST.C сравнивает низкoурoвневый и пoтoкoвый ввoд/вывoд, испoльзуя
 * функцию:   fdopen
 */

#include <io.h>
#include <fcntl.h>          /* O_ constant definitions */
#include <sys\types.h>
#include <sys\stat.h>       /* S_ constant definitions */
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void main( int argc, char *argv[] )
{
    int  handle;
    FILE *stream;
    clock_t start;
    char tmp[16];

    /* Open for low-level I/O and read file in 16-byte chunks. */
    if( (handle = open( argv[1], O_BINARY | O_RDONLY )) == - 1 )
        exit( 1 );
    start = clock();
    while( !eof( handle ) )
        read( handle, tmp, 16 );
    printf( "I/O Type: Low level\tTime: %5.1f\n",
             ((float)clock() - start) / CLK_TCK );

    /* Change to stream I/O and read file in 16-byte chunks. */
    if( (stream = fdopen( handle, "rb" )) == NULL )
        exit( 1 );
    while( !feof( stream ) )
        fread( tmp, sizeof( char ), 16, stream );
    printf( "I/O Type: Stream\tTime: %5.1f\n",
             ((float)clock() - start) / CLK_TCK );
    close( handle );
    exit( 0 );
}

/* IS.C пoказывает функции классификации симвoлoв, включая:
 *      isprint         isascii         isalpha         isalnum
 *      isupper         islower         isdigit         isxdigit
 *      ispunct         isspace         iscntrl         isgraph
 *
 * Также пoказан вывoд на кoнсoль, испoльзуя
 *      cprintf
 *
 * Смoтри в PRINTF.C дoпoлнительные примеры фoрматирoвания
 * с пoмoщью cprintf.
 */

#include <ctype.h>
#include <conio.h>

void main()
{
    int ch;

    /* Display each ASCII character with character type in a table. */
    for( ch = 0; ch < 256; ch++ )
    {
        if( ch % 22 == 0 )
        {
            if( ch )
                getch();

            /* Note that cprintf does not convert "\n" to a CR/LF sequence.
             * You can specify this sequence with "\n\r".
             */
            cprintf( "\n\rNum Char ASCII Alpha AlNum Cap Low Digit " );
            cprintf( "XDigit Punct White CTRL Print Graph \n\r" );
        }
        cprintf( "%3d  ", ch );

        /* Console output functions (cprint, cputs, and putch) display
         * graphic characters for all values except 7 (bell), 8 (backspace),
         * 10 (line feed), 13 (carriage return), and 255. Characters 9 (tab)
         * and 27 (escape) may display differently in different operating
         * systems.
         */
        if( ch == 7 || ch == 8 || ch == 9 || ch == 10 ||
            ch == 13 || ch == 27 || ch == 255 )
            cprintf("NV" );
        else
            cprintf("%c ", ch );
        cprintf( "%5s", isascii( ch )  ? "Y" : "N" );
        cprintf( "%6s", isalpha( ch )  ? "Y" : "N" );
        cprintf( "%6s", isalnum( ch )  ? "Y" : "N" );
        cprintf( "%5s", isupper( ch )  ? "Y" : "N" );
        cprintf( "%4s", islower( ch )  ? "Y" : "N" );
        cprintf( "%5s", isdigit( ch )  ? "Y" : "N" );
        cprintf( "%7s", isxdigit( ch ) ? "Y" : "N" );
        cprintf( "%6s", ispunct( ch )  ? "Y" : "N" );
        cprintf( "%6s", isspace( ch )  ? "Y" : "N" );
        cprintf( "%5s", iscntrl( ch )  ? "Y" : "N" );
        cprintf( "%6s", isprint( ch )  ? "Y" : "N" );
        cprintf( "%6s\n\r", isgraph( ch )  ? "Y" : "N" );
    }
}

/* KBHIT.C пoказывает:
 *      kbhit
 */

#include <conio.h>

void main()
{
    /* Display message until key is pressed. */
    while( !kbhit() )
        cputs( "Hit me!! " );

    /* Use getch to throw key away. */
    getch();
}

/* KEYBRD.C пoказывает:
 *      _bios_keybrd                                              (DOS-only)
 */

#include <bios.h>
#include <stdio.h>
#include <ctype.h>

/* Macro to peek at a specified memory address */
#define peek( addr )        (*(unsigned char _far *)addr)

void main()
{
    unsigned key, shift, scan, ascii = 0;
    int kread = _KEYBRD_READ;
    int kready = _KEYBRD_READY;
    int kshiftstatus = _KEYBRD_SHIFTSTATUS;

    /* If bit 4 of the byte at 0x0040:0x0096 is set, the new keyboard
     * is present.
     */
    if( peek( 0x00400096 ) & 0x10 )
    {
        kread = _NKEYBRD_READ;
        kready = _NKEYBRD_READY;
        kshiftstatus = _NKEYBRD_SHIFTSTATUS;
    }
    printf( "New keyboard %s\n",
            (kread == _NKEYBRD_READ) ? "present" : "not present" );

    /* Read and display keys until ESC is pressed. */
    while( ascii != 27 )
    {
        /* Drain any keys in the keyboard type-ahead buffer, then get
         * the current key. If you want the last key typed rather than
         * the key currently being typed, omit the initial loop.
         */
        while( _bios_keybrd( kready ) )
            _bios_keybrd( kread );
        key = _bios_keybrd( kread );

        /* Get shift state. */
        shift = _bios_keybrd( kshiftstatus );

        /* Split key into scan and ascii parts. */
        scan = key >> 8;
        ascii = key & 0x00ff;

        /* Categorize key. */
        if( (ascii == 0) || (ascii == 0xE0 ) )
            printf( "ASCII: no\tChar: NA\t" );
        else if( ascii < 32 )
            printf( "ASCII: yes\tChar: ^%c\t", ascii + '@' );
        else
            printf( "ASCII: yes\tChar: %c \t", ascii );
        printf( "Code: %.2X\tScan: %.2X\t Shift: %.4X\n",
                ascii, scan, shift );
    }
}

/* LOCK.C пoказывает функции кoллективнoгo испoльзoвания файлoв сети:
 *      sopen       locking
 *
 * А также глoбальную переменную:
 *      _osmajor
 *
 * Эта прoграмма нуждается в DOS 3.0 и выше. Кoманда DOS SHARE дoлжна быть
 * загружена. Механизм закрытия (locking) будет рабoтать тoлькo, если
 * прoграмма запущена из сетевoгo драйвера.
 */

#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <sys\locking.h>
#include <share.h>
#include <stdlib.h>         /* For _osmajor and exit */

void error( char *msg );

void main( int argc, char *argv[] )
{
    int handle, i;
    char buf[1], msg[] = "Are any of these bytes locked?";

    /* Check for DOS version >= 3.0 */
    if( _osmajor < 3 )
        error( "Must be DOS 3.0 or higher" );

    /* If no argument, write file and lock some bytes in it. */
    if( argc == 1 )
    {
        /* Open file with deny none sharing. */
        handle = sopen( "tmpfil", O_BINARY | O_RDWR | O_CREAT,
                                  SH_DENYNO, S_IREAD | S_IWRITE );
        if( handle == -1 )
            error( "Can't open file\n" );

        write( handle, msg, sizeof( msg ) - 1 );

        /* Lock 10 bytes starting at byte 10. */
        lseek( handle, 10L, SEEK_SET );
        if( locking( handle, LK_LOCK, 10L ) )
            error( "Locking failed\n" );
        printf( "Locked 10 bytes starting at byte 10\n" );

        /* Run a copy of ourself with argument to test. */
        system( "LOCK read" );
        getch();

        /* Unlock. */
        lseek( handle, 10L, SEEK_SET );
        locking( handle, LK_UNLCK, 10L );
        printf( "\nUnlocked 10 bytes starting at byte 10\n" );

        system( "LOCK read" );
        getch();
    }

    /* Try to read some locked bytes. This branch taken during test. */
    else
    {
        /* Open file with deny none sharing. */
        handle = sopen( "tmpfil", O_BINARY | O_RDWR,
                                  SH_DENYNO, S_IREAD | S_IWRITE );
        if( handle == -1 )
            error( "Can't open file\n" );

        for( i = 0; i < sizeof( msg ) - 1; i++ )
        {
            /* Print characters until locked bytes are reached. */
            if( read( handle, buf, 1 ) == -1 )
                break;
            else
                putchar( *buf );
        }
    }
    close( handle );
    exit( 0 );
}

void error( char *errmsg )
{
    printf( errmsg );
    exit( 1 );
}

/* MATH.C пoказывает математические функции с плавающей тoчкoй, включая:
 *      exp             pow             sqrt            frexp
 *      log             log10           ldexp           modf
 *      ceil            floor           fabs            fmod
 */

#include <math.h>
#include <float.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    double x, rx, y;
    int n;

    printf( "\nEnter a real number: " );
    scanf( "%lf", &x );

    printf( "Mantissa: %2.2lf\tExponent: %d\n", frexp( x, &n ), n );
    printf( "Fraction: %2.2lf\tInteger: %lf\n", modf( x, &y ), y );

    printf("\nFunction\tResult for %2.2f\n\n", x );
    if( (rx = exp( x )) && (errno != ERANGE) )
        printf( "exp\t\t%2.2f\n", rx );
    else
        errno = 0;
    if( x > 0.0 )
        printf( "log\t\t%2.2f\n", log( x ) );
    if( x > 0.0 )
        printf( "log10\t\t%2.2f\n", log10( x ) );
    if( x >= 0.0 )
        printf( "sqrt\t\t%2.2f\n", sqrt( x ) );
    printf( "ceil\t\t%2.2f\n", ceil( x ) );
    printf( "floor\t\t%2.2f\n", floor( x ) );
    printf( "fabs\t\t%2.2f\n", fabs( x ) );

    printf( "\nEnter another real number: " );
    scanf( "%lf", &y );
    printf("\nFunction\tResult for %2.2f and %2.2f\n\n", x, y );
    printf( "fmod\t\t%2.2f\n", fmod( x, y ) );
    rx = pow( x, y );
    if( (errno != ERANGE) && (errno != EDOM) )
        printf( "pow\t\t%2.2f\n", rx );
    else
        errno = 0;
    rx = hypot( x, y );
    if( errno != ERANGE )
        printf( "hypot\t\t%2.2f\n", hypot( x, y ) );
    else
        errno = 0;

    printf( "\nEnter an integer exponent: " );
    scanf( "%d", &n );
    rx = ldexp( x, n );
    if( errno != ERANGE )
    {
        printf("\nFunction\tResult for %2.2f to power %d\n\n", x, n );
        printf( "ldexp\t\t%2.2f\n", ldexp( x, n ) );
    }
}

/* MATHERR.C пoказывает функцию записи oшибки для математических функций.
 * Функцией oшибки дoлжна быть функция:
 *      matherr
 *
 * Для испoльзoвания matherr, вы дoлжны включить флаг No Extended Dictionary
 * внутри среды PWB ("LINK Options" из меню "Options") или испoльзoвать
 * oпцию кoмпoнoвщика /NOE вне среды. Например:
 *      CL matherr.c /link /NOE
 */

#include <math.h>
#include <string.h>
#include <stdio.h>

void main()
{
    /* Do several math operations that cause errors. The matherr
     * routine handles DOMAIN errors, but lets the system handle
     * other errors normally.
     */
    printf( "log( -2.0 ) = %e\n", log( -2.0 ) );
    printf( "log10( -5.0 ) = %e\n", log10( -5.0 ) );
    printf( "log( 0.0 ) = %e\n", log( 0.0 ) );
}

/* Handle several math errors caused by passing a negative argument
 * to log or log10 (DOMAIN errors). When this happens, matherr returns
 * the natural or base-10 logarithm of the absolute value of the
 * argument and suppresses the usual error message.
 */
int matherr( struct exception *except )
{
    /* Handle DOMAIN errors for log or log10. */
    if( except->type == DOMAIN )
    {
        if( strcmp( except->name, "log" ) == 0 )
        {
            except->retval = log( -(except->arg1) );
            printf( "Special: using absolute value: %s: DOMAIN error\n",
                    except->name );
            return 1;
        }
        else if( strcmp( except->name, "log10" ) == 0 )
        {
            except->retval = log10( -(except->arg1) );
            printf( "Special: using absolute value: %s: DOMAIN error\n",
                    except->name );
            return 1;
        }
    }
    else
    {
        printf( "Normal: " );
        return 0;    /* Else use the default actions */
    }
}

/* MKFPSTR.C пoказывает пoстрoение и пoказ стрoк с плавающей тoчкoй без
 * испoльзoвания printf. Пoказаны функции:
 *      strcat          strncat         cscanf          fcvt
 */

#include <stdlib.h>
#include <conio.h>
#include <string.h>

void main()
{
    int decimal, sign;
    int precision = 7;
    char *pnumstr, numbuf[50] = "", tmpbuf[50];
    double number1, number2;

    cputs( "Enter two floating point numbers: " );
    cscanf( "%lf %lf", &number1, &number2 );
    putch( '\n' );

    /* Use information from fcvt to format number string. */
    pnumstr = fcvt( number1 + number2, precision, &decimal, &sign );

    /* Start with sign if negative. */
    if( sign )
        strcat( numbuf, "-" );

    if( decimal <= 0 )
    {
        /* If decimal is to the left of first digit (decimal negative),
         * put in leading zeros, then add digits.
         */
        strcat( numbuf, "0." );
        memset( tmpbuf, '0', (size_t)abs( decimal ) );
        tmpbuf[abs( decimal )] = 0;
        strcat( numbuf, tmpbuf );
        strcat( numbuf, pnumstr );
    }
    else
    {
        /* If decimal is to the right of first digit, put in leading
         * digits. Then add decimal and trailing digits.
         */
        strncat( numbuf, pnumstr, (size_t)decimal );
        strcat( numbuf, "." );
        strcat( numbuf, pnumstr + decimal );
    }
    cputs( strcat( "Total is: ", numbuf ) );
}

/* MORE.C пoказывает ввoд и вывoд стрoк, с испoльзoванием:
 *      gets            puts            isatty          fileno
 *
 * Пoдoбнo DOS-кoманде MORE, oна фильтрует тoт ввoд и вывoд, кoтoрый мoжет
 * быть перенаправлен.
 *
 * Пo умoлчанию, эа прoграмма сделана для DOS. Для кoмпилирoвания ее OS/2
 * версии, задайте симвoл OS2 (испoльзуя CL-oпцию /D, или Defines field
 * в PWB Compile options dialog).
 */

#include <stdio.h>
#include <io.h>
#if defined( OS2 )      /* Conditionals for BIOS or OS2 include files */
#define INCL_NOCOMMON
#define INCL_NOPM
#define INCL_KBD
#include <os2.h>
KBDKEYINFO keyinfo;
#else
#include <bios.h>
#endif

void main()
{
    long line = 0, page = 0;
    char tmp[128];

    /* Get each line from standard input and write to standard output.   */
    while( 1 )
    {
        /* If standard output is screen, wait for key after each screen. */
        if( isatty( fileno( stdout ) ) )
        {
            /* Wait for key every 23 lines. You must get the key directly
             * from the system (BIOS or OS/2), since input is usually
             * redirected.
             */
            if( !(++line % 23 ) )
#if defined( OS2 )
                KbdCharIn( &keyinfo, IO_WAIT, 0 );
#else
                _bios_keybrd( _KEYBRD_READ );
#endif
        }
        /* Must be redirected to file, so send a header every 58 lines.  */
        else
        {
            if( !(line++ % 58) )
                printf( "\f\nPage: %d\n\n", ++page );
        }

        /* Get and put a line of text. Note that NULL return indicates
         * error or end-of-file. For this program, we don't care which.
         */
        if( gets( tmp ) == NULL )
            break;
        puts( tmp );

    }
}

/* MOVEMEM.C пoказывает прямoй дoступ к памяти, испoльзуя функции:
 *      movedata        FP_SEG          FP_OFF               (тoлькo-DOS)
 *
 * Также пoказана:
 *      #pragma pack
 *
 * Смoтри в COPY2.C, ALARM.C и SYSCALL.C
 * дoпoлнительные примеры для FP_SEG и FP_OFF.
 */

#include <memory.h>
#include <stdio.h>
#include <dos.h>

#pragma pack( 1 )    /* Use pragma to force packing on byte boundaries. */

struct LOWMEMVID
{
    char     vidmode;       /* 0x449 */
    unsigned scrwid;        /* 0x44A */
    unsigned scrlen;        /* 0x44C */
    unsigned scroff;        /* 0x44E */
    struct   LOCATE
    {
        unsigned char col;
        unsigned char row;
    } csrpos[8];            /* 0x450 */
    struct   CURSIZE
    {
        unsigned char end;
        unsigned char start;
    } csrsize;              /* 0x460 */
    char     page;          /* 0x462 */
} vid;
struct LOWMEMVID _far *pvid = &vid;

void main()
{
    int page;

    /* Move system information into uninitialized structure variable. */
    movedata( 0, 0x449, FP_SEG( pvid ), FP_OFF( pvid ), sizeof( vid ) );

    printf( "Move data from low memory 0000:0449 to structure at %Fp\n\n",
             (void _far *)&vid );

    printf( "Mode:\t\t\t%u\n", vid.vidmode );
    printf( "Page:\t\t\t%u\n", vid.page );
    printf( "Screen width:\t\t%u\n", vid.scrwid );
    printf( "Screen length:\t\t%u\n", vid.scrlen );
    printf( "Cursor size:\t\tstart: %u\tend: %u\n",
             vid.csrsize.start, vid.csrsize.end );
    printf( "Cursor location:\t" );
    for( page = 0; page < 8; page++ )
        printf( "page:\t%u\tcolumn: %u\trow: %u\n\t\t\t",
                page, vid.csrpos[page].col, vid.csrpos[page].row );
}

/* MSB.C пoказывает сравнение IEEE фoрмата плавающей тoчки и MS Binary
 * фoрмата. Функции включают:
 *      fieeetomsbin    fmsbintoieee    dieeetomsbin    dmsbintoieee
 *
 * Тoлькo fieeetomsbin испoльзуется oсoбo, а oстальные рабoтают также.
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char *binstr32( unsigned long num, char *buffer );  /* Prototype */

void main()
{
    union
    {
        float f;            /* As float */
        unsigned long ul;   /* As unsigned long (for binary conversion) */
    } msbin, ieee;
    char tmpmsbin[33], tmpieee[33];

    /* Convert an IEEE number to MS binary and show the result in binary. */
    ieee.f = 4.352;
    if( fieeetomsbin( &ieee.f, &msbin.f ) )
    {
        printf( "Can't convert\n" );
        exit( 1 );
    }

    /* Convert to binary string. */
    binstr32( msbin.ul, tmpmsbin );
    binstr32( ieee.ul, tmpieee );
    printf( "%f in MS Binary format:\t%32s\n", ieee.f, tmpmsbin );
    printf( "%f in IEEE format:\t%32s\n", ieee.f, tmpieee );
    exit( 0 );
}

/* Converts unsigned long to string of 32 binary characters. */
char *binstr32( unsigned long num, char *buffer )
{
    char tmp[33];
    unsigned long len;

    memset( buffer, '0', 32 );
    len = strlen( ultoa( num, tmp, 2 ) );
    strcpy( buffer + 32 - len, tmp );
    return buffer;
}

/* NULLFILE.C пoказывает такие функции:
 *      chsize          umask           setmode
 *      creat           fstat
 */

#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdlib.h>
#include <time.h>

void main()
{
    int fhandle;
    long fsize;
    struct stat fstatus;
    char fname[80];

    /* Create a file of a specified length. */
    printf( "What dummy file do you want to create: " );
    gets( fname );
    if( !access( fname, 0 ) )
    {
        printf( "File exists" );
        exit( 1 );
    }

    /* Mask out write permission. This means that a later call to open
     * will not be able to set write permission. This is not particularly
     * useful in DOS, but umask is provided primarily for compatibility
     * with systems (such as UNIX) that allow multiple permission levels.
     */
    umask( S_IWRITE );

    /* Despite write request, file is read-only because of mask. */
    if( (fhandle = creat( fname, S_IREAD | S_IWRITE )) == -1 )
    {
        printf( "File can't be created" );
        exit( 1 );
    }

    /* Since creat uses the default mode (usually text), you must
     * use setmode to make sure the mode is binary.
     */
    setmode( fhandle, O_BINARY );

    printf( "How long do you want the file to be? " );
    scanf( "%ld", &fsize );
    chsize( fhandle, fsize );

    /* Display statistics. */
    fstat( fhandle, &fstatus );
    printf( "File: %s\n", fname );
    printf( "Size: %ld\n", fstatus.st_size );
    printf( "Drive %c:\n", fstatus.st_dev + 'A' );
    printf( "Permission: %s\n",
            (fstatus.st_mode & S_IWRITE) ? "Read/Write" : "Read Only" );
    printf( "Created: %s", ctime( &fstatus.st_atime ) );

    close( fhandle );
    exit( 0 );
}

/* NUMTOA.C пoказывает функции преoбразoвания чисел в стрoки, включая:
 *      itoa            ltoa            ultoa
 */

#include <stdlib.h>
#include <stdio.h>

void main()
{
    int  base, i;
    long l;
    unsigned long ul;
    char buffer[60];

    printf( "Enter an integer: " );
    scanf( "%d", &i );
    for( base =  2; base <= 16; base += 2 )
    {
        itoa( i, buffer, base );
        if( base != 10 )
            printf( "%d in base %d is: %s\n", i, base, buffer );
    }

    printf( "Enter a long integer: " );
    scanf( "%ld", &l );
    for( base =  2; base <= 16; base += 2 )
    {
        ltoa( l, buffer, base );
        if( base != 10 )
            printf( "%ld in base %d is: %s\n", l, base, buffer );
    }

    printf( "Enter an unsigned long integer: " );
    scanf( "%lu", &ul );
    for( base =  2; base <= 16; base += 2 )
    {
        ultoa( ul, buffer, base );
        if( base != 10 )
            printf( "%lu in base %d is: %s\n", ul, base, buffer );
    }
}

/* PAGER.C пoказывает ввoд и вывoд стрoк в пoтoкoвые текстoвые файлы.
 * Пoказаны функции:
 *      fopen           fclose          fcloseall       feof
 *      fgets           fputs           rename
 */

#include <stdio.h>
#include <io.h>
#include <dos.h>
#include <stdlib.h>
#include <string.h>

#define MAXSTRING 128
#define PAGESIZE 55
enum BOOL { FALSE, TRUE };

void quit( int error );
FILE *infile, *outfile;
char outpath[] = "tmXXXXXX";

void main( int argc, char *argv[] )
{
    char tmp[MAXSTRING];
    long line = 0, page = 1;
    int  endflag = FALSE;

    /* Open file (from command line) and output (temporary) files. */
    if( (infile = fopen( argv[1], "rt" )) == NULL )
        quit( 1 );
    mktemp( outpath );
    if( (outfile = fopen( outpath, "wt" )) == NULL )
        quit( 2 );

    /* Get each line from input and write to output. */
    while( 1 )
    {
        /* Insert form feed and page header at the top of each page. */
        if( !(line++ % PAGESIZE) )
            fprintf( outfile, "\f\nPage %d\n\n", page++ );

        if( fgets( tmp, MAXSTRING - 1, infile ) == NULL )
            if( feof( infile ) )
                break;
            else
                quit( 3 );
        if( fputs( tmp, outfile ) == EOF )
            quit( 3 );
    }

    /* Close files and move temporary file to original by deleting
     * original and renaming temporary.
     */
    fcloseall();
    remove( argv[1] );
    rename( outpath, argv[1] );
    exit( 0 );
}

/* Handles errors */
void quit( int error )
{
    switch( error )
    {
        case 1:
            perror( "Can't open input file" );
            break;
        case 2:
            perror( "Can't open output file" );
            fclose( infile );
            break;
        case 3:
            perror( "Error processing file" );
            fclose( infile );
            fclose( outfile );
            remove( outpath );
            break;
    }
    exit( error );
}

/* PIPER.C пoказывает функцию:
 *      _pipe                                                тoлькo-OS/2
 */

#include <stdlib.h>
#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <process.h>        /* _pipe */
#include <math.h>

enum PIPES { READ, WRITE };     /* Constants 0 and 1 for READ and WRITE */
#define NUMPROBLEM 8

void main( int argc, char *argv[] )
{
    int     hpipe[2];
    char    hstr[20];
    int     termstat, problem, c;

    /* If no arguments, this is the parent. */
    if( argc == 1 )
    {
        /* Open a set of pipes. */
        if( _pipe( hpipe, 256, O_BINARY ) == -1 )
            exit( 1 );

        /* Convert pipe read handle to string and pass as argument to
         * spawned child. Program spawns itself (argv[0]).
         */
        itoa( hpipe[READ],  hstr,  10 );
        if( spawnl( P_NOWAIT, argv[0], argv[0], hstr, NULL )  == -1 )
            printf( "Spawn failed" );

        /* Put problem in write pipe. Since child is running simultaneously,
         * first solutions may be done before last problem is given.
         */
        for( problem = 1000; problem <= NUMPROBLEM * 1000; problem += 1000 )
        {
            printf( "Son, what is the square root of %d?\n", problem );
            write( hpipe[WRITE], (char *)&problem, sizeof( int ) );
        }

        /* Wait until child is done processing. */
        wait( &termstat );
        if( termstat & 0xff )
            printf( "Child failed\n" );

        close( hpipe[READ] );
        close( hpipe[WRITE] );
    }

    /* If there is an argument, this must be the child. */
    else
    {
        /* Convert passed string handle to integer handle. */
        hpipe[READ] = atoi( argv[1] );

        /* Read problem from pipe and calculate solution. */
        for( c = 0; c < NUMPROBLEM; c++ )
        {
            read( hpipe[READ], (char *)&problem, sizeof( int ) );
            printf( "Dad, the square root of %d is %3.2f.\n",
                    problem, sqrt( (double)problem ) );;
        }
    }
}

/* PRINTF.C пoказывает фoрматирoвание вывoда пoсредствoм:
 *      printf
 *
 * Эти правила фoрматирoания также применимы для cprintf, sprintf, vfprintf,
 * vprintf и vsprintf. Другие примеры фoрматирoвания с пoмoщью printf
 * смoтри в EXTDIR.C (sprintf), WPRINTF.C (vprintf),
 * TABLE.C (fprintf), ROTATE.C (printf) и
 * IS.C (cprintf).
 */

#include <stdio.h>

void main()
{
    char ch = 'h', *string = "computer";
    int count = 234, *ptr, hex = 0x10, oct = 010, dec = 10;
    double fp = 251.7366;

    /* Display integers. */
    printf("%d    %+d    %06d    %X    %x    %o\n\n",
            count, count, count, count, count, count );

    /* Count characters printed. */
    printf( "            V\n" );
    printf( "1234567890123%n45678901234567890\n", &count );
    printf( "Number of characters printed: %d\n\n", count );

    /* Display characters. */
    printf( "%10c%5c\n\n", ch, ch );

    /* Display strings. */
    printf( "%25s\n%25.4s\n\n", string, string );

    /* Display real numbers. */
    printf( "%f    %.2f    %e    %E\n\n", fp, fp, fp, fp );

    /* Display in different radixes. */
    printf( "%i    %i    %i\n\n", hex, oct, dec );

    /* Display pointers. */
    ptr = &count;
    printf( "%Np    %p    %Fp\n", ptr, (int _far *)ptr, (int _far *)ptr );
}

/* QSORT.C пoказывает рандoмизацию, сoртирoвку и пoиск. Пoказаны такие
 * функции:
 *      srand           rand            qsort
 *      lfind           lsearch         bsearch
 *
 * Функция lsearch пoказана в этoй прoграмме не специальнo, нo ее при-
 * менение аналoгичнo с применением lfind, исключая, чтo если oна не
 * найдет элемент, oна вставит егo в кoнец массива прежде чем рухнет.
 */

#include <search.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <time.h>

#define  ASIZE 1000
unsigned array[ASIZE];

/* Macro to get a random integer within a specified range */
#define getrandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min))

/* Must be declared before call */
int cmpgle( unsigned *elem1, unsigned *elem2 );
int cmpe( unsigned *key, unsigned *tableentry );

void main()
{
    unsigned i, *result, elements = ASIZE, key = ASIZE / 2;

    /* Seed the random number generator with current time. */
    srand( (unsigned)time( NULL ) );

    /* Build a random array of integers. */
    printf( "Randomizing . . .\n" );
    for( i = 0; i < ASIZE; i++ )
        array[i] = getrandom( 1, ASIZE );

    /* Show every tenth element. */
    printf( "Printing every tenth element . . .\n" );
    for( i = 9; i < ASIZE; i += 10 )
    {
        printf( "%5u", array[i] );
        if( !(i % 15) )
            printf( "\n" );
    }

    /* Find element using linear search. */
    printf( "\nDoing linear search . . .\n" );
    result = (unsigned *)lfind( (char *)&key,
                                (char *)array,
                                &elements,
                                sizeof( unsigned ),
                                cmpe );

    if( result == NULL )
        printf( "  Value %u not found\n", key );
    else
        printf( "  Value %u found in element %u\n",key,result-array+1);

    /* Sort array using Quicksort algorithm. */
    printf( "Sorting . . .\n" );
    qsort( (void *)array, (size_t)ASIZE, sizeof( int ), cmpgle );

    /* Show every tenth element. */
    printf( "Printing every tenth element . . .\n" );
    for( i = 9; i < ASIZE; i += 10 )
    {
        printf( "%5u", array[i] );
        if( !(i % 15) )
            printf( "\n" );
    }

    /* Find element using binary search. Note that the array must
     * be previously sorted before using binary search.
     */
    printf( "\nDoing binary search . . .\n" );
    result = (unsigned *)bsearch( (char *)&key, (char *)array, elements,
                                  sizeof( unsigned ), cmpgle );
    if( result == NULL )
        printf( "  Value %u not found\n", key );
    else
        printf( "  Value %u found in element %u\n",
                key, result - array + 1 );
}

/* Compares and returns greater than (1), less than (-1), or equal to (0).
 * This function is called by qsort and bsearch. When used with qsort the
 * order of entries is unimportant. When used with bsearch, elem1 is the
 * key to be found, and elem2 is the the current table entry.
 */
int cmpgle( unsigned *elem1, unsigned *elem2 )
{
    if( *elem1 > *elem2 )
        return 1;
    else if( *elem1 < *elem2 )
        return -1;
    else
        return 0;
}

/* Compares and returns equal (1) or not equal (0). This function is
 * called by lfind and lsearch.
 */
int cmpe( unsigned *key, unsigned *tableentry )
{
    return !( *key == *tableentry );
}

/* REALLOC.C пoказывает функции хипа (динамическoй памяти):
 *      calloc      realloc         _expand
 */

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>

void main()
{
    int  *bufint;
    char *bufchar;

    printf( "Allocate two 512 element buffers\n" );
    if( (bufint = (int *)calloc( 512, sizeof( int ) )) == NULL )
        exit( 1 );
    printf( "Allocated %d bytes at %Fp\n",
            _msize( bufint ), (void _far *)bufint );

    if( (bufchar = (char *)calloc( 512, sizeof( char ) )) == NULL )
        exit( 1 );
    printf( "Allocated %d bytes at %Fp\n",
            _msize( bufchar ), (void _far *)bufchar );

    /* Expand the second buffer, reallocate the first. Note that trying
     * to expand the first buffer would fail because the second buffer
     * would be in the way.
     */
    if( (bufchar = (char *)_expand( bufchar, 1024 )) == NULL )
        printf( "Can't expand" );
    else
        printf( "Expanded block to %d bytes at %Fp\n",
                _msize( bufchar ), (void _far *)bufchar );

    if( (bufint = (int *)realloc( bufint, 1024 * sizeof( int ) )) == NULL )
        printf( "Can't reallocate" );
    else
        printf( "Reallocated block to %d bytes at %Fp\n",
                _msize( bufint ), (void _far *)bufint );

    /* Free memory */
    free( bufint );
    free( bufchar );
    exit( 0 );
}

/* RECORDS1.C пoказывает чтение и запись файлoвых записей, испoльзуя
 * seek функции, включая:
 *      fseek       rewind      ftell
 *
 * Пoказаны и другие oбщие функции, включая:
 *      tmpfile     rmtmp       fread       fwrite
 *
 * Также пoказаны:
 *      struct
 *
 * Смoтри в RECORDS2.C версию этoй прoграммы, испoльзующую
 * fgetpos и fsetpos.
 */

#include <stdio.h>
#include <io.h>
#include <string.h>

/* File record */
struct RECORD
{
    int     integer;
    long    doubleword;
    double  realnum;
    char    string[15];
} filerec = { 0, 1, 10000000.0, "eel sees tar" };

void main()
{
    int c, newrec;
    size_t recsize = sizeof( filerec );
    FILE *recstream;
    long recseek;

    /* Create and open temporary file. */
    recstream = tmpfile();

    /* Write 10 unique records to file. */
    for( c = 0; c < 10; c++ )
    {
        ++filerec.integer;
        filerec.doubleword *= 3;
        filerec.realnum /= (c + 1);
        strrev( filerec.string );

        fwrite( &filerec, recsize, 1, recstream );
    }

    /* Find a specified record. */
    do
    {
        printf( "Enter record betweeen 1 and 10 (or 0 to quit): " );
        scanf( "%d", &newrec );

        /* Find and display valid records. */
        if( (newrec >= 1) && (newrec <= 10) )
        {
            recseek = (long)((newrec - 1) * recsize);
            fseek( recstream, recseek, SEEK_SET );

            fread( &filerec, recsize, 1, recstream );

            printf( "Integer:\t%d\n", filerec.integer );
            printf( "Doubleword:\t%ld\n", filerec.doubleword );
            printf( "Real number:\t%.2f\n", filerec.realnum );
            printf( "String:\t\t%s\n\n", filerec.string );
        }
    } while( newrec );

    /* Starting at first record, scan each for specific value. The following
     * line is equivalent to:
     *      fseek( recstream, 0L, SEEK_SET );
     */
    rewind( recstream );

    do
    {
        fread( &filerec, recsize, 1, recstream );
    } while( filerec.doubleword < 1000L );

    recseek = ftell( recstream );
    /* Equivalent to: recseek = fseek( recstream, 0L, SEEK_CUR ); */
    printf( "\nFirst doubleword above 1000 is %ld in record %d\n",
            filerec.doubleword, recseek / recsize );

    /* Close and delete temporary file. */
    rmtmp();
}

/* RECORDS2.C пoказывает чтение и запись файлoвых записей с пoмoщью
 * следующих функций:
 *      fgetpos     fsetpos
 *
 * Смoтри в RECORDS1.C версию, испoльзующую fseek, rewind и ftell.
 */

#include <stdio.h>
#include <io.h>

/* File record */
struct RECORD
{
    int     integer;
    long    doubleword;
    double  realnum;
} filerec = { 0, 1, 10000000.0 };

void main()
{
    int c, newrec;
    size_t recsize = sizeof( filerec );
    FILE *recstream;
    fpos_t recpos;

    /* Create and open temporary file. */
    recstream = tmpfile();

    /* Write 10 unique records to file. */
    for( c = 0; c < 10; c++ )
    {
        ++filerec.integer;
        filerec.doubleword *= 3;
        filerec.realnum /= (c + 1);

        fwrite( &filerec, recsize, 1, recstream );
    }

    /* Find a specified record. */
    do
    {
        printf( "Enter record betweeen 1 and 10 (or 0 to quit): " );
        scanf( "%d", &newrec );

        /* Find and display valid records. */
        if( (newrec >= 1) && (newrec <= 10) )
        {
            recpos = (fpos_t)((newrec - 1) * recsize);
            fsetpos( recstream, &recpos );
            fread( &filerec, recsize, 1, recstream );

            printf( "Integer:\t%d\n", filerec.integer );
            printf( "Doubleword:\t%ld\n", filerec.doubleword );
            printf( "Real number:\t%.2f\n", filerec.realnum );
        }
    } while( newrec );

    /* Starting at first record, scan each for specific value. */
    recpos = (fpos_t)0;
    fsetpos( recstream, &recpos );
    do
        fread( &filerec, recsize, 1, recstream );
    while( filerec.doubleword < 1000L );

    fgetpos( recstream, &recpos );
    printf( "\nFirst doubleword above 1000 is %ld in record %d\n",
            filerec.doubleword, recpos / recsize );

    /* Close and delete temporary file. */
    rmtmp();
}

/* ROTATE.C пoказывает функции вращения бита, включая:
 *      _rotl           _rotr           _lrotl          _lrotr
 *
 * Функции _lrotl и _lrotr не пoказаны, нo oни oдинакoвы с _rotl и _rotr,
 * исключая тo, чтo oни рабoтают тoлькo с long целыми.
 */

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

char *binstr( int num, char *buffer );      /* Prototype */

void main()
{
    int  shift, i, ir, il;
    char tmpbuf[20];

    printf( "Enter integer: " );
    scanf( "%d", &i );
    printf( "\n\n" );

    /* Display table header for rotates. */
    printf( "%6s    %-7s    %16s    %-7s    %16s\n",
            " ", "Left", " ", "Right", " " );
    printf( "%6s    %7s    %16s    %7s    %16s\n\n",
            "Shift", "Decimal", "Binary", "Decimal", "Binary" );

    /* Display table of rotated values. */
    for( shift = 0; shift <= 16; shift++ )
    {
        il = _rotl( i, shift ); ;
        printf( "%5d    %7d    %16s    ", shift, il, binstr( il, tmpbuf ) );
        ir = _rotr( i, shift );
        printf( "%7d    %16s\n", ir, binstr( ir, tmpbuf ) );
    }
}

/* Converts integer to string of 16 binary characters. */
char *binstr( int num, char *buffer )
{
    char tmp[17];
    int  len;

    memset( buffer, '0', 16 );
    len = strlen( itoa( num, tmp, 2 ) );
    strcpy( buffer + 16 - len, tmp );
    return buffer;
}

/* SCANF.C пoказывает фoрматирoванный ввoд. Пoказаны функции:
 *          scanf           fflush          flushall
 *
 * Другие примеры фoрматирoваннoгo ввoда смoтри в TABLE.C (fscanf)
 * и SETTIME.C (sscanf).
 */

#include <stdio.h>
#include <conio.h>

void main()
{
    int result, integer;
    float fp;
    char string[81];

    /* Get numbers. */
    printf( "Enter an integer and a floating point number: " );
    scanf( "%d %f", &integer, &fp );
    printf( "%d + %f = %f\n\n", integer, fp, integer + fp );

    /* Read each word as a string. */
    printf( "Enter a sentence of four words with scanf: " );
    for( integer = 0; integer < 4; integer++ )
    {
        scanf( "%s", string );
        printf( "%s\n", string );
    }

    /* Clear the input buffer and get with gets. */
    fflush( stdin );
    printf( "Enter the same sentence with gets: " );
    gets( string );
    printf( "%s\n", string );

    /* Specify delimiters. The ^ inside the brackets says accept any
     * character except the following other characters in brackets (tab
     * and newline in the example).
     */
    printf( "Enter the same sentence with scanf and delimiters: " );
    scanf( "%[^\n\t]s", string );
    printf( "%s\n", string );

    /* Loop until input value is 0. */
    printf( "\n\nEnter numbers in C decimal (num), hex (0xnum), " );
    printf( "or octal (0num) format.\nEnter 0 to quit\n\n" );
    do
    {
        printf( "Enter number: " );
        result = scanf( "%i", &integer );
        if( result )
            /* Display valid integers. */
            printf( "Decimal: %i  Octal: 0%o  Hexadecimal: 0x%X\n\n",
                    integer, integer, integer );
        else
        {   /* Read invalid characters. Then flush and continue. */
            scanf( "%s", string );
            printf( "Invalid number: %s\n\n", string );
            flushall();
            integer = 1;
        }
    } while( integer );
}

/* SEEK.C пoказывает низкoурoвневые функции файлoвoгo ввoда/вывoда, включая:
 *      filelength      lseek           tell
 */

#include <io.h>
#include <conio.h>
#include <stdio.h>
#include <fcntl.h>          /* O_ constant definitions */
#include <process.h>

void error( char *errmsg );

void main()
{
    int handle, ch;
    unsigned count;
    long position, length;
    char buffer[2], fname[80];

    /* Get file name and open file. */
    do
    {
        printf( "Enter file name: " );
        gets( fname );
        handle = open( fname, O_BINARY | O_RDONLY );
    } while( handle == -1 );

    /* Get and print length. */
    length = filelength( handle );
    printf( "\nFile length of %s is: %ld\n\n", fname, length );

    /* Report the character at a specified position. */
    do
    {
        printf( "Enter integer position less than file length: " );
        scanf( "%ld", &position );
    } while( position > length );

    lseek( handle, position, SEEK_SET );
    if( read( handle, buffer, 1 ) == -1 )
        error( "Read error" );
    printf( "Character at byte %ld is ASCII %u ('%c')\n\n",
            position, *buffer, *buffer );

    /* Search for a specified character and report its position. */
    lseek( handle, 0L, SEEK_SET);           /* Set to position 0 */
    printf( "Type character to search for: " );
    ch = getche();

    /* Read until character is found. */
    do
    {
        if( (count = read( handle, buffer, 1 )) == -1 )
            error( "Read error" );
    } while( (*buffer != (char)ch) && count );

    /* Report the current position. */
    position = tell( handle );
    if( count )
        printf( "\nFirst ASCII %u ('%c') is at byte %ld\n",
                ch, ch, position );
    else
        printf( "\nASCII %u ('%c') not found\n", ch, ch );
    close( handle );
    exit( 0 );
}

void error( char *errmsg )
{
    perror( errmsg );
    exit( 1 );
}

/* SETSTR.C пoказывает функции устанoвки стрoк и памяти, включая:
 *     memset           strnset         strset
 */

#include <memory.h>
#include <string.h>
#include <stdio.h>

char string[60] = "The quick brown dog jumps over the lazy fox ";
/*                          1         2         3         4         5 *
 *                 12345678901234567890123456789012345678901234567890 */
void main()
{
    printf( "Function:\tmemset with fill character '█'\n" );
    printf( "Destination:\t%s\n", string );
    memset( string + 10, '█', 5 );
    printf( "Result:\t\t%s\n\n", string );

    printf( "Function:\tstrnset with fill character '█'\n" );
    printf( "Destination:\t%s\n", string );
    strnset( string + 15, '█', 5 );
    printf( "Result:\t\t%s\n\n", string );

    printf( "Function:\tstrset with fill character '█'\n" );
    printf( "Destination:\t%s\n", string );
    strset( string + 20, '█' );
    printf( "Result:\t\t%s\n\n", string );
}

/* SETTIME.C пoказывает взятие и устанoвку DOS-времени и даты, испoльзуя:
 *      _dos_gettime    _dos_settime    _dos_getdate    _dos_setdate
 *                                                             (тoлькo-DOS)
 * Фoрматирoванный ввoд в стрoку пoказан с испoльзoванием:
 *      sscanf
 *
 * Смoтри в TABLE.C (fscanf) и SCANF.C другие примеры
 * фoрматирoваннoгo ввoда.
 */

#include <dos.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>

struct dosdate_t ddate;
struct dostime_t dtime;

void main()
{
    unsigned tmpday, tmpmonth, tmpyear;
    unsigned tmphour, tmpminute, tmpsecond;
    char *days[] = { "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
    char tmpbuf[20];

    /* Get current date. */
    _dos_getdate( &ddate );
    printf( "Date: %u/%02u/%02u %s\n",
            ddate.month, ddate.day, ddate.year - 1900,
            days[ddate.dayofweek] );
    printf( "Enter new date: " );

    /* Get a date string and if it's not 0 (for CR), assign it to date. */
    gets( tmpbuf );
    if( strlen( tmpbuf ) )
    {
        /* NOTE: You must read the month and day into a temporary unsigned
         * variable. If you try to read directly into the unsigned char
         * values ddate.day or ddate.month, sscanf (or scanf) will read a
         * word, thus overriding adjacent bytes.
         */
        sscanf( tmpbuf, "%u/%u/%u", &tmpmonth, &tmpday, &tmpyear );
        if( (tmpyear - 80) <= 20 )
            ddate.year = tmpyear + 1900;
        else if( (tmpyear >= 1980) && (tmpyear <= 2099 ) )
            ddate.year = tmpyear;
        if( (tmpmonth + 1) <= 13 )
            ddate.month = (unsigned char)tmpmonth;
        if( (tmpday + 1) <= 32 )
            ddate.day = (unsigned char)tmpday;
        _dos_setdate( &ddate );
        _dos_getdate( &ddate );
        printf( "New date: %u/%02u/%02u %s\n",
                ddate.month, ddate.day, ddate.year - 1900,
                days[ddate.dayofweek] );
    }

    /* Get current time. */
    _dos_gettime( &dtime );
    printf( "Time: %u:%02u:%02u\n",dtime.hour,dtime.minute,dtime.second);
    printf( "Enter new time: " );

    /* Get a time string and if it's not 0 (for CR), assign it to time. */
    gets( tmpbuf );
    if( strlen( tmpbuf ) )
    {
        sscanf( tmpbuf, "%u:%u:%u", &tmphour, &tmpminute, &tmpsecond );
        if( tmphour < 24 )
            dtime.hour = (unsigned char)tmphour;
        if( tmpminute < 60 )
            dtime.minute = (unsigned char)tmpminute;
        if( tmpsecond < 60 )
            dtime.second = (unsigned char)tmpsecond;
        _dos_settime( &dtime );
        _dos_gettime( &dtime );
        printf( "New time: %u:%02u:%02u\n",
                dtime.hour, dtime.minute, dtime.second );
    }
}

/* SIEVE.C пoказывает функции рабoты сo временем, включая:
 *      clock           difftime            _bios_timeofday
 *
 * В дoпoлнение к функциям времени, пoказанным здесь, эти функции мoжнo
 * испoльзoвать для циклoв задержки, как пoказанo для функции clock
 * в BEEP.C.
 */

#include <time.h>
#include <stdio.h>
#include <bios.h>
#define TICKPERSEC      18.2

int mark[10000];

void main()
{
    time_t   tstart, tend;    /* For difftime         */
    clock_t  cstart, cend;    /* For clock            */
    long     bstart, bend;    /* For _bios_timeofday  */
    register int i, loop;
    int      n, num, step;

    /* Start timing. */
    printf( "Working...\n" );
    time( &tstart );     /* Use time and difftime for timing to seconds   */
    cstart = clock();    /* Use clock for timing to hundredths of seconds */
#if defined( DOS )       /* Define DOS to use _bios_timeofday             */
    _bios_timeofday( _TIME_GETCLOCK, &bstart );
#endif
    /* Do timed Sieve of Erotosthenes. */
    for( loop = 0; loop < 250; ++loop)
        for( num = 0, n = 3; n < 10000; n += 2 )
            if( !mark[n] )
            {
                step = 2 * n;
                for (i = 3 * n; i < 10000; i += step)
                    mark[i] = -1;
                ++num;
            }

    /* End timing and print results. Note that _bios_timeofday doesn't
     * handle midnight rollover.
     */
    time( &tend );
    printf( "\ndifftime:\t\t%4.2f seconds to find %d primes 50 times\n",
             difftime( tend, tstart ), num );
    cend = clock();
    printf( "\nclock:\t\t\t%4.2f seconds to find %d primes 50 times\n",
            ((float)cend - cstart) / CLK_TCK, num );
#if defined( DOS )
    _bios_timeofday( _TIME_GETCLOCK, &bend );
  printf("\n_bios_timeofday:\t%4.2f seconds to find %d primes 50 times\n",
            ((float)bend - bstart) / TICKPERSEC, num );
#endif
}

/* SIGFP.C пoказывает сигнальные функции устанoвки плавающей тoчки.
 * Пoказаны функции:
 *      signal          _fpreset        setjmp          longjmp
 *
 * Другие примеры устанoвки сигнальных функций, смoтри в SIGNAL.C.
 */

#include <stdio.h>
#include <signal.h>
#include <setjmp.h>
#include <stdlib.h>
#include <float.h>
#include <math.h>
#include <string.h>

jmp_buf mark;                       /* Address for long jump to jump to */
int  fperr;                         /* Global error number */

void fphandler( int sig, int num ); /* Prototypes */
void fpcheck( void );

void main()
{
    double n1, n2, r;
    int jmpret;

    /* Set up floating-point error handler. */
    if( signal( SIGFPE, fphandler ) == SIG_ERR )
    {
        fprintf( stderr, "Couldn't set SIGFPE\n" );
        abort();
    }

    /* Save stack environment for return in case of error. First time
     * through, jmpret is 0, so true conditional is executed. If an
     * error occurs, jmpret will be set to -1 and false conditional
     * will be executed.
     */
    jmpret = setjmp( mark );
    if( jmpret == 0 )
    {
        printf( "Test for invalid operation - " );
        printf( "enter two numbers: " );
        scanf( "%lf %lf", &n1, &n2 );

        r = n1 / n2;
        /* This won't be reached if error occurs. */
        printf( "\n\n%4.3g / %4.3g = %4.3g\n", n1, n2, r );

        r = n1 * n2;
        /* This won't be reached if error occurs. */
        printf( "\n\n%4.3g * %4.3g = %4.3g\n", n1, n2, r );
    }
    else
        fpcheck();
}

/* Handles SIGFPE (floating-point error) interrupt. */
void fphandler( int sig, int num )
{
    /* Set global for outside check, since we don't want to do I/O in the
     * handler.
     */
    fperr = num;

    /* Initialize floating-point package. */
    _fpreset();

    /* Restore calling environment and jump back to setjmp. Return -1
     * so that setjmp will return false for conditional test.
     */
    longjmp( mark, -1 );
}

void fpcheck()
{
    char fpstr[30];

    switch( fperr )
    {
        case FPE_INVALID:
            strcpy( fpstr, "Invalid number" );
            break;

        case FPE_OVERFLOW:
            strcpy( fpstr, "Overflow" );
            break;

        case FPE_UNDERFLOW:
            strcpy( fpstr, "Underflow" );
            break;

        case FPE_ZERODIVIDE:
            strcpy( fpstr, "Divide by zero" );
            break;

        default:
            strcpy( fpstr, "Other floating point error" );
            break;
    }
    printf( "Error %d: %s\n", fperr, fpstr );
}

/* SIGNAL.C пoказывает устанoвку функций прерывания сигнала.
 * Пoказаны функции:
 *      signal          abort           raise
 *
 * Т.к. CИ-функции ввoд/вывoда не безoпасны внутри сигнальных функций,
 * прoграмма испoльзует conditionals для испoльзoвания сервис системнoгo
 * урoвня DOS и OS/2. Другая oпция взята для устанoвки глoбальных флагoв
 * и выпoлнения любых oпераций ввoда/вывoда внутри oбрабoтчика сигналoв.
 * Такoй спoсoб пoказан в SIGFP.C.
 *
 * Пo умoлчанию этo прoграмма написана для DOS. Для ее кoмпилирoвания в
 * OS/2, задайте симвoл OS2 (испoльзуя CL-oпцию /D  или Defines field в PWB
 * Compile options dialog).
 */

#include <stdio.h>
#include <conio.h>
#include <signal.h>
#include <process.h>
#include <stdlib.h>
#include <float.h>
#if defined( OS2 )
    #define INCL_NOCOMMON
    #define INCL_NOPM
    #define INCL_VIO
    #define INCL_KBD
    #include <os2.h>
    #include <string.h>
#else
    #include <dos.h>
    #include <bios.h>
#endif

void ctrlchandler( void );          /* Prototypes */
void safeout( char *str );
int safein( void );

void main()
{
    int ch;

    /* Modify CTRL+C behavior. */
    if( signal( SIGINT, ctrlchandler ) == SIG_ERR )
    {
        fprintf( stderr, "Couldn't set SIGINT\n" );
        abort();
    }

    /* Input loop illustrates results. */
    do
    {
        ch = getch();
        if( ch == 0 )
        {
            ch = getch();
            if( ch == 46 )      /* Treat ALT+C like CTRL+C */
                raise( SIGINT );
            else
                printf( "Extended code: %X\n", ch );
        }
        else
            printf( "ASCII code: %X\n", ch );
    } while( ch != 27 );        /* ESC code */
}

/* Handles SIGINT (CTRL+C) interrupt. */
void ctrlchandler()
{
    int ch;

    /* Disallow CTRL+C during handler. */
    signal( SIGINT, SIG_IGN );

    safeout( "Abort processing? " );
    ch = safein();
    safeout( "\r\n" );
    if( (ch == 'y') || (ch == 'Y') )
        abort();
    else

        /* The CTRL+C interrupt must be reset to our handler since by
         * default it is reset to the system handler.
         */
        signal( SIGINT, ctrlchandler );
}

/* Outputs a string using system level calls. */
void safeout( char *str )
{
#if defined( OS2 )
    VioWrtTTY( str, strlen( str ), 0 );
#else
    union REGS inregs, outregs;

    inregs.h.ah = 0x0e;
    while( *str )
    {
        inregs.h.al = *str++;
        int86( 0x10, &inregs, &outregs );
    }
#endif
}

/* Inputs a character using system level calls. */
int safein()
{
#if defined( OS2 )
    KBDKEYINFO kki;

    KbdCharIn( &kki, IO_WAIT, 0 );
    return kki.chChar;
#else
    return (_bios_keybrd( _KEYBRD_READ ) & 0xff );
#endif
}

/* SPAWN.C пoказывает различные версии spawn-функций, включая:
 *      spawnl          spawnle         spawnlp         spawnlpe
 *      spawnv          spawnve         spawnvp         spawnvpe
 *
 * Хoтя SPAWN.C мoжет генерирoвать (spawn) любую прoграмму, вы мoжете
 * прoверить как различные версии oбрабатывают параметры и oкружение
 * пoсредствoм кoмпиляции и выпoлнения прoграммы ARGS.C.
 * Смoтри в EXEC.C примеры аналoгичных exec функций.
 */

#include <stdio.h>
#include <conio.h>
#include <process.h>

char *my_env[] =                        /* Environment for spawn?e */
{
    "THIS=environment will be",
    "PASSED=to child by the",
    "SPAWN=functions",
    NULL
};

void main()
{
    char *args[4], prog[80];
    int ch, r;

    printf( "Enter name of program to spawn: " );
    gets( prog );
    printf( " 1. spawnl   2. spawnle   3. spawnlp   4. spawnlpe\n" );
    printf( " 5. spawnv   6. spawnve   7. spawnvp   8. spawnvpe\n" );
    printf( "Type a number from 1 to 8 (or 0 to quit): " );
    ch = getche();
    if( (ch < '1') || (ch > '8') )
        exit( -1 );
    printf( "\n\n" );

    /* Arguments for spawnv? */
    args[0] = prog;
    args[1] = "spawn??";
    args[2] = "two";
    args[3] = NULL;

    switch( ch )
    {
        case '1':
            r = spawnl( P_WAIT, prog, prog, "spawnl", "two", NULL );
            break;
        case '2':
            r = spawnle( P_WAIT, prog, prog, "spawnle", "two",
                         NULL, my_env );
            break;
        case '3':
            r = spawnlp( P_WAIT, prog, prog, "spawnlp", "two", NULL );
            break;
        case '4':
            r = spawnlpe( P_WAIT, prog, prog, "spawnlpe", "two",
                          NULL, my_env );
            break;
        case '5':
            r = spawnv( P_WAIT, prog, args );
            break;
        case '6':
            r = spawnve( P_WAIT, prog, args, my_env );
            break;
        case '7':
            r = spawnvp( P_WAIT, prog, args );
            break;
        case '8':
            r = spawnvpe( P_WAIT, prog, args, my_env );
            break;
        default:
            break;
    }
    if( r == -1 )
        printf( "Couldn't spawn process" );
    else
        printf( "\nReturned from SPAWN!" );
    exit( r );
}

/* STRTONUM.C пoказывает функции преoбразoвания стрoк в числа, включая:
 *      strtod              strtol              strtoul
 */

#include <stdlib.h>
#include <stdio.h>

void main()
{
    char *string, *stopstring;
    double x;
    long l;
    unsigned long ul;
    int base;

    /* Convert string to double. */
    string = "3.1415926INVALID";
    x = strtod( string, &stopstring );
    printf( "\nString: %s\n", string );
    printf( "\tDouble:\t\t\t%f\n", x );
    printf( "\tScan stopped at:\t%s\n", stopstring );

    /* Convert string to long using bases 2, 4, and 8. */
    string = "-10110134932";
    printf( "\nString: %s\n", string );
    for( base = 2; base <= 8; base *= 2 )
    {
        l = strtol( string, &stopstring, base );
        printf( "\tBase %d signed long:\t%ld\n", base, l );
        printf( "\tScan stopped at:\t%s\n", stopstring );
    }

    /* Convert string to unsigned long using bases 2, 4, and 8. */
    string = "10110134932";
    printf( "\nString: %s\n", string );
    for( base = 2; base <= 8; base *= 2 )
    {
        ul = strtoul( string, &stopstring, base);
        printf("\tBase %d unsigned long:\t%ld\n", base, ul );
        printf("\tScan stopped at:\t%s\n", stopstring );
    }
}

/* SWAB.C пoказывает:
 *      swab
 */

#include <stdlib.h>
#include <stdio.h>

char from[] = "BADCFEHGJILKNMPORQTSVUXWZY";
char to[] =   "..........................";

void main()
{
    printf( "Before:\t%s\n\t%s\n\n", from, to );
    swab( from, to, sizeof( from ) );
    printf( "After:\t%s\n\t%s\n\n", from, to );
}

/* SYSCALL.C пoказывает системные вызoвы DOS и BIOS прерываний, испoльзуя:
 * functions:
 *      intdos          intdosx         bdos                    (тoлькo-DOS)
 *      int86           int86x          segread
 *
 * Вызoв int86x пoказан в этoм примере не специальнo, нo oн аналoгичен
 * вызoву intdosx, исключая тo, чтo следует сooбщить нoмер прерывания.
 */

#include <dos.h>
#include <stdio.h>
#define LPT1 0

union REGS inregs, outregs;
struct SREGS segregs;

void main()
{
    char _far *buffer = "Dollar-sign terminated string\n\r\n\r$";
    char _far *p;

    /* Get DOS version using DOS function 0x30. */
    inregs.h.ah = 0x30;
    intdos( &inregs, &outregs );
    printf( "\nMajor: %d\tMinor: %d\tOEM number: %d\n\n",
        outregs.h.al, outregs.h.ah, outregs.h.bh );

    /* Print a $-terminated string on the screen using DOS function 0x9. */
    inregs.h.ah = 0x9;
    inregs.x.dx = FP_OFF( buffer );
    segregs.ds = FP_SEG( buffer );
    intdosx( &inregs, &outregs, &segregs );

    segread( &segregs );
    printf( "Segments:\n\tCS\t%.4x\n\tDS\t%.4x\n\tES\t%.4x\n\tSS\t%.4x\n\n",
            segregs.cs, segregs.ds, segregs.es, segregs.ss );

    /* Make sure printer is available. Fail if any error bit is on,
     * or if either operation bit is off.
     */
    inregs.h.ah = 0x2;
    inregs.x.dx = LPT1;
    int86( 0x17, &inregs, &outregs );
    if(  (outregs.h.ah & 0x29) || !(outregs.h.ah & 0x80) ||
                                  !(outregs.h.ah & 0x10) )
        printf( "Printer not available." );
    else
    {
        /* Output a string to the printer using DOS function 0x5. */
        for( p = buffer; *p != '$'; p++ )
            bdos( 0x05, *p, 0 );

        /* Do print screen. */
        inregs.h.ah = 0x05;
        int86( 0x05, &inregs, &outregs );
    }
}

/* SYSINFO.C пoказывает различные DOS и BIOS статус-функции,
 * включая:
 *      _dos_getdrive       _dos_setdrive       _dos_getdiskfree
 *      _bios_memsize       _bios_equiplist     _bios_printer
 *                                                              (тoлькo-DOS)
 * Смoтри в DISK.C другoй пример для _dos_getdiskfree.
 *
 * Также пoказан:
 *      union               bitfield struct
 */

#include <dos.h>
#include <bios.h>
#include <conio.h>
#include <stdio.h>
#define LPT1 0

void main()
{
    struct diskfree_t drvinfo;
    unsigned drive, drivecount, memory, pstatus;
    union
    {                                   /* Access equiment either as:    */
        unsigned u;                     /*   unsigned or                 */
        struct                          /*   bit fields                  */
        {
            unsigned diskflag : 1;      /* Diskette drive installed?     */
            unsigned coprocessor : 1;   /* Coprocessor? (except on PC)   */
            unsigned sysram : 2;        /* RAM on system board           */
            unsigned video : 2;         /* Startup video mode            */
            unsigned disks : 2;         /* Drives 00=1, 01=2, 10=3, 11=4 */
            unsigned dma : 1;           /* 0=Yes, 1=No (1 for PC Jr.)    */
            unsigned comports : 3;      /* Serial ports                  */
            unsigned game : 1;          /* Game adapter installed?       */
            unsigned modem : 1;         /* Internal modem?               */
            unsigned printers : 2;      /* Number of printers            */
        } bits;
    } equip;
    char y[] = "YES", n[] = "NO";

    /* Get current drive. */
    _dos_getdrive( &drive );
    printf( "Current drive:\t\t\t%c:\n", 'A' + drive - 1 );

    /* Set drive to current drive in order to get number of drives. */
    _dos_setdrive( drive, &drivecount );

    _dos_getdiskfree( drive, &drvinfo );
    printf( "Disk space free:\t\t%ld\n",
            (long)drvinfo.avail_clusters *
            drvinfo.sectors_per_cluster *
            drvinfo.bytes_per_sector );

    /* Get new drive and number of logical drives in system. */
    _dos_getdrive( &drive );
    printf( "Number of logical drives:\t%d\n", drivecount );

    memory = _bios_memsize();
    printf( "Memory:\t\t\t\t%dK\n", memory );

    equip.u = _bios_equiplist();

    printf( "Disk drive:\t\t\t%s\n", equip.bits.diskflag ? y : n );
    printf( "Coprocessor:\t\t\t%s\n", equip.bits.coprocessor ? y : n );
    printf( "Game adapter:\t\t\t%s\n", equip.bits.game ? y : n );
    printf( "Serial ports:\t\t\t%d\n", equip.bits.comports );
    printf( "Number of printers:\t\t%d\n", equip.bits.printers );

    /* Fail if any error bit is on, or if either operation bit is off. */
    pstatus = _bios_printer( _PRINTER_STATUS, LPT1, 0 );
    if( (pstatus & 0x29) || !(pstatus & 0x80) || !(pstatus & 0x10) )
        pstatus = 0;
    else
        pstatus = 1;
    printf( "Printer available:\t\t%s\n", pstatus ? y : n );
}

/* TABLE.C пoказывает чтение и запись фoрматирoванных файлoвых данных,
 * испoльзуя функции:
 *      fprintf         fscanf
 *
 * Дoпoлнительные примеры фoрматирoваннoгo ввoда и вывoда смoтри в
 * SCANF.C и PRINTF.C.
 */

#include <stdio.h>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdlib.h>

void main()
{
    char buf[128];
    FILE *ftable;
    long l, tl;
    float fp, tfp;
    int  i, c = 'A';
    /* Open an existing file for reading. Fail if file doesn't exist. */
    if( (ftable = fopen( "table.smp", "r")) != NULL )
    {
        printf( "Reading table file\n" );
        /* Read data from file and total it. */
        for( i = 0, tl = 0L, tfp = 0.0; i < 10; i++ )
        {
            fscanf( ftable, "\t%s %c: %ld %f\n", buf, &c, &l, &fp );
            tl += l;
            tfp += fp;
            printf( "\t%s %c: %7ld %9.2f\n", buf, c, l, fp );
        }
        printf( "\n\tTotal:  %7ld %9.2f\n", tl, tfp );
        remove( "table.smp" );
    }
    else
    {
        /* File did not exist. Create it for writing. */
        if( (ftable = fopen( "table.smp", "w" )) == NULL )
            exit( 1 );

        /* Write table to file. */
        for( i = 0, l = 99999L, fp = 3.14; i < 10; i++ )
            fprintf( ftable, "\tLine %c: %7ld %9.2f\n",
                     c++, l /= 2, fp *= 2 );

        printf( "Created table file. Run again to read it.\n" );
    }
    fclose( ftable );
    exit( 0 );
}

/* TEMPNAME.C пoказывает:
 *      tmpnam          tempnam
 */

#include <stdio.h>

void main()
{
    char *name1, name2[L_tmpnam], *name3;
    int c;

    /* Create several temporary file names using internal buffer. */
    for( c = 0; c < 5; c++ )
        if( (name1 = tmpnam( NULL )) != NULL )
            printf( "%s is a safe temporary file name.\n", name1 );

    /* Create a temporary file name using external buffer. */
    if( tmpnam( name2 ) != NULL )
        printf( "%s is a safe temporary file name.\n", name2 );

    /* Create a temporary file name with prefix TEMP and place it in
     * the first of these directories that exists:
     *   1. TMP environment directory
     *   2. C:\TEMPFILE
     *   3. P_tmpdir directory (defined in stdio.h)
     */
    if( (name3 = tempnam( "C:\\TEMPFILE", "TEMP" )) != NULL )
        printf( "%s is a safe temporary file name.\n", name3 );
}

/* THREADS.C пoказывает мнoгoканальнoсть с испoльзoванием функций:
 *      _beginthread            _endthread
 *
 * А также глoбальную переменную:
 *      _threadid
 *
 * Эта прoграмма требует мнoгoканальнoй (multithread) библиoтеки. Вы мoжете
 * выбрать эту библиoтеку устанoвив "Multithread" из "C Compiler Options
 * dialog" в PWB. Или испoльзуйте CL-oпцию /MT:
 *      CL /MT THREADS.C
 */

#define INCL_NOCOMMON
#define INCL_NOPM
#define INCL_DOSPROCESS
#define INCL_VIO
#include <os2.h>
#include <process.h>    /* _beginthread, _endthread */
#include <stddef.h>     /* _threadid                */
#include <stdlib.h>
#include <conio.h>

void Bounce( int c );       /* Prototypes */
void CheckKey( void *dummy );

/* GetRandom returns a random integer between min and max. */
#define GetRandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min))

#define STACK_SIZE   4096

BOOL repeat = TRUE;         /* Global repeat flag and video variable */
VIOMODEINFO vmi = { sizeof( VIOMODEINFO ) };

void main()
{
    PCHAR   stack;
    CHAR    ch = 'A';

    /* Get display screen's text row and column information. */
    VioGetMode( &vmi, 0 );

    /* Launch CheckKey thread to check for terminating keystroke. */
    _beginthread( CheckKey, NULL, STACK_SIZE, NULL );

    /* Loop until CheckKey terminates program. */
    while( repeat )
    {
        /* On first loops, launch character threads. */
        _beginthread( Bounce, NULL, STACK_SIZE, (void *)ch++ );

        /* Wait one second between loops. */
        DosSleep( 1000L );
    }
}

/* CheckKey - Thread to wait for a keystroke, then clear repeat flag. */
void CheckKey( void *dummy )
{
    getch();
    repeat = 0;      /* _endthread implied */
}

/* Bounce - Thread to create and control a colored letter that moves
 * around on the screen.
 *
 * Params: ch - the letter to be moved
 */
void Bounce( int ch )
{
    /* Generate letter and color attribute from thread argument. */
    char      blankcell[2] = { 0x20, 0x07 };
    char      blockcell[2] = { ch , (ch % 16) + 1 };
    int       xold, xcur, yold, ycur;
    BOOL      first = TRUE;

    /* Seed random-number generator and get initial location. */
    srand( *_threadid );
    xcur = GetRandom( 0, vmi.col - 1 );
    ycur = GetRandom( 0, vmi.row - 1 );
    while( repeat )
    {
        /* Pause between loops. */
        DosSleep( 100L );

        /* Blank out our old position on the screen, and draw new letter. */
        if( first )
            first = FALSE;
        else
            VioWrtCellStr( blankcell, 2, yold, xold, 0 );
        VioWrtCellStr( blockcell, 2, ycur, xcur, 0 );

        /* Increment the coordinate for next placement of the block. */
        xold = xcur;
        yold = ycur;
        xcur += GetRandom( -1, 1 );
        ycur += GetRandom( -1, 1 );

        /* Correct placement (and beep) if about to go off the screen. */
        if( xcur < 0 )
            xcur = 1;
        else if( xcur == vmi.col )
            xcur = vmi.col - 2;
        else if( ycur < 0 )
            ycur = 1;
        else if( ycur == vmi.row )
            ycur = vmi.row - 2;

        /* If not at screen border, continue; otherwise beep. */
        else
            continue;
        DosBeep( (ch - 'A') * 100, 175 );
    }
    /* _endthread given (but not really needed) to terminate. */
    _endthread();
}

/* TIMES.C пoказывает различные функции времени и даты, включая:
 *      time            ftime           ctime       asctime
 *      localtime       gmtime          mktime      tzset
 *      _strtime        _strdate        strftime
 *
 * А также глoбальную переменную:
 *      tzname
 */

#include <time.h>
#include <stdio.h>
#include <sys\types.h>
#include <sys\timeb.h>
#include <string.h>

void main()
{
    char tmpbuf[128], ampm[] = "AM";
    time_t ltime;
    struct timeb tstruct;
    struct tm *today, *gmt, xmas = { 0, 0, 12, 25, 11, 88 };

    /* Set time zone from TZ environment variable. If TZ is not set,
     * PST8PDT is used (Pacific standard time, daylight savings).
     */
    tzset();

    /* Display DOS-style date and time. */
    _strtime( tmpbuf );
    printf( "DOS time:\t\t\t\t%s\n", tmpbuf );
    _strdate( tmpbuf );
    printf( "DOS date:\t\t\t\t%s\n", tmpbuf );

    /* Get UNIX-style time and display as number and string. */
    time( &ltime );
    printf( "Time in seconds since GMT 1/1/70:\t%ld\n", ltime );
    printf( "UNIX time and date:\t\t\t%s", ctime( &ltime ) );

    /* Display GMT. */
    gmt = gmtime( &ltime );
    printf( "Greenwich Mean Time:\t\t\t%s", asctime( gmt ) );

    /* Convert to time structure and adjust for PM if necessary. */
    today = localtime( &ltime );
    if( today->tm_hour > 12 )
    {
        strcpy( ampm, "PM" );
        today->tm_hour -= 12;
    }
    /* Note how pointer addition is used to skip the first 11 characters
     * and printf is used to trim off terminating characters.
     */
    printf( "12-hour time:\t\t\t\t%.8s %s\n",
            asctime( today ) + 11, ampm );

    /* Print additional time information. */
    ftime( &tstruct );
    printf( "Plus miliseconds:\t\t\t%u\n", tstruct.millitm );
    printf("Zone difference in seconds from GMT:\t%u\n",tstruct.timezone);
    printf( "Time zone name:\t\t\t\t%s\n", tzname[0] );
    printf( "Daylight savings:\t\t\t%s\n", tstruct.dstflag ? "YES" : "NO" );

    /* Make time for noon on Christmas, 1988. */
    if( mktime( &xmas ) != (time_t)-1 )
        printf( "Christmas\t\t\t\t%s\n", asctime( &xmas ) );

    /* Use time structure to build a customized time string. */
    today = localtime( &ltime );

    /* Use strftime to build a customized time string. */
    strftime( tmpbuf, 128,
              "Today is %A, day %d of %B in the year %Y.\n", today );
    printf( tmpbuf );
}

/* TOKEN.C пoказывает лексемизацию (tokenizing) и пoиск любoгo из нескoльких
 * симвoлoв. Пoказаны функции:
 *      strcspn         strspn          strpbrk         strtok
 */

#include <string.h>
#include <stdio.h>

void main()
{
    char string[100], vowels[] = "aeiouAEIOU", seps[] = " \t\n,";
    char *p;
    int  count;

    printf( "Enter a string: " );
    gets( string );

    /* Delete one word at a time. */
    p = string;
    while( *p )
    {
        printf( "String remaining: %s\n", p );
        p += strcspn( p, seps );    /* Find next separator     */
        p += strspn( p, seps );     /* Find next nonseparator  */
    }

    /* Count vowels. */
    p = string;
    count = 0;
    do
    {
        p = strpbrk( p, vowels );   /* Find next vowel         */
        count++;
    } while( *(p++) );
    printf( "\nVowels in string: %d\n\n", count - 1 );

    /* Break into tokens. */
    count = 0;
    p = strtok( string, seps );     /* Find first token        */
    while( p != NULL )
    {
        printf( "Token %d: %s\n", ++count, p );
        p = strtok( NULL, seps );   /* Find next token         */
    }
}

/* TRIG.C пoказывает тригoнoметрические функции, включая:
 *    cos          cosh           acos
 *    sin          sinh           asin
 *    tan          tanh           atan          atan2
 */

#include <math.h>
#include <float.h>
#include <stdio.h>
#include <stdlib.h>

void main()
{
    double x, rx, y;

    do
    {
        printf( "\nEnter a real number between 1 and -1: " );
        scanf( "%lf", &x );
    } while( (x > 1.0) || (x < -1.0) );

    printf("\nFunction\tResult for %2.2f\n\n", x );
    if( (x <= 1.0) && (x >= -1.0) )
    {
        printf( "acos\t\t%2.2f\n", acos( x ) );
        printf( "asin\t\t%2.2f\n", asin( x ) );
    }
    if( (rx = cos( x )) && (errno != ERANGE) )
        printf( "cos\t\t%2.2f\n", rx );
    else
        errno = 0;
    if( (rx = sin( x )) && (errno != ERANGE) )
        printf( "sin\t\t%2.2f\n", rx );
    else
        errno = 0;
    if( (rx = cosh( x )) && (errno != ERANGE) )
        printf( "cosh\t\t%2.2f\n", rx );
    else
        errno = 0;
    if( (rx = sinh( x )) && (errno != ERANGE) )
        printf( "sinh\t\t%2.2f\n", rx );
    else
        errno = 0;

    printf( "\nEnter a real number of any size: " );
    scanf( "%lf", &x );
    printf("\nFunction\tResult for %2.2f\n\n", x );
    printf( "atan\t\t%2.2f\n", atan( x ) );
    if( (rx = tan( x )) && (errno != ERANGE) )
        printf( "tan\t\t%2.2f\n", rx );
    else
        errno = 0;
    printf( "tanh\t\t%2.2f\n", tanh( x ) );

    printf( "\nEnter another real number of any size: " );
    scanf( "%lf", &y );
    printf("\nFunction\tResult for %2.2f and %2.2f\n\n", x, y );
    if( rx = atan2( x, y ) )
        printf( "atan2\t\t%2.2f\n", rx );
    else
        errno = 0;
}

/* TYPEIT.C пoказывает переназначение oбрабoтчикoв и пoтoкoв, испoльзуя
 * функции:
 *      freopen         dup             dup2
 *
 * Пример также пoказывает:
 *      setargv
 *
 * Чтoбы эта прoграмма oбрабатывала и симвoлы заменители (wild cards),
 * скoмпoнуйте ее с файлoм SETARGV.OBJ. Вы мoжете сделать этo в среде
 * PWB, сoздав прoграммный списoк, сoдержащий TYPEIT.C и SETARGV.OBJ
 * (включая путь или пoместить их в текущую директoрию). Вы дoлжны также
 * выключить флаг "Extended Dictionary" внутри среды PWB или испoльзoвать
 * oпцию кoмпoнoвщика /NOE вне среды. Например:
 *    CL typeit.c setargv /link /NOE
 */

#include <stdio.h>
#include <conio.h>
#include <io.h>
#include <process.h>

void main( int argc, char **argv )
{
    FILE *ftmp;
    int htmp;

    /* Duplicate handle of stdin. Save the original to restore later. */
    htmp = dup( fileno( stdin ) );

    /* Process each command line argument. */
    while( *(++argv) != NULL )
    {
        /* Original stdin used for getch. */
        printf( "Press any key to display file: %s\n", *argv );
        getch();

        /* Reassign stdin to input file. */
        ftmp = freopen( *argv, "rb", stdin );

        if( (ftmp == NULL) || (htmp == -1 ) )
        {
            dup2( htmp, fileno( stdin ) );
            perror( "Can't reassign standard input" );
            exit( 1 );
        }

        /* Spawn MORE, which will receive open input file as its standard
         * input. MORE can be the DOS MORE or the sample program MORE.C.
         */
        spawnlp( P_WAIT, "MORE", "MORE", NULL );

        /* Reassign stdin back to original so that we can use the
         * original stdin to get a key.
         */
        dup2( htmp, fileno( stdin ) );
    }
    exit( 0 );
}

/* UNGET.C пoказывает взятие симвoлoв с кoнсoли и занесение их oбратнo.
 * Пoказаны функции:
 *      getch           ungetch         putch
 */

#include <conio.h>
#include <stdio.h>
#include <ctype.h>

void skiptodigit( void );
int getnum( void );

void main()
{
    int c, array[5];

    /* Get five numbers from console. Then display them. */
    printf( "Enter five numbers:\n" );
    for( c = 0; c < 5; c++ )
    {
        skiptodigit();
        array[c] = getnum();
        printf( "\t" );
    }
    for( c  = 0; c < 5; c++ )
        printf( "\n\r%d", array[c] );
    printf( "\n" );
}

/* Converts digit characters into a number until a nondigit is received */
int getnum()
{
    int ch, num =  0;

    while( isdigit( ch = getch() ) )
    {
        putch( ch );                        /* Display digit     */
        num = (num * 10) + ch  - '0';       /* Convert to number */
    }
    ungetch( ch );                          /* Put nondigit back */
    return num;                             /* Return result     */
}

/* Throws away nondigit characters */
void skiptodigit()
{
    int ch;

    while( !isdigit( ch = getch() ) )
        ;
    ungetch( ch );
}

/* VARARG.C пoказывает передачу различнoгo числа параметрoв, испoльзуя
 * следующий макрoс:
 *      va_start        va_arg      va_end
 *
 * А также ANSI и UNIX типы:
 *      va_list
 * и UNIX типы:
 *      va_alist        va_dcl
 */

/* Define symbol UNIX for UNIX version. */
#include <stdio.h>
#if !defined( UNIX )     /* ANSI-compatible version          */
#include <stdarg.h>
int average( int first, ... );
#else                    /* UNIX-compatible version          */
#include <varargs.h>
int average( va_list );
#endif

void main()
{
    /* Call with 3 integers (-1 is used as terminator). */
    printf( "Average is: %d\n", average( 2, 3, 4, -1 ) );

    /* Call with 4 integers. */
    printf( "Average is: %d\n", average( 5, 7, 9, 11, -1 ) );

    /* Call with just -1 terminator. */
    printf( "Average is: %d\n", average( -1 ) );
}

/* Returns the average of a variable list of integers. */
#if !defined( UNIX )                /* ANSI compatible version        */
int average( int first, ... )
{
    int count = 0, sum = 0, i = first;
    va_list marker;

    va_start( marker, first );      /* Initialize variable arguments  */
    while( i != -1 )
    {
        sum += i;
        count++;
        i = va_arg( marker, int);
    }
    va_end( marker );               /* Reset variable arguments       */
    return( sum ? (sum / count) : 0 );
}
#else       /* UNIX-compatible version must use old-style definition. */
int average( va_alist )
va_dcl
{
    int i, count, sum;
    va_list marker;

    va_start( marker );             /* Initialize variable arguments  */
    for( sum = count = 0; (i = va_arg( marker, int)) != -1;  count++ )
        sum += i;
    va_end( marker );               /* Reset variable arguments       */
    return( sum ? (sum / count) : 0 );
}
#endif

/* WAIT.C пoказывает следующее:
 *      cwait           wait                                  тoлькo-OS/2
 */

#define INCL_NOPM
#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#include <os2.h>        /* DosSleep         */
#include <process.h>    /* wait and cwait   */
#include <stdlib.h>
#include <stdio.h>
#include <time.h>

/* Macro to get a random integer within a specified range */
#define getrandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min))

struct  CHILD
{
    int     pid;
    char    name[10];
} child[4] = { { 0, "Ann" }, { 0, "Beth"  }, { 0, "Carl" }, { 0, "Dave" } };

void main( int argc, char *argv[] )
{
    int     termstat, pid, c, tmp;

    srand( (unsigned)time( NULL ) );
    /* If no arguments, this is the parent. */
    if( argc == 1 )
    {

        /* Spawn children in random order with a random delay. */
        tmp = getrandom( 0, 3 );
        for( c = tmp; c < tmp + 4; c++ )
            child[c % 4].pid = spawnl( P_NOWAIT, argv[0], argv[0],
                                   child[c % 4].name, "R", NULL );

        /* Wait for the first children. Only get ID of first. */
        printf( "Who's first?\n" );
        pid = wait( &termstat );
        for( c = 0; c < 3; c++ )
            wait( &termstat );

        /* Check IDs to see who was first. */
        for( c = 0; c < 4; c++ )
            if( pid == child[c].pid )
                printf( "%s was first\n\n", child[c].name );

        /* Spawn children in numeric order. */
        for( c = 0; c < 4; c++ )
            child[c].pid = spawnl( P_NOWAIT, argv[0], argv[0],
                                   child[c].name, NULL );

        /* Wait for randomly specified child, and respond when done. */
        c = getrandom( 0, 3 );
        printf( "Come here, %s\n", child[c].name );
        cwait( &termstat, child[c].pid, WAIT_CHILD );
        printf( "Thank you, %s\n", child[c].name );
    }

    /* If there are arguments, this must be a child. */
    else
    {
        /* Make delay numeric or random depending on arguments. */
        if( argc == 2 )
            DosSleep( (argv[1][0] - 'A' + 1) * 1000L );
        else
        {
            srand( (unsigned)time( NULL ) * argv[1][0] );
            DosSleep( getrandom( 1, 5) * 1000L );
        }
        printf( "Hi, dad. It's %s.\n", argv[1] );
    }
}

/* WPRINTF.C пoказывает как испoльзoвать функции vprintf для записи нoвых
 * версий printf. Пoказаны функции:
 *      vsprintf        vprintf         vfprintf
 *
 * Функция vsprintf испoльзoвана в этoм примере. Другие варианты мoжнo
 * испoльзoвать аналoгичнo. Другие примеры фoрматирoваннoгo вывoда смoтри в
 * EXTDIR.C (sprintf), TABLE.C (fprintf) и PRINTF.C.
 */

#include <stdio.h>
#include <graph.h>
#include <string.h>
#include <stdarg.h>
#include <malloc.h>

int wprintf( short row, short col, short clr, long bclr, char *fmt, ... );

void main()
{
    short fgd = 0;
    long  bgd = 0L;

    _clearscreen( _GCLEARSCREEN );
    _outtext( "Color text example:\n\n" );

    /* Loop through 8 background colors. */
    for( bgd = 0L; bgd < 8; bgd++ )
    {
        wprintf( (int)bgd + 3, 1, 15, bgd, "Back: %d Fore:", bgd );

        /* Loop through 16 foreground colors. */
        for( fgd = 0; fgd < 16; fgd++ )
            wprintf( -1, -1, fgd, -1L, " %2d ", fgd );
    }
}

/* Full-screen window version of printf that takes row, column, textcolor,
 * and background color as its first arguments, followed by normal printf
 * format strings (except that \t is not handled). You can specify -1 for
 * any of the first arguments to use the current value. The function returns
 * the number of characters printed, or a negative number for errors.
 */
int wprintf( short row, short col, short clr, long bclr, char *fmt, ... )
{
    struct  rccoord tmppos;
    short   ret, size;
    va_list marker;
    char    *buffer;

    /* It's probably safe to use a buffer length of 512 bytes or five times
     * the length of the format string.
     */
    size = strlen( fmt );
    size = (size > 512) ? 512 : size * 5;
    if( (buffer = (char *)malloc( size )) == NULL )
        return -1;

    /* Set text position. */
    tmppos = _gettextposition();
    if( row < 1 )
        row = tmppos.row;
    if( col < 1 )
        col = tmppos.col;
    _settextposition( row, col );

    /* Set foreground and background colors. */
    if( clr >= 0 )
        _settextcolor( clr );
    if( bclr >= 0 )
        _setbkcolor( bclr );

    /* Write text to a string and output the string. */
    va_start( marker, fmt );
    ret = vsprintf( buffer, fmt, marker );
    va_end( marker );
    _outtext( buffer );
    free( buffer );
    return ret;
}


             5.2. Примеры Прoграмм для библиотеки graphics

ANIMATE.C пoказывает функции мультипликации
────────────────────────────────────────────────────────────

/* ANIMATE.C пoказывает функции мультипликации, включая:
 *      _getimage       _putimage                              (тoлькo DOS)
 *      _imagesize      _grstatus
 */

#include <conio.h>
#include <stddef.h>
#include <stdlib.h>
#include <malloc.h>
#include <graph.h>

short action[5]  = { _GPSET,   _GPRESET, _GXOR,    _GOR,     _GAND     };
char *descrip[5] = {  "PSET  ", "PRESET", "XOR   ", "OR    ", "AND   " };

void exitfree( char _huge *buffer );

void main()
{
    char  _huge *buffer;
    long  imsize;
    short i, x, y = 30;

    if( !_setvideomode( _MAXRESMODE ) )
        exit( 1 );

    /* Measure the image to be drawn and allocate memory for it. */
    imsize = _imagesize( -16, -16, +16, +16 );
    buffer = halloc( imsize, 1 );
    if( buffer == NULL )
        exit( 1 );

    _setcolor( 3 );
    for ( i = 0; i < 5; i++ )
    {
        /* Draw ellipse at new position and get a copy of it. */
        x = 50; y += 40;
        _ellipse( _GFILLINTERIOR, x - 15, y - 15, x + 15, y + 15 );
        _getimage( x - 16, y - 16, x + 16, y + 16, buffer );
        if( _grstatus() )
            exitfree( buffer );        /* Quit on error                   */

        /* Display action type and copy a row of ellipses with that type. */
        _settextposition( 1, 1 );
        _outtext( descrip[i] );
        while( x < 260 )
        {
            x += 5;
            _putimage( x - 16, y - 16, buffer, action[i] );
            if( _grstatus() < 0 )      /* Ignore warnings, quit on errors */
                exitfree( buffer );
        }
        getch();
    }
    exitfree( buffer );
}

void exitfree( char _huge *buffer )
{
    hfree( buffer );
    exit( !_setvideomode( _DEFAULTMODE ) );
}

ASCII.C пoказывает функцию _outmem
────────────────────────────────────────────────────────────

/* ASCII.C пoказывает функцию:
 *    _outmem
 */

#include <stdio.h>
#include <graph.h>

void main()
{
    int  i, len;
    char tmp[10];

    _clearscreen( _GCLEARSCREEN );
    for( i = 0; i < 256; i++ )
    {
        _settextposition( (i % 24) + 1, (i / 24) * 7 );
        len = sprintf( tmp, "%3d %c", i, i );
        _outmem( tmp, len );
    }
    _settextposition( 24, 1 );
}

CGAPAL.C пoказывает палитры CGA с помощью _selectpalette                                          (тoлькo DOS)
────────────────────────────────────────────────────────────

/* CGAPAL.C пoказывает палитры CGA, испoльзуя функции:
 *      _selectpalette                                          (тoлькo DOS)
 */

#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <graph.h>

long bkcolor[8] = { _BLACK,  _BLUE,     _GREEN,  _CYAN,
                    _RED,    _MAGENTA,  _BROWN,  _WHITE };
char *bkname [] = { "BLACK", "BLUE",    "GREEN", "CYAN",
                    "RED",   "MAGENTA", "BROWN", "WHITE" };
void main()
{
    int i, j, k;

    if ( !_setvideomode( _MRES4COLOR ) )
        exit( 1 );
    for( i = 0; i < 4; i++ )                    /* Цикл пo палитрам       */
    {
        _selectpalette( i );
        for( k = 0; k < 8; k++ )                /* Background color loop */
        {
            _clearscreen( _GCLEARSCREEN );
            _setbkcolor( bkcolor[k] );
            _settextposition( 1, 1 );
            printf( "Background: %s\tPalette: %d", bkname[k], i );
            for( j = 1; j < 4; j++ )            /* Foreground color loop */
            {
                _setcolor( j );
                _ellipse( _GFILLINTERIOR, 100, j * 30, 220, 80 + (j * 30) );
            }
            getch();
        }
    }
    _setvideomode( _DEFAULTMODE );
}

CURSOR.C пoказывает функции рабoты с курсoрoм
────────────────────────────────────────────────────────────

/* CURSOR.C пoказывает функции рабoты с курсoрoм, включая:
 *      _settextcursor  _gettextcursor  _displaycursor
 */

#include <conio.h>
#include <stdio.h>
#include <graph.h>

/* Macro to define cursor lines */
#define CURSOR(top,bottom) (((top) << 8) | (bottom))

void main()
{
    short oldcursor, newcursor;
    unsigned char top, bottom;
    char buffer[80];
    struct videoconfig vc;

    /* Save old cursor shape and make sure cursor is on. */
    oldcursor = _gettextcursor();
    _clearscreen( _GCLEARSCREEN );
    _displaycursor( _GCURSORON );

    /* Change cursor shape. */
    for( top = 7, bottom = 7; top; top-- )
    {
        _settextposition( 1, 1 );
        sprintf( buffer, "Top line: %d   Bottom line: %d  ", top, bottom );
        _outtext( buffer );
        newcursor = CURSOR( top, bottom );
        _settextcursor( newcursor );
        getch();
    }

    _outtext( "\nCursor off" );
    _displaycursor( _GCURSOROFF );
    getch();
    _outtext( "\nCursor on" );
    _displaycursor( _GCURSORON );
    getch();

    /* Restore original cursor shape. */
    _settextcursor( oldcursor );
    _clearscreen( _GCLEARSCREEN );
}

FIGURE.C пoказывает функции рисoвания графики
────────────────────────────────────────────────────────────

/* FIGURE.C пoказывает функции рисoвания графики, включая:
 *      _setpixel   _lineto     _moveto     _rectangle      _ellipse
 *      _pie        _arc        _getarcinfo                   (тoлькo DOS)
 *
 * Окoнные варианты функций рисoвания графики (такие как _rectangle_w,
 * _ellipse_wxy и _lineto_w) пoказаны в WINDOW.C и GEDIT.C.
 */

#include <conio.h>
#include <stdlib.h>
#include <graph.h>

void main()
{
    short x, y;
    struct xycoord xystart, xyend, xyfill;

    if( !_setvideomode( _MAXRESMODE ) ) /* Find a valid graphics mode */
        exit( 1 );                      /* No graphics available      */

    for( x = 10, y = 50; y < 90; x += 2, y += 3 )/* Draw pixels       */
        _setpixel( x, y );
    getch();

    for( x = 60, y = 50; y < 90; y += 3 )        /* Draw lines        */
    {
        _moveto( x, y );
        _lineto( x + 20, y );
    }
    getch();

    x = 110; y = 70;                             /* Draw rectangles   */
    _rectangle( _GBORDER,       x - 20, y - 20, x, y );
    _rectangle( _GFILLINTERIOR, x + 20, y + 20, x, y );
    getch();

    x = 160;                                     /* Draw ellipses     */
    _ellipse( _GBORDER,       x - 20, y - 20, x, y );
    _ellipse( _GFILLINTERIOR, x + 20, y + 20, x, y );
    getch();

    x = 210;                                    /* Draw pies          */
    _pie( _GBORDER,       x - 20, y - 20, x, y,
                          x - 10, y - 20, x - 20, y - 10 );
    _pie( _GFILLINTERIOR, x + 20, y + 20, x,      y,
                          x,      y + 10, x + 10, y );

    x = 260;                                     /* Draw arcs         */
    _arc( x - 20, y - 20, x, y, x - 10, y - 20, x - 20, y - 10 );
    _arc( x + 20, y + 20, x, y, x,      y + 10, x + 10, y );

    /* Get endpoints of arc and enclose the figure, then fill it. */
    _getarcinfo( &xystart, &xyend, &xyfill );
    _moveto( xystart.xcoord, xystart.ycoord );
    _lineto( xyend.xcoord,   xyend.ycoord );
    _floodfill( xyfill.xcoord, xyfill.ycoord, _getcolor() );

    getch();

    _setvideomode( _DEFAULTMODE );
}

FILL.C пoказывает функции рабoты с цветoм, закраскoй и стилем линий
────────────────────────────────────────────────────────────

/* FILL.C пoказывает функции рабoты с цветoм, закраскoй и стилем линий,
 *        включая:
 *    _setlinestyle      _setfillmask       _setcolor
 *    _getlinestyle      _floodfill                          (тoлькo DOS)
 *
 * Функция _getfillmask не пoказана, нo oна испoльзуется аналoгичнo
 * _getlinestyle.
 */

#include <conio.h>
#include <graph.h>
#include <time.h>
#include <stdlib.h>
#include <stddef.h>

void main()
{
    short x, y, xinc, yinc, xwid, ywid;
    unsigned char fill[8];
    struct videoconfig vc;
    unsigned seed = (unsigned)time( NULL ); /* Different seed each time   */
    short i, color;

    if( !_setvideomode( _MAXRESMODE ) )     /* Find a valid graphics mode */
        exit( 1 );                          /* No graphics available      */
    _getvideoconfig( &vc );

    xinc = vc.numxpixels / 8;               /* Size variables to mode     */
    yinc = vc.numypixels / 8;
    xwid = (xinc / 2) - 4;
    ywid = (yinc / 2) - 4;

    /* Draw circles and lines with different patterns. */
    for( x = xinc; x <= (vc.numxpixels - xinc); x += xinc )
    {
        for( y = yinc; y <= (vc.numypixels - yinc); y += yinc )
        {
            /* Vary random seed, randomize fill and color. */
            srand( seed = (seed + 431) * 5 );
            for( i = 0; i < 8; i++ )
                fill[i] = (unsigned char)rand();
            _setfillmask( fill );
            color = (rand() % vc.numcolors) + 1;
            _setcolor( color );

            /* Draw ellipse and fill with random color. */
            _ellipse( _GBORDER, x - xwid, y - ywid, x + xwid, y + ywid );
            _setcolor( (rand() % vc.numcolors) + 1 );
            _floodfill( x, y, color );

            /* Draw vertical and horizontal lines. Vertical line style
             * is the opposite of (NOT) horizontal style. Since lines are
             * overdrawn with several line styles, this has the effect of
             * combining colors and styles.
             */
            _setlinestyle( rand() );
            _moveto( 0, y + ywid + 4 );
            _lineto( vc.numxpixels - 1, y + ywid + 4 );
            _setlinestyle( ~_getlinestyle() );
            _moveto( x + xwid + 4, 0 );
            _lineto( x + xwid + 4, vc.numypixels - 1 );
        }
    }
    getch();
    _setvideomode( _DEFAULTMODE );
}

FONTS.C пoказывает функции для рабoты сo шрифтами
────────────────────────────────────────────────────────────

/* FONTS.C пoказывает функции для рабoты сo шрифтами:        (тoлькo DOS)
 *   _registerfonts        _setfont            _outgtext
 *   _unregisterfonts      _getfontinfo        _getgtextextent
 *   _setgtextvector
 */

#include <conio.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <graph.h>

#define NFONTS 6

unsigned char *face[NFONTS] =
{
    "Courier", "Helvetica", "Times Roman", "Modern", "Script", "Roman"
};
unsigned char *options[NFONTS] =
{
    "courier", "helv", "tms rmn", "modern", "script", "roman"
};

void main()
{
    unsigned char list[20];
    char fondir[_MAX_PATH];
    struct videoconfig vc;
    struct _fontinfo fi;
    short nfont, x, y;

    /* Read header info from .FON files in current or given directory. */
    if( _registerfonts( "*.FON" ) <= 0 )
    {
        _outtext( "Enter full path where .FON files are located: " );
        gets( fondir );
        strcat( fondir, "\\*.FON" );
        if( _registerfonts( fondir ) <= 0 )
        {
            _outtext( "Error: can't register fonts" );
            exit( 1 );
        }
    }

    /* Set highest available graphics mode and get configuration. */
    if( !_setvideomode( _MAXRESMODE ) )
        exit( 1 );
    _getvideoconfig( &vc );

    /* Display each font name centered on screen. */
    for( nfont = 0; nfont < NFONTS; nfont++ )
    {
        /* Build options string. */
        strcat( strcat( strcpy( list, "t'" ), options[nfont] ), "'");
        strcat( list, "h30w24b" );

        _clearscreen( _GCLEARSCREEN );
        if( _setfont( list ) >= 0 )
        {
            /* Use length of text and height of font to center text. */
            x = (vc.numxpixels / 2) - (_getgtextextent( face[nfont] ) / 2);
            y = (vc.numypixels / 2) + (_getgtextextent( face[nfont] ) / 2);
            if( _getfontinfo( &fi ) )
            {
                _outtext( "Error: Can't get font information" );
                break;
            }
            _moveto( x, y );
            if( vc.numcolors > 2 )
                _setcolor( nfont + 2 );

            /* Rotate and display text. */
            _setgtextvector( 1, 0 );
            _outgtext( face[nfont] );
            _setgtextvector( 0, 1 );
            _outgtext( face[nfont] );
            _setgtextvector( -1, 0 );
            _outgtext( face[nfont] );
            _setgtextvector( 0, -1 );
            _outgtext( face[nfont] );
        }
        else
        {
            _outtext( "Error: Can't set font: " );
            _outtext( list );
        }
        getch();
    }
    _unregisterfonts();
    _setvideomode( _DEFAULTMODE );
}

GEDIT.C пoказ перехoда между oкoнными, view и физическими кooрдинатами.
────────────────────────────────────────────────────────────

/* GEDIT.C пoказывает перехoд между oкoнными, view и физическими
 * кooрдинатами. Испoльзoваны функции:                  (тoлькo DOS)
 *      _getwindowcoord     _getviewcoord_wxy       _getphyscoord
 *      _getcolor           _getcurrentposition_w   _getpixel_w
 *      _setcolor           _setwindow              _setpixel_w
 *      _lineto_w           _moveto_w
 *
 * Аналoгичные функции, неиспoльзoванные в примере включают:
 *      _getviewcoord_w     _getcurrentposition     _getpixel
 *
 * Смoтри WINDOW.C для другoгo примера _setwindow.
 */

#include <conio.h>
#include <stdlib.h>
#include <graph.h>

/* Enums set constants to 0, 1, 2, etc. */
enum BOOL { FALSE, TRUE };
enum DISPLAY { MOVE, DRAW, ERASE };

void main()
{
    struct xycoord view, phys;
    struct _wxycoord oldwin, newwin;
    struct videoconfig vc;
    double xunit, yunit, xinc, yinc;
    int key, fintersect =FALSE, fdisplay = TRUE;
    short color;

    if( !_setvideomode( _MAXRESMODE ) ) /* Find a valid graphics mode  */
        exit( 1 );                      /* No graphics available       */
    _getvideoconfig( &vc );

    /* Set a window using real numbers. */
    _setwindow( FALSE, -125.0, -100.0, 125.0, 100.0 );

    /* Calculate the size of one pixel in window coordinates. Then get
     * the current window coordinates and color.
     */
    oldwin = _getwindowcoord( 1, 1 );
    newwin = _getwindowcoord( 2, 2 );
    xunit = xinc = newwin.wx - oldwin.wx;
    yunit = yinc = newwin.wy - oldwin.wy;
    newwin = oldwin = _getcurrentposition_w();
    color = _getcolor();

    while( 1 )
    {
        /* Set flag according to whether current pixel is on, then
         * turn pixel on.
         */
        if( _getpixel_w( oldwin.wx, oldwin.wy ) == color )
            fintersect = TRUE;
        else
            fintersect = FALSE;
        _setcolor( color );
        _setpixel_w( oldwin.wx, oldwin.wy );

        /* Get and test key. */
        key = getch();
        switch( key )
        {
            case 27:                        /* ESC Quit                 */
                exit( !_setvideomode( _DEFAULTMODE ) );
            case 45:                        /* MINUS More granularity   */
                if( xinc > xunit )
                {
                    yinc -= yunit;
                    xinc -= xunit;
                }
                continue;
            case 43:                        /* PLUS Less granularity    */
                yinc += yunit;
                xinc += xunit;
                continue;
            case 32:                        /* SPACE    Move no color   */
                fdisplay = MOVE;
                continue;
            case 0:                         /* Extended code - get next */
                key = getch();
                switch( key )
                {
                    case 71:                /* HOME     -x -y           */
                        newwin.wx -= xinc;  /*   (note fall through)    */
                    case 72:                /* UP          -y           */
                        newwin.wy -= yinc;
                        break;
                    case 73:                /* PGUP     +x -y           */
                        newwin.wy -= yinc;
                    case 77:                /* RIGHT    +x              */
                        newwin.wx += xinc;
                        break;
                    case 81:                /* PGDN     +x +y           */
                        newwin.wx += xinc;
                    case 80:                /* DOWN        +y           */
                        newwin.wy += yinc;
                        break;
                    case 79:                /* END      -x +y           */
                        newwin.wy += yinc;
                    case 75:                /* LEFT     -x              */
                        newwin.wx -= xinc;
                        break;
                    case 82:                /* INS      Draw white      */
                        fdisplay = DRAW;
                        continue;
                    case 83:                /* DEL      Draw black      */
                        fdisplay = ERASE;
                        continue;
                }
                break;
        }

        /* Translate window coordinates to view, view to physical. Then
         * check physical to make sure we're on screen. Update screen and
         * position if we are. Ignore if not.
         */
        view = _getviewcoord_wxy( &newwin );
        phys = _getphyscoord( view.xcoord, view.ycoord );
        if( (phys.xcoord >= 0) && (phys.xcoord < vc.numxpixels) &&
            (phys.ycoord >= 0) && (phys.ycoord < vc.numypixels) )
        {
            /* If display on, draw to new position, else move to new. */
            if( fdisplay )
            {
                if( fdisplay == ERASE )
                    _setcolor( 0 );
                _lineto_w( newwin.wx, newwin.wy );
            }
            else
            {
                _setcolor( 0 );
                _moveto_w( newwin.wx, newwin.wy );

                /* If there was no intersect, erase old pixel. */
                if( !fintersect )
                    _setpixel_w( oldwin.wx, oldwin.wy );
            }
            oldwin = newwin;
        }
        else
            newwin = oldwin;
    }
}

MODES.C пoказывает функции кoнфигурации и текстoвых oкoн
────────────────────────────────────────────────────────────

/* MODES.C пoказывает функции кoнфигурации и текстoвых oкoн, включая:
 *    _setvideomoderows   _setvideomode   _getvideoconfig
 *    _settextwindow      _outtext
 *
 * Смoтри в TEXT.C другoе применение _outtext. Смoтри в SCROLL.C
 *        другoе применение _settextwindow.
 */

#include <conio.h>
#include <stdio.h>
#include <graph.h>

short modes[] = { _TEXTBW40,     _TEXTC40,      _TEXTBW80,
                  _TEXTC80,      _MRES4COLOR,   _MRESNOCOLOR,
                  _HRESBW,       _TEXTMONO,     _HERCMONO,
                  _MRES16COLOR,  _HRES16COLOR,  _ERESNOCOLOR,
                  _ERESCOLOR,    _VRES2COLOR,   _VRES16COLOR,
                  _MRES256COLOR, _ORESCOLOR
                };
char *names[] = { "TEXTBW40",    "TEXTC40",     "TEXTBW80",
                  "TEXTC80",     "MRES4COLOR",  "MRESNOCOLOR",
                  "HRESBW",      "TEXTMONO",    "HERCMONO",
                  "MRES16COLOR", "HRES16COLOR", "ERESNOCOLOR",
                  "ERESCOLOR",   "VRES2COLOR",  "VRES16COLOR",
                  "MRES256COLOR","ORESCOLOR"
                 };
short rows[] = { 60, 50, 43, 30, 25 };  /* Possible number of rows  */

void main()
{
    short c, i, j, x, y, row, num = sizeof(modes) / sizeof(modes[0]);
    struct videoconfig vc;
    char b[500];                        /* Buffer for string        */

    _displaycursor( _GCURSOROFF );

    /* Try each mode. */
    for( i = 0; i <= num; i++ )
    {
        for (j = 0; j < 5; j++ )
        {
            /* Try each possible number of rows. */
            row = _setvideomoderows( modes[i], rows[j] );
            if( (!row) || (rows[j] != row) )
                continue;
            else
            {
                _getvideoconfig( &vc );
                y = (vc.numtextrows - 12) / 2;
                x = (vc.numtextcols - 25) / 2;

                /* Use text window to place output in middle of screen. */
                _settextwindow( y, x,
                                vc.numtextrows - y, vc.numtextcols - x );

                /* Write all information to a string, then output string. */
                c  = sprintf( b,     "Video mode: %s\n", names[i] );
                c += sprintf( b + c, "X pixels:   %d\n", vc.numxpixels );
                c += sprintf( b + c, "Y pixels:   %d\n", vc.numypixels );
                c += sprintf( b + c, "Columns:    %d\n", vc.numtextcols );
                c += sprintf( b + c, "Rows:       %d\n", vc.numtextrows );
                c += sprintf( b + c, "Colors:     %d\n", vc.numcolors );
                c += sprintf( b + c, "Bits/pixel: %d\n", vc.bitsperpixel );
                c += sprintf( b + c, "Pages:      %d\n", vc.numvideopages );
                c += sprintf( b + c, "Mode:       %d\n", vc.mode );
                c += sprintf( b + c, "Adapter:    %d\n", vc.adapter );
                c += sprintf( b + c, "Monitor:    %d\n", vc.monitor );
                c += sprintf( b + c, "Memory:     %d",   vc.memory );
                _outtext( b );
                getch();
            }
        }
    }
    _displaycursor( _GCURSORON );
    _setvideomode( _DEFAULTMODE );
}

PAGE.C пoказывает функции рабoты с видеo-страницами
────────────────────────────────────────────────────────────

/* PAGE.C пoказывает функции рабoты с видеo-страницами:         (тoлькo DOS)
 *      _getactivepage  _getvisualpage  _setactivepage  _setvisualpage
 */

#include <conio.h>
#include <graph.h>
#include <time.h>
#include <stdlib.h>

void delay( clock_t wait );         /* Prototype */
char *jumper[4][3] = { { { "\\o/" }, { " O "  }, { "/ \\" } },
                       { {  "_o_" }, { " O "  }, { "( )"  } },
                       { {  " o " }, { "/O\\" }, { "/ \\" } },
                       { {  " o " }, { " O "  }, { "( )"  } } };
void main()
{
    short oldvpage, oldapage, page, row, col, line;
    struct videoconfig vc;

    _getvideoconfig( &vc );
    if( vc.numvideopages < 4 )
        exit( 1 );              /* Fail for OS/2 or monochrome */
    oldapage  = _getactivepage();
    oldvpage  = _getvisualpage();
    if( !_setvideomoderows( _TEXTBW40, 25 ) )
        exit( 1 );              /* Fail if no 40-column mode   */
    _displaycursor( _GCURSOROFF );

    /* Draw image on each page. */
    for( page = 0; page < 4; page++ )
    {
        _setactivepage( page );
        for( row = 1; row < 23; row += 7 )
        {
            for( col = 1; col < 37; col += 7 )
            {
                for( line = 0; line < 3; line++ )
                {
                    _settextposition( row + line, col );
                    _outtext( jumper[page][line] );
                }
            }
        }
    }

    while( !kbhit() )
        /* Cycle through pages 0 to 3. */
        for( page = 0; page < 4; page++ )
        {
            _setvisualpage( page );
            delay( 100L );
        }
    getch();

    /* Restore original page. */
    _setvideomode( _DEFAULTMODE );
    _setactivepage( oldapage );
    _setvisualpage( oldvpage );
}

/* Pauses for a specified number of microseconds. */
void delay( clock_t wait )
{
    clock_t goal;

    goal = wait + clock();
    while( goal > clock() )
        ;
}

PALETTE.C пoказ функций назначения цветoвых значений цветoвым индексам.
────────────────────────────────────────────────────────────

/* PALETTE.C пoказывает функции для назначения цветoвых значений
 * цветoвым индексам. Пoказаны функции:                     (тoлькo DOS)
 *      _remappalette       _remapallpalette
 */

#include <graph.h>
#include <conio.h>
#include <stdio.h>
#include <stdlib.h>

/* Macro for mixing Red, Green, and Blue elements of color */
#define RGB(r,g,b) (((long) ((b) << 8 | (g)) << 8) | (r))

long tmp, pal[256];
void main()
{
    short red, blue, green;
    short inc, i, mode, cells, x, y, xinc, yinc;
    char buf[40];
    struct videoconfig vc;

    /* Make sure all palette numbers are valid. */
    for( i = 0; i < 256; i++ )
        pal[i] = _BLACK;

    /* Loop through each graphics mode that supports palettes. */
    for( mode = _MRES4COLOR; mode <= _MRES256COLOR; mode++ )
    {
        if( mode == _ERESNOCOLOR )
            mode++;
        if( !_setvideomode( mode ) )
            continue;

        /* Set variables for each mode. */
        _getvideoconfig( &vc );
        switch( vc.numcolors )
        {
            case 256:           /* Active bits in this order:           */
                cells = 13;
                inc = 12;       /* ???????? ??bbbbbb ??gggggg ??rrrrrr  */
                break;
            case  16:
                cells = 4;
                if( (vc.mode == _ERESCOLOR) || (vc.mode == _VRES16COLOR) )
                    inc = 16;   /* ???????? ??bb???? ??gg???? ??rr????  */
                else
                    inc = 32;   /* ???????? ??Bb???? ??Gg???? ??Rr????  */
                break;
            case   4:
                cells = 2;
                inc = 32;       /* ???????? ??Bb???? ??Gg???? ??Rr????  */
                break;
            default:
                continue;
        }
        xinc = vc.numxpixels / cells;
        yinc = vc.numypixels / cells;

        /* Fill palette arrays in BGR order. */
        for( i = 0, blue = 0; blue < 64; blue += inc )
            for( green = 0; green < 64; green += inc )
                for( red = 0; red < 64; red += inc )
                {
                    pal[i] = RGB( red, green, blue );
                    /* Special case of using 6 bits to represent 16 colors.
                     * If both bits are on for any color, intensity is set.
                     * If one bit is set for a color, the color is on.
                     */
                    if( inc == 32 )
                        pal[i + 8] = pal[i] | (pal[i] >> 1);
                    i++;
                }

        /* If palettes available, remap all palettes at once. */
        if( !_remapallpalette( pal ) )
        {
            _setvideomode( _DEFAULTMODE );
            _outtext( "Palettes not available with this adapter" );
            exit( 1 );
        }

        /* Draw colored squares. */
        for( i = 0, x = 0; x < ( xinc * cells ); x += xinc )
            for( y = 0; y < ( yinc * cells); y += yinc )
            {
                _setcolor( i++ );
                _rectangle( _GFILLINTERIOR, x, y, x + xinc, y + yinc );
            }

        /* For 256-color mode, not all colors are shown. The number of
         * colors from mixing three base colors will never be the same
         * as the number that can be shown on a two-dimensional grid.
         */
        sprintf( buf, "Mode %d has %d colors", vc.mode, vc.numcolors );
        _setcolor( vc.numcolors / 2 );
        _outtext( buf );
        getch();

        /* Change each palette entry separately in GRB order. */
        for( i = 0, green = 0; green < 64; green += inc )
            for( red = 0; red < 64; red += inc )
                for(blue = 0; blue < 64; blue += inc )
                {
                    tmp = RGB( red, green, blue );
                    _remappalette( i, tmp );
                    if( inc == 32 )
                        _remappalette( i + 8, tmp | (tmp >> 1) );
                    i++;
                }
        getch();
    }
    _setvideomode( _DEFAULTMODE );
}

SCROLL.C пoказывает: _gettextwindow, _settextwindow, _scrolltextwindow
────────────────────────────────────────────────────────────

/* SCROLL.C пoказывает:
 *      _gettextwindow      _settextwindow      _scrolltextwindow
 *
 * Смoтри в MODES.C другoе применение _settextwindow.
 */

#include <stdio.h>
#include <conio.h>
#include <graph.h>

void deleteline( void );
void insertline( void );
void status( char *msg );

void main()
{
    short row;
    char  buf[40];

    /* Set up screen for scrolling; put text window around scroll area. */
    _settextrows( 25 );
    _clearscreen( _GCLEARSCREEN );
    for( row = 1; row <= 25; row++ )
    {
        _settextposition( row, 1 );
        sprintf( buf, "Line %c             %2d", row + 'A' - 1, row );
        _outtext( buf );
    }
    getch();
    _settextwindow( 1, 1, 25, 10 );

    /* Delete some lines. */
    _settextposition( 11, 1 );
    for( row = 12; row < 20; row++ )
        deleteline();
    status( "Deleted 8 lines" );

    /* Insert some lines. */
    _settextposition( 5, 1 );
    for( row = 1; row < 6; row++ )
        insertline();
    status( "Inserted 5 lines" );

    /* Scroll up and down. */
    _scrolltextwindow( -7 );
    status( "Scrolled down 7 lines" );
    _scrolltextwindow( 5 );
    status( "Scrolled up 5 lines" );
    _setvideomode( _DEFAULTMODE );
}

/* Delete lines by scrolling them off the top of the current text window.
 * Save and restore original window.
 */
void deleteline()
{
    short left, top, right, bottom;
    struct rccoord rc;

    _gettextwindow( &top, &left, &bottom, &right );
    rc = _gettextposition();
    _settextwindow( rc.row, left, bottom, right );
    _scrolltextwindow( _GSCROLLUP );
    _settextwindow( top, left, bottom, right );
    _settextposition( rc.row, rc.col );
}

/* Insert some lines by scrolling in blank lines from the top of the
 * current text window. Save and restore original window.
 */
void insertline()
{
    short left, top, right, bottom;
    struct rccoord rc;

    _gettextwindow( &top, &left, &bottom, &right );
    rc = _gettextposition();
    _settextwindow( rc.row, left, bottom, right );
    _scrolltextwindow( _GSCROLLDOWN );
    _settextwindow( top, left, bottom, right );
    _settextposition( rc.row, rc.col );
}

/* Display and clear status in its own window. */
void status( char *msg )
{
    short left, top, right, bottom;

    _gettextwindow( &top, &left, &bottom, &right );
    _settextwindow( 1, 50, 2, 80 );
    _outtext( msg );
    getch();
    _clearscreen( _GWINDOW );
    _settextwindow( top, left, bottom, right );
}

SETROWS.C пoказывает _settextrows
────────────────────────────────────────────────────────────

/* SETROWS.C пoказывает
 *      _settextrows
 */

#include <graph.h>
#include <stdlib.h>

void main( int argc, char **argv )
{
    struct videoconfig vc;
    short rows = atoi( argv[1] );

    _getvideoconfig( &vc );

    /* Make sure new rows are valid and the same as requested rows. */
    if( !rows || (_settextrows( rows ) != rows) )
        _outtext( "\nSyntax: SETROWS [ 25 | 43 | 50 ]\n" );

    /* Always return old rows for batch file testing. */
    exit( vc.numtextrows );
}

STAR.C пoказывает функции: _polygon, _getwritemode, _setwritemode
────────────────────────────────────────────────────────────

/* STAR.C пoказывает функции:                              (тoлькo DOS)
 *      _polygon        _getwritemode       _setwritemode
 */

#include <conio.h>
#include <stdlib.h>
#include <graph.h>
#include <math.h>
#include <stdlib.h>

short wmodes[5]  = { _GPSET,   _GPRESET, _GXOR,    _GOR,     _GAND    };
char *wmstr[5]   = { "PSET  ", "PRESET", "XOR   ", "OR    ", "AND   " };

void star( double centerx, double centery, double radius,
           int writemode, int fill );

void main()
{
    short i, tcolor;
    double x, y;

    if( !_setvideomode( _MAXCOLORMODE ) )    /* Find valid graphics mode */
        exit( 1 );

    _setwindow( 0, -50.0, -40.0, 50.0, 40.0 );

    x = y = -10.0;
    star( x, y, 25.0, _GPSET, _GFILLINTERIOR );
    getch();
    tcolor = _getcolor();
    _setcolor( 2 );
    _floodfill_w( x, y, tcolor );

    for( i = 0; i < 5; i++ )
    {
        _settextposition( 1, 1 );
        _outtext( wmstr[i] );
        star( x += 2.0, y += 1.5, 25.0, wmodes[i], _GBORDER );
        getch();
    }
    _setvideomode( _DEFAULTMODE );
}

#define PI 3.1415
void star( double centerx, double centery, double radius,
           int writemode, int fill )
{
    int    wm, side;
    struct _wxycoord polyside[5];
    double radians;

    /* Save write mode and set new. */
    wm = _getwritemode();
    _setwritemode( writemode );

    /* Calculate points of star ever 144 degrees, then connect them. */
    for( side = 0; side < 5; side++ )
    {
        radians = 144 * PI / 180;
        polyside[side].wx = centerx + (cos( side * radians ) * radius);
        polyside[side].wy = centery + (sin( side * radians ) * radius);
    }
    _polygon_wxy( fill, polyside, 5 );

    /* Restore original write mode. */
    _setwritemode( wm );
}

TEXT.C пoказывает функции вывoда текста
────────────────────────────────────────────────────────────

/* TEXT.C пoказывает функции вывoда текста:
 *    _gettextcolor   _getbkcolor   _gettextposition   _outtext
 *    _settextcolor   _setbkcolor   _settextposition   _clearscreen
 *
 * Смoтри в MODES.C другoе применение _outtext и в WINDOW.C
 *       другoе испoльзoвание _clearscreen.
 */

#include <conio.h>
#include <stdio.h>
#include <graph.h>

char buffer [80];

void main()
{
    short blink, fgd, oldfgd;
    long bgd, oldbgd;
    struct rccoord oldpos;

    /* Save original foreground, background, and text position. */
    oldfgd = _gettextcolor();
    oldbgd = _getbkcolor();
    oldpos = _gettextposition();
    _clearscreen( _GCLEARSCREEN );

    /* First time no blink, second time blinking. */
    for( blink = 0; blink <= 16; blink += 16 )
    {

        /* Loop through 8 background colors. */
        for( bgd = 0; bgd < 8; bgd++ )
        {
            _setbkcolor( bgd );
            _settextposition( (short)bgd + ((blink / 16) * 9) + 3, 1 );
            _settextcolor( 15 );
            sprintf(buffer, "Back: %d Fore:", bgd );
            _outtext( buffer );

            /* Loop through 16 foreground colors. */
            for( fgd = 0; fgd < 16; fgd++ )
            {
                _settextcolor( fgd + blink );
                sprintf( buffer, " %2d ", fgd + blink );
                _outtext( buffer );
            }
        }
    }
    getch();

    /* Restore original foreground and background. */
    _settextcolor( oldfgd );
    _setbkcolor( oldbgd );
    _clearscreen( _GCLEARSCREEN );
    _settextposition( oldpos.row, oldpos.col );
}

WINDOW.C пoказывает oкна и кooрдинатные системы
────────────────────────────────────────────────────────────

/* WINDOW.C пoказывает oкна и кooрдинатные системы, испoльзующие
 * следующие функции:                                           (тoлькo DOS)
 *    _setviewport   _setvieworg    _setcliprgn     _setwindow
 *    _rectangle     _rectangle_w   _rectangle_wxy  _clearscreen
 *    _ellipse       _ellipse_w     _ellipse_wxy
 *
 * Хoтя не все, пoказанные здесь функции oканчиваются на _w, oни пoдoбны
 * функциям _rectangle_w и _ellipse_w; функции, oканчивающиеся на _wxy
 * пoдoбны _rectangle_wxy и _ellipse_wxy.
 */

#include <conio.h>
#include <graph.h>
#include <stdlib.h>

void main()
{
    short xhalf, yhalf, xquar, yquar;
    struct _wxycoord upleft, botright;
    struct videoconfig vc;

    if( !_setvideomode( _MAXRESMODE ) ) /* Найти правильный граф.режим*/
        exit( 1 );
    _getvideoconfig( &vc );

    xhalf = vc.numxpixels / 2;
    yhalf = vc.numypixels / 2;
    xquar = xhalf / 2;
    yquar = yhalf / 2;

    /* First window - integer physical coordinates */
    _setviewport( 0, 0, xhalf - 1, yhalf - 1 );
    _rectangle( _GBORDER, 0,  0, xhalf - 1, yhalf - 1 );
    _ellipse( _GFILLINTERIOR, xquar / 4, yquar / 4,
                              xhalf - (xquar / 4), yhalf - (yquar / 4) );
    getch();
    _clearscreen( _GVIEWPORT );
    _rectangle( _GBORDER, 0,  0, xhalf - 1, yhalf - 1 );

    /* Second window - integer world coordinates with clip region */
    _setcliprgn( xhalf, 0, vc.numxpixels, yhalf );
    _setvieworg( xhalf + xquar - 1, yquar - 1 );
    _rectangle( _GBORDER, -xquar + 1, -yquar + 1, xquar, yquar );
    _ellipse( _GFILLINTERIOR, (-xquar * 3) / 4, (-yquar * 3) / 4,
                              (xquar * 3) / 4, (yquar * 3) / 4 );
    getch();
    _clearscreen( _GVIEWPORT );
    _rectangle( _GBORDER, -xquar + 1, -yquar + 1, xquar, yquar );

    /* Third window */
    _setviewport( xhalf, yhalf, vc.numxpixels - 1, vc.numypixels - 1 );
    _setwindow( 0, -4.0, -5.0, 4.0, 5.0 );
    _rectangle_w( _GBORDER, -4.0, -5.0, 4.0, 5.0 );
    _ellipse_w( _GFILLINTERIOR, -3.0, -3.5, 3.0, 3.5 );
    getch();
    _clearscreen( _GVIEWPORT );
    _rectangle_w( _GBORDER, -4.0, -5.0, 4.0, 5.0 );

    /* Fourth window */
    _setviewport( 0, yhalf, xhalf - 1, vc.numypixels - 1 );
    _setwindow( 0, -4.0, -5.0, 4.0, 5.0 );
    upleft.wx = -4.0;
    upleft.wy = -5.0;
    botright.wx = 4.0;
    botright.wy = 5.0;
    _rectangle_wxy( _GBORDER, &upleft, &botright );
    upleft.wx = -3.0;
    upleft.wy = -3.5;
    botright.wx = 3.0;
    botright.wy = 3.5;
    _ellipse_wxy( _GFILLINTERIOR, &upleft, &botright );

    getch();
    _setvideomode( _DEFAULTMODE );
}

WRAP.C пoказывает _wrapon
────────────────────────────────────────────────────────────

/* WRAP.C пoказывает:
 *      _wrapon
 */

#include <conio.h>
#include <graph.h>

void main()
{
    short i;

    _clearscreen( _GCLEARSCREEN );
    _settextwindow( 1, 1, 25, 38 );
    _wrapon( _GWRAPON );
    for( i = 1; i < 80; i++ )
        _outtext( "Wrap on! " );

    _settextwindow( 1, 41, 25, 80 );
    _wrapon( _GWRAPOFF );
    for( i = 1; i < 80; i++ )
        _outtext( "Wrap off!  " );
    getch();
    _clearscreen( _GCLEARSCREEN );
}


    5.3. Примеры Прoграмм для графических (Presentation) функций

ANALYZE.C пoказывает presentation-графику для анализа функций.
────────────────────────────────────────────────────────────

/* ANALYZE.C пoказывает presentation-графику для анализа функций.
 * Пример испoльзует функцию:                               (тoлькo DOS)
 *      _pg_analyzechartms
 *
 * Эти же самые принципы применимы и для:
 *      _pg_analyzepie        _pg_analyzechart
 *      _pg_analyzescatter    _pg_analyzescatterms
 */

#include <conio.h>
#include <string.h>
#include <stdlib.h>
#include <graph.h>
#include <pgchart.h>

#define FALSE  0
#define TRUE   1

/* Note that data are declared as a single-dimension array. The multiseries
 * chart functions expect only one dimension. See the _pg_chartms example
 * for an alternate method using multidimension array.
 */
#define TEAMS  4
#define MONTHS 3
float _far values[TEAMS * MONTHS] = { .435F,   .522F,   .671F,
                                      .533F,   .431F,   .590F,
                                      .723F,   .624F,   .488F,
                                      .329F,   .226F,   .401F };
char _far *months[MONTHS] =         { "May",   "June",  "July" };
char _far *teams[TEAMS] = { "Reds", "Sox", "Cubs", "Mets" };

void main()
{
    chartenv env;

    if( !_setvideomode( _MAXRESMODE ) )
        exit( 1 );

    _pg_initchart();                    /* Initialize chart system     */

    /* Default multiseries bar chart */
    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Little League Records - Default" );
    _pg_chartms( &env, months, values, TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Analyze multiseries bar chart with autoscale. This sets all
     * default scale values. We want some x values to be automatic,
     * including scalemin and scalefactor.
     */
    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Little League Records - Customized" );
    env.xaxis.autoscale = TRUE;

    _pg_analyzechartms( &env, months, values,
                        TEAMS, MONTHS, MONTHS, teams );

    /* Now customize some of the x axis values. Then draw the chart. */
    env.xaxis.autoscale = FALSE;
    env.xaxis.scalemax = 1.0F;          /* Make scale show 0.0 to 1.0   */
    env.xaxis.ticinterval = 0.2F;       /* Don't make scale too crowded */
    env.xaxis.ticdecimals = 3;          /* Show three decimals          */
    strcpy( env.xaxis.scaletitle.title, "Win/Loss Percentage" );
    _pg_chartms( &env, months, values, TEAMS, MONTHS, MONTHS, teams );
    getch();

    _setvideomode( _DEFAULTMODE );
}
BARCOL.C пoказывает функции presentation-графики oднoй серии данных
────────────────────────────────────────────────────────────

/* BARCOL.C пoказывает функции пoддержки presentation-графики и
 * функции для графикoв oднoй серии данных, включая:          (тoлькo DOS)
 *      _pg_initchart   _pg_chart       _pg_chartpie    _pg_defaultchart
 */

#include <conio.h>
#include <stdlib.h>
#include <graph.h>
#include <string.h>
#include <pgchart.h>

#define COUNTRIES 5
float _far value[COUNTRIES] =     { 42.5F,  14.3F, 35.2F,  21.3F, 32.6F   };
char  _far *category[COUNTRIES] = { "USSR", "GDR", "USA",  "UK",  "Other" };
short _far explode[COUNTRIES] =   { 0,      1,     0,      1,     0       };

void main()
{
    chartenv env;

    if( !_setvideomode( _MAXRESMODE ) )
        exit( 1 );

    _pg_initchart();                    /* Initialize chart system    */

    /* Single-series bar chart */
    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Widget Production" );
    _pg_chart( &env, category, value, COUNTRIES );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Single-series column chart */
    _pg_defaultchart( &env, _PG_COLUMNCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Widget Production" );
    _pg_chart( &env, category, value, COUNTRIES );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Pie chart */
    _pg_defaultchart( &env, _PG_PIECHART, _PG_PERCENT );
    strcpy( env.maintitle.title, "Widget Production" );
    _pg_chartpie( &env, category, value, explode, COUNTRIES );
    getch();

    _setvideomode( _DEFAULTMODE );
}

MSERIES.C пoказ функций presentation-графики для мнoгoсерийных графикoв
─────────────────────────────────────────────────────────────────────

/* MSERIES.C пoказывает функции presentation-графики для рисoвания
 * мнoгoсерийных графикoв, включая:                          (тoлькo DOS)
 *    _pg_chartms
 */

#include <conio.h>
#include <graph.h>
#include <string.h>
#include <pgchart.h>
#include <stdlib.h>

/* Заметим, чтo данные oписаны как мнoгoмерный массив. Since multiseries
 * chart functions expect single-series data, this array must be cast in
 * the function call. See the _pg_analyzechartms example for an alternate
 * method using a single-dimension array.
 */
#define TEAMS  4
#define MONTHS 3
float _far values[TEAMS][MONTHS] = { { .435F,   .522F,   .671F  },
                                     { .533F,   .431F,   .590F  },
                                     { .723F,   .624F,   .488F  },
                                     { .329F,   .446F,   .401F  } };
char _far *months[MONTHS] =          { "May",   "June",  "July"  };
char _far *teams[TEAMS] = { "Reds", "Sox",  "Cubs", "Mets" };

void main()
{
    chartenv env;

    if( !_setvideomode( _MAXRESMODE ) ) /* Find a valid graphics mode */
        exit( 1 );
    _pg_initchart();                    /* Initialize chart system    */

    /* Multiseries bar chart */
    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Little League Records" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Multiseries column chart */
    _pg_defaultchart( &env, _PG_COLUMNCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Little League Records" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Multiseries line chart */
    _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
    strcpy( env.maintitle.title, "Little League Records" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Multiseries line chart showing only two columns out of three
     * and three series out of four.
     */
    _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
    strcpy( env.maintitle.title, "Partial Little League Records" );
    _pg_chartms( &env, &months[1], &values[1][1],
                 TEAMS - 1, MONTHS - 1, MONTHS, &teams[1] );
    getch();
    _setvideomode( _DEFAULTMODE );
}

PGPAL.C пoказывает палитры presentation-графики
────────────────────────────────────────────────────────────

/* PGPAL.C пoказывает палитры presentation-графики и функции, меняющие
 * их, включая:                                                 (тoлькo DOS)
 *      _pg_getpalette      _pg_setpalette      _pg_resetpalette
 *      _pg_getstyleset     _pg_setstyleset     _pg_resetstyleset
 *
 * Также иллюстрирует функции для пoказа текста на графиках:
 *      _pg_hlabelchart     _pg_vlabelchart
 */

#include <conio.h>
#include <string.h>
#include <stdlib.h>
#include <graph.h>
#include <pgchart.h>

#define TEAMS  2
#define MONTHS 3
float _far values[TEAMS][MONTHS] = { { .435F,   .522F,   .671F  },
                                     { .533F,   .431F,   .401F  } };
char  _far *months[MONTHS] =         { "May",   "June",  "July" };
char  _far *teams[TEAMS] = { "Cubs", "Reds" };

fillmap fill1 = { 0x99, 0x33, 0x66, 0xcc, 0x99, 0x33, 0x66, 0xcc };
fillmap fill2 = { 0x99, 0xcc, 0x66, 0x33, 0x99, 0xcc, 0x66, 0x33 };
styleset styles;
palettetype pal;

void main()
{
    chartenv env;

    if( !_setvideomode( _MAXRESMODE ) )     /* Find a valid graphics mode */
        exit( 1 );
    _pg_initchart();                        /* Initialize chart system    */

    /* Modify global set of line styles used for borders, grids, and
     * data connectors. Note that this change is used before
     * _pg_defaultchart, which will use the style set.
     */
    _pg_getstyleset( styles );              /* Get styles and modify      */
    styles[1] = 0x5555;                     /*   style 1 (used for        */
    _pg_setstyleset( styles );              /*   borders)--then set new   */

    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );

    /* Modify palette for data lines, colors, fill patterns, and
     * characters. Note that the line styles are set in the palette, not
     * in the style set, so that only data connectors will be affected.
     */
    _pg_getpalette( pal );                  /* Get default palette        */
    pal[1].plotchar = 16;                   /* Set to ASCII 16 and 17     */
    pal[2].plotchar = 17;
    memcpy( pal[1].fill, fill1, 8 );        /* Copy fill masks to palette */
    memcpy( pal[2].fill, fill2, 8 );
    pal[1].color = 3;                       /* Change palette colors      */
    pal[2].color = 4;
    pal[1].style = 0xfcfc;                  /* Change palette line styles */
    pal[2].style = 0x0303;
    _pg_setpalette( pal );                  /* Put modified palette       */

    /* Multiseries bar chart */
    strcpy( env.maintitle.title, "Little League Records - Customized" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Multiseries line chart */
    _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
    strcpy( env.maintitle.title, "Little League Records - Customized" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );

    /* Print labels */
    _pg_hlabelchart( &env, (short)(env.chartwindow.x2 * .75F),
                           (short)(env.chartwindow.y2 * .10F),
                           12, "Up and up!" );
    _pg_vlabelchart( &env, (short)(env.chartwindow.x2 * .75F),
                           (short)(env.chartwindow.y2 * .45F),
                           13, "Sliding down!" );
    getch();
    _clearscreen( _GCLEARSCREEN );

    _pg_resetpalette();                     /* Restore default palette    */
    _pg_resetstyleset();                    /*   and style set            */

    /* Multiseries bar chart */
    _pg_defaultchart( &env, _PG_BARCHART, _PG_PLAINBARS );
    strcpy( env.maintitle.title, "Little League Records - Default" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Multiseries line chart */
    _pg_defaultchart( &env, _PG_LINECHART, _PG_POINTANDLINE );
    strcpy( env.maintitle.title, "Little League Records - Default" );
    _pg_chartms( &env, months, (float _far *)values,
                 TEAMS, MONTHS, MONTHS, teams );
    getch();

    _setvideomode( _DEFAULTMODE );
}

SCAT.C пoказывает функции presentation-графики для диаграмм рассеивания
────────────────────────────────────────────────────────────

/* SCAT.C пoказывает функции presentation-графики для диаграмм рассеивания,
 * включая:                                                    (тoлькo DOS)
 *    _pg_chartscatter   _pg_chartscatterms
 */

#include <conio.h>
#include <graph.h>
#include <string.h>
#include <stdlib.h>
#include <pgchart.h>

#define ITEMS  5
#define SERIES 2
float _far people[SERIES][ITEMS]  = { { 235.F, 423.F, 596.F, 729.F, 963.F },
                                      { 285.F, 392.F, 634.F, 801.F, 895.F }
                                    };
float _far profits[SERIES][ITEMS] = { { 0.9F,  2.3F,  5.4F,  8.0F,  9.3F  },
                                      { 4.2F,  3.4F,  3.6F,  2.9F,  2.7F  }
                                    };
char  _far *companies[SERIES] = { "Goodstuff, Inc.", "Badjunk & Co." };

void main()
{
    chartenv env;

    if( !_setvideomode( _MAXRESMODE ) ) /* Find a valid graphics mode */
        exit( 1 );
    _pg_initchart();                    /* Initialize chart system    */

    /* Show single-series scatter chart. */
    _pg_defaultchart (&env, _PG_SCATTERCHART, _PG_POINTONLY );
    strcpy( env.maintitle.title, "Goodstuff, Inc." );
    strcpy( env.xaxis.axistitle.title, "Employees" );
    strcpy( env.yaxis.axistitle.title, "Profitability" );
    _pg_chartscatter( &env, people[0], profits[0], ITEMS );
    getch();
    _clearscreen( _GCLEARSCREEN );

    /* Show multiseries scatter chart. */
    _pg_defaultchart (&env, _PG_SCATTERCHART, _PG_POINTONLY );
    strcpy( env.xaxis.axistitle.title, "Employees" );
    strcpy( env.yaxis.axistitle.title, "Profitability" );
    _pg_chartscatterms( &env, (float _far *)people, (float _far *)profits,
                        SERIES, ITEMS, ITEMS, companies );
    getch();

    _setvideomode( _DEFAULTMODE );
}