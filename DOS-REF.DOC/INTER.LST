-----------------------------------------------------------
INT 0 - DIVIDE ERROR
Automatically called at end of DIV or IDIV operation
that results in error. Normally set by DOS to display an error
message and abort the program.
-----------------------------------------------------------
INT 1 - SINGLE-STEP
Generated at end of each machine instruction if
TF bit in FLAGS is set. This is what makes the T command
of DEBUG work for single-stepping. Is not generated after
MOV to segment register or POP of segment register.
-----------------------------------------------------------
INT 2 - NMI (Non Maskable Interrupt)
Generated by NMI signal in hardware. Used in IBM for
memory parity error trapping.
-----------------------------------------------------------
INT 3 - 1-BYTE INTERRUPT
Generated by opcode 0CCh. Similar to 8080's RST
instruction. Generally used to set breakpoints for DEBUG.
-----------------------------------------------------------
INT 4 - Overflow (internal interrupt)
Generated by INTO instruction if OF flag is set. If
flag is not set, INTO is effectively a NOP. Used to trap any
arithmetic errors when program is ready to handle them rather
than immediately when they occur.
-----------------------------------------------------------
INT 5 - Print-Screen Key
Automatically called by keyboard scan when print-
screen key is pressed. Normally executes routine to print
the screen, but may call any routine that can safely be
executed from inside the keyboard scanner.
Status and result byte at address 0050:0000.
-----------------------------------------------------------
INT 5 - BOUND check failed (80286 internal interrupt)
-----------------------------------------------------------
INT 6 - Undefined Opcode (80286 internal interrupt)
-----------------------------------------------------------
INT 7 - No Math Unit Available (80286 protected-mode internal)
-----------------------------------------------------------
INT 8 thru 0F - Vectored Hardware Lines
In IBM, these 8 interrupts are generated in
response to IRQ 0 through IRQ 7 (if enabled via port 21).
                                                [Tandy 1000]
        IRQ0    -       timer interrupt
        IRQ1    -       keyboard interrupt
        IRQ2    -       EGA vertical retrace    [fixed disk]
        IRQ3    -       serial port 2 (com2:)
        IRQ4    -       serial port 1 (com1:)
        IRQ5    -       fixed disk              [60hz ram refresh]
                        (LPT2 on PC/AT)
        IRQ6    -       diskette interrupt
        IRQ7    -       PPI interrupt (lpt1:, lpt2:)
-----------------------------------------------------------
INT 8 - Double Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 9 - Math Unit Protection Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 0A - Invalid Task State Segment (80286 protected-mode internal)
-----------------------------------------------------------
INT 0B - Not Present (80286 protected-mode internal)
-----------------------------------------------------------
INT 0C - Stack Fault (80286 protected-mode internal)
-----------------------------------------------------------
INT 0D - General Protection Violation (80286 protected-mode internal)
-----------------------------------------------------------
INT 0E - Page Fault (80386 native-mode internal)
-----------------------------------------------------------
INT 10 - VIDEO - SET VIDEO MODE
        AH = 0
        AL =
                0 = 40x25 B&W
                1 = 40x25 COLOR
                2 = 80x25 BW
                3 = 80x25 COLOR
                4 = 320x200 GRAPHICS, 4 COLOR
                5 = 320x200 GRAPHICS, 4 GREY
                6 = 640x200 GRAPHICS, B&W
                7 = MONOCHROME
                8 = 160x200 GRAPHICS, 16 COLOR (PCjr/Tandy 1000)
                9 = 320x200 GRAPHICS, 16 COLOR (PCjr/Tandy 1000)
                A = 640x200 GRAPHICS, 4 COLOR (PCjr/Tandy 1000)
                D = 320x200 graphics, 16 color (EGA)
                E = 640x200 graphics, 16 color (EGA)
                F = 640x350 graphics, monochrome (EGA)
               10 = 640x350 graphics, 4 or 16 color (EGA)
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR CHARACTERISTICS
        AH = 1
        CH =
                bits 5-6 = blink attribute
                        (00=normal, 01=invis., 10 = slow, 11=fast)
                bits 0-4 = start line for cursor in char. cell
        CL =
                bits 0-4 = end line for cursor in char. cell
-----------------------------------------------------------
INT 10 - VIDEO - SET CURSOR POSITION
        AH = 2
        DH,DL = ROW,COLUMN - 0,0 = UPPER LEFT
        BH = PAGE NO. - 0 = GRAPHICS
-----------------------------------------------------------
INT 10 - VIDEO - READ CURSOR POSITION
        AH = 3
        BH = PAGE NO. - 0 = GRAPHICS
        Return: DH,DL = ROW,COLUMN
                CH,CL = CURSOR MODE,CURRENT SET
-----------------------------------------------------------
INT 10 - VIDEO - READ LIGHT PEN POSITION
        AH = 4
        Return: AH = 0: light pen switch not activated
                AH = 1: light pen values in registers
                DH = row of current position
                DL = column of current position
                CH = raster line (0-199)
                BX = pixel column (0-319 or 0-639)
-----------------------------------------------------------
INT 10 - VIDEO - SELECT DISPLAY PAGE
        AH = 5
        AL =
                0 - 7: new page value for modes 0 & 1
                0 - 3: new page value for modes 2 & 3
                80H: read CRT/CPU page registers [PCjr]
                81H: set CPU page register to value in BL [PCjr]
                82H: set CRT page register to value in BH [PCjr]
                83H: set both display registers [PCjr]
        Return: BH = CRT page register
                BL = CPU page register
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE UP
        AH = 6
        AL = NO. OF LINES BLANKED AT BOTTOM OF PAGE
                0 = BLANK WINDOW
        BH = ATTRIBUTES TO BE USED ON BLANK LINE
        WINDOW:
        CH,CL = UPPER LEFT CORNER
        DH,DL = LOWER RIGHT CORNER
-----------------------------------------------------------
INT 10 - VIDEO - SCROLL PAGE DOWN
        AH = 7
        AL = NO. OF LINES BLANKED AT TOP OF PAGE
                0 = BLANK WINDOW
        BH = ATTRIBUTES TO BE USED ON BLANK LINE
        WINDOW:
        CH,CL = UPPER LEFT CORNER
        DH,DL = LOWER RIGHT CORNER
-----------------------------------------------------------
INT 10 - VIDEO - READ ATTRIBUTES/CHARACTER AT CURSOR POSITION
        AH = 8
        BH = DISPLAY PAGE
        Return: AL = CHAR
                AH = ATTRIBUTE OF CHAR - ALPHA MODE
-----------------------------------------------------------
INT 10 - VIDEO - WRITE ATTRIBUTES/CHARACTERS AT CURSOR POS
        AH = 9
        AL = CHARACTER
        BH = DISPLAY PAGE - ALPHA MODE
        BL = attributes of char (alpha modes) or color (graphics modes)
        CX = number of times to write character
-----------------------------------------------------------
INT 10 - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POS
        AH = 0AH
        AL = CHARACTER
        BH = DISPLAY PAGE - ALPHA MODE
        BL = COLOR OF CHARACTER (GRAPHICS MODE)
        CX = number of times to write character
-----------------------------------------------------------
INT 10 - SET COLOR PALETTE
        AH = 0BH
        BH = PALETTE COLOR ID
        BL = COLOR TO BE USED W/COLOR ID
-----------------------------------------------------------
INT 10 - WRITE DOT ON SCREEN
        AH = 0Ch
        AL = color of dot (0/1 in mode 6, 0-3 in modes 4 and 5)
             if bit 7 set, new color will be XORed with current pixel
        DX = row (0 - 199)
        CX = column (0 - 319 in modes 4/5, 0 - 639 in mode 6)
        Note: video modes 4-6 only
-----------------------------------------------------------
INT 10 - READ DOT ON SCREEN
        AH = 0Dh
        CX = column (0 - 319 or 639)
        DX = row (0 - 199)
        Return: AL = COLOR READ
-----------------------------------------------------------
INT 10 - WRITE CHARACTER - ADVANCE CURSOR (TTY WRITE)
        AH = 0EH
        AL = character
        BH = display page (alpha modes)
        BL = foreground color (graphics modes)
-----------------------------------------------------------
INT 10 - GET CURRENT VIDEO MODE
        AH = 0FH
        Return: AH = # OF COLUMNS ON SCREEN
                AL = CURRENT VIDEO MODE
                BH = CURRENT ACTIVE DISPLAY PAGE
-----------------------------------------------------------
INT 10 - SET PALETTE REGISTERS (PCjr AND TANDY 1000)
        AH = 10H
        AL = 0: SET PALETTE REGISTER
                BL = PALETTE REGISTER TO SET
                BH = COLOR VALUE TO STORE
        AL = 1: SET BORDER COLOR REGISTER
                BH = COLOR VALUE TO STORE
        AL = 2: SET ALL PALETTE REGISTERS
                ES:DX = POINTER TO 17-BYTE LIST
                        BYTES 0-15 = VALUES FOR PALETTE REGS. 0-15
                        BYTE 16 = VALUE FOR BORDER REGISTER
-----------------------------------------------------------
INT 10 - WRITE STRING, DON'T MOVE CURSOR (PC/AT ONLY)
        AH = 13H
        AL = 0
        BL = ATTRIBUTE
        BH = DISPLAY PAGE NUMBER
        DX = STARTING CURSOR POSITION
        CX = LENGTH OF STRING
        ES:BP = POINTER TO START OF STRING
-----------------------------------------------------------
INT 10 - WRITE STRING, MOVE CURSOR AFTER STRING (PC/AT ONLY)
        AH = 13H
        AL = 1
        BL = ATTRIBUTE
        BH = DISPLAY PAGE NUMBER
        DX = STARTING CURSOR POSITION
        CX = LENGTH OF STRING
        ES:BP = POINTER TO START OF STRING
-----------------------------------------------------------
INT 10 - WRITE STRING OF ALTERNATING CHARACTERS, ATTRIBUTES;
        DON'T MOVE CURSOR (PC/AT ONLY)
        AH = 13H
        AL = 2
        BH = DISPLAY PAGE NUMBER
        DX = STARTING CURSOR POSITION
        CX = LENGTH OF STRING
        ES:BP = POINTER TO START OF STRING
-----------------------------------------------------------
INT 10 - WRITE STRING OF ALTERNATING CHARACTERS, ATTRIBUTES;
        MOVE CURSOR (PC/AT ONLY)
        AH = 13H
        AL = 3
        BH = DISPLAY PAGE NUMBER
        DX = STARTING CURSOR POSITION
        CX = LENGTH OF STRING
        ES:BP = POINTER TO START OF STRING
-----------------------------------------------------------
INT 10 - GET VIDEO RAM ADDRESS [TANDY 1000]
        AH = 70H
        Return: AX  = SEGMENT ADDRESS OF THE FOLLOWING
                [BX] = OFFSET ADDRESS OF GREEN PLANE
                [CX] = SEGMENT ADDRESS OF GREEN PLANE
                [DX] = SEGMENT ADDRESS OF RED/BLUE PLANE
                (RED OFFSET = 0, BLUE OFFSET = 4000)
-----------------------------------------------------------
INT 10 - GET INCRAM ADDRESSES [TANDY 1000]
        AH = 71H
        Return: AX  = SEGMENT ADDRESS OF THE FOLLOWING
                [BX] = SEGMENT ADDRESS OF INCRAM
                [CX] = OFFSET ADDRESS OF INCRAM
-----------------------------------------------------------
INT 10 - SCROLL SCREEN RIGHT [TANDY 1000]
        AH = 72H
        AL = NO. OF COLUMNS BLANKED AT LEFT OF PAGE
                0 = BLANK WINDOW
        BH = ATTRIBUTES TO BE USED ON BLANK COLUMNS
        WINDOW:
        CH,CL = UPPER LEFT CORNER
        DH,DL = LOWER RIGHT CORNER
----------------------------------------------------------
INT 10 - SCROLL SCREEN LEFT [TANDY 1000]
        AH = 73H
        AL = NO. OF COLUMNS BLANKED AT RIGHT OF PAGE
                0 = BLANK WINDOW
        BH = ATTRIBUTES TO BE USED ON BLANK COLUMNS
        WINDOW:
        CH,CL = UPPER LEFT CORNER
        DH,DL = LOWER RIGHT CORNER
-----------------------------------------------------------
INT 10 - Get Video Buffer (TopView/DESQview/TaskView)
        AH = FEh
        ES:DI = segment:offset of assumed video buffer
        Returns:
                ES:DI = segment:offset of actual video buffer
-----------------------------------------------------------
INT 10 - Update Video Buffer (TopView/DESQview/TaskView)
        AH = FFh
        CX = number of sequential characters that have been modified
        DI = offset of first character that has been modified
        ES = segment of video buffer
-----------------------------------------------------------
INT 11 - EQUIPMENT DETERMINATION
        Return: AX = "equipment flag" bits
                0       diskette installed
                1       8087 present
                2,3     always = 11
                4,5     initial video mode
                        01 = 40x25 COLOR
                        10 = 80x25 COLOR
                        11 = 80X25 IBM monochrome
                6,7     number of diskette drives (only if bit 0 = 1)
                        00 = 1, 01 = 2
                8       0 = dma present, 1= no dma on system
                9,10,11 number of RS232 cards
                12      game I/O attached
                13      serial printer installed (IBM-PCjr)
                14,15   number of printers
-----------------------------------------------------------
INT 12 - MEMORY SIZE
        Return: AX = NO. OF CONTIGUOUS 1K BLOCKS
-----------------------------------------------------------
INT 13 - RESET DISK SYSTEM
        AH = 0
-----------------------------------------------------------
INT 13 - STATUS OF DISK SYSTEM
        AH = 1
        Return: AL = STATUS
                01H = BAD COMMAND
                02H = ADDRESS MARK NOT FOUND
                03H = WRITE ATTEMPTED ON WRITE-PROTECTED DISK
                04H = SECTOR NOT FOUND
                06H = DISKETTE REMOVED
                08H = DMA OVERRUN
                09H = DMA ACROSS 64K BOUNDARY
                10H = BAD CRC
                20H = CONTROLLER FAILURE
                40H = SEEK FAILED
                80H = TIME OUT
-----------------------------------------------------------
INT 13 - READ SECTORS INTO MEMORY
        AH = 2
        AL = NO. OF SECTORS
        CH = TRACK NO.
        CL = SECTOR NO.
        DH = HEAD NO.
        DL = DRIVE NO.
        ES:BX = ADDRESS OF BUFFER
        Return: CF = SUCCESS/FAILURE SIGNAL
                AH = STATUS (SEE AH = 01)
                AL = NUMBER OF SECTORS READ
-----------------------------------------------------------
INT 13 - WRITES SECTORS FROM MEMORY
        AH = 3
        AL = NO. OF SECTORS
        CH = TRACK NO.
        CL = SECTOR NO.
        DH = HEAD NO.
        DL = DRIVE NO.
        ES:BX = ADDRESS OF BUFFER
        Return: CF = SUCCESS/FAILURE SIGNAL
                AH = STATUS (SEE AH = 01)
                AL = NUMBER OF SECTORS WRITTEN
-----------------------------------------------------------
INT 13 - VERIFIES SECTORS
        AH = 4
        AL = NO. OF SECTORS
        CH = TRACK NO.
        CL = SECTOR NO.
        DH = HEAD NO.
        DL = DRIVE NO.
        Return: CF = SUCCESS/FAILURE SIGNAL
                AH = STATUS (SEE AH = 01)
                AL = NUMBER OF SECTORS VERIFIED
-----------------------------------------------------------
INT 13 - FORMAT DISKETTE TRACK
        AH = 5
        AL = NUMBER OF SECTORS
        CH = TRACK NUMBER
        CL = SECTOR NUMBER
        DH = HEAD NUMBER
        DL = DRIVE NUMBER
        ES:BX = POINTER TO 4-BYTE ADDRESS FIELD
                BYTE 1 = TRACK
                BYTE 2 = HEAD
                BYTE 3 = SECTOR
                BYTE 4 = BYTES/SECTOR
        Return: CF = SUCCESS/FAILURE SIGNAL
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - GET CURRENT DRIVE PARAMETERS (PC/XT and PC/AT)
        AH = 8
        DL = DRIVE NUMBER
        Return: CF = SUCCESS/FAILURE FLAG
                AH = STATUS CODE (SEE AH = 01)
                DL = NUMBER OF DRIVES (?)
                DH = MAX. NUMBER OF SIDES
                CL = MAX. NUMBER OF SECTORS
                CH = MAX. NUMBER OF TRACKS
-----------------------------------------------------------
INT 13 - INITIALIZE TWO FIXED DISK BASE TABLES (PC/AT ONLY)
        AH = 9
        Return: CF = SUCCESS/FAILURE FLAG
                AH = STATUS CODE (SEE ABOVE)
                INTERRUPT 41 POINTS TO TABLE FOR DRIVE 0
                INTERRUPT 46 POINTS TO TABLE FOR DRIVE 1
-----------------------------------------------------------
INT 13 - READ LONG (PC/AT ONLY)
        AH = 0AH
        DL = DRIVE ID
        DH = HEAD NUMBER
        CH = CYLINDER NUMBER
        CL = SECTOR NUMBER
        ES:BX = POINTER TO BUFFER
        Return: CF = SUCCESS/FAILURE FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - WRITE LONG (PC/AT ONLY)
        AH = 0BH
        DL = DRIVE ID
        DH = HEAD NUMBER
        CH = SECTOR NUMBER
        ES:BX = POINTER TO BUFFER
        Return: CF = SUCCESS/FAILURE FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - SEEK TO CYLINDER (PC/XT and PC/AT)
        AH = 0CH
        DL = DRIVE ID
        DH = HEAD NUMBER
        CH = SECTOR NUMBER
        Return: CF = SUCCESS/FAILURE FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - ATLERNATE DISK RESET (PC/XT and PC/AT)
        AH = 0DH
        DL = DRIVE ID
        Return: CF = SUCCESS/FAIL FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - TEST FOR DRIVE READY (PC/AT ONLY)
        AH = 10H
        DL = DRIVE ID
        Return: CF = SUCCESS/FAIL FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - RECALIBRATE DRIVE (PC/XT and PC/AT)
        AH = 11H
        DL = DRIVE ID
        Return: CF = SUCCESS/FAIL FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - CONTROLLER DIAGNOSTICS (PC/AT ONLY)
        AH = 14H
        Return: CF = SUCCESS/FAIL FLAG
                AH = STATUS CODE (SEE AH = 01)
-----------------------------------------------------------
INT 13 - GET DISK TYPE (PC/AT ONLY)
        AH = 15H
        DL = DRIVE ID
        Return: AH = DISK TYPE
                0 = DISK NOT THERE
                1 = DISKETTE, NO CHANGE DETECTION PRESENT
                2 = DISKETTE, CHANGE DETECTION PRESENT
                3 = FIXED DISK
                CX,DX = NUMBER OF 512-BYTE SECTORS WHEN AH = 3
-----------------------------------------------------------
INT 13 - CHANGE OF DISK STATUS (PC/AT ONLY)
        AH = 16H
        Return: DL = DRIVE THAT HAD DISK CHANGE
                AH = DISK CHANGE STATUS
                00 = NO DISK CHANGE
                01 = DISK CHANGED (6?)
-----------------------------------------------------------
INT 13 - SET DISK TYPE (PC/AT ONLY)
        AH = 17H
        AL = DISK TYPE
        00 = NO DISK
        01 = REGULAR DISK IN REGULAR DRIVE
        02 = REGULAR DISK IN HIGH-CAP. DRIVE
        03 = HIGH-CAP. DISK IN HIGH-CAP. DRIVE
        DL = DRIVE ID
-----------------------------------------------------------
INT 14 - SERIAL I/O - INITIALIZE USART
        AH = 0
        AL = INITIALIZING PARAMETERS
        7 - 6 - 5      4 - 3     2    1 - 0
        -BAUD RATE-    PARITY   STOP   WORD
                                BITS  LENGTH
        000  110 BD    00 NONE  0-1   10 - 7
        001  150 BD    01 ODD   1-2   11 - 8
        010  300 BD    11 EVEN
        011  600 BD
        100 1200 BD
        101 2400 BD
        110 4800 BD
        111 9600 BD (4800 ON PCjr)
        DX = PORT NUMBER
        Return: AX port status--see below
-----------------------------------------------------------
INT 14 - SERIAL I/O - TRANSMIT CHARACTER
        AH = 1
        AL = CHARACTER
        DX = PORT NUMBER
        Return: AH = RS-232 STATUS CODE BITS
                0 = DATA READY
                1 = OVERRUN ERROR
                2 = PARITY ERROR
                3 = FRAMING ERROR
                4 = BREAK DETECTED
                5 = TRANSMISSION BUFFER REG. EMPTY
                6 = TRANSMISSION SHIFT REG. EMPTY
                7 = TIME OUT
                AL = MODEM STATUS BITS
                0 = DELTA CLEAR-TO-SEND
                1 = DELTA DATA-SET-READY
                2 = TRAILING EDGE RING DETECTED
                3 = CHANGE, RECEIVE LINE SIGNAL DETECTED
                4 = CLEAR-TO-SEND
                5 = DATA-SET-READY
                6 = RING DETECTED
                7 = RECEIVE LINE SIGNAL DETECTED
-----------------------------------------------------------
INT 14 - SERIAL I/O - RECEIVE CHARACTER
        AH = 2
        Return: AL = CHARACTER RECEIVED
                AH = RS-232 STATUS CODE (SEE ABOVE)
-----------------------------------------------------------
INT 14 - SERIAL I/O - GET USART STATUS
        AH = 3
        Return: AH = RS-232 STATUS CODE (SEE ABOVE)
                AL = MODEM STATUS CODE (SEE ABOVE)
-----------------------------------------------------------
INT 15 - TURN ON CASSETTE MOTOR
        AH = 0
-----------------------------------------------------------
INT 15 - TURN OFF CASSETTE MOTOR
        AH = 1
-----------------------------------------------------------
INT 15 - READ DATA BLOCKS FROM CASSETTE
        AH = 2
        CX = COUNT OF BYTES
        ES:BX = POINTER TO DATA AREA
        Return: CF = ERROR SIGNAL
                DX = COUNT OF BYTES READ
                ES:BX = POINTER PAST LAST BYTE READ
-----------------------------------------------------------
INT 15 - WRITE DATA BLOCKS TO CASSETTE
        AH = 3
        CX = COUNT OF BYTES TO WRITE
        ES:BX = POINTER TO DATA AREA
        Return: ES:BX = POINTER PAST LAST BYTE WRITTEN
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView - Give up CPU time
        AX = 1000h
        Return: after other process(es) run
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView - Get Version
        AX = 1022h
        BX = 0
        Return: BX nonzero, TopView or compat loaded
                TaskView returns BX = 0001h
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView command
        AH = 11h
        AL = various
-----------------------------------------------------------
INT 15 - DESQview/TopView/TaskView command
        AH = 12h
        AL = various
-----------------------------------------------------------
INT 15 - DEVICE OPEN (PC/AT ONLY)
        AH = 80h
        Return: BX = DEVICE ID
                CX = PROCESS TYPE
-----------------------------------------------------------
INT 15 - DEVICE CLOSE (PC/AT ONLY)
        AH = 81h
        Return: BX = DEVICE ID
                CX = PROCESS TYPE
-----------------------------------------------------------
INT 15 - DEVICE PROGRAM TERMINATE (PC/AT ONLY)
        AH = 82h
        Return: BX = DEVICE ID
-----------------------------------------------------------
INT 15 - EVENT WAIT (PC/AT ONLY)
        AH = 83h
        AL = SUBSERVICE
        0 = SET INTERVAL
        1 = CANCEL
        ES:BX = POINTER TO CALLER'S MEMORY
        CX,DX = number of microseconds to wait (only accurate to 977 us)
-----------------------------------------------------------
INT 15 - READ JOYSTICK SWITCH SETTINGS (PC/AT ONLY)
        AH = 84h
        DX = 0
        Return: AL = SWITCH SETTINGS
-----------------------------------------------------------
INT 15 - READ JOYSTICK INPUTS (PC/AT ONLY)
        AH = 84h
        DX = 1
        Return: AX = A(x) VALUE
                BX = A(y) VALUE
                CX = B(x) VALUE
                DX = B(y) VALUE
-----------------------------------------------------------
INT 15 - SYSTEM REQUEST KEY PRESS (PC/AT ONLY)
        AH = 85h
        Return: AL = 00 PRESS
                AL = 01 BREAK
-----------------------------------------------------------
INT 15 - WAIT (PC/AT ONLY)
        AH = 86h
        Return: CX,DX = number of microseconds to wait (only accurate to 977 us)
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - BLOCK MOVE   (PC/AT ONLY)
        AH = 87h
        CX = NUMBER OF WORDS TO MOVE
        ES:SI = POINTER TO TABLE
-----------------------------------------------------------
INT 15 - EXTENDED MEMORY - GET MEMORY SIZE      (PC/AT ONLY)
        AH = 88h
        Return: AX = MEMORY SIZE
-----------------------------------------------------------
INT 15 - SWITCH TO VIRTUAL MODE (PC/AT ONLY)
        AH = 89h
-----------------------------------------------------------
INT 15 - DEVICE BUSY LOOP (PC/AT ONLY)
        AH = 90h
        AL = TYPE CODE
-----------------------------------------------------------
INT 15 - SET FLAG AND COMPLETE INTERRUPT
        AH = 91h
        AL = TYPE CODE
-----------------------------------------------------------
INT 15 - GET SYSTEM CONFIGURATION (XT after 1/10/86, PC Conv, XT286, PS/2)
        AH = C0h
        Return: CF = 1 if BIOS doesn't support call
                ES:BX pointer to ROM table
                   byte_count  dw   ?   ; number of bytes following
                   model       db   ?   ; PC=ff, XT=fe or fb, PCjr = fd, etc, etc
                   submodel    db   ?   ; distingushes between AT and XT/286, etc.
                   BIOS_rev    db   ?   ; 0 for first release, 1 for 2nd, etc.
                   featbyte    db   ?   ; 80h = DMA channel 3 used by hd BIOS,
                                        ; 40h = 2nd 8259 installed,
                                        ; 20h = Real-Time Clock installed,
                                        ; 10h = INT 15h called upon INT 9h
                                        ;  8h = wait for external event supported,
                                        ;  4h = extended BIOS area allocated at 640K,
                                        ;  2h = bus is Micro Channel instead of PC.
                                        ;  1h   reserved
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - READ CHAR FROM BUFFER - WAIT IF EMPTY
        AH = 0
        Return: AH = SCAN CODE
                AL = CHARACTER
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - CHECK BUFFER - DO NOT CLEAR
        AH = 1
        Return: FLAG ZF = 0 = CHAR IN BUFFER
                  AH = SCAN CODE
                  AL = CHARACTER
                FLAG ZF = 1 = NO CHAR IN BUFFER
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - GET SHIFT STATUS
        AH = 2
                AL = SHIFT STATUS BITS
                  0 = RIGHT SHIFT KEY DEPRESSED
                  1 = LEFT SHIFT KEY DEPRESSED
                  2 = CTRL DEPRESSED
                  3 = ALT DEPRESSED
                  4 = SCROLL LOCK ACTIVE
                  5 = NUM LOCK ACTIVE
                  6 = CAPS LOCK ACTIVE
                  7 = INSERT STATE ACTIVE
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - SET DELAYS (PCjr, AT, PS/2)
        AH = 3
        AL = 0: RESET TYPEMATIC (PCjr)
        AL = 1: INCREASE INITIAL DELAY (PCjr)
        AL = 2: INCREASE CONTINUING DELAY (PCjr)
        AL = 3: INCREASE BOTH DELAYS (PCjr)
        AL = 4: TURN OFF TYPEMATIC (PCjr)
        AL = 5: Set typematic rate (AT or PS/2)
          BH = 00 - 03 for delays of 250ms, 500ms, 750ms, or 1s
          BL = 00 - 1F for typematic rates of 30cps down to 2cps
-----------------------------------------------------------
INT 16 - KEYBOARD I/O - KEYCLICK (PCjr ONLY)
        AH = 4
        AL = 0: CLICK OFF
        AL = 1: CLICK ON
-----------------------------------------------------------
INT 16 - KEYBOARD - Write to keyboard buffer (AT or PS/2 with enhanced kbd)
        AH = 5
        CH = scan code
        CL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - Get enhanced keystroke (AT or PS/2 with enhanced kbd)
        AH = 10h
        Return: AH = scan code
                AL = character
-----------------------------------------------------------
INT 16 - KEYBOARD - Check enhanced keystroke (AT or PS/2 with enhanced kbd)
        AH = 11h
        Return: ZF = 0 if keystroke available
                  AH = scan code \ meaningless if ZF = 1
                  AL = character /
                ZF = 1 if kbd buffer empty
-----------------------------------------------------------
INT 16 - KEYBOARD - Get enhanced shift flags (AT or PS/2 with enhanced kbd)
        AH = 12h
        Return:
                AL (same as for AH=02)
                  bit 7: Ins ON
                  bit 6: CapsLock ON
                  bit 5: NumLock ON
                  bit 4: ScrollLock ON
                  bit 3: Either ALT key down
                  bit 2: Either CTRL key down
                  bit 1: Left shift key down
                  bit 0: Right shift key down
                AH
                  bit 7: SysReq key down
                  bit 6: CapsLock key down
                  bit 5: NumLock key down
                  bit 4: ScrollLock key down
                  bit 3: Right Alt key down
                  bit 2: Right Ctrl key down
                  bit 1: Left Alt key down
                  bit 0: Right Alt key down
-----------------------------------------------------------
INT 17 - CHARACTER TO PRINTER
        AH = 0
        AL = CHAR
        Return: AH = STATUS BITS
                  0 = TIME OUT
                  1 = UNUSED
                  2 = UNUSED
                  3 = I/O ERROR
                  4 = SELECTED
                  5 = OUT OF PAPER
                  6 = ACKNOWLEDGE
                  7 = NOT BUSY
-----------------------------------------------------------
INT 17 - INITIALIZE PRINTER
        AH = 1
        Return: AH = STATUS (SEE ABOVE)
-----------------------------------------------------------
INT 17 - STATUS OF PRINTER
        AH = 2
        Return: AH = STATUS (SEE ABOVE)
-----------------------------------------------------------
INT 18 - TRANSFER TO ROM BASIC
CAUSES TRANSFER TO ROM-BASED BASIC (IBM-PC)
OFTEN REBOOTS A COMPATIBLE
-----------------------------------------------------------
INT 19 - DISK BOOT
CAUSES REBOOT OF DISK SYSTEM (NO MEMORY TEST PERFORMED).
-----------------------------------------------------------
INT 1A - GET TIME OF DAY
        AH = 0
        Return: CX = high (most signif.) portion of clock count
                DX = low (least signif.) portion of clock count
                AL = 0 if clock was read or written (via AH=0,1)
                withing the current 24-hour period
                Otherwise, AL > 0
-----------------------------------------------------------
INT 1A - SET TIME OF DAY
        AH = 1
        CX = high (most signif.) portion of clock count
        DX = low (least signif.) portion of clock count
-----------------------------------------------------------
INT 1A - READ REAL TIME CLOCK (PC/AT ONLY)
        AH = 2
        Return: CH = hours
                CL = minutes
                DH = seconds
-----------------------------------------------------------
INT 1A - SET REAL TIME CLOCK (PC/AT ONLY)
        AH = 3
        Return: CH = hours
                CL = minutes
                DH = seconds
                DL = 1, if daylight savings; 0 if standard time
-----------------------------------------------------------
INT 1A - READ DATE FROM REAL TIME CLOCK (PC/AT ONLY)
        AH = 4
        Return: DL = DAY
                DH = MONTH
                CL = YEAR
                CH = CENTURY (19 OR 20)
-----------------------------------------------------------
INT 1A - SET DATE IN REAL TIME CLOCK (PC/AT ONLY)
        AH = 5
        DL = DAY
        DH = MONTH
        CL = YEAR
        CH = CENTURY (19 OR 20)
-----------------------------------------------------------
INT 1A - SET ALARM (PC/AT ONLY)
        AH = 6
        CH = HOURS
        CL = MINUTES
        DH = SECONDS
        Return: INT 4Ah will be called when alarm goes off
-----------------------------------------------------------
INT 1A - RESET ALARM (PC/AT ONLY)
        AH = 7
-----------------------------------------------------------
INT 1B - CTRL-BREAK KEY
This interrupt is called when the keyboard scanner of
the IBM machines detects CTRL and BREAK pressed at the same
time. It normally points to a simple IRET so that it does
nothing, but many programs change it to return a CTRL-C scan
code and thus invoke INT 23.
-----------------------------------------------------------
INT 1C - CLOCK TICK
This interrupt is called (in the IBM) at the end of
each time-update operation by the real-time clock routines. It
normally points to an IRET unless PRINT.COM has been installed.
-----------------------------------------------------------
INT 1D -> 6845 Video Init tables
        table for modes 0 and 1   \
        table for modes 2 and 3    \ each table is 16 bytes long
        table for modes 4,5, and 6 /
        table for mode 7          /
        4 words -- size of video RAM for modes 0/1, 2/3, 4/5, and 6/7
        8 bytes -- number of columns in each mode
        8 bytes -- video controller mode byte for each mode
-----------------------------------------------------------
INT 1E -> Diskette Params (BASE TABLE)
Default at f000:efc7
        db      step rate & head unload times
        db      head load time & DMA
        db      motor off time
        db      sector size (0->128, 1->256, 2->512, 3->1024)
        db      last sector number (8 or 9 typical)
        db      inter-sector gap size on read/write (42 typical)
        db      data transfer length (255 typical)
        db      inter-sector gap size on format (80 typical)
        db      sector fill on format (f6 typical)
        db      head-settle time ms (typical 25, 2.10->15)
        db      motor start-up time (1/8 secs) (typical 4, 2.10->2)
-----------------------------------------------------------
INT 1F -> Pointer to Graphics Set 2--contains bitmaps for high 128 chars
-----------------------------------------------------------
INT 20 - PROGRAM TERMINATION
RETURNS TO DOS
-----------------------------------------------------------
INT 21 - PROGRAM TERMINATION
        AH = 00H
Same action as INT 20; returns to DOS.
-----------------------------------------------------------
INT 21 - KEYBOARD INPUT
        AH = 01H
        Return: AL = CHARACTER READ
-----------------------------------------------------------
INT 21 - DISPLAY OUTPUT
        AH = 02H
        DL = CHAR
-----------------------------------------------------------
INT 21 - AUX Input
        AH = 03H
        Return: AL = CHARACTER READ
-----------------------------------------------------------
INT 21 - AUX Output
        AH = 04H
        DL = CHAR
-----------------------------------------------------------
INT 21 - PRINTER OUTPUT
        AH = 05H
        DL = CHAR
-----------------------------------------------------------
INT 21 - DIRECT CONSOLE I/O - CHARACTER OUTPUT
        AH = 06H
        DL = CHAR <> 0FFH
-----------------------------------------------------------
INT 21 - DIRECT CONSOLE I/O - CHARACTER INPUT
        AH = 06H
        DL = 0FFH
        Return: FLAG ZF = SET    = NO CHARACTER
                CLEAR  = CHARACTER RECIEVED
                AL = CHARACTER
                Character is echoed to STDOUT if received.
-----------------------------------------------------------
INT 21 - Direct STDIN Input, no echo
        Reg AH = 07H
Same as Function 6 for input but char not echoed.
-----------------------------------------------------------
INT 21 - KEYBOARD INPUT - NO ECHO
        AH = 08H
        Return: AL = CHAR
-----------------------------------------------------------
INT 21 - PRINT STRING
        AH = 09H
        DS:DX  = ADDRESS OF STRING TERMINATED WITH "$"
-----------------------------------------------------------
INT 21 - BUFFERED KEYBOARD INPUT
        AH = 0AH
        DS:DX  = ADDRESS OF BUFFER
FIRST BYTE OF BUFFER MUST HAVE MAX LENGTH
ON RETURN SECOND BYTE HAS ACTUAL LENGTH
-----------------------------------------------------------
INT 21 - CHECK STANDARD INPUT STATUS
        AH = 0BH
        Return: AL =
                FFH IF CHAR TYPED
                00H IF NOT TYPED
-----------------------------------------------------------
INT 21 - Clear Keyboard Buffer
        AH = 0CH
        AL must be 1, 6, 7, 8, or 0aH.
  Flushes all typeahead input, then executes function specified
by AL (by moving it to AH and repeating the INT 21 call).
  If AL contains a value not in the list above, the keyboard buffer is
flushed and no other action is taken.
-----------------------------------------------------------
INT 21 - Disk Reset
        Reg AH = 0DH
Flushes all disk buffers.
-----------------------------------------------------------
INT 21 - SELECT DISK
        AH = 0EH
        DL = new default drive number (0 = A, 1 = B, etc.)
        Return: AL = number of logical drives
-----------------------------------------------------------
INT 21 - OPEN DISK FILE
        AH = 0FH
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
-----------------------------------------------------------
INT 21 - CLOSE DISK FILE
        AH = 10H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
-----------------------------------------------------------
INT 21 - Search First using FCB
        AH = 11H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
If file found, FCB is created at DTA address and
set up to OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - Search Next using FCB
        AH = 12H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
If file found, FCB is created at DTA address and
set up to OPEN or DELETE it.
-----------------------------------------------------------
INT 21 - Delete File via FCB
        AH = 13H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
-----------------------------------------------------------
INT 21 - SEQUENTIAL DISK FILE READ
        AH = 14H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                0 = SUCCESSFUL READ
                1 = END OF FILE
                2 = DATA TRANSFER AREA TOO SMALL
                3 = PARTIAL RECORD, EOF
-----------------------------------------------------------
INT 21 - SEQUENTIAL DISK RECORD WRITE
        AH = 15H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                0 = SUCCESSFUL WRITE
                1 = DISKETTE FULL
                2 = DATA TRANSFER AREA TOO SMALL
-----------------------------------------------------------
INT 21 - CREATE A DISK FILE
        AH = 16H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = SUCCESSFUL CREATION
                FF = NO ROOM IN DIRECTORY
-----------------------------------------------------------
INT 21 - Rename File via FCB
        AH = 17H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        FCB contains new name starting at byte 17H.
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 18h
        Return: AL = 0
-----------------------------------------------------------
INT 21 - Default Disk Number
        AH = 19h
        Return: AL = current drive number (letter - 'A')
-----------------------------------------------------------
INT 21 - SET DISK TRANSFER AREA ADDRESS
        AH = 1AH
        DS = SEGMENT ADDRESS OF BUFFER
        DX = OFFSET ADDRESS OF BUFFER
-----------------------------------------------------------
INT 21 - Default Drive Disk Size
        AH = 1BH
        Return: DS:BX points to FAT ID byte
                DX = number of allocation units on disk
                AL = number of sectors per AU
                CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - Specific Drive's Disk Size
        AH = 1CH
        DL = Drive Number to check
        Return: DS:BX points to FAT ID byte
                DX = number of allocation units on disk
                AL = number of sectors per AU
                CX = number of bytes per sector
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 1Dh
        Return: AL = 0
-----------------------------------------------------------~r
INT 21 - Internal - does nothing
        AH = 1Eh
        Return: AL = 0
-----------------------------------------------------------
INT 21 - Internal - GET DEFAULT DRIVE PARAMETER BLOCK
        AH = 1Fh
        Return: AL = 00h No Error
                     FFh Error
                (DS:BX) = ADDRESS OF DRIVE PARAMETER BLOCK.
(For DOS 2.x and 3.x, this just invokes function 32h with DL = 0)
-----------------------------------------------------------
INT 21 - Internal - does nothing
        AH = 20h
        Return: AL = 0
-----------------------------------------------------------
INT 21 - RANDOM DISK RECORD READ
        AH = 21H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                0 = SUCCESSFUL READ
                1 = END OF FILE
                2 = DATA TRANSFER AREA TOO SMALL
                3 = PARTIAL RECORD, EOF
-----------------------------------------------------------
INT 21 - Random Disk Write
        AH = 22H
Same setup as Random Read, but writes to disk
-----------------------------------------------------------
INT 21 - FILE SIZE
        AH = 23H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        Return: AL =
                00 = FILE FOUND
                FF = FILE NOT FOUND
FCB SET TO NO. OF RECORDS
-----------------------------------------------------------
INT 21 - Set Random Record Field
        AH = 24H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
FCB must be OPEN already
        Return: Random Record Field of FCB is set to be
                same as Current Block and Current Record.
-----------------------------------------------------------
INT 21 - Set Interrupt Vector
        AH = 25H
        AL = INT number
        DS:DX = new vector to be used for specified INT
-----------------------------------------------------------
INT 21 - Create PSP
        AH = 26H
        DX = Segment number to set up PSP at
Current PSP is copied to specified segment
-----------------------------------------------------------
INT 21 - RANDOM BLOCK READ
        AH = 27H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        CX = NO. OF RECORDS TO BE READ
        Return: AL =
                0 = SUCCESSFUL READ
                1 = END OF FILE
                2 = DATA TRANSFER AREA TOO SMALL
                3 = PARTIAL RECORD, EOF
-----------------------------------------------------------
INT 21 - RANDOM BLOCK WRITE
        AH = 28H
        DS = SEGMENT ADDRESS OF FCB
        DX = OFFSET ADDRESS OF FCB
        CX = NO. OF RECORDS TO BE WRITTEN
        Return: AL =
                0 = SUCCESSFUL WRITE
                1 = DISKETTE FULL
                2 = DATA TRANSFER AREA TOO SMALL
-----------------------------------------------------------
INT 21 - Parse Filename
        AH = 29h
        DS:SI = pointer to string to parse
        ES:DI = pointer to memory to fill with unopened FCB
        AL = bit mask to control parsing
            0 = 0: parsing stops if file separator found
                1: leading separator ignored
            1 = 0: drive number in FCB set to default drive if not present
                   in string
                1: drive number in FCB not changed
            2 = 0: filename in FCB set to blanks if no filename in string
                1: filename in FCB not changed if string does not contain
                   a filename
            3 = 0: extension in FCB set to blanks if no extension in string
                1: extension left unchanged
        Return: AL = 00: no wildcards in name or extension
                     01: wildcards appeared
                DS:SI = pointer to first byte after parsed string
                ES:DI = unopened FCB
-----------------------------------------------------------
INT 21 - GET CURRENT DATE
        AH = 2AH
        Return: DL = DAY
                DH = MONTH
                CX = YEAR
                AL = DAY OF THE WEEK (0=SUNDAY, 1=MONDAY, ETC.)
-----------------------------------------------------------
INT 21 - Set CURRENT DATE
        AH = 2Bh
        DL = day
        DH = month
        CX = year
        Return: AL = 0 if no error
                AL = 0FFh if bad value sent to routine
        (DOS 3.3 also sets CMOS clock)
        (DESQview also accepts CX = 4445h and DX = 5351h, i.e. 'DESQ' as valid)
-----------------------------------------------------------
INT 21 - GET CURRENT TIME
        AH = 2CH
        Return: CH = HOURS
                CL = MINUTES
                DH = SEC
                DL = SEC/100
NOTE: TIME IS UPDATED EVERY 5/100 SECOND
-----------------------------------------------------------
INT 21 - Set CURRENT TIME
        AH = 2DH
        CH = HOURS
        CL = MINUTES
        DH = SEC
        DL = SEC/100
        Return: AL = 0 if no error
                AL = 0ffH if bad value sent to routine
        (DOS 3.3 also sets CMOS clock)
-----------------------------------------------------------
INT 21 - Set Verify Flag
        AH = 2EH
        DL = 0
        AL = 1 if VERIFY on
        AL = 0 if VERIFY off
-----------------------------------------------------------
INT 21 - Get Disk Transfer Area Address
        AH = 2FH
        Return: ES = SEGMENT address of DTA
                BX = OFFSET address of DTA
-----------------------------------------------------------
INT 21 - Get DOS Version
        AH = 30H
        Return: AL = Major Version number
                AH = Minor Version number
                BH = OEM number
                BL:CX = 24-bit user number
-----------------------------------------------------------
INT 21 - TERMINATE BUT STAY RESIDENT
        AH = 31H
        AL = EXIT CODE
        DX = PROGRAM SIZE, IN PARAGRAPHS
-----------------------------------------------------------
INT 21 - Internal - GET DRIVE PARAMETER BLOCK
        AH = 32H
        DL = DRIVE NUMBER
        0 = DEFAULT, 1 = A, ETC.
        Return: AL = 0FFH IF INVALID DRIVE NUMBER, ELSE
                DS:BX = ADDRESS OF DRIVE PARAMETER BLOCK.

                STRUCTURE OF DOS DRIVE PARAMETER BLOCK:

DPBLOCK         STRUCT          ;OFFSET
DISK_OFFSET     DB      ?       ;  0.  DRIVE NUMBER (0 = A, ETC.)
UNIT_OFFSET     DB      ?       ;  1.  UNIT NUMBER WITHIN DEVICE DRIVER
SECTOR_SIZE     DW      ?       ;  2.  NUMBER OF BYTES PER SECTOR
MAX_CLUSTER     DB      ?       ;  4.  LARGEST SECTOR NUMBER IN CLUSTER
                                ;      ADD ONE FOR NUMBER OF SECTORS/CLUSTER
LOG2_SECTORS    DB      ?       ;  5.  LOG BASE TWO OF THE CLUSTER SIZE
RESERVED        DW      ?       ;  6.  NUMBER OF RESERVED (BOOT) SECTORS
FAT_COUNT       DB      ?       ;  8.  NUMBER OF COPIES OF THE FAT
ROOT_COUNT      DW      ?       ;  9.  NUMBER OF ROOT DIRECTORY ENTRIES
DATA_START      DW      ?       ; 11.  FIRST SECTOR OF DATA ON MEDIUM
MAX_NUMBER      DW      ?       ; 13.  LARGEST POSSIBLE CLUSTER NUMBER
                                ;      SUBTRACT ONE FOR NUMBER OF CLUSTERS
FAT_SECTORS     DB      ?       ; 15.  NUMBER OF SECTORS IN ONE FAT COPY
ROOT_START      DW      ?       ; 16.  FIRST SECTOR OF ROOT DIRECTORY
DEVICE_ADDR     DD      ?       ; 18.  CORRESPONDING DEVICE DRIVER ADDRESS
DESCRIPTOR      DB      ?       ; 22.  MEDIA DESCRIPTOR BYTE FOR MEDIUM
VALID_BYTE      DB      ?       ; 23.  0FFH INDICATES BLOCK MUST BE REBUILT
NEXT_BLOCK      DD      ?       ; 24.  ADDRESS OF NEXT DEVICE BLOCK IN LIST

;       FROM THIS POINT ON, DOS 3 DIFFERS FROM 2:

                IF      DOS2
DIR_START       DW      ?       ; 28.  STARTING CLUSTER OF CURRENT DIRECTORY
                                ;      ZERO INDICATES THE ROOT DIRECTORY
PATH_NAME       DB      64 DUP (?)
                                ; 30.  ASCIIZ CURRENT DIRECTORY PATH STRING
                ELSE    DOS3
;               ON MY XT, THIS WAS ALWAYS:
                DW      0
                DW      0FFFFH
                ENDIF
DPBLOCK         ENDS
-----------------------------------------------------------
INT 21 - Get or Set CONTROL-BREAK
        AH = 33H
        AL = 0 for Get or 1 for Put
        DL = 0 for OFF or 1 for ON
        Return: DL = 0 if BREAK=OFF or 1 if BREAK=ON
                AL = FFH IF ERROR
-----------------------------------------------------------
INT 21 - Internal - Return CritSectFlag Pointer
        AH = 34H
        Return: ES:BX points to DOS "Critical Section Flag"

When byte pointed to is zero, DOS is supposed to be
safe to interrupt. NOT RELIABLE according to Chris Dunford.
Examination of DOS 2.10 code in this area
indicates that the byte immediately FOLLOWING this
"Critical Section Flag" must be 00 to permit the
PRINT.COM interrupt to be called. This suggests that
checking the WORD pointed to, rather than the BYTE,
might increase reliability of the test greatly.
-----------------------------------------------------------
INT 21 - Get Interrupt Vector
        AH = 35H
        AL = INT number
        Return: ES = Segment address of INT vector
                BX = Offset address of INT vector
-----------------------------------------------------------
INT 21 - DISK SPACE
        AH = 36H
        DL = DRIVE NUMBER (1-4)
        Return: AX = ? (SIDES)
                BX = ? (BLOCKS FREE)
                CX = ? (BLOCK SIZE)
                DX = ? (TOTAL BLOCKS)
NOTE: MULT AX x CX x BX for FREE SPACE ON DISK
MULT AX x CX x DX for TOTAL DISK SPACE
-----------------------------------------------------------
INT 21 - Internal - switchar/availdev
        AH = 37H
        AL =
        0 Read switch character (returns current character in DL)
        1 Set switch character (specify new character in DL)
        2 Read device availability (as set by function AL=3)
        3 Set device availability, where:
        DL = 0 means /DEV/ must preceed device names
        DL <> 0 means /DEV/ need not preceed device names
        Return: DL = Switch character (if AL=0 or 1)
                Device availability flag (if AL=2 or 3)
                AL=0FFh means the value in AL was not in the range 0-3.
Functions 2 & 3 appear not to be implemented for DOS 3.x
-----------------------------------------------------------
INT 21 - Get Country-Dependent Information
        AH = 38h
  DOS 2.x
        AL = 0  get current-country info
        DS:DX = segment:offset of buffer for returned info
        Return:
        BX = country code
        buffer at DS:DX filled as follows:
           bytes 0-1 = date format   0 = USA    mm dd yy
                                     1 = Europe dd mm yy
                                     2 = Japan  yy mm dd
           byte 2    = currency symbol
           byte 3    = 00h
           byte 4    = thousands separator char
           byte 5    = 00h
           byte 6    = decimal separator char
           byte 7    = 00h
           bytes 8-1Fh reserved

  DOS 3.x
        AL = 0 for current country
        AL = 01h thru 0FEh for specific country with code <255
        AL = 0FFh for specific country with code >= 255
           BX = 16-bit country code
        DS:DX = segment:offset of buffer for returned info
        DX = 0FFFFh if setting country code, rather than getting info
        Return: (if DX <> 0FFFFh)
           BX = country code
           DS:DX filled in:
              bytes 0-1 = date format (see above)
              bytes 2-6 = currency symbol string, ASCIZ
              byte 7    = thousands seaprator char
              byte 8    = 00h
              byte 9    = decimal separator char
              byte 0Ah  = 00h
              byte 0Bh  = date separator char
              byte 0Ch  = 00h
              byte 0Dh  = time separator char
              byte 0Eh  = 00h
              byte 0Fh  = currency format
                           bit 1 = number of spaces between value and curr sym
                           bit 0 = 0 if currency symbol precedes value
                                   1 if currency symbol follows value
              byte 10h  = number of digits after decimal in currency
              byte 11h  = time format
                           bit 0 = 0 if 12-hour clock
                                   1 if 24-hour clock
              bytes 12h-15h = address of case map routine (FAR CALL)
              byte 16h  = data-list separator char
              byte 17h  = 00h
              bytes 18h-21h reserved
         If error:
           CF set
           AX = error code
-----------------------------------------------------------
INT 21 - CREATE A SUBDIRECTORY (MKDIR)
        AH = 39H
        DS = SEGMENT address of ASCIIZ pathname
        DX = OFFSET address of ASCIIZ pathname
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - REMOVE A DIRECTORY ENTRY (RMDIR)
        AH = 3AH
        DS = SEGMENT address of ASCIIZ pathname
        DX = OFFSET address of ASCIIZ pathname
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - CHANGE THE CURRENT DIRECTORY (CHDIR)
        AH = 3BH
        DS = SEGMENT address of ASCIIZ
        DX = OFFSET address of ASCIIZ
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - CREATE A FILE WITH HANDLE (CREAT)
        AH = 3CH
        CX = ATTRIBUTES FOR FILE
        DS = SEGMENT ADDRESS OF ASCIIZ
        DX = OFFSET ADDRESS OF ASCIIZ
        Return: Flag CF = 1 if error
                AX = File Handle or Error Code
-----------------------------------------------------------
INT 21 - OPEN DISK FILE WITH HANDLE
        AH = 3DH
        AL = ACCESS CODE
                0 = Read Only
                1 = Write Only
                2 = Read/Write
                Options (3.x):
                        80H = no inheritance
                        10H = deny read/write
                        20H = deny write
                        30H = deny read
                        40H = deny none
        DS = SEGMENT ADDRESS OF ASCIIZ
        DX = OFFSET ADDRESS OF ASCIIZ
        Return: Flag CF = 1 if error
                AX = File Handle or Error Code
-----------------------------------------------------------
INT 21 - CLOSE A FILE WITH HANDLE
        AH = 3EH
        BX = FILE HANDLE
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - READ FROM FILE WITH HANDLE
        AH = 3FH
        BX = FILE HANDLE
        CX = NO. OF BYTES TO READ
        DS = SEGMENT ADDRESS OF BUFFER
        DX = OFFSET ADDRESS OF BUFFER
        Return: Flag CF = 1 if error
                AX = Bytes Read or Error Code
-----------------------------------------------------------
INT 21 - WRITE TO FILE WITH HANDLE
        AH = 40H
        BX = FILE HANDLE
        CX = NO. OF BYTES TO Write
        DS = SEGMENT ADDRESS OF BUFFER
        DX = OFFSET ADDRESS OF BUFFER
        Return: Flag CF = 1 if error
                AX = Bytes Read or Error Code
-----------------------------------------------------------
INT 21 - DELETE A FILE (UNLINK)
        AH = 41H
        DS = SEGMENT OF ASCIIZ TO DELETE
        DX = OFFSET OF ASCIIZ TO DELETE
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - MOVE FILE READ/WRITE POINTER (LSEEK)
        AH = 42H
        AL = METHOD VALUE
                0 = offset from beginning of file
                1 = offset from present location
                2 = offset from end of file
        BX = FILE HANDLE
        CX = BYTES OFFSET HIGH
        DX = BYTES OFFSET LOW
        Return: Flag CF = 1 if error
                AX = Offset low word or Error Code
                DX = Offset high word
-----------------------------------------------------------
INT 21 - GET/PUT FILE ATTRIBUTES (CHMOD)
        AH = 43H
        AL =
        0 = GET FILE ATTRIBUTES
        1 = PUT FILE ATTRIBUTES
        CX = FILE ATTRIBUTES BITS ON PUT
        0 = READ ONLY
        1 = HIDDEN FILE
        2 = SYSTEM FILE
        3 = VOLUME LABEL
        4 = SUBDIRECTORY
        5 = WRITTEN SINCE BACKUP
        DX = POINTER TO FILE ASCIIZ FILE NAME
        Return: Flag CF = 1 if error
                AX = Error Code if any
                CX = FILE ATTRIBUTES ON GET
-----------------------------------------------------------
INT 21 - IOCTL
        AH = 44H
        AL =
        0 = Get device information (DX)
        1 = Set device information (DL, DH = 0)
                DX BITS =
                0 = console input device
                1 = console output device
                2 = null device
                3 = clock device
                5 = binary mode
                6 = EOF
                7 = is device
                        if not, EOF = 0 if channel has been written
                        bits 0-5 are block device number
                12= network device
                14= can process control strings (AL=2-5)

        2 = Read CX bytes to DS:DX from BX control chan
        3 = Write CX bytes from DS:DX from BX control chan
        4 = as 2 but for drive BL
        5 = as 3 but for drive BL
                AX = number of bytes transfered

        6 = Get input status
        7 = Get output status
                AX = FFH for ready or 00H for not ready

        8 = Is block device BL changeable? (DOS 3)
                AX = 0 = yes
        9 = Is logical device BL local? (DOS 3)
                DX (attribute word) bit 12 (1000H) = 0 = yes
        10= Is handle BX local? (DOS 3)
                DX (attribute word) bit 15 (8000H) = 0 = yes
        11= Change sharing retry count to DX (def 3), (DOS 3)
                delay CX (def 1)
        12= General IOCTL (DOS 3.3 [3.2?])
        BX = file handle (or BL = drive number w/0 = default)
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Create Duplicate Handle (DUP)
        AH = 45H
        BX = file handle to duplicate
        Return: Flag CF = 1 if error
                AX = File handle or Error Code
-----------------------------------------------------------
INT 21 - Force Duplicate Handle (FORCDUP) (DUP2)
        AH = 46H
        BX = Existing file handle
        CX = new file handle
        Return: Flag CF = 1 if error
                AX = File handle or Error Code
-----------------------------------------------------------
INT 21 - Get Current Directory
        AH = 47H
        DL = drive (0=default, 1=A, etc.)
        DS:SI points to 64-byte buffer area
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Allocate Memory
        AH = 48H
        BX = number of 16-byte paragraphs desired
        Return: Flag CF = 1 if error
                AX = Segment of allocated memory or Error Code
                BX = Maximum available on error
-----------------------------------------------------------
INT 21 - Free Memory
        AH = 49H
        ES = Segment address of area to be freed
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Adjust Block Size (SETBLOCK)
        AH = 4AH
        ES = Segment address of block to change
        BX = New size in paragraphs
        Return: Flag CF = 1 if error
                AX = Error Code if any
                BX = Maximum available on error
-----------------------------------------------------------
INT 21 - Load or Execute (EXEC)
        AH = 4BH
        AL =
                0 = load and execute program
                2 = load (Internal) but do not execute
                3 = load overlay; do not create PSP
        DS:DX = filename
        ES:BX = parameter block
                AL =
                0 =>    word segment environment pointer
                        dword command line pointer
                        dword FCB 1
                        dword FCB 2
                3 =>    word segment load address
                        word segment relocation factor
        Return: Flag CF = 1 if error
                AX = Error Code if any

struct exec {
        unsigned exec_magic;    /* 0x4d, 0x5a signature */
        unsigned exec_isr;      /* image size remainder (mod 512) */
        unsigned exec_size;     /* file size in pages (512) */
        unsigned exec_nrel;     /* number of relocation items */
        unsigned exec_hsize;    /* header size in paragraphs */
        unsigned exec_min;      /* minimum extra paragraphs */
        unsigned exec_max;      /* maximum extra paragraphs */
        unsigned exec_ss;       /* stack segment */
        unsigned exec_sp;       /* stack offset */
        unsigned exec_cksum;    /* word checksum of entire file */
        unsigned exec_pc;       /* initial pc */
        unsigned exec_cs;       /* code segment */
        unsigned exec_orel;     /* offset of relocation table */
        unsigned exec_ovno;     /* overlay number */
};
-----------------------------------------------------------
INT 21 - Quit With Exit Code (EXIT)
        AH = 4CH
        AL = exit code
-----------------------------------------------------------
INT 21 - GET EXIT CODE OF SUBPROGRAM (WAIT)
        AH = 4DH
        Return: AL = exit code of subprogram (FNs 31H or 4cH)
                AH = circumstance which caused termination
                        0 = Terminate/abort
                        1 = Control-C
                        2 = Hard error
                        3 = Terminate and stay resident
-----------------------------------------------------------
INT 21 - Find First ASCIIZ (FIND FIRST)
        AH = 4EH
        CX = SEARCH ATTRIBUTES
        DS:DX = POINTER TO ASCIIZ FILENAME (WITH ATTRIBUTES)
        Return: Flag CF = 1 if error
                AX = Error Code if any
                (DTA) = data block
-----------------------------------------------------------
INT 21 - Find Next ASCIIZ (FIND NEXT)
        AH = 4FH
        Return: Flag CF = 1 if error
                AX = Error Code if any
                (DTA) = data block
-----------------------------------------------------------
INT 21 - Internal - Set PSP Segment
        AH = 50H
        BX = Segment address of new PSP
-----------------------------------------------------------
INT 21 - Internal - Get PSP Segment
        AH = 51H
        Return: BX = Current PSP Segment

struct psp {
        char psp_int20[2];      /* 00h: exit */
        unsigned psp_msize;     /* 02h: memory size in paragraphs */
        char psp_res0[1];       /* 04h: XXX (0) */
        char psp_dos[5];        /* 05h: far call to dos */
        int (*psp_term)();      /* 0ah: terminate address */
        unsigned psp_tseg;      /* 0ch: terminate segment */
        int (*psp_break)();     /* 0eh: break address */
        unsigned psp_bseg;      /* 10h: break segment */
        int (*psp_error)();     /* 12h: error address */
        unsigned psp_eseg;      /* 14h: error segment */
        unsigned psp_ppsp;      /* 16h: parent psp segment */
        char psp_ofile[20];     /* 18h: open files, 0xff = unused */
        unsigned psp_envp;      /* 2ch: environment segment */
        char psp_res2[4];       /* 2eh: XXX */
        int psp_nfiles;         /* 32h: max open files */
        char *psp_aofile;       /* 34h: ofile address */
        unsigned psp_aoseg;     /* 36h: ofile segment */
        char psp_res3[24];      /* 38h: XXX */
        char psp_int21[3];      /* 50h: int 21, far return */
        char psp_res4[2];       /* 53h: XXX */
        char psp_xfcb1[7];      /* 55h: FCB #1 extension */
        char psp_fcb1[9];       /* 5ch: FCB #1 */
        char psp_xfcb2[7];      /* 65h: FCB #2 extension */
        char psp_fcb2[20];      /* 6ch: FCB #2 */
        char psp_dma[128];      /* 80h: Command Tail */
};
-----------------------------------------------------------
INT 21 - Internal - Get Disk List
        AH = 52H
        Return: ES:BX points to DOS list of lists

List of Lists:
Bytes   Value
-2&-1   Segment of first memory control block
0-3     Pointer to first DOS disk block (see func 36H)
4-7     Partially Unknown. Pointer to a device driver. Maybe first
               resident driver?
8-B     Pointer to CLOCK$ device driver, whether installable or
               resident
C-F     Pointer to actual CON: device driver, whether installable
               or resident
-----DOS 2.x
10      Number of logical drives in system
11-12   Maximum bytes/block of any block device
13-16   unknown
17      Beginning (not a pointer. The real beginning!) of NUL device
           driver. This is the first device on DOS's linked list
           of device drivers.
-----DOS 3.x
10-11   Maximum bytes/block of any block device (0200H)
12-15   Unknown. Pointer to current directory block????
16-19   Partially Undefined: Pointer to array of drive info:
               51H bytes per drive, starting with A: ...
               00-3F Current path as ASCIIZ, starting with 'x:\'
               40-43 Unknown. I see zeros always
               44    Unknown. Flags? I see 40H, except for
                       entry after last valid entry = 00H
               45-48 Pointer to DOS Disk Block for this drive
               49-4A Unknown. Current track or block? -1 if never
                       accessed.
               4B-4E Unknown. I see -1 always
               4F-52 Unknown. I see 2 always
1A-1D   Unknown. Pointer to data area, maybe including cluster
               allocation table?
1E-1F   Unknown. I see zero always
20      Number of block devices.
21      Value of LASTDRIVE command in CONFIG.SYS (default 5)
22      Beginning (not a pointer. The real beginning!) of NUL device
           driver. This is the first device on DOS's linked list
           of device drivers.
-----------------------------------------------------------
INT 21 - Internal - Translate BPB
        AH = 53H
        DS:SI points to BPB (Bios Parameter Block)
        ES:BP points to area for DOS Disk Block
Translates BPB (Bios Parameter Block, see below)
into a DOS Disk Block (see function call 32h).

BPB
Bytes   Value
0-1     Bytes/sector. Get from DDB bytes 2-3.
2       Sectors/cluster. Get from: (DDB byte 4) + 1
3-4     Reserved sectors. Get from: DDB bytes 6-7
5       Number of FATs. Get from: DDB byte 8
6-7     Number of root dir entries. Get from: DDB bytes 9-A
8-9     Total # of sectors. Get from:
        ((DDB bytes D-E) - 1) * (sectors per cluster (BPB byte 2))
          + (DDB Bytes B-C)
A       Media descriptor byte. Get from: DDB byte 16
B-C     Number of sectors/FAT. Get from: DDB byte F
-----------------------------------------------------------
INT 21 - Get Verify Flag
        AH = 54H
        Return: AL = 0 if flag OFF
                AL = 1 if flag ON
-----------------------------------------------------------
INT 21 - Internal - Create PSP
        AH = 55H
        DX = Segment number to set up PSP at
Like FN 26H but creates "child" PSP rather
than copying existing one.
-----------------------------------------------------------
INT 21 - RENAME A FILE
        AH = 56H
        DS = SEGMENT OF ASCIIZ OLD NAME
        DX = OFFSET OF ASCIIZ OLD NAME
        ES = SEGMENT OF ASCIIZ NEW NAME
        DI = OFFSET OF ASCIIZ NEW NAME
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Get/Put Date/Time
        AH = 57H
        AL = FUNCTION CODE
                0 = GET DATE AND TIME
                1 = SET DATE AND TIME
        BX = FILE HANDLE
        CX = TIME TO BE SET (IF AL = 1)
        DX = DATE TO BE SET (IF AL = 1)
        Return: Flag CF = 1 if error
                AX = Error Code if any
                CX = TIME OF LAST WRITE (IF AL = 0)
                DX = DATE OF LAST WRITE (IF AL = 0)
-----------------------------------------------------------
INT 21 - Get/Set allocation strategy (DOS 3.x)
        AH = 58H
        AL = FUNCTION CODE
                0 = GET ALLOCATION STRATEGY
                1 = SET ALLOCATION STRATEGY
        BX = STRATEGY CODE (IF AL = 1)
                0 = first fit
                1 = best fit
                2 = last fit
        Return: Flag CF = 1 if error
                AX = Strategy code or Error Code
-----------------------------------------------------------
INT 21 - GET EXTENDED ERROR CODE (DOS 3.X)
        AH = 59H
        BX = VERSION CODE (0000 FOR DOS 3.0)
        Return: AX = EXTENDED ERROR CODE
                BH = CLASS OF ERROR
                BL = SUGGESTED ACTION CODE
                CH = LOCUS (WHERE ERROR OCCURRED)
        Error codes:
                01 function number invalid
                02 file not found
                03 path not found
                04 too many open files
                05 access denied
                06 invalid handle
                07 memory control block destroyed
                08 insufficient memory
                09 memory block address invalid
                0A environment invalid
                0B format invalid
                0C access code invalid
                0D data invalid
                0F invalid drive
                10 attempted to remove current directory
                11 not same device
                12 no more files
                13 disk write-protected
                14 unknown unit
                15 drive not ready
                16 unknown command
                17 data error (CRC)
                18 bad request structure length
                19 seek error
                1A unknwon media type
                1B sector not found
                1C printer out of paper
                1D write fault
                1E read fault
                1F general failure
                20 sharing violation
                21 lock violation
                22 disk change invalid
                23 FCB unavailable
                24-31 reserved
                32 Network request not supported (DOS 3.1 + MS Networks)
                33 Remote computer not listening
                34 Duplicate name on network
                35 Network name not found
                36 Network busy
                37 Network device no longer exists
                38 Network BIOS command limit exceeded
                39 Network adapter hardware error
                3A Incorrect response from network
                3B Unexpected network error
                3C Incompatible remote adapter
                3D Print queue full
                3E Queue not full
                3F Not enough space to print file
                40 Network name was deleted
                41 Network: Access denied
                42 Network device type incorrect
                43 Network name not found
                44 Network name limit exceeded
                45 Network BIOS session limit exceeded
                46 Temporarily paused
                47 Network request not accepted
                48 Print/disk redirection paused (DOS 3.1 + MS Networks)
                49-4F reserved
                50 file exists
                51 reserved
                52 cannot make directory
                53 fail on INT 24h
        Error Classes:
                01 out of resource
                02 temporary situation
                03 authorization (denied access)
                04 internal
                05 hardware failure
                06 system failure
                07 application program error
                08 not found
                09 bad format
                0A locked
                0B media error
                0C already exists
                0D unknown
        Suggested Action:
                01 retry
                02 delayed retry
                03 prompt user
                04 abort after cleanup
                05 immediate abort
                06 ignore
                07 retry after user intervention
        Error Locus:
                01 unknown or not appropriate
                02 block device
                03 network related
                04 serial device
                05 memory related
-----------------------------------------------------------
INT 21 - CREATE TMEPORARY FILE (DOS 3.x)
        AH = 5AH
        DS:DX = POINTER TO DIRECTORY PATH NAME
        CX = FILE ATTRIBUTE
        Return: Flag CF = 1 if error
                AX = Error Code if any
                DS:DX = PATH NAME

NOTE: THE FILE CREATED IS NOT TRULY "TEMPORARY". IT MUST BE
REMOVED BY THE USER.
-----------------------------------------------------------
INT 21 - CREATE NEW FILE (DOS 3.x)
        AH = 5BH
        DS:DX = POINTER TO DIRECTORY PATH NAME
        CX = FILE ATTRIBUTE
        Return: Flag CF = 1 if error
                AX = Error Code if any
                DS:DX = PATH NAME

NOTE: UNLIKE FUNCTION 3CH, FUNCTION 5BH WILL FAIL IF THE FILE
ALREADY EXISTS.
-----------------------------------------------------------
INT 21 - LOCK/UNLOCK FILE ACCESS (DOS 3.x)
        AH = 5CH
        AL =
                0 IF LOCK
                1 IF UNLOCK
        BX = FILE HANDLE
        CX:DX = OFFSET TO LOCK
        SI:DI = AMOUNT TO LOCK
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Internal - Unknown
        AH = 5DH XXX
-----------------------------------------------------------
INT 21 - Get Machine Name (DOS 3.1 + Microsoft Networks)
        AX = 5E00H
        DS:DX -> buffer for ASCIIZ name
        Return: Flag CF = 1 if error
                AX = Error Code if any
                CH = 0 if name not defined
                CL = NETBIOS name number
                DS:DX -> pointer to identifier if CH <> 0
-----------------------------------------------------------
INT 21 - Set Printer Setup (DOS 3.1 + Microsoft Networks)
        AX = 5E02H
        BX = Redirection list index
        CX = length of setup string <= 64
        DS:SI -> string buffer
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Get Printer Setup (DOS 3.1 + Microsoft Networks)
        AX = 5E03H
        BX = Redirection list index
        ES:DI -> string buffer
        Return: Flag CF = 1 if error
                AX = Error Code if any
                CX = length of setup string <= 64
-----------------------------------------------------------
INT 21 - Get Redirection List Entry (DOS 3.1 + Microsoft Networks)
        AX = 5F02H
        BX = Redirection list index
        DS:SI -> 16 char local device name buffer
        ES:DI -> 128 char network name buffer
        Return: Flag CF = 1 if error
                AX = Error Code if any
                BH = Device status flag (BIT 0 = 0 if valid)
                BL = device type (03 if printer, 04 if drive)
                CX = stored param value
                DX, BP destroyed
-----------------------------------------------------------
INT 21 - Redirect Device (DOS 3.1 + Microsoft Networks)
        AX = 5F03H
        BL = device type
                03 = printer device
                04 = file device
        CX = stored param value
        DS:SI -> source device name
        ES:DI -> destination ASCIIZ network path + ASCIIZ password
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Cancel Redirection (DOS 3.1 + Microsoft Networks)
        AX = 5F04H
        DS:SI -> device name or network path
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 21 - Internal - Resolve path string to fully qualified path string
        AH = 60h
        DI:SI = relative path strings
        ES:DI = buffer for fully qualified name
        Returns: buffer filled with qualified name
                 may return error code, unknown.
-----------------------------------------------------------
INT 21 - Internal - Unknown
        AH = 61H
        Returns AL = 0 in DOS 3.1 (unused function)
-----------------------------------------------------------
INT 21 - GET PSP ADDRESS (DOS 3.x)
        AH = 62H
        Return: BX = SEGMENT ADDRESS OF PSP
-----------------------------------------------------------
INT 21 - GET LEAD BYTE TABLE (DOS 2.25 only)
        AH = 63H
        AL = SUBFUNCTION
                0 = get system lead byte table
                1 = set/clear interim console flag
                2 = get interim console flag
        DL = 1/0 to set/clear interim console flag
        Return: DS:SI -> lead byte table (AL = 0)
                DL = interim console flag (AL = 2)
-----------------------------------------------------------
INT 21 - Internal - unknown (DOS 3.3)
        AH = 64h
-----------------------------------------------------------
INT 21 - GET EXTENDED COUNTRY INFORMATION (DOS 3.3)
        AH = 65h
        AL = info ID (1 - 6)
        BX = code page (-1=global code page)
        DX = country ID (-1=current country)
        ES:DI = pointer to country information buffer
        CX = size of buffer
        Return: AX = error code if carry set, otherwise
                CX = size of country information returned
                ES:DI = pointer to country information:
                        1 BYTE info ID
                        if info ID <> 1
                        1 DWORD pointer to information
                           if info ID == 1
                        1 WORD size
                        1 WORD country ID
                        1 WORD code page
                       34 BYTE see function 38h
-----------------------------------------------------------
INT 21 - GET/SET GLOBAL CODE PAGE TABLE (DOS 3.3)
        AH = 66h
        AL = 00h get global code page
             Return: AX = error code if carry flag set
                     BX = active code page
                     DX = system code page
           = 01h set global page
             BX = active code page
             DX = system code page (active page at boot time)
             Return: AX = error code if carry flag set
-----------------------------------------------------------
INT 21 - SET HANDLE COUNT (DOS 3.3)
        AH = 67h
        BX = desired number of handles (max 255)
        Return: Carry clear if ok
                Carry set if error (and error code in AX)
-----------------------------------------------------------
INT 21 - COMMIT FILE - WRITE ALL BUFFERED DATA TO DISK (DOS 3.3)
        AH = 68H
        BX = file handle
        Return: carry flag set on error (and error code in AX)
-----------------------------------------------------------
INT 21 - DoubleDos -
        AX = E400h
        Return: AL <> 0 if DoubleDos is active
-----------------------------------------------------------
INT 21 - DoubleDos - Turn off Task Switching
        AH = EAh
        Return: task switching turned off
-----------------------------------------------------------
INT 21 - DoubleDos - Turn on Task Switching
        AH = EBh
        Return: task switching turned on
-----------------------------------------------------------
INT 21 - DoubleDos - Get Virtual Screen Address
        AH = ECh
        Return: ES = segment of virtual screen
                Screen address can change if task-switching is on!!
-----------------------------------------------------------
INT 21 - DoubleDos - Give away time to other tasks
        AH = EEh
        AL = number of 55ms time slices to give away
        Return: returns after giving away time slices
-----------------------------------------------------------
INT 21 - CED installable commands
        AH = 0FFH
           AL = 0 add installable command
             BL = mode - bit 0 = 1 callable from DOS prompt
                         bit 1 = 1 callable from application
             DS:SI pointer to CR-terminated command name
             ES:DI pointer to FAR routine entry point
           AL = 1 remove installable command
             DS:SI pointer to CR-terminated command name
           AL = 2 reserved, may be used to test for CED installation
        Returns:
           CF set on error
             AX = 1 invalid function
                  2 command not found (subfunction 1 only)
                  8 insufficient memory (subfunction 0 only)
                 0Eh bad data (subfunction 0 only)
           AH = 0FFh if CED not installed
-----------------------------------------------------------
INT 22 - TERMINATE ADDRESS
FAR (DWORD) address of routine to be executed
when program "returns to DOS". Should NEVER be called directly.
-----------------------------------------------------------
INT 23 - CONTROL "C" EXIT ADDRESS
Automatically called from keyboard scanner when
CTRL-C or CTRL-BREAK is detected. Normally aborts program
and returns to DOS, but may be changed.
-----------------------------------------------------------
INT 24 - FATAL ERROR ABORT ADDRESS
Automatically called upon detection of unrecoverable
disk error. Normally prints "Abort, Retry, or Ignore?" message
and takes the reply, but may be changed if desired.

Provides the following values in registers on entry to interrupt handler:
        AH: bit 7 = 0 disk I/O error
                  = 1 other error -- if block device, bad FAT
                                  -- if char device, code in DI
            bit 6  unused
            bit 5 = 1 if Ignore allowed, 0 if not (DOS 3.2)
            bit 4 = 1 if Retry allowed, 0 if not (DOS 3.2?)
            bit 3 = 1 if Fail allowed, 0 if not (DOS 3.2)
            bit 2 \ disk area of error  00 = DOS area  01 = FAT
            bit 1 /                     10 = root dir  11 = data area
            bit 0 = 1 if write, 0 if read
        AL = drive number if AH bit 7 = 1, otherwise undefined
        BP:SI = address of device header for which error occurred
            block device if high bit of BP:SI+4 = 1
        low byte of DI:
           00 = write-protect error
           01 = unknown unit
           02 = drive not ready
           03 = unknown command
           04 = data error (bad CRC)
           05 = bad request structure length
           06 = seek error
           07 = unknown media type
           08 = sector not found
           09 = printer out of paper
           0A = write fault
           0B = read fault
           0C = general failure
           0F = invalid disk change (DOS 3.x)
Handler must return
        AL = 00  ignore error
           = 01  retry operation
           = 02  terminate program through INT 23
           = 03  fail system call in progress (DOS 3.2)
-----------------------------------------------------------
INT 25 - ABSOLUTE DISK READ
        AL = Drive number (0=A, 1=B, etc)
        DS:BX = Disk Transfer Address (buffer)
        CX = Number of sectors to read
        DX = First relative sector to read
        Return: Flag CF = 1 if error
                AL = error code issued to INT 24h in low half of DI
                AH = 80h if attachment failed to respond
                     40h if seek operation failed
                     20h if controller failed
                     10h if data error (bad CRC)
                     08h if DMA failure
                     04h if requested sector not found
                     03h if write-protected disk
                     02h if bad address mark
                     01h if bad command
       ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 26 - ABSOLUTE DISK WRITE
        AL = Drive number (0=A, 1=B, etc)
        DS:BX = Disk Transfer Address (buffer)
        CX = Number of sectors to write
        DX = First relative sector to write
        Return: Flag CF = 1 if error
                AL = error code issued to INT 24h in low half of DI
                AH = same error codes as for INT 25h
        ORIGINAL FLAGS ON STACK!
-----------------------------------------------------------
INT 27 - TERMINATE BUT STAY RESIDENT
        CS = CURRENT PROGRAM SEGMENT
        DX = LAST PROGRAM BYTE + 1
-----------------------------------------------------------
INT 28 - Internal - Keyboard Busy Loop
This interrupt is called from inside the "get input
from keyboard" routine in DOS, if and only if it is safe to use
INT 21 to access the disk at that time. It is used primarily by
the PRINT.COM routines, but any number of other routines could
be chained to it by saving the original vector, and calling it
with a FAR call (or just JMPing to it) at the end of the new
routine.
Until PRINT.COM installs its own routine, this
interrupt vector simply points to an IRET opcode.
-----------------------------------------------------------
INT 29 - Internal - Fast Putchar
This interrupt is called from the DOS output routines
if output is going to a device rather than a file, and the
device driver's attribute word has bit 3 (04H) set to "1".
-----------------------------------------------------------
INT 2A - Network Installation Check (Microsoft Networks)
        AH = 00H
        Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2A - Check Direct I/O (Microsoft Networks)
        AX = 0300H
        DS:SI -> ASCIIZ disk device name
        Return: CF == 0 if allowed
-----------------------------------------------------------
INT 2A - Execute NETBIOS (Microsoft Networks)
        AH = 04H
        AL = 0 for error retry, 1 for no retry
        ES:BX -> NCB
        Return: AX = 0 for no error
                AH = 1, AL = error code
-----------------------------------------------------------
INT 2A - Get Network Resource Information (Microsoft Networks)
        AX = 0500H
        Return: AX = reserved
                BX = # network names
                CX = # commands
                DX = # sessions
-----------------------------------------------------------
INT 2B - Internal routine for MSDOS (IRET) XXX
-----------------------------------------------------------
INT 2C - Internal routine for MSDOS (IRET) XXX
-----------------------------------------------------------
INT 2D - Internal routine for MSDOS (IRET) XXX
-----------------------------------------------------------
INT 2E - Internal - Execute Command
        ES:SI -> counted CR-terminated command string

The top-level command.com executes the command; all
registers are destroyed as in exec.
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Installation Check
        AX = 0100H
        Return: AL =
                FFH if installed
                01H if not installed, not OK to install
                00H if not installed, OK to install
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Submit file
        AX = 0101H
        DS:DX -> packet of one byte level and DWORD file pointer
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Remove file
        AX = 0102H
        DS:DX -> file name (wildcards allowed)
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Remove all files
        AX = 0103H
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Hold queue/Get status
        AX = 0104H
        Return: Flag CF = 1 if error
                AX = Error Code if any
                    1 if function invalid
                    2 if file not found
                    3 if path not found
                    4 if too many open files
                    5 if access denied
                    8 if queue full
                    9 if spooler busy
                   0Ch if name too long
                   0Fh if drive invalid
                DX = Error count
                DS:SI -> print queue (null-string terminated
                        list of 64-byte ASCIZ file names)
-----------------------------------------------------------
INT 2F - Multiplexor - PRINT Restart queue
        AX = 0105H
        Return: Flag CF = 1 if error
                AX = Error Code if any
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN Installation Check
        AX = 0600H
        Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - ASSIGN
        AX = 0601H XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 10H XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 11H XXX
-----------------------------------------------------------
INT 2F - Multiplexor - MSDOS Internal
        AH = 12H XXX
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND Installation Check
        AX = B700H
        Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - APPEND
        AX = B701H XXX
-----------------------------------------------------------
INT 2F - Multiplexor - Network Program Installation Check
        AX = B800H
        Return: AH <> 0 if installed
-----------------------------------------------------------
INT 2F - Multiplexor - Get Current Post Address
        AX = B803H
        Return: ES:BX = post address
-----------------------------------------------------------
INT 2F - Multiplexor - Set New Post Address
        AX = B804H
        ES:BX = new post address
-----------------------------------------------------------
INT 30 -> (NOT A VECTOR!) FAR jump instruction for CP/M-style calls
INT 31
-----------------------------------------------------------
INT 32 -> not used
-----------------------------------------------------------
INT 33 -> USED BY MICROSOFT MOUSE
-----------------------------------------------------------
INT 40 -> Relocated (by fixed disk) Floppy Handler (original INT 13h)
-----------------------------------------------------------
INT 41 -> Fixed Disk Params
        dw      cylinders
        db      heads
        dw      0
        dw      write pre-comp
        db      0
        db      0 "control byte"
        db      0, 0, 0
        dw      landing zone
        db      sectors/track
        db      0
-----------------------------------------------------------
INT 42 -> Relocated (by EGA) Video Handler (original INT 10h)
-----------------------------------------------------------
INT 43 -> EGA Initialization Params
-----------------------------------------------------------
INT 44 -> EGA/PCjr fonts
-----------------------------------------------------------
INT 45 -> reserved
-----------------------------------------------------------
INT 46 -> Secondary Fixed Disk Params (see INT 41h)
-----------------------------------------------------------
INT 47 -> reserved
-----------------------------------------------------------
INT 48 -> PCjr Cordless Keyboard Translation
-----------------------------------------------------------
INT 49 -> PCjr Non-keyboard Scan Code Translation Table
-----------------------------------------------------------
INT 4A -> AT User Alarm
-----------------------------------------------------------
INT 4B -> reserved
-----------------------------------------------------------
INT 4C -> reserved
-----------------------------------------------------------
INT 4D -> reserved
-----------------------------------------------------------
INT 4E -> reserved
-----------------------------------------------------------
INT 4F -> reserved
-----------------------------------------------------------
INT 50-57 -> IRQ0-IRQ7 relocated by DESQview
-----------------------------------------------------------
INT 5C - NETBIOS interface
        ES:BX -> Network Control Block
-----------------------------------------------------------
INT 70 thru 77 - AT Vectored Hardware Lines
        IRQ8    -       real-time clock
        IRQ9    -       LAN adapter 1 (rerouted to INT 0Ah by BIOS)
        IRQ10   -       reserved
        IRQ11   -       reserved
        IRQ12   -       reserved
        IRQ13   -       80287 error (rerouted to INT 2 by BIOS)
        IRQ14   -       fixed disk
        IRQ15   -       reserved
-----------------------------------------------------------
INT 86 - Relocated (by NETBIOS) INT 18
-----------------------------------------------------------
INT F8 - INTERVAL TIMER (10 MSEC)
-----------------------------------------------------------
INT FA - USART READY (RS-232C)
-----------------------------------------------------------
INT FB - USART Rx READY (keyboard)
-----------------------------------------------------------
%
