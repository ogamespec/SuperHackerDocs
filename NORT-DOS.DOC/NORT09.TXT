                ГЛАВА 9. ВИДЕОДОСТУП 2 - ГРАФИЧЕСКИЙ РЕЖИМ


              После  завершения  обсуждения  основ  видеопредставления
         информации и собственно текстового  режима  в  предшествующей
         главе,   перейдем   к   рассмотрению  особенностей  работы  в
         графическом режиме.
              Не  следует  удивляться  сложности  предмета   "машинная
         графика". Сама по себе графика - вещь непростая; здесь же она
         осложняется чисто техническими аспектами, такими как цветовые
         палитры,  многочисленные режимы м хранимые образы содержимого
         экрана. Это сложный, многоаспектный вопрос. В  рамках  данной
         главы мы не будем углубляться в детали. Если в Ваши намерения
         входит использование графического режима  IBM/PC  или  просто
         изучение  основ  предмета,  то  следует  продолжать чтение. В
         противном случае, материал настоящей главы может быть опущен.
              Все сказанное ниже распространяется на компьютер IBM/PC,
         а  также  на  все  совместимые  с  ним  компьютеры (последние
         предполагают возможность выполнения произвольной программы, в
         том  числе  и  графической, написанной для IBM/PC). Если речь
         идет о компьютерах, использующих операционную систему MS-DOS,
         то большинство положений нуждается в уточнениях.

              9.1. Основы машинной графики

              Существует два основных способа формирования графических
         изображений на видеомониторе.  Причудливый  мир  компьютерных
         (экранных)    игр   позволяет   получить   о   них   какое-то
         представление, оценить их место, роль и возможности. (Ниже об
         этом   еще  пойдет  речь,  однако  следует  все  это  увидеть
         собственными глазами.)
              Эти  способы  основываются  либо  на  векторном, либо на
         растровом  (точечном,  пиксельном)   принципах   формирования
         изображений,  далее именуемых просто векторной или пиксельной
         графикой. Графика IBM/PC -  это  пиксельная  графика;  именно
         этому виду графики мы уделим основное внимание.
              (Термин  "вектор",  кстати,  уже  использовался нами при
         рассмотрении прерываний. Там он обозначал два машинных слова,
         содержащих адрес программы, выполняющей обработку прерываний;
         здесь под "вектором" понимается отрезок прямой. И  первая,  и
         вторая   интерпретация  термина  имеют  чисто  математические
         параллели, с которыми мы не будем далее соприкасаться.  Здесь
         нам важно эти термины не смешивать).
              При построении изображений на экране дисплея  средствами
         векторной  графики  используются только прямые. В этом случае
         машинная программа специфицирует две крайние точки прямой,  а
         собственно дисплей "проводит" между ними прямую.
              Если взять обычный экран дисплея - будь то телевизионный
         приемник  или  компьютерный терминал - то в случае растрового
         сканирования  электронный   луч,   генерирующий   изображение
         перемещается  по  стандартному  шаблону, образуемому строками
         развертки,  заполняющими  весь  экран.  В   случае   дисплея,
         работающего   на  принципах  векторной  графики,  перемещение
         электронного  луча  осуществляется   по   команде,   рисующей
         заданную  прямую  между  заданными  точками. В рамках системы
         векторного   сканирования,  перемещение   электронного   луча
         осуществляется  по заданной в каждом случае  траектории, а не
         по раз и навсегда установленному шаблону.
              Векторная    графика    обладает    рядом   существенных
         преимуществ - ей присущи  высокая  четкость,  и  точность,  а
         также  сравнительно высокое быстродействие. Все это делает ее
         эффективной  в  сфере  инженерной  графики,   а   также   при
         построении  особенно сложных или точных графических дисплеев.
         Однако векторно-графические  системы  используются  лишь  для
         вычерчивания  прямых  (или  изображений,  которые  могут быть
         представлены в виде совокупности коротких отрезков).В  рамках
         этой  системы  оказывается  невозможным заполнять изображения
         цветом сложной формы. Это сильно сужает область их  возможных
         применений.
              В  основе  растровой или пиксельной графики лежит другой
         принцип. Экран дисплея  здесь  разделяется  на  прямоугольную
         сетку,    состоящую   из   множества   мельчайших   элементов
         изображения, называемых также пикселями  или  пэлами.  Каждый
         пиксель   обладает   свойством   светимости.   Таким  образом
         изображение синтезируется из множества отдельных точек.
              Размеры  пикселей  и  расстояния  между  ними  тщательно
         рассчитываются таким образом,  чтобы  промежутки  между  ними
         отсутствовали.  Если  группа  смежных  пикселей  находится  в
         возбужденном состоянии (т.е. светится), то они воспринимаются
         глазом  не  как  совокупность отдельных точек, а как сплошной
         участок. Если бы точки были  достаточно  малы,  то  этот  тип
         дисплея  мог бы конкурировать с векторным по части четкости и
         точности,  однако,  у  большинства  растровых  дисплеев  этот
         показатель оставляет желать лучшего.
              В  принципе,  любая  система  машинной   графики   может
         обеспечить  воспроизведение  цвета,  однако, чаще всего, цвет
         ассоциируется с растровой графикой. Цвет - это веский (но  не
         единственный)   аргумент   в   пользу   превосходства  систем
         растровой графики над системами векторной графики в игровой и
         деловой  сферах.  Способность воспроизводить сплошные, прямо-
         криволинейные поверхности в цвете  делает  растровую  графику
         намного  предпочтительней  векторной  (исключение  составляют
         специальные приложения, например, технические чертежи).
              И   последний  аспект.  В  отличие  от  систем векторной
         графики, в  которых  изображение   генерируется   с   помощью
         последовательности   команд   (каждая   команда  рисует  одну
         небольшую  прямую), системы   растровой   графики   допускают
         использование  хранимого  в памяти образа экрана (эти вопросы
         мы уже рассматривали применительно к  текстовым  образам).  В
         компьютере  IBM/PC  мы имеем дело именно с сиcтемой растровой
         (пиксельной)   графики;   управление   процессом   построения
         изображения   на  экране  дисплея  осуществляется  с  помощью
         хранимого  образа  экрана.  Все   преимущества   дисплеев   с
         хранимыми   образами  экрана  распространяются  на  растровый
         дисплей компьютера IBM/PC - и в первую очередь способность  к
         считыванию  и  записи  отображаемых данных непосредственно из
         памяти дисплея.

              9.2. Понятие элемента отображения (пикселя)

              По  мере  движения  сканирующего  луча по экрану дисплея
         высвечиваются те  или  иные  пиксели.  (По  крайней  мере  те
         пиксели,  которые  находятся  в  видимой части экрана; дело в
         том, что сканирующий луч выходит  за  пределы  видимой  части
         экрана, в так называемую "закадровую" область. Эта область не
         содержит пиксели, однако, для нее может быть установлен цвет.
         В  языке  Бейсик  для  этого служит параметр границ оператора
         COLOR  (ЦВЕТ);  кроме  того,  одна  из  функций  обслуживания
         BIOS-ПЗУ  может  быть  использована для установки закадрового
         цвета).
              Напомним, что в  текстовом  режиме  экран  персонального
         компьютера  IBM/PC  состоит  из  25  горизонтальных текстовых
         строк;  из  материалов  предшествующей  главы,  связанных   с
         описанием  курсора,  известно  также,  что  на  каждый символ
         цветного    графического    дисплея     приходится     восемь
         горизонтальных   строк   развертки.   Отсюда   следует,   что
         вертикальный размер общего пиксельного поля IBM/PC равен  200
         строкам (8Х25).
              Горизонтальный    размер    пиксельного    поля    может
         варьироваться.  Этот  размер  зависит   от   объема   памяти,
         требуемой  для  управления  пикселями,  а  также  от величины
         пикселя (точки), высвечиваемой на том  или  ином  графическом
         мониторе.
              Компьютер  IBM/PC  имеет  два  различных  горизонтальных
         формата  (размера)  пиксельного   поля,   устанавливаемых   в
         зависимости   от  требуемого  размера  (а,  следовательно,  и
         количества)  пикселя(ей). В режиме среднего разрешения ширина
         экрана составляет 320 точек, а в режиме  высокого  разрешения
         - 640  точек. (Компьютер  IBM/PC  допускает также возможность
         работы  в  режиме  низкого  разрешения,  однако,  этот  режим
         практически  не  используется.  В  режиме  низкого разрешения
         поверхность экрана  представляется  в  виде  матрицы  160Х100
         пикселей.    Аппаратура    цветного   графического   адаптера
         поддерживает режим низкого  разрешения,  однако,  программная
         поддержка на уровне BIOS-ПЗУ отсутствует).
              Таким  образом,  графический  режим  среднего разрешения
         предусматривает наличие 320 точек по горизонтали экрана и 200
         точек по вертикали, в то время как графический режим высокого
         разрешения  -  640  точек  по  горизонтали  и  200  точек  по
         вертикали.  Понятно, что изображение, представленное в режиме
         высокого разрешения,  способно  воспроизводить  более  мелкие
         детали  только  на  горизонтали.  Для  большинства приложений
         качество изображения практически осталось бы неизменным, если
         бы режим высокого разрешения выражался параметрами 320Х400.
              Каждый пиксель на экране дисплея может находиться либо в
         активном (светимость), либо в пассивном состоянии;  в  режиме
         среднего разрешения может быть воспроизведен и цвет. В режиме
         высокого разрешения цвет не  воспроизводится,  отчасти  из-за
         особенностей  генерации изображения, отчасти из-за отсутствия
         дополнительной памяти, необходимой для воспроизведения цвета.
              Рассмотрим    требования    к    памяти,   предъявляемые
         графическим   режимом   высокого  разрешения.  Если  к  числу
         сведений,  сообщаемых  о  пикселе,  относится  только признак
         активного  или  пассивного  состояния (наличие или отсутствие
         светимости  пикселя), а именно это и сообщается о пикселе, то
         для  управления пикселем достаточно одного бита, принимающего
         значение  0  или  1.  В  режиме  высокого  разрешения имеется
         640Х200  (или  128000) пикселей. Для управления ими требуется
         128000  бит,  а  с  учетом  того,  что байт состоит из восьми
         битов,  -  16000  байт. Именно такая память выделена цветному
         графическому адаптеру (округлена до 16К).
              Режим среднего разрешения требует вдвое  меньшего  числа
         пикселей.  Имея  те же 16К байт памяти мы  можем выделить для
         каждого пикселя два бита. С помощью  двух  битов  могут  быть
         представлены  четыре  различные величины (0, 1, 2, 3); но это
         позволит лишь частично решить проблему воспроизведения  цвета.
              Прежде, чем познакомиться  с  окончательным  разрешением
         проблемы  воспроизведения цвета в графическом режиме, обратим
         внимание на одно отличие  в  специфике  использования  памяти
         дисплея  в  графическом  и  текстовом  режимах. Из предыдущей
         главы нам известно о наличии двух текстовых режимов  -  80-ти
         позиционного  и  40-позиционного.  Графика представлена также
         двумя  режимами:  режимом  среднего  разрешения   и   режимом
         высокого  разрешения.  В  обоих  случаях  число  отображаемых
         элементов одного режима вдвое  превышает  число  отображаемых
         элементов   другого   режима.   Соответственно  изменяются  и
         требования, предъявляемые к памяти. На  этом  сходство  между
         ними  заканчивается.  Если  в текстовом режиме дополнительная
         память  используется  для  увеличения  числа  страниц,  то  в
         графическом  режиме  дополнительная  память  используется для
         удвоения объема памяти, отводимой под один пиксель.
              В связи со спецификой  управления  цветом  в  компьютере
         IBM/PC    возникает    вопрос   о   количестве   одновременно
         используемых цветов.  Цветной  графический  адаптер  и  экран
         видеомонитора  способны  воспроизвести  любой  из шестнадцати
         возможных цветов  для  каждого  пикселя.  Здесь  нет  никаких
         проблем. Проблемы возникают при спецификации цвета.
              Фирма   IBM   могла  пойти  по  пути  создания  цветного
         графического  адаптера,  имеющего   достаточно   памяти   для
         представления  всех  возможных цветов каждого пикселя, однако
         она этого не сделала.  Как  уже  говорилось  выше,  в  режиме
         высокого  разрешения  каждому  пикселю  отводится только один
         бит,  поэтому   в   принципе   в   этом   режиме   невозможно
         воспроизвести  более двух цветов - белого и черного. В режиме
         среднего  разрешения  каждому  пикселю  отводится  два  бита,
         поэтому возможно воспроизведение четырех цветов.
              Проблема выбора того или  иного  набора,  состоящего  из
         четырех  цветов,  решена необычно и остроумно. В любой момент
         времени  активны  только  четыре   цвета,   но   пользователю
         предоставляется   возможность  установить  любой  из  четырех
         цветов по своему усмотрению. Остальные три устанавливаются  в
         рамках  так  называемой палитры. В качестве компенсации фирма
         IBM предоставляет на выбор две  возможные  палитры  -  первая
         состоит  из  зеленого, красного и коричневого (на большинстве
         дисплеев воспроизводится как желтый), а вторая  -  из  циана,
         малинового и белого.
              Если все это звучит  недостаточно  убедительно,  давайте
         рассмотрим  этот  вопрос  с другой стороны. При задании цвета
         любого пикселя в режиме  среднего  разрешения  мы  используем
         один из четырех кодов 0, 1, 2, 3. Что стоит за этими числами?
         Ничего  жестко  фиксированного.  Их  смысл   определяется   в
         процессе спецификации используемого цвета. Мы можем закрепить
         за кодом 0 один  из  16  цветов.  Для  кодов  1-3  фирма  IBM
         предлагает  две  стандартные  возможности  (две  палитры),  и
         пользователь  должен  выбрать,   какую   палитру   он   будет
         использовать. Заметим здесь, что пользователь не может влиять
         на составление палитры.
              Давайте  еще  раз  осмыслим  происходящее. Если бы объем
         памяти был достаточно велик,  то  мы  могли  бы  для  каждого
         пикселя    использовать   полную   гамму   цветов   (16).   В
         действительности объем памяти таков, что  в  режиме  высокого
         разрешения  цветовая  гамма каждого пикселя состоит только из
         двух цветов, а в  режиме  среднего  разрешения  -  только  из
         четырех.  Пользователю  могли  бы  быть  предоставлены  более
         широкие возможности в части выбора  цвета,  однако  по  этому
         пути разработчики персонального компьютера не пошли.
              В  режиме   высокого   разрешения   пользователь   лишен
         возможности  выбирать  конкретные цвета (два цвета) по своему
         усмотрению; этими цветами могут быть только черный и белый. В
         режиме   среднего  разрешения  пользователь  имеет  некоторую
         свободу выбора цветовой гаммы. Из четырех  цветов  один  цвет
         устанавливается   пользователем  произвольно.  Остальные  три
         цвета  устанавливаются  в  рамках  одной   из   двух   строго
         фиксированных палитр.
              Таким  образом,  любой  цветной  дисплей  в  графическом
         режиме позволяет использовать четыре цвета, причем три  цвета
         выбираются  из палитры 1 (зеленый, красный, коричневый), либо
         из палитры 2 (циан, малиновый, белый).
              Если  цветной дисплей находится в графическом режиме, то
         цвет любого пикселя (из  состава  имеющихся  четырех  цветов)
         можно  применить  путем  изменения  содержимого  двух  битов,
         описывающих этот пиксель. Существует и  возможность  изменить
         сразу  цвета  всего  изображения;  для  этого  следует:  либо
         изменить палитру, либо изменить цвет 0, либо изменить и то  и
         другое.  В этих случаях собственно  изображение (картинка) не
         меняется,  изменяется  лишь  ее  цвет(а).  (Для  графического
         режима  низкого  разрешения  предусмотрено  достаточно битов,
         чтобы каждый пиксель мог воспроизвести любой из 16  возможных
         цветов. Режим низкого разрешения может быть вполне реализован
         на  Вашем  компьютере;  аппаратная  поддержка  этого   режима
         реализована полностью. Однако программная поддержка на уровне
         BIOS-ПЗУ полностью отсутствует. Если  функции  программ  BIOS
         возьмет  на себя программа пользователя, то графический режим
         низкого разрешения будет функционировать).

              9.3. Отображение пикселей на экране

              Графический  режим  работы компьютера представляет собой
         наиболее сложный режим. Если использовать процедуры BIOS-ПЗУ,
         ориентированные  на обслуживание графического режима (описаны
         в  параграфе 8.9), то декодирование образа экрана выполняется
         автоматически.  Это одна из причин их широкого использования.
         В  тех  случаях,  когда необходимо использовать режим прямого
         управления,   следует   детально  ознакомиться  с  материалом
         настоящего параграфа.
              Подобно  обычному  телевизору,  видеомонитор  генерирует
         изображение за два прохода. На первом проходе электронный луч
         перемещается  только по четным строкам развертки; после этого
         (на обратном ходе луча) сканируются все нечетные строки.
              При  работе  в  текстовом  режиме  это  обстоятельство в
         расчет   не   принимается,   поскольку   функции   управления
         формированием   изображения  полностью  выполняет  контроллер
         видеомонитора.   В   графическом   режиме   эти   особенности
         необходимо учитывать.
              Электронные схемы генерации  изображения  в  графическом
         режиме  должны воспринимать поток битов, определяющих пиксели,
         причем воспринимать их в том порядке, в  котором  сканирующий
         луч  перемещается  по  экрану - сначала по четным, а затем по
         нечетным строкам. По этой причине образ экрана хранится не  в
         том виде, который удобен  человеку-оператору  или  программе;
         структура  хранимого образа отвечает потребностям электронных
         схем генерации. На рис. 9.1 воспроизводится эта структура.
              Для  того,  чтобы  структура  хранимого  образа   экрана
         соответствовала механизму сканирования экрана, память дисплея
         организована в виде двух блоков, смещенными друг относительно
         друга  на  4К.  Первый  блок  содержит  информацию о пикселях
         четных строк, а второй  блок  -  о пикселях  нечетных  строк.
         Рассмотрим  эти  вопросы более подробно (используя в качестве
         примера графику с высоким разрешением).
              В начале  области  (блока)  памяти  располагаются  биты,
         управляющие  процессом  отображения  на экране дисплея первой
         строки, т.е. строки с номером 0. Строка содержит 640 пикселей
         (графический  режим  с высоким разрешением), а каждый пиксель
         требует для индикации своего состояния 1 бит. Таким  образом,
         для  управления  первой  строкой  требуется  640 битов или 80
         байтов. Для управления следующей четной  строкой  (строкой  с
         номером  2)  также  требуется  640 битов или 80 байтов и т.д.
         Самый первый бит управляет точкой экрана дисплея, находящейся
         на  пересечении  нулевой  строки  и  нулевого  столбца (0,0),
         следующий бит управляет точкой (0,1) и т.д. Последней  точкой
         первой  строки  является  точка  (0,639);  следом за ней идет
         точка (2,0) и т.д.  В  конце  концов  блок  памяти,  хранящий
         четные  строки,  оказывается  исчерпанным, и с нового адреса,
         кратного  1К,  начинается  блок  памяти,  хранящий   нечетные
         строки.
              Для графического режима со  средним  разрешением  память
         организована   точно   также,   с   той  лишь  разницей,  что
         горизонтальная координата экрана  состоит  из  320  пикселей,
         причем  каждый пиксель представлен двумя битами, позволяющими
         представить  цветовые  комбинации. Для  представления  строки
         по-прежнему    требуется   80   байтов;   для   представления
         используются два блока памяти: один - для четных, а другой  -
         для нечетных строк.
              Заметим  здесь,  что конечный адрес памяти будет одним и
         тем же как для режима среднего, так  и  для  режима  высокого
         разрешения.  Но  в  одном  случае число пикселей вдвое меньше
         (при  вдвое  большем   количестве   битов,   отведенных   для
         представления  каждого  пикселя),  а  в другом  случае  вдвое
         больше  (соответственно,  количество  битов,  отведенных  для
         представления  пикселя  в  два  раза  меньше).  Такой  подход
         позволяет сохранить постоянную длину строки для обоих режимов
         -   640   битов  или  80  байтов.  Программы,  приведенные  в
         приложении (листинг  9.1),  дают  возможность  пользователям,
         программирующим   на   Паскале,  эффективно  управлять  любым
         пикселем.    Эти    программы    осуществляют     необходимые
         арифметические преобразования, связанные с пересчетом позиции
         пикселя  на  экране  дисплея   в   адрес   памяти,   хранящей
         кодированный  образ экрана, избавляя пользователя от рутинной
         работы по вычислению смещений битов и байтов.
              Эффективность    этих   процедур   становится   особенно
         очевидной,  когда   требуется   создавать   быстродействующие
         программы генерации изображений. Любая программа, относящаяся
         к указанному классу, должна тем или иным способом  переводить
         пиксели  из  активного  состояния  (состояние  светимости)  в
         пассивное  и  наоборот.  Сделать  это  можно  либо  используя
         функции  обслуживания  BIOS-ПЗУ, описанные в  предыдущей  и в
         последней главах, либо упомянутые Паскаль-процедуры  (листинг
         9.1).  Высокое  быстродействие программ генерации изображений
         предполагает, что тот или  иной  фрагмент  будет  загружен  в
         память  графического  адаптера  сразу  целиком,  а  не  будет
         формироваться побитно.  А  для  этого  необходимо  произвести
         декомпозицию  изображения  на четные и нечетные строки, после
         чего  обеспечить  их  размещение  в  соответствующих   блоках
         памяти.  Указанное  обстоятельство  сильно  усложняет процесс
         быстрой генерации изображений.
              Решение задачи быстрой генерации изображений зависит  от
         потребностей  и  от  принятых компромиссов. Один из возможных
         подходов  состоит  в  разбиении   изображения   на   участки,
         помещаемые  в  один  байт (четыре пикселя для режима среднего
         разрешения и восемь пикселей для режима высокого разрешения).
         Приняв  такую схему, можно осуществлять загрузку фрагментов в
         память графического адаптера побайтно. Такой  метод позволяет
         резко  снизить  вычислительные  затраты,  в противном случае,
         программы должны  выполнять  массу  операций  манипулирования
         битами,   таких,   например,   как  сдвиги,  логические  "И",
         логические "ИЛИ" и т.п. Работа с  байтами  повышает  скорость
         генерации  образа приблизительно в три раза, при условии, что
         собственно образ уже построен.
              Существует  и  другой,  более  грубый  способ  повышения
         скорости   генерации   изображения.   Его   суть   состоит  в
         использовании текстовой графики (псевдографики),  описываемой
         в следующем параграфе.

              9.4.   Представление  текста  (символов)  в  графическом
         режиме.

              Отображение  символов  на экране дисплея не представляет
         особого труда, даже если  компьютер  работает  в  графическом
         режиме.   Символы   в   этом  случае  представляются  в  виде
         совокупности пикселей,  как  если  бы  это  были  графические
         объекты, подлежащие рисованию (вычерчиванию).
              Для фиксации схемы вычерчивания символов  в  графическом
         режиме  приняты  специальные  соглашения. Площадь, занимаемая
         символом,  представляется  в  виде   матрицы   размером   8Х8
         пикселей.  Принятый  принцип кодирования в принципе очевиден.
         Для воспроизведения  очертания  (рисунка)  символа  отводится
         восемь   байтов.  Восемь   битов   каждого   байта  управляют
         состоянием  восьми  пикселей  одной  строки  рисунка  символа
         (нумерация  пикселей  ведется  слева направо). Очередной байт
         описывает очередную строку  (нумерация  строк  осуществляется
         сверху вниз).
              На рис.9.2 представлена диаграмма  отображения  символов
         (букв), содержащая  сведения об особенностях взаимодействия с
         таблицей рисования символов. В качестве примера выбрана буква
         "А".
              Даже  при  беглом знакомстве с этой диаграммой возникает
         ряд интересных вопросов. Нижняяя  строка  диаграммы  отведена
         под   нижний   выносной   элемент  символа  (литеры),  такой,
         например, как "хвост" прописной буквы "у". Две верхние строки
         отведены  под  заголовок  литеры.  В  качестве литер, имеющих
         заголовок, можно привести строчную букву "ь" (имеется в  виду
         ее  вертикальный  отрезок, используюший область заголовка), а
         также все прописные буквы алфавита (буквы верхнего регистра).
         Вопреки  "здравому  смыслу"  буквы  размещаются  не по центру
         матрицы, а смещаются (выравниваются ) по  ее  левой  границе,
         так  что  два  столбца справа служат для  отделения  символов
         друг от друга.
              При формировании символов в графическом режиме  BIOS-ПЗУ
         осуществляет  поиск  рисунка  (образа)  символа во внутренней
         таблице отображения, а  затем  найденное  табличное  описание
         использует для команд активизации пикселей. На заключительной
         стадии устанавливаются соответствующие биты в памяти  дисплея
         путем  пересылки  четных  и  нечетных строк в соответствующие
         блоки памяти.
              Поскольку в графическом режиме высокого  разрешения цвет
         не  воспроизводится  (воспроизводятся  только  черный и белый
         цвета), то рисунок (образ) символа непосредственно  управляет
         активизацией  пикселя.  В  цветном режиме среднего разрешения
         воспроизводятся цвет  очертания  (рисунок)  и  фоновый  цвет.
         Фоновый  цвет  -  это  цвет, обозначенный кодом 0; этим кодом
         может быть обозначен любой из 16-ти  имеющихся  цветов.  Цвет
         очертания  устанавливается с помощью  кода 3 текущей цветовой
         палитры; для палитры 1 это белый цвет,  а  для  палитры  0  -
         коричневый/желтый.
              Процедуры  манипулирования  символами   BIOS-ПЗУ   могут
         осуществлять  как  считывание, так и запись символов. Функция
         обслуживания с кодом 8 является именно  такой  процедурой.  В
         текстовом  режиме  никаких  проблем  при чтении не возникает,
         поскольку в  памяти  дисплея  хранится  байт  с  кодом  ASCII
         требуемого  символа.  В графическом режиме все обстоит не так
         просто, поскольку байт с кодом ASCII  в  памяти  отсутствует.
         Вместо  этого  память  содержит группу байтов, представляющих
         точечный  (пиксельный)  рисунок  символа.  Поэтому  процедура
         BIOS-ПЗУ  чтения символа осуществляет нетривиальные операции.
         Она читает пиксели и  сопоставляет  их  с содержимым  таблицы
         рисунков    (образов)    символов,   выполняя   своего   рода
         распознавание образа.
              Таблица  рисунков  (образов)  символов  состоит  из двух
         частей и представляет для пользователя значительный  интерес.
         Первая  часть  этой  таблицы хранится в ПЗУ и содержит первые
         128 символов кода ASCII,  то  есть  все  стандартные  символы
         алфавита. Вторая часть таблицы содержит рисунки остальных 128
         символов  (т.е.  символов   CHR$(120)-CHR$(255)).   Поскольку
         первая  часть  находится  в  ПЗУ  (указатель  на  нее  строго
         фиксирован), то она  не  может  быть  ни  модифицирована,  ни
         заменена  на  другую таблицу. Вторая часть таблицы, в отличие
         от  первой,  ориентирована  на  пользователя;  она  создается
         пользователем под его потребность.
              Один  из  векторов  прерывания  (прерывание  с  кодом 31
         (1F(16)),  размещенный   в   таблице   векторов   по   адресу
         124(7С(16))  используется  для  указания  на  эту  таблицу. В
         исходном состоянии таблица отсутствует и вектор  равен  нулю.
         После  создания  нужной таблицы и загрузки ее адреса в вектор
         прерывания любое обращение к BIOS-ПЗУ для  записи  символа  с
         кодом   CHR$(128)-CHR$(255)  приведет  к  воспроизведению  на
         экране этого символа.
              Такой   подход,   основанный  на  свободном  определении
         таблицы рисунков 128 символов  является  важной  предпосылкой
         для быстрого построения наиболее типичных графических образов
         (несложные  графики,  схемы,   рисунки,   таблицы,   чертежи,
         диаграммы  и др.). Если требования к изображаемым объектам не
         слишком  высоки,  то  всегда   можно   определить   ансамбль,
         состоящий  из  128  шаблонов  (каждый шаблон имеет размер 8Х8
         пикселей) и генерировать на их основе эти объекты.  Очевидно,
         что  наиболее  сложные  и  детальные  образы  не  могут  быть
         построены таким способом. И все-таки ансамбль,  состоящий  из
         128  предварительно  определенных шаблонов, достаточно велик,
         чтобы    пользовательские    программы    обладали    высоким
         быстродействием,   были   просты  и  компактны.  В  сущности,
         процедуры обслуживания рисунков символов BIOS-ПЗУ  (используя
         таблицу,  созданную  пользователем)  берут  на  себя основную
         работу по генерации образов; пользовательские программы  лишь
         помещают нужные символы в нужные позиции экрана.
              Описанные  возможности  генерации  графических  символов
         отнюдь не исключают возможность непосредственного  доступа  к
         памяти дисплея и управления отдельным пикселем. В графическом
         режиме пользователь может сочетать обе возможности. Когда это
         удобно  -  использовать  таблицу  графических  символов,  при
         необходимости - манипулировать пикселями.  Вполне  допустимо,
         например,   изменять   любой  пиксель  внутри  любого  образа
         символа, уже выведенного на экран.
              Таблица  рисунков символов требует для своего размещения
         1024 байтов памяти: 128 символов Х 8  байтов  (требуемых  для
         каждого символа). В графическом режиме со средним разрешением
         один байт программы  пользователя  может  использоваться  для
         управления   образом,   состоящим   из   64   пикселей,   что
         эквивалентно  восьми  байтам  отображаемой  информации.   При
         соблюдении  определенных  требований такой подход позволяет в
         восемь раз сжать графический образ по отношению к исходному.
              Прежде чем использовать эти возможности, следует оценить
         последствия  ограничений, распространяемых не только на число
         возможных шаблонов, но и на число  воспроизводимых  цветов  в
         режиме  среднего  разрешения.  Число  таких  цветов  не может
         превышать  двух.  Обычный  режим  цветной  графики  позволяет
         использовать  полную  4-х цветную палитру, в то время как при
         использовании возможностей построения изображений  на  основе
         синтеза  символов  количество цветов в палитре уменьшается до
         двух.
              В  тех  случаях,  когда   таблица   рисунков   символов,
         формируемая  пользователем,  не  применяется  для  построения
         изображений  в   графическом   режиме,   можно   использовать
         специальные  символы  из расширенного набора. Это может найти
         применение  при  имитации  символов  текстового  режима,  при
         построении  специальных  шаблонов  или  алфавитов.  Так,  это
         наиболее  простой  и  эффективный  способ  генерации   других
         национальных алфавитов - греческого, славянского (кириллица),
         японского (кана). Символика арабского языка  и  иврита  также
         вполне  представима, однако, здесь возникают другие сложности
         -    сложности,    связанные    с    особенностями     письма
         (справа-налево).

              Приложение 9.1. Текст программы генерации изображений
                       (Паскаль).


         module listing_9_1;
         type
          word_bits_type       =  set of 0..15;
         high_res_pixel_type   = (off,on);
         medium_res_pixel_type =(color_0,color_1,color_2,color_3;
          graphics_screen_type=
            record
              even_pixel : array [0..99,0..39] of word_bits_type;
              filler     : array [1..192] of byte;
              odd_pixel  : array [0..99,0..39] of word_bits_type;
            end;
         var [static]
          graphics_screen_pointer  :  ads of graphics_screen_type;
          general_screen_pointer   :  adsmem;
          row,column               :  integer;
         value
          graphics_screen_pointer.s := #B800;
          graphics_screen_pointer.r := 0;
          general_screen_pointer.s  :=#B800;
          general_screen_pointer.r  :=0;
         {===================================================================}
               ТЕКСТ   РАЗОБРАТЬ  НЕЛЬЗЯ

               graphics_screen_pointer ^ .odd_pixel [(row-1) div 2,column div 16]
         else
            work_byte :=
             graphics_screen_pointer ^ .even_pixel [row div 2, column div 16];
         work_value := column mod 16;
         if color = on then
           work_byte := work_byte + [work_value]
         else
           work_byte := work_byte - [work_value];
         if odd (row) then
           graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 16]
             := work_byte
         else
           graphics_screen_pointer ^ .even_pixel[row div 2, column div 16]
             := work_byte;
         end;
         {===========================================================}
         procedure set_medium_res_pixel (color : medium_res_pixel_type);
           var [static]
             work_byte : word_bits_type;
             work_set0 : set of 0..15;
             work_set1 : set of 0..15;
         begin
          if odd (row) then
            work_byte :=
           graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 8];
          else
            work_byte :=
           graphics_screen_pointer ^ .even_pixel [row div 2, column div 8];
          work_set0 := [(column mod 8) * 2];
          work_set1 := [(column mod 8) * 2 + 1];
          if color in [color_2,color_3] then
            work_byte := work_byte + work_set0
          else
            work_byte := work_byte - work_set0;
          if color in [color_1,color_3] then
            work_byte := work_byte + work_set1
          else
            work_byte := work_byte - work_set1;
          if odd (row) then
            graphics_screen_pointer ^ .odd_pixel [(row-1) div 2, column div 8]
             :=work_byte
          else
            graphics_screen_pointer ^ .even_pixel [row div 2, column div 8]
             := work_byte;
         end;
         {===========================================================}
         procedure clear_screen_graphics;
           var [static]
             i : word;
           begin
             for i := 0 to 16383 do
               general_screen_pointer ^ [i] := 0;
           end;
         {===========================================================}
         end.