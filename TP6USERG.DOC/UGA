
                ПРИЛОЖЕНИЕ А. УТИЛИТЫ TURBO PASCAL.

     Это приложение   описывает  пять  автономных  программ-утилит,
которые поставляются  вместе  с  Турбо  Паскалем:  TPUMOVER,  MАКЕ,
TOUCH, CREP, и BINOBJ.


     Использование TPUMOVER - программы для работы с модулями.

     Когда Вы пишете модули,  то хотите их сделать  доступными  для
любой разрабатываемой Вами программы (В главе 4 "Модули и связанные
с ними возможности" объясняется что такое Модуль и говорится о том,
как  создавать  собственные  модули.).  Теперь мы покажем Вам,  как
использовать TPUMOVER для удаления редко  используемых  модулей  из
TURBO.TPL, и как поместить туда часто используемые модули.

                    Просмотр файлов - модулей.

     Существует два типа файлов модулей:  .TPU файлы и .TPL  файлы.
Когда Вы компилируете модуль, Турбо Паскаль помещает результирующий
об'ектный код в .TPU (Turbo Pascal Unit  -  Модуль  Турбо  Паскаля)
файл, который всегда содержит только один модуль.
     Файл .TPL (Turbo Pascal Library -  Библиотека  Турбо  Паскаля)
может содержать много модулей. Например, все модули, находящиеся на
Вашей дистрибутивной дискете сосредоточены в файле TURBO.TPL.  Файл
TURBO.TPL является   библиотечным  файлом из которого Турбо Паскаль
выбирает необходимые модули.  Если в процессе  компиляции  какой-то
модуль в   TURBO.TPL   не   найден,  то  Турбо  Паскаль  ищет  файл
"имя_модуля.TPU",  если же и этот файл не  будет  обнаружен,  тогда
компиляция  заканчивается  с  выдачей  ошибки.  Если Вы используете
опцию Build,  Турбо Паскаль сначала ищет  файл  "имя_модуля.PAS"  и
перекомпилирует  его,  формируя  результирующий .TPU файл.  Если Вы
используете опцию Make, Турбо Паскаль просматривает оба файла "имя_
модуля.PAS" и "имя_модуля.TPU", сравнивая их даты и время последней
модификации и перекомпилирует  .PAS  файл,  если  он  модифицирован
после создания . TPU файла. Обычно, когда Вы пишете свой модуль, он
хранится в .TPU файле,  а для его использования, Вы должны сообщить
Турбо Паскалю,  где его искать. Если Вы используете интегрированную
среду, то должны специфицировать опцию Unit Directories (Справочник
модулей)   в   меню   Oрtions/Directories   (Опции/   Справочники).
(Turbo.TPL загружается из справочника Turbo в этом же  меню).  Если
Вы  используете  среду  компилятора  коммандной  строки,  то должны
применять опцию /U (Используйте опцию /Т  для  загрузки  библиотеки
Турбо   Паскаля   из   другого   справочника  в  случае  применения
компилятора командной строки).
     Наверное Вы уже заметили,  что можно использовать  стандартные
модули Турбо Паскаля - без указания  имени  файла.  Это  происходит
потому,  что эти модули хранятся в стандартном модуле Турбо Паскаля
-  TURBO.TPL,  который помещен на дистрибутивной дискете. Поскольку
стандартные модули находятся в этом файле, то любая программа может
использовать их без "знания" их местоположения.
     Предположим у Вас есть модуль TOOLS.TPU,  и Вы используете его
во многих различных программах.  Хотя  добавление  модуля  TOOLS  в
библиотеку  TURBO.TPL  требует  дополнительной  оперативной  памяти
(TURBO.  TPL автоматически загружается компилятором  в  оперативную
память),  наличие  этого  модуля  в  резидентной  библиотеке делает
использование модуля TOOLS более доступным,  из-за того, что модуль
находится в памяти, а не на диске.
     В TURBO.TPL  уже  имеются  пять  стандартных модулей:  System,
Overlay, Printer, Crt и Dos.


                      Использование TPUMOVER.

     TPUMOVER -   диалоговая   программа,    очень    похожая    на
интегрированную  среду  Турбо  Паскаля.  Она показывает Вам модули,
содержащиеся в двух различных файлах и позволяет  Вам перебрасывать
модули  между  этими файлами или удалять их.  TPUMOVER используется
главным образом для работы с файлами в TURBO.TPL,  но также имеет и
другие полезные функции.
     Заметьте, что TPUMOVER отображает  содержимое  файлов  в  двух
окнах.  Вверху  окна появляется имя файла,  после чего отображается
список модулей  в  этом  файле.  Каждая  строка  окна  представляет
информацию об одном модуле: имя модуля, размер кода, размер данных,
размер  таблицы  символов  и  имена  модулей,  используемых  данным
модулем. Все размеры приводятся в байтах, а имена модулей усекаются
до семи символов.  Если список используемых модулей слишком большой
и  не вмещается в окно,  то он оканчивается тремя точками,  нажатие
клавиши F4 приводит к выдаче верхнего  под-окна  с  именами  других
модулей.  И, наконец, в окне отведены две строки для отображения (в
байтах) текущего размера файла и количества свободного пространства
на диске, где этот файл расположен.
     В любой момент времени,  одно из окон является "активным".  Об
этом свидетельствует  двойная  линия  вокруг активного окна.  Кроме
того,  только в активном окне имеется  подсвеченное  поле,  которое
появляется  в  списке  модулей  файла,  это поле может перемещаться
вверх и вниз  с  использованием  клавиш  управления.  Все  вводимые
команды  относятся  только  к  активному  окну,  нажатие клавиши F6
переключает окна из активного состояния в пассивное и наоборот. Для
включения TPUMOVER наберите:

         TPUMOVER  файл1  файл2.

     где файл1  и  файл2  -  .TPL  или .TPU файлы.  Расширение .TPU
предполагается по умолчанию,  поэтому Вы должны явно добавлять .TPL
для .TPL файлов.
     TPUMOVER загружается  и  отображает  два  окна  - с файлом 1 в
левом окне и файлом 2 в правом окне.  Заметьте, что если Вы укажете
только файл 1, правое окно по умолчанию будет иметь имя NОNAME.TPU.
Если Вы вообще не укажете файлов, TPUMOVER будет пытаться загрузить
TURBO.TPL (в левом окне,  с пустым правом окном). Если этот файл не
будет обнаружен,  TPUMOVER отобразить содержимое  справочника  всех
фалов с расширением .TPL.


                       Команды TPUMOVER.

     Основные команды перечислены снизу  экрана.   Ниже  приводится
краткое описание каждой из них:
     - F1 - вызывает выдачу подсказки на экран.
     - F2 - сохраняет  текущий  файл  (файл  связанный  с  активным
окном).
     - F3 - позволяет выбрать новый файл для активного окна.
     - F4 - отображает верхнее подокно,  показывающее все вхождения
модулей в данный модуль.  В главном окне показывается только первое
вхождение.   Если  снизу  имеются  три  точки,  то  существуют  еще
вхождения, для отображения которых необходимо нажать клавишу F4.
     - F6 - позволяет Вам переключать окна, переводя их попеременно
из активного в пассивное состояние (и наоборот).
     - + (знак плюс) маркирует модуль (для последующего копирования
или  удаления).  Вы  можете  одновременно   маркировать   несколько
модулей, Вы можете также аннулировать маркирование модуля повторным
нажатием клавиши (+).
     - Ins - копирует все маркированные модули из активного окна  в
пассивное.
     - Del - удаляет все маркированные модули из активного окна.
     - Esc - позволяет осуществить выход из TPUMOVER. Заметьте, что
эта операция не сохраняет автоматически все проделанные  изменения,
Вы должны явно задавать F2 для сохранения модификаций перед выходом
из TPUMOVER.


                  Помещение модулей в TURBO.TPL.

     Предположим Вы создали модуль Tools,  который откомпилирован и
помещен в файл  TOOLS.TPU.   Вы  хотите  поместить  этот  модуль  в
TURBO.TPL. Как это сделать? Прежде всего наберите команду:

         TPUMOVER  TURBO  TOOLS

     Эта команда  вызовет отображение экрана TPUMOVER с TURBO.TPL в
левом окне (активное)  и TOOLS.TPU в правом окне.  Заметьте,  что в
этом примере   предполагается  что  TURBO.TPL и TOOLS.TPU находятся
оба в текущем справочнике,  если это не так,  Вам необходимо задать
соответствующий путь для каждого файла.  Теперь выполните следующие
действия:
     1. Нажмите F6 для активизации правого окна (TOOLS.TPU).
     2. Нажмите  +  для  маркирования  TOOLS (единственный модуль в
правом  окне).
     3. Нажмите Ins для копирования TOOLS в TURBO.TPL.
     4. Нажмите F6 для  активизации  левого  окна  (TURBO.TPL).
     5. Нажмите  F2  для сохранения изменений в TURBO.TPL на диске.
     6. Нажмите Esc для выхода из TPUMOVER.

     Модуль TOOLS  теперь  будет  являться частью TURBO.TPL и будет
автоматически загружаться при использовании Турбо Паскаля.
     Если Вы захотите добавить другие модули в TURBO.TPL, Вы можете
это сделать  без  выхода  из  TPUMOVER.  После  нажатия на F2,  для
сохранения TURBO.TPL на диске, выполните следующие действия:
     1. Нажмите клавишу F6 для активизации правого окна.
     2. Нажмите клавишу F3 для выбора нового файла в правом окне.
     3. Повторите шаги 2 - 5 предыдущего примера  для  маркирования
соответствующего модуля,  копирования его в TURBO.TPL,  активизации
левого окна, и сохранения TURBO.TPL на диске.
     Вы можете  повторять  это столько раз,  сколько необходимо для
построения Вашей библиотеки.


                  Удаление модулей из TURBO.TPL.

     Предположим, что  большинство  из Ваших программ не используют
модули Overlay или Printer, поэтому давайте удалим их из TURBO.TPL,
для чего наберите команду:

         TPUMOVER  TURBO

     Это вызовет  загрузку  TPUMOVER  с  TURBO.TPL  в  левом окне и
NONAME.TPU (имя по умолчанию) в правом. Левое окно активное, поэто-
му выполняем   следующие  действия:
     - Используйте клавишу "стрелка вниз" для перемещения светового
       поля на модуль Overlay.
     - Нажмите + для выбора модуля Overlay.
     - Нажмите клавишу Del для удаления модуля Overlay.
     - Нажмите клавишу F2 для сохранения изменений в TURBO.TPL.
     - Нажмите Esc для выхода из TPUMOVER.

     Вы можете повторить процедуру для удаления модуля Printer.


            Перемещение файлов между .TPL библиотеками.

     Предположим, что Ваш товарищ написал ряд модулей и передал Вам
файл  (MYSTUFF.TPL)  в  котором  содержатся  эти модули.  Вы хотите
скопировать только модули GameStuff и RandStuff  в  TURBO.TPL.  Как
это  сделать?  Ваша  командая  строка  должна  выглядеть  следующим
образом:

         TPUMOVER  MYSTUFF.TPL  TURBO.TPL

     Это приведет  к  загрузке  TPUMOVER  с  MYSTUFF.TPL  в   левом
(активном)  окне  и  TURBO.TPL  в правом окне.  Далее,  используйте
следующие команды:
     - Используйте  клавиши  "стрелка  вверх"  и "стрелка вниз" для
перемещения светового поля на GaveStuff.
     - Нажмите клавишу + для выбора GameStuff.
     - Используйте  клавиши  "стрелка вверх" или "стрелка вниз" для
перемещения светового поля на RandStuff.
     - Нажмите клавишу + для выбора RandStuff.
     - Нажмите клавишу Ins для копирования GameStuff и RandStuff  в
Turbo.TPL.
     - Нажмите клавишу F6 для активизации окна с TURBO.TPL.
     - Нажмите F2 для сохранения изменений в TURBO.TPL.
     - Нажмите Esc для выхода из TPUMOVER.


           Сокращения, употребляемые в командной строке.

     Вы можете  использовать несколько параметров командной строки,
которые позволяют Вам быстро  манипулировать  модулями.   Параметры
имеют следующий формат.

        TPUMOVER TURBO /параметр имя модуля

     где параметром является или +, или -, или *.
     Эти команды выполняют  следующие  функции  без  отображения  в
окнах:
     /+ добавляет названный модуль в TURBO.TPL
     /- Удаляет названный модуль из TURBO.TPL
     /* Извлекает   (копирует)  названный  модуль  из  TURBO.TPL  и
сохраняет его в файле с именем "имя модуля .TPU".
     /? Отображает окно подсказки.


                     Автономная утилита Make.

     Этот раздел   содержит   полную   документацию   по   созданию
конфигурационных файлов и использованию программы Make.


                 Создание конфигурационных файлов.

     Конфигурационный  файл   содержит    определения    и    связи
необходимые для программы  Make  с целью поддержания Ваших программ
в актуальном состоянии.  Вы можете  создавать  сколь  угодно  много
конфигурационных файлов  с  любыми  именами.  Если  Вы  не зададите
конфигурационный файл при запуске программы Make (используя опцию -
f),  то  в этом случае Make будет искать файл с именем по умолчанию
Makefile.
     Вы можете создавать конфигурационный  файл  с  помощью  любого
текстового редактора, например, встроенного редактора Турбо-Паскаля.
Все определения   и   директивы   заканчиваются  символом  возврата
каретки,  если строка слишком длинна, то Вы можете ее продолжить на
следующей строке,  поместив обратную наклонную черту (\) в качестве
последнего символа строки.
     Пробелы и знаки табуляции используются для  отделения  смежных
идентификаторов и соблюдения синтаксических правил в командах.
     Создание конфигурационного    файла   во   многом   напоминает
написание программы - с  определениями,  командами  и  директивами.
Ниже приводится список конструкций,  разрешенных в конфигурационном
файле.

     - комментарии.
     - явные  правила.
     - неявные правила.
     - макроопределения.
     - директивы: включение файла, условное выполнение, обнаружение
       ошибок, аннулирование макроопределения.

     Давайте рассмотрим  более детально каждую из этих конструкций.

                           Комментарии.

     Комментарии начинаются с символа (#),  все что следует за этим
символом до конца строки программой Make игнорируется.  Комментарии
могут помещаться  в  любом  месте.  Обратная  наклонная  черта   не
продолжает комментарий на следующую строку,  вместо этого Вы должны
использовать символ (#) на каждой строке.  Обратную наклонную черту
нельзя  использовать  в качестве символа продолжения комментария по
той причине, что если черта предшествует символу #, она не является
последним символом в строке,  если же она стоит после знака #,  она
является частью самого комментария.
     Ниже приводится  ряд  примеров комментариев в конфигурационном
файле.

     # makefile fo GETSTA .
     # does compile project maintenance
     # implicit rule
     .asm.obj: #.OBJ файлы зависят от входных ASM файлов
       tasm $*.asm,$*.obj:               # команда для их создания
     # unconditional rule
     getstars.exe:                    всегда создается GETSTARS.EXE
       tpc getstars /m
     # dependencies
     slib2.obj: slib2.asm               # команда для его создания.
                  # Используется приведенное выше неявное правило
     slib1.obj: slib1.asm          # приведение в соответствие как
                                               в явном правиле
       tasm slib1.asm,slib1.obj:
     # end of makefile


                          Явные правила.

     Явные правила принимают форму:

         target [target ... ]: [source source ... ]
            [command]
            [command]
            ...
     где target - файл,  который подлежит модифицированию, source -
файл  от  которого  зависит  target,  а  command - любая допустимая
команда MS-DOS (включая запуск .BAT файлов и выполнение .COM и .EXE
файлов).
     Явные правила определяют один или более  результирующих  имен,
отсуствие или наличие нескольких исходных файлов,  и необязательный
список команд,   подлежащих  выполнению.  Имена  результирующего  и
исходного файлов,  перечисленных в явных правилах,  могут содержать
имя   устройства  и  спецификации  справочника,  но  они  не  могут
содержать шаблоны имен файлов (например *.OBJ).
     Синтаксис команды является  важным  элементом,   результирущий
файл должен начинаться  с  начала  строки  (колонка  1),  и  каждая
команда  должна  быть отделена по крайней мере,  одним пробелом или
знаком табуляции.  Как уже упоминалось  ранее,  обратная  наклонная
черта  может  использоваться  в  качестве  символа продолжения если
список исходных файлов или команд  не  умещается  в  одной  строке.
И, наконец,  как  исходные  файлы,  так  и  команды   не   являются
обязательными  параметрами,  возможно существование явного правила,
содержащего  только  результирующий  файл   target   [target..]   с
последующим символом двоеточия(:).
     Идея применения   явного   правила   состоит   в   том,    что
перечисленные    команды   будут   создавать   или   модифицировать
результирующий файл target,  обычно используя  для  этого  исходные
файлы.  Когда программа Make обнаруживает явное правило,  то прежде
всего она проверяет наличие результирующего и исходных файлов. Если
результирующий  файл  существует,  то  его  время  и  дата пследней
модификации сравниваются  с  временем  и  датой  каждого  исходного
файла.  Если  любой из исходных файлов модифицирован после создания
результирующего файла,  список команд выполняется.  В  задании  для
программы  MAKE  имя  файла  в  левой  части  явного правила должно
встречаться не более одного раза.
     Каждая командная  строка  в  явном правиле должна начинаться с
раделителя (пробела).  Make рассматривает все строки  после  явного
правила как   часть списка команд вплоть до строки,  начинающейся с
колонки 1 (без предшествующих разделителей) и до конца файла.
     Пустые строки игнорируются.
     Явное правило,  не  содержащее  после  себя  командные  строки
трактуется несколько иначе, нежели правило с командными строками.
     - Если явное правило для результирующего файла  имеет команды,
то  формирование  этого  результирующего  файла  зависит  только от
перечисленных в правиле файлов.
     - Если  явное правило не содержит команд,  результирующий файл
зависит от файлов заданных в явном правиле,  и он также зависит  от
любого   файла   соответствующего   неявному  правилу  для  данного
результирующего файла.
     Ниже представлен   конфигурационный   файл  с  примером  явных
правил:

         myutil.obj: myutil.asm
           tasm myutil.asm,myutil.obj;

         myapp.exe:  myapp.pas myglobal.tpu myitils.tpu
           tpc myapp /Tc:\tp5\bin

         myglobal.tpu: myglobal.pas
           tpc myglobal /Tc:\tp5\bin

         myutils.tpu: myutils.pas myglobal.tpu myutil.obj
           tpc myutils /Tc:\tp5\bin

     - Первое явное правило означает,  что  MYUTIL.OBJ  зависит  от
MYUTIL.ASM, и что MYUTIL.OBJ создается выполнением заданной команды
TASM. (опция /Т плюс имя пути во всех этих примерах будет об'яснена
позже).
     - Второе правило означает, что MYAPP.EXE зависит от MYAPP.PAS,
MYGLOBAL.TPU и MYUTIL.OBJ, и создается заданной командой TPC.
     - Если Вы измените порядок следования  правил  таким  образом,
что правило   для формирования MYAPP.EXE будет стоять первым,  Make
перекомпилирует ( или переассемблирует)  только необходимые  файлы.
Это произойдет потому, что Make без заданного результирующего файла
в командной строке будет пытаться выполнить первое  явное  правило,
которое будет обнаружено в конфигурационном файле.
     - На  практике,  Вам  следует  опускать  два  последних  явных
правила  и  просто добавлять директиву /М в команду в явном правиле
для MYAPP.EXE.  Однако  Вам  необходимо  добавить  все  зависимости
исходных файлов из MYGLOBAL.TPU и MYUTOL.TPU.


                         Неявные правила.

     Make также позволяет Вам определять неявные  правила,  которые
являются   обобщением   явных   правил.   Ниже   приводится  пример
иллюстрирующий  зависимость  между  этими  двумя   типами   правил.
Рассмотрим явное правило из программы в предыдущем примере.

         myutil.obj:myutil.asm
           tasm myutil.asm.myutil.obj;

     Это правило является общим,  потому,  что  оно  придерживается
общего  принципа:  .OBJ  файл  зависит от .ASM файла с тем же самым
именем и создаетя выполнением  программы  TASM  (Турбо  Ассемблер).
Действительно,  Вы можете иметь конфигурационный файл с несколькими
(или даже несколькими  десятками)  явных  правил,  придерживающихся
этого формата.
     Для переопределения  явного   правила   неявным,   Вы   можете
сократить  все явные правила одинаковой формы.  В качестве неявного
правила, конструкция

         .asm.obj:
           tasm $*.asm, $*.obj;

     Это правило  означает,  что "любой файл оканчивающийся на .OBJ
зависит от файла с тем же именем,  с расширением .ASM,  и .OBJ файл
создается  с  использованием  команды tasm $*.ASM,  $*.obj,  где $*
представляет собой имя файла без расширения".  (символ $*  является
специальным   макроопределением   и   рассматриваются  в  следующем
разделе).
     Неявное правило имеет следующий синтаксис:

         .source_extension.target_extension:
           (command)
           (command)
           ...

     Заметьте, что  команды  не  являются  обязательными  и  должны
начинаться  не  с  начала  строки.  Source_extension  -  расширение
исходного  файла  (которое  должно  начинаться  с  первой  колонки)
представляет   собой   расширение   любого  файла  удовлетворяющего
формату:

         имя_файла.расширение_исходного файла

     Аналогично, target_extension    (расширение    результирующего
файла)      относится                    к                    файлу
"имя_файла.расширение_результирующего_файла", где       "имя_файла"
одинаковое для исходного и результирующего файлов. Другими словами,
это неявное правило заменяет все явные правила имеющие формат

         fname.target_extension:fname.source_extension
           (command) (command)
           ...

     для любого fname (имени файла).

     Неявные правила используются в том случае,  если  для  данного
результирующего  файла  не  найдено  явного  правила или если явное
правило для этого файла не имеет команд.
     Расширение файла  используется  для  определения  того,  каким
неявным правилом пользоваться.  Неявное правило применяется  в  том
случае,  если найден файл с тем же именем, что и результирующий, но
с упомянутым расширением исходного файла. Для примера, предположим,
что у Вас есть конфигурационный файл (с именем Makefile) содержание
которого следующее:

         .asm.obj:
           tasm $*.asm,$*.obj;

     Если у Вас есть подпрограмма  на  языке  ассемблера  с  именем
RATIO.ASM, которую Вы хотите откомпилировать в RATIO.OBJ, Вы должны
использовать команду

         make ratio.obj

     Программа Make будет считать RATIO.OBJ результирующим  файлом.
Поскольку для создания RATIO.OBJ явного правила нет, Make применяет
неявное правило и генерирует команду

         tasm ratio.asm,ratio.obj;

     которая конечно   использует   для  создания  RATIO.OBJ  Турбо
Ассемблера.
     Неявные правила также используются,  если задано явное правило
без команд. Предположим, в начале Вашего конфигурационного файла, о
котором упоминались ранее, имеется следующее неявное правило.

         .pas.tpu:
           tpc $<

     Тогда Вы  можете  переписать  последние  два   явных   правила
следущим образом:

         myglobal.tpu:   myglobal.pas   myutils.tpu:   myutils.pas
         myglobal.tpu myutil.obj

     Поскольку у Вас нет явной информации о том,  как создавать эти
.TPU файлы, Make применяет неявное правило, определенное ранее.
     Несколько неявных правил  могут  быть  написаны  с  одинаковым
расширением результирующего файла, но в определенный момент времени
применяется  только  одно  такое  правило.   Если   для   заданного
расширения  результирующего  файла существует более одного неявного
правила,  то каждое правило проверяется в том порядке,  как правила
располагаются в конфигурационном файле.
     Программа Make использует первое неявное правило, обнаруженное
для файла  с исходным расширением.  Даже если команды этого правила
не выполняются, проверка других неявных правил не производится.
     Все последующие  строки  неявного  правила рассматриваются как
часть списка команд,  вплоть  до  строки,  которая  начинается  без
разделителей  или  до  конца  файла.  Пустые  строки  игнорируются.
Синтаксис командной строки приводится далее в этом приложении.
     В отличие  от явных правил,  программа Make в случае  неявного
правила не знает полного имени файла.  По этой причине  Make  может
задавать  специальные макросы,  позволяющие Вам включать имя файла,
которое  строится  по  этому  правилу  (Детальная   информация   по
макроопределениям  приводится  в  этом  приложении).  Вот несколько
примеров неявных правил:

         .pas.exe:
           tpc $<

         .pas.tpu:
           tpc $<

         .asm.obj:
           tasm $* /mx;

     В предыдущем примере, в качестве результирующих файлов исполь-
зовались .EXE файлы,  а в качестве исходных - .PAS файлы.   В  этом
примере имеется   одна командная строка (синтаксис командной строки
рассматривается ниже в этом приложении).
     Второе неявное  правило  создает  .TPU  файлы  из .PAS файлов.
Последний  пример  указывает  программе  Make  на   ассемблирование
заданного файла из исходного .ASM файла,  используя Турбо Ассемблер
TASM с опцией /mx.


                          Списки команд.

     До сих пор Вы обсуждали явные и неявные правила,  и то как они
используют списки команд.  Теперь давайте рассмотрим сами команды и
опции для их установки.
     Команды в списке команд должны иметь отступ - т.е.  иметь  или
знаки  табуляции  или  предшествующие  пробелы  в  строке.  Команды
представляются в следующем формате:

         [префикс...] тело команды

     Каждая командая   строка   в   списке   команд   состоит    из
(необязательного) списка префиксов, с последующим телом команды.
     Префиксы, разрешенные в команде,   модифицируют  интерпретацию
команды программой  MAKE.  Префикс представляет собой знак (@)  или
(-), после чего следует число.
     @ Отменяет отображение команды перед выполнением.
     Отображения не происходит даже если не  задана  опция  -  S  в
командной  строке.  Действие этого префикса распространяется только
на команду в которой он имеется.

     - num устанавливает реакцию программы  MAKE  на  коды  выхода.
Если число (num) определено, MAKE прекратит обработку, только в том
случае,  если статус выхода будет превышать  заданное  значение.  В
этом  примере,  MAKE прекращает обработку только если статус выхода
больше 4-х:

         -4 myprog sample.x

     Если префикса - num не задано,  MAKE проверяет  статус  выхода
для команды.  Если статус не нулевой, MAKE останавливает выполнение
текущий результирующий файл.

     (-) Если задан дефис без числа, MAKE вообще не будет проверять
статус  выхода.  Независимо  от  кода  выхода,  работа  MAKE  будет
продолжена.

     Тело команды интерпретируется точно также,  если бы  Вы  ввели
строку для COMMAND.COM,  за исключением того, что не поддерживаются
переопределение устройств ввода/вывода и связь через  каналы.  MAKE
выполняет   следующие   встроенные   команды,   активизируя   копию
COMMAND.COM для их выполнения:

     BREAK       CD       CHDIR       CLS       COPY
     MD          MKDIR    PATH        PROMPT    REN
     RENAME      SET      TIME        TYPE      VER
     VERIFY      VOL

     MAKE осуществляет   поиск   любого   другого   имени  команды,
используя алгоритм поиска MS-DOS:

     - Сначала осуществляется поиск в текущем  справочнике,   после
чего выполняется поиск в справочнике указанных в пути.
     - В каждом справочнике сначала  проверяется  наличие  файла  с
расширением .COM, затем .EXE и наконец .BAT.
     - Если обнаружен .BAT файл,  активизируется копия  COMMAND.COM
для выполнения.

     Конечно, если  в командной строке задано расширение файла,  то
поиск файла осуществляется только  с  этим  расширением.  Следующая
команда  вызовет  выполнение  программой  COMMAND.COM команды смены
справочника

         cd  c:\include

     Эта команда будет осуществлять поиск для выполнения, используя
полный поисковый алгоритм:

         tpc  myprog.pas  /$B+, R+,I+

     Эта команда   будет   осуществлять   поиск   только  используя
расширение .COM:
         myprog.com  geo.xyz

     Эта команда   будет   выполняться   с   использованием  явного
определения имени файла и устройства.

         c:\myprogs\fil.exe -r

                             Макросы.

     Часто определенные   команды,   имена   файлов    или    опции
используются в конфигурационном файле несколько раз.  В приведенном
ранее примере этого приложения, все команды TPC использовали ключ /
TC:\tp5\bin,   что   означало,   что   файлы  TPC.CFG  и  TURBO.TPL
расположены  в  справочнике  C:\TP5\BIN.  Предположим,  Вы   хотите
подключить другой справочник, что для этого необходимо сделать?
     Вы можете изменить все опции /Т,  вставив необходимое имя пути
файла. Или Вы можете определить макрос (макроопределение). Макрос -
- это имя ,  которое определяет некоторую строку символов (букв или
цифр).  Макроопределение  задает имя макроса и текст расширения.  В
результате,  если программа  Make  обнаружит  имя,  соответствующее
макросу, она заменит это имя на макро-расширение.
     Предположим, Вы определили следующий  макрос  в  самом  начале
своего конфигурационного файла:

         TYRBO = C:\tp5\bin

     Вы определили макрос TURBO, который эквивалентен строке c:\tp\
bin. Теперь  Вы можете переписать конфигурационный  файл  следующим
образом:

         TURBO=c:\tp5\bin
         myapp.exe: myapp.pas mygobal.tpu myutils.tpu
           tpc myapp /T$(TURBO)

         myurils.tpu: myutil.pas myglobal.tpu myytil.obj
           tpc myutils /T$(TURBO)

         myglobal.tpu: myglobal.pas
           tpc myglobal; /T$(TURBO)

         myutil.obj: myutil.asm
           tasm myutil.asm,myutil.obj;

     Везде где  специфицирован  справочник  Turbo,  Вы  используете
вызов   макроса   $(TURBO).  Когда  Вы  запускаете  MAKE,  $(TURBO)
заменяется расширением с:\TP5.BIN.  В результате Вы имеете  тот  же
самый   набор   команд.   Так   в   чем   же   здесь  выигрыш?  Ваш
конфигурационный файл стал  более  гибким.  Изменив  теперь  первую
строку на

         TURBO = c:\tp5\project

     Вы измените все команды для использования конфигурационными  и
библиотечными файлами другого справочника.
     Если же Вы вынесете первую строку из конфигурационного файла и
будете вводить   ее вместе с вызовом программы MAKE,  используя при
этом опцию - D (определить),  Вы можете задавать каждый  раз  новый
справочник:

         make  -DTURBO=c:\tp5\project

     Это задает  программе  MAKE  режим  интерпретации  TURBO   как
макроса с расширением текста c:\tp5\project.
     Макроопределения имеют форму

         имя_макроса = расширение_текста.

     где "имя_макроса" - строка,  составленная из букв и  цифр  без
использования разделителей,  хотя Вы можете иметь разделители между
именем макроса и знаком равенства (=).  Расширение_текста  -  любая
произвольная строка,  содержащая буквы,  цифры, разделители и знаки
пунктуации, заканчивающаяся символом возврата каретки.
     Если имя    макроса    уже    было    определено,    то,   или
макроопределением  в  конфигурационном  файле,  или  опцией  -D   в
командной строке запуска программы MAKE,  новое определение заменит
старое. Использование  строчных  или  прописных  букв   в   макросе
является  существенным;  это  означает,  что  имена макросов turbo,
Turbo и TURBO будут считаться различными.
     Макрос в   конфигурационном   файле  активизируется  следующим
образом:

         $(имя макроса)

     Скобки являются обязательными,  даже если имя макроса  состоит
из  одного  символа,  исключая  шесть  специальных предопределенных
макросов о которых речь пойдет немного позднее. Эта конструкция - $
(имя макроса) - носит название макровызова.
     Когда Make обнаруживает  макровызов  она  заменяет  макрос  на
расширение.  Если  макрос  не определен,  Make заменяет его нулевой
строкой.

     Макросы в макросах:  Макросы не могут активизироваться в левой
части  (имя  макроса) макроопределения.  Они могут использоваться в
правой части (расширение текста), но они не расширяются до тех пор,
пока определенный макрос не будет активизирован.
     Другими словами,  когда макровызов расширяется, любые макросы,
имеющиеся в его расширении также расширяются.

     Макросы в правилах: Макросы в строках правила расширяются.

     Макросы в директивах: Макровызовы расширяются в директивах !if
и !elif. Если макрос активизированный в директивах !if или !elif не
определен, он расширяется до значения 0 (False - Ложно).

     Макросы в  командах:  Макровызовы  в  командах  расширяются во
время выполнения команды.

     Прграмма MAKE  имеет  несколько  специальных  предопределенных
встроенных макросов:  $d,  $*,  $<,  $:,  $., и $&. Первый является
проверочным макросом,  используемым в  условных  директивах  !if  и
!elif, другие являются макросами имени файла, используемого в явных
и неявных  правилах.  Различные  макросы   имен   файлов   работают
аналогичным образом,  расширяясь до некоторых вариаций полного пути
имени создаваемого файла. Кроме того, строки окружения операционной
системы SET автоматически загружаются в качестве макросов, а макрос
_MAKE_ определяется как 1 (единица).

     Макрос условного тестирования ($d).

     Этот макрос  расширяется  в  1,  если  заданное  имя   макроса
определено, и в 0, если не определено. Содержание расширения текста
макроса не имеет  значения.  Этот  специальный  макрос  расширяется
только в том случае,  если заданы директивы !if и !elif.  Например,
если Вы хотите изменить Ваш конфигурационный  файл  таким  образом,
чтобы  он  использовал  специфический справочник для Турбо Паскаля,
если он не задан,  Вы можете поместить следующие  строки  в  начале
своего конфигурационного файла:

         !if  !elif                 # Если TURBO не определен
         TURBO=c:\tp5\bin           # Определяем его на с:\tp5\bin
         !endif

     Если Вы активизируете MAKE в командной строке

         make -DTURBO=c:\tp5\project

     То TURBO будет определяться как c:\tp5\project. Однако, если Вы
активизируете только один MAKE:

         make

     то TURBO  будет  определен как c:\tp5\bin - это Ваш справочник
"по умолчанию".


     Макрос имени основного файла ($*).

     Этот макрос разрешается  в  командах  для  явного  и  неявного
правила.  Макрос расширяется до имени создаваемого файла,  исключая
всякое расширение:

         Имя файла  A:\P\TESTFILE.PAS
         $* расширяется до A:\P\TESTFILE

     Например, Вы   можете   модифицировать   явное   правило   для
MYAPP.EXE:

         myapp.exe:  myapp.pas myglobal.tpu myutils.tpu
           tpc $* /TS(TURBO)

     Когда команда в этом правиле выполняется, макрос $* заменяется
на имя результирующего файла (без расширения)  - MYAPP. Этот макрос
очень удобен для  неявных правил.  Например,  неявное  правило  для
TPC может  выглядеть следующим образом (допуская,  что макрос TURBO
уже определен или будет определен):

         .pas.exe:
           tpc $* /TS(TURBO)


     Макрос имени полного файла ($<).

     Макрос имени полного файла ($<)  также используется в командах
для явного и  неявного правила.  В явном правиле, $< расширяется до
полного имени результирующего файла (включая расширение),   подобно
следующему примеру:

         Имя файла A:\P\TESTFILE.PAS
         $<  расширяется до A:\P\TESTFILE.PAS

     Например, правило

         starlib.tpu: starlib.pas
           copy $< \oldtpus
           tpc $* /TS(TURBO)

     будет копировать   STARLIB.TPU  в  справочник  \OLDTPUS  перед
компиляцией STARLIB.PAS.
     В неявном  правиле,  $< принимает значение  имени  файла  плюс
расширение исходного файла. Например, предыдущее неявное правило

         .asm.obj:
           tasm $*.asm,$*.obj;

     может быть переделано в

         .asm.obj:
           tasm $<,$*.obj;


     Макрос имени пути файла ($:).

     Этот макрос  расширяется  до  имени  пути  (без  имени файла),
например:

         имя файла  A:\P\TESTFILE.PAS
          $. расширяется до A:\P\


     Макрос имени файла и расширения ($.)

     Этот макрос  расширяется  до  имени   файла   с   расширением,
например:

         имя файла  A:\P\TESTFILE.PAS
          $. расширяется до TESTFILE.PAS


     Макрос имени файла ($&).

     Этот макрос расширяется только до имени файла,  без  пути  или
расширения, например:

         имя файла  A:\P\TESTFILE.PAS
          $& расширяется до TESRFILE


                            Директивы.

     Версия программы MAKE, поставляемая с Турбо Паскалем позволяет
делать  то,  что  не  могут другие версии MAKE - применять условные
директивы,  подобно  директивам  в   Турбо   Паскале.   Вы   можете
использовать  эти директивы для подключения других конфигурационных
файлов, создания правил и команд для выдачи сообщений об ошибках, и
отмены макроопределений.
     Директивы в    конфигурационном     файле     начинаются     с
восклицательного знака (!).  Ниже приводится полный список директив
программы MAKE.

         !include
         !if
         !else
         !elif
         !endif
         !error
         !undef

     Директива включения файла (!include) определяет  файл, который
будет   подключаться   в   конфигурационный  файл  для  последующей
интерпретации. Директива имеет следующий вид:

         !include "имя файла"
     или
         !include <имя файла>

     Эти директивы  могут  вкладываться  до  произвольной   глубины
вложенности.  Если  директива подключения пытается подключить файл,
который  уже  находится  в  более   верхнем   уровне   вложенности,
(зацикливание   вложенности),   внутренняя   директива  подключения
отвергается как ошибочная.
     Как использовать эту директиву?  Предположим Вы  создали  файл
PATH.MAC таким образом, что он содержит следующее:

         !if  !$d(TURBO)
         TURBO=c:\tp5\bin
         !endif

     То в  этом  случае  Вы  можете   использовать   это   условное
макроопределение в любом конфигурационном файле, применяя директиву

         !include  "PATH.MAC"

     Когда программа  MAKE  обнаруживает  директиву  !include,  она
открывает указанный файл и считывает содержимое,  как будто бы этот
файл является частью конфигурационного файла.
     Условные директива (!if,  !elif, !else, и !endif) представляют
программисту  определенную  степень  гибкости  при  конструировании
конфигурационных файлов.  Правила и макросы могут в зависимости  от
условий    интерпретировать   макроопределения   командной   строки
(используя опцию - D) таким  образом,  что  будет  разрешаться  или
запрещаться отдельные команды конфигурационного файла.
     Формат этих  директив  анологичен  формату  условных  директив
Турбо Паскаля, но является более расширенным:

         !if   выражение
               [строки]
         !endif

         !if   выражение
               [строки]
         !else
               [строки]
         !endif
         !if   выражение
               [строки]
         !elif выражение
               [строки]
         !endif

     Заметьте: [строки] могут быть следующими:
               макроопределение
               явное правило
               неявное правило
               директива подключения
               группа if
               директива ошибки
               директива отмены определения.

     Условные директивы  формируют группу,  включающую,  по крайней
мере,  директиву  !if  начинающую  группу   и   директиву   !endif,
заканчивающую группу.
     - В состав группы может быть включена одна директива !else.
     - Директивы !elif могут находиться  между  директивами  !if  и
!else.
     - Правила,  макросы, и другие директивы могут находиться между
различными условными директивами в любом количестве.  Заметьте, что
полные правила,  со своими командами,  не могут расщепляться  между
условными директивами.
     - Группы   условных   директив   могут   быть   вложенными  до
произвольной глубины.

     Любые правила,  команды,  и директивы должны  быть  полными  в
границах отдельного исходного файла.
     Любые директивы !if  должны  иметь  соответствующие  директивы
!endif  в  границах  того  же  исходного  файла.  Поэтому следующий
подключаемый файл является некорректным, независимо от того, что он
содержит,  потому что он не имеет соответствующей директивы !endif.

         !if $(FILE_COUNT)  > 5
         некоторые правила
         !else
         другие пррравила
         <end-of-file>

     Выражение, допустимое в директиве !if или !elif использует тот
же  синтаксис,  что  используется  в  языке  программирования   Си.
Выражение  подсчитывается  как простое 32-х битовое целое выражение
со знаком.
     Числа могут    вводится    десятичными,    восьмиричными   или
шестнадцатиричными  константами.  Например   является   допустимыми
следующие константы в выражении.

         4536        # десятичная константа
         0677        # восьмиричная константа (заметьте, что она
                       задается ведущим нулем).
         $23AF       # шестнадцатиричная константа.

     также допустимы следующие унарные операторы:

         - отрицание.
         ~ битовое дополнение.
         ! логическое Не.

     В выражении  могут  использоваться любые из следующих бинарных
операторов:

         + сложение
         - вычитание
         * умножение
         / деление
         % вычисление остатка
         >> сдвиг вправо
         << сдвиг влево
         &  битовое и
         |  битовое или
         ^  логическое исключающие или
         && логическое и
         || логическое или
         >  больше
         <  меньше
         >= больше или равно
         <= меньше или равно
         == равенство
         != неравенство

     Выражение может  содержать  следующий  тернарный (состоящий из
трех частей) оператор:

         ?:         Операнд перед знаком ? трактуется в качестве
                    проверочного.

     Если значение  этого   операнда   отличается   от   нуля,   то
результатом  является второй операнд (часть между ?  и двоеточием).
Если значение первого  операнда  равно  нулю,  результат  принимает
значение третьего операнда (часть после двоеточия).
     Для группировки  операндов  в  группу   могут   использоваться
скобки. В случае отсуствия скобок бинарные операторы группируются в
вычислении согласно порядка вычисления принятого в языке Си.
     Группировка операндов   одинакового   приоритета  производится
слева  направо,  за  исключением  тернарного   оператора,   который
группируется справа налево.
     Макросы могут активизироваться в выражении,  причем, считается
допустимым   использование   специального   макроса   $d().   После
расширения  всех  макросов  выражение  должно  быть   синтаксически
правильным.  Любые  слова  в расширяемом выражении трактуются,  как
ошибки.
     Директива сообщения  об  ошибке  (!error)   вызывает остановку
программы MAKE и печать фатальной  диагностики,   содержащий  текст
после директивы !error. Формат директивы следующий.

         !error  "любой текст"

     Эта директива предназначена для включения в условные директивы
для предоставления  возможности  условного  выхода,   определяемого
пользователем. Например,  Вы можете вставить следующий исходный код
впереди первого явного правила.

         !if  !$d(TURBO)
         # если TURBO не определен.
         !error TURBO не определен.
         !endif

     Если Вы   достигнете  этого  места  без  определенного  TURBO,
программа MAKE остановится с выдачей сообщения об ошибке:

         Fatal makefile 5: Error directive: TURBO не определен

     Директива отмены  макроопределения  (!undef)  вызывает  отмену
любого   определения  для  именованного  макроса.  Если  макрос  не
определен, директива не имеет никакого эффекта. Синтаксис директивы
следующий: !undef имя макроса.


                   Использование программы Make.

     Теперь Вы   достаточно   знаете   о   том,    как    создавать
конфигурационные   файлы,   теперь  самое  время,  узнать,  как  их
использовать  вместе  с  программой  MAKE.  Самый  простой   способ
использования MAKE состоит в простом наборе команды

         make

     в командной   строке   MS-DOS.   После  этого  программа  MAKE
просматривает  наличие  конфигурационного  файла   MAKEFILE,   если
программа  не  может его найти,  то она просматривает наличие файла
MAKEFILE.MAK,  если и он отсуствует,  программа  останавливается  с
выдачей сообщения об ошибке.
     Что делать,  если  Вы  хотите  использовать  файл  с   именем,
отличным  от MAKEFILE или MAKEFILE.MAK?  Вам необходимо указать для
программы MAKE опцию (-f), задающую имя файла:

         make - f stars.mak

     Оющий синтаксис использования программы MAKE следующий:

      make опция опция ... результирующий файл результирующий файл

     где опция - опция программы  MAKE  (рассматривается  ниже),  и
результирующий   файл   -   имя   результирующего   файла,  который
формируется явным правилом.

     Ниже приводятся синтаксические правила:

     - Если приводится  список  опций,  то  слово  MAKE  отделяется
пробелом.
     - Каждая  опция  make  должна  отделяться  от  смежных   опций
пробелом.  Опции  могут  располагаться  в  любом  порядке и в любом
количестве (пока есть место в командной строке).
     - После   списка   опций   должен   следовать   пробел,  затем
необязательный список результирующих файлов.
     - Каждый  результирующий файл также должен отделяться пробелом
от других  результирующих  файлов.  MAKE  формирует  результирующие
файлы    в    порядке    поступления,    составные   части   файлов
перекомпилируются.

     Если командная строка не содержит никаких  имен результирующих
файлов,  программа  MAKE  использует  первый  результирующий  файл,
упоминающийся  в  явном  правиле.  Если  один  или   более   файлов
упоминается в командной строке, они переформируются.
     Ниже приводится  несколько  примеров   командных   строк   для
программы MAKE.

         make -n -fstars.mak
         make -s
         make -Iinclude -DTURBO=c\tp5\project

     Если любая    исполняемая   команда   снимается   при   помощи
Ctrl-Break,  то  MAKE  останавливается.  Поэтому  Ctrl-Break   (или
Ctrl-C)  останавливает  как  текущую  исполняемую  команду,  так  и
программу MAKE.


                        Файл BUILTINS.MAK.

     При использовании программы MAKE,  часто возникает потребность
многократного использования макросов и правил (обычно неявных). Для
этого у Вас есть три возможности. Во-первых, Вы можете поместить их
в каждый создаваемый  Вами  конфигурационный  файл.  Во-вторых,  Вы
можете  поместить  их  все  в  один  файл  и использовать директиву
подключения !include в каждом из создаваемых  Вами конфигурационных
файлов.
     В третьих,    Вы   можете   поместить   их  в  файл  с  именем
BUILTINS.MAK.
     Всякий раз,  когда   Вы   запускаете   программу   MAKE,   она
просматривает файл с именем BUILTINS.MAK,  и если он обнаружен,  то
MAKE считывает  его  перед  обращением  к  файлу  MAKEFILE  (или  к
выбранному Вами конфигурационному файлу).
     Файл BUILTINS.MAK  предназначается  для  использования   любых
правил (обычно неявных правил)  или макросов, которые в большинстве
случаев будут Вами использоваться.
     Специального требования,  чтобы  существовал файл BUILTINS.MAK
не  существует.  Если  MAKE   обнаружит   файл   BUILTINS.MAK,   он
обрабатывает   этот  файл  первым.  Если  MAKE  не  обнаружит  файл
BUILTINS.MAK,  он  переходит  непосредственно  к  обработке   файла
MAKEFILE (или заданного Вами конфигурационного файла).


                Как Make осуществляет поиск файлов.

     MAKE будет  искать файл BUILTINS.MAK в текущем справочнике или
в справочнике откуда  запускается  система  (если  Вы  работаете  в
MS-DOS 3.X).  Вам следует поместить этот файл в том же справочнике,
где находится файл MAKE.EXE.
     Программа MAKE  всегда  осуществляет  поиск  конфигурационного
файла  только  в  текущем  справочнике.  Этот файл содержит правила
создания выполнимых файлов.
     MAKE также  осуществляет  поиск  в  текущем  справочнике любых
подключаемых  файлов  по  !include.  Если  Вы   используете   опцию
подключения - I, поиск также выполняется в указанном справочнике.


              Опции командной строки программы Make.

     Мы уже  упоминали  несколько  опций командной строки программы
MAKE, теперь мы представляем полный их перечень.
     Заметьте, что   вид   (строчная   или   прописная)    является
существенным, опция -d не служит заменой для -D.

     - D идентификатор.  - Определяет именованный идентификатор для
строки, состоящей из одиночного символа 1.
     - D   идент=строка.  -  Определяет  именованный  идентификатор
"идент" для  "строки"  после  знака  равенства.  Строка  не  должна
содержать пробелы или знаки табуляции.
     - I  directory.   - MAKE будет осуществлять поиск подключаемых
файлов в указанном справочнике (directory)  (также как и в  текущем
справочнике).
     - U   идентификатор.   -   Отменяет   предыдущие   определения
идентификатора.
     - S.  -  Обычно,  MAKE  выдает  на  экран  каждую  выполняемую
команду,  при использовании опции - S выдача  команд  на  экран  не
производится.
     - n.  - Вызывает выдачу команд,  без их выполнения.  Это очень
полезно при отладке конфигурационного файла.
     - f  имя  файла.   -   Использует   имя   файла   в   качестве
конфигурационного.  Если  данного  файла  не существует и не задано
расширение,  то будет осуществляться поиск файла с именем указанным
в опции с расширением .MAK.
     - ?  или - h. - Производится выдача подсказки по использованию
опций.

               Сообщения об ошибках программы MAKE.

     Все диагностические  сообщения  программы MAKE можно разделить
на 2 вида:  фатальные ошибки и  просто  ошибки.  При  возникновении
фатальной  ошибки  выполнение программы немедленно прерывается.  Вы
должны  предпринять  надлежащие  действия  и  повторить  выполнение
программы.  Ошибки  (просто  ошибки)  указывают на синтаксические и
семантические ошибки в конфигурационном файле. Программа MAKE будет
продолжать  интерпретацию конфигурационного файла и закончит работу
после обработки всех строк файла.

     Фатальные ошибки.

         Don't know how to make XXXXXXXX
         Неизвестно, как создавать ХХХХХХХХ

     Это сообщение выдается,  когда MAKE  обнаружит  несуществующее
имя файла в последовательности построения, и не существует правила,
позволяющего построить этот файл.

         Error directive: XXXX
         Ошибочная директива: ХХХХ

     Это сообщение  выдается,  когда  программа  MAKE  обрабатывает
директиву  сообщения  об  ошибке в исходном файле.  Текст директивы
отображается в сообщении.

         Incorrect command line argument: XXX
         Некорректный аргумент ХХХ командной строки.

     Эта ошибка   возникает  в  случае,  если  MAKE  выполняется  с
некорректными аргументами командной строки.

         Not enough memory.
         Недостаточно памяти.

     Эта ошибка   возникает,  когда  происходит  исчерпание  общего
запаса  оперативной  памяти.  Вам   следует   попытаться   провести
компиляцию  на  компьютере с большим об'емом памяти.  Если же у Вас
используется  компьютер  с  об'емом  памяти  в  640К,  Вам  следует
упростить свой исходный файл.

         Unable to execute command
         Невозможно выполнить команду.

     Это сообщение выдается после попытки выполнения  команды.  Это
может  произойти  в  результате  неудачи в обнаружении исполняемого
файла,  или  нарушения  синтаксиса  команды.  Гораздо  реже   может
возникнуть ситуация,  что исполняемый файл существует,  но каким-то
образом запорчен.

         Unable to open makefile
         Невозможно открыть конфигурационный файл.

     Это сообщение выдается,  когда текущий справочник не  содержит
конфигурационный файл с именем MAKEFILE.

     Ошибки.

         Bad file name format in include statement
         Плохой формат имени файла в операторе подключения

     Имена подключаемых  файлов  должны  заключаться  в кавычки или
фигурные скобки.

         Bad undef statement syntax
         Плохой синтаксис оператора отмены макроопределения.

     Утверждение !Undef должно содержать одиночный идентификатор  и
ничего более.

         Character constant too long
         Символьная константа слишком длинна.

     Символьные константы  могут быть длиной только  один  или  два
символа.

         Command arguments toо long.
         Слишком длинный перечень аргументов командной строки.

     Аргументы, присуствующие в команде выполняемой программой MAKE
не должны превышать общую длину  командной  строки  более  чем  127
символов - ограничение, накладываемое операционной системой MS-DOS.

         Сommand syntax error
         Синтаксическая ошибка в команде.

     Эта ошибка возникает в случае, если:
     - Первая  строка  правила  в  конфигурационном  файле содержит
ведущие пробелы.
     - Неявное правило не содержит расширений файлов.
     - Явное  правило  не  содержит  имени перед символом двоеточия
(:).
     - Макроопределение   не   содержит   имени   перед    символом
равенства(=).

         Division by zero.
         Деление на ноль.

     Операция деления  или получения остатка в утверждении !if имет
нулевой делитель.

         Expression syntax error in !if statemant
         Синтаксическая ошибка выражения в утверждении !if.

     Плохо составлено  выражение  в  утверждении  !if  -   содержит
несоответствующее   количество   скобок,  излишнее  количество  или
пропущенные операторы, константы.

         File name too long
         Слишком длинное имя файла.

     Имя файла заданное в директиве !include слишком длинное.
     Общая длина  имени пути файла в MS-DOS должна быть не более 78
символов.

         Illegal chracter in constants expression X
         Недействительный символ Х в константом выражении.

     Программе MAKE  встретился  некоторый  символ,  запрещенный  в
константном  выражении.  Если  этот символ является буквой,  то это
(вероятно)   означает   синтаксическую   ошибку    в    обозначении
идентификатора.

         Illegal octal digit
         Недействительная восьмиричная цифра.

     Восьмиричная константа содержит цифру 8 или 9.

         Macro expansion too long
         Макрорасширение слишком длинное.

     Макрос не может расширяться более чем на 4096  символов.   Эта
ошибка часто встречается в случае, если макрос рекурсивно расширяет
сам себя, что некорректно.

         misplaced elif statment
         Неправильное использование утверждения elif.

     Встретившаяся директива   !elif   не   имеет   соответствующей
директивы !if.

         No file name ending
         Нет окончания имени файла.

     Имя файла  в   утверждении   include   не   имеет   корректной
закрывающей кавычки или фигурной скобки.

         Redefinition of target XXXXXXXX
         Повторное определение результирующего файла ХХХХХХХХ.

     Имя результирующего  файла встречается в более чем одном явном
правиле.

         Unable to open include file XXXXXXXX.XXX
         Невозможно открыть подключаемый файл ХХХХХХХХ.ХХХ

     Файл не обнаружен.  Это может возникнуть также  в  результате,
если   подключаемый   файл   подключает   самого  себя.  Проверьте,
существует ли файл на самом деле.

         Unexpected end of file in conditional started on line #
         Неожиданный конец файла в условном предложении на строке N

     Исходный файл заканчивается,  до обнаружения  программой  MAKE
утверждения !endif, которое или пропущено, или имеет синтаксическую
ошибку.

         Unknown preprocessor statment
         Неизвестное препроцессорное утверждение

     Встретившийся в  начале строки символ (!)  не имеет после себя
утверждения, соответствующего  error,  undef,  if,  elif,  include,
else, или endif.


                          Утилита TOUCH.

     В некоторых   случаях   у  Вас  может  возникнуть  потребность
перекомпилировать,  или заново построить  отдельный  результирующий
файл,  хотя  с  исходными файлами никаких изменений не проводилось.
Одним из способов реализации этого,  является использование утилиты
TOUCH,  поставляемой с Турбо-Паскалем.  TOUCH изменяет дату и время
одного или более файлов на текущие,  делая их таким образом,  более
"новыми", чем файлы, которые от них зависят.
     Для осуществления   перепостроения    результирующего    файла
"затроньте" один или более файлов от которых зависит результирующий
файл. Для этого введите:

         touch имя файла [имя файла...]

     в командной  строке  MS-DOS.   TOUCH   обновит   дату   (даты)
формирования файлов.
     Проделав это, Вы можете теперь активизировать команду MAKE для
перепостроения затронутых результирующих файлов.  (Используя  TOUCH
Вы можете   употреблять символы * и ?  для указания имени файлов по
шаблону поиска).


                           Утилита GREP.

     GREP -   это   мощная   поисковая   утилита,   которая   может
осуществлять  просмотр  текста  в  нескольких  файлах одновременно.
Например,  если Вы забыли в какой  программе  определена  процедура
SetUpModem,  Вы  можете  использовать  программу GREP для просмотра
содержимого всех .PAS файлов в Вашем справочнике на  наличие строки
SetUPMyModem.
     Синтаксис командной строки для программы GREP следующий:

         GREP [опции] поисковая строка [спецификация файла...]

     где опции - состоят из одного или более одиночных  символов  с
дефисом впереди,  "поисковая строка" определяет шаблон для поиска и
"спецификация  файла"  -  путь  и  имя  файла.  Спецификация  файла
информирует GREP о файлах (или группах файлов) подлежащих просмотру
это может быть  явное  задание  имени  или  использование  символов
поиска по шаблону (? и *).
     Указание пути  файла  не  является   обязательным.   Если   Вы
используете  спецификацию  файла без указания пути,  программа GREP
делает просмотр только в текущем справочнике.  Если Вы  не  укажете
спецификацию  файла,  ввод для программы GREP должен осуществляться
перенаправлением стандартного ввода или использованием канала.


                   Переключатели программы GREP.

     В командной строке,  опции представляют собой один  или  более
одиночных символов с дефисом (-) впереди. Каждый отдельный символ -
- это переключатель, который Вы можете включить или выключить: знак
(+) после символа включает опцию, а знак минус (-) выключает.
     Значение по умолчанию - включено (подразумевается +):   напри-
мер, -  R означает то же самое, что и -R+. Вы можете составить спи-
сок опций следующим образом:  (-I -P -L).  Или Вы можете об'единить
их: -ILD  или (-IL -D, и т.д.). Для программы GREP все это является
идентичным.

     Ниже приводится список переключателей и их значения:

     - С   Только   подсчет:  Выдается  только  подсчет  количества
соответствующих поисковых строк.  Для каждого файла, содержащего по
крайней  мере одну искомую строку,  GREP выдает имя файла и подсчет
количества соответсвующих строк. Сами строки не отображаются.

     - D Справочники:  Для каждой спецификации файла, приведенной в
командной   строке,   GREP   просматривает   все   файлы,   которые
соответствуют этой спецификации, как в указанном справочнике, так и
во всех подчиненных справочниках. Если Вы не указали в спецификации
файла пути,  GREP  предполагает,  что  файлы  находятся  в  текущем
справочнике.

     - I   Игнорировать  верхний/нижний  регистры:  Программа  GREP
игнорирует различия верхнего/нижнего регистров. GREP интерпретирует
все буквы от а до z, как идентичные соответствующим буквам A-Z.

     - L Выдать список соответствующих файлов:  Выдается только имя
каждого файла,  содержащего поисковую строку.  Как только программа
GREP  находит  соответствие,  она  выдает  имя  файла  и  сразу  же
переходит к просмотру следующго файла.

     - N Номера строк:  Каждая соответствующая  строка,   выводимая
программой GREP сопровождается предшествующим номером строки.

     - О   UNIX-подобный  формат  вывода:  Изменяет  формат  вывода
соответствующих строк для организации канала  связи  UNIX-подобного
формата.  Всем  строкам  на выходе предшествует имя файла,  который
содержит искомые строки.

     - R Поиск нормального выражения:  Текст  определенный  строкой
поиска интерпретируется как нормальное выражение,  вместо буквенной
строки.

     - U  Обновить  опции:  GREP  об'единяет  опции,   заданные   в
командной  строке с другими не указанными опциями (со значениями по
умолчанию) и записывает их в файл GREP.COM как  новые  значения  по
умолчанию.  (Другими словами,  программа GREP самоконфигурируется).
Эта опция позволяет Вам произвести установку опций по  умолчанию по
своему усмотрению.

     - V Несоответствие: Выводятся только не соответсвующие строки.
Не соответсвующими строками считаются только строки,  не содержащие
поисковой строки.

     - W  Поиск слова:  Искомый текст,  соответствующий нормальному
выражению   считается   соответствием   только   в   случае,   если
предшествующий  и последующий символы не являются частью слова.  По
умолчанию набор символов слова включает A-Z,  9-0  и  подчеркивание
(_).  Дополнительная форма этой опции позволяет Вам специфицировать
набор допустимых символов в слове. Эта форма имеет вид - W [набор],
где  "набор" - любой допустимый набор.  Если для определения набора
используются алфавитные символы,  набор автоматически определяется,
как  содержащий  значения  как верхнего так и нижнего регистров для
каждой буквы.  Если опция -W используется совместно с опцией -U, то
новый  набор  допустимых  символов сохраняется в качестве набора по
умолчанию.

     - Z  Дополнительная  информация:  GREP  выводит  имя   каждого
просматриваемого файла.  Каждая соответствующая строка предваряется
ее номером. Дается подсчет соответствующих строк для каждого файла,
даже если он равен нулю.

     Некоторые из  этих  опций  находятся  в  противоречии  друг  с
другом.  В этом случае необходимо придерживаться следующего порядка
в применении.

         -Z -L -C -N

     Каждое появление опции отвергает предыдущее определение:
     Состояние опций   отражает    установленный    Вами    порядок
использования.  В  любой  данный  момент времени каждая опция может
быть только включенной, или только выключенной.
     Вы можете установить предпочитаемые Вами значения по умолчанию
для каждой опции GREP.COM при помощи  опции  -U. Например, если  Вы
хотите,   чтобы   GREP   всегда   осуществляла   поиск   с  выдачей
дополнительной информации (опция -Z включена), Вы можете установить
этот режим с помощью следующей команды:

         GREP -U -Z


         Как осуществлять поиск с помощью программы GREP.

     Значение строки поиска определяет образец поиска для программы
GREP. Поисковая  строка может быть или нормальным выражением (через
переключатель -R) или буквенной строкой.
     В нормальных  выражениях  операторы рассматриваются как единое
целое, буквенные поисковые строки не содержат операторов.
     Вы можете   заключить   поисковую   строку   в   кавычки   для
предотвращения интерпретации пробелов и знаков табуляции в качестве
разделителей.  Поиск соответствия не должен пересекать границ строк
(каждое соответствие должно находится в пределах отдельной строки).

     Когда используется   переключатель   -R,   поисковая    строка
интерпретируется  как  нормальное  выражение  (в  противоположность
буквенному выражению), при этом следующие символы имеют специальные
значения:

     ^ Этот знак (символ вставки)  в начале выражения соответствует
началу строки.
     $ Знак доллара в конце выражения соответствует концу строки.
     . Точка соответствует любому символу.
     * Выражение  следующее  за  символом  звездочки  соответствует
нулевому или большему количеству  появлений  этого  выражения:  fo*
соответствует fo, foo и т.д., но не f.
     [] Строка, заключенная в скобки соответствует любому символу в
этой строке,  но не в другой.  Если первый символ в строке - символ
вставки,  выражение соответствует любому символу,  кроме символов в
самой строке. Например [xyz] соответствует x, y и z, в то время как
[^xyz] соответствует а и в,  но не х или у. Диапазон символов может
быть задан  двумя  символами,  отделенными дефисом (-).  Могут быть
комбинации  для  формирования  выражений,   вроде   [?a-bd-z]   для
соответствия символу ? и любой букве, кроме с.
     \ Символ  обратной наклонной черты,  сообщает программе GREP о
поиске последующего буквенного символа.
     Например, \. соответствует точке.
     Заметьте: Четыре  символа  (?,  +,  * и.) не имеют какого-либо
специального значения,  если они используются в  наборе.  Символ  ^
интерпретируется  специальным образом только в том случае,  если он
сразу же следует в начале набора (т.  е. сразу же после символа [).
     Любой обычный    символ,   не   упомянутый   в   этом   списке
соответствует самому  символу.  Конкатенация  нормальных  выражений
являтся нормальным выражением.

               Примеры использования программы GREP.

-------------------------------------------------------------------
     Следующие примеры  предполагают,  что опции по умолчанию имеют
положение - off (выключено).

         grep main (*.pas
         соответствует :  main()
                          mymain(
         Не соответствует : mymainfunс()
                            MAIN(i: integer);

         Просматривает :  *.pas  в текущем справочнике.
         Примечание :  По умолчанию, поиск зависит
                       от положения верхнего/нижнего регистра.
-------------------------------------------------------------------
         grep  -R[^a-z]main\*(*.pas
         Соответствует:    main(i: integer)
                           main(i,j: integer)

         Не соответствует: mymain()
                           MAIN(i: integer);
         Просматривает :  *.pas в текущем справочнике.
         Примечание :  Поскольку пробелы и знаки табуляции обычно
                       считаются разделителями в командной строке,
                       Вы должны заключить их в кавычки, если Вы
                       хотите включить их в качестве части нор-
                       мального выражения. В Вашем примере пробел
                       после слова main был заключен в кавычки, с
                       использованием символа обратной наклонной
                       черты. Вы также можете выполнить это, по-
                       местив пробел или целое нормальное выраже-
                       ние в двойные кавычки (").
-------------------------------------------------------------------
         grep -RI[a-c]:\\data\.fil*.pas*.inc
         Соответсевует:     A:\data.fil
                            C:\Data.Fil
                            B:\Data.Fil

         Несоответствует:   d:\data.fil
                            a:data.fil
                            writeln(*c:\\data.fil*);

         Просматривает:     *.pas и *.inc а текущем справочнике

         Примечание:        Если Вы хотите выполнить поиск символов
                            \ и . Вы должны заключить их в кавычки,
                            поместив впереди них символ обратной
                            наклонной черты.
-------------------------------------------------------------------
         grep -RI[^a-z] word[^a-z]*.doc
         Соответствует:     every new word must be on a new line
                            MY WORD!
                            word -- smallest unit of speech.
                            In the beginning there was the WORD, and
                            the WORD.

         Не соответствует:  Each file has at least 2000 words.
                            He misspells toward as towоrd.

         Просматривает:     *.doc  в текущем справочнике.

         Примечание:        Этот формат в основном применяется для по-
                            иска слов.
-------------------------------------------------------------------
         grep "search string with spaces" *.doc *.asm a:\work\
         myfile.*

         Соответствует:     This is a search string with spaces in it

         Не соответствует:  THIS IS A SEARCH STRING WITH SPACES
                            IN IT.

         Просматривает:     *.doc и *.asm в текущем справочнике, и
                            myfile.* в справочнике \work на
                            устройствe А:

         Примечание:        Этот пример того, как осуществлять поиск
                            строки  со вставленными пробелами.
-------------------------------------------------------------------
         grep -RD"[,.:?'\"]" $\*.doc

         Соответствует:     He said hi to me.
                            Where are you going?
                            Happening in anticipation of a unique
                            situation,
                            Examples include the following:
                            "Many men smoke, but fu man chu."

         Не соответствует:  He said "HI" to me
                            Where are you going? I'm headed to the
                            beach this

         Просматривает:     *.doc в корневом справочнике и во всех
                            подсправочниках на текущем устройстве.

         Примечание:        Игнорирует различия верхнего/нижнего
                            регистра и выдает имена всех файлов,
                            которые содержат по крайней мере одно
                            соответствие. В предыдущих примерах
                            показаны различные способы спецификации
                            ряда переключателей.


                          Утилита BINOBJ.

     Программа BINOBJ.EXE  предназначена для конвертирования любого
файла в .OBJ файл,  таким образом,  что он  может  компоноваться  в
программу Турбо Паскаля как "процедура". Это весьма полезно, если у
Вас имеется файл двоичных  даннных,  который  должен  находиться  в
сегменте  кода  или  если  размер  файла данных слишком большой для
формирования массива типированных  констант.  Например,  Вы  можете
использовать  BINOBJ  с  модулем  GRAPH для связывания графического
устройства или файлов печати с Вашим .EXE файлом.  В  этом  случае,
для  использования  Вашей  графической  программы,  Вам нужно иметь
только .EXE файл.  (см.  пример GRLINK.PAS на дистрибутивном  диске
N2).

         BINOBJ  принимает три параметра:
         BINOBJ  <источник[.BIN]> <место назначения [.OBJ]>
                 <общее имя>

     где источник - двоичный файл, подлежащий преобразованию, место
назначения - имя  формируемого  .OBJ  файла,  и  общее  имя  -  имя
процедуры, которая будет обьявлена в Вашей программе.
     В следующем примере,  процедура Showscreen принимает указатель
в качестве параметра и передает 4000 байтов данных в память экрана.
Файл MENU.DTA   содержит  образ  главного меню экрана (80*25*2=4000
байтов).
     Ниже приводится  простая  (без  проверок  на  ошибки)   версия
программы MYPROGRAM.PAS:

         program MyProg;

         procedure ShowScreen(var ScreenData : pointer;
         {Отображение полного экрана, без проверки на ошибки!}
         var
           ScreenSegment: word;

         begin
           if (Lo(LastMode) = 7) then                    ( Mono? )
             ScreenSegment := $B000
          else
            ScreenSegment := $B800;
         Move(ScreenData^,                        { По указателю }
                      Ptr(ScreenSegment,0)^    { В память экрана }
                      4000);                       ( 80 * 25 * 2 )
         end;

         var
           MenuP : pointer;
           MenuF : file;
         begin
           Assign(MenuF,'MENU.DTA'); {Открытие файла данных экрана}
           Reset(MenuF, 1);
           GetMem(MenuP, 4000);         { Размещение буфера в куче}
           BlokRead(MenuF, MenuP^,4000);     {Чтение данных экрана}
           Close(MenuF);
           ShowScreen(MenuP);                  {Отображение экрана}
         end.

     Файл данных экрана MENU.DTA открывается и считывается  в буфер
кучи.  Оба  файла  MYPROG.EXE  и  MENU.DTA  должены присуствовать в
момент выполнения программы.  Вы  можете  использовать  BINOBJ  для
пребразования   MENU.DTA  в  .OBJ  файл  (MENUDTA.OBJ)  и  сообщить
программе о необходимости связи этого файла с  процедурой MenuData.
Затем  Вы  можете  об'явить  внешней  процедуру  MenuData,  которая
фактически будет содержать экранные данные. Скомпоновав .OBJ файл с
помощью  директивы  компилятора  $L,  MenuData  будет  длинной 4000
байтов и  будет  содержать  данные  Вашего  экрана.  Прежде  всего,
вызовите BINOBJ для обработки MENU.DTA.

         binobj MENU.DTA MENUDTA MenuData

     Первый параметр  MENU.DTA  указывает  на  обычный  файл данных
экрана, второй - MENUDTA - это имя создаваемого .OBJ файла (т.к. не
указано расширение,  будет  добавлено  .OBJ).  Последней параметр -
MenuData - имя внешней процедуры,  которая будет об'явлена в  Вашей
программе.  Теперь,  поскольку  Вы  конвертировали  MENU.DTA в .OBJ
файл,  новая версия программы MYPROG.PAS будет выглядеть  следующим
образом:

         program MyProg;

         procedure ScowScreen(ScreenData : pointer);
         {Отображение полного экрана, без проверок на ошибки}
         var
           ScreenSegment: word;
         begin
           if (Lo(LastMode) = 7) then                     ( Mono? )
             ScreenSegment :=$B000
           else
             ScreenSegment :=$B800;
         Move(ScreenData^,                           {По умолчанию}
                        Ptr(ScreenSegment,0)^     {В память экрана}
                        4000);                      ( 80 * 25 * 2 )
       end;

       procedure MenuData; external;
       ($L MENUDTA.OBJ)
       begin
         ShowScreen(&MenuData);                {Отображение экрана}
       end.

     Заметьте, что процедура ShowScreen не изменилась,  и что адрес
Вашей процедуры передается с употреблением оператора @.
     Преимущество связывания  данных экрана с .EXE файлом очевидно.
Вам  нет  необходимости  осуществлять   какую-либо   поддержку   по
оперированию  с файлами для использования основной программы. Кроме
того,  у  Вас  есть  преимущество,  заключающееся   в   возможности
обращения к экрану по имени (MenuData). Недостатки:

     - Каждый  раз  при  модификации  файла  информации экрана,  Вы
должны заново преобразовывать ее в .OBJ  файл  и  перекомпилировать
программу MYPROG.
     - Вы  должны  иметь  отдельный .OBJ файл (и внешнюю процедуру)
для каждого экранного меню, которое Вы хотите отобразить.

     Программа BINOBJ  особенно  полезна при стабильности двоичного
файла.  Одна  из  простых  графических   программ   (находится   на
дистрибутивной   дискете   N2)  GRLINK.PAS  использует  BINOBJ  для
построения двух модулей, которые содержат драйвер и файлы печати.

